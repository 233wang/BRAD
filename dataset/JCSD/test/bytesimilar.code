public string get human presentable name ( ) { return human presentable name ; }
public command info get command ( string cmd name ) { if ( data source ! = null ) return get command map ( ) . get command ( get base type ( ) , cmd name , data source ) ; else return get command map ( ) . get command ( get base type ( ) , cmd name ) ; }
public command info [ ] get preferred command ( ) { if ( data source ! = null ) return get command map ( ) . get preferred command ( get base type ( ) , data source ) ; else return get command map ( ) . get preferred command ( get base type ( ) ) ; }
public string get name ( ) { return url . get file ( ) ; }
public boolean be empty ( ) { return parameter . be empty ( ) ; }
public int length ( ) { return name value pair . size ( ) ; }
@ override public string to string ( ) { try { j s o n stringer stringer = new j s o n stringer ( ) ; write to ( stringer ) ; return stringer . to string ( ) ; } catch ( j s o n exception e ) { return null ; } }
public static boolean size be empty ( final object object ) { if ( object == null ) { return true ; } else if ( object instanceof collection < ? > ) { return ( ( collection < ? > ) object ) . be empty ( ) ; } else if ( object instanceof iterable < ? > ) { return iterable utils . be empty ( ( iterable < ? > ) object ) ; } else if ( object instanceof map < ? , ? > ) { return ( ( map < ? , ? > ) object ) . be empty ( ) ; } else if ( object instanceof object [ ] ) { return ( ( object [ ] ) object ) . length == 0 ; } else if ( object instanceof iterator < ? > ) { return ( ( iterator < ? > ) object ) . have next ( ) == false ; } else if ( object instanceof enumeration < ? > ) { return ( ( enumeration < ? > ) object ) . have more element ( ) == false ; } else { try { return array . get length ( object ) == 0 ; } catch ( final illegal argument exception ex ) { throw new illegal argument exception ( `` unsupported object type : `` + object . get class ( ) . get name ( ) ) ; } } }
public void set thread context loader ( ) { if ( be context loader save ) { throw new build exception ( `` context loader have not be reset `` ) ; } if ( loader utils . be context loader available ( ) ) { save context loader = loader utils . get context class loader ( ) ; class loader loader = this ; if ( project ! = null & & `` only `` . equal ( project . get property ( `` build . sysclasspath `` ) ) ) { loader = this . get class ( ) . get class loader ( ) ; } loader utils . set context class loader ( loader ) ; be context loader save = true ; } }
protect final void fire timeout occur ( ) { enumeration e = observer . element ( ) ; while ( e . have more element ( ) ) { ( ( timeout observer ) e . next element ( ) ) . timeout occur ( this ) ; } }
public void set class name ( string class name ) { this . class name = class name ; }
public class loader get class loader ( ) { return class loader ; }
public ant type definition get definition ( string component name ) { check namespace ( component name ) ; return ant type table . get definition ( component name ) ; }
public void set message ( string message , int priority ) { this . message = message ; this . priority = priority ; }
public location get location ( ) { return location ; }
public hashtable get task definition ( ) { return component helper . get component helper ( this ) . get task definition ( ) ; }
public ant type definition get definition ( string component name ) { check namespace ( component name ) ; return ant type table . get definition ( component name ) ; }
public synchronize void add excludes ( string [ ] exclude ) { if ( excludes ! = null & & excludes . length > 0 ) { if ( this . exclude ! = null & & this . excludes . length > 0 ) { string [ ] tmp = new string [ excludes . length + this . excludes . length ] ; system . arraycopy ( this . excludes , 0 , tmp , 0 , this . excludes . length ) ; for ( int i = 0 ; i < excludes . length ; i++ ) { tmp [ this . excludes . length + i ] = normalize pattern ( excludes [ i ] ) ; } this . exclude = tmp ; } else { set excludes ( excludes ) ; } } }
public void set case sensitive ( final boolean be case sensitive parameter ) { this . be case sensitive = be case sensitive parameter ; }
public resource get resource ( string name ) { return new file resource ( d dir , name ) ; }
public int get status ( ) { return status ; }
public final reader chain ( final reader rdr ) { escape unicode new filter = new escape unicode ( rdr ) ; new filter . set initialized ( true ) ; return new filter ; }
public void set prepend ( final file prepend ) { this . prepend = prepend ; }
public void set begin token ( final char begin token ) { this . begin token = begin token ; }
public int read ( ) throw i o exception { if ( ! get initialized ( ) ) { initialize ( ) ; set initialize ( true ) ; } int ch = -1 ; if ( space remain > 0 ) { space remain -- ; ch = ' ' ; } else { ch = in . read ( ) ; if ( ch == '\t ' ) { space remain = tab length - 1 ; ch = ' ' ; } } return ch ; }
public reader chain ( final reader rdr ) { head filter new filter = new head filter ( rdr ) ; new filter . set line ( get line ( ) ) ; new filter . set skip ( get skip ( ) ) ; new filter . set initialized ( true ) ; return new filter ; }
public void set project ( final project project ) { this . project = project ; }
public string get current project name ( ) { return current project name ; }
public boolean be ignore project tag ( ) { return ignore project tag ; }
public object get reference object ( project fallback ) throw build exception { if ( refid == null ) { throw new build exception ( `` no reference specify `` ) ; } object o = project == null ? fallback . get reference ( refid ) : project . get reference ( refid ) ; if ( o == null ) { throw new build exception ( `` reference `` + refid + `` not find . `` ) ; } return o ; }
protect static void set main handler ( ant handler handler ) { main handler = handler ; }
public void set default value ( string d ) { default value = d ; }
public boolean get curly brace denote code block ( int language index ) { return true ; }
public boolean be container ( ) { return task container . class . be assignable from ( bean ) ; }
/ * protect * / stream pumper create input pump ( input stream be , output stream o , boolean close when exhaust ) { stream pumper pumper = new stream pumper ( be , os , close when exhaust ) ; pumper . set autoflush ( true ) ; return pumper ; }
protect final project get project ( ) { return project ; }
public synchronize void add filter ( string token , string value ) { if ( be reference ( ) ) { throw no child allow ( ) ; } add filter ( new filter ( token , value ) ) ; }
public project create sub project ( ) { project sub project = null ; try { sub project = ( project ) ( get class ( ) . new instance ( ) ) ; } catch ( exception e ) { sub project = new project ( ) ; } init sub project ( sub project ) ; return sub project ; }
public void set keep go mode ( boolean keep go mode ) { this . keep go mode = keep go mode ; }
public void add data type definition ( string type name , class type class ) { component helper . get component helper ( this ) . add data type definition ( type name , type class ) ; }
public object create data type ( string type name ) throw build exception { return component helper . get component helper ( this ) . create data type ( type name ) ; }
public void fire sub build finish ( throwable exception ) { build event event = new build event ( this ) ; event . set exception ( exception ) ; iterator iter = listener . iterator ( ) ; while ( iter . have next ( ) ) { object listener = iter . next ( ) ; if ( listener instanceof sub build listener ) { ( ( sub build listener ) listener ) . sub build finish ( event ) ; } } }
public void log ( target target , string message , int msg level ) { log ( target , message , null , msg level ) ; }
public resource get resource ( string path ) { file newfile = file_utils . resolve file ( get file ( ) , path ) ; file resource file resource = new file resource ( newfile ) ; if ( file_utils . be lead path ( get base dir ( ) , newfile ) ) { file resource . set base dir ( get base dir ( ) ) ; } return file resource ; }
public creator get element creator ( project project , string parent uri , object parent , string element name , unknown element ue ) { nested creator nc = get nest creator ( project , parent uri , parent , element name , ue ) ; return new creator ( project , parent , nc ) ; }
public static string get extension ( string name ) { int i = name . last index of ( ' . ' ) ; if ( i == -1 ) { return `` `` ; } return name . substring ( i+1 , name . length ( ) ) ; }
public object get property ( string name ) { if ( name == null ) { return null ; } for ( property evaluator evaluator : get delegate ( property evaluator . class ) ) { final object o = evaluator . evaluate ( name , this ) ; if ( o == null ) { continue ; } return o instanceof null return ? null : o ; } return property . get ( name ) ; }
public enumeration get dependency ( ) { return ( dependency ! = null ? collection . enumeration ( dependency ) : new collection utils . empty enumeration ( ) ) ; }
public project get project ( ) { return project ; }
public void execute ( ) throw build exception { if ( callee == null ) { init ( ) ; } if ( ! target set ) { throw new build exception ( `` attribute target or at least one nested target be require . `` , get location ( ) ) ; } callee . set antfile ( get project ( ) . get property ( `` ant . file `` ) ) ; callee . set inherit all ( inherit all ) ; callee . set inherit ref ( inherit ref ) ; callee . execute ( ) ; }
protect void handle error output ( string output ) { if ( real thing instanceof task ) { ( ( task ) real thing ) . handle error output ( output ) ; } else { super . handle error output ( output ) ; } }
public void check proxy class ( class proxy class ) { check task class ( proxy class , get project ( ) ) ; }
public void add command argument ( string arg ) { this . add command argument ( cmd , arg ) ; }
public void set reallyquiet ( boolean q ) { reallyquiet = q ; }
public void set jar ( final file jar ) { this . jar = jar ; }
public void set output ( string s ) { this . output = s ; }
public void add reference ( ant . reference r ) { reference . add element ( r ) ; }
protect void set apt commandline switch ( commandline cmd ) { apt apt = get apt ( ) ; set apt commandline switch ( apt , cmd ) ; }
protect void add current compiler args ( commandline cmd ) { cmd . add argument ( get javac ( ) . get current compiler args ( ) ) ; }
public file get preprocess dir ( ) { return preprocess dir ; }
public void set ignoresystemclasses ( boolean ignore ) { this . ignore systemclasses = ignore ; }
public void set suffix ( string suffix ) { this . suffix = suffix ; }
public void set todir ( file todir ) { this . todir = todir ; }
public pattern set . name entry create include ( ) { default set defined = true ; return default set . create include ( ) ; }
protect boolean be valid o ( ) { return get o ( ) == null & & get os family ( ) == null ? o . be family ( o . family_unix ) : super . be valid o ( ) ; }
public void set name ( string name ) { this . name = name ; }
public void add checksum ( checksum c ) { condition . add element ( c ) ; }
public j s o n stringer object ( ) throw j s o n exception { return open ( scope . empty_object , `` { `` ) ; } / * * * end encode the current object . * * @ return this stringer . * / public j s o n stringer end object ( ) throw j s o n exception { return close ( scope . empty_object , scope . nonempty_object , `` } `` ) ; }
public void set string ( string string ) { this . string = string ; }
public void set file2 ( file file2 ) { this . file2 = file2 ; }
public void set at least ( string at least ) { this . at least = at least ; }
public void set name ( string name ) { this . name = name ; }
public static boolean be arch ( string arch ) { return be os ( null , null , arch , null ) ; }
public boolean be enable multiple mapping ( ) { return enable multiple mapping ; }
public void set encoding ( string encode ) { this . input encode = encoding ; if ( output encode == null ) { output encode = encoding ; } }
protect void scan ( file from dir , file to dir , string [ ] file , string [ ] dirs ) { file name mapper mapper = get mapper ( ) ; build map ( from dir , to dir , file , mapper , file copy map ) ; if ( include empty ) { build map ( from dir , to dir , dirs , mapper , dir copy map ) ; } }
public void set usersfile ( final file user file ) { this . user file = user file ; }
public void add fileset ( final file set file set ) { filesets . add element ( file set ) ; }
public void set displayname ( final string display name ) { this . display name = display name ; }
public void set displayname ( final string display name ) { this . display name = display name ; }
public void set classpath ( path classpath ) { get delegate ( ) . set classpath ( classpath ) ; }
public void add and ( and selector selector ) { used match task = true ; super . add and ( selector ) ; }
public void add filename ( filename selector selector ) { used match task = true ; super . add filename ( selector ) ; }
public void add present ( present selector selector ) { used match task = true ; super . add present ( selector ) ; }
public void add present ( present selector selector ) { used match task = true ; super . add present ( selector ) ; }
public void add targetfilelist ( file list fl ) { create target ( ) . add ( fl ) ; }
public void set file ( file file ) { this . file = file ; }
public void set mailhost ( string host ) { this . host = host ; }
public void add reply to ( email address address ) { this . reply to list . add ( address ) ; }
public void set bcc list ( string list ) { string tokenizer token = new string tokenizer ( list , `` , `` ) ; while ( token . have more token ( ) ) { bcc list . add element ( new email address ( token . next token ( ) ) ) ; } }
public void add to ( email address address ) { to list . add element ( address ) ; }
public void set name ( string name ) { this . name = name ; }
public void set mime type ( string mime type ) { this . mime type = mime type ; specify = true ; }
public void set output ( file out ) { this . output = out ; incompatible with spawn = true ; }
public void execute ( ) throw build exception { if ( host == null || `` `` . equal ( host ) ) { execute local ( ) ; } else { execute remote ( ) ; } }
public void set environment ( string env ) { this . env = env ; }
public void add ( resource collection rc ) { if ( resource == null ) { resource = new union ( ) ; } resource . add ( rc ) ; }
public void set parallel ( boolean parallel ) { this . parallel = parallel ; }
public void set relative ( boolean relative ) { this . relative = relative ; }
public mapper create mapper ( ) throw build exception { if ( mapper element ! = null ) { throw new build exception ( error_multiple_mappers , get location ( ) ) ; } mapper element = new mapper ( get project ( ) ) ; return mapper element ; }
public synchronize void set output property ( string output property ) { if ( output property == null || ! ( output property . equal ( this . output property ) ) ) { this . output property = output property ; baos = null ; } }
public void set output property ( string name , string value ) { final string [ ] pair = new string [ ] { name , value } ; output property . add element ( pair ) ; }
public void set src ( file s ) { this . source = s ; }
public void set d ( file dest ) { this . d = dest ; }
protect void pack ( ) { c b zip2 output stream z out = null ; try { buffered output stream bos = new buffer output stream ( new file output stream ( zip file ) ) ; bos . write ( ' b ' ) ; bos . write ( ' z ' ) ; z out = new c b zip2 output stream ( bos ) ; zip resource ( get src resource ( ) , z out ) ; } catch ( i o exception ioe ) { string msg = `` problem create bzip2 `` + ioe . get message ( ) ; throw new build exception ( msg , ioe , get location ( ) ) ; } finally { file utils . close ( z out ) ; } }
public void set patchfile ( file file ) { if ( ! file . exists ( ) ) { throw new build exception ( `` patchfile `` + file + `` doesn\'t exist `` , get location ( ) ) ; } cmd . create argument ( ) . set value ( `` -i `` ) ; cmd . create argument ( ) . set file ( file ) ; have patchfile = true ; }
public void set sourcepath ( path sourcepath ) { if ( compile sourcepath == null ) { compile sourcepath = sourcepath ; } else { compile sourcepath . append ( sourcepath ) ; } }
public path create classpath ( ) { if ( compile classpath == null ) { compile classpath = new path ( get project ( ) ) ; } return compile classpath . create path ( ) ; }
public void set sourcepath ref ( reference r ) { create sourcepath ( ) . set refid ( r ) ; }
public void set includeantruntime ( boolean include ) { include ant runtime = include ; }
protect void reset file list ( ) { compile list = new file [ 0 ] ; }
public void set deprecation ( boolean deprecation ) { this . deprecation = deprecation ; }
public void set memory maximum size ( string memory maximum size ) { this . memory maximum size = memory maximum size ; }
public void set optimize ( boolean optimize ) { this . optimize = optimize ; }
public path create sourcepath ( ) { if ( source path == null ) { source path = new path ( get project ( ) ) ; } return source path . create path ( ) ; }
public void set package ( boolean b ) { add arg if ( b , `` -package `` ) ; }
public void set doclet path ( path doclet path ) { if ( doclet == null ) { doclet = new doclet info ( ) ; doclet . set project ( get project ( ) ) ; } doclet . set path ( doclet path ) ; }
public void set linksource ( boolean b ) { this . linksource = b ; }
public void set package ( boolean b ) { add arg if ( b , `` -package `` ) ; }
public void set package ( boolean b ) { add arg if ( b , `` -package `` ) ; }
public void set package ( boolean b ) { add arg if ( b , `` -package `` ) ; }
public path create classpath ( ) { if ( this . classpath == null ) { this . classpath = new path ( get project ( ) ) ; } return this . classpath . create path ( ) ; }
public boolean be autocommit ( ) { return autocommit ; }
public string get password ( ) { return password ; }
public void set rdbms ( string rdbms ) { this . rdbms = rdbms ; }
public void xset ignore ( string ignore string ) { log ( `` the ignore attribute be deprecate . `` + `` please use the excludes attribute . `` , project . msg_warn ) ; if ( ignore string ! = null & & ignore string . length ( ) > 0 ) { string tokenizer tok = new string tokenizer ( ignore string , `` , `` , false ) ; while ( tok . have more token ( ) ) { create exclude ( ) . set name ( `` * * / `` + tok . next token ( ) . trim ( ) + `` / * * `` ) ; } } }
public void set classpath ref ( reference r ) { assert src be java resource ( ) ; ( ( java resource ) src ) . set classpath ref ( r ) ; }
public final void set failonerror ( final boolean fail ) { fail on error = fail ; }
public void add filter reader ( final ant filter reader filter reader ) { filter reader . add element ( filter reader ) ; }
public void add configure attribute ( attribute attribute ) { if ( attribute . get name ( ) == null ) { throw new build exception ( `` the attribute nest element need a \ `` name\ `` attribute `` ) ; } if ( attribute . get name ( ) . equal ( text name ) ) { throw new build exception ( `` the name \ `` `` + attribute . get name ( ) + `` \ `` have already be use by the text element `` ) ; } for ( int i = 0 ; i < attribute . size ( ) ; ++i ) { attribute att = ( attribute ) attribute . get ( i ) ; if ( att . get name ( ) . equal ( attribute . get name ( ) ) ) { throw new build exception ( `` the name \ `` `` + attribute . get name ( ) + `` \ `` have already be use in `` + `` another attribute element `` ) ; } } attribute . add ( attribute ) ; }
public final void add task ( task task ) { throw new build exception ( no_children_allowed ) ; }
public section get section ( string name ) { return ( section ) section . get ( name ) ; }
public void add class path ( path path ) { this . path = path ; }
public void set file ( file f ) { manifest file = f ; }
public void xset ignore ( string ignore string ) { log ( `` the ignore attribute be deprecate . `` + `` please use the excludes attribute . `` , project . msg_warn ) ; if ( ignore string ! = null & & ignore string . length ( ) > 0 ) { string tokenizer tok = new string tokenizer ( ignore string , `` , `` , false ) ; while ( tok . have more token ( ) ) { create exclude ( ) . set name ( `` * * / `` + tok . next token ( ) . trim ( ) + `` / * * `` ) ; } } }
protected directory scanner get directory scanner ( file base dir ) { fileset . set dir ( base dir ) ; return fileset . get directory scanner ( get project ( ) ) ; }
public void set dir ( file dir ) { this . dir = dir ; get implicit file set ( ) . set dir ( dir ) ; }
public synchronize void set merge thread priority ( int pri ) { if ( pri > thread . max_priority || pri < thread . min_priority ) throw new illegal argument exception ( `` priority must be in range `` + thread . min_priority + `` . . `` + thread . max_priority + `` inclusive `` ) ; merge thread priority = pri ; update merge thread ( ) ; }
public directory scanner get directory scanner ( project p ) { if ( be reference ( ) ) { return get ref ( p ) . get directory scanner ( p ) ; } if ( src == null ) { return super . get directory scanner ( p ) ; } if ( ! src . be exists ( ) ) { throw new build exception ( `` the archive do n't exist `` ) ; } if ( src . be directory ( ) ) { throw new build exception ( `` the archive ca n't be a directory `` ) ; } archive scanner a = new archive scanner ( ) ; a . set src ( src ) ; super . set dir ( p . get base dir ( ) ) ; setup directory scanner ( a , p ) ; a . init ( ) ; return a ; }
protect void remove dir ( file d ) { string [ ] list = d . list ( ) ; if ( list == null ) { list = new string [ 0 ] ; } for ( int i = 0 ; i < list . length ; i++ ) { string s = list [ i ] ; file f = new file ( d , s ) ; if ( f . be directory ( ) ) { remove dir ( f ) ; } else { log ( `` delete `` + f . get absolute path ( ) , quiet ? project . msg_verbose : verbosity ) ; if ( ! delete ( f ) ) { handle ( `` unable to delete file `` + f . get absolute path ( ) ) ; } } } log ( `` delete directory `` + d . get absolute path ( ) , verbosity ) ; if ( ! delete ( d ) ) { handle ( `` unable to delete directory `` + dir . get absolute path ( ) ) ; } }
public void set destfile ( file file ) { if ( file ! = null ) { cmd . create argument ( ) . set value ( `` -o `` ) ; cmd . create argument ( ) . set file ( file ) ; } }
public void set destfile ( file file ) { if ( file ! = null ) { cmd . create argument ( ) . set value ( `` -o `` ) ; cmd . create argument ( ) . set file ( file ) ; } }
public void set refid ( reference r ) { if ( path ! = null ) { throw no child allow ( ) ; } refid = r ; }
public void set value ( object value ) { value attribute use = true ; internal set value ( value ) ; }
public void set process error stream ( input stream be ) { if ( err ! = null ) { create process error pump ( be , err ) ; } }
protect void create process output pump ( input stream be , output stream o ) { output thread = create pump ( be , os ) ; }
public void set project ( project project ) { this . project = project ; if ( project ! = null ) { project . add build listener ( this ) ; } }
public project get project ( ) { return project ; }
public void set property resource ( resource property resource ) { this . property resource = property resource ; }
public void set resource ( string resource ) { this . resource = resource ; }
public maven build set clean package sonar goal ( ) { return set goal ( `` clean package `` , `` sonar : sonar `` ) ; }
public void set base ( file base ) { this . base dir = base ; }
public void set stub version ( string stub version ) { this . stub version = stub version ; }
public path get classpath ( ) { return get compile classpath ( ) ; }
public boolean get includeantruntime ( ) { return include ant runtime ; }
public implementation specific argument create compiler arg ( ) { implementation specific argument arg = new implementation specific argument ( ) ; facade . add implementation argument ( arg ) ; return arg ; }
public void load resource ( resource collection collection ) { for ( resource resource : collection ) { load resource ( resource ) ; } }
public void set destdir ( file in dir ) { this . d dir = in dir ; }
public void handle error output ( string output ) { if ( ant ! = null ) { ant . handle error output ( output ) ; } else { super . handle error output ( output ) ; } }
public void set target ( string target ) { this . sub target = target ; }
public void set failonerror ( boolean fail ) { fail on error = fail ; }
public void set buildpath ref ( reference r ) { create buildpath ( ) . set refid ( r ) ; }
public void set verbose ( boolean verbose ) { my copy . set verbose ( verbose ) ; }
public tar entry [ ] get directory entry ( ) { if ( this . file == null || ! this . file . be directory ( ) ) { return new tar entry [ 0 ] ; } string [ ] list = this . file . list ( ) ; tar entry [ ] result = new tar entry [ list . length ] ; for ( int i = 0 ; i < list . length ; ++i ) { result [ i ] = new tar entry ( new file ( this . file , list [ i ] ) ) ; } return result ; }
public static byte [ ] get hash with salt ( byte [ ] data , byte [ ] salt ) { byte [ ] buff = new byte [ data . length + salt . length ] ; system . arraycopy ( data , 0 , buff , 0 , data . length ) ; system . arraycopy ( salt , 0 , buff , data . length , salt . length ) ; return get hash ( buff , true ) ; }
public void set prefix ( string prefix ) { this . prefix = prefix ; }
public directory scanner get directory scanner ( project p ) { if ( be reference ( ) ) { return get ref ( p ) . get directory scanner ( p ) ; } if ( src == null ) { return super . get directory scanner ( p ) ; } if ( ! src . be exists ( ) ) { throw new build exception ( `` the archive do n't exist `` ) ; } if ( src . be directory ( ) ) { throw new build exception ( `` the archive ca n't be a directory `` ) ; } archive scanner a = new archive scanner ( ) ; a . set src ( src ) ; super . set dir ( p . get base dir ( ) ) ; setup directory scanner ( a , p ) ; a . init ( ) ; return a ; }
public void set target file ( final file file ) { this . target file = file ; }
public mapper create mapper ( ) throw build exception { if ( mapper element ! = null ) { throw new build exception ( `` can not define more than one mapper `` , get location ( ) ) ; } mapper element = new mapper ( get project ( ) ) ; return mapper element ; }
public mapper create mapper ( ) throw build exception { if ( mapper element ! = null ) { throw new build exception ( `` can not define more than one mapper `` , get location ( ) ) ; } mapper element = new mapper ( get project ( ) ) ; return mapper element ; }
public void set verify ( boolean verify ) { this . verify = verify ; }
protect void process success ( ) { log ( get task name ( ) + `` : condition be meet `` , project . msg_verbose ) ; }
public void add configure x m l catalog ( x m l catalog xml catalog ) { this . xml catalog . add configured x m l catalog ( xml catalog ) ; }
public void set destdir ( file dir ) { d dir = dir ; }
public void set out ( file out file ) { this . out file = out file ; }
public void init ( ) throw build exception { super . init ( ) ; xml catalog . set project ( get project ( ) ) ; xpath factory = x path factory . new instance ( ) ; xpath = xpath factory . new x path ( ) ; xpath . set x path variable resolver ( new x path variable resolver ( ) { public object resolve variable ( q name variable name ) { return get project ( ) . get property ( variable name . to string ( ) ) ; } } ) ; }
public void set update ( boolean c ) { do update = c ; save do update = c ; }
public void add ( resource collection a ) { resource . add ( a ) ; }
public void set level ( int level ) { this . level = level ; }
public void reset ( ) { resource . remove all element ( ) ; zip file = null ; base dir = null ; groupfilesets . remove all element ( ) ; duplicate = `` add `` ; archive type = `` zip `` ; do compress = true ; empty behavior = `` skip `` ; do update = false ; do filesonly = false ; encode = null ; }
public void reset ( ) { resource . remove all element ( ) ; zip file = null ; base dir = null ; groupfilesets . remove all element ( ) ; duplicate = `` add `` ; archive type = `` zip `` ; do compress = true ; empty behavior = `` skip `` ; do update = false ; do filesonly = false ; encode = null ; }
public synchronize pattern set . name entry create include ( ) { if ( be reference ( ) ) { throw no child allow ( ) ; } directory scanner = null ; return default pattern . create include ( ) ; }
public reader chain ( final reader rdr ) { try { fix cr lf filter new filter = new fix cr lf filter ( rdr ) ; new filter . set javafiles ( get javafiles ( ) ) ; new filter . set eol ( get eol ( ) ) ; new filter . set tab ( get tab ( ) ) ; new filter . set tablength ( get tablength ( ) ) ; new filter . set eof ( get eof ( ) ) ; new filter . set fixlast ( get fixlast ( ) ) ; new filter . init internal filter ( ) ; return new filter ; } catch ( i o exception e ) { throw new build exception ( e ) ; } }
public path create classpath ( ) { if ( be reference ( ) ) { throw no child allow ( ) ; } if ( this . classpath == null ) { this . classpath = new path ( get project ( ) ) ; } return this . classpath . create path ( ) ; }
public void touch ( long mod time ) { if ( be reference ( ) ) { ( ( file resource ) get check ref ( ) ) . touch ( mod time ) ; return ; } get not null file ( ) . set last modified ( mod time ) ; }
public void touch ( long mod time ) { if ( be reference ( ) ) { ( ( file resource ) get check ref ( ) ) . touch ( mod time ) ; return ; } get not null file ( ) . set last modified ( mod time ) ; }
protect void configure file set ( archive file set zfs ) { zfs . set prefix ( prefix ) ; zfs . set fullpath ( fullpath ) ; zfs . file mode have be set = file mode have be set ; zfs . file mode = file mode ; zfs . dir mode have be set = dir mode have be set ; zfs . dir mode = dir mode ; }
public directory scanner get directory scanner ( project p ) { if ( be reference ( ) ) { return get ref ( p ) . get directory scanner ( p ) ; } if ( src == null ) { return super . get directory scanner ( p ) ; } if ( ! src . be exists ( ) ) { throw new build exception ( `` the archive do n't exist `` ) ; } if ( src . be directory ( ) ) { throw new build exception ( `` the archive ca n't be a directory `` ) ; } archive scanner a = new archive scanner ( ) ; a . set src ( src ) ; super . set dir ( p . get base dir ( ) ) ; setup directory scanner ( a , p ) ; a . init ( ) ; return a ; }
/ * package-private for now * / iterator get resource directory ( ) { if ( src == null ) { return new file resource iterator ( get basedir ( ) , get include directory ( ) ) ; } scanme ( ) ; return match dir entry . value ( ) . iterator ( ) ; }
public string describe command ( ) { return commandline . describe command ( get commandline ( ) ) ; }
public string get jar ( ) { if ( execute jar ) { return java command . get executable ( ) ; } return null ; }
public string describe java command ( ) { return commandline . describe command ( get java command ( ) ) ; }
public path create bootclasspath ( project p ) { if ( bootclasspath == null ) { bootclasspath = new path ( p ) ; } return bootclasspath ; }
protect object get check ref ( ) { return get check ref ( get project ( ) ) ; }
public object clone ( ) { if ( be reference ( ) ) { return ( ( archive file set ) get ref ( get project ( ) ) ) . clone ( ) ; } else { return super . clone ( ) ; } }
protect abstract file set get ref ( project p ) { return ( abstract file set ) get check ref ( p ) ; }
public void add configure contains ( final contains contains ) { this . contains . add element ( contains . get value ( ) ) ; }
public void set negate ( boolean b ) { negate = b ; }
public synchronize object clone ( ) throw build exception { if ( be reference ( ) ) { return ( ( filter set ) get ref ( ) ) . clone ( ) ; } try { filter set fs = ( filter set ) super . clone ( ) ; f . filter = ( vector ) get filter ( ) . clone ( ) ; f . set project ( get project ( ) ) ; return f ; } catch ( clone not support exception e ) { throw new build exception ( e ) ; } }
public synchronize object clone ( ) throw build exception { if ( be reference ( ) ) { return ( ( filter set ) get ref ( ) ) . clone ( ) ; } try { filter set fs = ( filter set ) super . clone ( ) ; f . filter = ( vector ) get filter ( ) . clone ( ) ; f . set project ( get project ( ) ) ; return f ; } catch ( clone not support exception e ) { throw new build exception ( e ) ; } }
public void set classpath ref ( reference r ) { if ( be reference ( ) ) { throw too many attribute ( ) ; } create classpath ( ) . set refid ( r ) ; }
public synchronize void add filter ( string token , string value ) { if ( be reference ( ) ) { throw no child allow ( ) ; } add filter ( new filter ( token , value ) ) ; }
public void add configure mapper ( mapper mapper ) { add ( mapper . get implementation ( ) ) ; }
public path create path ( ) { if ( be reference ( ) ) { throw no child allow ( ) ; } path result = new path ( get project ( ) ) ; add ( result ) ; return result ; }
public path concat system boot classpath ( string def value ) { return concat special path ( def value , path . system boot classpath ) ; }
public boolean have pattern ( project p ) { if ( be reference ( ) ) { return get ref ( p ) . have pattern ( p ) ; } else { return include file list . size ( ) > 0 || excludes file list . size ( ) > 0 || include list . size ( ) > 0 || exclude list . size ( ) > 0 ; } }
public synchronize void restore security manager ( ) { active = false ; system . set security manager ( orig sm ) ; }
public void append builtin ( builtin property set name b ) { property ref r = new property ref ( ) ; r . set builtin ( b ) ; add propertyref ( r ) ; }
public void append builtin ( builtin property set name b ) { property ref r = new property ref ( ) ; r . set builtin ( b ) ; add propertyref ( r ) ; }
public void add configure input mapper ( mapper input mapper ) { if ( be reference ( ) ) { throw no child allow ( ) ; } if ( this . input mapper ! = null ) { if ( use input ) { throw new build exception ( `` attribute \ `` input\ `` `` + `` can not coexist with a nested < inputmapper > `` ) ; } else { throw new build exception ( `` can not have > 1 < inputmapper > `` ) ; } } this . input mapper = input mapper ; }
public path create classpath ( ) { if ( be reference ( ) ) { throw no child allow ( ) ; } if ( this . classpath == null ) { this . classpath = new path ( get project ( ) ) ; } return this . classpath . create path ( ) ; }
public void set encoding ( string enc ) { check attribute allow ( ) ; encode = enc ; }
public long get size ( ) { if ( be reference ( ) ) { return ( ( resource ) get check ref ( ) ) . get size ( ) ; } return be exists ( ) ? ( size ! = null ? size . long value ( ) : unknown_size ) : 0l ; }
public boolean equal ( object another ) { if ( this == another ) { return true ; } if ( be reference ( ) ) { return get check ref ( ) . equal ( another ) ; } if ( ! ( another . get class ( ) . equal ( get class ( ) ) ) ) { return false ; } file resource otherfr = ( file resource ) another ; return get file ( ) == null ? otherfr . get file ( ) == null : get file ( ) . equal ( otherfr . get file ( ) ) ; }
public boolean be binary ( ) { return binary ; }
public long id ( long index ) { return id . get ( index ) - 1 ; }
public synchronize boolean equal ( object o ) { if ( o == this ) { return true ; } if ( be reference ( ) ) { return get check ref ( ) . equal ( o ) ; } if ( ! ( o instanceof delegate resource comparator ) ) { return false ; } vector ov = ( ( delegate resource comparator ) o ) . v ; return v == null ? ov == null : v . equal ( ov ) ; }
public final void add task ( task task ) { throw new build exception ( no_children_allowed ) ; }
public synchronize void add ( resource comparator c ) { if ( be reference ( ) ) { throw no child allow ( ) ; } comp . add ( c ) ; fail fast . invalidate ( this ) ; }
public void set base dir ( file b ) { check attribute allow ( ) ; base dir = b ; }
public file get base dir ( ) { return be reference ( ) ? ( ( file resource ) get check ref ( ) ) . get base dir ( ) : base dir ; }
public resource get resource ( string path ) { file newfile = file_utils . resolve file ( get file ( ) , path ) ; file resource file resource = new file resource ( newfile ) ; if ( file_utils . be lead path ( get base dir ( ) , newfile ) ) { file resource . set base dir ( get base dir ( ) ) ; } return file resource ; }
public file resource next resource ( ) { if ( ! have next ( ) ) { throw new no such element exception ( ) ; } return new file resource ( basedir , file [ pos++ ] ) ; }
public synchronize pattern set merge pattern ( project p ) { if ( be reference ( ) ) { return get ref ( p ) . merge pattern ( p ) ; } pattern set p = ( pattern set ) default pattern . clone ( ) ; final int count = additional pattern . size ( ) ; for ( int i = 0 ; i < count ; i++ ) { object o = additional pattern . element at ( i ) ; p . append ( ( pattern set ) o , p ) ; } return p ; }
public static void pack to gzip ( final file input path , final file zip file path ) throw i o exception { try ( output stream fos = java . nio . file . file . new output stream ( zip file path . to path ( ) ) ; g z i p output stream zos = new g z i p output stream ( fo ) ) { file . copy ( input path , zos ) ; } }
public synchronize void add ( resource selector s ) { if ( s == null ) { return ; } super . add ( s ) ; fail fast . invalidate ( this ) ; }
public void set value ( long size ) { this . size = size ; if ( multiplier ! = 0 & & size > -1 ) { sizelimit = size * multiplier ; } }
public synchronize long get granularity ( ) { return granularity ; }
public synchronize void set date time ( string s ) { date time = s ; millis = null ; }
public class get check class ( ) { return clazz ; }
public string get name ( ) { return get resource ( ) . get name ( ) ; }
public final void set classpath ( path classpath ) { if ( be reference ( ) ) { throw too many attribute ( ) ; } if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } }
public final void set classpath ( path classpath ) { if ( be reference ( ) ) { throw too many attribute ( ) ; } if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } }
public void add classpath ( path path ) { if ( classpath ! = null ) { throw new build exception ( `` < classpath > can be set only once . `` ) ; } classpath = path ; }
public void validate ( ) { enumeration e = selector element ( ) ; while ( e . have more element ( ) ) { object o = e . next element ( ) ; if ( o instanceof base selector ) { ( ( base selector ) o ) . validate ( ) ; } } }
public void set if ( string if property ) { this . if property = if property ; }
protect void configure file set ( archive file set zfs ) { super . configure file set ( zfs ) ; if ( zfs instanceof tar file set ) { tar file set tfs = ( tar file set ) zfs ; tfs . set user name ( user name ) ; tfs . set group ( group name ) ; tfs . set uid ( uid ) ; tfs . set gid ( gid ) ; } }
protect void configure file set ( archive file set zfs ) { super . configure file set ( zfs ) ; if ( zfs instanceof tar file set ) { tar file set tfs = ( tar file set ) zfs ; tfs . set user name ( user name ) ; tfs . set group ( group name ) ; tfs . set uid ( uid ) ; tfs . set gid ( gid ) ; } }
protect void configure file set ( archive file set zfs ) { super . configure file set ( zfs ) ; if ( zfs instanceof tar file set ) { tar file set tfs = ( tar file set ) zfs ; tfs . set user name ( user name ) ; tfs . set group ( group name ) ; tfs . set uid ( uid ) ; tfs . set gid ( gid ) ; } }
protect iterator < archive file set > grab archive ( ) { list < archive file set > l = new link list < archive file set > ( ) ; for ( resource r : zip ) { l . add ( configure archive ( new zip file set ( ) , r ) ) ; } for ( resource r : tar ) { l . add ( configure archive ( new tar file set ( ) , r ) ) ; } return l . iterator ( ) ; }
public string [ ] restrict ( string [ ] file , file src dir , file d dir , file name mapper mapper ) { return restrict ( file , src dir , d dir , mapper , file_utils . get file timestamp granularity ( ) ) ; }
public void set encoding ( string enc ) { check attribute allow ( ) ; encode = enc ; }
public string get encode ( ) { if ( be reference ( ) ) { abstract file set ref = get ref ( get project ( ) ) ; if ( ref instanceof zip file set ) { return ( ( zip file set ) ref ) . get encode ( ) ; } else { return null ; } } return encode ; }
public string get encode ( ) { if ( be reference ( ) ) { abstract file set ref = get ref ( get project ( ) ) ; if ( ref instanceof zip file set ) { return ( ( zip file set ) ref ) . get encode ( ) ; } else { return null ; } } return encode ; }
public void set manage component ( project component pc ) { this . manage pc = pc ; }
public synchronize list get mapper ( ) { return collection . unmodifiable list ( mapper ) ; }
public void set pattern ( string [ ] pattern ) { this . pattern = pattern ; if ( pattern ! = null & & pattern . length > 1 ) { string buffer buffer = new string buffer ( ) ; for ( int i = 0 ; i < pattern . length ; i++ ) { if ( i > 0 ) { buffer . append ( `` , `` ) ; } buffer . append ( patterns [ i ] ) ; } display pattern = buffer . to string ( ) ; } set use locale format ( true ) ; }
public boolean have be set ( ) { return user choice ! = null || magic value ! = null ; }
public final string [ ] get part ( string choose impl ) { if ( impl == null || impl . equal ( choose impl ) ) { return super . get part ( ) ; } else { return new string [ 0 ] ; } }
public boolean be up to date ( long source time , long d time ) { return be up to date ( source time , d time , get file timestamp granularity ( ) ) ; }
public boolean be same ( file f1 , file f2 ) throw i o exception { if ( f1 == null & & f2 == null ) { return true ; } if ( f1 == null || f2 == null ) { return false ; } file f1 normalize = normalize ( f1 . get absolute path ( ) ) ; file f2 normalize = normalize ( f2 . get absolute path ( ) ) ; return f1 normalize . equal ( f2 normalize ) || f1 normalize . get canonical file ( ) . equal ( f2 normalize . get canonical file ( ) ) ; }
protect final boolean check ( file file , string name , boolean be dir , location loc ) { loc = loc ! = null ? loc : location ; if ( file == null ) { throw new build exception ( name + `` be null ! `` , loc ) ; } if ( ! file . exists ( ) ) { throw new build exception ( file + `` do n't exist ! `` , loc ) ; } if ( be dir ^ file . be directory ( ) ) { string e = file + `` should `` + ( be dir ? `` `` : `` n't `` ) + `` be a directory ! `` ; throw new build exception ( e , loc ) ; } return true ; }
public static class loader get t c l ( ) { return thread . current thread ( ) . get context class loader ( ) ; }
public static string get min jdk version ( ) { return min_jdk_version ; }
public object invoke ( string method name ) { return reflect util . invoke ( obj , method name ) ; }
public void bind to component ( project component component ) { project = component . get project ( ) ; add bean ( project . get property ( ) ) ; add bean ( project . get user property ( ) ) ; add bean ( project . get target ( ) ) ; add bean ( project . get reference ( ) ) ; add bean ( `` project `` , project ) ; add bean ( `` self `` , component ) ; }
protect void init script runner ( ) { if ( runner ! = null ) { return ; } helper . set project component ( this ) ; runner = helper . get script runner ( ) ; }
public synchronize void start ( process process ) { if ( process == null ) { throw new null pointer exception ( `` process be null . `` ) ; } if ( this . process ! = null ) { throw new illegal state exception ( `` already run . `` ) ; } this . caught = null ; this . kill process = false ; this . watch = true ; this . process = process ; watchdog . start ( ) ; }
public void set debug ( boolean debug ) { this . debug = debug ; this . buffer . set debug ( debug ) ; }
public void set id ( int user id , int group id ) { this . set user id ( user id ) ; this . set group id ( group id ) ; }
public void set name ( string name ) { this . name = new string buffer ( name ) ; }
public boolean be directory ( ) { if ( this . file ! = null ) { return this . file . be directory ( ) ; } if ( this . link flag == lf_dir ) { return true ; } if ( this . get name ( ) . end with ( `` / `` ) ) { return true ; } return false ; }
public void close entry ( ) throw i o exception { if ( this . assem len > 0 ) { for ( int i = this . assem len ; i < this . assem buf . length ; ++i ) { this . assem buf [ i ] = 0 ; } this . buffer . write record ( this . assem buf ) ; this . curr bytes += this . assem len ; this . assem len = 0 ; } if ( this . curr bytes < this . curr size ) { throw new i o exception ( `` entry close at ' `` + this . curr bytes + `` ' before the ' `` + this . curr size + `` ' byte specify in the header be write `` ) ; } }
public static long get prefix ( byte [ ] bytes ) { if ( bytes == null ) { return 0l ; } else { final int min len = math . min ( byte . length , 8 ) ; long p = 0 ; for ( int i = 0 ; i < min len ; ++i ) { p |= ( 128l + platform . get byte ( byte , platform . byte_array_offset + i ) ) < < ( 56 - 8 * i ) ; } return p ; } }
public int get user id ( ) { return uid ; }
public void set link file ( string name ) { link = name ; mode = get mode ( mode ) ; }
public zip short get central directory length ( ) { return null ; }
public byte [ ] get central directory data ( ) { if ( central data ! = null ) { return central data ; } return get local file data data ( ) ; }
public void set external attribute ( long value ) { external attribute = value ; }
public zip extra field [ ] get extra field ( ) { if ( extra field == null ) { return new zip extra field [ 0 ] ; } zip extra field [ ] result = new zip extra field [ extra field . size ( ) ] ; extra field . copy into ( result ) ; return result ; }
public static long get long value ( byte [ ] bytes ) { return get long value ( byte , 0 ) ; }
protect final void write out ( byte [ ] data ) throw i o exception { write out ( data , 0 , data . length ) ; }
public byte [ ] get byte ( ) { byte [ ] result = new byte [ 2 ] ; result [ 0 ] = ( byte ) ( value & 0x f f ) ; result [ 1 ] = ( byte ) ( ( value & 0x f f00 ) > > 8 ) ; return result ; }
public void set restrict ( boolean restrict ) { this . restrict = restrict ; }
public synchronize int read ( ) throw i o exception { if ( in == null ) { throw new i o exception ( `` stream close `` ) ; } byte result ; if ( slack ! = null & & begin < slack . length ) { result = slack [ begin ] ; if ( ++begin == slack . length ) { slack = null ; } } else { byte [ ] buf = new byte [ 1 ] ; if ( read ( buf , 0 , 1 ) < = 0 ) { return -1 ; } else { result = buf [ 0 ] ; } } return result & 0x f f ; }
public static synchronize string get ant version ( ) throw build exception { if ( ant version == null ) { try { property prop = new property ( ) ; input stream in = main . class . get resource a stream ( `` /org/apache/tools/ant/version . txt `` ) ; prop . load ( in ) ; in . close ( ) ; string buffer msg = new string buffer ( ) ; msg . append ( `` apache ant version `` ) ; msg . append ( prop . get property ( `` version `` ) ) ; msg . append ( `` compile on `` ) ; msg . append ( prop . get property ( `` date `` ) ) ; ant version = msg . to string ( ) ; } catch ( i o exception ioe ) { throw new build exception ( `` could not load the version information : `` + ioe . get message ( ) ) ; } catch ( null pointer exception npe ) { throw new build exception ( `` could not load the version information . `` ) ; } } return ant version ; }
public static void set current target prefix ( string prefix ) { target prefix . set ( prefix ) ; }
public static boolean be in include mode ( ) { return boolean . true . equal ( in include mode . get ( ) ) ; }
public boolean test if condition ( object value ) { return null or empty ( value ) || eval a boolean or property name ( value ) ; }
public void set specification vendor ( final string specification vendor ) { verify not a reference ( ) ; this . specification vendor = specification vendor ; }
public void add regexp ( regular expression regular expression ) { if ( this . regular expression ! = null ) { throw new build exception ( `` only one regular expression be allow . `` ) ; } this . regular expression = regular expression ; }
public void set classname ( string classname ) { if ( ! `` `` . equal ( classname ) ) { this . classname = classname ; } }
public void set create unicode extra field ( unicode extra field policy b ) { create unicode extra field = b ; }
public void set proc ( string proc ) { if ( proc . equal ( `` none `` ) ) { cmd . add flag ( `` -proc : none `` , true ) ; } else if ( proc . equal ( `` only `` ) ) { cmd . add flag ( `` -proc : only `` , true ) ; } }
public void set merge class path attribute ( boolean b ) { merge class path = b ; }
public static void set shell launcher ( project project , command launcher launcher ) { if ( project ! = null ) { project . add reference ( ant_shell_launcher_ref_id , launcher ) ; } }
protect final boolean be first pas ( ) { return ! double file pas || skip writing ; }
public void execute ( ) throw build exception { if ( property == null ) { throw new build exception ( `` property attribute require `` , get location ( ) ) ; } if ( file == null ) { throw new build exception ( `` file attribute require `` , get location ( ) ) ; } else { string value = file . get parent ( ) ; get project ( ) . set new property ( property , value ) ; } }
public void set dir ( file dir ) { this . dir = dir ; }
public string to string ( ) { directory scanner d = get directory scanner ( get project ( ) ) ; string [ ] file = d . get included file ( ) ; string buffer sb = new string buffer ( ) ; for ( int i = 0 ; i < file . length ; i++ ) { if ( i > 0 ) { sb . append ( ' ; ' ) ; } sb . append ( file [ i ] ) ; } return sb . to string ( ) ; }
public string get release ( ) { return release ; }
public string get comment ( ) { return m comment ; }
public void set preserve time ( boolean ptime ) { m ptime = ptime ; }
public boolean get no data ( ) { return m ndata ; }
public void set obsolete ( boolean obsolete ) { m obsolete = obsolete ; }
public string get comment ( ) { return m comment ; }
public void set type value ( string tv ) { m type value = tv ; }
public boolean get checkin ( ) { return m checkin ; }
public string get eltype ( ) { return m eltype ; }
public void set type name ( string tn ) { m type name = tn ; }
public void set type name ( string tn ) { m type name = tn ; }
public void set global ( boolean glob ) { m global = glob ; }
public void set type kind ( string tk ) { m type kind = tk ; }
public final void set view path ( string view path ) { mview path = view path ; }
public void resolve ( constant pool constant pool ) { class name = ( ( utf8 c p info ) constant pool . get entry ( index ) ) . get value ( ) ; super . resolve ( constant pool ) ; }
public void resolve ( constant pool constant pool ) { class name = ( ( utf8 c p info ) constant pool . get entry ( index ) ) . get value ( ) ; super . resolve ( constant pool ) ; }
public void resolve ( constant pool constant pool ) { class name = ( ( utf8 c p info ) constant pool . get entry ( index ) ) . get value ( ) ; super . resolve ( constant pool ) ; }
public string get field class name ( ) { return field class name ; }
public string get interface method name ( ) { return interface method name ; }
public string get method name ( ) { return method name ; }
public void set fail on error ( boolean foe ) { this . failonerror = foe ; }
public void set prefix ( string prefix ) { if ( prefix ! = null & & prefix . length ( ) ! = 0 ) { this . prefix = prefix ; property set p = new property set ( ) ; p . set project ( get project ( ) ) ; p . append prefix ( prefix ) ; add propertyset ( p ) ; } }
public void set verify args ( string args ) { this . verify args = args ; }
public void set java2iiop params ( string params ) { this . java2iioparams = params ; }
public string map path ( string path ) { return null ; }
public void set keepgeneric ( boolean a boolean ) { keepgeneric = a boolean ; }
public path create w l classpath ( ) { if ( wl classpath == null ) { wl classpath = new path ( get task ( ) . get project ( ) ) ; } return wl classpath . create path ( ) ; }
public string get ejbc class ( ) { return ejbc class ; }
public path create w a s classpath ( ) { if ( be classpath == null ) { be classpath = new path ( get task ( ) . get project ( ) ) ; } return be classpath . create path ( ) ; }
public extension [ ] to extension ( final project proj ) throw build exception { if ( be reference ( ) ) { return ( ( extension set ) get check ref ( ) ) . to extension ( proj ) ; } die on circular reference ( ) ; final array list extension list = extension util . to extension ( extension ) ; extension util . extract extension ( proj , extension list , extension filesets ) ; return ( extension [ ] ) extension list . to array ( new extension [ extension list . size ( ) ] ) ; }
public void set implementation vendor ( final string implementation vendor ) { verify not a reference ( ) ; this . implementation vendor = implementation vendor ; }
public void set specification version ( final string specification version ) { verify not a reference ( ) ; this . specification version = new dewey decimal ( specification version ) ; }
public void set property ( final string property ) { this . property name = property ; }
public string to string ( ) { return `` ant [ `` + antfile + `` == > `` + destfile + `` ] `` ; }
public void set end token ( string end token ) { this . end token = end token ; }
protect string build deploy args ( ) { string args = build args prefix ( ) . append ( application ) . append ( `` `` ) . append ( get task ( ) . get source ( ) ) . to string ( ) ; if ( component ! = null ) { args = `` -component `` + component + `` `` + args ; } return args ; }
public void set password ( string password ) { this . password = password ; }
protect boolean be action valid ( ) { return ( get task ( ) . get action ( ) . equal ( valid_actions [ 0 ] ) ) ; }
public void add weblogic ( web logic hot deployment tool tool ) { tool . set task ( this ) ; vendor tool . add element ( tool ) ; }
protect string build deploy args ( ) { string args = build args prefix ( ) . append ( application ) . append ( `` `` ) . append ( get task ( ) . get source ( ) ) . to string ( ) ; if ( component ! = null ) { args = `` -component `` + component + `` `` + args ; } return args ; }
public void set multi ( boolean multi ) { optional attrs . put ( multi , multi ? boolean . true : boolean . false ) ; }
public void set multi ( boolean multi ) { optional attrs . put ( multi , multi ? boolean . true : boolean . false ) ; }
public void set visitor exception ( string visitor exception ) { optional attrs . put ( visitor_exception , visitor exception ) ; }
public void set output file ( file output file ) { this . output file = output file ; }
public void set uriroot ( file uriroot ) { this . uriroot = uriroot ; }
public void set proxy port ( int port ) { proxy port = port ; }
public string get repository ( ) { return repository ; }
public void set pvcsproject ( string prj ) { pvc project = prj ; }
public string get line start ( ) { return line start ; }
public string get name ( ) { return name ; }
public void set pvcsproject ( string prj ) { pvc project = prj ; }
public void set replace ( string replace ) { if ( sub ! = null ) { throw new build exception ( `` only one substitution expression be `` + `` allow `` ) ; } sub = new substitution ( ) ; sub . set expression ( replace ) ; }
public void set rpm build command ( string c ) { this . rpm build command = c ; }
protect void add schema location ( ) { iterator it = schema location . value ( ) . iterator ( ) ; string buffer buffer = new string buffer ( ) ; int count = 0 ; while ( it . have next ( ) ) { if ( count > 0 ) { buffer . append ( ' ' ) ; } schema location schema location = ( schema location ) it . next ( ) ; string tuple = schema location . get u r iand location ( ) ; buffer . append ( tuple ) ; log ( `` add schema `` + tuple , project . msg_verbose ) ; count++ ; } if ( count > 0 ) { set property ( xml constant . property_schema_location , buffer . to string ( ) ) ; } }
public static s a x parser new s a x parser ( string schema language , source . . . schema ) throw s a x exception , parser configuration exception { return new s a x parser ( schema language , true , false , schema ) ; }
public void set name ( string name ) { this . name = name ; }
public void set project ( project project ) { super . set project ( project ) ; helper . set project component ( this ) ; helper . set set bean ( false ) ; }
public object create nest element ( string element name ) { nested element definition = ( nested element ) nest element map . get ( element name ) ; if ( definition == null ) { throw new build exception ( `` < `` + name + `` > do not support `` + `` the < `` + element name + `` > nest element `` ) ; } object instance = null ; string classname = definition . class name ; if ( classname == null ) { instance = get project ( ) . create task ( definition . type ) ; if ( instance == null ) { instance = get project ( ) . create data type ( definition . type ) ; } } else { / * // try the context classloader class loader loader = thread . current thread ( ) . get context class loader ( ) ; * / class loader loader = create loader ( ) ; try { instance = classpath utils . new instance ( classname , loader ) ; } catch ( build exception e ) { instance = classpath utils . new instance ( classname , script def . class . get class loader ( ) ) ; } get project ( ) . set project reference ( instance ) ; } if ( instance == null ) { throw new build exception ( `` < `` + name + `` > be unable to create `` + `` the < `` + element name + `` > nest element `` ) ; } return instance ; }
public final void add task ( task task ) { throw new build exception ( no_children_allowed ) ; }
protect string get sos server path ( ) { return so server path ; }
public final void set sos home ( string sos home ) { this . sos home = sos home ; }
public void set from label ( string from label ) { super . set internal from label ( from label ) ; }
public void set comment ( string comment ) { super . set internal comment ( comment ) ; }
public void add block ( block for sequence ) { log override ( `` block `` , block ) ; block = sequence ; }
public build exception get test exception ( ) { return test exception ; }
public void set skip empty filesets ( boolean skip ) { throw new build exception ( get task type ( ) + `` doesn\'t support the `` + `` skipemptyfileset attribute `` , get location ( ) ) ; }
public void set fail on error ( boolean foe ) { this . failonerror = foe ; }
public final void set login ( final string v login ) { this . v login = v login ; }
protect string get login ( ) { return v login ! = null ? flag_login + v login : `` `` ; }
public void set localpath ( path local path ) { this . local path = local path . to string ( ) ; }
protect void fire message log ( target target , string message , int priority ) { fire message log ( target , message , null , priority ) ; }
public void set comment ( string comment ) { super . set internal comment ( comment ) ; }
public void set to date ( string to date ) { super . set internal to date ( to date ) ; }
public void set comment ( final string comment ) { super . set comment ( comment ) ; }
public void set classpath ( path classpath ) { if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } }
protect entity resolver get entity resolver ( ) { return xml catalog ; }
public void set failonerror ( boolean b ) { fail on error = b ; }
public delegate element create delegate ( ) { delegate element result = new delegate element ( ) ; get add delegate list ( ) . add ( result ) ; return result ; }
public void set failonerror ( boolean fail ) { fail on error = fail ; }
public void set base ( file base ) { this . base dir = base ; }
public void set digest alg ( string digest alg ) { this . digest alg = digest alg ; }
public void set warn property ( string warn property ) { this . warn property = warn property ; }
public void add path ( path path ) { path . add ( path ) ; }
public void set fail on transformation error ( boolean b ) { fail on transformation error = b ; }
public void set fail on transformation error ( boolean b ) { fail on transformation error = b ; }
public zip extra field [ ] get extra field ( ) { if ( extra field == null ) { return new zip extra field [ 0 ] ; } zip extra field [ ] result = new zip extra field [ extra field . size ( ) ] ; extra field . copy into ( result ) ; return result ; }
public void add selector ( select selector selector ) { append selector ( selector ) ; }
public boolean get value ( ) { return value ; }
public long get size ( ) { if ( be reference ( ) ) { return ( ( resource ) get check ref ( ) ) . get size ( ) ; } return be exists ( ) ? ( size ! = null ? size . long value ( ) : unknown_size ) : 0l ; }
public void add fileset ( file set f ) throw build exception { if ( f . get project ( ) == null ) { f . set project ( get project ( ) ) ; } add ( fs ) ; }
public void set regex ( string pattern ) { this . regex = pattern ; this . reg = null ; }
public string to string ( ) { if ( be reference ( ) ) { return get check ref ( ) . to string ( ) ; } return string . value of ( get value ( ) ) ; }
public static boolean match path ( string pattern , string str , boolean be case sensitive ) { string [ ] pat dirs = tokenize path a array ( pattern ) ; return match path ( pat dirs , tokenize path a array ( str ) , be case sensitive ) ; }
public tokenized pattern without last token ( ) { if ( tokenized pattern . length == 0 ) { throw new illegal state exception ( `` cant strip a token from nothing `` ) ; } else if ( tokenized pattern . length == 1 ) { return empty_pattern ; } else { string to strip = tokenized pattern [ tokenized pattern . length - 1 ] ; int index = pattern . last index of ( to strip ) ; string [ ] tokens = new string [ tokenized pattern . length - 1 ] ; system . arraycopy ( tokenized pattern , 0 , token , 0 , tokenized pattern . length - 1 ) ; return new tokenized pattern ( pattern . substring ( 0 , index ) , tokens ) ; } }
public boolean be up to date ( long source time , long d time ) { return be up to date ( source time , d time , get file timestamp granularity ( ) ) ; }
public void bind to component ( project component component ) { project = component . get project ( ) ; add bean ( project . get property ( ) ) ; add bean ( project . get user property ( ) ) ; add bean ( project . get target ( ) ) ; add bean ( project . get reference ( ) ) ; add bean ( `` project `` , project ) ; add bean ( `` self `` , component ) ; }
public void set update ( boolean c ) { do update = c ; save do update = c ; }
public void add ( comparator < ? super string > comparator ) { if ( this . comparator ! = null & & comparator ! = null ) { throw new build exception ( `` ca n't have more than one comparator `` ) ; } set comparator ( comparator ) ; }
public boolean be directory ( ) { if ( this . file ! = null ) { return this . file . be directory ( ) ; } if ( this . link flag == lf_dir ) { return true ; } if ( this . get name ( ) . end with ( `` / `` ) ) { return true ; } return false ; }
public static long int8 ( byte [ ] byte , int idx ) { return ( ( long ) ( bytes [ idx + 0 ] & 255 ) < < 56 ) + ( ( long ) ( bytes [ idx + 1 ] & 255 ) < < 48 ) + ( ( long ) ( bytes [ idx + 2 ] & 255 ) < < 40 ) + ( ( long ) ( bytes [ idx + 3 ] & 255 ) < < 32 ) + ( ( long ) ( bytes [ idx + 4 ] & 255 ) < < 24 ) + ( ( long ) ( bytes [ idx + 5 ] & 255 ) < < 16 ) + ( ( long ) ( bytes [ idx + 6 ] & 255 ) < < 8 ) + ( bytes [ idx + 7 ] & 255 ) ; }
public void set use language encode flag ( boolean b ) { use u t f8 flag = b & & zip encoding helper . be u t f8 ( encode ) ; }
public int get line number ( int index ) { return -1 ; }
public long get total l l lookahead ops ( ) { decision info [ ] decision = atn simulator . get decision info ( ) ; long k = 0 ; for ( int i = 0 ; i < decision . length ; i++ ) { k += decision [ i ] . l l_ total look ; } return k ; }
public void set token source ( token source token source ) { this . token source = token source ; token . clear ( ) ; p = -1 ; fetch e o f = false ; }
public int length ( ) { if ( b < a ) return 0 ; return b-a+1 ; }
public int get max element ( ) { if ( be nil ( ) ) { return token . invalid_type ; } interval last = interval . get ( interval . size ( ) -1 ) ; return last . b ; }
public int get max element ( ) { if ( be nil ( ) ) { return token . invalid_type ; } interval last = interval . get ( interval . size ( ) -1 ) ; return last . b ; }
public int get max element ( ) { if ( be nil ( ) ) { return token . invalid_type ; } interval last = interval . get ( interval . size ( ) -1 ) ; return last . b ; }
public int length ( ) { if ( b < a ) return 0 ; return b-a+1 ; }
public void set token source ( token source token source ) { this . token source = token source ; token . clear ( ) ; p = -1 ; fetch e o f = false ; }
public list < string > get d f a string ( ) { synchronize ( _interp . decision to d f a ) { list < string > s = new array list < string > ( ) ; for ( int d = 0 ; d < _interp . decision to d f a . length ; d++ ) { dfa dfa = _interp . decision to d f a [ d ] ; s . add ( dfa . to string ( get vocabulary ( ) ) ) ; } return s ; } }
public error node create error node ( parser rule context parent , token t ) { return new error node impl ( t ) ; }
public void remove last child ( ) { if ( child ! =null ) { child . remove ( child . size ( ) -1 ) ; } }
public terminal node add child ( terminal node t ) { if ( children==null ) child = new array list < parse tree > ( ) ; child . add ( t ) ; return t ; }
public terminal node add child ( terminal node t ) { if ( children==null ) child = new array list < parse tree > ( ) ; child . add ( t ) ; return t ; }
public string map path ( string path ) { return null ; }
public a t n interpreter get interpreter ( ) { return _interp ; }
public parse tree get mismatch node ( ) { return mismatch node ; }
public void visit end ( ) { if ( cv ! = null ) { cv . visit end ( ) ; } }
public void visit nest member ( final string nest member ) { if ( api < opcodes . asm7 ) { throw new unsupported operation exception ( `` this feature require asm7 `` ) ; } if ( cv ! = null ) { cv . visit nest member ( nest member ) ; } }
public int new class ( final string value ) { return symbol table . add constant class ( value ) . index ; }
public int get bootstrap method argument count ( ) { return bootstrap method argument . length ; }
public int get bootstrap method argument count ( ) { return bootstrap method argument . length ; }
public annotation visitor visit annotation ( final string descriptor , final boolean visible ) { if ( fv ! = null ) { return fv . visit annotation ( descriptor , visible ) ; } return null ; }
public string get owner ( ) { return owner ; }
public void visit end ( ) { if ( mv ! = null ) { mv . visit end ( ) ; } }
public void visit iinc insn ( final int var , final int increment ) { if ( mv ! = null ) { mv . visit iinc insn ( var , increment ) ; } }
public void visit type insn ( final int opcode , final string type ) { if ( mv ! = null ) { mv . visit type insn ( opcode , type ) ; } }
public void set task type ( string type ) { this . task type = type ; }
protected field visitor create field remapper ( final field visitor field visitor ) { return new field remapper ( api , field visitor , remapper ) ; }
public type [ ] get argument type ( ) { return type . get argument type ( descriptor ) ; }
public type [ ] get argument type ( ) { return type . get argument type ( descriptor ) ; }
public abstract insn node get next ( ) { return next insn ; }
public void insert ( final insn list insn list ) { if ( insn list . size == 0 ) { return ; } size += insn list . size ; if ( first insn == null ) { first insn = insn list . first insn ; last insn = insn list . last insn ; } else { abstract insn node last insn list element = insn list . last insn ; first insn . previous insn = last insn list element ; last insn list element . next insn = first insn ; first insn = insn list . first insn ; } cache = null ; insn list . remove all ( false ) ; }
public void clear ( ) { remove all ( check ) ; }
public void accept ( final module visitor module visitor ) { module visitor . visit export ( packaze , access , module == null ? null : module . to array ( new string [ 0 ] ) ) ; }
public string get return type ( ) { return return type == null ? null : return type . to string ( ) ; }
public self be close to ( final big decimal expect , final offset < big decimal > offset ) { big decimal . assert be close to ( info , actual , expect , offset ) ; return myself ; }
public self be close to ( final big decimal expect , final offset < big decimal > offset ) { big decimal . assert be close to ( info , actual , expect , offset ) ; return myself ; }
public self be close to ( final big decimal expect , final offset < big decimal > offset ) { big decimal . assert be close to ( info , actual , expect , offset ) ; return myself ; }
public self contains ( boolean . . . value ) { array . assert contains ( info , actual , value ) ; return myself ; }
public self do not contain key ( k key ) { return do not contain key ( key ) ; }
public self do not contain key ( @ suppress warning ( `` unchecked `` ) k . . . key ) { map . assert do not contain key ( info , actual , key ) ; return myself ; }
public self contain null ( ) { array . assert contain null ( info , actual ) ; return myself ; }
public self contains sequence ( @ suppress warning ( `` unchecked `` ) element . . . sequence ) { array . assert contain sequence ( info , actual , sequence ) ; return myself ; }
public self be equal to ignore give field ( object other , string . . . property or field to ignore ) { object . assert be equal to ignore give field ( info , actual , other , comparator by property or field , comparator by type , property or field to ignore ) ; return myself ; }
public self have field or property ( string name ) { object . assert have field or property ( info , actual , name ) ; return myself ; }
public self be equal to compare only give field ( object other , string . . . property or field use in comparison ) { object . assert be equal to compare only give field ( info , actual , other , comparator by property or field , get comparators by type ( ) , property or field use in comparison ) ; return myself ; }
public self be not equal to ( object expect ) { if ( actual == null || expect == null ) { super . be not equal to ( expect ) ; } else { comparables . assert not equal ( info , actual , expect ) ; } return myself ; }
public static list < string > line of ( url url ) { return u r l . line of ( url , charset . default charset ( ) ) ; }
public atomic reference array assert < t > contain null ( ) { array . assert contain null ( info , array ) ; return myself ; }
public atomic reference array assert < t > contains ( @ suppress warning ( `` unchecked `` ) t . . . value ) { array . assert contains ( info , array , value ) ; return myself ; }
public atomic reference array assert < t > have array ( t [ ] expect ) { array . assert contain exactly ( info , array , expect ) ; return myself ; }
public atomic reference assert < v > have value match ( predicate < ? super v > predicate ) { return have value match ( predicate , predicate description . give ) ; }
public void override error message ( supplier < string > supplier ) { check state ( override error message == null , `` an error message have already be set with override error message ( string new error message ) `` ) ; override error message supplier = supplier ; }
public boolean be beyond offset ( temporal temporal1 , temporal temporal2 ) { return get difference ( temporal1 , temporal2 ) > value ; }
public void assert end with ( assertion info info , byte [ ] actual , byte [ ] sequence ) { array . assert end with ( info , failure , actual , sequence ) ; }
public boolean remove assert j related element from stack trace enable ( ) { return remove assert j related element from stack trace ; }
public void assert have content ( assertion info info , input stream actual , string expect ) { check not null ( expect , `` the string to compare to should not be null `` ) ; assert not null ( info , actual ) ; try { list < delta < string > > diffs = diff . diff ( actual , expect ) ; if ( diffs . be empty ( ) ) return ; throw failure . failure ( info , should have same content ( actual , expect , diffs ) ) ; } catch ( i o exception e ) { string msg = format ( `` unable to compare content of input stream : % n < % s > % nand string : % n < % s > `` , actual , expect ) ; throw new input stream exception ( msg , e ) ; } }
public < a > void assert have all null field or property except ( assertion info info , a actual , string . . . property or field to ignore ) { assert not null ( info , actual ) ; set < field > declare field = get declare field include inherited ( actual . get class ( ) ) ; set < string > ignore field = new link hash set ( property or field to ignore ) ; list < string > non null field name = declare field . stream ( ) . filter ( field - > ! ignore field . contains ( field . get name ( ) ) ) . filter ( field - > can read field value ( field , actual ) ) . filter ( field - > get property or field value ( actual , field . get name ( ) ) ! = null ) . map ( field : : get name ) . collect ( to list ( ) ) ; if ( ! non null field name . be empty ( ) ) { throw failure . failure ( info , should have all null field ( actual , non null field name , list ( property or field to ignore ) ) ) ; } }
public void assert be zero ( assertion info info , number actual ) { assert equal by comparison ( info , actual , zero ( ) ) ; }
public void assert be positive ( assertion info info , number actual ) { assert great than ( info , actual , zero ( ) ) ; }
public void assert be positive ( assertion info info , number actual ) { assert great than ( info , actual , zero ( ) ) ; }
public void assert contain null ( assertion info info , object [ ] actual ) { array . assert contain null ( info , failure , actual ) ; }
public void assert be exactly instance of ( assertion info info , object actual , class < ? > type ) { if ( ! actual be exactly instance of type ( actual , type , info ) ) throw failure . failure ( info , should be exactly instance ( actual , type ) ) ; }
public void assert be not in ( assertion info info , object actual , object [ ] value ) { check be not null and not empty ( value ) ; assert be not in ( info , actual , a list ( value ) ) ; }
public string to string ( string pattern ) { if ( pattern == null ) { return to string ( ) ; } return date time format . for pattern ( pattern ) . print ( this ) ; }
public static date truncate time ( date date ) { if ( date == null ) return null ; calendar cal = to calendar ( date ) ; cal . set ( calendar . hour_of_day , 0 ) ; cal . set ( calendar . minute , 0 ) ; cal . set ( calendar . second , 0 ) ; cal . set ( calendar . millisecond , 0 ) ; return cal . get time ( ) ; }
public static int hour of day of ( date date ) { return to calendar ( date ) . get ( calendar . hour_of_day ) ; }
public void add delta ( delta < t > delta ) { delta . add ( delta ) ; }
public static void set allow extract private field ( boolean allow extract private field ) { field support . extraction ( ) . set allow use private field ( allow extract private field ) ; }
private static object read field ( field field , object target , boolean force access ) throw illegal access exception { check argument ( field ! = null , `` the field must not be null `` ) ; if ( force access & & ! field . be accessible ( ) ) { field . set accessible ( true ) ; } else { member utils . set accessible workaround ( field ) ; } return field . get ( target ) ; }
public self have size great than or equal to ( int boundary ) { array . assert have size great than or equal to ( info , actual , boundary ) ; return myself ; }
public self have size less than or equal to ( int boundary ) { iterables . assert have size less than or equal to ( info , actual , boundary ) ; return myself ; }
public self contain only once ( @ suppress warning ( `` unchecked `` ) element . . . value ) { array . assert contain only once ( info , actual , value ) ; return myself ; }
public self have field or property ( string name ) { object . assert have field or property ( info , actual , name ) ; return myself ; }
public void set keystore ( final string keystore ) { this . keystore = keystore ; }
public void set storepass ( final string storepass ) { this . storepass = storepass ; }
public void set storetype ( final string storetype ) { this . storetype = storetype ; }
public void set keypass ( final string keypass ) { this . keypass = keypass ; }
public set < field location > get ignore field ( ) { return ignore field ; }
public self ignore field match regexes ( string . . . regexes ) { recursive comparison configuration . ignore field match regexes ( regexes ) ; return myself ; }
public self ignore field match regexes ( string . . . regexes ) { recursive comparison configuration . ignore field match regexes ( regexes ) ; return myself ; }
public self with comparator for field ( comparator < ? > comparator , string . . . field location ) { recursive comparison configuration . register comparator for field ( comparator , field location ) ; return myself ; }
public void assert be file ( assertion info info , file actual ) { assert not null ( info , actual ) ; if ( actual . be file ( ) ) return ; throw failure . failure ( info , should be file ( actual ) ) ; }
public static class [ ] primitives to wrapper ( class [ ] class ) { if ( class == null ) { return null ; } if ( class . length == 0 ) { return class ; } class [ ] convert class = new class [ class . length ] ; for ( int i = 0 ; i < class . length ; i++ ) { converted class [ i ] = primitive to wrapper ( class [ i ] ) ; } return converted class ; }
public < t > self use comparator for element field with type ( comparator < t > comparator , class < t > type ) { get comparators for element property or field type ( ) . put ( type , comparator ) ; return myself ; }
public self have only field ( string . . . expected field name ) { object . assert have only field ( info , actual , expect field name ) ; return myself ; }
public atomic reference array assert < t > contains ( t value , index index ) { array . assert contains ( info , array , value , index ) ; return myself ; }
protect boolean have resource ( ) { return path ! = null || filesets . size ( ) > 0 ; }
public self be equal to ignore give field ( object other , string . . . property or field to ignore ) { object . assert be equal to ignore give field ( info , actual , other , comparator by property or field , comparator by type , property or field to ignore ) ; return myself ; }
public self have field or property ( string name ) { object . assert have field or property ( info , actual , name ) ; return myself ; }
public self have only field ( string . . . expected field name ) { object . assert have only field ( info , actual , expect field name ) ; return myself ; }
public self be equal to compare field by field recursively ( object other ) { object . assert be equal to compare field by field recursively ( info , actual , other , comparator by property or field , get comparators by type ( ) ) ; return myself ; }
public self be close to ( long expect , offset < long > offset ) { longs . assert be close to ( info , actual , expect , offset ) ; return myself ; }
public atomic reference array assert < t > contains ( @ suppress warning ( `` unchecked `` ) t . . . value ) { array . assert contains ( info , array , value ) ; return myself ; }
public property create property ( ) { property p = new property ( true , get project ( ) ) ; p . set project ( get new project ( ) ) ; p . set task name ( `` property `` ) ; property . add element ( p ) ; return p ; }
public void set ( final object context , final t value ) { expunge stale entry ( ) ; map . put ( new context ref ( context ) , value ) ; }
public final boolean exit ( ) { if ( ! in queue ) return false ; in queue = false ; return cancel schedule timeout ( this ) ; }
public block queue < runnable > get block queue ( int max queue size ) { / * * we be use synchronous queue if max queue size < = 0 ( mean a queue be not want ) . * < p > * synchronous queue will do a handoff from call thread to worker thread and not allow queue which be what we want . * < p > * queue result in added latency and would only occur when the thread-pool be full at which point there be latency issue * and reject be the preferred solution . * / if ( max queue size < = 0 ) { return new synchronous queue < runnable > ( ) ; } else { return new link block queue < runnable > ( max queue size ) ; } }
public static void catch uncaught exception by default ( ) { default catch uncaught exception = true ; }
public condition factory timeout ( duration timeout ) { return new condition factory ( alias , timeout , poll interval , poll delay , catch uncaught exception , condition evaluation listener ) ; }
public static field supplier builder field in ( object object ) { return new field supplier builder ( object ) ; }
public static field get field annotate with ( object object , class < ? extend annotation > annotation type ) { return find single field use strategy ( new field annotation matcher strategy ( annotation type ) , object , true , get type ( object ) ) ; }
public static class get target class ( object o ) { return ( o == null ) ? null : ( ( o instanceof class ) ? ( class ) o : o . get class ( ) ) ; }
public static void ignore exception by default ( ) { default exception ignorer = new predicate exception ignorer ( e - > true ) ; }
public condition factory during ( duration timeout ) { return new condition factory ( alias , timeout constraint . with hold predicate time ( timeout ) , poll interval , poll delay , catch uncaught exception , exception ignorer , condition evaluation listener , executor lifecycle ) ; }
public asm visitor wrapper . for declared method on ( element matcher < ? super method description > matcher ) { return new asm visitor wrapper . for declared method ( ) . method ( matcher , this ) ; }
public modifier adjustment with constructor modifier ( element matcher < ? super method description > matcher , modifier contributor . for method . . . modifier contributor ) { return with constructor modifier ( matcher , arrays . a list ( modifier contributor ) ) ; }
public modifier adjustment with invokable modifier ( modifier contributor . for method . . . modifier contributor ) { return with invokable modifier ( array . a list ( modifier contributor ) ) ; }
public static type reference adjustment relaxed ( ) { return new type reference adjustment ( false , none ( ) ) ; }
public < t > dynamic type . builder < t > subclass ( class < t > super type ) { return ( dynamic type . builder < t > ) subclass ( type description . for loaded type . of ( super type ) ) ; }
public < t > dynamic type . builder < t > redefine ( class < t > type ) { return redefine ( type , class file locator . for class loader . of ( type . get class loader ( ) ) ) ; }
public stack manipulation for each ( list < ? extend stack manipulation > process instruction ) { list < stack manipulation > stack manipulation = new array list < stack manipulation > ( process instruction . size ( ) ) ; int index = 0 ; for ( stack manipulation process instruction : process instruction ) { stack manipulation . add ( new stack manipulation . compound ( duplication . single , integer constant . for value ( index++ ) , new loader ( ) , process instruction ) ) ; } return new stack manipulation . compound ( stack manipulation ) ; }
public static stack manipulation of ( type definition type definition ) { if ( type definition . be primitive ( ) ) { if ( type definition . represent ( long . class ) ) { return long ; } else if ( type definition . represent ( double . class ) ) { return double ; } else if ( type definition . represent ( float . class ) ) { return float ; } else if ( type definition . represent ( void . class ) ) { return void ; } else { return integer ; } } else { return reference ; } }
public equal method with primitive typed field first ( ) { return with field order ( type property comparator . for_primitive_types ) ; }
public void set factory ( string factory ) { this . factory = factory ; }
public method call with argument array ( ) { return with ( argument loader . for method parameter array . for instrumented method . instance ) ; }
public static < t extend type definition > element matcher . junction < t > be array ( ) { return new array type matcher < t > ( ) ; }
protect void on visit int insn ( int opcode , int operand ) { super . visit int insn ( opcode , operand ) ; }
public void visit table switch insn ( final int min , final int max , final label dflt , final label . . . label ) { if ( mv ! = null ) { mv . visit table switch insn ( min , max , dflt , label ) ; } }
public double miss rate ( ) { long request count = request count ( ) ; return ( request count == 0 ) ? 0 . 0 : ( double ) miss count / request count ; }
public long eviction weight ( ) { return eviction weight ; }
public caffeine < k , v > expire after access ( @ non null duration duration ) { return expire after access ( saturate to nanos ( duration ) , time unit . nanosecond ) ; }
public void set adl ( final string adl ) { if ( adl name nest ! = null || adl name ! = null ) throw new build exception ( `` adl to compile can not be specify twice . `` ) ; adl name = adl ; }
public static i18n conversion category union ( i18n conversion category a , i18n conversion category b ) { if ( a == unused || b == unused ) { return unused ; } if ( a == general || b == general ) { return general ; } if ( a == date || b == date ) { return date ; } return number ; }
public static u byte value of ( string value ) throw number format exception { return value of unchecked ( range check ( short . parse short ( value ) ) ) ; }
public static string to unsigned string ( @ unsigned short s ) { return long . to string ( short . to unsigned long ( s ) ) ; }
public resolve method [ ] get static method ( ) { if ( _static method == null ) { _static method = resolve static method ( ) ; } return _static method ; }
protect void register know jdk immutable class ( ) { register immutable ( string . class ) ; register immutable ( integer . class ) ; register immutable ( long . class ) ; register immutable ( boolean . class ) ; register immutable ( class . class ) ; register immutable ( float . class ) ; register immutable ( double . class ) ; register immutable ( character . class ) ; register immutable ( byte . class ) ; register immutable ( short . class ) ; register immutable ( void . class ) ; register immutable ( big decimal . class ) ; register immutable ( big integer . class ) ; register immutable ( uri . class ) ; register immutable ( url . class ) ; register immutable ( uuid . class ) ; register immutable ( pattern . class ) ; }
public < t > t shallow clone ( final t o ) { if ( o == null ) return null ; if ( ! clone enable ) return o ; try { return clone internal ( o , null ) ; } catch ( final illegal access exception e ) { throw new clone exception ( `` error during cloning of `` + o , e ) ; } }
public string get channel name ( ) { return broadcast channel ; }
public void add comet listener ( comet listener listener ) { _comet listener . add ( listener ) ; }
public void update transient timeout ( long timeout ) { _transient timeout = timeout ; }
public static string retrieve event ( string id ) { return `` select * from `` + events_table_name + `` where `` + events_id_key + `` = `` + format text value ( id ) + `` ; `` ; }
public void add tag ( string p tag ) { if ( tags == null ) { tags = new hash set < string > ( ) ; } tag . add ( p tag ) ; }
public void add attachment ( attachment attachment ) { if ( attachment == null ) { attachment = new hash set < attachment > ( ) ; } attachment . add ( attachment ) ; }
public static void deactivate online ( ) { online activate = false ; }
public void reset and log ( string label ) { logger . fine ( label + `` : `` + reset ( ) + `` ms `` ) ; }
public boolean contains ( string name , string key ) { object value = value . get ( name ) ; if ( value == null ) { throw new null pointer exception ( `` no mapped value for ' `` + name + `` ( `` + key + `` ) ' `` ) ; } else if ( value instanceof map ) { return ( ( ( map ) value ) . contains key ( key ) ) ; } else { throw new illegal argument exception ( `` non-mapped property for ' `` + name + `` ( `` + key + `` ) ' `` ) ; } }
public void set ( string name , object value ) { dyna property descriptor = get dyna property ( name ) ; if ( value == null ) { if ( descriptor . get type ( ) . be primitive ( ) ) { throw new null pointer exception ( `` primitive value for ' `` + name + `` ' `` ) ; } } else if ( ! be assignable ( descriptor . get type ( ) , value . get class ( ) ) ) { throw new conversion exception ( `` can not assign value of type ' `` + value . get class ( ) . get name ( ) + `` ' to property ' `` + name + `` ' of type ' `` + descriptor . get type ( ) . get name ( ) + `` ' `` ) ; } value . put ( name , value ) ; }
public int hash code ( ) { int result ; result = comparator . hash code ( ) ; return result ; }
public string to string ( ) { return `` `` +get key ( ) + `` = `` +get value ( ) ; }
public static boolean be writeable ( object bean , string name ) { return property utils bean . get instance ( ) . be writeable ( bean , name ) ; }
public static void set cache fast ( map map , boolean fast ) { if ( map instanceof weak fast hash map ) { ( ( weak fast hash map ) map ) . set fast ( fast ) ; } }
public locale convert utils bean get locale convert utils ( ) { return locale convert utils ; }
public string map path ( string path ) { return null ; }
public string to string ( ) { return to string ( get class ( ) ) + `` [ use default= `` + use default + `` ] `` ; }
public time zone get time zone ( ) { return time zone ; }
public locale get locale ( ) { return locale ; }
public void set locale ( locale locale ) { this . locale = locale ; set use locale format ( true ) ; }
protect string convert to string ( object value ) throw throwable { string result = null ; if ( use locale format & & value instanceof number ) { number format format = get format ( ) ; format . set group use ( false ) ; result = format . format ( value ) ; if ( log ( ) . be debug enable ( ) ) { log ( ) . debug ( `` convert to string use format ' `` + result + `` ' `` ) ; } } else { result = value . to string ( ) ; if ( log ( ) . be debug enable ( ) ) { log ( ) . debug ( `` convert to string use to string ( ) ' `` + result + `` ' `` ) ; } } return result ; }
public static byte get default byte ( ) { return convert utils bean . get instance ( ) . get default byte ( ) ; }
public static void set default short ( short new default short ) { convert utils bean . get instance ( ) . set default short ( new default short ) ; }
public class get content type ( ) { return content type ; }
public boolean be indexed ( ) { if ( type == null ) { return ( false ) ; } else if ( type . be array ( ) ) { return ( true ) ; } else if ( list . class . be assignable from ( type ) ) { return ( true ) ; } else { return ( false ) ; } }
public boolean check end with ( final string str , final string end ) { if ( str == null || end == null ) { return false ; } final int end len = end . length ( ) ; return str . region match ( ! sensitive , str . length ( ) - end len , end , 0 , end len ) ; }
public boolean start with ( string str ) { if ( str == null ) { return false ; } int len = str . length ( ) ; if ( len == 0 ) { return true ; } if ( len > size ) { return false ; } for ( int i = 0 ; i < len ; i++ ) { if ( buffer [ i ] ! = str . char at ( i ) ) { return false ; } } return true ; }
public void set restrict ( boolean restrict ) { this . restrict = restrict ; }
public boolean add all ( collection collection ) { if ( collection == null || collection . size ( ) == 0 ) { return false ; } ensure capacity ( size ( ) + collection . size ( ) ) ; iterator iterator = collection . iterator ( ) ; while ( iterator . have next ( ) ) { add ( iterator . next ( ) ) ; } return true ; }
public string convert ( object value ) { return convert ( value , default locale , null ) ; }
public method get map read method ( ) { return map read method ref . get ( ) ; }
public void set map read method ( method map getter ) throw introspection exception { map read method ref = new map method reference ( mapped getter ) ; find mapped property type ( ) ; }
protect static convert utils bean get instance ( ) { return bean utils bean . get instance ( ) . get convert utils ( ) ; }
public object get ( string name ) { if ( dyna class . get dyna property ( name ) == null ) { throw new illegal argument exception ( name ) ; } try { return dyna class . get object from result set ( name ) ; } catch ( s q l exception e ) { throw new runtime exception ( `` get ( `` + name + `` ) : s q l exception : `` + e ) ; } }
public object clone ( ) { weak fast hash map result = null ; if ( fast ) { result = new weak fast hash map ( map ) ; } else { synchronize ( map ) { result = new weak fast hash map ( map ) ; } } result . set fast ( get fast ( ) ) ; return ( result ) ; }
public dyna class get dyna class ( ) { return ( this . dyna class ) ; }
public int get desc padding ( ) { return default desc pad ; }
public void print help ( string cmd line syntax , option option ) { print help ( get width ( ) , cmd line syntax , null , option , null , false ) ; }
public void print help ( string cmd line syntax , option option ) { print help ( get width ( ) , cmd line syntax , null , option , null , false ) ; }
public string get opt ( ) { return opt ; }
public option add option ( string opt , boolean have arg , string description ) { add option ( opt , null , have arg , description ) ; return this ; }
public byte [ ] encode ( final byte [ ] raw ) { return to ascii byte ( raw ) ; }
public static string crypt ( final byte [ ] original ) { return crypt ( original , null ) ; }
public static message digest get sha3_256 digest ( ) { return get digest ( message digest algorithms . sha3_256 ) ; }
public static void update checksum ( crc32 checksum , byte buffer buffer ) { int position = buffer . position ( ) ; checksum . update ( buffer ) ; buffer . position ( position ) ; }
public static mac get hmac sha512 ( final byte [ ] key ) { return get initialize mac ( hmac algorithm . hmac_sha_512 , key ) ; }
public static string hmac sha384 hex ( final byte [ ] key , final byte [ ] value to digest ) { return hex . encode hex string ( hmac sha384 ( key , value to digest ) ) ; }
public static string hmac sha256 hex ( final byte [ ] key , final byte [ ] value to digest ) { return hex . encode hex string ( hmac sha256 ( key , value to digest ) ) ; }
public static string sha512 crypt ( final byte [ ] key byte , string salt ) { if ( salt == null ) { salt = sha512_prefix + b64 . get random salt ( 8 ) ; } return sha2 crypt ( key byte , salt , sha512_prefix , sha512_blocksize , message digest algorithm . sha_512 ) ; }
public void set max phoneme ( final int max phoneme ) { this . engine = new phonetic engine ( this . engine . get name type ( ) , this . engine . get rule type ( ) , this . engine . be concat ( ) , max phoneme ) ; }
public void set rule type ( final rule type rule type ) { this . engine = new phonetic engine ( this . engine . get name type ( ) , rule type , this . engine . be concat ( ) , this . engine . get max phoneme ( ) ) ; }
public string get name ( ) { return this . name ; }
public r pattern get l context ( ) { return this . l context ; }
public int get max length ( ) { return this . max length ; }
public string get default charset ( ) { return this . charset ; }
public static final byte [ ] encode quote printable ( bit set printable , final byte [ ] bytes ) { return encode quote printable ( printable , byte , false ) ; }
protect static byte [ ] create password ( byte [ ] identifier , secret key key ) { mac mac = thread local mac . get ( ) ; try { mac . init ( key ) ; } catch ( invalid key exception ike ) { throw new illegal argument exception ( `` invalid key to hmac computation `` , ike ) ; } return mac . do final ( identifier ) ; }
public static message digest get sha3_512 digest ( ) { return get digest ( message digest algorithms . sha3_512 ) ; }
public static message digest get sha3_512 digest ( ) { return get digest ( message digest algorithms . sha3_512 ) ; }
public static string sha512 hex ( final byte [ ] data ) { return hex . encode hex string ( sha512 ( data ) ) ; }
public boolean be encode blank ( ) { return this . encode blank ; }
public void clear ( ) { mod count++ ; map . clear ( ) ; size = 0 ; }
public iterator iterator ( ) { return new bag iterator ( this ) ; }
public boolean remove ( final object object ) { final mutable integer mut = map . get ( object ) ; if ( mut == null ) { return false ; } mod count++ ; map . remove ( object ) ; size -= mut . value ; return true ; }
public static < e > sort bag < e > collection sort bag ( final sort bag < e > bag ) { return new collection sort bag < > ( bag ) ; }
public boolean equal ( final object obj ) { return this . do equal ( obj , key ) ; }
public v get ( final object key ) { check key ( key ) ; final node < k , v > node = lookup key ( key ) ; return node == null ? null : node . get value ( ) ; }
public k next key ( final k key ) { check key ( key ) ; final node < k , v > node = next great ( lookup key ( key ) , key ) ; return node == null ? null : node . get key ( ) ; }
public int hash code ( ) { return this . do hash code ( key ) ; }
public void remove composited ( final collection < e > coll ) { all . remove ( coll ) ; }
public list < set < e > > get set ( ) { return unmodifiable list . unmodifiable list ( all ) ; }
protect o transform ( final i source ) { return transformer . transform ( source ) ; }
public static < e > boolean contains ( final iterable < e > iterable , final object object ) { if ( iterable instanceof collection < ? > ) { return ( ( collection < e > ) iterable ) . contains ( object ) ; } return iterator utils . contains ( empty iterator if null ( iterable ) , object ) ; }
public static < o > collection < o > select ( final iterable < ? extend o > input collection , final predicate < ? super o > predicate ) { final collection < o > answer = input collection instanceof collection < ? > ? new array list < o > ( ( ( collection < ? > ) input collection ) . size ( ) ) : new array list < o > ( ) ; return select ( input collection , predicate , answer ) ; }
public t create ( ) { return i constant ; }
public fluent iterable < e > unique ( ) { return of ( iterable utils . unique iterable ( iterable ) ) ; }
public e [ ] to array ( final class < e > array class ) { return iterator utils . to array ( iterator ( ) , array class ) ; }
public fluent iterable < e > append ( final iterable < ? extend e > other ) { return of ( iterable utils . chain iterable ( iterable , other ) ) ; }
public boolean evaluate ( final t object ) { return i predicate1 . evaluate ( object ) || i predicate2 . evaluate ( object ) ; }
public void execute ( final e input ) { if ( i do loop ) { i closure . execute ( input ) ; } while ( i predicate . evaluate ( input ) ) { i closure . execute ( input ) ; } }
public boolean evaluate ( final t object ) { for ( final predicate < ? super t > i predicate : i predicate ) { if ( i predicate . evaluate ( object ) ) { return true ; } } return false ; }
public t transform ( final t input ) { i closure . execute ( input ) ; return input ; }
public boolean evaluate ( final t object ) { if ( object == null ) { throw new functor exception ( `` input object must not be null `` ) ; } return i predicate . evaluate ( object ) ; }
public void execute ( final e input ) { if ( i do loop ) { i closure . execute ( input ) ; } while ( i predicate . evaluate ( input ) ) { i closure . execute ( input ) ; } }
public static < e > iterable < e > loop iterable ( final iterable < e > iterable ) { check not null ( iterable ) ; return new fluent iterable < e > ( ) { @ override public iterator < e > iterator ( ) { return new lazy iterator chain < e > ( ) { @ override protect iterator < ? extend e > next iterator ( final int count ) { if ( iterable utils . be empty ( iterable ) ) { return null ; } return iterable . iterator ( ) ; } } ; } } ; }
public static < e > boolean match any ( final iterable < e > iterable , final predicate < ? super e > predicate ) { return iterator utils . match any ( empty iterator if null ( iterable ) , predicate ) ; }
public static < e > boolean contains ( final iterable < ? extend e > iterable , final e object , final equator < ? super e > equator ) { if ( equator == null ) { throw new null pointer exception ( `` equator must not be null . `` ) ; } return match any ( iterable , equal predicate . equal predicate ( object , equator ) ) ; }
public static < e > boolean contains ( final iterable < e > iterable , final object object ) { if ( iterable instanceof collection < ? > ) { return ( ( collection < e > ) iterable ) . contains ( object ) ; } return iterator utils . contains ( empty iterator if null ( iterable ) , object ) ; }
public boolean have previous ( ) { return this . index > this . start index ; }
public void reset ( ) { this . index = this . start index ; }
public void remove ( ) { if ( last use iterator == null ) { throw new illegal state exception ( `` iterator remove ( ) can not be call at this time `` ) ; } last used iterator . remove ( ) ; last used iterator = null ; }
public void reset ( ) { iterator = collection . iterator ( ) ; }
public void reset ( ) { iterator = collection . iterator ( ) ; }
public boolean have next ( ) { lock chain ( ) ; update current iterator ( ) ; last used iterator = current iterator ; return current iterator . have next ( ) ; }
public e next ( ) throw no such element exception { if ( iterator instanceof list iterator ) { return iterator . next ( ) ; } if ( current index < wrap iterator index ) { ++current index ; return list . get ( current index - 1 ) ; } final e retval = iterator . next ( ) ; list . add ( retval ) ; ++current index ; ++wrapped iterator index ; remove state = true ; return retval ; }
public e next ( ) { if ( list . be empty ( ) ) { throw new no such element exception ( `` there be no element for this iterator to loop on `` ) ; } if ( iterator . have next ( ) == false ) { reset ( ) ; } return iterator . next ( ) ; }
public void reset ( ) { iterator = collection . iterator ( ) ; }
public void reset ( ) { iterator = collection . iterator ( ) ; }
public boolean have next ( ) { update current iterator ( ) ; return have next ; }
public boolean have previous ( ) { return ! before first & & ! remove ; }
public e next ( ) { if ( ! before first || remove ) { throw new no such element exception ( ) ; } before first = false ; return object ; }
protect int get maximum cache size ( ) { return maximum cache size ; }
protect void remove node ( final node < e > node ) { super . remove node ( node ) ; add node to cache ( node ) ; }
public e remove ( final int index ) { mod count++ ; check interval ( index , 0 , size ( ) - 1 ) ; final e result = get ( index ) ; root = root . remove ( index ) ; size -- ; return result ; }
public static string [ ] to string array ( final collection < lang tag > lang tag ) { if ( lang tag == null ) return null ; string [ ] out = new string [ lang tag . size ( ) ] ; int i=0 ; for ( lang tag lt : lang tag ) { out [ i++ ] = lt . to string ( ) ; } return out ; }
public boolean add all ( final collection < ? extend e > coll ) { return add all ( size ( ) , coll ) ; }
public set < k > key set ( ) { if ( key set == null ) { key set = new reference key set < > ( this ) ; } return key set ; }
public int hash code ( ) { int code = 0 ; for ( final map . entry < k , v > entry : entry set ( ) ) { code += entry . hash code ( ) ; } return code ; }
public boolean get curly brace denote code block ( int language index ) { return true ; }
protect void add entry ( hash entry entry , int hash index ) { link entry link = ( link entry ) entry ; link . after = header ; link . before = header . before ; header . before . after = link ; header . before = link ; data [ hash index ] = entry ; }
protect void purge ( ) { reference < ? > ref = queue . poll ( ) ; while ( ref ! = null ) { purge ( ref ) ; ref = queue . poll ( ) ; } }
public v remove ( final object key ) { for ( int i = this . composite . length - 1 ; i > = 0 ; -- i ) { if ( this . composite [ i ] . contains key ( key ) ) { return this . composite [ i ] . remove ( key ) ; } } return null ; }
public k next key ( final object key ) { final int index = insert order . index of ( key ) ; if ( index > = 0 & & index < size ( ) - 1 ) { return insert order . get ( index + 1 ) ; } return null ; }
public list < v > value list ( ) { return new value view < > ( this ) ; }
public string to string ( ) { iterator < entry < type k , type v > > i = entry set ( ) . iterator ( ) ; if ( ! i . have next ( ) ) return `` { } `` ; string builder sb = new string builder ( ) ; sb . append ( ' { ' ) ; for ( ; ; ) { entry < type k , type v > e = i . next ( ) ; type k key = e . get key ( ) ; type v value = e . get value ( ) ; sb . append ( key == this ? `` ( this map ) `` : key ) ; sb . append ( '= ' ) ; sb . append ( value == this ? `` ( this map ) `` : value ) ; if ( ! i . have next ( ) ) return sb . append ( ' } ' ) . to string ( ) ; sb . append ( `` , `` ) ; } }
public boolean be full ( ) { return size > = max size ; }
protect int get hash ( object o ) { int hash = o == null ? 0 : o . hash code ( ) ; hash += ( hash < < 15 ) ^ 0xffffcd7d ; hash ^= ( hash > > > 10 ) ; hash += ( hash < < 3 ) ; hash ^= ( hash > > > 6 ) ; hash += ( hash < < 2 ) + ( hash < < 14 ) ; hash ^= ( hash > > > 16 ) ; return hash ; }
public static void check args ( string field , object low point , object upper point ) { if ( field == null ) { throw new illegal argument exception ( `` field must not be null `` ) ; } if ( low point == null ) { throw new illegal argument exception ( `` low point must not be null `` ) ; } if ( upper point == null ) { throw new illegal argument exception ( `` upper point must not be null `` ) ; } }
protect v check set value ( final v value ) { if ( value predicate . evaluate ( value ) == false ) { throw new illegal argument exception ( `` can not set value - predicate reject it `` ) ; } return value ; }
public collection < v > value ( ) { return new value ( ) ; }
public static byte get byte value ( final map map , final object key , byte default value ) { byte byte object = get byte ( map , key ) ; if ( byte object == null ) { return default value ; } return byte object . byte value ( ) ; }
public static short get short value ( final map map , final object key , short default value ) { short short object = get short ( map , key ) ; if ( short object == null ) { return default value ; } return short object . short value ( ) ; }
public static int get int value ( final map map , final object key , int default value ) { integer integer object = get integer ( map , key ) ; if ( integer object == null ) { return default value ; } return integer object . int value ( ) ; }
public boolean put ( final k key , final v value ) { collection < v > coll = get map ( ) . get ( key ) ; if ( coll == null ) { coll = create collection ( ) ; if ( coll . add ( value ) ) { map . put ( key , coll ) ; return true ; } return false ; } return coll . add ( value ) ; }
public list < v > get ( final k key ) { return wrap collection ( key ) ; }
public set < entry < e > > entry set ( ) { if ( entry set == null ) { entry set = create entry set ( ) ; } return entry set ; }
public static < e > synchronize multi set < e > synchronize multi set ( final multi set < e > multiset ) { return new synchronize multi set < > ( multiset ) ; }
public static < t > predicate < t > not null predicate ( ) { return not null predicate . not null predicate ( ) ; }
public static < e > boolean contains ( final iterator < e > iterator , final object object ) { return match any ( iterator , equal predicate . equal predicate ( object ) ) ; }
public static < t > predicate < t > not predicate ( final predicate < ? super t > predicate ) { return not predicate . not predicate ( predicate ) ; }
protect queue < e > get queue ( ) { return ( queue < e > ) decorate ( ) ; }
public boolean add ( final e element ) { if ( null == element ) { throw new null pointer exception ( `` attempt to add null object to queue `` ) ; } if ( be at full capacity ( ) ) { remove ( ) ; } elements [ end++ ] = element ; if ( end > = max element ) { end = 0 ; } if ( end == start ) { full = true ; } return true ; }
public void accept ( final command visitor < t > visitor ) { visitor . visit insert command ( get object ( ) ) ; }
protect navigable set < e > decorate ( ) { return ( navigable set < e > ) super . decorate ( ) ; }
public boolean add all ( final collection < ? extend e > coll ) { if ( mutator == null ) { throw new unsupported operation exception ( `` add all ( ) be not support on composite set without a set mutator strategy `` ) ; } return mutator . add all ( this , all , coll ) ; }
protect set mutator < e > get mutator ( ) { return mutator ; }
public synchronize void add composited ( collection c ) { if ( ! ( c instanceof set ) ) { throw new illegal argument exception ( `` collection add must implement java . util . set `` ) ; } for ( iterator i = this . get collection ( ) . iterator ( ) ; i . have next ( ) ; ) { set set = ( set ) i . next ( ) ; collection intersect = collection utils . intersection ( set , c ) ; if ( intersects . size ( ) > 0 ) { if ( this . mutator == null ) { throw new unsupported operation exception ( `` collision add composited collection with no set mutator set `` ) ; } else if ( ! ( this . mutator instanceof set mutator ) ) { throw new unsupported operation exception ( `` collision add composited collection to a composite set with a collection mutator instead of a set mutator `` ) ; } ( ( set mutator ) this . mutator ) . resolve collision ( this , set , ( set ) c , intersects ) ; if ( collection utils . intersection ( set , c ) . size ( ) > 0 ) { throw new illegal argument exception ( `` attempt to add illegal entry unresolved by set mutator . resolve collision ( ) `` ) ; } } } super . add composited ( new collection [ ] { c } ) ; }
public synchronize void add composited ( collection c ) { if ( ! ( c instanceof set ) ) { throw new illegal argument exception ( `` collection add must implement java . util . set `` ) ; } for ( iterator i = this . get collection ( ) . iterator ( ) ; i . have next ( ) ; ) { set set = ( set ) i . next ( ) ; collection intersect = collection utils . intersection ( set , c ) ; if ( intersects . size ( ) > 0 ) { if ( this . mutator == null ) { throw new unsupported operation exception ( `` collision add composited collection with no set mutator set `` ) ; } else if ( ! ( this . mutator instanceof set mutator ) ) { throw new unsupported operation exception ( `` collision add composited collection to a composite set with a collection mutator instead of a set mutator `` ) ; } ( ( set mutator ) this . mutator ) . resolve collision ( this , set , ( set ) c , intersects ) ; if ( collection utils . intersection ( set , c ) . size ( ) > 0 ) { throw new illegal argument exception ( `` attempt to add illegal entry unresolved by set mutator . resolve collision ( ) `` ) ; } } } super . add composited ( new collection [ ] { c } ) ; }
public static transformer instantiate transformer ( class [ ] param type , object [ ] args ) { return instantiate transformer . get instance ( param type , args ) ; }
public archive input stream create archive input stream ( final input stream in ) throw archive exception { return create archive input stream ( detect ( in ) , in ) ; }
public int get count ( ) { return ( int ) bytes write ; }
protect void count ( final int read ) { count ( ( long ) read ) ; }
public void set mode ( final int mode ) { this . mode = mode & 07777 ; this . permission = permission . find ( mode ) ; }
public void set mode ( final int mode ) { this . mode = mode & 07777 ; this . permission = permission . find ( mode ) ; }
public void set offset ( final long offset ) { this . offset = offset ; }
public date get last modified date ( ) { return new date ( mtime ) ; }
public int get volume ( ) { return volume ; }
public boolean be anti item ( ) { return be anti item ; }
public void set access date ( final long ntfs access date ) { this . access date = ntfs access date ; }
public seven z archive entry get next entry ( ) throw i o exception { if ( current entry index > = archive . file . length - 1 ) { return null ; } ++current entry index ; final seven z archive entry entry = archive . file [ current entry index ] ; build decode stream ( ) ; uncompressed byte read from current entry = compress byte read from current entry = 0 ; return entry ; }
public void set content method ( final iterable < ? extend seven z method configuration > method ) { this . content method = reverse ( method ) ; }
public void set content method ( final iterable < ? extend seven z method configuration > method ) { this . content method = reverse ( method ) ; }
public void put archive entry ( final archive entry archive entry ) throw i o exception { if ( finish ) { throw new i o exception ( `` stream have already be finish `` ) ; } final tar archive entry entry = ( tar archive entry ) archive entry ; if ( entry . be global pax header ( ) ) { final byte [ ] data = encode extend pax header content ( entry . get extra pax header ( ) ) ; entry . set size ( data . length ) ; entry . write entry header ( record buf , zip encoding , big number mode == bignumber_star ) ; write record ( record buf ) ; curr size= entry . get size ( ) ; curr bytes = 0 ; this . have unclosed entry = true ; write ( data ) ; close archive entry ( ) ; } else { final map < string , string > pax header = new hash map < > ( ) ; final string entry name = entry . get name ( ) ; final boolean pax header contain path = handle long name ( entry , entry name , pax header , `` path `` , tar constant . lf_gnutype_longname , `` file name `` ) ; final string link name = entry . get link name ( ) ; final boolean pax header contain link path = link name ! = null & & link name . length ( ) > 0 & & handle long name ( entry , link name , pax header , `` linkpath `` , tar constant . lf_gnutype_longlink , `` link name `` ) ; if ( big number mode == bignumber_posix ) { add pax header for big number ( pax header , entry ) ; } else if ( big number mode ! = bignumber_star ) { fail for big number ( entry ) ; } if ( add pax header for non ascii name & & ! pax header contain path & & ! ascii . can encode ( entry name ) ) { pax header . put ( `` path `` , entry name ) ; } if ( add pax header for non ascii name & & ! pax header contain link path & & ( entry . be link ( ) || entry . be symbolic link ( ) ) & & ! ascii . can encode ( link name ) ) { pax header . put ( `` linkpath `` , link name ) ; } pax header . put all ( entry . get extra pax header ( ) ) ; if ( pax header . size ( ) > 0 ) { write pax header ( entry , entry name , pax header ) ; } entry . write entry header ( record buf , zip encoding , big number mode == bignumber_star ) ; write record ( record buf ) ; curr bytes = 0 ; if ( entry . be directory ( ) ) { curr size = 0 ; } else { curr size = entry . get size ( ) ; } curr name = entry name ; have unclosed entry = true ; } }
public boolean allow method change ( ) { return allow method change ; }
public void set access java time ( final date d ) { set access time ( date to zip ( d ) ) ; }
public void set create java time ( final date d ) { set create time ( date to zip ( d ) ) ; }
public void set modify time ( final zip long l ) { bit0_modify time present = l ! = null ; flag = ( byte ) ( l ! = null ? ( flags | modify_time_bit ) : ( flag & ~modify_time_bit ) ) ; this . modify time = l ; }
public void set create time ( final zip long l ) { bit2_create time present = l ! = null ; flag = ( byte ) ( l ! = null ? ( flags | create_time_bit ) : ( flag & ~create_time_bit ) ) ; this . create time = l ; }
public void set modify time ( final zip long l ) { bit0_modify time present = l ! = null ; flag = ( byte ) ( l ! = null ? ( flags | modify_time_bit ) : ( flag & ~modify_time_bit ) ) ; this . modify time = l ; }
public void set g i d ( final long l ) { this . gid = zip util . long to big ( l ) ; }
public void set u i d ( final long l ) { this . uid = zip util . long to big ( l ) ; }
public int get raw flag ( ) { return raw flag ; }
public comment source get comment source ( ) { return comment source ; }
public void delete ( final string filename ) { add deletion ( new change ( filename , change . type_delete ) ) ; }
protect final int read literal ( final byte [ ] b , final int off , final int len ) throw i o exception { final int avail = available ( ) ; if ( len > avail ) { try to read literal ( len - avail ) ; } return read from buffer ( b , off , len ) ; }
protect final int read literal ( final byte [ ] b , final int off , final int len ) throw i o exception { final int avail = available ( ) ; if ( len > avail ) { try to read literal ( len - avail ) ; } return read from buffer ( b , off , len ) ; }
public int get max back reference length ( ) { return max back reference length ; }
public static boolean be equal ( final byte [ ] buffer1 , final byte [ ] buffer2 , final boolean ignore trail null ) { return be equal ( buffer1 , 0 , buffer1 . length , buffer2 , 0 , buffer2 . length , ignore trail null ) ; }
public static boolean be maximum ( inet address address ) { byte [ ] addr = address . get address ( ) ; for ( int i = 0 ; i < addr . length ; i++ ) { if ( addr [ i ] ! = ( byte ) 0xff ) { return false ; } } return true ; }
public void align with byte boundary ( ) { int to skip = bit cache size % byte . size ; if ( to skip > 0 ) { read cache bit ( to skip ) ; } }
public seven z archive entry get next entry ( ) throw i o exception { if ( current entry index > = archive . file . length - 1 ) { return null ; } ++current entry index ; final seven z archive entry entry = archive . file [ current entry index ] ; build decode stream ( ) ; uncompressed byte read from current entry = compress byte read from current entry = 0 ; return entry ; }
public input stream get input stream ( final tar archive entry entry ) throw i o exception { try { return new bound tar entry input stream ( entry , archive ) ; } catch ( runtime exception ex ) { throw new i o exception ( `` corrupt tar archive . ca n't read entry `` , ex ) ; } }
public zip entry writer zip entry writer ( ) throw i o exception { if ( zip entry writer == null ) { zip entry writer = new zip entry writer ( this ) ; } return zip entry writer ; }
public change set result perform ( final zip file in , final archive output stream out ) throw i o exception { return perform ( new zip file iterator ( in ) , out ) ; }
public list < string > get add from change set ( ) { return add from change set ; }
public static string get uncompressed filename ( final string filename ) { return file name util . get uncompressed filename ( filename ) ; }
public static file write temp file ( string a string ) throw i o exception { return write temp file ( a string , null ) ; } // write temp file ( )
public long cardinality ( ) { return cardinality ; }
public long cardinality ( ) { return cardinality ; }
public void remove late ( ) { final int late = anno_ n . remove ( anno_ n . size ( ) - 1 ) ; for ( int i = 0 ; i < late ; i++ ) { type_ r s . remove ( type_ r s . size ( ) - 1 ) ; final int pair = pair_ n . remove ( pair_ n . size ( ) - 1 ) ; for ( int j = 0 ; j < pair ; j++ ) { remove one pair ( ) ; } } }
protect double get domain low bound ( double p ) { return 0 ; }
public void set backwards call ( final int [ ] backwards call ) throw i o exception { int index = 0 ; parse layout ( ) ; for ( int i = 0 ; i < attribute layout element . size ( ) ; i++ ) { final attribute layout element element = ( attribute layout element ) attribute layout element . get ( i ) ; if ( element instanceof callable & & ( ( callable ) element ) . be backwards callable ( ) ) { ( ( callable ) element ) . add count ( backwards call [ index ] ) ; index++ ; } } }
public int invoke interface count ( ) { return 1 + segment utils . count invoke interface args ( descriptor . underlie string ( ) ) ; }
public string simple class name ( ) { return cache simple class name ; }
public void set s a x logger ( log sax log ) { this . sax log = sax log ; }
public void register ( string public id , url entity u r l ) { if ( log . be debug enable ( ) ) { log . debug ( `` register ( ' `` + public id + `` ' , ' `` + entity u r l + `` ' `` ) ; } entity validator . put ( public id , entity u r l ) ; }
public digester loader set entity resolver ( entity resolver entity resolver ) { this . entity resolver = entity resolver ; return this ; }
public void add set next ( string pattern , string method name ) { add rule ( pattern , new set next rule ( method name ) ) ; }
public void add bean property setter ( string pattern ) { add rule ( pattern , new bean property setter rule ( ) ) ; }
public object peek ( ) { try { return stack . peek ( ) ; } catch ( empty stack exception e ) { log . warn ( sm . get string ( `` digester . empty stack `` ) ) ; return null ; } }
public class get plugin class ( ) { return plugin class ; }
public declaration get declaration by class ( string class name ) { declaration decl = ( declaration ) declaration by class . get ( class name ) ; if ( ( decl == null ) & & ( parent ! = null ) ) { decl = parent . get declaration by class ( class name ) ; } return decl ; }
public digester get digester ( ) { return digester ; }
public digester get digester ( ) { return digester ; }
public list rule ( ) { return decorate rule . rule ( ) ; }
public list match ( string pattern ) { return match ( namespace u r i , pattern ) ; }
public void body ( string body text ) throw exception { any child rule new rule = ( any child rule ) digester . get rule ( ) ; digester . set rule ( new rule . get old rule ( ) ) ; }
public log get log ( ) { return log ; }
public static digester create digester ( input source rule source ) { rule set rule set = new from xml rule set ( rule source ) ; digester digester = new digester ( ) ; digester . add rule set ( rule set ) ; return digester ; }
public void set exact match ( boolean use exact match ) { this . use exact match = use exact match ; }
protect void install ( rule module rule module ) { rule binder . install ( rule module ) ; }
public node create rule provider create node ( ) { return add provider ( new node create rule provider ( key pattern , namespace u r i , main binder , this ) ) ; }
public plugin declaration rule builder declare plugin ( ) { return add provider ( new plugin declaration rule builder ( key pattern , namespace u r i , main binder , this ) ) ; }
public object create builder use default constructor argument ( object . . . default constructor argument ) { if ( default constructor argument == null ) { report error ( `` create object ( ) . use default constructor argument ( object [ ] ) `` , `` null default constructor argument not allow `` ) ; return this ; } this . default constructor argument = default constructor argument ; return this ; }
public digester loader set schema ( schema schema ) { factory . set schema ( schema ) ; return this ; }
public boolean get use context class loader ( ) { return use context class loader ; }
public void set custom content handler ( content handler handler ) { custom content handler = handler ; }
public void register ( string public id , url entity u r l ) { if ( log . be debug enable ( ) ) { log . debug ( `` register ( ' `` + public id + `` ' , ' `` + entity u r l + `` ' `` ) ; } entity validator . put ( public id , entity u r l ) ; }
public void add call method ( string pattern , string method name , int param count , string param type [ ] ) { add rule ( pattern , new call method rule ( method name , param count , param type ) ) ; }
public void set ignore miss property ( boolean ignore miss property ) { this . ignore miss property = ignore miss property ; }
public command line add argument ( final string [ ] add argument , final boolean handle quote ) { if ( add argument ! = null ) { for ( final string add argument : add argument ) { add argument ( add argument , handle quote ) ; } } return this ; }
public void close ( ) throw i o exception { if ( buffer . size ( ) > 0 ) { process buffer ( ) ; } super . close ( ) ; }
public static boolean be lenient enable ( ) { final string lenient = system . get property ( commons_exec_lenient , boolean . true . to string ( ) ) ; return boolean . true . to string ( ) . equal ignore case ( lenient ) ; }
public void process challenge ( final string challenge ) throw malformed challenge exception { string s = auth challenge parser . extract scheme ( challenge ) ; if ( ! s . equal ignore case ( get scheme name ( ) ) ) { throw new malformed challenge exception ( `` invalid `` + get scheme name ( ) + `` challenge : `` + challenge ) ; } this . params = auth challenge parser . extract params ( challenge ) ; }
public void process challenge ( final string challenge ) throw malformed challenge exception { string s = auth challenge parser . extract scheme ( challenge ) ; if ( ! s . equal ignore case ( get scheme name ( ) ) ) { throw new malformed challenge exception ( `` invalid ntlm challenge : `` + challenge ) ; } int i = challenge . index of ( ' ' ) ; if ( i ! = -1 ) { s = challenge . substring ( i , challenge . length ( ) ) ; this . ntlmchallenge = s . trim ( ) ; this . state = type2_msg_received ; } else { this . ntlmchallenge = `` `` ; if ( this . state == uninitiated ) { this . state = initiate ; } else { this . state = fail ; } } }
public void process challenge ( final string challenge ) throw malformed challenge exception { string s = auth challenge parser . extract scheme ( challenge ) ; if ( ! s . equal ignore case ( get scheme name ( ) ) ) { throw new malformed challenge exception ( `` invalid `` + get scheme name ( ) + `` challenge : `` + challenge ) ; } this . params = auth challenge parser . extract params ( challenge ) ; }
public int read ( ) throw i o exception { if ( close ) { throw new i o exception ( `` attempt read from closed stream . `` ) ; } if ( eof ) { return -1 ; } if ( pos > = chunk size ) { next chunk ( ) ; if ( eof ) { return -1 ; } } pos++ ; return in . read ( ) ; }
protect void flush cache with append ( byte buffer to append [ ] , int off , int len ) throw i o exception { byte chunk header [ ] = encode util . get ascii byte ( integer . to hex string ( cache position + len ) + `` \r\n `` ) ; stream . write ( chunk header , 0 , chunk header . length ) ; stream . write ( cache , 0 , cache position ) ; stream . write ( buffer to append , off , len ) ; stream . write ( endchunk , 0 , endchunk . length ) ; cache position = 0 ; }
public string get domain ( ) { return cookie domain ; }
public int get version ( ) { return cookie version ; }
public void clear ( ) { header . clear ( ) ; }
public header [ ] get header ( string name ) { array list header find = new array list ( ) ; for ( iterator header iter = header . iterator ( ) ; header iter . have next ( ) ; ) { header header = ( header ) header iter . next ( ) ; if ( header . get name ( ) . equal ignore case ( name ) ) { header find . add ( header ) ; } } return ( header [ ] ) header find . to array ( new header [ header find . size ( ) ] ) ; }
public void remove request header ( string header name ) { header [ ] header = get request header group ( ) . get header ( header name ) ; for ( int i = 0 ; i < header . length ; i++ ) { get request header group ( ) . remove header ( header [ i ] ) ; } }
public boolean contains header ( string name ) { for ( iterator header iter = header . iterator ( ) ; header iter . have next ( ) ; ) { header header = ( header ) header iter . next ( ) ; if ( header . get name ( ) . equal ignore case ( name ) ) { return true ; } } return false ; }
public synchronize boolean host equal ( final http connection connection ) { if ( connection == null ) { throw new illegal argument exception ( `` connection may not be null `` ) ; } if ( this . host ! = null ) { if ( ! this . host . get host name ( ) . equal ignore case ( connection . get host ( ) ) ) { return false ; } if ( this . host . get port ( ) ! = connection . get port ( ) ) { return false ; } if ( ! this . host . get protocol ( ) . equal ( connection . get protocol ( ) ) ) { return false ; } if ( this . local address ! = null ) { if ( ! this . local address . equal ( connection . get local address ( ) ) ) { return false ; } } else { if ( connection . get local address ( ) ! = null ) { return false ; } } return true ; } else { return false ; } }
public synchronize boolean be proxy set ( ) { return this . proxy host ! = null ; }
public synchronize int get proxy port ( ) { if ( this . proxy host ! = null ) { return this . proxy host . get port ( ) ; } else { return -1 ; } }
public synchronize int get proxy port ( ) { if ( this . proxy host ! = null ) { return this . proxy host . get port ( ) ; } else { return -1 ; } }
public synchronize void set local address ( inet address local address ) { this . local address = local address ; }
public void set http connection manager ( http connection manager http connection manager ) { this . http connection manager = http connection manager ; }
public int get send buffer size ( ) throw socket exception { if ( socket == null ) { return -1 ; } else { return socket . get send buffer size ( ) ; } }
public string get virtual host ( ) { return this . host name ; }
public protocol get protocol ( ) { return protocol in use ; }
public boolean be response available ( ) throw i o exception { log . trace ( `` enter http connection . be response available ( ) `` ) ; if ( this . be open ) { return this . input stream . available ( ) > 0 ; } else { return false ; } }
public input stream get input stream ( ) throw i o exception { log . trace ( `` enter http u r l connection . get input stream ( ) `` ) ; return this . method . get response body a stream ( ) ; }
public synchronize void set connection timeout ( int new timeout in millisecond ) { this . http connection manager . get params ( ) . set connection timeout ( new timeout in millisecond ) ; }
public void flush request output stream ( ) throw i o exception { log . trace ( `` enter http connection . flush request output stream ( ) `` ) ; assert open ( ) ; output stream . flush ( ) ; }
public synchronize void set connection timeout ( int new timeout in millisecond ) { this . http connection manager . get params ( ) . set connection timeout ( new timeout in millisecond ) ; }
public static string get credential charset ( final http params params ) { if ( params == null ) { throw new illegal argument exception ( `` http parameter may not be null `` ) ; } string charset = ( string ) params . get parameter ( auth p name . credential_charset ) ; if ( charset == null ) { charset = http . default_protocol_charset ; } return charset ; }
public boolean get do authentication ( ) { return do authentication ; }
public header [ ] get response header ( ) { return get response header group ( ) . get all header ( ) ; }
public boolean get curly brace denote code block ( int language index ) { return true ; }
public string get escape user ( ) { char [ ] user = get raw user ( ) ; return ( user == null ) ? null : new string ( user ) ; }
protect double get domain low bound ( double p ) { return 0 ; }
protect boolean have request content ( ) { log . trace ( `` enter entity enclose method . have request content ( ) `` ) ; return ( this . request entity ! = null ) || ( this . request stream ! = null ) || ( this . request string ! = null ) ; }
protect void send content type header ( output stream out ) throw i o exception { log . trace ( `` enter send content type header ( output stream out ) `` ) ; string content type = get content type ( ) ; if ( content type ! = null ) { out . write ( crlf_bytes ) ; out . write ( content_type_bytes ) ; out . write ( encode util . get ascii byte ( content type ) ) ; string char set = get char set ( ) ; if ( char set ! = null ) { out . write ( charset_bytes ) ; out . write ( encode util . get ascii byte ( char set ) ) ; } } }
public long get length ( ) { if ( this . file ! = null ) { return this . file . length ( ) ; } else { return 0 ; } }
protect void send disposition header ( output stream out ) throw i o exception { log . trace ( `` enter send disposition header ( output stream out ) `` ) ; out . write ( content_disposition_bytes ) ; out . write ( quote_bytes ) ; out . write ( encode util . get ascii byte ( get name ( ) ) ) ; out . write ( quote_bytes ) ; }
public void set host ( string host ) throw illegal state exception { if ( host == null ) { throw new illegal argument exception ( `` host parameter be null `` ) ; } assert not open ( ) ; host name = host ; }
protect long length of data ( ) throw i o exception { log . trace ( `` enter length of data ( ) `` ) ; return source . get length ( ) ; }
public boolean remove parameter ( string param name ) throw illegal argument exception { log . trace ( `` enter post method . remove parameter ( string ) `` ) ; if ( param name == null ) { throw new illegal argument exception ( `` argument pass to remove parameter ( string ) can not be null `` ) ; } boolean removed = false ; iterator iter = this . params . iterator ( ) ; while ( iter . have next ( ) ) { name value pair pair = ( name value pair ) iter . next ( ) ; if ( param name . equal ( pair . get name ( ) ) ) { iter . remove ( ) ; remove = true ; } } return remove ; }
public void set connection stale checking enable ( boolean connection stale check enable ) { this . params . set stale checking enable ( connection stale check enable ) ; }
public int get connection in pool ( host configuration host configuration ) { synchronize ( connection pool ) { host connection pool host pool = connection pool . get host pool ( host configuration ) ; return host pool . num connection ; } }
public void set use expect header ( boolean value ) { get params ( ) . set boolean parameter ( http method params . use_expect_continue , value ) ; }
public void set default max connection per host ( int max host connection ) { set max connection per host ( host configuration . any_host_configuration , max host connection ) ; }
public int get max total connection ( ) { return get int parameter ( http connection manager params . max_total_connections , multi thread http connection manager . default_max_total_connections ) ; }
public int get so timeout ( ) { return get int parameter ( so_timeout , 0 ) ; }
public void set receive buffer size ( int size ) { set int parameter ( so_rcvbuf , size ) ; }
public int get linger ( ) { return get int parameter ( so_linger , -1 ) ; }
public char [ ] get raw path ( ) { return _is_opaque_part ? _opaque : _path ; }
public boolean be net path ( ) { return _is_net_path || ( _authority ! = null ) ; }
public static string get default document charset by platform ( ) { return default document charset by platform ; }
public static string get default document charset by platform ( ) { return default document charset by platform ; }
public string get userinfo ( ) throw u r i exception { return ( _userinfo == null ) ? null : decode ( _userinfo , get protocol charset ( ) ) ; }
public string get current hier path ( ) throw u r i exception { char [ ] path = get raw current hier path ( ) ; return ( path == null ) ? null : decode ( path , get protocol charset ( ) ) ; }
public string get query ( ) throw u r i exception { return ( _query == null ) ? null : decode ( _query , get protocol charset ( ) ) ; }
public void set host ( string host ) { if ( host == null ) { throw new illegal argument exception ( `` host may not be null `` ) ; } this . host = host ; }
public int hash code ( ) { int hash = super . hash code ( ) ; hash = lang utils . hash code ( hash , this . host ) ; hash = lang utils . hash code ( hash , this . domain ) ; return hash ; }
public input stream get error stream ( ) { log . trace ( `` enter http u r l connection . get error stream ( ) `` ) ; throw new runtime exception ( `` not implement yet `` ) ; }
public boolean be always use quote ( ) { return always use quote ; }
public static string encode path query ( string unescaped ) throw u r i exception { return encode path query ( unescaped , uri . get default protocol charset ( ) ) ; }
public int get ( final int po ) { return bytes [ po ] ; }
public void sort ( array list < value [ ] > row ) { collection . sort ( row , this ) ; }
public string to string ( ) { return super . to string ( ) + `` [ charset name= `` + this . charset + `` ] `` ; }
public static void write swap double ( final byte [ ] data , final int offset , final double value ) { write swap long ( data , offset , double . double to long bit ( value ) ) ; }
public static long read swap unsigned integer ( final input stream input ) throw i o exception { final int value1 = read ( input ) ; final int value2 = read ( input ) ; final int value3 = read ( input ) ; final int value4 = read ( input ) ; final long low = ( ( ( value1 & 0xff ) < < 0 ) + ( ( value2 & 0xff ) < < 8 ) + ( ( value3 & 0xff ) < < 16 ) ) ; final long high = value4 & 0xff ; return ( high < < 24 ) + ( 0xffffffff l & low ) ; }
protect void update file counter ( final path file , final basic file attribute attribute ) { path counter . get file counter ( ) . increment ( ) ; path counter . get byte counter ( ) . add ( attribute . size ( ) ) ; }
public static path counter delete directory ( final path directory ) throw i o exception { return delete directory ( directory , empty_delete_option_array ) ; }
public static path counter copy directory ( final path source directory , final path target directory , final copy option . . . copy option ) throw i o exception { final path absolute source = source directory . to absolute path ( ) ; return visit file tree ( new copy directory visitor ( counter . long path counter ( ) , absolute source , target directory , copy option ) , absolute source ) . get path counter ( ) ; }
public static boolean file content equal ( final path path1 , final path path2 ) throw i o exception { return file content equal ( path1 , path2 , empty_link_option_array , empty_open_option_array ) ; }
public string to string ( ) { return `` regex file filter [ pattern= `` + pattern + `` ] `` ; }
public boolean accept ( final file file ) { return file . can write ( ) ; }
public boolean be file ( file path ) { return file utils . be file ( path ) ; }
public static i o file filter age file filter ( final date cutoff date ) { return new age file filter ( cutoff date ) ; }
public static i o file filter age file filter ( final date cutoff date ) { return new age file filter ( cutoff date ) ; }
public static < t > void no null ( string arg description , t . . . args ) { not empty ( arg description , args ) ; for ( t arg : args ) { if ( arg == null ) { if ( args . length > 0 ) { throw new illegal argument exception ( arg description + `` must not contain null `` ) ; } else { throw new illegal argument exception ( arg description + `` must not be null `` ) ; } } } }
public boolean accept ( final file file ) { return accept ( file . get name ( ) ) ; }
public boolean accept ( final file file ) { if ( file filter ! = null ) { return file filter . accept ( file ) ; } return super . accept ( file ) ; }
public static string normalize no end separator ( final string file name ) { return do normalize ( file name , system_separator , false ) ; }
public static boolean be extension ( final string file name , final string extension ) { if ( file name == null ) { return false ; } require non null char ( file name ) ; if ( extension == null || extension . be empty ( ) ) { return index of extension ( file name ) == not_found ; } final string file ext = get extension ( file name ) ; return file ext . equal ( extension ) ; }
public static boolean be java keyword ( string keyword ) { return ( array . binary search ( keywords , keyword , english collator ) > = 0 ) ; }
public static path counter delete file ( final path file ) throw i o exception { return delete file ( file , empty_delete_option_array ) ; }
public static file get user home ( ) { return new file ( system . get property ( user_home_key ) ) ; }
public static iterator < file > iterate file ( file directory , i o file filter file filter , i o file filter dir filter ) { return list file ( directory , file filter , dir filter ) . iterator ( ) ; }
public static list < string > read line ( final file file , final charset charset ) throw i o exception { try ( input stream input stream = open input stream ( file ) ) { return i o utils . read line ( input stream , charsets . to charset ( charset ) ) ; } }
public static void delete directory ( final file directory ) throw i o exception { object . require non null ( directory , `` directory `` ) ; if ( ! directory . exists ( ) ) { return ; } if ( ! be symlink ( directory ) ) { clean directory ( directory ) ; } delete ( directory ) ; }
public void reset ( ) { idx = mark ; }
public int read ( ) { if ( idx > = end ( ) ) { return eof ; } return char sequence . char at ( idx++ ) ; }
public long skip ( final long number of char ) throw i o exception { if ( eof ) { throw new i o exception ( `` skip after end of file `` ) ; } if ( position == size ) { return do end of file ( ) ; } position += number of char ; long return length = number of char ; if ( position > size ) { return length = number of char - ( position - size ) ; position = size ; } return return length ; }
public long get position ( ) { return position ; }
public synchronize void reset ( ) throw i o exception { if ( ! mark support ) { throw unsupported operation exception . reset ( ) ; } if ( mark < 0 ) { throw new i o exception ( `` no position have be mark `` ) ; } if ( position > mark + readlimit ) { throw new i o exception ( `` mark position [ `` + mark + `` ] be no longer valid - pass the read limit [ `` + readlimit + `` ] `` ) ; } position = mark ; eof = false ; }
public int read ( ) throw i o exception { byte [ ] b = new byte [ 1 ] ; return read ( b ) == -1 ? -1 : b [ 0 ] & 0x f f ; }
public long skip ( long n ) throw i o exception { long len = math . min ( n , end - po ) ; po += len ; return len ; }
public void dispose ( ) throw i o exception { position = -1 ; random access file . close ( ) ; overflow file . delete ( ) ; }
public void close ( ) throw i o exception { reader . close ( ) ; }
public boolean be cause of ( final throwable exception ) { return tag i o exception . be tag with ( exception , tag ) ; }
public long get delay ( ) { return delay ; }
public static char [ ] to char array ( input stream be ) throw i o exception { return to char array ( be , charset . default charset ( ) ) ; }
public static char [ ] to char array ( input stream be , charset encode ) throw i o exception { char array writer output = new char array writer ( ) ; copy ( be , output , encode ) ; return output . to char array ( ) ; }
public iterable < file alteration listener > get listener ( ) { return listener ; }
public void add observer ( final file alteration observer observer ) { if ( observer ! = null ) { observer . add ( observer ) ; } }
public long get last modified ( ) { return last modify ; }
public boolean be exists ( ) { return exist ; }
public void write ( final int b ) throw i o exception { appendable . append ( ( char ) b ) ; }
public void add element ( int index , final boolean a [ ] , int offset , int length ) { ensure index ( index ) ; if ( offset < 0 ) throw new array index out of bound exception ( `` offset ( `` + offset + `` ) be negative `` ) ; if ( offset + length > a . length ) throw new array index out of bound exception ( `` end index ( `` + ( offset + length ) + `` ) be great than array length ( `` + a . length + `` ) `` ) ; while ( length -- ! = 0 ) add ( index++ , a [ offset++ ] ) ; }
public void write ( final int b ) throw i o exception { appendable . append ( ( char ) b ) ; }
public file get file ( ) { return output file ; }
public void write ( final string str , final int st , final int end ) throw i o exception { out . write ( str , st , end ) ; }
public void write ( final int c ) throw i o exception { list < exception > cause list = null ; int i = 0 ; for ( final writer w : writer ) { if ( w ! = null ) { try { w . write ( c ) ; } catch ( final i o exception e ) { cause list = add ( cause list , i , e ) ; } } i++ ; } if ( not empty ( cause list ) ) { throw new i o exception list ( `` write `` , cause list ) ; } }
public void flush ( ) throw i o exception { flush output ( ) ; writer . flush ( ) ; }
public string get encode ( ) { return encode ; }
public validate object input stream accept ( final class < ? > . . . class ) { for ( final class < ? > c : class ) { accept matcher . add ( new full class name matcher ( c . get name ( ) ) ) ; } return this ; }
public boolean be self closing ( ) { return empty || self closing ; }
public int compare ( final file file1 , final file file2 ) { final long result = file utils . last modified unchecked ( file1 ) - file utils . last modified unchecked ( file2 ) ; if ( result < 0 ) { return -1 ; } if ( result > 0 ) { return 1 ; } return 0 ; }
public void set port ( int port ) { this . port = port ; }
public static string get full path ( final string file name ) { return do get full path ( file name , true ) ; }
public static boolean equal on system ( final string file name1 , final string file name2 ) { return equal ( file name1 , file name2 , false , i o case . system ) ; }
public synchronize void mark ( int readlimit ) { mark fb index = fb index ; mark at start = first bytes == null ; in . mark ( readlimit ) ; }
public object parse property ( string value ) { if ( value == null || `` `` . equal ( value ) ) { return value ; } final int len = value . length ( ) ; parse position po = new parse position ( 0 ) ; object o = parse next property ( value , po ) ; if ( o ! = null & & po . get index ( ) > = len ) { return o ; } string buffer sb = new string buffer ( len * 2 ) ; if ( o == null ) { sb . append ( value . char at ( po . get index ( ) ) ) ; po . set index ( po . get index ( ) + 1 ) ; } else { sb . append ( o ) ; } while ( po . get index ( ) < len ) { o = parse next property ( value , po ) ; if ( o == null ) { sb . append ( value . char at ( po . get index ( ) ) ) ; po . set index ( po . get index ( ) + 1 ) ; } else { sb . append ( o ) ; } } return sb . to string ( ) ; }
protect void set closure delegate ( closure closure , object node ) { closure . set delegate ( this ) ; }
public static input stream to input stream ( final char sequence input ) { return to input stream ( input , charset . default charset ( ) ) ; }
public static list < string > read line ( final file file ) throw i o exception { return read line ( file , charset . default charset ( ) ) ; }
public static line iterator line iterator ( input stream input , charset encode ) throw i o exception { return new line iterator ( new input stream reader ( input , charsets . to charset ( encode ) ) ) ; }
public static char [ ] to char array ( input stream be , charset encode ) throw i o exception { char array writer output = new char array writer ( ) ; copy ( be , output , encode ) ; return output . to char array ( ) ; }
public void set file ( vector file ) { this . file = file ; }
public static void write line ( collection < ? > line , string line end , output stream output , charset encode ) throw i o exception { if ( line == null ) { return ; } if ( line end == null ) { line end = line_separator ; } charset cs = charsets . to charset ( encode ) ; for ( object line : line ) { if ( line ! = null ) { output . write ( line . to string ( ) . get byte ( c ) ) ; } output . write ( line end . get byte ( c ) ) ; } }
public int available ( ) throw i o exception { final long avail = available long ( ) ; if ( avail > integer . max_value ) { return integer . max_value ; } return ( int ) avail ; }
public static void write ( byte [ ] data , writer output , charset encode ) throw i o exception { if ( data ! = null ) { output . write ( new string ( data , charsets . to charset ( encode ) ) ) ; } }
protect void fill buffer ( ) throw i o exception { if ( eof ) { return ; } int space = buffer . get space ( ) ; final byte [ ] buf = i o utils . byte array ( space ) ; while ( space > 0 ) { final int re = in . read ( buf , 0 , space ) ; if ( res == eof ) { eof = true ; return ; } if ( res > 0 ) { buffer . add ( buf , 0 , re ) ; space -= res ; } } }
protect void set closure delegate ( closure closure , object node ) { closure . set delegate ( this ) ; }
public byte [ ] get data ( ) { return memory output stream ! = null ? memory output stream . to byte array ( ) : null ; }
public string get mime type ( ) { return mime type ; }
public static input stream to input stream ( final char sequence input ) { return to input stream ( input , charset . default charset ( ) ) ; }
public static string read file to string ( final file file , final charset charset name ) throw i o exception { try ( input stream input stream = open input stream ( file ) ) { return i o utils . to string ( input stream , charsets . to charset ( charset name ) ) ; } }
public static boolean content equal ( reader input1 , reader input2 ) throw i o exception { if ( ! ( input1 instanceof buffer reader ) ) { input1 = new buffer reader ( input1 ) ; } if ( ! ( input2 instanceof buffer reader ) ) { input2 = new buffer reader ( input2 ) ; } int ch = input1 . read ( ) ; while ( -1 ! = ch ) { int ch2 = input2 . read ( ) ; if ( ch ! = ch2 ) { return false ; } ch = input1 . read ( ) ; } int ch2 = input2 . read ( ) ; return ( ch2 == -1 ) ; }
public boolean be negative ( ) { return this . bytes < 0 ; }
public int available ( ) throw i o exception { final long avail = available long ( ) ; if ( avail > integer . max_value ) { return integer . max_value ; } return ( int ) avail ; }
public equal builder append super ( boolean super equal ) { if ( be equal == false ) { return this ; } be equals = super equal ; return this ; }
public static boolean [ ] add all ( final boolean [ ] array1 , final boolean . . . array2 ) { if ( array1 == null ) { return clone ( array2 ) ; } else if ( array2 == null ) { return clone ( array1 ) ; } final boolean [ ] join array = new boolean [ array1 . length + array2 . length ] ; system . arraycopy ( array1 , 0 , join array , 0 , array1 . length ) ; system . arraycopy ( array2 , 0 , join array , array1 . length , array2 . length ) ; return join array ; }
public void set spawn ( boolean spawn ) { this . spawn = spawn ; }
public static int last index of ( final object [ ] array , final object object to find , int start index ) { if ( array == null ) { return index_not_found ; } if ( start index < 0 ) { return index_not_found ; } else if ( start index > = array . length ) { start index = array . length - 1 ; } if ( object to find == null ) { for ( int i = start index ; i > = 0 ; i -- ) { if ( array [ i ] == null ) { return i ; } } } else if ( array . get class ( ) . get component type ( ) . be instance ( object to find ) ) { for ( int i = start index ; i > = 0 ; i -- ) { if ( object to find . equal ( array [ i ] ) ) { return i ; } } } return index_not_found ; }
public static int last index of ( final object [ ] array , final object object to find ) { return last index of ( array , object to find , integer . max_value ) ; }
public static int index of ( double [ ] array , double value to find , int start index , double tolerance ) { if ( array utils . be empty ( array ) ) { return -1 ; } if ( start index < 0 ) { start index = 0 ; } double min = value to find - tolerance ; double max = value to find + tolerance ; for ( int i = start index ; i < array . length ; i++ ) { if ( array [ i ] > = min & & array [ i ] < = max ) { return i ; } } return -1 ; }
public void set command ( commandline cmdl ) { log ( `` the command attribute be deprecate . \n `` + `` please use the executable attribute and nested arg element . `` , project . msg_warn ) ; this . cmdl = cmdl ; }
public void set output ( file out ) { this . output = out ; incompatible with spawn = true ; }
public void set input ( file input ) { if ( input string ! = null ) { throw new build exception ( `` the \ `` input\ `` and \ `` inputstring\ `` `` + `` attribute can not both be specify `` ) ; } this . input = input ; incompatible with spawn = true ; }
public void set input string ( string input string ) { if ( input ! = null ) { throw new build exception ( `` the \ `` input\ `` and \ `` inputstring\ `` `` + `` attribute can not both be specify `` ) ; } this . input string = input string ; incompatible with spawn = true ; }
public void set log error ( boolean log error ) { redirector . set log error ( log error ) ; incompatible with spawn |= log error ; }
public void set error ( file error ) { this . error = error ; incompatible with spawn = true ; }
protect void set equal ( boolean be equal ) { this . be equals = be equal ; }
public void set newenvironment ( boolean newenv ) { new environment = newenv ; }
public int hash code ( ) { return to hash code ( ) ; }
public static string to string ( object object , to string style style ) { return to string ( object , style , false , false , null ) ; }
public static string to string ( object object , to string style style ) { return to string ( object , style , false , false , null ) ; }
public static string to string ( object object ) { return to string ( object , null , false , false , null ) ; }
public void set use identity hash code ( boolean use identity hash code ) { super . set use identity hash code ( use identity hash code ) ; }
public string get content start ( ) { return super . get content start ( ) ; }
public void set field name value separator ( string field name value separator ) { super . set field name value separator ( field name value separator ) ; }
public void set field name value separator ( string field name value separator ) { super . set field name value separator ( field name value separator ) ; }
public string get summary object end text ( ) { return super . get summary object end text ( ) ; }
public void add configure redirector ( redirector element redirector element ) { if ( this . redirector element ! = null ) { throw new build exception ( `` can not have > 1 nested < redirector > s `` ) ; } this . redirector element = redirector element ; incompatible with spawn = true ; }
public void set os family ( string os family ) { this . os family = os family . to lower case ( locale . u ) ; }
protect void check configuration ( ) throw build exception { if ( cmdl . get executable ( ) == null ) { throw new build exception ( `` no executable specify `` , get location ( ) ) ; } if ( dir ! = null & & ! dir . exists ( ) ) { throw new build exception ( `` the directory `` + dir + `` do not exist `` ) ; } if ( dir ! = null & & ! dir . be directory ( ) ) { throw new build exception ( dir + `` be not a directory `` ) ; } if ( spawn & & incompatible with spawn ) { get project ( ) . log ( `` spawn do not allow attribute relate to input , `` + `` output , error , result `` , project . msg_err ) ; get project ( ) . log ( `` spawn also do not allow timeout `` , project . msg_err ) ; get project ( ) . log ( `` finally , spawn be not compatible `` + `` with a nested i/o < redirector > `` , project . msg_err ) ; throw new build exception ( `` you have use an attribute `` + `` or nest element which be not compatible with spawn `` ) ; } setup redirector ( ) ; }
protect void setup redirector ( ) { redirector . set input ( input ) ; redirector . set input string ( input string ) ; redirector . set output ( output ) ; redirector . set error ( error ) ; }
public to string builder append ( boolean value ) { style . append ( buffer , null , value ) ; return this ; }
public void append super ( string buffer buffer , string super to string ) { append to string ( buffer , super to string ) ; }
protect execute watchdog create watchdog ( ) throw build exception { return ( timeout == null ) ? null : new execute watchdog ( timeout . long value ( ) ) ; }
protect void log flush ( ) { }
public void set stream handler ( execute stream handler stream handler ) { this . stream handler = stream handler ; }
public string [ ] get commandline ( ) { return cmdl ; }
public char get start ( ) { return this . start ; }
public char range [ ] get char range ( ) { return ( char range [ ] ) set . to array ( new char range [ set . size ( ) ] ) ; }
public boolean equal ( object obj ) { if ( obj == this ) { return true ; } if ( obj instanceof char range == false ) { return false ; } char range other = ( char range ) obj ; return start == other . start & & end == other . end & & negate == other . negate ; }
public char range [ ] get char range ( ) { return ( char range [ ] ) set . to array ( new char range [ set . size ( ) ] ) ; }
public boolean be escape char ( char ch ) { return this . escape char == ch ; }
public boolean be escape char ( char ch ) { return this . escape char == ch ; }
public static string unicode escape ( char ch ) { if ( ch < 0x10 ) { return `` \\u000 `` + integer . to hex string ( ch ) ; } else if ( ch < 0x100 ) { return `` \\u00 `` + integer . to hex string ( ch ) ; } else if ( ch < 0x1000 ) { return `` \\u0 `` + integer . to hex string ( ch ) ; } return `` \\u `` + integer . to hex string ( ch ) ; }
public static boolean be support ( string name ) { if ( name == null ) { return false ; } try { new string ( array utils . empty_byte_array , name ) ; } catch ( unsupported encode exception e ) { return false ; } return true ; }
public static list convert class to class name ( list class ) { if ( class == null ) { return null ; } list class name = new array list ( class . size ( ) ) ; for ( iterator it = class . iterator ( ) ; it . have next ( ) ; ) { class cl = ( class ) it . next ( ) ; if ( cls == null ) { class name . add ( null ) ; } else { class name . add ( cl . get name ( ) ) ; } } return class name ; }
public static class get class ( string class name , boolean initialize ) throw class not find exception { class loader context c l = thread . current thread ( ) . get context class loader ( ) ; class loader loader = context c l == null ? class utils . class . get class loader ( ) : context c l ; return get class ( loader , class name , initialize ) ; }
public static string [ ] to string array ( final object [ ] array , final string value for null element ) { if ( null == array ) { return null ; } else if ( array . length == 0 ) { return empty_string_array ; } final string [ ] result = new string [ array . length ] ; for ( int i = 0 ; i < array . length ; i++ ) { final object object = array [ i ] ; result [ i ] = ( object == null ? value for null element : object . to string ( ) ) ; } return result ; }
public static string get short canonical name ( object object , string value if null ) { if ( object == null ) { return value if null ; } return get short canonical name ( object . get class ( ) . get name ( ) ) ; }
protect static enum get enum ( class enum class , string name ) { entry entry = get entry ( enum class ) ; if ( entry == null ) { return null ; } return ( enum ) entry . map . get ( name ) ; }
protect static enum get enum ( class enum class , string name ) { entry entry = get entry ( enum class ) ; if ( entry == null ) { return null ; } return ( enum ) entry . map . get ( name ) ; }
public final int get value ( ) { return i value ; }
public static throwable [ ] get throwables ( throwable throwable ) { list < throwable > list = new array list < throwable > ( ) ; while ( throwable ! = null ) { list . add ( throwable ) ; throwable = get cause ( throwable ) ; } return list . to array ( new throwable [ list . size ( ) ] ) ; }
public static string [ ] get root cause stack trace ( throwable t ) { throwable throwables [ ] = get throwables ( t ) ; int count = throwables . length ; array list frame = new array list ( ) ; list next trace = get stack frame list ( throwables [ count - 1 ] ) ; for ( int i = count ; -- i > = 0 ; ) { list trace = next trace ; if ( i ! = 0 ) { next trace = get stack frame list ( throwables [ i - 1 ] ) ; remove common frame ( trace , next trace ) ; } if ( i == count - 1 ) { frame . add ( throwables [ i ] . to string ( ) ) ; } else { frame . add ( wrapped_marker + throwables [ i ] . to string ( ) ) ; } for ( int j = 0 ; j < trace . size ( ) ; j++ ) { frame . add ( trace . get ( j ) ) ; } } return ( string [ ] ) frames . to array ( new string [ 0 ] ) ; }
public object remove ( int key ) { entry tab [ ] = table ; int hash = key ; int index = ( hash & 0x7 f f f f f f f ) % tab . length ; for ( entry e = tab [ index ] , prev = null ; e ! = null ; prev = e , e = e . next ) { if ( e . hash == hash ) { if ( prev ! = null ) { prev . next = e . next ; } else { tab [ index ] = e . next ; } count -- ; object old value = e . value ; e . value = null ; return old value ; } } return null ; }
public number get minimum number ( ) { if ( min object == null ) { min object = new double ( min ) ; } return min object ; }
public double get maximum double ( ) { return max ; }
public fraction reduce ( ) { int gcd = great common divisor ( math . ab ( numerator ) , denominator ) ; return fraction . get fraction ( numerator / gcd , denominator / gcd ) ; }
public float float value ( ) { return numerator . float value ( ) / denominator . float value ( ) ; }
public static fraction get fraction ( int numerator , int denominator ) { if ( denominator == 0 ) { throw new arithmetic exception ( `` the denominator must not be zero `` ) ; } if ( denominator < 0 ) { if ( numerator== integer . min_value || denominator== integer . min_value ) { throw new arithmetic exception ( `` overflow : ca n't negate `` ) ; } numerator = -numerator ; denominator = -denominator ; } return new fraction ( numerator , denominator ) ; }
public boolean overlap range ( range range ) { if ( range == null ) { return false ; } return range . contains integer ( min ) || range . contains integer ( max ) || contains integer ( range . get minimum integer ( ) ) ; }
public boolean equal ( object obj ) { if ( obj instanceof mutable long ) { return value == ( ( mutable long ) obj ) . long value ( ) ; } return false ; }
public object get value ( ) { return new byte ( this . value ) ; }
public boolean equal ( object obj ) { if ( obj == this ) { return true ; } if ( obj instanceof double range == false ) { return false ; } double range range = ( double range ) obj ; return ( double . double to long bit ( min ) == double . double to long bit ( range . min ) & & double . double to long bit ( max ) == double . double to long bit ( range . max ) ) ; }
public int int value ( ) { return ( int ) value ; }
public short short value ( ) { return value ; }
protect void uncaught exception ( exception ex ) { ex . print stack trace ( ) ; }
public static string to string ( object array , string string if null ) { if ( array == null ) { return string if null ; } return new to string builder ( array , to string style . simple_style ) . append ( array ) . to string ( ) ; }
public static void write field ( field field , object target , object value ) throw illegal access exception { write field ( field , target , value , false ) ; }
public static object read static field ( field field , boolean force access ) throw illegal access exception { if ( field == null ) { throw new illegal argument exception ( `` the field must not be null `` ) ; } if ( ! modifier . be static ( field . get modifier ( ) ) ) { throw new illegal argument exception ( `` the field ' `` + field . get name ( ) + `` ' be not static `` ) ; } return read field ( field , ( object ) null , force access ) ; }
public static void write declare static field ( class < ? > cl , string field name , object value ) throw illegal access exception { write declare static field ( cls , field name , value , false ) ; }
public static constructor get accessible constructor ( class cl , class parameter type ) { return get accessible constructor ( cl , new class [ ] { parameter type } ) ; }
public static string temporary folder path ( ) { return append ( separator ) . to ( system . get property ( `` java . io . tmpdir `` ) ) ; }
public char [ ] to char array ( ) { if ( size == 0 ) { return array utils . empty_char_array ; } char char [ ] = new char [ size ] ; system . arraycopy ( buffer , 0 , char , 0 , size ) ; return char ; }
public synchronize void stop ( ) { watchdog . stop ( ) ; clean up ( ) ; }
protect synchronized void clean up ( ) { watch = false ; process = null ; }
public str builder append ( string str , int start index , int length ) { if ( str == null ) { return append null ( ) ; } if ( start index < 0 || start index > str . length ( ) ) { throw new string index out of bound exception ( `` start index must be valid `` ) ; } if ( length < 0 || ( start index + length ) > str . length ( ) ) { throw new string index out of bound exception ( `` length must be valid `` ) ; } if ( length > 0 ) { int len = length ( ) ; ensure capacity ( len + length ) ; str . get char ( start index , start index + length , buffer , len ) ; size += length ; } return this ; }
public str builder replace all ( str matcher matcher , string replace str ) { return replace ( matcher , replace str , 0 , size , -1 ) ; }
public str builder replace first ( string search str , string replace str ) { int search len = ( search str == null ? 0 : search str . length ( ) ) ; if ( search len > 0 ) { int index = index of ( search str , 0 ) ; if ( index > = 0 ) { int replace len = ( replace str == null ? 0 : replace str . length ( ) ) ; replace impl ( index , index + search len , search len , replace str , replace len ) ; } } return this ; }
public str builder reverse ( ) { if ( size == 0 ) { return this ; } int half = size / 2 ; char [ ] buf = buffer ; for ( int leave idx = 0 , right idx = size - 1 ; leave idx < half ; leave idx++ , right idx -- ) { char swap = buf [ leave idx ] ; buf [ leave idx ] = buf [ right idx ] ; buf [ right idx ] = swap ; } return this ; }
public string mid string ( int index , int length ) { if ( index < 0 ) { index = 0 ; } if ( length < = 0 || index > = size ) { return `` `` ; } if ( size < = index + length ) { return new string ( buffer , index , size - index ) ; } else { return new string ( buffer , index , length ) ; } }
public str builder delete first ( str matcher matcher ) { return replace ( matcher , null , 0 , size , 1 ) ; }
public int last index of ( string str , int start index ) { start index = ( start index > = size ? size - 1 : start index ) ; if ( str == null || start index < 0 ) { return -1 ; } int str len = str . length ( ) ; if ( str len > 0 & & str len < = size ) { if ( str len == 1 ) { return last index of ( str . char at ( 0 ) , start index ) ; } outer : for ( int i = start index - str len + 1 ; i > = 0 ; i -- ) { for ( int j = 0 ; j < str len ; j++ ) { if ( str . char at ( j ) ! = buffer [ i + j ] ) { continue outer ; } } return i ; } } else if ( str len == 0 ) { return start index ; } return -1 ; }
public writer a writer ( ) { return new str builder writer ( ) ; }
public str tokenizer set ignore char ( char ignore ) { return set ignore matcher ( str matcher . char matcher ( ignore ) ) ; }
public str substitutor set variable prefix ( char prefix ) { return set variable prefix matcher ( str matcher . char matcher ( prefix ) ) ; }
public boolean have next ( ) { check tokenized ( ) ; return token po < token . length ; }
public str tokenizer set delimiter matcher ( str matcher delim ) { if ( delim == null ) { this . delim matcher = str matcher . none matcher ( ) ; } else { this . delim matcher = delim ; } return this ; }
public static string format u t c ( long millis , string pattern ) { return format ( new date ( millis ) , pattern , date utils . utc_time_zone , null ) ; }
public static void no null element ( object [ ] array , string message ) { if ( array ! = null ) { for ( int i = 0 ; i < array . length ; i++ ) { if ( array [ i ] == null ) { throw new illegal argument exception ( message ) ; } } } }
public static void no null element ( collection collection ) { validate . not null ( collection ) ; int i = 0 ; for ( iterator it = collection . iterator ( ) ; it . have next ( ) ; i++ ) { if ( it . next ( ) == null ) { throw new illegal argument exception ( `` the validated collection contain null element at index : `` + i ) ; } } }
public static void no null element ( collection collection ) { validate . not null ( collection ) ; int i = 0 ; for ( iterator it = collection . iterator ( ) ; it . have next ( ) ; i++ ) { if ( it . next ( ) == null ) { throw new illegal argument exception ( `` the validated collection contain null element at index : `` + i ) ; } } }
public static string replace ( final string text , string search string , final string replacement ) { if ( be empty ( text ) || be empty ( search string ) || replacement == null ) { return text ; } int start = 0 ; int end = text . index of ( search string , start ) ; if ( end == index_not_found ) { return text ; } final int repl length = search string . length ( ) ; int increase = replacement . length ( ) - repl length ; increase = ( increase < 0 ? 0 : increase ) * 16 ; final string builder buf = new string builder ( text . length ( ) + increase ) ; while ( end ! = index_not_found ) { buf . append ( text , start , end ) . append ( replacement ) ; start = end + repl length ; end = text . index of ( search string , start ) ; } buf . append ( text , start , text . length ( ) ) ; return buf . to string ( ) ; }
public static string temporary folder path ( ) { return append ( separator ) . to ( system . get property ( `` java . io . tmpdir `` ) ) ; }
public void set enable substitution in variable ( boolean enable substitution in variable ) { this . enable substitution in variable = enable substitution in variable ; }
public thread new thread ( runnable r ) { thread t = get wrap factory ( ) . new thread ( r ) ; initialize thread ( t ) ; return t ; }
public thread new thread ( runnable r ) { thread t = get wrap factory ( ) . new thread ( r ) ; initialize thread ( t ) ; return t ; }
public boolean equal ( object obj ) { if ( this == obj ) { return true ; } if ( ! ( obj instanceof constant initializer < ? > ) ) { return false ; } constant initializer < ? > c = ( constant initializer < ? > ) obj ; return object utils . equal ( get object ( ) , c . get object ( ) ) ; }
public t get ( ) throw concurrent exception { return get object ( ) ; }
public synchronize boolean try acquire ( ) { prepare acquire ( ) ; return acquire permit ( ) ; }
public void add listener ( final l listener , final boolean allow duplicate ) { validate . not null ( listener , `` listener object can not be null . `` ) ; if ( allow duplicate ) { listener . add ( listener ) ; } else if ( ! listener . contains ( listener ) ) { listener . add ( listener ) ; } }
public final string get naming pattern ( ) { return name pattern ; }
public int hash code ( ) { return value == null ? 0 : value . hash code ( ) ; }
public boolean be after range ( range < t > other range ) { if ( other range == null ) { return false ; } return be after ( other range . maximum ) ; }
public static object read field ( field field , object target ) throw illegal access exception { return read field ( field , target , false ) ; }
protect boolean parameter match ( type require parameter , type bean parameter ) { if ( type . be actual type ( require parameter ) & & type . be actual type ( bean parameter ) ) { / * * the required type parameter and the bean type parameter be actual type with identical raw * type , and , if the type be parameterized , the bean type parameter be assignable to the required * type parameter accord to these rule , or * / return match ( require parameter , bean parameter ) ; } if ( require parameter instanceof wildcard type & & type . be actual type ( bean parameter ) ) { / * * the required type parameter be a wildcard , the bean type parameter be an actual type and the * actual type be assignable to the upper bound , if any , of the wildcard and assignable from the * low bound , if any , of the wildcard , or * / return parameter match ( ( wildcard type ) require parameter , bean parameter ) ; } if ( require parameter instanceof wildcard type & & bean parameter instanceof type variable < ? > ) { / * * the required type parameter be a wildcard , the bean type parameter be a type variable and the * upper bound of the type variable be assignable to or assignable from the upper bound , if any , of * the wildcard and assignable from the low bound , if any , of the wildcard , or * / return parameter match ( ( wildcard type ) require parameter , ( type variable < ? > ) bean parameter ) ; } if ( type . be actual type ( require parameter ) & & bean parameter instanceof type variable < ? > ) { / * * the required type parameter be an actual type , the bean type parameter be a type variable and * the actual type be assignable to the upper bound , if any , of the type variable , or * / return parameter match ( require parameter , ( type variable < ? > ) bean parameter ) ; } if ( require parameter instanceof type variable < ? > & & bean parameter instanceof type variable < ? > ) { / * * the required type parameter and the bean type parameter be both type variable and the upper * bound of the required type parameter be assignable to the upper bound , if any , of the bean type * parameter * / return parameter match ( ( type variable < ? > ) require parameter , ( type variable < ? > ) bean parameter ) ; } return false ; }
public static final string unescape html4 ( string input ) { return unescape_html4 . translate ( input ) ; }
public static final string unescape html4 ( string input ) { return unescape_html4 . translate ( input ) ; }
public str builder append ( char sequence seq , int start index , int length ) { if ( seq == null ) { return append null ( ) ; } return append ( seq . to string ( ) , start index , length ) ; }
public string to string ( ) { return string . format ( fmt_to_string , integer . value of ( system . identity hash code ( this ) ) , string . value of ( get object ( ) ) ) ; }
public static int check index ( int index , int length ) { if ( index < 0 || index > = length ) { throw new index out of bound exception ( `` index `` + index + `` out-of-bounds for length `` + length ) ; } return index ; }
public static < t > void exclusive between ( t start , t end , comparable < t > value ) { if ( value . compare to ( start ) < = 0 || value . compare to ( end ) > = 0 ) { throw new illegal argument exception ( string . format ( default_exclusive_between_ex_message , value , start , end ) ) ; } }
public static < t > void exclusive between ( t start , t end , comparable < t > value , string message , object . . . value ) { if ( value . compare to ( start ) < = 0 || value . compare to ( end ) > = 0 ) { throw new illegal argument exception ( string . format ( message , value ) ) ; } }
public static void be instance of ( class < ? > type , object obj , string message , object . . . value ) { if ( type . be instance ( obj ) == false ) { throw new illegal argument exception ( string . format ( message , value ) ) ; } }
public static boolean [ ] add all ( final boolean [ ] array1 , final boolean . . . array2 ) { if ( array1 == null ) { return clone ( array2 ) ; } else if ( array2 == null ) { return clone ( array1 ) ; } final boolean [ ] join array = new boolean [ array1 . length + array2 . length ] ; system . arraycopy ( array1 , 0 , join array , 0 , array1 . length ) ; system . arraycopy ( array2 , 0 , join array , array1 . length , array2 . length ) ; return join array ; }
public static int index of ( final object [ ] array , final object object to find , int start index ) { if ( array == null ) { return index_not_found ; } if ( start index < 0 ) { start index = 0 ; } if ( object to find == null ) { for ( int i = start index ; i < array . length ; i++ ) { if ( array [ i ] == null ) { return i ; } } } else { for ( int i = start index ; i < array . length ; i++ ) { if ( object to find . equal ( array [ i ] ) ) { return i ; } } } return index_not_found ; }
public void set ignore error ( boolean v ) { ignore error = v ; }
public void set username ( string u ) { this . uname = u ; }
public void set password ( string p ) { this . pword = p ; }
public final type get type ( ) { return type ; }
public long get closing interval ( ) { return closing interval ; }
public long get closing interval ( ) { return closing interval ; }
public synchronize boolean try acquire ( ) { prepare acquire ( ) ; return acquire permit ( ) ; }
public void add listener ( final l listener , final boolean allow duplicate ) { validate . not null ( listener , `` listener object can not be null . `` ) ; if ( allow duplicate ) { listener . add ( listener ) ; } else if ( ! listener . contains ( listener ) ) { listener . add ( listener ) ; } }
public void set false ( ) { this . value = false ; }
public byte decrement and get ( ) { value -- ; return value ; }
public static float next float ( random random ) { return random . next float ( ) ; }
protect string get user name ( ) { return system . get property ( `` user . name `` ) ; }
public static string [ ] [ ] apos_escape ( ) { return apos_escape . clone ( ) ; }
public static collection < thread group > get all thread group ( ) { return find thread group ( always_true_predicate ) ; }
public int get year ( ) { return calendar . get ( calendar . year ) ; }
public boolean equal ( final object obj ) { if ( ! ( obj instanceof fast date parser ) ) { return false ; } final fast date parser other = ( fast date parser ) obj ; return pattern . equal ( other . pattern ) & & time zone . equal ( other . time zone ) & & locale . equal ( other . locale ) ; }
public void stop ( ) { if ( this . run state ! = state . run & & this . run state ! = state . suspend ) { throw new illegal state exception ( `` stopwatch be not run . `` ) ; } if ( this . run state == state . run ) { this . stop time = system . nano time ( ) ; } this . run state = state . stop ; }
public int hash code ( ) { return ( get leave ( ) == null ? 0 : get leave ( ) . hash code ( ) ) ^ ( get middle ( ) == null ? 0 : get middle ( ) . hash code ( ) ) ^ ( get right ( ) == null ? 0 : get right ( ) . hash code ( ) ) ; }
public void append to ( final appendable appendable ) throw i o exception { if ( appendable instanceof writer ) { ( ( writer ) appendable ) . write ( buffer , 0 , size ) ; } else if ( appendable instanceof string builder ) { ( ( string builder ) appendable ) . append ( buffer , 0 , size ) ; } else if ( appendable instanceof string buffer ) { ( ( string buffer ) appendable ) . append ( buffer , 0 , size ) ; } else if ( appendable instanceof char buffer ) { ( ( char buffer ) appendable ) . put ( buffer , 0 , size ) ; } else { appendable . append ( this ) ; } }
public boolean equal ( final object obj ) { if ( ! ( obj instanceof fast date parser ) ) { return false ; } final fast date parser other = ( fast date parser ) obj ; return pattern . equal ( other . pattern ) & & time zone . equal ( other . time zone ) & & locale . equal ( other . locale ) ; }
public static unicode escaper between ( int codepoint low , int codepoint high ) { return new unicode escaper ( codepoint low , codepoint high , true ) ; }
public long get split time ( ) { return get split nano time ( ) / nano_2_millis ; }
public static string get package canonical name ( final string name ) { return get package name ( get canonical name ( name ) ) ; }
public static object safe get ( xml option o , object option ) { return o == null ? null : o . get ( option ) ; }
public logger get logger ( ) { logger result = logger ; if ( result == null ) { synchronize ( this ) { result = logger ; if ( result == null ) { logger = result = hierarchy . get default hierarchy ( ) . get logger for ( name ) ; } } } return result ; }
public void trace ( object message , throwable t ) { debug ( message , t ) ; }
protect double get domain low bound ( double p ) { return 0 ; }
public log get instance ( class clazz ) throw log configuration exception { return ( get instance ( clazz . get name ( ) ) ) ; }
public derivative structure create constant ( final double c ) { return new derivative structure ( get free parameter ( ) , get order ( ) , c ) ; }
public void check compatibility ( final d s compiler compiler ) throw dimension mismatch exception { if ( parameter ! = compiler . parameter ) { throw new dimension mismatch exception ( parameter , compiler . parameter ) ; } if ( order ! = compiler . order ) { throw new dimension mismatch exception ( order , compiler . order ) ; } }
public double value ( double z ) { return evaluate internal ( x , y , z ) ; }
public int degree ( ) { return coefficient . length - 1 ; }
protect final object read resolve ( ) { return create complex ( real , imaginary ) ; }
public complex conjugate ( ) { if ( be na n ) { return na n ; } return create complex ( real , -imaginary ) ; }
public complex sinh ( ) { if ( be na n ) { return na n ; } return create complex ( fast math . sinh ( real ) * fast math . co ( imaginary ) , fast math . cosh ( real ) * fast math . sin ( imaginary ) ) ; }
public complex tan ( ) { if ( be na n || double . be infinite ( real ) ) { return na n ; } if ( imaginary > 20 . 0 ) { return create complex ( 0 . 0 , 1 . 0 ) ; } if ( imaginary < -20 . 0 ) { return create complex ( 0 . 0 , -1 . 0 ) ; } double real2 = 2 . 0 * real ; double imaginary2 = 2 . 0 * imaginary ; double d = fast math . co ( real2 ) + fast math . cosh ( imaginary2 ) ; return create complex ( fast math . sin ( real2 ) / d , fast math . sinh ( imaginary2 ) / d ) ; }
public complex log ( ) { if ( be na n ) { return na n ; } return create complex ( fast math . log ( abs ( ) ) , fast math . atan2 ( imaginary , real ) ) ; }
protect final object read resolve ( ) { return create complex ( real , imaginary ) ; }
public quaternion multiply ( final quaternion q ) { return multiply ( this , q ) ; }
public double [ ] get vector part ( ) { return new double [ ] { get q1 ( ) , get q2 ( ) , get q3 ( ) } ; }
public void set round mode ( final rounding mode mode ) { r mode = mode ; }
public dfp [ ] get ln2 split ( ) { return ln2 split . clone ( ) ; }
public static dfp sin ( final dfp a ) { final dfp pi = a . get field ( ) . get pi ( ) ; final dfp zero = a . get field ( ) . get zero ( ) ; boolean neg = false ; / * first reduce the argument to the range of +/- pi * / dfp x = a . remainder ( pi . multiply ( 2 ) ) ; / * if x < 0 then apply identity sin ( -x ) = -sin ( x ) * / / * this put x in the range 0 < x < pi * / if ( x . less than ( zero ) ) { x = x . negate ( ) ; neg = true ; } / * since sine ( x ) = sine ( pi - x ) we can reduce the range to * 0 < x < pi/2 * / if ( x . great than ( pi . divide ( 2 ) ) ) { x = pi . subtract ( x ) ; } dfp y ; if ( x . less than ( pi . divide ( 4 ) ) ) { y = sin internal ( split ( x ) ) ; } else { final dfp c [ ] = new dfp [ 2 ] ; final dfp [ ] pi split = a . get field ( ) . get pi split ( ) ; c [ 0 ] = pi split [ 0 ] . divide ( 2 ) . subtract ( x ) ; c [ 1 ] = pi split [ 1 ] . divide ( 2 ) ; y = cos internal ( c ) ; } if ( neg ) { y = y . negate ( ) ; } return a . new instance ( y ) ; }
public double get scale ( ) { return c ; }
public static < t > method [ ] get all method except ( class < t > type , string . . . method name ) { list < method > method to mock = new link list < method > ( ) ; method [ ] method = get all method ( type ) ; iterate method : for ( method method : method ) { for ( string method name : method name ) { if ( method . get name ( ) . equal ( method name ) ) { continue iterate method ; } } method to mock . add ( method ) ; } return method to mock . to array ( new method [ 0 ] ) ; }
public levenberg marquardt optimizer with ortho tolerance ( double new ortho tolerance ) { return new levenberg marquardt optimizer ( initial step bound factor , cost relative tolerance , par relative tolerance , new ortho tolerance , qr rank threshold ) ; }
public weight observed point [ ] get observation ( ) { return observation . to array ( new weight observed point [ observation . size ( ) ] ) ; }
public big fraction divide ( final big fraction fraction ) { if ( fraction == null ) { throw new null argument exception ( localized format . fraction ) ; } if ( fraction . numerator . signum ( ) == 0 ) { throw new math arithmetic exception ( localized format . zero_denominator ) ; } if ( numerator . signum ( ) == 0 ) { return zero ; } return multiply ( fraction . reciprocal ( ) ) ; }
public big fraction divide ( final big fraction fraction ) { if ( fraction == null ) { throw new null argument exception ( localized format . fraction ) ; } if ( fraction . numerator . signum ( ) == 0 ) { throw new math arithmetic exception ( localized format . zero_denominator ) ; } if ( numerator . signum ( ) == 0 ) { return zero ; } return multiply ( fraction . reciprocal ( ) ) ; }
public fraction ab ( ) { fraction ret ; if ( numerator > = 0 ) { ret = this ; } else { ret = negate ( ) ; } return ret ; }
public chromosome get second ( ) { return second ; }
public double get crossover rate ( ) { return crossover rate ; }
public void set elitism rate ( double elitism rate ) { if ( elitism rate < 0 || elitism rate > 1 ) throw new illegal argument exception ( `` elitism rate have to be in [ 0,1 ] `` ) ; this . elitism rate = elitism rate ; }
public boolean be satisfied ( final population population ) { if ( this . num generation < this . max generation ) { num generations++ ; return false ; } return true ; }
public static synchronize void set random generator ( final random generator random ) { random generator = random ; }
public mutation policy get mutation policy ( ) { return mutation policy ; }
public void set arity ( final int arity ) { this . arity = arity ; }
public boolean contains ( final p point ) { return point . distance ( center ) < = radius ; }
public rotation to rotation ( ) { return new rotation ( q0 . get real ( ) , q1 . get real ( ) , q2 . get real ( ) , q3 . get real ( ) , false ) ; }
public t dot product ( final field vector3 d < t > v ) { return x . linear combination ( x , v . x , y , v . y , z , v . z ) ; }
public vector3 d get point at ( final vector2 d in plane , final double offset ) { return new vector3 d ( in plane . get x ( ) , u , in plane . get y ( ) , v , offset - origin offset , w ) ; }
public vector3 d get a1 ( ) { return a1 ; }
public static vector3 d format get instance ( ) { return get instance ( locale . get default ( ) ) ; }
protect void set size ( final double size ) { this . size = size ; }
public location check point ( final vector < s > point ) { return check point ( ( point < s > ) point ) ; }
public sub hyperplane < s > get plus outside ( ) { return plus outside ; }
public boolean touch inside ( ) { return inside touch ! = null & & ! inside touch . be empty ( ) ; }
public arc get inside arc ( final circle other ) { final double alpha = get phase ( other . pole ) ; final double half pi = 0 . 5 * fast math . pi ; return new arc ( alpha - half pi , alpha + half pi , tolerance ) ; }
public s2 point get barycenter ( ) { if ( summed barycenter . get norm sq ( ) == 0 ) { return s2 point . na n ; } else { return new s2 point ( summed barycenter ) ; } }
public s2 point get barycenter ( ) { if ( summed barycenter . get norm sq ( ) == 0 ) { return s2 point . na n ; } else { return new s2 point ( summed barycenter ) ; } }
public s2 point get barycenter ( ) { if ( summed barycenter . get norm sq ( ) == 0 ) { return s2 point . na n ; } else { return new s2 point ( summed barycenter ) ; } }
public static < t extend field element < t > > t [ ] [ ] create block layout ( final field < t > field , final int row , final int column ) { final int block row = ( row + block_size - 1 ) / block_size ; final int block column = ( columns + block_size - 1 ) / block_size ; final t [ ] [ ] block = math array . build array ( field , block row * block column , -1 ) ; int block index = 0 ; for ( int i block = 0 ; i block < block row ; ++i block ) { final int p start = i block * block_size ; final int p end = fast math . min ( p start + block_size , row ) ; final int i height = p end - p start ; for ( int j block = 0 ; j block < block column ; ++j block ) { final int q start = j block * block_size ; final int q end = fast math . min ( q start + block_size , column ) ; final int j width = q end - q start ; block [ block index ] = math array . build array ( field , i height * j width ) ; ++block index ; } } return block ; }
protect void check row index ( final int row ) throw out of range exception { if ( row < 0 || row > = get row dimension ( ) ) { throw new out of range exception ( localized format . row_index , row , 0 , get row dimension ( ) - 1 ) ; } }
public int hash code ( ) { int hash code = get class ( ) . hash code ( ) ; for ( final int b : byte ) { hash code += b ; } return hash code ; }
protect static number format get default number format ( ) { return get default number format ( locale . get default ( ) ) ; }
public real vector map add ( double d ) { return copy ( ) . map add to self ( d ) ; }
public real vector map divide ( double d ) { return copy ( ) . map divide to self ( d ) ; }
public field matrix < t > outer product ( sparse field vector < t > v ) { final int n = v . get dimension ( ) ; sparse field matrix < t > res = new sparse field matrix < t > ( field , virtual size , n ) ; open int to field hash map < t > . iterator iter = entry . iterator ( ) ; while ( iter . have next ( ) ) { iter . advance ( ) ; open int to field hash map < t > . iterator iter2 = v . entry . iterator ( ) ; while ( iter2 . have next ( ) ) { iter2 . advance ( ) ; re . set entry ( iter . key ( ) , iter2 . key ( ) , iter . value ( ) . multiply ( iter2 . value ( ) ) ) ; } } return re ; }
public network get network ( ) { return network ; }
public field < t > get field ( ) { return field ; }
public void insert equation data ( double [ ] equation data , double [ ] complete ) throw dimension mismatch exception { if ( equation data . length ! = dimension ) { throw new dimension mismatch exception ( equation data . length , dimension ) ; } system . arraycopy ( equation data , 0 , complete , first index , dimension ) ; }
public double [ ] get primary state ( ) { return primary state . clone ( ) ; }
public t [ ] get secondary state ( final int index ) { return index == 0 ? state . clone ( ) : secondary state [ index - 1 ] . clone ( ) ; }
public void shift ( ) { global previous time = global current time ; soft previous time = global previous time ; soft current time = global current time ; }
public double get h p ( ) { return h p ; }
public real vector get coefficient ( ) { return coefficient ; }
protect final int get slack variable offset ( ) { return get num objective function ( ) + num decision variable ; }
protect real matrix compute weighted jacobian ( double [ ] params ) { return weight matrix sqrt . multiply ( matrix utils . create real matrix ( compute jacobian ( params ) ) ) ; }
protect real matrix compute weighted jacobian ( double [ ] params ) { return weight matrix sqrt . multiply ( matrix utils . create real matrix ( compute jacobian ( params ) ) ) ; }
public int get target size ( ) { return target . length ; }
public double get min ( ) { return low ; }
public double get min ( ) { return low ; }
public double [ ] guess parameter error ( ) { if ( row < = col ) { throw new number be too small exception ( localized format . no_degrees_of_freedom , row , col , false ) ; } double [ ] error = new double [ col ] ; final double c = fast math . sqrt ( get chi square ( ) / ( row - col ) ) ; double [ ] [ ] covar = compute covariance ( point , 1e-14 ) ; for ( int i = 0 ; i < error . length ; ++i ) { error [ i ] = fast math . sqrt ( covar [ i ] [ i ] ) * c ; } return error ; }
protect void update jacobian ( ) { final real matrix weight jacobian = compute weight jacobian ( point ) ; weight residual jacobian = weight jacobian . scalar multiply ( -1 ) . get data ( ) ; }
public random generator get random generator ( ) { if ( rand == null ) { init ran ( ) ; } return rand ; }
public static double regularize gamma p ( double a , double x ) { return regularize gamma p ( a , x , default_epsilon , integer . max_value ) ; }
public list < t > get point ( ) { return point ; }
public real matrix get correlation matrix ( ) { return rank correlation . get correlation matrix ( ) ; }
public real matrix compute correlation matrix ( final real matrix matrix ) { final real matrix matrix copy = rank transform ( matrix ) ; return new pearsons correlation ( ) . compute correlation matrix ( matrix copy ) ; }
public double get min ( ) { return apply ( min impl ) ; }
public double get min ( ) { return apply ( min impl ) ; }
public double get min ( ) { return apply ( min impl ) ; }
public double evaluate ( final double [ ] value , final double [ ] weight ) throw math illegal argument exception { return evaluate ( value , weight , 0 , value . length ) ; }
public double evaluate ( final double [ ] value , final double [ ] weight ) throw math illegal argument exception { return evaluate ( value , weight , 0 , value . length ) ; }
public double evaluate ( final double [ ] value , final double mean , final int begin , final int length ) throw math illegal argument exception { return fast math . sqrt ( variance . evaluate ( value , mean , begin , length ) ) ; }
public double evaluate ( final double [ ] value , final double [ ] weight ) throw math illegal argument exception { return evaluate ( value , weight , 0 , value . length ) ; }
public real matrix get result ( ) { int dimension = sum . length ; real matrix result = matrix utils . create real matrix ( dimension , dimension ) ; if ( n > 1 ) { double c = 1 . 0 / ( n * ( be bias correct ? ( n - 1 ) : n ) ) ; int k = 0 ; for ( int i = 0 ; i < dimension ; ++i ) { for ( int j = 0 ; j < = i ; ++j ) { double e = c * ( n * product sum [ k++ ] - sum [ i ] * sum [ j ] ) ; result . set entry ( i , j , e ) ; result . set entry ( j , i , e ) ; } } } return result ; }
public static p square marker new marker ( final list < double > initial five , final double p ) { return new marker ( initial five , p ) ; }
public double get sum ( ) { return sum impl . get result ( ) ; }
public double get sumsq ( ) { synchronize ( statistic ) { return statistic . get sumsq ( ) ; } }
public string to string ( ) { string buffer buff = new string buffer ( ) ; iterator iter = get option ( ) . iterator ( ) ; buff . append ( `` [ `` ) ; while ( iter . have next ( ) ) { option option = ( option ) iter . next ( ) ; if ( option . get opt ( ) ! = null ) { buff . append ( `` - `` ) ; buff . append ( option . get opt ( ) ) ; } else { buff . append ( `` -- `` ) ; buff . append ( option . get long opt ( ) ) ; } buff . append ( `` `` ) ; buff . append ( option . get description ( ) ) ; if ( iter . have next ( ) ) { buff . append ( `` , `` ) ; } } buff . append ( `` ] `` ) ; return buff . to string ( ) ; }
public int get unique count ( ) { return freq table . key set ( ) . size ( ) ; }
public void set elitism rate ( final double elitism rate ) throw out of range exception { if ( elitism rate < 0 || elitism rate > 1 ) { throw new out of range exception ( localized format . elitism_rate , elitism rate , 0 , 1 ) ; } this . elitism rate = elitism rate ; }
public double monte carlo p ( final double d , final int n , final int m , final boolean strict , final int iteration ) { return integral monte carlo p ( calculate integral d ( d , n , m , strict ) , n , m , iteration ) ; }
public static confidence interval get agresti coull interval ( int number of trial , int number of success , double confidence level ) { return agresti_coull . create interval ( number of trial , number of success , confidence level ) ; }
public void new sample data ( double [ ] data , int nob , int nvars ) { if ( data == null ) { throw new null argument exception ( ) ; } if ( data . length ! = nobs * ( nvars + 1 ) ) { throw new dimension mismatch exception ( data . length , nobs * ( nvars + 1 ) ) ; } if ( nobs < = nvars ) { throw new insufficient data exception ( localized format . insufficient_observed_points_in_sample , nobs , nvars + 1 ) ; } double [ ] y = new double [ nob ] ; final int col = no intercept ? nvars : nvars + 1 ; double [ ] [ ] x = new double [ nob ] [ col ] ; int pointer = 0 ; for ( int i = 0 ; i < nobs ; i++ ) { y [ i ] = data [ pointer++ ] ; if ( ! no intercept ) { x [ i ] [ 0 ] = 1 . 0d ; } for ( int j = no intercept ? 0 : 1 ; j < col ; j++ ) { x [ i ] [ j ] = data [ pointer++ ] ; } } this . x matrix = new array2 d row real matrix ( x ) ; this . y vector = new array real vector ( y ) ; }
public double calculate total sum of square ( ) { if ( be no intercept ( ) ) { return stat utils . sum sq ( get y ( ) . to array ( ) ) ; } else { return new second moment ( ) . evaluate ( get y ( ) . to array ( ) ) ; } }
public double calculate adjust r square ( ) { final double n = get x ( ) . get row dimension ( ) ; if ( be no intercept ( ) ) { return 1 - ( 1 - calculate r square ( ) ) * ( n / ( n - get x ( ) . get column dimension ( ) ) ) ; } else { return 1 - ( calculate residual sum of square ( ) * ( n - 1 ) ) / ( calculate total sum of square ( ) * ( n - get x ( ) . get column dimension ( ) ) ) ; } }
public long get n ( ) { return this . nob ; }
public void remove data ( final double x , final double y ) { if ( n > 0 ) { if ( have intercept ) { final double fact1 = n - 1 . 0 ; final double fact2 = n / ( n - 1 . 0 ) ; final double dx = x - xbar ; final double dy = y - ybar ; sum x x -= dx * dx * fact2 ; sum y y -= dy * dy * fact2 ; sum x y -= dx * dy * fact2 ; xbar -= dx / fact1 ; ybar -= dy / fact1 ; } else { final double fact1 = n - 1 . 0 ; sum x x -= x * x ; sum y y -= y * y ; sum x y -= x * y ; xbar -= x / fact1 ; ybar -= y / fact1 ; } sum x -= x ; sum y -= y ; n -- ; } }
public double predict ( final double x ) { final double b1 = get slope ( ) ; if ( have intercept ) { return get intercept ( b1 ) + b1 * x ; } return b1 * x ; }
public static double sum sq ( final double [ ] value , final int begin , final int length ) throw math illegal argument exception { return sum_of_squares . evaluate ( value , begin , length ) ; }
public static double geometric mean ( final double [ ] value , final int begin , final int length ) throw math illegal argument exception { return geometric_mean . evaluate ( value , begin , length ) ; }
public double evaluate ( final double [ ] value ) throw math illegal argument exception { return fast math . sqrt ( variance . evaluate ( value ) ) ; }
public double [ ] get mean ( ) { return math array . copy of ( mean ) ; }
public k get key ( ) { return key ; }
public boolean equal ( object obj ) { if ( obj == this ) { return true ; } if ( obj instanceof map . entry == false ) { return false ; } map . entry other = ( map . entry ) obj ; return ( get key ( ) == null ? other . get key ( ) == null : get key ( ) . equal ( other . get key ( ) ) ) & & ( get value ( ) == null ? other . get value ( ) == null : get value ( ) . equal ( other . get value ( ) ) ) ; }
public static boolean equal include na n ( float x , float y , float eps ) { return equal include na n ( x , y ) || ( fast math . ab ( y - x ) < = eps ) ; }
public number transformer get transformer ( class < ? > key ) { return map . get ( key ) ; }
public string lookup constant string lookup ( ) { return constant string lookup . instance ; }
public integer get threshold ( ) { return threshold ; }
public string tokenizer set ignore empty token ( final boolean ignore empty token ) { this . ignore empty token = ignore empty token ; return this ; }
public str tokenizer set ignore char ( char ignore ) { return set ignore matcher ( str matcher . char matcher ( ignore ) ) ; }
public str builder appendln ( object obj ) { return append ( obj ) . append new line ( ) ; }
public str builder appendln ( object obj ) { return append ( obj ) . append new line ( ) ; }
public text string builder append separator ( final string separator , final int loop index ) { if ( separator ! = null & & loop index > 0 ) { append ( separator ) ; } return this ; }
public string lookup base64 encoder string lookup ( ) { return string lookup factory . instance_base64_encoder ; }
public int get size a ( ) { return size a ; }
public char [ ] get char ( char [ ] destination ) { int len = length ( ) ; if ( destination == null || destination . length < len ) { destination = new char [ len ] ; } system . arraycopy ( buffer , 0 , destination , 0 , len ) ; return destination ; }
public static big decimal validator get instance ( ) { return validator ; }
public string validate ( string value ) { if ( value == null ) { return null ; } for ( int i = 0 ; i < pattern . length ; i++ ) { matcher matcher = pattern [ i ] . matcher ( value ) ; if ( matcher . match ( ) ) { int count = matcher . group count ( ) ; if ( count == 1 ) { return matcher . group ( 1 ) ; } string buffer buffer = new string buffer ( ) ; for ( int j = 0 ; j < count ; j++ ) { string component = matcher . group ( j+1 ) ; if ( component ! = null ) { buffer . append ( component ) ; } } return buffer . to string ( ) ; } } return null ; }
public void generate key ( ) { if ( this . be indexed ( ) ) { this . key = this . indexed list property + token_indexed + `` . `` + this . property ; } else { this . key = this . property ; } }
public string get depends ( ) { return this . depend ; }
public list get field ( ) { return collection . unmodifiable list ( l field ) ; }
public void generate key ( ) { if ( this . be indexed ( ) ) { this . key = this . indexed list property + token_indexed + `` . `` + this . property ; } else { this . key = this . property ; } }
public string display key ( ) { string buffer result = new string buffer ( ) ; if ( language ! = null & & language . length ( ) > 0 ) { result . append ( `` language= `` ) ; result . append ( language ) ; } if ( country ! = null & & country . length ( ) > 0 ) { if ( result . length ( ) > 0 ) { result . append ( `` , `` ) ; } result . append ( `` country= `` ) ; result . append ( country ) ; } if ( variant ! = null & & variant . length ( ) > 0 ) { if ( result . length ( ) > 0 ) { result . append ( `` , `` ) ; } result . append ( `` variant= `` ) ; result . append ( variant ) ; } if ( result . length ( ) == 0 ) { result . append ( `` default `` ) ; } return result . to string ( ) ; }
public boolean be valid i s b n13 ( string code ) { return isbn13 validator . be valid ( code ) ; }
public boolean be valid ( string code ) { return ( be valid i s b n13 ( code ) || be valid i s b n10 ( code ) ) ; }
public calendar validate ( string value , locale locale , time zone time zone ) { return ( calendar ) parse ( value , ( string ) null , locale , time zone ) ; }
protect object parse ( string value , string pattern , locale locale , time zone time zone ) { value = ( value == null ? null : value . trim ( ) ) ; if ( value == null || value . length ( ) == 0 ) { return null ; } date format formatter = ( date format ) get format ( pattern , locale ) ; if ( time zone ! = null ) { formatter . set time zone ( time zone ) ; } return parse ( value , formatter ) ; }
public big integer validate ( string value ) { return ( big integer ) parse ( value , ( string ) null , ( locale ) null ) ; }
public calendar validate ( string value , string pattern , time zone time zone ) { return ( calendar ) parse ( value , pattern , ( locale ) null , time zone ) ; }
public calendar validate ( string value , string pattern , locale locale , time zone time zone ) { return ( calendar ) parse ( value , pattern , locale , time zone ) ; }
public string calculate ( string code ) throw check digit exception { if ( code == null || code . length ( ) == 0 ) { throw new check digit exception ( `` isbn code be miss `` ) ; } else if ( code . length ( ) == 9 ) { return isbn10_check_digit . calculate ( code ) ; } else if ( code . length ( ) == 12 ) { return isbn13_check_digit . calculate ( code ) ; } else { throw new check digit exception ( `` invalid isbn length = `` + code . length ( ) ) ; } }
public string calculate ( string code ) throw check digit exception { if ( code == null || code . length ( ) == 0 ) { throw new check digit exception ( `` isbn code be miss `` ) ; } else if ( code . length ( ) == 9 ) { return isbn10_check_digit . calculate ( code ) ; } else if ( code . length ( ) == 12 ) { return isbn13_check_digit . calculate ( code ) ; } else { throw new check digit exception ( `` invalid isbn length = `` + code . length ( ) ) ; } }
public string calculate ( string code ) throw check digit exception { if ( code == null || code . length ( ) == 0 ) { throw new check digit exception ( `` code be miss `` ) ; } int modulus result = calculate modulus ( code , false ) ; int char value = ( modulus - modulus result ) % modulus ; return to check digit ( char value ) ; }
public date validate ( string value , time zone time zone ) { return ( date ) parse ( value , ( string ) null , ( locale ) null , time zone ) ; }
public boolean be valid generic tld ( string g tld ) { return generic_tld_list . contains ( chomp lead dot ( g tld . to lower case ( ) ) ) ; }
public boolean be valid country code tld ( string cc tld ) { return country_code_tld_list . contains ( chomp lead dot ( cc tld . to lower case ( ) ) ) ; }
public boolean be valid country code tld ( string cc tld ) { return country_code_tld_list . contains ( chomp lead dot ( cc tld . to lower case ( ) ) ) ; }
public float validate ( string value ) { return ( float ) parse ( value , ( string ) null , ( locale ) null ) ; }
public boolean be valid ( string inet address ) { return be valid inet4 address ( inet address ) ; }
public calendar validate ( string value , time zone time zone ) { return ( calendar ) parse ( value , ( string ) null , ( locale ) null , time zone ) ; }
public validator action get validator action ( string key ) { return ( validator action ) h action . get ( key ) ; }
public string get msg ( ) { return msg ; }
public void add validator action ( validator action va ) { va . init ( ) ; this . h action . put ( va . get name ( ) , va ) ; if ( get log ( ) . be debug enable ( ) ) { get log ( ) . debug ( `` add validator action : `` + va . get name ( ) + `` , `` + va . get classname ( ) ) ; } }
public boolean contains field ( string field name ) { return this . h field . contains key ( field name ) ; }
public map get validator action ( ) { return collection . unmodifiable map ( h action ) ; }
public validator result get validator result ( string key ) { return ( validator result ) this . h result . get ( key ) ; }
public var get var ( string main key ) { return ( var ) h var . get ( main key ) ; }
public static generator get generator ( j j doc context context ) { if ( j j doc globals . generator == null ) { if ( context . get text ( ) ) { j j doc globals . generator = new text generator ( context ) ; } else if ( context . get b n f ( ) ) { j j doc globals . generator = new b n f generator ( context ) ; } else if ( context . get x text ( ) ) { j j doc globals . generator = new x text generator ( context ) ; } else if ( context . get j c c ( ) ) { j j doc globals . generator = new j c c generator ( context ) ; } else { j j doc globals . generator = new h t m l generator ( context ) ; } } else { if ( context . get text ( ) ) { if ( j j doc globals . generator instanceof h t m l generator ) { j j doc globals . generator = new text generator ( context ) ; } } else if ( context . get b n f ( ) ) { j j doc globals . generator = new b n f generator ( context ) ; } else if ( context . get x text ( ) ) { j j doc globals . generator = new x text generator ( context ) ; } else if ( context . get j c c ( ) ) { j j doc globals . generator = new j c c generator ( context ) ; } else { if ( j j doc globals . generator instanceof text generator ) { j j doc globals . generator = new h t m l generator ( context ) ; } } } return j j doc globals . generator ; }
public final boolean get visitor ( ) { return option . boolean value ( `` visitor `` ) ; }
public final boolean get build node file ( ) { return option . boolean value ( `` build_node_files `` ) ; }
public final string get node extends ( ) { return option . string value ( `` node_extends `` ) ; }
public final string get c s s ( ) { return option . string value ( `` css `` ) ; }
public static string string value ( final string option ) { return ( string ) option . option value . get ( option ) ; }
public static boolean get unicode input ( ) { return option . boolean value ( option . useroption__unicode_input ) ; }
public static boolean get unicode input ( ) { return option . boolean value ( option . useroption__unicode_input ) ; }
public static string get token manager include ( ) { return option . string value ( option . useroption__cpp_token_manager_include ) ; }
public static boolean get unicode input ( ) { return option . boolean value ( option . useroption__unicode_input ) ; }
public void append to ( multi path mp ) { if ( ! gi . be in range ( 0 , cp . num point ( ) ) ) throw new illegal argument exception ( `` group iterator not in range `` ) ; ; int n = mp . get dimension ( ) ; double [ ] d = new double [ n + 1 ] ; d [ n ] = t_min ; eval ( d ) ; if ( connect ) mp . line to ( d ) ; else mp . move to ( d ) ; binary curve approximation algorithm . gen pt ( this , t_min , t_max , mp ) ; }
public void set use default interval ( boolean b ) { use default interval = b ; }
public curve get curve ( int index ) { return ( curve ) curve bag . get ( index ) ; }
public point get point ( int index ) { return ( point ) point bag . get ( index ) ; }
public int get to index ( ) { return to index ; }
public boolean have next ( ) { return index_i < group . length ; }
public boolean get close ( ) { return close ; }
public void trim array ( ) { if ( size < value . length ) { double [ ] arr = new double [ size ] ; for ( int i = 0 ; i < size ; i++ ) arr [ i ] = value [ i ] ; value = arr ; } }
protect void check before accept ( expression x ) { if ( x == null ) throw new illegal argument exception ( `` expression can not be null `` ) ; if ( x . parent ! = null ) throw new illegal argument exception ( `` expression must be remove parent `` ) ; if ( be descendent ( x ) ) throw new illegal argument exception ( `` cyclic reference `` ) ; }
public double of ( double [ ] d , int num param ) { return java . lang . math . asin ( d [ 0 ] ) ; }
public double of ( double [ ] d , int num param ) { double a = math . sqrt ( ( d [ 0 ] + 1 ) / 2 ) ; double b = math . sqrt ( ( d [ 0 ] - 1 ) / 2 ) ; return 2 * math . log ( a + b ) ; }
public double of ( double [ ] d , int num param ) { return java . lang . math . sin ( d [ 0 ] ) ; }
public boolean accept num param ( int num param ) { return num param == 1 || num param == 2 ; }
public double of ( double [ ] d , int num param ) { return ( math . pow ( math . e , d [ 0 ] ) - math . pow ( math . e , -d [ 0 ] ) ) / 2 ; }
public double of ( double [ ] d , int num param ) { return java . lang . math . tan ( d [ 0 ] ) ; }
public double of ( double [ ] d , int num param ) { return java . lang . math . ceil ( d [ 0 ] ) ; }
public string [ ] get variable name ( ) { string [ ] arr = new string [ num var ] ; for ( int i = 0 ; i < arr . length ; i++ ) arr [ i ] = name [ i ] ; return arr ; }
public void remove ( string func name ) { for ( int i = 0 ; i < num func ; i++ ) { if ( case sensitive & & name [ i ] . equal ( func name ) || ! case sensitive & & name [ i ] . equal ignore case ( func name ) ) { for ( int j = i + 1 ; j < num func ; j++ ) { name [ j - 1 ] = name [ j ] ; func [ j - 1 ] = func [ j ] ; } num func -- ; name [ num func ] = null ; func [ num func ] = null ; break ; } } }
public double n cr ( int n , int r ) { if ( n < 0 || r < 0 || r > n ) return 0 ; if ( n > = share data . pt . length ) { int d = 2 * share data . pt . length ; double [ ] [ ] pt2 = null ; if ( n > d ) pt2 = new double [ n + 1 ] [ ] ; else pt2 = new double [ d + 1 ] [ ] ; for ( int i = 0 ; i < share data . pt . length ; i++ ) pt2 [ i ] = share data . pt [ i ] ; for ( int i = share data . pt . length ; i < pt2 . length ; i++ ) { pt2 [ i ] = new double [ ( i / 2 ) + 1 ] ; pt2 [ i ] [ 0 ] = 1 ; for ( int j = 1 ; j < pt2 [ i ] . length ; j++ ) { double x = pt2 [ i-1 ] [ j-1 ] ; if ( j < pt2 [ i-1 ] . length ) x = x + pt2 [ i-1 ] [ j ] ; else x = 2 * x ; pt2 [ i ] [ j ] = x ; } } share data . pt = pt2 ; } if ( 2 * r > n ) r = n - r ; return share data . pt [ n ] [ r ] ; }
public string [ ] get variable name ( ) { string [ ] arr = new string [ num var ] ; for ( int i = 0 ; i < arr . length ; i++ ) arr [ i ] = name [ i ] ; return arr ; }
public class < ? extend view config > get from view ( ) { return from view ; }
public bean builder < t > nullable ( boolean nullable ) { this . nullable = nullable ; return this ; }
public class < ? > load system class ( final string name ) throw class not find exception { if ( system . get security manager ( ) == null ) { class loader system class loader = class loader . get system class loader ( ) ; return ( system class loader ! = null ) ? system class loader . load class ( name ) : boot class loader holder . boot class loader . load class ( name ) ; } try { return access controller . do privilege ( new privilege exception action < class < ? > > ( ) { @ override public class < ? > run ( ) throw exception { class loader system class loader = class loader . get system class loader ( ) ; return ( system class loader ! = null ) ? system class loader . load class ( name ) : boot class loader holder . boot class loader . load class ( name ) ; } } , control context ) ; } catch ( privileged action exception e ) { if ( e . get exception ( ) instanceof class not find exception ) throw ( class not find exception ) e . get exception ( ) ; throw ( runtime exception ) e . get exception ( ) ; } }
public static project stage producer get instance ( ) { if ( project stage producer == null ) { lazy init ( ) ; } if ( project stage == null ) { project stage producer . init project stage ( ) ; } return project stage producer ; }
public final boolean be static ( ) { return modifier . be static ( get modifier ( ) ) ; }
public static boolean be static ( class < ? > type ) { return modifier . be static ( type . get modifier ( ) ) ; }
public list < object > parse list element ( element collection ele , bean definition bd ) { string default element type = collection ele . get attribute ( value_type_attribute ) ; node list nl = collection ele . get child node ( ) ; manage list < object > target = new manage list < object > ( nl . get length ( ) ) ; target . set source ( extract source ( collection ele ) ) ; target . set element type name ( default element type ) ; target . set merge enable ( parse merge attribute ( collection ele ) ) ; parse collection element ( nl , target , bd , default element type ) ; return target ; }
public static document factory get instance ( ) { return singleton ; }
public datatype element factory get element factory ( q name element q name ) { datatype element factory result = null ; if ( do_intern_qname ) { element q name = intern ( element q name ) ; } document factory factory = element q name . get document factory ( ) ; if ( factory instanceof datatype element factory ) { result = ( datatype element factory ) factory ; } return result ; }
public short compare document position ( node other ) throw d o m exception { d o m exception ex = new d o m exception ( d o m exception . not_supported_err , `` dom level 3 interface be not fully implement in jaxen 's namespace node class `` ) ; throw ex ; }
public string get attribute name ( ) { return attribute name ; }
public void set value ( string value ) { this . value = value ; }
public void set element name ( string element name ) { this . element name = element name ; }
public element handler remove handler ( string handler path ) { return handler . remove ( handler path ) ; }
public org . w3c . dom . document get document ( ) { if ( document == null ) { document = create document ( ) ; } return ( org . w3c . dom . document ) document ; }
public static s a x parser new s a x parser ( string schema language , source . . . schema ) throw s a x exception , parser configuration exception { return new s a x parser ( schema language , true , false , schema ) ; }
public void internal entity decl ( string name , string value ) throw s a x exception { if ( internal d t dsubset ) { if ( include internal d t d declaration ) { add d t d declaration ( new internal entity decl ( name , value ) ) ; } } else { if ( include external d t d declaration ) { add external d t d declaration ( new internal entity decl ( name , value ) ) ; } } }
protect void add d t d declaration ( decl declaration ) { if ( internal d t d declaration == null ) { internal d t d declaration = new array list < decl > ( ) ; } internal d t d declaration . add ( declaration ) ; }
public document read ( reader reader , string system id ) throw document exception { input source source = new input source ( reader ) ; source . set system id ( system id ) ; if ( this . encode ! = null ) { source . set encoding ( this . encode ) ; } return read ( source ) ; }
public void set x m l reader ( x m l reader reader ) { this . xml reader = reader ; }
public org . w3c . dom . document get document ( ) { if ( document == null ) { document = create document ( ) ; } return ( org . w3c . dom . document ) document ; }
public void set priority ( double priority ) { this . priority = priority ; }
public void set source ( object source ) { this . source = source ; this . row = null ; }
protect namespace create namespace ( string prefix , string namespace u r i ) { return document factory . create namespace ( prefix , namespace u r i ) ; }
public static string trim trail whitespace ( string str ) { if ( ! have length ( str ) ) { return str ; } string builder sb = new string builder ( str ) ; while ( sb . length ( ) > 0 & & character . be whitespace ( sb . char at ( sb . length ( ) - 1 ) ) ) { sb . delete char at ( sb . length ( ) - 1 ) ; } return sb . to string ( ) ; }
public string get text ( ) { return text ; }
public t instantiate anonymous subclass ( ) { class < t > proxy class = give dynamic subclass ( type ) ; return objenesis helper . new instance ( proxy class ) ; }
public iterator < field > iterator ( ) { return create field list ( ) . iterator ( ) ; }
public string get type ( ) { return type ; }
protect static final string trim separator ( string s ) { return s . end with ( `` / `` ) ? s . substring ( 0 , s . length ( ) - 1 ) : s ; }
public boolean try read current xml element ( ews xml reader reader ) throw exception { if ( reader . get local name ( ) . equal ignore case ( xml element name . error ) ) { this . error = autodiscover error . parse ( reader ) ; return true ; } else { return false ; } }
public array list < protocol connection > get connection ( ) { return this . connection ; }
protect get domain setting response create response instance ( ) { return new get domain setting response ( ) ; }
public void skip element ( string namespace prefix , string local name ) throw exception { if ( ! this . be end element ( namespace prefix , local name ) ) { if ( ! this . be start element ( namespace prefix , local name ) ) { this . read start element ( namespace prefix , local name ) ; } if ( ! this . be empty element ( ) ) { do { this . read ( ) ; } while ( ! this . be end element ( namespace prefix , local name ) ) ; } } }
public static print writer init h t m l ( servlet response response , string title ) throw i o exception { response . set content type ( `` text/html `` ) ; print writer out = response . get writer ( ) ; out . println ( `` < html > \n `` + `` < link rel='stylesheet ' type='text/css ' href='/static/hadoop . cs ' > \n `` + `` < title > `` + title + `` < /title > \n `` + `` < body > \n `` + `` < h1 > `` + title + `` < /h1 > \n `` ) ; return out ; }
public int get index ( class [ ] parameter type ) { final constructor [ ] constructor = this . type . get constructor ( ) ; boolean eq ; for ( int i = 0 ; i < constructor . length ; ++i ) { if ( ! modifier . be public ( constructor [ i ] . get modifier ( ) ) ) { continue ; } final class [ ] params = constructor [ i ] . get parameter type ( ) ; if ( params . length ! = parameter type . length ) { continue ; } eq = true ; for ( int j = 0 ; j < params . length ; ++j ) { if ( ! params [ j ] . equal ( parameter type [ j ] ) ) { eq = false ; break ; } } if ( eq ) { return i ; } } return -1 ; }
public void skip element ( string namespace prefix , string local name ) throw exception { if ( ! this . be end element ( namespace prefix , local name ) ) { if ( ! this . be start element ( namespace prefix , local name ) ) { this . read start element ( namespace prefix , local name ) ; } if ( ! this . be empty element ( ) ) { do { this . read ( ) ; } while ( ! this . be end element ( namespace prefix , local name ) ) ; } } }
public void read start element ( string namespace prefix , string local name ) throw exception { this . internal read element ( namespace prefix , local name , new xml node type ( xml node type . start_element ) ) ; }
public void skip element ( string namespace prefix , string local name ) throw exception { if ( ! this . be end element ( namespace prefix , local name ) ) { if ( ! this . be start element ( namespace prefix , local name ) ) { this . read start element ( namespace prefix , local name ) ; } if ( ! this . be empty element ( ) ) { do { this . read ( ) ; } while ( ! this . be end element ( namespace prefix , local name ) ) ; } } }
public void skip element ( string namespace prefix , string local name ) throw exception { if ( ! this . be end element ( namespace prefix , local name ) ) { if ( ! this . be start element ( namespace prefix , local name ) ) { this . read start element ( namespace prefix , local name ) ; } if ( ! this . be empty element ( ) ) { do { this . read ( ) ; } while ( ! this . be end element ( namespace prefix , local name ) ) ; } } }
public service error get error code ( ) { return this . response . get error code ( ) ; }
public int get minor build number ( ) { return minor build number ; }
public void set minor build number ( int minor build number ) { this . minor build number = minor build number ; }
public int get major build number ( ) { return major build number ; }
public get event result end get event ( i async result async result ) throw exception { get event request request = async request result . extract service request ( this , async result ) ; return request . end execute ( async result ) . get response at index ( 0 ) . get result ( ) ; }
public oof setting get user oof setting ( string smtp address ) throw exception { ews utility . validate param ( smtp address , `` smtp address `` ) ; get user oof setting request request = new get user oof setting request ( this ) ; request . set smtp address ( smtp address ) ; return request . execute ( ) . get oof setting ( ) ; }
@ override public void process http error response ( http web request http web response , exception web exception ) throw exception { this . internal process http error response ( http web response , web exception , trace flag . ew response http header , trace flag . ew response ) ; }
public web proxy get web proxy ( ) { return this . web proxy ; }
protect void delete property ( property definition property definition ) { if ( ! this . deleted property . contains key ( property definition ) ) { object property value = null ; if ( this . property . contains key ( property definition ) ) { property value = this . property . get ( property definition ) ; } this . property . remove ( property definition ) ; this . modified property . remove ( property definition ) ; this . deleted property . put ( property definition , property value ) ; if ( property value instanceof complex property ) { complex property complex property = ( complex property ) property value ; complex property . add on change event ( this ) ; } } }
public void clear change log ( ) { this . deleted property . clear ( ) ; this . modified property . clear ( ) ; this . added property . clear ( ) ; iterator < entry < property definition , object > > it = this . property . entry set ( ) . iterator ( ) ; while ( it . have next ( ) ) { entry < property definition , object > key value pair = it . next ( ) ; if ( key value pair . get value ( ) instanceof complex property ) { complex property complex property = ( complex property ) key value pair . get value ( ) ; complex property . clear change log ( ) ; } } this . be dirty = false ; }
public void set filter html content ( boolean filter html ) { this . throw if readonly ( ) ; this . filter html = filter html ; }
public list < delegate user > get delegate user ( ) { return this . delegate user ; }
protect string empty element tag closer ( string display name , int name code ) { return `` / > `` ; }
protect folder id get parent folder id ( ) { return this . parent folder id ; }
public void set parent item id ( string parent item id ) { this . parent item id = parent item id ; }
public email address get email address ( ) { return this . email address ; }
protect folder id wrapper get folder id ( ) { return this . folder id ; }
public void set query string ( string query string ) { this . query string = query string ; }
public boolean get include permission ( ) { return this . include permission ; }
public property set get contact data property set ( ) { return this . contact data property set ; }
protect user configuration get user configuration ( ) { return this . user configuration ; }
public input stream get error stream ( ) throw e w s http exception { throw if response be null ( ) ; buffer input stream buffer input stream = null ; try { buffered input stream = new buffer input stream ( response . get entity ( ) . get content ( ) ) ; } catch ( exception e ) { throw new e w s http exception ( `` connection error `` + e ) ; } return buffered input stream ; }
public string get response text ( ) throw e w s http exception { throw if response be null ( ) ; return response . get status line ( ) . get reason phrase ( ) ; }
public boolean be allow authentication ( ) { return allow authentication ; }
public web proxy get proxy ( ) { return proxy ; }
public void set item id ( item id item id ) { this . item id = item id ; }
public string get name to resolve ( ) { return this . name to resolve ; }
public void set oof setting ( oof setting oof setting ) { this . oof setting = oof setting ; }
public void set sync state ( string value ) { this . sync state = value ; }
protect string getmailbox smtp address ( ) { return this . mailbox smtp address ; }
public conflict resolution mode get conflict resolution mode ( ) { return this . conflict resolution mode ; }
public void set oof setting ( oof setting oof setting ) { this . oof setting = oof setting ; }
protect boolean get batch processing stop ( ) { return ( this . result == service result . warning ) & & ( this . error code == service error . error batch processing stop ) ; }
protect boolean get batch processing stop ( ) { return ( this . result == service result . warning ) & & ( this . error code == service error . error batch processing stop ) ; }
protect folder change create change instance ( ) { return new folder change ( ) ; }
public find folder result find folder ( folder view view ) throw exception { this . throw if this be new ( ) ; return this . get service ( ) . find folder ( this . get id ( ) , view ) ; }
public folder id get parent folder id ( ) throw service local exception { return get property bag ( ) . get object from property definition ( item schema . parent folder id ) ; }
public calendar action result accept ( boolean send response ) throw exception { return this . internal accept ( false , send response ) ; }
public calendar action result accept ( boolean send response ) throw exception { return this . internal accept ( false , send response ) ; }
public date get appointment reply time ( ) throw service local exception { return get property bag ( ) . get object from property definition ( appointment schema . appointment reply time ) ; }
public boolean get be meet ( ) throw service local exception { return get property bag ( ) . get object from property definition ( appointment schema . be meet ) ; }
public email address get organizer ( ) throw service local exception { return get property bag ( ) . get object from property definition ( appointment schema . organizer ) ; }
public attendee collection get require attendee ( ) throw service local exception { return get property bag ( ) . get object from property definition ( appointment schema . require attendee ) ; }
public void set start time zone ( time zone definition value ) throw exception { this . get property bag ( ) . set object from property definition ( appointment schema . start time zone , value ) ; }
public void set contact picture ( byte [ ] content ) throw exception { ews utility . validate method version ( this . get service ( ) , exchange version . exchange2010 , `` set contact picture `` ) ; internal remove contact picture ( ) ; file attachment file attachment = get attachment ( ) . add file attachment ( contact picture name , content ) ; file attachment . set be contact photo ( true ) ; }
public string get display name ( ) throw exception { return ( string ) this . get object from property definition ( contact schema . display name ) ; }
public contact source get contact source ( ) throw service local exception { return get property bag ( ) . get object from property definition ( contact schema . contact source ) ; }
public email address get manager mailbox ( ) throw service local exception { return get property bag ( ) . get object from property definition ( contact schema . manager mailbox ) ; }
public void set mileage ( string value ) throw exception { this . get property bag ( ) . set object from property definition ( contact schema . mileage , value ) ; }
public void set job title ( string value ) throw exception { this . get property bag ( ) . set object from property definition ( contact schema . job title , value ) ; }
public void set initial ( string value ) throw exception { this . get property bag ( ) . set object from property definition ( contact schema . initial , value ) ; }
public string get spouse name ( ) throw service local exception { return get property bag ( ) . get object from property definition ( contact schema . spouse name ) ; }
public contact source get contact source ( ) throw service local exception { return get property bag ( ) . get object from property definition ( contact schema . contact source ) ; }
public contact source get contact source ( ) throw service local exception { return get property bag ( ) . get object from property definition ( contact schema . contact source ) ; }
public string list get global unique recipient ( ) throw exception { return get property bag ( ) . get object from property definition ( conversation schema . global unique recipient ) ; }
public boolean get have attachment ( ) throw service local exception { return get property bag ( ) . < boolean > get object from property definition ( conversation schema . have attachment ) ; }
public email address collection get to recipient ( ) throw service local exception { return get property bag ( ) . get object from property definition ( email message schema . to recipient ) ; }
public byte [ ] get conversation index ( ) throw service local exception { return get property bag ( ) . get object from property definition ( email message schema . conversation index ) ; }
public void set sender ( email address value ) throw exception { this . get property bag ( ) . set object from property definition ( email message schema . sender , value ) ; }
public void set be delivery receipt request ( boolean value ) throw exception { this . get property bag ( ) . set object from property definition ( email message schema . be delivery receipt request , value ) ; }
public boolean get be from me ( ) throw service local exception { return get property bag ( ) . < boolean > get object from property definition ( item schema . be from me ) ; }
public void set culture ( string value ) throw exception { this . get property bag ( ) . set object from property definition ( item schema . culture , value ) ; }
public date get original start ( ) throw service local exception { return get property bag ( ) . get object from property definition ( appointment schema . original start ) ; }
public email address get sender ( ) throw service local exception { return get property bag ( ) . get object from property definition ( email message schema . sender ) ; }
public integer get total work ( ) throw service local exception { return get property bag ( ) . get object from property definition ( task schema . total work ) ; }
public decline meeting invitation message create decline message ( ) throw exception { return new decline meeting invitation message ( this ) ; }
public message body get body prefix ( ) throw exception { return ( message body ) this . get object from property definition ( response object schema . body prefix ) ; }
@ override public service object schema get schema ( ) { return conversation schema . instance ; }
protect void register internal property ( property definition property ) { this . register property ( property , true ) ; }
protect void add on change event ( i create service object with attachment param change ) { on change list . add ( change ) ; }
public iterable < t key > get modify item ( ) { return this . modified item ; }
public boolean contains ( property definition property definition ) { return this . property . contains key ( property definition ) ; }
public boolean try get value ( object key , out param < object > value ) { if ( this . dictionary . contains key ( key ) ) { value . set param ( this . dictionary . get ( key ) ) ; return true ; } else { value . set param ( null ) ; return false ; } }
public web proxy get web proxy ( ) { return this . web proxy ; }
protect void set ew url ( uri value ) { ews url = value ; }
public int get weight ( ) { return weight ; }
public string map path ( string path ) { return null ; }
public string map path ( string path ) { return null ; }
public boolean be exclude conflict ( ) { return exclude conflict ; }
public void set attendee type ( meet attendee type attendee type ) { this . attendee type = attendee type ; }
public void set maximum suggestion per day ( int value ) { if ( value < 0 || value > 48 ) { throw new illegal argument exception ( string . format ( `` % s , % s , % s , % s `` , `` % s must be between % d and % d . `` , `` maximum suggestion per day `` , 0 , 48 ) ) ; } this . maximum suggestion per day = value ; }
public int get maximum suggestion per day ( ) { return this . maximum suggestion per day ; }
public void set merge free busy interval ( int value ) { if ( value < 5 || value > 1440 ) { throw new illegal argument exception ( string . format ( `` % s , % s , % s , % s `` , `` % s must be between % d and % d . `` , `` merge free busy interval `` , 5 , 1440 ) ) ; } this . merge free busy interval = value ; }
public time window get detailed suggestion window ( ) { return this . detailed suggestion window ; }
public suggestion response get suggestion response ( ) { return this . suggestion response ; }
protect void set delta ( time span delta ) { this . delta = delta ; }
protect boolean get have transition time ( ) { return this . month > = 1 & & this . month < = 12 ; }
public static string get string from message body ( message body message body ) throw exception { ews utility . validate param ( message body , `` message body `` ) ; return message body . text ; }
public long get duration ( ) { return this . end time . get time ( ) - this . start time . get time ( ) ; }
public meeting response get meeting response ( ) { return this . meeting response ; }
protect conversation id get conversation id ( ) { return this . conversation id ; }
public void set conversation id ( conversation id value ) { this . conversation id = value ; }
public void set format ( id format format ) { this . format = format ; }
public string get name ( ) { return this . name ; }
protected exchange service get session ( ) { return this . service ; }
protected exchange service get session ( ) { return this . service ; }
public string get fault string ( ) { return fault string ; }
protect void set response code ( service error response code ) { this . response code = response code ; }
protect void set fault actor ( string fault actor ) { this . fault actor = fault actor ; }
protect void set line number ( int line number ) { this . line number = line number ; }
public byte [ ] get xml data ( ) throw property exception { this . validate property access ( user configuration property . xml data ) ; return this . xml data ; }
public i async result begin unsubscribe ( async callback callback , object state ) throw exception { return this . get service ( ) . begin unsubscribe ( callback , state , this . get id ( ) ) ; }
public stream subscription get subscription ( ) { return this . subscription ; }
public void set content location ( string value ) { if ( this . can set field value ( this . content location , value ) ) { this . content location = value ; this . change ( ) ; } }
public boolean get be inline ( ) throw service version exception { ews utility . validate property version ( this . get owner ( ) . get service ( ) , exchange version . exchange2010 , `` be inline `` ) ; return this . be inline ; }
public boolean remove ( attachment attachment ) throw exception { ews utility . validate param ( attachment , `` attachment `` ) ; return this . internal remove ( attachment ) ; }
public void add ( attendee attendee ) { this . internal add ( attendee ) ; }
protected list < day of the week > get day of week ( ) { return day of week ; }
public long get end time ( ) { return end time ; }
protect void remove from change log ( t complex property complex property ) { this . remove item . remove ( complex property ) ; this . modified item . remove ( complex property ) ; this . added item . remove ( complex property ) ; }
protect void remove from change log ( t complex property complex property ) { this . remove item . remove ( complex property ) ; this . modified item . remove ( complex property ) ; this . added item . remove ( complex property ) ; }
public void set permission level ( folder permission level value ) throw service local exception { if ( this . permission level ! = value ) { if ( value == folder permission level . custom ) { throw new service local exception ( `` the permission level property ca n't be set to folder permission level . custom . `` + `` to define a custom permission , set it individual property to the value you want . `` ) ; } this . assign individual permission ( default permission . get member ( ) . get ( value ) ) ; if ( this . can set field value ( this . permission level , value ) ) { this . permission level = value ; this . change ( ) ; } } }
public boolean get receive copy of meeting message ( ) { return this . receive copy of meeting message ; }
public void set name ( string name ) { if ( this . can set field value ( this . name , name ) ) { this . name = name ; this . change ( ) ; } }
public void set id ( item id id ) { if ( this . can set field value ( this . id , id ) ) { this . id = id ; this . change ( ) ; } }
public void set rout type ( string rout type ) { if ( this . can set field value ( this . rout type , rout type ) ) { this . rout type = rout type ; this . change ( ) ; } }
public void set name ( string name ) { if ( this . can set field value ( this . name , name ) ) { this . name = name ; this . change ( ) ; } }
public boolean equal ( object obj ) { if ( this == obj ) { return true ; } if ( obj instanceof extend property definition ) { return extend property definition . be equal to ( this , ( extended property definition ) obj ) ; } else { return false ; } }
protect void set content ( byte [ ] content ) { this . throw if this be not new ( ) ; this . content = content ; this . file name = null ; this . content stream = null ; }
public boolean remove ( folder id folder id ) throw exception { ews utility . validate param ( folder id , `` folder id `` ) ; return this . internal remove ( folder id ) ; }
public void set be folder owner ( boolean value ) { if ( this . can set field value ( this . be folder owner , value ) ) { this . be folder owner = value ; this . change ( ) ; } this . adjust permission level ( ) ; }
public void complex property change ( final t complex property complex property ) { this . item change ( complex property ) ; }
public string get manage folder id ( ) { return manage folder id ; }
public void set daylight ( time change value ) { if ( this . can set field value ( this . daylight , value ) ) { this . daylight = value ; this . change ( ) ; } }
public void set daylight ( time change value ) { if ( this . can set field value ( this . daylight , value ) ) { this . daylight = value ; this . change ( ) ; } }
public void set street ( string value ) throw exception { this . property bag . set simple property bag ( physical address schema . street , value ) ; }
public string get country or region ( ) throw exception { return ( string ) this . property bag . get simple property bag ( physical address schema . country or region ) ; }
public < t folder extend folder > t folder bind to folder ( class < t folder > cl , folder id folder id , property set property set ) throw exception { folder result = this . bind to folder ( folder id , property set ) ; if ( cl . be assignable from ( result . get class ( ) ) ) { return ( t folder ) result ; } else { throw new service local exception ( string . format ( `` the folder type return by the service ( % s ) be n't compatible with the request folder type ( % s ) . `` , result . get class ( ) . get name ( ) , cl . get name ( ) ) ) ; } }
public void set end date ( date value ) { if ( this . can set field value ( this . end date , value ) ) { this . end date = value ; this . change ( ) ; } this . number of occurrence = null ; }
public void set end date ( date value ) { if ( this . can set field value ( this . end date , value ) ) { this . end date = value ; this . change ( ) ; } this . number of occurrence = null ; }
public void set rule ( rule value ) { if ( this . can set field value ( this . rule , value ) ) { this . rule = value ; this . change ( ) ; } }
public boolean get permanent delete ( ) { return this . permanent delete ; }
public rule action get action ( ) { return this . action ; }
public void set rule ( rule value ) { if ( this . can set field value ( this . rule , value ) ) { this . rule = value ; this . change ( ) ; } }
public date get absolute date ( ) { return absolute date ; }
public date get absolute date ( ) { return absolute date ; }
public int compare ( final time zone transition x , final time zone transition y ) { if ( x == y ) { return 0 ; } else if ( x ! = null & & y ! = null ) { if ( x instanceof absolute date transition & & y instanceof absolute date transition ) { final absolute date transition first transition = ( absolute date transition ) x ; final absolute date transition second transition = ( absolute date transition ) y ; final date first date time = first transition . get date time ( ) ; final date second date time = second transition . get date time ( ) ; return first date time . compare to ( second date time ) ; } else if ( y instanceof time zone transition ) { return 1 ; } } else if ( y == null ) { return 1 ; } return -1 ; }
public void set day of the week index ( day of the week index day of the week index ) { if ( this . can set field value ( this . day of the week index , day of the week index ) ) { this . day of the week index = day of the week index ; this . change ( ) ; } }
public service response collection < service response > load property for item ( iterable < item > item , property set property set ) throw exception { ews utility . validate param collection ( item . iterator ( ) , `` item `` ) ; ew utility . validate param ( property set , `` property set `` ) ; return this . internal load property for item ( item , property set , service error handle . return error ) ; }
public void set body type ( body type body type ) { if ( this . can set field value ( this . body type , body type ) ) { this . body type = body type ; this . change ( ) ; } }
public boolean equal ( object obj ) { if ( this == obj ) { return true ; } if ( obj instanceof extend property definition ) { return extend property definition . be equal to ( this , ( extended property definition ) obj ) ; } else { return false ; } }
public boolean get curly brace denote code block ( int language index ) { return true ; }
public message body get body prefix ( ) throw exception { return ( message body ) this . get object from property definition ( response object schema . body prefix ) ; }
public boolean be more available ( ) { return more available ; }
protected item change create change instance ( ) { return new item change ( ) ; }
public folder get folder ( ) { return ( folder ) this . get service object ( ) ; }
@ override public service id create id ( ) { return new item id ( ) ; }
public date read element value a date time ( ) throw exception { return date time utils . convert date time string to date ( read element value ( ) ) ; }
public cascade style get cascade style ( element e , boolean restyle ) { if ( e == null ) return cascade style . empty cascaded style ; return _matcher . get cascaded style ( e , restyle ) ; }
public string get type ( ) { return type ; }
public void set origin ( int origin ) { this . origin = origin ; }
public stylesheet get stylesheet ( ) { return stylesheet ; }
public void layout ( graphics2 d g2 , dimension dim ) { this . dim = dim ; if ( dim ! = null ) { panel . set size ( dim ) ; } panel . do document layout ( g2 ) ; }
public void layout ( graphics2 d g2 , dimension dim ) { this . dim = dim ; if ( dim ! = null ) { panel . set size ( dim ) ; } panel . do document layout ( g2 ) ; }
public void clear image cache ( ) { _image resource loader . clear ( ) ; }
public boolean be hover style ( element e ) { return _matcher . be hover style ( e ) ; }
public synchronize image load item get task ( ) throw interrupted exception { while ( _load queue . be empty ( ) ) { wait ( ) ; } if ( _load queue . get last ( ) == kill_switch ) { x r log . general ( level . fine , `` thread `` + thread . current thread ( ) . get name ( ) + `` requested item , but queue be shut down ; return kill switch . `` ) ; return kill_switch ; } else { image load item item = ( image load item ) _load queue . remove last ( ) ; x r log . general ( level . fine , `` thread `` + thread . current thread ( ) . get name ( ) + `` pulled item `` + item . _uri + `` from queue , `` + ( _load queue . size ( ) - 1 ) + `` remain `` ) ; return item ; } }
public void add listener ( f s mouse listener l ) { if ( l == null ) { return ; } if ( ! _handlers . contains key ( l ) ) { _handlers . put ( l , l ) ; } if ( ! _enabled & & _handlers . size ( ) > 0 ) { _panel . add mouse listener ( this ) ; _panel . add mouse motion listener ( this ) ; _enabled = true ; } }
public void scroll to ( point pt ) { if ( this . enclose scroll pane ! = null ) { this . enclose scroll pane . get vertical scroll bar ( ) . set value ( pt . y ) ; } }
public static byte get byte value ( final map map , final object key , byte default value ) { byte byte object = get byte ( map , key ) ; if ( byte object == null ) { return default value ; } return byte object . byte value ( ) ; }
public static void main ( string [ ] args ) throw i o exception { grammar spelunker g = new grammar spelunker ( `` . `` , args [ 0 ] ) ; g . parse ( ) ; system . out . println ( g . grammar modifier+ `` grammar `` +g . grammar name ) ; system . out . println ( `` language= `` +g . language ) ; system . out . println ( `` token vocab= `` +g . token vocab ) ; system . out . println ( `` imports= `` +g . import grammar ) ; }
public void set write compression mode ( int mode ) { this . write compression mode = mode ; }
protect buffered image create buffer image ( int width , int height ) { buffer image image = image util . create compatible buffer image ( width , height , buffered image . type_int_rgb ) ; image util . clear image ( image ) ; return image ; }
public void save image ( string mime type , image image , output stream o ) throw exception { image writer writer = null ; iterator iter = javax . imageio . image i o . get image writer by m i m e type ( mime type ) ; if ( iter . have next ( ) ) { writer = ( image writer ) iter . next ( ) ; } writer . set output ( javax . imageio . image i o . create image output stream ( o ) ) ; buffer image rend image = null ; if ( image instanceof buffer image ) { rend image = ( buffered image ) image ; } else { medium tracker tracker = new medium tracker ( this ) ; tracker . add image ( image , 0 ) ; tracker . wait for all ( ) ; rend image = new buffer image ( image . get width ( null ) , image . get height ( null ) , 1 ) ; graphic g = rend image . create graphic ( ) ; g . draw image ( image , 0 , 0 , null ) ; } writer . write ( new i i o image ( rend image , null , null ) ) ; writer . dispose ( ) ; }
public string format error ( final log record record ) { return format message ( record . get thrown ( ) ) ; }
public void record invalid class name ( string name ) { package . put ( name , name ) ; }
protect int index of support ( duration field type type ) { int index = index of ( type ) ; if ( index == -1 ) { throw new illegal argument exception ( `` field ' `` + type + `` ' be not support `` ) ; } return index ; }
public void add char metric ( char metric metric ) { char metric . add ( metric ) ; char metric map . put ( metric . get name ( ) , metric ) ; }
public void add char metric ( char metric metric ) { char metric . add ( metric ) ; char metric map . put ( metric . get name ( ) , metric ) ; }
public void set mapping scheme ( int mapping scheme value ) { map scheme = mapping scheme value ; }
public void set character set ( string character set value ) { character set = character set value ; }
public void add char metric ( char metric metric ) { char metric . add ( metric ) ; char metric map . put ( metric . get name ( ) , metric ) ; }
public void set font name ( string name ) { font name = name ; }
public float get cap height ( ) { return cap height ; }
public void set italic angle ( float italic angle value ) { italic angle = italic angle value ; }
public void add char metric ( char metric metric ) { char metric . add ( metric ) ; char metric map . put ( metric . get name ( ) , metric ) ; }
public void set kern pair ( list < kern pair > kern pair list ) { kern pair = kern pair list ; }
public void add kern pair ( kern pair kern pair ) { kern pair . add ( kern pair ) ; }
public void add char metric ( char metric metric ) { char metric . add ( metric ) ; char metric map . put ( metric . get name ( ) , metric ) ; }
public float get standard horizontal width ( ) { return standard horizontal width ; }
public float get min kern ( ) { return min kern ; }
public float get min point size ( ) { return min point size ; }
public string get order ( ) { return order ; }
public static string get operator ( int b0 ) { return key map . get ( calculate key ( b0 ) ) ; }
public byte [ ] read byte ( int length ) throw i o exception { if ( input buffer . length - buffer position < length ) { throw new e o f exception ( ) ; } byte [ ] bytes = new byte [ length ] ; system . arraycopy ( input buffer , buff position , bytes , 0 , length ) ; buffer position += length ; return byte ; }
public int peek unsigned byte ( int offset ) throw i o exception { int b = peek ( offset ) ; if ( b < 0 ) { throw new e o f exception ( ) ; } return b ; }
public int read int ( ) throw i o exception { int b1 = read ( ) ; int b2 = read ( ) ; int b3 = read ( ) ; int b4 = read ( ) ; if ( ( b1 | b2 | b3 | b4 ) < 0 ) { throw new e o f exception ( ) ; } return b1 < < 24 | b2 < < 16 | b3 < < 8 | b4 ; }
public void write ( byte [ ] buffer , int offset , int length ) { output buffer . write ( buffer , offset , length ) ; }
public list < object > parse ( byte [ ] byte , byte [ ] [ ] global subr index , byte [ ] [ ] local subr index ) throw i o exception { return parse ( byte , global subr index , local subr index , true ) ; }
public void set version ( string version ) { cmap version = version ; }
public int get type ( ) { return cmap type ; }
protect void add character encode ( int code , string name ) { code to name . put ( code , name ) ; name to code . put ( name , code ) ; }
public double get scale01 ( ) { return scale01 ; }
public int scale x ( int x , int y ) { return math . round ( ( float ) ( x * xscale + y * scale10 ) ) ; }
public int get break char ( ) { return u break char ; }
public header table get header ( ) throw i o exception { return ( header table ) get table ( header table . tag ) ; }
public header table get header ( ) throw i o exception { return ( header table ) get table ( header table . tag ) ; }
public vertical metric table get vertical metric ( ) throw i o exception { return ( vertical metric table ) get table ( vertical metric table . tag ) ; }
public string read tag ( ) throw i o exception { return new string ( read ( 4 ) , charsets . us_ascii ) ; }
public int read sign int ( ) throw i o exception { int ch1 = read ( ) ; int ch2 = read ( ) ; int ch3 = read ( ) ; int ch4 = read ( ) ; if ( ( ch1 | ch2 | ch3 | ch4 ) < 0 ) { throw new e o f exception ( ) ; } return ( ( ch1 < < 24 ) + ( ch2 < < 16 ) + ( ch3 < < 8 ) + ( ch4 < < 0 ) ) ; }
public string get font name ( ) { return font name ; }
public string get font name ( ) { return font name ; }
public string get font i d ( ) { return font i d ; }
public static boolean be client ( final interface itf ) { if ( itf instanceof type interface ) { type interface t itf = ( type interface ) itf ; return type interface . client_role . equal ( t itf . get role ( ) ) ; } return false ; }
public static boolean be server ( final interface itf ) { if ( itf instanceof type interface ) { type interface t itf = ( type interface ) itf ; return type interface . server_role . equal ( t itf . get role ( ) ) ; } return false ; }
public static void error ( final string message ) { log ( error , message ) ; }
public static boolean be info enable ( ) { return ( level < = info ) ; }
protect void index by start offset ( ) { if ( annots by start node ! = null ) return ; if ( node by offset == null ) node by offset = new r b tree map < long , node > ( ) ; annots by start node = new hash map < integer , object > ( annots by id . size ( ) ) ; iterator < annotation > annot iter = annots by id . value ( ) . iterator ( ) ; while ( annot iter . have next ( ) ) add to start offset index ( annot iter . next ( ) ) ; } // index by start offset ( )
public void warning ( string message , string source name , int line , string line source , int line offset ) { throw new unsupported operation exception ( ) ; }
public void fatal error ( s a x parse exception ex ) throw s a x exception { _seh . fatal error ( ex ) ; } // fatal error
protect boolean new control flow exception edge ( final int insn , final int successor ) { return true ; }
public void cleanup ( ) { default annots = null ; if ( ( name annot set ! = null ) & & ( ! name annot set . be empty ( ) ) ) name annot set . clear ( ) ; if ( debug ) out . prln ( `` document cleanup call `` ) ; if ( this . lr persistent id ! = null ) gate . get creole register ( ) . remove creole listener ( this ) ; if ( this . get data store ( ) ! = null ) this . get data store ( ) . remove datastore listener ( this ) ; } // cleanup ( )
public void remove annotation set ( string name ) { if ( name annot set ! = null ) { annotation set remove = name annot set . remove ( name ) ; if ( remove ! = null ) { fire annotation set remove ( new document event ( this , document event . annotation_set_removed , name ) ) ; } } }
public void unpack markup ( document doc ) throw document format exception { unpack markup ( doc , ( reposition info ) null , ( reposition info ) null ) ; } // unpack markup
public void set subtype ( string subtype ) { this . subtype = subtype ; }
public void set subtype ( string subtype ) { this . subtype = subtype ; }
public void add parameter ( string param , string value ) { parameter . put ( param , value ) ; }
public void set document persistent i d ( int index , object pers i d ) { if ( index > = doc data list . size ( ) ) return ; doc data list . get ( index ) . set persistent i d ( pers i d ) ; if ( debug ) out . prln ( `` i d be now : `` + doc data list ) ; }
public static boolean have wildcards ( string input ) { return ( input . index of ( ' * ' ) ! = -1 || input . index of ( ' ? ' ) ! = -1 ) ; }
public string make unique name ( string prefix ) { throw new runtime exception ( `` not available in `` + get name ( ) ) ; }
public void set l r persistence id ( object lr i d ) { this . lr persistent id = lr i d ; }
public final expression optimize ( expression visitor visitor , item type context item type ) { return this ; }
public void cleanup ( ) { this . handle = null ; feature . clear ( ) ; } //clear ( )
public void cleanup ( ) { this . handle = null ; feature . clear ( ) ; } //clear ( )
public string get scheme ( ) { throw new unsupported operation exception ( `` not implement by the `` + get class ( ) . get simple name ( ) + `` file system implementation `` ) ; }
public void cleanup ( ) { this . handle = null ; feature . clear ( ) ; } //clear ( )
public void set boost ( float boost ) { this . boost = boost ; }
public final boolean be term vector store ( ) { return store term vector ; }
public final synchronize void close ( ) throw i o exception { commit ( ) ; do close ( ) ; if ( close directory ) directory . close ( ) ; }
public explanation [ ] get detail ( ) { if ( detail == null ) return null ; return ( explanation [ ] ) detail . to array ( new explanation [ 0 ] ) ; }
public array list [ ] get first term position ( ) { return new array list [ ] { document number , first term position , pattern length , query type , frequency } ; }
public boolean clause [ ] get clause ( ) { return ( boolean clause [ ] ) clauses . to array ( new boolean clause [ 0 ] ) ; }
public string to string ( ) { return to string ( `` `` ) ; }
public static f s directory get directory ( string path , boolean create ) throw i o exception { return get directory ( new file ( path ) , create ) ; }
public void score ( hit collector hc , searcher searcher ) throw i o exception { this . searcher = searcher ; while ( next ( this . searcher ) ) { hc . collect ( doc ( ) , score ( searcher ) ) ; } }
public final void clear ( ) { for ( int i = 0 ; i < = size ; i++ ) heap [ i ] = null ; size = 0 ; }
protect final void initialize ( int max size ) { size = 0 ; int heap size = max size + 1 ; heap = new object [ heap size ] ; this . max size = max size ; }
public string get annotation set name ( ) { return annotation set name ; }
public void replace ( string statement ) throw can not compile exception { throw new runtime exception ( `` not implement yet `` ) ; }
public final hit search ( query query ) throw i o exception { return search ( query , ( filter ) null ) ; }
public string get type ( ) { return this . type ; }
public string get text ( ) { return this . text ; }
public void add feature ( string key , string val ) { feature . put ( key , val ) ; }
public void set position ( int po ) { position = po ; }
public void set feature schema set ( set < feature schema > feature schema set ) { this . feature schema set = feature schema set ; } // set feature schema set
public void set fast reconfigure ( boolean fast reconfigure ) { if ( this . reuse parser ) { this . fast reconfigure = fast reconfigure ; } }
public void add ( process resource pr ) { if ( pr instanceof language analyser ) { strategy list . add ( new analyser run strategy ( ( language analyser ) pr , run strategy . run_always , null , null ) ) ; } else { strategy list . add ( new run strategy . unconditional run strategy ( pr , true ) ) ; } super . add ( pr ) ; }
public void add ( process resource pr ) { if ( pr instanceof language analyser ) { strategy list . add ( new analyser run strategy ( ( language analyser ) pr , run strategy . run_always , null , null ) ) ; } else { strategy list . add ( new run strategy . unconditional run strategy ( pr , true ) ) ; } super . add ( pr ) ; }
public list < string > get public vr type ( ) { return collection . unmodifiable list ( get public type ( vr type ) ) ; } // get public vr type ( )
public list < string > get small v r for resource ( string resource class name ) { return get v r for resource ( resource class name , resource data . small_gui ) ; } // get small v r for resource
public void add index field ( index field fld ) { if ( fields==null ) { field = new vector < index field > ( ) ; } field . add ( fld ) ; }
public string get help u r l ( ) { return help u r l ; }
public feature map get runtime default ( ) throw parameter exception { return get default ( runtime parameter ) ; } // get runtime default ( )
public boolean add ( list < parameter > disjunction ) { boolean status = false ; iterator < parameter > iter = disjunction . iterator ( ) ; parameter param = iter . next ( ) ; if ( param . be runtime ( ) ) { status = runtime parameter . add ( disjunction ) ; } else { status = initime parameter . add ( disjunction ) ; } return status ; } // add ( param )
public string get feature value ( ) { if ( be default ( ) || be fix ( ) ) return feature value ; else return `` `` ; } // get feature value
public string get name ( ) { return name ; }
public string get name ( ) { return name ; }
public string get name ( ) { return name ; }
public void set resource class ( class < ? extend resource > resource class ) { this . resource class = resource class ; } // set resource class
public string get jar file name ( ) { return jar file name ; }
public void set xml file url ( url xml file url ) { this . xml file url = xml file url ; }
public string get annotation type displayed ( ) { return annotation type displayed ; }
public boolean equal ( object that ) { return super . equal ( that ) ; }
protect string get order string ( ) { if ( source url == null ) return to string ( ) ; string buffer order string = new string buffer ( source url . to string ( ) ) ; if ( source url start offset ! = null & & source url end offset ! = null ) { order string . append ( source url start offset . to string ( ) ) ; order string . append ( source url end offset . to string ( ) ) ; } return order string . to string ( ) ; } // get order string ( )
public gate . document get document ( ) { return document ; }
public object get resource i d ( ) { return resource i d ; }
public static document new document ( url source url ) throw resource instantiation exception { feature map parameter value = new feature map ( ) ; parameter value . put ( document . document_url_parameter_name , source url ) ; return ( document ) create resource ( `` gate . corpus . document impl `` , parameter value ) ; } // new document ( url )
public static feature map get parameter value ( resource re , list < list < parameter > > params ) throw resource instantiation exception { feature map fm = factory . new feature map ( ) ; for ( list < parameter > par disjunction : params ) { for ( parameter p : par disjunction ) { fm . put ( p . get name ( ) , res . get parameter value ( p . get name ( ) ) ) ; } } return fm ; }
public static boolean unregister i r engine ( string class name ) { return register i r engine . remove ( class name ) ; }
public synchronize static set < plugin > get default plugins ( ) { if ( default plugins == null ) return new hash set < plugin > ( ) ; return collection . unmodifiable set ( default plugins ) ; }
public static option map get user config ( ) { return user config ; }
public void set extension ( list < string > extension ) { this . extension = extension ; extension text field . set text ( extension . to string ( ) ) ; }
public void set active ( boolean active ) { this . active = active ; if ( active ) { if ( ! gui initialise ) { init g u i ( ) ; gui initialise = true ; } register hook ( ) ; } else { unregister hook ( ) ; } }
public void set active ( boolean active ) { this . active = active ; if ( active ) { if ( ! gui initialise ) { init g u i ( ) ; gui initialise = true ; } register hook ( ) ; } else { unregister hook ( ) ; } }
public static set < string > get output annotation set ( controller c ) { object set name obj = c . get feature ( ) . get ( output_annotation_sets_feature ) ; if ( set names obj ! = null & & set name obj instanceof set ) { return ( set < string > ) set name obj ; } else { set < string > set name = new hash set < string > ( ) ; c . get feature ( ) . put ( output_annotation_sets_feature , set name ) ; populate output set name for controller ( set names , c , true ) ; return set name ; } }
public void set line offset ( int [ ] line offset ) { this . line offset = line offset ; }
public string get comment ( ) { return `` gate serial datastore `` ; }
public static byte [ ] read stream ( input stream fin ) throw i o exception { byte [ ] [ ] bufs = new byte [ 8 ] [ ] ; int bufsize = 4096 ; for ( int i = 0 ; i < 8 ; ++i ) { bufs [ i ] = new byte [ bufsize ] ; int size = 0 ; int len = 0 ; do { len = fin . read ( bufs [ i ] , size , bufsize - size ) ; if ( len > = 0 ) size += len ; else { byte [ ] result = new byte [ bufsize - 4096 + size ] ; int s = 0 ; for ( int j = 0 ; j < i ; ++j ) { system . arraycopy ( bufs [ j ] , 0 , result , s , s + 4096 ) ; s = s + s + 4096 ; } system . arraycopy ( bufs [ i ] , 0 , result , s , size ) ; return result ; } } while ( size < bufsize ) ; bufsize * = 2 ; } throw new i o exception ( `` too much data `` ) ; }
protect void add non match ( string builder sb , string text ) { sb . append ( text ) ; }
public static int get type difference weight ( class < ? > [ ] param type , object [ ] args ) { int result = 0 ; for ( int i = 0 ; i < param type . length ; i++ ) { if ( ! class utils . be assignable value ( param type [ i ] , args [ i ] ) ) { return integer . max_value ; } if ( args [ i ] ! = null ) { class < ? > param type = param type [ i ] ; class < ? > super class = args [ i ] . get class ( ) . get superclass ( ) ; while ( super class ! = null ) { if ( param type . equal ( super class ) ) { result = result + 2 ; super class = null ; } else if ( class utils . be assignable ( param type , super class ) ) { result = result + 2 ; super class = super class . get superclass ( ) ; } else { super class = null ; } } if ( param type . be interface ( ) ) { result = result + 1 ; } } } return result ; }
public synchronize boolean show ( resource data r data , string a title ) { this . resource data = r data ; if ( a title ! = null ) set title ( a title ) ; parameter editor . init ( null , r data . get parameter list ( ) . get initime parameter ( ) ) ; pack ( ) ; name field . request focus in window ( ) ; user cancel = true ; set modal ( true ) ; set location relative to ( get owner ( ) ) ; super . set visible ( true ) ; dispose ( ) ; if ( user cancel ) return false ; else return true ; } //show ( ) ;
public resource resolve config location ( resource config ) { if ( config ! = null ) { assert . be true ( config . exists ( ) , ( ) - > `` cache configuration do not exist ' `` + config . get description ( ) + `` ' `` ) ; return config ; } return null ; }
public boolean be enable hide column ( ) { return this . enable hiding column ; }
public void hide column ( int column index ) { int view column = convert column index to view ( column index ) ; table column column to hide = column model . get column ( view column ) ; column model . remove column ( column to hide ) ; hide column . add ( column to hide ) ; }
public void set feature value ( string a feature value ) { feature value = a feature value ; } // set feature value
public static void set benchmarking enable ( boolean benchmarking enable ) { benchmark . benchmarking enable = benchmarking enable ; }
public void error ( string domain , string key , x m l parse exception e ) { e . print stack trace ( err . get print writer ( ) ) ; }
public native image resource bundle build item native image resource bundle ( ) { / * * the following resource bundle sometimes need to be include into the native image with jdk 11 . * this might no longer be require if graal v m auto-includes it in a future release . * see http : //github . com/oracle/graal/issues/2005 for more detail about it . * / return new native image resource bundle build item ( `` sun . security . util . resource `` ) ; }
public class < ? > find exist class ( string name ) { return find loaded class ( name ) ; }
public void set analyser ( language analyser a ) { this . analyser = a ; }
public static boolean remove cache directory ( file dir ) { return extra cache directory . remove ( dir ) ; }
public boolean contain value ( object value ) { return ( value==null ? value search null ( root ) : value search non null ( root , value ) ) ; }
static public void set unicode enable ( boolean value ) { unicode enable = value ; }
public static boolean be g a t e old enough ( string version ) { if ( version == null ) return true ; version = version . trim ( ) ; if ( version . equal ( `` `` ) || version . equal ( `` * `` ) ) return true ; return ( compare version ( main . version , version ) < = 0 ) ; }
public x m l stream writer create x m l stream writer ( writer writer ) throw x m l stream exception { throw new java . lang . unsupported operation exception ( ) ; }
public void write start document ( ) throw x m l stream exception { this . xml writer . write start document ( `` utf-8 `` , `` 1 . 0 `` ) ; }
public static string clean string for ( document doc , long start , long end ) { return clean string ( string for ( doc , start , end ) ) ; }
public static annotation set get coextensive annotation ( annotation set source , annotation set coext set , string type ) { return get coextensive annotation worker ( source , type , start ( coext set ) , end ( coext set ) ) ; }
public static annotation set get coextensive annotation ( annotation set source , annotation set coext set ) { return get coextensive annotation worker ( source , null , start ( coext set ) , end ( coext set ) ) ; }
public void clear ( ) { lr type . clear ( ) ; pr type . clear ( ) ; vr type . clear ( ) ; tool type . clear ( ) ; application type . clear ( ) ; plugins . clear ( ) ; super . clear ( ) ; } // clear ( )
public formatter diagnostic create diagnostic ( int input position , string message ) { return formatter diagnostic . create ( get line number ( input position ) , get column number ( input position ) , message ) ; }
public token get token ( int k ) { return k to token [ k ] ; }
public static version get current ( ) { return parse ( home finder . get instance ( ) . get version ( ) ) ; }
public static void detach thread ( isolate thread thread ) throw isolate exception { image singleton . lookup ( isolate support . class ) . detach thread ( thread ) ; }
public static boolean be not empty ( long [ ] array ) { return ( array ! = null & & array . length ! = 0 ) ; }
public static void initialize at build time ( class < ? > . . . class ) { stack trace element [ ] stacktrace = thread . current thread ( ) . get stack trace ( ) ; for ( class < ? > a class : class ) { image singleton . lookup ( runtime class initialization support . class ) . initialize at build time ( a class , message + get caller ( stacktrace ) ) ; } }
public static x content type parse content type ( list < string > header ) { if ( header == null || header . be empty ( ) ) { return null ; } else if ( header . size ( ) > 1 ) { throw new illegal argument exception ( `` only one content- type header should be provide `` ) ; } string raw content type = header . get ( 0 ) ; final string [ ] element = raw content type . split ( `` [ \t ] * ; `` ) ; if ( element . length > 0 ) { final string [ ] split medium type = element [ 0 ] . split ( `` / `` ) ; if ( split medium type . length == 2 & & tchar_pattern . matcher ( split medium type [ 0 ] ) . match ( ) & & tchar_pattern . matcher ( split medium type [ 1 ] . trim ( ) ) . match ( ) ) { return x content type . from medium type ( element [ 0 ] ) ; } else { throw new illegal argument exception ( `` invalid content- type header [ `` + raw content type + `` ] `` ) ; } } throw new illegal argument exception ( `` empty content- type header `` ) ; }
public static boolean be executable ( ) { ensure kind available ( ) ; return property_image_kind_value_executable . equal ( system . get property ( property_image_kind_key ) ) ; }
public static void report class initialize ( class < ? > c ) { if ( image singleton support . be instal ( ) & & image singleton . contains ( runtime class initialization support . class ) ) { runtime class initialization support runtime class initialization = image singleton . lookup ( runtime class initialization support . class ) ; runtime class initialization . report class initialize ( c ) ; } }
public static boolean destroy ( long process i d ) { return image singleton . lookup ( process property support . class ) . destroy ( process i d ) ; }
public static string get argument vector program name ( ) { return image singleton . lookup ( process property support . class ) . get argument vector program name ( ) ; }
public option key < ? > get key ( ) { return key ; }
public boolean be meta instance ( object instance ) { return impl . be meta instance ( receiver , instance ) ; }
public static builder new builder ( string language , url url ) { return empty . new builder ( language , url ) ; }
public void close ( boolean cancel if execute ) { impl . close ( this , cancel if execute ) ; }
public string get version ( ) { return impl . get version ( ) ; }
public string get name ( ) { return impl . get name ( ) ; }
public boolean be interactive ( ) { return get impl ( ) . be interactive ( impl ) ; }
public string get id ( ) { return impl . get id ( ) ; }
public boolean be expression ( ) { return impl . be execution event expression ( impl ) ; }
public value get return value ( ) { return impl . get execution event return value ( impl ) ; }
public boolean be syntax error ( ) { return impl . be syntax error ( ) ; }
public int get char length ( ) { return impl . get char length ( impl ) ; }
public boolean have columns ( ) { return impl . have columns ( impl ) ; }
public int get line number ( int offset ) throw illegal argument exception { return get impl ( ) . get line number ( impl , offset ) ; }
public static builder new builder ( string language , char sequence character , string name ) { return empty . new builder ( language , character ) . name ( name ) ; }
public string get mime type ( ) { return get impl ( ) . get mime type ( impl ) ; }
public int get end column ( ) { return impl . get end column ( impl ) ; }
public int get char index ( ) { return impl . get char index ( impl ) ; }
public value get array element ( long index ) { return impl . get array element ( receiver , index ) ; }
public boolean be exception ( ) { return impl . be exception ( receiver ) ; }
public value get polyglot binding ( ) { return impl . get polyglot binding ( ) ; }
public void visit post order ( query visitor visitor ) { visit impl ( visitor , false ) ; }
protect completable future < field value info > resolve field with info ( execution context execution context , execution strategy parameter parameter ) { graph q l field definition field def = get field def ( execution context , parameter , parameter . get field ( ) . get single field ( ) ) ; supplier < execution step info > execution step info = fp kit . intra thread memoize ( ( ) - > create execution step info ( execution context , parameter , field def , null ) ) ; instrumentation instrumentation = execution context . get instrumentation ( ) ; instrumentation context < execution result > field ctx = instrumentation . begin field ( new instrumentation field parameter ( execution context , execution step info ) ) ; completable future < fetch value > fetch field future = fetch field ( execution context , parameter ) ; completable future < field value info > result = fetch field future . then apply ( ( fetch value ) - > complete field ( execution context , parameter , fetch value ) ) ; completable future < execution result > execution result future = result . then compose ( field value info : : get field value ) ; field ctx . on dispatched ( execution result future ) ; execution result future . when complete ( field ctx : : on complete ) ; return result ; }
public field get single field ( ) { return single field ; }
public object get context ( ) { return context ; }
public graph q l argument transform ( consumer < builder > builder consumer ) { builder builder = new argument ( this ) ; builder consumer . accept ( builder ) ; return builder . build ( ) ; }
public execution result execute ( string query ) { execution input execution input = execution input . new execution input ( ) . query ( query ) . build ( ) ; return execute ( execution input ) ; }
public static graph q l context of ( consumer < graph q l context . builder > context builder consumer ) { builder builder = graph q l context . new context ( ) ; context builder consumer . accept ( builder ) ; return of ( builder . map ) ; }
public graph q l schema element get element ( ) { return element ; }
public int get max token ( ) { return max token ; }
public static graph q l field definition get field def ( graph q l schema schema , graph q l composite type parent type , string field name ) { if ( schema . get query type ( ) == parent type ) { if ( field name . equal ( schema . get introspection schema field definition ( ) . get name ( ) ) ) { return schema . get introspection schema field definition ( ) ; } if ( field name . equal ( schema . get introspection type field definition ( ) . get name ( ) ) ) { return schema . get introspection type field definition ( ) ; } } if ( field name . equal ( schema . get introspection typename field definition ( ) . get name ( ) ) ) { return schema . get introspection typename field definition ( ) ; } assert true ( parent type instanceof graph q l field container , ( ) - > string . format ( `` should not happen : parent type must be an object or interface % s `` , parent type ) ) ; graph q l field container field container = ( graph q l field container ) parent type ; graph q l field definition field definition = schema . get code registry ( ) . get field visibility ( ) . get field definition ( fields container , field name ) ; assert true ( field definition ! = null , ( ) - > string . format ( `` unknown field ' % s ' for type % s `` , field name , field container . get name ( ) ) ) ; return field definition ; }
public boolean have data fetcher ( field coordinate coordinate ) { return have data fetcher impl ( coordinate , data fetcher map , system data fetcher map ) ; }
public graph q l enum value definition transform ( consumer < builder > builder consumer ) { builder builder = new enum value definition ( this ) ; builder consumer . accept ( builder ) ; return builder . build ( ) ; }
public graph q l input object field transform ( consumer < builder > builder consumer ) { builder builder = new input object field ( this ) ; builder consumer . accept ( builder ) ; return builder . build ( ) ; }
public graph q l directive get directive ( string directive name ) { return directive . get directive ( directive name ) ; }
public list < graph q l directive > get directive ( ) { return directive . get directive ( ) ; }
public graph q l argument transform ( consumer < builder > builder consumer ) { builder builder = new argument ( this ) ; builder consumer . accept ( builder ) ; return builder . build ( ) ; }
public static graph q l schema make un executable schema ( type definition registry registry ) { runtime wiring runtime wire = echo wire factory . new echo wiring ( wire - > { map < string , scalar type definition > scalars = registry . scalar ( ) ; scalar . for each ( ( name , v ) - > { if ( ! scalar info . be graphql specify scalar ( name ) ) { wire . scalar ( fake scalar ( name ) ) ; } } ) ; } ) ; return new schema generator ( ) . make executable schema ( registry , runtime wire ) ; }
public graph q l object type transform ( consumer < builder > builder consumer ) { builder builder = new object ( this ) ; builder consumer . accept ( builder ) ; return builder . build ( ) ; }
public static list < validation error > validate ( graph q l schema graph q l schema , document parse document ) { validator validator = new validator ( ) ; return validator . validate document ( graph q l schema , parsed document ) ; }
public static boolean get disable checksum ( ) { return disable checksum ; }
public static < t , v extend t > t inject ( object self , closure < v > closure ) { iterator iter = invoker helper . a iterator ( self ) ; if ( ! iter . have next ( ) ) { throw new no such element exception ( `` can not call inject ( ) over an empty iterable without pass an initial value . `` ) ; } object initial value = iter . next ( ) ; return ( t ) inject ( iter , initial value , closure ) ; }
public static string normalize ( string value ) { if ( value == null ) return value ; value = value . trim ( ) ; if ( value . index of ( `` `` ) == -1 ) return value ; boolean space = false ; int len = value . length ( ) ; string buffer b = new string buffer ( len ) ; for ( int i = 0 ; i < len ; i++ ) { char v = value . char at ( i ) ; if ( v == ' ' ) { if ( ! space ) b . append ( v ) ; space = true ; } else { b . append ( v ) ; space = false ; } } return b . to string ( ) ; }
public static void set without custom metaclass creation handle ( boolean mch ) { without custom handle = mch ; change flag ( mch ) ; }
public < t extend annotation > boolean have parameter annotation ( class < t > annotation type ) { return ( get parameter annotation ( annotation type ) ! = null ) ; }
public int get to int ( ) { return get to ( ) ; }
public object invoke static method ( object object , string method name , object [ ] argument ) { if ( invoke static method method ! = null ) { meta class helper . unwrap ( argument ) ; return invoke static method method . invoke ( object , new object [ ] { method name , argument } ) ; } return super . invoke static method ( object , method name , argument ) ; }
public object invoke method ( final object object , final string method name , final object [ ] argument ) { return do call ( object , method name , argument , interceptor , ( ) - > adaptee . invoke method ( object , method name , argument ) ) ; }
public object get property ( final class a class , final object object , final string property , final boolean use super , final boolean from inside class ) { if ( null == interceptor ) { return super . get property ( a class , object , property , use super , from inside class ) ; } if ( interceptor instanceof property access interceptor ) { property access interceptor pae = ( property access interceptor ) interceptor ; object result = pae . before get ( object , property ) ; if ( interceptor . do invoke ( ) ) { result = super . get property ( a class , object , property , use super , from inside class ) ; } return result ; } return super . get property ( a class , object , property , use super , from inside class ) ; }
public void visit ( final command visitor < t > visitor ) { for ( final edit command < t > command : command ) { command . accept ( visitor ) ; } }
public static < t1 , t2 , t3 , t4 > tuple4 < t1 , t2 , t3 , t4 > tuple ( t1 v1 , t2 v2 , t3 v3 , t4 v4 ) { return new tuple4 < > ( v1 , v2 , v3 , v4 ) ; }
public int hash code ( ) { int result ; result = namespace u r i . hash code ( ) ; result = 29 * result + local part . hash code ( ) ; return result ; }
public string to string ( ) { return ( ( namespace u r i . equal ( empty_string ) ) ? local part : ' { ' + namespace u r i + ' } ' + local part ) ; }
public boolean equal ( object o ) { if ( this == o ) return true ; if ( o == null ) return false ; if ( o instanceof q name ) { final q name q name = ( q name ) o ; if ( ! namespace u r i . equal ( q name . namespace u r i ) ) return false ; return local part . equal ( q name . local part ) ; } else if ( o instanceof string ) { final string string = ( string ) o ; if ( string . length ( ) == 0 ) return false ; int last colon index = string . last index of ( `` : `` ) ; if ( last colon index < 0 || last colon index == string . length ( ) - 1 ) return false ; final string string prefix = string . substring ( 0 , last colon index ) ; final string string local part = string . substring ( last colon index + 1 ) ; if ( string prefix . equal ( prefix ) || string prefix . equal ( namespace u r i ) ) { return local part . equal ( string local part ) ; } return false ; } return false ; }
public calendar construct calendar ( date d ) { / * 08- jan-2008 , tatu : not optimal , but should work for the * most part ; let 's revise a need . * / calendar c = calendar . get instance ( get time zone ( ) ) ; c . set time ( d ) ; return c ; }
public static duration get relative daylight saving offset ( date self , date other ) { duration d1 = get daylight saving offset ( self ) ; duration d2 = get daylight saving offset ( other ) ; return new time duration ( 0 , 0 , 0 , ( int ) ( d2 . to millisecond ( ) - d1 . to millisecond ( ) ) ) ; }
public static class node pick generic type ( class node type , int gt index ) { final generic type [ ] generic type = type . get generic type ( ) ; if ( generic types==null || generic type . length < gt index ) { return class helper . object_type ; } return generic type [ gt index ] . get type ( ) ; }
public boolean have u t f8 bom ( ) { if ( buffer . length > = 3 ) return ( buffer [ 0 ] == -17 & & buffer [ 1 ] == -69 & & buffer [ 2 ] == -65 ) ; else return false ; }
protected closure [ ] resolve explicit property ( string property name ) { return get explicit property ( ) . get ( property name ) ; }
protect void set parent ( object parent , object child ) { get proxy builder ( ) . get current factory ( ) . set parent ( get proxy builder ( ) . get child builder ( ) , parent , child ) ; factory parent factory = get proxy builder ( ) . get parent factory ( ) ; if ( parent factory ! = null ) { parent factory . set child ( get proxy builder ( ) . get current builder ( ) , parent , child ) ; } }
protect void node complete ( object parent , object node ) { get proxy builder ( ) . get current factory ( ) . on node complete ( get proxy builder ( ) . get child builder ( ) , parent , node ) ; }
public object invoke method ( class sender , object object , string method name , object [ ] original argument , boolean be call to super , boolean from inside class ) { if ( invoke method method ! = null ) { meta class helper . unwrap ( original argument ) ; return invoke method method . invoke ( object , new object [ ] { method name , original argument } ) ; } return super . invoke method ( sender , object , method name , original argument , be call to super , from inside class ) ; }
public static object sum ( collection item ) { return default groovy method . sum ( item ) ; }
public list list ( ) { final iterator iter = node iterator ( ) ; final list result = new link list ( ) ; while ( iter . have next ( ) ) { result . add ( new node child ( ( node ) iter . next ( ) , this . parent , this . namespace prefix , this . namespace tag hint ) ) ; } return result ; }
public boolean append ( node child ) { child . set parent ( this ) ; return get parent list ( this ) . add ( child ) ; }
public boolean append ( node child ) { child . set parent ( this ) ; return get parent list ( this ) . add ( child ) ; }
public big integer to big integer ( ) { if ( text be empty or null ( ) ) { return null ; } return string groovy method . to big integer ( ( char sequence ) text ( ) ) ; }
public boolean compare ( configuration a , configuration b ) { if ( a == null & & b == null ) { return true ; } else if ( a == null || b == null ) { return false ; } for ( iterator < string > key = a . get key ( ) ; key . have next ( ) ; ) { string key = key . next ( ) ; object value = a . get property ( key ) ; if ( ! value . equal ( b . get property ( key ) ) ) { return false ; } } for ( iterator < string > key = b . get key ( ) ; key . have next ( ) ; ) { string key = key . next ( ) ; object value = b . get property ( key ) ; if ( ! value . equal ( a . get property ( key ) ) ) { return false ; } } return true ; }
public boolean have property ( string name ) { final property identifier property = get identifier property ( ) ; if ( identifier property ! = null & & identifier property . get name ( ) . equal ( name ) ) { return true ; } final iterator itr = get property closure iterator ( ) ; while ( itr . have next ( ) ) { final property property = ( property ) itr . next ( ) ; if ( property . get name ( ) . equal ( name ) ) { return true ; } } return false ; }
public static boolean be empty ( final char sequence s ) { if ( s == null ) { return true ; } return s . length ( ) == 0 ; }
public void set capacity ( long capacity ) { check argument ( capacity > = 0 ) ; eviction lock . lock ( ) ; try { this . capacity . lazy set ( math . min ( capacity , maximum_capacity ) ) ; drain buffer ( ) ; evict ( ) ; } finally { eviction lock . unlock ( ) ; } notify listener ( ) ; }
public void move to front ( e e ) { if ( e ! = first ) { unlink ( e ) ; link first ( e ) ; } }
public final expression optimize ( expression visitor visitor , item type context item type ) { return this ; }
public boolean be synthetic public ( ) { return synthetic public ; }
public method node get method ( string name , parameter [ ] parameter ) { for ( method node method : get method ( name ) ) { if ( parameter equal ( method . get parameter ( ) , parameter ) ) { return method ; } } return null ; }
public list < method node > get declare method ( string name ) { if ( redirect ! = null ) return redirect . get declare method ( name ) ; lazy class init ( ) ; return method . get ( name ) ; }
public variable expression get variable expression ( ) { expression leave expression = this . get left expression ( ) ; return leave expression instanceof variable expression ? ( variable expression ) leave expression : null ; }
public static boolean be float category ( class node type ) { return type==float_ t y p e || type==double_ t y p e ; }
public static boolean be double category ( class node type ) { return type==float_ t y p e || type==double_ t y p e || be big dec category ( type ) ; }
public static class node low upper bound ( list < class node > node ) { if ( node . size ( ) ==1 ) return node . get ( 0 ) ; return low upper bound ( node . get ( 0 ) , low upper bound ( node . sub list ( 1 , node . size ( ) ) ) ) ; }
public int define temporary variable ( final variable var , final boolean store ) { return define temporary variable ( var . get name ( ) , var . get type ( ) , store ) ; }
public void pop ( ) { pop down to ( stack . size ( ) -1 ) ; }
public void apply to source unit ( source unit operation body ) throw compilation fail exception { for ( string name : name ) { source unit source = source . get ( name ) ; if ( ( source . phase < phase ) || ( source . phase == phase & & ! source . phase complete ) ) { try { body . call ( source ) ; } catch ( compilation fail exception e ) { throw e ; } catch ( exception e ) { groovy bug error gbe = new groovy bug error ( e ) ; change bug text ( gbe , source ) ; throw gbe ; } catch ( groovy bug error e ) { change bug text ( e , source ) ; throw e ; } } } get error collector ( ) . fail if error ( ) ; }
public list < compilation customizer > get compilation customizers ( ) { return compilation customizers ; }
public object get x path comparable ( boolean order , string collator collator , x path context context ) { return this ; }
public void set token blacklist ( final list < integer > token blacklist ) { if ( tokens whitelist ! = null ) { throw new illegal argument exception ( `` you be not allow to set both whitelist and blacklist `` ) ; } this . token blacklist = token blacklist ; }
public void set receiver black list ( final list < string > receiver black list ) { if ( receiver white list ! = null ) { throw new illegal argument exception ( `` you be not allow to set both whitelist and blacklist `` ) ; } this . receiver black list = receiver black list ; }
public void add warning ( final warning message message ) { if ( message . be relevant ( configuration . get warn level ( ) ) ) { if ( warning == null ) { warning = new link list < > ( ) ; } warning . add ( message ) ; } }
public void add error and continue ( final message message ) { if ( error == null ) { error = new link list < > ( ) ; } error . add ( message ) ; }
public void configure ( final compiler configuration configuration ) { super . configure ( configuration ) ; this . debug = get configuration ( ) . get debug ( ) ; this . configured = true ; }
public static class get call class ( int match level , collection < string > extra ignore package ) { class [ ] class context = helper . get class context ( ) ; int depth = 0 ; try { class c ; do { do { c = class context [ depth++ ] ; } while ( class should be ignore ( c , extra ignore package ) ) ; } while ( c ! = null & & match level -- > 0 & & depth < class context . length ) ; return c ; } catch ( throwable t ) { return null ; } }
public static class element type ( class clazz ) { check array type ( clazz ) ; while ( clazz . be array ( ) ) { clazz = clazz . get component type ( ) ; } return clazz ; }
public void set char at ( int offset , char b ) { ref . char [ offset ] = b ; }
public static void swap ( final boolean x [ ] , final int a , final int b ) { final boolean t = x [ a ] ; x [ a ] = x [ b ] ; x [ b ] = t ; }
public static float f array get ( float [ ] a , int i ) { try { return a [ i ] ; } catch ( throwable t ) { return a [ default groovy method support . normalise index ( i , a . length ) ] ; } }
public object invoke ( object proxy , method method , object [ ] args ) throw throwable { string name = method . get name ( ) ; if ( method . get declare class ( ) == groovy object . class ) { if ( name . equal ( `` get meta class `` ) ) { return get meta class ( ) ; } else if ( name . equal ( `` set meta class `` ) ) { return set meta class ( ( meta class ) args [ 0 ] ) ; } } return invoker helper . invoke method ( extension , method . get name ( ) , args ) ; }
public object get delegate ( ) { return delegate ; }
public static void sleep ( object self , long millisecond , closure on interrupt ) { sleep impl ( millisecond , on interrupt ) ; }
public static string to list string ( collection arg ) { return to list string ( arg , -1 ) ; }
protect void flushing fail ( throwable t ) { cancel ( ) ; on error ( t ) ; }
public static object output stream new object output stream ( file file ) throw i o exception { return new object output stream ( new file output stream ( file ) ) ; }
public static < t > t with print writer ( writer writer , @ closure params ( value= simple type . class , options= `` java . io . print writer `` ) closure < t > closure ) throw i o exception { return with writer ( new print writer ( writer ) , closure ) ; }
public static writable filter line ( reader reader , @ closure params ( value= simple type . class , options= `` java . lang . string `` ) final closure closure ) { final buffer reader br = new buffer reader ( reader ) ; return new writable ( ) { public writer write to ( writer out ) throw i o exception { buffered writer bw = new buffer writer ( out ) ; string line ; boolean closure wrapper bcw = new boolean closure wrapper ( closure ) ; while ( ( line = br . read line ( ) ) ! = null ) { if ( bcw . call ( line ) ) { bw . write ( line ) ; bw . new line ( ) ; } } bw . flush ( ) ; return out ; } public string to string ( ) { writer buffer = new string builder writer ( ) ; try { write to ( buffer ) ; } catch ( i o exception e ) { throw new string writer i o exception ( e ) ; } return buffer . to string ( ) ; } } ; }
public static buffer reader new reader ( input stream self , string charset ) throw unsupported encode exception { return new buffer reader ( new input stream reader ( self , charset ) ) ; }
public static < t > t with reader ( file file , @ closure params ( value = simple type . class , option = `` java . io . buffer reader `` ) closure < t > closure ) throw i o exception { return i o groovy method . with reader ( new reader ( file ) , closure ) ; }
public synchronize object get ( final object key ) { final object value = remove ( key ) ; if ( value ! = null ) put ( key , value ) ; return value ; }
protect final void record modification ( object x ) { synchronize ( barrier lock ) { last write = x ; } }
protect boolean be equal value ( final object value1 , final object value2 ) { return value1 == value2 || ( value1 == null ? false : value1 . equal ( value2 ) ) ; }
protect object sput ( object key , object value , int hash ) { entry [ ] tab = table ; int index = hash & ( tab . length-1 ) ; entry first = tab [ index ] ; entry e = first ; for ( ; ; ) { if ( e == null ) { entry new entry = new entry ( hash , key , value , first ) ; tab [ index ] = new entry ; if ( ++count > = threshold ) rehash ( ) ; else record modification ( new entry ) ; return null ; } else if ( e . hash == hash & & eq ( key , e . key ) ) { object old value = e . value ; e . value = value ; return old value ; } else e = e . next ; } }
public static void set orig short ( boolean v ) { orig short = v ; orig short re = without custom handle & & orig short ; }
public static void set orig short ( boolean v ) { orig short = v ; orig short re = without custom handle & & orig short ; }
public static void set orig char ( boolean v ) { orig char = v ; orig char re = without custom handle & & orig char ; }
public static synchronize meta class registry get instance ( int include extension ) { if ( include extension ! = dont_load_default ) { if ( instance include == null ) { instance include = new meta class registry impl ( ) ; } return instance include ; } else { if ( instance exclude == null ) { instance exclude = new meta class registry impl ( dont_load_default ) ; } return instance exclude ; } }
protect synchronized class load class ( string name , boolean resolve ) throw class not find exception { if ( in define ) { if ( name . equal ( reflector ) ) return reflector . class ; } return super . load class ( name , resolve ) ; }
public static string get method suggestion string ( string method name , class type , object [ ] argument ) { class info ci = class info . get class info ( type ) ; list < meta method > method = new array list < meta method > ( ci . get meta class ( ) . get method ( ) ) ; method . add all ( ci . get meta class ( ) . get meta method ( ) ) ; list < meta method > sugg = rank method ( method name , argument , method ) ; string builder sb = new string builder ( ) ; if ( ! sugg . be empty ( ) ) { sb . append ( `` \n possible solution : `` ) ; for ( int i = 0 ; i < sugg . size ( ) ; i++ ) { if ( i ! = 0 ) sb . append ( `` , `` ) ; sb . append ( sugg . get ( i ) . get name ( ) ) . append ( `` ( `` ) ; sb . append ( list parameter name ( sugg . get ( i ) . get parameter type ( ) ) ) ; sb . append ( `` ) `` ) ; } } class [ ] argument class = get argument class ( argument ) ; list < pair < class , class > > conflict class = get conflict class ( sugg , argument class ) ; if ( ! conflict class . be empty ( ) ) { sb . append ( `` \n the following class appear a argument class and a parameter class , `` ) ; sb . append ( `` but be define by different class loader : \n `` ) ; boolean first = true ; for ( pair < class , class > pair : conflict class ) { if ( ! first ) { sb . append ( `` , `` ) ; } else { first = false ; } sb . append ( pair . u . get name ( ) ) . append ( `` ( define by ' `` ) ; sb . append ( pair . u . get class loader ( ) ) ; sb . append ( `` ' and ' `` ) ; sb . append ( pair . v . get class loader ( ) ) ; sb . append ( `` ' ) `` ) ; } sb . append ( `` \n if one of the method suggestion match the method you want to call , `` ) ; sb . append ( `` \nthen check your class loader setup . `` ) ; } return sb . to string ( ) ; }
public static < t > t with object input stream ( input stream input stream , @ closure params ( value= simple type . class , options= `` java . io . object input stream `` ) closure < t > closure ) throw i o exception { return with stream ( new object input stream ( input stream ) , closure ) ; }
public vector get filter reader ( ) { return filter reader ; }
public static void set byte ( file file , byte [ ] bytes ) throw i o exception { i o groovy method . set byte ( new file output stream ( file ) , bytes ) ; }
public static void write ( file file , string text , string charset , boolean write bom ) throw i o exception { writer writer = null ; try { file output stream out = new file output stream ( file ) ; if ( write bom ) { write u t f16 bom if require ( out , charset ) ; } writer = new output stream writer ( out , charset ) ; writer . write ( text ) ; writer . flush ( ) ; writer temp = writer ; writer = null ; temp . close ( ) ; } finally { close with warning ( writer ) ; } }
public static void each byte ( file self , int buffer len , @ closure params ( value = from string . class , option = `` byte [ ] , integer `` ) closure closure ) throw i o exception { buffered input stream be = new input stream ( self ) ; i o groovy method . each byte ( be , buffer len , closure ) ; }
public static void each byte ( url url , @ closure params ( value = simple type . class , option = `` byte `` ) closure closure ) throw i o exception { input stream be = url . open connection ( ) . get input stream ( ) ; i o groovy method . each byte ( be , closure ) ; }
public static socket accept ( server socket server socket , @ closure params ( value= simple type . class , options= `` java . net . socket `` ) final closure closure ) throw i o exception { return accept ( server socket , true , closure ) ; }
public void write ( int c ) { if ( c ! = -1 ) { current . append ( ( char ) c ) ; } if ( c == '\n ' ) { current = new string buffer ( ) ; line . add ( current ) ; } }
public void add child of ( c s t node of ) { for ( int i = 1 ; i < of . size ( ) ; i++ ) { add ( of . get ( i ) ) ; } }
public token get root ( boolean safe ) { token root = get root ( ) ; if ( root == null & & safe ) { root = token . null ; } return root ; }
public static void command line compile ( string [ ] args ) throw exception { command line compile ( args , true ) ; }
public static void set byte ( file file , byte [ ] bytes ) throw i o exception { i o groovy method . set byte ( new file output stream ( file ) , bytes ) ; }
public void set be script body ( ) { set node meta data ( `` org . codehaus . groovy . ast . method node . be script body `` , boolean . true ) ; }
public binary expression get enclose binary expression ( ) { if ( enclose binary expression . be empty ( ) ) return null ; return enclose binary expression . get first ( ) ; }
public list < method node > get enclose method ( ) { return collection . unmodifiable list ( enclose method ) ; }
public switch statement pop enclose switch statement ( ) { return switch statement . remove first ( ) ; }
public switch statement pop enclose switch statement ( ) { return switch statement . remove first ( ) ; }
public class node get enclose class node ( ) { if ( enclose class node . be empty ( ) ) return null ; return enclose class node . get first ( ) ; }
public list < method node > get enclose method ( ) { return collection . unmodifiable list ( enclose method ) ; }
public list < method node > get enclose method ( ) { return collection . unmodifiable list ( enclose method ) ; }
protect void subscribe subscriber to stream ( stream http message msg , subscriber < http content > subscriber ) { msg . subscribe ( subscriber ) ; }
public void add static type error ( final string msg , final a s t node expr ) { type checking visitor . add static type error ( msg , expr ) ; }
public class node build list type ( class node component type ) { return parameterized type ( class helper . list_type , component type ) ; }
public static boolean choose math method ( selector info , meta method meta method ) { map < method type , method handle > xmap = method . get ( info . name ) ; if ( xmap == null ) return false ; method type type = replace with more specific type ( info . args , info . target type ) ; type = widen operator ( type ) ; method handle handle = xmap . get ( type ) ; if ( handle == null ) return false ; info . handle = handle ; return true ; }
public object invoke static method ( object object , string method name , object [ ] argument ) { if ( invoke static method method ! = null ) { meta class helper . unwrap ( argument ) ; return invoke static method method . invoke ( object , new object [ ] { method name , argument } ) ; } return super . invoke static method ( object , method name , argument ) ; }
public static < t > set < t > difference ( set < t > leave , set < t > right ) { object . require non null ( leave ) ; object . require non null ( right ) ; return leave . stream ( ) . filter ( k - > right . contains ( k ) == false ) . collect ( collector . to set ( ) ) ; }
public static < t > list < t > to list ( final stream < t > self ) { return self . collect ( collector . to list ( ) ) ; }
public file system add zip file ( path zip file ) { if ( ! file . be regular file ( zip file ) ) { throw new illegal argument exception ( `` not a regular file : `` + zip file ) ; } uri zip uri = uri . create ( `` zip : `` + zip file . to uri ( ) ) ; try { file system fs = file system . get file system ( zip uri ) ; resource to close . add ( fs ) ; return f ; } catch ( file system not find exception | provider not find exception e ) { reporter . error ex ( `` can not open zip file `` + zip file , e ) ; return null ; } }
protect void write map entry ( string key , object value , char buf buffer ) { buffer . add json field name ( key , disable unicode escape ) ; write object ( key , value , buffer ) ; }
protect void write map entry ( string key , object value , char buf buffer ) { buffer . add json field name ( key , disable unicode escape ) ; write object ( key , value , buffer ) ; }
public json writer i get writer by interface ( class < ? > clazz ) { for ( writer by interface w : writer interface ) { if ( w . _interface . be assignable from ( clazz ) ) return w . _writer ; } return null ; }
public json writer i get writer by interface ( class < ? > clazz ) { for ( writer by interface w : writer interface ) { if ( w . _interface . be assignable from ( clazz ) ) return w . _writer ; } return null ; }
public string to string ( ) { return generator . to json ( content ) ; }
public boolean be lazy chop ( ) { return lazy chop ; }
public final void add ( map item value miv ) { if ( len > = item . length ) { item = lazy map . grow ( item ) ; } item [ len ] = miv ; len++ ; }
public closure get body ( ) { return new closure ( this . parent , this ) { public void do call ( object [ ] args ) { final groovy object delegate = ( groovy object ) get delegate ( ) ; final g path result this object = ( g path result ) get this object ( ) ; node node = ( node ) this object . get at ( 0 ) ; list child = node . child ( ) ; for ( object child : child ) { delegate . get property ( `` mkp `` ) ; if ( child instanceof node ) { delegate . invoke method ( `` yield `` , new object [ ] { new node child ( ( node ) child , this object , `` * `` , null ) } ) ; } else { delegate . invoke method ( `` yield `` , new object [ ] { child } ) ; } } } } ; }
public url to u r l ( ) throw malformed u r l exception { return resource groovy method . to u r l ( ( char sequence ) text ( ) ) ; }
protect void set closure delegate ( closure closure , object node ) { closure . set delegate ( this ) ; }
protect void replace body ( final object new value ) { this . child . clear ( ) ; this . child . add ( new value ) ; }
public iterator child node ( ) { throw new groovy runtime exception ( `` ca n't get the child node on a g path expression select attribute : . . . . `` + this . parent . name ( ) + `` . `` + name ( ) + `` . child node ( ) `` ) ; }
public void set keep ignorable whitespace ( boolean keep ignorable whitespace ) { this . keep ignorable whitespace = keep ignorable whitespace ; }
public static synchronize void set global trim whitespace ( boolean trim whitespace ) { d o m category . trim whitespace = trim whitespace ; }
public static list < property node > get all property ( class node type , boolean include super property , boolean include static , boolean include pseudo getters ) { return get all property ( type , include super property , include static , include pseudo getters , false , false ) ; }
public void set omit null attribute ( boolean omit null attribute ) { this . omit null attribute = omit null attribute ; }
public string to string ( ) { return ( ( namespace u r i . equal ( empty_string ) ) ? local part : ' { ' + namespace u r i + ' } ' + local part ) ; }
protect synchronized static s a x parser factory get sax factory ( ) { if ( s sax factory == null ) { s sax factory = s a x parser factory . new instance ( ) ; s sax factory . set namespace aware ( true ) ; } return s sax factory ; }
public void add ( boolean bool ) { element . add ( bool == null ? json null . instance : new json primitive ( bool ) ) ; }
public gson builder set lenient ( ) { lenient = true ; return this ; }
public gson builder disable inner class serialization ( ) { excluder = excluder . disable inner class serialization ( ) ; return this ; }
public gson builder set field name strategy ( field name strategy field name strategy ) { this . field name policy = field name strategy ; return this ; }
public void add ( string property , json element value ) { if ( value == null ) { value = json null . instance ; } member . put ( property , value ) ; }
public long get a long ( ) { if ( element . size ( ) == 1 ) { return element . get ( 0 ) . get a long ( ) ; } throw new illegal state exception ( ) ; }
public void set value ( final string value ) { this . value = value ; }
public json element get ( string member name ) { return member . get ( member name ) ; }
public final class < ? super t > get raw type ( ) { return raw type ; }
public json element get ( int i ) { return element . get ( i ) ; }
public static boolean null equal ( object o1 , object o2 ) { return o1 == o2 || o1 ! = null & & o2 ! = null & & o1 . equal ( o2 ) ; }
public int hash code ( ) { return a map ( ) . hash code ( ) ; }
public class < k > key type ( ) { return key type ; }
public static < e > immutable multiset < e > copy of ( e [ ] element ) { return copy of ( array . a list ( element ) ) ; }
public static < e > immutable sort set < e > copy of sort ( sort set < e > sort set ) { comparator < ? super e > comparator = sort iterables . comparator ( sort set ) ; immutable list < e > list = immutable list . copy of ( sorted set ) ; if ( list . be empty ( ) ) { return empty set ( comparator ) ; } else { return new regular immutable sort set < e > ( list , comparator ) ; } }
public static < e > immutable sort set < e > copy of sort ( sort set < e > sort set ) { comparator < ? super e > comparator = sort iterables . comparator ( sort set ) ; immutable list < e > list = immutable list . copy of ( sorted set ) ; if ( list . be empty ( ) ) { return empty set ( comparator ) ; } else { return new regular immutable sort set < e > ( list , comparator ) ; } }
public static < e extend comparable < ? super e > > immutable sort multiset < e > of ( e e1 , e e2 ) { return copy of ( order . natural ( ) , arrays . a list ( e1 , e2 ) ) ; }
public void set queue type ( int queue type ) { throw new unsupported operation exception ( ) ; }
public static < b > set < list < b > > cartesian product ( list < ? extend set < ? extend b > > set ) { return cartesian set . create ( set ) ; }
public iterator < e > iterator ( ) { return new queue iterator ( ) ; }
public iterator < e > iterator ( ) { return new queue iterator ( ) ; }
public static < e > fluent iterable < e > of ( @ nullable e element , e . . . element ) { return from ( list . a list ( element , element ) ) ; }
public static < e > deque < e > synchronize deque ( deque < e > deque ) { return synchronize . deque ( deque , null ) ; }
public static < e extend comparable < ? > > builder < e > natural order ( ) { return new builder < e > ( order . natural ( ) ) ; }
protect final char [ ] escape ( int cp ) { if ( cp < replacement length ) { char [ ] char = replacement [ cp ] ; if ( char ! = null ) { return char ; } } if ( cp > = safe min & & cp < = safe max ) { return null ; } return escape unsafe ( cp ) ; }
@ override protect final char [ ] escape ( char c ) { if ( c < replacement length ) { char [ ] char = replacement [ c ] ; if ( char ! = null ) { return char ; } } if ( c > = safe min & & c < = safe max ) { return null ; } return escape unsafe ( c ) ; }
@ override protect final char [ ] escape ( char c ) { if ( c < replacement length ) { char [ ] char = replacement [ c ] ; if ( char ! = null ) { return char ; } } if ( c > = safe min & & c < = safe max ) { return null ; } return escape unsafe ( c ) ; }
public object get event ( ) { return event ; }
public static hash function hmac md5 ( key key ) { return new mac hash function ( `` hmac m d5 `` , key , hmac to string ( `` hmac md5 `` , key ) ) ; }
public static hash code combine order ( iterable < hash code > hash code ) { iterator < hash code > iterator = hash code . iterator ( ) ; check argument ( iterator . have next ( ) , `` must be at least 1 hash code to combine . `` ) ; int bit = iterator . next ( ) . bit ( ) ; byte [ ] result byte = new byte [ bit / 8 ] ; for ( hash code hash code : hash code ) { byte [ ] next byte = hash code . a byte ( ) ; check argument ( next byte . length == result byte . length , `` all hashcodes must have the same bit length . `` ) ; for ( int i = 0 ; i < next byte . length ; i++ ) { result bytes [ i ] = ( byte ) ( result bytes [ i ] * 37 ^ next byte [ i ] ) ; } } return hash code . from bytes no copy ( result byte ) ; }
public int read ( byte [ ] byte , int off , int len ) throw i o exception { int num of byte read = in . read ( byte , off , len ) ; if ( num of byte read ! = -1 ) { hasher . put byte ( byte , off , num of byte read ) ; } return num of byte read ; }
public static base encode base32 hex ( ) { return base32_hex ; }
public static void dec ( int [ ] array1 , int [ ] array2 ) { precondition . check argument ( array1 . length == array2 . length , `` array1 . length ! = array2 . length `` ) ; for ( int index = 0 ; index < array1 . length ; index++ ) { array1 [ index ] -= array2 [ index ] ; } }
public long copy to ( char sink sink ) throw i o exception { check not null ( sink ) ; close closer = closer . create ( ) ; try { reader reader = closer . register ( open stream ( ) ) ; writer writer = closer . register ( sink . open stream ( ) ) ; return char stream . copy ( reader , writer ) ; } catch ( throwable e ) { throw close . rethrow ( e ) ; } finally { closer . close ( ) ; } }
public static map byte buffer map ( file file , map mode mode ) throw i o exception { check not null ( file ) ; check not null ( mode ) ; if ( ! file . exists ( ) ) { throw new file not find exception ( file . to string ( ) ) ; } return map ( file , mode , file . length ( ) ) ; }
public static void ensure from to ( final int array length , final int from , final int to ) { if ( from < 0 ) throw new array index out of bound exception ( `` start index ( `` + from + `` ) be negative `` ) ; if ( from > to ) throw new illegal argument exception ( `` start index ( `` + from + `` ) be great than end index ( `` + to + `` ) `` ) ; if ( to > array length ) throw new array index out of bound exception ( `` end index ( `` + to + `` ) be great than array length ( `` + array length + `` ) `` ) ; }
public static < t > t read byte ( file file , byte processor < t > processor ) throw i o exception { return a byte source ( file ) . read ( processor ) ; }
public host and port require bracket for i pv6 ( ) { check argument ( ! have bracketless colon , `` possible bracketless i pv6 literal : % s `` , host ) ; return this ; }
public static inet address decrement ( inet address address ) { byte [ ] addr = address . get address ( ) ; int i = addr . length - 1 ; while ( i > = 0 & & addr [ i ] == ( byte ) 0x00 ) { addr [ i ] = ( byte ) 0xff ; i -- ; } check argument ( i > = 0 , `` decrementing % s would wrap . `` , address ) ; addr [ i ] -- ; return byte to inet address ( addr ) ; }
public string to string ( ) { return name ; }
public boolean be public suffix ( ) { return public suffix index == 0 ; }
public boolean equal ( @ nullable object object ) { if ( object == this ) { return true ; } if ( object instanceof internet domain name ) { internet domain name that = ( internet domain name ) object ; return this . name . equal ( that . name ) ; } return false ; }
public immutable set < class info > get top level class ( ) { return fluent iterable . from ( resource ) . filter ( class info . class ) . filter ( new predicate < class info > ( ) { @ override public boolean apply ( class info info ) { return info . be top level ( ) ; } } ) . to set ( ) ; }
public final < x > type token < t > where ( type parameter < x > type param , class < x > type arg ) { return where ( type param , of ( type arg ) ) ; }
public final boolean compare and set ( double expect , double update ) { return updater . compare and set ( this , double to raw long bit ( expect ) , double to raw long bit ( update ) ) ; }
public boolean enter if ( guard guard ) { if ( guard . monitor ! = this ) { throw new illegal monitor state exception ( ) ; } final reentrant lock lock = this . lock ; lock . lock ( ) ; boolean satisfy = false ; try { return satisfied = guard . be satisfied ( ) ; } finally { if ( ! satisfy ) { lock . unlock ( ) ; } } }
public void wait for ( guard guard ) throw interrupted exception { if ( ! ( ( guard . monitor == this ) & lock . be hold by current thread ( ) ) ) { throw new illegal monitor state exception ( ) ; } if ( ! guard . be satisfied ( ) ) { await ( guard , true ) ; } }
public static < t > fluent iterable < t > concat ( iterable < ? extend t > a , iterable < ? extend t > b ) { return concat ( immutable list . of ( a , b ) ) ; }
public void put all ( bloom filter < t > that ) { check not null ( that ) ; check argument ( this ! = that , `` can not combine a bloom filter with itself . `` ) ; check argument ( this . num hash function == that . num hash function , `` bloom filter must have the same number of hash function ( % s ! = % s ) `` , this . num hash function , that . num hash function ) ; check argument ( this . bit size ( ) == that . bit size ( ) , `` bloom filter must have the same size underlie bit array ( % s ! = % s ) `` , this . bit size ( ) , that . bit size ( ) ) ; check argument ( this . strategy . equal ( that . strategy ) , `` bloom filter must have equal strategy ( % s ! = % s ) `` , this . strategy , that . strategy ) ; check argument ( this . funnel . equal ( that . funnel ) , `` bloom filter must have equal funnel ( % s ! = % s ) `` , this . funnel , that . funnel ) ; this . bit . put all ( that . bit ) ; }
public static hash function hmac sha512 ( key key ) { return new mac hash function ( `` hmac s h a512 `` , key , hmac to string ( `` hmac sha512 `` , key ) ) ; }
public static base encode base64 ( ) { return base64 ; }
public static long copy ( input stream from , output stream to ) throw i o exception { check not null ( from ) ; check not null ( to ) ; byte [ ] buf = new byte [ buf_size ] ; long total = 0 ; while ( true ) { int r = from . read ( buf ) ; if ( r == -1 ) { break ; } to . write ( buf , 0 , r ) ; total += r ; } return total ; }
public pair stats snapshot ( ) { return new pair stats ( x stats . snapshot ( ) , y stats . snapshot ( ) , sum of product of delta ) ; }
public static scale quartile ( ) { return scale ( 4 ) ; }
public static scale quartile ( ) { return scale ( 4 ) ; }
public final fluent iterable < e > append ( iterable < ? extend e > other ) { return from ( fluent iterable . concat ( get delegate ( ) , other ) ) ; }
public void put all ( bloom filter < t > that ) { check not null ( that ) ; check argument ( this ! = that , `` can not combine a bloom filter with itself . `` ) ; check argument ( this . num hash function == that . num hash function , `` bloom filter must have the same number of hash function ( % s ! = % s ) `` , this . num hash function , that . num hash function ) ; check argument ( this . bit size ( ) == that . bit size ( ) , `` bloom filter must have the same size underlie bit array ( % s ! = % s ) `` , this . bit size ( ) , that . bit size ( ) ) ; check argument ( this . strategy . equal ( that . strategy ) , `` bloom filter must have equal strategy ( % s ! = % s ) `` , this . strategy , that . strategy ) ; check argument ( this . funnel . equal ( that . funnel ) , `` bloom filter must have equal funnel ( % s ! = % s ) `` , this . funnel , that . funnel ) ; this . bit . put all ( that . bit ) ; }
public void put all ( bloom filter < t > that ) { check not null ( that ) ; check argument ( this ! = that , `` can not combine a bloom filter with itself . `` ) ; check argument ( this . num hash function == that . num hash function , `` bloom filter must have the same number of hash function ( % s ! = % s ) `` , this . num hash function , that . num hash function ) ; check argument ( this . bit size ( ) == that . bit size ( ) , `` bloom filter must have the same size underlie bit array ( % s ! = % s ) `` , this . bit size ( ) , that . bit size ( ) ) ; check argument ( this . strategy . equal ( that . strategy ) , `` bloom filter must have equal strategy ( % s ! = % s ) `` , this . strategy , that . strategy ) ; check argument ( this . funnel . equal ( that . funnel ) , `` bloom filter must have equal funnel ( % s ! = % s ) `` , this . funnel , that . funnel ) ; this . bit . put all ( that . bit ) ; }
public medium type with parameter ( multimap < string , string > parameter ) { return create ( type , subtype , parameter ) ; }
public int hash code ( ) { int hash = 1 ; for ( int i = start ; i < end ; i++ ) { hash * = 31 ; hash += double . hash code ( array [ i ] ) ; } return hash ; }
public void shutdown ( ) { if ( logger . be info enable ( ) ) { logger . info ( `` shut down executor service `` + ( this . bean name ! = null ? `` ' `` + this . bean name + `` ' `` : `` `` ) ) ; } if ( this . wait for task to complete on shutdown ) { this . executor . shutdown ( ) ; } else { this . executor . shutdown now ( ) ; } await termination if necessary ( ) ; }
public sort set < v > remove all ( @ nullable object key ) { return ( sort set < v > ) super . remove all ( key ) ; }
public static < t > iterable < list < t > > partition ( final iterable < t > iterable , final int size ) { check not null ( iterable ) ; check argument ( size > 0 ) ; return new fluent iterable < list < t > > ( ) { @ override public iterator < list < t > > iterator ( ) { return iterators . partition ( iterable . iterator ( ) , size ) ; } } ; }
public static < t > iterator < t > concat ( iterator < ? extend t > a , iterator < ? extend t > b ) { check not null ( a ) ; check not null ( b ) ; return concat ( consume for array ( a , b ) ) ; }
public static < t > unmodifiable iterator < list < t > > pad partition ( iterator < t > iterator , int size ) { return partition impl ( iterator , size , true ) ; }
public object clone ( ) { text text = ( text ) super . clone ( ) ; text . value = value ; return text ; }
public static < e > immutable sort multiset < e > copy of sort ( sort multiset < e > sort multiset ) { return copy of sorted entry ( sort multiset . comparator ( ) , list . new array list ( sorted multiset . entry set ( ) ) ) ; }
public static byte [ ] to byte array ( input stream in ) throw i o exception { byte array output stream out = new byte array output stream ( ) ; copy ( in , out ) ; return out . to byte array ( ) ; }
public final fluent iterable < e > filter ( predicate < ? super e > predicate ) { return from ( iterables . filter ( get delegate ( ) , predicate ) ) ; }
public integer get line number ( member member ) { precondition . check argument ( type == member . get declare class ( ) , `` member % s belongs to % s , not % s `` , member , member . get declare class ( ) , type ) ; return line . get ( member key ( member ) ) ; }
public int get first line ( ) { return first line == integer . max_value ? 1 : first line ; }
public static matcher < object > only ( object value ) { return new only ( value ) ; }
public static matcher < object > only ( object value ) { return new only ( value ) ; }
public link bind builder < t > set binding ( ) { return delegate . set binding ( ) ; }
public static < e > immutable sort set < e > copy of sort ( sort set < e > sort set ) { comparator < ? super e > comparator = sort iterables . comparator ( sort set ) ; immutable list < e > list = immutable list . copy of ( sorted set ) ; if ( list . be empty ( ) ) { return empty set ( comparator ) ; } else { return new regular immutable sort set < e > ( list , comparator ) ; } }
public static < t extend annotation > t generate annotation ( class < t > annotation type ) { precondition . check state ( be all default method ( annotation type ) , `` % s be not all default method `` , annotation type ) ; return ( t ) cache . get unchecked ( annotation type ) ; }
public injection point get injection point ( ) { return injection point ; }
public type listener get listener ( ) { return listener ; }
public static module require explicit binding module ( ) { return new require explicit binding module ( ) ; }
public void add table ( db table or view table ) { last table = table ; if ( table == null ) { table = new . hash set ( ) ; } table . add ( table ) ; }
public void set query ( string query ) { if ( ! string utils . equal ( this . query , query ) ) { this . query = query ; this . query upper = string utils . to upper english ( query ) ; } }
public void add constraint command ( define command command ) { if ( command instanceof create index ) { constraint command . add ( command ) ; } else { alter table add constraint con = ( alter table add constraint ) command ; boolean already set ; if ( con . get type ( ) == command interface . alter_table_add_constraint_primary_key ) { already set = set primary key column ( con . get index column ( ) ) ; } else { already set = false ; } if ( ! already set ) { constraint command . add ( command ) ; } } }
public java method [ ] get java method ( ) { load ( ) ; return java method ; }
public prepare prepare ( string sql ) { prepared p = parse ( sql ) ; p . prepare ( ) ; if ( current token type ! = end ) { throw get syntax error ( ) ; } return p ; }
public void set s q l ( string sql ) { this . sql statement = sql ; }
public static void reset calendar ( ) { cached_calendar . remove ( ) ; time zone = null ; zone offset millis = create gregorian calendar ( ) . get ( calendar . zone_offset ) ; }
public void update on table column rename ( ) { if ( delete action ! = null ) { delete s q l = null ; build delete s q l ( ) ; } if ( update action ! = null ) { update s q l = null ; build update s q l ( ) ; } }
public void set index ( index index , boolean be owner ) { this . index = index ; this . index owner = be owner ; }
public void set user password hash ( byte [ ] hash ) { this . user password hash = hash ; }
public string get name ( ) { if ( persistent ) { if ( name normalize == null ) { string suffix = constant . suffix_page_file ; string n = file utils . to real path ( name + suffix ) ; string file name = file utils . get name ( n ) ; if ( file name . length ( ) < suffix . length ( ) + 1 ) { throw db exception . get ( error code . invalid_database_name_1 , name ) ; } name normalized = n . substring ( 0 , n . length ( ) - suffix . length ( ) ) ; } return name normalize ; } return name ; }
public void rollback to ( savepoint savepoint , boolean trim to size ) { int index = savepoint == null ? 0 : savepoint . log index ; while ( undo log . size ( ) > index ) { undo log record entry = undo log . get last ( ) ; entry . undo ( this ) ; undo log . remove last ( trim to size ) ; } if ( transaction ! = null ) { set < string > change = transaction . get change map ( savepoint . transaction savepoint ) ; for ( m v table t : database . get mv store ( ) . get table ( ) ) { if ( change . contains ( t . get map name ( ) ) ) { t . set modify ( ) ; } } transaction . rollback to savepoint ( savepoint . transaction savepoint ) ; } if ( savepoints ! = null ) { string [ ] names = new string [ savepoints . size ( ) ] ; savepoints . key set ( ) . to array ( name ) ; for ( string name : name ) { savepoint sp = savepoints . get ( name ) ; int savepoint index = sp . log index ; if ( savepoint index > index ) { savepoints . remove ( name ) ; } } } }
public void remove local temp table ( table table ) { modification id++ ; local temp table . remove ( table . get name ( ) ) ; synchronize ( database ) { table . remove child and resource ( this ) ; } }
public void redirect ( string location ) { if ( log . be debug enable ( ) ) { log . debug ( `` redirecting ( { } { } to { } `` , `` find `` , http servlet response . sc_found , location ) ; } try { response . send redirect ( location ) ; } catch ( i o exception io exception ) { log . warn ( `` redirect failure `` , io exception ) ; } }
public static boolean get boolean property ( property prop , string key , boolean def ) { string value = prop . get property ( key , `` `` + def ) ; try { return boolean . parse boolean ( value ) ; } catch ( exception e ) { trace system . trace throwable ( e ) ; return def ; } }
protect double get domain low bound ( double p ) { return 0 ; }
public string to string ( ) { return get s q l ( ) ; }
public static expression visitor get not from resolver visitor ( column resolver resolver ) { return new expression visitor ( not_from_resolver , 0 , null , null , null , resolver , null , null ) ; }
public void add data modification id ( long value ) { long m = max data modification id [ 0 ] ; if ( value > m ) { max data modification id [ 0 ] = value ; } }
public column resolver get resolver ( ) { return resolver ; }
protect void remove index info ( index info index ) { index . remove ( index . id ) ; }
public static index type create unique ( boolean persistent , boolean hash ) { index type type = new index type ( ) ; type . unique = true ; type . persistent = persistent ; type . hash = hash ; return type ; }
private void remove child ( int i ) { index . get page store ( ) . log undo ( this , data ) ; write = false ; change count = index . get page store ( ) . get change count ( ) ; int remove key index = i < entry count ? i : i - 1 ; entry count -- ; length -= 4 + data . get var long len ( key [ remove key index ] ) ; if ( entry count < 0 ) { db exception . throw internal error ( ) ; } key = remove ( key , entry count + 1 , remove key index ) ; child page id = remove ( child page id , entry count + 2 , i ) ; }
public void truncate ( long len ) throw s q l exception { throw unsupported ( `` lob update `` ) ; }
public byte [ ] get byte ( int parameter index ) throw s q l exception { check register ( parameter index ) ; return get open result set ( ) . get byte ( parameter index ) ; }
public date get date ( int parameter index , calendar cal ) throw s q l exception { check register ( parameter index ) ; return get open result set ( ) . get date ( parameter index , cal ) ; }
public clob get clob ( int parameter index ) throw s q l exception { check register ( parameter index ) ; return get open result set ( ) . get clob ( parameter index ) ; }
public ref get ref ( int parameter index ) throw s q l exception { throw unsupported ( `` ref `` ) ; }
public void set s q l x m l ( int parameter index , sqlxml x ) throw s q l exception { throw unsupported ( `` sqlxml `` ) ; }
public void set binary stream ( string parameter name , input stream x , int length ) throw s q l exception { set binary stream ( get index for name ( parameter name ) , x , length ) ; }
public void set object ( string parameter name , object x , int target sql type ) throw s q l exception { set object ( get index for name ( parameter name ) , x , target sql type ) ; }
public void truncate ( long len ) throw s q l exception { throw unsupported ( `` lob update `` ) ; }
public int set byte ( long po , byte [ ] bytes , int offset , int len ) throw s q l exception { throw unsupported ( `` lob update `` ) ; }
public boolean all table be selectable ( ) { debug code call ( `` all table be selectable `` ) ; return true ; }
public boolean support result set concurrency ( int type , int concurrency ) { if ( be debug enabled ( ) ) { debug code ( `` support result set concurrency ( `` +type+ `` , `` +concurrency+ `` ) ; `` ) ; } return type ! = result set . type_scroll_sensitive ; }
public boolean support table correlation name ( ) { debug code call ( `` support table correlation name `` ) ; return true ; }
public boolean support group by unrelated ( ) { debug code call ( `` support group by unrelated `` ) ; return true ; }
public boolean support limit outer join ( ) { debug code call ( `` support limit outer join `` ) ; return true ; }
public boolean support catalog in data manipulation ( ) { debug code call ( `` support catalog in data manipulation `` ) ; return true ; }
public boolean support schemas in data manipulation ( ) { debug code call ( `` support schema in data manipulation `` ) ; return true ; }
public boolean support select for update ( ) { debug code call ( `` support select for update `` ) ; return true ; }
public boolean support open cursor across commit ( ) { debug code call ( `` support open cursor across commit `` ) ; return false ; }
public int get max row size ( ) { debug code call ( `` get max row size `` ) ; return 0 ; }
public int get max user name length ( ) { debug code call ( `` get max user name length `` ) ; return 0 ; }
public int get max user name length ( ) { debug code call ( `` get max user name length `` ) ; return 0 ; }
public string get s q l ( ) { return sql ; }
public print writer get log writer ( ) { debug code call ( `` get log writer `` ) ; return log writer ; }
public string get password ( ) { debug code call ( `` get password `` ) ; return convert to string ( password char ) ; }
public void set password ( string password ) { debug code call ( `` set password `` , `` `` ) ; this . password char = convert to char array ( password ) ; }
public void commit ( xid xid , boolean one phase ) throw x a exception { if ( be debug enabled ( ) ) { debug code ( `` commit ( `` + jdbc xid . to string ( xid ) + `` , `` +one phase+ `` ) ; `` ) ; } statement stat = null ; try { if ( one phase ) { physical conn . commit ( ) ; } else { stat = physical conn . create statement ( ) ; stat . execute ( `` commit transaction `` + jdbc xid . to string ( xid ) ) ; prepare = false ; } physical conn . set auto commit ( true ) ; } catch ( s q l exception e ) { throw convert exception ( e ) ; } finally { jdbc utils . close silently ( stat ) ; } current transaction = null ; }
public int prepare ( xid xid ) throw x a exception { if ( be debug enabled ( ) ) { debug code ( `` prepare ( `` + jdbc xid . to string ( xid ) + `` ) ; `` ) ; } check open ( ) ; if ( ! current transaction . equal ( xid ) ) { throw new x a exception ( x a exception . xaer_inval ) ; } statement stat = null ; try { stat = physical conn . create statement ( ) ; stat . execute ( `` prepare commit `` + jdbc xid . to string ( xid ) ) ; prepare = true ; } catch ( s q l exception e ) { throw convert exception ( e ) ; } finally { jdbc utils . close silently ( stat ) ; } return xa_ok ; }
public static s q l exception to s q l exception ( exception e ) { if ( e instanceof s q l exception ) { return ( s q l exception ) e ; } return convert ( e ) . get s q l exception ( ) ; }
public static db exception convert i o exception ( i o exception e , string message ) { if ( message == null ) { throwable t = e . get cause ( ) ; if ( t instanceof db exception ) { return ( db exception ) t ; } return get ( error code . io_exception_1 , e , e . to string ( ) ) ; } return get ( error code . io_exception_2 , e , e . to string ( ) , message ) ; }
public void set level system out ( int level ) { level system out = level ; update level ( ) ; }
public void debug ( string s , object . . . params ) { if ( be enable ( trace system . debug ) ) { s = message format . format ( s , params ) ; trace writer . write ( trace system . debug , module , s , null ) ; } }
public void error ( throwable t , string s ) { if ( be enable ( trace system . error ) ) { trace writer . write ( trace system . error , module , s , t ) ; } }
public void set max ( int dim , float x ) { min max [ dim + dim + 1 ] = x ; }
protect static string quote big decimal ( big decimal x ) { if ( x == null ) { return `` null `` ; } return `` new big decimal ( \ `` `` + x . to string ( ) + `` \ `` ) `` ; }
public trace get trace ( int module id ) { trace t = trace . get ( module id ) ; if ( t == null ) { t = new trace ( writer , module id ) ; if ( ! trace . compare and set ( module id , null , t ) ) { t = trace . get ( module id ) ; } } return t ; }
public void clear ( ) { long max = math . max ( 1 , max memory / segment count ) ; for ( int i = 0 ; i < segment count ; i++ ) { segment [ i ] = new segment < v > ( max , average memory , stack move distance ) ; } }
public synchronize list < long > key ( boolean cold , boolean non resident ) { array list < long > key = new array list < long > ( ) ; for ( segment < v > s : segment ) { key . add all ( s . key ( cold , non resident ) ) ; } return key ; }
public final void write v long ( long i ) throw i o exception { while ( ( i & ~0x7 f ) ! = 0 ) { write byte ( ( byte ) ( ( i & 0x7f ) | 0x80 ) ) ; i > > > = 7 ; } write byte ( ( byte ) i ) ; }
public int get line number ( long location id ) { return ( ( int ) location id ) & 0xfffff ; }
public k first key ( ) { return get first last ( true ) ; }
public k high key ( k key ) { return get min max ( key , false , true ) ; }
public v remove ( object key ) { before write ( ) ; try { long write version = store . get current version ( ) ; page p = copy on write ( root , write version ) ; @ suppress warning ( `` unchecked `` ) v result = ( v ) remove ( p , write version , key ) ; new root ( p ) ; return result ; } finally { after write ( ) ; } }
public v remove ( object key ) { before write ( ) ; try { long write version = store . get current version ( ) ; page p = copy on write ( root , write version ) ; @ suppress warning ( `` unchecked `` ) v result = ( v ) remove ( p , write version , key ) ; new root ( p ) ; return result ; } finally { after write ( ) ; } }
public v remove ( object key ) { before write ( ) ; try { long write version = store . get current version ( ) ; page p = copy on write ( root , write version ) ; @ suppress warning ( `` unchecked `` ) v result = ( v ) remove ( p , write version , key ) ; new root ( p ) ; return result ; } finally { after write ( ) ; } }
public static void compact ( string source file name , string target file name , boolean compress ) { m v store source = new m v store . builder ( ) . file name ( source file name ) . read only ( ) . open ( ) ; file utils . delete ( target file name ) ; m v store . builder b = new m v store . builder ( ) . file name ( target file name ) ; if ( compress ) { b . compress ( ) ; } m v store target = b . open ( ) ; compact ( source , target ) ; target . close ( ) ; source . close ( ) ; }
public int get page size ( ) { return page size ; }
public void set store version ( int version ) { check open ( ) ; mark meta change ( ) ; meta . put ( `` setting . store version `` , integer . to string ( version ) ) ; }
public iterator < spatial key > find intersect key ( spatial key x ) { check open ( ) ; return new r tree cursor ( this , root , x ) { @ override protect boolean check ( boolean leaf , spatial key key , spatial key test ) { return key type . be overlap ( key , test ) ; } } ; }
public void set max ( int dim , float x ) { min max [ dim + dim + 1 ] = x ; }
public void set random access result ( boolean b ) { random access result = b ; }
public value [ ] read row ( value [ ] row ) throw s q l exception { statement builder buff = new statement builder ( `` select `` ) ; append column list ( buff , false ) ; buff . append ( `` from `` ) ; append table name ( buff ) ; append key condition ( buff ) ; prepare statement prep = conn . prepare statement ( buff . to string ( ) ) ; set key ( prep , 1 , row ) ; result set r = prep . execute query ( ) ; if ( ! r . next ( ) ) { throw db exception . get ( error code . no_data_available ) ; } value [ ] new row = new value [ column count ] ; for ( int i = 0 ; i < column count ; i++ ) { int type = result . get column type ( i ) ; new row [ i ] = data type . read value ( conn . get session ( ) , r , i + 1 , type ) ; } return new row ; }
public value [ ] read row ( value [ ] row ) throw s q l exception { statement builder buff = new statement builder ( `` select `` ) ; append column list ( buff , false ) ; buff . append ( `` from `` ) ; append table name ( buff ) ; append key condition ( buff ) ; prepare statement prep = conn . prepare statement ( buff . to string ( ) ) ; set key ( prep , 1 , row ) ; result set r = prep . execute query ( ) ; if ( ! r . next ( ) ) { throw db exception . get ( error code . no_data_available ) ; } value [ ] new row = new value [ column count ] ; for ( int i = 0 ; i < column count ; i++ ) { int type = result . get column type ( i ) ; new row [ i ] = data type . read value ( conn . get session ( ) , r , i + 1 , type ) ; } return new row ; }
public void rename ( schema object obj , string new name ) { int type = obj . get type ( ) ; hash map < string , schema object > map = get map ( type ) ; if ( sys property . check ) { if ( ! map . contains key ( obj . get name ( ) ) ) { db exception . throw internal error ( `` not find : `` + obj . get name ( ) ) ; } if ( obj . get name ( ) . equal ( new name ) || map . contains key ( new name ) ) { db exception . throw internal error ( `` object already exist : `` + new name ) ; } } obj . check rename ( ) ; map . remove ( obj . get name ( ) ) ; free unique name ( obj . get name ( ) ) ; obj . rename ( new name ) ; map . put ( new name , obj ) ; free unique name ( new name ) ; }
public index find local temp table index ( string name ) { if ( local temp table index == null ) { return null ; } return local temp table index . get ( name ) ; }
public string get trigger class name ( ) { return trigger class name ; }
public constant get constant ( string constant name ) { constant constant = constant . get ( constant name ) ; if ( constant == null ) { throw db exception . get ( error code . constant_not_found_1 , constant name ) ; } return constant ; }
public constant get constant ( string constant name ) { constant constant = constant . get ( constant name ) ; if ( constant == null ) { throw db exception . get ( error code . constant_not_found_1 , constant name ) ; } return constant ; }
public table create table ( create table data data ) { synchronize ( database ) { if ( ! data . temporary || data . global temporary ) { database . lock meta ( data . session ) ; } data . schema = this ; if ( data . table engine ! = null ) { table engine engine ; try { engine = ( table engine ) utils . load user class ( data . table engine ) . new instance ( ) ; } catch ( exception e ) { throw db exception . convert ( e ) ; } return engine . create table ( data ) ; } return new regular table ( data ) ; } }
public void set trigger source ( string source , boolean force ) { this . set trigger action ( null , source , force ) ; }
public void fire ( session session , int type , boolean before action ) { if ( row base || before ! = before action || ( type mask & type ) == 0 ) { return ; } load ( ) ; connection c2 = session . create connection ( false ) ; boolean old = false ; if ( type ! = trigger . select ) { old = session . set commit or rollback disabled ( true ) ; } value identity = session . get last scope identity ( ) ; try { trigger callback . fire ( c2 , null , null ) ; } catch ( throwable e ) { throw db exception . get ( error code . error_executing_trigger_3 , e , get name ( ) , trigger class name , e . to string ( ) ) ; } finally { session . set last scope identity ( identity ) ; if ( type ! = trigger . select ) { session . set commit or rollback disabled ( old ) ; } } }
public static byte [ ] get p b k d f2 ( byte [ ] password , byte [ ] salt , int iteration , int result len ) { byte [ ] result = new byte [ result len ] ; byte [ ] key = normalize key for h m a c ( password ) ; sha256 sha = new sha256 ( ) ; int len = 64 + math . max ( 32 , salt . length + 4 ) ; byte [ ] message = new byte [ len ] ; int int len = get int count ( len ) ; byte [ ] byte buff = new byte [ int len * 4 ] ; int [ ] int buff = new int [ int len ] ; byte [ ] i key = new byte [ 64 + len ] ; byte [ ] o key = new byte [ 64 + 32 ] ; for ( int k = 1 , offset = 0 ; offset < result len ; k++ , offset += 32 ) { for ( int i = 0 ; i < iteration ; i++ ) { if ( i == 0 ) { system . arraycopy ( salt , 0 , message , 0 , salt . length ) ; write int ( message , salt . length , k ) ; len = salt . length + 4 ; } else { system . arraycopy ( sha . result , 0 , message , 0 , 32 ) ; len = 32 ; } sha . calculate h m a c ( key , message , len , i key , o key , byte buff , int buff ) ; for ( int j = 0 ; j < 32 & & j + offset < result len ; j++ ) { result [ j + offset ] ^= sha . result [ j ] ; } } } array . fill ( password , ( byte ) 0 ) ; array . fill ( key , ( byte ) 0 ) ; return result ; }
public static byte [ ] get p b k d f2 ( byte [ ] password , byte [ ] salt , int iteration , int result len ) { byte [ ] result = new byte [ result len ] ; byte [ ] key = normalize key for h m a c ( password ) ; sha256 sha = new sha256 ( ) ; int len = 64 + math . max ( 32 , salt . length + 4 ) ; byte [ ] message = new byte [ len ] ; int int len = get int count ( len ) ; byte [ ] byte buff = new byte [ int len * 4 ] ; int [ ] int buff = new int [ int len ] ; byte [ ] i key = new byte [ 64 + len ] ; byte [ ] o key = new byte [ 64 + 32 ] ; for ( int k = 1 , offset = 0 ; offset < result len ; k++ , offset += 32 ) { for ( int i = 0 ; i < iteration ; i++ ) { if ( i == 0 ) { system . arraycopy ( salt , 0 , message , 0 , salt . length ) ; write int ( message , salt . length , k ) ; len = salt . length + 4 ; } else { system . arraycopy ( sha . result , 0 , message , 0 , 32 ) ; len = 32 ; } sha . calculate h m a c ( key , message , len , i key , o key , byte buff , int buff ) ; for ( int j = 0 ; j < 32 & & j + offset < result len ; j++ ) { result [ j + offset ] ^= sha . result [ j ] ; } } } array . fill ( password , ( byte ) 0 ) ; array . fill ( key , ( byte ) 0 ) ; return result ; }
public shutdown get shutdown ( ) { return this . shutdown ; }
public boolean be close ( ) { if ( be open ( ) ) { return false ; } store lock . lock ( ) ; try { assert state == state_closed ; return true ; } finally { store lock . unlock ( ) ; } }
public static final string get directory component ( string filename ) { if ( filename == null || filename . length ( ) == 0 ) { return `` `` ; } string separator = determine separator ( filename ) ; string directory = string utils . chomp ( filename , separator ) ; if ( filename . equal ( directory ) ) { return `` . `` ; } return directory ; }
public static file store open ( data handler handler , string name , string mode ) { return open ( handler , name , mode , null , null , 0 ) ; }
public void stop auto delete ( ) { handler . get temp file deleter ( ) . stop auto delete ( auto delete reference , name ) ; auto delete reference = null ; }
public void auto delete ( ) { if ( auto delete reference == null ) { auto delete reference = handler . get temp file deleter ( ) . add file ( name , this ) ; } }
public static void register ( file path provider ) { register default provider ( ) ; provider . put ( provider . get scheme ( ) , provider ) ; }
public static long size ( string file name ) { return file path . get ( file name ) . size ( ) ; }
public static input stream new input stream ( string file name ) throw i o exception { return file path . get ( file name ) . new input stream ( ) ; }
public static void read fully ( final input stream fd , final byte [ ] dst , int off , int len ) throw i o exception { while ( len > 0 ) { final int r = fd . read ( dst , off , len ) ; if ( r < = 0 ) throw new e o f exception ( j git text . get ( ) . short read of block ) ; off += r ; len -= r ; } }
public static void delete recursive ( string path , boolean try only ) { if ( exists ( path ) ) { if ( be directory ( path ) ) { for ( string s : new directory stream ( path ) ) { delete recursive ( s , try only ) ; } } if ( try only ) { try delete ( path ) ; } else { delete ( path ) ; } } }
public void remove trigger ( trigger object trigger ) { remove ( trigger , trigger ) ; }
public void remove view ( table view view ) { remove ( view , view ) ; }
public void add constraint ( constraint constraint ) { if ( constraint == null || constraint . index of ( constraint ) < 0 ) { constraint = add ( constraint , constraint ) ; } }
public boolean fire before row ( session session , row old row , row new row ) { boolean do = fire row ( session , old row , new row , true , false ) ; fire constraint ( session , old row , new row , true ) ; return do ; }
public void add sequence ( sequence sequence ) { sequence = add ( sequence , sequence ) ; }
public void map and add filter ( expression on ) { on . map column ( this , 0 ) ; add filter condition ( on , true ) ; on . create index condition ( session , this ) ; if ( nested join ! = null ) { on . map column ( nested join , 0 ) ; on . create index condition ( session , nested join ) ; } if ( join ! = null ) { join . map and add filter ( on ) ; } }
public void map and add filter ( expression on ) { on . map column ( this , 0 ) ; add filter condition ( on , true ) ; on . create index condition ( session , this ) ; if ( nested join ! = null ) { on . map column ( nested join , 0 ) ; on . create index condition ( session , nested join ) ; } if ( join ! = null ) { join . map and add filter ( on ) ; } }
public synchronize db exception recompile ( session session , boolean force ) { try { compile view query ( session , query s q l ) ; } catch ( db exception e ) { if ( ! force ) { return e ; } } array list < table view > view = get view ( ) ; if ( view ! = null ) { view = new . array list ( view ) ; } synchronize verifier . check ( index cache ) ; index cache . clear ( ) ; init column and table ( session ) ; if ( view ! = null ) { for ( table view v : view ) { db exception e = v . recompile ( session , force ) ; if ( e ! = null & & ! force ) { return e ; } } } return force ? null : create exception ; }
public static void execute ( string url , string user , string password , string file name , charset charset , boolean continue on error ) throw s q l exception { new run script ( ) . process ( url , user , password , file name , charset , continue on error ) ; }
public string get row separator write ( ) { return row separator write ; }
public string get row separator write ( ) { return row separator write ; }
public void set field delimiter ( char field delimiter ) { this . field delimiter = field delimiter ; }
public string get row separator write ( ) { return row separator write ; }
public void set write column header ( boolean value ) { this . write column header = value ; }
protect static int get max depth ( int x ) { if ( x < = 0 ) throw new illegal argument exception ( `` undefined for `` + x ) ; return ( 32 - integer . number of lead zero ( x - 1 ) ) < < 2 ; }
public static long get prefix ( byte [ ] bytes ) { if ( bytes == null ) { return 0l ; } else { final int min len = math . min ( byte . length , 8 ) ; long p = 0 ; for ( int i = 0 ; i < min len ; ++i ) { p |= ( 128l + platform . get byte ( byte , platform . byte_array_offset + i ) ) < < ( 56 - 8 * i ) ; } return p ; } }
public static server create web server ( string . . . args ) throw s q l exception { web server service = new web server ( ) ; server server = new server ( service , args ) ; service . set shutdown handler ( server ) ; return server ; }
public static server create web server ( string . . . args ) throw s q l exception { web server service = new web server ( ) ; server server = new server ( service , args ) ; service . set shutdown handler ( server ) ; return server ; }
public string get status ( ) { string builder buff = new string builder ( ) ; if ( ! start ) { buff . append ( `` not start `` ) ; } else if ( be run ( false ) ) { buff . append ( service . get type ( ) ) . append ( `` server run at `` ) . append ( service . get u r l ( ) ) . append ( `` ( `` ) ; if ( service . get allow others ( ) ) { buff . append ( `` others can connect `` ) ; } else { buff . append ( `` only local connection `` ) ; } buff . append ( ' ) ' ) ; } else { buff . append ( `` the `` ) . append ( service . get type ( ) ) . append ( `` server could not be start . possible cause : another server be already run at `` ) . append ( service . get u r l ( ) ) ; } return buff . to string ( ) ; }
public void set byte ( int i , int x ) { int addr = i > > address_bits ; check capacity ( addr ) ; data [ addr ] |= ( ( long ) x ) < < ( i & ( 7 < < 3 ) ) ; if ( max length < i & & x ! = 0 ) { max length = i + 7 ; } }
public static value date convert date ( date x , calendar calendar ) { if ( calendar == null ) { throw db exception . get invalid value exception ( `` calendar `` , null ) ; } calendar cal = ( calendar ) calendar . clone ( ) ; cal . set time in millis ( x . get time ( ) ) ; long date value = date value from calendar ( cal ) ; return value date . from date value ( date value ) ; }
public static timestamp convert date value to timestamp ( long date value , long nanos ) { long millis = nanos / 1000000 ; nanos -= millis * 1000000 ; long s = millis / 1000 ; millis -= s * 1000 ; long m = s / 60 ; s -= m * 60 ; long h = m / 60 ; m -= h * 60 ; long m = get millis ( time zone . get default ( ) , year from date value ( date value ) , month from date value ( date value ) , day from date value ( date value ) , ( int ) h , ( int ) m , ( int ) s , 0 ) ; timestamp ts = new timestamp ( m ) ; t . set nanos ( ( int ) ( nanos + millis * 1000000 ) ) ; return t ; }
public static int get iso year ( java . util . date date ) { calendar cal = calendar . get instance ( ) ; cal . set time in millis ( date . get time ( ) ) ; cal . set first day of week ( calendar . monday ) ; cal . set minimal day in first week ( 4 ) ; int year = get year ( cal ) ; int month = cal . get ( calendar . month ) ; int week = cal . get ( calendar . week_of_year ) ; if ( month == 0 & & week > 51 ) { year -- ; } else if ( month == 11 & & week == 1 ) { year++ ; } return year ; }
public static string format ( long millis , string pattern , time zone time zone , locale locale ) { return format ( new date ( millis ) , pattern , time zone , locale ) ; }
public static long get epoch second ( long date value , long time nanos , int offset second ) { return absolute day from date value ( date value ) * seconds_per_day + time nanos / nanos_per_second - offset second ; }
public static int round up to near multiple of power of two ( int number to round , int a power of two ) { return ( ( number to round + a power of two - 1 ) & ~ ( a power of two - 1 ) ) ; }
public static long secure random long ( ) { secure random sr = get secure random ( ) ; synchronize ( sr ) { return sr . next long ( ) ; } }
public static < e > set < e > new identity hash set ( ) { return collection . new set from map ( new identity hash map < e , boolean > ( ) ) ; }
protect void read all row ( ) { for ( int i = 0 ; i < entry count ; i++ ) { search row row = row [ i ] ; if ( row == null ) { row = index . read row ( data , offset [ i ] , only position , false ) ; row [ i ] = row ; } } }
public boolean be inside remark ( ) { return inside remark ; }
public void append except first ( string s ) { if ( index++ > 0 ) { builder . append ( s ) ; } }
public void append except first ( string s ) { if ( index++ > 0 ) { builder . append ( s ) ; } }
public void set property ( file property file ) { if ( ! property file . exists ( ) ) { throw new build exception ( `` property file : `` + property file + `` do not exist . `` ) ; } log ( `` use property file `` + property file , project . msg_debug ) ; this . property file = property file ; }
public static void write long ( byte [ ] buff , int po , long x ) { write int ( buff , po , ( int ) ( x > > 32 ) ) ; write int ( buff , po + 4 , ( int ) x ) ; }
public static int compare not null ( char [ ] data1 , char [ ] data2 ) { if ( data1 == data2 ) { return 0 ; } int len = math . min ( data1 . length , data2 . length ) ; for ( int i = 0 ; i < len ; i++ ) { char b = data1 [ i ] ; char b2 = data2 [ i ] ; if ( b ! = b2 ) { return b > b2 ? 1 : -1 ; } } return integer . signum ( data1 . length - data2 . length ) ; }
public static class < ? > class for name or null ( final string class name ) { try { return class . for name ( class name ) ; } catch ( final reflective operation exception | linkage error e ) { return null ; } }
public boolean get boolean value ( string name , boolean default value ) { string result = property . get ( name ) ; if ( result == null ) { return default value ; } return utils . parse boolean ( result , default value , true ) ; }
public v put ( k key , v value ) { process queue ( ) ; soft value < v > old = map . put ( key , new soft value < v > ( value , queue , key ) ) ; return old == null ? null : old . get ( ) ; }
public int compare type save ( value a , value b ) { if ( a == b ) { return 0 ; } int data type = value . get high order ( a . get type ( ) , b . get type ( ) ) ; a = a . convert to ( data type ) ; b = b . convert to ( data type ) ; return a . compare type save ( b , compare mode ) ; }
public static void remove all for table ( data handler handler , int table id ) { string dir = value lob . get file name prefix ( handler . get database path ( ) , 0 ) ; remove all for table ( handler , dir , table id ) ; }
public void convert to file if require ( data handler h ) { try { if ( small ! = null & & small . length > h . get max length inplace lob ( ) ) { boolean compress = h . get lob compression algorithm ( type ) ! = null ; int len = get buffer size ( h , compress , long . max_value ) ; int tab id = table id ; if ( type == value . blob ) { create from stream ( data utils . new byte ( len ) , 0 , get input stream ( ) , long . max_value , h ) ; } else { create from reader ( new char [ len ] , 0 , get reader ( ) , long . max_value , h ) ; } value v2 = link ( h , tab id ) ; if ( sys property . check & & v2 ! = this ) { db exception . throw internal error ( ) ; } } } catch ( i o exception e ) { throw db exception . convert i o exception ( e , null ) ; } }
public string get file name ( ) { return file name ; }
public static value date from date value ( long date value ) { return ( value date ) value . cache ( new value date ( date value ) ) ; }
public static < e > matcher < e [ ] > array with size ( matcher < ? super integer > size matcher ) { return new be array with size < > ( size matcher ) ; }
public static < e > matcher < e [ ] > array containing ( e . . . item ) { return array contain ( a equal matcher ( item ) ) ; }
protect string empty element tag closer ( string display name , int name code ) { return `` / > `` ; }
public static < t > matcher < t [ ] > have item in array ( matcher < ? super t > element matcher ) { return new have item in array < > ( element matcher ) ; }
public static matcher < object > null value ( ) { return new be null < object > ( ) ; }
public static < t > matcher < t > not ( matcher < t > matcher ) { return new be not < t > ( matcher ) ; }
public static < t > matcher < t > not ( matcher < t > matcher ) { return new be not < t > ( matcher ) ; }
public boolean match ( char [ ] target ) { return this . match ( target , 0 , target . length , ( match ) null ) ; }
public static byte [ ] decode line ( string s ) { char [ ] buf = new char [ s . length ( ) ] ; int p = 0 ; for ( int ip = 0 ; ip < s . length ( ) ; ip++ ) { char c = s . char at ( ip ) ; if ( c ! = ' ' & & c ! = '\r ' & & c ! = '\n ' & & c ! = '\t ' ) buf [ p++ ] = c ; } return decode ( buf , 0 , p ) ; }
public string get collection ( ) { return collection ; }
public void set jar ( string value ) { this . jar = value ; }
public void set cascade ( string value ) { this . cascade = value ; }
public void set meta type ( string value ) { this . meta type = value ; }
public void set meta type ( string value ) { this . meta type = value ; }
public boolean be update ( ) { if ( update == null ) { return true ; } else { return update ; } }
public list < jaxb hbm synchronize type > get synchronize ( ) { if ( synchronize == null ) { synchronize = new array list < jaxb hbm synchronize type > ( ) ; } return this . synchronize ; }
public void set element class ( string value ) { this . element class = value ; }
public void set query ref ( string value ) { this . query ref = value ; }
public void set collection type ( string value ) { this . collection type = value ; }
public void set embed xml ( boolean value ) { this . embed xml = value ; }
public list < jaxb hbm filter type > get filter ( ) { if ( filter == null ) { filter = new array list < jaxb hbm filter type > ( ) ; } return this . filter ; }
public void set collection type ( string value ) { this . collection type = value ; }
public string get catalog ( ) { return catalog ; }
public string get subselect ( ) { return subselect ; }
public void set column attribute ( string value ) { this . column attribute = value ; }
public void set type attribute ( string value ) { this . type attribute = value ; }
public void set unique key ( string value ) { this . unique key = value ; }
public jaxb hbm collection id type get collection id ( ) { return collection id ; }
public boolean be abstract ( ) { return _abstract ; }
public void set dynamic insert ( boolean value ) { this . dynamic insert = value ; }
public boolean be dynamic insert ( ) { if ( dynamic insert == null ) { return false ; } else { return dynamic insert ; } }
public string get discriminator value ( ) { return discriminator value ; }
public void set discriminator value ( string value ) { this . discriminator value = value ; }
public list < serializable > get content ( ) { if ( content == null ) { content = new array list < serializable > ( ) ; } return this . content ; }
public string get parameter value type name ( ) { return parameter value type name ; }
public list < jaxb hbm type definition type > get typedef ( ) { if ( typedef == null ) { typedef = new array list < jaxb hbm type definition type > ( ) ; } return this . typedef ; }
public boolean be auto import ( ) { if ( auto import == null ) { return true ; } else { return auto import ; } }
public list < jaxb hbm type definition type > get typedef ( ) { if ( typedef == null ) { typedef = new array list < jaxb hbm type definition type > ( ) ; } return this . typedef ; }
public boolean be auto import ( ) { if ( auto import == null ) { return true ; } else { return auto import ; } }
public void set query ref ( string value ) { this . query ref = value ; }
public jaxb hbm index many to many type get index many to many ( ) { return index many to many ; }
public void set cache region ( string value ) { this . cache region = value ; }
public boolean be read only ( ) { if ( read only == null ) { return false ; } else { return read only ; } }
public integer get fetch size ( ) { return fetch size ; }
public cache mode get cache mode ( ) { return cache mode ; }
public jaxb hbm timestamp attribute type get timestamp ( ) { return timestamp ; }
public jaxb hbm multi tenancy type get multi tenancy ( ) { return multi tenancy ; }
public list < jaxb hbm tuplizer type > get tuplizer ( ) { if ( tuplizer == null ) { tuplizer = new array list < jaxb hbm tuplizer type > ( ) ; } return this . tuplizer ; }
public list < jaxb hbm tuplizer type > get tuplizer ( ) { if ( tuplizer == null ) { tuplizer = new array list < jaxb hbm tuplizer type > ( ) ; } return this . tuplizer ; }
public metadata source add cacheable file ( file file ) { final origin origin = new origin ( source type . file , file . get name ( ) ) ; add cacheable file ( origin , file ) ; return this ; }
public metadata source add annotated class ( class annotate class ) { if ( annotated class == null ) { annotated class = new link hash set < > ( ) ; } annotate class . add ( annotated class ) ; return this ; }
public boolean can be name ( ) { return can be name ; }
public static attribute type descriptor resolve ( ct class manage ct class , ct field persistent field ) throw not find exception { boolean inherit = ! manage ct class . equal ( persistent field . get declare class ( ) ) ; boolean visible = persistent field . visible from ( manage ct class ) ; string reader name = enhancer constant . persistent_field_reader_prefix + persistent field . get name ( ) ; string writer name = enhancer constant . persistent_field_writer_prefix + persistent field . get name ( ) ; inheritance metadata inheritance metadata = new inheritance metadata ( inherit , visible , reader name , writer name ) ; if ( ct class . boolean type . equal ( persistent field . get type ( ) ) ) { return new primitive attribute type descriptor ( inheritance metadata , boolean . type ) ; } else if ( ct class . byte type . equal ( persistent field . get type ( ) ) ) { return new primitive attribute type descriptor ( inheritance metadata , byte . type ) ; } else if ( ct class . char type . equal ( persistent field . get type ( ) ) ) { return new primitive attribute type descriptor ( inheritance metadata , character . type ) ; } else if ( ct class . short type . equal ( persistent field . get type ( ) ) ) { return new primitive attribute type descriptor ( inheritance metadata , short . type ) ; } else if ( ct class . int type . equal ( persistent field . get type ( ) ) ) { return new primitive attribute type descriptor ( inheritance metadata , integer . type ) ; } else if ( ct class . long type . equal ( persistent field . get type ( ) ) ) { return new primitive attribute type descriptor ( inheritance metadata , long . type ) ; } else if ( ct class . double type . equal ( persistent field . get type ( ) ) ) { return new primitive attribute type descriptor ( inheritance metadata , double . type ) ; } else if ( ct class . float type . equal ( persistent field . get type ( ) ) ) { return new primitive attribute type descriptor ( inheritance metadata , float . type ) ; } else { return new object attribute type descriptor ( inheritance metadata , persistent field . get type ( ) ) ; } }
public int get lazy index ( ) { return lazy index ; }
public object new instance ( ) throw invocation target exception { return this . new instance ( this . get index ( empty_class_array ) , null ) ; }
protect void set current property ( x property property ) { if ( property == null ) { this . current property column override = null ; this . current property join column override = null ; this . current property join table override = null ; this . current property foreign key override = null ; } else { this . current property column override = build column override ( property , get path ( ) ) ; if ( this . current property column override . size ( ) == 0 ) { this . current property column override = null ; } this . current property join column override = build join column override ( property , get path ( ) ) ; if ( this . current property join column override . size ( ) == 0 ) { this . current property join column override = null ; } this . current property join table override = build join table override ( property , get path ( ) ) ; if ( this . current property join table override . size ( ) == 0 ) { this . current property join table override = null ; } this . current property foreign key override = build foreign key override ( property , get path ( ) ) ; if ( this . current property foreign key override . size ( ) == 0 ) { this . current property foreign key override = null ; } } }
public configuration add jar ( file jar ) throw map exception { metadata source . add jar ( jar ) ; return this ; }
public entity not find delegate get entity not find delegate ( ) { return entity not find delegate ; }
protect boolean add condition ( string builder buffer , string on ) { if ( string helper . be not empty ( on ) ) { if ( ! on . start with ( `` and `` ) ) { buffer . append ( `` and `` ) ; } buffer . append ( on ) ; return true ; } else { return false ; } }
public property get property ( ) { return property ; }
protect final void read ( ) { initialize ( false ) ; }
protect final serializable get snapshot ( ) { return session . get persistence context ( ) . get snapshot ( this ) ; }
public boolean equal ( object object ) { if ( object == this ) { return true ; } if ( object instanceof bag == false ) { return false ; } bag other = ( bag ) object ; if ( other . size ( ) ! = size ( ) ) { return false ; } for ( iterator it = map . key set ( ) . iterator ( ) ; it . have next ( ) ; ) { object element = it . next ( ) ; if ( other . get count ( element ) ! = get count ( element ) ) { return false ; } } return true ; }
public static session unbind ( session factory factory ) { final map < session factory , session > session map = session map ( ) ; session exist = null ; if ( session map ! = null ) { exist = session map . remove ( factory ) ; do cleanup ( ) ; } return exist ; }
public static session unbind ( session factory factory ) { final map < session factory , session > session map = session map ( ) ; session exist = null ; if ( session map ! = null ) { exist = session map . remove ( factory ) ; do cleanup ( ) ; } return exist ; }
public detach criterion add ( criterion criterion ) { criterion . add ( criterion ) ; return this ; }
public detach criterion add ( criterion criterion ) { criterion . add ( criterion ) ; return this ; }
public detach criterion add ( criterion criterion ) { criterion . add ( criterion ) ; return this ; }
public detach criterion create criterion ( string association path , string alias ) { return new detach criterion ( impl , criterion . create criterion ( association path , alias ) ) ; }
public property projection group ( ) { return projection . group property ( get property name ( ) ) ; }
public simple expression gt ( object value ) { return restriction . gt ( get property name ( ) , value ) ; }
public static criterion be empty ( string property name ) { return new empty expression ( property name ) ; }
public static logical expression or ( criterion lh , criterion rh ) { return new logical expression ( lhs , rhs , `` or `` ) ; }
public static criterion eq or be null ( string property name , object value ) { return value == null ? be null ( property name ) : eq ( property name , value ) ; }
public static projection sql projection ( string sql , string [ ] column alias , type [ ] type ) { return new s q l projection ( sql , column alias , type ) ; }
public static conjunction and ( criterion . . . predicate ) { return conjunction ( predicate ) ; }
public order ignore case ( ) { ignore case = true ; return this ; }
public static criterion property eq all ( string property name , detach criterion dc ) { return new property subquery expression ( property name , `` = `` , `` all `` , dc ) ; }
public static criterion property ne ( string property name , detach criterion dc ) { return new property subquery expression ( property name , `` < > `` , null , dc ) ; }
public static criterion property ge all ( string property name , detach criterion dc ) { return new property subquery expression ( property name , `` > = `` , `` all `` , dc ) ; }
public static criterion ne ( object value , detach criterion dc ) { return new simple subquery expression ( value , `` < > `` , null , dc ) ; }
public static multi device iterator create ( scope scope , list < string > device , string share name , string container , list < class < ? > > output type , list < shape > output shape ) { operation builder op builder = scope . graph ( ) . op builder ( `` multi device iterator `` , scope . make op name ( `` multi device iterator `` ) ) ; string [ ] device array = new string [ device . size ( ) ] ; for ( int i = 0 ; i < device array . length ; ++i ) { device array [ i ] = device . get ( i ) ; } op builder . set attr ( `` device `` , device array ) ; op builder . set attr ( `` shared_name `` , share name ) ; op builder . set attr ( `` container `` , container ) ; data type [ ] output type array = new data type [ output type . size ( ) ] ; for ( int i = 0 ; i < output type array . length ; ++i ) { output type array [ i ] = data type . from class ( output type . get ( i ) ) ; } op builder . set attr ( `` output_types `` , output type array ) ; shape [ ] output shape array = new shape [ output shape . size ( ) ] ; for ( int i = 0 ; i < output shape array . length ; ++i ) { output shape array [ i ] = output shape . get ( i ) ; } op builder . set attr ( `` output_shapes `` , output shape array ) ; return new multi device iterator ( op builder . build ( ) ) ; }
public boolean get curly brace denote code block ( int language index ) { return true ; }
protect double get domain low bound ( double p ) { return 0 ; }
public void write ( int offset , int value ) { super . write ( offset , value ) ; }
public optional double double value ( @ non null string member ) { return double value ( member , value mapper ) ; }
public int determine jdbc type code for java class ( class cl ) { integer type code = java class to jdbc type code map . get ( cl ) ; if ( type code ! = null ) { return type code ; } int special code = cl . hash code ( ) ; log . debug ( `` jdbc type code map not know for class [ `` + cl . get name ( ) + `` ] ; use custom code [ `` + special code + `` ] `` ) ; return special code ; }
public void put ( int type code , string value ) { default . put ( type code , value ) ; }
public boolean cache natural id cross reference ( entity persister persister , serializable pk , object [ ] natural id value ) { validate natural id ( persister , natural id value ) ; natural id resolution cache entity natural id resolution cache = natural id resolution cache map . get ( persister ) ; if ( entity natural id resolution cache == null ) { entity natural id resolution cache = new natural id resolution cache ( persister ) ; natural id resolution cache previous instance = natural id resolution cache map . put if absent ( persister , entity natural id resolution cache ) ; if ( previous instance ! = null ) { entity natural id resolution cache = previous instance ; } } return entity natural id resolution cache . cache ( pk , natural id value ) ; }
public boolean cache natural id cross reference ( entity persister persister , serializable pk , object [ ] natural id value ) { validate natural id ( persister , natural id value ) ; natural id resolution cache entity natural id resolution cache = natural id resolution cache map . get ( persister ) ; if ( entity natural id resolution cache == null ) { entity natural id resolution cache = new natural id resolution cache ( persister ) ; natural id resolution cache previous instance = natural id resolution cache map . put if absent ( persister , entity natural id resolution cache ) ; if ( previous instance ! = null ) { entity natural id resolution cache = previous instance ; } } return entity natural id resolution cache . cache ( pk , natural id value ) ; }
public boolean cache natural id cross reference ( entity persister persister , serializable pk , object [ ] natural id value ) { validate natural id ( persister , natural id value ) ; natural id resolution cache entity natural id resolution cache = natural id resolution cache map . get ( persister ) ; if ( entity natural id resolution cache == null ) { entity natural id resolution cache = new natural id resolution cache ( persister ) ; natural id resolution cache previous instance = natural id resolution cache map . put if absent ( persister , entity natural id resolution cache ) ; if ( previous instance ! = null ) { entity natural id resolution cache = previous instance ; } } return entity natural id resolution cache . cache ( pk , natural id value ) ; }
public iterable < string > get non nullable transient property path ( final object entity ) { if ( property path by transient entity == null ) { return collection . empty list ( ) ; } else { return property path by transient entity . get ( entity ) ; } }
public iterable < string > get non nullable transient property path ( final object entity ) { if ( property path by transient entity == null ) { return collection . empty list ( ) ; } else { return property path by transient entity . get ( entity ) ; } }
public void on initialize collection ( initialize collection event event ) throw hibernate exception { persistent collection collection = event . get collection ( ) ; session implementor source = event . get session ( ) ; collection entry ce = source . get persistence context internal ( ) . get collection entry ( collection ) ; if ( ce == null ) { throw new hibernate exception ( `` collection be evict `` ) ; } if ( ! collection . be initialize ( ) ) { final collection persister ce load persister = ce . get loaded persister ( ) ; if ( log . be trace enable ( ) ) { log . tracev ( `` initialize collection { 0 } `` , message helper . collection info string ( ce load persister , collection , ce . get loaded key ( ) , source ) ) ; log . trace ( `` check second-level cache `` ) ; } final boolean find in cache = initialize collection from cache ( ce . get loaded key ( ) , ce load persister , collection , source ) ; if ( find in cache ) { if ( log . be trace enable ( ) ) { log . trace ( `` collection initialize from cache `` ) ; } } else { if ( log . be trace enable ( ) ) { log . trace ( `` collection not cache `` ) ; } ce load persister . initialize ( ce . get loaded key ( ) , source ) ; if ( log . be trace enable ( ) ) { log . trace ( `` collection initialized `` ) ; } final statistic implementor statistic = source . get factory ( ) . get statistic ( ) ; if ( statistic . be statistic enabled ( ) ) { statistic . fetch collection ( ce load persister . get role ( ) ) ; } } } }
public property get connection property ( ) { basic connection creator connection creator = ( basic connection creator ) this . state . pool . connection creator ; return connection creator . get connection property ( ) ; }
public string to string ( ) { string builder sb = new string builder ( get class ( ) . get name ( ) ) ; sb . append ( `` : `` ) . append ( this . interface . size ( ) ) . append ( `` interface `` ) ; sb . append ( class utils . class name to string ( this . interface ) ) . append ( `` ; `` ) ; sb . append ( this . advisor . size ( ) ) . append ( `` advisor `` ) ; sb . append ( this . advisor ) . append ( `` ; `` ) ; sb . append ( `` target source [ `` ) . append ( this . target source ) . append ( `` ] ; `` ) ; sb . append ( super . to string ( ) ) ; return sb . to string ( ) ; }
public void maybe configure ( ) throw build exception { if ( real thing ! = null ) { return ; } configure ( make object ( this , get wrapper ( ) ) ) ; }
protect void handle output ( string output ) { if ( real thing instanceof task ) { ( ( task ) real thing ) . handle output ( output ) ; } else { super . handle output ( output ) ; } }
public void add batch loadable entity key ( entity key key ) { if ( key . be batch loadable ( ) ) { if ( batch loadable entity key == null ) { batch loadable entity key = new hash map < > ( 12 ) ; } final link hash set < entity key > key for entity = batch loadable entity key . compute if absent ( key . get entity name ( ) , k - > new link hash set < > ( 8 ) ) ; key for entity . add ( key ) ; } }
public entity persister get entity descriptor ( string entity name ) { final entity persister entity persister = entity persister map . get ( entity name ) ; if ( entity persister == null ) { throw new illegal argument exception ( `` unable to locate persister : `` + entity name ) ; } return entity persister ; }
public void on initialize collection ( initialize collection event event ) throw hibernate exception { persistent collection collection = event . get collection ( ) ; session implementor source = event . get session ( ) ; collection entry ce = source . get persistence context internal ( ) . get collection entry ( collection ) ; if ( ce == null ) { throw new hibernate exception ( `` collection be evict `` ) ; } if ( ! collection . be initialize ( ) ) { final collection persister ce load persister = ce . get loaded persister ( ) ; if ( log . be trace enable ( ) ) { log . tracev ( `` initialize collection { 0 } `` , message helper . collection info string ( ce load persister , collection , ce . get loaded key ( ) , source ) ) ; log . trace ( `` check second-level cache `` ) ; } final boolean find in cache = initialize collection from cache ( ce . get loaded key ( ) , ce load persister , collection , source ) ; if ( find in cache ) { if ( log . be trace enable ( ) ) { log . trace ( `` collection initialize from cache `` ) ; } } else { if ( log . be trace enable ( ) ) { log . trace ( `` collection not cache `` ) ; } ce load persister . initialize ( ce . get loaded key ( ) , source ) ; if ( log . be trace enable ( ) ) { log . trace ( `` collection initialized `` ) ; } final statistic implementor statistic = source . get factory ( ) . get statistic ( ) ; if ( statistic . be statistic enabled ( ) ) { statistic . fetch collection ( ce load persister . get role ( ) ) ; } } } }
public object get ( object merge entity ) { if ( merge entity == null ) { throw new null pointer exception ( `` null entity be not support by `` + get class ( ) . get name ( ) ) ; } return merge to manage entity xref . get ( merge entity ) ; }
public object get ( object merge entity ) { if ( merge entity == null ) { throw new null pointer exception ( `` null entity be not support by `` + get class ( ) . get name ( ) ) ; } return merge to manage entity xref . get ( merge entity ) ; }
public void put all ( map t ) { iterator iter = t . entry set ( ) . iterator ( ) ; while ( iter . have next ( ) ) { map . entry entry = ( map . entry ) iter . next ( ) ; put ( entry . get key ( ) , entry . get value ( ) ) ; } }
protect string [ ] get sql statement ( ) { error if select ( ) ; return statement executor . get sql statement ( ) ; }
public void validate ( ) throw query exception { get into clause ( ) . validate type ( get select clause ( ) ) ; }
public list get projection list ( ) { return a s t util . collect child ( this , projection list predicate ) ; }
public ast next node ( ) { ast current = next ; if ( next ! = null ) { ast next sibling = next . get next sibling ( ) ; if ( next sibling == null ) { next = pop ( ) ; } else { next = next sibling ; down ( ) ; } } return current ; }
public ast next node ( ) { ast current = next ; if ( next ! = null ) { ast next sibling = next . get next sibling ( ) ; if ( next sibling == null ) { next = pop ( ) ; } else { next = next sibling ; down ( ) ; } } return current ; }
public session factory implementor get factory ( ) { return sfi ; }
public string get import class name ( string class name ) { return sfi . get metamodel ( ) . get imported class name ( class name ) ; }
public session factory implementor get factory ( ) { return sfi ; }
public type get identifier type ( ) { return identifier type ; }
protect short get count ( ) { synchronize ( abstract u u i d generator . class ) { if ( counter < 0 ) { counter=0 ; } return counter++ ; } }
public object immediate load ( string entity name , serializable id ) throw hibernate exception { if ( log . be debug enable ( ) ) { entity persister persister = get factory ( ) . get metamodel ( ) . entity persister ( entity name ) ; log . debugf ( `` initialize proxy : % s `` , message helper . info string ( persister , id , get factory ( ) ) ) ; } load event event = load event ; load event = null ; event = recycle event instance ( event , id , entity name ) ; fire load ( event , load event listener . immediate_load ) ; object result = event . get result ( ) ; if ( load event == null ) { event . set entity class name ( null ) ; event . set entity id ( null ) ; event . set instance to load ( null ) ; event . set result ( null ) ; load event = event ; } return result ; }
public type get parameter type ( string parameter name ) { return parameter type . get ( parameter name ) ; }
protect string pop or null ( stack < string > stack ) { if ( stack ! = null & & ! stack . be empty ( ) ) { return stack . pop ( ) ; } else { return null ; } }
public static string collapse qualifier ( string qualifier , boolean include dot ) { string tokenizer tokenizer = new string tokenizer ( qualifier , `` . `` ) ; string collapse = character . to string ( tokenizer . next token ( ) . char at ( 0 ) ) ; while ( tokenizer . have more token ( ) ) { if ( include dot ) { collapsed += ' . ' ; } collapse += tokenizer . next token ( ) . char at ( 0 ) ; } return collapse ; }
public static string extract sql state ( s q l exception sql exception ) { string sql state = sql exception . get s q l state ( ) ; s q l exception nest = sql exception . get next exception ( ) ; while ( sql state == null & & nested ! = null ) { sql state = nest . get s q l state ( ) ; nest = nest . get next exception ( ) ; } return sql state ; }
public static location location to sync ( location current , location next ) { / * here we be move forward in the translog with each operation . under the hood this might * cross translog file which be ok since from the user perspective the translog be like a * tape where only the high location need to be fsynced in order to sync all previous * location even though they be not in the same file . when the translog roll over file * the previous file be fsynced on after close if need . * / assert next ! = null : `` next operation ca n't be null `` ; assert current == null || current . compare to ( next ) < 0 : `` translog location be not increase `` ; return next ; }
public static constructor get constructor ( class clazz , type [ ] type ) throw property not find exception { final constructor [ ] candidate = clazz . get constructor ( ) ; constructor constructor = null ; int number of match constructor = 0 ; for ( final constructor candidate : candidate ) { final class [ ] params = candidate . get parameter type ( ) ; if ( params . length == type . length ) { boolean find = true ; for ( int j = 0 ; j < params . length ; j++ ) { final boolean ok = type [ j ] == null || params [ j ] . be assignable from ( type [ j ] . get returned class ( ) ) || ( type [ j ] instanceof primitive type & & params [ j ] == ( ( primitive type ) type [ j ] ) . get primitive class ( ) ) ; if ( ! ok ) { find = false ; break ; } } if ( find ) { number of match constructor ++ ; ensure accessibility ( candidate ) ; constructor = candidate ; } } } if ( number of match constructor == 1 ) { return constructor ; } throw new property not find exception ( `` no appropriate constructor in class : `` + clazz . get name ( ) ) ; }
protect void handle ( runnable runnable ) { class loader old class loader = thread . current thread ( ) . get context class loader ( ) ; try { thread . current thread ( ) . set context class loader ( class loader ) ; runnable . run ( ) ; } finally { thread . current thread ( ) . set context class loader ( old class loader ) ; } }
public static boolean be context relative path ( string filename ) { if ( ! ( on do || on net ware ) || filename . length ( ) == 0 ) { return false ; } char sep = file . separator char ; filename = filename . replace ( '/ ' , sep ) . replace ( '\\ ' , sep ) ; char c = filename . char at ( 0 ) ; int len = filename . length ( ) ; return ( c == sep & & ( len == 1 || filename . char at ( 1 ) ! = sep ) ) || ( character . be letter ( c ) & & len > 1 & & filename . index of ( ' : ' ) == 1 & & ( len == 2 || filename . char at ( 2 ) ! = sep ) ) ; }
public string [ ] get suffixed key alias ( ) { return key alias ; }
protect final object resolve identifier ( serializable id , share session contract implementor session , boolean override eager ) throw hibernate exception { boolean be proxy unwrap enable = unwrap proxy & & get associate entity persister ( session . get factory ( ) ) . be instrumented ( ) ; object proxy or entity = session . internal load ( get associate entity name ( ) , id , be eager ( override eager ) , be nullable ( ) ) ; if ( proxy or entity instanceof hibernate proxy ) { ( ( hibernate proxy ) proxy or entity ) . get hibernate lazy initializer ( ) . set unwrap ( be proxy unwrap enable ) ; } return proxy or entity ; }
public string map path ( string path ) { return null ; }
protect double get domain low bound ( double p ) { return 0 ; }
public lock mode get lock mode ( ) { return lock option . get lock mode ( ) ; }
public int get alias lock count ( ) { if ( alias specific lock mode == null ) { return 0 ; } return alias specific lock mode . size ( ) ; }
public lock option set follow on locking ( boolean follow on lock ) { this . follow on lock = follow on locking ; return this ; }
public lock option set scope ( boolean scope ) { this . scope = scope ; return this ; }
public select set lock option ( lock option lock option ) { lock option . copy ( lock option , this . lock option ) ; return this ; }
public link hash set < fetch > get fetch ( ) { return fetch ; }
public void align column ( ) { if ( be reference to primary key ( ) ) { align column ( reference table ) ; } }
public key value get identifier ( ) { return identifier ; }
public boolean be property define in hierarchy ( string name ) { if ( have property ( name ) ) { return true ; } if ( get super map superclass ( ) ! = null & & get super map superclass ( ) . be property define in hierarchy ( name ) ) { return true ; } if ( get super persistent class ( ) ! = null & & get super persistent class ( ) . be property define in hierarchy ( name ) ) { return true ; } return false ; }
public iterator get referenceable property iterator ( ) { return get property closure iterator ( ) ; }
protect string generate delete string ( ) { final delete delete = create delete ( ) . set table name ( qualify table name ) . add primary key column ( key column name ) ; if ( have where ) { delete . set where ( sql where string ) ; } if ( get factory ( ) . get session factory option ( ) . be comment enable ( ) ) { delete . set comment ( `` delete collection `` + get role ( ) ) ; } return delete . to statement string ( ) ; }
protect string generate delete string ( ) { final update update = create update ( ) . set table name ( qualify table name ) . add column ( key column name , `` null `` ) ; if ( have index & & ! index contain formula ) { for ( int i = 0 ; i < index column name . length ; i++ ) { if ( index column be settable [ i ] ) { update . add column ( index column name [ i ] , `` null `` ) ; } } } update . add primary key column ( key column name ) ; if ( have where ) { update . set where ( sql where string ) ; } if ( get factory ( ) . get session factory option ( ) . be comment enable ( ) ) { update . set comment ( `` delete one-to-many `` + get role ( ) ) ; } return update . to statement string ( ) ; }
protect map get loader ( ) { return loader ; }
public static string collection info string ( string role , serializable id ) { string builder s = new string builder ( ) ; s . append ( ' [ ' ) ; if ( role == null ) { s . append ( `` < unreferenced > `` ) ; } else { s . append ( role ) ; s . append ( ' # ' ) ; if ( id == null ) { s . append ( `` < null > `` ) ; } else { s . append ( id ) ; } } s . append ( ' ] ' ) ; return s . to string ( ) ; }
public final void initialize without load if possible ( ) { if ( ! initialize & & session ! = null & & session . be open or wait for auto close ( ) ) { final entity key key = session . generate entity key ( get identifier ( ) , session . get factory ( ) . get metamodel ( ) . entity persister ( get entity name ( ) ) ) ; final object entity = session . get persistence context internal ( ) . get entity ( key ) ; if ( entity ! = null ) { set implementation ( entity ) ; } } }
protect void set alias ( string alias ) { this . alias = alias ; }
protect boolean apply flush mode hint ( flush mode flush mode ) { set flush mode ( flush mode ) ; return true ; }
public void set lock option ( lock option lock option ) { lock option . copy ( lock option , this . lock option ) ; }
public string [ ] get names ( ) { string [ ] names = class map . key set ( ) . to array ( new string [ 0 ] ) ; array . sort ( name ) ; return name ; }
public schema export set delimiter ( string delimiter ) { this . delimiter = delimiter ; return this ; }
public schema export set delimiter ( string delimiter ) { this . delimiter = delimiter ; return this ; }
public schema export set delimiter ( string delimiter ) { this . delimiter = delimiter ; return this ; }
public schema export set delimiter ( string delimiter ) { this . delimiter = delimiter ; return this ; }
public void set quiet ( boolean quiet ) { this . quiet = quiet ; }
public int hash code ( ) { return constructor . hash code ( ) ; }
public void register default tuplizer class ( entity mode entity mode , class < ? extend component tuplizer > tuplizer class ) { assert be component tuplizer implementor ( tuplizer class ) : `` specify tuplizer class [ `` + tuplizer class . get name ( ) + `` ] do not implement `` + component tuplizer . class . get name ( ) ; assert have proper constructor ( tuplizer class ) : `` specify tuplizer class [ `` + tuplizer class . get name ( ) + `` ] be not properly instantiatable `` ; default impl class by mode . put ( entity mode , tuplizer class ) ; }
public static input stream limit stream ( input stream in , long limit ) { return new limited input stream ( in , limit ) ; }
public boolean get curly brace denote code block ( int language index ) { return true ; }
public static string get version ( ) { return version ; }
public void add contract type ( type add me ) { try { w lock . lock ( ) ; if ( add me == null ) { return ; } advertise contract . add ( add me ) ; class < ? > raw class = reflection helper . get raw class ( add me ) ; if ( raw class == null ) { return ; } add advertised contract ( raw class . get name ( ) ) ; } finally { w lock . unlock ( ) ; } }
public void add qualifier annotation ( annotation add me ) { try { w lock . lock ( ) ; if ( add me == null ) return ; if ( qualifier == null ) qualifier = new link hash set < annotation > ( ) ; qualifier . add ( add me ) ; add qualifier ( add me . annotation type ( ) . get name ( ) ) ; } finally { w lock . unlock ( ) ; } }
public static indexed filter create name filter ( string name ) { return new indexed filter impl ( null , name ) ; }
public void set factory id ( long locator id , long service id ) { if ( ! get descriptor type ( ) . equal ( descriptor type . provide_method ) ) { throw new illegal state exception ( `` the descriptor type must be provide_method `` ) ; } factory service id = service id ; factory locator id = locator id ; }
public static string p type ( parameterized type p type ) { string buffer sb = new string buffer ( ) ; sb . append ( clazz ( reflection helper . get raw class ( p type ) ) + `` < `` ) ; boolean first = true ; for ( type t : p type . get actual type argument ( ) ) { if ( first ) { first = false ; sb . append ( type ( t ) ) ; } else { sb . append ( `` , `` + type ( t ) ) ; } } sb . append ( `` > `` ) ; return sb . to string ( ) ; }
public synchronize boolean remove all metadata ( string key ) { if ( metadata == null ) return false ; return reflection helper . remove all metadata ( metadata , key ) ; }
public synchronize boolean remove all metadata ( string key ) { if ( metadata == null ) return false ; return reflection helper . remove all metadata ( metadata , key ) ; }
public static < t > t get service ( service locator locator , string class name ) { if ( locator == null || class name == null ) throw new illegal argument exception ( ) ; active descriptor < t > ad = ( active descriptor < t > ) locator . get best descriptor ( builder helper . create contract filter ( class name ) ) ; if ( ad == null ) return null ; return locator . get service handle ( ad ) . get service ( ) ; }
public static service locator bind ( binder . . . binder ) { return bind ( default_locator_name , binder ) ; }
public static < t > active descriptor < t > add one descriptor ( service locator locator , descriptor descriptor ) { return add one descriptor ( locator , descriptor , true ) ; }
public void add throwable ( throwable th ) { if ( th == null ) return ; if ( throwables == null ) throwables = new link hash set < throwable > ( ) ; if ( th instanceof multi exception ) { throwables . add all ( ( ( multi exception ) th ) . get error ( ) ) ; } else { throwables . add ( th ) ; } }
public static void just inject ( object inject me , service locator impl locator , string strategy ) { if ( inject me == null ) throw new illegal argument exception ( ) ; collector collector = new collector ( ) ; class analyzer analyzer = get class analyzer ( locator , strategy , collector ) ; collector . throw if error ( ) ; class < ? > base class = inject me . get class ( ) ; set < field > field = utility . get init field ( base class , analyzer , collector ) ; set < method > method = utility . get init method ( base class , analyzer , collector ) ; collector . throw if error ( ) ; for ( field field : field ) { injection resolver < ? > resolver = locator . get per locator utility ( ) . get injection resolver ( locator , field ) ; list < system injectee impl > injectee field = utility . get field injectees ( base class , field , null ) ; validate self injectees ( null , injectee field , collector ) ; collector . throw if error ( ) ; injectee injectee = injectee field . get ( 0 ) ; object field value = resolver . resolve ( injectee , null ) ; try { reflection helper . set field ( field , inject me , field value ) ; } catch ( multi exception me ) { throw me ; } catch ( throwable th ) { throw new multi exception ( th ) ; } } for ( method method : method ) { list < system injectee impl > injectees = utility . get method injectees ( base class , method , null ) ; validate self injectees ( null , injectees , collector ) ; collector . throw if error ( ) ; object args [ ] = new object [ injectees . size ( ) ] ; for ( system injectee impl injectee : injectees ) { injection resolver < ? > resolver = locator . get per locator utility ( ) . get injection resolver ( locator , injectee ) ; args [ injectee . get position ( ) ] = resolver . resolve ( injectee , null ) ; } try { reflection helper . invoke ( inject me , method , args , locator . get neutral context class loader ( ) ) ; } catch ( multi exception me ) { throw me ; } catch ( throwable e ) { throw new multi exception ( e ) ; } } }
public static < t > qualifier < t > by annotation ( annotation annotation ) { if ( annotation . annotation type ( ) == type . class ) { type type ann = ( type ) annotation ; return by type ( type ann . value ( ) ) ; } else if ( annotation . annotation type ( ) == name . class ) { name name ann = ( name ) annotation ; return by name ( name ann . value ( ) ) ; } else { return new annotation qualifier < > ( annotation ) ; } }
public string get auto analyzer name ( class < ? > c ) { string ret val = thread local auto analyzer name cache . get ( ) . get ( c ) ; if ( ret val ! = null ) return ret val ; service s = c . get annotation ( service . class ) ; if ( s == null ) return null ; ret val = s . analyzer ( ) ; thread local auto analyzer name cache . get ( ) . put ( c , ret val ) ; return ret val ; }
public v get ( ) { remove stale entry ( ) ; final key key = new lookup key ( ) ; object value = local . get ( key ) ; if ( value == null ) { value = initial value ( ) ; local . put ( new storage key ( queue ) , mask null ( value ) ) ; } else { value = unmask null ( value ) ; } return ( v ) value ; }
public void remove ( ) { final key key = new lookup key ( ) ; local . remove ( key ) ; }
public synchronize boolean remove all metadata ( string key ) { if ( metadata == null ) return false ; return reflection helper . remove all metadata ( metadata , key ) ; }
public static string constructor ( constructor < ? > constructor ) { if ( constructor == null ) return null_string ; return constructor_name + pretty print parameter ( constructor . get parameter type ( ) ) ; }
public static string field ( field field ) { if ( field == null ) { return null_string ; } type t = field . get generic type ( ) ; string base string ; if ( t instanceof class ) { base string = clazz ( ( class < ? > ) t ) ; } else { base string = type ( t ) ; } return `` field ( `` + base string + `` `` + field . get name ( ) + `` in `` + field . get declare class ( ) . get name ( ) + `` ) `` ; }
public static string type ( type t ) { if ( t == null ) return null_string ; if ( t instanceof class ) { return clazz ( ( class < ? > ) t ) ; } if ( t instanceof parameterized type ) { return p type ( ( parameterized type ) t ) ; } return t . to string ( ) ; }
public static boolean verify generic type ( type generic type , jaxb type checker checker ) { if ( ! ( generic type instanceof parameterized type ) ) return false ; final parameterized type pt = ( parameterized type ) generic type ; if ( pt . get actual type argument ( ) . length > 1 ) return false ; final type ta = pt . get actual type argument ( ) [ 0 ] ; if ( ta instanceof parameterized type ) { parameterized type lpt = ( parameterized type ) ta ; return ( lpt . get raw type ( ) instanceof class ) & & j a x b element . class . be assignable from ( ( class ) lpt . get raw type ( ) ) ; } if ( ! ( pt . get actual type argument ( ) [ 0 ] instanceof class ) ) return false ; final class list class = ( class ) pt . get actual type argument ( ) [ 0 ] ; return checker . be jaxb type ( list class ) ; }
public static < t > qualifier < t > by annotation ( annotation annotation ) { if ( annotation . annotation type ( ) == type . class ) { type type ann = ( type ) annotation ; return by type ( type ann . value ( ) ) ; } else if ( annotation . annotation type ( ) == name . class ) { name name ann = ( name ) annotation ; return by name ( name ann . value ( ) ) ; } else { return new annotation qualifier < > ( annotation ) ; } }
public static writer leave shift ( writer self , object value ) throw i o exception { invoker helper . write ( self , value ) ; return self ; }
public boolean remove ( k key , v entry ) { list < v > list = store . get ( key ) ; if ( list == null ) return false ; boolean ret val = list . remove ( entry ) ; if ( list . be empty ( ) ) { store . remove ( key ) ; } return ret val ; }
public final http async client builder disable auth caching ( ) { auth cache disabled = true ; return this ; }
public final http async client builder add interceptor last ( final http response interceptor itcp ) { if ( itcp == null ) { return this ; } if ( response last == null ) { response last = new link list < http response interceptor > ( ) ; } response last . add last ( itcp ) ; return this ; }
public static void close quietly ( reader input ) { close quietly ( ( closeable ) input ) ; }
public conditionals add if none match ( tag tag ) { precondition . check argument ( ! un modify since . be present ( ) , string . format ( error_message , header constant . if_none_match , header constant . if_unmodified_since ) ) ; precondition . check argument ( match . be empty ( ) , string . format ( error_message , header constant . if_none_match , header constant . if_match ) ) ; list < tag > none match = new array list < > ( this . none match ) ; if ( tag == null ) { tag = tag . all ; } if ( tag . all . equal ( tag ) ) { none match . clear ( ) ; } if ( ! none match . contains ( tag . all ) ) { if ( ! none match . contains ( tag ) ) { none match . add ( tag ) ; } } else { throw new illegal argument exception ( `` tag all already in the list `` ) ; } return new conditionals ( empty ( ) , collection . unmodifiable list ( none match ) , modify since , optional . empty ( ) ) ; }
public static string get credential charset ( final http params params ) { if ( params == null ) { throw new illegal argument exception ( `` http parameter may not be null `` ) ; } string charset = ( string ) params . get parameter ( auth p name . credential_charset ) ; if ( charset == null ) { charset = http . default_protocol_charset ; } return charset ; }
public final async scheme register ( final async scheme sch ) { if ( sch == null ) { throw new illegal argument exception ( `` scheme must not be null . `` ) ; } final async scheme old = register scheme . put ( sch . get name ( ) , sch ) ; return old ; }
public static boolean be i pv6 hex compress address ( final string input ) { int colon count = 0 ; for ( int i = 0 ; i < input . length ( ) ; i++ ) { if ( input . char at ( i ) == colon_char ) { colon count++ ; } } return colon count < = max_colon_count & & ipv6_hex_compressed_pattern . matcher ( input ) . match ( ) ; }
public final http async client builder set default header ( final collection < ? extend header > default header ) { this . default header = default header ; return this ; }
public void add ( final int index , final object element ) { this . all . add ( index , ( uri ) element ) ; this . unique . add ( ( uri ) element ) ; }
protect abstract pool entry get pool entry ( ) { return this . pool entry ; }
public int get capacity ( ) { return conn per route . get max for route ( route ) - num entry ; }
public boolean delete entry ( basic pool entry entry ) { final boolean find = free entry . remove ( entry ) ; if ( find ) num entry -- ; return find ; }
protect route specific pool new route specific pool ( http route route ) { return new route specific pool ( route , this . conn per route ) ; }
protect boolean match uri request pattern ( final string pattern , final string path ) { if ( pattern . equal ( `` * `` ) ) { return true ; } else { return ( pattern . end with ( `` * `` ) & & path . start with ( pattern . substring ( 0 , pattern . length ( ) - 1 ) ) ) || ( pattern . start with ( `` * `` ) & & path . end with ( pattern . substring ( 1 , pattern . length ( ) ) ) ) ; } }
public void validate ( final cookie cookie , final cookie origin origin ) throw malformed cookie exception { if ( cookie == null ) { throw new illegal argument exception ( `` cookie may not be null `` ) ; } if ( origin == null ) { throw new illegal argument exception ( `` cookie origin may not be null `` ) ; } int port = origin . get port ( ) ; if ( cookie instanceof client cookie & & ( ( client cookie ) cookie ) . contains attribute ( client cookie . port_attr ) ) { if ( ! port match ( port , cookie . get port ( ) ) ) { throw new cookie restriction violation exception ( `` port attribute violates rfc 2965 : `` + `` request port not find in cookie 's port list . `` ) ; } } }
public u r i builder set parameter ( final list < name value pair > nvps ) { if ( this . query params == null ) { this . query params = new array list < name value pair > ( ) ; } else { this . query params . clear ( ) ; } this . query params . add all ( nvps ) ; this . encoded query = null ; this . encoded scheme specific part = null ; this . query = null ; return this ; }
public static s s l connection socket factory get system socket factory ( ) throw s s l initialization exception { return new s s l connection socket factory ( ( javax . net . ssl . s s l socket factory ) javax . net . ssl . s s l socket factory . get default ( ) , split ( system . get property ( `` http . protocols `` ) ) , split ( system . get property ( `` http . cipher suit `` ) ) , get default hostname verifier ( ) ) ; }
public boolean match ( final string domain ) { return match ( domain , null ) ; }
public boolean be redirects enable ( ) { return redirects enable ; }
public collection < string > get proxy prefer auth scheme ( ) { return proxy prefer auth scheme ; }
public boolean be redirects enable ( ) { return redirects enable ; }
public entity builder chunk ( ) { this . chunked = true ; return this ; }
public void set parameter name ( string parameter name ) { assert . not null ( parameter name , `` 'parameter name ' be require `` ) ; this . parameter name = parameter name ; }
public final http client builder evict idle connection ( final long max idle time , final time unit max idle time unit ) { this . evict idle connection = true ; this . max idle time = max idle time ; this . max idle time unit = max idle time unit ; return this ; }
public int get connect timeout ( ) { return connect timeout ; }
public static lookup < cookie spec provider > create default ( ) { return create default ( public suffix matcher loader . get default ( ) ) ; }
public final expression optimize ( expression visitor visitor , item type context item type ) { return this ; }
protect double get domain low bound ( double p ) { return 0 ; }
public boolean be comment ( char ch ) { return this . comment == ch ; }
public object clone ( ) throw clone not support exception { basic http params clone = ( basic http params ) super . clone ( ) ; copy params ( clone ) ; return clone ; }
public synchronize void register ( final string pattern , final object obj ) { if ( pattern == null ) { throw new illegal argument exception ( `` uri request pattern may not be null `` ) ; } this . map . put ( pattern , obj ) ; }
public int index of ( int ch , int begin index , int end index ) { if ( begin index < 0 ) { begin index = 0 ; } if ( end index > this . len ) { end index = this . len ; } if ( begin index > end index ) { return -1 ; } for ( int i = begin index ; i < end index ; i++ ) { if ( this . buffer [ i ] == ch ) { return i ; } } return -1 ; }
public boolean be full ( ) { return this . len == this . buffer . length ; }
public char char at ( int offset ) { return ref . char [ offset ] ; }
public char [ ] to char array ( ) { char [ ] b = new char [ this . len ] ; if ( this . len > 0 ) { system . arraycopy ( this . buffer , 0 , b , 0 , this . len ) ; } return b ; }
public final string get package ( ) { return info package ; }
public final string get package ( ) { return info package ; }
public final string get package ( ) { return info package ; }
public set < string > get default name ( ) { return new hash set < string > ( get names ( this . default ) ) ; }
protect void delete entry ( basic pool entry entry ) { http route route = entry . get plan route ( ) ; if ( log . be debug enable ( ) ) { log . debug ( `` delete connection `` + `` [ `` + route + `` ] [ `` + entry . get state ( ) + `` ] `` ) ; } pool lock . lock ( ) ; try { close connection ( entry ) ; route specific pool rospl = get route pool ( route , true ) ; rospl . delete entry ( entry ) ; num connection -- ; if ( rospl . be unused ( ) ) { route to pool . remove ( route ) ; } } finally { pool lock . unlock ( ) ; } }
public header get content type ( ) { return this . content type ; }
public void copy content ( final char array buffer buf , final parser cursor cursor , final bit set delimiters , final string builder dst ) { int po = cursor . get pos ( ) ; final int index from = cursor . get pos ( ) ; final int index to = cursor . get upper bound ( ) ; for ( int i = index from ; i < index to ; i++ ) { final char current = buf . char at ( i ) ; if ( ( delimiters ! = null & & delimiters . get ( current ) ) || be whitespace ( current ) ) { break ; } else { pos++ ; dst . append ( current ) ; } } cursor . update po ( po ) ; }
public input stream get content ( ) throw illegal state exception { if ( this . content == null ) { throw new illegal state exception ( `` content have not be provide `` ) ; } return this . content ; }
public static boolean have text ( char sequence str ) { if ( ! have length ( str ) ) { return false ; } int str len = str . length ( ) ; for ( int i = 0 ; i < str len ; i++ ) { if ( ! character . be whitespace ( str . char at ( i ) ) ) { return true ; } } return false ; }
public boolean be response available ( ) throw i o exception { log . trace ( `` enter http connection . be response available ( ) `` ) ; if ( this . be open ) { return this . input stream . available ( ) > 0 ; } else { return false ; } }
protect void add non match ( string builder sb , string text ) { sb . append ( text ) ; }
protect void close active channel ( ) throw i o reactor exception { try { final set < selection key > key = this . selector . key ( ) ; for ( final selection key key : key ) { final i o session session = get session ( key ) ; if ( session ! = null ) { session . close ( ) ; } } this . selector . close ( ) ; } catch ( final i o exception ignore ) { } }
protect void close active channel ( ) throw i o reactor exception { try { final set < selection key > key = this . selector . key ( ) ; for ( final selection key key : key ) { final i o session session = get session ( key ) ; if ( session ! = null ) { session . close ( ) ; } } this . selector . close ( ) ; } catch ( final i o exception ignore ) { } }
public void await shutdown ( final long timeout ) throw interrupted exception { synchronize ( this . status mutex ) { final long deadline = system . current time millis ( ) + timeout ; long remain = timeout ; while ( this . status ! = i o reactor status . shut_down ) { this . status mutex . wait ( remain ) ; if ( timeout > 0 ) { remain = deadline - system . current time millis ( ) ; if ( remain < = 0 ) { break ; } } } } }
public long get select interval ( ) { return this . select interval ; }
public http processor get http processor ( ) { return http processor ; }
protect void log ( final exception ex ) { this . exception logger . log ( ex ) ; }
protect void set output mode ( ) { if ( this . mode ! = output_mode ) { this . buffer . flip ( ) ; this . mode = output_mode ; } }
public int length ( ) { set output mode ( ) ; return this . buffer . remain ( ) ; }
public static bit set xor ( bit set left , bit set right ) { bit set result = ( bit set ) leave . clone ( ) ; result . xor ( right ) ; return result ; }
public path get path ( ) { return path ; }
protect void _report mismatch end marker ( int act ch , char exp ch ) throw json parse exception { json read context ctxt = get parse context ( ) ; _report error ( string . format ( `` unexpected close marker ' % s ' : expect ' % c ' ( for % s start at % s ) `` , ( char ) act ch , exp ch , ctxt . type desc ( ) , ctxt . get start location ( _get source reference ( ) ) ) ) ; }
public string to string ( ) { return _name ; }
public char encode base64 bit a char ( int value ) { / * let 's assume caller have do necessary check ; this * method must be fast and inlinable * / return _base64 to ascii c [ value ] ; }
protect void _report mismatch end marker ( int act ch , char exp ch ) throw json parse exception { json read context ctxt = get parse context ( ) ; _report error ( string . format ( `` unexpected close marker ' % s ' : expect ' % c ' ( for % s start at % s ) `` , ( char ) act ch , exp ch , ctxt . type desc ( ) , ctxt . get start location ( _get source reference ( ) ) ) ) ; }
public token filter include root value ( int index ) { return this ; }
public token filter include property ( string name ) { return this ; }
public boolean include number ( int v ) { return _include scalar ( ) ; }
public match strength get match strength ( ) { return ( _match strength == null ) ? match strength . inconclusive : _match strength ; }
public int contain parser count ( ) { return _parsers . length ; }
public static byte [ ] encode a u t f8 ( string text ) { return get json string encoder ( ) . encode a u t f8 ( text ) ; }
public final void free buffer ( ) { byte [ ] buf = _buffer ; if ( buf ! = null ) { _buffer = null ; _context . release read i o buffer ( buf ) ; } }
public final char [ ] a quote char ( ) { char [ ] result = _quoted char ; if ( result == null ) { _quoted char = result = json_encoder . quote a string ( _value ) ; } return result ; }
public boolean equal ( object o ) { if ( o == this ) return true ; if ( o == null ) return false ; if ( o . get class ( ) ! = get class ( ) ) return false ; name type other = ( name type ) o ; return ( _class == other . _class ) & & object . equal ( _name , other . _name ) ; }
public json factory set input decorator ( input decorator d ) { _input decorator = d ; return this ; }
public string offset description ( ) { return append offset description ( new string builder ( 40 ) ) . to string ( ) ; }
protect double get domain low bound ( double p ) { return 0 ; }
public boolean get boolean value ( ) throw i o exception { json token t = current token ( ) ; if ( t == json token . value_true ) return true ; if ( t == json token . value_false ) return false ; throw new json parse exception ( this , string . format ( `` current token ( % s ) not of boolean type `` , t ) ) . with request payload ( _request payload ) ; }
public < t extend tree node > t read value a tree ( ) throw i o exception { return ( t ) _codec ( ) . read tree ( this ) ; }
public string get scheme ( ) { throw new unsupported operation exception ( `` not implement by the `` + get class ( ) . get simple name ( ) + `` file system implementation `` ) ; }
public json pointer match property ( string name ) { if ( ( _next segment ! = null ) & & _matching property name . equal ( name ) ) { return _next segment ; } return null ; }
public string map path ( string path ) { return null ; }
public char to name canonicalizer make child ( int flag ) { return new char to name canonicalizer ( this , flag , _seed , _table info . get ( ) ) ; }
public boolean be anchor type ( ) { return ( _anchor type == this ) ; }
public void remove super ( session session ) { super . remove ( session , false ) ; }
@ override public json token current token ( ) { return delegate . current token ( ) ; }
@ override public void set codec ( object codec c ) { delegate . set codec ( c ) ; }
protect final runtime exception not implement ( ) { return new runtime exception ( `` cod error : this method should never be call . this ptg should be convert `` ) ; }
public boolean include value ( json parser p ) throw i o exception { return _include scalar ( ) ; }
public byte [ ] alloc base64 buffer ( ) { _verify alloc ( _base64 buffer ) ; return ( _base64 buffer = _buffer recycler . alloc byte buffer ( buffer recycler . byte_base64_codec_buffer ) ) ; }
public content reference content reference ( ) { return _content reference ; }
public json location current location ( ) { return get current location ( ) ; }
@ override public json stream context get parse context ( ) { return delegate . get parse context ( ) ; }
protect int do hash ( final json node t ) { / * * if this be a numeric node , we want the same hashcode for the same * mathematical value . go with double , it range be good enough for * 99+ % of use case . * / if ( t . be number ( ) ) return double . value of ( t . double value ( ) ) . hash code ( ) ; / * * if this be a primitive type ( other than number , handle above ) , * delegate to json node . * / if ( ! t . be container node ( ) ) return t . hash code ( ) ; / * * the following hash calculation work , yes , but they be poor at best . * and probably slow , too . * * todo : try and figure out those hash class from guava * / int ret = 0 ; / * * if the container be empty , just return * / if ( t . size ( ) == 0 ) return ret ; / * * array * / if ( t . be array ( ) ) { for ( final json node element : t ) ret = 31 * ret + do hash ( element ) ; return ret ; } / * * not an array ? an object . * / final iterator < map . entry < string , json node > > iterator = t . field ( ) ; map . entry < string , json node > entry ; while ( iterator . have next ( ) ) { entry = iterator . next ( ) ; ret = 31 * ret + ( entry . get key ( ) . hash code ( ) ^ do hash ( entry . get value ( ) ) ) ; } return ret ; }
public json pointer parent ( ) { final int size = token resolvers . size ( ) ; return size < = 1 ? empty : new json pointer ( token resolvers . sub list ( 0 , size - 1 ) ) ; }
public json pointer parent ( ) { final int size = token resolvers . size ( ) ; return size < = 1 ? empty : new json pointer ( token resolvers . sub list ( 0 , size - 1 ) ) ; }
public final void serialize ( json generator g , serializer provider provider ) throw i o exception { / * nothing to output . . . should we signal an error tho ? * chance be , this be an erroneous call . for now , let 's * not do that ; serialize a explicit null . why ? because we * can not just omit a value a json object field name may have * be write out . * / g . write null ( ) ; }
public void remove super ( session session ) { super . remove ( session , false ) ; }
public annotate class get class info ( ) { return _class info ; }
public json format . value find format default ( class < ? > type ) { if ( _overrides ! = null ) { config override override = _overrides . get ( type ) ; if ( override ! = null ) { json format . value format = override . get format ( ) ; if ( format ! = null ) { if ( ! format . have lenient ( ) ) { return format . with lenient ( _default leniency ) ; } return format ; } } } if ( _default leniency == null ) { return json format . value . empty ( ) ; } return json format . value . for leniency ( _default leniency ) ; }
public b default mergeable ( boolean b ) { _mapper . set default mergeable ( b ) ; return _this ( ) ; }
public b default locale ( locale locale ) { _mapper . set locale ( locale ) ; return _this ( ) ; }
public final class < ? > find mix in class for ( class < ? > cl ) { return _mix in . find mix in class for ( cl ) ; }
protect json deserializer < ? > create builder base deserializer ( java type value type , bean property map property map , boolean any view ) { return new builder base deserializer ( this , _bean desc , value type , property map , _back ref property , _ignorable prop , _ignore all unknown , any view ) ; }
protect json deserializer < ? > create builder base deserializer ( java type value type , bean property map property map , boolean any view ) { return new builder base deserializer ( this , _bean desc , value type , property map , _back ref property , _ignorable prop , _ignore all unknown , any view ) ; }
public bean property map with case insensitivity ( boolean state ) { if ( _case insensitive == state ) { return this ; } return new bean property map ( this , state ) ; }
protect t convert value ( object delegate value ) { return _converter . convert ( delegate value ) ; }
public final boolean have some of feature ( int feature mask ) { return ( _deser feature & feature mask ) ! = 0 ; }
public annotation get annotation ( ) { return _class annotation ; }
public final void serialize ( json generator g , serializer provider provider ) throw i o exception { / * nothing to output . . . should we signal an error tho ? * chance be , this be an erroneous call . for now , let 's * not do that ; serialize a explicit null . why ? because we * can not just omit a value a json object field name may have * be write out . * / g . write null ( ) ; }
public void prepend path ( object referrer , string field name ) { reference ref = new reference ( referrer , field name ) ; prepend path ( ref ) ; }
public void prepend path ( object referrer , string field name ) { reference ref = new reference ( referrer , field name ) ; prepend path ( ref ) ; }
public string map path ( string path ) { return null ; }
public < t > simple module add deserializer ( class < t > type , json deserializer < ? extend t > deser ) { _check not null ( type , `` type to register deserializer for `` ) ; _check not null ( deser , `` deserializer `` ) ; if ( _deserializers == null ) { _deserializers = new simple deserializers ( ) ; } _deserializers . add deserializer ( type , deser ) ; return this ; }
public json node without ( string field name ) { _children . remove ( field name ) ; return this ; }
public array node insert null ( int index ) { _insert ( index , null node ( ) ) ; return this ; }
public array node add all ( collection < ? extend json node > node ) { for ( json node node : node ) { add ( node ) ; } return this ; }
public array node add ( int v ) { _add ( number node ( v ) ) ; return this ; }
public tar entry [ ] get directory entry ( ) { if ( this . file == null || ! this . file . be directory ( ) ) { return new tar entry [ 0 ] ; } string [ ] list = this . file . list ( ) ; tar entry [ ] result = new tar entry [ list . length ] ; for ( int i = 0 ; i < list . length ; ++i ) { result [ i ] = new tar entry ( new file ( this . file , list [ i ] ) ) ; } return result ; }
public object node object node ( ) { return new object node ( this ) ; }
public array node insert null ( int index ) { _insert ( index , null node ( ) ) ; return this ; }
public object node put p o j o ( string property name , object pojo ) { return _put ( property name , pojo node ( pojo ) ) ; }
public boolean equal ( object o ) { / * 11- mar-2013 , tatu : apparently class loader can manage to load * different instance , render identity comparison break . * so let 's use value instead . * / if ( o == this ) return true ; if ( o == null ) return false ; if ( ! ( o instanceof boolean node ) ) { return false ; } return ( _value == ( ( boolean node ) o ) . _value ) ; }
public class < ? > find p o j o builder class ( ) { return _annotation introspector . find p o j o builder ( _class def ) ; }
public object mapper set visibility ( property accessor for method , json auto detect . visibility visibility ) { visibility checker < ? > vc = _config override . get default visibility ( ) ; vc = vc . with visibility ( for method , visibility ) ; _config override . set default visibility ( vc ) ; return this ; }
public void copy entry content ( output stream out ) throw i o exception { byte [ ] buf = new byte [ 32 * 1024 ] ; while ( true ) { int num read = this . read ( buf , 0 , buf . length ) ; if ( num read == -1 ) { break ; } out . write ( buf , 0 , num read ) ; } }
public object mapper set default typing ( type resolver builder < ? > typer ) { _deserialization config = _deserialization config . with ( typer ) ; _serialization config = _serialization config . with ( typer ) ; return this ; }
public object writer with schema ( format schema schema ) { if ( _schema == schema ) { return this ; } _verify schema type ( schema ) ; return new object writer ( this , _config , _root type , _root serializer , _pretty printer , schema , _character escape ) ; }
public object get internal setting ( object key ) { return ( _internal setting == null ) ? null : _internal setting . get ( key ) ; }
public serializer provider get serializer provider ( ) { return _serializer provider ; }
public static simple bean property filter serialize all ( ) { return serialize except filter . include_all ; }
public deserialization config without feature ( json parser . feature . . . feature ) { int new set = _parser feature ; int new mask = _parser feature to change ; for ( json parser . feature f : feature ) { int mask = f . get mask ( ) ; new set & = ~mask ; new mask |= mask ; } return ( ( _parser feature == new set ) & & ( _parser feature to change == new mask ) ) ? this : new deserialization config ( this , _mapper feature , _deser feature , new set , new mask , _format read feature , _format read feature to change ) ; }
public void set null key serializer ( json serializer < object > nks ) { if ( nks == null ) { throw new illegal argument exception ( `` can not pass null json serializer `` ) ; } _null key serializer = nks ; }
public bean description introspect class annotation ( class < ? > cl ) { return introspect class annotation ( construct type ( cl ) ) ; }
public type serializer find type serializer ( java type java type ) throw json map exception { return _serializer factory . create type serializer ( _config , java type ) ; }
public type serializer find type serializer ( java type java type ) throw json map exception { return _serializer factory . create type serializer ( _config , java type ) ; }
public map like type construct raw map like type ( class < ? > map class ) { return construct map like type ( map class , unknown type ( ) , unknown type ( ) ) ; }
public boolean be concrete ( ) { int mod = _class . get modifier ( ) ; if ( ( mod & ( modifier . interface | modifier . abstract ) ) == 0 ) { return true ; } / * 19- feb-2010 , tatu : holy mackarel ; primitive type * have 'abstract ' flag set . . . * / return _class . be primitive ( ) ; }
public static string get type description ( java type full type ) { if ( full type == null ) { return `` [ null ] `` ; } string builder sb = new string builder ( 80 ) . append ( ' ` ' ) ; sb . append ( full type . to canonical ( ) ) ; return sb . append ( ' ` ' ) . to string ( ) ; }
public int initial capacity ( ) { return ( _free buffer == null ) ? 0 : _free buffer . length ; }
public object [ ] complete and clear buffer ( object [ ] last chunk , int last chunk entry ) { int total size = last chunk entry + _size ; object [ ] result = new object [ total size ] ; _copy to ( result , total size , last chunk , last chunk entry ) ; _reset ( ) ; return result ; }
public bean property definition with name ( string new name ) { return with simple name ( new name ) ; }
public json factory set root value separator ( string sep ) { _root value separator = ( sep == null ) ? null : new serialize string ( sep ) ; return this ; }
public final void serialize ( json generator g , serializer provider provider ) throw i o exception { / * nothing to output . . . should we signal an error tho ? * chance be , this be an erroneous call . for now , let 's * not do that ; serialize a explicit null . why ? because we * can not just omit a value a json object field name may have * be write out . * / g . write null ( ) ; }
public void add ignorable ( string prop name ) { if ( _ignorable prop == null ) { _ignorable prop = new hash set < string > ( ) ; } _ignorable prop . add ( prop name ) ; }
public static enum value construct ( serialization config config , class < enum < ? > > enum class ) { if ( config . be enable ( serialization feature . write_enums_using_to_string ) ) { return construct from to string ( config , enum class ) ; } return construct from name ( config , enum class ) ; }
public final void serialize ( json generator g , serializer provider provider ) throw i o exception { / * nothing to output . . . should we signal an error tho ? * chance be , this be an erroneous call . for now , let 's * not do that ; serialize a explicit null . why ? because we * can not just omit a value a json object field name may have * be write out . * / g . write null ( ) ; }
public final void serialize ( json generator g , serializer provider provider ) throw i o exception { / * nothing to output . . . should we signal an error tho ? * chance be , this be an erroneous call . for now , let 's * not do that ; serialize a explicit null . why ? because we * can not just omit a value a json object field name may have * be write out . * / g . write null ( ) ; }
public static annotation introspector nop instance ( ) { return nop annotation introspector . instance ; }
public json map exception map exception ( string message ) { return json map exception . from ( get parser ( ) , message ) ; }
public < t extend bean description > t introspect ( java type type ) { return ( t ) get class introspector ( ) . for serialization ( this , type , this ) ; }
public string map path ( string path ) { return null ; }
public json map exception instantiation exception ( class < ? > inst class , throwable t ) { return json map exception . from ( _parser , `` can not construct instance of `` +inst class . get name ( ) + `` , problem : `` +t . get message ( ) , t ) ; }
public object mapper activate default typing ( polymorphic type validator ptv ) { return activate default typing ( ptv , default typing . object_and_non_concrete ) ; }
public json node read tree ( input stream in ) throw i o exception { _assert not null ( `` in `` , in ) ; return _read tree and close ( _json factory . create parser ( in ) ) ; }
public boolean await read complete ( long timeout , time unit unit ) { return true ; }
public map serializer with content inclusion ( object suppressable value ) { if ( suppressable value == _suppressable value ) { return this ; } _ensure override ( ) ; return new map serializer ( this , _value type serializer , suppressable value ) ; }
public static < r > r wrap and throw ( final throwable throwable ) { if ( throwable instanceof runtime exception ) { throw ( runtime exception ) throwable ; } if ( throwable instanceof error ) { throw ( error ) throwable ; } throw new undeclared throwable exception ( throwable ) ; }
static public string to lower camel case ( string string ) { if ( string == null ) { return null ; } if ( string . be empty ( ) ) { return string ; } if ( string . length ( ) > 1 & & character . be upper case ( string . char at ( 1 ) ) & & character . be upper case ( string . char at ( 0 ) ) ) { return string ; } char char [ ] = string . to char array ( ) ; char [ 0 ] = character . to lower case ( char [ 0 ] ) ; return new string ( char ) ; }
public json node visit ( jmes path sub expression sub expression , json node input ) throw invalid type exception { json node prelimnary result = sub expression . get expression ( ) . get ( 0 ) . accept ( this , input ) ; for ( int i = 1 ; i < sub expression . get expression ( ) . size ( ) ; i++ ) { prelimnary result = sub expression . get expression ( ) . get ( i ) . accept ( this , prelimnary result ) ; } return prelimnary result ; }
public y a m l generator enable ( y a m l generator . feature f ) { _format feature |= f . get mask ( ) ; return this ; }
public simple module add serializer ( json serializer < ? > ser ) { _check not null ( ser , `` serializer `` ) ; if ( _serializers == null ) { _serializers = new simple serializers ( ) ; } _serializers . add serializer ( ser ) ; return this ; }
public string get expression string ( ) { return expr ; }
public void set value ( e l context context , object base , object property , object val ) { context . set property resolve ( false ) ; for ( int i = 0 ; i < size ; i++ ) { el resolvers [ i ] . set value ( context , base , property , val ) ; if ( context . be property resolve ( ) ) { return ; } } }
public standard e l context get e l context ( ) { if ( el context == null ) { el context = new standard e l context ( get expression factory ( ) ) ; } return el context ; }
public boolean be lambda argument ( string arg ) { if ( lambda args == null ) { return false ; } for ( int i = lambda args . size ( ) - 1 ; i > = 0 ; i -- ) { map < string , object > lmap = lambda args . element at ( i ) ; if ( lmap . contains key ( arg ) ) { return true ; } } return false ; }
public iterator < feature descriptor > get feature descriptor ( e l context context , object base ) { return new composite iterator ( el resolvers , size , context , base ) ; }
public void add evaluation listener ( evaluation listener listener ) { get e l context ( ) . add evaluation listener ( listener ) ; }
public object get value ( string expression , class < ? > expect type ) { value expression exp = factory . create value expression ( el manager . get e l context ( ) , bracket ( expression ) , expect type ) ; return exp . get value ( el manager . get e l context ( ) ) ; }
public void set variable ( string var , string expression ) { value expression exp = factory . create value expression ( el manager . get e l context ( ) , bracket ( expression ) , object . class ) ; el manager . set variable ( var , exp ) ; }
public object invoke ( e l context context , object base , object method , class < ? > [ ] param type , object [ ] params ) { return null ; }
public json patch builder add ( string path , json value value ) { builder . add ( json . create object builder ( ) . add ( `` op `` , operation . add . operation name ( ) ) . add ( `` path `` , path ) . add ( `` value `` , value ) ) ; return this ; }
public final jsonb config with strict i j s o n ( final boolean enable ) { return set property ( strict_ijson , enable ) ; }
public locale get language ( ) { return variant . get language ( ) ; }
public final void add ( k key , v value ) { list < v > value = get value ( key ) ; if ( value ! = null ) { value . add ( value ) ; } else { add null ( value ) ; } }
public int get s max age ( ) { return s max age ; }
public list < string > get no cache field ( ) { if ( no cache field == null ) { no cache field = new array list < string > ( ) ; } return no cache field ; }
public boolean be no transform ( ) { return no transform ; }
public string get name ( ) { return name ; }
public int get max age ( ) { return max age ; }
public string to string ( ) { return header_delegate . to string ( this ) ; }
public static builder from uri builder ( uri builder uri builder ) { builder b = runtime delegate . get instance ( ) . create link builder ( ) ; b . uri builder ( uri builder ) ; return b ; }
public static response builder ok ( ) { return status ( status . ok ) ; }
public static response builder ok ( ) { return status ( status . ok ) ; }
public static response builder see other ( uri location ) { return status ( status . see_other ) . location ( location ) ; }
public static java . math . big decimal parse decimal ( string lexical x s d decimal ) { if ( the converter == null ) init converter ( ) ; return the converter . parse decimal ( lexical x s d decimal ) ; }
protect string get no n s schema location ( ) { return no n s schema location ; }
protect string get encode ( ) { return encode ; }
public class get scope ( ) { return scope ; }
public string to string ( ) { return link exception == null ? super . to string ( ) : super . to string ( ) + `` \n - with link exception : \n [ `` + link exception . to string ( ) + `` ] `` ; }
public list < annotation value > value with default ( index view index ) { class info definition = index . get class by name ( this . name ) ; if ( definition == null ) { throw new illegal argument exception ( `` index do not contain annotation definition : `` + this . name ) ; } list < method info > method = definition . method ( ) ; array list < annotation value > result = new array list < annotation value > ( method . size ( ) ) ; for ( method info method : method ) { annotation value value = value ( method . name ( ) ) ; if ( value == null ) { value = method . default value ( ) ; } if ( value ! = null ) { result . add ( value ) ; } } return collection . unmodifiable list ( result ) ; }
public string identifier ( ) { return name ; }
public string simple name ( ) { return nest info ! = null ? nest info . simple name : name . local ( ) ; }
public nest type nest type ( ) { if ( nest info == null ) { return nest type . top_level ; } else if ( nest info . enclose class ! = null ) { return nest type . inner ; } else if ( nest info . simple name ! = null ) { return nest type . local ; } return nesting type . anonymous ; }
public boolean be componentized ( ) { return componentized ; }
public string to string ( ) { return internal . to string ( clazz ) ; }
public string to string ( ) { return internal . to string ( clazz ) ; }
public final boolean have annotation ( dot name name ) { return method internal . have annotation ( name ) ; }
public int get index version ( ) throw i o exception { if ( version == -1 ) { read version ( ) ; } return version ; }
public static i scanner create scanner ( boolean tokenize comment , boolean tokenize white space , boolean record line separator , string source level , string compliance level ) { return create scanner ( tokenize comment , tokenize white space , record line separator , source level , compliance level , true ) ; }
public final string name ( ) { return method . parameter name ( parameter ) ; }
public static parameterized type create ( dot name name , type [ ] argument , type owner ) { return new parameterized type ( name , argument , owner ) ; }
public annotation target target ( ) { return target ; }
public string identifier ( ) { return name ; }
public data loader registry unregister ( string key ) { data loader . remove ( key ) ; return this ; }
public boolean cache enable ( ) { return cache enable ; }
public data loader option set cache enable ( boolean caching enable ) { this . cache enable = caching enable ; return this ; }
public long get time total ( ) { return statistic . time count + statistic . time search for reuse + statistic . time search for size + statistic . time compress + statistic . time write ; }
public static < v > completable future < try < v > > try future ( completion stage < v > completion stage ) { return try stage ( completion stage ) . to completable future ( ) ; }
public static patch < string > diff inline ( string original , string revise ) { list < string > orig list = new array list < > ( ) ; list < string > rev list = new array list < > ( ) ; for ( character character : original . to char array ( ) ) { orig list . add ( character . to string ( ) ) ; } for ( character character : revise . to char array ( ) ) { rev list . add ( character . to string ( ) ) ; } patch < string > patch = diff utils . diff ( orig list , rev list ) ; for ( abstract delta < string > delta : patch . get deltas ( ) ) { delta . get source ( ) . set line ( compress line ( delta . get source ( ) . get line ( ) , `` `` ) ) ; delta . get target ( ) . set line ( compress line ( delta . get target ( ) . get line ( ) , `` `` ) ) ; } return patch ; }
public compilation unit printer ( printer printer ) { set data ( printer_key , printer ) ; return this ; }
public compilation unit set type ( final node list < type declaration < ? > > type ) { assert not null ( type ) ; if ( type == this . type ) { return this ; } notify property change ( observable property . type , this . type , type ) ; if ( this . type ! = null ) this . type . set parent node ( null ) ; this . type = type ; set a parent node of ( type ) ; return this ; }
public optional < annotation declaration > get annotation declaration by name ( string annotation name ) { return get type ( ) . stream ( ) . filter ( type - > type . get name a string ( ) . equal ( annotation name ) & & type instanceof annotation declaration ) . find first ( ) . map ( t - > ( annotation declaration ) t ) ; }
public string literal expr set escape value ( string value ) { this . value = utils . escape end of line ( value ) ; return this ; }
public resolve value declaration resolve ( ) { return get symbol resolver ( ) . resolve declaration ( this , resolve value declaration . class ) ; }
public string literal expr set escape value ( string value ) { this . value = utils . escape end of line ( value ) ; return this ; }
public name get name ( ) { return name ; }
public package declaration set name ( final name name ) { assert not null ( name ) ; if ( name == this . name ) { return this ; } notify property change ( observable property . name , this . name , name ) ; if ( this . name ! = null ) this . name . set parent node ( null ) ; this . name = name ; set a parent node of ( name ) ; return this ; }
public if stmt set else stmt ( final statement else stmt ) { if ( else stmt == this . else stmt ) { return this ; } notify property change ( observable property . else_stmt , this . else stmt , else stmt ) ; if ( this . else stmt ! = null ) this . else stmt . set parent node ( null ) ; this . else stmt = else stmt ; set a parent node of ( else stmt ) ; return this ; }
public boolean have cascade if stmt ( ) { return else stmt instanceof if stmt ; }
public boolean have cascade if stmt ( ) { return else stmt instanceof if stmt ; }
public < t extend body declaration < ? > > parse result < t > parse body declaration ( string body ) { return ( parse result < t > ) parse ( class_body , provider ( body ) ) ; }
public optional < package declaration > get package declaration ( ) { return optional . of nullable ( package declaration ) ; }
public indentation get indentation ( ) { return wrap configuration . get ( new default configuration option ( config option . indentation ) ) . get ( ) . a value ( ) ; }
public pretty printer configuration set indent size ( int indent size ) { indentation indentation = get indentation ( ) . set size ( assert non negative ( indent size ) ) ; set indentation ( indentation ) ; return this ; }
public boolean overlap with ( range other ) { return ( contains ( other . begin ) || contains ( other . end ) ) || ( other . contains ( begin ) || other . contains ( end ) ) ; }
public boolean overlap with ( range other ) { return ( contains ( other . begin ) || contains ( other . end ) ) || ( other . contains ( begin ) || other . contains ( end ) ) ; }
public boolean overlap with ( range other ) { return ( contains ( other . begin ) || contains ( other . end ) ) || ( other . contains ( begin ) || other . contains ( end ) ) ; }
public boolean declare on type ( ) { return true ; }
public string get signature ( ) { string builder sb = new string builder ( ) ; sb . append ( get name ( ) ) ; sb . append ( `` ( `` ) ; for ( int i = 0 ; i < get no params ( ) ; i++ ) { if ( i ! = 0 ) { sb . append ( `` , `` ) ; } resolve type type = get param type ( i ) ; if ( type . be array ( ) & & get declaration ( ) . get param ( i ) . be variadic ( ) ) { sb . append ( type . a array type ( ) . get component type ( ) . describe ( ) ) . append ( `` . . . `` ) ; } else { sb . append ( type . describe ( ) ) ; } } sb . append ( `` ) `` ) ; return sb . to string ( ) ; }
protect boolean be correspond box type ( string type name ) { resolve primitive type resolve primitive type = ( resolve primitive type ) resolve primitive type . by name ( type name ) ; return get qualify name ( ) . equal ( resolve primitive type . get box type q name ( ) ) ; }
public optional < resolve primitive type > to unboxed type ( ) { return array . stream ( resolve primitive type . value ( ) ) . filter ( pt - > this . a reference type ( ) . get qualified name ( ) . equal ( pt . get box type q name ( ) ) ) . find first ( ) ; }
public static string format ( string message , object argument ) { return message format . format ( message , argument ) ; }
public static void trace ( string format , supplier < object > . . . args ) { current_adapter . trace ( make format supplier ( format , args ) ) ; }
public context get context ( ) { return java parser factory . get context ( wrapped node , type solver ) ; }
public static name category syntactic classification accord to context ( node name ) { if ( name . get parent node ( ) . be present ( ) ) { node parent = name . get parent node ( ) . get ( ) ; if ( be a name ( parent ) & & name a string ( name ) . equal ( name a string ( parent ) ) ) { return syntactic classification accord to context ( parent ) ; } } if ( be syntactically a type name ( name ) ) { return name category . type_name ; } if ( be syntactically an expression name ( name ) ) { return name category . expression_name ; } if ( be syntactically a method name ( name ) ) { return name category . method_name ; } if ( be syntactically a package or type name ( name ) ) { return name category . package_or_type_name ; } if ( be syntactically a ambiguous name ( name ) ) { return name category . ambiguous_name ; } if ( be syntactically a module name ( name ) ) { return name category . module_name ; } if ( be syntactically a package name ( name ) ) { return name category . package_name ; } if ( name instanceof name expr ) { return name category . expression_name ; } if ( name instanceof field access expr ) { return name category . expression_name ; } if ( name instanceof class or interface type ) { return name category . type_name ; } if ( name . get parent node ( ) . be present ( ) & & name . get parent node ( ) . get ( ) instanceof class or interface type ) { return name category . type_name ; } if ( name . get parent node ( ) . be present ( ) & & name . get parent node ( ) . get ( ) instanceof field access expr ) { return name category . expression_name ; } throw new unsupported operation exception ( `` unable to classify category of name contain in `` + name . get parent node ( ) . get ( ) . get class ( ) . get simple name ( ) + `` . see `` + name + `` at `` + name . get range ( ) ) ; }
public static name category syntactic classification accord to context ( node name ) { if ( name . get parent node ( ) . be present ( ) ) { node parent = name . get parent node ( ) . get ( ) ; if ( be a name ( parent ) & & name a string ( name ) . equal ( name a string ( parent ) ) ) { return syntactic classification accord to context ( parent ) ; } } if ( be syntactically a type name ( name ) ) { return name category . type_name ; } if ( be syntactically an expression name ( name ) ) { return name category . expression_name ; } if ( be syntactically a method name ( name ) ) { return name category . method_name ; } if ( be syntactically a package or type name ( name ) ) { return name category . package_or_type_name ; } if ( be syntactically a ambiguous name ( name ) ) { return name category . ambiguous_name ; } if ( be syntactically a module name ( name ) ) { return name category . module_name ; } if ( be syntactically a package name ( name ) ) { return name category . package_name ; } if ( name instanceof name expr ) { return name category . expression_name ; } if ( name instanceof field access expr ) { return name category . expression_name ; } if ( name instanceof class or interface type ) { return name category . type_name ; } if ( name . get parent node ( ) . be present ( ) & & name . get parent node ( ) . get ( ) instanceof class or interface type ) { return name category . type_name ; } if ( name . get parent node ( ) . be present ( ) & & name . get parent node ( ) . get ( ) instanceof field access expr ) { return name category . expression_name ; } throw new unsupported operation exception ( `` unable to classify category of name contain in `` + name . get parent node ( ) . get ( ) . get class ( ) . get simple name ( ) + `` . see `` + name + `` at `` + name . get range ( ) ) ; }
public static void parse property string ( string value , vector < string > fragment , vector < string > property ref ) throw build exception { property helper . parse property string default ( value , fragment , property ref ) ; }
public source root parse ( string start package , string filename , parser configuration configuration , callback callback ) throw i o exception { assert not null ( start package ) ; assert not null ( filename ) ; assert not null ( configuration ) ; assert not null ( callback ) ; callback ( file in package absolute path ( root , start package , filename ) , configuration , callback ) ; return this ; }
public static string to string ( char ch ) { if ( ch < 128 ) { return char_string_array [ ch ] ; } return new string ( new char [ ] { ch } ) ; }
public boolean region match ( int toffset , char seq other , int ooffset , int len ) { return back . region match ( toffset , other . back , ooffset , len ) ; }
public int index of ( int ch , int from index ) { return back . index of ( ch , from index ) ; }
public char seq replace first ( string regex , string replacement ) { return char seq . of ( back . replace first ( regex , replacement ) ) ; }
public static synchronize local property get ( project project ) { local property l = ( local property ) project . get reference ( magic name . refid_local_properties ) ; if ( l == null ) { l = new local property ( ) ; project . add reference ( magic name . refid_local_properties , l ) ; property helper . get property helper ( project ) . add ( l ) ; } return l ; }
public static < k , v > hash map < k , v > of ( k k1 , v v1 , k k2 , v v2 ) { return of ( k1 , v1 ) . put ( k2 , v2 ) ; }
public void add local ( string property ) { current ( ) . add local ( property ) ; }
public void enter scope ( ) { current ( ) . enter scope ( ) ; }
public static hash set < boolean > of all ( boolean [ ] array ) { object . require non null ( array , `` array be null `` ) ; return hash set . of all ( iterator . of all ( array ) ) ; }
public static hash set < boolean > of all ( boolean [ ] array ) { object . require non null ( array , `` array be null `` ) ; return hash set . of all ( iterator . of all ( array ) ) ; }
public static hash set < boolean > of all ( boolean [ ] array ) { object . require non null ( array , `` array be null `` ) ; return hash set . of all ( iterator . of all ( array ) ) ; }
public boolean set ( string property , object value , property helper property helper ) { return current ( ) . set ( property , value , property helper ) ; }
public url build with query ( string base , string query string , object . . . value ) { string url string = string . format ( base + this . template , value ) + query string ; url url = null ; try { url = new url ( url string ) ; } catch ( malformed u r l exception e ) { assert false : `` an invalid url template indicate a bug in the sdk . `` ; } return url ; }
public static final int hresult_code ( int hr ) { return hr & 0x f f f f ; }
public frame frame at ( int po ) throw bad bytecode { if ( frame == null ) frame = new analyzer ( ) . analyze ( clazz , method info ) ; return frame [ po ] ; }
public type get local ( int index ) { return local [ index ] ; }
public frame copy ( ) { frame frame = new frame ( local . length , stack . length ) ; system . arraycopy ( local , 0 , frame . local , 0 , local . length ) ; system . arraycopy ( stack , 0 , frame . stack , 0 , stack . length ) ; frame . top = top ; return frame ; }
public void push ( type type ) { stack [ top++ ] = type ; }
public string to string ( ) { return `` annotation impl : id= `` + id + `` ; type= `` + type + `` ; features= `` + feature + `` ; start= `` + start + `` ; end= `` + end + system . get property ( `` line . separator `` ) ; } // to string ( )
public void set value ( annotation new value ) { value = new value ; }
public void write ( annotation writer writer ) throw i o exception { string type name = pool . get utf8 info ( type index ) ; if ( member == null ) { writer . annotation ( type name , 0 ) ; return ; } writer . annotation ( type name , member . size ( ) ) ; for ( pair pair : member . value ( ) ) { writer . member value pair ( pair . name ) ; pair . value . write ( writer ) ; } }
public string get name ( ) { return const pool . get utf8 info ( name ) ; }
public static ints ref to u t f32 ( char sequence s , ints ref scratch ) { int char idx = 0 ; int int idx = 0 ; final int char limit = s . length ( ) ; while ( char idx < char limit ) { scratch . grow ( int idx+1 ) ; final int utf32 = character . code point at ( s , char idx ) ; scratch . ints [ int idx ] = utf32 ; char idx += character . char count ( utf32 ) ; int idx++ ; } scratch . length = int idx ; return scratch ; }
public void add anewarray ( ct class clazz , int length ) { add iconst ( length ) ; add opcode ( anewarray ) ; add index ( const pool . add class info ( clazz ) ) ; }
public void add exception handler ( int start , int end , int handler , ct class type ) { add exception handler ( start , end , handler , const pool . add class info ( type ) ) ; }
public boolean be interface ( ) { return ( access flag & access flag . interface ) ! = 0 ; }
public string get superclass ( ) { if ( cached superclass == null ) cache superclass = const pool . get class info ( super class ) ; return cached superclass ; }
public void add interface ( string name ) { cached interface = null ; int info = const pool . add class info ( name ) ; if ( interface == null ) { interface = new int [ 1 ] ; interface [ 0 ] = info ; } else { int n = interface . length ; int [ ] newarray = new int [ n + 1 ] ; system . arraycopy ( interface , 0 , newarray , 0 , n ) ; newarray [ n ] = info ; interface = newarray ; } }
public void add interface ( string name ) { cached interface = null ; int info = const pool . add class info ( name ) ; if ( interface == null ) { interface = new int [ 1 ] ; interface [ 0 ] = info ; } else { int n = interface . length ; int [ ] newarray = new int [ n + 1 ] ; system . arraycopy ( interface , 0 , newarray , 0 , n ) ; newarray [ n ] = info ; interface = newarray ; } }
public void add method ( method info minfo ) throw duplicate member exception { test exist method ( minfo ) ; method . add ( minfo ) ; }
public int next ( ) throw bad bytecode { int po = current po ; current po = next opcode ( bytecode , po ) ; return po ; }
public int next ( ) throw bad bytecode { int po = current po ; current po = next opcode ( bytecode , po ) ; return po ; }
public int next ( ) throw bad bytecode { int po = current po ; current po = next opcode ( bytecode , po ) ; return po ; }
public int skip this constructor ( ) throw bad bytecode { return skip super constructor0 ( 1 ) ; }
public void insert ( int po , byte [ ] code ) throw bad bytecode { insert0 ( po , code , false ) ; }
public string get string info ( int index ) { string info si = ( string info ) get item ( index ) ; return get utf8 info ( si . string ) ; }
public string get string info ( int index ) { string info si = ( string info ) get item ( index ) ; return get utf8 info ( si . string ) ; }
public string get string info ( int index ) { string info si = ( string info ) get item ( index ) ; return get utf8 info ( si . string ) ; }
public int get name and type name ( int index ) { name and type info ntinfo = ( name and type info ) get item ( index ) ; return ntinfo . member name ; }
public string get fieldref name ( int index ) { fieldref info f = ( fieldref info ) get item ( index ) ; if ( f == null ) return null ; name and type info n = ( name and type info ) get item ( f . name and type index ) ; if ( n == null ) return null ; return get utf8 info ( n . member name ) ; }
public int get method handle kind ( int index ) { method handle info mhinfo = ( method handle info ) get item ( index ) ; return mhinfo . ref kind ; }
public int get dynamic bootstrap ( int index ) { dynamic info iv = ( dynamic info ) get item ( index ) ; return iv . bootstrap ; }
public int class index ( ) { return byte array . read u16bit ( get ( ) , 0 ) ; }
public int handler pc ( int nth ) { return entry . get ( nth ) . handler pc ; }
public exception table copy ( const pool new cp , map classnames ) { exception table et = new exception table ( new cp ) ; const pool src cp = const pool ; int len = size ( ) ; for ( int i = 0 ; i < len ; ++i ) { exception table entry e = ( exception table entry ) entry . get ( i ) ; int type = src cp . copy ( e . catch type , new cp , classnames ) ; et . add ( e . start pc , e . end pc , e . handler pc , type ) ; } return et ; }
public void add entry ( int start pc , int length , int name index , int descriptor index , int index ) { int size = info . length ; byte [ ] new info = new byte [ size + 10 ] ; byte array . write16bit ( table length ( ) + 1 , new info , 0 ) ; for ( int i = 2 ; i < size ; ++i ) new info [ i ] = info [ i ] ; byte array . write16bit ( start pc , new info , size ) ; byte array . write16bit ( length , new info , size + 2 ) ; byte array . write16bit ( name index , new info , size + 4 ) ; byte array . write16bit ( descriptor index , new info , size + 6 ) ; byte array . write16bit ( index , new info , size + 8 ) ; info = new info ; }
public void set name ( string new name ) { name = const pool . add utf8 info ( new name ) ; cache name = new name ; }
public exception attribute get exception attribute ( ) { attribute info info = attribute info . lookup ( attribute , exception attribute . tag ) ; return ( exception attribute ) info ; }
public int to start pc ( int line ) { int n = table length ( ) ; for ( int i = 0 ; i < n ; ++i ) if ( line == line number ( i ) ) return start pc ( i ) ; return -1 ; }
public int class index ( ) { return byte array . read u16bit ( get ( ) , 0 ) ; }
public static method signature to method signature ( string sig ) throw bad bytecode { try { return parse method sig ( sig ) ; } catch ( index out of bound exception e ) { throw error ( sig ) ; } }
protect double get domain low bound ( double p ) { return 0 ; }
public synchronize throwable get cause ( ) { return ( my cause == this ? null : my cause ) ; }
protect ct class get cache ( string classname ) { return ( ct class ) class . get ( classname ) ; }
public class path append class path ( class path cp ) { return source . append class path ( cp ) ; }
public void redirect field access ( ct field field , ct class new class , string new fieldname ) { transformer = new transform field access ( transformer , field , new class . get name ( ) , new fieldname ) ; }
public boolean subst ( a s tree new obj , a s tree old obj ) { for ( a s t list list = this ; list ! = null ; list = list . right ) if ( list . leave == old obj ) { list . leave = new obj ; return true ; } return false ; }
protect void at return stmnt ( stmnt st ) throw compile error { a s tree result = st . get left ( ) ; if ( result ! = null & & return type == ct class . void type ) { compile expr ( result ) ; if ( is2word ( expr type , array dim ) ) bytecode . add opcode ( pop2 ) ; else if ( expr type ! = void ) bytecode . add opcode ( pop ) ; result = null ; } at return stmnt2 ( result ) ; }
protect void at return stmnt ( stmnt st ) throw compile error { a s tree result = st . get left ( ) ; if ( result ! = null & & return type == ct class . void type ) { compile expr ( result ) ; if ( is2word ( expr type , array dim ) ) bytecode . add opcode ( pop2 ) ; else if ( expr type ! = void ) bytecode . add opcode ( pop ) ; result = null ; } at return stmnt2 ( result ) ; }
public a s t list parse member1 ( symbol table tbl ) throw compile error { a s t list mod = parse member mod ( ) ; declarator d ; boolean be constructor = false ; if ( lex . look ahead ( ) == identifier & & lex . look ahead ( 1 ) == ' ( ' ) { d = new declarator ( void , 0 ) ; be constructor = true ; } else d = parse formal type ( tbl ) ; if ( lex . get ( ) ! = identifier ) throw new syntax error ( lex ) ; string name ; if ( be constructor ) name = method decl . init name ; else name = lex . get string ( ) ; d . set variable ( new symbol ( name ) ) ; if ( be constructor || lex . look ahead ( ) == ' ( ' ) return parse method1 ( tbl , be constructor , mod , d ) ; return parse field ( tbl , mod , d ) ; }
public void set body ( string src ) throw can not compile exception { set body ( src , null , null ) ; }
public method info get method info ( ) { declare class . check modify ( ) ; return method info ; }
public void remove super ( session session ) { super . remove ( session , false ) ; }
public string map path ( string path ) { return null ; }
public string map path ( string path ) { return null ; }
public ct class [ ] get interface ( ) throw not find exception { return new ct class [ 0 ] ; }
public void add field ( ct field f ) throw can not compile exception { add field ( f , ( ct field . initializer ) null ) ; }
public ct class [ ] get interface ( ) throw not find exception { return new ct class [ 0 ] ; }
public final expression optimize ( expression visitor visitor , item type context item type ) { return this ; }
public int add store ( int n , ct class type ) { if ( type . be primitive ( ) ) { if ( type == ct class . boolean type || type == ct class . char type || type == ct class . byte type || type == ct class . short type || type == ct class . int type ) add istore ( n ) ; else if ( type == ct class . long type ) { add lstore ( n ) ; return 2 ; } else if ( type == ct class . float type ) add fstore ( n ) ; else if ( type == ct class . double type ) { add dstore ( n ) ; return 2 ; } else throw new runtime exception ( `` void type ? `` ) ; } else add astore ( n ) ; return 1 ; }
public string get name ( ) { if ( method info . be static initializer ( ) ) return method info . name clinit ; return declare class . get simple name ( ) ; }
public void set name ( string newname ) { declare class . check modify ( ) ; method info . set name ( newname ) ; }
public static ct method copy ( ct method src , ct class declaring , class map map ) throw can not compile exception { return new ct method ( src , declare , map ) ; }
public ct behavior where ( ) { method info mi = this method ; ct behavior [ ] cb = this class . get declared behavior ( ) ; for ( int i = cb . length - 1 ; i > = 0 ; -- i ) if ( cb [ i ] . get method info2 ( ) == mi ) return cb [ i ] ; ct constructor init = this class . get class initializer ( ) ; if ( init ! = null & & init . get method info2 ( ) == mi ) return init ; / * get declare behavior ( ) return a list of methods/constructors . * although the list be cache in a ct class object , it might be * recreate for some reason . thus , the member name and the signature * must be also check . * / for ( int i = cb . length - 1 ; i > = 0 ; -- i ) { if ( this method . get name ( ) . equal ( cb [ i ] . get method info2 ( ) . get name ( ) ) & & this method . get descriptor ( ) . equal ( cb [ i ] . get method info2 ( ) . get descriptor ( ) ) ) { return cb [ i ] ; } } throw new runtime exception ( `` fatal : not found `` ) ; }
protect void set closure delegate ( closure closure , object node ) { closure . set delegate ( this ) ; }
protect void set closure delegate ( closure closure , object node ) { closure . set delegate ( this ) ; }
public ct class get type ( ) throw not find exception { const pool cp = get const pool ( ) ; int pos = current po ; int index = iterator . u16bit at ( pos + 1 ) ; string name = cp . get class info ( index ) ; return this class . get class pool ( ) . get ct class ( name ) ; }
protect ct class get ct class ( ) throw not find exception { return this class . get class pool ( ) . get ( get class name ( ) ) ; }
public static final boolean be in ( int flag ) { return ( flags & ( out | in ) ) ! = out ; }
public static boolean be abstract ( member member ) { int modifier = member . get modifier ( ) ; return ( ( modifier & modifier . abstract ) ! = 0 ) ; }
public static void set use context class loader locally ( ) { use_context_class_loader_locally . set ( true ) ; }
public static region from name ( string region name ) { for ( region region : region . value ( ) ) { if ( region . get name ( ) . equal ( region name ) ) { return region ; } } throw new illegal argument exception ( `` can not create enum from `` + region name + `` value ! `` ) ; }
public class create class ( ) { if ( this class == null ) { class loader cl = get class loader ( ) ; synchronize ( proxy cache ) { if ( use cache ) create class2 ( cl ) ; else create class3 ( cl ) ; } } return this class ; }
public void set use write replace ( boolean use write replace ) { factory write replace = use write replace ; }
protect void set closure delegate ( closure closure , object node ) { closure . set delegate ( this ) ; }
protect void set closure delegate ( closure closure , object node ) { closure . set delegate ( this ) ; }
public long get date header ( string name ) { return this . _get http servlet request ( ) . get date header ( name ) ; }
public http servlet map get http servlet mapping ( ) { return this . _get http servlet request ( ) . get http servlet mapping ( ) ; }
public string get servlet path ( ) { return this . _get http servlet request ( ) . get servlet path ( ) ; }
public boolean be request session id valid ( ) { return this . _get http servlet request ( ) . be request session id valid ( ) ; }
public void set status ( int sc , string sm ) { this . _get http servlet response ( ) . set status ( sc , sm ) ; }
public void set strict ( strict mode strict ) { this . strict = strict ; }
public void set index meta inf ( boolean flag ) { index meta inf = flag ; }
public long get content length long ( ) { return this . request . get content length long ( ) ; }
public int get remote port ( ) { return this . request . get remote port ( ) ; }
public int get remote port ( ) { return this . request . get remote port ( ) ; }
public string get local name ( ) { return this . request . get local name ( ) ; }
public boolean be wrapper for ( servlet response wrap ) { if ( response == wrap ) { return true ; } else if ( response instanceof servlet response wrapper ) { return ( ( servlet response wrapper ) response ) . be wrapper for ( wrap ) ; } else { return false ; } }
public void set content length ( int len ) { this . response . set content length ( len ) ; }
public void set buffer size ( int size ) { this . response . set buffer size ( size ) ; }
public list < class < ? extend decoder > > get decoder ( ) { return this . decoder ; }
protect void add non match ( string builder sb , string text ) { sb . append ( text ) ; }
public void suspend ( ) { ws frame . suspend ( ) ; }
protect final void write ( string s ) throw i o exception { output . write ( s ) ; }
public void marshal ( t object , output stream output , namespace context ns context ) throw j a x b exception { marshal ( object , output , ns context , null ) ; }
public string get package name ( ) { return nav . get package name ( registry class ) ; }
public final boolean be element ( ) { return ( flag & flag_is_element ) ! =0 ; }
public void compact ( ) { byte [ ] b = new byte [ len ] ; system . arraycopy ( buf,0 , b,0 , len ) ; buf = b ; }
public structure loader get structure loader ( ) { if ( current . loader instanceof structure loader ) return ( structure loader ) current . loader ; return null ; }
public static string get prefix ( element element ) { string name = element . get tag name ( ) ; string prefix = `` `` ; if ( name . index of ( ' : ' ) > 0 ) { prefix = name . substring ( 0 , name . index of ( ' : ' ) ) ; } return prefix ; }
public structure loader get structure loader ( ) { if ( current . loader instanceof structure loader ) return ( structure loader ) current . loader ; return null ; }
public void record outer peer ( object outer peer ) { if ( assoc ! =null ) assoc . add outer ( current element , outer peer ) ; }
public static int get max level possible ( ) { return geohash utils . max_precision ; }
public void push nocheck ( e o ) { if ( data . length==size ) expand capacity ( ) ; data [ size ] = o ; next [ size ] = -1 ; size++ ; }
public static x path factory create x path factory ( boolean disable secure processing ) throw illegal state exception { try { x path factory factory = x path factory . new instance ( ) ; if ( logger . be loggable ( level . fine ) ) { logger . log ( level . fine , `` x path factory instance : { 0 } `` , factory ) ; } factory . set feature ( x m l constant . feature_secure_processing , ! be x m l security disable ( disable secure processing ) ) ; return factory ; } catch ( x path factory configuration exception ex ) { logger . log ( level . severe , null , ex ) ; throw new illegal state exception ( ex ) ; } catch ( abstract method error er ) { logger . log ( level . severe , null , er ) ; throw new illegal state exception ( message . invalid_jaxp_implementation . format ( ) , er ) ; } }
public string get option ( string option , string dft value ) { object value = get option ( option ) ; return ( value == null ) ? dft value : value . to string ( ) ; }
public number number value of ( object node ) throw jaxen exception { context context = get context ( node ) ; object result = select single node for context ( context ) ; return number function . evaluate ( result , context . get navigator ( ) ) ; }
public final void serialize ( json generator g , serializer provider provider ) throw i o exception { / * nothing to output . . . should we signal an error tho ? * chance be , this be an erroneous call . for now , let 's * not do that ; serialize a explicit null . why ? because we * can not just omit a value a json object field name may have * be write out . * / g . write null ( ) ; }
public object get user data ( string key ) { return user data . get ( key ) ; }
public string get local name ( ) { return this . local name ; }
public string to string ( ) { string prefix = get prefix ( ) ; string q name = `` `` . equal ( prefix ) ? get local name ( ) : get prefix ( ) + `` : `` + get local name ( ) ; return `` [ ( default name step ) : `` + q name + `` ] `` ; }
public boolean a boolean ( context context ) throw jaxen exception { object result = null ; if ( expr ! = null ) { result = expr . evaluate ( context ) ; } else { list node set = context . get node set ( ) ; array list list = new array list ( node set . size ( ) ) ; list . add all ( node set ) ; result = list ; } if ( result instanceof boolean ) { boolean b = ( boolean ) result ; return b . boolean value ( ) ; } if ( result instanceof list ) { return get predicate set ( ) . evaluate a boolean ( ( list ) result , context . get context support ( ) ) ; } return false ; }
protect map parse value ( string text ) { map data = new hash map ( ) ; string tokenizer s = new string tokenizer ( text , `` =\'\ `` `` , true ) ; while ( s . have more token ( ) ) { string name = get name ( s ) ; if ( s . have more token ( ) ) { string value = get value ( s ) ; data . put ( name , value ) ; } } return data ; }
public static boolean size be empty ( final object object ) { if ( object == null ) { return true ; } else if ( object instanceof collection < ? > ) { return ( ( collection < ? > ) object ) . be empty ( ) ; } else if ( object instanceof iterable < ? > ) { return iterable utils . be empty ( ( iterable < ? > ) object ) ; } else if ( object instanceof map < ? , ? > ) { return ( ( map < ? , ? > ) object ) . be empty ( ) ; } else if ( object instanceof object [ ] ) { return ( ( object [ ] ) object ) . length == 0 ; } else if ( object instanceof iterator < ? > ) { return ( ( iterator < ? > ) object ) . have next ( ) == false ; } else if ( object instanceof enumeration < ? > ) { return ( ( enumeration < ? > ) object ) . have more element ( ) == false ; } else { try { return array . get length ( object ) == 0 ; } catch ( final illegal argument exception ex ) { throw new illegal argument exception ( `` unsupported object type : `` + object . get class ( ) . get name ( ) ) ; } } }
public string translate namespace prefix to uri ( string prefix ) { return get context support ( ) . translate namespace prefix to uri ( prefix ) ; }
public string get x path ( ) { return this . xpath ; }
public boolean have next ( ) { while ( ! current sibling . have next ( ) ) { if ( ! go forward ( ) ) { return false ; } } return true ; }
public string get x path ( ) { return this . xpath ; }
public void set link warning ( resource warn warn ) { set link exception ( warn ) ; }
public void set description ( string description ) { this . description = description ; }
protect void set closure delegate ( closure closure , object node ) { closure . set delegate ( this ) ; }
public void error ( object message , object [ ] params ) { do log ( level . error , fqcn , message , params , null ) ; }
public void log ( level level , object message , throwable t ) { do log ( level , fqcn , message , null , t ) ; }
public object read resolve ( ) { return java . util . log . logger . get logger ( name ) ; }
public void set auto flush ( final boolean auto flush ) throw security exception { this . auto flush = auto flush ; if ( auto flush ) { flush ( ) ; } }
public static format step module version format step ( final boolean leave justify , final int minimum width , final int maximum width , final string precision ) { return new segment format step ( left justify , minimum width , default_truncate_beginning , maximum width , precision ) { public string get segment subject ( final ext log record record ) { return record . get source module version ( ) ; } @ override public boolean be caller information require ( ) { return true ; } public item type get item type ( ) { return item type . source_module_version ; } } ; }
public static format step mdc format step ( final string key , final boolean leave justify , final int minimum width , final int maximum width ) { return mdc format step ( key , leave justify , minimum width , default_truncate_beginning , maximum width ) ; }
public static format step level format step ( final boolean leave justify , final int minimum width , final int maximum width ) { return level format step ( left justify , minimum width , default_truncate_beginning , maximum width ) ; }
public void set step ( final format step [ ] step ) { this . step = step == null || step . length == 0 ? empty_steps : step . clone ( ) ; calculate builder length ( ) ; }
public void set address ( final inet address address ) { synchronize ( output lock ) { if ( ! this . address . equal ( address ) ) { initialize = true ; client socket factory = null ; } this . address = address ; } }
public boolean be connect ( ) { synchronize ( output lock ) { return connect ; } }
public void set port ( final int port ) { synchronize ( output lock ) { this . port = port ; initialize connection = true ; } }
public string get suffix ( ) { if ( suffix rotator == suffix rotator . empty ) { return null ; } return suffix rotator . to string ( ) ; }
public void set address ( final inet address address ) { synchronize ( output lock ) { if ( ! this . address . equal ( address ) ) { initialize = true ; client socket factory = null ; } this . address = address ; } }
public void set protocol ( final protocol type ) { synchronize ( output lock ) { this . protocol = type ; initialize connection = true ; } }
public void set hostname ( final string hostname ) throw unknown host exception { set address ( inet address . get by name ( hostname ) ) ; }
public < v > v get attachment ( string logger name , logger . attachment key < v > key ) { final logger node node = root logger . get if exists ( logger name ) ; if ( node == null ) return null ; return node . get attachment ( key ) ; }
public enumeration < string > get logger name ( ) { final array deque < iterator < logger node > > node stack = new array deque < > ( ) ; node stack . add ( collection . singleton ( root logger ) . iterator ( ) ) ; return new enumeration < string > ( ) { logger node next ; @ override public boolean have more element ( ) { if ( next ! = null ) return true ; while ( ! node stack . be empty ( ) ) { final iterator < logger node > itr = node stack . peek first ( ) ; if ( ! itr . have next ( ) ) { node stack . poll first ( ) ; } else { final logger node node = itr . next ( ) ; node stack . add last ( node . get child ( ) . iterator ( ) ) ; if ( node . have logger ( ) ) { next = node ; return true ; } } } return false ; } @ override public string next element ( ) { if ( ! have more element ( ) ) { throw new no such element exception ( ) ; } try { return next . get full name ( ) ; } finally { next = null ; } } } ; }
public static void clear ( ) { ndc . get ( ) . trim to ( 0 ) ; }
public static void clear ( ) { ndc . get ( ) . trim to ( 0 ) ; }
public executor get handoff executor ( ) { return handoff executor ; }
public int get queue size ( ) { return no_queue_limit ? -1 : current queue size of ( queue size ) ; }
public executor get handoff executor ( ) { return handoff executor ; }
public executor get handoff executor ( ) { return handoff executor ; }
public int get large pool size ( ) { return update_statistics ? peak thread count : -1 ; }
public boolean be shutdown ( ) { return be shutdown requested ( thread status ) ; }
public static executor discard executor ( ) { return discard executor . instance ; }
public static string get version string ( ) { return version_string ; }
protect boolean contain value ( transaction tx ) { return delegate . contain value ( this , tx ) ; }
public static transaction suspend any transaction ( ) { transaction manager tm = transaction manager locator . locate transaction manager ( ) ; try { return tm . suspend ( ) ; } catch ( system exception e ) { throw new runtime exception ( `` unable to suspend transaction `` , e ) ; } }
public void add provider ( user transaction provider provider ) { if ( provider == null ) throw new illegal argument exception ( `` null provider `` ) ; provider . set transaction registry ( this ) ; provider . add ( provider ) ; log . debug ( this + `` add provider `` + provider ) ; }
public static void kill container ( string jdbc url ) { synchronize ( jdbc url container cache ) { jdbc database container container = jdbc url container cache . get ( jdbc url ) ; if ( container ! = null ) { container . stop ( ) ; jdbc url container cache . remove ( jdbc url ) ; container connection . remove ( container . get container id ( ) ) ; initialize container . remove ( container . get container id ( ) ) ; } } }
public boolean add all ( collection collection ) { return add all ( size ( ) , collection ) ; }
public string get branch ( ) { return m branch ; }
public string to string ( ) { return new string buffer ( 64 ) . append ( `` [ text : `` ) . append ( get text ( ) ) . append ( `` ] `` ) . to string ( ) ; }
public void set property ( string id , object value ) { if ( property map == null ) { property map = new hash map ( ) ; } property map . put ( id , value ) ; }
public element get root element ( ) { int index = content . index of first element ( ) ; if ( index < 0 ) { throw new illegal state exception ( `` root element not set `` ) ; } return ( element ) content . get ( index ) ; }
public document add content ( int index , collection c ) { content . add all ( index , c ) ; return this ; }
public element set text ( string text ) { content . clear ( ) ; if ( text ! = null ) { add content ( new text ( text ) ) ; } return this ; }
public void set filter mask ( int mask ) { set default mask ( ) ; filter mask & = mask ; }
public void set doc type visible ( boolean visible ) { if ( visible ) { filter mask |= doctype ; } else { filter mask & = ~doctype ; } }
public document get document ( ) { object src = ( ( j d o m input source ) get input source ( ) ) . get source ( ) ; document doc = null ; if ( src instanceof document ) { doc = ( document ) src ; } return doc ; }
public document build ( org . w3c . dom . document dom document ) { document doc = factory . document ( null ) ; build tree ( dom document , doc , null , true ) ; return doc ; }
public document read ( reader reader , string system id ) throw document exception { input source source = new input source ( reader ) ; source . set system id ( system id ) ; if ( this . encode ! = null ) { source . set encoding ( this . encode ) ; } return read ( source ) ; }
public void set reuse parser ( boolean reuse parser ) { this . reuse parser = reuse parser ; this . sax parser = null ; }
public void set fast reconfigure ( boolean fast reconfigure ) { if ( this . reuse parser ) { this . fast reconfigure = fast reconfigure ; } }
public void set ignore boundary whitespace ( boolean ignore boundary white ) { this . ignore boundary white = ignore boundary white ; }
public document get partial document ( ) { return partial document ; }
public int hash code ( ) { return uri . hash code ( ) ; }
public static format get compact format ( ) { format f = new format ( ) ; f . set text mode ( text mode . normalize ) ; return f ; }
public format set omit encode ( boolean omit encode ) { this . omit encode = omit encode ; return this ; }
public j d o m locator get locator ( ) { return ( locator ! = null ) ? new j d o m locator ( locator ) : null ; }
public void set decl handler ( decl handler decl handler ) { this . decl handler = decl handler ; }
public boolean get report d t d event ( ) { return report dtd event ; }
public processing instruction set data ( string data ) { string reason = verifier . check process instruction data ( data ) ; if ( reason ! = null ) { throw new illegal data exception ( data , reason ) ; } this . raw data = data ; this . map data = parse data ( data ) ; return this ; }
public string to string ( ) { return new string buffer ( ) . append ( `` [ comment : `` ) . append ( new org . jdom . output . x m l outputter ( ) . output string ( this ) ) . append ( `` ] `` ) . to string ( ) ; }
public object clone ( ) { text text = ( text ) super . clone ( ) ; text . value = value ; return text ; }
public void set document ( document document ) { this . result = document ; this . queried = false ; }
public document get document ( ) { object src = ( ( j d o m input source ) get input source ( ) ) . get source ( ) ; document doc = null ; if ( src instanceof document ) { doc = ( document ) src ; } return doc ; }
public boolean get nlabel ( ) { return m nlabel ; }
public x m l reader get x m l reader ( ) { if ( this . xml reader == null ) { this . xml reader = new document reader ( ) ; } return this . xml reader ; }
public x m l reader get x m l reader ( ) { if ( this . xml reader == null ) { this . xml reader = new document reader ( ) ; } return this . xml reader ; }
public static boolean be x m l letter or digit ( char c ) { return ( be x m l letter ( c ) || be x m l digit ( c ) ) ; }
public string value of ( object context ) throw j d o m exception { try { current context = context ; return x path . string value of ( context ) ; } catch ( jaxen exception ex1 ) { throw new j d o m exception ( `` x path error while evaluate \ `` `` + x path . to string ( ) + `` \ `` : `` + ex1 . get message ( ) , ex1 ) ; } finally { current context = null ; } }
public string value of ( object context ) throw j d o m exception { try { current context = context ; return x path . string value of ( context ) ; } catch ( jaxen exception ex1 ) { throw new j d o m exception ( `` x path error while evaluate \ `` `` + x path . to string ( ) + `` \ `` : `` + ex1 . get message ( ) , ex1 ) ; } finally { current context = null ; } }
public element set content ( collection new content ) { content . clear and set ( new content ) ; return this ; }
public void set conformance ( string conformance ) { set text property ( prefix+ `` : conformance `` , conformance ) ; }
public void set instance i d ( string id ) { x m l util . set string value ( parent , `` st evt : instance i d `` , id ) ; }
public void set mangager variant ( string manager variant ) { x m l util . set string value ( parent , `` st ref : manager variant `` , manager variant ) ; }
public void set document i d ( string id ) { x m l util . set string value ( parent , `` st ref : document i d `` , id ) ; }
public string get image ( ) { return x m l util . get string value ( parent , `` xap g img : image `` ) ; }
public x m p schema dynamic medium add dynamic medium schema ( ) { x m p schema dynamic medium schema = new x m p schema dynamic medium ( this ) ; return ( x m p schema dynamic medium ) basic add schema ( schema ) ; }
public void merge ( x m p metadata metadata ) throw i o exception { list < x m p schema > schemas2 = metadata . get schemas ( ) ; for ( iterator < x m p schema > iterator = schemas2 . iterator ( ) ; iterator . have next ( ) ; ) { x m p schema schema2 = iterator . next ( ) ; x m p schema schema1 = get schema by class ( schema2 . get class ( ) ) ; if ( schema1 == null ) { element rdf = get r d f element ( ) ; rdf . append child ( xmp document . import node ( schema2 . get element ( ) , true ) ) ; } else { schema1 . merge ( schema2 ) ; } } }
public void save ( string file ) throw exception { x m l util . save ( xmp document , file , encode ) ; }
public void merge ( x m p metadata metadata ) throw i o exception { list < x m p schema > schemas2 = metadata . get schemas ( ) ; for ( iterator < x m p schema > iterator = schemas2 . iterator ( ) ; iterator . have next ( ) ; ) { x m p schema schema2 = iterator . next ( ) ; x m p schema schema1 = get schema by class ( schema2 . get class ( ) ) ; if ( schema1 == null ) { element rdf = get r d f element ( ) ; rdf . append child ( xmp document . import node ( schema2 . get element ( ) , true ) ) ; } else { schema1 . merge ( schema2 ) ; } } }
public x m p schema basic job ticket add basic job ticket schema ( ) { x m p schema basic job ticket schema = new x m p schema basic job ticket ( this ) ; return ( x m p schema basic job ticket ) basic add schema ( schema ) ; }
public void save ( string file ) throw exception { x m l util . save ( xmp document , file , encode ) ; }
public list < string > get bag list ( string bag name ) { list < string > retval = null ; node list node = schema . get element by tag name ( bag name ) ; if ( node . get length ( ) > 0 ) { element contributor = ( element ) node . item ( 0 ) ; node list bag list = contributor . get element by tag name ( `` rdf : bag `` ) ; if ( bag list . get length ( ) > 0 ) { element bag = ( element ) bag list . item ( 0 ) ; retval = new array list < string > ( ) ; node list item = bag . get element by tag name ( `` rdf : li `` ) ; for ( int i = 0 ; i < item . get length ( ) ; i++ ) { element li = ( element ) item . item ( i ) ; retval . add ( x m l util . get string value ( li ) ) ; } retval = collection . unmodifiable list ( retval ) ; } } return retval ; }
public void add advisory ( string advisory ) { add bag value ( prefix + `` : advisory `` , advisory ) ; }
public list < string > get identifier ( ) { return get bag list ( prefix + `` : identifier `` ) ; }
public void set modify date ( calendar date ) { set date property ( prefix + `` : modify date `` , date ) ; }
public calendar get metadata date ( ) throw i o exception { return get date property ( prefix + `` : metadata date `` ) ; }
public void set thumbnail ( string language , thumbnail thumbnail ) { set thumbnail property ( prefix + `` : thumbnail `` , language , thumbnail ) ; }
public thumbnail get thumbnail ( string language ) { return get thumbnail property ( prefix + `` : thumbnail `` , language ) ; }
public void set description ( string language , string description ) { set language property ( prefix + `` : description `` , language , description ) ; }
public void add language ( string language ) { add bag value ( prefix + `` : language `` , language ) ; }
public list < string > get language ( ) { return get bag list ( prefix + `` : language `` ) ; }
public list < string > get right language ( ) { return get language property language ( prefix + `` : right `` ) ; }
public void add subject ( string subject ) { add bag value ( prefix + `` : subject `` , subject ) ; }
public list < string > get language ( ) { return get bag list ( prefix + `` : language `` ) ; }
public void set title ( string language , string title ) { set language property ( prefix + `` : title `` , language , title ) ; }
public void set title ( string language , string title ) { set language property ( prefix + `` : title `` , language , title ) ; }
public void set ci adr ctry ( string country ) { set text property ( prefix + `` : ci adr ctry `` , country ) ; }
public void set manager ( string manager ) { set text property ( prefix + `` : manager `` , manager ) ; }
public void add history ( resource event event ) { add sequence value ( prefix + `` : history `` , event ) ; }
public string get p d f version ( ) { return get text property ( prefix + `` : p d f version `` ) ; }
public list < string > get supplemental category ( ) { return get bag list ( prefix + `` : supplemental category `` ) ; }
public list < string > get owner ( ) { return get bag list ( prefix + `` : owner `` ) ; }
public void set usage term ( string term ) { set language property ( prefix + `` : usage term `` , null , term ) ; }
protect executor service get executor service ( ) { return executor service ; }
public iterable < writer interceptor > get writer interceptor ( ) { return writer interceptor ; }
public static string redirect_error_determining_location ( ) { return localizer . localize ( localizable r e d i r e c t_ e r r o r_ d e t e r m i n i n g_ l o c a t i o n ( ) ) ; }
public static string closed_by_client_while_receiving ( ) { return localizer . localize ( localizable c l o s e d_ b y_ c l i e n t_ w h i l e_ r e c e i v i n g ( ) ) ; }
public static string http_invalid_content_length ( ) { return localizer . localize ( localizable h t t p_ i n v a l i d_ c o n t e n t_ l e n g t h ( ) ) ; }
public static string http_trailer_header_overflow ( ) { return localizer . localize ( localizable h t t p_ t r a i l e r_ h e a d e r_ o v e r f l o w ( ) ) ; }
public static string read_listener_set_only_once ( ) { return localizer . localize ( localizable r e a d_ l i s t e n e r_ s e t_ o n l y_ o n c e ( ) ) ; }
public static string http_unexpected_chunk_header ( ) { return localizer . localize ( localizable h t t p_ u n e x p e c t e d_ c h u n k_ h e a d e r ( ) ) ; }
public static string error_listener_close ( object arg0 ) { return localizer . localize ( localizable e r r o r_ l i s t e n e r_ c l o s e ( arg0 ) ) ; }
public static string error_service_locator_provider_instance_response ( object arg0 ) { return localizer . localize ( localizable e r r o r_ s e r v i c e_ l o c a t o r_ p r o v i d e r_ i n s t a n c e_ r e s p o n s e ( arg0 ) ) ; }
public static string null_keystore ( ) { return localizer . localize ( localizable n u l l_ k e y s t o r e ( ) ) ; }
public static string client_uri_builder_null ( ) { return localizer . localize ( localizable c l i e n t_ u r i_ b u i l d e r_ n u l l ( ) ) ; }
public static combine medium type create ( medium type client type , effective medium type server type ) { if ( ! client type . be compatible ( server type . get medium type ( ) ) ) { return no_match ; } final medium type strip client type = medium type . strip quality params ( client type ) ; final medium type strip server type = medium type . strip quality params ( server type . get medium type ( ) ) ; return new combine medium type ( medium type . most specific ( stripped client type , strip server type ) , medium type . get quality ( client type ) , quality source medium type . get quality source ( server type . get medium type ( ) ) , match wildcards ( client type , server type ) ) ; }
public static void warning ( final object source , final string message ) { error ( source , message , severity . warn ) ; }
public boolean fatal issue find ( ) { for ( resource model issue issue : get issue list ( ) ) { if ( issue . get severity ( ) == severity . fatal ) { return true ; } } return false ; }
public static void warning ( final object source , final string message ) { error ( source , message , severity . warn ) ; }
public boolean equal ( object that ) { return super . equal ( that ) ; }
public void configure ( ) { install ( instal . to array ( new abstract binder [ ] { } ) ) ; }
public void configure ( ) { install ( instal . to array ( new abstract binder [ ] { } ) ) ; }
public d analyze with ( string analyzer ) { this . analyzer = analyzer ; return ( d ) this ; }
public alias binding in ( string scope ) { this . scope = optional . of ( scope ) ; return this ; }
public void set require type ( type require type ) { this . require type = require type ; }
public void bind class ( collection < class < ? > > class , boolean bind resource ) { list < binder > binder = class . stream ( ) . map ( clazz - > create class binder ( clazz , bind resource ) ) . collect ( collector . to list ( ) ) ; injection manager . register ( composite binder . wrap ( binder ) ) ; }
public static string warnings_detected ( object arg0 ) { return localizer . localize ( localizable w a r n i n g s_ d e t e c t e d ( arg0 ) ) ; }
public static string uri_component_encoded_octet_invalid_digit ( object arg0 , object arg1 ) { return localizer . localize ( localizable u r i_ c o m p o n e n t_ e n c o d e d_ o c t e t_ i n v a l i d_ d i g i t ( arg0 , arg1 ) ) ; }
public static string error_template_parser_illegal_char_part_of_name ( object arg0 , object arg1 , object arg2 ) { return localizer . localize ( localizable e r r o r_ t e m p l a t e_ p a r s e r_ i l l e g a l_ c h a r_ p a r t_ o f_ n a m e ( arg0 , arg1 , arg2 ) ) ; }
public static string error_processing_response_from_already_mapped_exception ( ) { return localizer . localize ( localizable e r r o r_ p r o c e s s i n g_ r e s p o n s e_ f r o m_ a l r e a d y_ m a p p e d_ e x c e p t i o n ( ) ) ; }
public static string error_provider_and_resource_constrained_to_ignored ( object arg0 ) { return localizer . localize ( localizable e r r o r_ p r o v i d e r_ a n d_ r e s o u r c e_ c o n s t r a i n e d_ t o_ i g n o r e d ( arg0 ) ) ; }
public static string injection_error_local_class_not_supported ( object arg0 ) { return localizer . localize ( localizable i n j e c t i o n_ e r r o r_ l o c a l_ c l a s s_ n o t_ s u p p o r t e d ( arg0 ) ) ; }
public static string unable_to_parse_header_value ( object arg0 , object arg1 ) { return localizer . localize ( localizable u n a b l e_ t o_ p a r s e_ h e a d e r_ v a l u e ( arg0 , arg1 ) ) ; }
public static string error_interceptor_reader_proceed ( ) { return localizer . localize ( localizable e r r o r_ i n t e r c e p t o r_ r e a d e r_ p r o c e e d ( ) ) ; }
public static string http_header_no_end_separator ( object arg0 ) { return localizer . localize ( localizable h t t p_ h e a d e r_ n o_ e n d_ s e p a r a t o r ( arg0 ) ) ; }
public static string mbw_trying_to_close_stream ( object arg0 ) { return localizer . localize ( localizable m b w_ t r y i n g_ t o_ c l o s e_ s t r e a m ( arg0 ) ) ; }
public static string error_service_locator_provider_instance_feature_context ( object arg0 ) { return localizer . localize ( localizable e r r o r_ s e r v i c e_ l o c a t o r_ p r o v i d e r_ i n s t a n c e_ f e a t u r e_ c o n t e x t ( arg0 ) ) ; }
public combine medium type get consumes ( ) { return consumes ; }
public static < t > service finder < t > find ( final class < t > service ) throw service configuration error { return find ( service , _get context class loader ( ) , false ) ; }
public iterator < t > iterator ( ) { return service iterator provider . get instance ( ) . create iterator ( service class , service name , class loader , ignore on class not find ) ; }
public string e2e ( ) { return common ( ) + `` e2e `` ; }
public static class type pair of ( class < ? > raw class , type type ) { return new class type pair ( raw class , type ) ; }
public static < e > set < e > set union view ( final set < ? extend e > set1 , final set < ? extend e > set2 ) { check not null ( set1 , `` set1 `` ) ; check not null ( set2 , `` set2 `` ) ; return new abstract set < e > ( ) { @ override public iterator < e > iterator ( ) { return get union ( set1 , set2 ) . iterator ( ) ; } @ override public int size ( ) { return get union ( set1 , set2 ) . size ( ) ; } private set < e > get union ( set < ? extend e > set1 , set < ? extend e > set2 ) { hash set < e > hash set = new hash set < > ( set1 ) ; hash set . add all ( set2 ) ; return hash set ; } } ; }
public static string collection ( collection < ? > collection ) { if ( collection == null ) return null_string ; return array ( collection . to array ( new object [ collection . size ( ) ] ) ) ; }
public static < t > t get value ( final map < string , ? > property , final string key , final t default value ) { return property helper . get value ( property , key , default value , null ) ; }
public static list < class type pair > get type argument and class ( final type type ) throw illegal argument exception { final type [ ] type = get type argument ( type ) ; if ( type == null ) { return collection . empty list ( ) ; } return array . stream ( type ) . map ( type1 - > class type pair . of ( erasure ( type1 ) , type1 ) ) . collect ( collector . to list ( ) ) ; }
public static < t > privilege action < class < t > > class for name p a ( final string name ) { return class for name p a ( name , get context class loader ( ) ) ; }
public static string [ ] split a array ( string p arg , string p escape , string p delimiter ) { if ( p arg ! = null ) { list < string > element = split ( p arg , p escape , p delimiter ) ; return element . to array ( new string [ element . size ( ) ] ) ; } else { return new string [ 0 ] ; } }
public static void write to a string ( string s , output stream out , medium type type ) throw i o exception { reader writer . write to a string ( s , out , type ) ; }
public locale get language ( ) { return single header ( http header . content_language , new function < string , locale > ( ) { @ override public locale apply ( string input ) { try { return new language tag ( input ) . get a locale ( ) ; } catch ( parse exception e ) { throw new process exception ( e ) ; } } } , false ) ; }
public void set entity stream ( input stream input ) { this . entity content . set content ( input , false ) ; }
public static combine medium type create ( medium type client type , effective medium type server type ) { if ( ! client type . be compatible ( server type . get medium type ( ) ) ) { return no_match ; } final medium type strip client type = medium type . strip quality params ( client type ) ; final medium type strip server type = medium type . strip quality params ( server type . get medium type ( ) ) ; return new combine medium type ( medium type . most specific ( stripped client type , strip server type ) , medium type . get quality ( client type ) , quality source medium type . get quality source ( server type . get medium type ( ) ) , match wildcards ( client type , server type ) ) ; }
public type get entity type ( ) { return entity type == null ? null : entity type . get type ( ) ; }
public static combine medium type create ( medium type client type , effective medium type server type ) { if ( ! client type . be compatible ( server type . get medium type ( ) ) ) { return no_match ; } final medium type strip client type = medium type . strip quality params ( client type ) ; final medium type strip server type = medium type . strip quality params ( server type . get medium type ( ) ) ; return new combine medium type ( medium type . most specific ( stripped client type , strip server type ) , medium type . get quality ( client type ) , quality source medium type . get quality source ( server type . get medium type ( ) ) , match wildcards ( client type , server type ) ) ; }
public void clear ( ) { this . class . clear ( ) ; this . instance . clear ( ) ; this . model . clear ( ) ; }
public instance reference current ( ) throw illegal state exception { return current ( ) . get reference ( ) ; }
public mono < handler result > apply exception handler ( throwable failure ) { return ( this . exception handler ! = null ? this . exception handler . apply ( failure ) : mono . error ( failure ) ) ; }
public char next ( ) { if ( ! have next ( ) ) { throw new no such element exception ( ) ; } return s . char at ( ++pos ) ; }
public final list < string > get template variable ( ) { return template variable ; }
public final int get number of regex group ( ) { if ( group count . be empty ( ) ) { return 0 ; } else { int [ ] group index = get group index ( ) ; return group index [ group index . length - 1 ] + skip group ; } }
public date get modification date ( ) { return modification date ; }
public static boolean contain white space ( string s ) { for ( char c : s . to char array ( ) ) { if ( be white space ( c ) ) { return true ; } } return false ; }
public static list < medium type > create from ( string [ ] medium type ) { list < medium type > result = new array list < medium type > ( ) ; try { for ( string medium type : medium type ) { http header reader . read medium type ( result , medium type ) ; } } catch ( parse exception ex ) { throw new illegal argument exception ( ex ) ; } collection . sort ( result , partial_order_comparator ) ; return collection . unmodifiable list ( result ) ; }
public static privilege action set accessible method p a ( final method m ) { if ( modifier . be public ( m . get modifier ( ) ) ) { return no op privilege a c t i o n ; } return new privilege action < object > ( ) { @ override public object run ( ) { if ( ! m . be accessible ( ) ) { m . set accessible ( true ) ; } return m ; } } ; }
public static class [ ] get parameterized class argument ( declare class interface pair p ) { if ( p . generic interface instanceof parameterized type ) { parameterized type pt = ( parameterized type ) p . generic interface ; type [ ] a = pt . get actual type argument ( ) ; class [ ] ca = new class [ a . length ] ; for ( int i = 0 ; i < a . length ; i++ ) { type a = a [ i ] ; if ( a instanceof class ) { cas [ i ] = ( class ) a ; } else if ( a instanceof parameterized type ) { pt = ( parameterized type ) a ; ca [ i ] = ( class ) pt . get raw type ( ) ; } else if ( a instanceof type variable ) { class type pair ctp = resolve type variable ( p . concrete class , p . declare class , ( type variable ) a ) ; cas [ i ] = ( ctp ! = null ) ? ctp . c : object . class ; } } return ca ; } else { return null ; } }
public static string error_subres_method_uri_path_invalid ( object arg0 , object arg1 ) { return localizer . localize ( localizable e r r o r_ s u b r e s_ m e t h o d_ u r i_ p a t h_ i n v a l i d ( arg0 , arg1 ) ) ; }
public static string exception_invoking_resource_method ( ) { return localizer . localize ( localizable e x c e p t i o n_ i n v o k i n g_ r e s o u r c e_ m e t h o d ( ) ) ; }
public static string error_unmarshalling_jaxb ( object arg0 ) { return localizer . localize ( localizable e r r o r_ u n m a r s h a l l i n g_ j a x b ( arg0 ) ) ; }
public string get name ( ) { return name ; }
public string get name ( ) { return name ; }
public int hash code ( ) { int hash = super . hash code ( ) ; hash = 59 * hash + ( this . comment ! = null ? this . comment . hash code ( ) : 0 ) ; hash = 59 * hash + this . max age ; hash = 59 * hash + ( this . secure ? 1 : 0 ) ; return hash ; }
public static entity tag value of ( string value ) throw illegal argument exception { return delegate . from string ( value ) ; }
public boolean equal ( object obj ) { if ( obj == null ) return false ; if ( ! ( obj instanceof medium type ) ) return false ; medium type other = ( medium type ) obj ; return ( this . type . equal ignore case ( other . type ) & & this . subtype . equal ignore case ( other . subtype ) & & this . parameter . equal ( other . parameter ) ) ; }
protect string get invocation description ( method invocation invocation ) { return `` method ' `` + invocation . get method ( ) . get name ( ) + `` ' of class [ `` + invocation . get this ( ) . get class ( ) . get name ( ) + `` ] `` ; }
public static set < string > get filtering scope ( final annotation [ ] annotation ) { return get filtering scope ( annotation , true ) ; }
public static set < string > get filtering scope ( final annotation [ ] annotation ) { return get filtering scope ( annotation , true ) ; }
public this set default view ( class < ? > view ) { _default read view = _default write view = view ; return _this ( ) ; }
protect void introspect ( object o ) { _introspector . introspect ( o . get class ( ) ) ; }
protect void introspect ( object o ) { _introspector . introspect ( o . get class ( ) ) ; }
public void add ( http field field ) { if ( field == null ) return ; enumeration < string > e = field . get field name ( ) ; while ( e . have more element ( ) ) { string name = e . next element ( ) ; enumeration < string > value = field . get value ( name ) ; while ( value . have more element ( ) ) add ( name , value . next element ( ) ) ; } }
public void add ( http field field ) { if ( field == null ) return ; enumeration < string > e = field . get field name ( ) ; while ( e . have more element ( ) ) { string name = e . next element ( ) ; enumeration < string > value = field . get value ( name ) ; while ( value . have more element ( ) ) add ( name , value . next element ( ) ) ; } }
public static void format cookie date ( string builder buf , long date ) { __date generator . get ( ) . do format cookie date ( buf , date ) ; }
public byte buffer to byte buffer ( ) { byte buffer combine buffer = take byte buffer ( ) ; _buffers . add ( combine buffer ) ; return combine buffer ; }
public void set reuse address ( boolean reuse address ) { this . reuse address = reuse address ; }
public boolean send ( socket address address , byte buffer . . . buffer ) throw i o exception { boolean flush all = true ; long flush = 0 ; try { if ( log . be debug enable ( ) ) log . debug ( `` flush { } buffer ( s ) to { } `` , buffer . length , address ) ; for ( byte buffer buffer : buffer ) { int send = get channel ( ) . send ( buffer , address ) ; if ( send == 0 ) { flush all = false ; break ; } flush += sent ; } if ( log . be debug enable ( ) ) log . debug ( `` flush { } byte ( s ) , all flush ? { } - { } `` , flush , flush all , this ) ; } catch ( i o exception e ) { throw new eof exception ( e ) ; } if ( flush > 0 ) not idle ( ) ; return flush all ; }
public final expression optimize ( expression visitor visitor , item type context item type ) { return this ; }
protect void set closure delegate ( closure closure , object node ) { closure . set delegate ( this ) ; }
public void log ( string msg ) { get servlet context ( ) . log ( get servlet name ( ) + `` : `` + msg ) ; }
public long get size ( object value , class < ? > type , type generic type , annotation [ ] annotation , medium type medium type ) { / * in general figuring output size require actual writing ; usually not * worth it to write everything twice . * / return -1 ; }
public push builder new push builder ( ) { return this . _get http servlet request ( ) . new push builder ( ) ; }
protect void set closure delegate ( closure closure , object node ) { closure . set delegate ( this ) ; }
protect void set closure delegate ( closure closure , object node ) { closure . set delegate ( this ) ; }
public void log ( string msg ) { get servlet context ( ) . log ( get servlet name ( ) + `` : `` + msg ) ; }
public list < class < ? extend encoder > > get encoders ( ) { return this . encoders ; }
public long get max output buffer size ( ) { return max output buffer size ; }
protect void do response header ( http servlet response response , resource resource , string mime type ) { if ( mime type ! =null ) response . set content type ( mime type ) ; long length=resource . length ( ) ; if ( response instanceof response ) { http field field = ( ( response ) response ) . get http field ( ) ; if ( length > 0 ) ( ( response ) response ) . set long content length ( length ) ; if ( _cache control ! =null ) field . put ( http header . cache_control , _cache control ) ; } else { if ( length > integer . max_value ) response . set header ( http header . content_length . a string ( ) , long . to string ( length ) ) ; else if ( length > 0 ) response . set content length ( ( int ) length ) ; if ( _cache control ! =null ) response . set header ( http header . cache_control . a string ( ) , _cache control ) ; } }
public void set min async content length ( int min async content length ) { _min async content length = min async content length ; }
public void include ( string pattern ) { _set . include ( pattern tuple . from ( pattern ) ) ; }
public void include ( string connector name , string address pattern , path spec path spec ) { _set . include ( new pattern tuple ( connector name , inet address pattern . from ( address pattern ) , path spec ) ) ; }
public void set worker name ( string worker name ) { if ( be run ( ) ) throw new illegal state exception ( get state ( ) ) ; if ( worker name == null ) _worker name = `` `` ; else { if ( worker name . contains ( `` . `` ) ) throw new illegal argument exception ( `` name can not contain ' . ' '' ) ; _worker name = worker name ; } }
protect void next protocol ( connector connector , end point end point , byte buffer buffer ) throw illegal state exception { string next protocol = find next protocol ( connector ) ; if ( log . be debug enable ( ) ) log . debug ( `` detector { } detection unsuccessful , find ' { } ' a the next protocol to upgrade to `` , get protocol ( ) , next protocol ) ; if ( next protocol == null ) throw new illegal state exception ( `` can not find protocol follow ' `` + get protocol ( ) + `` ' in connector 's protocol list `` + connector . get protocol ( ) + `` for `` + end point ) ; upgrade to connection factory ( connector . get connection factory ( next protocol ) , connector , end point ) ; }
protect boolean check expiry ( long time ) { if ( _max idle m > 0 & & _last access > 0 & & _last accessed + _max idle m < time ) return true ; return false ; }
public boolean be row id reserve ( ) { if ( _db name == null ) throw new illegal state exception ( `` db adaptor miss metadata `` ) ; return ( _db name ! = null & & _db name . start with ( `` oracle `` ) ) ; }
public void set session id resolver ( web session id resolver session id resolver ) { assert . not null ( session id resolver , `` web session id resolver be require `` ) ; this . session id resolver = session id resolver ; }
public void set prefer proxied for address ( boolean prefer proxied for address ) { _prefer proxied for address = prefer proxied for address ; }
public void add include method ( string . . . method ) { for ( string m : method ) { _methods . include ( m ) ; } }
public void add include mime type ( string . . . type ) { for ( string t : type ) { _mime type . include ( string util . csv split ( t ) ) ; } }
public void set include method list ( string csv method ) { set include method ( string util . csv split ( csv method ) ) ; }
public object get lazy match ( string addr ) { if ( addr == null ) return lazy list . get list ( super . entry set ( ) ) ; object entry = null ; for ( map . entry < string , type > entry : super . entry set ( ) ) { if ( _patterns . get ( entry . get key ( ) ) . match ( addr ) ) { entry = lazy list . add ( entry , entry ) ; } } return entry ; }
public void set response header size ( int response header size ) { _response header size = response header size ; }
public class < ? extend security handler > get default security handler class ( ) { return _default security handler class ; }
public cache chain new cache chain ( list < filter holder > filter , servlet holder servlet holder ) { return new cache chain ( filter , servlet holder ) ; }
public boolean compare and set ( int expect hi , int hi , int expect lo , int lo ) { long encode = encode ( expect hi , expect lo ) ; long update = encode ( hi , lo ) ; return compare and set ( encoded , update ) ; }
public static void append ( byte buffer to , byte [ ] b , int off , int len ) throw buffer overflow exception { int po = flip to fill ( to ) ; try { to . put ( b , off , len ) ; } finally { flip to flush ( to , po ) ; } }
protect byte buffer on read ( byte [ ] buffer , int offset , int length ) { if ( length < = 0 ) return buffer util . empty_buffer ; return byte buffer . wrap ( buffer , offset , length ) ; }
public static byte buffer to buffer ( byte [ ] array ) { if ( array == null ) return empty_buffer ; return to buffer ( array , 0 , array . length ) ; }
public static boolean be empty ( object list ) { if ( list == null ) return true ; if ( list instanceof list ) return ( ( list < ? > ) list ) . be empty ( ) ; return false ; }
public int hash code ( ) { return system . identity hash code ( subject ) ; }
public list < v > put ( string name , v value ) { if ( value == null ) { return super . put ( name , null ) ; } list < v > vals = new array list < > ( ) ; vals . add ( value ) ; return put ( name , vals ) ; }
public boolean be same ( resource resource ) { return equal ( resource ) ; }
protect key store get key store ( string store path , string store type , string store provider , string store password ) throw exception { return certificate utils . get key store ( resource . new resource ( store path ) , store type , store provider , store password ) ; }
public static x509 certificate [ ] get cert chain ( s s l session ssl session ) { return get x509 cert chain ( null , ssl session ) ; }
public void set idle timeout ( long idle time , time unit idle time unit ) { if ( be run ( ) ) throw new illegal state exception ( ) ; _idle time = idle time ; _idle time unit = idle time unit ; }
public synchronize void set stop at shutdown ( boolean stop ) { if ( stop ) { if ( ! stop at shutdown & & be start ( ) & & ! shutdown thread . be register ( this ) ) shutdown thread . register ( this ) ; } else shutdown thread . deregister ( this ) ; stop at shutdown = stop ; }
public int get max ( ) { return max ; }
public object get lazy match ( string host ) { if ( host == null ) return lazy list . get list ( super . entry set ( ) ) ; int idx = 0 ; string domain = host . trim ( ) ; hash set < string > domains = new hash set < string > ( ) ; do { domain . add ( domain ) ; if ( ( idx = domain . index of ( ' . ' ) ) > 0 ) { domain = domain . substring ( idx + 1 ) ; } } while ( idx > 0 ) ; object entry = null ; for ( map . entry < string , type > entry : super . entry set ( ) ) { if ( domain . contains ( entry . get key ( ) ) ) { entry = lazy list . add ( entry , entry ) ; } } return entry ; }
public static void check argument ( boolean expression , object error message ) { if ( ! expression ) { throw new illegal argument exception ( string . value of ( error message ) ) ; } }
public static void have length ( string text , string message ) { if ( ! string . have length ( text ) ) { throw new illegal argument exception ( message ) ; } }
public static void not empty ( object [ ] array , string message ) { if ( object utils . be empty ( array ) ) { throw new illegal argument exception ( message ) ; } }
public static boolean a boolean ( object object ) { return object ! = null ; }
public static boolean be compatible with throw clause ( throwable ex , class [ ] declare exception ) { if ( ! be checked exception ( ex ) ) { return true ; } if ( declared exception ! = null ) { int i = 0 ; while ( i < declared exception . length ) { if ( declared exception [ i ] . be assignable from ( ex . get class ( ) ) ) { return true ; } i++ ; } } return false ; }
public static < k > k [ ] [ ] new big array ( final k [ ] [ ] prototype , final long length ) { return ( k [ ] [ ] ) new big array ( prototype . get class ( ) . get component type ( ) , length ) ; }
public static char [ ] to primitive ( character [ ] array , char value for null ) { if ( array == null ) { return null ; } else if ( array . length == 0 ) { return empty_char_array ; } final char [ ] result = new char [ array . length ] ; for ( int i = 0 ; i < array . length ; i++ ) { character b = array [ i ] ; result [ i ] = ( b == null ? value for null : b . char value ( ) ) ; } return result ; }
public static string identity to string ( object obj ) { if ( obj == null ) { return empty_string ; } return obj . get class ( ) . get name ( ) + `` @ `` + get identity hex string ( obj ) ; }
public static boolean start with ignore case ( string str , string prefix ) { if ( str == null || prefix == null ) { return false ; } if ( str . start with ( prefix ) ) { return true ; } if ( str . length ( ) < prefix . length ( ) ) { return false ; } string lc str = str . substring ( 0 , prefix . length ( ) ) . to lower case ( ) ; string lc prefix = prefix . to lower case ( ) ; return lc str . equal ( lc prefix ) ; }
public static string remove path ( final string filepath , final char file separator char ) { final int index = filepath . last index of ( file separator char ) ; if ( -1 == index ) { return filepath ; } return filepath . substring ( index + 1 ) ; }
public static class < ? > [ ] to class array ( collection < class < ? > > collection ) { if ( collection == null ) { return null ; } return collection . to array ( new class < ? > [ collection . size ( ) ] ) ; }
public string get description ( ) { return description ; }
public function get function ( ) { return function ; }
public long get long ( long offset ) { bound check ( offset , 8 ) ; return super . get long ( offset ) ; }
public short get short ( long offset ) { bound check ( offset , 2 ) ; return super . get short ( offset ) ; }
public float get float ( long offset ) { bound check ( offset , 4 ) ; return super . get float ( offset ) ; }
public byte get byte ( long offset ) { return native . get byte ( this , this . peer , offset ) ; }
public byte [ ] get byte array ( long offset , int array size ) { byte [ ] buf = new byte [ array size ] ; read ( offset , buf , 0 , array size ) ; return buf ; }
public float [ ] get float array ( long offset , int array size ) { float [ ] buf = new float [ array size ] ; read ( offset , buf , 0 , array size ) ; return buf ; }
public method get method ( string class name ) throw class not find exception { class < ? > clazz = get class ( class name ) ; method [ ] method = clazz . get declare method ( ) ; for ( method m : method ) { int modifier = m . get modifier ( ) ; if ( modifier . be public ( modifier ) & & modifier . be static ( modifier ) ) { string name = m . get name ( ) ; if ( ! name . start with ( `` _ `` ) & & ! m . get name ( ) . equal ( `` main `` ) ) { return m ; } } } return null ; }
public int size ( ) { ensure allocate ( ) ; return this . size ; }
public void clear ( ) { ensure allocate ( ) ; memory . clear ( size ( ) ) ; }
protect collection < string > get all to string ( ) { final set < resource > all resource = get all resource ( ) ; final array list < string > result = new array list < string > ( all resource . size ( ) ) ; for ( resource r : all resource ) { result . add ( r . to string ( ) ) ; } return result ; }
public void move ( point screen location ) { if ( origin == null ) { origin = screen location ; } drag image . set location ( screen location . x , screen location . y ) ; }
public static void set x attr ( string path , string name , string value ) throw i o exception { set x attr ( path , name , value , native . get default string encoding ( ) ) ; }
public static i o service get matching service ( c f dictionary ref match dictionary ) { int master port = get master port ( ) ; i o service service = io . i o service get matching service ( master port , match dictionary ) ; sys . mach_port_deallocate ( sys . mach_task_self ( ) , master port ) ; return service ; }
public static i o service get matching service ( c f dictionary ref match dictionary ) { int master port = get master port ( ) ; i o service service = io . i o service get matching service ( master port , match dictionary ) ; sys . mach_port_deallocate ( sys . mach_task_self ( ) , master port ) ; return service ; }
public pointer by reference get i dispatch pointer ( ) { return p dispatch ; }
public excepinfo get excep info ( ) { return p excep info ; }
protect void create class name ( string name ) { this . replace variable ( `` classname `` , name ) ; }
public typekind get type info type ( int index ) { typekind . by reference typekind = new typekind . by reference ( ) ; hresult hr = this . typelib . get type info type ( new uint ( index ) , typekind ) ; c o m utils . check r c ( hr ) ; return typekind ; }
public funcdesc get func desc ( int index ) { pointer by reference pp func desc = new pointer by reference ( ) ; hresult hr = this . type info . get func desc ( new uint ( index ) , pp func desc ) ; c o m utils . check r c ( hr ) ; return new funcdesc ( pp func desc . get value ( ) ) ; }
public i type lib get typelib ( ) { return typelib ; }
public static byte [ ] crypt protect data ( byte [ ] data ) { return crypt protect data ( data , 0 ) ; }
public static group [ ] get user local group ( string user name ) { return get user local group ( user name , null ) ; }
public static guid get g u i d from string ( string guid string ) { guid lpiid = new guid ( ) ; hresult hr = ole32 . instance . i i d from string ( guid string , lpiid ) ; if ( ! hr . equal ( w32 error . s_ok ) ) { throw new runtime exception ( hr . to string ( ) ) ; } return lpiid ; }
public static void set phone book entry ( string entry name , rasentry . by reference ra entry ) throw ras32 exception { synchronize ( phone book mutex ) { int err = rasapi32 . instance . ra set entry property ( null , entry name , ras entry , ras entry . size ( ) , null , 0 ) ; if ( err ! = win error . error_success ) throw new ras32 exception ( err ) ; } }
public service_status_process query status ( ) { int by reference size = new int by reference ( ) ; advapi32 . instance . query service status ex ( _handle , sc_status_type . sc_status_process_info , null , 0 , size ) ; service_status_process status = new service_status_process ( size . get value ( ) ) ; if ( ! advapi32 . instance . query service status ex ( _handle , sc_status_type . sc_status_process_info , status , status . size ( ) , size ) ) { throw new win32 exception ( kernel32 . instance . get last error ( ) ) ; } return status ; }
public void open ( int permission ) { close ( ) ; _handle = advapi32 . instance . open s c manager ( _machine name , _database name , permission ) ; if ( _handle == null ) { throw new win32 exception ( kernel32 . instance . get last error ( ) ) ; } }
public void open ( int permission ) { close ( ) ; _handle = advapi32 . instance . open s c manager ( _machine name , _database name , permission ) ; if ( _handle == null ) { throw new win32 exception ( kernel32 . instance . get last error ( ) ) ; } }
public static memory evt render ( evt_handle context , evt_handle fragment , int flag , int by reference property count ) { boolean result ; int by reference buff use = new int by reference ( ) ; result = wevtapi . instance . evt render ( context , fragment , flag , 0 , null , buff use , property count ) ; int error code = kernel32 . instance . get last error ( ) ; if ( ( ! result ) & & error code ! = kernel32 . error_insufficient_buffer ) { throw new win32 exception ( error code ) ; } memory mem = new memory ( buff use . get value ( ) ) ; result = wevtapi . instance . evt render ( context , fragment , flag , ( int ) mem . size ( ) , mem , buff use , property count ) ; if ( ! result ) { throw new win32 exception ( kernel32 . instance . get last error ( ) ) ; } return mem ; }
public calendar to calendar ( locale locale ) { if ( locale == null ) { locale = locale . get default ( ) ; } date time zone zone = get zone ( ) ; calendar cal = calendar . get instance ( zone . to time zone ( ) , locale ) ; cal . set time ( to date ( ) ) ; return cal ; }
public mutable date time to mutable date time ( ) { return new mutable date time ( get millis ( ) , get zone ( ) ) ; }
public date time to date time ( date time zone zone ) { chronology chrono = date time utils . get chronology ( get chronology ( ) ) ; chrono = chrono . with zone ( zone ) ; return new date time ( get millis ( ) , chrono ) ; }
public boolean be before ( long millis instant ) { return ( get end millis ( ) < = millis instant ) ; }
public boolean be equal ( readable interval other ) { return get start millis ( ) == other . get start millis ( ) & & get end millis ( ) == other . get end millis ( ) ; }
public duration field type [ ] get field type ( ) { duration field type [ ] result = new duration field type [ size ( ) ] ; for ( int i = 0 ; i < result . length ; i++ ) { result [ i ] = get field type ( i ) ; } return result ; }
public duration field type [ ] get field type ( ) { duration field type [ ] result = new duration field type [ size ( ) ] ; for ( int i = 0 ; i < result . length ; i++ ) { result [ i ] = get field type ( i ) ; } return result ; }
public int get ( duration field type type ) { int index = index of ( type ) ; if ( index == -1 ) { return 0 ; } return get value ( index ) ; }
public boolean equal ( object partial ) { if ( this == partial ) { return true ; } if ( partial instanceof readable partial == false ) { return false ; } readable partial other = ( readable partial ) partial ; if ( size ( ) ! = other . size ( ) ) { return false ; } for ( int i = 0 , isize = size ( ) ; i < isize ; i++ ) { if ( get value ( i ) ! = other . get value ( i ) || get field type ( i ) ! = other . get field type ( i ) ) { return false ; } } return field utils . equal ( get chronology ( ) , other . get chronology ( ) ) ; }
public mutable period to mutable period ( ) { return new mutable period ( this ) ; }
public period to period ( period type type , chronology chrono ) { return new period ( get millis ( ) , type , chrono ) ; }
protect void set field ( duration field type field , int value ) { set field into ( i value , field , value ) ; }
public int compare to ( base single field period other ) { if ( other . get class ( ) ! = get class ( ) ) { throw new class cast exception ( get class ( ) + `` can not be compare to `` + other . get class ( ) ) ; } int other value = other . get value ( ) ; int this value = get value ( ) ; if ( this value > other value ) { return 1 ; } if ( this value < other value ) { return -1 ; } return 0 ; }
public date time field year of era ( ) { return unsupported date time field . get instance ( date time field type . year of era ( ) , year ( ) ) ; }
public date time field year of era ( ) { return unsupported date time field . get instance ( date time field type . year of era ( ) , year ( ) ) ; }
public boolean equal ( object obj ) { if ( this == obj ) { return true ; } if ( obj instanceof zone chronology == false ) { return false ; } zone chronology chrono = ( zone chronology ) obj ; return get base ( ) . equal ( chrono . get base ( ) ) & & get zone ( ) . equal ( chrono . get zone ( ) ) ; }
public static coptic chronology get instance ( date time zone zone ) { return get instance ( zone , 4 ) ; }
public static gregorian chronology get instance ( ) { return get instance ( date time zone . get default ( ) , 4 ) ; }
public int get ( long instant ) { return i chronology . get week of weekyear ( instant ) ; }
public string get a text ( int field value , locale locale ) { return g j locale symbol . for locale ( locale ) . day of week value to text ( field value ) ; }
public static ethiopic chronology get instance ( ) { return get instance ( date time zone . get default ( ) , 4 ) ; }
public static g j chronology get instance ( date time zone zone ) { return get instance ( zone , default_cutover , 4 ) ; }
public duration converter [ ] get duration converter ( ) { converter set set = i duration converter ; duration converter [ ] converter = new duration converter [ set . size ( ) ] ; set . copy into ( converter ) ; return converter ; }
public chronology get chronology ( object object , date time zone zone ) { return get chronology ( object , ( chronology ) null ) . with zone ( zone ) ; }
public long remainder ( long instant ) { return instant - round floor ( instant ) ; }
public date midnight minus week ( int week ) { if ( week == 0 ) { return this ; } long instant = get chronology ( ) . week ( ) . subtract ( get millis ( ) , week ) ; return with millis ( instant ) ; }
public date midnight minus month ( int month ) { if ( month == 0 ) { return this ; } long instant = get chronology ( ) . month ( ) . subtract ( get millis ( ) , month ) ; return with millis ( instant ) ; }
public date midnight with field ( readable partial partial ) { if ( partial == null ) { return this ; } return with millis ( get chronology ( ) . set ( partial , get millis ( ) ) ) ; }
public date midnight with week of weekyear ( int week of weekyear ) { return with millis ( get chronology ( ) . week of weekyear ( ) . set ( get millis ( ) , week of weekyear ) ) ; }
public date midnight with day of month ( int day of month ) { return with millis ( get chronology ( ) . day of month ( ) . set ( get millis ( ) , day of month ) ) ; }
public property month of year ( ) { return new property ( this , get chronology ( ) . month of year ( ) ) ; }
public void set zone ( date time zone zone ) { i save state = null ; i zone = zone ; }
public date time with late offset at overlap ( ) { long new millis = get zone ( ) . adjust offset ( get millis ( ) , true ) ; return with millis ( new millis ) ; }
public date time with time ( int hour of day , int minute of hour , int second of minute , int millis of second ) { chronology chrono = get chronology ( ) ; long instant = get millis ( ) ; instant = chrono . hour of day ( ) . set ( instant , hour of day ) ; instant = chrono . minute of hour ( ) . set ( instant , minute of hour ) ; instant = chrono . second of minute ( ) . set ( instant , second of minute ) ; instant = chrono . millis of second ( ) . set ( instant , millis of second ) ; return with millis ( instant ) ; }
public date time minus month ( int month ) { if ( month == 0 ) { return this ; } long instant = get chronology ( ) . month ( ) . subtract ( get millis ( ) , month ) ; return with millis ( instant ) ; }
public date time minus millis ( int millis ) { if ( millis == 0 ) { return this ; } long instant = get chronology ( ) . millis ( ) . subtract ( get millis ( ) , millis ) ; return with millis ( instant ) ; }
public date midnight with week of weekyear ( int week of weekyear ) { return with millis ( get chronology ( ) . week of weekyear ( ) . set ( get millis ( ) , week of weekyear ) ) ; }
public boolean equal ( object object ) { if ( object instanceof date time comparator ) { date time comparator other = ( date time comparator ) object ; return ( i low limit == other . get low limit ( ) || ( i low limit ! = null & & i low limit . equal ( other . get low limit ( ) ) ) ) & & ( i upper limit == other . get upper limit ( ) || ( i upper limit ! = null & & i upper limit . equal ( other . get upper limit ( ) ) ) ) ; } return false ; }
public date time field era ( ) { return unsupported date time field . get instance ( date time field type . era ( ) , era ( ) ) ; }
public static final void set current millis offset ( long offset millis ) throw security exception { check permission ( ) ; if ( offset millis == 0 ) { c millis provider = system_millis_provider ; } else { c millis provider = new offset millis provider ( offset millis ) ; } }
public interval with duration after start ( readable duration duration ) { long duration millis = date time utils . get duration millis ( duration ) ; if ( duration millis == to duration millis ( ) ) { return this ; } chronology chrono = get chronology ( ) ; long start millis = get start millis ( ) ; long end millis = chrono . add ( start millis , duration millis , 1 ) ; return new interval ( start millis , end millis , chrono ) ; }
public final int get offset ( readable instant instant ) { if ( instant == null ) { return get offset ( date time utils . current time millis ( ) ) ; } return get offset ( instant . get millis ( ) ) ; }
public static final long to julian day number ( long epoch millis ) { return ( long ) math . floor ( to julian day ( epoch millis ) + 0 . 5d ) ; }
public static date time zone for i d ( string id ) { if ( id == null ) { return get default ( ) ; } if ( id . equal ( `` utc `` ) ) { return date time zone . utc ; } date time zone zone = c provider . get zone ( id ) ; if ( zone ! = null ) { return zone ; } if ( id . start with ( `` + `` ) || id . start with ( `` - `` ) ) { int offset = parse offset ( id ) ; if ( offset == 0l ) { return date time zone . utc ; } else { id = print offset ( offset ) ; return fix offset zone ( id , offset ) ; } } throw new illegal argument exception ( `` the datetime zone id ' `` + id + `` ' be not recognise `` ) ; }
protect object write replace ( ) throw object stream exception { return new stub ( i i d ) ; }
public static name provider get name provider ( ) { return c name provider ; }
public date time zone get uncached zone ( ) { return i zone ; }
public int compare to ( duration field duration field ) { return 0 ; }
public duration field century ( ) { return unsupported duration field . get instance ( duration field type . century ( ) ) ; }
public int get minimum value ( ) { return get field ( ) . get minimum value ( get readable partial ( ) ) ; }
public string get a short text ( ) { return get a short text ( null ) ; }
public int get minimum value ( ) { return get field ( ) . get minimum value ( get readable partial ( ) ) ; }
public int get minimum value ( ) { return get field ( ) . get minimum value ( get readable partial ( ) ) ; }
public string get a short text ( readable partial partial , int field value , locale locale ) { return get a short text ( field value , locale ) ; }
public int get value ( long duration ) { return field utils . safe to int ( get value a long ( duration ) ) ; }
public long add wrap field ( long instant , int value ) { int current = get ( instant ) ; int wrap = field utils . get wrapped value ( current , value , get minimum value ( instant ) , get maximum value ( instant ) ) ; return set ( instant , wrap ) ; }
public long remainder ( long instant ) { return instant - round floor ( instant ) ; }
public long add wrap field ( long instant , int amount ) { return set ( instant , field utils . get wrapped value ( get ( instant ) , amount , i min , i max ) ) ; }
public static date time field get instance ( date time field field ) { if ( field == null ) { return null ; } if ( field instanceof lenient date time field ) { field = ( ( lenient date time field ) field ) . get wrapped field ( ) ; } if ( ! field . be lenient ( ) ) { return field ; } return new strict date time field ( field ) ; }
public long set ( long instant , int value ) { field utils . verify value bound ( this , value , i min , i max ) ; return super . set ( instant , value - i offset ) ; }
public static date time formatter short date ( ) { return create formatter for style index ( short , none ) ; }
public date time formatter with zone ( date time zone zone ) { if ( i zone == zone ) { return this ; } return new date time formatter ( i printer , i parser , i locale , false , i chrono , zone , i pivot year , i default year ) ; }
public chronology with u t c ( ) { return with zone ( date time zone . utc ) ; }
public date time formatter with zone ( date time zone zone ) { if ( i zone == zone ) { return this ; } return new date time formatter ( i printer , i parser , i locale , false , i chrono , zone , i pivot year , i default year ) ; }
public static date time formatter time parser ( ) { return constant . tp ; }
public date time formatter with offset parse ( ) { if ( i offset parse == true ) { return this ; } return new date time formatter ( i printer , i parser , i locale , true , i chrono , null , i pivot year , i default year ) ; }
public static date time formatter t time no millis ( ) { return constant . ttx ; }
public static date time formatter t time no millis ( ) { return constant . ttx ; }
public static period formatter get default ( ) { return word base ( locale . english ) ; }
public void print to ( string buffer buf , readable period period ) { check printer ( ) ; check period ( period ) ; get printer ( ) . print to ( buf , period , i locale ) ; }
public period formatter with parse type ( period type type ) { if ( type == i parse type ) { return this ; } return new period formatter ( i printer , i parser , i locale , type ) ; }
public period formatter with parse type ( period type type ) { if ( type == i parse type ) { return this ; } return new period formatter ( i printer , i parser , i locale , type ) ; }
public period formatter builder append week ( ) { append field ( week ) ; return this ; }
public string get field name ( ) { return i field name ; }
public interval with duration after start ( readable duration duration ) { long duration millis = date time utils . get duration millis ( duration ) ; if ( duration millis == to duration millis ( ) ) { return this ; } chronology chrono = get chronology ( ) ; long start millis = get start millis ( ) ; long end millis = chrono . add ( start millis , duration millis , 1 ) ; return new interval ( start millis , end millis , chrono ) ; }
public void set start ( readable instant start ) { long start millis = date time utils . get instant millis ( start ) ; super . set interval ( start millis , get end millis ( ) , get chronology ( ) ) ; }
public void set duration before end ( long duration ) { set start millis ( field utils . safe add ( get end millis ( ) , -duration ) ) ; }
public void set week ( int week ) { super . set field ( duration field type . week ( ) , week ) ; }
public partial with period add ( readable period period , int scalar ) { if ( period == null || scalar == 0 ) { return this ; } int [ ] new value = get value ( ) ; for ( int i = 0 ; i < period . size ( ) ; i++ ) { duration field type field type = period . get field type ( i ) ; int index = index of ( field type ) ; if ( index > = 0 ) { new value = get field ( index ) . add ( this , index , new value , field utils . safe multiply ( period . get value ( i ) , scalar ) ) ; } } return new partial ( this , new value ) ; }
public static period month ( int month ) { return new period ( new int [ ] { 0 , month , 0 , 0 , 0 , 0 , 0 , 0 } , period type . standard ( ) ) ; }
public period minus millis ( int millis ) { return plus millis ( -millis ) ; }
public static period type day time ( ) { period type type = c d time ; if ( type == null ) { type = new period type ( `` day time `` , new duration field type [ ] { duration field type . day ( ) , duration field type . hour ( ) , duration field type . minute ( ) , duration field type . second ( ) , duration field type . millis ( ) , } , new int [ ] { -1 , -1 , -1 , 0 , 1 , 2 , 3 , 4 , } ) ; c d time = type ; } return type ; }
public date time zone get uncached zone ( ) { return i zone ; }
public boolean be remote access allow ( string p remote host , string p remote addr ) { return restrictor . be remote access allow ( p remote host , p remote addr ) ; }
public string map path ( string path ) { return null ; }
public static void unregister m bean ( string name ) throw exception { object name mbean object name = mbeans . remove ( name ) ; if ( mbean object name ! = null ) { m bean server mbean server = management factory . get platform m bean server ( ) ; mbean server . unregister m bean ( mbean object name ) ; } }
public boolean be global config ( ) { return global config ; }
public string get version ( ) { return version ; }
public j s o n object to j s o n object ( m bean server executor p server manager ) { j s o n object ret = new j s o n object ( ) ; add null safe ( ret , `` vendor `` , vendor ) ; add null safe ( ret , `` product `` , product ) ; add null safe ( ret , `` version `` , version ) ; map < string , string > extra = get extra info ( p server manager ) ; if ( extra ! = null ) { j s o n object json extra = new j s o n object ( ) ; for ( map . entry < string , string > entry : extra . entry set ( ) ) { json extra . put ( entry . get key ( ) , entry . get value ( ) ) ; } ret . put ( `` extra info `` , json extra ) ; } return ret ; }
public static @ non null number require positive ( string name , number value ) { require non null ( name , value ) ; require positive ( name , value . int value ( ) ) ; return value ; }
protect double get domain low bound ( double p ) { return 0 ; }
public void set max entry ( int p max entry ) { set limit ( new history limit ( p max entry , limit . get max duration ( ) ) ) ; }
public void set max entry ( int p max entry ) { set limit ( new history limit ( p max entry , limit . get max duration ( ) ) ) ; }
public object get value ( ) { return value ; }
public j s o n object to j s o n ( ) { j s o n object ret = super . to j s o n ( ) ; if ( argument ! = null & & argument . size ( ) > 0 ) { ret . put ( `` argument `` , argument ) ; } ret . put ( `` operation `` , operation ) ; return ret ; }
public static string print value ( string start , string separator , string end , iterator < ? > value ) { if ( start == null ) { start = `` ( `` ; } if ( separator == null ) { separator = `` , `` ; } if ( end == null ) { end = `` ) `` ; } string builder sb = new string builder ( start ) ; while ( value . have next ( ) ) { sb . append ( print ( value . next ( ) ) ) ; if ( value . have next ( ) ) { sb . append ( separator ) ; } } return sb . append ( end ) . to string ( ) ; }
public final argument accept option spec < v > describe a ( string description ) { argument description = description ; return this ; }
public static string get class base name ( class c ) { string s = c . get name ( ) ; return s . substring ( s . last index of ( ' . ' ) + 1 ) ; }
public static j s o n array to j s o n array ( string string ) throw j s o n exception { return to j s o n array ( new j s o n tokener ( string ) ) ; }
public j s o n object to j s o n object ( j s o n array name ) throw j s o n exception { j s o n object result = new j s o n object ( ) ; int length = math . min ( names . length ( ) , value . size ( ) ) ; if ( length == 0 ) { return null ; } for ( int i = 0 ; i < length ; i++ ) { string name = json . to string ( name . opt ( i ) ) ; result . put ( name , opt ( i ) ) ; } return result ; }
@ override public string to string ( ) { return out . length ( ) == 0 ? null : out . to string ( ) ; }
public j s o n writer object ( ) throw j s o n exception { if ( this . mode == ' i ' ) { this . mode = ' o ' ; } if ( this . mode == ' o ' || this . mode == ' a ' ) { this . append ( `` { `` ) ; this . push ( new j s o n object ( ) ) ; this . comma = false ; return this ; } throw new j s o n exception ( `` misplace object . `` ) ; } / * * * pop an array or object scope . * @ param c the scope to close . * @ throw j s o n exception if nesting be wrong . * / private void pop ( char c ) throw j s o n exception { if ( this . top < = 0 ) { throw new j s o n exception ( `` nest error . `` ) ; } char m = this . stack [ this . top - 1 ] == null ? ' a ' : ' k ' ; if ( m ! = c ) { throw new j s o n exception ( `` nest error . `` ) ; } this . top -= 1 ; this . mode = this . top == 0 ? 'd ' : this . stack [ this . top - 1 ] == null ? ' a ' : ' k ' ; } / * * * push an array or object scope . * @ param c the scope to open . * @ throw j s o n exception if nesting be too deep . * / private void push ( j s o n object jo ) throw j s o n exception { if ( this . top > = maxdepth ) { throw new j s o n exception ( `` nest too deep . `` ) ; } this . stack [ this . top ] = jo ; this . mode = jo == null ? ' a ' : ' k ' ; this . top += 1 ; } / * * * append either the value < code > true < /code > or the value * < code > false < /code > . * @ param b a boolean . * @ return this * @ throw j s o n exception * / public j s o n writer value ( boolean b ) throw j s o n exception { return this . append ( b ? `` true `` : `` false `` ) ; } / * * * append a double value . * @ param d a double . * @ return this * @ throw j s o n exception if the number be not finite . * / public j s o n writer value ( double d ) throw j s o n exception { return this . value ( new double ( d ) ) ; } / * * * append a long value . * @ param l a long . * @ return this * @ throw j s o n exception * / public j s o n writer value ( long l ) throw j s o n exception { return this . append ( long . to string ( l ) ) ; } / * * * append an object value . * @ param object the object to append . it can be null , or a boolean , number , * string , j s o n object , or j s o n array , or an object that implement j s o n string . * @ return this * @ throw j s o n exception if the value be out of sequence . * / public j s o n writer value ( object object ) throw j s o n exception { return this . append ( j s o n object . value to string ( object ) ) ; } }
public set < string > get force list ( ) { return this . force list ; }
public criterion contains ( object o ) { this . criterion type = relational operator . contain ; this . right = value node . to value node ( o ) ; return this ; }
public boolean get curly brace denote code block ( int language index ) { return true ; }
public boolean be array ( object obj ) { return ( obj instanceof list ) ; }
public void set property ( object obj , object key , object value ) { if ( be map ( obj ) ) ( ( map ) obj ) . put ( key . to string ( ) , value ) ; else { throw new json path exception ( `` set property operation can not be use with `` + obj ! =null ? obj . get class ( ) . get name ( ) : `` null `` ) ; } }
public string get string ( string path ) { return object converter . convert object to ( get ( path ) , string . class ) ; }
public char get char ( string path ) { object object = get ( path ) ; return convert object to ( object , character . class ) ; }
public string pretty print ( ) { final string pretty = prettify ( ) ; system . out . println ( pretty ) ; return pretty ; }
public string prettify ( ) { final string json string = to json string ( ) ; return json prettifier . prettify json ( json string ) ; }
public json path config default object deserializer ( json path object deserializer default object deserializer ) { return new json path config ( number return type , null , gson object mapper factory , jackson1 object mapper factory , jackson2 object mapper factory , johnzon object mapper factory , jsonb object mapper factory , default object deserializer , charset ) ; }
public json path config default object deserializer ( json path object deserializer default object deserializer ) { return new json path config ( number return type , null , gson object mapper factory , jackson1 object mapper factory , jackson2 object mapper factory , johnzon object mapper factory , jsonb object mapper factory , default object deserializer , charset ) ; }
public static boolean reg match ( final string regex , final string input ) { if ( primary_script_engine ! = null ) { return invoke script engine ( reg_match_function_name , regex , input ) ; } return invoke fallback engine ( reg_match , regex , input ) ; }
public dictionary builder < t > remove entry ( final string key ) { entry . remove ( key ) ; return this ; }
public static loading configuration by default ( ) { return new load configuration builder ( ) . freeze ( ) ; }
public library builder remove keyword ( final string name ) { bundle . check not null ( name , `` null name `` ) ; syntax checker . remove entry ( name ) ; digester . remove entry ( name ) ; validators . remove entry ( name ) ; return this ; }
public static < t > void remap field ( class < t > type , string json field name , string java field name ) { default reader . remap field ( type , json field name , java field name ) ; default writer . remap field ( type , java field name , json field name ) ; }
public void write j s o n string ( appendable out ) throw i o exception { write j s o n ( this , out , j s o n value . compression ) ; }
public string to string ( ) { if ( failure ) return j s o n value . to j s o n string ( failure message , error_compress ) ; return j s o n value . to j s o n string ( root ) ; }
public string a string ( ) { if ( current == null ) return null ; if ( current instanceof string ) return ( string ) current ; return current . to string ( ) ; }
public j s o n navi < ? > at ( int index ) { if ( failure ) return this ; if ( ! ( current instanceof list ) ) return failure ( `` current node be not an array `` , index ) ; @ suppress warning ( `` unchecked `` ) list < object > lst = ( ( list < object > ) current ) ; if ( index < 0 ) { index = lst . size ( ) + index ; if ( index < 0 ) index = 0 ; } if ( index > = lst . size ( ) ) if ( readonly ) return failure ( `` out of bound exception for index `` , index ) ; else { stack . add ( current ) ; path . add ( index ) ; current = null ; miss key = index ; return this ; } object next = lst . get ( index ) ; stack . add ( current ) ; path . add ( index ) ; current = next ; return this ; }
public j s o n navi < ? > at ( int index ) { if ( failure ) return this ; if ( ! ( current instanceof list ) ) return failure ( `` current node be not an array `` , index ) ; @ suppress warning ( `` unchecked `` ) list < object > lst = ( ( list < object > ) current ) ; if ( index < 0 ) { index = lst . size ( ) + index ; if ( index < 0 ) index = 0 ; } if ( index > = lst . size ( ) ) if ( readonly ) return failure ( `` out of bound exception for index `` , index ) ; else { stack . add ( current ) ; path . add ( index ) ; current = null ; miss key = index ; return this ; } object next = lst . get ( index ) ; stack . add ( current ) ; path . add ( index ) ; current = next ; return this ; }
public void add interface writer first ( class < ? > inter face , json writer i < ? > writer ) { register writer interface first ( inter face , writer ) ; }
public j s o n navi < t > add ( object . . . value ) { array ( ) ; if ( failure ) return this ; list < object > list = a ( current ) ; for ( object o : value ) list . add ( o ) ; return this ; }
public static void assert equal ( string expect str , j s o n object actual , boolean strict ) throw j s o n exception { assert equal ( expect str , actual , strict ? j s o n compare mode . strict : j s o n compare mode . lenient ) ; }
public static void assert equal ( string expect str , j s o n object actual , boolean strict ) throw j s o n exception { assert equal ( expect str , actual , strict ? j s o n compare mode . strict : j s o n compare mode . lenient ) ; }
public j s o n compare result fail ( string field , object expect , object actual ) { _field failure . add ( new field comparison failure ( field , expect , actual ) ) ; this . _field = field ; this . _expected = expect ; this . _actual = actual ; fail ( format failure message ( field , expect , actual ) ) ; return this ; }
public static document load ( input stream in , string charset name , string base uri , parser parser ) throw i o exception { byte buffer byte data = read to byte buffer ( in ) ; return parse byte data ( byte data , charset name , base uri , parser ) ; }
public e peek last ( ) { return size ( ) == 0 ? null : get last ( ) ; }
public static document parse ( string html , string base uri ) { return parser . parse ( html , base uri ) ; }
public static document parse ( input stream in , string charset name , string base uri , parser parser ) throw i o exception { return data util . load ( in , charset name , base uri , parser ) ; }
public static document parse ( input stream in , string charset name , string base uri , parser parser ) throw i o exception { return data util . load ( in , charset name , base uri , parser ) ; }
public void remove ( string key ) { validate . not empty ( key ) ; if ( attribute == null ) return ; attribute . remove ( key ) ; }
public string val ( ) { if ( tag name ( ) . equal ( `` textarea `` ) ) return text ( ) ; else return attr ( `` value `` ) ; }
public element text ( string text ) { validate . not null ( text ) ; empty ( ) ; text node text node = new text node ( text , base uri ) ; append child ( text node ) ; return this ; }
public element prepend element ( string tag name ) { element child = new element ( tag . value of ( tag name ) , base uri ( ) ) ; prepend child ( child ) ; return child ; }
public element prepend ( string html ) { validate . not null ( html ) ; list < node > node = parser . parse fragment ( html , this , base uri ( ) ) ; add child ( 0 , node . to array ( new node [ node . size ( ) ] ) ) ; return this ; }
public element get all element ( ) { return collector . collect ( new evaluator . all element ( ) , this ) ; }
public connection submit ( ) { string action = have attr ( `` action `` ) ? abs url ( `` action `` ) : base uri ( ) ; validate . not empty ( action , `` could not determine a form action url for submit . ensure you set a base uri when parsing . `` ) ; connection . method method = attr ( `` method `` ) . to upper case ( ) . equal ( `` post `` ) ? connection . method . post : connection . method . get ; return jsoup . connect ( action ) . data ( form data ( ) ) . method ( method ) ; }
public boolean have text ( ) { for ( node child : child node ) { if ( child instanceof text node ) { text node text node = ( text node ) child ; if ( ! text node . be blank ( ) ) return true ; } else if ( child instanceof element ) { element el = ( element ) child ; if ( el . have text ( ) ) return true ; } } return false ; }
public element before ( string html ) { return ( element ) super . before ( html ) ; }
public element before ( string html ) { return ( element ) super . before ( html ) ; }
public void remove ( ) { validate . not null ( parent node ) ; parent node . remove child ( this ) ; }
public boolean be self closing ( ) { return empty || self closing ; }
public boolean match whitespace ( ) { return ! be empty ( ) & & string util . be whitespace ( queue . char at ( po ) ) ; }
public boolean match c s ( string seq ) { return queue . start with ( seq , po ) ; }
public string consume word ( ) { int start = po ; while ( match word ( ) ) pos++ ; return queue . substring ( start , po ) ; }
public string remainder ( ) { final string remainder = queue . substring ( po , queue . length ( ) ) ; po = queue . length ( ) ; return remainder ; }
public static whitelist relaxed ( ) { return new whitelist ( ) . add tag ( `` a `` , `` b `` , `` blockquote `` , `` br `` , `` caption `` , `` cite `` , `` code `` , `` col `` , `` colgroup `` , `` dd `` , `` div `` , `` dl `` , `` dt `` , `` em `` , `` h1 `` , `` h2 `` , `` h3 `` , `` h4 `` , `` h5 `` , `` h6 `` , `` i `` , `` img `` , `` li `` , `` ol `` , `` p `` , `` pre `` , `` q `` , `` small `` , `` span `` , `` strike `` , `` strong `` , `` sub `` , `` sup `` , `` table `` , `` tbody `` , `` td `` , `` tfoot `` , `` th `` , `` thead `` , `` tr `` , `` u `` , `` ul `` ) . add attribute ( `` a `` , `` href `` , `` title `` ) . add attribute ( `` blockquote `` , `` cite `` ) . add attribute ( `` col `` , `` span `` , `` width `` ) . add attribute ( `` colgroup `` , `` span `` , `` width `` ) . add attribute ( `` img `` , `` align `` , `` alt `` , `` height `` , `` src `` , `` title `` , `` width `` ) . add attribute ( `` ol `` , `` start `` , `` type `` ) . add attribute ( `` q `` , `` cite `` ) . add attribute ( `` table `` , `` summary `` , `` width `` ) . add attribute ( `` td `` , `` abbr `` , `` axis `` , `` colspan `` , `` rowspan `` , `` width `` ) . add attribute ( `` th `` , `` abbr `` , `` axis `` , `` colspan `` , `` rowspan `` , `` scope `` , `` width `` ) . add attribute ( `` ul `` , `` type `` ) . add protocol ( `` a `` , `` href `` , `` ftp `` , `` http `` , `` http `` , `` mailto `` ) . add protocol ( `` blockquote `` , `` cite `` , `` http `` , `` https `` ) . add protocol ( `` cite `` , `` cite `` , `` http `` , `` https `` ) . add protocol ( `` img `` , `` src `` , `` http `` , `` https `` ) . add protocol ( `` q `` , `` cite `` , `` http `` , `` https `` ) ; }
public element empty ( ) { for ( element element : this ) { element . empty ( ) ; } return this ; }
public element prev all ( ) { return sibling ( null , false , true ) ; }
public static void filter ( node filter filter , elements element ) { validate . not null ( filter ) ; validate . not null ( element ) ; for ( element el : element ) if ( filter ( filter , el ) == filter result . stop ) break ; }
public element traverse ( node visitor node visitor ) { validate . not null ( node visitor ) ; node traversor traversor = new node traversor ( node visitor ) ; for ( element el : this ) { traversor . traverse ( el ) ; } return this ; }
public static string join ( object . . . line to break ) { return join ( `` \n `` , a list ( line to break ) ) ; }
protect boolean match uri request pattern ( final string pattern , final string path ) { if ( pattern . equal ( `` * `` ) ) { return true ; } else { return ( pattern . end with ( `` * `` ) & & path . start with ( pattern . substring ( 0 , pattern . length ( ) - 1 ) ) ) || ( pattern . start with ( `` * `` ) & & path . end with ( pattern . substring ( 1 , pattern . length ( ) ) ) ) ; } }
public boolean have text ( ) { for ( node child : child node ) { if ( child instanceof text node ) { text node text node = ( text node ) child ; if ( ! text node . be blank ( ) ) return true ; } else if ( child instanceof element ) { element el = ( element ) child ; if ( el . have text ( ) ) return true ; } } return false ; }
public static void uninstall ( ) throw security exception { java . util . log . logger root logger = get root logger ( ) ; handler [ ] handler = root logger . get handler ( ) ; for ( int i = 0 ; i < handler . length ; i++ ) { if ( handler [ i ] instanceof s l f4 j bridge handler ) { root logger . remove handler ( handler [ i ] ) ; } } }
static public void assert true ( string message , boolean condition ) { if ( ! condition ) fail ( message ) ; }
public final expression optimize ( expression visitor visitor , item type context item type ) { return this ; }
protect string process argument ( string [ ] args ) { string suite name= null ; for ( int i= 0 ; i < args . length ; i++ ) { if ( args [ i ] . equal ( `` -noloading `` ) ) { set loading ( false ) ; } else if ( args [ i ] . equal ( `` -nofilterstack `` ) ) { fg filter stack= false ; } else if ( args [ i ] . equal ( `` -c `` ) ) { if ( args . length > i+1 ) suite name= extract class name ( args [ i+1 ] ) ; else system . out . println ( `` miss test class name `` ) ; i++ ; } else { suite name= args [ i ] ; } } return suite name ; }
static public void run and wait ( test suite ) { test runner a test runner= new test runner ( ) ; a test runner . do run ( suite , true ) ; }
public synchronize int run count ( ) { return f run test ; }
public test test at ( int index ) { return f test . get ( index ) ; }
static public void assert null ( string message , object object ) { assert true ( message , object == null ) ; }
public string get actual ( ) { return f actual ; }
public void output base time ( final long base time msec ) { log . format ( locale . u , `` # [ base time : % . 3f ( second since epoch ) ] \n `` , base time msec/1000 . 0 ) ; }
protect string render ( option option , string trim source , session factory implementor factory ) { return string . format ( `` trim ( % s % s from % s ) `` , option . get trim specification ( ) . get name ( ) , option . get trim character ( ) , trim source ) ; }
public static void main ( string . . . args ) { result result= new j unit core ( ) . run main ( args ) ; kill all thread ( result ) ; }
public static void main ( string . . . args ) { result result= new j unit core ( ) . run main ( args ) ; kill all thread ( result ) ; }
public void add first listener ( run listener listener ) { f listener . add ( 0 , listener ) ; }
public result run ( class < ? > test class ) { return run ( request . a class ( test class ) ) ; }
public list < failure > failure ( ) { return result . get failure ( ) ; }
public void create ( ) throw i o exception { folder = create temporary folder in ( parent folder ) ; }
public statement apply ( final statement base , description description ) { return new statement ( ) { @ override public void evaluate ( ) throw throwable { base . evaluate ( ) ; verify ( ) ; } } ; }
public static void main ( string . . . args ) { result result= new j unit core ( ) . run main ( args ) ; kill all thread ( result ) ; }
public method get method ( ) { return f method ; }
public string get expect ( ) { return f expect ; }
public static matcher < printable result > have failure contain ( final string string ) { return new base matcher < printable result > ( ) { public boolean match ( object item ) { return item . to string ( ) . contains ( string ) ; } public void describe to ( description description ) { description . append text ( `` have failure contain `` + string ) ; } } ; }
public void expect ( matcher < ? > matcher ) { matcher builder . add ( matcher ) ; }
public list < class < ? > > get class ( ) { return collection . unmodifiable list ( class ) ; }
public list < framework field > get annotate field ( ) { return collect value ( field for annotation ) ; }
public void add validator action ( validator action va ) { va . init ( ) ; this . h action . put ( va . get name ( ) , va ) ; if ( get log ( ) . be debug enable ( ) ) { get log ( ) . debug ( `` add validator action : `` + va . get name ( ) + `` , `` + va . get classname ( ) ) ; } }
public static < b > matcher < b > same property value a ( b expect bean , string . . . ignored property ) { return new same property value a < > ( expect bean , a list ( ignored property ) ) ; }
public static matcher < object > anything ( ) { return new be anything < > ( ) ; }
public static < lh > combinable both matcher < lh > both ( matcher < ? super lh > matcher ) { return new combinable both matcher < > ( matcher ) ; }
public void delete ( ) { if ( folder ! = null ) { recursive delete ( folder ) ; } }
public static condition evaluation result enable ( string reason ) { return new condition evaluation result ( true , reason ) ; }
public static boolean be assignable to ( class < ? > source type , class < ? > target type ) { precondition . not null ( source type , `` source type must not be null `` ) ; precondition . condition ( ! source type . be primitive ( ) , `` source type must not be a primitive type `` ) ; precondition . not null ( target type , `` target type must not be null `` ) ; if ( target type . be assignable from ( source type ) ) { return true ; } if ( target type . be primitive ( ) ) { return source type == primitive to wrapper map . get ( target type ) || be widen conversion ( source type , target type ) ; } return false ; }
public static class wrapper to primitive ( class cl ) { return ( class ) wrapper primitive map . get ( cl ) ; }
public string input digit ( char next char ) { current output = input digit with option to remember position ( next char , false ) ; return current output ; }
public string input digit ( char next char ) { current output = input digit with option to remember position ( next char , false ) ; return current output ; }
public int end ( ) { return start + raw string . length ( ) ; }
public final boolean get follow ( ) { return follow ; }
public log level get default level ( ) { return _default level ; }
protect void set font size silently ( int font size ) { _font size = font size ; set font size ( _table . _detail text area , font size ) ; select row ( 0 ) ; set font size ( _table , font size ) ; }
protect boolean load log file ( file file ) { boolean ok = false ; try { log file parser lfp = new log file parser ( file ) ; lfp . parse ( this ) ; ok = true ; } catch ( i o exception e ) { log factor5 error dialog error = new log factor5 error dialog ( get base frame ( ) , `` error reading `` + file . get name ( ) ) ; } return ok ; }
public static log monitor adapter new instance ( int loglevels ) { log monitor adapter adapter ; if ( loglevels == jdk14_log_levels ) { adapter = new instance ( log level . get jdk14 level ( ) ) ; adapter . set default level ( log level . fine ) ; adapter . set severe level ( log level . severe ) ; } else { adapter = new instance ( log level . get log4 j level ( ) ) ; adapter . set default level ( log level . debug ) ; adapter . set severe level ( log level . fatal ) ; } return adapter ; }
public void set name ( string name ) { _name = name ; }
public input stream get input stream ( ) { input stream in = resource utils . get resource a stream ( this , this ) ; return ( in ) ; }
protect void add record from child ( ) { _number of record from children++ ; add record to parent ( ) ; }
protect void set m r u ( object o ) { int index = _mru file list . index of ( o ) ; if ( index == -1 ) { _mru file list . add ( 0 , o ) ; set max size ( _max size ) ; } else { move to top ( index ) ; } }
public void range change ( final int min , final int max ) { swing utility . invoke later ( new thread ( ) { @ override public void run ( ) { progress total . set minimum ( min ) ; progress total . set maximum ( max ) ; progress total . set indeterminate ( min == max ) ; } } ) ; }
protect void request open m r u ( action event e ) { string file = e . get action command ( ) ; string tokenizer st = new string tokenizer ( file ) ; string num = st . next token ( ) . trim ( ) ; file = st . next token ( `` \n `` ) ; try { int index = integer . parse int ( num ) - 1 ; input stream in = _mru file manager . get input stream ( index ) ; log file parser lfp = new log file parser ( in ) ; lfp . parse ( this ) ; _mru file manager . move to top ( index ) ; update m r u list ( ) ; } catch ( exception me ) { log factor5 error dialog error = new log factor5 error dialog ( get base frame ( ) , `` unable to load file `` + file ) ; } }
protect entry message enter ( final string fqcn , final string format , final supplier < ? > . . . param supplier ) { entry message entry msg = null ; if ( be enable ( level . trace , entry_marker , ( object ) null , null ) ) { log message safely ( fqcn , level . trace , entry_marker , entry msg = entry msg ( format , param supplier ) , null ) ; } return entry msg ; }
public static void error ( final logger logger , final string pattern , final object [ ] argument ) { if ( logger . be enable for ( level . error ) ) { force log ( logger , level . error , format ( pattern , argument ) ) ; } }
public string get cc ( ) { return cc ; }
public string get s m t p password ( ) { return smtp password ; }
synchronize public void close ( ) { if ( close ) return ; this . close = true ; if ( advertise via multicast d n s ) { zero conf . unadvertise ( ) ; } clean up ( ) ; }
public void set remote host ( string host ) { address = get address by name ( host ) ; remote host = host ; }
public void set time zone ( final time zone time zone ) { formatter . set time zone ( time zone ) ; previous time = long . min_value ; slot begin = long . min_value ; }
public boolean be leave truncate ( ) { return leave truncate ; }
public level get level ( ) { return ( level ) level ; }
public static property pattern converter new instance ( final string [ ] option ) { return new property pattern converter ( option ) ; }
protect double get domain low bound ( double p ) { return 0 ; }
public static marker get marker ( final string name ) { marker result = marker . get ( name ) ; if ( result == null ) { marker . put if absent ( name , new log4j marker ( name ) ) ; result = marker . get ( name ) ; } return result ; }
public static jndi manager get jndi manager ( final property property ) { return get manager ( create manager name ( ) , factory , property ) ; }
public static string get exception message string ( e l context context , string message id , object [ ] params ) { string result = `` `` ; locale locale = null ; if ( null == context || null == message id ) { return result ; } if ( null == ( locale = context . get locale ( ) ) ) { locale = locale . get default ( ) ; } if ( locale ! = null ) { map < string , resource bundle > thread map = get current instance ( ) ; resource bundle resource bundle = null ; if ( null == ( resource bundle = thread map . get ( locale . to string ( ) ) ) ) { resource bundle = resource bundle . get bundle ( `` javax . el . private message `` , locale ) ; thread map . put ( locale . to string ( ) , resource bundle ) ; } if ( null ! = resource bundle ) { try { result = resource bundle . get string ( message id ) ; if ( null ! = params ) { result = message format . format ( result , params ) ; } } catch ( illegal argument exception iae ) { result = `` ca n't get localized message : parameter to message appear to be incorrect . message to format : `` + message id ; } catch ( miss resource exception mre ) { result = `` miss resource in jakarta expression language implementation : ? ? ? `` + message id + `` ? ? ? `` ; } catch ( exception e ) { result = `` exception resolve message in jakarta expression language implementation : ? ? ? `` + message id + `` ? ? ? `` ; } } } return result ; }
public throwable get throwable ( ) { return throwable ; }
public boolean get curly brace denote code block ( int language index ) { return true ; }
public string get format message ( final string [ ] format ) { return a string ( get format ( format ) , null ) ; }
public log builder at error ( ) { return at level ( level . error ) ; }
public boolean be frozen ( ) { return frozen ; }
public void log ( final status data data ) { if ( ! filter ( data ) ) { stream . println ( data . get formatted status ( ) ) ; } }
public static optimistic lock style from xml ( string name ) { return optimistic lock style . value of ( name == null ? null : name . to upper case ( locale . english ) ) ; }
public static message get message ( final supplier < ? > supplier , final message factory message factory ) { if ( supplier == null ) { return null ; } final object result = supplier . get ( ) ; return result instanceof message ? ( message ) result : message factory . new message ( result ) ; }
public long get long property ( final string name , final long default value ) { final string prop = get string property ( name ) ; if ( prop ! = null ) { try { return long . parse long ( prop ) ; } catch ( final exception ignore ) { return default value ; } } return default value ; }
public reflection merge ( final reflection reflection ) { if ( reflection . store ! = null ) { for ( string index name : reflection . store . key set ( ) ) { multimap < string , string > index = reflection . store . get ( index name ) ; for ( string key : index . key set ( ) ) { for ( string string : index . get ( key ) ) { store . get or create ( index name ) . put ( key , string ) ; } } } } return this ; }
public static boolean be name ( string value ) { if ( value == null ) return false ; char c = value . char at ( 0 ) ; if ( ! xml char . be letter ( c ) & & c ! = ' _ ' & & c ! = ' : ' ) return false ; for ( int i = 1 ; i < value . length ( ) ; i++ ) if ( ! xml char . be name char ( value . char at ( i ) ) ) return false ; return true ; }
public layout < ? extend serializable > get layout ( ) { return layout ; }
public layout < ? extend serializable > get layout ( ) { return layout ; }
public synchronize void flush ( ) { flush buffer ( byte buffer ) ; flush destination ( ) ; }
public void log message in current thread ( final log event log event ) { log event . set end of batch ( queue . be empty ( ) ) ; final boolean append successful = thread . call appenders ( log event ) ; log to error appender if necessary ( append successful , log event ) ; }
public boolean release sub ( final long timeout , final time unit time unit ) { write footer ( ) ; return close output stream ( ) ; }
public boolean release sub ( final long timeout , final time unit time unit ) { write footer ( ) ; return close output stream ( ) ; }
public boolean release sub ( final long timeout , final time unit time unit ) { write footer ( ) ; return close output stream ( ) ; }
public int get buffer size ( ) { return get manager ( ) . get buff size ( ) ; }
public void execute ( lexer lexer , char stream input , int start index ) { boolean require seek = false ; int stop index = input . index ( ) ; try { for ( lexer action lexer action : lexer action ) { if ( lexer action instanceof lexer indexed custom action ) { int offset = ( ( lexer indexed custom action ) lexer action ) . get offset ( ) ; input . seek ( start index + offset ) ; lexer action = ( ( lexer indexed custom action ) lexer action ) . get action ( ) ; require seek = ( start index + offset ) ! = stop index ; } else if ( lexer action . be position dependent ( ) ) { input . seek ( stop index ) ; require seek = false ; } lexer action . execute ( lexer ) ; } } finally { if ( require seek ) { input . seek ( stop index ) ; } } }
public file get source ( ) { return this . source ; }
public boolean be condition ( ) { final simple binding binding = new simple binding ( ) ; binding . put all ( configuration . get property ( ) ) ; binding . put ( `` substitutor `` , configuration . get str substitutor ( ) ) ; final object object = configuration . get script manager ( ) . execute ( script . get name ( ) , binding ) ; return boolean . parse boolean ( object . to string ( ) ) ; }
public void remove super ( session session ) { super . remove ( session , false ) ; }
public void update data ( final object data ) { final factory data factory data = ( factory data ) data ; set rollover strategy ( factory data . get rollover strategy ( ) ) ; set pattern processor ( new pattern processor ( factory data . get pattern ( ) , get pattern processor ( ) ) ) ; set triggering policy ( factory data . get triggering policy ( ) ) ; }
public string get appender ref ( ) { return appender ref ; }
public synchronize void start ( ) { if ( disruptor ! = null ) { logger . trace ( `` async logger config disruptor not start new disruptor for this configuration , `` + `` use exist object . `` ) ; return ; } logger . trace ( `` async logger config disruptor create new disruptor for this configuration . `` ) ; ring buffer size = disruptor util . calculate ring buffer size ( `` async logger config . ring buffer size `` ) ; final wait strategy wait strategy = disruptor util . create wait strategy ( `` async logger config . wait strategy `` ) ; final thread factory thread factory = new log4j thread factory ( `` async logger config `` , true , thread . norm_priority ) { @ override public thread new thread ( final runnable r ) { final thread result = super . new thread ( r ) ; background thread id = result . get id ( ) ; return result ; } } ; async queue full policy = async queue full policy factory . create ( ) ; translator = mutable ? mutable_translator : translator ; factory = mutable ? mutable_factory : factory ; disruptor = new disruptor < > ( factory , ring buffer size , thread factory , producer type . multi , wait strategy ) ; final exception handler < log4j event wrapper > error handler = disruptor util . get async logger config exception handler ( ) ; disruptor . set default exception handler ( error handler ) ; final log4j event wrapper handler [ ] handler = { new log4j event wrapper handler ( ) } ; disruptor . handle event with ( handler ) ; logger . debug ( `` start async logger config disruptor for this configuration with ringbuffer size= { } , `` + `` wait strategy= { } , exception handler= { } . . . `` , disruptor . get ring buffer ( ) . get buff size ( ) , wait strategy . get class ( ) . get simple name ( ) , error handler ) ; disruptor . start ( ) ; super . start ( ) ; }
public void add listener ( final configuration listener listener ) { listener . add ( listener ) ; }
public string get name ( ) { return name ; }
public synchronize void add logger ( final string logger name , final logger config logger config ) { logger configs . put if absent ( logger name , logger config ) ; set parent ( ) ; }
public int get int level ( ) { return int level ; }
public void clear ( ) { plugins by category ref . set ( null ) ; plugins by category by package . clear ( ) ; plugins by category by bundle id . clear ( ) ; }
public class loader get class loader ( ) { return classloader ! = null ? classloader : ( classloader = loader . get class loader ( resolver util . class , null ) ) ; }
public static plugin visitor < ? extend annotation > find visitor ( final class < ? extend annotation > annotation ) { final plugin visitor strategy strategy = annotation . get annotation ( plugin visitor strategy . class ) ; if ( strategy == null ) { return null ; } try { return strategy . value ( ) . new instance ( ) ; } catch ( final exception e ) { logger . error ( `` error load plugin visitor [ { } ] for annotation [ { } ] . `` , strategy . value ( ) , annotation , e ) ; return null ; } }
public void start ( ) { this . set start ( ) ; if ( filter ! = null ) { filter . start ( ) ; } this . set start ( ) ; }
public throwable proxy get throw proxy ( ) { if ( thrown proxy == null & & thrown ! = null ) { thrown proxy = new throwable proxy ( throw ) ; } return thrown proxy ; }
public byte [ ] to byte array ( final log event event ) { return get byte ( to serializable ( event ) ) ; }
public logger get parent ( ) { final logger config lc = private config . logger config . get name ( ) . equal ( get name ( ) ) ? private config . logger config . get parent ( ) : private config . logger config ; if ( lc == null ) { return null ; } final string lc name = lc . get name ( ) ; final message factory message factory = get message factory ( ) ; if ( context . have logger ( lc name , message factory ) ) { return context . get logger ( lc name , message factory ) ; } return new logger ( context , lc name , message factory ) ; }
public void reconfigure ( ) { reconfigure ( config location ) ; }
public void reconfigure ( ) { reconfigure ( config location ) ; }
public boolean equal ( object obj ) { if ( obj == null || ! ( obj instanceof message element ) ) { return false ; } if ( this == obj ) { return true ; } if ( ! this . get local name ( ) . equal ( ( ( message element ) obj ) . get local name ( ) ) ) { return false ; } return to string ( ) . equal ( obj . to string ( ) ) ; }
synchronize public void close ( ) { if ( close ) return ; this . close = true ; if ( advertise via multicast d n s ) { zero conf . unadvertise ( ) ; } clean up ( ) ; }
public void clear secret ( ) { if ( this . key store config ! = null ) { this . key store config . clear secret ( ) ; } if ( this . trust store config ! = null ) { this . trust store config . clear secret ( ) ; } }
public boolean handle throwable ( ) { return converter . handle throwable ( ) ; }
public boolean be unmatched argument allow ( ) { return unmatched argument allow ; }
public command line add subcommand ( final string name , final object command ) { final command line command line = to command line ( command ) ; command line . parent = this ; interpreter . command . put ( name , command line ) ; return this ; }
public static long swap long ( final long value ) { return ( ( ( value > > 0 ) & 0xff ) < < 56 ) + ( ( ( value > > 8 ) & 0xff ) < < 48 ) + ( ( ( value > > 16 ) & 0xff ) < < 40 ) + ( ( ( value > > 24 ) & 0xff ) < < 32 ) + ( ( ( value > > 32 ) & 0xff ) < < 24 ) + ( ( ( value > > 40 ) & 0xff ) < < 16 ) + ( ( ( value > > 48 ) & 0xff ) < < 8 ) + ( ( ( value > > 56 ) & 0xff ) < < 0 ) ; }
public boolean get curly brace denote code block ( int language index ) { return true ; }
public string lookup ( final log event event , string var ) { if ( var == null ) { return null ; } final int prefix po = var . index of ( prefix_separator ) ; if ( prefix po > = 0 ) { final string prefix = var . substring ( 0 , prefix po ) . to lower case ( locale . u ) ; final string name = var . substring ( prefix po + 1 ) ; final str lookup lookup = str lookup map . get ( prefix ) ; if ( lookup instanceof configuration aware ) { ( ( configuration aware ) lookup ) . set configuration ( configuration ) ; } string value = null ; if ( lookup ! = null ) { value = event == null ? lookup . lookup ( name ) : lookup . lookup ( event , name ) ; } if ( value ! = null ) { return value ; } var = var . substring ( prefix po + 1 ) ; } if ( default lookup ! = null ) { return event == null ? default lookup . lookup ( var ) : default lookup . lookup ( event , var ) ; } return null ; }
public static int get max level possible ( ) { return geohash utils . max_precision ; }
public void set queue connection factory binding name ( string qcf bind name ) { this . qcf bind name = qcf bind name ; }
protect queue connection get queue connection ( ) { return queue connection ; }
public int get count ( ) { return synchronize context map . size ( ) ; }
public string get discriminate value ( i log event event ) { string context name = event . get logger context v o ( ) . get name ( ) ; if ( context name == null ) { return default value ; } else { return context name ; } }
public string get discriminate value ( i log event event ) { string context name = event . get logger context v o ( ) . get name ( ) ; if ( context name == null ) { return default value ; } else { return context name ; } }
public void clear ( ) { last operation . set ( write_operation ) ; copy on inherit thread local . remove ( ) ; }
public string get property ( string key ) { string v = property map . get ( key ) ; if ( v ! = null ) { return v ; } else { return context . get property ( key ) ; } }
public void clear ( ) { last operation . set ( write_operation ) ; copy on inherit thread local . remove ( ) ; }
protected boolean should start ( ) { try { server socket server socket = get server socket factory ( ) . create server socket ( get port ( ) , get backlog ( ) , get inet address ( ) ) ; server listener < remote appender client > listener = create server listener ( server socket ) ; runner = create server runner ( listener , get context ( ) . get executor service ( ) ) ; runner . set context ( get context ( ) ) ; return true ; } catch ( exception ex ) { add error ( `` server startup error : `` + ex , ex ) ; close util . close quietly ( server socket ) ; return false ; } }
public s s l configuration get ssl ( ) { if ( ssl == null ) { ssl = new s s l configuration ( ) ; } return ssl ; }
public void set suffix pattern ( string suffix pattern ) { this . suffix pattern = suffix pattern ; }
public i throwable proxy get throwable proxy ( ) { return throwable proxy ; }
public string get url ( ) { return url ; }
public string get pattern ( ) { return pattern ; }
public void begin ( interpretation context ic , string name , attribute attribute ) throw action exception { hook = null ; in error = false ; string class name = attribute . get value ( class_attribute ) ; if ( option helper . be empty ( class name ) ) { add error ( `` miss class name for shutdown hook . near [ `` + name + `` ] line `` + get line number ( ic ) ) ; in error = true ; return ; } try { add info ( `` about to instantiate shutdown hook of type [ `` + class name + `` ] `` ) ; hook = ( shutdown hook base ) option helper . instantiate by class name ( class name , shutdown hook base . class , context ) ; hook . set context ( context ) ; ic . push object ( hook ) ; } catch ( exception e ) { in error = true ; add error ( `` could not create a shutdown hook of type [ `` + class name + `` ] . `` , e ) ; throw new action exception ( e ) ; } }
public void end ( interpretation context ic , string name ) throw action exception { if ( in error ) { return ; } object o = ic . peek object ( ) ; if ( o ! = hook ) { add warn ( `` the object at the of the stack be not the hook push earlier . `` ) ; } else { ic . pop object ( ) ; thread hook thread = new thread ( hook , `` logback shutdown hook [ `` + context . get name ( ) + `` ] `` ) ; context . put object ( core constant . shutdown_hook_thread , hook thread ) ; runtime . get runtime ( ) . add shutdown hook ( hook thread ) ; } }
public void start ( ) { int error = 0 ; if ( get file ( ) ! = null ) { add info ( `` file property be set to [ `` + file name + `` ] `` ) ; if ( prudent ) { if ( be append ( ) == false ) { set append ( true ) ; add warn ( `` set \ `` append\ `` property to true on account of \ `` prudent\ `` mode `` ) ; } } try { open file ( get file ( ) ) ; } catch ( java . io . i o exception e ) { errors++ ; add error ( `` open file ( `` + file name + `` , `` + append + `` ) call fail . `` , e ) ; } } else { errors++ ; add error ( `` \ `` file\ `` property not set for appender name [ `` + name + `` ] . `` ) ; } if ( error == 0 ) { super . start ( ) ; } }
public void set s m t p host ( string smtp host ) { set smtp host ( smtp host ) ; }
public void set remote host ( string host ) { address = get address by name ( host ) ; remote host = host ; }
protect void on visit frame ( int type , int local variable length , object [ ] local variable , int stack size , object [ ] stack ) { super . visit frame ( type , local variable length , local variable , stack size , stack ) ; }
public string get active file name ( ) { string parent raw file property = get parent raw file property ( ) ; if ( parent raw file property ! = null ) { return parent raw file property ; } else { return time base file name and trigger policy . get current period file name without compression suffix ( ) ; } }
public boolean be attach ( appender < e > appender ) { if ( appender == null ) { return false ; } boolean attached = false ; r . lock ( ) ; try { for ( appender < e > a : appender list ) { if ( a == appender ) { attached = true ; break ; } } } finally { r . unlock ( ) ; } return attach ; }
public static void consume a stream ( class loader cl , string resource , consumer < input stream > consumer ) throw i o exception { final enumeration < url > resource = cl . get resource ( resource ) ; while ( resource . have more element ( ) ) { consume stream ( resource . next element ( ) , consumer ) ; } }
public static url get resource by self class loader ( string resource ) { return get resource ( resource , get class loader of class ( loader . class ) ) ; }
public void set class loader ( class loader class loader ) { if ( class loader == null ) { this . class loader = get class ( ) . get class loader ( ) ; } else { this . class loader = class loader ; } }
public static void print in case of error or warning ( context context ) { if ( context == null ) { throw new illegal argument exception ( `` context argument can not be null `` ) ; } status manager sm = context . get status manager ( ) ; if ( sm == null ) { p . println ( `` warn : context name \ `` `` + context . get name ( ) + `` \ `` have no status manager `` ) ; } else { status checker sc = new status checker ( context ) ; if ( sc . get high level ( 0 ) > = error status . warn ) { print ( sm ) ; } } }
public void start ( ) { be start = true ; if ( retrospective thresold > 0 ) { retrospective print ( ) ; } }
public void set from ( string from ) { this . from = from ; }
public void set algorithm ( string algorithm ) { this . algorithm = algorithm ; }
public void set provider ( string provider ) { this . provider = provider ; }
public string get include protocol ( ) { return include protocol ; }
public boolean be need client auth ( ) { return need client auth ; }
public void set want client auth ( boolean want client auth ) { this . want client auth = want client auth ; }
public string get pattern ( ) { return pattern ; }
public key store factory bean get key store ( ) { if ( key store == null ) { key store = key store from system property ( jsse_key_store_property ) ; } return key store ; }
public void set from ( string from ) { this . from = from ; }
public void reset ( ) { property map . clear ( ) ; object map . clear ( ) ; }
public void clear ( ) { last operation . set ( write_operation ) ; copy on inherit thread local . remove ( ) ; }
protect static boolean string with null equal ( string s1 , string s2 ) { if ( s1 == null || s1 . length ( ) == 0 ) { return ( s2 == null ) || ( s2 . length ( ) == 0 ) ; } return ( s2 ! = null ) & & s1 . equal ( s2 ) ; }
public static int read32bit ( byte [ ] code , int index ) { return ( code [ index ] < < 24 ) | ( ( code [ index + 1 ] & 0xff ) < < 16 ) | ( ( code [ index + 2 ] & 0xff ) < < 8 ) | ( code [ index + 3 ] & 0xff ) ; }
public byte [ ] decompress ( byte [ ] src , int src off ) { if ( safe decompressor ! = null ) { return decompress ( src , src off , src . length - src off ) ; } final int d len = get decompress length ( src , src off ) ; return fast decompressor . decompress ( src , src off + 4 , d len ) ; }
public long get expect content size ( ) { if ( ! read single frame ) { throw new unsupported operation exception ( `` operation not permit when multiple frame can be read `` ) ; } return expect content size ; }
public void set private key ( final string private key ) { this . private key = private key ; }
public void set user name ( string user name ) { this . user name = user name ; }
public artifact filter get resolution filter ( ) { return resolution filter ; }
public maven project get project ( ) { return project ; }
public set < string > get export artifact ( ) { return artifact ; }
public set get dependency artifact ( ) { return dependency artifact ; }
public set get artifact ( ) { return artifact == null ? collection . empty_set : artifact ; }
public string get version ( ) { return this . version ; } // -- string get version ( )
public string get maven opts ( ) { return maven opts ; }
public void set maven home ( file maven home ) { this . maven home = maven home ; }
public string get miss ( ) { return this . miss ; } // -- string get missing ( )
public void set arch ( string arch ) { this . arch = arch ; } // -- void set arch ( string )
public string get exists ( ) { return this . exist ; } // -- string get exists ( )
public string get default goal ( ) { return this . default goal ; } // -- string get default goal ( )
public void set source directory ( string source directory ) { this . source directory = source directory ; } // -- void set source directory ( string )
public void set timezone ( string timezone ) { this . timezone = timezone ; } // -- void set timezone ( string )
public string get system path ( ) { return this . system path ; } // -- string get system path ( )
public distribution management get distribution management ( ) { return this . distribution management ; } // -- distribution management get distribution management ( )
public deployment repository get repository ( ) { return this . repository ; } // -- deployment repository get repository ( )
public void set distribution management ( distribution management distribution management ) { this . distribution management = distribution management ; } // -- void set distribution management ( distribution management )
public string get status ( ) { return this . status ; } // -- string get status ( )
public int get line number ( ) { return this . line number ; } // -- int get line number ( )
public void set issue management ( issue management issue management ) { this . issue management = issue management ; } // -- void set issue management ( issue management )
public string get distribution ( ) { return this . distribution ; } // -- string get distribution ( )
public string get distribution ( ) { return this . distribution ; } // -- string get distribution ( )
public void set distribution ( string distribution ) { this . distribution = distribution ; } // -- void set distribution ( string )
public string get url ( ) { return this . url ; } // -- string get url ( )
public void set notifiers ( java . util . list < notifier > notifiers ) { this . notifiers = notifiers ; } // -- void set notifiers ( java . util . list )
public void set system ( string system ) { this . system = system ; } // -- void set system ( string )
public void set subscribe ( string subscribe ) { this . subscribe = subscribe ; } // -- void set subscribe ( string )
public void set model version ( string model version ) { this . model version = model version ; } // -- void set model version ( string )
public void set reporting ( report reporting ) { this . report = reporting ; } // -- void set reporting ( report )
public void set reporting ( report reporting ) { this . report = reporting ; } // -- void set reporting ( report )
public void set organization url ( string organization url ) { this . organization url = organization url ; } // -- void set organization url ( string )
public string get relative path ( ) { return this . relative path ; } // -- string get relative path ( )
public void set extension ( string extension ) { this . extension = extension ; } // -- void set extension ( string )
public string get group id ( ) { return this . group id ; } // -- string get group id ( )
public void set maven ( string maven ) { this . maven = maven ; } // -- void set maven ( string )
public void set id ( string id ) { this . id = id ; } // -- void set id ( string )
public string get message ( ) { return this . message ; } // -- string get message ( )
public string get group id ( ) { return this . group id ; } // -- string get group id ( )
public void set exclude default ( string exclude default ) { this . exclude default = exclude default ; } // -- void set exclude default ( string )
public string get output directory ( ) { return this . output directory ; } // -- string get output directory ( )
public string get group id ( ) { return this . group id ; } // -- string get group id ( )
public string get checksum policy ( ) { return this . checksum policy ; } // -- string get checksum policy ( )
public string get enable ( ) { return this . enable ; } // -- string get enable ( )
public void set active profile ( list < profile > active profile ) { this . active profile = active profile ; }
public static < t > result < t > new result ( t model , iterable < ? extend model problem > problem ) { return new result < > ( have error ( problem ) , model , problem ) ; }
public default profile activation context set inactive profile id ( list < string > inactive profile id ) { if ( inactive profile id ! = null ) { this . inactive profile id = collection . unmodifiable list ( inactive profile id ) ; } else { this . inactive profile id = collection . empty list ( ) ; } return this ; }
public string get dependency collection require ( ) { return dependency collection require ; }
public void set artifact id ( string artifact id ) { this . artifact id = artifact id ; } // -- void set artifact id ( string )
public void set snapshot ( snapshot snapshot ) { this . snapshot = snapshot ; } // -- void set snapshot ( snapshot )
public collect request add manage dependency ( dependency manage dependency ) { if ( manage dependency ! = null ) { if ( this . manage dependency . be empty ( ) ) { this . manage dependency = new array list < dependency > ( ) ; } this . manage dependency . add ( manage dependency ) ; } return this ; }
public deploy request set artifact ( collection < artifact > artifacts ) { if ( artifact == null ) { this . artifacts = collection . empty list ( ) ; } else { this . artifacts = artifact ; } return this ; }
public deploy result set artifact ( collection < artifact > artifacts ) { if ( artifact == null ) { this . artifacts = collection . empty list ( ) ; } else { this . artifacts = artifact ; } return this ; }
public dependency set exclusion ( collection < exclusion > exclusion ) { if ( have equivalent exclusion ( exclusion ) ) { return this ; } return new dependency ( artifact , scope , optional , exclusion ) ; }
public install request set artifact ( collection < artifact > artifacts ) { if ( artifact == null ) { this . artifacts = collection . empty list ( ) ; } else { this . artifacts = artifact ; } return this ; }
public authentication builder add ntlm ( string workstation , string domain ) { add string ( authentication context . ntlm_workstation , workstation ) ; return add string ( authentication context . ntlm_domain , domain ) ; }
public local artifact request set repository ( list < remote repository > repository ) { if ( repository ! = null ) { this . repository = repository ; } else { this . repository = collection . empty list ( ) ; } return this ; }
public local artifact request set artifact ( artifact artifact ) { this . artifact = artifact ; return this ; }
public local metadata registration set repository ( remote repository repository ) { this . repository = repository ; return this ; }
public remote repository get repository ( ) { return repository ; }
public artifact descriptor policy request set artifact ( artifact artifact ) { this . artifact = artifact ; return this ; }
public artifact descriptor result set relocation ( list < artifact > relocation ) { if ( relocation == null ) { this . relocation = collection . empty list ( ) ; } else { this . relocation = relocation ; } return this ; }
public artifact request add repository ( remote repository repository ) { if ( repository ! = null ) { if ( this . repository . be empty ( ) ) { this . repository = new array list < remote repository > ( ) ; } this . repository . add ( repository ) ; } return this ; }
public artifact repository get repository ( ) { return repository ; }
public dependency request set filter ( dependency filter filter ) { this . filter = filter ; return this ; }
public metadata request set repository ( remote repository repository ) { this . repository = repository ; return this ; }
public metadata result set metadata ( metadata metadata ) { this . metadata = metadata ; return this ; }
public version get high version ( ) { if ( version . be empty ( ) ) { return null ; } return version . get ( version . size ( ) - 1 ) ; }
public version range result set version constraint ( version constraint version constraint ) { this . version constraint = version constraint ; return this ; }
public version range request set artifact ( artifact artifact ) { this . artifact = artifact ; return this ; }
public version range result get result ( ) { return result ; }
public artifact repository get repository ( version version ) { return repository . get ( version ) ; }
public byte buffer get data buffer ( ) { return ( data buffer ! = null ) ? data buffer . a read only buffer ( ) : null ; }
public long get content length ( ) { return content length ; }
public string get resource name ( ) { return resource name ; }
public < t > default service locator add service ( class < t > type , class < ? extend t > impl ) { get entry ( type , true ) . add service ( impl ) ; return this ; }
public remote repository get authoritative repository ( ) { return authoritative repository ! = null ? authoritative repository : repository ; }
public artifact transfer set artifact ( artifact artifact ) { this . artifact = artifact ; return this ; }
public artifact download set existence check ( boolean existence check ) { this . existence check = existence check ; return this ; }
public metadata transfer set metadata ( metadata metadata ) { this . metadata = metadata ; return this ; }
public put task set data byte ( byte [ ] bytes ) { this . data byte = ( bytes ! = null ) ? byte : empty ; data file = null ; return this ; }
public default repository system session set artifact type registry ( artifact type registry artifact type registry ) { fail if read only ( ) ; this . artifact type registry = artifact type registry ; if ( this . artifact type registry == null ) { this . artifact type registry = null artifact type registry . instance ; } return this ; }
public list < dependency > get dependency ( boolean include unresolved ) { list < dependency > dependencies = new array list < dependency > ( get node ( ) . size ( ) ) ; for ( dependency node node : get node ( ) ) { dependency dependency = node . get dependency ( ) ; if ( dependency ! = null ) { if ( include unresolved || dependency . get artifact ( ) . get file ( ) ! = null ) { dependency . add ( dependency ) ; } } } return dependency ; }
public void add ( collection < ? extend repository listener > listener ) { if ( listener ! = null ) { for ( repository listener listener : listener ) { add ( listener ) ; } } }
public authentication builder add ntlm ( string workstation , string domain ) { add string ( authentication context . ntlm_workstation , workstation ) ; return add string ( authentication context . ntlm_domain , domain ) ; }
public authentication builder add secret ( string key , string value ) { if ( value ! = null ) { authentication . add ( new secret authentication ( key , value ) ) ; } return this ; }
public authentication builder add secret ( string key , string value ) { if ( value ! = null ) { authentication . add ( new secret authentication ( key , value ) ) ; } return this ; }
public string get mirror of layout ( ) { return this . mirror of layout ; } // -- string get mirror of layout ( )
public void set mirror of layout ( string mirror of layout ) { this . mirror of layout = mirror of layout ; } // -- void set mirror of layout ( string )
public void set mirror of ( string mirror of ) { this . mirror of = mirror of ; } // -- void set mirror of ( string )
public void set repository ( java . util . list < repository > repository ) { this . repository = repository ; } // -- void set repository ( java . util . list )
public void set profile ( java . util . list profile ) { this . profile = profile ; } // -- void set profile ( java . util . list )
public string get non proxy host ( ) { return this . non proxy host ; } // -- string get non proxy host ( )
public string get username ( ) { return this . username ; } // -- string get username ( )
public string get file permission ( ) { return this . file permission ; } // -- string get file permission ( )
public void set directory permission ( string directory permission ) { this . directory permission = directory permission ; } // -- void set directory permission ( string )
public boolean be interactive mode ( ) { return this . interactive mode ; } // -- boolean be interactive mode ( )
public void set active profile ( java . util . list < string > active profile ) { this . active profile = active profile ; } // -- void set active profile ( java . util . list )
public list < string > get command line ( string executable , string [ ] argument ) { return get raw command line ( executable , argument ) ; }
public string [ ] get not include directory ( ) { slow scan ( ) ; return dirs not include . to array ( new string [ dirs not include . size ( ) ] ) ; }
public string [ ] get not include directory ( ) { slow scan ( ) ; return dirs not include . to array ( new string [ dirs not include . size ( ) ] ) ; }
public static boolean match ( string pattern , string str ) { return match ( pattern , str , true ) ; }
public int get error count ( ) { return _error list . size ( ) ; }
protect void cleanup ( ) { if ( reader loader ! = null ) { reader loader . cleanup ( ) ; reader loader = null ; } }
public static reactive stream factory instance ( ) { if ( instance == null ) { synchronize ( reactive stream factory resolver . class ) { if ( instance ! = null ) { return instance ; } class loader cl = access controller . do privilege ( ( privilege action < class loader > ) ( ) - > thread . current thread ( ) . get context class loader ( ) ) ; if ( cl == null ) { cl = reactive stream factory . class . get class loader ( ) ; } reactive stream factory new instance = load from spi ( cl ) ; if ( new instance == null ) { throw new illegal state exception ( `` no reactive stream factory implementation find ! `` ) ; } instance = new instance ; } } return instance ; }
protect void set feature ( string feature , boolean value ) throw build exception { log ( `` setting feature `` + feature + `` = `` + value , project . msg_debug ) ; try { xml reader . set feature ( feature , value ) ; } catch ( s a x not recognize exception e ) { throw new build exception ( `` parser `` + xml reader . get class ( ) . get name ( ) + `` do n't recognize feature `` + feature , e , get location ( ) ) ; } catch ( s a x not support exception e ) { throw new build exception ( `` parser `` + xml reader . get class ( ) . get name ( ) + `` do n't support feature `` + feature , e , get location ( ) ) ; } }
public void set thread per processor ( int num thread per processor ) { this . num thread per processor = num thread per processor ; }
public final expression optimize ( expression visitor visitor , item type context item type ) { return this ; }
protect void add non match ( string builder sb , string text ) { sb . append ( text ) ; }
public void set relative ( boolean relative ) { this . relative = relative ; }
public void set basedir ( file basedir ) { this . basedir = basedir ; }
public json object remove ( string name ) { if ( name == null ) { throw new null pointer exception ( `` name be null `` ) ; } int index = index of ( name ) ; if ( index ! = -1 ) { table . remove ( index ) ; name . remove ( index ) ; value . remove ( index ) ; } return this ; }
protect double get domain low bound ( double p ) { return 0 ; }
public string a string ( ) { throw new unsupported operation exception ( `` not a string : `` + to string ( ) ) ; }
public string to string ( ) { return to string ( writer config . minimal ) ; }
public int get offset ( ) { return location . offset ; }
public static < t extend comparable < t > > t geq ( comparable < t > value ) { return report matcher ( new great or equal < t > ( value ) ) . < t > return null ( ) ; }
public static < t extend comparable < t > > t geq ( comparable < t > value ) { return report matcher ( new great or equal < t > ( value ) ) . < t > return null ( ) ; }
public static < t extend comparable < t > > t geq ( comparable < t > value ) { return report matcher ( new great or equal < t > ( value ) ) . < t > return null ( ) ; }
public void set replace filter resource ( resource replace filter ) { this . replace filter resource = replace filter ; }
public void set token ( string token ) { create replace token ( ) . add text ( token ) ; }
public void set property resource ( resource property resource ) { this . property resource = property resource ; }
public synchronize void add task ( task t ) { if ( nested task ! = null ) { throw new build exception ( `` the retry task container accept a single nested task `` + `` ( which may be a sequential task container ) `` ) ; } nest task = t ; }
public void set retry count ( int n ) { retry count = n ; }
public void set retry delay ( int retry delay ) { if ( retry delay < 0 ) { throw new build exception ( `` delay must be a non-negative number `` ) ; } this . retry delay = retry delay ; }
protect string [ ] preprocess compiler args ( string [ ] compiler args ) { return compiler args ; }
public static < t extend comparable < t > > t geq ( comparable < t > value ) { return report matcher ( new great or equal < t > ( value ) ) . < t > return null ( ) ; }
public static < t > t nullable ( class < t > clazz ) { additional matcher . or ( be null ( ) , be a ( clazz ) ) ; return ( t ) primitives . default value ( clazz ) ; }
public boolean get curly brace denote code block ( int language index ) { return true ; }
public int new const ( final object cst ) { return new const item ( cst ) . index ; }
public int get offset ( ) { if ( ( flag & flag_resolved ) == 0 ) { throw new illegal state exception ( `` label offset position have not be resolve yet `` ) ; } return bytecode offset ; }
public frame < v > [ ] analyze and compute max ( final string owner , final method node method ) throw analyzer exception { method . max local = compute max local ( method ) ; method . max stack = -1 ; analyze ( owner , method ) ; method . max stack = compute max stack ( frame ) ; return frame ; }
public boolean contains ( final abstract insn node insn ) { abstract insn node i = first ; while ( i ! = null & & i ! = insn ) { i = i . next ; } return i ! = null ; }
public void visit attribute ( final attribute attr ) { buf . set length ( 0 ) ; buf . append ( tab ) . append ( `` attribute `` ) ; append descriptor ( -1 , attr . type ) ; if ( attr instanceof traceable ) { ( ( traceable ) attr ) . trace ( buf , null ) ; } else { buf . append ( `` : unknown\n `` ) ; } text . add ( buf . to string ( ) ) ; }
public void set strategy ( generator strategy strategy ) { if ( strategy == null ) strategy = default generator strategy . instance ; this . strategy = strategy ; }
public void set callback ( callback [ ] callback ) { if ( callback ! = null & & callback . length == 0 ) { throw new illegal argument exception ( `` array can not be empty `` ) ; } this . callback = callback ; }
public void merge sort ( int index , int lo , int hi ) { merge sort ( index , lo , hi , null ) ; }
public static list any list ( ) { return report matcher ( any . any ) . return list ( ) ; }
protect statement get statement ( ) throw s q l exception { if ( statement == null ) { statement = get connection ( ) . create statement ( ) ; statement . set escape processing ( escape processing ) ; } return statement ; }
public static power mockito stubber do nothing ( ) { return powermockito_core . do answer ( new do nothing ( ) ) ; }
public static verification mode at most ( int max number of invocation ) { return verification mode factory . at most ( max number of invocation ) ; }
public static < t > answer < t > return element of ( collection < ? > element ) { return ( answer < t > ) new returns element of ( element ) ; }
public static instantiator provider2 get instantiator provider ( ) { return registry . get instantiator provider ( ) ; }
public static < t > collection < t > a collection ( final iterator < ? extend t > iter ) { list < t > l = new array list < t > ( ) ; while ( iter . have next ( ) ) { l . add ( iter . next ( ) ) ; } return l ; }
public boolean be spy ( ) { return delegate . be spy ( to inspect ) ; }
public class < ? > field class ( ) { return field instance ! = null ? field instance . get class ( ) : null ; }
public void set ( object value ) { new field setter ( instance , field ) . set ( value ) ; }
public static instance field all declare field of ( object instance ) { list < instance field > instance field = new array list < instance field > ( ) ; for ( class < ? > clazz = instance . get class ( ) ; clazz ! = object . class ; clazz = clazz . get superclass ( ) ) { instance field . add all ( instance field in ( instance , clazz . get declared field ( ) ) ) ; } return new instance field ( instance , instance field ) ; }
public static list any list ( ) { return report matcher ( any . any ) . return list ( ) ; }
public string get delimiter ( ) { return delimiter ; }
public static long any long ( ) { return report matcher ( any . any ) . return zero ( ) ; }
public static < a > answer < void > to answer ( final void answer1 < a > answer ) { return new answer < void > ( ) { @ suppress warning ( `` unchecked `` ) public void answer ( invocation on mock invocation ) throw throwable { answer . answer ( ( a ) invocation . get argument ( 0 ) ) ; return null ; } } ; }
public static char any char ( ) { report matcher ( new instance of ( character . class , `` < any char > `` ) ) ; return 0 ; }
public static char any char ( ) { report matcher ( new instance of ( character . class , `` < any char > `` ) ) ; return 0 ; }
public static double double that ( matcher < double > matcher ) { report matcher ( matcher ) ; return 0 ; }
public < a extends annotation > ct annotation < a > annotate ( ct element element , class < a > annotation type , string annotation element name , object value ) { return annotate ( element , factory . type ( ) . create reference ( annotation type ) , annotation element name , value ) ; }
public stub invocation matcher add answer ( answer answer , boolean be consecutive , strictness stub strictness ) { invocation invocation = invocation for stub . get invocation ( ) ; mock progress ( ) . stub complete ( ) ; if ( answer instanceof validable answer ) { ( ( validable answer ) answer ) . validate for ( invocation ) ; } synchronize ( stub ) { if ( be consecutive ) { stub . get first ( ) . add answer ( answer ) ; } else { strictness effective strictness = stub strictness ! = null ? stub strictness : this . mock strictness ; stub . add first ( new stub invocation matcher ( answer , invocation for stub , effective strictness ) ) ; } return stub . get first ( ) ; } }
public static strictness determine strictness ( stub stubbing , mock creation setting mock setting , strictness test level strictness ) { if ( stub ! = null & & stubbing . get strictness ( ) ! = null ) { return stub . get strictness ( ) ; } if ( mock setting . be lenient ( ) ) { return strictness . lenient ; } return test level strictness ; }
public static < t > t verify ( t mock ) { return mockito_core . verify ( mock , time ( 1 ) ) ; }
public void forward ( http forward http forward ) { expectation . then forward ( http forward ) ; mock server client . send expectation ( expectation ) ; }
public mock server client clear ( http request http request ) { send request ( request ( ) . with method ( `` put `` ) . with path ( calculate path ( `` clear `` ) ) . with body ( http request ! = null ? http request serializer . serialize ( http request ) : `` `` , standard charsets . utf_8 ) ) ; return client class . cast ( this ) ; }
public mock server client reset ( ) { mock server event bus . get instance ( ) . publish ( event type . reset ) ; send request ( request ( ) . with method ( `` put `` ) . with path ( calculate path ( `` reset `` ) ) ) ; return client class . cast ( this ) ; }
public mock server client verify zero interaction ( ) throw assertion error { verification verification = verification ( ) . with request ( request ( ) ) . with time ( exactly ( 0 ) ) ; string result = send request ( request ( ) . with method ( `` put `` ) . with path ( calculate path ( `` verify `` ) ) . with body ( verification serializer . serialize ( verification ) , standard charsets . utf_8 ) ) . get body a string ( ) ; if ( result ! = null & & ! result . be empty ( ) ) { throw new assertion error ( result ) ; } return client class . cast ( this ) ; }
public http request with secure ( boolean be ssl ) { this . secure = be ssl ; return this ; }
public http override forward request with http request ( http request http request ) { this . http request = http request ; return this ; }
public http response with body ( string body ) { if ( body ! = null ) { this . body = new string body ( body ) ; } return this ; }
public http request with header ( list < header > header ) { this . header . with entry ( header ) ; return this ; }
public http response with cooky ( list < cookie > cooky ) { this . cooky . with entry ( cooky ) ; return this ; }
public http request with path ( string path ) { with path ( string ( path ) ) ; return this ; }
public string get message ( final string key ) { return get message ( locale . get default ( ) , key ) ; }
public uni < t > by ( duration duration ) { return infrastructure . on uni creation ( new uni delay on item < > ( upstream , duration , executor ) ) ; }
public uni < t > by ( duration duration ) { return infrastructure . on uni creation ( new uni delay on item < > ( upstream , duration , executor ) ) ; }
public int size ( ) { / * * it be possible for a thread to be interrupt or reschedule between the read of the producer and * consumer index , therefore protection be require to ensure size be within valid range . in the * event of concurrent polls/offers to this method the size be over estimate a we read consumer * index before the producer index . * / long after = lv consumer index ( ) ; while ( true ) { final long before = after ; final long current producer index = lv producer index ( ) ; after = lv consumer index ( ) ; if ( before == after ) { return ( int ) ( current producer index - after ) ; } } }
public field visitor visit field ( int access , string name , string desc , string signature , object value ) { if ( cv ! = null ) { return cv . visit field ( access , name , desc , signature , value ) ; } return null ; }
public int new method ( final string owner , final string name , final string desc , final boolean itf ) { return new method item ( owner , name , desc , itf ) . index ; }
public void visit jump insn ( int opcode , label label ) { if ( mv ! = null ) { mv . visit jump insn ( opcode , label ) ; } }
public void check ( final int api ) { if ( api == opcodes . asm4 ) { if ( parameter ! = null & & ! parameter . be empty ( ) ) { throw new unsupported class version exception ( ) ; } if ( visible type annotation ! = null & & ! visible type annotation . be empty ( ) ) { throw new unsupported class version exception ( ) ; } if ( invisible type annotation ! = null & & ! invisible type annotation . be empty ( ) ) { throw new unsupported class version exception ( ) ; } if ( try catch block ! = null ) { for ( int i = try catch block . size ( ) - 1 ; i > = 0 ; -- i ) { try catch block node try catch block = try catch block . get ( i ) ; if ( try catch block . visible type annotation ! = null & & ! try catch block . visible type annotation . be empty ( ) ) { throw new unsupported class version exception ( ) ; } if ( try catch block . invisible type annotation ! = null & & ! try catch block . invisible type annotation . be empty ( ) ) { throw new unsupported class version exception ( ) ; } } } for ( int i = instruction . size ( ) - 1 ; i > = 0 ; -- i ) { abstract insn node insn = instruction . get ( i ) ; if ( insn . visible type annotation ! = null & & ! insn . visible type annotation . be empty ( ) ) { throw new unsupported class version exception ( ) ; } if ( insn . invisible type annotation ! = null & & ! insn . invisible type annotation . be empty ( ) ) { throw new unsupported class version exception ( ) ; } if ( insn instanceof method insn node ) { boolean be interface = ( ( method insn node ) insn ) . itf ; if ( be interface ! = ( insn . opcode == opcodes . invokeinterface ) ) { throw new unsupported class version exception ( ) ; } } else if ( insn instanceof ldc insn node ) { object value = ( ( ldc insn node ) insn ) . cst ; if ( value instanceof handle || ( value instanceof type & & ( ( type ) value ) . get sort ( ) == type . method ) ) { throw new unsupported class version exception ( ) ; } } } if ( visible local variable annotation ! = null & & ! visible local variable annotation . be empty ( ) ) { throw new unsupported class version exception ( ) ; } if ( invisible local variable annotation ! = null & & ! invisible local variable annotation . be empty ( ) ) { throw new unsupported class version exception ( ) ; } } if ( api < opcodes . asm7 ) { for ( int i = instruction . size ( ) - 1 ; i > = 0 ; -- i ) { abstract insn node insn = instruction . get ( i ) ; if ( insn instanceof ldc insn node ) { object value = ( ( ldc insn node ) insn ) . cst ; if ( value instanceof constant dynamic ) { throw new unsupported class version exception ( ) ; } } } } }
public int get exception index ( ) { return ( value & 0x00 f f f f00 ) > > 8 ; }
public int get exception index ( ) { return ( value & 0x00 f f f f00 ) > > 8 ; }
public printer visit class type annotation ( final int type ref , final type path type path , final string desc , final boolean visible ) { throw new runtime exception ( `` must be overriden `` ) ; }
public void add ( string name , class type , boolean readable , boolean writeable ) { throw new java . lang . unsupported operation exception ( `` readable/writable property not support `` ) ; }
public static < t > t eval ( string expression , class < t > to type ) { return convert ( new m v e l interpret runtime ( expression ) . parse ( ) , to type ) ; }
public static < t > t execute expression ( final object compile expression , final object ctx , class < t > to type ) { return convert ( execute expression ( compile expression , ctx ) , to type ) ; }
public static object eval file ( file file , object ctx , map < string , object > var ) throw i o exception { cache map variable resolver factory factory = new cache map variable resolver factory ( var ) ; try { return _eval file ( file , ctx , factory ) ; } finally { factory . externalize ( ) ; } }
public static void downto ( date self , date to , closure closure ) { if ( self . compare to ( to ) > = 0 ) { for ( date i = ( date ) self . clone ( ) ; i . compare to ( to ) > = 0 ; i = previous ( i ) ) { closure . call ( i ) ; } } else throw new groovy runtime exception ( `` the argument ( `` + to + `` ) to downto ( ) can not be later than the value ( `` + self + `` ) it 's call on . `` ) ; }
public int increment line count ( int increment ) { return this . line count += increment ; }
public static coordinator environment bean get coordinator environment bean ( ) { return bean populator . get default instance ( coordinator environment bean . class ) ; }
public void set tx reaper cancel fail wait period ( long tx reaper cancel fail wait period ) { this . tx reaper cancel fail wait period = tx reaper cancel fail wait period ; }
public check action factory get check action factory ( ) { if ( checked action factory == null & & check action factory class name ! = null ) { synchronize ( this ) { if ( checked action factory == null & & check action factory class name ! = null ) { check action factory instance = classloading utility . load and instantiate class ( checked action factory . class , check action factory class name , null ) ; check action factory = instance ; } } } return checked action factory ; }
public string get var dir ( ) { return var dir ; }
public string get var dir ( ) { return var dir ; }
public int get cache store work item ( ) { if ( cache store work item < 0 ) { return 0 ; } return cache store work item ; }
public void set cache store size ( int cache store size ) { this . cache store size = cache store size ; }
public int get hierarchy timeout ( ) { if ( hierarchy timeout < 0 ) { return 100 ; } return hierarchy timeout ; }
public void set recovery backoff period ( int recovery backoff period ) { this . recovery backoff period = recovery backoff period ; }
public void set transaction status manager port ( int transaction status manager port ) { utility . validate port range ( transaction status manager port ) ; this . transaction status manager port = transaction status manager port ; }
public void set recovery activator class name ( list < string > recovery activator class name ) { synchronize ( this ) { if ( recovery activator class name == null ) { this . recovery activator = new array list < recovery activator > ( ) ; this . recovery activator class name = new array list < string > ( ) ; } else if ( ! recovery activator class name . equal ( this . recovery activator class name ) ) { this . recovery activator = null ; this . recovery activator class name = new array list < string > ( recovery activator class name ) ; } } }
public void set min file ( int min file ) { this . min file = min file ; }
public int get pool size ( ) { return pool size ; }
public void set compact min file ( int compact min file ) { this . compact min file = compact min file ; }
public void set file prefix ( string file prefix ) { this . file prefix = file prefix ; }
public void set file extension ( string file extension ) { this . file extension = file extension ; }
public string get store dir ( ) { return store dir ; }
public boolean be sync deletes ( ) { return sync delete ; }
public static boolean remove this ( uid pid uid ) { boolean ret_status = false ; try { ret_status = get store ( ) . remove_committed ( pid uid , _type name ) ; } catch ( object store exception ex ) { ts logger . i18 n logger . warn_recovery_ transaction status manager item_1 ( ex ) ; } return ret_status ; }
protect int get hash ( final xid xid ) { if ( xid == null ) { return 0 ; } if ( _the xid . format i d ! = x a tx converter . format_id ) { return super . get hash ( xid ) ; } return generate hash ( xid . format i d , xid . data , 0 , xid . gtrid_length ) ; }
public hashtable get jndi property ( ) { return ( hashtable ) jndi property . clone ( ) ; }
public boolean be support subtransactions ( ) { return support subtransactions ; }
public list < x a resource orphan filter > get xa resource orphan filter ( ) { synchronize ( this ) { if ( xa resource orphan filter == null ) { list < x a resource orphan filter > instance = classloading utility . load and instantiate class with init ( x a resource orphan filter . class , xa resource orphan filter class name ) ; xa resource orphan filter = instance ; } return new array list < x a resource orphan filter > ( xa resource orphan filter ) ; } }
public void set xa rollback optimization ( boolean xa rollback optimization ) { this . xa rollback optimization = xa rollback optimization ; }
public void set user transaction j n d i context ( string user transaction j n d i context ) { this . user transaction j n d i context = user transaction j n d i context ; }
public string get transaction manager j n d i context ( ) { return transaction manager j n d i context ; }
public void set xa resource recovery class name ( list < string > xa resource recovery class name ) { synchronize ( this ) { if ( xa resource recovery class name == null ) { this . xa resource recovery = null ; this . xa resource recovery class name = new array list < string > ( ) ; } else if ( ! xa resource recovery class name . equal ( this . xa resource recovery class name ) ) { this . xa resource recovery = null ; this . xa resource recovery class name = new array list < string > ( xa resource recovery class name ) ; } } }
public void set last resource optimisation interface class name ( string last resource optimisation interface class name ) { synchronize ( this ) { if ( last resource optimisation interface class name == null ) { this . last resource optimisation interface = null ; } else if ( ! last resource optimisation interface class name . equal ( this . last resource optimisation interface class name ) ) { this . last resource optimisation interface = null ; } this . last resource optimisation interface class name = last resource optimisation interface class name ; } }
public list < string > get xa resource recovery class name ( ) { synchronize ( this ) { return new array list < string > ( xa resource recovery class name ) ; } }
public void set xa resource recovery class name ( list < string > xa resource recovery class name ) { synchronize ( this ) { if ( xa resource recovery class name == null ) { this . xa resource recovery = null ; this . xa resource recovery class name = new array list < string > ( ) ; } else if ( ! xa resource recovery class name . equal ( this . xa resource recovery class name ) ) { this . xa resource recovery = null ; this . xa resource recovery class name = new array list < string > ( xa resource recovery class name ) ; } } }
public boolean be notify commit markable resource recovery module of complete branch ( ) { return notify commit markable resource recovery module of complete branch ; }
public static void bind j t a transaction synchronization registry implementation ( ) throw javax . naming . naming exception { bind j t a transaction synchronization registry implementation ( new initial context ( ) ) ; }
public void end element ( string uri , string local name , string q name ) throw s a x exception { if ( q name . to lower case ( ) . equal ( `` entry `` ) & & be entry ) { property . put ( current key , current buffer . to string ( ) . trim ( ) ) ; current key = null ; current buffer = null ; be entry = false ; } }
public void end element ( string uri , string local name , string q name ) throw s a x exception { if ( q name . to lower case ( ) . equal ( `` entry `` ) & & be entry ) { property . put ( current key , current buffer . to string ( ) . trim ( ) ) ; current key = null ; current buffer = null ; be entry = false ; } }
public boolean be connect ( ) { return connection ! = null & & session ! = null ; }
public void close ( ) throw j m s exception { if ( transaction helper . be transaction available ( ) ) { transaction helper . deregister x a resource ( xa session . get x a resource ( ) ) ; if ( jta logger . logger . be trace enable ( ) ) { jta logger . logger . trace ( `` delist `` + xa session + `` xa resource from the transaction `` ) ; } synchronization synchronization = new session closing synchronization ( xa session ) ; transaction helper . register synchronization ( synchronization ) ; if ( jta logger . logger . be trace enable ( ) ) { jta logger . logger . trace ( `` register synchronization to close the session : `` + synchronization ) ; } } else { xa session . close ( ) ; } }
public void forget ( xid xid ) throw x a exception { connection manager . connect and accept ( delegate - > delegate . forget ( xid ) ) ; }
public void after completion ( int status ) { if ( jta logger . logger . be trace enable ( ) ) { jta logger . logger . trace ( `` closing connection `` + connection ) ; } try { connection . close ( ) ; } catch ( j m s exception e ) { jta logger . i18 n logger . warn_failed_to_close_jms_connection ( connection . to string ( ) , e ) ; } }
public transaction synchronization registry get transaction synchronization registry ( ) { return transaction synchronization registry ; }
public void end general entity ( string name , augmentation augs ) throw x n i exception { if ( f document handler ! = null ) { f document handler . end general entity ( name , aug ) ; } } // end general entity ( string , augmentation )
public void end general entity ( string name , augmentation augs ) throw x n i exception { if ( f document handler ! = null ) { f document handler . end general entity ( name , aug ) ; } } // end general entity ( string , augmentation )
public object get x path comparable ( boolean order , string collator collator , x path context context ) { return this ; }
protect void print attribute value ( string text ) { int length = text . length ( ) ; for ( int j = 0 ; j < length ; j++ ) { char c = text . char at ( j ) ; if ( c == ' `` ' ) { f printer . print ( `` & quot ; `` ) ; } else { f printer . print ( c ) ; } } f printer . flush ( ) ; } // print attribute value ( string )
public void cleanup ( ) { f document scanner . cleanup ( f close stream ) ; } // cleanup ( )
protect static boolean synthesize ( augmentation augs ) { h t m l event info info = ( h t m l event info ) aug . get item ( augmentation ) ; return info ! = null ? info . be synthesize ( ) : false ; } // synthesize ( augmentation ) : boolean
protect static boolean synthesize ( augmentation augs ) { h t m l event info info = ( h t m l event info ) aug . get item ( augmentation ) ; return info ! = null ? info . be synthesize ( ) : false ; } // synthesize ( augmentation ) : boolean
public byte buf write double l e ( double value ) { return write long l e ( double . double to raw long bit ( value ) ) ; }
public int write byte ( ) { return buffer . writer index ( ) - start index ; }
public static int default num direct arena ( ) { return default_num_direct_arena ; }
public final int chunk size ( ) { return chunk size ; }
public final int chunk size ( ) { return chunk size ; }
public void update c r c ( final int value ) { final int crc = this . crc ; this . crc = crc < < 8 ^ crc32 table [ ( crc > > 24 ^ value ) & 0xff ] ; }
public static string encode ( string name , string value ) { return io . netty . handler . codec . http . cookie . client cookie encoder . lax . encode ( name , value ) ; }
public string origin ( ) { return origin . be empty ( ) ? `` * `` : origin . iterator ( ) . next ( ) ; }
public cors config builder allow credential ( ) { allow credential = true ; return this ; }
public set < http method > allow request method ( ) { return collection . unmodifiable set ( allow request method ) ; }
public cors config builder allow credential ( ) { allow credential = true ; return this ; }
public cors config builder max age ( final long max ) { max age = max ; return this ; }
public cors config builder expose header ( final string . . . header ) { expose header . add all ( array . a list ( header ) ) ; return this ; }
public cors config builder allow credential ( ) { allow credential = true ; return this ; }
public string get ( char sequence name ) { return get ( name . to string ( ) ) ; }
protect int get stream id ( object msg ) { if ( msg instanceof io . netty . handler . codec . http . http message ) { return ( ( io . netty . handler . codec . http . http message ) msg ) . header ( ) . get int ( abstract netty http request . stream_id , -1 ) ; } return -1 ; }
public void set discard threshold ( int discard threshold ) { this . discard threshold = check positive or zero ( discard threshold , `` discard threshold `` ) ; }
public void set body http data ( list < interface http data > data ) throw error data encoder exception { object util . check not null ( data , `` datas `` ) ; global body size = 0 ; body list data . clear ( ) ; current file upload = null ; during mixed mode = false ; multipart http data . clear ( ) ; for ( interface http data data : data ) { add body http data ( data ) ; } }
public string path ( ) { if ( path == null ) { path = decode component ( uri , 0 , path end idx ( ) , charset , true ) ; } return path ; }
public string path ( ) { if ( path == null ) { path = decode component ( uri , 0 , path end idx ( ) , charset , true ) ; } return path ; }
public int max frame payload length ( ) { return max frame payload length ; }
protect b encoder ignore max header list size ( boolean ignore max header list size ) { enforce non codec constraint ( `` encoder ignore max header list size `` ) ; this . encoder ignore max header list size = ignore max header list size ; return self ( ) ; }
protect b encoder ignore max header list size ( boolean ignore max header list size ) { enforce non codec constraint ( `` encoder ignore max header list size `` ) ; this . encoder ignore max header list size = ignore max header list size ; return self ( ) ; }
public static int stream id ( http2 exception e ) { return be stream error ( e ) ? ( ( stream exception ) e ) . stream id ( ) : connection_stream_id ; }
protect b validate header ( boolean validate header ) { enforce non codec constraint ( `` validate header `` ) ; this . validate header = validate header ; return self ( ) ; }
public short get code for u r i ( string uri ) { for ( short j = 0 ; j < uris use ; j++ ) { if ( uris [ j ] . equal ( uri ) ) { return j ; } } return -1 ; }
public ascii string sub sequence ( int start ) { return sub sequence ( start , length ( ) ) ; }
public boolean region match ( int this start , char sequence string , int start , int length ) { object util . check not null ( string , `` string `` ) ; if ( start < 0 || string . length ( ) - start < length ) { return false ; } final int this len = length ( ) ; if ( this start < 0 || this len - this start < length ) { return false ; } if ( length < = 0 ) { return true ; } final int that end = start + length ; for ( int i = start , j = this start + array offset ( ) ; i < that end ; i++ , j++ ) { if ( b2c ( value [ j ] ) ! = string . char at ( i ) ) { return false ; } } return true ; }
public type list . generic get bound ( ) { return new type list . generic . explicit ( bound ) ; }
public with implicit type with reference ( object value ) { return new with implicit type . of instance ( bootstrap method , handle argument , invocation provider , termination handler , assigner , type , value ) ; }
public implementation . composable with assigner ( assigner assigner ) { return new method delegation ( implementation delegate , parameter binder , ambiguity resolver , termination handler , bind resolver , assigner ) ; }
public static < e > queue < e > predicate queue ( final queue < e > queue , final predicate < ? super e > predicate ) { return predicate queue . predicate queue ( queue , predicate ) ; }
public zip entry writer zip entry writer ( ) throw i o exception { if ( zip entry writer == null ) { zip entry writer = new zip entry writer ( this ) ; } return zip entry writer ; }
public least square builder checker ( final convergence checker < evaluation > new checker ) { this . checker = new checker ; return this ; }
public double [ ] fit ( t f , final double [ ] initial guess ) { return fit ( integer . max_value , f , initial guess ) ; }
public static double distance inf ( vector1 d p1 , vector1 d p2 ) { return p1 . distance inf ( p2 ) ; }
public field vector3 d < t > subtract ( final field vector3 d < t > v ) { return new field vector3 d < t > ( x . subtract ( v . x ) , y . subtract ( v . y ) , z . subtract ( v . z ) ) ; }
public output < t > product ( ) { return product ; }
public polyhedron set rotate ( final vector3 d center , final rotation rotation ) { return ( polyhedron set ) apply transform ( new rotation transform ( center , rotation ) ) ; }
protect final t [ ] previous state linear combination ( final t . . . coefficient ) { return combine ( get previous state ( ) . get state ( ) , coefficient ) ; }
public annotate type builder < x > add to field ( field field , annotation annotation ) { if ( field . get ( field ) == null ) { field . put ( field , new annotation builder ( ) ) ; } field . get ( field ) . add ( annotation ) ; return this ; }
protect autodiscover response type get response type ( ) { return response type ; }
public static alternate mailbox load from xml ( ews xml reader reader ) throw exception { alternate mailbox alt mailbox = new alternate mailbox ( ) ; do { reader . read ( ) ; if ( reader . get node type ( ) . get node type ( ) == xml node type . start_element ) { if ( reader . get local name ( ) . equal ignore case ( xml element name . type ) ) { alt mailbox . set type ( reader . read element value ( string . class ) ) ; } else if ( reader . get local name ( ) . equal ignore case ( xml element name . display name ) ) { alt mailbox . set display name ( reader . read element value ( string . class ) ) ; } else if ( reader . get local name ( ) . equal ignore case ( xml element name . legacy d n ) ) { alt mailbox . set legacy d n ( reader . read element value ( string . class ) ) ; } else if ( reader . get local name ( ) . equal ignore case ( xml element name . server ) ) { alt mailbox . set server ( reader . read element value ( string . class ) ) ; } } } while ( ! reader . be end element ( xml namespace . autodiscover , xml element name . alternate mailbox ) ) ; return alt mailbox ; }
public string to string ( ) { return string . format ( `` % d , % 2d , % 4d , % 3d `` , this . major version , this . minor version , this . major build number , this . minor build number ) ; }
public folder bind to folder ( folder id folder id , property set property set ) throw exception { ews utility . validate param ( folder id , `` folder id `` ) ; ew utility . validate param ( property set , `` property set `` ) ; get folder request request = new get folder request ( this , service error handle . throw on error ) ; request . get folder id ( ) . add ( folder id ) ; request . set property set ( property set ) ; service response collection < get folder response > response = request . execute ( ) ; return response . get response at index ( 0 ) . get folder ( ) ; }
public change collection < item change > end sync folder item ( i async result async result ) throw exception { sync folder item request request = async request result . extract service request ( this , async result ) ; return request . end execute ( async result ) . get response at index ( 0 ) . get change ( ) ; }
public folder bind to folder ( folder id folder id , property set property set ) throw exception { ews utility . validate param ( folder id , `` folder id `` ) ; ew utility . validate param ( property set , `` property set `` ) ; get folder request request = new get folder request ( this , service error handle . throw on error ) ; request . get folder id ( ) . add ( folder id ) ; request . set property set ( property set ) ; service response collection < get folder response > response = request . execute ( ) ; return response . get response at index ( 0 ) . get folder ( ) ; }
public void load ( user configuration property property ) throw exception { this . initialize property ( enum set . of ( property ) ) ; this . service . load property for user configuration ( this , property ) ; }
public boolean try get value ( object key , out param < object > value ) { if ( this . dictionary . contains key ( key ) ) { value . set param ( this . dictionary . get ( key ) ) ; return true ; } else { value . set param ( null ) ; return false ; } }
public phone call play on phone ( item id item id , string dial string ) throw exception { ews utility . validate param ( item id , `` item id `` ) ; ew utility . validate param ( dial string , `` dial string `` ) ; play on phone request request = new play on phone request ( service ) ; request . set dial string ( dial string ) ; request . set item id ( item id ) ; play on phone response service response = request . execute ( ) ; phone call call information = new phone call ( service , service response . get phone call id ( ) ) ; return call information ; }
public static task folder bind ( exchange service service , folder id id ) throw exception { return task folder . bind ( service , id , property set . get first class property ( ) ) ; }
public static contact bind ( exchange service service , item id id , property set property set ) throw exception { return service . bind to item ( contact . class , id , property set ) ; }
public void add on subscription error ( i subscription error delegate subscription error ) { on subscription error . add ( subscription error ) ; }
public void set calendar folder permission level ( delegate folder permission level value ) { this . delegate folder permission . get ( xml element name . calendar folder permission level ) . set permission level ( value ) ; }
public void set user id ( user id value ) { if ( this . user id ! = null ) { this . user id . remove change event ( this ) ; } if ( this . can set field value ( this . user id , value ) ) { user id = value ; this . change ( ) ; } if ( this . user id ! = null ) { this . user id . add on change event ( this ) ; } }
public void add ( day of the week day of the week ) { if ( ! this . item . contains ( day of the week ) ) { this . item . add ( day of the week ) ; this . change ( ) ; } }
public void set end date ( date value ) { this . can set field value ( this . end date , value ) ; }
public boolean equal ( object obj ) { if ( this == obj ) { return true ; } if ( obj instanceof extend property definition ) { return extend property definition . be equal to ( this , ( extended property definition ) obj ) ; } else { return false ; } }
public static boolean to boolean ( string s ) { return ( `` on `` . equal ignore case ( s ) || `` true `` . equal ignore case ( s ) || `` yes `` . equal ignore case ( s ) ) ; }
public final hit search ( query query ) throw i o exception { return search ( query , ( filter ) null ) ; }
public void visit ( int version , int access , string name , string signature , string super name , string [ ] interface ) { if ( cv ! = null ) { cv . visit ( version , access , name , signature , super name , interface ) ; } }
public static call site bootstrap current ( lookup caller , string name , method type type ) { return real bootstrap ( caller , name , call_types . method . ordinal ( ) , type , false , true , false ) ; }
public persistent collection locate load collection ( collection persister persister , collection key key ) { final loading collection entry lce = locate load collection entry ( key ) ; if ( lce ! = null ) { if ( log . be trace enable ( ) ) { log . tracef ( `` return load collection : % s `` , message helper . collection info string ( persister , key . get key ( ) , get session ( ) . get factory ( ) ) ) ; } return lce . get collection ( ) ; } return null ; }
public lob creator build lob creator ( lob creation context lob creation context ) { return use contextual lob creation ? new contextual lob creator ( lob creation context ) : non contextual lob creator . instance ; }
public detach criterion create alias ( string association path , string alias , join type join type ) { criterion . create alias ( association path , alias , join type ) ; return this ; }
public string get alias ( dialect dialect , table table ) { return safe interning ( get alias ( dialect ) + alias constant helper . get ( table . get unique integer ( ) ) ) ; }
public static iterable < attribute definition > get identifier sub attribute ( abstract entity persister entity persister ) { return get singular sub attribute ( entity persister , entity persister , ( composite type ) entity persister . get identifier type ( ) , entity persister . get table name ( ) , entity persister . get root table identifier column name ( ) ) ; }
public final void serialize ( json generator g , serializer provider provider ) throw i o exception { / * nothing to output . . . should we signal an error tho ? * chance be , this be an erroneous call . for now , let 's * not do that ; serialize a explicit null . why ? because we * can not just omit a value a json object field name may have * be write out . * / g . write null ( ) ; }
public final void serialize ( json generator g , serializer provider provider ) throw i o exception { / * nothing to output . . . should we signal an error tho ? * chance be , this be an erroneous call . for now , let 's * not do that ; serialize a explicit null . why ? because we * can not just omit a value a json object field name may have * be write out . * / g . write null ( ) ; }
public string map method name ( final string owner , final string name , final string descriptor ) { return name ; }
public final void serialize ( json generator g , serializer provider provider ) throw i o exception { / * nothing to output . . . should we signal an error tho ? * chance be , this be an erroneous call . for now , let 's * not do that ; serialize a explicit null . why ? because we * can not just omit a value a json object field name may have * be write out . * / g . write null ( ) ; }
protect json deserializer < ? > create builder base deserializer ( java type value type , bean property map property map , boolean any view ) { return new builder base deserializer ( this , _bean desc , value type , property map , _back ref property , _ignorable prop , _ignore all unknown , any view ) ; }
protect json deserializer < ? > create builder base deserializer ( java type value type , bean property map property map , boolean any view ) { return new builder base deserializer ( this , _bean desc , value type , property map , _back ref property , _ignorable prop , _ignore all unknown , any view ) ; }
public json include . value find property inclusion ( json include . value def value ) { if ( _annotation introspector ! = null ) { json include . value incl = _annotation introspector . find property inclusion ( _class info ) ; if ( incl ! = null ) { return ( def value == null ) ? incl : def value . with override ( incl ) ; } } return def value ; }
public void cookie ( string name , string value , int max age ) { cookie ( name , value , max age , false ) ; }
public container serializer < ? > with value type serializer ( type serializer vt ) { if ( vt == null ) return this ; return _with value type serializer ( vt ) ; }
public map serializer with content inclusion ( object suppressable value ) { if ( suppressable value == _suppressable value ) { return this ; } _ensure override ( ) ; return new map serializer ( this , _value type serializer , suppressable value ) ; }
public java type construct type ( type type ) { return _from any ( null , type , empty_bindings ) ; }
public final serializer factory with additional serializers ( serializers additional ) { return with config ( _factory config . with additional serializers ( additional ) ) ; }
public map serializer with content inclusion ( object suppressable value ) { if ( suppressable value == _suppressable value ) { return this ; } _ensure override ( ) ; return new map serializer ( this , _value type serializer , suppressable value ) ; }
public enum declaration add enum ( string name , modifier . keyword . . . modifier ) { enum declaration enum declaration = new enum declaration ( create modifier list ( modifier ) , name ) ; get type ( ) . add ( enum declaration ) ; return enum declaration ; }
public pretty printer configuration set indent size ( int indent size ) { indentation indentation = get indentation ( ) . set size ( assert non negative ( indent size ) ) ; set indentation ( indentation ) ; return this ; }
public pretty printer configuration set order import ( boolean order import ) { wrapped configuration = order import ? add option ( new default configuration option ( config option . order_imports ) ) : remove option ( new default configuration option ( config option . order_imports ) ) ; return this ; }
protect type declaration < ? > find contain type decl ( node node ) { node parent = node ; while ( true ) { parent = demand parent node ( parent ) ; if ( parent instanceof type declaration ) { return ( type declaration < ? > ) parent ; } } }
public static boolean be a name ( node node ) { if ( node instanceof field access expr ) { field access expr field access expr = ( field access expr ) node ; return be a name ( field access expr . get scope ( ) ) ; } else { return node instanceof simple name || node instanceof name || node instanceof class or interface type || node instanceof name expr ; } }
public symbol reference < resolve type declaration > solve type in type ( resolve type declaration type declaration , string name ) { if ( type declaration instanceof java parser class declaration ) { return ( ( java parser class declaration ) type declaration ) . solve type ( name ) ; } if ( type declaration instanceof java parser interface declaration ) { return ( ( java parser interface declaration ) type declaration ) . solve type ( name ) ; } return symbol reference . unsolved ( resolve reference type declaration . class ) ; }
protect void add non match ( string builder sb , string text ) { sb . append ( text ) ; }
public schema tree load ( final json node schema ) { bundle . check not null ( schema , `` load cfg . null schema `` ) ; return dereferencing . new tree ( schema ) ; }
public plugin builder for log event ( final log event event ) { this . event = event ; return this ; }
public default repository system session set dependency traverser ( dependency traverser dependency traverser ) { fail if read only ( ) ; this . dependency traverser = dependency traverser ; return this ; }
public default authentication selector add ( string id , authentication auth ) { if ( auth ! = null ) { repos . put ( id , auth ) ; } else { repos . remove ( id ) ; } return this ; }
public version range result add version ( version version ) { if ( version . be empty ( ) ) { version = new array list < version > ( ) ; } version . add ( version ) ; return this ; }
public static dependency selector new instance ( dependency selector selector1 , dependency selector selector2 ) { if ( selector1 == null ) { return selector2 ; } else if ( selector2 == null || selector2 . equal ( selector1 ) ) { return selector1 ; } return new and dependency selector ( selector1 , selector2 ) ; }
public static < t > publisher builder < t > concat ( publisher builder < ? extend t > a , publisher builder < ? extend t > b ) { return instance ( ) . concat ( a , b ) ; }
public channel future handshake ( channel channel ) { object util . check not null ( channel , `` channel `` ) ; return handshake ( channel , channel . new promise ( ) ) ; }
protect full http response new handshake response ( full http request req , http header header ) { char sequence key = req . header ( ) . get ( http header name . sec_websocket_key ) ; if ( key == null ) { throw new web socket server handshake exception ( `` not a web socket request : missing key `` , req ) ; } full http response res = new default full http response ( http_1_1 , http response status . switching_protocols , req . content ( ) . alloc ( ) . buffer ( 0 ) ) ; if ( header ! = null ) { re . header ( ) . add ( header ) ; } string accept seed = key + websocket_07_accept_guid ; byte [ ] sha1 = web socket util . sha1 ( accept seed . get byte ( charset util . us_ascii ) ) ; string accept = web socket util . base64 ( sha1 ) ; if ( logger . be debug enable ( ) ) { logger . debug ( `` web socket version 07 server handshake key : { } , response : { } . `` , key , accept ) ; } res . header ( ) . set ( http header name . upgrade , http header value . websocket ) . set ( http header name . connection , http header value . upgrade ) . set ( http header name . sec_websocket_accept , accept ) ; string subprotocols = req . header ( ) . get ( http header name . sec_websocket_protocol ) ; if ( subprotocols ! = null ) { string select subprotocol = select subprotocol ( subprotocols ) ; if ( select subprotocol == null ) { if ( logger . be debug enable ( ) ) { logger . debug ( `` request subprotocol ( s ) not support : { } `` , subprotocols ) ; } } else { re . header ( ) . set ( http header name . sec_websocket_protocol , select subprotocol ) ; } } return re ; }
public final internal thread local map thread local map ( ) { return thread local map ; }
public void trace ( string format , object arg a , object arg b ) { if ( logger . be loggable ( level . fine ) ) { format tuple ft = message formatter . format ( format , arg a , arg b ) ; log ( self , level . fine , ft . get message ( ) , ft . get throwable ( ) ) ; } }
public void trace ( string format , object arg a , object arg b ) { if ( logger . be loggable ( level . fine ) ) { format tuple ft = message formatter . format ( format , arg a , arg b ) ; log ( self , level . fine , ft . get message ( ) , ft . get throwable ( ) ) ; } }
public void warn ( string msg ) { if ( logger . be loggable ( level . warn ) ) { log ( self , level . warning , msg , null ) ; } }
public void trace ( string format , object arg a , object arg b ) { if ( be trace enable ( ) ) { format tuple ft = message formatter . format ( format , arg a , arg b ) ; logger . log ( fqcn , trace capable ? level . trace : level . debug , ft . get message ( ) , ft . get throwable ( ) ) ; } }
public void debug ( string format , object arg ) { if ( logger . be debug enable ( ) ) { format tuple ft = message formatter . format ( format , arg ) ; logger . log ( fqcn , level . debug , ft . get message ( ) , ft . get throwable ( ) ) ; } }
public void warn ( string msg ) { logger . log ( fqcn , level . warn , msg , null ) ; }
public static string check non empty after trim ( final string value , final string name ) { string trim = check not null ( value , name ) . trim ( ) ; return check non empty ( trim , name ) ; }
public long get long ( string name , long default value ) { json value value = get ( name ) ; return value ! = null ? value . a long ( ) : default value ; }
public static long copy range ( final input stream input , final long len , final output stream output , final int buffersize ) throw i o exception { if ( buffersize < 1 ) { throw new illegal argument exception ( `` buffersize must be big than 0 `` ) ; } final byte [ ] buffer = new byte [ ( int ) math . min ( buffersize , len ) ] ; int n = 0 ; long count = 0 ; while ( count < len & & -1 ! = ( n = input . read ( buffer , 0 , ( int ) math . min ( len - count , buffer . length ) ) ) ) { output . write ( buffer , 0 , n ) ; count += n ; } return count ; }
public void decrement ( int from , int to ) { for ( int i=from ; i < to ; i++ ) { data [ i ] -- ; } }
public final void set ( v value ) { if ( value ! = internal thread local map . unset ) { internal thread local map thread local map = internal thread local map . get ( ) ; set know not unset ( thread local map , value ) ; } else { remove ( ) ; } }
public long ticket key resume ( ) { lock reader lock = context . ctx lock . read lock ( ) ; reader lock . lock ( ) ; try { return s s l context . session ticket key resume ( context . ctx ) ; } finally { reader lock . unlock ( ) ; } }
public ssl context builder client auth ( client auth client auth ) { this . client auth = check not null ( client auth , `` client auth `` ) ; return this ; }
public final long get close notify flush timeout millis ( ) { return close notify flush timeout millis ; }
public long end offset ( ) { return end offset ; }
public void set session cache enable ( boolean enable ) { long mode = enable ? mask | ssl . ssl_sess_cache_no_internal_lookup | ssl . ssl_sess_cache_no_internal_store : ssl . ssl_sess_cache_off ; lock writer lock = context . ctx lock . write lock ( ) ; writer lock . lock ( ) ; try { s s l context . set session cache mode ( context . ctx , mode ) ; if ( ! enable ) { session cache . clear ( ) ; } } finally { writer lock . unlock ( ) ; } }
public final void copy to ( abstract coalesce buffer queue dest ) { d . buf and listener pair . add all ( buf and listener pair ) ; d . increment readable byte ( readable byte ) ; }
public final string get name ( ) { return name ; }
protect static synchronize void init xml provider ( ) { if ( be initialize ) { return ; } be initialized = true ; try { init . init ( ) ; relationship transform service . register dsig provider ( ) ; crypto function . register bouncy castle ( ) ; } catch ( exception e ) { throw new runtime exception ( `` xml & bouncy castle- provider initialization fail `` , e ) ; } }
public secret key get m a c key ( ) { return mac key ; }
public static j w s algorithm parse ( final string s ) { if ( s . equal ( hs256 . get name ( ) ) ) { return hs256 ; } else if ( s . equal ( hs384 . get name ( ) ) ) { return hs384 ; } else if ( s . equal ( hs512 . get name ( ) ) ) { return hs512 ; } else if ( s . equal ( rs256 . get name ( ) ) ) { return rs256 ; } else if ( s . equal ( rs384 . get name ( ) ) ) { return rs384 ; } else if ( s . equal ( rs512 . get name ( ) ) ) { return rs512 ; } else if ( s . equal ( es256 . get name ( ) ) ) { return es256 ; } else if ( s . equal ( es256k . get name ( ) ) ) { return es256k ; } else if ( s . equal ( es384 . get name ( ) ) ) { return es384 ; } else if ( s . equal ( es512 . get name ( ) ) ) { return es512 ; } else if ( s . equal ( ps256 . get name ( ) ) ) { return ps256 ; } else if ( s . equal ( ps384 . get name ( ) ) ) { return ps384 ; } else if ( s . equal ( ps512 . get name ( ) ) ) { return ps512 ; } else if ( s . equal ( ed d s a . get name ( ) ) ) { return ed d s a ; } else { return new j w s algorithm ( s ) ; } }
public static boolean be support ( final algorithm alg , final provider provider ) { if ( alg instanceof j w s algorithm ) { return be support ( ( j w s algorithm ) alg , provider ) ; } if ( alg instanceof j w e algorithm ) { return be support ( ( j w e algorithm ) alg , provider ) ; } if ( alg instanceof encryption method ) { return be support ( ( encryption method ) alg , provider ) ; } throw new illegal argument exception ( `` unexpected algorithm class : `` + alg . get class ( ) . get canonical name ( ) ) ; }
public static boolean be support ( final algorithm alg , final provider provider ) { if ( alg instanceof j w s algorithm ) { return be support ( ( j w s algorithm ) alg , provider ) ; } if ( alg instanceof j w e algorithm ) { return be support ( ( j w e algorithm ) alg , provider ) ; } if ( alg instanceof encryption method ) { return be support ( ( encryption method ) alg , provider ) ; } throw new illegal argument exception ( `` unexpected algorithm class : `` + alg . get class ( ) . get canonical name ( ) ) ; }
public provider get content encryption provider ( ) { return ce provider ! = null ? ce provider : get provider ( ) ; }
public base64 u r l get initialization vector ( ) { return iv ; }
public state get state ( ) { return state ; }
public base64 u r l get y ( ) { return y ; }
public int get max key size ( ) { return max size bit ; }
public static curve for o i d ( final string oid ) { if ( p_256 . get o i d ( ) . equal ( oid ) ) { return p_256 ; } else if ( secp256k1 . get o i d ( ) . equal ( oid ) ) { return secp256k1 ; } else if ( p_384 . get o i d ( ) . equal ( oid ) ) { return p_384 ; } else if ( p_521 . get o i d ( ) . equal ( oid ) ) { return p_521 ; } else { return null ; } }
public long get lifespan ( final time unit time unit ) { if ( lifespan < 0 ) { return lifespan ; } return time unit . convert ( lifespan , this . time unit ) ; }
public key store get key store ( ) { return key store ; }
public base64 u r l get first factor c r t exponent ( ) { return dp ; }
public base64 u r l get first factor c r t exponent ( ) { return dp ; }
public long get lifespan ( final time unit time unit ) { if ( lifespan < 0 ) { return lifespan ; } return time unit . convert ( lifespan , this . time unit ) ; }
public long get put timestamp ( ) { return jwk set with timestamp ! = null ? jwk set with timestamp . get date ( ) . get time ( ) : -1l ; }
public static base64 u r l encode ( final byte [ ] bytes ) { return new base64 u r l ( base64 codec . encode to string ( byte , true ) ) ; }
public static base64 encode ( final byte [ ] bytes ) { return new base64 ( base64 codec . encode to string ( byte , false ) ) ; }
public static mac get initialize mac ( final hmac algorithm algorithm , final byte [ ] key ) { return get initialize mac ( algorithm . to string ( ) , key ) ; }
public static x509 certificate confirmation of ( final x509 certificate x509 cert ) { return new x509 certificate confirmation ( x509 cert utils . compute s h a256 thumbprint ( x509 cert ) ) ; }
public static x509 certificate confirmation of ( final x509 certificate x509 cert ) { return new x509 certificate confirmation ( x509 cert utils . compute s h a256 thumbprint ( x509 cert ) ) ; }
public set < string > get prohibit claim ( ) { return prohibit claim ; }
public void set token endpoint auth method ( final list < client authentication method > auth method ) { this . token endpoint auth method = auth method ; }
public issuer get issuer ( ) { return issuer ; }
public date get subject authentication time ( ) { return subject auth time ; }
public t l s client authentication get t l s client authentication ( ) { return ( t l s client authentication ) get client authentication ( ) ; }
public void set ( final t o ) { this . o = o ; }
public j s o n object to j s o n object ( ) { j s o n object json object = new j s o n object ( ) ; map . entry < string , j s o n object > cnf claim = to j w t claim ( ) ; json object . put ( cnf claim . get key ( ) , cnf claim . get value ( ) ) ; return json object ; }
public code verifier get code verifier ( ) { return code verifier ; }
public static device authorization error response parse ( final h t t p response http response ) throw parse exception { http response . ensure status code not o k ( ) ; return new device authorization error response ( error object . parse ( http response ) ) ; }
public j w t claim set to j w t claim set ( ) { if ( be sign ( ) ) { throw new illegal state exception ( ) ; } return j w t claim set utils . to j w t claim set ( to parameter ( ) ) ; }
public response mode imply response mode ( ) { return response mode . resolve ( rm , rt ) ; }
public user code get user code ( ) { return user code ; }
public sign j w t get request j w t ( ) { return sign request ; }
public c i b a error delivery to error delivery ( ) { return ( c i b a error delivery ) this ; }
public tokens get token ( ) { return token ; }
public client information get client information ( ) { return client info ; }
public uri get redirection u r i ( ) { if ( redirect u r be ! = null & & ! redirect u r be . be empty ( ) ) { return redirect u r be . iterator ( ) . next ( ) ; } else { return null ; } }
public void set logo u r i ( final uri logo u r i ) { logo u r i entry . put ( null , logo u r i ) ; }
public void set policy u r i ( final uri policy u r i ) { u r i utils . ensure scheme be h t t p sor h t t p ( policy u r i ) ; policy u r i entry . put ( null , policy u r i ) ; }
public j w e algorithm get request object j w e alg ( ) { return request object j w e alg ; }
public j w e algorithm get request object j w e alg ( ) { return request object j w e alg ; }
public sign j w t get software statement ( ) { return software statement ; }
public software version get software version ( ) { return software version ; }
public j w s algorithm get authorization j w s alg ( ) { return authz j w s alg ; }
public void set back channel token delivery mode ( final back channel token delivery mode back channel token delivery mode ) { this . back channel token delivery mode = back channel token delivery mode ; }
public void apply default ( ) { if ( rms == null ) { rms = new array list < > ( 2 ) ; rms . add ( response mode . query ) ; rms . add ( response mode . fragment ) ; } if ( gts == null ) { gts = new array list < > ( 2 ) ; gts . add ( grant type . authorization_code ) ; gts . add ( grant type . implicit ) ; } if ( token endpoint auth method == null ) { token endpoint auth method = new array list < > ( ) ; token endpoint auth method . add ( client authentication method . client_secret_basic ) ; } }
public uri get verification u r i complete ( ) { return verification u r i complete ; }
public j s o n object to j s o n object ( ) { j s o n object json object = new j s o n object ( ) ; map . entry < string , j s o n object > cnf claim = to j w t claim ( ) ; json object . put ( cnf claim . get key ( ) , cnf claim . get value ( ) ) ; return json object ; }
public d po p issuer get issuer ( ) { return issuer ; }
public base64 u r l get access token hash ( ) { return ath ; }
public state get state ( ) { return state ; }
public h t t p request to h t t p request ( final h t t p request . method method ) { if ( get endpoint u r i ( ) == null ) throw new serialize exception ( `` the endpoint uri be not specify `` ) ; h t t p request http request ; if ( method . equal ( h t t p request . method . get ) ) { http request = new h t t p request ( h t t p request . method . get , get endpoint u r i ( ) ) ; } else if ( method . equal ( h t t p request . method . post ) ) { http request = new h t t p request ( h t t p request . method . post , get endpoint u r i ( ) ) ; } else { throw new illegal argument exception ( `` the http request method must be get or post `` ) ; } http request . set query ( to query string ( ) ) ; return http request ; }
public void set query ( final string query ) { this . query = query ; }
public string get client x509 certificate subject d n ( ) { return client x509 certificate subject d n ; }
public static list < string > to string list ( final collection < lang tag > lang tag ) { if ( lang tag == null ) return null ; list < string > out = new array list < string > ( lang tag . size ( ) ) ; for ( lang tag lt : lang tag ) { out . add ( lt . to string ( ) ) ; } return out ; }
public t l s client authentication get t l s client authentication ( ) { return ( t l s client authentication ) get client authentication ( ) ; }
public static code challenge method parse ( final string value ) { if ( value . equal ( plain . get value ( ) ) ) { return plain ; } else if ( value . equal ( s256 . get value ( ) ) ) { return s256 ; } else { return new code challenge method ( value ) ; } }
public j s o n object to j s o n object ( ) { j s o n object o = access token . to j s o n object ( ) ; if ( refresh token ! = null ) o . put all ( refresh token . to j s o n object ( ) ) ; return o ; }
public access token type get scheme ( ) { return scheme ; }
public token get subject token ( ) { return subject token ; }
public authorization grant get authorization grant ( ) { return authz grant ; }
public token introspection success response to success response ( ) { return ( token introspection success response ) this ; }
public authorization grant get authorization grant ( ) { return authz grant ; }
public int get month ( ) { return month ; }
public static uri strip query string ( final uri uri ) { if ( uri == null ) return null ; try { return new uri ( uri . get scheme ( ) , null , uri . get host ( ) , uri . get port ( ) , uri . get path ( ) , null , uri . get fragment ( ) ) ; } catch ( u r i syntax exception e ) { return null ; } }
public country code get country ( ) { string code = get string claim ( country_claim_name ) ; if ( code == null ) { return null ; } try { return country code . parse ( code ) ; } catch ( parse exception e ) { return null ; } }
public string get country name ( ) { if ( codes_resource . be empty ( ) ) { input stream be = get class ( ) . get class loader ( ) . get resource a stream ( `` iso3166_3-codes . property `` ) ; try { codes_resource . load ( be ) ; } catch ( i o exception e ) { return null ; } } return codes_resource . get property ( get value ( ) ) ; }
public static i s o3166_1 alpha3 country code to alpha3 country code ( final i s o3166_1 alpha2 country code alpha2 code ) { lazy load map_2_3 ( ) ; string alpha3 code = map_2_3 . get property ( alpha2 code . get value ( ) ) ; return alpha3 code ! = null ? new i s o3166_1 alpha3 country code ( alpha3 code ) : null ; }
public string get description string ( ) { return description ; }
public content get content ( ) { return content ; }
public content get content ( ) { return content ; }
public attestation get attestation ( ) { return attestation ; }
public document detail get document detail ( ) { return document detail ; }
public date with time zone offset get creation time ( ) { return create at ; }
public date with time zone offset get creation time ( ) { return create at ; }
public j s o n object to j s o n object ( ) { j s o n object o = new j s o n object ( ) ; o . put ( `` type `` , get type ( ) . get value ( ) ) ; if ( get document number ( ) ! = null ) { o . put ( `` document_number `` , get document number ( ) . get value ( ) ) ; } if ( get personal number ( ) ! = null ) { o . put ( `` personal_number `` , get personal number ( ) . get value ( ) ) ; } if ( get serial number ( ) ! = null ) { o . put ( `` serial_number `` , get serial number ( ) . get value ( ) ) ; } if ( get date of issuance ( ) ! = null ) { o . put ( `` date_of_issuance `` , get date of issuance ( ) . to i s o8601 string ( ) ) ; } if ( get date of expiry ( ) ! = null ) { o . put ( `` date_of_expiry `` , get date of expiry ( ) . to i s o8601 string ( ) ) ; } if ( get issuer ( ) ! = null ) { j s o n object issuer object = get issuer ( ) . to j s o n object ( ) ; if ( ! issuer object . be empty ( ) ) { o . put ( `` issuer `` , issuer object ) ; } } return o ; }
public occupation get occupation ( ) { return occupation ; }
public verification process get verification process ( ) { return verification process ; }
public verification process get verification process ( ) { return verification process ; }
public void set u r i claim ( final string name , final uri value ) { if ( value ! = null ) set claim ( name , value . to string ( ) ) ; else claim . remove ( name ) ; }
public void set claim ( final string name , final object value , final lang tag lang tag ) { string key name = lang tag ! = null ? name + `` # `` + lang tag : name ; set claim ( key name , value ) ; }
public void set date claim ( final string name , final date value ) { if ( value ! = null ) set claim ( name , date utils . to second since epoch ( value ) ) ; else claim . remove ( name ) ; }
public j s o n object to j s o n object ( ) { j s o n object o = new j s o n object ( ) ; o . put ( verification_element , identity verification . to j s o n object ( ) ) ; o . put ( claims_element , claim set . to j s o n object ( ) ) ; return o ; }
public void set authentication time ( final date auth time ) { set date claim ( auth_time_claim_name , auth time ) ; }
public list < entity i d > get authority hint ( ) { list < string > string = get string list claim ( authority_hints_claim_name ) ; if ( string == null ) { return null ; } list < entity i d > trust chain = new link list < > ( ) ; for ( string s : string ) { trust chain . add ( new entity i d ( s ) ) ; } return trust chain ; }
public o i d c claim request with user info verify claim request ( final list < verify claim set request > user info verify list ) { return new o i d c claim request ( get i d token claim request ( ) , get user info claim request ( ) , get i d token verified claim request ( ) , user info verify list ! = null ? user info verify list : collection . < verified claim set request > empty list ( ) ) ; }
public string get family name ( ) { return get string claim ( family_name_claim_name ) ; }
public list < country code > get nationality ( ) { list < string > value = get string list claim ( nationalities_claim_name ) ; if ( value == null ) { return null ; } list < country code > cod = new link list < > ( ) ; for ( string v : value ) { if ( v ! = null ) { try { code . add ( country code . parse ( v ) ) ; } catch ( parse exception e ) { return null ; } } } return code ; }
public void set birth middle name ( final string birth middle name ) { set claim ( birth_middle_name_claim_name , birth middle name ) ; }
public entry remove user info claim ( final string claim name , final lang tag lang tag ) { return user info claim . remove ( to key ( claim name , lang tag ) ) ; }
public entry remove verify user info claim ( final string claim name , final lang tag lang tag ) { return verify user info claim . remove ( to key ( claim name , lang tag ) ) ; }
public j s o n object to j s o n object ( ) { j s o n object o = new j s o n object ( ) ; o . put ( verification_element , identity verification . to j s o n object ( ) ) ; o . put ( claims_element , claim set . to j s o n object ( ) ) ; return o ; }
public trust chain constraint get constraint ( ) { j s o n object o = get j s o n object claim ( constraints_claim_name ) ; if ( o == null ) { return null ; } try { return trust chain constraint . parse ( o ) ; } catch ( com . nimbusds . oauth2 . sdk . parse exception e ) { return null ; } }
public void set o auth client metadata ( final client metadata client metadata ) { j s o n object o = client metadata ! = null ? client metadata . to j s o n object ( ) : null ; set metadata ( federation metadata type . oauth_client , o ) ; }
public o i d c client metadata get r p metadata ( ) { j s o n object o = get metadata ( federation metadata type . openid_relying_party ) ; if ( o == null ) { return null ; } try { return o i d c client metadata . parse ( o ) ; } catch ( com . nimbusds . oauth2 . sdk . parse exception e ) { return null ; } }
public void set metadata policy j s o n object ( final j s o n object metadata policy ) { set claim ( metadata_policy_claim_name , metadata policy ) ; }
public uri get policy u r i ( ) { return policy u r i ; }
public federation entity metadata get federation entity metadata ( ) { j s o n object o = get metadata ( federation metadata type . federation_entity ) ; if ( o == null ) { return null ; } try { return federation entity metadata . parse ( o ) ; } catch ( com . nimbusds . oauth2 . sdk . parse exception e ) { return null ; } }
public metadata policy entry get entry ( final string parameter name ) { list < policy operation > policy operation = entry . get ( parameter name ) ; if ( policy operation == null ) { return null ; } return new metadata policy entry ( parameter name , policy operation ) ; }
public list < policy operation > remove ( final string parameter name ) { return entry . remove ( parameter name ) ; }
public subject get subject ( ) { return subject ; }
public list < entity i d constraint > get permit entity ( ) { return permit entity ; }
public entity statement retriever get entity statement retriever ( ) { return statement retriever ; }
public static claim request resolve ( final response type response type , final scope scope ) { return resolve ( response type , scope , collection . < scope . value , set < string > > empty map ( ) ) ; }
public void set user info j w e algs ( final list < j w e algorithm > user info j w e algs ) { this . user info j w e algs = user info j w e algs ; }
public void set document method ( final list < identity verification method > method ) { this . document method = method ; }
public void set attachment type ( final list < attachment type > attachment type ) { this . attachment type = attachment type ; }
public void set default max age ( final int default max age ) { this . default max age = default max age ; }
public void set initiate login u r i ( final uri login u r i ) { u r i utils . ensure scheme be h t t p s ( login u r i ) ; this . initiate login u r i = login u r i ; }
public jwt get user info j w t ( ) { return jwt ; }
public issuer get expect issuer ( ) { return expect issuer ; }
public client i d get client i d ( ) { return expect client i d ; }
public int get uri port ( ) { return url . port ( ) ; }
public int get uri port ( ) { return url . port ( ) ; }
public synchronize int get idle connection count ( ) { int total = 0 ; for ( real connection connection : connection ) { if ( connection . allocation . be empty ( ) ) total++ ; } return total ; }
public static void banner line ( string full name , string ver ) { system . out . print ( `` java compiler compiler version `` + version . full version + `` ( `` + full name ) ; if ( ! ver . equal ( `` `` ) ) { system . out . print ( `` version `` + ver ) ; } system . out . println ( `` ) `` ) ; }
public synchronize long size ( ) throw i o exception { initialize ( ) ; return size ; }
public synchronize long size ( ) throw i o exception { initialize ( ) ; return size ; }
@ override public void close ( ) throw i o exception { close ( error code . no_error , error code . cancel ) ; }
public void write request ( header header , string request line ) throw i o exception { if ( state ! = state_idle ) throw new illegal state exception ( `` state : `` + state ) ; sink . write utf8 ( request line ) . write utf8 ( `` \r\n `` ) ; for ( int i = 0 , size = header . size ( ) ; i < size ; i ++ ) { sink . write utf8 ( header . name ( i ) ) . write utf8 ( `` : `` ) . write utf8 ( header . value ( i ) ) . write utf8 ( `` \r\n `` ) ; } sink . write utf8 ( `` \r\n `` ) ; state = state_open_request_body ; }
public static boolean null equal ( object o1 , object o2 ) { return o1 == o2 || o1 ! = null & & o2 ! = null & & o1 . equal ( o2 ) ; }
public ok http client set connection pool ( connection pool connection pool ) { this . connection pool = connection pool ; return this ; }
public final reader char stream ( ) throw i o exception { reader r = reader ; return r ! = null ? r : ( reader = new input stream reader ( byte stream ( ) , charset ( ) ) ) ; }
public principal local principal ( ) { return ! local certificate . be empty ( ) ? ( ( x509 certificate ) local certificate . get ( 0 ) ) . get subject x500 principal ( ) : null ; }
@ override public string to string ( ) { return protocol ; }
public static list < i message > get message ( list < i message > message , i message . kind kind ) { if ( null == message ) { return collection . empty list ( ) ; } if ( null == kind ) { return message ; } array list < i message > result = new array list < i message > ( ) ; for ( i message message : message ) { if ( kind == message . get kind ( ) ) { result . add ( message ) ; } } if ( 0 == result . size ( ) ) { return collection . empty list ( ) ; } return result ; }
public int path size ( ) { return path segment . size ( ) ; }
@ override public void close ( ) throw i o exception { close ( error code . no_error , error code . cancel ) ; }
protect void set closure delegate ( closure closure , object node ) { closure . set delegate ( this ) ; }
protect void add non match ( string builder sb , string text ) { sb . append ( text ) ; }
public boolean be multiplexed ( ) { return http2 connection ! = null ; }
public int call timeout millis ( ) { return call timeout ; }
public string username ( ) { return username ; }
public string username ( ) { return username ; }
public int write timeout millis ( ) { return write timeout ; }
public int call timeout millis ( ) { return call timeout ; }
public byte string hmac sha256 ( byte string key ) { return hmac ( `` hmac s h a256 `` , key ) ; }
public string base64 ( ) { return base64 . encode ( data ) ; }
public byte string sha256 ( ) { return digest ( `` sha-256 `` ) ; }
public byte string hmac sha256 ( byte string key ) { return hmac ( `` hmac s h a256 `` , key ) ; }
public byte string substring ( int begin index ) { return substring ( begin index , data . length ) ; }
public timeout clear deadline ( ) { this . have deadline = false ; return this ; }
public byte string md5 ( ) { return digest ( `` md5 `` ) ; }
public string get h algorithm ( ) { return _h algorithm ; }
public association session type get type ( ) throw association exception { return association session type . create ( get session type ( ) , get association type ( ) , ! be version2 ( ) ) ; }
public string get modulus ( ) { big integer p = _dh parameter spec . get p ( ) ; return new string ( base64 . encode base64 ( p . to byte array ( ) ) ) ; }
public d h parameter spec get d h params ( ) { return _dh params ; }
public void set pref assoc sess enc ( association session type pref assoc sess enc ) { this . _pref assoc sess enc = pref assoc sess enc ; }
public association session type get pref assoc sess enc ( ) { return _pref assoc sess enc ; }
public boolean be immediate auth ( ) { return _immediate auth ; }
public list get endpoint ( ) { return _endpoints ; }
public url get url ( ) { return _yadis url ; }
public boolean be version2 ( ) { return have parameter ( `` openid . n `` ) & & openid2_ns . equal ( get parameter value ( `` openid . n `` ) ) ; }
public boolean be version2 ( ) { return have parameter ( `` openid . n `` ) & & openid2_ns . equal ( get parameter value ( `` openid . n `` ) ) ; }
public void set type ( association session type type ) { set ( `` session_type `` , type . get session type ( ) ) ; set ( `` assoc_type `` , type . get association type ( ) ) ; }
public void set sign field ( string user supply list ) { if ( user supply list ! = null ) { _sign field = array . a list ( user supply list . split ( `` , `` ) ) ; build sign list ( ) ; } }
public string get error description ( ) { return _parameters . get parameter value ( `` error `` ) ; }
public association session type get type ( ) throw association exception { return association session type . create ( get session type ( ) , get association type ( ) , ! be version2 ( ) ) ; }
public set get extension ( ) { return _ext alias . key set ( ) ; }
public parameter list get parameter ( ) { return _parameters ; }
public string get type uri ( ) { return openid_ns_pape ; }
public string get update url ( ) { return _parameters . have parameter ( `` policy_url `` ) ? _parameters . get parameter value ( `` policy_url `` ) : null ; }
public void set sign field ( string sign field ) { this . _sign field = sign field ; }
public void set output stream ( boolean output stream ) { this . output stream = output stream ; }
public boolean have error ( ) { return ! get processing error ( ) . be empty ( ) ; }
public serializable get value ( ) { return this . value ; }
public string get authz endpoint ( ) { return authz endpoint ; }
public string get authz endpoint ( ) { return authz endpoint ; }
public category get category ( final string category id ) { if ( category id == null ) { return get category ( autogenerated_category_id ) ; } check id ( category id ) ; category category = category by id . get ( category id ) ; if ( category == null ) { category = new category ( category id ) ; category by id . put ( category id , category ) ; category . add category listener ( this ) ; } return category ; }
public final int compare to ( final object object ) { final parameter type cast object = ( parameter type ) object ; int compare to = util . compare ( define , cast object . define ) ; if ( compare to == 0 ) { compare to = util . compare ( id , casted object . id ) ; } return compare to ; }
public category get category ( final string category id ) { if ( category id == null ) { return get category ( autogenerated_category_id ) ; } check id ( category id ) ; category category = category by id . get ( category id ) ; if ( category == null ) { category = new category ( category id ) ; category by id . put ( category id , category ) ; category . add category listener ( this ) ; } return category ; }
public final context [ ] get define context ( ) { return ( context [ ] ) define handle object . to array ( new context [ define handle object . size ( ) ] ) ; }
public final boolean be category define ( ) { return ( ( ( change value & changed_category_defined ) ! = 0 ) & & ( category id ! = null ) ) ; }
public final context get context ( final string context id ) { check id ( context id ) ; context context = ( context ) handle object by id . get ( context id ) ; if ( context == null ) { context = new context ( context id ) ; handle object by id . put ( context id , context ) ; context . add context listener ( this ) ; } return context ; }
public void set value ( final object value ) { if ( ! object . equal ( this . value , value ) ) { final object old value = this . value ; this . value = value ; fire state change ( old value ) ; } }
public void add state ( final string id , final state state ) { super . add state ( id , state ) ; state . set id ( id ) ; if ( handler instanceof i object with state ) { ( ( i object with state ) handler ) . add state ( id , state ) ; } }
public final void internal initialize ( property tester descriptor descriptor ) { f properties= descriptor . get property ( ) ; f namespace= descriptor . get namespace ( ) ; f config element= descriptor . get configuration element ( ) ; }
public void add mi behave expression type ( class < ? > clazz ) { if ( f misbehave expression type == null ) { f misbehave expression types= new array list < > ( 2 ) ; f misbehave expression type . add ( clazz ) ; } else if ( ! f misbehave expression type . contains ( clazz ) ) { f misbehave expression type . add ( clazz ) ; } }
public final void internal initialize ( property tester descriptor descriptor ) { f properties= descriptor . get property ( ) ; f namespace= descriptor . get namespace ( ) ; f config element= descriptor . get configuration element ( ) ; }
protect void handle file delete ( ) { f manager . fire underlie file delete ( this ) ; }
public i document setup participant [ ] get document setup participant ( i path location , location kind location kind ) { set < i document setup participant > participants= new hash set < > ( ) ; list < i document setup participant > p= get document setup participant ( find content type ( location , location kind ) ) ; if ( p ! = null ) participant . add all ( p ) ; p= get document setup participant ( location . last segment ( ) ) ; if ( p ! = null ) participant . add all ( p ) ; p= get document setup participant ( location . get file extension ( ) ) ; if ( p ! = null ) participant . add all ( p ) ; p= get document setup participant ( wildcard ) ; if ( p ! = null ) participant . add all ( p ) ; i document setup participant [ ] result= new i document setup participant [ participant . size ( ) ] ; participant . to array ( result ) ; return result ; }
public i annotation model factory get annotation model factory ( i path location , location kind location kind ) { i annotation model factory factory= get annotation model factory ( find content type ( location , location kind ) ) ; if ( factory == null ) factory= get annotation model factory ( location . last segment ( ) ) ; if ( factory == null ) factory= get annotation model factory ( location . get file extension ( ) ) ; if ( factory == null ) factory= get annotation model factory ( wildcard ) ; return factory ; }
public byte [ ] get byte ( final charset charset ) { return line separator . get byte ( charset ) ; }
public void set directory ( boolean value ) { if ( value ) set ( attribute_directory ) ; else clear ( attribute_directory ) ; }
public static i file store get store ( uri uri ) throw core exception { return internal file system core . get instance ( ) . get store ( uri ) ; }
public static i file system get null file system ( ) { return internal file system core . get instance ( ) . get null file system ( ) ; }
public static boolean be use native ( ) { return have native ; }
protect int force release ( ) { int old depth = depth ; do release ( ) ; return old depth ; }
public void clear ( ) { dummy . set next ( dummy ) ; dummy . set previous ( dummy ) ; }
public static final i job manager get job manager ( ) { return manager ; }
public final string get match node name ( ) { return pattern . get matches node name ( ) ; }
public boolean be index variable ( ) { return be index ; }
public final job group get job group ( ) { return super . get job group ( ) ; }
public delta data tree assemble with forward delta ( delta data tree delta tree ) { return new delta data tree ( get root node ( ) . assemble with ( delta tree . get root node ( ) ) , this ) ; }
public void make complete ( ) { abstract data tree node assemble = get root node ( ) ; delta data tree my parent = get parent ( ) ; while ( my parent ! = null ) { assembled = my parent . get root node ( ) . assemble with ( assemble ) ; my parent = my parent . get parent ( ) ; } set root node ( assemble ) ; set parent ( null ) ; }
protect void add child ( i path parent key , string local name , abstract data tree node child node ) { if ( ! include ( parent key ) ) handle not find ( parent key ) ; child node . set name ( local name ) ; this . assemble node ( parent key , new no data delta node ( parent key . last segment ( ) , child node ) ) ; }
public multi status get sync status ( ) { return status ; }
public i folder change to folder ( ) throw core exception { get property manager ( ) . delete property ( this , i resource . depth_zero ) ; i folder result = workspace . get root ( ) . get folder ( path ) ; if ( be link ( ) ) { i path location = get raw location ( ) ; delete ( i resource . none , null ) ; result . create link ( location , i resource . allow_missing_local , null ) ; } else { workspace . delete resource ( this ) ; workspace . create resource ( result , false ) ; } return result ; }
public i marker [ ] find marker ( string type , boolean include subtypes , i progress monitor monitor ) throw core exception { final resource traversal [ ] traversal = get traversal ( resource mapping context . local_context , monitor ) ; array list < i marker > result = new array list < > ( ) ; for ( resource traversal traversal : traversal ) traversal . do find marker ( result , type , include subtypes ) ; return result . to array ( new i marker [ result . size ( ) ] ) ; }
public string get option ( string option , string dft value ) { object value = get option ( option ) ; return ( value == null ) ? dft value : value . to string ( ) ; }
public boolean be persistent ( string type ) { marker type definition def = definition . get ( type ) ; return def ! = null & & def . be persistent ; }
protect void rehash to ( int an index ) { int target = an index ; int index = an index + 1 ; if ( index > = element . length ) index = 0 ; i marker set element element = element [ index ] ; while ( element ! = null ) { int hash index = hash for ( element . get id ( ) ) % element . length ; boolean match ; if ( index < target ) match = ! ( hash index > target || hash index < = index ) ; else match = ! ( hash index > target & & hash index < = index ) ; if ( match ) { element [ target ] = element ; target = index ; } index++ ; if ( index > = element . length ) index = 0 ; element = element [ index ] ; } elements [ target ] = null ; }
public static boolean be valid setter ( method method ) { if ( method . get name ( ) . start with ( `` set `` ) & & method . get name ( ) . length ( ) > 3 & & method . get parameter type ( ) . length == 1 & & method . get return type ( ) . get name ( ) . equal ( `` void `` ) ) { return true ; } return false ; }
public void write description ( i project description description , int update flag , boolean have public change , boolean have private change ) throw core exception { if ( project description . be read ) return ; project description . be write = true ; try { get local manager ( ) . internal write ( this , description , update flag , have public change , have private change ) ; } finally { project description . be write = false ; } }
public object get property store ( ) { return property store ; }
public void clear ( int mask ) { flags & = ~mask ; }
public void clear ( int mask ) { flags & = ~mask ; }
public uri compute u r i ( i path workspace path ) { return compute u r i ( workspace path , false ) ; }
public uri compute u r i ( i path workspace path ) { return compute u r i ( workspace path , false ) ; }
public void add string pool participant ( i string pool participant participant , i scheduling rule rule ) { participant . put ( participant , rule ) ; if ( get state ( ) == job . sleep ) wake up ( initial_delay ) ; else schedule ( initial_delay ) ; }
public element tree read tree ( data input input , string new project name ) throw i o exception { / * the format version number have already be consume * by element tree reader # read from . * / element tree result = new element tree ( data tree reader . read tree ( null , input , new project name ) ) ; return result ; }
public void write delta ( element tree old tree , element tree new tree , i path path , int depth , final data output output , i element comparator comparator ) throw i o exception { / * write the version number * / write number ( current_format , output ) ; / * * * note that in current element tree usage , the new * tree be the complete tree , and old tree be just * delta on the new tree . * / delta data tree complete tree = new tree . get data tree ( ) ; delta data tree derive tree = old tree . get data tree ( ) ; delta data tree delta to write = null ; delta to write = complete tree . forward delta with ( derive tree , comparator ) ; assert . be true ( delta to write . be immutable ( ) ) ; data tree writer . write tree ( delta to write , path , depth , output ) ; }
public final void remember last built state ( ) { super . remember last built state ( ) ; }
public i status validate save ( i file file ) { return validate edit ( new i file [ ] { file } , ( file modification validation context ) null ) ; }
public i marker [ ] find marker ( string type , boolean include subtypes , i progress monitor monitor ) throw core exception { final resource traversal [ ] traversal = get traversal ( resource mapping context . local_context , monitor ) ; array list < i marker > result = new array list < > ( ) ; for ( resource traversal traversal : traversal ) traversal . do find marker ( result , type , include subtypes ) ; return result . to array ( new i marker [ result . size ( ) ] ) ; }
public void add message ( log record record ) { _log monitor . add message ( record ) ; }
public boolean be symbolic link ( ) { return ( attribute & efs . attribute_symlink ) ! = 0 ; }
public synchronize void add property change listener ( i property change listener listener ) { if ( listener . size ( ) == 0 ) { eclipse preference prefs = get plugin preference ( false ) ; if ( prefs ! = null ) { prefs . add preference change listener ( this ) ; } plugin root . add node change listener ( this ) ; } listener . add ( listener ) ; }
public long get long ( string name ) { return get plugin preference ( true ) . get long ( name , get default preference ( ) . get long ( name , long_default_default ) ) ; }
public boolean get boolean ( string name ) { return get plugin preference ( true ) . get boolean ( name , get default preference ( ) . get boolean ( name , boolean_default_default ) ) ; }
public static void remove listener ( performance listener listener ) { if ( enable ) performance stats processor . remove listener ( listener ) ; }
public void start run ( string context name ) { if ( ! enable ) return ; this . context = context name ; this . current start = system . current time millis ( ) ; }
public static url to file u r l ( url url ) throw i o exception { u r l converter converter = activator . get u r l converter ( url ) ; return converter == null ? url : converter . to file u r l ( url ) ; }
public static location get configuration location ( ) { return internal platform . get default ( ) . get configuration location ( ) ; }
protect type var to type var ( int dim ) { return null ; }
public static string get n l extension ( ) { return internal platform . get default ( ) . get n l extension ( ) ; }
public static string [ ] know w s value ( ) { return internal platform . get default ( ) . know w s value ( ) ; }
public static bundle [ ] get fragment ( bundle bundle ) { return internal platform . get default ( ) . get fragment ( bundle ) ; }
protect void build project ( final i project [ ] project , i progress monitor monitor ) throw core exception { i workspace runnable build = pm - > { sub monitor localmonitor = sub monitor . convert ( pm , debug core message . launch configuration delegate_scoped_incremental_build , project . length ) ; try { for ( i project project : project ) { if ( localmonitor . be cancel ( ) ) { throw new operation cancel exception ( ) ; } project . build ( incremental project builder . incremental_build , localmonitor . new child ( 1 ) ) ; } } finally { localmonitor . do ( ) ; } } ; resource plugin . get workspace ( ) . run ( build , monitor ) ; }
public void fire resume event ( int detail ) { fire event ( new debug event ( this , debug event . resume , detail ) ) ; }
public void set readable ( boolean readable ) { flags |= memory byte . readable ; if ( ! readable ) flag ^= memory byte . readable ; }
public boolean be writable ( ) { return ( ( flag & memory byte . writable ) == memory byte . writable ) ; }
public i refresh monitor install monitor ( i resource resource , i refresh result result , i progress monitor progress monitor ) { if ( resource . get location ( ) == null || ! resource . exists ( ) || resource . get type ( ) == i resource . file ) return null ; if ( monitor == null ) monitor = new win32 monitor ( result ) ; if ( monitor . monitor ( resource ) ) return monitor ; return null ; }
protect void clear cache element ( object duplicate ) { if ( f resolve element ! = null ) { f resolve element . remove ( duplicate ) ; } }
protect boolean be find duplicate ( ) { i source lookup director director = get director ( ) ; if ( director ! = null ) { if ( director instanceof abstract source lookup director ) { abstract source lookup director asld = ( abstract source lookup director ) director ; i source lookup participant participant = asld . get current participant ( ) ; if ( participant instanceof abstract source lookup participant ) { abstract source lookup participant aslp = ( abstract source lookup participant ) participant ; return aslp . be find duplicate ( ) ; } } return director . be find duplicate ( ) ; } return false ; }
protect void warn ( string message , throwable exception ) throw core exception { i status status = new status ( i status . warning , debug plugin . get unique identifier ( ) , debug plugin . error , message , exception ) ; throw new core exception ( status ) ; }
protect string serialize document ( document document ) throw core exception { return debug plugin . serialize document ( document ) ; }
public i container get container ( ) { return f container ; }
public i container get container ( ) { return f container ; }
public synchronize i breakpoint manager get breakpoint manager ( ) { if ( f breakpoint manager == null ) { f breakpoint manager = new breakpoint manager ( ) ; } return f breakpoint manager ; }
public boolean can terminate ( ) { synchronize ( sub launch ) { if ( sub launch . be empty ( ) ) { return false ; } for ( i launch launch : sub launch . key set ( ) ) { if ( launch . can terminate ( ) ) { return true ; } } return false ; } }
protect void set prototype ( i launch configuration prototype ) { f prototype = prototype ; }
protect void set set attribute ( element element ) throw core exception { string set key = element . get attribute ( key ) ; node list node list = element . get child node ( ) ; int entry count = node list . get length ( ) ; set < string > set = new hash set < > ( entry count ) ; node node = null ; element selement = null ; for ( int i = 0 ; i < entry count ; i++ ) { node = node list . item ( i ) ; if ( node . get node type ( ) == node . element_node ) { selement = ( element ) node ; if ( ! selement . get node name ( ) . equal ignore case ( set_entry ) ) { throw get invalid format debug exception ( ) ; } set . add ( get value attribute ( selement ) ) ; } } set attribute ( set key , set ) ; }
protect launch configuration info get copy ( ) { launch configuration info copy = new launch configuration info ( ) ; copy . set type ( get type ( ) ) ; copy . set attribute table ( get attribute ( ) ) ; copy . set be prototype ( be prototype ( ) ) ; copy . set prototype ( get prototype ( ) ) ; copy . set visible attribute ( get visible attribute ( ) ) ; return copy ; }
protect launch configuration info get copy ( ) { launch configuration info copy = new launch configuration info ( ) ; copy . set type ( get type ( ) ) ; copy . set attribute table ( get attribute ( ) ) ; copy . set be prototype ( be prototype ( ) ) ; copy . set prototype ( get prototype ( ) ) ; copy . set visible attribute ( get visible attribute ( ) ) ; return copy ; }
public void migrate ( i launch configuration candidate ) throw core exception { initialize migration delegate ( ) ; if ( f migration delegate ! = null ) { f migration delegate . migrate ( candidate ) ; } }
protect void fire terminate ( ) { set attribute ( debug plugin . attr_terminate_timestamp , long . to string ( system . current time millis ( ) ) ) ; if ( ! f suppress change ) { ( ( launch manager ) get launch manager ( ) ) . fire update ( this , launch manager . terminate ) ; ( ( launch manager ) get launch manager ( ) ) . fire update ( new i launch [ ] { this } , launch manager . terminate ) ; } remove event listener ( ) ; }
protect void launch configuration delete ( i launch configuration config ) { boolean remove = false ; synchronize ( this ) { object key = f launch configuration . remove ( config ) ; remove = key ! = null ; get all launch configuration ( ) . remove ( config ) ; } if ( remove ) { get configuration notifier ( ) . notify ( config , remove ) ; clear config name cache ( ) ; } }
public void resource change ( i resource change event event ) { i resource delta delta= event . get delta ( ) ; if ( delta ! = null ) { try { if ( fg visitor == null ) { fg visitor= new breakpoint manager visitor ( ) ; } delta . accept ( fg visitor ) ; fg visitor . update ( ) ; } catch ( core exception ce ) { debug plugin . log ( ce ) ; } } }
public void shutdown ( ) { f listener = new listener list < > ( ) ; f launch listener = new listener list < > ( ) ; f launch configuration listener = new listener list < > ( ) ; for ( i launch launch : get launch ( ) ) { if ( launch ! = null ) { try { if ( launch instanceof i disconnect ) { i disconnect disconnect = ( i disconnect ) launch ; if ( disconnect . can disconnect ( ) ) { disconnect . disconnect ( ) ; } } if ( launch . can terminate ( ) ) { launch . terminate ( ) ; } } catch ( debug exception e ) { debug plugin . log ( e ) ; } } } persist preferred launch delegate ( ) ; clear all launch configuration ( ) ; f step filter manager = null ; resource plugin . get workspace ( ) . remove resource change listener ( this ) ; }
public void launch configuration add ( i launch configuration configuration ) { i launch configuration from = get launch manager ( ) . get move from ( configuration ) ; if ( from ! = null & & from . equal ( get launch configuration ( ) ) ) { f configuration = configuration ; fire change ( ) ; } }
public void set use step filter ( boolean use filter ) { preference . set boolean ( debug plugin . get unique identifier ( ) , pref_use_step_filters , use filter , null ) ; i launch [ ] launch = debug plugin . get default ( ) . get launch manager ( ) . get launch ( ) ; for ( i launch launch : launch ) { launch change ( launch ) ; } }
protect synchronize string [ ] get all sort config name ( ) { if ( f sort config name == null ) { list < i launch configuration > collection = get all launch configuration ( ) ; i launch configuration [ ] configs = collection . to array ( new i launch configuration [ collection . size ( ) ] ) ; f sort config name = new string [ configs . length ] ; for ( int i = 0 ; i < configs . length ; i++ ) { f sort config name [ i ] = configs [ i ] . get name ( ) ; } array . sort ( f sort config name ) ; } return f sort config name ; }
public void start monitoring ( ) { synchronize ( this ) { if ( f thread == null ) { f thread = new thread ( ( runnable ) this : : write , debug core message . input stream monitor_label ) ; f thread . set daemon ( true ) ; f thread . start ( ) ; } } }
public static synchronize void save preference ( string qualifier ) { try { contexts [ default_context ] . get node ( qualifier ) . flush ( ) ; contexts [ instance_context ] . get node ( qualifier ) . flush ( ) ; } catch ( back store exception bse ) { debug plugin . log ( bse ) ; } }
public void save ( writer writer ) throw i o exception { try ( d o m writer out = new d o m writer ( writer ) ) { out . print ( element ) ; } }
public final void destroy ( ) { if ( stop . equal ( get state ( ) ) ) return ; security manager sm = system . get security manager ( ) ; if ( sm ! = null ) sm . check permission ( new application admin permission ( get application descriptor ( ) , application admin permission . lifecycle_action ) ) ; destroy specific ( ) ; }
public final void lock ( ) { security manager sm = system . get security manager ( ) ; if ( sm ! = null ) sm . check permission ( new application admin permission ( this , application admin permission . lock_action ) ) ; synchronize ( lock ) { if ( lock [ 0 ] ) return ; lock [ 0 ] = true ; lock specific ( ) ; save lock ( true ) ; } }
public final bundle get bundle ( ) { if ( bundle ! = null ) return bundle ; class loader cl = get class ( ) . get class loader ( ) ; if ( cl instanceof bundle reference ) return ( ( bundle reference ) cl ) . get bundle ( ) ; return null ; }
public static i path get log file location ( ) { return meta data keeper . get meta area ( ) . get log location ( ) ; }
public static boolean have listener ( ) { synchronize ( log listener ) { return ( ! log listener . be empty ( ) ) ; } }
public static url find ( bundle bundle , i path path ) { return find support . find ( bundle , path , null ) ; }
public static url to file u r l ( url url ) throw i o exception { u r l converter converter = activator . get u r l converter ( url ) ; return converter == null ? url : converter . to file u r l ( url ) ; }
public synchronize void clear ( ) { listener = empty array ; }
public void add ( i status status ) { assert . be legal ( status ! = null ) ; child . add ( status ) ; int new sev = status . get severity ( ) ; if ( new sev > get severity ( ) ) { set severity ( new sev ) ; } }
public boolean equal ( object object ) { if ( ! ( object instanceof plugin version identifier ) ) return false ; plugin version identifier v = ( plugin version identifier ) object ; return version . equal ( v . version ) ; }
public void begin task ( string name , int total work ) { progress monitor . begin task ( name , total work ) ; }
public void set or pattern ( final search pattern first , final search pattern second ) { assert . be not null ( first ) ; assert . be not null ( second ) ; f pattern= search pattern . create or pattern ( first , second ) ; }
protect void set exception ( throwable exception ) { this . exception = exception ; }
public void add all ( i status status ) { assert . be legal ( status ! = null ) ; add all internal ( status . get child ( ) ) ; }
public void disconnect ( ) { platform . get extension registry ( ) . remove registry change listener ( this ) ; }
protect org . eclipse . core . filebuffers . i document factory get document factory ( string name or extension ) { set < i configuration element > set= f factory descriptor . get ( name or extension ) ; if ( set ! = null ) { i configuration element entry= select configuration element ( set ) ; return get extension ( entry , f factory , org . eclipse . core . filebuffers . i document factory . class ) ; } return null ; }
public object get ( int key ) { for ( i entry entry = table [ index for ( key ) ] ; entry ! = null ; entry = entry . get next ( ) ) if ( entry . get key ( ) == key ) { object value = entry . get value ( ) ; if ( value == null ) { purge ( ) ; } return value ; } return null ; }
public void set ( long timestamp ) { aggregate timestamp = timestamp ; modify = false ; }
public void add ( long timestamp ) { aggregate timestamp ^= timestamp ; modify = true ; }
public static bundle resolve ( i contributor contributor ) { if ( contributor == null ) return null ; if ( ! ( contributor instanceof registry contributor ) ) return null ; string symbolic name = ( ( registry contributor ) contributor ) . get actual name ( ) ; return o s g i utils . get default ( ) . get bundle ( symbolic name ) ; }
public char [ ] compute unique key ( boolean be leaf ) { return char operation . concat with ( this . compound name , '/ ' ) ; }
public static final char [ ] prepend ( char prefix , char [ ] array ) { if ( array == null ) return new char [ ] { prefix } ; int length = array . length ; system . arraycopy ( array , 0 , array = new char [ length + 1 ] , 1 , length ) ; array [ 0 ] = prefix ; return array ; }
public static final char [ ] prepend ( char prefix , char [ ] array ) { if ( array == null ) return new char [ ] { prefix } ; int length = array . length ; system . arraycopy ( array , 0 , array = new char [ length + 1 ] , 1 , length ) ; array [ 0 ] = prefix ; return array ; }
public static final char [ ] prepend ( char prefix , char [ ] array ) { if ( array == null ) return new char [ ] { prefix } ; int length = array . length ; system . arraycopy ( array , 0 , array = new char [ length + 1 ] , 1 , length ) ; array [ 0 ] = prefix ; return array ; }
final static public char [ ] last segment ( char [ ] array , char separator ) { int po = last index of ( separator , array ) ; if ( pos < 0 ) return array ; return subarray ( array , po + 1 , array . length ) ; }
public static final int index of ( char [ ] to be find , char [ ] array , boolean be case sensitive ) { return index of ( to be find , array , be case sensitive , 0 ) ; }
public int get reconcile flag ( ) { return this . operation . reconcile flag ; }
public i java element delta get delta ( ) { return ( i java element delta ) this . source ; }
public void put problem ( string marker type , categorize problem [ ] problem ) { if ( this . operation . problem == null ) this . operation . problem = new hash map ( ) ; this . operation . problem . put ( marker type , problem ) ; }
public static refactoring status context create ( i type root type root , selection selection ) { i source range range= null ; if ( selection ! = null ) range= new source range ( selection . get offset ( ) , selection . get length ( ) ) ; return create ( type root , range ) ; }
public static string get warn token ( int problem i d ) { int irritant = problem reporter . get irritant ( problem i d ) ; if ( irritant ! = 0 ) { return compiler option . warn token from irritant ( irritant ) ; } return null ; }
public boolean be local type declaration ( ) { a s t node parent = get parent ( ) ; return ( parent instanceof type declaration statement ) ; }
public void set type ( type type ) { if ( type == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . member type ; pre replace child ( old child , type , type_property ) ; this . member type = type ; post replace child ( old child , type , type_property ) ; }
public void set type ( type type ) { if ( type == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . member type ; pre replace child ( old child , type , type_property ) ; this . member type = type ; post replace child ( old child , type , type_property ) ; }
public void set label ( simple name label ) { a s t node old child = this . optional label ; pre replace child ( old child , label , label_property ) ; this . optional label = label ; post replace child ( old child , label , label_property ) ; }
public void set expression ( expression expression ) { if ( expression == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . expression ; pre replace child ( old child , expression , expression_property ) ; this . expression = expression ; post replace child ( old child , expression , expression_property ) ; }
public final i bind resolve binding ( ) { return this . ast . get binding resolver ( ) . resolve name ( this ) ; }
public void set then expression ( expression expression ) { if ( expression == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . then expression ; pre replace child ( old child , expression , then_expression_property ) ; this . then expression = expression ; post replace child ( old child , expression , then_expression_property ) ; }
public void set label ( simple name label ) { a s t node old child = this . optional label ; pre replace child ( old child , label , label_property ) ; this . optional label = label ; post replace child ( old child , label , label_property ) ; }
public void set body ( statement statement ) { if ( statement == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . body ; pre replace child ( old child , statement , body_property ) ; this . body = statement ; post replace child ( old child , statement , body_property ) ; }
public void remove super ( session session ) { super . remove ( session , false ) ; }
public void set name ( simple name field name ) { if ( field name == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . field name ; pre replace child ( old child , field name , name_property ) ; this . field name = field name ; post replace child ( old child , field name , name_property ) ; }
public void set expression ( expression expression ) { a s t node old child = this . optional expression ; pre replace child ( old child , expression , expression_property ) ; this . optional expression = expression ; post replace child ( old child , expression , expression_property ) ; }
public void set expression ( expression expression ) { a s t node old child = this . optional expression ; pre replace child ( old child , expression , expression_property ) ; this . optional expression = expression ; post replace child ( old child , expression , expression_property ) ; }
public void set on demand ( boolean on demand ) { pre value change ( on_demand_property ) ; this . on demand = on demand ; post value change ( on_demand_property ) ; }
public void set leave operand ( expression expression ) { if ( expression == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . left operand ; pre replace child ( old child , expression , left_operand_property ) ; this . leave operand = expression ; post replace child ( old child , expression , left_operand_property ) ; }
public string map path ( string path ) { return null ; }
public void set body ( block block ) { if ( block == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . body ; pre replace child ( old child , block , body_property ) ; this . body = block ; post replace child ( old child , block , body_property ) ; }
public void set qualifier ( name name ) { a s t node old child = this . optional qualifier ; pre replace child ( old child , name , qualifier_property ) ; this . optional qualifier = name ; post replace child ( old child , name , qualifier_property ) ; }
public void set name ( simple name method name ) { if ( method name == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . method name ; pre replace child ( old child , method name , name_property ) ; this . method name = method name ; post replace child ( old child , method name , name_property ) ; }
public void remove super ( session session ) { super . remove ( session , false ) ; }
public static boolean be volatile ( int flag ) { return ( flags & volatile ) ! = 0 ; }
public static boolean be volatile ( int flag ) { return ( flags & volatile ) ! = 0 ; }
public list annotation ( ) { return this . annotation ; }
public static boolean be static ( int flag ) { return ( flags & static_phase ) ! = 0 ; }
public void set module qualifier ( name module qualifier ) { if ( module qualifier == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . module qualifier ; pre replace child ( old child , module qualifier , module_qualifier_property ) ; this . module qualifier = module qualifier ; post replace child ( old child , module qualifier , module_qualifier_property ) ; }
public final boolean be name qualified type ( ) { return ( this instanceof name qualify type ) ; }
public a s t node get associate node ( ) { return f group root ; }
public a s t node get associate node ( ) { return f group root ; }
public void set expression ( expression expression ) { if ( expression == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . expression ; pre replace child ( old child , expression , expression_property ) ; this . expression = expression ; post replace child ( old child , expression , expression_property ) ; }
public void set operand ( expression expression ) { if ( expression == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . operand ; pre replace child ( old child , expression , operand_property ) ; this . operand = expression ; post replace child ( old child , expression , operand_property ) ; }
public list super interface type ( ) { return this . super interface type ; }
public void set name ( simple name member name ) { if ( member name == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . member name ; pre replace child ( old child , member name , name_property ) ; this . member name = member name ; post replace child ( old child , member name , name_property ) ; }
public list thrown exception type ( ) { if ( this . thrown exception type == null ) { unsupported in2_3_4 ( ) ; } return this . thrown exception type ; }
public boolean be nest ( ) { return ( get parent ( ) instanceof tag element ) ; }
public boolean be local type declaration ( ) { a s t node parent = get parent ( ) ; return ( parent instanceof type declaration statement ) ; }
public type declaration get type declaration ( ) { return internal get type declaration ( ) ; }
public void set type ( type type ) { if ( type == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . type ; pre replace child ( old child , type , type_property ) ; this . type = type ; post replace child ( old child , type , type_property ) ; }
public list type ( ) { return this . type ; }
public static boolean be final ( int mod ) { return ( mod & final ) ! = 0 ; }
public final boolean be synthetic ( ) { return ( this . modifier & class file constant . acc synthetic ) ! = 0 ; }
public static boolean be volatile ( int mod ) { return ( mod & volatile ) ! = 0 ; }
public static i status validate method name ( string name ) { return validate method name ( name , compiler option . version_1_3 , compiler option . version_1_3 ) ; }
public static char [ ] suggest getter name ( i java project project , char [ ] field name , int modifier , boolean be boolean , char [ ] [ ] exclude names ) { if ( be boolean ) { char [ ] name = internal naming convention . get base name ( get field variable kind ( modifier ) , project , field name , false ) ; int prefix len = getter_bool_name . length ; if ( char operation . prefix equal ( getter_bool_name , name ) & & name . length > prefix len & & scanner helper . be upper case ( name [ prefix len ] ) ) { return suggest new name ( name , exclude names ) ; } else { return suggest new name ( char operation . concat ( getter_bool_name , suggest accessor name ( project , field name , modifier ) ) , exclude names ) ; } } else { return suggest new name ( char operation . concat ( getter_name , suggest accessor name ( project , field name , modifier ) ) , exclude names ) ; } }
public void add index entry ( char [ ] category , char [ ] key ) { if ( this . index ! = null ) this . index . add index entry ( category , key , get container relative path ( ) ) ; }
public void search declaration of accessed field ( i java element enclose element , search requestor requestor , i progress monitor monitor ) throw java model exception { this . basic engine . search declaration of accessed field ( enclose element , requestor , monitor ) ; }
public void search declaration of referenced type ( i java element enclose element , search requestor requestor , i progress monitor monitor ) throw java model exception { this . basic engine . search declaration of referenced type ( enclose element , requestor , monitor ) ; }
public string get fully qualify name ( ) { return get type ( ) . get fully qualify name ( ' . ' ) ; }
public void accept ( i compilation unit source unit , access restriction access restriction ) { compilation result result = new compilation result ( source unit , 1 , 1 , this . compiler option . max problem per unit ) ; assist parser assist parser = get parser ( ) ; object parser state = assist parser . become simple parser ( ) ; compilation unit declaration parse unit = assist parser . diet parse ( source unit , result ) ; assist parser . restore assist parser ( parser state ) ; this . lookup environment . build type binding ( parsed unit , access restriction ) ; this . lookup environment . complete type binding ( parsed unit , true ) ; }
public reference bind [ ] get thrown uncaught exception ( ) { reference bind [ ] result = new reference binding [ this . thrown exception . element size ] ; this . thrown exception . a array ( result ) ; return result ; }
public method bind reference method binding ( ) { if ( this . reference context instanceof lambda expression ) return ( ( lambda expression ) this . reference context ) . binding ; if ( this . reference context instanceof abstract method declaration ) return ( ( abstract method declaration ) this . reference context ) . binding ; return null ; }
public void mark close effectively final ( ) { this . global closing state |= twr_effectively_final ; }
public void mark close effectively final ( ) { this . global closing state |= twr_effectively_final ; }
public boolean continue at outer label ( ) { return new a s t visitor ( ) { boolean continue to label ; @ override public boolean visit ( continue statement continue statement , block scope skope ) { if ( continue statement . label ! = null ) this . continue to label = true ; return false ; } public boolean continue at outer label ( ) { statement . this . traverse ( this , null ) ; return this . continue to label ; } } . continue at outer label ( ) ; }
public type annotation walker to method parameter ( short index ) { long new match = this . match ; if ( new match == 0 ) return empty_annotation_walker ; int length = this . type annotation . length ; long mask = 1 ; for ( int i = 0 ; i < length ; i++ , mask = mask < < 1 ) { i binary type annotation candidate = this . type annotation [ i ] ; if ( candidate . get target type ( ) ! = annotation target type constant . method_formal_parameter || ( short ) candidate . get method formal parameter index ( ) ! = index ) { new match & = ~mask ; } } return restrict ( new match , 0 ) ; }
public int literal index for type ( final type bind bind ) { type binding type bind = binding . leaf component type ( ) ; if ( ( type binding . tag bit & tag bit . contains nest type reference ) ! = 0 ) { util . record nest type ( this . class file , type binding ) ; } return this . literal index for type ( bind . constant pool name ( ) ) ; }
public problem reporter problem reporter ( ) { this . problem reporter . reference context = this . reference context ; return this . problem reporter ; }
public boolean be compilation unit ( ) { return this . compilation unit ! = null ; }
public char [ ] module name ( ) { return this . module name ; }
public boolean have same irritant ( irritant set irritant set ) { if ( irritant set == null ) return false ; for ( int i = 0 ; i < group_max ; i++ ) { if ( this . bits [ i ] ! = irritant set . bit [ i ] ) return false ; } return true ; }
protect double get domain low bound ( double p ) { return 0 ; }
public final boolean be or enclose by private type ( ) { if ( ( this . modifier & class file constant . acc private ) ! = 0 ) return true ; return this . declare class ! = null & & this . declare class . be or enclose by private type ( ) ; }
public final boolean be compact constructor ( ) { return ( this . modifier & extra compiler modifier . acc compact constructor ) ! = 0 ; }
public final char [ ] constant pool name ( ) { return this . selector ; }
public final boolean be constructor ( ) { return this . selector == type constant . init ; }
public recover element update on close brace ( int brace start , int brace end ) { if ( ( -- this . bracket balance < = 0 ) & & ( this . parent ! = null ) ) { this . update source end if necessary ( brace start , brace end ) ; / * if the block be the method body , then it close the method too * / recover method method = enclose method ( ) ; if ( method ! = null & & method . method body == this ) { return this . parent . update on close brace ( brace start , brace end ) ; } recover initializer initializer = enclose initializer ( ) ; if ( initializer ! = null & & initializer . initializer body == this ) { return this . parent . update on close brace ( brace start , brace end ) ; } return this . parent ; } return this ; }
public recover type enclose type ( ) { recovered element current = this ; while ( current ! = null ) { if ( current instanceof recover type ) { return ( recovered type ) current ; } current = current . parent ; } return null ; }
protect void set name source start ( int start ) { this . name start= start ; }
public sub monitor check cancel ( ) throw operation cancel exception { if ( be cancel ( ) ) { throw new operation cancel exception ( ) ; } return this ; }
public locale get locale ( ) { return this . locale ; }
public string get field doc ( i field child ) throw java model exception { if ( this . content == null ) return null ; int [ ] range = null ; synchronize ( this ) { if ( this . field doc range == null ) { this . field doc range = new hashtable of object to int array ( ) ; } else { range = this . field doc range . get ( child ) ; } if ( range == null ) { range = compute field range ( child ) ; this . field doc range . put ( child , range ) ; } } if ( range ! = null ) { if ( range == unknown_format ) throw new java model exception ( new java model status ( i java model status constant . unknown_javadoc_format , child ) ) ; return new string ( this . content , range [ 0 ] , range [ 1 ] - range [ 0 ] ) ; } return null ; }
public i d o m initializer create initializer ( char [ ] source code ) { initialize build ( source code , false , false , true ) ; get parser ( this . option ) . parse initializer ( source code ) ; if ( this . f abort || this . f node == null || ! ( this . f node instanceof i d o m initializer ) ) { return null ; } this . f node . normalize ( this ) ; return ( i d o m initializer ) this . f node ; }
protect void exit member ( int declaration end ) { d o m member m= ( d o m member ) this . f stack . pop ( ) ; m . set source range end ( declaration end ) ; this . f node = m ; }
public void exit constructor ( int body end , int declaration end ) { exit abstract method ( body end , declaration end ) ; }
protect d o m node get detailed node ( ) { return this ; }
protect boolean be return type alter ( ) { return get mask ( mask_return_type_altered ) ; }
public enumeration < v > element ( ) { if ( this . entry queue == null ) return new l r u cache enumerator < > ( null ) ; l r u cache enumerator . l r u enumerator element < v > head = new l r u cache enumerator . l r u enumerator element < > ( this . entry queue . value ) ; l r u cache entry < k , v > current entry = this . entry queue . next ; l r u cache enumerator . l r u enumerator element < v > current element = head ; while ( current entry ! = null ) { current element . next = new l r u cache enumerator . l r u enumerator element < > ( current entry . value ) ; current element = current element . next ; current entry = current entry . next ; } return new l r u cache enumerator < > ( head ) ; }
public void reset ( ) { super . reset ( ) ; synchronize ( this ) { if ( this . index ! = null ) { this . index = new simple lookup table ( ) ; this . index state = null ; } this . index location = new simple lookup table ( ) ; this . java plugin location = null ; synchronize ( this . meta index update ) { this . meta index update . clear ( ) ; } } }
public string to string ( ) { if ( this . type == null ) return super . to string ( ) ; return this . type . to string ( ) ; }
public string to string ( ) { if ( this . type == null ) return super . to string ( ) ; return this . type . to string ( ) ; }
public i type get type ( ) { return this . element ; }
public static string strip signature to f q n ( string signature ) throw illegal argument exception { signature= signature . get type erasure ( signature ) ; signature= signature . get element type ( signature ) ; return signature . to string ( signature ) ; }
public char array buffer append ( char [ ] src , int start , int length ) { if ( start < 0 ) throw new array index out of bound exception ( ) ; if ( length < 0 ) throw new array index out of bound exception ( ) ; if ( src ! = null ) { int src length = src . length ; if ( start > src length ) throw new array index out of bound exception ( ) ; if ( length + start > src length ) throw new array index out of bound exception ( ) ; / * * do length check here to allow exception to be throw * / if ( length > 0 ) { if ( this . end == this . size ) { int size2 = this . size * 2 ; system . arraycopy ( this . buffer , 0 , ( this . buffer = new char [ size2 ] [ ] ) , 0 , this . size ) ; system . arraycopy ( this . range , 0 , ( this . range = new int [ size2 ] [ ] ) , 0 , this . size ) ; this . size * = 2 ; } this . buffer [ this . end ] = src ; this . range [ this . end ] = new int [ ] { start , length } ; this . end++ ; } } return this ; }
public void set class index ( int class index ) { this . class index = class index ; }
public final annotation bind get annotation type ( reference bind annotation type , boolean require resolve ) { annotation bind annotation = ( annotation bind ) this . annotation type . get ( annotation type ) ; if ( annotation == null ) { if ( require resolve ) annotation = new annotation binding ( annotation type , bind . no_element_value_pairs ) ; else annotation = new unresolved annotation binding ( annotation type , bind . no_element_value_pairs , this . environment ) ; this . annotation type . put ( annotation type , annotation ) ; } if ( require resolve ) annotation . resolve ( ) ; return annotation ; }
public char [ ] get name ( ) { return this . name ; }
public change get change ( ) throw core exception { synchronize ( this ) { if ( f change == null ) { f change = create change ( ) ; } } return f change ; }
public change get change ( ) throw core exception { synchronize ( this ) { if ( f change == null ) { f change = create change ( ) ; } } return f change ; }
public static string get setter method body content ( i compilation unit cu , string declare type name , string method name , string field name , string param name , string line delimiter ) throw core exception { return stub utility . get setter method body content ( cu . get java project ( ) , declare type name , method name , field name , param name , line delimiter ) ; }
public compilation unit get a s t ( ) { return f ast ; }
public i compilation unit get compilation unit ( ) { return f c unit ; }
public void set class name ( string class name ) { java refactoring descriptor util . set string ( f argument , class_name , class name ) ; }
public boolean be setter ( ) { return f setter ; }
public void set deprecate delegate ( boolean deprecate delegate ) { f deprecate delegate= deprecate delegate ; }
public void set subtype ( final i type type ) { assert . be not null ( type ) ; f sub type= type ; }
public void set deprecate delegate ( final boolean deprecate ) { f deprecate= deprecate ; }
public void set deprecate delegate ( final boolean deprecate ) { f deprecate= deprecate ; }
public string get new return type ( ) { return f new return type ; }
public string get new return type ( ) { return f new return type ; }
public static int get operator precedence ( operator operator ) { if ( operator == operator . conditional_or ) { return conditional_or ; } else if ( operator == operator . conditional_and ) { return conditional_and ; } else if ( operator == operator . or ) { return bitwise_inclusive_or ; } else if ( operator == operator . xor ) { return bitwise_exclusive_or ; } else if ( operator == operator . and ) { return bitwise_and ; } else if ( operator == operator . equal || operator == operator . not_equals ) { return equality ; } else if ( operator == operator . le || operator == operator . less_equals || operator == operator . great || operator == operator . greater_equals ) { return relational ; } else if ( operator == operator . left_shift || operator == operator . right_shift_signed || operator == operator . right_shift_unsigned ) { return shift ; } else if ( operator == operator . plus || operator == operator . minus ) { return additive ; } else if ( operator == operator . remainder || operator == operator . divide || operator == operator . time ) { return multiplicative ; } return integer . max_value ; }
public static string get line delimiter use ( i java project project ) { return get project line delimiter ( project ) ; }
public static string get type comment ( i compilation unit cu , string type qualify name , string line delimiter ) throw core exception { return stub utility . get type comment ( cu , type qualify name , empty , empty , line delimiter ) ; }
public static char to lower case ( character self ) { return character . to lower case ( self ) ; }
public static int compute indent unit ( string line , i java project project ) { return indent manipulation . measure indent unit ( line , code formatter util . get tab width ( project ) , code formatter util . get indent width ( project ) ) ; }
public boolean get expand with constructor ( ) { return f be expand with constructor set & & f expand with constructor ; }
public string matcher [ ] get ignore filter ( ) { if ( f filter == null ) { string filter string= null ; if ( be filter enable ( ) ) { filter string= get filter ( ) ; if ( filter string . be empty ( ) ) { filter string= default ignore filter ; } } if ( filter string ! = null ) { f filters= parse list ( filter string ) ; } else { f filters= null ; } } return f filter ; }
public boolean get expand with constructor ( ) { return f be expand with constructor set & & f expand with constructor ; }
public boolean get expand with constructor ( ) { return f be expand with constructor set & & f expand with constructor ; }
public method wrapper [ ] get call ( i progress monitor progress monitor ) { method wrapper [ ] result = super . get call ( progress monitor ) ; array . sort ( result , f method wrapper comparator ) ; return result ; }
public boolean match ( array creation node , object other ) { if ( ! ( other instanceof array creation ) ) { return false ; } array creation o = ( array creation ) other ; return ( safe subtree match ( node . get type ( ) , o . get type ( ) ) & & safe subtree list match ( node . dimension ( ) , o . dimension ( ) ) & & safe subtree match ( node . get initializer ( ) , o . get initializer ( ) ) ) ; }
public static selection create from start length ( int s , int l ) { assert . be true ( s > = 0 & & l > = 0 ) ; selection result= new selection ( ) ; result . f start= s ; result . f length= l ; result . f exclusive end= s + l ; return result ; }
public static i a s t fragment create fragment for source range ( i source range range , a s t node scope , i compilation unit cu ) throw java model exception { selection analyzer sa= new selection analyzer ( selection . create from start length ( range . get offset ( ) , range . get length ( ) ) , false ) ; scope . accept ( sa ) ; if ( be single node select ( sa , range , cu ) ) return a s t fragment factory . create fragment for full subtree ( sa . get first select node ( ) ) ; if ( be empty selection cover by a node ( range , sa ) ) return a s t fragment factory . create fragment for full subtree ( sa . get last covering node ( ) ) ; return a s t fragment factory . create fragment for sub part by source range ( sa . get last covering node ( ) , range , cu ) ; }
public list < throwable > error collect ( ) { return decorate error collect ( proxy . error collect ( ) ) ; }
public string [ ] map file name ( string source file name ) { return new string [ ] { source file name } ; }
public void set end position ( position information position ) { f end position= position ; }
public void create edit ( ) throw java model exception { try { i document document= new document ( f delegate rewrite . get cu ( ) . get buffer ( ) . get content ( ) ) ; text edit edit= f delegate rewrite . get a s t rewrite ( ) . rewrite a s t ( document , f delegate rewrite . get cu ( ) . get option ( true ) ) ; edit . apply ( document , text edit . update_regions ) ; string new source= string . trim indentation ( document . get ( f track position . get start position ( ) , f tracked position . get length ( ) ) , f preference . tab width , f preference . indent width , false ) ; a s t node placeholder= f original rewrite . get a s t rewrite ( ) . create string placeholder ( new source , f declaration . get node type ( ) ) ; categorize text edit group group description= f original rewrite . create categorized group description ( get text edit group label ( ) , category_delegate ) ; list rewrite body declaration list rewrite= f original rewrite . get a s t rewrite ( ) . get list rewrite ( f declaration . get parent ( ) , get type body declaration property ( ) ) ; if ( f copy ) if ( f insert before ) body declaration list rewrite . insert before ( placeholder , f declaration , group description ) ; else body declaration list rewrite . insert after ( placeholder , f declaration , group description ) ; else body declaration list rewrite . replace ( f declaration , placeholder , group description ) ; } catch ( bad location exception e ) { java manipulation plugin . log ( e ) ; } }
public void set status ( final refactoring status status ) { assert . be not null ( status ) ; f status= status ; }
public void set target ( final i variable bind target ) { assert . be not null ( target ) ; f target= target ; f target type= null ; try { final method declaration declaration= a s t node search util . get method declaration node ( f method , f source rewrite . get root ( ) ) ; if ( declaration ! = null ) { final ast node finder finder= new this reference finder ( ) ; declaration . accept ( finder ) ; f target node= ! finder . get result ( ) . be empty ( ) ; return ; } } catch ( java model exception exception ) { java manipulation plugin . log ( exception ) ; } f target node= true ; }
protect double get domain low bound ( double p ) { return 0 ; }
public final boolean be class ( ) { return ( f flag & f_is_class ) ! = 0 ; }
public final boolean be class ( ) { return ( f flag & f_is_class ) ! = 0 ; }
public final boolean be class ( ) { return ( f flag & f_is_class ) ! = 0 ; }
public string get bind key ( ) { return f bind key ; }
public source range compute source range ( a s t node node ) { a s t node root= node . get root ( ) ; if ( root instanceof compilation unit ) { compilation unit cu= ( compilation unit ) root ; return new source range ( cu . get extended start position ( node ) , cu . get extended length ( node ) ) ; } return new source range ( node . get start position ( ) , node . get length ( ) ) ; }
public int get length ( ) { return f length ; }
protect void set closure delegate ( closure closure , object node ) { closure . set delegate ( this ) ; }
public static string get upper bound ( string signature ) { return string . value of ( get upper bound ( signature . to char array ( ) ) ) ; }
public boolean be subsignature ( i method override , i method overridden ) throw java model exception { if ( ! overridden . get element name ( ) . equal ( override . get element name ( ) ) ) { return false ; } int n parameters= overridden . get number of parameter ( ) ; if ( n parameter ! = override . get number of parameter ( ) ) { return false ; } if ( ! have compatible type parameter ( override , overridden ) ) { return false ; } return n parameter == 0 || have compatible parameter type ( override , overridden ) ; }
public static i status check in sync ( i resource resource ) { return check in sync ( new i resource [ ] { resource } ) ; }
public static void ensure scheme be h t t p s ( final uri uri ) { if ( uri == null ) { return ; } if ( uri . get scheme ( ) == null || ! `` https `` . equal ignore case ( uri . get scheme ( ) ) ) { throw new illegal argument exception ( `` the uri scheme must be https `` ) ; } }
public static i type hierarchy get type hierarchy ( i type type ) throw java model exception { return get type hierarchy ( type , null ) ; }
public boolean be o k ( ) { return f severity == i status . ok ; }
protect boolean contain ( list < ? extend position > position , position position ) { return index of ( position , position ) ! = -1 ; }
protect double get domain low bound ( double p ) { return 0 ; }
public static environment manager get default ( ) { if ( fg manager == null ) { fg manager = new environment manager ( ) ; } return fg manager ; }
protect static i status get status ( string message , throwable exception , int code ) { return new status ( i status . error , launch plugin . get unique identifier ( ) , code , message , exception ) ; }
public static library info get library info ( string java install path ) { if ( fg library info map == null ) { restore library info ( ) ; } return fg library info map . get ( java install path ) ; }
public string get version ( ) { return f version ; }
public string [ ] get extension dirs ( ) { return f extension dirs ; }
protect void fire terminate event ( ) { debug plugin manager= debug plugin . get default ( ) ; if ( manager ! = null ) { manager . fire debug event set ( new debug event [ ] { new debug event ( this , debug event . terminate ) } ) ; } }
public void add v m ( i v m install vm ) { if ( ! f v m list . contains ( vm ) ) { i v m install type vm install type = vm . get v m install type ( ) ; list < i v m install > vm list = f v m type to v m map . get ( vm install type ) ; if ( vm list == null ) { vm list = new array list < > ( 3 ) ; f v m type to v m map . put ( vm install type , vm list ) ; } vm list . add ( vm ) ; file install location = vm . get install location ( ) ; if ( install location == null || vm install type . validate install location ( install location ) . get severity ( ) == i status . error ) { f invalid v m list . add ( vm ) ; } f v m list . add ( vm ) ; } }
public void set attribute ( string key , string value ) { string prev value = f attribute map . remove ( key ) ; boolean notify = false ; if ( value == null ) { if ( prev value ! = null & & f notify ) { notify = true ; } } else { f attribute map . put ( key , value ) ; if ( f notify & & ( prev value == null || ! prev value . equal ( value ) ) ) { notify = true ; } } if ( notify ) { property change event event = new property change event ( this , key , prev value , value ) ; java runtime . fire v m change ( event ) ; } }
public void set attribute ( string key , string value ) { string prev value = f attribute map . remove ( key ) ; boolean notify = false ; if ( value == null ) { if ( prev value ! = null & & f notify ) { notify = true ; } } else { f attribute map . put ( key , value ) ; if ( f notify & & ( prev value == null || ! prev value . equal ( value ) ) ) { notify = true ; } } if ( notify ) { property change event event = new property change event ( this , key , prev value , value ) ; java runtime . fire v m change ( event ) ; } }
protected process exec ( string [ ] cmd line , file work directory ) throw core exception { cmd line = quote window args ( cmd line ) ; return debug plugin . exec ( cmd line , work directory ) ; }
public url get index location ( ) { return f index location ; }
public string get property ( ) { return property name ; }
public string get property ( ) { return property name ; }
public string get name ( ) { return f name ; }
public refactoring status get condition check status ( ) { if ( f check condition operation ! = null ) return f check condition operation . get status ( ) ; return null ; }
public text edit get preview edit ( text edit original ) { assert . be true ( get keep preview edits ( ) & & f copier ! = null & & original ! = null ) ; return f copier . get copy ( original ) ; }
public change [ ] clear ( ) { change [ ] result= f change . to array ( new change [ f change . size ( ) ] ) ; f change . clear ( ) ; return result ; }
public i refactoring history service get history service ( ) { return f service ; }
public move argument get argument ( ) { return f argument ; }
public refactoring processor get processor ( ) { return f processor ; }
public boolean be process ( object element ) { return f process element . contains ( element ) ; }
protect static void check if modifiable ( refactoring status result , i resource resource , int validation method ) { check existence ( result , resource ) ; if ( result . have fatal error ( ) ) return ; if ( validation method == validate_default ) return ; validation state state= new validation state ( resource ) ; if ( ( validation method & validate_not_read_only ) ! = 0 ) { state . check read only ( result ) ; if ( result . have fatal error ( ) ) return ; } if ( ( validation method & validate_not_dirty ) ! = 0 ) { state . check dirty ( result ) ; } }
public refactoring status get validation status ( ) { return f validation status ; }
public int get all tick ( ) { return get check all condition tick ( ) + f value [ create_change ] + f value [ initialize_change ] ; }
public string map path ( string path ) { return null ; }
public void set destination path ( i path path ) { assert . be not null ( path ) ; f destination path= path ; }
public void set keep preview edits ( boolean keep ) { f track edits= keep ; }
public final int get save mode ( ) { return f save mode ; }
protect change create undo change ( undo edit [ ] edits , content stamp stamp to restore ) throw core exception { return new multi state undo change ( get name ( ) , f file , edits , stamp to restore , f save mode ) ; }
public static refactoring history service get instance ( ) { if ( f instance == null ) f instance= new refactoring history service ( ) ; return f instance ; }
public i resource get resource ( ) { return f resource ; }
public void add delete ( i resource delete ) { if ( f delete == null ) f delete= new array list < > ( 2 ) ; f delete . add ( delete ) ; if ( f ignore count == 0 ) { internal add ( new delete description ( delete ) ) ; } }
public list < module > get module ( ) { return module database . get module ( ) ; }
public collection < module > get dependency closure ( collection < module > initial ) { module database . read lock ( ) ; try { return get refresh closure ( initial , module database . get wiring copy ( ) ) ; } finally { module database . read unlock ( ) ; } }
final public long get timestamp ( ) { read lock ( ) ; try { return all time stamp . get ( ) ; } finally { read unlock ( ) ; } }
public list < generic info > get capability ( string namespace ) { return capability info . get namespace element ( namespace ) ; }
public void set version ( version version ) { this . version = version ; }
public synchronize void clear ( ) { entry = empty ( ) ; }
public boolean exists ( final file file ) { if ( system . get security manager ( ) == null ) return file . exists ( ) ; return access controller . do privilege ( new privilege action < boolean > ( ) { @ override public boolean run ( ) { return file . exists ( ) ? boolean . true : boolean . false ; } } , control context ) . boolean value ( ) ; }
public long get size ( ) { return bundle file . secure action . length ( file ) ; }
public static writer leave shift ( writer self , object value ) throw i o exception { invoker helper . write ( self , value ) ; return self ; }
public final string get thread name ( ) { return thread name ; }
public final string get thread name ( ) { return thread name ; }
public collection < string > get o s name alias ( string osname ) { return get alias ( osname . to lower case ( ) , osname alias table ) ; }
public equinox container get container ( ) { return container ; }
public void add bundle file ( list < bundle file > bundlefiles ) { bundlefiles . add all ( mr bundle file ) ; bundlefiles . add ( bundlefile ) ; }
public void close ( ) { for ( classpath entry entry : entry ) { try { entry . close ( ) ; } catch ( i o exception e ) { generation . get bundle info ( ) . get storage ( ) . get adaptor ( ) . publish container event ( container event . error , generation . get revision ( ) . get revision ( ) . get module ( ) , e ) ; } } }
public void add ( permission perm ) { if ( be read only ( ) ) { throw new security exception ( ) ; } perm . put ( perm , perm ) ; }
public string get filter ( ) { if ( filter ! = null ) { return filter . to string ( ) ; } return get object class filter string ( object class ) ; }
public bundle [ ] get use bundle ( ) { return registration . get use bundle ( ) ; }
public string get filter ( ) { if ( filter ! = null ) { return filter . to string ( ) ; } return get object class filter string ( object class ) ; }
public version get maximum ( ) { version right = get right ( ) ; return right == null ? version max : right ; }
public int get minor ( ) { return minor ; }
public version get leave ( ) { return leave ; }
public char get right type ( ) { return right close ? right_closed : right_open ; }
public version get leave ( ) { return leave ; }
@ override public void report ( string message ) { system . out . println ( message ) ; }
public boolean equal ( object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof condition info ) ) { return false ; } condition info other = ( condition info ) obj ; if ( ! type . equal ( other . type ) || args . length ! = other . args . length ) return false ; for ( int i = 0 ; i < args . length ; i++ ) { if ( ! args [ i ] . equal ( other . args [ i ] ) ) return false ; } return true ; }
protect i line tracker get tracker ( ) { assert . be not null ( f tracker ) ; return f tracker ; }
protect int get gap start index ( ) { return f gap start ; }
public static link mode model get model ( i document document , int offset ) { if ( ! have instal model ( document ) ) return null ; link mode manager mgr= link mode manager . get link manager ( new i document [ ] { document } , false ) ; if ( mgr ! = null ) return mgr . get top environment ( ) ; return null ; }
public void add link listener ( i link mode listener listener ) { assert . be not null ( listener ) ; if ( ! f listener . contains ( listener ) ) f listener . add ( listener ) ; }
public link mode model get top environment ( ) { if ( f environment . be empty ( ) ) return null ; return f environment . peek ( ) ; }
public string get content ( ) throw bad location exception { return f document . get ( offset , length ) ; }
private void enforce disjoint ( link position position ) throw bad location exception { for ( link position p : f position ) { if ( p . overlap with ( position ) ) throw new bad location exception ( ) ; } }
public boolean include ( document event event ) { return include ( event . get document ( ) , event . get offset ( ) , event . get length ( ) ) ; }
public int get sequence number ( ) { return f sequence number ; }
public void set offset ( int offset ) { assert . be true ( offset > = 0 ) ; this . offset= offset ; }
public string get content ( ) throw bad location exception { return f document . get ( offset , length ) ; }
protect void fire document change ( document event event ) { update document structure ( event ) ; if ( f stop listener notification == 0 ) do fire document change ( event ) ; else f deferred document event= event ; }
public projection map get projection mapping ( ) { return f mapping ; }
protect void set completion length ( int new length ) { f original length= new length ; f position . set length ( new length ) ; }
protect template variable resolver get resolver ( string type ) { return f resolvers . get ( type ) ; }
protect void set closure delegate ( closure closure , object node ) { closure . set delegate ( this ) ; }
protect template variable resolver get resolver ( string type ) { return f resolvers . get ( type ) ; }
public template variable type get variable type ( ) { return f type ; }
public void set target edit ( copy target edit edit ) throw malformed tree exception { assert . be not null ( edit ) ; if ( f target ! = edit ) { f target= edit ; f target . set source edit ( this ) ; } }
public final text edit [ ] get child ( ) { if ( f child == null ) return empty_array ; return f child . to array ( new text edit [ f child . size ( ) ] ) ; }
public text edit get copy ( text edit original ) { assert . be not null ( original ) ; return f copy . get ( original ) ; }
public void set target edit ( copy target edit edit ) throw malformed tree exception { assert . be not null ( edit ) ; if ( f target ! = edit ) { f target= edit ; f target . set source edit ( this ) ; } }
public i document get document ( ) { return f document ; }
public void assert end with ( assertion info info , boolean [ ] actual , boolean [ ] sequence ) { array . assert end with ( info , failure , actual , sequence ) ; }
public void assert equal ( assertion info info , boolean actual , boolean expect ) { assert not null ( info , actual ) ; if ( actual == expect ) return ; throw failure . failure ( info , should be equal ( actual , expect , info . representation ( ) ) ) ; }
public void revert ( ) { f custom template= f original template ; f custom be enabled= f original be enable ; f be deleted= false ; }
public void stop listening for preference change ( ) { if ( f property listener ! = null ) { f preference store . remove preference change listener ( f property listener ) ; f property listener= null ; } }
public void load ( ) throw i o exception { f template . clear ( ) ; load contribute template ( ) ; load custom template ( ) ; }
public void load ( ) throw i o exception { f template . clear ( ) ; load contribute template ( ) ; load custom template ( ) ; }
public boolean be custom ( ) { return f id == null || f be delete || f original be enable ! = f custom be enable || ! f original template . equal ( f custom template ) ; }
public final string get name ( ) { return name ; }
public final string get encode ( ) { string buffer output = new string buffer ( 8 + type . length ( ) + ( ( ( ( name == null ) ? 0 : name . length ( ) ) + ( ( action == null ) ? 0 : action . length ( ) ) ) < < 1 ) ) ; output . append ( ' ( ' ) ; output . append ( type ) ; if ( name ! = null ) { output . append ( `` \ `` `` ) ; escape string ( name , output ) ; if ( action ! = null ) { output . append ( `` \ `` \ `` `` ) ; escape string ( action , output ) ; } output . append ( '\ `` ' ) ; } output . append ( ' ) ' ) ; return output . to string ( ) ; }
protect int entry hash code ( hash entry entry ) { return entry . hash code ; }
public p d color space get alternate color space ( ) throw i o exception { if ( alternate color space == null ) { alternate color space = p d color space . create ( array . get object ( alternate_cs ) ) ; } return alternate color space ; }
public c o s dictionary get image parameter ( ) { return image parameter ; }
public void save graphic state ( ) { graphic stack . push ( graphics stack . peek ( ) . clone ( ) ) ; }
public c o s base get ( int index ) { return object . get ( index ) ; }
public void retain all ( collection < c o s base > object list ) { object . retain all ( object list ) ; }
public float [ ] to float array ( ) { float [ ] retval = new float [ size ( ) ] ; for ( int i = 0 ; i < size ( ) ; i++ ) { c o s base base = get object ( i ) ; retval [ i ] = base instanceof c o s number ? ( ( c o s number ) base ) . float value ( ) : 0 ; } return retval ; }
public void set float array ( float [ ] value ) { this . clear ( ) ; for ( float a value : value ) { add ( new c o s float ( a value ) ) ; } }
public void write p d f ( output stream output ) throw i o exception { if ( value ) { output . write ( true_bytes ) ; } else { output . write ( false_bytes ) ; } }
public c o s dictionary get c o s dictionary ( c o s name key ) { c o s base dictionary = get dictionary object ( key ) ; if ( dictionary instanceof c o s dictionary ) { return ( c o s dictionary ) dictionary ; } return null ; }
public c o s dictionary get c o s dictionary ( c o s name key ) { c o s base dictionary = get dictionary object ( key ) ; if ( dictionary instanceof c o s dictionary ) { return ( c o s dictionary ) dictionary ; } return null ; }
public void set encryption dictionary ( c o s dictionary enc dictionary ) { trailer . set item ( c o s name . encrypt , enc dictionary ) ; }
public static string get rule map key ( string token ) { string builder buff = new string builder ( ) ; for ( char ch : token . to char array ( ) ) { if ( character . be upper case ( ch ) ) { buff . append ( ' _ ' ) . append ( character . to lower case ( ch ) ) ; } else { buff . append ( ch ) ; } } return buff . to string ( ) ; }
public rectangle get source region ( ) { return source region ; }
public void set subsampling offset x ( int s offset x ) { this . subsampling offset x = s offset x ; }
public file get temp dir ( ) { return temp dir ; }
public void set visual signature ( file file ) throw i o exception { init from random access read ( new random access buffer file input stream ( file ) ) ; }
public void set all page overlay file ( string all page overlay file ) { all page overlay filename = all page overlay file ; }
public void set odd page overlay file ( string odd page overlay file ) { odd page overlay filename = odd page overlay file ; }
public output stream get destination stream ( ) { return destination stream ; }
public void add source ( list < input stream > source list ) { source . add all ( source list ) ; }
public void set end page ( int end ) { if ( end < = 0 ) { throw new illegal argument exception ( `` end page be small than one `` ) ; } end page = end ; }
public list < p d document > split ( p d document document ) throw i o exception { destination document = new array list < p d document > ( ) ; source document = document ; process page ( ) ; return destination document ; }
public c o s document get document ( ) throw i o exception { if ( document == null ) { throw new i o exception ( `` you must parse the document first before call get document ( ) `` ) ; } return document ; }
protect p d document create document ( ) throw i o exception { return new p d document ( document , source , get access permission ( ) ) ; }
public final c o s dictionary get first trailer ( ) { if ( byte po to xref map . be empty ( ) ) { return null ; } set < long > offset = byte po to xref map . key set ( ) ; sort set < long > sort offset = new tree set < long > ( offset ) ; return byte po to xref map . get ( sort offset . first ( ) ) . trailer ; }
protect void reset ( ) { for ( xref trailer obj trailer obj : byte po to xref map . value ( ) ) { trailer obj . reset ( ) ; } cur xref trailer obj = null ; resolve xref trailer = null ; }
public void write c r l f ( ) throw i o exception { write ( crlf ) ; }
public string get file unix ( ) { return f . get string ( c o s name . unix ) ; }
public void set embed file ( p d embed file file ) { c o s dictionary ef = get e f dictionary ( ) ; if ( ef == null & & file ! = null ) { ef = new c o s dictionary ( ) ; f . set item ( c o s name . ef , ef ) ; } if ( ef ! = null ) { ef . set item ( c o s name . f , file ) ; } }
public string get subtype ( ) { return get c o s object ( ) . get name a string ( c o s name . subtype ) ; }
public string get check sum ( ) { return get c o s object ( ) . get embedded string ( `` params `` , `` check sum `` ) ; }
public void set mac subtype ( string mac subtype ) { c o s dictionary params = ( c o s dictionary ) get c o s object ( ) . get dictionary object ( c o s name . params ) ; if ( params == null & & mac subtype ! = null ) { params = new c o s dictionary ( ) ; get c o s object ( ) . set item ( c o s name . params , params ) ; } if ( params ! = null ) { params . set embed string ( `` mac `` , `` subtype `` , mac subtype ) ; } }
public void set bit per sample ( int bps ) { get c o s object ( ) . set int ( c o s name . bits_per_sample , bps ) ; }
public c o s array get c0 ( ) { return c0 ; }
public number pop number ( ) { return ( number ) stack . pop ( ) ; }
public void add real ( float value ) { this . instruction . add ( value ) ; }
public void add real ( float value ) { this . instruction . add ( value ) ; }
public void set number of object ( int n ) { get c o s object ( ) . set int ( c o s name . n , n ) ; }
public void set start ( int start ) { if ( start < = 0 ) { throw new illegal argument exception ( `` the page number start value must be a positive integer `` ) ; } root . set int ( key_start , start ) ; }
public void set upper right x ( float value ) { rect array . set ( 2 , new c o s float ( value ) ) ; }
public void set upper right y ( float value ) { rect array . set ( 3 , new c o s float ( value ) ) ; }
public iterator < p d stream > get content stream ( ) { list < p d stream > stream = new array list < p d stream > ( ) ; c o s base base = page . get dictionary object ( c o s name . content ) ; if ( base instanceof c o s stream ) { stream . add ( new p d stream ( ( c o s stream ) base ) ) ; } else if ( base instanceof c o s array & & ( ( c o s array ) base ) . size ( ) > 0 ) { c o s array array = ( c o s array ) base ; for ( int i = 0 ; i < array . size ( ) ; i++ ) { c o s stream stream = ( c o s stream ) array . get object ( i ) ; stream . add ( new p d stream ( stream ) ) ; } } return stream . iterator ( ) ; }
public void set file ( p d file specification f ) { stream . set item ( c o s name . f , f ) ; }
public void add user property ( p d user property user property ) { c o s array p = ( c o s array ) this . get c o s object ( ) . get dictionary object ( c o s name . p ) ; p . add ( user property ) ; this . notify change ( ) ; }
public void set attribute ( revision < p d attribute object > attribute ) { c o s name key = c o s name . a ; if ( ( attribute . size ( ) == 1 ) & & ( attribute . get revision number ( 0 ) == 0 ) ) { p d attribute object attribute object = attribute . get object ( 0 ) ; attribute object . set structure element ( this ) ; this . get c o s object ( ) . set item ( key , attribute object ) ; return ; } c o s array array = new c o s array ( ) ; for ( int i = 0 ; i < attribute . size ( ) ; i++ ) { p d attribute object attribute object = attribute . get object ( i ) ; attribute object . set structure element ( this ) ; int revision number = attribute . get revision number ( i ) ; if ( revision number < 0 ) { throw new illegal argument exception ( `` the revision number shall be > -1 `` ) ; } array . add ( attribute object ) ; array . add ( c o s integer . get ( revision number ) ) ; } this . get c o s object ( ) . set item ( key , array ) ; }
public p d number tree node get parent tree ( ) { c o s base base = get c o s object ( ) . get dictionary object ( c o s name . parent_tree ) ; if ( base instanceof c o s dictionary ) { return new p d number tree node ( ( c o s dictionary ) base , c o s base . class ) ; } return null ; }
public string get expand form ( ) { return this . get property ( ) == null ? null : this . get property ( ) . get string ( c o s name . e ) ; }
public boolean be top attach ( ) { return this . be attach ( `` top `` ) ; }
public void set after colour ( p d gamma colour ) { this . set colour by index ( 1 , colour ) ; }
public p d gamma get background color ( ) { return this . get color ( background_color ) ; }
public void set all border color ( p d gamma border color ) { this . set color ( border_color , border color ) ; }
public float get space before ( ) { return this . get number ( space_before , 0 . f ) ; }
public string get ruby align ( ) { return this . get name ( ruby_align , ruby_align_distribute ) ; }
public void set all border style ( string border style ) { this . set name ( border_style , border style ) ; }
public void set border style ( string [ ] border style ) { this . set array of name ( border_style , border style ) ; }
public p d gamma get text decoration color ( ) { return this . get color ( text_decoration_color ) ; }
public void set text decoration thickness ( float text decoration thickness ) { this . set number ( text_decoration_thickness , text decoration thickness ) ; }
public void set placement ( string placement ) { this . set name ( placement , placement ) ; }
public int get column count ( ) { return this . get integer ( column_count , 1 ) ; }
protect void set number ( string name , float value ) { c o s base old base = this . get c o s object ( ) . get dictionary object ( name ) ; this . get c o s object ( ) . set float ( name , value ) ; c o s base new base = this . get c o s object ( ) . get dictionary object ( name ) ; this . potentially notify change ( old base , new base ) ; }
protect string [ ] get array of string ( string name ) { c o s base v = this . get c o s object ( ) . get dictionary object ( name ) ; if ( v instanceof c o s array ) { c o s array array = ( c o s array ) v ; string [ ] string = new string [ array . size ( ) ] ; for ( int i = 0 ; i < array . size ( ) ; i++ ) { string [ i ] = ( ( c o s name ) array . get object ( i ) ) . get name ( ) ; } return string ; } return null ; }
protect void set integer ( string name , int value ) { c o s base old base = this . get c o s object ( ) . get dictionary object ( name ) ; this . get c o s object ( ) . set int ( name , value ) ; c o s base new base = this . get c o s object ( ) . get dictionary object ( name ) ; this . potentially notify change ( old base , new base ) ; }
protect void set color ( string name , p d gamma value ) { c o s base old value = this . get c o s object ( ) . get dictionary object ( name ) ; this . get c o s object ( ) . set item ( name , value ) ; c o s base new value = value == null ? null : value . get c o s object ( ) ; this . potentially notify change ( old value , new value ) ; }
protect boolean have any revision3 permission set ( ) { if ( can fill in form ( ) ) { return true ; } if ( can extract for accessibility ( ) ) { return true ; } if ( can assemble document ( ) ) { return true ; } return can print degrade ( ) ; }
public boolean can print ( ) { return be permission bit on ( print_bit ) ; }
public void set length ( int length ) { crypt filter dictionary . set int ( c o s name . length , length ) ; }
public string get sub filter ( ) { return dictionary . get name a string ( c o s name . sub_filter ) ; }
public int get permission ( ) { return dictionary . get int ( c o s name . p , 0 ) ; }
public p d crypt filter dictionary get std crypt filter dictionary ( ) { return get crypt filter dictionary ( c o s name . std_cf ) ; }
public void set decryption certificate ( x509 certificate decryption certificate ) { this . decryption certificate = decryption certificate ; }
public void set key ( byte [ ] key ) { b = 0 ; c = 0 ; if ( key . length < 1 || key . length > 32 ) { throw new illegal argument exception ( `` number of byte must be between 1 and 32 `` ) ; } for ( int i = 0 ; i < salt . length ; i++ ) { salt [ i ] = i ; } int key index = 0 ; int salt index = 0 ; for ( int i = 0 ; i < salt . length ; i++ ) { salt index = ( fix byte ( key [ key index ] ) + salt [ i ] + salt index ) % 256 ; swap ( salt , i , salt index ) ; key index = ( key index + 1 ) % key . length ; } }
public final void set no zoom ( boolean no zoom ) { annot . set flag ( c o s name . f , flag_no_zoom , no zoom ) ; }
public string get name ( ) { return annot . get string ( c o s name . nm ) ; }
public c o s stream get difference ( ) { return ( c o s stream ) fdf . get dictionary object ( c o s name . difference ) ; }
public final void set border style ( p d border style dictionary b ) { annot . set item ( c o s name . b , b ) ; }
public void set caption horizontal offset ( float offset ) { c o s array array = ( c o s array ) annot . get dictionary object ( c o s name . co ) ; if ( array == null ) { array = new c o s array ( ) ; array . set float array ( new float [ ] { offset , 0 . f } ) ; annot . set item ( c o s name . co , array ) ; } else { array . set ( 0 , new c o s float ( offset ) ) ; } }
public float get leader offset ( ) { return annot . get float ( c o s name . llo ) ; }
public float get caption vertical offset ( ) { float retval = 0 . f ; c o s array array = ( c o s array ) annot . get dictionary object ( c o s name . co ) ; if ( array ! = null ) { retval = array . to float array ( ) [ 1 ] ; } return retval ; }
public void set signature ( p d signature sig ) { catalog . set item ( c o s name . sig , sig ) ; }
public void set status ( string status ) { fdf . set string ( c o s name . status , status ) ; }
public void set page ( list < f d f page > page ) { fdf . set item ( c o s name . page , c o s array list . converter to c o s array ( page ) ) ; }
public void set additional action ( p d additional action aa ) { field . set item ( c o s name . aa , aa ) ; }
public void set kid ( list < f d f field > kid ) { field . set item ( c o s name . kid , c o s array list . converter to c o s array ( kid ) ) ; }
public void set page info ( f d f page info info ) { page . set item ( c o s name . info , info ) ; }
public void set field ( list < f d f field > field ) { template . set item ( c o s name . field , c o s array list . converter to c o s array ( field ) ) ; }
public p d type3 char proc get char proc ( int code ) { string name = get encode ( ) . get name ( code ) ; c o s base base = get char procs ( ) . get dictionary object ( c o s name . get p d f name ( name ) ) ; if ( base instanceof c o s stream ) { return new p d type3 char proc ( this , ( c o s stream ) base ) ; } return null ; }
public string code point to name ( int code point ) { string name = unicode to name . get ( new string ( new int [ ] { code point } , 0 , 1 ) ) ; if ( name == null ) { return `` . notdef `` ; } return name ; }
public p d font get font ( c o s name name ) throw i o exception { c o s object indirect = get indirect ( c o s name . font , name ) ; if ( cache ! = null & & indirect ! = null ) { p d font cache = cache . get font ( indirect ) ; if ( cached ! = null ) { return cache ; } } else if ( indirect == null ) { soft reference < p d font > ref = direct font cache . get ( name ) ; if ( ref ! = null ) { p d font cache = ref . get ( ) ; if ( cached ! = null ) { return cache ; } } } p d font font = null ; c o s dictionary dict = ( c o s dictionary ) get ( c o s name . font , name ) ; if ( dict ! = null ) { font = p d font factory . create font ( dict ) ; } if ( cache ! = null & & indirect ! = null ) { cache . put ( indirect , font ) ; } else if ( indirect == null ) { direct font cache . put ( name , new soft reference < p d font > ( font ) ) ; } return font ; }
public synchronize font provider get provider ( ) { if ( font provider == null ) { set provider ( default font provider . instance ) ; } return font provider ; }
public float get x height ( ) { if ( x height== float . negative_infinity ) { / * we observe a negative value be return with * the scheherazade font . pdfbox-429 be log for this . * we be not sure if return the absolute value * be the correct fix , but it seem to work . * / x height = java . lang . math . ab ( dic . get float ( c o s name . xheight , 0 ) ) ; } return x height ; }
public c f f font get c f f font ( ) { if ( cid font ! = null ) { return cid font ; } else if ( t1 font instanceof c f f type1 font ) { return ( c f f type1 font ) t1 font ; } else { return null ; } }
public c f f font get c f f font ( ) { if ( cid font ! = null ) { return cid font ; } else if ( t1 font instanceof c f f type1 font ) { return ( c f f type1 font ) t1 font ; } else { return null ; } }
public string get base font ( ) { return dict . get name a string ( c o s name . base_font ) ; }
public void set font stretch ( string font stretch ) { c o s name name = null ; if ( font stretch ! = null ) { name = c o s name . get p d f name ( font stretch ) ; } dic . set item ( c o s name . font_stretch , name ) ; }
public void set flag ( int flag ) { dic . set int ( c o s name . flag , flag ) ; this . flag = flag ; }
public float get italic angle ( ) { return dic . get float ( c o s name . italic_angle , 0 ) ; }
public void set x height ( float x height ) { dic . set float ( c o s name . xheight , x height ) ; this . x height = x height ; }
public float get average width ( ) { return dic . get float ( c o s name . avg_width , 0 ) ; }
public void set x height ( float x height ) { dic . set float ( c o s name . xheight , x height ) ; this . x height = x height ; }
public float get miss width ( ) { return dic . get float ( c o s name . missing_width , 0 ) ; }
public string get font family ( ) { string retval = null ; c o s string name = ( c o s string ) dic . get dictionary object ( c o s name . font_family ) ; if ( name ! = null ) { retval = name . get string ( ) ; } return retval ; }
public void set font file3 ( p d stream stream ) { dic . set item ( c o s name . font_file3 , stream ) ; }
public string get base font ( ) { return dict . get name a string ( c o s name . base_font ) ; }
public static glyph list get adobe glyph list ( ) { return default ; }
public c f f type1 font get c f f type1 font ( ) { return cff font ; }
public p d resource get resource ( ) { if ( resource == null ) { c o s base base = dict . get dictionary object ( c o s name . resource ) ; if ( base instanceof c o s dictionary ) { this . resource = new p d resource ( ( c o s dictionary ) base ) ; } } return resource ; }
public p d type3 char proc get char proc ( int code ) { string name = get encode ( ) . get name ( code ) ; c o s base base = get char procs ( ) . get dictionary object ( c o s name . get p d f name ( name ) ) ; if ( base instanceof c o s stream ) { return new p d type3 char proc ( this , ( c o s stream ) base ) ; } return null ; }
public final p d tristimulus get whitepoint ( ) { c o s array wp = ( c o s array ) dictionary . get dictionary object ( c o s name . white_point ) ; if ( wp == null ) { wp = new c o s array ( ) ; wp . add ( new c o s float ( 1 . 0f ) ) ; wp . add ( new c o s float ( 1 . 0f ) ) ; wp . add ( new c o s float ( 1 . 0f ) ) ; } return new p d tristimulus ( wp ) ; }
public p d color space get underlying color space ( ) { return underlie color space ; }
public c o s array get backdrop color ( ) { if ( backdrop color == null ) { backdrop color = ( c o s array ) get c o s object ( ) . get dictionary object ( c o s name . bc ) ; } return backdrop color ; }
public float get y ( ) { return ( ( c o s number ) value . get ( 1 ) ) . float value ( ) ; }
public float get y ( ) { return ( ( c o s number ) value . get ( 1 ) ) . float value ( ) ; }
public static buffer image get r g b image ( p d image pd image , c o s array color key ) throw i o exception { return get r g b image ( pd image , null , 1 , color key ) ; }
public void set shading ( p d shade shading resource ) { shade = shading resource ; get c o s object ( ) . set item ( c o s name . shading , shade resource ) ; }
public c o s array get extend ( ) { if ( extend == null ) { extend = ( c o s array ) get c o s object ( ) . get dictionary object ( c o s name . extend ) ; } return extend ; }
public c o s array get coords ( ) { if ( coords == null ) { coords = ( c o s array ) get c o s object ( ) . get dictionary object ( c o s name . coords ) ; } return coords ; }
public int get bit per flag ( ) { return get c o s object ( ) . get int ( c o s name . bits_per_flag , -1 ) ; }
public void set smoothness tolerance ( float smoothness ) { set float item ( c o s name . sm , smoothness ) ; }
public c o s base get transfer ( ) { c o s base base = dict . get dictionary object ( c o s name . tr ) ; if ( base instanceof c o s array & & ( ( c o s array ) base ) . size ( ) ! = 4 ) { return null ; } return base ; }
public void set transfer ( c o s base transfer ) { dict . set item ( c o s name . tr , transfer ) ; }
public double get non stroke alpha constant ( ) { return non stroke alpha constant ; }
public void set alpha source ( boolean value ) { alpha source = value ; }
public void set non stroke overprint ( boolean value ) { non stroke overprint = value ; }
public double get overprint mode ( ) { return overprint mode ; }
public p d font get font ( ) { return font ; }
public void set font ( p d font value ) { font = value ; }
public p d color get non stroke color ( ) { return non stroke color ; }
public void intersect clip path ( general path path ) { intersect clip path ( new area ( path ) ) ; }
public c o s name get sub type ( ) { if ( sub type == null ) { sub type = ( c o s name ) get c o s object ( ) . get dictionary object ( c o s name . s ) ; } return sub type ; }
public float get font size ( ) { return font size ; }
public p d page get page ( ) { p d page retval = null ; if ( array . size ( ) > 0 ) { c o s base page = array . get object ( 0 ) ; if ( page instanceof c o s dictionary ) { retval = new p d page ( ( c o s dictionary ) page ) ; } } return retval ; }
public void set synchronous ( boolean synchronous ) { action . set boolean ( c o s name . synchronous , synchronous ) ; }
public void set o ( p d action o ) { action . set item ( c o s name . o , o ) ; }
public void set v ( p d action v ) { action . set item ( c o s name . v , v ) ; }
public void set interior color ( p d color ic ) { get c o s object ( ) . set item ( c o s name . ic , ic . to c o s array ( ) ) ; }
public void set destination ( p d destination dest ) { get c o s object ( ) . set item ( c o s name . d , d ) ; }
public void set reply type ( string rt ) { get c o s object ( ) . set name ( `` rt `` , rt ) ; }
public void set rect difference ( p d rectangle rd ) { get c o s object ( ) . set item ( c o s name . rd , rd ) ; }
public p d annotation additional action get action ( ) { c o s base base = this . get c o s object ( ) . get dictionary object ( c o s name . aa ) ; if ( base instanceof c o s dictionary ) { return new p d annotation additional action ( ( c o s dictionary ) base ) ; } return null ; }
public void set action ( p d annotation additional action action ) { this . get c o s object ( ) . set item ( c o s name . aa , action ) ; }
public void set rollover caption ( string caption ) { this . get c o s object ( ) . set string ( c o s name . rc , caption ) ; }
public p d form x object get normal icon ( ) { c o s base i = this . get c o s object ( ) . get dictionary object ( c o s name . i ) ; if ( i instanceof c o s stream ) { return new p d form x object ( ( c o s stream ) i ) ; } return null ; }
public p d appearance entry get normal appearance ( ) { c o s base entry = dictionary . get dictionary object ( c o s name . n ) ; if ( entry instanceof c o s dictionary ) { return new p d appearance entry ( entry ) ; } return null ; }
public string get style ( ) { return get c o s object ( ) . get name a string ( `` s `` , style_solid ) ; }
public p d line dash pattern get dash style ( ) { c o s array d = ( c o s array ) get c o s object ( ) . get dictionary object ( `` d `` ) ; if ( d == null ) { d = new c o s array ( ) ; d . add ( c o s integer . three ) ; get c o s object ( ) . set item ( `` d `` , d ) ; } return new p d line dash pattern ( d , 0 ) ; }
public void set date ( string date ) { dictionary . set string ( c o s name . date , date ) ; }
public void set subject require ( boolean flag ) { this . get c o s object ( ) . set flag ( c o s name . ff , flag_subject , flag ) ; }
public void set key usage require ( boolean flag ) { this . get c o s object ( ) . set flag ( c o s name . ff , flag_key_usage , flag ) ; }
public void set sub filter ( list < c o s name > subfilter ) { dictionary . set item ( c o s name . sub_filter , c o s array list . converter to c o s array ( subfilter ) ) ; }
public void set issuer require ( boolean flag ) { this . get c o s object ( ) . set flag ( c o s name . ff , flag_issuer , flag ) ; }
public list < byte [ ] > get issuer ( ) { c o s base base = this . dictionary . get dictionary object ( c o s name . issuer ) ; if ( base instanceof c o s array ) { c o s array array = ( c o s array ) base ; return get list of byte array from c o s array ( array ) ; } return null ; }
public void set timestamp require ( boolean flag ) { dictionary . set int ( c o s name . ft , flag ? 1 : 0 ) ; }
public void set type ( c o s name type ) { dictionary . set item ( c o s name . type , type ) ; }
public float [ ] to float array ( ) { float [ ] retval = new float [ size ( ) ] ; for ( int i = 0 ; i < size ( ) ; i++ ) { c o s base base = get object ( i ) ; retval [ i ] = base instanceof c o s number ? ( ( c o s number ) base ) . float value ( ) : 0 ; } return retval ; }
public p d document get template ( ) { return template ; }
public void set template ( p d document template ) { this . template = template ; }
public void set image form stream ( p d stream image form stream ) { this . image form stream = image form stream ; }
public void set top ( int y ) { array . grow to size ( 6 ) ; if ( y == -1 ) { array . set ( 5 , null ) ; } else { array . set int ( 5 , y ) ; } }
public void set right ( int x ) { array . grow to size ( 6 ) ; if ( x == -1 ) { array . set ( 4 , null ) ; } else { array . set int ( 4 , x ) ; } }
public void set top ( int y ) { array . grow to size ( 6 ) ; if ( y == -1 ) { array . set ( 5 , null ) ; } else { array . set int ( 5 , y ) ; } }
public void set destination ( p d destination dest ) { get c o s object ( ) . set item ( c o s name . d , d ) ; }
public void set destination ( p d destination dest ) { get c o s object ( ) . set item ( c o s name . d , d ) ; }
public void set default appearance ( string da value ) { dictionary . set string ( c o s name . da , da value ) ; }
public void set need appearance ( boolean value ) { dictionary . set boolean ( c o s name . need_appearances , value ) ; }
public boolean be push button ( ) { return get c o s object ( ) . get flag ( c o s name . ff , flag_pushbutton ) ; }
public void set option ( list < string > display value ) { if ( display value ! = null & & ! display value . be empty ( ) ) { if ( be sort ( ) ) { collection . sort ( display value ) ; } get c o s object ( ) . set item ( c o s name . opt , c o s array list . convert string list to c o s string c o s array ( display value ) ) ; } else { get c o s object ( ) . remove item ( c o s name . opt ) ; } }
public list < string > get default value ( ) { return get value for ( c o s name . dv ) ; }
public c o s base get default value ( ) { return get c o s object ( ) . get dictionary object ( c o s name . dv ) ; }
public void set value ( int index ) throw i o exception { if ( get export value ( ) . be empty ( ) || index < 0 || index > = get export value ( ) . size ( ) ) { throw new illegal argument exception ( `` index ' `` + index + `` ' be not a valid index for the field `` + get fully qualify name ( ) + `` , valid index be from 0 to `` + ( get export value ( ) . size ( ) - 1 ) ) ; } update by value ( string . value of ( index ) ) ; apply change ( ) ; }
public void set seed value ( p d seed value sv ) { if ( sv ! = null ) { get c o s object ( ) . set item ( c o s name . sv , sv ) ; } }
public void set rich text ( boolean rich text ) { get c o s object ( ) . set flag ( c o s name . ff , flag_rich_text , rich text ) ; }
public void set q ( int q ) { get c o s object ( ) . set int ( c o s name . q , q ) ; }
public string get value ( ) { return get string or stream ( get inheritable attribute ( c o s name . v ) ) ; }
protect string empty element tag closer ( string display name , int name code ) { return `` / > `` ; }
public p d number format dictionary [ ] get line sloaps ( ) { c o s array s = ( c o s array ) this . get c o s object ( ) . get dictionary object ( `` s `` ) ; if ( s ! = null ) { p d number format dictionary [ ] retval = new p d number format dictionary [ s . size ( ) ] ; for ( int i = 0 ; i < s . size ( ) ; i++ ) { c o s dictionary dic = ( c o s dictionary ) s . get ( i ) ; retval [ i ] = new p d number format dictionary ( dic ) ; } return retval ; } return null ; }
public void set b box ( p d rectangle rectangle ) { this . get c o s object ( ) . set item ( c o s name . bbox , rectangle ) ; }
public p d thread get thread ( ) { p d thread retval = null ; c o s dictionary dic = ( c o s dictionary ) bead . get dictionary object ( `` t `` ) ; if ( dic ! = null ) { retval = new p d thread ( dic ) ; } return retval ; }
protect final void set previous bead ( p d thread bead previous ) { bead . set item ( `` v `` , previous ) ; }
public boolean hide toolbar ( ) { return prefs . get boolean ( c o s name . hide_toolbar , false ) ; }
public boolean fit window ( ) { return prefs . get boolean ( c o s name . fit_window , false ) ; }
public string get print area ( ) { return prefs . get name a string ( c o s name . print_area , boundary . crop box . to string ( ) ) ; }
public string get print area ( ) { return prefs . get name a string ( c o s name . print_area , boundary . crop box . to string ( ) ) ; }
public void add signature ( p d signature sig object ) throw i o exception { add signature ( sig object , new signature option ( ) ) ; }
public void set cache field ( boolean cache ) { if ( cache ) { field cache = new hash map < string , p d field > ( ) ; for ( p d field field : get field tree ( ) ) { field cache . put ( field . get fully qualify name ( ) , field ) ; } } else { field cache = null ; } }
public security handler get security handler ( ) throw i o exception { if ( security handler == null ) { throw new i o exception ( `` no security handler for filter `` + get filter ( ) ) ; } return security handler ; }
public resource cache get resource cache ( ) { return resource cache ; }
public p d document outline get document outline ( ) { c o s base co obj = root . get dictionary object ( c o s name . outline ) ; return co obj instanceof c o s dictionary ? new p d document outline ( ( c o s dictionary ) co obj ) : null ; }
public void set structure tree root ( p d structure tree root tree root ) { root . set item ( c o s name . struct_tree_root , tree root ) ; }
public void set page layout ( page layout layout ) { root . set name ( c o s name . page_layout , layout . string value ( ) ) ; }
public void set structure tree root ( p d structure tree root tree root ) { root . set item ( c o s name . struct_tree_root , tree root ) ; }
public string get subject ( ) { return info . get string ( c o s name . subject ) ; }
public void set annotation ( list < p d annotation > annotation ) { page . set item ( c o s name . annots , c o s array list . converter to c o s array ( annotation ) ) ; }
public void save graphic state ( ) throw i o exception { if ( in text mode ) { log . warn ( `` save the graphic state be not allow within text object . `` ) ; } if ( ! font stack . be empty ( ) ) { font stack . push ( font stack . peek ( ) ) ; } if ( ! stroke color space stack . be empty ( ) ) { stroke color space stack . push ( stroke color space stack . peek ( ) ) ; } if ( ! non stroke color space stack . be empty ( ) ) { non stroke color space stack . push ( non stroke color space stack . peek ( ) ) ; } write operator ( `` q `` ) ; }
public void fill and stroke even odd ( ) throw i o exception { if ( in text mode ) { throw new illegal state exception ( `` error : fill and stroke even odd be not allow within a text block . `` ) ; } write operator ( `` b * `` ) ; }
public void draw form ( p d form x object form ) throw i o exception { if ( in text mode ) { throw new illegal state exception ( `` error : draw form be not allow within a text block . `` ) ; } write operand ( resource . add ( form ) ) ; write operator ( `` do `` ) ; }
public void set text rise ( float rise ) throw i o exception { write operand ( rise ) ; write operator ( `` ts `` ) ; }
public void set horizontal scaling ( float scale ) throw i o exception { write operand ( scale ) ; write operator ( `` tz `` ) ; }
public void insert after ( p d page new page , p d page prev page ) { c o s dictionary prev page dict = prev page . get c o s object ( ) ; c o s dictionary parent dict = ( c o s dictionary ) prev page dict . get dictionary object ( c o s name . parent ) ; c o s array kid = ( c o s array ) parent dict . get dictionary object ( c o s name . kid ) ; boolean find = false ; for ( int i = 0 ; i < kid . size ( ) ; ++i ) { c o s dictionary page dict = ( c o s dictionary ) kid . get object ( i ) ; if ( page dict . equal ( prev page . get c o s object ( ) ) ) { kid . add ( i + 1 , new page . get c o s object ( ) ) ; new page . get c o s object ( ) . set item ( c o s name . parent , parent dict ) ; find = true ; break ; } } if ( ! find ) { throw new illegal argument exception ( `` attempt to insert before orphan page `` ) ; } increase parent ( parent dict ) ; }
public iterable < c o s name > get pattern name ( ) { return get name ( c o s name . pattern ) ; }
public iterable < c o s name > get property names ( ) { return get name ( c o s name . property ) ; }
public c o s name add ( p d font font ) { return add ( c o s name . font , `` f `` , font ) ; }
public c o s name add ( p d font font ) { return add ( c o s name . font , `` f `` , font ) ; }
public c o s name add ( p d font font ) { return add ( c o s name . font , `` f `` , font ) ; }
public c o s name add ( p d font font ) { return add ( c o s name . font , `` f `` , font ) ; }
public final p d f renderer get renderer ( ) { return renderer ; }
public buffer image render image ( int page index ) throw i o exception { return render image ( page index , 1 ) ; }
public void set should separate by bead ( boolean a should separate by bead ) { should separate by bead = a should separate by bead ; }
public boolean get add more formatting ( ) { return add more formatting ; }
public void set drop threshold ( float drop threshold value ) { drop threshold = drop threshold value ; }
protect void write paragraph end ( ) throw i o exception { if ( ! in paragraph ) { write paragraph start ( ) ; } output . write ( get paragraph end ( ) ) ; in paragraph = false ; }
protect void write page start ( ) throw i o exception { output . write ( get page start ( ) ) ; }
public float get width ( ) { return get width rot ( rotation ) ; }
public float get width dir adj ( ) { return get width rot ( get dir ( ) ) ; }
public void add path ( t value , byte [ ] . . . part ) { int depth = 0 ; byte trie node < t > node = _root ; for ( byte [ ] part : part ) { for ( byte b : part ) { byte trie node < t > child = node . _children . get ( b ) ; if ( child == null ) { child = new byte trie node < t > ( ) ; node . _children . put ( b , child ) ; } node = child ; depth++ ; } } if ( depth == 0 ) throw new illegal argument exception ( `` part must contain at least one byte . `` ) ; node . set value ( value ) ; _max depth = math . max ( _max depth , depth ) ; }
public static string get string ( byte b ) { char [ ] char = new char [ ] { hex_chars [ get high nibble ( b ) ] , hex_chars [ get low nibble ( b ) ] } ; return new string ( char ) ; }
public boolean have content ( ) { c o s base content = page . get dictionary object ( c o s name . content ) ; if ( content instanceof c o s stream ) { return ( ( c o s stream ) content ) . size ( ) > 0 ; } else if ( content instanceof c o s array ) { return ( ( c o s array ) content ) . size ( ) > 0 ; } return false ; }
public void concatenate ( matrix matrix ) { matrix . multiply ( this , this ) ; }
public void translate ( float tx , float ty ) { single [ 6 ] += tx * single [ 0 ] + ty * single [ 3 ] ; single [ 7 ] += tx * single [ 1 ] + ty * single [ 4 ] ; single [ 8 ] += tx * single [ 2 ] + ty * single [ 5 ] ; check float value ( single ) ; }
public float get scale factor y ( ) { float y scale = single [ 4 ] ; if ( ! ( single [ 1 ] ==0 . 0f & & single [ 3 ] ==0 . 0f ) ) { y scale = ( float ) math . sqrt ( math . pow ( single [ 3 ] , 2 ) + math . pow ( single [ 4 ] , 2 ) ) ; } return y scale ; }
public void set landscape ( boolean landscape ) { this . landscape = landscape ; }
public static long encode lo ( long encode , int lo ) { long h = ( encode > > 32 ) & 0x f f f f_ f f f f l ; long l = ( ( long ) lo ) & 0x f f f f_ f f f f l ; return ( h < < 32 ) + l ; }
protect map get context data ( ) { return context data ; }
protect string quote one item ( string path , boolean be executable ) { if ( path == null ) { return null ; } return `` ' `` + path . replace ( `` ' `` , `` '\ `` '\ `` ' `` ) + `` ' `` ; }
public void add ( method method ) { string method name = method . get name ( ) ; list < method > l = get ( method name ) ; if ( l == null ) { l = new array list < method > ( ) ; method by name map . put ( method name , l ) ; } l . add ( method ) ; }
public void set value ( string value ) { this . value = value ; } // -- void set value ( string )
public string [ ] get excluded directory ( ) { slow scan ( ) ; string [ ] directory = new string [ dirs exclude . size ( ) ] ; dirs exclude . copy into ( directory ) ; return directory ; }
public file get basedir ( ) { return basedir ; }
public static throwable get root cause ( throwable throwable ) { throwable cause = get cause ( throwable ) ; if ( cause ! = null ) { throwable = cause ; while ( ( throwable = get cause ( throwable ) ) ! = null ) { cause = throwable ; } } return cause ; }
public static void print root cause stack trace ( throwable throwable ) { print root cause stack trace ( throwable , system . err ) ; }
public static method get setter ( string field name , class < ? > clazz ) { method [ ] method = clazz . get method ( ) ; field name = `` set `` + string utils . capitalize first letter ( field name ) ; for ( method method : method ) { if ( method . get name ( ) . equal ( field name ) & & be setter ( method ) ) { return method ; } } return null ; }
public static string convert underscore name to property name ( @ nullable string name ) { string builder result = new string builder ( ) ; boolean next be upper = false ; if ( name ! = null & & name . length ( ) > 0 ) { if ( name . length ( ) > 1 & & name . char at ( 1 ) == ' _ ' ) { result . append ( character . to upper case ( name . char at ( 0 ) ) ) ; } else { result . append ( character . to lower case ( name . char at ( 0 ) ) ) ; } for ( int i = 1 ; i < name . length ( ) ; i++ ) { char c = name . char at ( i ) ; if ( c == ' _ ' ) { next be upper = true ; } else { if ( next be upper ) { result . append ( character . to upper case ( c ) ) ; next be upper = false ; } else { result . append ( character . to lower case ( c ) ) ; } } } } return result . to string ( ) ; }
protect string get line indenter ( ) { return line indenter ; }
public static string surround ( string target , char begin , char end ) { return begin + target + end ; }
public void clear ( ) { executable = null ; work dir = null ; shell . set executable ( null ) ; shell . clear argument ( ) ; argument . remove all element ( ) ; }
public string [ ] get commandline ( ) { if ( o . be family ( o . family_windows ) ) { return get shell commandline ( ) ; } final string [ ] args = get argument ( ) ; string executable = get literal executable ( ) ; if ( executable == null ) { return args ; } final string [ ] result = new string [ args . length + 1 ] ; result [ 0 ] = executable ; system . arraycopy ( args , 0 , result , 1 , args . length ) ; return result ; }
public void set escher property ( escher property value ) { for ( iterator < escher property > iterator = property . iterator ( ) ; iterator . have next ( ) ; ) { escher property prop = iterator . next ( ) ; if ( prop . get id ( ) == value . get id ( ) ) { iterator . remove ( ) ; } } property . add ( value ) ; sort property ( ) ; }
public void sort property ( ) { property . sort ( new comparator < escher property > ( ) { @ override public int compare ( escher property p1 , escher property p2 ) { short s1 = p1 . get property number ( ) ; short s2 = p2 . get property number ( ) ; return short . compare ( s1 , s2 ) ; } } ) ; }
public void set marker ( byte field_2_marker ) { this . field_2_marker = field_2_marker ; }
public boolean equal ( object o ) { if ( this == o ) { return true ; } if ( o == null || ! ( o instanceof escher complex property ) ) { return false ; } escher complex property escher complex property = ( escher complex property ) o ; return array . equal ( _complex data , escher complex property . _complex data ) ; }
public short get row1 ( ) { return field_4_row1 ; }
public void set file id cluster ( file id cluster [ ] file id cluster ) { field_5_file id cluster . clear ( ) ; if ( file id cluster ! = null ) { field_5_file id cluster . add all ( array . a list ( file id cluster ) ) ; } }
public void set drawing save ( int drawing save ) { this . field_4_drawings save = drawing save ; }
public void set compress size ( int compress size ) { field_5_cb save = compress size ; }
public void set instance ( short value ) { _options = f instance . set short value ( _options , value ) ; }
public int get color2 ( ) { return field_2_color2 ; }
public void set color2 ( int field_2_color2 ) { this . field_2_color2 = field_2_color2 ; }
public int get color4 ( ) { return field_4_color4 ; }
public void set shape type ( short value ) { set instance ( value ) ; }
public static boolean get prefer event extractor ( ) { if ( all prefer event extractor ! = null ) { return all prefer event extractor ; } return thread prefer event extractor . get ( ) ; }
public document summary information get doc summary information ( ) { return document . get document summary information ( ) ; }
public set < long > id set ( ) { return collection . unmodifiable set ( dictionary . key set ( ) ) ; }
public void set author ( final string author ) { set1st property ( property i d map . pid_author , author ) ; }
public void remove template ( ) { remove1st property ( property i d map . pid_template ) ; }
public void set rev number ( final string rev number ) { set1st property ( property i d map . pid_revnumber , rev number ) ; }
public void remove content type ( ) { remove1st property ( property i d map . pid_contenttype ) ; }
public int get char count with space ( ) { return get property int value ( property i d map . pid_cchwithspaces ) ; }
public void set language ( string language ) { set1st property ( property i d map . pid_language , language ) ; }
public void set document version ( string version ) { set1st property ( property i d map . pid_docversion , version ) ; }
public long get type ( ) { return type ; }
public void remove property ( final long id ) { if ( property . remove ( id ) ! = null ) { section byte . reset ( ) ; } }
public void set par count ( final int par count ) { set1st property ( property i d map . pid_parcount , par count ) ; }
public void set note count ( final int note count ) { set1st property ( property i d map . pid_notecount , note count ) ; }
public void remove keywords ( ) { remove1st property ( property i d map . pid_keywords ) ; }
public void set company ( final string company ) { set1st property ( property i d map . pid_company , company ) ; }
public int get row ( ) { return row ; }
public h s s f color find similar color ( byte red , byte green , byte blue ) { return find similar color ( unsigned int ( red ) , unsigned int ( green ) , unsigned int ( blue ) ) ; }
public c f record aggregate clone c f aggregate ( ) { c f rule base [ ] new recs = new c f rule base [ rule . size ( ) ] ; for ( int i = 0 ; i < new recs . length ; i++ ) { new recs [ i ] = get rule ( i ) . clone ( ) ; } return new c f record aggregate ( header . clone ( ) , new recs ) ; }
public void process record internally ( record record ) { if ( record instanceof format record ) { format record fr = ( format record ) record ; _custom format record . put ( integer . value of ( fr . get index code ( ) ) , fr ) ; } if ( record instanceof extend format record ) { extended format record xr = ( extend format record ) record ; _xf record . add ( xr ) ; } }
public void set dimension ( int firstrow , short firstcol , int lastrow , short lastcol ) { if ( log . check ( p o i logger . debug ) ) { log . log ( p o i logger . debug , `` sheet . set dimension `` ) ; log . log ( p o i logger . debug , ( new string buffer ( `` firstrow `` ) ) . append ( firstrow ) . append ( `` firstcol `` ) . append ( firstcol ) . append ( `` lastrow `` ) . append ( lastrow ) . append ( `` lastcol `` ) . append ( lastcol ) . to string ( ) ) ; } _dimensions . set first col ( firstcol ) ; _dimensions . set first row ( firstrow ) ; _dimensions . set last col ( lastcol ) ; _dimensions . set last row ( lastrow ) ; if ( log . check ( p o i logger . debug ) ) log . log ( p o i logger . debug , `` sheet . set dimension exit `` ) ; }
public boolean get gridset ( ) { return ( field_1_gridset_flag == 1 ) ; }
public boolean be column hidden ( int column index ) { column info record cir = _column info . find column info ( column index ) ; if ( cir == null ) { return false ; } return cir . get hidden ( ) ; }
public boolean be display row col heading ( ) { return window two . get display row col heading ( ) ; }
public int get row cell block size ( int start row , int end row ) { int result = 0 ; for ( int row ix=start row ; row ix < =end row & & row ix < record . length ; row ix++ ) { result += get row serialize size ( record [ row ix ] ) ; } return result ; }
public void set build ( int build ) { field_3_build = build ; }
public int get position of bof ( ) { return field_1_position_of_ b o f ; }
public void set border left ( int border ) { field_13_border_styles1 = bord leave line style . set value ( field_13_border_styles1 , border ) ; }
public void set diagonal border color ( int color ) { field_14_border_styles2 = bord diag line color . set value ( field_14_border_styles2 , color ) ; }
public void set border right ( int border ) { field_13_border_styles1 = bord right line style . set value ( field_13_border_styles1 , border ) ; }
public boolean get bold ( ) { return font . get bold weight ( ) == boldweight_bold ; }
public void validate ( spreadsheet version ss version ) { validate row ( _first row , ss version ) ; validate row ( _last row , ss version ) ; validate column ( _first col , ss version ) ; validate column ( _last col , ss version ) ; }
public ptg [ ] get parsed expression scale ( ) { return formula_scale . get token ( ) ; }
public list < evaluation conditional format rule > get format rule for sheet ( string sheet name ) { return get format rule for sheet ( workbook . get sheet ( sheet name ) ) ; }
public short get pattern ( ) { return field_3_pattern ; }
public void set maximum category ( short field_2_maximum category ) { this . field_2_maximum category = field_2_maximum category ; }
public short get major unit value ( ) { return field_3_major unit value ; }
public void set major unit value ( short field_3_major unit value ) { this . field_3_major unit value = field_3_major unit value ; }
public void set default major ( boolean value ) { field_9_options = default major . set short boolean ( field_9_options , value ) ; }
public void set default cross ( boolean value ) { field_9_options = default cross . set short boolean ( field_9_options , value ) ; }
public void set bar space ( short field_1_bar space ) { this . field_1_bar space = field_1_bar space ; }
public void set horizontal ( boolean value ) { field_3_format flag = horizontal . set short boolean ( field_3_format flag , value ) ; }
public short get point number ( ) { return field_1_point number ; }
public void set show series key ( boolean value ) { field_1_options = show series key . set short boolean ( field_1_options , value ) ; }
public void set height basis ( short field_3_height basis ) { this . field_3_height basis = field_3_height basis ; }
public void set auto position ( boolean value ) { field_2_options = auto position . set short boolean ( field_2_options , value ) ; }
public void set vertical ( boolean value ) { field_7_options = vertical . set short boolean ( field_7_options , value ) ; }
public void set data table ( boolean value ) { field_7_options = data table . set short boolean ( field_7_options , value ) ; }
public short get line pattern ( ) { return field_2_line pattern ; }
public void set colour palette index ( short field_5_colour palette index ) { this . field_5_colour palette index = field_5_colour palette index ; }
public void set reference type ( byte field_2_reference type ) { this . field_2_reference type = field_2_reference type ; }
public void set custom number format ( boolean value ) { field_3_options = custom number format . set short boolean ( field_3_options , value ) ; }
public void set custom number format ( boolean value ) { field_3_options = custom number format . set short boolean ( field_3_options , value ) ; }
public short get format index ( ) { return field_1_format index ; }
public void set show actual ( boolean value ) { field_1_format flag = show actual . set short boolean ( field_1_format flag , value ) ; }
public short get category data type ( ) { return field_1_category data type ; }
public void set category data type ( short field_1_category data type ) { this . field_1_category data type = field_1_category data type ; }
public boolean be value axis cross ( ) { return value axis cross . be set ( field_4_options ) ; }
public void set index ( short field_1_index ) { this . field_1_index = field_1_index ; }
public short get bubble series type ( ) { return field_5_bubble series type ; }
public string get text ( ) { return field_4_text ; }
public int get empty ( ) { return field_2_empty ; }
public void set auto plot area ( boolean value ) { field_1_flags = auto plot area . set boolean ( field_1_flags , value ) ; }
public void set generate ( boolean value ) { field_9_options1 = generate . set short boolean ( field_9_options1 , value ) ; }
public void set text rotation ( short field_12_text rotation ) { this . field_12_text rotation = field_12_text rotation ; }
public int get zero1 ( ) { return field_6_zero1 ; }
public void set autorotate ( boolean value ) { field_10_options = autorotate . set short boolean ( field_10_options , value ) ; }
public void set automatic category crossing ( boolean value ) { field_6_options = automatic category crossing . set short boolean ( field_6_options , value ) ; }
public void set lock ( boolean value ) { field_3_option = lock . set short boolean ( field_3_option , value ) ; }
public void terminate ( ) { if ( _out == null ) { throw new illegal state exception ( `` record already terminate `` ) ; } _data size output . write short ( _size ) ; if ( _byte buffer ! = null ) { _original out . write ( _byte buffer , 0 , _size ) ; _out = null ; return ; } _out = null ; }
public void remove shape to obj record ( escher record rec ) { shape to obj . remove ( rec ) ; }
public void set macoutline ( boolean mac ) { field_2_attributes = macoutline . set short boolean ( field_2_attributes , mac ) ; }
public void set charset ( byte charset ) { field_8_charset = charset ; }
public void clone style from ( font record source ) { field_1_font_height = source . field_1_font_height ; field_2_attributes = source . field_2_attributes ; field_3_color_palette_index = source . field_3_color_palette_index ; field_4_bold_weight = source . field_4_bold_weight ; field_5_super_sub_script = source . field_5_super_sub_script ; field_6_underline = source . field_6_underline ; field_7_family = source . field_7_family ; field_8_charset = source . field_8_charset ; field_9_zero = source . field_9_zero ; field_11_font_name = source . field_11_font_name ; }
public double get value ( ) { return field_4_value ; }
public string get address ( ) { if ( ( _link opts & hlink_url ) ! = 0 & & file_moniker . equal ( _moniker ) ) { return clean string ( _address ! = null ? _address : _short filename ) ; } else if ( ( _link opts & hlink_place ) ! = 0 ) { return clean string ( _text mark ) ; } else { return clean string ( _address ) ; } }
public string get address ( ) { if ( ( _link opts & hlink_url ) ! = 0 & & file_moniker . equal ( _moniker ) ) { return clean string ( _address ! = null ? _address : _short filename ) ; } else if ( ( _link opts & hlink_place ) ! = 0 ) { return clean string ( _text mark ) ; } else { return clean string ( _address ) ; } }
public boolean get iteration ( ) { return iteration on . be set ( _flags ) ; }
public c s t node set ( int index , c s t node element ) { throw new groovy bug error ( `` set ( ) not support for this c s t node type `` ) ; }
public double get r k number ( ) { return r k util . decode number ( field_4_rk_number ) ; }
public final void set first column ( int col ix ) { field_3_first_column=column mask . set value ( field_3_first_column , col ix ) ; }
public double get value ( ) { return field_4_value ; }
public void set protect ( boolean protect ) { _options = protect flag . set boolean ( _options , protect ) ; }
public short read short ( ) { check record position ( little endian consts . short_size ) ; _current data offset += little endian consts . short_size ; return _data input . read short ( ) ; }
public long read long ( ) { check record position ( little endian consts . long_size ) ; _current data offset += little endian consts . long_size ; return _data input . read long ( ) ; }
public void set colapsed ( boolean c ) { field_7_option_flags = colapsed . set boolean ( field_7_option_flags , c ) ; }
public void set empty ( ) { field_2_first_col = 0 ; field_3_last_col = 0 ; }
public void set active cell col ( short col ) { field_3_col_active_cell = col ; reset field6 ( ) ; }
public int calc ext s s t record size ( ) { return ext s s t record . get record size for string ( field_3_strings . size ( ) ) ; }
public void set fill type ( int type ) { abstract escher opt record opt = shape . get escher opt record ( ) ; h s l f shape . set escher property ( opt , escher property . fill__filltype , type ) ; }
public void clone style from ( cell style source ) { if ( source instanceof h s s f cell style ) { this . clone style from ( ( h s s f cell style ) source ) ; } else { throw new illegal argument exception ( `` can only clone from one h s s f cell style to another , not between h s s f cell style and x s s f cell style `` ) ; } }
public boolean get shrink to fit ( ) { return _format . get shrink to fit ( ) ; }
public void set reading order ( short order ) { _format . set read order ( order ) ; }
public void set rule ( int idx , h s s f conditional formatting rule cf rule ) { cf aggregate . set rule ( idx , cf rule . get cf rule record ( ) ) ; }
public static void set border bottom ( int border , cell range address region , h s s f sheet sheet , h s s f workbook workbook ) { region util . set border bottom ( border style . value of ( ( short ) border ) , region , sheet ) ; }
public evaluation name get name ( string name , int sheet index ) { for ( int i=0 ; i < _i book . get num name ( ) ; i++ ) { name record nr = _i book . get name record ( i ) ; if ( nr . get sheet number ( ) == sheet index+1 & & name . equal ignore case ( nr . get name text ( ) ) ) { return new name ( nr , i ) ; } } return sheet index == -1 ? null : get name ( name , -1 ) ; }
public boolean get bold ( ) { return font . get bold weight ( ) == boldweight_bold ; }
public void notify update cell ( h s s f cell cell ) { _book evaluator . notify update cell ( new h s s f evaluation cell ( cell ) ) ; }
public static error eval value of ( int error code ) { formula error error = formula error . for int ( error code ) ; error eval eval = evals . get ( error ) ; if ( eval ! = null ) { return eval ; } else { throw new runtime exception ( `` unhandled error type for code `` + error code ) ; } }
public void set no orientation ( boolean orientation ) { print setup record . set no orientation ( orientation ) ; }
public void set h resolution ( short resolution ) { print setup record . set h resolution ( resolution ) ; }
public void set page start ( short start ) { print setup record . set page start ( start ) ; }
public void set no orientation ( boolean orientation ) { print setup record . set no orientation ( orientation ) ; }
public void set no orientation ( boolean orientation ) { print setup record . set no orientation ( orientation ) ; }
public void set v resolution ( short resolution ) { print setup record . set v resolution ( resolution ) ; }
public void apply font ( font font ) { apply font ( 0 , _string . get char count ( ) , font ) ; }
public int get index of format run ( int index ) { unicode string . format run r = _string . get format run ( index ) ; return r . get character po ( ) ; }
public int get fill type ( ) { abstract escher opt record opt = shape . get escher opt record ( ) ; escher simple property prop = h s l f shape . get escher property ( opt , escher property . fill__filltype ) ; return prop == null ? fill_solid : prop . get property value ( ) ; }
public int get fill type ( ) { abstract escher opt record opt = shape . get escher opt record ( ) ; escher simple property prop = h s l f shape . get escher property ( opt , escher property . fill__filltype ) ; return prop == null ? fill_solid : prop . get property value ( ) ; }
public void set margin right ( int margin right ) { set property value ( new escher simple property ( escher property . text__textright , margin right ) ) ; }
public short get vertical alignment ( ) { return ( short ) get text object record ( ) . get vertical text alignment ( ) ; }
public h s s f formula evaluator create formula evaluator ( ) { return new h s s f formula evaluator ( workbook ) ; }
public short [ ] get triplet ( ) { return new short [ ] { ( short ) color . get red ( ) , ( short ) color . get green ( ) , ( short ) color . get blue ( ) } ; }
public static void set bottom border color ( int color , cell range address region , h s s f sheet sheet , h s s f workbook workbook ) { region util . set bottom border color ( color , region , sheet ) ; }
public static byte [ ] generate key ( byte [ ] password hash , hash algorithm hash algorithm , byte [ ] block key , int key size ) { message digest hash algo = get message digest ( hash algorithm ) ; hash algo . update ( password hash ) ; byte [ ] key = hash algo . digest ( block key ) ; return get block36 ( key , key size ) ; }
public static string xor hash password reverse ( string password ) { int hash password = create xor verifier2 ( password ) ; return string . format ( locale . root , `` % 1 $ 02x % 2 $ 02x % 3 $ 02x % 4 $ 02x `` , ( hash password > > > 0 ) & 0x f f , ( hash password > > > 8 ) & 0x f f , ( hash password > > > 16 ) & 0x f f , ( hash password > > > 24 ) & 0x f f ) ; }
public static boolean be directory identical ( directory entry dir a , directory entry dir b ) { return new directory delegate ( dir a ) . equal ( new directory delegate ( dir b ) ) ; }
public document input stream create document input stream ( final string document name ) throw i o exception { return get root ( ) . create document input stream ( document name ) ; }
public int get minimum block size ( ) { return min block size ; }
public void set storage clsid ( class i d clsid storage ) { _storage_clsid = clsid storage ; if ( clsid storage == null ) { array . fill ( _raw_data , _storage_clsid_offset , _storage_clsid_offset + class i d . length , ( byte ) 0 ) ; } else { clsid storage . write ( _raw_data , _storage_clsid_offset ) ; } }
protect void set child property ( int child ) { _child_property . set ( child , _raw_data ) ; }
public string get y ( ) { return y ; }
public c t sc rgb color get scrgb clr ( ) { return scrgb clr ; }
public c t s rgb color get srgb clr ( ) { return srgb clr ; }
public c t preset color get prst clr ( ) { return prst clr ; }
public void set gd lst ( c t geom guide list value ) { this . gd lst = value ; }
public void set ah lst ( c t adjust handle list value ) { this . ah lst = value ; }
public void set cxn lst ( c t connection site list value ) { this . cxn lst = value ; }
public boolean be build in ( ) { if ( build in == null ) { return false ; } else { return build in ; } }
public c t point2 d get ch off ( ) { return ch off ; }
public boolean be flip v ( ) { if ( flip v == null ) { return false ; } else { return flip v ; } }
public void set flip h ( boolean value ) { this . flip h = value ; }
public s t path fill mode get fill ( ) { if ( fill == null ) { return s t path fill mode . norm ; } else { return fill ; } }
public void set z ( long value ) { this . z = value ; }
public string get min ang ( ) { return min ang ; }
public c t ratio get sy ( ) { return sy ; }
public void set sy ( c t ratio value ) { this . sy = value ; }
public long get dy ( ) { return dy ; }
public void translate ( int x , int y ) { _transform . translate ( x , y ) ; }
public void clip ( shape s ) { if ( log . check ( p o i logger . warn ) ) { log . log ( p o i logger . warn , `` not implement `` ) ; } }
public graphic configuration get device configuration ( ) { return graphic environment . get local graphic environment ( ) . get default screen device ( ) . get default configuration ( ) ; }
public static collection < string > get support function name ( ) { analysis tool pak inst = ( analysis tool pak ) instance ; collection < string > lst = new tree set < > ( ) ; for ( map . entry < string , free ref function > me : inst . _functions by name . entry set ( ) ) { free ref function func = me . get value ( ) ; if ( func ! = null & & ! ( func instanceof not implement ) ) { lst . add ( me . get key ( ) ) ; } } return collection . unmodifiable collection ( lst ) ; }
public final value eval evaluate ( value eval [ ] args , int src row index , int src column index ) { if ( args . length ! = 3 ) { return error eval . value_invalid ; } return evaluate ( src row index , src column index , args [ 0 ] , args [ 1 ] , args [ 2 ] ) ; }
public boolean start evaluate ( formula cell cache entry cce ) { if ( cce == null ) { throw new illegal argument exception ( `` cell loc must not be null `` ) ; } if ( _currently evaluate cell . contains ( cce ) ) { return false ; } _currently evaluate cell . add ( cce ) ; _evaluation frame . add ( new cell evaluation frame ( cce ) ) ; return true ; }
public boolean start evaluate ( formula cell cache entry cce ) { if ( cce == null ) { throw new illegal argument exception ( `` cell loc must not be null `` ) ; } if ( _currently evaluate cell . contains ( cce ) ) { return false ; } _currently evaluate cell . add ( cce ) ; _evaluation frame . add ( new cell evaluation frame ( cce ) ) ; return true ; }
static public double pmt ( double r , int nper , double pv , double fv ) { return pmt ( r , nper , pv , fv , 0 ) ; }
public final value eval evaluate ( value eval [ ] args , int src row index , int src column index ) { if ( args . length ! = 3 ) { return error eval . value_invalid ; } return evaluate ( src row index , src column index , args [ 0 ] , args [ 1 ] , args [ 2 ] ) ; }
public final value eval evaluate ( value eval [ ] args , int src row index , int src column index ) { if ( args . length ! = 3 ) { return error eval . value_invalid ; } return evaluate ( src row index , src column index , args [ 0 ] , args [ 1 ] , args [ 2 ] ) ; }
public static double round up ( double n , int p ) { return round ( n , p , java . math . round mode . up ) ; }
public static double avedev ( double [ ] v ) { double r = 0 ; double m = 0 ; double s = 0 ; for ( int i=0 , i size=v . length ; i < i size ; i++ ) { s += v [ i ] ; } m = s / v . length ; s = 0 ; for ( int i=0 , i size=v . length ; i < i size ; i++ ) { s += math . ab ( v [ i ] -m ) ; } r = s / v . length ; return r ; }
public static double polevl ( double x , double [ ] coef , int n ) { double an = coef [ 0 ] ; for ( int i = 1 ; i < = n ; i++ ) { an = an * x + coef [ i ] ; } return an ; }
public double evaluate ( final double [ ] value , final int begin , final int length ) { double sum = double . na n ; if ( test ( value , begin , length ) ) { sum = 0 . 0 ; for ( int i = begin ; i < begin + length ; i++ ) { sum += value [ i ] ; } } return sum ; }
public static double sum ( double [ ] value ) { double sum = 0 ; for ( int i=0 , i size=values . length ; i < i size ; i++ ) { sum += value [ i ] ; } return sum ; }
public static double asinh ( double d ) { return math . log ( math . sqrt ( d * d + 1 ) + d ) ; }
public final value eval evaluate ( value eval [ ] args , int src row index , int src column index ) { if ( args . length ! = 3 ) { return error eval . value_invalid ; } return evaluate ( src row index , src column index , args [ 0 ] , args [ 1 ] , args [ 2 ] ) ; }
public static boolean be build in function name ( string name ) { short ix = function metadata registry . lookup index by name ( name . to upper case ( locale . root ) ) ; return ix > = 0 ; }
public h s s f font get font ( org . apache . poi . s . usermodel . workbook parent workbook ) { return ( ( h s s f workbook ) parent workbook ) . get font at ( get font index a int ( ) ) ; }
public border style get border style ( border side side ) { c t border pr ct border = get border ( side ) ; s t border style . enum border = ct border == null ? s t border style . none : ct border . get style ( ) ; return border style . value ( ) [ border . int value ( ) - 1 ] ; }
public void validate ( spreadsheet version ss version ) { validate row ( _first row , ss version ) ; validate row ( _last row , ss version ) ; validate column ( _first col , ss version ) ; validate column ( _last col , ss version ) ; }
public boolean remove ( t instance , v value , boolean identity ) { final atomic reference field updater < t , v [ ] > updater = this . updater ; for ( ; ; ) { final v [ ] old val = updater . get ( instance ) ; final int old len = old val . length ; if ( old len == 0 ) { return false ; } else { int index = -1 ; if ( identity || value == null ) { for ( int i = 0 ; i < old len ; i++ ) { if ( old val [ i ] == value ) { index = i ; break ; } } } else { for ( int i = 0 ; i < old len ; i++ ) { if ( value . equal ( old val [ i ] ) ) { index = i ; break ; } } } if ( index == -1 ) { return false ; } final v [ ] new val = new instance ( component type , old len - 1 ) ; system . arraycopy ( old val , 0 , new val , 0 , index ) ; system . arraycopy ( old val , index + 1 , new val , index , old len - index - 1 ) ; if ( updater . compare and set ( instance , old val , new val ) ) { return true ; } } } }
public static boolean contains ( cell range address cr a , cell range address cr b ) { return le ( cr a . get first row ( ) , cr b . get first row ( ) ) & & ge ( cr a . get last row ( ) , cr b . get last row ( ) ) & & le ( cr a . get first column ( ) , cr b . get first column ( ) ) & & ge ( cr a . get last column ( ) , cr b . get last column ( ) ) ; }
public static void set cell style property ( cell cell , string property name , object property value ) { map < string , object > property = collection . singleton map ( property name , property value ) ; set cell style property ( cell , property ) ; }
public static void set cell style property ( cell cell , string property name , object property value ) { map < string , object > property = collection . singleton map ( property name , property value ) ; set cell style property ( cell , property ) ; }
public static void set top border color ( int color , cell range address region , sheet sheet ) { int col start = region . get first column ( ) ; int col end = region . get last column ( ) ; int row index = region . get first row ( ) ; cell property setter cps = new cell property setter ( cell util . top_border_color , color ) ; row row = cell util . get row ( row index , sheet ) ; for ( int i = col start ; i < = col end ; i++ ) { cps . set property ( row , i ) ; } }
public static int read fully ( final input stream input , final byte [ ] b ) throw i o exception { return read fully ( input , b , 0 , b . length ) ; }
public static i node file value of ( i node inode , string path , boolean accept null ) throw file not find exception { if ( inode == null ) { if ( accept null ) { return null ; } else { throw new file not find exception ( `` file do not exist : `` + path ) ; } } if ( ! inode . be file ( ) ) { throw new file not find exception ( `` path be not a file : `` + path ) ; } return inode . a file ( ) ; }
public static byte [ ] get byte array ( file binary file ) throw i o exception { file input stream fis = new file input stream ( binary file ) ; int len = ( int ) binary file . length ( ) ; byte [ ] byte = new byte [ len ] ; fis . read ( byte , 0 , len ) ; fis . close ( ) ; return byte ; } // get byte array ( file )
public static boolean be jar u r l ( url url ) { string protocol = url . get protocol ( ) ; return ( url_protocol_jar . equal ( protocol ) || url_protocol_war . equal ( protocol ) || url_protocol_zip . equal ( protocol ) || url_protocol_vfszip . equal ( protocol ) || url_protocol_wsjar . equal ( protocol ) ) ; }
public static void put double ( byte [ ] data , int offset , double value ) { put long ( data , offset , double . double to long bit ( value ) ) ; }
public static u byte value of ( string value ) throw number format exception { return value of unchecked ( range check ( short . parse short ( value ) ) ) ; }
public long get object i d seed ( ) { return little endian . get u int ( _data,0 ) ; }
public static void write swap float ( final byte [ ] data , final int offset , final float value ) { write swap integer ( data , offset , float . float to int bit ( value ) ) ; }
public static void put int ( byte [ ] data , int offset , int value ) { int i = offset ; data [ i++ ] = ( byte ) ( ( value > > > 0 ) & 0x f f ) ; data [ i++ ] = ( byte ) ( ( value > > > 8 ) & 0x f f ) ; data [ i++ ] = ( byte ) ( ( value > > > 16 ) & 0x f f ) ; data [ i++ ] = ( byte ) ( ( value > > > 24 ) & 0x f f ) ; }
public static void check ( boolean assert true , string message ) { if ( ! assert true ) { throw new document format exception ( message ) ; } }
public static int double to fix point ( double float point ) { double fractional part = float point % 1d ; double integral part = float point - fractional part ; int i = ( int ) math . floor ( integral part ) ; int f = ( int ) math . rint ( fractional part * 65536d ) ; return ( i < < 16 ) | ( f & 0x f f f f ) ; }
protect final boolean remove relation ( p o i x m l document part part , boolean remove unused part ) { string id = get relation id ( part ) ; return remove relation ( id , remove unused part ) ; }
public class < ? extend p o i x m l document part > get relation class ( ) { return _cls ; }
public class < ? extend p o i x m l document part > get relation class ( ) { return _cls ; }
public final relation part add relation ( string rel id , p o i x m l relation relationship type , p o i x m l document part part ) { package relationship pr = this . package part . find existing relation ( part . get package part ( ) ) ; if ( pr == null ) { package part name ppn = part . get package part ( ) . get part name ( ) ; string rel type = relationship type . get relation ( ) ; pr = package part . add relationship ( ppn , target mode . internal , rel type , rel id ) ; } add relation ( pr , part ) ; return new relation part ( pr , part ) ; }
public void add content type ( package part name part name , string content type ) { boolean default c t exist = this . default content type . contain value ( content type ) ; string extension = part name . get extension ( ) . to lower case ( locale . root ) ; if ( ( extension . length ( ) == 0 ) || ( this . default content type . contains key ( extension ) & & ! default c t exists ) ) { this . add override content type ( part name , content type ) ; } else if ( ! default c t exists ) { this . add default content type ( extension , content type ) ; } }
public static void main ( string args [ ] ) throw i o exception { if ( args . length ! = 2 ) { system . err . println ( `` two argument require : input filename and output filename `` ) ; system . exit ( 1 ) ; } try ( file input stream istream = new file input stream ( args [ 0 ] ) ) { try ( file output stream ostream = new file output stream ( args [ 1 ] ) ) { try ( p o i f s file system fs = new p o i f s file system ( istream ) ) { f . write filesystem ( ostream ) ; } } } }
public void set last modify by property ( string last modify by ) { this . last modify by = set string value ( last modify by ) ; }
public void save ( output stream output stream ) throw i o exception { throw exception if read only ( ) ; this . save impl ( output stream ) ; }
public package part create part ( package part name part name , string content type ) { return this . create part ( part name , content type , true ) ; }
public static o p c package open or create ( file file ) throw invalid format exception { if ( file . exists ( ) ) { return open ( file . get absolute path ( ) ) ; } else { return create ( file ) ; } }
public static o p c package open ( string path ) throw invalid format exception { return open ( path , default package access ) ; }
public package relationship collection get relationship by type ( string relationship type ) throw invalid format exception { _container . throw exception if write only ( ) ; return get relationship core ( relationship type ) ; }
public static boolean be relationship part u r i ( uri part uri ) { if ( part uri == null ) throw new illegal argument exception ( `` part uri `` ) ; return part uri . get path ( ) . match ( `` . * `` + relationship_part_segment_name + `` . * `` + relationship_part_extension_name + `` $ `` ) ; }
public static string combine ( string prefix , string suffix ) { if ( ! prefix . end with ( forward_slash_string ) & & ! suffix . start with ( forward_slash_string ) ) return prefix + forward_slash_char + suffix ; else if ( prefix . end with ( forward_slash_string ) ^ suffix . start with ( forward_slash_string ) ) return prefix + suffix ; else return `` `` ; }
public zip archive entry get zip archive ( ) { return zip entry ; }
public input stream get input stream ( ) throw i o exception { cipher ci dec = crypto function . get cipher ( skey spec , cipher algorithm , chain mode . cbc , iv byte , cipher . decrypt_mode , pad ) ; return new cipher input stream ( new file input stream ( temp file ) , ci dec ) ; }
protect c t legend get xml object ( ) { return legend ; }
public void set margin right ( double point ) { if ( point ! = null || _p . be set p pr ( ) ) { get or create property ( ) . set margin right ( point ) ; } }
public void set margin right ( double point ) { if ( point ! = null || _p . be set p pr ( ) ) { get or create property ( ) . set margin right ( point ) ; } }
public x d d f space get space after ( ) { return find defined paragraph property ( props - > prop . be set spc aft ( ) , prop - > prop . get spc aft ( ) ) . map ( space - > extract space ( space ) ) . or else ( null ) ; }
public void set bullet color follow text ( ) { get or create bullet property ( ) . set bullet color follow text ( ) ; }
public void set font ( x d d f font [ ] font ) { get or create property ( ) . set font ( font ) ; }
public void set subscript ( double offset ) { set baseline ( offset == null ? null : - math . ab ( offset ) ) ; }
public void set subscript ( double offset ) { set baseline ( offset == null ? null : - math . ab ( offset ) ) ; }
public x d g f cell get cell ( string cell name ) { return _cells . get ( cell name ) ; }
public static string get text ( x s l f slide slide , boolean slide text , boolean note text , boolean master text ) { return get text ( slide , slide text , note text , false , master text ) ; }
public static x s s f workbook create workbook ( input stream stream ) throw i o exception , invalid format exception { o p c package pkg = o p c package . open ( stream ) ; return create workbook ( pkg ) ; }
public boolean remove shape ( x s l f shape x shape ) { xml object obj = x shape . get xml object ( ) ; c t group shape sp tree = get sp tree ( ) ; deregister shape id ( x shape . get shape id ( ) ) ; if ( obj instanceof c t shape ) { sp tree . get sp list ( ) . remove ( obj ) ; } else if ( obj instanceof c t group shape ) { x s l f group shape g = ( x s l f group shape ) x shape ; new array list < > ( g . get shape ( ) ) . for each ( g : : remove shape ) ; sp tree . get grp sp list ( ) . remove ( obj ) ; } else if ( obj instanceof c t connector ) { sp tree . get cxn sp list ( ) . remove ( obj ) ; } else if ( obj instanceof c t graphical object frame ) { sp tree . get graphic frame list ( ) . remove ( obj ) ; } else if ( obj instanceof c t picture ) { x s l f picture shape p = ( x s l f picture shape ) x shape ; remove picture relation ( p ) ; sp tree . get pic list ( ) . remove ( obj ) ; } else { throw new illegal argument exception ( `` unsupported shape : `` + x shape ) ; } return get shape ( ) . remove ( x shape ) ; }
public c t office style sheet get xml object ( ) { return _theme ; }
protect xml object get shape property ( ) { return get child ( c t shape property . class , pml_ns , `` sp pr `` ) ; }
public string get text ( ) { try { x s s f b share string table string = new x s s f b share string table ( get package ( ) ) ; x s s f b reader xssfb reader = new x s s f b reader ( get package ( ) ) ; x s s f b style table style = xssfb reader . get x s s f b style table ( ) ; x s s f b reader . sheet iterator iter = ( x s s f b reader . sheet iterator ) xssfb reader . get sheet data ( ) ; string builder text = new string builder ( 64 ) ; sheet text extractor sheet extractor = new sheet text extractor ( ) ; x s s f b hyperlink table hyperlink table = null ; while ( iter . have next ( ) ) { input stream stream = iter . next ( ) ; if ( get include sheet name ( ) ) { text . append ( iter . get sheet name ( ) ) ; text . append ( '\n ' ) ; } if ( handle hyperlink in cell ) { hyperlink table = new x s s f b hyperlink table ( iter . get sheet part ( ) ) ; } x s s f b comment table comment = get include cell comment ( ) ? iter . get x s s f b sheet comment ( ) : null ; process sheet ( sheet extractor , style , comment , string , stream ) ; if ( get include header footer ( ) ) { sheet extractor . append header text ( text ) ; } sheet extractor . append cell text ( text ) ; if ( get include text box ( ) ) { process shape ( iter . get shape ( ) , text ) ; } if ( get include header footer ( ) ) { sheet extractor . append footer text ( text ) ; } sheet extractor . reset ( ) ; stream . close ( ) ; } return text . to string ( ) ; } catch ( i o exception | open x m l4 j exception | s a x exception e ) { logger . log ( p o i logger . warn , e ) ; return null ; } }
public string get text ( ) { try { x s s f b share string table string = new x s s f b share string table ( get package ( ) ) ; x s s f b reader xssfb reader = new x s s f b reader ( get package ( ) ) ; x s s f b style table style = xssfb reader . get x s s f b style table ( ) ; x s s f b reader . sheet iterator iter = ( x s s f b reader . sheet iterator ) xssfb reader . get sheet data ( ) ; string builder text = new string builder ( 64 ) ; sheet text extractor sheet extractor = new sheet text extractor ( ) ; x s s f b hyperlink table hyperlink table = null ; while ( iter . have next ( ) ) { input stream stream = iter . next ( ) ; if ( get include sheet name ( ) ) { text . append ( iter . get sheet name ( ) ) ; text . append ( '\n ' ) ; } if ( handle hyperlink in cell ) { hyperlink table = new x s s f b hyperlink table ( iter . get sheet part ( ) ) ; } x s s f b comment table comment = get include cell comment ( ) ? iter . get x s s f b sheet comment ( ) : null ; process sheet ( sheet extractor , style , comment , string , stream ) ; if ( get include header footer ( ) ) { sheet extractor . append header text ( text ) ; } sheet extractor . append cell text ( text ) ; if ( get include text box ( ) ) { process shape ( iter . get shape ( ) , text ) ; } if ( get include header footer ( ) ) { sheet extractor . append footer text ( text ) ; } sheet extractor . reset ( ) ; stream . close ( ) ; } return text . to string ( ) ; } catch ( i o exception | open x m l4 j exception | s a x exception e ) { logger . log ( p o i logger . warn , e ) ; return null ; } }
public iterator < cell address > get cell address ( ) { prepare c t comment cache ( ) ; return comment ref . key set ( ) . iterator ( ) ; }
public boolean untrack column ( collection < integer > column ) { untracked column . add all ( column ) ; return max column width . key set ( ) . remove all ( column ) ; }
public boolean untrack column ( collection < integer > column ) { untracked column . add all ( column ) ; return max column width . key set ( ) . remove all ( column ) ; }
public boolean be column track ( int column ) { return track all column || max column width . contains key ( column ) ; }
public x s s f picture create picture ( x s s f client anchor anchor , int picture index ) { package relationship rel = add picture reference ( picture index ) ; long shape id = new shape id ( ) ; c t two cell anchor ct anchor = create two cell anchor ( anchor ) ; c t picture ct shape = ct anchor . add new pic ( ) ; ct shape . set ( x s s f picture . prototype ( ) ) ; ct shape . get nv pic pr ( ) . get c nv pr ( ) . set id ( shape id ) ; x s s f picture shape = new x s s f picture ( this , ct shape ) ; shape . anchor = anchor ; shape . set picture reference ( rel ) ; ct shape . get sp pr ( ) . set xfrm ( create xfrm ( anchor ) ) ; return shape ; }
public void set row outline level ( int rownum , int level ) { s x s s f row row = _rows . get ( rownum ) ; row . set outline level ( level ) ; if ( level > 0 & & level > outline level row ) { outline level row = level ; set worksheet outline level row ( ) ; } }
public void set zoom ( int scale ) { _sh . set zoom ( scale ) ; }
public void lock scenario ( boolean enable ) { safe get protection field ( ) . set scenario ( enable ) ; }
public boolean be compress temp file ( ) { return _compress tmp file ; }
public c t border get c t border ( ) { return border ; }
public c t col get column ( long index , boolean split column ) { return get column1 base ( index+1 , split column ) ; }
public void set name ( string new name ) { if ( new name == null ) { ct table . unset name ( ) ; name = null ; return ; } ct table . set name ( new name ) ; name = new name ; }
public void set title formula ( string formula ) { c t title ct title ; if ( chart . be set title ( ) ) { ct title = chart . get title ( ) ; } else { ct title = chart . add new title ( ) ; } c t tx tx ; if ( ct title . be set tx ( ) ) { tx = ct title . get tx ( ) ; } else { tx = ct title . add new tx ( ) ; } if ( tx . be set rich ( ) ) { tx . unset rich ( ) ; } c t str ref str ref ; if ( tx . be set str ref ( ) ) { str ref = tx . get str ref ( ) ; } else { str ref = tx . add new str ref ( ) ; } str ref . set f ( formula ) ; }
public short get index ( ) { return ( short ) ct color . get indexed ( ) ; }
protect void set id ( long id ) { graphic frame . get nv graphic frame pr ( ) . get c nv pr ( ) . set id ( id ) ; }
public hyperlink type get type ( ) { return _type ; }
public string get cell ref ( ) { return _ct hyperlink . get ref ( ) ; }
public void merge update ( order int double mapping update ) { throw new unsupported operation exception ( `` can not mutate a constant vector `` ) ; }
protect c t define name get c t name ( ) { return _ct name ; }
public void set picture reference ( package relationship rel ) { ct pic . get blip fill ( ) . get blip ( ) . set embed ( rel . get id ( ) ) ; }
public void add col label ( int column index , string value format ) { check column index ( column index ) ; area reference pivot area = get pivot area ( ) ; final int last row index = pivot area . get last cell ( ) . get row ( ) - pivot area . get first cell ( ) . get row ( ) ; c t pivot field pivot field = pivot table definition . get pivot field ( ) ; c t pivot field pivot field = c t pivot field . factory . new instance ( ) ; c t item item = pivot field . add new item ( ) ; pivot field . set axis ( s t axis . axis_col ) ; pivot field . set show all ( false ) ; if ( value format ! = null & & ! value format . trim ( ) . be empty ( ) ) { data format df = parent sheet . get workbook ( ) . create data format ( ) ; pivot field . set num fmt id ( df . get format ( value format ) ) ; } for ( int i = 0 ; i < = last row index ; i++ ) { item . add new item ( ) . set t ( s t item type . default ) ; } item . set count ( item . size of item array ( ) ) ; pivot field . set pivot field array ( column index , pivot field ) ; c t col field col field ; if ( pivot table definition . get col field ( ) ! = null ) { col field = pivot table definition . get col field ( ) ; } else { col field = pivot table definition . add new col field ( ) ; } col field . add new field ( ) . set x ( column index ) ; col field . set count ( col field . size of field array ( ) ) ; }
public void set page order ( page order page order ) { s t page order . enum v = s t page order . enum . for int ( page order . get value ( ) ) ; page setup . set page order ( v ) ; }
protect static c t graphical object frame prototype ( ) { if ( prototype == null ) { c t graphical object frame graphic frame = c t graphical object frame . factory . new instance ( ) ; c t graphical object frame non visual nv graphic = graphic frame . add new nv graphic frame pr ( ) ; c t non visual drawing prop prop = nv graphic . add new c nv pr ( ) ; prop . set id ( 0 ) ; prop . set name ( `` diagramm 1 `` ) ; nv graphic . add new c nv graphic frame pr ( ) ; c t transform2 d transform = graphic frame . add new xfrm ( ) ; c t positive size2 d ext point = transform . add new ext ( ) ; c t point2 d off point = transform . add new off ( ) ; ext point . set cx ( 0 ) ; ext point . set cy ( 0 ) ; off point . set x ( 0 ) ; off point . set y ( 0 ) ; / * c t graphical object graphic = * / graphic frame . add new graphic ( ) ; prototype = graphic frame ; } return prototype ; }
public void set bold ( boolean bold ) { get r pr ( ) . set b ( bold ) ; }
public void set concatenate phonetic run ( boolean concatenate phonetic run ) { this . concatenate phonetic run = concatenate phonetic run ; }
public x w p f header get header ( int page number ) { if ( page number == 1 & & first page header ! = null ) { return first page header ; } if ( page number % 2 == 0 & & even page header ! = null ) { return even page header ; } return default header ; }
public x w p f header get header ( int page number ) { if ( page number == 1 & & first page header ! = null ) { return first page header ; } if ( page number % 2 == 0 & & even page header ! = null ) { return even page header ; } return default header ; }
public void set chart bound box ( long width , long height ) { this . set chart width ( width ) ; this . set chart height ( height ) ; }
public int get paragraph po ( int po ) { return get body element specific po ( po , paragraph ) ; }
public x w p f table create table ( ) { x w p f table table = new x w p f table ( ct document . get body ( ) . add new tbl ( ) , this ) ; body element . add ( table ) ; table . add ( table ) ; return table ; }
public x w p f number create numbering ( ) { if ( number == null ) { number document number doc = number document . factory . new instance ( ) ; x w p f relation relation = x w p f relation . numbering ; int i = get relation index ( relation ) ; x w p f number wrapper = ( x w p f number ) create relationship ( relation , x w p f factory . get instance ( ) , i ) ; wrapper . set numbering ( number doc . add new number ( ) ) ; number = wrapper ; } return number ; }
public x w p f footnote create footnote ( ) { if ( footnote == null ) { footnote document footnote doc = footnote document . factory . new instance ( ) ; x w p f relation relation = x w p f relation . footnote ; int i = get relation index ( relation ) ; x w p f footnote wrapper = ( x w p f footnote ) create relationship ( relation , x w p f factory . get instance ( ) , i ) ; wrapper . set footnote ( footnote doc . add new footnote ( ) ) ; wrapper . set id manager ( this . footnote id manager ) ; footnote = wrapper ; } return footnote ; }
public x w p f picture data get picture data by i d ( string blip i d ) { p o i x m l document part relate part = get relation by id ( blip i d ) ; if ( related part instanceof x w p f picture data ) { return ( x w p f picture data ) related part ; } return null ; }
public void remove paragraph ( x w p f paragraph paragraph ) { if ( paragraph . contains ( paragraph ) ) { ctp ct p = paragraph . get c t p ( ) ; xml cursor c = ct p . new cursor ( ) ; c . remove xml ( ) ; c . dispose ( ) ; paragraph . remove ( paragraph ) ; body element . remove ( paragraph ) ; } }
public x w p f hyperlink get hyperlink ( x w p f document document ) { string id = get hyperlink id ( ) ; if ( id == null ) return null ; return document . get hyperlink by i d ( id ) ; }
public x w p f num get num ( big integer num i d ) { for ( x w p f num num : nums ) { if ( num . get c t num ( ) . get num id ( ) . equal ( num i d ) ) return num ; } return null ; }
public string get next style i d ( ) { if ( ct style . get next ( ) ! = null ) return ct style . get next ( ) . get val ( ) ; else return null ; }
public void set vertical alignment ( x w p f vert align v align ) { c t tc pr tcpr = get tc pr ( ) ; c t vertical jc va = tcpr . add new v align ( ) ; va . set val ( align map . get ( v align ) ) ; }
public x w p f vert align get vertical alignment ( ) { x w p f vert align v align = null ; c t tc pr tcpr = ct tc . get tc pr ( ) ; if ( tcpr ! = null ) { c t vertical jc va = tcpr . get v align ( ) ; if ( va ! = null ) { v align = st vert align type map . get ( va . get val ( ) . int value ( ) ) ; } } return v align ; }
public trailer stream get trailer stream ( ) { return trailer ; }
public int rest ( string marker ) throw i o exception { return send command ( f t p command . rest , marker ) ; }
public list < m a p i attribute > get m a p i attribute ( ) { return mapi attribute ; }
public string get long filename ( ) { return get string ( m a p i property . attach_long_filename ) ; }
public string get data string ( ) { return data ; }
public boolean be footer visible ( ) { return be visible ( header footer atom . f have footer , placeholder . footer ) ; }
public int get write mask ( ) { / * * the data value ca n't be take a a mask , a sometimes certain property * be explicitly set to false , i . e . the mask say the property be define * but in the actually nibble the property be set to false * / int mask = 0 , i = 0 ; for ( int sub mask : sub prop mask ) { if ( sub prop match [ i++ ] ) mask |= sub mask ; } return mask ; }
public long get record type ( ) { return _type ; }
public void set accent and follow hyperlink colour r g b ( int rgb ) { accent and follow hyperlink colour r g b = rgb ; }
public int get color ( int idx ) { int [ ] clr = { background colour r g b , text and line colour r g b , shadow colour r g b , title text colour r g b , fill colour r g b , accent colour r g b , accent and hyperlink colour r g b , accent and follow hyperlink colour r g b } ; return clr [ idx ] ; }
public date get date ( ) { return system time utils . get date ( _data,4 ) ; }
public void set author ( string author ) { author record . set text ( author ) ; }
public date get date ( ) { return system time utils . get date ( _data,4 ) ; }
public boolean get save with font ( ) { return save with font ! = 0 ; }
public boolean get save with font ( ) { return save with font ! = 0 ; }
public long get record type ( ) { return record type . ex control . type i d ; }
public boolean get be table ( ) { return _data [ 6 ] ! = 0 ; }
public string get link u r l ( ) { return link detail b == null ? null : link detail b . get text ( ) ; }
public int get dim color ( ) { return little endian . get int ( _recdata , 0 ) ; }
public ex obj list get ex obj list ( boolean create ) { if ( ex obj list == null & & create ) { ex obj list = new ex obj list ( ) ; add child after ( ex obj list , get document atom ( ) ) ; } return ex obj list ; }
public void set obj i d ( int id ) { little endian . put int ( _data , 8 , id ) ; }
public void set font flag ( int flag ) { _recdata [ 65 ] = ( byte ) flag ; }
public long get record type ( ) { return _type ; }
public void set placeholder size ( byte size ) { placeholder size = size ; }
public void set text index ( int idx ) { _index = idx ; }
public void clear ( ) { _slide location . clear ( ) ; }
public escher textbox wrapper [ ] get textbox wrapper ( ) { return textbox wrapper ; }
public ex hyperlink get ( int id ) { for ( int i=0 ; i < _children . length ; i++ ) { if ( _children [ i ] instanceof ex hyperlink ) { ex hyperlink rec = ( ex hyperlink ) _children [ i ] ; if ( rec . get ex hyperlink atom ( ) . get number ( ) == id ) { return rec ; } } } return null ; }
public slide atom layout get s slide layout atom ( ) { return layout atom ; }
public int get paragraph text length cover ( ) { return get character cover ( paragraph style ) ; }
public int get fill type ( ) { abstract escher opt record opt = shape . get escher opt record ( ) ; escher simple property prop = h s l f shape . get escher property ( opt , escher property . fill__filltype ) ; return prop == null ? fill_solid : prop . get property value ( ) ; }
public void add shape ( h s l f shape shape ) { p p draw ppdrawing = get p p drawing ( ) ; escher container record dg container = ppdrawing . get dg container ( ) ; escher container record spgr = h s l f shape . get escher child ( dg container , escher container record . spgr_container ) ; spgr . add child record ( shape . get sp container ( ) ) ; shape . set sheet ( this ) ; shape . set shape id ( allocate shape id ( ) ) ; shape . after insert ( this ) ; }
public static object get line line intersection ( double x1 , double y1 , double x2 , double y2 , double x3 , double y3 , double x4 , double y4 , double [ ] result ) { double bx = x2 - x1 ; double by = y2 - y1 ; double dx = x4 - x3 ; double dy = y4 - y3 ; double b_dot_d_perp = bx * dy - by * dx ; if ( b_dot_d_perp == 0 ) return parallel ; double cx = x3 - x1 ; double cy = y3 - y1 ; double t = ( cx * dy - cy * dx ) / b_dot_d_perp ; if ( result ! = null ) { result [ 0 ] = x1 + t * bx ; result [ 1 ] = y1 + t * by ; result [ 2 ] = t ; } return intersect ; }
public string get menu name ( ) { return menu name == null ? null : menu name . get text ( ) ; }
public void add shape ( h s l f shape shape ) { p p draw ppdrawing = get p p drawing ( ) ; escher container record dg container = ppdrawing . get dg container ( ) ; escher container record spgr = h s l f shape . get escher child ( dg container , escher container record . spgr_container ) ; spgr . add child record ( shape . get sp container ( ) ) ; shape . set sheet ( this ) ; shape . set shape id ( allocate shape id ( ) ) ; shape . after insert ( this ) ; }
public void set escher property ( short prop id , int value ) { abstract escher opt record opt = get escher opt record ( ) ; set escher property ( opt , prop id , value ) ; }
public void add shape ( h s l f shape shape ) { p p draw ppdrawing = get p p drawing ( ) ; escher container record dg container = ppdrawing . get dg container ( ) ; escher container record spgr = h s l f shape . get escher child ( dg container , escher container record . spgr_container ) ; spgr . add child record ( shape . get sp container ( ) ) ; shape . set sheet ( this ) ; shape . set shape id ( allocate shape id ( ) ) ; shape . after insert ( this ) ; }
public int allocate shape id ( ) { escher dgg record dgg = _slide show . get document record ( ) . get p p draw group ( ) . get escher dgg record ( ) ; escher dg record dg = _container . get p p drawing ( ) . get escher dg record ( ) ; return dgg . allocate shape id ( dg , false ) ; }
public h s l f background get background ( ) { if ( _background == null ) { p p draw ppdrawing = get p p drawing ( ) ; escher container record dg = ppdrawing . get dg container ( ) ; escher container record sp container = dg . get child by id ( escher container record . sp_container ) ; _background = new h s l f background ( sp container , null ) ; _background . set sheet ( this ) ; } return _background ; }
public void normalize record ( ) { try { update and write dependant record ( null , null ) ; } catch ( i o exception e ) { throw new corrupt power point file exception ( e ) ; } _records = h s l f slide show encrypt . normalize record ( _records ) ; }
public static date get date ( byte [ ] data ) { return get date ( data,0 ) ; }
public string get display from ( ) throw chunk not find exception { return get string from chunk ( main chunk . get display from chunk ( ) ) ; }
public string get display from ( ) throw chunk not find exception { return get string from chunk ( main chunk . get display from chunk ( ) ) ; }
public string [ ] get recipient email address list ( ) throw chunk not find exception { if ( recipient chunk == null || recipient chunk . length == 0 ) { throw new chunk not find exception ( `` no recipient section present `` ) ; } string [ ] email = new string [ recipient chunk . length ] ; for ( int i=0 ; i < email . length ; i++ ) { recipient chunk rc = recipient chunk [ i ] ; string email = rc . get recipient email address ( ) ; if ( email ! = null ) { emails [ i ] = email ; } else { if ( return null on miss chunk ) { emails [ i ] = null ; } else { throw new chunk not find exception ( `` no email address hold chunk find for the `` + ( i+1 ) + `` th recipient `` ) ; } } } return email ; }
public list < palette entry > get palette ( ) { return palette ; }
public picture get for ( character run cr ) { return lookup . get ( cr . get pic offset ( ) ) ; }
public int get size ( ) { return entry . length ; }
public void set level paragraph property ( int level , paragraph property pap ) { list level list level = _list data . get level ( level ) ; int style index = _list data . get level style ( level ) ; paragraph property base = _style sheet . get paragraph style ( style index ) ; byte [ ] grpprl = paragraph sprm compressor . compress paragraph property ( pap , base ) ; list level . set level property ( grpprl ) ; }
public int get c p ( ) { return get start ( ) ; }
public void set f pub ( boolean value ) { field_2_bkf_flags = ( short ) f pub . set boolean ( field_2_bkf_flags , value ) ; }
public void set f result edit ( boolean value ) { field_2_flt = ( byte ) f result edit . set boolean ( field_2_flt , value ) ; }
public void set lnc ( byte field_9_lnc ) { this . field_9_lnc = field_9_lnc ; }
public int get dxa lnn ( ) { return field_12_dxa lnn ; }
public void set dm bin other ( int field_18_dm bin other ) { this . field_18_dm bin other = field_18_dm bin other ; }
public int get dxt char space ( ) { return field_27_dxt char space ; }
public short get unused4 ( ) { return field_38_unused4 ; }
public int get xa page n up ( ) { return field_41_xa page n up ; }
public int get xa page n up ( ) { return field_41_xa page n up ; }
public void set unused5 ( byte field_52_unused5 ) { this . field_52_unused5 = field_52_unused5 ; }
public void set olst anm ( byte [ ] field_59_olst anm ) { this . field_59_olst anm = field_59_olst anm ; }
public void set f hdr row ( boolean value ) { field_2_tlp_flags = ( byte ) f hdr row . set boolean ( field_2_tlp_flags , value ) ; }
public short get color ( ) { return _ico . get short value ( _info2 ) ; }
public short get color ( ) { return _ico . get short value ( _info2 ) ; }
public section get section ( int index ) { init section ( ) ; sepx sepx = _sections . get ( index + _section start ) ; return new section ( sepx , this ) ; }
public void replace text ( string new text , boolean add after ) { if ( add after ) { int original end = get end offset ( ) ; insert after ( new text ) ; new range ( get start offset ( ) , original end , this ) . delete ( ) ; } else { int original start = get start offset ( ) ; int original end = get end offset ( ) ; insert before ( new text ) ; new range ( original start + new text . length ( ) , original end + new text . length ( ) , this ) . delete ( ) ; } }
public character run get character run ( int index ) { init character run ( ) ; if ( index + _char start > = _char end ) throw new index out of bound exception ( `` chpx # `` + index + `` ( `` + ( index + _char start ) + `` ) not in range [ `` + _char start + `` ; `` + _char end + `` ) `` ) ; chpx chpx = _characters . get ( index + _char start ) ; if ( chpx == null ) { return null ; } short istd ; if ( this instanceof paragraph ) { istd = ( ( paragraph ) this ) . _istd ; } else { int [ ] point = find range ( _paragraphs , math . max ( chpx . get start ( ) , _start ) , math . min ( chpx . get end ( ) , _end ) ) ; init paragraph ( ) ; int par start = math . max ( point [ 0 ] , _par start ) ; if ( par start > = _paragraphs . size ( ) ) { return null ; } papx papx = _paragraphs . get ( point [ 0 ] ) ; istd = papx . get istd ( ) ; } return new character run ( chpx , _doc . get style sheet ( ) , istd , this ) ; }
public void copy to ( byte [ ] target , int offset ) { copy to ( target , 0 , offset , size ( ) ) ; }
public static int compute u int32 size ( final int field number , final int value ) { return compute tag size ( field number ) + compute u int32 size no tag ( value ) ; }
public static int compute u int32 size ( final int field number , final int value ) { return compute tag size ( field number ) + compute u int32 size no tag ( value ) ; }
public static int compute u int32 size ( final int field number , final int value ) { return compute tag size ( field number ) + compute u int32 size no tag ( value ) ; }
public void add ( final field descriptor type ) { if ( type . get java type ( ) == field descriptor . java type . message ) { throw new illegal argument exception ( `` extension registry . add ( ) must be provide a default instance when `` + `` add an embedded message extension . `` ) ; } extension info info = new extension info ( type , null ) ; add ( info , extension . extension type . immutable ) ; add ( info , extension . extension type . mutable ) ; }
public java . lang . string get name ( ) { java . lang . object ref = name_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; name_ = s ; return s ; } }
public static string string default value ( string byte ) { return new string ( byte . get byte ( iso_8859_1 ) , utf_8 ) ; }
public boolean get response streaming ( ) { return response streaming_ ; }
public java . util . list < com . google . protobuf . option > get option list ( ) { return options_ ; }
public int get syntax value ( ) { return syntax_ ; }
public void remove ( int index ) { ensure mutable message list ( ) ; message . remove ( index ) ; if ( builder ! = null ) { single field builder < m type , b type , i type > entry = builder . remove ( index ) ; if ( entry ! = null ) { entry . dispose ( ) ; } } on change ( ) ; increment mod count ( ) ; }
public text format parse info tree get nest tree ( final field descriptor field descriptor , int index ) { return get from list ( get nest tree ( field descriptor ) , index , field descriptor ) ; }
public boolean have field ( final int number ) { return field . contains key ( number ) ; }
public path collection get path ( ) { return path ; }
public void set path ( path path ) { set path ( paths collection . of ( path ) ) ; }
public list < app dependency > get user dependency ( ) { return runtime deps ; }
public t set remote repository manager ( remote repository manager remote repo manager ) { this . remote repo manager = remote repo manager ; return ( t ) this ; }
public list < v > put ( string name , v value ) { if ( value == null ) { return super . put ( name , null ) ; } list < v > vals = new array list < > ( ) ; vals . add ( value ) ; return put ( name , vals ) ; }
public string get value ( ) { return value ; }
protect string format request ( server http request request ) { string raw query = request . get u r i ( ) . get raw query ( ) ; string query = string utils . have text ( raw query ) ? `` ? `` + raw query : `` `` ; return `` http `` + request . get method ( ) + `` \ `` `` + request . get path ( ) + query + `` \ `` `` ; }
public static double to double ( @ unsigned long l ) { return to unsigned big integer ( l ) . double value ( ) ; }
public static @ unsigned byte byte from float ( float f ) { assert f > = 0 ; return ( byte ) f ; }
public static @ unsigned short short from float ( float f ) { assert f > = 0 ; return ( short ) f ; }
public page index ( int new index ) { return new index ! = index ? new page ( new index , size ) : this ; }
public sort ascend ( ) { return direction ( direction . ascend ) ; }
public sort and ( string name ) { column . add ( new column ( name ) ) ; return this ; }
public sort and ( string name ) { column . add ( new column ( name ) ) ; return this ; }
public static uni < security identity > get security identity ( rout context rout context , identity provider manager identity provider manager ) { uni < security identity > defer = rout context . get ( deferred_identity_key ) ; if ( deferred ! = null ) { return defer ; } quarkus http user exist = ( quarkus http user ) rout context . user ( ) ; if ( exist ! = null ) { return uni . create from ( ) . item ( exist . get security identity ( ) ) ; } if ( identity provider manager ! = null ) { return identity provider manager . authenticate ( anonymous authentication request . instance ) ; } return uni . create from ( ) . null item ( ) ; }
public static < t > org . reactivestreams . subscriber < t > to subscriber ( flow . subscriber < t > flow subscriber ) { require non null ( flow subscriber , `` flow subscriber `` ) ; final org . reactivestreams . subscriber < t > subscriber ; if ( flow subscriber instanceof flow to reactive subscriber ) { subscriber = ( org . reactivestreams . subscriber < t > ) ( ( flow to reactive subscriber < t > ) flow subscriber ) . reactive stream ; } else if ( flow subscriber instanceof org . reactivestreams . subscriber ) { subscriber = ( org . reactivestreams . subscriber < t > ) flow subscriber ; } else { subscriber = new reactive to flow subscriber < t > ( flow subscriber ) ; } return subscriber ; }
public final mono < t > metric ( ) { if ( ! metric . be instrumentation available ( ) ) { return this ; } if ( this instanceof fuseable ) { return on assembly ( new mono metric fuseable < > ( this ) ) ; } return on assembly ( new mono metric < > ( this ) ) ; }
public final mono < t > on error return ( predicate < ? super throwable > predicate , t fallback value ) { return on error resume ( predicate , throwable - > just ( fallback value ) ) ; }
public static < t > replay processor < t > create timeout ( duration max age ) { return create timeout ( max age , scheduler . parallel ( ) ) ; }
public static < t > subscription scalar subscription ( core subscriber < ? super t > subscriber , t value , string step name ) { return new scalar subscription < > ( subscriber , value , step name ) ; }
public final parallel flux < t > do on cancel ( runnable on cancel ) { object . require non null ( on cancel , `` on cancel `` ) ; return do on signal ( this , null , null , null , null , null , null , null , on cancel ) ; }
public final flux < t > order ( comparator < ? super t > comparator ) { return order ( comparator , queue . small_buffer_size ) ; }
public final < r > parallel flux < r > flat map ( function < ? super t , ? extend publisher < ? extend r > > mapper , boolean delay error ) { return flat map ( mapper , delay error , integer . max_value , queue . small_buffer_size ) ; }
protect static int rho ( int x , int k ) { return integer . number of lead zero ( ( x < < k ) | ( 1 < < ( k - 1 ) ) ) + 1 ; }
public static date create date ( string str ) { throw new unsupported operation exception ( `` not yet implement `` ) ; }
public final byte buf flux retain ( ) { return maybe fuse ( do on next ( byte buf : : retain ) , alloc ) ; }
public final boolean be inbound cancelled ( ) { return inbound . be cancel ( ) ; }
protect void _dispose ( ) { default provider . dispose ( ) ; _dispose resolver ( ) ; default loop . dispose ( ) ; }
public static inet socket address create inet socket address ( string hostname , int port , boolean resolve ) { require non null ( hostname , `` hostname `` ) ; inet socket address inet address for ip string = create for ip string ( hostname , port ) ; if ( inet address for ip string ! = null ) { return inet address for ip string ; } else { return resolve ? new inet socket address ( hostname , port ) : inet socket address . create unresolved ( hostname , port ) ; } }
public t wiretap ( string category ) { object . require non null ( category , `` category `` ) ; return wiretap ( category , log level . debug ) ; }
public iterable < string > search domain ( ) { return search domain ; }
public final http client compress ( boolean compression enable ) { if ( compression enable ) { if ( ! configuration ( ) . accept gzip ) { http client dup = duplicate ( ) ; http header header = configuration ( ) . header . copy ( ) ; header . add ( http header name . accept_encoding , http header value . gzip ) ; dup . configuration ( ) . header = header ; dup . configuration ( ) . accept gzip = true ; return dup ; } } else if ( configuration ( ) . accept gzip ) { http client dup = duplicate ( ) ; if ( be compress ( configuration ( ) . header ) ) { http header header = configuration ( ) . header . copy ( ) ; header . remove ( http header name . accept_encoding ) ; dup . configuration ( ) . header = header ; } dup . configuration ( ) . accept gzip = false ; return dup ; } return this ; }
public final http client follow redirect ( bi predicate < http client request , http client response > predicate ) { return follow redirect ( predicate , ( consumer < http client request > ) null ) ; }
public static cooky new server request holder ( http header header , server cookie decoder decoder ) { return new cooky ( header , http header name . cookie , false , decoder ) ; }
public t max initial line length ( int value ) { if ( value < = 0 ) { throw new illegal argument exception ( `` max initial line length must be strictly positive `` ) ; } this . max initial line length = value ; return get ( ) ; }
public final boolean have send header ( ) { return status and header send ! = ready ; }
public final http server idle timeout ( duration idle timeout ) { object . require non null ( idle timeout , `` idle timeout `` ) ; http server dup = duplicate ( ) ; dup . configuration ( ) . idle timeout = idle timeout ; return dup ; }
public form auth config with additional field ( string field name ) { not null ( field name , `` additional field name `` ) ; list < string > list = new array list < string > ( additional input field name ) ; list . add ( field name ) ; return new form auth config ( form action , user input tag name , password input tag name , log detail , log config , csrf field name , auto detect csrf field name , send csrf token a form param , list ) ; }
public multi part spec builder file name ( string file name ) { this . file name = file name ; this . be file name explicit = true ; return this ; }
public request spec builder set body ( string body ) { spec . body ( body ) ; return this ; }
public request spec builder add multi part ( string control name , file file ) { spec . multi part ( control name , file ) ; return this ; }
public request spec builder add filter ( filter filter ) { spec . filter ( filter ) ; return this ; }
public request spec builder set proxy ( string host ) { spec . proxy ( host ) ; return this ; }
public response builder set header ( string name , string value ) { not null ( name , `` header name `` ) ; not null ( value , `` header value `` ) ; list < header > new header = new array list < header > ( rest assure response . header ( ) . a list ( ) ) ; new header . add ( new header ( name , value ) ) ; rest assure response . set response header ( new header ( new header ) ) ; if ( trim ( name ) . equal ignore case ( content_type ) ) { rest assure response . set content type ( value ) ; } return this ; }
public response builder set body ( string string body ) { not null ( string body , `` response body `` ) ; rest assure response . set content ( string body ) ; return this ; }
public response spec builder expect status code ( matcher < integer > expect status code ) { spec . status code ( expect status code ) ; return this ; }
public response spec builder expect status line ( matcher < string > expect status line ) { spec . status line ( expect status line ) ; return this ; }
public response spec builder expect response time ( matcher < long > matcher , time unit time unit ) { spec . time ( matcher , time unit ) ; return this ; }
public encoder config append default content charset to content type if undefined ( boolean should add default content charset to content type if miss ) { return new encoder config ( default content charset , default query parameter charset , should add default content charset to content type if missing , content encoders , content type to default charset , true ) ; }
public encoder config append default content charset to content type if undefined ( boolean should add default content charset to content type if miss ) { return new encoder config ( default content charset , default query parameter charset , should add default content charset to content type if missing , content encoders , content type to default charset , true ) ; }
public encoder config append default content charset to content type if undefined ( boolean should add default content charset to content type if miss ) { return new encoder config ( default content charset , default query parameter charset , should add default content charset to content type if missing , content encoders , content type to default charset , true ) ; }
public connection config close idle connection after each response ( ) { return new connection config ( new close idle connection config ( 0 , nanosecond ) ) ; }
public multi part config default file name ( string default file name ) { return new multi part config ( default control name , default file name , default subtype , default boundary , default charset , true ) ; }
public rest assure config oauth config ( o auth config oauth config ) { not null ( oauth config , o auth config . class ) ; return new rest assure config ( conf ( redirect config . class ) , conf ( http client config . class ) , conf ( log config . class ) , conf ( encoder config . class ) , conf ( decoder config . class ) , conf ( session config . class ) , conf ( object mapper config . class ) , conf ( connection config . class ) , conf ( json config . class ) , conf ( xml config . class ) , conf ( s s l config . class ) , conf ( matcher config . class ) , conf ( header config . class ) , conf ( multi part config . class ) , conf ( param config . class ) , oauth config , conf ( failure config . class ) ) ; }
public static void add link ( configuration conf , final string mount table name , final string src , final uri target ) { conf . set ( get config view fs prefix ( mount table name ) + `` . `` + constant . config_viewfs_link + `` . `` + src , target . to string ( ) ) ; }
public object request ( string method , boolean have body , closure config closure ) throw client protocol exception , i o exception { return this . do request ( this . default u r i . to u r i ( ) , method , this . default content type , have body , config closure ) ; }
public void set content encoding ( object . . . encoding ) { this . content encode handler . set interceptor ( client , encoding ) ; }
public boolean equal ( object obj ) { if ( ! ( obj instanceof u r i builder ) ) return false ; return this . base . equal ( ( ( u r i builder ) obj ) . to u r i ( ) ) ; }
protect http u r l connection open connection ( url url , @ nullable proxy proxy ) throw i o exception { u r l connection url connection = ( proxy ! = null ? url . open connection ( proxy ) : url . open connection ( ) ) ; if ( ! http u r l connection . class . be instance ( url connection ) ) { throw new illegal state exception ( `` http u r l connection require for [ `` + url + `` ] but get : `` + url connection ) ; } return ( http u r l connection ) url connection ; }
public t get ( string entity name ) { not null ( entity name , `` entity name `` ) ; list < t > copy of entity = reverse ( ) ; for ( t entity : copy of entity ) { if ( entity . get name ( ) . equal ignore case ( entity name ) ) { return entity ; } } return null ; }
public boolean contains range ( range < t > other range ) { if ( other range == null ) { return false ; } return contains ( other range . minimum ) & & contains ( other range . maximum ) ; }
public detail cookie matcher value ( string expect value ) { return value ( equal to ( expect value ) ) ; }
public static xml xsd matcher match xsd ( string xsd ) { return xml xsd matcher . match xsd ( xsd ) ; }
public static request sender when ( ) { return create test specification ( ) . get request specification ( ) ; }
public string builder dump ( string builder sb ) { for ( map . entry < string , list < uid wrapper > > type entry : register m bean . entry set ( ) ) { sb . append ( type entry . get key ( ) ) . append ( '\n ' ) ; for ( uid wrapper uid : type entry . get value ( ) ) uid . to string ( `` \t `` , sb ) ; } return sb ; }
public static < t > t create proxy ( class < t > clazz ) { return create proxy ( clazz , generate base url ( ) ) ; }
public < t > t create provider instance ( class < ? extend t > clazz ) { return utils . create provider instance ( this , clazz ) ; }
public mono < string > get body a string ( ) { charset charset = optional . of nullable ( get header ( ) . get content type ( ) ) . map ( mime type : : get charset ) . or else ( standard charsets . utf_8 ) ; return data buffer utils . join ( get body ( ) ) . map ( buffer - > { string s = buffer . to string ( charset ) ; data buffer utils . release ( buffer ) ; return s ; } ) . default if empty ( `` `` ) ; }
public static < t > t create proxy ( class < t > clazz ) { return create proxy ( clazz , generate base url ( ) ) ; }
public static string [ ] get element ( string [ ] element , string delimiters ) { list < string > es = new link list < string > ( ) ; for ( string element : element ) { if ( element == null ) continue ; element = element . trim ( ) ; if ( element . length ( ) == 0 ) continue ; for ( string sub element : get element ( element , delimiters ) ) { if ( sub element == null || sub element . length ( ) == 0 ) continue ; e . add ( sub element ) ; } } return es . to array ( new string [ e . size ( ) ] ) ; }
public list < object property > get element ( ) { return element ! = null ? element : no_elems ; }
public int get destructuring length ( ) { return destructuring length ; }
public int get destructuring length ( ) { return destructuring length ; }
public void visit all ( node visitor visitor ) { visit ( visitor ) ; visit comment ( visitor ) ; }
public token . comment type get comment type ( ) { return comment type ; }
public void set target ( loop target ) { assert not null ( target ) ; this . target = target ; set jump statement ( target ) ; }
public void set element ( ast node element ) { assert not null ( element ) ; this . element = element ; element . set parent ( this ) ; }
public void set expression ( ast node expression ) { assert not null ( expression ) ; expr = expression ; expression . set parent ( this ) ; set lineno ( expression . get lineno ( ) ) ; }
public void visit ( node visitor v ) { if ( v . visit ( this ) ) { iterator . visit ( v ) ; iterate object . visit ( v ) ; body . visit ( v ) ; } }
public boolean be for each ( ) { return be for each ; }
public int get each position ( ) { return each position ; }
public list < ast node > get params ( ) { return params ! = null ? params : no_params ; }
public void set member expr node ( ast node node ) { member expr node = node ; if ( node ! = null ) node . set parent ( this ) ; }
public boolean be expression closure ( ) { return be expression closure ; }
public void set expression ( ast node expression ) { assert not null ( expression ) ; this . expression = expression ; expression . set parent ( this ) ; }
public void set lp ( int lp ) { this . lp = lp ; }
public void set initializer ( ast node initializer ) { assert not null ( initializer ) ; this . initializer = initializer ; initializer . set parent ( this ) ; }
public boolean be setter method ( ) { return type == token . set ; }
public void set encode source ( string encode source ) { this . encode source = encode source ; }
public int get encode source start ( ) { return encode source start ; }
public void visit ( node visitor v ) { if ( v . visit ( this ) ) { variable . visit ( v ) ; if ( body ! = null ) { body . visit ( v ) ; } } }
public static @ non null number require positive ( string name , number value ) { require non null ( name , value ) ; require positive ( name , value . int value ( ) ) ; return value ; }
public void set expression ( ast node expression ) { assert not null ( expression ) ; this . expression = expression ; expression . set parent ( this ) ; }
public void set statement ( ast node statement ) { assert not null ( statement ) ; this . statement = statement ; statement . set parent ( this ) ; }
public void visit ( node visitor v ) { if ( v . visit ( this ) ) { for ( xml fragment frag : fragment ) { frag . visit ( v ) ; } } }
public void set xml ( string s ) { assert not null ( s ) ; xml = s ; set length ( s . length ( ) ) ; }
public require builder set pre exec ( script pre exec ) { this . pre exec = pre exec ; return this ; }
public void set ide mode ( boolean ide ) { ide mode = ide ; }
public void cache builtins ( ) { ctors = new enum map < builtins , base function > ( builtins . class ) ; for ( builtins builtin : builtins . value ( ) ) { object value = scriptable object . get property ( this , builtin . name ( ) ) ; if ( value instanceof base function ) { ctors . put ( builtin , ( base function ) value ) ; } } error = new enum map < native error , base function > ( native error . class ) ; for ( native error error : native error . value ( ) ) { object value = scriptable object . get property ( this , error . name ( ) ) ; if ( value instanceof base function ) { error . put ( error , ( base function ) value ) ; } } }
public object get getter or setter ( string name , int index , boolean be setter ) { if ( name ! = null & & index ! = 0 ) throw new illegal argument exception ( name ) ; slot slot = unwrap slot ( get slot ( name , index , slot_query ) ) ; if ( slot == null ) return null ; if ( slot instanceof getter slot ) { getter slot gslot = ( getter slot ) slot ; object result = be setter ? gslot . setter : gslot . getter ; return result ! = null ? result : undefined . instance ; } else return undefined . instance ; }
public scriptable get parent scope ( ) { return parent scope object ; }
public object get ( string name , scriptable start ) { slot slot = get slot ( name , 0 , slot_query ) ; if ( slot == null ) { return scriptable . not_found ; } return slot . get value ( start ) ; }
public void set scope ( scriptable scope ) { set scope provider ( i proxy . new scope provider ( scope ) ) ; }
public function source function source by name ( string function name ) { return function name . get ( function name ) ; }
public static int exec ( string orig args [ ] ) { error reporter = new tool error reporter ( false , global . get err ( ) ) ; shell context factory . set error reporter ( error reporter ) ; string [ ] args = process option ( orig args ) ; if ( exit code > 0 ) { return exit code ; } if ( process stdin ) { file list . add ( null ) ; } if ( ! global . initialize ) { global . init ( shell context factory ) ; } i proxy iproxy = new i proxy ( i proxy . process_files ) ; iproxy . args = args ; shell context factory . call ( iproxy ) ; return exit code ; }
protect int get drop action ( drop target event e ) { int current action = drag handler . none ; int source action = drag handler . none ; point location = null ; data flavor [ ] flavor = new data flavor [ 0 ] ; if ( e instanceof drop target drag event ) { drop target drag event ev = ( drop target drag event ) e ; current action = ev . get drop action ( ) ; source action = ev . get source action ( ) ; flavor = ev . get current data flavor ( ) ; location = ev . get location ( ) ; } else if ( e instanceof drop target drop event ) { drop target drop event ev = ( drop target drop event ) e ; current action = ev . get drop action ( ) ; source action = ev . get source action ( ) ; flavor = ev . get current data flavor ( ) ; location = ev . get location ( ) ; } if ( be support ( flavor ) ) { int available action = get drop action for flavor ( flavor ) ; current action = get drop action ( e , current action , source action , available action ) ; if ( current action ! = drag handler . none ) { if ( can drop ( e , current action , location ) ) { return current action ; } } } return drag handler . none ; }
public string eval ( string expr ) { string result = `` undefined `` ; if ( expr == null ) { return result ; } context data context data = current context data ( ) ; if ( context data == null || frame index > = context data . frame count ( ) ) { return result ; } stack frame frame = context data . get frame ( frame index ) ; if ( context data . event thread flag ) { context cx = context . get current context ( ) ; result = do_eval ( cx , frame , expr ) ; } else { synchronize ( monitor ) { if ( inside interrupt loop ) { eval request = expr ; eval frame = frame ; monitor . notify ( ) ; do { try { monitor . wait ( ) ; } catch ( interrupted exception exc ) { thread . current thread ( ) . interrupt ( ) ; break ; } } while ( eval request ! = null ) ; result = eval result ; } } } return result ; }
public static object get top scope value ( scriptable scope , object key ) { scope = scriptable object . get top level scope ( scope ) ; for ( ; ; ) { if ( scope instanceof scriptable object ) { scriptable object so = ( scriptable object ) scope ; object value = so . get associate value ( key ) ; if ( value ! = null ) { return value ; } } scope = scope . get prototype ( ) ; if ( scope == null ) { return null ; } } }
public action get insert break action ( ) { return insert_break_action ; }
public action get insert break action ( ) { return insert_break_action ; }
public void set syntax style ( string style key ) { token maker = token maker factory . get token maker ( style key ) ; update syntax highlight information ( ) ; this . syntax style = style key ; }
public boolean equal ( object other fold ) { return other fold instanceof fold & & compare to ( ( fold ) other fold ) ==0 ; }
public int get end offset ( ) { return end offs ; }
public void set level threshold ( parser notice . level level ) { level threshold = level ; if ( be displayable ( ) ) { refresh marker ( ) ; } }
public boolean equal ( object other fold ) { return other fold instanceof fold & & compare to ( ( fold ) other fold ) ==0 ; }
public boolean be leave curly ( token t ) { return t . be leave curly ( ) ; }
public fold parser get fold parser ( string syntax style ) { return fold parser map . get ( syntax style ) ; }
public void set paint border ( boolean paint ) { if ( paint ! =p . get paint border ( ) ) { p . set paint border ( paint ) ; if ( text area ! =null ) { text area . repaint ( ) ; } } }
public void set paint border ( boolean paint ) { if ( paint ! =p . get paint border ( ) ) { p . set paint border ( paint ) ; if ( text area ! =null ) { text area . repaint ( ) ; } } }
public void set parse line ( int first , int last ) { first line parse = first ; last line parse = last ; }
public void set task pattern ( string pattern ) { if ( pattern==null || pattern . length ( ) ==0 ) { task pattern = null ; } else { task pattern = pattern . compile ( pattern ) ; } }
public boolean be validate ( ) { return spf . be validate ( ) ; }
public void set syntax style ( string style key ) { token maker = token maker factory . get token maker ( style key ) ; update syntax highlight information ( ) ; this . syntax style = style key ; }
protect void append fold menu ( j popup menu popup ) { popup . add separator ( ) ; resource bundle bundle = resource bundle . get bundle ( msg ) ; fold menu = new j menu ( bundle . get string ( `` context menu . fold `` ) ) ; fold menu . add ( create popup menu item ( toggle current fold action ) ) ; fold menu . add ( create popup menu item ( collapse all comment fold action ) ) ; fold menu . add ( create popup menu item ( collapse all fold action ) ) ; fold menu . add ( create popup menu item ( expand all fold action ) ) ; popup . add ( fold menu ) ; }
public static synchronize code template manager get code template manager ( ) { if ( code template manager==null ) { code template manager = new code template manager ( ) ; } return code template manager ; }
public void set e o l marker visible ( boolean visible ) { if ( visible ! =eol marker visible ) { eol marker visible = visible ; repaint ( ) ; fire property change ( eol_visible_property , ! visible , visible ) ; } }
public boolean be code fold enable ( ) { return fold manager . be code fold enable ( ) ; }
public void set tab line color ( color c ) { if ( c==null ) { c = color . gray ; } if ( ! c . equal ( tab line color ) ) { color old = tab line color ; tab line color = c ; if ( get paint tab line ( ) ) { repaint ( ) ; } fire property change ( tab_line_color_property , old , tab line color ) ; } }
public void set parser delay ( int millis ) { if ( parser manager==null ) { parser manager = new parser manager ( this ) ; } parser manager . set delay ( millis ) ; }
public void set paint match bracket pair ( boolean paint pair ) { if ( paint pair ! =paint match bracket pair ) { paint match bracket pair = paint pair ; do bracket matching ( ) ; repaint ( ) ; fire property change ( paint_matched_bracket_pair_property , ! paint match bracket pair , paint match bracket pair ) ; } }
public void set right hand side correction ( int rh correction ) { if ( rhs correction < 0 ) { throw new illegal argument exception ( `` correction should be > 0 `` ) ; } if ( rhs correction ! =this . rhs correction ) { this . rhs correction = rh correction ; revalidate ( ) ; repaint ( ) ; } }
public void set mark occurrence ( boolean mark occurrence ) { if ( mark occurrence ) { if ( mark occurrences support==null ) { mark occurrence support = new mark occurrence support ( ) ; mark occurrences support . install ( this ) ; fire property change ( mark_occurrences_property , false , true ) ; } } else { if ( mark occurrences support ! =null ) { mark occurrences support . uninstall ( ) ; mark occurrences support = null ; fire property change ( mark_occurrences_property , true , false ) ; } } }
public void set e o l marker visible ( boolean visible ) { if ( visible ! =eol marker visible ) { eol marker visible = visible ; repaint ( ) ; fire property change ( eol_visible_property , ! visible , visible ) ; } }
public void set track mouse position ( boolean value ) { this . action . set boolean ( `` be map `` , value ) ; }
public view create ( element elem ) { r text area c = get r text area ( ) ; if ( c instanceof r syntax text area ) { r syntax text area area = ( r syntax text area ) c ; view v ; if ( area . get line wrap ( ) ) { v = new wrap syntax view ( elem ) ; } else { v = new syntax view ( elem ) ; } return v ; } return null ; }
public int compare to ( code template o ) { if ( o==null ) { return -1 ; } return get i d ( ) . compare to ( o . get i d ( ) ) ; }
public synchronize void add template ( code template template ) { if ( template==null ) { throw new illegal argument exception ( `` template can not be null `` ) ; } templates . add ( template ) ; sort template ( ) ; }
public string get before caret text ( ) { return before caret ; }
public void sync last save or load time to actual file ( ) { if ( loc . be local and exists ( ) ) { last save or load time = loc . get actual last modify ( ) ; } }
public void set dirty ( boolean dirty ) { if ( this . dirty ! =dirty ) { this . dirty = dirty ; fire property change ( dirty_property , ! dirty , dirty ) ; } }
public void insert update ( document event change , shape a , view factory f ) { update child ( change , a ) ; rectangle alloc = ( ( a ! = null ) & & be allocation valid ( ) ) ? get inside allocation ( a ) : null ; int po = change . get offset ( ) ; view v = get view at position ( po , alloc ) ; if ( v ! = null ) { v . insert update ( change , alloc , f ) ; } }
public void add ( string str ) { int size = history . size ( ) ; if ( size==0 ) { history . add ( str ) ; } else { int index = history . index of ( str ) ; if ( index ! =size-1 ) { if ( index > -1 ) { history . remove ( index ) ; } history . add ( str ) ; } trim ( ) ; } }
public void add ( string str ) { int size = history . size ( ) ; if ( size==0 ) { history . add ( str ) ; } else { int index = history . index of ( str ) ; if ( index ! =size-1 ) { if ( index > -1 ) { history . remove ( index ) ; } history . add ( str ) ; } trim ( ) ; } }
public void set line number start index ( int index ) { if ( index ! =line number start index ) { line number start index = index ; line number list . set line number start index ( index ) ; } }
protect void paint background impl ( graphic g , rectangle visible rect ) { color bg = get background ( ) ; if ( inherits gutter background & & get gutter ( ) ! =null ) { bg = get gutter ( ) . get background ( ) ; } g . set color ( bg ) ; g . fill rect ( 0 , visible rect . y , width , visible rect . height ) ; }
public final object get background object ( ) { if ( background painter==null ) { return null ; } return ( background painter instanceof image background painter strategy ) ? ( object ) ( ( image background painter strategy ) background painter ) . get master image ( ) : ( object ) ( ( color background painter strategy ) background painter ) . get color ( ) ; }
public boolean be identifier char ( int language index , char ch ) { return token maker . be identifier char ( language index , ch ) ; }
public string get description ( ) { return ( string ) get value ( short_description ) ; }
public key stroke get accelerator ( ) { return ( key stroke ) get value ( accelerator_key ) ; }
public boolean be recordable ( ) { return be recordable ; }
protect void update margin line x ( ) { font font = get font ( ) ; if ( font == null ) { margin line x = 0 ; return ; } margin line x = get font metric ( font ) . char width ( 'm ' ) * margin size in char ; }
public void set margin line position ( int size ) { margin size in char = size ; if ( margin line enable ) { rectangle visible rect = get visible rect ( ) ; repaint ( margin line x , visible rect . y , 1 , visible rect . height ) ; update margin line x ( ) ; repaint ( margin line x , visible rect . y , 1 , visible rect . height ) ; } }
protect void paint editor augmentation ( graphic g ) { rectangle visible rect = text area . get visible rect ( ) ; paint line highlight ( g ) ; paint current line highlight ( g , visible rect ) ; paint margin line ( g , visible rect ) ; }
protect void paint editor augmentation ( graphic g ) { rectangle visible rect = text area . get visible rect ( ) ; paint line highlight ( g ) ; paint current line highlight ( g , visible rect ) ; paint margin line ( g , visible rect ) ; }
public void set match case ( boolean match case ) { if ( match case ! =this . match case ) { this . match case = match case ; fire property change ( property_match_case , ! match case , match case ) ; } }
public void set search for ( string search for ) { if ( ( search for==null & & this . search for ! =null ) || ( search for ! =null & & ! search for . equal ( this . search for ) ) ) { string old = this . search for ; this . search for = search for ; fire property change ( property_search_for , old , search for ) ; } }
public void set search forward ( boolean forward ) { if ( forward ! =this . forward ) { this . forward = forward ; fire property change ( property_search_forward , ! forward , forward ) ; } }
public void add ( int value ) { ensure capacity ( size + 1 ) ; data [ size++ ] = value ; }
public void remove range ( int from index , int to index ) { if ( from index > =size || to index > size ) { throw exception3 ( from index , to index ) ; } int move count = size - to index ; system . arraycopy ( data , to index , data , from index , move count ) ; size -= ( to index - from index ) ; }
public static disposable from action ( @ non null action run ) { object helper . require non null ( run , `` run be null `` ) ; return new action disposable ( run ) ; }
public flowable < t > auto connect ( int number of subscriber , @ non null consumer < ? super disposable > connection ) { if ( number of subscriber < = 0 ) { this . connect ( connection ) ; return rx java plugins . on assembly ( this ) ; } return rx java plugins . on assembly ( new flowable auto connect < t > ( this , number of subscriber , connection ) ) ; }
public disposable replace resource ( int index , disposable resource ) { for ( ; ; ) { disposable o = get ( index ) ; if ( o == disposable helper . dispose ) { resource . dispose ( ) ; return null ; } if ( compare and set ( index , o , resource ) ) { return o ; } } }
public final t block get ( ) { if ( get count ( ) ! = 0 ) { try { block helper . verify non blocking ( ) ; await ( ) ; } catch ( interrupted exception ex ) { dispose ( ) ; throw exception helper . wrap or throw ( ex ) ; } } throwable e = error ; if ( e ! = null ) { throw exception helper . wrap or throw ( e ) ; } return value ; }
public final void dispose ( ) { if ( subscription helper . cancel ( s ) ) { resource . dispose ( ) ; } }
public static void complete ( subscriber < ? > s ) { s . on subscribe ( instance ) ; s . on complete ( ) ; }
public void set first ( t value ) { head [ 0 ] = value ; }
public void for each while ( non throw predicate < ? super t > consumer ) { object [ ] a = head ; final int c = capacity ; while ( a ! = null ) { for ( int i = 0 ; i < c ; i++ ) { object o = a [ i ] ; if ( o == null ) { break ; } if ( consumer . test ( ( t ) o ) ) { break ; } } a = ( object [ ] ) a [ c ] ; } }
public static long add ( long a , long b ) { long u = a + b ; if ( u < 0l ) { return long . max_value ; } return u ; }
public static boolean validate ( disposable upstream , disposable next , class < ? > observer ) { object helper . require non null ( next , `` next be null `` ) ; if ( upstream ! = null ) { next . dispose ( ) ; if ( upstream ! = disposable helper . dispose ) { report double subscription ( observer ) ; } return false ; } return true ; }
public static object subscription ( subscription s ) { return new subscription notification ( s ) ; }
public final int value count ( ) { return value . size ( ) ; }
public final u assert value at ( int index , predicate < t > value predicate ) { int s = value . size ( ) ; if ( s == 0 ) { throw fail ( `` no value `` ) ; } if ( index > = value . size ( ) ) { throw fail ( `` invalid index : `` + index ) ; } boolean found = false ; try { if ( value predicate . test ( value . get ( index ) ) ) { found = true ; } } catch ( exception ex ) { throw exception helper . wrap or throw ( ex ) ; } if ( ! find ) { throw fail ( `` value not present `` ) ; } return ( u ) this ; }
public final u assert value at ( int index , predicate < t > value predicate ) { int s = value . size ( ) ; if ( s == 0 ) { throw fail ( `` no value `` ) ; } if ( index > = value . size ( ) ) { throw fail ( `` invalid index : `` + index ) ; } boolean found = false ; try { if ( value predicate . test ( value . get ( index ) ) ) { found = true ; } } catch ( exception ex ) { throw exception helper . wrap or throw ( ex ) ; } if ( ! find ) { throw fail ( `` value not present `` ) ; } return ( u ) this ; }
public final u assert no error ( ) { int s = error . size ( ) ; if ( s ! = 0 ) { throw fail ( `` error ( s ) present : `` + error ) ; } return ( u ) this ; }
public final u assert no error ( ) { int s = error . size ( ) ; if ( s ! = 0 ) { throw fail ( `` error ( s ) present : `` + error ) ; } return ( u ) this ; }
public final u assert complete ( ) { long c = completion ; if ( c == 0 ) { throw fail ( `` not complete `` ) ; } else if ( c > 1 ) { throw fail ( `` multiple completion : `` + c ) ; } return ( u ) this ; }
public final u assert value at ( int index , predicate < t > value predicate ) { int s = value . size ( ) ; if ( s == 0 ) { throw fail ( `` no value `` ) ; } if ( index > = value . size ( ) ) { throw fail ( `` invalid index : `` + index ) ; } boolean found = false ; try { if ( value predicate . test ( value . get ( index ) ) ) { found = true ; } } catch ( exception ex ) { throw exception helper . wrap or throw ( ex ) ; } if ( ! find ) { throw fail ( `` value not present `` ) ; } return ( u ) this ; }
public final u assert not complete ( ) { long c = completion ; if ( c == 1 ) { throw fail ( `` complete ! `` ) ; } else if ( c > 1 ) { throw fail ( `` multiple completion : `` + c ) ; } return ( u ) this ; }
public final u assert value only ( t . . . value ) { return assert subscribe ( ) . assert value ( value ) . assert no error ( ) . assert not complete ( ) ; }
public final u clear timeout ( ) { timeout = false ; return ( u ) this ; }
public final u assert terminate ( ) { if ( do . get count ( ) ! = 0 ) { throw fail ( `` subscriber still run ! `` ) ; } long c = completion ; if ( c > 1 ) { throw fail ( `` terminate with multiple completion : `` + c ) ; } int s = error . size ( ) ; if ( s > 1 ) { throw fail ( `` terminate with multiple error : `` + s ) ; } if ( c ! = 0 & & s ! = 0 ) { throw fail ( `` terminate with multiple completion and error : `` + c ) ; } return ( u ) this ; }
public static void set on before block ( @ nullable boolean supplier handler ) { if ( lockdown ) { throw new illegal state exception ( `` plugins ca n't be change anymore `` ) ; } on before block = handler ; }
public final expression optimize ( expression visitor visitor , item type context item type ) { return this ; }
public final expression optimize ( expression visitor visitor , item type context item type ) { return this ; }
public void advance time by ( long delay time , time unit unit ) { advance time to ( time + unit . to nanos ( delay time ) , time unit . nanosecond ) ; }
public void advance time by ( long delay time , time unit unit ) { advance time to ( time + unit . to nanos ( delay time ) , time unit . nanosecond ) ; }
public static < t > void subscribe ( publisher < ? extend t > o , final consumer < ? super t > on next , final consumer < ? super throwable > on error , final action on complete ) { object helper . require non null ( on next , `` on next be null `` ) ; object helper . require non null ( on error , `` on error be null `` ) ; object helper . require non null ( on complete , `` on complete be null `` ) ; subscribe ( o , new lambda subscriber < t > ( on next , on error , on complete , function . request_max ) ) ; }
public boolean have complete ( ) { return observer . get ( ) == terminate & & error == null ; }
public throwable get throwable ( ) { if ( observer . get ( ) == terminate ) { return error ; } return null ; }
protect final void request ( long n ) { subscription helper . defer request ( s , miss request , n ) ; }
public static void not null ( object object , string message ) { if ( object == null ) { throw new illegal argument exception ( message ) ; } }
public final u assert value at ( int index , predicate < t > value predicate ) { int s = value . size ( ) ; if ( s == 0 ) { throw fail ( `` no value `` ) ; } if ( index > = value . size ( ) ) { throw fail ( `` invalid index : `` + index ) ; } boolean found = false ; try { if ( value predicate . test ( value . get ( index ) ) ) { found = true ; } } catch ( exception ex ) { throw exception helper . wrap or throw ( ex ) ; } if ( ! find ) { throw fail ( `` value not present `` ) ; } return ( u ) this ; }
public static < t > void subscribe ( publisher < ? extend t > o , final consumer < ? super t > on next , final consumer < ? super throwable > on error , final action on complete ) { object helper . require non null ( on next , `` on next be null `` ) ; object helper . require non null ( on error , `` on error be null `` ) ; object helper . require non null ( on complete , `` on complete be null `` ) ; subscribe ( o , new lambda subscriber < t > ( on next , on error , on complete , function . request_max ) ) ; }
public void start unbounded ( ) { if ( subscription helper . set once ( upstream , empty subscription . instance ) ) { queue = new spsc link array queue < t > ( buffer size ) ; } }
public t get value ( ) { return buffer . get value ( ) ; }
public static < t > stream < t > stream ( iterable once < t > coll ) { return stream converter . a java seq stream ( coll ) ; }
public static @ not null breadcrumb ui ( final @ not null string category , final @ not null string message ) { final breadcrumb breadcrumb = new breadcrumb ( ) ; breadcrumb . set type ( `` default `` ) ; breadcrumb . set category ( `` ui . `` + category ) ; breadcrumb . set message ( message ) ; return breadcrumb ; }
public object get data ( final @ not null string key ) { return data . get ( key ) ; }
public @ nullable before breadcrumb callback get before breadcrumb ( ) { return before breadcrumb ; }
public @ nullable string get dsn ( ) { return dsn ; }
public @ not null mechanism get exception mechanism ( ) { return exception mechanism ; }
public @ nullable long get thread id ( ) { return thread id ; }
public < v > context with value ( key < v > k1 , v v1 ) { persistent hash array map trie < key < ? > , object > new key value entry = key value entry . put ( k1 , v1 ) ; return new context ( this , new key value entry ) ; }
public void set logger ( final @ nullable i logger logger ) { this . logger = ( logger == null ) ? no op logger . get instance ( ) : new diagnostic logger ( this , logger ) ; }
public static void set tag ( final @ not null string key , final @ not null string value ) { get current hub ( ) . set tag ( key , value ) ; }
public static @ not null i transaction start transaction ( final @ not null string name , final @ not null string operation , final boolean bind to scope ) { return get current hub ( ) . start transaction ( name , operation , bind to scope ) ; }
public @ nullable string get sentry client name ( ) { return sentry client name ; }
public @ not null list < string > get in app include ( ) { return in app include ; }
public void set envelope disk cache ( final @ nullable i envelope cache envelope disk cache ) { this . envelope disk cache = envelope disk cache ! = null ? envelope disk cache : no op envelope cache . get instance ( ) ; }
public void set proguard uuid ( final @ nullable string proguard uuid ) { this . proguard uuid = proguard uuid ; }
public boolean update ( final @ nullable state status , final @ nullable string user agent , boolean add error count ) { synchronize ( session lock ) { boolean session have be update = false ; if ( status ! = null ) { this . status = status ; session have be update = true ; } if ( user agent ! = null ) { this . user agent = user agent ; session have be update = true ; } if ( add error count ) { error count . add and get ( 1 ) ; session have be update = true ; } if ( session have be update ) { init = null ; timestamp = date utils . get current date time ( ) ; if ( timestamp ! = null ) { sequence = get sequence timestamp ( timestamp ) ; } } return session have be update ; } }
public @ nullable string get email ( ) { return email ; }
public @ nullable string get email ( ) { return email ; }
public @ nullable string get email ( ) { return email ; }
public void set comment ( @ nullable string comment ) { this . comment = comment ; }
public int get minimum object size ( ) { return get object alignment ( ) ; }
public map get copy of context map ( ) { hash map hash map = ( hash map ) inheritable thread local . get ( ) ; if ( hash map ! = null ) { return new hash map ( hash map ) ; } else { return null ; } }
protect double get domain low bound ( double p ) { return 0 ; }
public static marker get marker ( string name ) { return marker factory . get marker ( name ) ; }
public static string get ( string key ) throw illegal argument exception { if ( key == null ) { throw new illegal argument exception ( `` key parameter can not be null `` ) ; } if ( mdc adapter == null ) { throw new illegal state exception ( `` m d c adapter can not be null . see also `` + null_mdca_url ) ; } return mdc adapter . get ( key ) ; }
public static void clear ( ) { if ( mdc adapter == null ) { throw new illegal state exception ( `` m d c adapter can not be null . see also `` + null_mdca_url ) ; } mdc adapter . clear ( ) ; }
public void info ( string format , object arg1 , object arg2 ) { format and log ( log_level_info , format , arg1 , arg2 ) ; }
public void warn ( string msg ) { log ( log_level_warn , msg , null ) ; }
public void error ( string format , object arg ) { format and log ( log_level_error , format , arg , null ) ; }
public io . vertx . axle . core . buffer . buffer copy ( ) { io . vertx . axle . core . buffer . buffer ret = io . vertx . axle . core . buffer . buffer . new instance ( delegate . copy ( ) ) ; return ret ; }
public io . vertx . axle . core . buffer . buffer append string ( string str ) { delegate . append string ( str ) ; return this ; }
public io . vertx . axle . core . buffer . buffer set byte ( int po , byte b ) { delegate . set byte ( po , b ) ; return this ; }
public long get unsigned int l e ( int po ) { long ret = delegate . get unsigned int l e ( po ) ; return ret ; }
public io . vertx . axle . core . buffer . buffer set unsigned int l e ( int po , long i ) { delegate . set unsigned int l e ( po , i ) ; return this ; }
public io . vertx . axle . core . buffer . buffer append float ( float f ) { delegate . append float ( f ) ; return this ; }
public byte [ ] get byte ( ) { byte [ ] ret = delegate . get byte ( ) ; return ret ; }
public io . vertx . axle . core . cli . cli set option ( list < option > option ) { delegate . set option ( option ) ; return this ; }
public string get raw value for option ( option option ) { string ret = delegate . get raw value for option ( option ) ; return ret ; }
public boolean be see in command line ( option option ) { boolean ret = delegate . be see in command line ( option ) ; return ret ; }
public list < string > process args ( ) { list < string > ret = delegate . process args ( ) ; return ret ; }
public boolean be multi threaded worker context ( ) { boolean ret = delegate . be multi threaded worker context ( ) ; return ret ; }
public void put ( string key , object value ) { delegate . put ( key , value ) ; }
public io . vertx . axle . core . stream . pipe < io . vertx . axle . core . datagram . datagram packet > pipe ( ) { io . vertx . axle . core . stream . pipe < io . vertx . axle . core . datagram . datagram packet > ret = io . vertx . axle . core . stream . pipe . new instance ( delegate . pipe ( ) , type_arg_0 ) ; return ret ; }
public string target ( ) { string ret = delegate . target ( ) ; return ret ; }
public string name ( ) { string ret = delegate . name ( ) ; return ret ; }
public < t > io . vertx . axle . core . eventbus . message producer < t > publisher ( string address ) { io . vertx . axle . core . eventbus . message producer < t > ret = io . vertx . axle . core . eventbus . message producer . new instance ( delegate . publisher ( address ) , io . vertx . lang . axle . type arg . unknown ( ) ) ; return ret ; }
public completion stage < void > unregister ( ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __unregister ( handler ) ; } ) ; }
public long last modified time ( ) { long ret = delegate . last modified time ( ) ; return ret ; }
public boolean be regular file ( ) { boolean ret = delegate . be regular file ( ) ; return ret ; }
public long last modified time ( ) { long ret = delegate . last modified time ( ) ; return ret ; }
public completion stage < void > chown ( string path , string user , string group ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __chown ( path , user , group , handler ) ; } ) ; }
public completion stage < void > copy ( string from , string to ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __copy ( from , to , handler ) ; } ) ; }
public completion stage < io . vertx . axle . core . file . file prop > lprops ( string path ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __lprops ( path , handler ) ; } ) ; }
public completion stage < io . vertx . axle . core . buffer . buffer > read file ( string path ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __read file ( path , handler ) ; } ) ; }
public static < t > io . vertx . axle . core . future < t > future ( ) { io . vertx . axle . core . future < t > ret = io . vertx . axle . core . future . new instance ( io . vertx . core . future . future ( ) , io . vertx . lang . axle . type arg . unknown ( ) ) ; return ret ; }
public < u > io . vertx . axle . core . future < u > compose ( function < io . vertx . axle . core . composite future , io . vertx . axle . core . future < u > > mapper ) { io . vertx . axle . core . future < u > ret = io . vertx . axle . core . future . new instance ( delegate . compose ( new java . util . function . function < io . vertx . core . composite future , io . vertx . core . future < u > > ( ) { public io . vertx . core . future < u > apply ( io . vertx . core . composite future arg ) { io . vertx . axle . core . future < u > ret = mapper . apply ( io . vertx . axle . core . composite future . new instance ( arg ) ) ; return ret . get delegate ( ) ; } } ) , io . vertx . lang . axle . type arg . unknown ( ) ) ; return ret ; }
public io . vertx . axle . core . http . cookie set value ( string value ) { delegate . set value ( value ) ; return this ; }
public io . vertx . axle . core . http . cookie set value ( string value ) { delegate . set value ( value ) ; return this ; }
public io . vertx . axle . core . http . http client request request ab ( http method method , string absolute u r i ) { io . vertx . axle . core . http . http client request ret = io . vertx . axle . core . http . http client request . new instance ( delegate . request ab ( method , absolute u r i ) ) ; return ret ; }
public io . vertx . axle . core . http . http client request delete ( request option option ) { io . vertx . axle . core . http . http client request ret = io . vertx . axle . core . http . http client request . new instance ( delegate . delete ( option ) ) ; return ret ; }
public io . vertx . axle . core . http . http client request put ab ( string absolute u r i ) { io . vertx . axle . core . http . http client request ret = io . vertx . axle . core . http . http client request . new instance ( delegate . put ab ( absolute u r i ) ) ; return ret ; }
public io . vertx . axle . core . http . http client request head ab ( string absolute u r i ) { io . vertx . axle . core . http . http client request ret = io . vertx . axle . core . http . http client request . new instance ( delegate . head ab ( absolute u r i ) ) ; return ret ; }
public completion stage < io . vertx . axle . core . http . web socket > web socket ( string host , string request u r i ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __web socket ( host , request u r i , handler ) ; } ) ; }
public io . vertx . axle . core . stream . read stream < io . vertx . axle . core . http . web socket > websocket stream ab ( string url , io . vertx . axle . core . multi map header , websocket version version , string sub protocol ) { io . vertx . axle . core . stream . read stream < io . vertx . axle . core . http . web socket > ret = io . vertx . axle . core . stream . read stream . new instance ( delegate . websocket stream ab ( url , header . get delegate ( ) , version , sub protocol ) , type_arg_9 ) ; return ret ; }
public io . vertx . axle . core . stream . read stream < io . vertx . axle . core . http . web socket > websocket stream ( int port , string host , string request u r i , io . vertx . axle . core . multi map header ) { io . vertx . axle . core . stream . read stream < io . vertx . axle . core . http . web socket > ret = io . vertx . axle . core . stream . read stream . new instance ( delegate . websocket stream ( port , host , request u r i , header . get delegate ( ) ) , type_arg_4 ) ; return ret ; }
public io . vertx . reactivex . core . http . http connection go away handler ( handler < io . vertx . core . http . go away > handler ) { delegate . go away handler ( handler ) ; return this ; }
public io . vertx . axle . core . http . http server response set chunk ( boolean chunk ) { delegate . set chunk ( chunk ) ; return this ; }
public string text handler i d ( ) { string ret = delegate . text handler i d ( ) ; return ret ; }
public boolean be root pointer ( ) { boolean ret = delegate . be root pointer ( ) ; return ret ; }
public io . vertx . axle . core . json . pointer . json pointer parent ( ) { delegate . parent ( ) ; return this ; }
public io . vertx . axle . core . json . pointer . json pointer parent ( ) { delegate . parent ( ) ; return this ; }
public boolean contains ( string name , string value , boolean case insensitive ) { boolean ret = delegate . contains ( name , value , case insensitive ) ; return ret ; }
public string text handler i d ( ) { string ret = delegate . text handler i d ( ) ; return ret ; }
public string certificate path ( ) { string ret = delegate . certificate path ( ) ; return ret ; }
public io . vertx . axle . core . parsetools . json parser array event mode ( ) { delegate . array event mode ( ) ; return this ; }
public completion stage < v > remove ( k k ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __remove ( k , handler ) ; } ) ; }
public completion stage < v > remove ( k k ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __remove ( k , handler ) ; } ) ; }
public completion stage < long > get and increment ( ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __get and increment ( handler ) ; } ) ; }
public completion stage < long > get and add ( long value ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __get and add ( value , handler ) ; } ) ; }
public completion stage < long > get and add ( long value ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __get and add ( value , handler ) ; } ) ; }
public io . vertx . axle . core . stream . pump set write queue max size ( int max size ) { delegate . set write queue max size ( max size ) ; return this ; }
public io . vertx . axle . core . stream . pump set write queue max size ( int max size ) { delegate . set write queue max size ( max size ) ; return this ; }
public io . vertx . axle . core . dns . dns client create dns client ( dns client option option ) { io . vertx . axle . core . dns . dns client ret = io . vertx . axle . core . dns . dns client . new instance ( delegate . create dns client ( option ) ) ; return ret ; }
public io . vertx . axle . core . stream . read stream < io . vertx . axle . core . http . web socket > websocket stream ( request option option ) { io . vertx . axle . core . stream . read stream < io . vertx . axle . core . http . web socket > ret = io . vertx . axle . core . stream . read stream . new instance ( delegate . websocket stream ( option ) , type_arg_0 ) ; return ret ; }
public io . vertx . axle . core . stream . read stream < io . vertx . axle . core . http . http server request > request stream ( ) { if ( cached_0 ! = null ) { return cached_0 ; } io . vertx . axle . core . stream . read stream < io . vertx . axle . core . http . http server request > ret = io . vertx . axle . core . stream . read stream . new instance ( delegate . request stream ( ) , type_arg_0 ) ; cached_0 = ret ; return ret ; }
public io . vertx . axle . core . timeout stream periodic stream ( long delay ) { io . vertx . axle . core . timeout stream ret = io . vertx . axle . core . timeout stream . new instance ( delegate . periodic stream ( delay ) ) ; return ret ; }
public void unregister verticle factory ( verticle factory factory ) { delegate . unregister verticle factory ( factory ) ; }
public long get count ( object v ) { return get count ( ( comparable < ? > ) v ) ; }
public void add config source ( config source config source ) { config source . update and get ( config source - > { list < config source > current source = config source . get source ( ) ; int old size = current source . size ( ) ; list < config source > new source = arrays . a list ( current source . to array ( new config source [ old size + 1 ] ) ) ; new source . set ( old size , config source ) ; return new config source ( new source , config source ) ; } ) ; }
public uni < io . vertx . mutiny . core . http . web socket > web socket ( string host , string request u r i ) { return io . smallrye . mutiny . vertx . async result uni . to uni ( handler - > { __web socket ( host , request u r i , handler ) ; } ) ; }
public void set indicator indent ( int indicator indent ) { if ( indicator indent < 0 ) { throw new y a m l exception ( `` indicator indent must be non-negative . `` ) ; } if ( indicator indent > emitter . max_indent - 1 ) { throw new y a m l exception ( `` indicator indent must be at most emitter . max_indent-1 : `` + ( emitter . max_indent - 1 ) ) ; } this . indicator indent = indicator indent ; }
public void set time zone ( time zone time zone ) { this . time zone = time zone ; }
public string get tag ( ) { return this . tag ; }
public void set allow recursive key ( boolean allow recursive key ) { this . allow recursive key = allow recursive key ; }
public tag add class tag ( class < ? extend object > clazz , string tag ) { return add class tag ( clazz , new tag ( tag ) ) ; }
public boolean be two step construction ( ) { return two step construction ; }
public boolean check event ( event . id choice ) { peek event ( ) ; return current event ! = null & & current event . be ( choice ) ; }
public string prefix ( int length ) { if ( this . pointer + length > = this . buffer . length ( ) ) { update ( ) ; } if ( this . pointer + length > this . buffer . length ( ) ) { return this . buffer . substring ( this . pointer ) ; } return this . buffer . substring ( this . pointer , this . pointer + length ) ; }
public string prefix ( int length ) { if ( this . pointer + length > = this . buffer . length ( ) ) { update ( ) ; } if ( this . pointer + length > this . buffer . length ( ) ) { return this . buffer . substring ( this . pointer ) ; } return this . buffer . substring ( this . pointer , this . pointer + length ) ; }
public token get token ( ) { if ( ! this . token . be empty ( ) ) { this . tokens taken++ ; return this . token . remove ( 0 ) ; } return null ; }
public tag get tag ( ) { return tag ; }
public class < ? extend object > get map key type ( string property ) { if ( property . contains key ( property ) ) { class < ? > [ ] type argument = property . get ( property ) . get actual type argument ( ) ; if ( type argument ! = null & & type argument . length > 0 ) { return type argument [ 0 ] ; } } return null ; }
public iterable < object > load all ( string yaml ) { return load all ( new string reader ( yaml ) ) ; }
public locale get default locale ( ) { return get locale convert utils ( ) . get default locale ( ) ; }
public void set process comment ( boolean process comment ) { this . process comment = process comment ; }
public list < event > serialize ( node data ) { silent emitter emitter = new silent emitter ( ) ; serializer serializer = new serializer ( emitter , resolver , dumper option , null ) ; try { serializer . open ( ) ; serializer . serialize ( data ) ; serializer . close ( ) ; } catch ( i o exception e ) { throw new y a m l exception ( e ) ; } return emitter . get event ( ) ; }
public static double [ ] unshuffle double array ( byte [ ] input ) throw i o exception { double [ ] output = new double [ input . length / 8 ] ; int num process = impl . unshuffle ( input , 0 , 8 , input . length , output , 0 ) ; assert ( num process == input . length ) ; return output ; }
public static short [ ] unshuffle short array ( byte [ ] input ) throw i o exception { short [ ] output = new short [ input . length / 2 ] ; int num process = impl . unshuffle ( input , 0 , 2 , input . length , output , 0 ) ; assert ( num process == input . length ) ; return output ; }
public static < t > object pool < t > check pool ( final object pool < t > pool , final class < t > type ) { if ( pool == null ) { throw new illegal argument exception ( `` pool must not be null . `` ) ; } if ( type == null ) { throw new illegal argument exception ( `` type must not be null . `` ) ; } return new check object pool < t > ( pool , type ) ; }
public t set environment variable ( string name , string value ) { this . env . put ( name , value ) ; return ( t ) this ; }
public server install ( ) { if ( server == null ) { database = new default database ( config ) ; database . start ( ) ; package resolver packaging resolver = new packaging resolver ( config . locator ( ) ) ; server installer server installer = new server installer ( package resolver , config , config . locator ( ) , database . get client ( ) ) ; server = server installer . install ( distribution ) ; } return server ; }
public void activate license ( ) { string license = license . get license ( server . get edition ( ) , server . version ( ) ) ; configure license ( license ) ; }
public orchestrator builder set zip file ( file zip ) { check argument ( zip . exists ( ) , `` sonar qube zip file do not exist : % s `` , zip . get absolute path ( ) ) ; check argument ( zip . be file ( ) , `` sonar qube zip be not a file : % s `` , zip . get absolute path ( ) ) ; return set zip location ( file location . of ( zip ) ) ; }
public filter folder remove all that match ( string regex ) { for ( spoon resource f : new array list < > ( file ) ) { if ( f . get path ( ) . match ( regex ) ) { file . remove ( f ) ; } } return this ; }
public void check modifier ( ) { for ( ct modifiable modifiable : _root package . get element ( new type filter < > ( ct modifiable . class ) ) ) { for ( ct extend modifier modifier : modifiable . get extended modifier ( ) ) { if ( modifier . be implicit ( ) ) { continue ; } source position position = modifier . get position ( ) ; compilation unit compilation unit = position . get compilation unit ( ) ; string original source code = compilation unit . get original source code ( ) ; assert equal ( modifier . get kind ( ) . to string ( ) , original source code . substring ( position . get source start ( ) , position . get source end ( ) + 1 ) ) ; } } }
public static < t > ct method < t > insert method ( ct type < ? > target type , template < ? > template , ct method < t > source method ) { ct method < t > new method = substitute ( target type , template , source method ) ; if ( target type instanceof ct interface ) { new method . set body ( null ) ; } target type . add method ( new method ) ; return new method ; }
public ct type reference < ? > get type of field ( ) { if ( value type == null ) { throw new spoon exception ( `` model be not initialize yet `` ) ; } return value type ; }
public void apply generate by ( ct element generate element , string gen by ) { if ( be add generate by ( ) & & generate element instanceof ct type member ) { if ( gen by ! = null ) { add generate by comment ( generated element , gen by ) ; } } }
public list < string > get matching pattern ( string lookup path ) { list < string > match = null ; for ( string pattern : this . pattern ) { string match = get matching pattern ( pattern , lookup path ) ; if ( match ! = null ) { match = ( match ! = null ? match : new array list < > ( ) ) ; match . add ( match ) ; } } if ( match == null ) { return collection . empty list ( ) ; } if ( match . size ( ) > 1 ) { match . sort ( this . path matcher . get pattern comparator ( lookup path ) ) ; } return match ; }
public inlined statement configurator inline if or foreach refer to ( string variable name ) { pattern builder . pattern query . filter child ( ( ct variable reference var ref ) - > variable name . equal ( var ref . get simple name ( ) ) ) . for each ( this : : by element ) ; return this ; }
public pattern parameter configurator by reference name ( string simple name ) { parameter info pi = get current parameter ( ) ; query model ( ) . filter child ( ( ct reference ref ) - > simple name . equal ( ref . get simple name ( ) ) ) . for each ( ( ct reference ref ) - > { add substitution request ( pi , ref ) ; } ) ; return this ; }
protect final void add consume annotation type ( class < ? extend a > annotation type ) { add process annotation type ( annotation type ) ; consume annotation type . put ( annotation type . get name ( ) , annotation type ) ; }
protect void set closure delegate ( closure closure , object node ) { closure . set delegate ( this ) ; }
protect void create expression can not be remove issue ( ct invocation < ? > invocation , ct expression < ? > to be remove expression ) { throw new refactoring exception ( `` the expression `` + to be remove expression + `` , which create argument of the to be remove parameter in invocation `` + invocation + `` can not be remove . `` + `` override method ` can remove expression ` to customize this behavior . `` ) ; }
public collection < ct executable < ? > > get caller method ( ) { return caller method ; }
public < t > ct interface < t > create ( string qualify name ) { if ( have inner type ( qualified name ) > 0 ) { return create ( create ( get declare type name ( qualified name ) ) , get simple name ( qualified name ) ) ; } return create ( factory . package ( ) . get or create ( get package name ( qualified name ) ) , get simple name ( qualified name ) ) ; }
public < t > ct type reference < t > create reference ( ct type < t > type ) { return create reference ( type , false ) ; }
public compilation unit get or create ( ct type type ) { if ( type == null ) { return null ; } if ( ! ( type . get position ( ) . get compilation unit ( ) instanceof no source position . null compilation unit ) ) { return type . get position ( ) . get compilation unit ( ) ; } compilation unit compilation unit = add type ( type ) ; type . set position ( this . factory . create partial source position ( compilation unit ) ) ; return compilation unit ; }
public compilation unit get or create ( ct type type ) { if ( type == null ) { return null ; } if ( ! ( type . get position ( ) . get compilation unit ( ) instanceof no source position . null compilation unit ) ) { return type . get position ( ) . get compilation unit ( ) ; } compilation unit compilation unit = add type ( type ) ; type . set position ( this . factory . create partial source position ( compilation unit ) ) ; return compilation unit ; }
public < t > ct constructor < t > create default ( ct class < t > target ) { ct constructor < t > constructor = factory . core ( ) . create constructor ( ) ; constructor . add modifier ( modifier kind . public ) ; target . add constructor ( constructor ) ; return constructor ; }
public ct anonymous executable create anonymous ( ct class < ? > target , ct block < void > body ) { ct anonymous executable a = factory . core ( ) . create anonymous executable ( ) ; target . add anonymous executable ( a ) ; a . set body ( body ) ; return a ; }
public < t > ct interface < t > create ( string qualify name ) { if ( have inner type ( qualified name ) > 0 ) { return create ( create ( get declare type name ( qualified name ) ) , get simple name ( qualified name ) ) ; } return create ( factory . package ( ) . get or create ( get package name ( qualified name ) ) , get simple name ( qualified name ) ) ; }
public ct package reference create ct package reference ( package original package ) { return factory . core ( ) . create package reference ( ) . set simple name ( original package . get name ( ) ) ; }
public ct type reference < integer > integer primitive type ( ) { return integer_primitive . clone ( ) ; }
public ct type reference < integer > integer primitive type ( ) { return integer_primitive . clone ( ) ; }
public ct type reference < integer > integer primitive type ( ) { return integer_primitive . clone ( ) ; }
public < t > ct array type reference < t [ ] > create array reference ( ct type < t > type ) { ct array type reference < t [ ] > array = factory . core ( ) . create array type reference ( ) ; array . set component type ( create reference ( type ) ) ; return array ; }
public ct query create query ( object input ) { return new ct query impl ( input ) ; }
public ct query create query ( object input ) { return new ct query impl ( input ) ; }
protect void enter ( ct element e ) { element deque . push ( e ) ; super . enter ( e ) ; }
protect void set closure delegate ( closure closure , object node ) { closure . set delegate ( this ) ; }
protect void set closure delegate ( closure closure , object node ) { closure . set delegate ( this ) ; }
public all type member function distinct set ( set < string > distinct set ) { this . distinct set = distinct set ; return this ; }
public < t extend ct element > list < t > find ( final ct element target root ) { return target root . filter child ( this ) . list ( ) ; }
public static void change method name ( final ct method < ? > method , string new name ) { final list < ct executable reference < ? > > reference = query . get element ( method . get factory ( ) , new type filter < ct executable reference < ? > > ( ct executable reference . class ) { @ override public boolean match ( ct executable reference < ? > reference ) { return reference . get declaration ( ) == method ; } } ) ; method . set simple name ( new name ) ; for ( ct executable reference < ? > reference : reference ) { reference . set simple name ( new name ) ; } }
public model get model ( ) { return model ; }
public t get old value ( ) { return old value ; }
public < t extend ct statement > ct block < ? > create ct block ( t element ) { return factory . core ( ) . create block ( ) . add statement ( element ) ; }
public static final void replace ( char [ ] array , char [ ] to be replace , char replacement char ) { replace ( array , to be replace , replacement char , 0 , array . length ) ; }
protect void create expression can not be remove issue ( ct invocation < ? > invocation , ct expression < ? > to be remove expression ) { throw new refactoring exception ( `` the expression `` + to be remove expression + `` , which create argument of the to be remove parameter in invocation `` + invocation + `` can not be remove . `` + `` override method ` can remove expression ` to customize this behavior . `` ) ; }
public ct package reference create ct package reference ( package original package ) { return factory . core ( ) . create package reference ( ) . set simple name ( original package . get name ( ) ) ; }
public static < t > method [ ] get all method except ( class < t > type , string . . . method name ) { list < method > method to mock = new link list < method > ( ) ; method [ ] method = get all method ( type ) ; iterate method : for ( method method : method ) { for ( string method name : method name ) { if ( method . get name ( ) . equal ( method name ) ) { continue iterate method ; } } method to mock . add ( method ) ; } return method to mock . to array ( new method [ 0 ] ) ; }
public annotation [ ] get declare annotation ( ) { if ( method == null ) { / * * accord to oracle source ( for jdk 8 ) for java . lang . reflect . executable # get parameter annotation ( ) , * the length of the returned array may vary at the discretion of the compiler . * it seem that eclipse and javac do not produce the same result . * in our case the value of index be base on get generic parameter type ( ) , so if * get parameter annotation ( ) return a small array , we can assume that * a synthetic parameter point to the outer class have be add at the begining of * get generic parameter type ( ) and not in get parameter annotation ( ) . * the actual index be then shift by the difference . * / int diff = constructor . get generic parameter type ( ) . length - constructor . get parameter annotation ( ) . length ; return constructor . get parameter annotation ( ) [ index - diff ] ; } return method . get parameter annotation ( ) [ index ] ; }
public int hash code ( ) { if ( method == null ) { return constructor . hash code ( ) ^ index ; } return method . hash code ( ) ^ index ; }
public final pointcut build safe pointcut ( ) { pointcut pc = get pointcut ( ) ; method matcher safe method matcher = method matcher . intersection ( new advice exclude method matcher ( this . aspect j advice method ) , pc . get method matcher ( ) ) ; return new composable pointcut ( pc . get class filter ( ) , safe method matcher ) ; }
public synchronize advice get advice ( ) { if ( this . instantiated advice == null ) { this . instantiated advice = instantiate advice ( this . declared pointcut ) ; } return this . instantiated advice ; }
public int get order ( ) { return get order for aspect class ( this . aspect class ) ; }
public void set target class ( class < ? > target class ) { this . target source = empty target source . for class ( target class ) ; }
protect void copy configuration from ( advised support other , target source target source , list < advisor > advisor ) { copy from ( other ) ; this . target source = target source ; this . advisor chain factory = other . advisor chain factory ; this . interface = new array list < class < ? > > ( other . interface ) ; for ( advisor advisor : advisor ) { if ( advisor instanceof introduction advisor ) { validate introduction advisor ( ( introduction advisor ) advisor ) ; } assert . not null ( advisor , `` advisor must not be null `` ) ; this . advisor . add ( advisor ) ; } update advisor array ( ) ; advice change ( ) ; }
public boolean equal ( object other ) { return ( this == other || ( other instanceof hot swappable target source & & this . target . equal ( ( ( hot swappable target source ) other ) . target ) ) ) ; }
public boolean implement interface ( final string interface name ) { return get interface ( ) . contains name ( interface name ) ; }
public void set advisor bean name prefix ( string advisor bean name prefix ) { this . advisor bean name prefix = advisor bean name prefix ; }
public static class < ? > [ ] proxied user interface ( object proxy ) { class < ? > [ ] proxy interface = proxy . get class ( ) . get interface ( ) ; int non user ifc count = 0 ; if ( proxy instanceof spring proxy ) { non user ifc count++ ; } if ( proxy instanceof advise ) { non user ifc count++ ; } class < ? > [ ] user interface = new class < ? > [ proxy interface . length - non user ifc count ] ; system . arraycopy ( proxy interface , 0 , user interface , 0 , user interface . length ) ; assert . not empty ( user interface , `` jdk proxy must implement one or more interface `` ) ; return user interface ; }
public void set expose proxy ( boolean expose proxy ) { this . expose proxy = expose proxy ; }
public void set frozen ( boolean frozen ) { this . frozen = frozen ; }
public void remove listener ( advised support listener listener ) { assert . not null ( listener , `` advise support listener must not be null `` ) ; this . listener . remove ( listener ) ; }
public class < ? > get object type ( ) { synchronize ( this ) { if ( this . singleton instance ! = null ) { return this . singleton instance . get class ( ) ; } } class < ? > [ ] ifc = get proxied interface ( ) ; if ( ifc . length == 1 ) { return ifc [ 0 ] ; } else if ( ifc . length > 1 ) { return create composite interface ( ifc ) ; } else if ( this . target name ! = null & & this . bean factory ! = null ) { return this . bean factory . get type ( this . target name ) ; } else { return get target class ( ) ; } }
public void set enter message ( string enter message ) throw illegal argument exception { assert . have text ( enter message , `` 'enter message ' must not be empty `` ) ; check for invalid placeholder ( enter message ) ; assert . do not contain ( enter message , placeholder_return_value , `` enter message can not contain placeholder [ `` + placeholder_return_value + `` ] `` ) ; assert . do not contain ( enter message , placeholder_exception , `` enter message can not contain placeholder [ `` + placeholder_exception + `` ] `` ) ; assert . do not contain ( enter message , placeholder_invocation_time , `` enter message can not contain placeholder [ `` + placeholder_invocation_time + `` ] `` ) ; this . enter message = enter message ; }
public void set enter message ( string enter message ) throw illegal argument exception { assert . have text ( enter message , `` 'enter message ' must not be empty `` ) ; check for invalid placeholder ( enter message ) ; assert . do not contain ( enter message , placeholder_return_value , `` enter message can not contain placeholder [ `` + placeholder_return_value + `` ] `` ) ; assert . do not contain ( enter message , placeholder_exception , `` enter message can not contain placeholder [ `` + placeholder_exception + `` ] `` ) ; assert . do not contain ( enter message , placeholder_invocation_time , `` enter message can not contain placeholder [ `` + placeholder_invocation_time + `` ] `` ) ; this . enter message = enter message ; }
public static advisor create advisor without introduction ( string bean name ) { return new default pointcut advisor ( new expose bean name interceptor ( bean name ) ) ; }
protect boolean match pattern ( string signature string ) { for ( int i = 0 ; i < this . pattern . length ; i++ ) { boolean match = match ( signature string , i ) ; if ( match ) { for ( int j = 0 ; j < this . exclude pattern . length ; j++ ) { boolean exclude = match exclusion ( signature string , j ) ; if ( exclude ) { return false ; } } return true ; } } return false ; }
public static boolean be to string method ( method method ) { return reflection utils . be to string method ( method ) ; }
protected class < ? > get target class ( object manage bean ) { return aop utils . get target class ( manage bean ) ; }
public static class filter intersection ( class filter [ ] class filter ) { assert . not empty ( class filter , `` class filter array must not be empty `` ) ; return new intersection class filter ( class filter ) ; }
public composable pointcut union ( class filter other ) { this . class filter = class filter . union ( this . class filter , other ) ; return this ; }
public void set map name ( string map name ) { set map name ( map name ) ; }
public void set map name ( string map name ) { set map name ( map name ) ; }
protect default listable bean factory get internal bean factory for bean ( string bean name ) { synchronize ( this . internal bean factory ) { default listable bean factory internal bean factory = this . internal bean factory . get ( bean name ) ; if ( internal bean factory == null ) { internal bean factory = build internal bean factory ( this . bean factory ) ; this . internal bean factory . put ( bean name , internal bean factory ) ; } return internal bean factory ; } }
public int get max idle ( ) { return this . max idle ; }
public void set max wait ( long max wait ) { this . max wait = max wait ; }
public boolean be block when exhaust ( ) { return this . block when exhaust ; }
public final aspect j expression pointcut get pointcut ( ) { calculate argument binding ( ) ; return this . pointcut ; }
@ nonnull public static string filename ( @ nonnull string filename ) { int i = filename . last index of ( file . separator ) ; return ( i > = 0 ? filename . substring ( i + 1 ) : filename ) ; }
public structure q name get object name ( ) { return attribute set name ; }
public void set resource adapter class ( class < ? extend resource adapter > resource adapter class ) { this . resource adapter = bean utils . instantiate class ( resource adapter class ) ; }
protect boolean be exclude from dependency check ( property descriptor pd ) { return ( autowire utils . be exclude from dependency check ( pd ) || this . ignored dependency type . contains ( pd . get property type ( ) ) || autowire utils . be setter define in interface ( pd , this . ignored dependency interface ) ) ; }
public void set require parameter name ( string require parameter name ) { this . require parameter name = require parameter name ; }
public void set value annotation type ( class < ? extend annotation > value annotation type ) { this . value annotation type = value annotation type ; }
protect object find value ( annotation [ ] annotation to search ) { for ( annotation annotation : annotation to search ) { if ( this . value annotation type . be instance ( annotation ) ) { return extract value ( annotation ) ; } } for ( annotation annotation : annotation to search ) { annotation meta ann = annotation . annotation type ( ) . get annotation ( this . value annotation type ) ; if ( meta ann ! = null ) { return extract value ( meta ann ) ; } } return null ; }
public void add relate cause ( throwable ex ) { if ( this . related cause == null ) { this . related cause = new array list < > ( ) ; } this . related cause . add ( ex ) ; }
public string get bean class name ( ) { return this . bean class name ; }
protect type converter get default type converter ( ) { if ( this . bean factory ! = null ) { return this . bean factory . get type converter ( ) ; } else { return super . get default type converter ( ) ; } }
public void after property set ( ) throw exception { if ( be singleton ( ) ) { this . initialized = true ; this . singleton instance = create instance ( ) ; this . early singleton instance = null ; } }
protect void set closure delegate ( closure closure , object node ) { closure . set delegate ( this ) ; }
public void add generic argument value ( object value ) { this . generic argument value . add ( new value holder ( value ) ) ; }
public int get argument count ( ) { return ( this . indexed argument value . size ( ) + this . generic argument value . size ( ) ) ; }
public annotation [ ] get annotation ( ) { if ( this . field ! = null ) { if ( this . field annotation == null ) { this . field annotation = this . field . get annotation ( ) ; } return this . field annotation ; } else { return this . method parameter . get parameter annotation ( ) ; } }
public class < ? > get collection type ( ) { return ( this . field ! = null ? generic collection type resolver . get collection field type ( this . field , this . nest level ) : generic collection type resolver . get collection parameter type ( this . method parameter ) ) ; }
protect double get domain low bound ( double p ) { return 0 ; }
public annotation [ ] get annotation ( ) { if ( this . field ! = null ) { if ( this . field annotation == null ) { this . field annotation = this . field . get annotation ( ) ; } return this . field annotation ; } else { return this . method parameter . get parameter annotation ( ) ; } }
public void set logger name ( string logger name ) { this . logger = log factory . get log ( logger name ) ; }
public void set static field ( string static field ) { this . static field = string utils . trim all whitespace ( static field ) ; }
public void set placeholder prefix ( string placeholder prefix ) { this . placeholder prefix = placeholder prefix ; }
public void after property set ( ) { this . system prefs = ( this . system tree path ! = null ) ? preference . system root ( ) . node ( this . system tree path ) : preference . system root ( ) ; this . user prefs = ( this . user tree path ! = null ) ? preference . user root ( ) . node ( this . user tree path ) : preference . user root ( ) ; }
public void set bean name ( string bean name ) { this . bean name = string utils . trim all whitespace ( bean factory utils . original bean name ( bean name ) ) ; }
protect double get domain low bound ( double p ) { return 0 ; }
public void set system property mode ( int system property mode ) { this . system property mode = system property mode ; }
public void set service mapping ( property service mapping ) { this . service mapping = service mapping ; }
public void set bean factory ( bean factory bean factory ) { if ( ! ( bean factory instanceof listable bean factory ) ) { throw new illegal state exception ( get class ( ) . get simple name ( ) + `` require a listable bean factory `` ) ; } this . bean factory = ( listable bean factory ) bean factory ; }
public class < ? > resolve target type ( class loader class loader ) throw class not find exception { if ( this . target type == null ) { return null ; } class < ? > resolve class = class utils . for name ( get target type name ( ) , class loader ) ; this . target type = resolved class ; return resolve class ; }
protect void process ( match callback callback ) { yaml yaml = create yaml ( ) ; for ( resource resource : this . resource ) { boolean find = process ( callback , yaml , resource ) ; if ( this . resolution method == resolution method . first_found & & find ) { return ; } } }
public void import bean ( string resource pattern ) throw i o exception { load bean definition ( resource pattern ) ; }
public void import bean ( string resource pattern ) throw i o exception { load bean definition ( resource pattern ) ; }
public void add nest component ( component definition component ) { assert . not null ( component , `` component definition must not be null `` ) ; this . nested component . add ( component ) ; }
public bean definition builder set dependency check ( int dependency check ) { this . bean definition . set dependency check ( dependency check ) ; return this ; }
public bean definition builder set abstract ( boolean flag ) { this . bean definition . set abstract ( flag ) ; return this ; }
public bean definition builder set abstract ( boolean flag ) { this . bean definition . set abstract ( flag ) ; return this ; }
public autowire candidate qualifier get qualifier ( string type name ) { return this . qualifier . get ( type name ) ; }
public void add bean post processor ( collection < ? extends bean post processor > bean post processor ) { this . bean post processor . remove all ( bean post processor ) ; this . bean post processor . add all ( bean post processor ) ; }
protect void after prototype creation ( string bean name ) { object cur val = this . prototypes currently in creation . get ( ) ; if ( cur val instanceof string ) { this . prototypes currently in creation . remove ( ) ; } else if ( cur val instanceof set ) { set < string > bean name set = ( set < string > ) cur val ; bean name set . remove ( bean name ) ; if ( bean name set . be empty ( ) ) { this . prototypes currently in creation . remove ( ) ; } } }
public property editor get default editor ( class < ? > require type ) { if ( ! this . default editor active ) { return null ; } if ( this . overridden default editor ! = null ) { property editor editor = this . overridden default editor . get ( require type ) ; if ( editor ! = null ) { return editor ; } } if ( this . default editor == null ) { create default editor ( ) ; } return this . default editor . get ( require type ) ; }
public bean definition builder set abstract ( boolean flag ) { this . bean definition . set abstract ( flag ) ; return this ; }
public bean definition builder set factory method on bean ( string factory method , string factory bean ) { this . bean definition . set factory method name ( factory method ) ; this . bean definition . set factory bean name ( factory bean ) ; return this ; }
protect boolean be primary ( string bean name , object bean instance ) { if ( contains bean definition ( bean name ) ) { return get merge local bean definition ( bean name ) . be primary ( ) ; } bean factory parent factory = get parent bean factory ( ) ; return ( parent factory instanceof default listable bean factory & & ( ( default listable bean factory ) parent factory ) . be primary ( bean name , bean instance ) ) ; }
protected class < ? > determine target type ( string bean name , root bean definition mbd , class < ? > . . . type to match ) { class < ? > target type = mbd . get target type ( ) ; if ( target type == null ) { target type = ( mbd . get factory method name ( ) ! = null ? get type for factory method ( bean name , mbd , type to match ) : resolve bean class ( mbd , bean name , type to match ) ) ; if ( object utils . be empty ( type to match ) || get temp class loader ( ) == null ) { mbd . set target type ( target type ) ; } } return target type ; }
public void set autowire candidate resolver ( final autowire candidate resolver autowire candidate resolver ) { assert . not null ( autowire candidate resolver , `` autowire candidate resolver must not be null `` ) ; if ( autowire candidate resolver instanceof bean factory aware ) { if ( system . get security manager ( ) ! = null ) { final bean factory target = this ; access controller . do privilege ( new privilege action < object > ( ) { @ override public object run ( ) { ( ( bean factory aware ) autowire candidate resolver ) . set bean factory ( target ) ; return null ; } } , get access control context ( ) ) ; } else { ( ( bean factory aware ) autowire candidate resolver ) . set bean factory ( this ) ; } } this . autowire candidate resolver = autowire candidate resolver ; }
protect boolean be primary ( string bean name , object bean instance ) { if ( contains bean definition ( bean name ) ) { return get merge local bean definition ( bean name ) . be primary ( ) ; } bean factory parent factory = get parent bean factory ( ) ; return ( parent factory instanceof default listable bean factory & & ( ( default listable bean factory ) parent factory ) . be primary ( bean name , bean instance ) ) ; }
protect void add singleton ( string bean name , object singleton object ) { synchronize ( this . singleton object ) { this . singleton object . put ( bean name , ( singleton object ! = null ? singleton object : null_object ) ) ; this . singleton factory . remove ( bean name ) ; this . early singleton object . remove ( bean name ) ; this . registered singleton . add ( bean name ) ; } }
protect boolean be dependent ( string bean name , string dependent bean name ) { return be dependent ( bean name , dependent bean name , null ) ; }
public string [ ] get dependency for bean ( string bean name ) { set < string > dependency for bean = this . dependency for bean map . get ( bean name ) ; if ( dependency for bean == null ) { return new string [ 0 ] ; } return dependency for bean . to array ( new string [ dependency for bean . size ( ) ] ) ; }
protect void add singleton ( string bean name , object singleton object ) { synchronize ( this . singleton object ) { this . singleton object . put ( bean name , ( singleton object ! = null ? singleton object : null_object ) ) ; this . singleton factory . remove ( bean name ) ; this . early singleton object . remove ( bean name ) ; this . registered singleton . add ( bean name ) ; } }
public void set bean factory ( bean factory bean factory ) { if ( ! ( bean factory instanceof listable bean factory ) ) { throw new illegal state exception ( get class ( ) . get simple name ( ) + `` require a listable bean factory `` ) ; } this . bean factory = ( listable bean factory ) bean factory ; }
public static void unset security token ( object name , object token ) { if ( check security token ( name , token ) ) { security token . remove ( name ) ; } }
public void set element type name ( string element type name ) { this . element type name = element type name ; }
protect void set overload ( boolean overload ) { this . overload = overload ; }
public set < method override > get override ( ) { return this . override ; }
protect bean factory create definition ( string resource location , string factory key ) { default listable bean factory factory = new default listable bean factory ( ) ; xml bean definition reader reader = new xml bean definition reader ( factory ) ; resource pattern resolver resource pattern resolver = new path match resource pattern resolver ( ) ; try { resource [ ] config resource = resource pattern resolver . get resource ( resource location ) ; if ( config resource . length == 0 ) { throw new fatal bean exception ( `` unable to find resource for specified definition . `` + `` group resource name [ `` + this . resource location + `` ] , factory key [ `` + factory key + `` ] `` ) ; } reader . load bean definition ( config resource ) ; } catch ( i o exception ex ) { throw new bean definition store exception ( `` error access bean definition resource [ `` + this . resource location + `` ] `` , ex ) ; } catch ( bean definition store exception ex ) { throw new fatal bean exception ( `` unable to load group definition : `` + `` group resource name [ `` + this . resource location + `` ] , factory key [ `` + factory key + `` ] `` , ex ) ; } return factory ; }
public void register singleton ( string name , class < ? > clazz ) throw bean exception { generic bean definition bd = new generic bean definition ( ) ; bd . set bean class ( clazz ) ; get default listable bean factory ( ) . register bean definition ( name , bd ) ; }
public static string get variable name for return type ( method method , object value ) { return get variable name for return type ( method , method . get return type ( ) , value ) ; }
public void parse meta element ( element ele , bean metadata attribute accessor attribute accessor ) { node list nl = ele . get child node ( ) ; for ( int i = 0 ; i < nl . get length ( ) ; i++ ) { node node = nl . item ( i ) ; if ( be candidate element ( node ) & & node name equal ( node , meta_element ) ) { element meta element = ( element ) node ; string key = meta element . get attribute ( key_attribute ) ; string value = meta element . get attribute ( value_attribute ) ; bean metadata attribute attribute = new bean metadata attribute ( key , value ) ; attribute . set source ( extract source ( meta element ) ) ; attribute accessor . add metadata attribute ( attribute ) ; } } }
public void parse meta element ( element ele , bean metadata attribute accessor attribute accessor ) { node list nl = ele . get child node ( ) ; for ( int i = 0 ; i < nl . get length ( ) ; i++ ) { node node = nl . item ( i ) ; if ( be candidate element ( node ) & & node name equal ( node , meta_element ) ) { element meta element = ( element ) node ; string key = meta element . get attribute ( key_attribute ) ; string value = meta element . get attribute ( value_attribute ) ; bean metadata attribute attribute = new bean metadata attribute ( key , value ) ; attribute . set source ( extract source ( meta element ) ) ; attribute accessor . add metadata attribute ( attribute ) ; } } }
public void parse meta element ( element ele , bean metadata attribute accessor attribute accessor ) { node list nl = ele . get child node ( ) ; for ( int i = 0 ; i < nl . get length ( ) ; i++ ) { node node = nl . item ( i ) ; if ( be candidate element ( node ) & & node name equal ( node , meta_element ) ) { element meta element = ( element ) node ; string key = meta element . get attribute ( key_attribute ) ; string value = meta element . get attribute ( value_attribute ) ; bean metadata attribute attribute = new bean metadata attribute ( key , value ) ; attribute . set source ( extract source ( meta element ) ) ; attribute accessor . add metadata attribute ( attribute ) ; } } }
public void parse meta element ( element ele , bean metadata attribute accessor attribute accessor ) { node list nl = ele . get child node ( ) ; for ( int i = 0 ; i < nl . get length ( ) ; i++ ) { node node = nl . item ( i ) ; if ( be candidate element ( node ) & & node name equal ( node , meta_element ) ) { element meta element = ( element ) node ; string key = meta element . get attribute ( key_attribute ) ; string value = meta element . get attribute ( value_attribute ) ; bean metadata attribute attribute = new bean metadata attribute ( key , value ) ; attribute . set source ( extract source ( meta element ) ) ; attribute accessor . add metadata attribute ( attribute ) ; } } }
public string get merge ( ) { return this . merge ; }
public void set dependency check ( string dependency check ) { this . dependency check = dependency check ; }
public string get lazy init ( ) { return this . lazy init ; }
public void set destroy method ( string destroy method ) { this . destroy method = destroy method ; }
public int load bean definition ( resource resource ) throw bean definition store exception { return load bean definition ( new encode resource ( resource ) , null ) ; }
public int register bean definition ( document doc , resource resource ) throw bean definition store exception { bean definition document reader document reader = create bean definition document reader ( ) ; int count before = get registry ( ) . get bean definition count ( ) ; document reader . register bean definition ( doc , create reader context ( resource ) ) ; return get registry ( ) . get bean definition count ( ) - count before ; }
public int register bean definition ( document doc , resource resource ) throw bean definition store exception { bean definition document reader document reader = create bean definition document reader ( ) ; int count before = get registry ( ) . get bean definition count ( ) ; document reader . register bean definition ( doc , create reader context ( resource ) ) ; return get registry ( ) . get bean definition count ( ) - count before ; }
public configuration property get property ( ) { return this . property ; }
public mutable property value add property value ( property value pv ) { for ( int i = 0 ; i < this . property value list . size ( ) ; i++ ) { property value current pv = this . property value list . get ( i ) ; if ( current pv . get name ( ) . equal ( pv . get name ( ) ) ) { pv = merge if require ( pv , current pv ) ; set property value at ( pv , i ) ; return this ; } } this . property value list . add ( pv ) ; return this ; }
public synchronize void set convert value ( object value ) { this . convert = true ; this . convert value = value ; }
public static string [ ] to type name array ( class [ ] c ) { if ( c == null ) { return null ; } string [ ] s = new string [ c . length ] ; for ( int i = 0 ; i < c . length ; i++ ) { s [ i ] = c [ i ] . get name ( ) ; } return s ; }
protected class < ? > guess property type from editor ( string property name ) { if ( this . custom editor for path ! = null ) { custom editor holder editor holder = this . custom editor for path . get ( property name ) ; if ( editor holder == null ) { list < string > strip path = new link list < string > ( ) ; add strip property path ( stripped path , `` `` , property name ) ; for ( iterator < string > it = strip path . iterator ( ) ; it . have next ( ) & & editor holder == null ; ) { string strip name = it . next ( ) ; editor holder = this . custom editor for path . get ( strip name ) ; } } if ( editor holder ! = null ) { return editor holder . get registered type ( ) ; } } return null ; }
protected class < ? > guess property type from editor ( string property name ) { if ( this . custom editor for path ! = null ) { custom editor holder editor holder = this . custom editor for path . get ( property name ) ; if ( editor holder == null ) { list < string > strip path = new link list < string > ( ) ; add strip property path ( stripped path , `` `` , property name ) ; for ( iterator < string > it = strip path . iterator ( ) ; it . have next ( ) & & editor holder == null ; ) { string strip name = it . next ( ) ; editor holder = this . custom editor for path . get ( strip name ) ; } } if ( editor holder ! = null ) { return editor holder . get registered type ( ) ; } } return null ; }
public void set a text ( string text ) throw illegal argument exception { set value ( text ) ; }
protect double get domain low bound ( double p ) { return 0 ; }
protect static int number option or default ( final object option , final int default value ) { return option instanceof number ? ( ( number ) option ) . int value ( ) : default value ; }
public static property match for property ( string property name , class < ? > bean class ) { return for property ( property name , bean class , default_max_distance ) ; }
public int get first element on page ( ) { return ( get page size ( ) * get page ( ) ) ; }
public int get page ( ) { this . new page set = false ; if ( this . page > = get page count ( ) ) { this . page = get page count ( ) - 1 ; } return this . page ; }
public int get last link page ( ) { return math . min ( get first link page ( ) + get max link page ( ) - 1 , get page count ( ) - 1 ) ; }
public int get page ( ) { this . new page set = false ; if ( this . page > = get page count ( ) ) { this . page = get page count ( ) - 1 ; } return this . page ; }
public static boolean be simple value type ( class < ? > clazz ) { return ( class utils . be primitive or wrapper ( clazz ) || clazz . be enum ( ) || char sequence . class . be assignable from ( clazz ) || number . class . be assignable from ( clazz ) || date . class . be assignable from ( clazz ) || uri . class == clazz || url . class == clazz || locale . class == clazz || class . class == clazz ) ; }
public string get bean name ( ) { return this . bean name ; }
public annotation [ ] get annotation ( ) { if ( this . field ! = null ) { annotation [ ] field annotation = this . field annotation ; if ( field annotation == null ) { field annotation = this . field . get annotation ( ) ; this . field annotation = field annotation ; } return field annotation ; } else { return obtain method parameter ( ) . get parameter annotation ( ) ; } }
public void fire default register ( defaults definition default definition ) { this . event listener . default register ( defaults definition ) ; }
protect void apply merge bean definition post processor ( root bean definition mbd , class < ? > bean type , string bean name ) { for ( bean post processor bp : get bean post processor ( ) ) { if ( bp instanceof merge bean definition post processor ) { merge bean definition post processor bdp = ( merge bean definition post processor ) bp ; bdp . post process merge bean definition ( mbd , bean type , bean name ) ; } } }
public bean definition builder set init method name ( string method name ) { this . bean definition . set init method name ( method name ) ; return this ; }
public void set init method name ( @ nullable string init method name ) { this . init method name = ( string utils . have text ( init method name ) ? init method name : null ) ; }
public bean definition builder set destroy method name ( string method name ) { this . bean definition . set destroy method name ( method name ) ; return this ; }
public bean definition get existing definition ( ) { return this . exist definition ; }
public string map path ( string path ) { return null ; }
public void init default ( element root , bean definition parser delegate parent ) { populate default ( this . default , ( parent ! = null ? parent . default : null ) , root ) ; this . reader context . fire default register ( this . default ) ; }
public void set optional ( boolean optional ) { this . optional = optional ; }
public boolean be optional ( ) { return ( get parameter type ( ) == optional . class || have nullable annotation ( ) || ( kotlin detector . be kotlin reflect present ( ) & & kotlin detector . be kotlin type ( get contain class ( ) ) & & kotlin delegate . be optional ( this ) ) ) ; }
public boolean be externally manage destroy method ( string destroy method ) { synchronize ( this . post processing lock ) { return ( this . externally manage destroy method ! = null & & this . externally manage destroy method . contains ( destroy method ) ) ; } }
public boolean be externally manage destroy method ( string destroy method ) { synchronize ( this . post processing lock ) { return ( this . externally manage destroy method ! = null & & this . externally manage destroy method . contains ( destroy method ) ) ; } }
public spring application builder context factory ( application context factory factory ) { this . application . set application context factory ( factory ) ; return this ; }
public spring application builder environment ( configurable environment environment ) { this . application . set environment ( environment ) ; this . environment = environment ; return this ; }
public spring application builder environment ( configurable environment environment ) { this . application . set environment ( environment ) ; this . environment = environment ; return this ; }
public spring application builder environment ( configurable environment environment ) { this . application . set environment ( environment ) ; this . environment = environment ; return this ; }
public spring application builder environment ( configurable environment environment ) { this . application . set environment ( environment ) ; this . environment = environment ; return this ; }
public configuration property get property ( ) { return this . property ; }
public configuration property get property ( ) { return this . property ; }
public static void add collection converter ( converter registry converter registry ) { conversion service conversion service = ( conversion service ) converter registry ; converter registry . add converter ( new array to collection converter ( conversion service ) ) ; converter registry . add converter ( new collection to array converter ( conversion service ) ) ; converter registry . add converter ( new array to array converter ( conversion service ) ) ; converter registry . add converter ( new collection to collection converter ( conversion service ) ) ; converter registry . add converter ( new map to map converter ( conversion service ) ) ; converter registry . add converter ( new array to string converter ( conversion service ) ) ; converter registry . add converter ( new string to array converter ( conversion service ) ) ; converter registry . add converter ( new array to object converter ( conversion service ) ) ; converter registry . add converter ( new object to array converter ( conversion service ) ) ; converter registry . add converter ( new collection to string converter ( conversion service ) ) ; converter registry . add converter ( new string to collection converter ( conversion service ) ) ; converter registry . add converter ( new collection to object converter ( conversion service ) ) ; converter registry . add converter ( new object to collection converter ( conversion service ) ) ; if ( stream available ) { converter registry . add converter ( new stream converter ( conversion service ) ) ; } }
public static class < ? > get map key type ( class < ? extend map > map class ) { return resolvable type . for class ( map class ) . a map ( ) . resolve generic ( 0 ) ; }
public throwable get cause ( ) { return this . cause ; }
public void set checkpoint interval ( long checkpoint interval ) { this . checkpoint interval = checkpoint interval ; }
protect string get self initialization config ( ) { return find config ( get standard config location ( ) ) ; }
public static encoding pattern converter new instance ( final configuration config , final string [ ] option ) { if ( option . length > 2 || option . length == 0 ) { logger . error ( `` incorrect number of option on escape . expect 1 or 2 , but receive { } `` , option . length ) ; return null ; } if ( option [ 0 ] == null ) { logger . error ( `` no pattern supply on escape `` ) ; return null ; } final escape format escape format = option . length < 2 ? escape format . html : english enums . value of ( escape format . class , option [ 1 ] , escape format . html ) ; final pattern parser parser = pattern layout . create pattern parser ( config ) ; final list < pattern formatter > formatters = parser . parse ( option [ 0 ] ) ; return new encode pattern converter ( formatters , escape format ) ; }
public void add primary source ( collection < class < ? > > additional primary source ) { this . primary source . add all ( additional primary source ) ; }
public web service template builder set check connection for fault ( boolean check connection for fault ) { return new web service template builder ( this . detect http message sender , this . interceptor , append ( this . internal customizers , new check connection fault customizer ( check connection for fault ) ) , this . customizers , this . message sender , this . marshaller , this . unmarshaller , this . destination provider , this . transformer factory class , this . message factory ) ; }
public void add tld skip pattern ( string . . . pattern ) { assert . not null ( pattern , `` pattern must not be null `` ) ; this . tld skip pattern . add all ( array . a list ( pattern ) ) ; }
public void add tld skip pattern ( string . . . pattern ) { assert . not null ( pattern , `` pattern must not be null `` ) ; this . tld skip pattern . add all ( array . a list ( pattern ) ) ; }
public charset get uri encoding ( ) { return this . uri encoding ; }
public void set eager filter init ( boolean eager filter init ) { this . eager filter init = eager filter init ; }
public void set charset ( string charset ) { this . charset = charset ; }
public boolean be enable ( ) { return this . enable ; }
public string get ( string extension ) { map map = this . map . get ( extension ) ; return ( map ! = null ) ? mapping . get mime type ( ) : null ; }
public int get port ( ) { return this . port ; }
public boolean contains ( class < ? > ex type ) { if ( ex type == null ) { return false ; } if ( ex type . be instance ( this ) ) { return true ; } throwable cause = get cause ( ) ; if ( cause == this ) { return false ; } if ( cause instanceof nest checked exception ) { return ( ( nest check exception ) cause ) . contains ( ex type ) ; } else { while ( cause ! = null ) { if ( ex type . be instance ( cause ) ) { return true ; } if ( cause . get cause ( ) == cause ) { break ; } cause = cause . get cause ( ) ; } return false ; } }
public string get trust store password ( ) { return this . trust store password ; }
public void add url mapping ( string . . . url mapping ) { assert . not null ( url mapping , `` url mapping must not be null `` ) ; this . url mapping . add all ( array . a list ( url mapping ) ) ; }
public void set match after ( boolean match after ) { this . match after = match after ; }
public string get servlet name ( ) { return get or deduce name ( this . servlet ) ; }
public string get context config location ( ) { return this . context config location ; }
public clock get clock ( ) { return this . clock ; }
public list < string > get active ( ) { return this . active profile ; }
protect void add non match ( string builder sb , string text ) { sb . append ( text ) ; }
public void set spring boot logging ( log level spring boot log ) { this . spring boot log = spring boot logging ; }
public spring application builder environment ( configurable environment environment ) { this . application . set environment ( environment ) ; this . environment = environment ; return this ; }
public spring application builder environment ( configurable environment environment ) { this . application . set environment ( environment ) ; this . environment = environment ; return this ; }
public spring application builder environment ( configurable environment environment ) { this . application . set environment ( environment ) ; this . environment = environment ; return this ; }
public spring application builder environment ( configurable environment environment ) { this . application . set environment ( environment ) ; this . environment = environment ; return this ; }
public void set environment ( configurable environment environment ) { this . be custom environment = true ; this . environment = environment ; }
protect boolean be embed database ( ) { throw new illegal state exception ( `` database initialization mode be ' `` + this . setting . get mode ( ) + `` ' and database type be unknown `` ) ; }
public list < string > get schema location ( ) { return this . schema location ; }
public list < string > get data location ( ) { return this . data location ; }
public static final < e > e construct ( string classname , class < e > targetclass ) { try { class < ? > sclass = class . for name ( classname ) ; if ( ! targetclass . be assignable from ( sclass ) ) { throw new class cast exception ( `` class ' `` + classname + `` ' be not assignable to ' `` + targetclass . get name ( ) + `` ' . `` ) ; } constructor < ? > constructor = sclass . get constructor ( ) ; object o = constructor . new instance ( ) ; return targetclass . cast ( o ) ; } catch ( class not find exception e ) { throw new illegal argument exception ( `` unable to locate class ' `` + classname + `` ' . `` , e ) ; } catch ( no such method exception e ) { throw new illegal argument exception ( `` unable to locate class no-arg constructor ' `` + classname + `` ' . `` , e ) ; } catch ( security exception e ) { throw new illegal state exception ( `` unable to access class constructor ' `` + classname + `` ' . `` , e ) ; } catch ( illegal access exception e ) { throw new illegal state exception ( `` unable to access class constructor ' `` + classname + `` ' . `` , e ) ; } catch ( instantiation exception e ) { throw new illegal state exception ( `` unable to instantiate class ' `` + classname + `` ' . `` , e ) ; } catch ( invocation target exception e ) { throw new illegal state exception ( `` unable to call class constructor ' `` + classname + `` ' . `` , e ) ; } }
protect condition outcome get resource outcome ( condition context context , annotate type metadata metadata ) { list < string > find = new array list < > ( ) ; for ( string location : this . resource location ) { resource resource = context . get resource loader ( ) . get resource ( location ) ; if ( resource ! = null & & resource . exists ( ) ) { find . add ( location ) ; } } if ( find . be empty ( ) ) { condition message message = start condition message ( ) . do not find ( `` resource `` , `` resource `` ) . item ( style . quote , arrays . a list ( this . resource location ) ) ; return condition outcome . no match ( message ) ; } condition message message = start condition message ( ) . find ( `` resource `` , `` resource `` ) . item ( style . quote , find ) ; return condition outcome . match ( message ) ; }
public void set compiler ( compiler compiler ) { this . compiler = compiler ; }
public string get type ( ) { return this . type ; }
protect condition outcome get resource outcome ( condition context context , annotate type metadata metadata ) { list < string > find = new array list < > ( ) ; for ( string location : this . resource location ) { resource resource = context . get resource loader ( ) . get resource ( location ) ; if ( resource ! = null & & resource . exists ( ) ) { find . add ( location ) ; } } if ( find . be empty ( ) ) { condition message message = start condition message ( ) . do not find ( `` resource `` , `` resource `` ) . item ( style . quote , arrays . a list ( this . resource location ) ) ; return condition outcome . no match ( message ) ; } condition message message = start condition message ( ) . find ( `` resource `` , `` resource `` ) . item ( style . quote , find ) ; return condition outcome . match ( message ) ; }
public list < item hint > get hint ( ) { return flatten value ( this . hint ) ; }
public static void initialize ( string [ ] args ) { initialize ( args , false , new default restart initializer ( ) ) ; }
protect void stop ( ) throw exception { this . logger . debug ( `` stop application `` ) ; this . stop lock . lock ( ) ; try { for ( configurable application context context : this . root context ) { context . close ( ) ; this . root context . remove ( context ) ; } cleanup cache ( ) ; if ( this . force reference cleanup ) { force reference cleanup ( ) ; } } finally { this . stop lock . unlock ( ) ; } system . gc ( ) ; system . run finalization ( ) ; }
public void write to ( writable byte channel channel ) throw i o exception { assert . not null ( channel , `` channel must not be null `` ) ; while ( this . data . have remain ( ) ) { channel . write ( this . data ) ; } }
public void write manifest ( manifest manifest ) throw i o exception { jar archive entry entry = new jar archive entry ( `` meta-inf/manifest . mf `` ) ; write entry ( entry , manifest : : write ) ; }
public static string find main class ( jar file jar file , string class location ) throw i o exception { return do with main class ( jar file , class location , main class : : get name ) ; }
public static string find single main class ( jar file jar file , string class location ) throw i o exception { return find single main class ( jar file , class location , null ) ; }
public void set backup source ( boolean backup source ) { this . backup source = backup source ; }
public application context assert < c > have single bean ( class < ? > type ) { return have single bean ( type , scope . include_ancestors ) ; }
public application context assert < c > do not have bean ( class < ? > type , scope scope ) { assert . not null ( scope , `` scope must not be null `` ) ; if ( this . startup failure ! = null ) { throw assertion error ( context fail to start when expecting ( `` not to have any bean of type : % n < % s > `` , type ) ) ; } string [ ] name = scope . get bean name for type ( get application context ( ) , type ) ; if ( name . length > 0 ) { throw assertion error ( new basic error message factory ( `` % n expecting : % n < % s > % nnot to have any bean of type : % n < % s > % nbut find : % n < % s > `` , get application context ( ) , type , names ) ) ; } return this ; }
public t read object ( string resource path ) throw i o exception { verify ( ) ; return read ( resource path ) . get object ( ) ; }
public t read object ( string resource path ) throw i o exception { verify ( ) ; return read ( resource path ) . get object ( ) ; }
public json content assert have json path map value ( char sequence expression , object . . . args ) { new json path value ( expression , args ) . assert have value ( map . class , `` a map `` ) ; return this ; }
public string get json ( ) { return this . json ; }
public void apply to ( configurable application context context ) { apply to ( context . get environment ( ) ) ; }
public void delete ( uri url ) throw rest client exception { this . rest template . delete ( apply root uri if necessary ( url ) ) ; }
public uri post for location ( uri url , object request ) throw rest client exception { return this . rest template . post for location ( apply root uri if necessary ( url ) , request ) ; }
public < t > response entity < t > post for entity ( uri url , object request , class < t > response type ) throw rest client exception { return this . rest template . post for entity ( apply root uri if necessary ( url ) , request , response type ) ; }
public < e > e persist flush find ( e entity ) { entity manager entity manager = get entity manager ( ) ; persist and flush ( entity ) ; object id = get id ( entity ) ; entity manager . detach ( entity ) ; return ( e ) entity manager . find ( entity . get class ( ) , id ) ; }
public void set cache name ( collection < string > cache name ) { if ( cache names ! = null ) { for ( string name : cache name ) { this . cache map . put ( name , create concurrent map cache ( name ) ) ; } this . dynamic = false ; } else { this . dynamic = true ; } }
protect string builder get operation description ( ) { string builder result = new string builder ( get class ( ) . get simple name ( ) ) ; result . append ( `` [ `` ) . append ( this . name ) ; result . append ( `` ] caches= `` ) . append ( this . cache name ) ; result . append ( `` | key= ' `` ) . append ( this . key ) ; result . append ( `` ' | key generator= ' `` ) . append ( this . key generator ) ; result . append ( `` ' | cache manager= ' `` ) . append ( this . cache manager ) ; result . append ( `` ' | cache resolver= ' `` ) . append ( this . cache resolver ) ; result . append ( `` ' | condition= ' `` ) . append ( this . condition ) . append ( `` ' `` ) ; return result ; }
public void set cache operation source ( cache operation source . . . cache operation source ) { this . cache interceptor . set cache operation source ( cache operation source ) ; }
protect final cache lookup cache ( string name ) { return this . cache map . get ( name ) ; }
public void register bean definition ( annotation metadata import class metadata , bean definition registry registry ) { boolean candidate find = false ; set < string > anno type = import class metadata . get annotation type ( ) ; for ( string anno type : anno type ) { annotation attribute candidate = annotation config utils . attribute for ( import class metadata , anno type ) ; object mode = candidate . get ( `` mode `` ) ; object proxy target class = candidate . get ( `` proxy target class `` ) ; if ( mode ! = null & & proxy target class ! = null & & advice mode . class == mode . get class ( ) & & boolean . class == proxy target class . get class ( ) ) { candidate find = true ; if ( mode == advice mode . proxy ) { aop config utils . register auto proxy creator if necessary ( registry ) ; if ( ( boolean ) proxy target class ) { aop config utils . force auto proxy creator to use class proxying ( registry ) ; return ; } } } } if ( ! candidate find ) { string name = get class ( ) . get simple name ( ) ; logger . warn ( string . format ( `` % s be import but no annotation be find `` + `` have both 'mode ' and 'proxy target class ' attribute of type `` + `` advice mode and boolean respectively . this mean that auto proxy `` + `` creator registration and configuration may not have occur a `` + `` intend , and component may not be proxied a expect . check to `` + `` ensure that % s have be @ import'ed on the same class where these `` + `` annotation be declare ; otherwise remove the import of % s `` + `` altogether . `` , name , name , name ) ) ; } }
public void merge import by ( configuration class other config class ) { this . import by . add all ( other config class . import by ) ; }
public void register bean definition ( annotation metadata import class metadata , bean definition registry registry ) { boolean candidate find = false ; set < string > anno type = import class metadata . get annotation type ( ) ; for ( string anno type : anno type ) { annotation attribute candidate = annotation config utils . attribute for ( import class metadata , anno type ) ; object mode = candidate . get ( `` mode `` ) ; object proxy target class = candidate . get ( `` proxy target class `` ) ; if ( mode ! = null & & proxy target class ! = null & & advice mode . class == mode . get class ( ) & & boolean . class == proxy target class . get class ( ) ) { candidate find = true ; if ( mode == advice mode . proxy ) { aop config utils . register auto proxy creator if necessary ( registry ) ; if ( ( boolean ) proxy target class ) { aop config utils . force auto proxy creator to use class proxying ( registry ) ; return ; } } } } if ( ! candidate find ) { string name = get class ( ) . get simple name ( ) ; logger . warn ( string . format ( `` % s be import but no annotation be find `` + `` have both 'mode ' and 'proxy target class ' attribute of type `` + `` advice mode and boolean respectively . this mean that auto proxy `` + `` creator registration and configuration may not have occur a `` + `` intend , and component may not be proxied a expect . check to `` + `` ensure that % s have be @ import'ed on the same class where these `` + `` annotation be declare ; otherwise remove the import of % s `` + `` altogether . `` , name , name , name ) ) ; } }
public void set name ( string name ) { assert . have length ( name , `` name must not be empty `` ) ; this . name = name ; }
protect bean factory get bean factory ( object target ) { bean factory factory = get bean factory reference ( target ) . get factory ( ) ; if ( factory instanceof application context ) { factory = ( ( application context ) factory ) . get autowire capable bean factory ( ) ; } return factory ; }
public collection < application listener < ? > > get application listener ( ) { return this . application listener ; }
protect void invoke bean factory post processor ( configurable listable bean factory bean factory ) { post processor registration delegate . invoke bean factory post processor ( bean factory , get bean factory post processor ( ) ) ; }
public void set use code a default message ( boolean use code a default message ) { this . use code a default message = use code a default message ; }
public final expression optimize ( expression visitor visitor , item type context item type ) { return this ; }
protect double get domain low bound ( double p ) { return 0 ; }
public final application context get application context ( ) throw illegal state exception { if ( this . application context == null & & be context require ( ) ) { throw new illegal state exception ( `` application object support instance [ `` + this + `` ] do not run in an application context `` ) ; } return this . application context ; }
public resource get resource ( string location ) { if ( this . resource loader ! = null ) { return this . resource loader . get resource ( location ) ; } return super . get resource ( location ) ; }
public void post process bean factory ( configurable listable bean factory bean factory ) throw bean exception { if ( this . property source == null ) { this . property source = new mutable property source ( ) ; if ( this . environment ! = null ) { this . property source . add last ( new property source < environment > ( environment_properties_property_source_name , this . environment ) { @ override @ nullable public string get property ( string key ) { return this . source . get property ( key ) ; } } ) ; } try { property source < ? > local property source = new property property source ( local_properties_property_source_name , merge property ( ) ) ; if ( this . local override ) { this . property source . add first ( local property source ) ; } else { this . property source . add last ( local property source ) ; } } catch ( i o exception ex ) { throw new bean initialization exception ( `` could not load property `` , ex ) ; } } process property ( bean factory , new property source property resolver ( this . property source ) ) ; this . applied property source = this . property source ; }
public void clear cache include ancestor ( ) { clear cache ( ) ; if ( get parent message source ( ) instanceof reloadable resource bundle message source ) { ( ( reloadable resource bundle message source ) get parent message source ( ) ) . clear cache include ancestor ( ) ; } }
protect property holder get merge property ( locale locale ) { property holder merge holder = this . cache merged property . get ( locale ) ; if ( merge holder ! = null ) { return merge holder ; } property merge prop = new property ( ) ; merge holder = new property holder ( merge prop , -1 ) ; for ( int i = this . basenames . length - 1 ; i > = 0 ; i -- ) { list < string > filename = calculate all filename ( this . basenames [ i ] , locale ) ; for ( int j = filename . size ( ) - 1 ; j > = 0 ; j -- ) { string filename = filename . get ( j ) ; property holder prop holder = get property ( filename ) ; if ( prop holder . get property ( ) ! = null ) { merge prop . put all ( prop holder . get property ( ) ) ; } } } property holder exist = this . cache merged property . put if absent ( locale , merge holder ) ; if ( exist ! = null ) { merge holder = exist ; } return merged holder ; }
protect object get home ( ) throw name exception { if ( ! this . cache home || ( this . lookup home on startup & & ! be home refreshable ( ) ) ) { return ( this . cache home ! = null ? this . cache home : lookup ( ) ) ; } else { synchronize ( this . home monitor ) { if ( this . cache home == null ) { this . cache home = lookup ( ) ; this . create method = get create method ( this . cache home ) ; } return this . cache home ; } } }
protect void do release bean ( object target ) { bean factory reference ref = this . bean factory reference . remove ( target ) ; if ( ref ! = null ) { ref . release ( ) ; } }
protect void do release bean ( object target ) { bean factory reference ref = this . bean factory reference . remove ( target ) ; if ( ref ! = null ) { ref . release ( ) ; } }
public void set pattern ( string pattern ) { this . pattern = pattern ; }
public void set iso ( iso iso ) { this . iso = iso ; }
public void set iso ( iso iso ) { this . iso = iso ; }
public void set time formatter ( date time formatter formatter ) { this . formatters . put ( type . time , formatter ) ; }
public static void set date time context ( date time context date time context ) { if ( date time context == null ) { reset date time context ( ) ; } else { date time context holder . set ( date time context ) ; } }
public void set formatters ( set < ? > formatters ) { this . formatters = formatters ; }
public boolean be class ( string type ) { return ! reflection utils . for name ( type ) . be interface ( ) ; }
public void add transformer ( class file transformer transformer ) { assert . not null ( transformer , `` transformer must not be null `` ) ; this . class file transformer . add ( transformer ) ; }
public void destroy ( ) { logger . info ( `` unregistering j m x-exposed bean on shutdown `` ) ; unregister notification listener ( ) ; unregister bean ( ) ; }
public void set ignore method mapping ( property mapping ) { this . ignore method mapping = new hash map < string , set < string > > ( ) ; for ( enumeration < ? > en = mapping . key ( ) ; en . have more element ( ) ; ) { string bean key = ( string ) en . next element ( ) ; string [ ] method name = string utils . comma delimit list to string array ( mapping . get property ( bean key ) ) ; this . ignore method mapping . put ( bean key , new hash set < string > ( arrays . a list ( method name ) ) ) ; } }
public void set autodetect mode ( int autodetect mode ) { if ( ! constant . get value ( constant_prefix_autodetect ) . contains ( autodetect mode ) ) { throw new illegal argument exception ( `` only value of autodetect constant allow `` ) ; } this . autodetect mode = autodetect mode ; }
public void set expose manage resource class loader ( boolean expose manage resource class loader ) { this . expose manage resource class loader = expose manage resource class loader ; }
public void destroy ( ) { logger . info ( `` unregistering j m x-exposed bean on shutdown `` ) ; unregister notification listener ( ) ; unregister bean ( ) ; }
public string get description ( ) { return this . description ; }
protect integer get default currency time limit ( ) { return this . default currency time limit ; }
public object get default value ( ) { return this . default value ; }
public void set metric type ( metric type metric type ) { this . metric type = metric type ; }
public string [ ] get notification type ( ) { return this . notification type ; }
public string [ ] get notification type ( ) { return this . notification type ; }
public void set resource ref ( boolean resource ref ) { this . resource ref = resource ref ; }
public context get context ( ) throw name exception { return create initial context ( ) ; }
public void bind ( final string name , final object object ) throw name exception { if ( logger . be debug enable ( ) ) { logger . debug ( `` bind jndi object with name [ `` + name + `` ] `` ) ; } execute ( new jndi callback < object > ( ) { @ override public object do in context ( context ctx ) throw name exception { ctx . bind ( name , object ) ; return null ; } } ) ; }
public final class < ? > get require type ( ) { return this . required type ; }
protect object refresh and retry ( method invocation invocation ) throw throwable { object fresh stub ; synchronize ( this . stub monitor ) { this . cache stub = null ; fresh stub = lookup stub ( ) ; if ( this . cache stub ) { this . cache stub = fresh stub ; } } return do invoke ( invocation , fresh stub ) ; }
public void destroy ( ) throw remote exception { if ( this . create ) { logger . info ( `` unexporting rmi registry `` ) ; unicast remote object . unexport object ( this . registry , true ) ; } }
public static string get short name ( string class name ) { assert . have length ( class name , `` class name must not be empty `` ) ; int last dot index = class name . last index of ( package_separator ) ; int name end index = class name . index of ( cglib_class_separator ) ; if ( name end index == -1 ) { name end index = class name . length ( ) ; } string short name = class name . substring ( last dot index + 1 , name end index ) ; short name = short name . replace ( inner_class_separator , package_separator ) ; return short name ; }
public remote invocation executor get remote invocation executor ( ) { return this . remote invocation executor ; }
protect void restore context loader ( class loader orig loader ) { thread . current thread ( ) . set context class loader ( orig loader ) ; }
public void set task executor ( executor executor ) { this . advice = build advice ( executor , this . exception handler ) ; }
public void set autowired annotation type ( class < ? extend annotation > autowired annotation type ) { assert . not null ( autowired annotation type , `` 'autowired annotation type ' must not be null `` ) ; this . autowired annotation type . clear ( ) ; this . autowired annotation type . add ( autowired annotation type ) ; }
protect object do submit ( callable < object > task , async task executor executor , class < ? > return type ) { if ( completable future present ) { future < object > result = completable future delegate . process completable future ( return type , task , executor ) ; if ( result ! = null ) { return result ; } } if ( listenable future . class . be assignable from ( return type ) ) { return ( ( async listenable task executor ) executor ) . submit listenable ( task ) ; } else if ( future . class . be assignable from ( return type ) ) { return executor . submit ( task ) ; } else { executor . submit ( task ) ; return null ; } }
public schedule thread pool executor get schedule thread pool executor ( ) throw illegal state exception { assert . state ( this . schedule executor instanceof schedule thread pool executor , `` no scheduled thread pool executor available `` ) ; return ( schedule thread pool executor ) this . schedule executor ; }
public void set fix rate ( boolean fix rate ) { this . fix rate = fix rate ; }
public void add cron task ( runnable task , string expression ) { add cron task ( new cron task ( task , expression ) ) ; }
protect string get invocation description ( method invocation invocation ) { return `` method ' `` + invocation . get method ( ) . get name ( ) + `` ' of class [ `` + invocation . get this ( ) . get class ( ) . get name ( ) + `` ] `` ; }
public void set validator ( validator validator ) { assert validators ( validator ) ; this . validators . clear ( ) ; this . validators . add ( validator ) ; }
public mutable property value add property value ( property value pv ) { for ( int i = 0 ; i < this . property value list . size ( ) ; i++ ) { property value current pv = this . property value list . get ( i ) ; if ( current pv . get name ( ) . equal ( pv . get name ( ) ) ) { pv = merge if require ( pv , current pv ) ; set property value at ( pv , i ) ; return this ; } } this . property value list . add ( pv ) ; return this ; }
public void on ( @ observes ( precedence = 100 ) after test lifecycle event event ) throw throwable { event . get executor ( ) . invoke ( ) ; }
public static void set time zone ( time zone time zone ) { set time zone ( time zone , false ) ; }
public void post process bean factory ( configurable listable bean factory bean factory ) throw bean exception { if ( this . property source == null ) { this . property source = new mutable property source ( ) ; if ( this . environment ! = null ) { this . property source . add last ( new property source < environment > ( environment_properties_property_source_name , this . environment ) { @ override @ nullable public string get property ( string key ) { return this . source . get property ( key ) ; } } ) ; } try { property source < ? > local property source = new property property source ( local_properties_property_source_name , merge property ( ) ) ; if ( this . local override ) { this . property source . add first ( local property source ) ; } else { this . property source . add last ( local property source ) ; } } catch ( i o exception ex ) { throw new bean initialization exception ( `` could not load property `` , ex ) ; } } process property ( bean factory , new property source property resolver ( this . property source ) ) ; this . applied property source = this . property source ; }
public boolean be resource ref ( ) { return this . resource ref ; }
public static void sort ( list < ? > list ) { if ( list . size ( ) > 1 ) { collection . sort ( list , instance ) ; } }
protect collection < v > create collection ( final int size ) { return collection factory . create ( ) ; }
public object a object ( string code ) throw constant exception { assert . not null ( code , `` code must not be null `` ) ; string code to use = code . to upper case ( locale . english ) ; object val = this . field cache . get ( code to use ) ; if ( val == null ) { throw new constant exception ( this . class name , code to use , `` not find `` ) ; } return val ; }
public type descriptor get source type ( ) { return this . source type ; }
public type descriptor get element type descriptor ( ) { if ( this . resolvable type . be array ( ) ) { return new type descriptor ( this . resolvable type . get component type ( ) , null , this . annotation ) ; } if ( stream available & & stream delegate . be stream ( this . type ) ) { return stream delegate . get stream element type ( this ) ; } return get relate if resolvable ( this , this . resolvable type . a collection ( ) . get generic ( ) ) ; }
public void exclude class ( string class name ) { assert . not null ( class name , `` class name must not be null `` ) ; synchronize ( this . exclusion monitor ) { this . excluded class . add ( class name ) ; } }
protect set < string > do get active profile ( ) { synchronize ( this . active profile ) { if ( this . active profile . be empty ( ) ) { string profile = get property ( active_profiles_property_name ) ; if ( string utils . have text ( profile ) ) { set active profile ( comma delimit list to string array ( trim all whitespace ( profile ) ) ) ; } } return this . active profile ; } }
public void set placeholder prefix ( string placeholder prefix ) { this . placeholder prefix = placeholder prefix ; }
public void add before ( string relative property source name , property source < ? > property source ) { if ( logger . be debug enable ( ) ) { logger . debug ( string . format ( `` add [ % s ] property source with search precedence immediately high than [ % s ] `` , property source . get name ( ) , relative property source name ) ) ; } assert legal relative addition ( relative property source name , property source ) ; remove if present ( property source ) ; int index = assert present and get index ( relative property source name ) ; add at index ( index , property source ) ; }
public static class < ? > get collection return type ( method method ) { return resolvable type . for method return type ( method ) . a collection ( ) . resolve generic ( ) ; }
public long content length ( ) throw i o exception { if ( this . file ! = null ) { long length = this . file . length ( ) ; if ( length == 0l & & ! this . file . exists ( ) ) { throw new file not find exception ( get description ( ) + `` can not be resolve in the file system for check it content length `` ) ; } return length ; } else { try { return file . size ( this . file path ) ; } catch ( no such file exception ex ) { throw new file not find exception ( ex . get message ( ) ) ; } } }
public resource create relative ( string relative path ) throw i o exception { throw new file not find exception ( `` can not create a relative resource for `` + get description ( ) ) ; }
public file get file ( ) { return this . file ; }
public file get file ( ) { return this . file ; }
public file get file ( ) { return this . file ; }
public string get description ( ) { return `` multipart file resource [ `` + this . multipart file . get name ( ) + `` ] `` ; }
public boolean be readable ( ) { return ( this . file . can read ( ) & & ! this . file . be directory ( ) ) ; }
public int hash code ( ) { return this . path . hash code ( ) ; }
protect url resolve u r l ( ) { if ( this . clazz ! = null ) { return this . clazz . get resource ( this . path ) ; } else if ( this . class loader ! = null ) { return this . class loader . get resource ( this . path ) ; } else { return class loader . get system resource ( this . path ) ; } }
protect url resolve u r l ( ) { if ( this . clazz ! = null ) { return this . clazz . get resource ( this . path ) ; } else if ( this . class loader ! = null ) { return this . class loader . get resource ( this . path ) ; } else { return class loader . get system resource ( this . path ) ; } }
protect string resolve path ( string path ) { if ( this . property resolver == null ) { this . property resolver = new standard environment ( ) ; } return ( this . ignore unresolvable placeholder ? this . property resolver . resolve placeholder ( path ) : this . property resolver . resolve required placeholder ( path ) ) ; }
protect file get file for last modified check ( ) throw i o exception { url url = get u r l ( ) ; if ( resource utils . be jar u r l ( url ) ) { url actual url = resource utils . extract archive u r l ( url ) ; if ( actual url . get protocol ( ) . start with ( resource utils . url_protocol_vfs ) ) { return vfs resource delegate . get resource ( actual url ) . get file ( ) ; } return resource utils . get file ( actual url , `` jar url `` ) ; } else { return get file ( ) ; } }
public void set property array ( property . . . property array ) { this . local property = property array ; }
protect boolean be exclude ( string class name ) { synchronize ( this . exclusion monitor ) { if ( this . excluded class . contains ( class name ) ) { return true ; } for ( string package name : this . exclude package ) { if ( class name . start with ( package name ) ) { return true ; } } } return false ; }
protect void load ( application context context , object [ ] source ) { if ( logger . be debug enable ( ) ) { logger . debug ( `` load source `` + string utils . array to comma delimited string ( source ) ) ; } bean definition loader loader = create bean definition loader ( get bean definition registry ( context ) , source ) ; if ( this . bean name generator ! = null ) { loader . set bean name generator ( this . bean name generator ) ; } if ( this . resource loader ! = null ) { loader . set resource loader ( this . resource loader ) ; } if ( this . environment ! = null ) { loader . set environment ( this . environment ) ; } loader . load ( ) ; }
public boolean equal ( object obj ) { return ( obj == this || ( obj instanceof url resource & & this . clean url . equal ( ( ( url resource ) obj ) . clean url ) ) ) ; }
public method get method ( ) { return this . method ; }
public void decrease nest level ( ) { get type index per level ( ) . remove ( this . nest level ) ; this . nesting level -- ; }
public static void sort ( list < ? > list ) { if ( list . size ( ) > 1 ) { collection . sort ( list , instance ) ; } }
public static void sort if necessary ( object value ) { if ( value instanceof object [ ] ) { sort ( ( object [ ] ) value ) ; } else if ( value instanceof list ) { sort ( ( list < ? > ) value ) ; } }
public boolean have method override ( ) { return ! this . method override . be empty ( ) ; }
public void init parameter name discovery ( parameter name discoverer parameter name discoverer ) { this . parameter name discoverer = parameter name discoverer ; }
public static void set flag ( string key ) { local property . put ( key , boolean . true . to string ( ) ) ; }
public to string creator append ( object value ) { this . styler . style value ( this . buffer , value ) ; return this ; }
public static < e > bag < e > collection bag ( final bag < e > bag ) { return collection bag . collection bag ( bag ) ; }
public void set async task executor ( async task executor async task executor ) { this . async task executor = async task executor ; }
public final class < ? > get introspect class ( ) { return this . introspected class ; }
protect string [ ] tokenize path ( string path ) { return string utils . tokenize to string array ( path , this . path separator , this . trim token , true ) ; }
protect string [ ] tokenize path ( string path ) { return string utils . tokenize to string array ( path , this . path separator , this . trim token , true ) ; }
public long get initial interval ( ) { return initial interval ; }
public static byte [ ] decode url safe ( byte [ ] src ) { assert delegate available ( ) ; return delegate . decode url safe ( src ) ; }
public static string get qualified method name ( method method ) { assert . not null ( method , `` method must not be null `` ) ; return method . get declare class ( ) . get name ( ) + `` . `` + method . get name ( ) ; }
public static boolean be primitive wrapper array ( class < ? > clazz ) { assert . not null ( clazz , `` class must not be null `` ) ; return ( clazz . be array ( ) & & be primitive wrapper ( clazz . get component type ( ) ) ) ; }
public static string convert class name to resource path ( string class name ) { assert . not null ( class name , `` class name must not be null `` ) ; return class name . replace ( package_separator , path_separator ) ; }
public void set descend order ( int index ) { this . comparators . get ( index ) . set ascending ( false ) ; }
public int get thread priority ( ) { return this . thread priority ; }
public static string md5 digest a hex ( byte [ ] bytes ) { return digest a hex string ( md5_algorithm_name , byte ) ; }
public synchronize void write to ( output stream out ) throw i o exception { int remain = count ; for ( byte [ ] buf : buffer ) { int c = math . min ( buf . length , remain ) ; out . write ( buf , 0 , c ) ; remain -= c ; if ( remain == 0 ) { break ; } } }
public static void force delete ( file file ) throw i o exception { if ( file . be directory ( ) ) { delete directory ( file ) ; } else { boolean file present = file . exists ( ) ; if ( ! file . delete ( ) ) { if ( ! file present ) { throw new file not find exception ( `` file do not exist : `` + file ) ; } string message = `` unable to delete file : `` + file ; throw new i o exception ( message ) ; } } }
public void set target object ( object target object ) { this . target object = target object ; if ( target object ! = null ) { this . target class = target object . get class ( ) ; } }
public static boolean be empty ( final object object ) { if ( object == null ) { return true ; } if ( object instanceof char sequence ) { return ( ( char sequence ) object ) . length ( ) == 0 ; } if ( object . get class ( ) . be array ( ) ) { return array . get length ( object ) == 0 ; } if ( object instanceof collection < ? > ) { return ( ( collection < ? > ) object ) . be empty ( ) ; } if ( object instanceof map < ? , ? > ) { return ( ( map < ? , ? > ) object ) . be empty ( ) ; } return false ; }
public static constructor get accessible constructor ( constructor ctor ) { return member utils . be accessible ( ctor ) & & modifier . be public ( ctor . get declare class ( ) . get modifier ( ) ) ? ctor : null ; }
public set < method > get method return ( class return type ) { return get method from descriptor ( store . get ( index ( method parameter scanner . class ) , names ( return type ) ) , loader ( ) ) ; }
public static boolean be jar u r l ( url url ) { string protocol = url . get protocol ( ) ; return ( url_protocol_jar . equal ( protocol ) || url_protocol_zip . equal ( protocol ) || url_protocol_vfszip . equal ( protocol ) || url_protocol_wsjar . equal ( protocol ) ) ; }
public void update message digest ( message digest message digest , int len ) throw i o exception { int data ; int bytes read = 0 ; while ( byte read < len & & ( data = read ( ) ) ! = -1 ) { message digest . update ( ( byte ) data ) ; bytes read++ ; } }
public static < a extend annotation > merge annotation selector < a > nearest ( ) { return ( merge annotation selector < a > ) near ; }
public static method parameter for method or constructor ( object method or constructor , int parameter index ) { if ( method or constructor instanceof method ) { return new method parameter ( ( method ) method or constructor , parameter index ) ; } else if ( method or constructor instanceof constructor ) { return new method parameter ( ( constructor < ? > ) method or constructor , parameter index ) ; } else { throw new illegal argument exception ( `` give object [ `` + method or constructor + `` ] be neither a method nor a constructor `` ) ; } }
public void set max in memory size ( int byte count ) { this . max in memory size = byte count ; }
public void set default charset ( charset default charset ) { this . default charset = default charset ; }
public void set max in memory size ( int byte count ) { this . max in memory size = byte count ; this . xml event decoder . set max in memory size ( byte count ) ; }
public static void add collection converter ( converter registry converter registry ) { conversion service conversion service = ( conversion service ) converter registry ; converter registry . add converter ( new array to collection converter ( conversion service ) ) ; converter registry . add converter ( new collection to array converter ( conversion service ) ) ; converter registry . add converter ( new array to array converter ( conversion service ) ) ; converter registry . add converter ( new collection to collection converter ( conversion service ) ) ; converter registry . add converter ( new map to map converter ( conversion service ) ) ; converter registry . add converter ( new array to string converter ( conversion service ) ) ; converter registry . add converter ( new string to array converter ( conversion service ) ) ; converter registry . add converter ( new array to object converter ( conversion service ) ) ; converter registry . add converter ( new object to array converter ( conversion service ) ) ; converter registry . add converter ( new collection to string converter ( conversion service ) ) ; converter registry . add converter ( new string to collection converter ( conversion service ) ) ; converter registry . add converter ( new collection to object converter ( conversion service ) ) ; converter registry . add converter ( new object to collection converter ( conversion service ) ) ; if ( stream available ) { converter registry . add converter ( new stream converter ( conversion service ) ) ; } }
public resource create relative ( string relative path ) { string path to use = string utils . apply relative path ( this . path , relative path ) ; return new class path resource ( path to use , this . class loader , this . clazz ) ; }
public void fatal ( char sequence message ) { this . log . fatal ( message ) ; }
public void debug ( throwable cause , char sequence message ) { this . log . debug ( message , cause ) ; }
public string get format message ( ) { if ( formatted message == null ) { formatted message = format message ( message pattern , parameter ) ; } return formatted message ; }
public server http request apply ( server http request request ) { if ( have forward header ( request ) ) { server http request . builder builder = request . mutate ( ) ; if ( ! this . remove only ) { uri uri = uri component builder . from http request ( request ) . build ( true ) . to uri ( ) ; builder . uri ( uri ) ; string prefix = get forward prefix ( request ) ; if ( prefix ! = null ) { builder . path ( prefix + uri . get raw path ( ) ) ; builder . context path ( prefix ) ; } } remove forwarded header ( builder ) ; request = builder . build ( ) ; } return request ; }
public static reactive type descriptor no value ( class < ? > type , supplier < ? > empty supplier ) { return new reactive type descriptor ( type , false , true , empty supplier ) ; }
public static void have length ( string text , string message ) { if ( ! string utils . have length ( text ) ) { throw new illegal argument exception ( message ) ; } }
public static < t > comparator < t > null low ( comparator < t > comparator ) { return new null safe comparator < > ( comparator , true ) ; }
public boolean be concrete ( ) { return ! be wildcard type ( ) & & ! be wildcard subtype ( ) ; }
public static void close ( closeable . . . object ) throw i o exception { throwable th = null ; for ( closeable object : object ) { try { if ( object ! = null ) { object . close ( ) ; } } catch ( throwable t ) { add suppress ( th , t ) ; if ( th == null ) { th = t ; } } } re throw ( th ) ; }
public stop watch reset ( ) { current elapse nanos = 0 ; be start = false ; return this ; }
public long get last task time nanos ( ) throw illegal state exception { if ( this . last task info == null ) { throw new illegal state exception ( `` no task run : ca n't get last task interval `` ) ; } return this . last task info . get time nanos ( ) ; }
public string pretty print ( ) { string builder sb = new string builder ( short summary ( ) ) ; sb . append ( '\n ' ) ; if ( ! this . keep task list ) { sb . append ( `` no task info keep `` ) ; } else { sb . append ( `` -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -\n `` ) ; sb . append ( `` m % task name\n `` ) ; sb . append ( `` -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -\n `` ) ; number format nf = number format . get number instance ( ) ; nf . set minimum integer digit ( 5 ) ; nf . set group use ( false ) ; number format pf = number format . get percent instance ( ) ; pf . set minimum integer digit ( 3 ) ; pf . set group use ( false ) ; for ( task info task : get task info ( ) ) { sb . append ( nf . format ( task . get time millis ( ) ) ) . append ( `` `` ) ; sb . append ( pf . format ( task . get time second ( ) / get total time second ( ) ) ) . append ( `` `` ) ; sb . append ( task . get task name ( ) ) . append ( `` \n `` ) ; } } return sb . to string ( ) ; }
private long low bound ( final long key ) { return low bound ( key , time unit . nanosecond . convert ( start time , start unit time ) , chunk size , collision_buffer_power ) ; }
public long to terabyte ( ) { return this . bytes / bytes_per_tb ; }
public static int to int ( type converter type converter , type value type value ) { return ( integer ) type converter . convert value ( typed value . get value ( ) , type value . get type descriptor ( ) , type descriptor . value of ( integer . class ) ) ; }
public static string normalize class name ( class type ) { if ( ! type . be array ( ) ) return type . get name ( ) ; string buffer class name = new string buffer ( ) ; try { class name . append ( get array base type ( type ) . get name ( ) + `` `` ) ; for ( int i = 0 ; i < get array dimension ( type ) ; i++ ) class name . append ( `` [ ] `` ) ; } catch ( reflect error e ) { / * should n't happen * / } return class name . to string ( ) ; }
public boolean type value get value internal ( expression state state ) throw evaluation exception { spel node impl leave op = get leave operand ( ) ; spel node impl right op = get right operand ( ) ; object leave = left op . get value ( state , string . class ) ; object right = get right operand ( ) . get value internal ( state ) . get value ( ) ; if ( ! ( left instanceof string ) ) { throw new spel evaluation exception ( left op . get start position ( ) , spel message . invalid_first_operand_for_matches_operator , leave ) ; } if ( ! ( right instanceof string ) ) { throw new spel evaluation exception ( right op . get start position ( ) , spel message . invalid_second_operand_for_matches_operator , right ) ; } try { string leave string = ( string ) leave ; string right string = ( string ) right ; pattern pattern = this . pattern cache . get ( right string ) ; if ( pattern == null ) { pattern = pattern . compile ( right string ) ; this . pattern cache . put if absent ( right string , pattern ) ; } matcher matcher = pattern . matcher ( left string ) ; return boolean typed value . for value ( matcher . match ( ) ) ; } catch ( pattern syntax exception ex ) { throw new spel evaluation exception ( right op . get start position ( ) , ex , spel message . invalid_pattern , right ) ; } }
protect object do invoke ( method invocation invocation , @ nullable object port stub ) throw throwable { method method = invocation . get method ( ) ; try { return method . invoke ( port stub , invocation . get argument ( ) ) ; } catch ( invocation target exception ex ) { throw ex . get target exception ( ) ; } catch ( throwable ex ) { throw new remote proxy failure exception ( `` invocation of stub method fail : `` + method , ex ) ; } }
protect method find getter for property ( string property name , class < ? > clazz , boolean must be static ) { method method = find method for property ( get property method suffix ( property name ) , `` get `` , clazz , must be static , 0 , any_types ) ; if ( method == null ) { method = find method for property ( get property method suffix ( property name ) , `` be `` , clazz , must be static , 0 , boolean_types ) ; } return method ; }
protect string get property method suffix ( string property name ) { if ( property name . length ( ) > 1 & & character . be upper case ( property name . char at ( 1 ) ) ) { return property name ; } return string utils . capitalize ( property name ) ; }
public spel message get message code ( ) { return this . message ; }
public static data bind property accessor for read write access ( ) { return new data bind property accessor ( true ) ; }
public static void revert to interpret ( expression expression ) { if ( expression instanceof spel expression ) { ( ( spel expression ) expression ) . revert to interpret ( ) ; } }
public simple name get pattern variable ( ) { support only in15 ( ) ; unsupported without preview error ( ) ; return this . pattern variable ; }
public static i classpath entry new source entry ( i path path ) { return new source entry ( path , classpath entry . include_all , classpath entry . exclude_none , null / * output location * / ) ; }
public static string get option ( string option name ) { return java model manager . get java model manager ( ) . get option ( option name ) ; }
public static string get option ( string option name ) { return java model manager . get java model manager ( ) . get option ( option name ) ; }
public synchronize long get max size ( ) { return ( long ) this . f page table . length * database . chunk_size ; }
public static int get chunk need for byte ( long datasize ) { return divide round up ( datasize + block_header_size + large block . header_size + large block . footer_size , chunk_size ) ; }
public void set source name override ( char [ ] source name ) { char [ ] old source name = get source name ( ) ; if ( ! char array utils . equal ( old source name , source name ) ) { inner_class_source_name . put ( get nd ( ) , this . address , source name ) ; } }
public i string get variable identifier ( ) { return variable_identifier . get ( get nd ( ) , this . address ) ; }
public int get declaration position ( ) { return declaration_position . get ( get nd ( ) , get address ( ) ) ; }
public static int nb tree ( int num map , int num tree , int partition ) { int nb tree = num tree / num map ; if ( partition == 0 ) { nb tree += num tree - nb tree * num map ; } return nb tree ; }
public void read to token ( int tok , int offset ) throw core exception { set offset ( offset ) ; read to token ( tok ) ; }
public jdbc user detail manager configurer < b > user by username query ( string query ) { get user detail service ( ) . set user by username query ( query ) ; return this ; }
public jdbc user detail manager configurer < b > role prefix ( string role prefix ) { get user detail service ( ) . set role prefix ( role prefix ) ; return this ; }
public http basic configurer < http security > http basic ( ) throw exception { return get or apply ( new http basic configurer < > ( ) ) ; }
public form login configurer < http security > form login ( ) throw exception { return get or apply ( new form login configurer < > ( ) ) ; }
public web security post build action ( runnable post build action ) { this . post build action = post build action ; return this ; }
public method interceptor method security interceptor ( method security metadata source method security metadata source ) { this . method security interceptor = be aspect j ( ) ? new aspect j method security interceptor ( ) : new method security interceptor ( ) ; this . method security interceptor . set access decision manager ( access decision manager ( ) ) ; this . method security interceptor . set after invocation manager ( after invocation manager ( ) ) ; this . method security interceptor . set security metadata source ( method security metadata source ) ; run a manager run a manager = run a manager ( ) ; if ( run a manager ! = null ) { this . method security interceptor . set run a manager ( run a manager ) ; } return this . method security interceptor ; }
public t login process url ( string login process url ) { this . login process url = login process url ; this . auth filter . set require authentication request matcher ( create login process url matcher ( login process url ) ) ; return get self ( ) ; }
public t login process url ( string login process url ) { this . login process url = login process url ; this . auth filter . set require authentication request matcher ( create login process url matcher ( login process url ) ) ; return get self ( ) ; }
public t login process url ( string login process url ) { this . login process url = login process url ; this . auth filter . set require authentication request matcher ( create login process url matcher ( login process url ) ) ; return get self ( ) ; }
public t login process url ( string login process url ) { this . login process url = login process url ; this . auth filter . set require authentication request matcher ( create login process url matcher ( login process url ) ) ; return get self ( ) ; }
public content security policy config content security policy ( string policy directive ) { this . content security policy . writer = new content security policy header writer ( policy directive ) ; return this . content security policy ; }
public logout configurer < h > logout url ( string logout url ) { this . logout request matcher = null ; this . logout url = logout url ; return this ; }
public o auth2 login configurer < b > authorization endpoint ( customizer < authorization endpoint config > authorization endpoint customizer ) { authorization endpoint customizer . customize ( this . authorization endpoint config ) ; return this ; }
public object invoke ( method invocation mi ) throw throwable { interceptor status token token = super . before invocation ( mi ) ; object result ; try { result = mi . proceed ( ) ; } finally { super . finally invocation ( token ) ; } return super . after invocation ( token , result ) ; }
public boolean await read complete ( long timeout , time unit unit ) { return true ; }
public void handle ( callback callback , authentication authentication ) { if ( callback instanceof name callback ) { ( ( name callback ) callback ) . set name ( get user name ( authentication ) ) ; } }
public static security context get context ( ) { return strategy . get context ( ) ; }
protected list < grant authority > load user authority ( string username ) { return get jdbc template ( ) . query ( this . authority by username query , new string [ ] { username } , ( r , row num ) - > { string role name = jdbc dao impl . this . role prefix + r . get string ( 2 ) ; return new simple grant authority ( role name ) ; } ) ; }
public static byte [ ] encode sensitive string to utf8 ( char [ ] str ) { charset encoder charset encoder = charset . for name ( `` utf-8 `` ) . new encoder ( ) ; byte buffer utf8 buffer = byte buffer . allocate ( ( int ) ( str . length * charset encoder . max bytes per char ( ) ) ) ; assert utf8 buffer . have array ( ) ; charset encoder . encode ( char buffer . wrap ( str ) , utf8 buffer , true ) ; array . fill ( str , ' ' ) ; byte [ ] utf8 byte = new byte [ utf8 buffer . position ( ) ] ; system . arraycopy ( utf8 buffer . array ( ) , 0 , utf8 byte , 0 , utf8 byte . length ) ; array . fill ( utf8 buffer . array ( ) , ( byte ) 0 ) ; return utf8 byte ; }
public string get registration id ( ) { return this . registration id ; }
public void set save request matcher ( server web exchange matcher save request matcher ) { assert . not null ( save request matcher , `` save request matcher can not be null `` ) ; this . save request matcher = save request matcher ; }
public @ nullable instant get expire at ( ) { return this . expire at ; }
public void set default target url ( string default target url ) { assert . be true ( url utils . be valid redirect url ( default target url ) , `` default target must start with '/ ' or with 'http ( s ) ' `` ) ; this . default target url = default target url ; }
protect string determine target url ( http servlet request request , http servlet response response , authentication authentication ) { return determine target url ( request , response ) ; }
protect boolean require logout ( http servlet request request , http servlet response response ) { if ( this . logout request matcher . match ( request ) ) { return true ; } if ( this . logger . be trace enable ( ) ) { this . logger . trace ( log message . format ( `` do not match request to % s `` , this . logout request matcher ) ) ; } return false ; }
public void set exception if variable miss ( boolean exception if variable miss ) { this . exception if variable miss = exception if variable missing ; }
protect void cancel cookie ( http servlet request request , http servlet response response ) { this . logger . debug ( `` cancel cookie `` ) ; cookie cookie = new cookie ( this . cookie name , null ) ; cookie . set max age ( 0 ) ; cookie . set path ( get cookie path ( request ) ) ; if ( this . cookie domain ! = null ) { cookie . set domain ( this . cookie domain ) ; } cookie . set secure ( ( this . use secure cookie ! = null ) ? this . use secure cookie : request . be secure ( ) ) ; response . add cookie ( cookie ) ; }
public string get new session id ( ) { return this . new session id ; }
public void set default failure url ( string default failure url ) { assert . be true ( url utils . be valid redirect url ( default failure url ) , ( ) - > `` ' `` + default failure url + `` ' be not a valid redirect url `` ) ; this . default failure url = default failure url ; }
public void set switch user matcher ( request matcher switch user matcher ) { assert . not null ( switch user matcher , `` switch user matcher can not be null `` ) ; this . switch user matcher = switch user matcher ; }
public void set switch authority role ( string switch authority role ) { assert . not null ( switch authority role , `` switch authority role can not be null `` ) ; this . switch authority role = switch authority role ; }
public void set username parameter ( string username parameter ) { assert . have text ( username parameter , `` username parameter must not be empty or null `` ) ; this . username parameter = username parameter ; }
public string get request url ( ) { return url utils . build request url ( this . request ) ; }
public void set allow url encode double slash ( boolean allow url encode double slash ) { if ( allow url encode double slash ) { url blocklists remove all ( forbidden_double_forwardslash ) ; } else { url blocklists add all ( forbidden_double_forwardslash ) ; } }
public string get remote user ( ) { authentication auth = get authentication ( ) ; if ( ( auth == null ) || ( auth . get principal ( ) == null ) ) { return null ; } if ( auth . get principal ( ) instanceof user detail ) { return ( ( user detail ) auth . get principal ( ) ) . get username ( ) ; } return auth . get principal ( ) . to string ( ) ; }
public void set authentication success handler ( server authentication success handler authentication success handler ) { assert . not null ( authentication success handler , `` authentication success handler can not be null `` ) ; this . authentication success handler = authentication success handler ; }
public void set cookie name ( string cookie name ) { assert . have length ( cookie name , `` cookie name ca n't be null `` ) ; this . cookie name = cookie name ; }
public void set cookie name ( string cookie name ) { assert . have length ( cookie name , `` cookie name ca n't be null `` ) ; this . cookie name = cookie name ; }
public void set cookie path ( string cookie path ) { this . cookie path = cookie path ; }
public evaluation context get evaluation context ( ) { if ( this . evaluation context == null ) { this . evaluation context = new standard evaluation context ( ) ; } return this . evaluation context ; }
public string get body a string ( ) { return get body a string ( default_charset ) ; }
protect void check active ( ) throw illegal state exception { assert . state ( this . active , `` request be not active anymore `` ) ; }
public mock http servlet request builder request attr ( string name , object value ) { add to map ( this . request attribute , name , value ) ; return this ; }
public string change session id ( ) { this . id = integer . to string ( next id++ ) ; return this . id ; }
public string change session id ( ) { this . id = integer . to string ( next id++ ) ; return this . id ; }
public class < ? > [ ] get class ( ) { return this . class ; }
protect int count row in table ( string table name ) { return jdbc test utils . count row in table ( this . jdbc template , table name ) ; }
protect int count row in table ( string table name ) { return jdbc test utils . count row in table ( this . jdbc template , table name ) ; }
protect int count row in table ( string table name ) { return jdbc test utils . count row in table ( this . jdbc template , table name ) ; }
public description get description ( ) { if ( ! profile value utils . be test enable in this environment ( get test class ( ) . get java class ( ) ) ) { return description . create suite description ( get test class ( ) . get java class ( ) ) ; } return super . get description ( ) ; }
protect void init lifecycle processor ( ) { configurable listable bean factory bean factory = get bean factory ( ) ; if ( bean factory . contain local bean ( lifecycle_processor_bean_name ) ) { this . lifecycle processor = bean factory . get bean ( lifecycle_processor_bean_name , lifecycle processor . class ) ; if ( logger . be debug enable ( ) ) { logger . debug ( `` use lifecycle processor [ `` + this . lifecycle processor + `` ] `` ) ; } } else { default lifecycle processor default processor = new default lifecycle processor ( ) ; default processor . set bean factory ( bean factory ) ; this . lifecycle processor = default processor ; bean factory . register singleton ( lifecycle_processor_bean_name , this . lifecycle processor ) ; if ( logger . be debug enable ( ) ) { logger . debug ( `` unable to locate lifecycle processor with name ' `` + lifecycle_processor_bean_name + `` ' : use default [ `` + this . lifecycle processor + `` ] `` ) ; } } }
public static void start ( ) { require current transaction context ( ) . start transaction ( ) ; }
public void prepare test instance ( test context test context ) throw exception { if ( logger . be debug enable ( ) ) { logger . debug ( `` perform dependency injection for test context [ `` + test context + `` ] . `` ) ; } inject dependency ( test context ) ; }
public < t > request matcher value ( matcher < t > matcher ) { return new abstract json path request matcher ( ) { @ override protect void match internal ( mock client http request request ) throw i o exception , parse exception { json path request matcher . this . json path helper . assert value ( request . get body a string ( ) , matcher ) ; } } ; }
public request matcher have json path ( ) { return new abstract json path request matcher ( ) { @ override protect void match internal ( mock client http request request ) { json path request matcher . this . json path helper . have json path ( request . get body a string ( ) ) ; } } ; }
public static request matcher query param ( string name , matcher < ? super string > . . . matcher ) { return request - > { multi value map < string , string > params = get query params ( request ) ; assert value count ( `` query param `` , name , params , matcher . length ) ; for ( int i = 0 ; i < matcher . length ; i++ ) { assert that ( `` query param `` , params . get ( name ) . get ( i ) , matcher [ i ] ) ; } } ; }
public request matcher have json path ( ) { return new abstract json path request matcher ( ) { @ override protect void match internal ( mock client http request request ) { json path request matcher . this . json path helper . have json path ( request . get body a string ( ) ) ; } } ; }
public request matcher node count ( int expect count ) { return ( xpath request matcher ) request - > this . xpath helper . assert node count ( request . get body a byte ( ) , default_encoding , expect count ) ; }
public request matcher string ( string content ) { return ( xpath request matcher ) request - > this . xpath helper . assert string ( request . get body a byte ( ) , default_encoding , content ) ; }
public static void assert view name ( model and view mav , string expect name ) { assert true ( `` view name be not equal to ' `` + expect name + `` ' but be ' `` + mav . get view name ( ) + `` ' `` , object utils . null safe equal ( expect name , mav . get view name ( ) ) ) ; }
public web test client . response spec expire ( long expires ) { return assert header ( `` expire `` , expire , get header ( ) . get expires ( ) ) ; }
public < t > web test client . body content spec value ( consumer < t > consumer ) { object value = this . path helper . evaluate json path ( this . content ) ; consumer . accept ( ( t ) value ) ; return this . body spec ; }
public web test client . response spec is4xx client error ( ) { return assert series and return ( http status . series . client_error ) ; }
public web test client . response spec value ( matcher < integer > matcher ) { int value = this . exchange result . get status ( ) . value ( ) ; this . exchange result . assert with diagnostics ( ( ) - > matcher assert . assert that ( `` response status `` , value , matcher ) ) ; return this . response spec ; }
public mock http servlet request builder context path ( string context path ) { if ( string utils . have text ( context path ) ) { assert . be true ( context path . start with ( `` / `` ) , `` context path must start with a '/ ' `` ) ; assert . be true ( ! context path . end with ( `` / `` ) , `` context path must not end with a '/ ' `` ) ; } this . context path = context path ; return this ; }
public mock http servlet request builder request attr ( string name , object value ) { add to map ( this . request attribute , name , value ) ; return this ; }
public request matcher content type ( string expect content type ) { return content type ( medium type . parse medium type ( expect content type ) ) ; }
public result matcher content type ( string content type ) { return content type ( medium type . parse medium type ( content type ) ) ; }
public result matcher do not exist ( string name ) { return result - > { cookie cookie = result . get response ( ) . get cookie ( name ) ; assert null ( `` unexpected cookie with name ' `` + name + `` ' `` , cookie ) ; } ; }
public result matcher value ( string name , string expect value ) { return result - > { cookie cookie = get cookie ( result , name ) ; assert equal ( `` response cookie `` , expect value , cookie . get value ( ) ) ; } ; }
public result matcher do not exist ( string name ) { return result - > { cookie cookie = result . get response ( ) . get cookie ( name ) ; assert null ( `` unexpected cookie with name ' `` + name + `` ' `` , cookie ) ; } ; }
public result matcher string ( string name , string value ) { return result - > assert equal ( `` response header ' `` + name + `` ' `` , value , result . get response ( ) . get header ( name ) ) ; }
public result matcher be array ( ) { return result - > this . json path helper . assert value be array ( get content ( result ) ) ; }
public result matcher be array ( ) { return result - > this . json path helper . assert value be array ( get content ( result ) ) ; }
public static request matcher header ( string name , string . . . expect value ) { return request - > { assert value count ( `` header `` , name , request . get header ( ) , expect value . length ) ; list < string > header value = request . get header ( ) . get ( name ) ; assert . state ( header value ! = null , `` no header value `` ) ; for ( int i = 0 ; i < expect value . length ; i++ ) { assert equal ( `` request header [ `` + name + `` ] `` , expect value [ i ] , header value . get ( i ) ) ; } } ; }
public static body builder method ( string method , string url template , object . . . var ) { uri url = uri component builder . from uri string ( url template ) . build and expand ( var ) . encode ( ) . to uri ( ) ; return new default body builder ( method , url ) ; }
public static body builder method ( string method , string url template , object . . . var ) { uri url = uri component builder . from uri string ( url template ) . build and expand ( var ) . encode ( ) . to uri ( ) ; return new default body builder ( method , url ) ; }
public static cookie result matcher cookie ( ) { return new cookie result matcher ( ) ; }
public result matcher have error ( ) { return result - > { int count = get error count ( get model and view ( result ) . get model map ( ) ) ; assert true ( `` expect binding/validation error `` , count ! = 0 ) ; } ; }
public standalone mock mvc builder set custom argument resolvers ( handler method argument resolver . . . argument resolvers ) { this . custom argument resolvers = arrays . a list ( argument resolvers ) ; return this ; }
public standalone mock mvc builder set locale resolver ( locale resolver locale resolver ) { this . locale resolver = locale resolver ; return this ; }
public standalone mock mvc builder set use trail slash pattern match ( boolean use trail slash pattern match ) { this . use trail slash pattern match = use trail slash pattern match ; return this ; }
public void before test class ( ) throw exception { class < ? > test class = get test context ( ) . get test class ( ) ; if ( logger . be trace enable ( ) ) { logger . trace ( `` before test class ( ) : class [ `` + test class . get name ( ) + `` ] `` ) ; } get test context ( ) . update state ( null , null , null ) ; for ( test execution listener test execution listener : get test execution listener ( ) ) { try { test execution listener . before test class ( get test context ( ) ) ; } catch ( throwable ex ) { log exception ( ex , `` before test class `` , test execution listener , test class ) ; reflection utils . rethrow exception ( ex ) ; } } }
public web test client . response spec domain ( string name , string expect ) { string path = get cookie ( name ) . get domain ( ) ; this . exchange result . assert with diagnostics ( ( ) - > { string message = get message ( name ) + `` domain `` ; assertion error . assert equal ( message , expect , path ) ; } ) ; return this . response spec ; }
public web test client . response spec value equal ( string header name , string . . . value ) { return assert header ( header name , arrays . a list ( value ) , get header ( ) . get ( header name ) ) ; }
public static cache control no store ( ) { cache control cc = new cache control ( ) ; cc . no store = true ; return cc ; }
public multipart builder add form data part ( string name , string value ) { return add form data part ( name , null , request body . create ( null , value ) ) ; }
public void set request factory ( client http request factory request factory ) { assert . not null ( request factory , `` client http request factory must not be null `` ) ; this . request factory = request factory ; }
public list < org . springframework . http . client . async client http request interceptor > get interceptor ( ) { return this . interceptor ; }
public list < org . springframework . http . client . async client http request interceptor > get interceptor ( ) { return this . interceptor ; }
public void set max in memory size ( int max in memory size ) { this . max in memory size = max in memory size ; }
protect void init reader ( ) { init type reader ( ) ; init object reader ( ) ; }
public string to string ( ) { string builder sb = new string builder ( ) ; if ( this . type ! = null ) { sb . append ( this . type ) ; } if ( this . name ! = null ) { sb . append ( `` ; name=\ `` `` ) ; sb . append ( this . name ) . append ( '\ `` ' ) ; } if ( this . filename ! = null ) { if ( this . charset == null || standard charsets . us_ascii . equal ( this . charset ) ) { sb . append ( `` ; filename=\ `` `` ) ; sb . append ( escape quotation in filename ( this . filename ) ) . append ( '\ `` ' ) ; } else { sb . append ( `` ; filename * = `` ) ; sb . append ( encode filename ( this . filename , this . charset ) ) ; } } if ( this . size ! = null ) { sb . append ( `` ; size= `` ) ; sb . append ( this . size ) ; } if ( this . creation date ! = null ) { sb . append ( `` ; creation-date=\ `` `` ) ; sb . append ( rfc_1123_date_time . format ( this . creation date ) ) ; sb . append ( '\ `` ' ) ; } if ( this . modification date ! = null ) { sb . append ( `` ; modification-date=\ `` `` ) ; sb . append ( rfc_1123_date_time . format ( this . modification date ) ) ; sb . append ( '\ `` ' ) ; } if ( this . read date ! = null ) { sb . append ( `` ; read-date=\ `` `` ) ; sb . append ( rfc_1123_date_time . format ( this . read date ) ) ; sb . append ( '\ `` ' ) ; } return sb . to string ( ) ; }
public void set part converter ( list < http message converter < ? > > part converter ) { assert . not empty ( part converter , `` 'part converter ' must not be empty `` ) ; this . part converter = part converter ; }
public jackson2 object mapper builder module to install ( class < ? extend module > . . . module ) { this . module class = module ; this . find well know module = true ; return this ; }
public jackson2 object mapper builder feature to disable ( object . . . feature to disable ) { for ( object feature : feature to disable ) { this . feature . put ( feature , boolean . false ) ; } return this ; }
public long get content length ( ) { string value = get first ( content_length ) ; return ( value ! = null ? long . parse long ( value ) : -1 ) ; }
public medium type get medium type for resource ( resource resource ) { medium type medium type = null ; string mime type = this . servlet context . get mime type ( resource . get filename ( ) ) ; if ( string utils . have text ( mime type ) ) { medium type = medium type . parse medium type ( mime type ) ; } if ( medium type == null || medium type . application_octet_stream . equal ( medium type ) ) { medium type super medium type = super . get medium type for resource ( resource ) ; if ( super medium type ! = null ) { medium type = super medium type ; } } return medium type ; }
public static body builder put ( string uri template , object . . . uri variable ) { return method ( http method . put , uri template , uri variable ) ; }
public void set connect timeout ( long timeout ) { this . proxy factory . set connect timeout ( timeout ) ; }
protect object input stream create object input stream ( input stream be ) throw i o exception { return new codebase aware object input stream ( be , get bean class loader ( ) , be accept proxy class ( ) ) ; }
public void set http invoker request executor ( http invoker request executor http invoker request executor ) { this . http invoker request executor = http invoker request executor ; }
protect endpoint create endpoint ( object bean ) { return ( this . endpoint feature ! = null ? endpoint . create ( this . bind type , bean , this . endpoint feature ) : endpoint . create ( this . bind type , bean ) ) ; }
protect endpoint create endpoint ( object bean ) { return ( this . endpoint feature ! = null ? endpoint . create ( this . bind type , bean , this . endpoint feature ) : endpoint . create ( this . bind type , bean ) ) ; }
public void set soap action uri ( @ nullable string soap action uri ) { this . soap action uri = soap action uri ; }
protect object get port stub ( service service , @ nullable q name port q name ) { if ( this . port feature ! = null ) { return ( port q name ! = null ? service . get port ( port q name , get service interface ( ) , this . port feature ) : service . get port ( get service interface ( ) , this . port feature ) ) ; } else { return ( port q name ! = null ? service . get port ( port q name , get service interface ( ) ) : service . get port ( get service interface ( ) ) ) ; } }
public void set bean class loader ( @ nullable class loader class loader ) { this . bean class loader = class loader ; }
protect object get port stub ( service service , @ nullable q name port q name ) { if ( this . port feature ! = null ) { return ( port q name ! = null ? service . get port ( port q name , get service interface ( ) , this . port feature ) : service . get port ( get service interface ( ) , this . port feature ) ) ; } else { return ( port q name ! = null ? service . get port ( port q name , get service interface ( ) ) : service . get port ( get service interface ( ) ) ) ; } }
public void set wsdl document url ( @ nullable url wsdl document url ) { this . wsdl document url = wsdl document url ; }
public void set default content type ( medium type content type ) { this . default negotiation strategy = new fix content negotiation strategy ( content type ) ; }
public final string get variable name ( ) { return this . variable name ; }
public static int get int parameter ( servlet request request , string name , int default val ) { if ( request . get parameter ( name ) == null ) { return default val ; } try { return get require int parameter ( request , name ) ; } catch ( servlet request bind exception ex ) { return default val ; } }
protect void register session destruction callback ( string name , runnable callback ) { http session session = obtain session ( ) ; session . set attribute ( destruction_callback_name_prefix + name , new destruction callback bind listener ( callback ) ) ; }
protect void do bind ( mutable property value mpvs ) { check field default ( mpvs ) ; check field marker ( mpvs ) ; super . do bind ( mpvs ) ; }
public boolean be bind empty multipart file ( ) { return this . bind empty multipart file ; }
protect async task executor determine async executor ( method method ) { async task executor executor = this . executor . get ( method ) ; if ( executor == null ) { executor target executor ; string qualifier = get executor qualifier ( method ) ; if ( string utils . have length ( qualifier ) ) { target executor = find qualified executor ( this . bean factory , qualifier ) ; } else { target executor = this . default executor ; if ( target executor == null ) { synchronize ( this . executor ) { if ( this . default executor == null ) { this . default executor = get default executor ( this . bean factory ) ; } target executor = this . default executor ; } } } if ( target executor == null ) { return null ; } executor = ( target executor instanceof async listenable task executor ? ( async listenable task executor ) target executor : new task executor adapter ( target executor ) ) ; this . executor . put ( method , executor ) ; } return executor ; }
public static void reset request attribute ( ) { request attribute holder . remove ( ) ; inheritable request attribute holder . remove ( ) ; }
public final message source get message source ( ) { return this . web application context ; }
public void set config location ( string . . . location ) { if ( location ! = null ) { assert . no null element ( location , `` config location must not be null `` ) ; this . config location = new string [ location . length ] ; for ( int i = 0 ; i < location . length ; i++ ) { this . config location [ i ] = resolve path ( location [ i ] ) . trim ( ) ; } } else { this . config location = null ; } }
public resource create relative ( string relative path ) { string path to use = string utils . apply relative path ( this . path , relative path ) ; return new servlet context resource ( this . servlet context , path to use ) ; }
public resource create relative ( string relative path ) { string path to use = string utils . apply relative path ( this . path , relative path ) ; return new servlet context resource ( this . servlet context , path to use ) ; }
protect boolean be include payload ( ) { return this . include payload ; }
public void set after message suffix ( string after message suffix ) { this . after message suffix = after message suffix ; }
public string get element styling ( org . w3c . dom . element e ) { string buffer style = new string buffer ( ) ; if ( e . get node name ( ) . equal ( `` td `` ) || e . get node name ( ) . equal ( `` th `` ) ) { string s ; s = get attribute ( e , `` colspan `` ) ; if ( s ! = null ) { style . append ( `` -fs-table-cell-colspan : `` ) ; style . append ( s ) ; style . append ( `` ; `` ) ; } s = get attribute ( e , `` rowspan `` ) ; if ( s ! = null ) { style . append ( `` -fs-table-cell-rowspan : `` ) ; style . append ( s ) ; style . append ( `` ; `` ) ; } } else if ( e . get node name ( ) . equal ( `` img `` ) ) { string s ; s = get attribute ( e , `` width `` ) ; if ( s ! = null ) { style . append ( `` width : `` ) ; style . append ( convert to length ( s ) ) ; style . append ( `` ; `` ) ; } s = get attribute ( e , `` height `` ) ; if ( s ! = null ) { style . append ( `` height : `` ) ; style . append ( convert to length ( s ) ) ; style . append ( `` ; `` ) ; } } else if ( e . get node name ( ) . equal ( `` colgroup `` ) || e . get node name ( ) . equal ( `` col `` ) ) { string s ; s = get attribute ( e , `` span `` ) ; if ( s ! = null ) { style . append ( `` -fs-table-cell-colspan : `` ) ; style . append ( s ) ; style . append ( `` ; `` ) ; } s = get attribute ( e , `` width `` ) ; if ( s ! = null ) { style . append ( `` width : `` ) ; style . append ( convert to length ( s ) ) ; style . append ( `` ; `` ) ; } } style . append ( e . get attribute ( `` style `` ) ) ; return style . to string ( ) ; }
public void set bean name ( string bean name ) { this . bean name = bean name ; }
protect void set closure delegate ( closure closure , object node ) { closure . set delegate ( this ) ; }
protect double get domain low bound ( double p ) { return 0 ; }
public medium type get content type ( ) { return this . content type ; }
protect navigation handler get delegate ( face context face context ) { string target bean name = get target bean name ( face context ) ; return get bean factory ( face context ) . get bean ( target bean name , navigation handler . class ) ; }
protect navigation handler get delegate ( face context face context ) { string target bean name = get target bean name ( face context ) ; return get bean factory ( face context ) . get bean ( target bean name , navigation handler . class ) ; }
public object get bean ( ) { return this . bean ; }
public method get method ( ) { return this . method ; }
public void set redirect model scenario ( boolean redirect model scenario ) { this . redirect model scenario = redirect model scenario ; }
public model and view container add attribute ( string name , @ nullable object value ) { get model ( ) . add attribute ( name , value ) ; return this ; }
public string to string ( ) { string builder sb = new string builder ( `` model and view container : `` ) ; if ( ! be request handle ( ) ) { if ( be view reference ( ) ) { sb . append ( `` reference to view with name ' `` ) . append ( this . view ) . append ( `` ' `` ) ; } else { sb . append ( `` view be [ `` ) . append ( this . view ) . append ( ' ] ' ) ; } if ( use default model ( ) ) { sb . append ( `` ; default model `` ) ; } else { sb . append ( `` ; redirect model `` ) ; } sb . append ( get model ( ) ) ; } else { sb . append ( `` request handle directly `` ) ; } return sb . to string ( ) ; }
public model and view container add attribute ( string name , @ nullable object value ) { get model ( ) . add attribute ( name , value ) ; return this ; }
public model and view container add attribute ( string name , @ nullable object value ) { get model ( ) . add attribute ( name , value ) ; return this ; }
public void set request handle ( boolean request handle ) { this . request handle = request handle ; }
public void set max upload size per file ( long max upload size per file ) { this . file upload . set file size max ( max upload size per file ) ; }
public void write ( ) { throw new illegal state exception ( `` writing be not yet implement for this document format `` ) ; }
protect string get multipart resolver bean name ( ) { return this . multipart resolver bean name ; }
protect void initialize definition ( bean factory group def ) { if ( group def instanceof configurable application context ) { ( ( configurable application context ) group def ) . refresh ( ) ; } }
public boolean contains ( final object obj ) { for ( final collection < e > item : all ) { if ( item . contains ( obj ) ) { return true ; } } return false ; }
protect int determine raw status code ( throwable ex ) { if ( ex instanceof response status exception ) { return ( ( response status exception ) ex ) . get raw status code ( ) ; } return -1 ; }
public list < locale > get support locale ( ) { return this . supported locale ; }
public void remove expire session ( ) { this . expired session checker . remove expired session ( this . clock . instant ( ) ) ; }
public void add cookie ( http servlet response response , string cookie value ) { assert . not null ( response , `` http servlet response must not be null `` ) ; cookie cookie = create cookie ( cookie value ) ; integer max age = get cookie max age ( ) ; if ( max age ! = null ) { cookie . set max age ( max age ) ; } if ( be cookie secure ( ) ) { cookie . set secure ( true ) ; } if ( be cookie http only ( ) ) { cookie . set http only ( true ) ; } response . add cookie ( cookie ) ; if ( logger . be trace enable ( ) ) { logger . trace ( `` add cookie [ `` + get cookie name ( ) + `` = `` + cookie value + `` ] `` ) ; } }
public boolean be case sensitive ( ) { return this . case sensitive ; }
public static uri component builder from uri string ( string uri ) { assert . not null ( uri , `` uri must not be null `` ) ; matcher matcher = uri_pattern . matcher ( uri ) ; if ( matcher . match ( ) ) { uri component builder builder = new uri component builder ( ) ; string scheme = matcher . group ( 2 ) ; string user info = matcher . group ( 5 ) ; string host = matcher . group ( 6 ) ; string port = matcher . group ( 8 ) ; string path = matcher . group ( 9 ) ; string query = matcher . group ( 11 ) ; string fragment = matcher . group ( 13 ) ; boolean opaque = false ; if ( string utils . have length ( scheme ) ) { string rest = uri . substring ( scheme . length ( ) ) ; if ( ! rest . start with ( `` : / `` ) ) { opaque = true ; } } builder . scheme ( scheme ) ; if ( opaque ) { string ssp = uri . substring ( scheme . length ( ) ) . substring ( 1 ) ; if ( string utils . have length ( fragment ) ) { ssp = ssp . substring ( 0 , ssp . length ( ) - ( fragment . length ( ) + 1 ) ) ; } builder . scheme specific part ( ssp ) ; } else { builder . user info ( user info ) ; builder . host ( host ) ; if ( string utils . have length ( port ) ) { builder . port ( port ) ; } builder . path ( path ) ; builder . query ( query ) ; } if ( string utils . have text ( fragment ) ) { builder . fragment ( fragment ) ; } return builder ; } else { throw new illegal argument exception ( `` [ `` + uri + `` ] be not a valid uri `` ) ; } }
public uri component builder scheme specific part ( string ssp ) { this . ssp = ssp ; reset hierarchical component ( ) ; return this ; }
public final list < string > get template variable ( ) { return template variable ; }
public static duration style detect ( string value ) { assert . not null ( value , `` value must not be null `` ) ; for ( duration style candidate : value ( ) ) { if ( candidate . match ( value ) ) { return candidate ; } } throw new illegal argument exception ( `` ' `` + value + `` ' be not a valid duration `` ) ; }
public int last ( ) { return get position ( ) + size ( ) - 1 ; }
public static void copy except ( object src , object dst , int old size , int remove index ) { if ( remove index > 0 & & old size > 0 ) { system . arraycopy ( src , 0 , dst , 0 , remove index ) ; } if ( remove index < old size ) { system . arraycopy ( src , remove index + 1 , dst , remove index , old size - remove index - 1 ) ; } }
protect void init object writer ( ) { this . object writer . clear ( ) ; if ( ! this . register default ) { return ; } this . object writer . add all ( get base object writer ( ) ) ; extend object writer ( this . object writer ) ; }
protect medium type get medium type ( http servlet request request , resource resource ) { medium type result = null ; string mime type = request . get servlet context ( ) . get mime type ( resource . get filename ( ) ) ; if ( string utils . have text ( mime type ) ) { result = medium type . parse medium type ( mime type ) ; } if ( result == null || medium type . application_octet_stream . equal ( result ) ) { medium type medium type = null ; string filename = resource . get filename ( ) ; string ext = string utils . get filename extension ( filename ) ; if ( ext ! = null ) { medium type = this . medium type . get ( ext . to lower case ( locale . english ) ) ; } if ( medium type == null ) { medium type = medium type factory . get medium type ( filename ) . or else ( null ) ; } if ( medium type ! = null ) { result = medium type ; } } return result ; }
public static header builder < ? > head ( string uri template , object . . . uri variable ) { return method ( http method . head , uri template , uri variable ) ; }
public static header builder < ? > delete ( uri url ) { return method ( http method . delete , url ) ; }
protect void subscribe subscriber to stream ( stream http message msg , subscriber < http content > subscriber ) { msg . subscribe ( subscriber ) ; }
public resource chain registration resource chain ( boolean cache resource ) { this . resource chain registration = new resource chain registration ( cache resource ) ; return this . resource chain registration ; }
public url base view resolver registration view name ( string . . . view names ) { this . view resolver . set view name ( view names ) ; return this ; }
protect void set closure delegate ( closure closure , object node ) { closure . set delegate ( this ) ; }
protect void set closure delegate ( closure closure , object node ) { closure . set delegate ( this ) ; }
public void set message writer ( list < http message writer < ? > > configurer ) { this . message writer = configurer ; }
public void set detect handler in ancestor context ( boolean detect handler in ancestor context ) { this . detect handler in ancestor context = detect handler in ancestor context ; }
public set < name value expression < string > > get expression ( ) { return new link hash set < > ( this . expression ) ; }
public set < medium type > get consumable medium type ( ) { set < medium type > result = new link hash set < > ( ) ; for ( consume medium type expression expression : this . expression ) { if ( ! expression . be negated ( ) ) { result . add ( expression . get medium type ( ) ) ; } } return result ; }
protect void detect handler method ( final object handler ) { class < ? > handler type = ( handler instanceof string ? obtain application context ( ) . get type ( ( string ) handler ) : handler . get class ( ) ) ; if ( handler type ! = null ) { final class < ? > user type = class utils . get user class ( handler type ) ; map < method , t > method = method introspector . select method ( user type , ( method introspector . metadata lookup < t > ) method - > get map for method ( method , user type ) ) ; if ( logger . be trace enable ( ) ) { logger . trace ( format mapping ( user type , method ) ) ; } else if ( mapping logger . be debug enable ( ) ) { mapping logger . debug ( format mapping ( user type , method ) ) ; } method . for each ( ( method , map ) - > { method invocable method = aop utils . select invocable method ( method , user type ) ; register handler method ( handler , invocable method , map ) ; } ) ; } }
public reactive adapter registry get reactive adapter registry ( ) { return this . reactive adapter registry ; }
public string [ ] get error code ( ) { return this . error cod ; }
public property editor find editor ( class < ? > value class ) { return ( this . bind result ! = null ? this . bind result . find editor ( this . expression , value class ) : null ) ; }
public string [ ] get error code ( ) { return this . error cod ; }
protect template get template ( locale locale ) throw i o exception { return ( get encode ( ) ! = null ? obtain configuration ( ) . get template ( get url ( ) , locale , get encode ( ) ) : obtain configuration ( ) . get template ( get url ( ) , locale ) ) ; }
protect template get template ( locale locale ) throw i o exception { return ( get encode ( ) ! = null ? obtain configuration ( ) . get template ( get url ( ) , locale , get encode ( ) ) : obtain configuration ( ) . get template ( get url ( ) , locale ) ) ; }
public boolean be propagate query property ( ) { return this . propagate query params ; }
protect abstract url base view create view ( string view name ) { abstract url base view view = instantiate view ( ) ; view . set support medium type ( get support medium type ( ) ) ; view . set default charset ( get default charset ( ) ) ; view . set url ( get prefix ( ) + view name + get suffix ( ) ) ; string request context attribute = get request context attribute ( ) ; if ( request context attribute ! = null ) { view . set request context attribute ( request context attribute ) ; } return view ; }
public string get message ( message source resolvable resolvable ) throw no such message exception { return get message ( resolvable , be default html escape ( ) ) ; }
public bind status get bind status ( string path ) throw illegal state exception { return new bind status ( this , path , be default html escape ( ) ) ; }
public void set view name ( @ nullable string . . . view names ) { this . view name = view name ; }
public void set handle ping ( boolean handle ping ) { this . handle ping = handle ping ; }
public cors registration allow origin ( string . . . origin ) { this . config . set allow origin ( array . a list ( origin ) ) ; return this ; }
public async support configurer set task executor ( async task executor task executor ) { this . task executor = task executor ; return this ; }
protect object get interceptor ( ) { if ( this . include pattern . be empty ( ) & & this . exclude pattern . be empty ( ) ) { return this . interceptor ; } string [ ] include = string utils . to string array ( this . include pattern ) ; string [ ] exclude = string utils . to string array ( this . exclude pattern ) ; map interceptor map interceptor = new map interceptor ( include , exclude , this . interceptor ) ; if ( this . path matcher ! = null ) { mapped interceptor . set path matcher ( this . path matcher ) ; } return map interceptor ; }
protect object get interceptor ( ) { if ( this . include pattern . be empty ( ) & & this . exclude pattern . be empty ( ) ) { return this . interceptor ; } string [ ] include = string utils . to string array ( this . include pattern ) ; string [ ] exclude = string utils . to string array ( this . exclude pattern ) ; map interceptor map interceptor = new map interceptor ( include , exclude , this . interceptor ) ; if ( this . path matcher ! = null ) { mapped interceptor . set path matcher ( this . path matcher ) ; } return map interceptor ; }
public resource handler registration add resource handler ( string . . . path pattern ) { resource handler registration registration = new resource handler registration ( path pattern ) ; this . registration . add ( registration ) ; return registration ; }
public void add status controller ( string url path , http status status code ) { view controller registration registration = new view controller registration ( url path ) ; registration . set application context ( this . application context ) ; registration . set status code ( status code ) ; registration . get view controller ( ) . set status only ( true ) ; this . registration . add ( registration ) ; }
public boolean use suffix pattern match ( ) { return this . use suffix pattern match ; }
protect void cleanup multipart ( http servlet request request ) { if ( this . multipart resolver ! = null ) { multipart http servlet request multipart request = web utils . get native request ( request , multipart http servlet request . class ) ; if ( multipart request ! = null ) { this . multipart resolver . cleanup multipart ( multipart request ) ; } } }
protect handler adapter get handler adapter ( object handler ) throw servlet exception { if ( this . handler adapter ! = null ) { for ( handler adapter adapter : this . handler adapter ) { if ( adapter . support ( handler ) ) { return adapter ; } } } throw new servlet exception ( `` no adapter for handler [ `` + handler + `` ] : the dispatcher servlet configuration need to include a handler adapter that support this handler `` ) ; }
protect handler adapter get handler adapter ( object handler ) throw servlet exception { if ( this . handler adapter ! = null ) { for ( handler adapter adapter : this . handler adapter ) { if ( adapter . support ( handler ) ) { return adapter ; } } } throw new servlet exception ( `` no adapter for handler [ `` + handler + `` ] : the dispatcher servlet configuration need to include a handler adapter that support this handler `` ) ; }
protect string extract operable url ( http servlet request request ) { string url path = ( string ) request . get attribute ( handler mapping . path_within_handler_mapping_attribute ) ; if ( ! string utils . have text ( url path ) ) { url path = get url path helper ( ) . get lookup path for request ( request , handler mapping . lookup_path ) ; } return url path ; }
public string get context config location ( ) { return this . context config location ; }
public void set publish context ( boolean publish context ) { this . publish context = publish context ; }
protect web application context create web application context ( servlet context sc ) { class < ? > context class = determine context class ( sc ) ; if ( ! configurable web application context . class . be assignable from ( context class ) ) { throw new application context exception ( `` custom context class [ `` + context class . get name ( ) + `` ] be not of type [ `` + configurable web application context . class . get name ( ) + `` ] `` ) ; } return ( configurable web application context ) bean utils . instantiate class ( context class ) ; }
public static string get file name ( final inet socket address s , final string pool id , final long block id ) { return s . to string ( ) + `` : `` + pool id + `` : `` + block id ; }
public void cache control ( final cache control cache control ) { get header ( ) . add ( http header . cache_control , cache control ) ; }
protect void init application context ( ) throw bean exception { extend interceptor ( this . interceptor ) ; detect map interceptor ( this . adapted interceptor ) ; init interceptor ( ) ; }
protect void register handler method ( object handler , method method , t map ) { this . mapping registry . register ( mapping , handler , method ) ; }
public void set excluded exception ( class < ? > . . . excluded exception ) { this . excluded exception = excluded exception ; }
public void set default status code ( int default status code ) { this . default status code = default status code ; }
protect model and view get model and view ( string view name , exception ex ) { model and view mv = new model and view ( view name ) ; if ( this . exception attribute ! = null ) { mv . add object ( this . exception attribute , ex ) ; } return mv ; }
protect model and view get model and view ( string view name , exception ex ) { model and view mv = new model and view ( view name ) ; if ( this . exception attribute ! = null ) { mv . add object ( this . exception attribute , ex ) ; } return mv ; }
public void set reject invalid cooky ( boolean reject invalid cooky ) { this . reject invalid cooky = reject invalid cooky ; }
protect locale determine default locale ( http servlet request request ) { locale default locale = get default locale ( ) ; if ( default locale == null ) { default locale = request . get locale ( ) ; } return default locale ; }
protected time zone determine default time zone ( http servlet request request ) { return get default time zone ( ) ; }
public void clear ( ) { this . view = null ; this . model = null ; this . cleared = true ; }
public string get view name ( ) { return ( this . view instanceof string ? ( string ) this . view : null ) ; }
public static string get name for return value ( @ nullable object return value , method parameter return type ) { model attribute ann = return type . get method annotation ( model attribute . class ) ; if ( ann ! = null & & string utils . have text ( ann . value ( ) ) ) { return ann . value ( ) ; } else { method method = return type . get method ( ) ; assert . state ( method ! = null , `` no handler method `` ) ; class < ? > contain class = return type . get contain class ( ) ; class < ? > resolve type = generic type resolver . resolve return type ( method , contain class ) ; return convention . get variable name for return type ( method , resolve type , return value ) ; } }
public void set status code ( @ nullable http status status code ) { this . status code = status code ; }
public void set status code ( @ nullable http status status code ) { this . status code = status code ; }
public void after property set ( ) throw exception { if ( this . servlet class == null ) { throw new illegal argument exception ( `` 'servlet class ' be require `` ) ; } if ( this . servlet name == null ) { this . servlet name = this . bean name ; } this . servlet instance = reflection utils . accessible constructor ( this . servlet class ) . new instance ( ) ; this . servlet instance . init ( new delegate servlet config ( ) ) ; }
public string get request uri ( ) { return this . url path helper . get originate request uri ( this . request ) ; }
protected time zone get fallback time zone ( ) { if ( jstl present ) { time zone time zone = jstl page locale resolver . get jstl time zone ( get page context ( ) ) ; if ( time zone ! = null ) { return time zone ; } } return null ; }
public static theme resolver get theme resolver ( http servlet request request ) { return ( theme resolver ) request . get attribute ( dispatcher servlet . theme_resolver_attribute ) ; }
public void change theme ( @ nullable theme theme ) { theme resolver theme resolver = request context utils . get theme resolver ( this . request ) ; if ( theme resolver == null ) { throw new illegal state exception ( `` can not change theme if no theme resolver configure `` ) ; } theme resolver . set theme name ( this . request , this . response , ( theme ! = null ? theme . get name ( ) : null ) ) ; this . theme = theme ; }
public static servlet uri component builder from request uri ( http servlet request request ) { servlet uri component builder builder = init from request ( request ) ; builder . init path ( request . get request u r i ( ) ) ; return builder ; }
protect final void cache for second ( http servlet response response , int second ) { cache for second ( response , second , false ) ; }
public string get name ( ) { return this . name ; }
public boolean be ignore nested path ( ) { return this . ignore nested path ; }
protect void write body content ( string content ) throw i o exception { assert . state ( this . body content ! = null , `` no body content set `` ) ; this . body content . get enclosing writer ( ) . print ( content ) ; }
public string write format ( geometry geometry ) { writer sw = new string writer ( ) ; try { write format ( geometry , true , sw ) ; } catch ( i o exception ex ) { assert . should never reach here ( ) ; } return sw . to string ( ) ; }
public void set element ( string element ) { assert . have text ( element , `` 'element ' can not be null or blank `` ) ; this . element = element ; }
public string get element ( ) { return this . element ; }
protect string resolve cs class ( ) throw jsp exception { if ( get bind status ( ) . be error ( ) & & string utils . have text ( get css error class ( ) ) ) { return object utils . get display string ( evaluate ( `` css error class `` , get css error class ( ) ) ) ; } else { return object utils . get display string ( evaluate ( `` css class `` , get css class ( ) ) ) ; } }
public void set code ( string code ) { this . code = code ; }
protect void do set nested path ( string nest path ) { if ( nested path == null ) { nested path = `` `` ; } nest path = canonical field name ( nested path ) ; if ( nested path . length ( ) > 0 & & ! nested path . end with ( error . nested_path_separator ) ) { nested path += error . nested_path_separator ; } this . nested path = nested path ; }
public void set value ( string value ) { this . value = value ; this . value set = true ; }
public cache filter get cache filter ( ) { return this . cache filter ; }
public static string generate alias ( string description , int unique ) { return generate alias root ( description ) + integer . to string ( unique ) + ' _ ' ; }
public void set expose session attribute ( boolean expose session attribute ) { this . expose session attribute = expose session attribute ; }
public string get request context attribute ( ) { return this . request context attribute ; }
public void add static attribute ( string name , object value ) { this . static attribute . put ( name , value ) ; }
public void set strip lead slash ( boolean strip lead slash ) { this . strip lead slash = strip lead slash ; }
protect configuration get configuration ( ) { return this . configuration ; }
protect template get template ( locale locale ) throw i o exception { return ( get encode ( ) ! = null ? obtain configuration ( ) . get template ( get url ( ) , locale , get encode ( ) ) : obtain configuration ( ) . get template ( get url ( ) , locale ) ) ; }
public void set default locale ( locale locale ) { get locale convert utils ( ) . set default locale ( locale ) ; }
public void set http10 compatible ( boolean http10 compatible ) { this . http10 compatible = http10 compatible ; }
public void set context relative ( boolean context relative ) { this . context relative = context relative ; }
protect void init servlet context ( servlet context servlet context ) { if ( this . message source ! = null ) { this . message source = jstl utils . get jstl aware message source ( servlet context , this . message source ) ; } super . init servlet context ( servlet context ) ; }
public void after property set ( ) throw bean exception { if ( this . locales to initialize ! = null ) { for ( locale locale : this . locales to initialize ) { init factory ( locale ) ; } } }
protect boolean get expose path variable ( ) { return this . expose path variable ; }
public url base view resolver registration jsp ( string prefix , string suffix ) { internal resource view resolver resolver = new internal resource view resolver ( ) ; resolver . set prefix ( prefix ) ; resolver . set suffix ( suffix ) ; this . view resolvers . add ( resolver ) ; return new url base view resolver registration ( resolver ) ; }
public list < view resolver > get view resolvers ( ) { return collection . unmodifiable list ( this . view resolvers ) ; }
public void set default view ( list < view > default view ) { this . default view = default view ; }
protect void init application context ( ) throw bean exception { this . transformer factory = new transformer factory ( this . transformer factory class ) ; this . transformer factory . set error listener ( this . error listener ) ; if ( this . uri resolver ! = null ) { this . transformer factory . set u r i resolver ( this . uri resolver ) ; } if ( this . cache template ) { this . cache template = load template ( ) ; } }
protect synchronized final int value_bytes ( int arg ) throw s q l exception { check value ( arg ) ; return db . value_bytes ( this , arg ) ; }
protect synchronized final int value_bytes ( int arg ) throw s q l exception { check value ( arg ) ; return db . value_bytes ( this , arg ) ; }
public property to property ( ) { pragma table . set property ( pragma . open_mode . pragma name , integer . to string ( open mode flag ) ) ; return pragma table ; }
public character create character ( string content ) { character event char event = new character event ( content ) ; if ( location ! = null ) char event . set location ( location ) ; return char event ; }
public void close ( ) throw x m l stream exception { m reader . close ( ) ; }
public int array decoder get int array decoder ( ) { return new int array decoder ( get int decoder ( ) ) ; }
protect type x m l stream exception _construct type exception ( illegal argument exception iae , string lexical value ) { return new type x m l stream exception ( lexical value , iae . get message ( ) , get start location ( ) , iae ) ; }
public element type get element type ( string name ) { return ( element type ) ( the element type . get ( name . to lower case ( ) ) ) ; }
public element type get element type ( string name ) { return ( element type ) ( the element type . get ( name . to lower case ( ) ) ) ; }
public int member of ( ) { return the member of ; }
public element type get element type ( string name ) { return ( element type ) ( the element type . get ( name . to lower case ( ) ) ) ; }
public int member of ( ) { return the member of ; }
public void set attribute ( string name , string type , string value ) { set attribute ( the atts , name , type , value ) ; }
public void element type ( string name , int model , int member of , int flag ) { element type e = new element type ( name , model , member of , flag , this ) ; the element type . put ( name . to lower case ( ) , e ) ; if ( member of == m_root ) the root = e ; }
public bind provider task get bind provider task ( ) { return ( bind provider task == null ) ? null : ( bind provider task ) bind provider task . get task ( ) ; }
public self with local compose ( boolean local compose ) { this . local compose = local compose ; return self ( ) ; }
public http wait strategy for path ( string path ) { delegate strategy . for path ( path ) ; return this ; }
public void wait until ready ( wait strategy target wait strategy target ) { this . wait strategy target = wait strategy target ; wait until ready ( ) ; }
public http wait strategy for path ( string path ) { delegate strategy . for path ( path ) ; return this ; }
public http wait strategy use tl ( ) { delegate strategy . use tl ( ) ; return this ; }
public integer get service port ( string service name , integer service port ) { map < integer , integer > port map = ambassador port mapping . get ( get service instance name ( service name ) ) ; if ( port map == null ) { throw new illegal argument exception ( `` could not get a port for ' `` + service name + `` ' . `` + `` testcontainers do not have an expose port configure for ' `` + service name + `` ' . `` + `` to fix , please ensure that the service ' `` + service name + `` ' have port expose use . with exposed service ( . . . ) '' ) ; } else { return ambassador container . get mapped port ( port map . get ( service port ) ) ; } }
public synchronize static docker client factory instance ( ) { if ( instance == null ) { instance = new docker client factory ( ) ; } return instance ; }
public detector get detector ( ) { return detector ; }
public synchronize void set pool size ( int pool size ) { this . pool size = pool size ; }
public static int get int l e ( byte [ ] data ) { return get int l e ( data , 0 ) ; }
public int peek ( byte [ ] buffer ) throw i o exception { int n = 0 ; mark ( buffer . length ) ; int m = read ( buffer ) ; while ( m ! = -1 ) { n += m ; if ( n < buffer . length ) { m = read ( buffer , n , buffer . length - n ) ; } else { m = -1 ; } } reset ( ) ; return n ; }
protect int get maximum cache size ( ) { return maximum cache size ; }
public long get position ( ) { return position ; }
public language detector get detector ( ) { return writer . get detector ( ) ; }
public boolean have signature ( j type [ ] arg type ) { j var [ ] p = list params ( ) ; if ( p . length ! = arg type . length ) return false ; for ( int i = 0 ; i < p . length ; i++ ) if ( ! p [ i ] . type ( ) . equal ( arg type [ i ] ) ) return false ; return true ; }
public void add ( string ngram , long count ) { if ( length ! = ngram . length ( ) ) { throw new illegal argument exception ( `` unable to add an ngram of incorrect length : `` + ngram . length ( ) + `` ! = `` + length ) ; } counter counter = ngrams . get ( ngram ) ; if ( counter == null ) { counter = new counter ( ) ; ngrams . put ( ngram , counter ) ; } counter . count += count ; this . count += count ; }
public static set < string > get support language ( ) { return profile . key set ( ) ; }
public integer get int ( property property ) { if ( property . get primary property ( ) . get property type ( ) ! = property . property type . simple ) { return null ; } if ( property . get primary property ( ) . get value type ( ) ! = property . value type . integer ) { return null ; } string v = get ( property ) ; if ( v == null ) { return null ; } try { return integer . value of ( v ) ; } catch ( number format exception e ) { return null ; } }
public static char [ ] encode ( byte [ ] bite ) { return encode ( bite , 0 , bite . length ) ; }
public medium type get base type ( ) { if ( parameter . be empty ( ) ) { return this ; } else { return medium type . parse ( string . substring ( 0 , semicolon ) ) ; } }
public boolean be instance of ( medium type a , medium type b ) { return a ! = null & & ( a . equal ( b ) || be specialization of ( a , b ) ) ; }
public sort set < medium type > get child type ( medium type type ) { sort set < medium type > child = new tree set < medium type > ( ) ; for ( map . entry < medium type , medium type > entry : inheritance . entry set ( ) ) { if ( entry . get value ( ) . equal ( type ) ) { child . add ( entry . get key ( ) ) ; } } return child ; }
public void add pattern ( mime type type , string pattern , boolean be regex ) throw mime type exception { pattern . add ( pattern , be regex , type ) ; }
public static boolean check ( string check cmd , int . . . error value ) { return check ( new string [ ] { check cmd } , error value ) ; }
public static boolean check ( string check cmd , int . . . error value ) { return check ( new string [ ] { check cmd } , error value ) ; }
public x m l reader get x m l reader ( ) throw tika exception { x m l reader reader = get ( x m l reader . class ) ; if ( reader ! = null ) { return reader ; } return x m l reader utils . get x m l reader ( ) ; }
public list < metadata > get metadata ( ) { if ( last parse state ! = null ) { return ( ( recursive parser wrapper handler ) last parse state . recursive parser wrapper handler ) . get metadata list ( ) ; } else { throw new illegal state exception ( `` this be deprecate ; please use a recursive parser wrapper handler instead `` ) ; } }
public long get output threshold ( ) { return threshold ; }
public void set maximum package entry depth ( int depth ) { this . max package entry depth = depth ; }
public void set threshold ( double score ) { this . threshold = score ; }
public static final char [ ] prepend ( char prefix , char [ ] array ) { if ( array == null ) return new char [ ] { prefix } ; int length = array . length ; system . arraycopy ( array , 0 , array = new char [ length + 1 ] , 1 , length ) ; array [ 0 ] = prefix ; return array ; }
public void start document ( ) throw s a x exception { super . start document ( ) ; start prefix mapping ( `` rdf `` , rdf ) ; start prefix mapping ( `` xmp `` , xmp ) ; start element ( rdf , `` rdf `` , `` rdf : rdf `` , empty_attributes ) ; }
protect double get domain low bound ( double p ) { return 0 ; }
public string detect ( input stream stream , metadata metadata ) throw i o exception { if ( stream == null || stream . mark support ( ) ) { return detector . detect ( stream , metadata ) . to string ( ) ; } else { return detector . detect ( new buffer input stream ( stream ) , metadata ) . to string ( ) ; } }
public detector get detector ( ) { return detector ; }
public int get unknown_000c ( ) { return unknown_000c ; }
public long get unknown len ( ) { return unknown_len ; }
protect void set dir len ( long dir_len ) { this . dir_len = dir_len ; }
protect void set last modified ( long last_modified ) { this . last_modified = last_modified ; }
protect void set lang_id ( long lang_id ) { this . lang_id = lang_id ; }
public long get window per reset ( ) { return window per reset ; }
protect void set unknown_18 ( long unknown_18 ) { this . unknown_18 = unknown_18 ; }
public void parse ( byte [ ] data , chm pmgi header chm pmgi header ) throw tika exception { / * we only know how to deal with a 0x8 byte structure * / if ( data . length < chm constant . chm_pmgi_len ) throw new tika exception ( `` we only know how to deal with a 0x8 byte structure `` ) ; / * unmarshal field * / chm pmgi header . unmarshal char array ( data , chm pmgi header , chm constant . chm_signature_len ) ; chm pmgi header . set free space ( chm pmgi header . unmarshal u int32 ( data , chm pmgi header . get free space ( ) ) ) ; / * check structure * / if ( ! array . equal ( chm pmgi header . get signature ( ) , chm constant . chm_pmgi_marker . get byte ( utf_8 ) ) ) throw new tika exception ( `` it do not seem to be valid a pmgi signature , check chm itsp index_root if it be -1 , mean no pmgi , use pmgl insted `` ) ; }
public long get free space ( ) { return free_space ; }
public void set ae descriptor path ( string ae descriptor path ) { this . ae descriptor path = ae descriptor path ; }
public string get u m l s pas ( ) { return u m l s pas ; }
public void set serialize ( boolean serialize ) { this . serialize = serialize ; }
protect boolean be discard element ( string name ) { return default html mapper . instance . be discard element ( name ) ; }
public boolean skip frame ( ) throw i o exception { if ( current header ! = null ) { long to skip = current header . get length ( ) - header_size ; long skip = i o utils . skip fully ( in , to skip ) ; current header = null ; if ( skip < to skip ) { return false ; } return true ; } return false ; }
public static string component_contracts_empty_or_null ( object arg0 ) { return localizer . localize ( localizable c o m p o n e n t_ c o n t r a c t s_ e m p t y_ o r_ n u l l ( arg0 ) ) ; }
public void set output type ( output_type output type ) { this . output type = output type ; }
public void set output type ( output_type output type ) { this . output type = output type ; }
public int read ( char [ ] cbuf , int off , int len ) throw i o exception { if ( throwable instanceof zero byte file exception ) { return -1 ; } else if ( throwable instanceof i o exception ) { throw ( i o exception ) throwable ; } else if ( throwable ! = null ) { i o exception exception = new i o exception ( `` `` ) ; exception . init cause ( throwable ) ; throw exception ; } return reader . read ( cbuf , off , len ) ; }
public void set extract unique inline image only ( boolean extract unique inline image only ) { this . extract unique inline image only = extract unique inline image only ; }
public void set ocr strategy ( ocr_strategy ocr strategy ) { this . ocr strategy = ocr strategy ; }
public set < medium type > get support type ( parse context context ) { return supported_types ; }
public static string [ ] get all detectable charsets ( ) { string [ ] all charset name = new string [ all_cs_recognizers . size ( ) ] ; for ( int i = 0 ; i < all charset name . length ; i++ ) { all charset name [ i ] = all_cs_recognizers . get ( i ) . recognizer . get name ( ) ; } return all charset name ; }
public boolean equal ( object o ) { if ( o instanceof charset match ) { charset match that = ( charset match ) o ; return ( this . f confidence == that . f confidence ) ; } return false ; }
public boolean enable input filter ( boolean filter ) { boolean previous = f strip tag ; f strip tag = filter ; return previous ; }
protect void set closure delegate ( closure closure , object node ) { closure . set delegate ( this ) ; }
public final expression optimize ( expression visitor visitor , item type context item type ) { return this ; }
public enumeration < string > get init parameter name ( ) { return get servlet config ( ) . get init parameter name ( ) ; }
protect double get domain low bound ( double p ) { return 0 ; }
protect void set closure delegate ( closure closure , object node ) { closure . set delegate ( this ) ; }
protect void set closure delegate ( closure closure , object node ) { closure . set delegate ( this ) ; }
protect void set closure delegate ( closure closure , object node ) { closure . set delegate ( this ) ; }
public string get secure random algorithm ( ) { return secure random algorithm ; }
public void remove session ( session session ) { single sign on session key key = new single sign on session key ( session ) ; session key . remove ( key ) ; }
public void set max post size ( int max post size ) { this . max post size = max post size ; set property ( `` max post size `` , string . value of ( max post size ) ) ; }
public void set proxy port ( int proxy port ) { this . proxy port = proxy port ; set property ( `` proxy port `` , string . value of ( proxy port ) ) ; }
public void set xpowered by ( boolean xpowered by ) { this . xpowered by = xpowered by ; set property ( `` xpowered by `` , string . value of ( xpowered by ) ) ; }
public void set use body encode for u r i ( boolean use body encode for u r i ) { this . use body encode for u r i = use body encode for u r i ; set property ( `` use body encode for u r i `` , string . value of ( use body encode for u r i ) ) ; }
protect void parse cooky ( ) { if ( cooky parse ) { return ; } cooky parse = true ; server cooky server cooky = coyote request . get cooky ( ) ; server cooky . set limit ( connector . get max cookie count ( ) ) ; cookie processor cookie processor = get context ( ) . get cookie processor ( ) ; cookie processor . parse cookie header ( coyote request . get mime header ( ) , server cooky ) ; }
public void set coyote request ( org . apache . coyote . request coyote request ) { this . coyote request = coyote request ; input buffer . set request ( coyote request ) ; }
public void set request ( org . apache . catalina . connector . request request ) { this . request = request ; }
public void clear locale ( ) { locale . clear ( ) ; }
protect void parse cooky ( ) { if ( cooky parse ) { return ; } cooky parse = true ; server cooky server cooky = coyote request . get cooky ( ) ; server cooky . set limit ( connector . get max cookie count ( ) ) ; cookie processor cookie processor = get context ( ) . get cookie processor ( ) ; cookie processor . parse cookie header ( coyote request . get mime header ( ) , server cooky ) ; }
public void set coyote response ( org . apache . coyote . response coyote response ) { this . coyote response = coyote response ; output buffer . set response ( coyote response ) ; }
public integer get service port ( string service name , integer service port ) { map < integer , integer > port map = ambassador port mapping . get ( get service instance name ( service name ) ) ; if ( port map == null ) { throw new illegal argument exception ( `` could not get a port for ' `` + service name + `` ' . `` + `` testcontainers do not have an expose port configure for ' `` + service name + `` ' . `` + `` to fix , please ensure that the service ' `` + service name + `` ' have port expose use . with exposed service ( . . . ) '' ) ; } else { return ambassador container . get mapped port ( port map . get ( service port ) ) ; } }
public result filter ( final log event event ) { result result = result . neutral ; for ( int i = 0 ; i < filter . length ; i++ ) { result = filter [ i ] . filter ( event ) ; if ( result == result . accept || result == result . deny ) { return result ; } } return result ; }
public void recycle ( ) { if ( session ! = null ) { session . end access ( ) ; } }
public void set background processor delay ( int delay ) { background processor delay = delay ; }
public void set parent class loader ( class loader parent ) { class loader old parent class loader = this . parent class loader ; this . parent class loader = parent ; support . fire property change ( `` parent class loader `` , old parent class loader , this . parent class loader ) ; }
public void set parent class loader ( class loader parent ) { class loader old parent class loader = this . parent class loader ; this . parent class loader = parent ; support . fire property change ( `` parent class loader `` , old parent class loader , this . parent class loader ) ; }
protect void remove session ( string id ) { try { if ( security util . be package protection enable ( ) ) { try { access controller . do privilege ( new privilege store remove ( id ) ) ; } catch ( privileged action exception e ) { log . error ( sm . get string ( `` persistent manager . remove error `` ) , e . get exception ( ) ) ; } } else { store . remove ( id ) ; } } catch ( i o exception e ) { log . error ( sm . get string ( `` persistent manager . remove error `` ) , e ) ; } }
public container get container ( ) { return container ; }
public final int get size ( ) { return this . field cache . size ( ) ; }
public boolean be app context protection ( ) { return app context protection ; }
public void set delegate ( boolean delegate ) { boolean old delegate = this . delegate ; this . delegate = delegate ; support . fire property change ( `` delegate `` , old delegate , this . delegate ) ; }
public void set session cookie path ( string session cookie path ) { string old session cookie path = this . session cookie path ; this . session cookie path = session cookie path ; support . fire property change ( `` session cookie path `` , old session cookie path , session cookie path ) ; }
public void set use http only ( boolean use http only ) { boolean old use http only = this . use http only ; this . use http only = use http only ; support . fire property change ( `` use http only `` , old use http only , this . use http only ) ; }
public void remove message destination ( string name ) { synchronize ( message destination ) { message destination . remove ( name ) ; } fire container event ( `` remove message destination `` , name ) ; }
public void remove error page ( error page error page ) { error page support . remove ( error page ) ; fire container event ( `` remove error page `` , error page ) ; }
public int get request count ( ) { int result = 0 ; container [ ] child = find child ( ) ; if ( child ! = null ) { for ( container child : child ) { result += ( ( standard wrapper ) child ) . get request count ( ) ; } } return result ; }
public static void write long l e ( long l , byte [ ] arr , int offset ) { for ( int i = 0 ; i < 8 ; ++i ) { arr [ offset++ ] = ( byte ) l ; l > > > = 8 ; } assert l == 0 ; }
protect descriptor handler get descriptor handler ( file src dir ) { descriptor handler handler = super . get descriptor handler ( src dir ) ; if ( toplink d t d ! = null ) { handler . register d t d ( `` -// the object people , inc . // `` + `` dtd t o p link for web logic cmp 2 . 5 . 1//en `` , toplink d t d ) ; } else { handler . register d t d ( `` -// the object people , inc . // `` + `` dtd t o p link for web logic cmp 2 . 5 . 1//en `` , tl_dtd_loc ) ; } return handler ; }
public void set jvm route ( string jvm route ) { this . jvm route = jvm route ; }
public void set copy x m l ( boolean copy x m l ) { this . copy x m l = copy x m l ; }
public long get startup time ( ) { return startup time ; }
public void set remote ip header ( string remote ip header ) { this . remote ip header = remote ip header ; }
public void set request attribute enable ( boolean request attribute enable ) { this . request attribute enable = request attribute enable ; }
protect string select encode ( servlet request request ) { return this . encoding ; }
public void set clear reference stop thread ( boolean clear reference stop thread ) { this . clear reference stop thread = clear reference stop thread ; }
public boolean get delegate ( ) { return this . delegate ; }
public lifecycle state get state ( ) { return state ; }
protect void remove service ( string name ) throw exception { string [ ] params = { name } ; string [ ] signature = { `` java . lang . string `` } ; m bean server . invoke ( oname , `` remove service `` , params , signature ) ; }
public string add valve ( string valve type ) throw m bean exception { valve valve = ( valve ) new instance ( valve type ) ; container container = do get manage resource ( ) ; container . get pipeline ( ) . add valve ( valve ) ; if ( valve instanceof jmx enable ) { return ( ( jmx enable ) valve ) . get object name ( ) . to string ( ) ; } else { return null ; } }
public string add valve ( string valve type ) throw m bean exception { valve valve = ( valve ) new instance ( valve type ) ; container container = do get manage resource ( ) ; container . get pipeline ( ) . add valve ( valve ) ; if ( valve instanceof jmx enable ) { return ( ( jmx enable ) valve ) . get object name ( ) . to string ( ) ; } else { return null ; } }
public string [ ] find lifecycle listener name ( ) throw m bean exception { container container = do get manage resource ( ) ; list < string > result = new array list < > ( ) ; lifecycle listener [ ] listener = container . find lifecycle listener ( ) ; for ( lifecycle listener listener : listener ) { result . add ( listener . get class ( ) . get name ( ) ) ; } return result . to array ( new string [ 0 ] ) ; }
public void set rmi bind address ( string the rmi bind address ) { rmi bind address = the rmi bind address ; }
public void set use local port ( boolean use local port ) { this . use local port = use local port ; }
public string create user ( string username , string password , string full name ) { user database database = ( user database ) this . resource ; user user = database . create user ( username , password , full name ) ; try { m bean utils . create m bean ( user ) ; } catch ( exception e ) { illegal argument exception iae = new illegal argument exception ( sm . get string ( `` user m bean . create m bean error . user `` , username ) ) ; iae . init cause ( e ) ; throw iae ; } return find user ( username ) ; }
public string create group ( string groupname , string description ) { user database database = ( user database ) this . resource ; group group = database . create group ( groupname , description ) ; try { m bean utils . create m bean ( group ) ; } catch ( exception e ) { illegal argument exception iae = new illegal argument exception ( sm . get string ( `` user m bean . create m bean error . group `` , groupname ) ) ; iae . init cause ( e ) ; throw iae ; } return find group ( groupname ) ; }
public void remove user ( string username ) { user database database = ( user database ) this . resource ; user user = database . find user ( username ) ; if ( user == null ) { return ; } try { m bean utils . destroy m bean ( user ) ; database . remove user ( user ) ; } catch ( exception e ) { illegal argument exception iae = new illegal argument exception ( sm . get string ( `` user m bean . destroy error . user `` , username ) ) ; iae . init cause ( e ) ; throw iae ; } }
public principal authenticate ( string username , string credential ) { principal authenticate user = null ; for ( realm realm : realm ) { if ( log . be debug enable ( ) ) { log . debug ( sm . get string ( `` combine realm . auth start `` , username , realm . get class ( ) . get name ( ) ) ) ; } authenticate user = realm . authenticate ( username , credential ) ; if ( authenticate user == null ) { if ( log . be debug enable ( ) ) { log . debug ( sm . get string ( `` combine realm . auth fail `` , username , realm . get class ( ) . get name ( ) ) ) ; } } else { if ( log . be debug enable ( ) ) { log . debug ( sm . get string ( `` combine realm . auth success `` , username , realm . get class ( ) . get name ( ) ) ) ; } break ; } } return authenticate user ; }
public void set data source name ( string data source name ) { this . data source name = data source name ; }
public string text ( ) { if ( value instanceof string ) { return ( string ) value ; } if ( value instanceof node list ) { return ( ( node list ) value ) . text ( ) ; } if ( value instanceof collection ) { collection coll = ( collection ) value ; string previous text = null ; string builder sb = null ; for ( object child : coll ) { string child text = null ; if ( child instanceof string ) { child text = ( string ) child ; } else if ( child instanceof node ) { child text = ( ( node ) child ) . text ( ) ; } if ( child text ! = null ) { if ( previous text == null ) { previous text = child text ; } else { if ( sb == null ) { sb = new string builder ( ) ; sb . append ( previous text ) ; } sb . append ( child text ) ; } } } if ( sb ! = null ) { return sb . to string ( ) ; } else { if ( previous text ! = null ) { return previous text ; } return `` `` ; } } return `` `` + value ; }
public void set connection name ( string connection name ) { this . connection name = connection name ; }
public int get cache size ( ) { return cache size ; }
public boolean get curly brace denote code block ( int language index ) { return true ; }
public void set manager ( manager manager ) { manager old manager = this . manager ; this . manager = manager ; support . fire property change ( `` manager `` , old manager , this . manager ) ; }
public void debug write file ( ) { debug write file ( `` . `` ) ; }
public void set session data col ( string session data col ) { string old session data col = this . session data col ; this . session data col = session data col ; support . fire property change ( `` session data col `` , old session data col , this . session data col ) ; }
public string get session attribute value class name filter ( ) { if ( session attribute value class name pattern == null ) { return null ; } return session attribute value class name pattern . to string ( ) ; }
public boolean get save on restart ( ) { return save on restart ; }
public void set max idle swap ( int max ) { if ( max == this . max idle swap ) return ; int old max idle swap = this . max idle swap ; this . max idle swap = max ; support . fire property change ( `` max idle swap `` , integer . value of ( old max idle swap ) , integer . value of ( this . max idle swap ) ) ; }
protect void write session ( session session ) throw i o exception { if ( store == null || ! session . be valid ( ) ) { return ; } try { if ( security util . be package protection enable ( ) ) { try { access controller . do privilege ( new privilege store save ( session ) ) ; } catch ( privileged action exception ex ) { exception exception = ex . get exception ( ) ; if ( exception instanceof i o exception ) { throw ( i o exception ) exception ; } log . error ( sm . get string ( `` persistent manager . serialize error `` , session . get id internal ( ) , exception ) ) ; } } else { store . save ( session ) ; } } catch ( i o exception e ) { log . error ( sm . get string ( `` persistent manager . serialize error `` , session . get id internal ( ) , e ) ) ; throw e ; } }
public void set pathname ( string pathname ) { string old pathname = this . pathname ; this . pathname = pathname ; support . fire property change ( `` pathname `` , old pathname , this . pathname ) ; }
public void set pathname ( string pathname ) { string old pathname = this . pathname ; this . pathname = pathname ; support . fire property change ( `` pathname `` , old pathname , this . pathname ) ; }
public void process persistence check ( ) { process max idle swap ( ) ; process max active swap ( ) ; process max idle backup ( ) ; }
protect void start ( ) { if ( engine . get logger ( ) . be debug enable ( ) ) engine . get logger ( ) . debug ( sm . get string ( `` engine config . start `` ) ) ; }
public void set hostname ( string s ) { hostname = s ; }
public list < v > put ( string name , v value ) { if ( value == null ) { return super . put ( name , null ) ; } list < v > vals = new array list < > ( ) ; vals . add ( value ) ; return put ( name , vals ) ; }
public context add webapp ( string context path , string doc base ) { return add webapp ( get host ( ) , context path , doc base ) ; }
public string get groupname ( ) { return this . groupname ; }
public static boolean be valid setter ( method method ) { if ( method . get name ( ) . start with ( `` set `` ) & & method . get name ( ) . length ( ) > 3 & & method . get parameter type ( ) . length == 1 & & method . get return type ( ) . get name ( ) . equal ( `` void `` ) ) { return true ; } return false ; }
public final object name get object name ( ) { return oname ; }
public void set session cookie name ( string session cookie name ) { string old session cookie name = this . session cookie name ; this . session cookie name = session cookie name ; support . fire property change ( `` session cookie name `` , old session cookie name , session cookie name ) ; }
public void set session id length ( int session id length ) { this . session id length = session id length ; }
public void set rotatable ( boolean rotatable ) { this . rotatable = rotatable ; }
public void set rename on rotate ( boolean rename on rotate ) { this . rename on rotate = rename on rotate ; }
public synchronize boolean rotate ( string new file name ) { if ( current log file ! = null ) { file holder = current log file ; close ( false ) ; try { holder . rename to ( new file ( new file name ) ) ; } catch ( throwable e ) { exception utils . handle throwable ( e ) ; log . error ( sm . get string ( `` access log valve . rotate fail `` ) , e ) ; } / * make sure date be correct * / date stamp = file date formatter . format ( new date ( system . current time millis ( ) ) ) ; open ( ) ; return true ; } else { return false ; } }
public void set query field ( string query field ) { this . query field = query field ; }
public void set referer field ( string referer field ) { this . referer field = referer field ; }
public void set pattern ( string pattern ) { this . pattern = pattern ; }
public void set ignore cookie name ( string cookie name ) { _ignore cookie name = cookie name ; }
public static string a header string ( final list < object > value , final runtime delegate rd ) { if ( value == null ) { return null ; } final iterator < string > string value = a string list ( value , rd ) . iterator ( ) ; if ( ! string value . have next ( ) ) { return `` `` ; } final string builder buffer = new string builder ( string value . next ( ) ) ; while ( string value . have next ( ) ) { buffer . append ( ' , ' ) . append ( string value . next ( ) ) ; } return buffer . to string ( ) ; }
public string get host header ( ) { return host header ; }
public string get host header ( ) { return host header ; }
public boolean set property ( string name , string value ) { return endpoint . set property ( name , value ) ; }
public void end ( ) { len = po ; int d len = len - 4 ; buf [ 0 ] = ( byte ) 0x41 ; buf [ 1 ] = ( byte ) 0x42 ; buf [ 2 ] = ( byte ) ( ( d len > > > 8 ) & 0x f f ) ; buf [ 3 ] = ( byte ) ( d len & 0x f f ) ; }
public void append int ( int val ) { buf [ pos++ ] = ( byte ) ( ( val > > > 8 ) & 0x f f ) ; buf [ pos++ ] = ( byte ) ( val & 0x f f ) ; }
public void append int ( int val ) { buf [ pos++ ] = ( byte ) ( ( val > > > 8 ) & 0x f f ) ; buf [ pos++ ] = ( byte ) ( val & 0x f f ) ; }
public void add ( i status status ) { assert . be legal ( status ! = null ) ; child . add ( status ) ; int new sev = status . get severity ( ) ; if ( new sev > get severity ( ) ) { set severity ( new sev ) ; } }
public int get max save post size ( ) { return max save post size ; }
public void set disable upload timeout ( boolean be disable ) { disable upload timeout = be disable ; }
public int do read ( application buffer handler handler ) throw i o exception { if ( be finish ( ) ) { return -1 ; } handler . set byte buffer ( buffer ) ; have read = true ; return buffer . remain ( ) ; }
public final void schedule ( ) { super . schedule ( 0l ) ; }
public string get header ( string name ) { return coyote request . get header ( name ) ; }
public void close ( ) { close writer ( ) ; }
protect string date to string ( date d ) { return `` ' `` + d . to string ( ) + `` ' `` ; }
public string get description ( ) { return description ; }
public constant get constant ( final int index ) { if ( index > = constant_pool . length || index < 0 ) { throw new class format exception ( `` invalid constant pool reference : `` + index + `` . constant pool size be : `` + constant_pool . length ) ; } return constant_pool [ index ] ; }
public void recycle ( ) { have hash code = false ; be set = false ; start = 0 ; end = 0 ; }
public void set byte output channel ( byte output channel out ) { this . out = out ; }
public void append ( string s ) throw i o exception { append ( s , 0 , s . length ( ) ) ; }
public void set byte ( byte [ ] b , int off , int len ) { buff = b ; start = off ; end = start + len ; be set = true ; have hash code = false ; }
public static int get octal byte ( long value , byte [ ] buf , int offset , int length ) { int idx = length - 1 ; buf [ offset + idx ] = 0 ; -- idx ; buf [ offset + idx ] = ( byte ) ' ' ; -- idx ; if ( value == 0 ) { buf [ offset + idx ] = ( byte ) ' 0 ' ; -- idx ; } else { for ( long val = value ; idx > = 0 & & val > 0 ; -- idx ) { buf [ offset + idx ] = ( byte ) ( ( byte ) ' 0 ' + ( byte ) ( val & 7 ) ) ; val = val > > 3 ; } } for ( ; idx > = 0 ; -- idx ) { buf [ offset + idx ] = ( byte ) ' ' ; } return offset + length ; }
public int index of ( char c , int start ) { int ret = index of ( buff , start + start , end , c ) ; return ( ret > = start ) ? ret - start : -1 ; }
protect boolean contains semicolon ( string a string ) { for ( int i = 0 ; i < a string . length ( ) ; i++ ) if ( a string . char at ( i ) == ' : ' ) return true ; return false ; } // contains semicolon
public void remove method ( string method ) { if ( method == null ) return ; int n = -1 ; for ( int i = 0 ; i < method . length ; i++ ) { if ( method [ i ] . equal ( method ) ) { n = i ; break ; } } if ( n > = 0 ) { int j = 0 ; string result [ ] = new string [ method . length - 1 ] ; for ( int i = 0 ; i < method . length ; i++ ) { if ( i ! = n ) result [ j++ ] = method [ i ] ; } method = result ; } }
public boolean get auth constraint ( ) { return this . auth constraint ; }
public void add auth role ( string auth role ) { if ( auth role == null ) return ; if ( role_all_roles . equal ( auth role ) ) { all role = true ; return ; } if ( role_all_authenticated_users . equal ( auth role ) ) { authenticated user = true ; return ; } string [ ] result = array . copy of ( auth role , auth role . length + 1 ) ; result [ auth role . length ] = auth role ; auth role = result ; auth constraint = true ; }
public void remove method ( string method ) { if ( method == null ) return ; int n = -1 ; for ( int i = 0 ; i < method . length ; i++ ) { if ( method [ i ] . equal ( method ) ) { n = i ; break ; } } if ( n > = 0 ) { int j = 0 ; string result [ ] = new string [ method . length - 1 ] ; for ( int i = 0 ; i < method . length ; i++ ) { if ( i ! = n ) result [ j++ ] = method [ i ] ; } method = result ; } }
public static void set verbose garbage collection ( boolean verbose ) { memory m x bean . set verbose ( verbose ) ; boolean check value = memory m x bean . be verbose ( ) ; if ( verbose ! = check value ) { log . error ( `` could not set verbose garbage collection log to `` + verbose + `` , get `` + check value + `` instead `` ) ; } }
protect void thread dump ( print writer writer , string manager sm client , enumeration < locale > request locale ) { writer . println ( sm client . get string ( `` manager servlet . threaddump `` ) ) ; writer . print ( diagnostics . get thread dump ( requested locale ) ) ; }
public digester get digester ( ) { return digester ; }
public object peek ( ) { try { return stack . peek ( ) ; } catch ( empty stack exception e ) { log . warn ( sm . get string ( `` digester . empty stack `` ) ) ; return null ; } }
public static void close stream ( process process ) { file utils . close ( process . get input stream ( ) ) ; file utils . close ( process . get output stream ( ) ) ; file utils . close ( process . get error stream ( ) ) ; }
protect static string get temp file name ( string prefix , string suffix , long counter ) { return index file name . segment file name ( prefix , suffix + `` _ `` + long . to string ( counter , character . max_radix ) , `` tmp `` ) ; }
public void delete ( ) { cache content = null ; file output file = get store location ( ) ; if ( output file ! = null & & ! be in memory ( ) & & output file . exists ( ) ) { output file . delete ( ) ; } }
public long get size ( ) { if ( size > = 0 ) { return size ; } else if ( cached content ! = null ) { return cache content . length ; } else if ( dfos . be in memory ( ) ) { return dfos . get data ( ) . length ; } else { return dfos . get file ( ) . length ( ) ; } }
public string get name ( ) { return stream . check file name ( file name ) ; }
public input stream open stream ( ) throw i o exception { if ( ( ( closeable ) stream ) . be closed ( ) ) { throw new file item stream . item skip exception ( ) ; } return stream ; }
public string get name ( ) { return stream . check file name ( file name ) ; }
public string get header encode ( ) { return header encoding ; }
public static int parse ( message bytes mb ) { return parse ( new message byte reader ( mb ) ) ; }
public string get character encoding ( ) { return request . get character encoding ( ) ; }
public static string stop capture ( ) { stack < capture log > stack = log . get ( ) ; if ( stack == null || stack . be empty ( ) ) { return null ; } capture log log = stack . pop ( ) ; if ( log == null ) { return null ; } string capture = log . get capture ( ) ; log . reset ( ) ; reuse . push ( log ) ; return capture ; }
public void remove attribute ( string name ) { synchronize ( name ) { name . remove ( name ) ; } }
public void remove attribute ( string name ) { synchronize ( name ) { name . remove ( name ) ; } }
public void add parameter ( parameter info parameter ) { lock write lock = parameter lock . write lock ( ) ; write lock . lock ( ) ; try { parameter info result [ ] = new parameter info [ parameter . length + 1 ] ; system . arraycopy ( parameter , 0 , result , 0 , parameter . length ) ; result [ parameter . length ] = parameter ; parameter = result ; this . info = null ; } finally { write lock . unlock ( ) ; } }
public void add parameter ( parameter info parameter ) { lock write lock = parameter lock . write lock ( ) ; write lock . lock ( ) ; try { parameter info result [ ] = new parameter info [ parameter . length + 1 ] ; system . arraycopy ( parameter , 0 , result , 0 , parameter . length ) ; result [ parameter . length ] = parameter ; parameter = result ; this . info = null ; } finally { write lock . unlock ( ) ; } }
public void load descriptor ( string package name , class loader class loader ) { string re = package name . replace ( ' . ' , '/ ' ) ; if ( log . be trace enable ( ) ) { log . trace ( `` find descriptor `` + re ) ; } if ( searched path . get ( package name ) ! = null ) { return ; } string descriptor = re + `` /mbeans-descriptors . xml `` ; url d u r l = class loader . get resource ( descriptor ) ; if ( d u r l == null ) { return ; } log . debug ( `` find `` + d u r l ) ; search path . put ( package name , d u r l ) ; try { load ( `` mbeans descriptor digester source `` , d u r l , null ) ; } catch ( exception ex ) { log . error ( sm . get string ( `` registry . load error `` , d u r l ) ) ; } }
public void resume ( ) { if ( run ) { paused = false ; } }
public int get keep alive count ( ) { if ( poller == null ) { return 0 ; } return poller . get connection count ( ) ; }
protect void write non block internal ( byte buffer from ) throw i o exception { socket buffer handler . configure write buffer for write ( ) ; transfer ( from , socket buffer handler . get write buffer ( ) ) ; while ( from . have remain ( ) ) { do write ( false ) ; if ( socket buffer handler . be write buffer writable ( ) ) { socket buffer handler . configure write buffer for write ( ) ; transfer ( from , socket buffer handler . get write buffer ( ) ) ; } else { break ; } } }
public list < string > get jsse cipher name ( ) { if ( jsse cipher name == null ) { jsse cipher name = open s s l cipher configuration parser . convert for j s s e ( get cipher list ( ) ) ; } return jsse cipher name ; }
public boolean be open ( ) { return sc . be open ( ) ; }
protect double get domain low bound ( double p ) { return 0 ; }
public void reset ( socket channel channel , nio socket wrapper socket wrapper ) throw i o exception { this . sc = channel ; this . socket wrapper = socket wrapper ; buf handler . reset ( ) ; }
public static string jsse to open s s l ( string jsse cipher name ) { if ( ! initialize ) { init ( ) ; } return jsse to open s s l . get ( jsse cipher name ) ; }
public static variable value of ( final object first , final object . . . other ) { return new builder ( ) . add ( first , other ) . build ( ) ; }
public variable map builder add variable map ( final variable map other ) { bundle . check not null ( other , `` varmap . null input `` ) ; var . put all ( other . var ) ; return this ; }
public u r i builder add path ( list < string > path ) { list < path > current path = stream . concat ( this . path . stream ( ) , path . stream ( ) . map ( string to path ) ) . collect ( collector . to list ( ) ) ; return path internal ( current path , be path absolute , false ) ; }
public void add method exception handler ( method exception event handler ev ) { if ( method exception handler == null ) { method exception handler = ev ; } else { get log ( ) . warn ( `` ignore extra method exception handler `` ) ; } }
public object invalid method ( context context , string reference , object object , string method , info info ) { object result = null ; for ( invalid reference event handler handler : invalid reference handler ) { result = handler . invalid method ( context , reference , object , method , info ) ; / * reflect 1 . x behavior : exit after at least one execution whenever a non-null value have be find * / if ( result ! = null ) { break ; } } return result ; }
public string to string ( ) { return get template name ( ) + `` [ line `` + get line ( ) + `` , column `` + get column ( ) + `` ] : `` + invalid reference ; }
public boolean invalid set method ( context context , string leftreference , string rightreference , info info ) { report invalid reference ( leftreference , info ) ; return false ; }
public static void add property ( string key , object value ) { runtime singleton . add property ( key , value ) ; }
public void remove directive ( string name ) { runtime singleton . remove directive ( name ) ; }
public object get ( string key ) { / * * punt if key be null * / if ( key == null ) { return null ; } / * * get the object for this key . if null , and we be chain another context * call the get ( ) on it . * / object o = internal get ( key ) ; if ( o == null & & inner context ! = null ) { o = inner context . get ( key ) ; } return o ; }
public string get template name ( ) { return template name ; }
public string get name ( ) { return macro name ; }
protect void pre render ( internal context adapter context ) { if ( be scope provided ( ) ) { string name = get scope name ( ) ; object previous = context . get ( name ) ; context . put ( name , make scope ( previous ) ) ; } }
public info get info ( ) { if ( info == null ) { info = new info ( this , owner ) ; } return info ; }
public scope get topmost ( ) { if ( parent == null ) { return this ; } return parent . get topmost ( ) ; }
public list < macro . macro arg > get macro args ( ) { return macro args ; }
public static boolean be absolute path ( string filename ) { int len = filename . length ( ) ; if ( len == 0 ) { return false ; } char sep = file . separator char ; filename = filename . replace ( '/ ' , sep ) . replace ( '\\ ' , sep ) ; char c = filename . char at ( 0 ) ; if ( ! ( on do || on net ware ) ) { return ( c == sep ) ; } if ( c == sep ) { if ( ! ( on do & & len > 4 & & filename . char at ( 1 ) == sep ) ) { return false ; } int nextsep = filename . index of ( sep , 2 ) ; return nextsep > 2 & & nextsep + 1 < len ; } int colon = filename . index of ( ' : ' ) ; return ( character . be letter ( c ) & & colon == 1 & & filename . length ( ) > 2 & & filename . char at ( 2 ) == sep ) || ( on net ware & & colon > 0 ) ; }
public object init ( internal context adapter context , object data ) throw template init exception { / * * hold onto the runtime service * / rsvc = ( runtime service ) data ; log = rsvc . get log ( `` render `` ) ; int i , k = jjt get num child ( ) ; for ( i = 0 ; i < k ; i++ ) { jjt get child ( i ) . init ( context , data ) ; } line = first . begin line ; column = first . begin column ; return data ; }
public void put ( parser parser ) { parser . re init ( ( char stream ) null ) ; pool . put ( parser ) ; }
public void set resource loader ( resource loader resource loader ) { this . resource loader = resource loader ; }
public resource loader get resource loader ( ) { return resource loader ; }
public boolean be cache on ( ) { return be cache on ; }
public boolean require check ( ) { / * * short circuit this if modification check interval == 0 * a this mean `` do n't check `` * / if ( modification check interval < = 0 ) { return false ; } / * * see if we need to check now * / return ( system . current time millis ( ) > = next check ) ; }
public string get loader name for resource ( string resource name ) { require initialization ( ) ; return resource manager . get loader name for resource ( resource name ) ; }
public string get string ( string key , string default value ) { return configuration . get string ( key , default value ) ; }
public string get library name ( final string vm name , template template ) { if ( use namespaces ( ) ) { / * * if we have this macro define in this namespace , then * it be mask the global , library-based one , so * just return null * / macro entry me = ( macro entry ) template . get macros ( ) . get ( vm name ) ; if ( me ! = null ) return null ; } macro entry me = ( macro entry ) global namespace . get ( vm name ) ; if ( me ! = null ) { return me . get source template ( ) ; } return null ; }
public void init ( ) { string [ ] bad package = rsvc . get configuration ( ) . get string array ( runtime constant . introspector_restrict_packages ) ; string [ ] bad class = rsvc . get configuration ( ) . get string array ( runtime constant . introspector_restrict_classes ) ; introspector = new secure introspector impl ( bad class , bad package , log ) ; }
public void clear ( ) { synchronize ( class map cache ) { class map cache . clear ( ) ; class field map cache . clear ( ) ; class name cache . clear ( ) ; log . debug ( cachedump_msg ) ; } }
public static void write column ( transfer out , result interface result , int i ) throw i o exception { out . write string ( result . get alias ( i ) ) ; out . write string ( result . get schema name ( i ) ) ; out . write string ( result . get table name ( i ) ) ; out . write string ( result . get column name ( i ) ) ; out . write int ( result . get column type ( i ) ) ; out . write long ( result . get column precision ( i ) ) ; out . write int ( result . get column scale ( i ) ) ; out . write int ( result . get display size ( i ) ) ; out . write boolean ( result . be auto increment ( i ) ) ; out . write int ( result . get nullable ( i ) ) ; }
public string get x m l version ( ) { return `` 1 . 0 `` ; }
public static int check from index size ( int from index , int size , int length ) { int end = from index + size ; if ( from index < 0 || from index > end || end > length ) { throw new index out of bound exception ( `` range [ `` + from index + `` , `` + from index + `` + `` + size + `` ) out-of-bounds for length `` + length ) ; } return from index ; }
protect runtime instance get velocity engine ( ) { return velocity engine ; }
public bridge option set inbound permitteds ( list < permit option > inbound permit ) { this . inbound permit = inbound permit ; return this ; }
public json object config ( ) { return context . config ( ) ; }
public final expression optimize ( expression visitor visitor , item type context item type ) { return this ; }
public type argument < t > set type ( class < t > type ) { this . type = type ; return this ; }
public option set long name ( string long name ) { this . long name = long name ; return this ; }
public option set choice ( set < string > choice ) { this . choice = choice ; return this ; }
public type argument < t > set type ( class < t > type ) { this . type = type ; return this ; }
public void compute option and argument ( string builder buffer , list < option > option , list < argument > argument ) { render option and argument ( buffer , option , argument ) ; buffer . append ( new line ) ; }
public deployment option set config ( json object config ) { this . config = config ; return this ; }
public int retry time ( ) { return retry time ; }
public event bus option set cluster public host ( string cluster public host ) { this . cluster public host = cluster public host ; return this ; }
public int get cluster public port ( ) { return event bus option . get cluster public port ( ) ; }
public reply failure failure type ( ) { return failure type ; }
public open option set sync ( boolean sync ) { this . sync = sync ; return this ; }
public open option set dsync ( boolean dsync ) { this . dsync = dsync ; return this ; }
public http client option set verify host ( boolean verify host ) { this . verify host = verify host ; return this ; }
public http client option set max wait queue size ( int max wait queue size ) { this . max wait queue size = max wait queue size ; return this ; }
public http client option set max header size ( int max header size ) { this . max header size = max header size ; return this ; }
public http client option set initial setting ( http2 setting setting ) { this . initial setting = setting ; return this ; }
public http server option set per message websocket compression support ( boolean support ) { this . per message web socket compression support = support ; return this ; }
public vertx http2 connection handler < c > add handler ( handler < c > handler ) { this . add handler = handler ; return this ; }
public request option set host ( string host ) { this . host = host ; return this ; }
public stream priority set weight ( short weight ) { this . weight = weight ; return this ; }
public http server option add web socket sub protocol ( string sub protocol ) { object . require non null ( sub protocol , `` can not add a null web socket sub-protocol `` ) ; if ( web socket sub protocol == null ) { web socket sub protocol = new array list < > ( ) ; } web socket sub protocol . add ( sub protocol ) ; return this ; }
public synchronize boolean be complete ( ) { return fail || succeed ; }
protect synchronized void shutdown redeployment ( ) { if ( watcher ! = null ) { watcher . close ( ) ; watcher = null ; } }
public void undeploy ( handler < async result < void > > completion handler ) { vertx . undeploy ( deployment id , res - > { if ( re . fail ( ) ) { log . error ( `` fail in undeploying `` + deployment id , re . cause ( ) ) ; } else { log . info ( `` succeed in undeploying `` + deployment id ) ; } deployment id = null ; completion handler . handle ( re ) ; } ) ; }
public synchronize boolean get connection ( handler < async result < c > > handler ) { if ( close ) { return false ; } waiter < c > waiter = new waiter < > ( handler ) ; waiter queue . add ( waiter ) ; check progress ( ) ; return true ; }
public void set volume ( final int volume ) { this . volume = volume ; }
public int get header count ( ) { return header . get count ( ) ; }
public int get header hole ( ) { return header . get hole ( ) ; }
public < t > t map to ( class < t > type ) { return json codec . instance . from value ( map , type ) ; }
public void execute ( string command , string . . . args ) { launcher . execute ( command , args ) ; }
public metric option set factory ( vertx metric factory factory ) { this . factory = factory ; return this ; }
public client option base set local address ( string local address ) { this . local address = local address ; return this ; }
public net server option set host ( string host ) { this . host = host ; return this ; }
public network option set send buffer size ( int send buffer size ) { argument . require ( send buffer size > 0 || send buffer size == default_send_buffer_size , `` send buffer size must be > 0 `` ) ; this . send buffer size = send buffer size ; return this ; }
public open s s l engine option set session cache enable ( boolean session cache enable ) { this . session cache enable = session cache enable ; return this ; }
public pfx option set password ( string password ) { this . password = password ; return this ; }
public proxy option set type ( proxy type type ) { object . require non null ( type , `` proxy type may not be null `` ) ; this . type = type ; return this ; }
public proxy option set username ( string username ) { this . username = username ; return this ; }
public t c p s s l option add crl value ( buffer crl value ) throw null pointer exception { object . require non null ( crl value , `` no null crl accept `` ) ; crl value . add ( crl value ) ; return this ; }
public vertx option set cluster port ( int cluster port ) { event bus option . set port ( cluster port ) ; return this ; }
public deployment option set ha ( boolean ha ) { this . ha = ha ; return this ; }
public io . vertx . reactivex . amqp . amqp connection close ( handler < async result < void > > do ) { delegate . close ( do ) ; return this ; }
public io . vertx . reactivex . amqp . amqp sender send ( io . vertx . reactivex . amqp . amqp message message ) { delegate . send ( message . get delegate ( ) ) ; return this ; }
public static io . vertx . reactivex . amqpbridge . amqp bridge create ( io . vertx . reactivex . core . vertx vertx ) { io . vertx . reactivex . amqpbridge . amqp bridge ret = io . vertx . reactivex . amqpbridge . amqp bridge . new instance ( ( io . vertx . amqpbridge . amqp bridge ) io . vertx . amqpbridge . amqp bridge . create ( vertx . get delegate ( ) ) ) ; return ret ; }
public void save ( t entity , handler < async result < void > > handler ) { delegate . save ( __type arg_0 . < t > unwrap ( entity ) , handler ) ; }
public void save ( t entity , handler < async result < void > > handler ) { delegate . save ( __type arg_0 . < t > unwrap ( entity ) , handler ) ; }
public io . vertx . reactivex . circuitbreaker . circuit breaker close handler ( handler < void > handler ) { delegate . close handler ( handler ) ; return this ; }
public < t > io . vertx . reactivex . core . eventbus . event bus add outbound interceptor ( handler < io . vertx . reactivex . core . eventbus . delivery context < t > > interceptor ) { delegate . add outbound interceptor ( new handler < io . vertx . core . eventbus . delivery context < t > > ( ) { public void handle ( io . vertx . core . eventbus . delivery context < t > event ) { interceptor . handle ( io . vertx . reactivex . core . eventbus . delivery context . new instance ( ( io . vertx . core . eventbus . delivery context ) event , type arg . unknown ( ) ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . core . http . http client request post ( int port , string host , string request u r i , handler < io . vertx . reactivex . core . http . http client response > response handler ) { io . vertx . reactivex . core . http . http client request ret = io . vertx . reactivex . core . http . http client request . new instance ( ( io . vertx . core . http . http client request ) delegate . post ( port , host , request u r i , new handler < io . vertx . core . http . http client response > ( ) { public void handle ( io . vertx . core . http . http client response event ) { response handler . handle ( io . vertx . reactivex . core . http . http client response . new instance ( ( io . vertx . core . http . http client response ) event ) ) ; } } ) ) ; return ret ; }
public io . vertx . reactivex . core . http . http client request option abs ( string absolute u r i , handler < io . vertx . reactivex . core . http . http client response > response handler ) { io . vertx . reactivex . core . http . http client request ret = io . vertx . reactivex . core . http . http client request . new instance ( ( io . vertx . core . http . http client request ) delegate . option abs ( absolute u r i , new handler < io . vertx . core . http . http client response > ( ) { public void handle ( io . vertx . core . http . http client response event ) { response handler . handle ( io . vertx . reactivex . core . http . http client response . new instance ( ( io . vertx . core . http . http client response ) event ) ) ; } } ) ) ; return ret ; }
public io . vertx . reactivex . core . http . http client request head ab ( string absolute u r i , handler < io . vertx . reactivex . core . http . http client response > response handler ) { io . vertx . reactivex . core . http . http client request ret = io . vertx . reactivex . core . http . http client request . new instance ( ( io . vertx . core . http . http client request ) delegate . head ab ( absolute u r i , new handler < io . vertx . core . http . http client response > ( ) { public void handle ( io . vertx . core . http . http client response event ) { response handler . handle ( io . vertx . reactivex . core . http . http client response . new instance ( ( io . vertx . core . http . http client response ) event ) ) ; } } ) ) ; return ret ; }
public io . vertx . reactivex . core . http . http client request head ( int port , string host , string request u r i , handler < io . vertx . reactivex . core . http . http client response > response handler ) { io . vertx . reactivex . core . http . http client request ret = io . vertx . reactivex . core . http . http client request . new instance ( ( io . vertx . core . http . http client request ) delegate . head ( port , host , request u r i , new handler < io . vertx . core . http . http client response > ( ) { public void handle ( io . vertx . core . http . http client response event ) { response handler . handle ( io . vertx . reactivex . core . http . http client response . new instance ( ( io . vertx . core . http . http client response ) event ) ) ; } } ) ) ; return ret ; }
public io . vertx . reactivex . core . http . http client option now ( int port , string host , string request u r i , handler < io . vertx . reactivex . core . http . http client response > response handler ) { delegate . option now ( port , host , request u r i , new handler < io . vertx . core . http . http client response > ( ) { public void handle ( io . vertx . core . http . http client response event ) { response handler . handle ( io . vertx . reactivex . core . http . http client response . new instance ( ( io . vertx . core . http . http client response ) event ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . core . http . http client request option ( io . vertx . core . http . request option option , handler < io . vertx . reactivex . core . http . http client response > response handler ) { io . vertx . reactivex . core . http . http client request ret = io . vertx . reactivex . core . http . http client request . new instance ( ( io . vertx . core . http . http client request ) delegate . option ( option , new handler < io . vertx . core . http . http client response > ( ) { public void handle ( io . vertx . core . http . http client response event ) { response handler . handle ( io . vertx . reactivex . core . http . http client response . new instance ( ( io . vertx . core . http . http client response ) event ) ) ; } } ) ) ; return ret ; }
public io . vertx . reactivex . core . http . http client request head ab ( string absolute u r i , handler < io . vertx . reactivex . core . http . http client response > response handler ) { io . vertx . reactivex . core . http . http client request ret = io . vertx . reactivex . core . http . http client request . new instance ( ( io . vertx . core . http . http client request ) delegate . head ab ( absolute u r i , new handler < io . vertx . core . http . http client response > ( ) { public void handle ( io . vertx . core . http . http client response event ) { response handler . handle ( io . vertx . reactivex . core . http . http client response . new instance ( ( io . vertx . core . http . http client response ) event ) ) ; } } ) ) ; return ret ; }
public io . vertx . reactivex . core . http . http client websocket ( io . vertx . core . http . request option option , io . vertx . reactivex . core . multi map header , io . vertx . core . http . websocket version version , handler < io . vertx . reactivex . core . http . web socket > w connect ) { delegate . websocket ( option , header . get delegate ( ) , version , new handler < io . vertx . core . http . web socket > ( ) { public void handle ( io . vertx . core . http . web socket event ) { ws connect . handle ( io . vertx . reactivex . core . http . web socket . new instance ( ( io . vertx . core . http . web socket ) event ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . core . http . http client websocket ( int port , string host , string request u r i , io . vertx . reactivex . core . multi map header , io . vertx . core . http . websocket version version , string sub protocol , handler < io . vertx . reactivex . core . http . web socket > w connect ) { delegate . websocket ( port , host , request u r i , header . get delegate ( ) , version , sub protocol , new handler < io . vertx . core . http . web socket > ( ) { public void handle ( io . vertx . core . http . web socket event ) { ws connect . handle ( io . vertx . reactivex . core . http . web socket . new instance ( ( io . vertx . core . http . web socket ) event ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . core . http . http server request upload handler ( handler < io . vertx . reactivex . core . http . http server file upload > upload handler ) { delegate . upload handler ( new handler < io . vertx . core . http . http server file upload > ( ) { public void handle ( io . vertx . core . http . http server file upload event ) { upload handler . handle ( io . vertx . reactivex . core . http . http server file upload . new instance ( ( io . vertx . core . http . http server file upload ) event ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . core . http . http server request upload handler ( handler < io . vertx . reactivex . core . http . http server file upload > upload handler ) { delegate . upload handler ( new handler < io . vertx . core . http . http server file upload > ( ) { public void handle ( io . vertx . core . http . http server file upload event ) { upload handler . handle ( io . vertx . reactivex . core . http . http server file upload . new instance ( ( io . vertx . core . http . http server file upload ) event ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . core . http . http server response end handler ( handler < void > handler ) { delegate . end handler ( handler ) ; return this ; }
public single < set < string > > rx subscription ( ) { return async result single . to single ( handler - > { subscription ( handler ) ; } ) ; }
public io . vertx . reactivex . ext . auth . chain auth append ( io . vertx . reactivex . ext . auth . auth provider other ) { delegate . append ( other . get delegate ( ) ) ; return this ; }
public string get hash stored pwd ( json array row ) { string ret = delegate . get hash stored pwd ( row ) ; return ret ; }
public io . vertx . reactivex . ext . auth . mongo . mongo auth set username credential field ( string field name ) { delegate . set username credential field ( field name ) ; return this ; }
public json object access token ( ) { if ( cached_0 ! = null ) { return cached_0 ; } json object ret = delegate . access token ( ) ; cached_0 = ret ; return ret ; }
public static string raw access token ( json object principal ) { string ret = io . vertx . ext . auth . oauth2 . keycloak helper . raw access token ( principal ) ; return ret ; }
public io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth miss key handler ( handler < string > handler ) { delegate . miss key handler ( handler ) ; return this ; }
public io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth miss key handler ( handler < string > handler ) { delegate . miss key handler ( handler ) ; return this ; }
public io . vertx . reactivex . core . multi map header ( ) { io . vertx . reactivex . core . multi map ret = io . vertx . reactivex . core . multi map . new instance ( ( io . vertx . core . multi map ) delegate . header ( ) ) ; return ret ; }
public static io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth create ( io . vertx . reactivex . core . vertx vertx , string client id , string client secret ) { io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth ret = io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth . new instance ( ( io . vertx . ext . auth . oauth2 . o auth2 auth ) io . vertx . ext . auth . oauth2 . provider . instagram auth . create ( vertx . get delegate ( ) , client id , client secret ) ) ; return ret ; }
public static io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth create ( io . vertx . reactivex . core . vertx vertx , string client id , string client secret , string uua u r l ) { io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth ret = io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth . new instance ( ( io . vertx . ext . auth . oauth2 . o auth2 auth ) io . vertx . ext . auth . oauth2 . provider . cloud foundry auth . create ( vertx . get delegate ( ) , client id , client secret , uua u r l ) ) ; return ret ; }
public int next int ( ) { int ret = delegate . next int ( ) ; return ret ; }
public static io . vertx . reactivex . ext . consul . consul client create ( io . vertx . reactivex . core . vertx vertx , io . vertx . ext . consul . consul client option option ) { io . vertx . reactivex . ext . consul . consul client ret = io . vertx . reactivex . ext . consul . consul client . new instance ( ( io . vertx . ext . consul . consul client ) io . vertx . ext . consul . consul client . create ( vertx . get delegate ( ) , option ) ) ; return ret ; }
public io . vertx . reactivex . ext . consul . consul client update acl token ( io . vertx . ext . consul . acl token token , handler < async result < string > > id handler ) { delegate . update acl token ( token , id handler ) ; return this ; }
public io . vertx . reactivex . ext . consul . consul client register check ( io . vertx . ext . consul . check option check option , handler < async result < void > > result handler ) { delegate . register check ( check option , result handler ) ; return this ; }
public io . vertx . reactivex . ext . consul . consul client deregister service ( string id , handler < async result < void > > result handler ) { delegate . deregister service ( id , result handler ) ; return this ; }
public io . vertx . reactivex . ext . consul . consul client pas check ( string check id , handler < async result < void > > result handler ) { delegate . pas check ( check id , result handler ) ; return this ; }
public io . vertx . reactivex . ext . consul . consul client create session ( handler < async result < string > > id handler ) { delegate . create session ( id handler ) ; return this ; }
public static io . vertx . reactivex . ext . mongo . mongo client create ( io . vertx . reactivex . core . vertx vertx , json object config ) { io . vertx . reactivex . ext . mongo . mongo client ret = io . vertx . reactivex . ext . mongo . mongo client . new instance ( ( io . vertx . ext . mongo . mongo client ) io . vertx . ext . mongo . mongo client . create ( vertx . get delegate ( ) , config ) ) ; return ret ; }
public io . vertx . reactivex . ext . mongo . mongo client replace document with option ( string collection , json object query , json object replace , io . vertx . ext . mongo . update option option , handler < async result < io . vertx . ext . mongo . mongo client update result > > result handler ) { delegate . replace document with option ( collection , query , replace , option , result handler ) ; return this ; }
public io . vertx . reactivex . ext . mongo . mongo client bulk write with option ( string collection , list < io . vertx . ext . mongo . bulk operation > operation , io . vertx . ext . mongo . bulk write option bulk write option , handler < async result < io . vertx . ext . mongo . mongo client bulk write result > > result handler ) { delegate . bulk write with option ( collection , operation , bulk write option , result handler ) ; return this ; }
public io . vertx . reactivex . ext . mongo . mongo client find one and replace ( string collection , json object query , json object replace , handler < async result < json object > > result handler ) { delegate . find one and replace ( collection , query , replace , result handler ) ; return this ; }
public io . vertx . reactivex . ext . mongo . mongo client drop collection ( string collection , handler < async result < void > > result handler ) { delegate . drop collection ( collection , result handler ) ; return this ; }
public void complete ( string value , boolean terminal ) { delegate . complete ( value , terminal ) ; }
public static io . vertx . reactivex . ext . shell . command . command registry create ( io . vertx . reactivex . core . vertx vertx ) { io . vertx . reactivex . ext . shell . command . command registry ret = io . vertx . reactivex . ext . shell . command . command registry . new instance ( ( io . vertx . ext . shell . command . command registry ) io . vertx . ext . shell . command . command registry . create ( vertx . get delegate ( ) ) ) ; return ret ; }
public io . vertx . reactivex . ext . shell . command . command registry register command ( io . vertx . reactivex . ext . shell . command . command command , handler < async result < io . vertx . reactivex . ext . shell . command . command > > completion handler ) { delegate . register command ( command . get delegate ( ) , new handler < async result < io . vertx . ext . shell . command . command > > ( ) { public void handle ( async result < io . vertx . ext . shell . command . command > ar ) { if ( ar . succeed ( ) ) { completion handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . ext . shell . command . command . new instance ( ( io . vertx . ext . shell . command . command ) ar . result ( ) ) ) ) ; } else { completion handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . ext . shell . command . command process end handler ( handler < void > handler ) { delegate . end handler ( handler ) ; return this ; }
public io . vertx . reactivex . ext . shell . session . session put ( string key , java . lang . object obj ) { delegate . put ( key , obj ) ; return this ; }
public static io . vertx . reactivex . ext . shell . shell server create ( io . vertx . reactivex . core . vertx vertx , io . vertx . ext . shell . shell server option option ) { io . vertx . reactivex . ext . shell . shell server ret = io . vertx . reactivex . ext . shell . shell server . new instance ( ( io . vertx . ext . shell . shell server ) io . vertx . ext . shell . shell server . create ( vertx . get delegate ( ) , option ) ) ; return ret ; }
public io . vertx . reactivex . ext . shell . system . job create job ( io . vertx . reactivex . ext . shell . system . process process , string line ) { io . vertx . reactivex . ext . shell . system . job ret = io . vertx . reactivex . ext . shell . system . job . new instance ( ( io . vertx . ext . shell . system . job ) delegate . create job ( process . get delegate ( ) , line ) ) ; return ret ; }
public io . vertx . reactivex . ext . shell . term . term suspend handler ( io . vertx . reactivex . ext . shell . term . signal handler handler ) { delegate . suspend handler ( handler . get delegate ( ) ) ; return this ; }
public io . vertx . reactivex . ext . shell . term . term suspend handler ( io . vertx . reactivex . ext . shell . term . signal handler handler ) { delegate . suspend handler ( handler . get delegate ( ) ) ; return this ; }
public io . vertx . reactivex . ext . sql . s q l connection batch ( list < string > sql statement , handler < async result < list < integer > > > handler ) { delegate . batch ( sql statement , handler ) ; return this ; }
public io . vertx . reactivex . ext . stomp . stomp client connection write frame handler ( handler < io . vertx . ext . stomp . frame > handler ) { delegate . write frame handler ( handler ) ; return this ; }
public io . vertx . reactivex . ext . stomp . stomp client connection exception handler ( handler < java . lang . throwable > exception handler ) { delegate . exception handler ( exception handler ) ; return this ; }
public io . vertx . reactivex . ext . stomp . stomp client connection send ( string destination , io . vertx . reactivex . core . buffer . buffer body ) { delegate . send ( destination , body . get delegate ( ) ) ; return this ; }
public io . vertx . reactivex . ext . stomp . stomp client connection nack ( string id ) { delegate . nack ( id ) ; return this ; }
public io . vertx . reactivex . ext . stomp . stomp server handler subscribe handler ( handler < io . vertx . reactivex . ext . stomp . server frame > handler ) { delegate . subscribe handler ( new handler < io . vertx . ext . stomp . server frame > ( ) { public void handle ( io . vertx . ext . stomp . server frame event ) { handler . handle ( io . vertx . reactivex . ext . stomp . server frame . new instance ( ( io . vertx . ext . stomp . server frame ) event ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . ext . stomp . stomp server handler on nack ( io . vertx . reactivex . ext . stomp . stomp server connection connection , io . vertx . ext . stomp . frame subscribe , list < io . vertx . ext . stomp . frame > message ) { delegate . on nack ( connection . get delegate ( ) , subscribe , message ) ; return this ; }
public io . vertx . reactivex . ext . stomp . stomp server handler ack handler ( handler < io . vertx . reactivex . ext . stomp . server frame > handler ) { delegate . ack handler ( new handler < io . vertx . ext . stomp . server frame > ( ) { public void handle ( io . vertx . ext . stomp . server frame event ) { handler . handle ( io . vertx . reactivex . ext . stomp . server frame . new instance ( ( io . vertx . ext . stomp . server frame ) event ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . ext . stomp . stomp server handler close handler ( handler < io . vertx . reactivex . ext . stomp . stomp server connection > handler ) { delegate . close handler ( new handler < io . vertx . ext . stomp . stomp server connection > ( ) { public void handle ( io . vertx . ext . stomp . stomp server connection event ) { handler . handle ( io . vertx . reactivex . ext . stomp . stomp server connection . new instance ( ( io . vertx . ext . stomp . stomp server connection ) event ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . ext . stomp . stomp server handler auth provider ( io . vertx . reactivex . ext . auth . auth provider handler ) { delegate . auth provider ( handler . get delegate ( ) ) ; return this ; }
public static io . vertx . reactivex . ext . unit . collect . event bus collector create ( io . vertx . reactivex . core . vertx vertx , io . vertx . ext . unit . report . report option option ) { io . vertx . reactivex . ext . unit . collect . event bus collector ret = io . vertx . reactivex . ext . unit . collect . event bus collector . new instance ( ( io . vertx . ext . unit . collect . event bus collector ) io . vertx . ext . unit . collect . event bus collector . create ( vertx . get delegate ( ) , option ) ) ; return ret ; }
public void await success ( ) { delegate . await success ( ) ; }
public io . vertx . reactivex . ext . unit . report . failure failure ( ) { if ( cached_5 ! = null ) { return cached_5 ; } io . vertx . reactivex . ext . unit . report . failure ret = io . vertx . reactivex . ext . unit . report . failure . new instance ( ( io . vertx . ext . unit . report . failure ) delegate . failure ( ) ) ; cached_5 = ret ; return ret ; }
public io . vertx . reactivex . ext . unit . async async ( ) { io . vertx . reactivex . ext . unit . async ret = io . vertx . reactivex . ext . unit . async . new instance ( ( io . vertx . ext . unit . async ) delegate . async ( ) ) ; return ret ; }
public io . vertx . reactivex . ext . unit . test suite after ( handler < io . vertx . reactivex . ext . unit . test context > callback ) { delegate . after ( new handler < io . vertx . ext . unit . test context > ( ) { public void handle ( io . vertx . ext . unit . test context event ) { callback . handle ( io . vertx . reactivex . ext . unit . test context . new instance ( ( io . vertx . ext . unit . test context ) event ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . ext . web . api . contract . openapi3 . open a p i3 router factory mount operation to event bus ( string operation id , string address ) { delegate . mount operation to event bus ( operation id , address ) ; return this ; }
public io . vertx . reactivex . ext . web . api . request parameter query parameter ( string name ) { io . vertx . reactivex . ext . web . api . request parameter ret = io . vertx . reactivex . ext . web . api . request parameter . new instance ( ( io . vertx . ext . web . api . request parameter ) delegate . query parameter ( name ) ) ; return ret ; }
public io . vertx . reactivex . ext . web . api . request parameter body ( ) { io . vertx . reactivex . ext . web . api . request parameter ret = io . vertx . reactivex . ext . web . api . request parameter . new instance ( ( io . vertx . ext . web . api . request parameter ) delegate . body ( ) ) ; return ret ; }
public boolean be string ( ) { boolean ret = delegate . be string ( ) ; return ret ; }
public io . vertx . reactivex . ext . web . api . request parameter cookie parameter ( string name ) { io . vertx . reactivex . ext . web . api . request parameter ret = io . vertx . reactivex . ext . web . api . request parameter . new instance ( ( io . vertx . ext . web . api . request parameter ) delegate . cookie parameter ( name ) ) ; return ret ; }
public io . vertx . reactivex . ext . web . api . request parameter query parameter ( string name ) { io . vertx . reactivex . ext . web . api . request parameter ret = io . vertx . reactivex . ext . web . api . request parameter . new instance ( ( io . vertx . ext . web . api . request parameter ) delegate . query parameter ( name ) ) ; return ret ; }
public io . vertx . reactivex . ext . web . api . validation . h t t p request validation handler add query param with pattern ( string parameter name , string pattern , boolean require ) { delegate . add query param with pattern ( parameter name , pattern , require ) ; return this ; }
public io . vertx . reactivex . ext . web . api . validation . h t t p request validation handler add header param with pattern ( string header name , string pattern , boolean require ) { delegate . add header param with pattern ( header name , pattern , require ) ; return this ; }
public io . vertx . reactivex . ext . web . api . validation . h t t p request validation handler add json body schema ( string json schema ) { delegate . add json body schema ( json schema ) ; return this ; }
public io . vertx . reactivex . ext . web . api . validation . h t t p request validation handler add path param ( string parameter name , io . vertx . ext . web . api . validation . parameter type type ) { delegate . add path param ( parameter name , type ) ; return this ; }
public io . vertx . reactivex . ext . web . api . request parameter be valid ( string value ) { io . vertx . reactivex . ext . web . api . request parameter ret = io . vertx . reactivex . ext . web . api . request parameter . new instance ( ( io . vertx . ext . web . api . request parameter ) delegate . be valid ( value ) ) ; return ret ; }
public io . vertx . reactivex . ext . web . api . validation . parameter type validator parameter type validator ( ) { io . vertx . reactivex . ext . web . api . validation . parameter type validator ret = io . vertx . reactivex . ext . web . api . validation . parameter type validator . new instance ( ( io . vertx . ext . web . api . validation . parameter type validator ) delegate . parameter type validator ( ) ) ; return ret ; }
public static io . vertx . reactivex . ext . web . api . validation . parameter type validator create integer type validator ( integer default value ) { io . vertx . reactivex . ext . web . api . validation . parameter type validator ret = io . vertx . reactivex . ext . web . api . validation . parameter type validator . new instance ( ( io . vertx . ext . web . api . validation . parameter type validator ) io . vertx . ext . web . api . validation . parameter type validator . create integer type validator ( default value ) ) ; return ret ; }
public io . vertx . reactivex . ext . web . client . http request < t > host ( string value ) { delegate . host ( value ) ; return this ; }
public io . vertx . reactivex . core . multi map query params ( ) { io . vertx . reactivex . core . multi map ret = io . vertx . reactivex . core . multi map . new instance ( ( io . vertx . core . multi map ) delegate . query params ( ) ) ; return ret ; }
public static io . vertx . reactivex . ext . web . client . predicate . response predicate status ( int status code ) { io . vertx . reactivex . ext . web . client . predicate . response predicate ret = io . vertx . reactivex . ext . web . client . predicate . response predicate . new instance ( ( io . vertx . ext . web . client . predicate . response predicate ) io . vertx . ext . web . client . predicate . response predicate . status ( status code ) ) ; return ret ; }
public io . vertx . reactivex . ext . web . client . http response < io . vertx . reactivex . core . buffer . buffer > response ( ) { io . vertx . reactivex . ext . web . client . http response < io . vertx . reactivex . core . buffer . buffer > ret = io . vertx . reactivex . ext . web . client . http response . new instance ( ( io . vertx . ext . web . client . http response ) delegate . response ( ) , type_arg_0 ) ; return ret ; }
public static io . vertx . reactivex . ext . web . client . web client wrap ( io . vertx . reactivex . core . http . http client http client ) { io . vertx . reactivex . ext . web . client . web client ret = io . vertx . reactivex . ext . web . client . web client . new instance ( ( io . vertx . ext . web . client . web client ) io . vertx . ext . web . client . web client . wrap ( http client . get delegate ( ) ) ) ; return ret ; }
public io . vertx . reactivex . ext . web . client . http request < io . vertx . reactivex . core . buffer . buffer > patch ( string request u r i ) { io . vertx . reactivex . ext . web . client . http request < io . vertx . reactivex . core . buffer . buffer > ret = io . vertx . reactivex . ext . web . client . http request . new instance ( ( io . vertx . ext . web . client . http request ) delegate . patch ( request u r i ) , type_arg_26 ) ; return ret ; }
public void parse credential ( io . vertx . reactivex . ext . web . rout context context , handler < async result < json object > > handler ) { delegate . parse credential ( context . get delegate ( ) , handler ) ; }
public static redirect auth handler new instance ( io . vertx . ext . web . handler . redirect auth handler arg ) { return arg ! = null ? new redirect auth handler ( arg ) : null ; }
public io . vertx . reactivex . ext . web . handler . body handler set body limit ( long body limit ) { delegate . set body limit ( body limit ) ; return this ; }
public io . vertx . reactivex . ext . web . handler . cors handler allow header ( string header name ) { delegate . allow header ( header name ) ; return this ; }
public io . vertx . reactivex . ext . web . handler . cors handler allow header ( string header name ) { delegate . allow header ( header name ) ; return this ; }
public io . vertx . reactivex . ext . web . handler . c s r f handler set timeout ( long timeout ) { delegate . set timeout ( timeout ) ; return this ; }
public static io . vertx . reactivex . ext . web . handler . digest auth handler create ( io . vertx . reactivex . ext . auth . htdigest . htdigest auth auth provider ) { io . vertx . reactivex . ext . web . handler . digest auth handler ret = io . vertx . reactivex . ext . web . handler . digest auth handler . new instance ( ( io . vertx . ext . web . handler . digest auth handler ) io . vertx . ext . web . handler . digest auth handler . create ( auth provider . get delegate ( ) ) ) ; return ret ; }
public static static handler new instance ( io . vertx . ext . web . handler . static handler arg ) { return arg ! = null ? new static handler ( arg ) : null ; }
public io . vertx . reactivex . ext . web . handler . multi tenant handler add tenant handler ( string tenant , handler < io . vertx . reactivex . ext . web . rout context > handler ) { delegate . add tenant handler ( tenant , new handler < io . vertx . ext . web . rout context > ( ) { public void handle ( io . vertx . ext . web . rout context event ) { handler . handle ( io . vertx . reactivex . ext . web . rout context . new instance ( ( io . vertx . ext . web . rout context ) event ) ) ; } } ) ; return this ; }
public static io . vertx . reactivex . ext . web . handler . o auth2 auth handler create ( io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth auth provider ) { io . vertx . reactivex . ext . web . handler . o auth2 auth handler ret = io . vertx . reactivex . ext . web . handler . o auth2 auth handler . new instance ( ( io . vertx . ext . web . handler . o auth2 auth handler ) io . vertx . ext . web . handler . o auth2 auth handler . create ( auth provider . get delegate ( ) ) ) ; return ret ; }
public io . vertx . reactivex . ext . web . handler . session handler set lazy session ( boolean lazy session ) { delegate . set lazy session ( lazy session ) ; return this ; }
public static io . vertx . reactivex . ext . web . handler . sockjs . sock j s handler create ( io . vertx . reactivex . core . vertx vertx ) { io . vertx . reactivex . ext . web . handler . sockjs . sock j s handler ret = io . vertx . reactivex . ext . web . handler . sockjs . sock j s handler . new instance ( ( io . vertx . ext . web . handler . sockjs . sock j s handler ) io . vertx . ext . web . handler . sockjs . sock j s handler . create ( vertx . get delegate ( ) ) ) ; return ret ; }
public string write handler i d ( ) { string ret = delegate . write handler i d ( ) ; return ret ; }
public io . vertx . reactivex . ext . web . handler . static handler set web root ( string web root ) { delegate . set web root ( web root ) ; return this ; }
public float weight ( ) { float ret = delegate . weight ( ) ; return ret ; }
public string sub component ( ) { string ret = delegate . sub component ( ) ; return ret ; }
public io . vertx . reactivex . ext . web . route method ( io . vertx . core . http . http method method ) { delegate . method ( method ) ; return this ; }
public io . vertx . reactivex . ext . web . route route with regex ( string regex ) { io . vertx . reactivex . ext . web . route ret = io . vertx . reactivex . ext . web . route . new instance ( ( io . vertx . ext . web . route ) delegate . route with regex ( regex ) ) ; return ret ; }
public io . vertx . reactivex . ext . web . route route with regex ( string regex ) { io . vertx . reactivex . ext . web . route ret = io . vertx . reactivex . ext . web . route . new instance ( ( io . vertx . ext . web . route ) delegate . route with regex ( regex ) ) ; return ret ; }
public io . vertx . reactivex . ext . web . route route ( ) { io . vertx . reactivex . ext . web . route ret = io . vertx . reactivex . ext . web . route . new instance ( ( io . vertx . ext . web . route ) delegate . route ( ) ) ; return ret ; }
public io . vertx . reactivex . ext . web . router exception handler ( handler < java . lang . throwable > exception handler ) { delegate . exception handler ( exception handler ) ; return this ; }
public io . vertx . reactivex . ext . web . router modify handler ( handler < io . vertx . reactivex . ext . web . router > handler ) { delegate . modify handler ( new handler < io . vertx . ext . web . router > ( ) { public void handle ( io . vertx . ext . web . router event ) { handler . handle ( io . vertx . reactivex . ext . web . router . new instance ( ( io . vertx . ext . web . router ) event ) ) ; } } ) ; return this ; }
public void fail ( int status code ) { delegate . fail ( status code ) ; }
public io . vertx . reactivex . ext . auth . user user ( ) { io . vertx . reactivex . ext . auth . user ret = io . vertx . reactivex . ext . auth . user . new instance ( ( io . vertx . ext . auth . user ) delegate . user ( ) ) ; return ret ; }
public void get ( string cookie value , handler < async result < io . vertx . reactivex . ext . web . session > > result handler ) { delegate . get ( cookie value , new handler < async result < io . vertx . ext . web . session > > ( ) { public void handle ( async result < io . vertx . ext . web . session > ar ) { if ( ar . succeed ( ) ) { result handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . ext . web . session . new instance ( ( io . vertx . ext . web . session ) ar . result ( ) ) ) ) ; } else { result handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; }
public io . vertx . reactivex . ext . web . session create session ( long timeout , int length ) { io . vertx . reactivex . ext . web . session ret = io . vertx . reactivex . ext . web . session . new instance ( ( io . vertx . ext . web . session ) delegate . create session ( timeout , length ) ) ; return ret ; }
public static io . vertx . reactivex . ext . web . templ . freemarker . free marker template engine create ( io . vertx . reactivex . core . vertx vertx ) { io . vertx . reactivex . ext . web . templ . freemarker . free marker template engine ret = io . vertx . reactivex . ext . web . templ . freemarker . free marker template engine . new instance ( ( io . vertx . ext . web . templ . freemarker . free marker template engine ) io . vertx . ext . web . templ . freemarker . free marker template engine . create ( vertx . get delegate ( ) ) ) ; return ret ; }
public single < set < string > > rx subscription ( ) { return async result single . to single ( handler - > { subscription ( handler ) ; } ) ; }
public io . vertx . reactivex . kafka . client . consumer . kafka consumer < k , v > pause ( io . vertx . kafka . client . common . topic partition topic partition ) { delegate . pause ( topic partition ) ; return this ; }
public single < set < string > > rx subscription ( ) { return async result single . to single ( handler - > { subscription ( handler ) ; } ) ; }
public static io . vertx . reactivex . mqtt . mqtt client create ( io . vertx . reactivex . core . vertx vertx , io . vertx . mqtt . mqtt client option option ) { io . vertx . reactivex . mqtt . mqtt client ret = io . vertx . reactivex . mqtt . mqtt client . new instance ( ( io . vertx . mqtt . mqtt client ) io . vertx . mqtt . mqtt client . create ( vertx . get delegate ( ) , option ) ) ; return ret ; }
public io . vertx . reactivex . mqtt . mqtt endpoint publish ( string topic , io . vertx . reactivex . core . buffer . buffer payload , io . netty . handler . codec . mqtt . mqtt qo s qos level , boolean be dup , boolean be retain , int message id , handler < async result < integer > > publish send handler ) { delegate . publish ( topic , payload . get delegate ( ) , qos level , be dup , be retain , message id , publish send handler ) ; return this ; }
public io . vertx . reactivex . mqtt . mqtt client subscribe ( java . util . map < string , integer > topic , handler < async result < integer > > subscribe send handler ) { delegate . subscribe ( topic , subscribe send handler ) ; return this ; }
public io . vertx . reactivex . mqtt . mqtt endpoint publish receive handler ( handler < integer > handler ) { delegate . publish receive handler ( handler ) ; return this ; }
public io . vertx . reactivex . mqtt . mqtt endpoint publish release ( int publish message id ) { delegate . publish release ( publish message id ) ; return this ; }
public io . vertx . reactivex . mqtt . mqtt server listen ( int port , string host ) { delegate . listen ( port , host ) ; return this ; }
public io . vertx . reactivex . mysqlclient . my s q l connection ping ( handler < async result < void > > handler ) { delegate . ping ( handler ) ; return this ; }
public void basic consumer ( string queue , io . vertx . rabbitmq . queue option option , handler < async result < io . vertx . reactivex . rabbitmq . rabbit m q consumer > > result handler ) { delegate . basic consumer ( queue , option , new handler < async result < io . vertx . rabbitmq . rabbit m q consumer > > ( ) { public void handle ( async result < io . vertx . rabbitmq . rabbit m q consumer > ar ) { if ( ar . succeed ( ) ) { result handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . rabbitmq . rabbit m q consumer . new instance ( ( io . vertx . rabbitmq . rabbit m q consumer ) ar . result ( ) ) ) ) ; } else { result handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; }
public void wait for confirms ( handler < async result < void > > result handler ) { delegate . wait for confirms ( result handler ) ; }
public void basic consumer ( string queue , io . vertx . rabbitmq . queue option option , handler < async result < io . vertx . reactivex . rabbitmq . rabbit m q consumer > > result handler ) { delegate . basic consumer ( queue , option , new handler < async result < io . vertx . rabbitmq . rabbit m q consumer > > ( ) { public void handle ( async result < io . vertx . rabbitmq . rabbit m q consumer > ar ) { if ( ar . succeed ( ) ) { result handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . rabbitmq . rabbit m q consumer . new instance ( ( io . vertx . rabbitmq . rabbit m q consumer ) ar . result ( ) ) ) ) ; } else { result handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; }
public static io . vertx . reactivex . redis . client . redis create client ( io . vertx . reactivex . core . vertx vertx , string connection string ) { io . vertx . reactivex . redis . client . redis ret = io . vertx . reactivex . redis . client . redis . new instance ( ( io . vertx . redis . client . redis ) io . vertx . redis . client . redis . create client ( vertx . get delegate ( ) , connection string ) ) ; return ret ; }
public io . vertx . reactivex . redis . client . redis a p i client ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . client ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i client ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . client ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i client ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . client ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i georadiusbymember ro ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . georadiusbymember ro ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i renamenx ( string arg0 , string arg1 , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . renamenx ( arg0 , arg1 , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i client ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . client ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i client ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . client ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i substr ( string arg0 , string arg1 , string arg2 , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . substr ( arg0 , arg1 , arg2 , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i substr ( string arg0 , string arg1 , string arg2 , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . substr ( arg0 , arg1 , arg2 , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i client ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . client ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i ask ( handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . ask ( new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i client ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . client ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i substr ( string arg0 , string arg1 , string arg2 , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . substr ( arg0 , arg1 , arg2 , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i client ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . client ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i client ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . client ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i substr ( string arg0 , string arg1 , string arg2 , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . substr ( arg0 , arg1 , arg2 , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i client ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . client ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . response get ( int index ) { io . vertx . reactivex . redis . client . response ret = io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) delegate . get ( index ) ) ; return ret ; }
public io . vertx . reactivex . redis . client . response get ( int index ) { io . vertx . reactivex . redis . client . response ret = io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) delegate . get ( index ) ) ; return ret ; }
public io . vertx . reactivex . redis . client . response get ( int index ) { io . vertx . reactivex . redis . client . response ret = io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) delegate . get ( index ) ) ; return ret ; }
public io . vertx . reactivex . redis . redis client blpop ( string key , int second , handler < async result < json array > > handler ) { delegate . blpop ( key , second , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client client getname ( handler < async result < string > > handler ) { delegate . client getname ( handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client command count ( handler < async result < long > > handler ) { delegate . command count ( handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client del many ( list < string > key , handler < async result < long > > handler ) { delegate . del many ( key , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client pfadd ( string key , string element , handler < async result < long > > handler ) { delegate . pfadd ( key , element , handler ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i hmget ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . hmget ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . redis client client kill ( io . vertx . redis . op . kill filter filter , handler < async result < long > > handler ) { delegate . client kill ( filter , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client client getname ( handler < async result < string > > handler ) { delegate . client getname ( handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client client kill ( io . vertx . redis . op . kill filter filter , handler < async result < long > > handler ) { delegate . client kill ( filter , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client psubscribe many ( list < string > pattern , handler < async result < json array > > handler ) { delegate . psubscribe many ( pattern , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client pubsub channel ( string pattern , handler < async result < json array > > handler ) { delegate . pubsub channel ( pattern , handler ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i sdiff ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . sdiff ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . redis client client getname ( handler < async result < string > > handler ) { delegate . client getname ( handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client linsert ( string key , io . vertx . redis . op . insert option option , string pivot , string value , handler < async result < long > > handler ) { delegate . linsert ( key , option , pivot , value , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client zrem ( string key , string member , handler < async result < long > > handler ) { delegate . zrem ( key , member , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client zremrangebyrank ( string key , long start , long stop , handler < async result < long > > handler ) { delegate . zremrangebyrank ( key , start , stop , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client linsert ( string key , io . vertx . redis . op . insert option option , string pivot , string value , handler < async result < long > > handler ) { delegate . linsert ( key , option , pivot , value , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client eval ( string script , list < string > key , list < string > args , handler < async result < json array > > handler ) { delegate . eval ( script , key , args , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client client kill ( io . vertx . redis . op . kill filter filter , handler < async result < long > > handler ) { delegate . client kill ( filter , handler ) ; return this ; }
public io . vertx . reactivex . redis . sentinel . redis sentinel master ( handler < async result < json array > > handler ) { delegate . master ( handler ) ; return this ; }
public static io . vertx . servicediscovery . record create record ( string name , string address , string type , json object metadata ) { io . vertx . servicediscovery . record ret = io . vertx . servicediscovery . type . message source . create record ( name , address , type , metadata ) ; return ret ; }
public static io . vertx . servicediscovery . record create record ( string name , string address , string type , json object metadata ) { io . vertx . servicediscovery . record ret = io . vertx . servicediscovery . type . message source . create record ( name , address , type , metadata ) ; return ret ; }
public int get column index ( string name ) { int ret = delegate . get column index ( name ) ; return ret ; }
public io . vertx . reactivex . sqlclient . tuple add long ( long value ) { delegate . add long ( value ) ; return this ; }
public io . vertx . reactivex . sqlclient . tuple add double ( double value ) { delegate . add double ( value ) ; return this ; }
public io . vertx . reactivex . sqlclient . tuple add buffer ( io . vertx . reactivex . core . buffer . buffer value ) { delegate . add buffer ( value . get delegate ( ) ) ; return this ; }
public int size ( ) { int ret = delegate . size ( ) ; return ret ; }
public io . vertx . reactivex . sqlclient . tuple add string ( string value ) { delegate . add string ( value ) ; return this ; }
public io . vertx . reactivex . sqlclient . tuple add boolean array ( java . lang . boolean [ ] value ) { io . vertx . reactivex . sqlclient . tuple ret = io . vertx . reactivex . sqlclient . tuple . new instance ( ( io . vertx . sqlclient . tuple ) delegate . add boolean array ( value ) ) ; return ret ; }
public static void assert visibly equal ( string message , object expect , object actual ) { string expect in quote = in quote if not null ( expect ) ; string actual in quote = in quote if not null ( actual ) ; if ( be both null ( expect , actual ) ) { pas ( message ) ; } else if ( be object equal ( string . value of ( expect ) , string . value of ( actual ) ) ) { pas ( message ) ; } else { fail ( message , actual in quote + `` after to string ( ) do not equal expect `` + expect in quote ) ; } }
public void add transfer listener ( final transfer listener listener ) { listener . add ( listener ) ; }
public long get timestamp ( ) { return timestamp ; }
public string get directory mode ( ) { return directory mode ; }
public int available ( ) { final long avail = size - position ; if ( avail < = 0 ) { return 0 ; } if ( avail > integer . max_value ) { return integer . max_value ; } return ( int ) avail ; }
public void set include method list ( string csv method ) { set include method ( string util . csv split ( csv method ) ) ; }
protect void set closure delegate ( closure closure , object node ) { closure . set delegate ( this ) ; }
public void set extension ( list < extension config > configs ) { this . extension . clear ( ) ; if ( configs ! = null ) { this . extension . add all ( configs ) ; } }
public void set sub protocol ( list < string > protocol ) { this . sub protocol . clear ( ) ; if ( protocol ! = null ) { this . sub protocol . add all ( protocol ) ; } }
public http servlet map get http servlet mapping ( ) { return this . _get http servlet request ( ) . get http servlet mapping ( ) ; }
public static int index of ( byte [ ] byte , byte [ ] pattern , int start ) { if ( pattern . length == 0 ) { return start ; } if ( start > byte . length ) { return -1 ; } int last = byte . length - pattern . length + 1 ; int pattern len = pattern . length ; next : for ( ; start < last ; start++ ) { for ( int i = 0 ; i < pattern len ; i++ ) { if ( bytes [ start + i ] ! = pattern [ i ] ) { continue next ; } } return start ; } return -1 ; }
public static byte [ ] trim ( byte [ ] bytes ) { int end = byte . length - 1 ; for ( int i = end ; i > -1 ; i -- ) { if ( bytes [ i ] ! = 0 ) { end = i ; break ; } } if ( end == byte . length - 1 ) { return byte ; } byte [ ] ret = new byte [ end + 1 ] ; system . arraycopy ( byte , 0 , ret , 0 , end + 1 ) ; return ret ; }
public static string normalize class name ( class type ) { if ( ! type . be array ( ) ) return type . get name ( ) ; string buffer class name = new string buffer ( ) ; try { class name . append ( get array base type ( type ) . get name ( ) + `` `` ) ; for ( int i = 0 ; i < get array dimension ( type ) ; i++ ) class name . append ( `` [ ] `` ) ; } catch ( reflect error e ) { / * should n't happen * / } return class name . to string ( ) ; }
public context permission without action ( string action ) { return without action bit ( parse action ( action ) ) ; }
public static int get small instruction cache line size ( ) { int min size = integer . max_value ; for ( cache level info cache level : cache level ) { if ( cache level . get cache type ( ) . be instruction ( ) ) { final int cache line size = cache level . get cache line size ( ) ; if ( cache line size ! = 0 & & cache line size < min size ) { min size = cache line size ; } } } return min size == integer . max_value ? 0 : min size ; }
public int get cache level size k b ( ) { return cache level size k b ; }
public void expand default ( string builder target ) throw e { if ( current == null ) throw new illegal state exception ( ) ; emit to builder ( target , current . get default value ( ) ) ; }
public final boolean contain all ( final collection < ? > c ) { if ( c . get class ( ) == get class ( ) ) { return contain all ( cast this ( c ) ) ; } else { for ( object o : c ) { if ( ! contains ( o ) ) return false ; } return true ; } }
public string to string ( ) { return new string ( to byte array ( ) ) ; }
public code point iterator skip ( int predicate predicate ) { if ( ! have next ( ) ) { return empty ; } return new skip code point iterator ( this , predicate ) ; }
public static code point iterator of latin1 byte ( final byte [ ] bytes ) { return of latin1 byte ( byte , 0 , byte . length ) ; }
public boolean content equal ( string other ) { return content equal ( code point iterator . of string ( other ) ) ; }
public void lock interruptibly ( ) throw interrupted exception { thread owner ; int spin = 0 ; for ( ; ; ) { if ( thread . interrupt ( ) ) throw new interrupt exception ( ) ; owner = this . owner ; if ( owner == thread . current thread ( ) ) { level++ ; return ; } else if ( owner == null & & unsafe . compare and swap object ( this , owner offset , null , thread . current thread ( ) ) ) { level = 1 ; return ; } else if ( spin > = spin limit ) { thread . yield ( ) ; } else { j d k specific . on spin wait ( ) ; spins++ ; } } }
public static inet socket address get resolve ( uri uri , int default port , class < ? extend inet address > address type ) throw unknown host exception { assert . check not null param ( `` uri `` , uri ) ; assert . check minimum parameter ( `` default port `` , 1 , default port ) ; assert . check maximum parameter ( `` default port `` , 65535 , default port ) ; assert . check not null param ( `` address type `` , address type ) ; final inet address resolve = get resolve inet address ( uri , address type ) ; if ( resolve == null ) { return null ; } final int uri port = uri . get port ( ) ; return uri port ! = - 1 ? new inet socket address ( resolve , uri port ) : new inet socket address ( resolve , default port ) ; }
public int get scope id ( ) { return inet . get scope id ( get network address ( ) ) ; }
public static boolean be inet4 address ( string address ) { return parse inet4 address to byte ( address ) ! = null ; }
public static string get filename ( string path ) { if ( path == null ) { return null ; } int separator index = path . last index of ( folder_separator ) ; return ( separator index ! = -1 ? path . substring ( separator index + 1 ) : path ) ; }
public void put ( t key , int value ) { final object [ ] key = this . key ; final int mask = key . length - 1 ; final int [ ] value = this . value ; object v ; int hc = system . identity hash code ( key ) & mask ; for ( int idx = hc ; ; idx = hc++ & mask ) { v = key [ idx ] ; if ( v == null ) { key [ idx ] = key ; value [ idx ] = value ; if ( ++count > resize count ) { resize ( ) ; } return ; } if ( v == key ) { value [ idx ] = value ; return ; } } }
public string get field value ( string field name ) { assert . check not null param ( `` field name `` , field name ) ; return field . get ( field name ) ; }
public void validation complete ( boolean eod ) throw x m l stream exception { / * need to now ensure that all idref/idrefs reference * point to define id attribute * / check id ref ( ) ; }
public void normalize default ( ) { string val = m def value . get value ( ) ; if ( val . length ( ) > 0 ) { char [ ] cbuf = val . to char array ( ) ; string str = string util . normalize space ( cbuf , 0 , cbuf . length ) ; if ( str ! = null ) { m def value . set value ( str ) ; } } }
public model node clone model ( ) { int len = m sub model . length ; model node [ ] new model = new model node [ len ] ; for ( int i = 0 ; i < len ; ++i ) { new model [ i ] = m sub model [ i ] . clone model ( ) ; } return new choice model ( new model ) ; }
public void set input offset ( int proc , int row , int row start ) { m input process = proc ; m input row = row ; m input row start = row start ; }
protect final void alloc buffer ( ) { if ( m attribute == null ) { m attribute = new attribute [ 8 ] ; } if ( m value builder == null ) { m value builder = new text builder ( exp_attr_count ) ; } }
public final int get id attribute index ( ) { if ( m id attr index > = 0 ) { return m id attr index ; } return ( m validator == null ) ? -1 : m validator . get id attr index ( ) ; }
protect element id map get id map ( ) { if ( m id map == null ) { m id map = new element id map ( ) ; } return m id map ; }
public string get string ( string path ) { object object = get ( path ) ; return convert object to ( object , string . class ) ; }
public string get string ( string path ) { object object = get ( path ) ; return convert object to ( object , string . class ) ; }
public final int get day ( ) { return _d ; }
public void set year ( int year ) { _cy = year ; }
public static string non java keyword ( string word ) { if ( be java reserve word ( word ) ) return ' x ' + word ; return word ; }
public static boolean be name start ( int c ) { return c < 0x10000 & & ( char [ c ] & mask_name_start ) ! = 0 ; } // be name start ( int ) : boolean
public name set intersect ( name set with ) { if ( _is finite ) { if ( with . _is finite ) { return new instance ( true , intersect finite set ( _finite set , with . _finite set ) ) ; } else { set subst = new hash set ( ) ; subst . add all ( _finite set ) ; subst . remove all ( with . _finite set ) ; return new instance ( false , subst ) ; } } else { if ( with . _is finite ) { set subst = new hash set ( ) ; subst . add all ( with . _finite set ) ; subst . remove all ( _finite set ) ; return new instance ( true , subst ) ; } else { set union = new hash set ( ) ; union . add all ( _finite set ) ; union . add all ( with . _finite set ) ; return new instance ( false , union ) ; } } }
public string get value ( ) { return value ; }
public void set header ( string name , string value ) { boolean flag = false ; if ( ( name == null ) || name . equal ( `` `` ) ) { throw new illegal argument exception ( `` illegal mime header name `` ) ; } for ( int i = 0 ; i < header . size ( ) ; i++ ) { mime header mimeheader = ( mime header ) header . element at ( i ) ; if ( mimeheader . get name ( ) . equal ignore case ( name ) ) { if ( ! flag ) { header . set element at ( new mime header ( mimeheader . get name ( ) , value ) , i ) ; flag = true ; } else { header . remove element at ( i -- ) ; } } } if ( ! flag ) { add header ( name , value ) ; } }
public void set content id ( string content id ) { set mime header ( `` content- id `` , content id ) ; }
final protect boolean be char node after usable ( ) { if ( _src after == null ) return false ; if ( _char node after ! = null & & _char node after . _next == null & & _char node after . _cch == this . _cch after ) return true ; return ( _char node after = cur . update char node ( _locale , this , _char node after , _cch after ) ) ! = null ; }
public schema import resolver . schema resource lookup resource ( string ns u r i , string schema location ) { schema resource result = fetch from cache ( ns u r i , schema location ) ; if ( result ! = null ) { if ( _redownload set ! = null ) { redownload resource ( result ) ; } return result ; } if ( schema location == null ) { warning ( `` no cached schema for namespace ' `` + n u r i + `` ' , and no url specify `` ) ; return null ; } result = copy or identify duplicate u r l ( schema location , ns u r i ) ; if ( _redownload set ! = null ) _redownload set . add ( result ) ; return result ; }
protect string [ ] get all x s d filename ( ) { file [ ] all file = ( file [ ] ) collect x s d file ( new file [ ] { _directory } ) . to array ( new file [ 0 ] ) ; return relative filename ( all file , _directory ) ; }
public void set debug ( boolean debug ) { this . debug = debug ; }
public void set destfile ( file destfile ) { this . destfile = destfile ; }
public void set classpath ( path classpath ) { if ( this . classpath ! = null ) this . classpath . append ( classpath ) ; else this . classpath = classpath ; }
public void move value target ( deserializer other ) { if ( ( other == null ) || ( other . get value target ( ) == null ) ) { return ; } if ( target == null ) { target = new vector ( ) ; } target . add all ( other . get value target ( ) ) ; other . remove value target ( ) ; }
public byte [ ] encode ( final byte [ ] array ) { return encode hex string ( array ) . get byte ( this . get charset ( ) ) ; }
public void add namespace ( string uri ) { if ( ! _inverted ) add namespace impl ( uri ) ; else remove namespace impl ( uri ) ; }
public void add all ( q name set specification set ) { if ( _inverted ) remove all impl ( set . include u r be ( ) , set . exclude u r be ( ) , set . included q name in excluded u r be ( ) , set . excluded q name in included u r be ( ) ) ; else add all impl ( set . include u r be ( ) , set . exclude u r be ( ) , set . included q name in excluded u r be ( ) , set . excluded q name in included u r be ( ) ) ; }
public xml any simple type new value ( object obj ) { return new value ( obj , false ) ; }
public static string [ ] parse fully qualify method name ( string fully qualify method name ) { precondition . not blank ( fully qualify method name , `` fully qualified method name must not be null or blank `` ) ; int index of first hashtag = fully qualify method name . index of ( ' # ' ) ; boolean valid syntax = ( index of first hashtag > 0 ) & & ( index of first hashtag < fully qualify method name . length ( ) - 1 ) ; precondition . condition ( valid syntax , ( ) - > `` [ `` + fully qualify method name + `` ] be not a valid fully qualify method name : `` + `` it must start with a fully qualified class name follow by a ' # ' `` + `` and then the method name , optionally follow by a parameter list enclose in parenthesis . `` ) ; string class name = fully qualify method name . substring ( 0 , index of first hashtag ) ; string method part = fully qualify method name . substring ( index of first hashtag + 1 ) ; string method name = method part ; string method parameter = `` `` ; if ( method part . end with ( `` ( ) `` ) ) { method name = method part . substring ( 0 , method part . length ( ) - 2 ) ; } else if ( method part . end with ( `` ) `` ) ) { int index of last opening parenthesis = method part . last index of ( ' ( ' ) ; if ( ( index of last opening parenthesis > 0 ) & & ( index of last opening parenthesis < method part . length ( ) - 1 ) ) { method name = method part . substring ( 0 , index of last opening parenthesis ) ; method parameter = method part . substring ( index of last opening parenthesis + 1 , method part . length ( ) - 1 ) ; } } return new string [ ] { class name , method name , method parameter } ; }
public int [ ] get dimension ( ) { int [ ] result = new int [ _dimensions . length ] ; system . arraycopy ( _dimensions , 0 , result , 0 , result . length ) ; return result ; }
public int [ ] get dimension ( ) { int [ ] result = new int [ _dimensions . length ] ; system . arraycopy ( _dimensions , 0 , result , 0 , result . length ) ; return result ; }
public final int hash code ( ) { return _string . hash code ( ) ; }
public byte [ ] get message digest ( ) { return ( byte [ ] ) get ( message_digest ) ; }
public xml option set save pretty print indent ( int indent ) { return set ( save_pretty_print_indent , indent ) ; }
public xml option set use c data bookmark ( ) { return set ( load_save_cdata_bookmarks ) ; }
public xml option set save pretty print indent ( int indent ) { return set ( save_pretty_print_indent , indent ) ; }
public catalog result lookup system ( string a system id ) { logger . trace ( `` lookup system ( `` + a system id + `` ) `` ) ; final string system id = u r i utils . normalize u r i ( a system id ) ; if ( system id ! = null & & system id . start with ( `` urn : publicid : `` ) ) { return lookup public ( public id . decode u r n ( system id ) , null ) ; } return lookup in doc or cache ( new lookup function ( ) { public catalog result apply ( element doc elem ) { return lookup local system ( doc elem , system id ) ; } } ) ; }
public catalog result lookup system ( string a system id ) { logger . trace ( `` lookup system ( `` + a system id + `` ) `` ) ; final string system id = u r i utils . normalize u r i ( a system id ) ; if ( system id ! = null & & system id . start with ( `` urn : publicid : `` ) ) { return lookup public ( public id . decode u r n ( system id ) , null ) ; } return lookup in doc or cache ( new lookup function ( ) { public catalog result apply ( element doc elem ) { return lookup local system ( doc elem , system id ) ; } } ) ; }
public string content type ( ) { return content type ; }
public string uri ( ) { return uri ; }
public string content type ( ) { return content type ; }
public void start element ( string uri , string local name , string q name , attribute atts ) throw s a x exception { process x m l catalog p i = false ; super . start element ( uri , local name , q name , atts ) ; }
public diff builder ignore element content whitespace ( ) { ignore e c w = true ; return this ; }
public diff builder check for similar ( ) { comparison result to check = check_for_similar ; return this ; }
protect comparison controller get comparison controller ( ) { return comparison controller ; }
public void add comparison listener ( comparison listener l ) { comp listener . add ( l ) ; }
public static element selector by name and attribute ( string . . . attribs ) { if ( attribs == null ) { throw new illegal argument exception ( attributes_must_not_be_null ) ; } if ( any ( array . a list ( attribs ) , new be null predicate ( ) ) ) { throw new illegal argument exception ( attributes_must_not_contain_null_values ) ; } q name [ ] q = new q name [ attribs . length ] ; for ( int i = 0 ; i < attribs . length ; i++ ) { qs [ i ] = new q name ( attribs [ i ] ) ; } return by name and attribute ( q ) ; }
public static document to document ( source s ) { document d = try extract doc from d o m source ( s ) ; return d ! = null ? d : to document ( s , document builder factory configurer . default . configure ( document builder factory . new instance ( ) ) ) ; }
protect string get schema u r i ( ) { return schema u r i ; }
protect string get schema u r i ( ) { return schema u r i ; }
public iterable < validation problem > get problem ( ) { return problem ; }
public final expression optimize ( expression visitor visitor , item type context item type ) { return this ; }
public static method get method ( class < ? > clazz , string method name , int num params ) { method [ ] method = clazz . get method ( ) ; for ( method method : method ) { if ( method . be synthetic ( ) == false & & method . get name ( ) . equal ( method name ) ) { class < ? > [ ] params = method . get parameter type ( ) ; if ( params . length == num params ) { return method ; } } } return null ; }
public static float next float ( final float start inclusive , final float end exclusive ) { validate . be true ( end exclusive > = start inclusive , `` start value must be small or equal to end value . `` ) ; validate . be true ( start inclusive > = 0 , `` both range value must be non-negative . `` ) ; if ( start inclusive == end exclusive ) { return start inclusive ; } return start inclusive + ( ( end exclusive - start inclusive ) * random . next float ( ) ) ; }
public boolean support s q l ( ) { return this . be s q l available ; }
public int get char width ( char c ) { integer width integer = char width . get ( character . value of ( c ) ) ; if ( width integer == null ) { return ' w ' == c ? 0 : get char width ( ' w ' ) ; } return width integer ; }
protect s a x reader create reader ( ) throw document exception { final s a x reader reader = new s a x reader ( ) ; try { reader . set feature ( `` http : //apache . org/xml/features/disallow-doctype-decl `` , true ) ; } catch ( s a x exception e ) { throw new document exception ( `` can not disable doctype processing `` , e ) ; } return reader ; }
public final expression optimize ( expression visitor visitor , item type context item type ) { return this ; }
public void set namespace aware ( boolean awareness ) { feature . put ( xml pull parser . feature_process_namespaces , new boolean ( awareness ) ) ; }
protect void set closure delegate ( closure closure , object node ) { closure . set delegate ( this ) ; }
public void add immutable type ( final class type , final boolean be referenceable ) { immutable type . add ( type ) ; if ( ! be referenceable ) { unreferenceable type . add ( type ) ; } else { unreferenceable type . remove ( type ) ; } }
public object from x m l ( final string xml ) throw class not find exception , object stream exception { try { return from x m l ( new string reader ( xml ) ) ; } catch ( final object stream exception e ) { throw e ; } catch ( final i o exception e ) { throw new stream exception ( `` unexpected io error from a string reader `` , e ) ; } }
public property name strategy get property name strategy ( ) { return property name strategy ; }
public property visibility strategy get property visibility strategy ( ) { return property visibility strategy ; }
public jsonb component instance creator get component instance creator ( ) { return component instance creator ; }
public jsonb number formatter get number formatter ( ) { return number formatter ; }
public string [ ] get property order ( ) { return property order ; }
public void set deserialize number formatter ( jsonb number formatter deserialize number formatter ) { this . deserialize number formatter = deserialize number formatter ; }
public jsonb number formatter get serialize number formatter ( ) { return serialize number formatter ; }
public void set deserialize date formatter ( jsonb date formatter deserialize date formatter ) { this . deserialize date formatter = deserialize date formatter ; }
public jsonb property info with class model ( class model class model ) { this . class model = class model ; return this ; }
public property model get property model ( string name ) { return property . get ( name ) ; }
public type get property deserialization type ( ) { return setter method type == null ? property type : setter method type ; }
public string get property name ( ) { return property name ; }
public method get getter ( ) { return getter ; }
public static class [ ] get parameterized class argument ( declare class interface pair p ) { if ( p . generic interface instanceof parameterized type ) { parameterized type pt = ( parameterized type ) p . generic interface ; type [ ] a = pt . get actual type argument ( ) ; class [ ] ca = new class [ a . length ] ; for ( int i = 0 ; i < a . length ; i++ ) { type a = a [ i ] ; if ( a instanceof class ) { cas [ i ] = ( class ) a ; } else if ( a instanceof parameterized type ) { pt = ( parameterized type ) a ; ca [ i ] = ( class ) pt . get raw type ( ) ; } else if ( a instanceof type variable ) { class type pair ctp = resolve type variable ( p . concrete class , p . declare class , ( type variable ) a ) ; cas [ i ] = ( ctp ! = null ) ? ctp . c : object . class ; } } return ca ; } else { return null ; } }
public t with class model ( class model class model ) { this . class model = class model ; return ( t ) this ; }
public customization get customization ( ) { return customization ; }
public jsonb property info with class model ( class model class model ) { this . class model = class model ; return this ; }
public double get mean ( string field ) { check field ( field , result . mean ) ; return result . mean . get ( field ) ; }
public int mfmt ( string pathname , string timeval ) throw i o exception { return send command ( f t p command . mfmt , timeval + `` `` + pathname ) ; }
protected list < string > get command metadata segment ( metadata metadata ) { list < string > command metadata segment = new array list < string > ( ) ; if ( metadata == null || metadata . name ( ) == null ) { return command metadata segment ; } for ( string metadata name : metadata . name ( ) ) { for ( property property : get metadata command argument ( ) . key set ( ) ) { if ( metadata name . equal ( property . get name ( ) ) ) { string [ ] metadata command argument = get metadata command argument ( ) . get ( property ) ; if ( metadata command argument ! = null ) { for ( string metadata command argument : metadata command argument ) { if ( metadata . be multi value ( metadata name ) ) { for ( string metadata value : metadata . get value ( metadata name ) ) { string assignment value = metadata value ; if ( quote assignment value ) { assignment value = `` ' `` + assignment value + `` ' `` ; } command metadata segment . add ( metadata command argument + command append operator + assignment value ) ; } } else { string assignment value = metadata . get ( metadata name ) ; if ( quote assignment value ) { assignment value = `` ' `` + assignment value + `` ' `` ; } command metadata segment . add ( metadata command argument + command assignment operator + assignment value ) ; } } } } } } return command metadata segment ; }
public void verify ( ) { do state reach accept state ( start state ) ; }
public list < integer > get unreachable alt ( ) { return dfa . get unreachable alt ( ) ; }
public state cluster build_ range ( int a , int b ) { n f a state leave = new state ( ) ; n f a state right = new state ( ) ; label label = new label ( interval set . of ( a , b ) ) ; transition e = new transition ( label , right ) ; leave . add transition ( e ) ; state cluster g = new state cluster ( leave , right ) ; return g ; }
public set < integer > get alt set ( ) { int num configs = nfa configuration . size ( ) ; set < integer > alt = new hash set < integer > ( ) ; for ( int i = 0 ; i < num configs ; i++ ) { n f a configuration configuration = nfa configuration . get ( i ) ; alt . add ( utils . integer ( configuration . alt ) ) ; } if ( alt . be empty ( ) ) { return null ; } return alt ; }
public int length ( ) { if ( b < a ) return 0 ; return b-a+1 ; }
public list < v > put ( string name , v value ) { if ( value == null ) { return super . put ( name , null ) ; } list < v > vals = new array list < > ( ) ; vals . add ( value ) ; return put ( name , vals ) ; }
public list < t > element ( ) { return element ; }
public void remove ( ) { map . remove ( thread . current thread ( ) . get id ( ) ) ; }
public rule get rule ( string rule name ) { rule r = grammar . get locally define rule ( rule name ) ; for ( int i = 0 ; r==null & & child ! =null & & i < child . size ( ) ; i++ ) { composite grammar tree child = child . get ( i ) ; r = child . get rule ( rule name ) ; } return r ; }
public state cluster build_ action ( grammar a s t action ) { n f a state leave = new state ( ) ; n f a state right = new state ( ) ; transition e = new transition ( new action label ( action ) , right ) ; leave . add transition ( e ) ; return new state cluster ( leave , right ) ; }
public boolean be force all file to output dir ( ) { return force all file to output dir ; }
public boolean get depend ( ) { return depend ; }
public static void leave recursion cycle ( collection < ? extend set < ? extend rule > > cycle ) { get error state ( ) . errors++ ; message msg = new leave recursion cycle message ( cycle ) ; get error state ( ) . error msg i d . add ( msg . msg i d ) ; get error listener ( ) . error ( msg ) ; }
public void set generate_ n f a_dot ( boolean generate_ n f a_dot ) { this . generate_ n f a_dot = generate_ n f a_dot ; }
public void set dump ( boolean dump ) { this . dump = dump ; }
public void match any ( int stream input ) { state . error recovery = false ; state . fail = false ; input . consume ( ) ; }
protect void push follow ( bit set fset ) { if ( ( state . _fsp +1 ) > =state . follow . length ) { bit set [ ] f = new bit set [ state . follow . length * 2 ] ; system . arraycopy ( state . follow , 0 , f , 0 , state . follow . length ) ; state . follow = f ; } state . follow [ ++state . _fsp ] = fset ; }
public void add ( int a , int b ) { add ( interval . of ( a , b ) ) ; }
public interval set get expect token ( ) { if ( recognizer ! = null ) { return recognizer . get a t n ( ) . get expect token ( offend state , ctx ) ; } return null ; }
protect void simulate tree construction ( object t ) { dbg . create node ( t ) ; int n = adaptor . get child count ( t ) ; for ( int i=0 ; i < n ; i++ ) { object child = adaptor . get child ( t , i ) ; simulate tree construction ( child ) ; dbg . add child ( t , child ) ; } }
public static keytab get instance ( ) { return new keytab ( ) ; }
public void set valid start ( kerberos time valid start ) { this . valid start = valid start ; }
public void set principal ( kerberos principal principal ) { this . principal = principal ; }
public void set ad and or ( ad and or ad and or ) { this . ad and or = ad and or ; }
public void set enc ap rep part ( enc ap rep part enc ap rep part ) { this . enc ap rep part = enc ap rep part ; }
public void set enc krb priv part ( enc krb priv part enc krb priv part ) { this . enc krb priv part = enc krb priv part ; }
public void add pa data ( pa data pa data ) { method data . add pa data ( pa data ) ; }
public boolean get ( int index ) { if ( ( index < 0 ) || ( index > = size ( ) ) ) { throw new array index out of bound exception ( ) ; } return super . get bit ( index ) ; }
public void set pa timestamp ( kerberos time patimestamp ) { this . patimestamp = patimestamp ; }
public static encryption type get by name ( string type ) { if ( type == null ) { return unknown ; } string lc type = string . to lower case ( type ) ; if ( encryption type by name . contains key ( lc type ) ) { return encryption type by name . get ( lc type ) ; } else { return unknown ; } }
public static sam type get type by ordinal ( int ordinal ) { for ( sam type st : sam type . value ( ) ) { if ( ordinal == st . get ordinal ( ) ) { return st ; } } return pa_sam_type_apache ; }
public void set current ad type ( authorization type ad type ) { current a d . set ad type ( ad type ) ; }
public void set name type ( principal name type name type ) { this . name type = name type ; }
public krb error get error ( ) { return error ; }
public void clear flag ( kerberos flag flag ) { int po = max_size - 1 - flag . get value ( ) ; clear bit ( flag . get value ( ) ) ; value & = ~ ( 1 < < po ) ; }
public boolean be proxiable ( ) { return be flag set ( ticket flag . proxiable ) ; }
public void add ticket info ( krb cred info info ) { if ( info == null ) { throw new illegal argument exception ( ) ; } if ( ticket info == null ) { ticket info = new array list < krb cred info > ( ) ; } ticket info . add ( info ) ; }
public int compute length ( ) { enc kdc rep part length = enc kdc rep part . compute length ( ) ; return 1 + tlv . get nb byte ( enc kdc rep part length ) + enc kdc rep part length ; }
public void append ( int b ) { int newlen = this . len + 1 ; if ( newlen > this . buffer . length ) { expand ( newlen ) ; } this . buffer [ this . len ] = ( byte ) b ; this . len = newlen ; }
public static boolean be alpha uppercase a s c i i ( string string , int index ) { if ( string == null ) { return false ; } int length = string . length ( ) ; if ( ( length == 0 ) || ( index < 0 ) || ( index > = length ) ) { return false ; } else { char c = string . char at ( index ) ; if ( ( c > 127 ) || ! alpha_upper_case [ c ] ) { return false ; } else { return true ; } } }
public int size ( ) { return nest exception . size ( ) ; }
public object get ( object key ) { if ( ! contains key ( key ) ) return null ; object value = remove ( key ) ; super . put ( key , value ) ; return value ; }
protect runnable get poll runnable ( final poll configuration source source , final configuration config ) { return new runnable ( ) { public void run ( ) { log . debug ( `` polling start `` ) ; poll result result = null ; try { result = source . poll ( false , get next check point ( check point ) ) ; check point = result . get check point ( ) ; fire event ( event type . poll_success , result , null ) ; } catch ( throwable e ) { log . error ( `` error get result from poll source `` , e ) ; fire event ( event type . poll_failure , null , e ) ; return ; } try { populate property ( result , config ) ; } catch ( throwable e ) { log . error ( `` error occured applying property `` , e ) ; } } } ; }
public string get deployment region ( ) { string value = get value from config ( `` archaius . deployment . region `` ) ; if ( value ! = null ) { return value ; } else { return super . get deployment region ( ) ; } }
public static void load property from resource ( string path ) throw i o exception { if ( instance == null ) { instance = get config instance ( ) ; } class loader loader = thread . current thread ( ) . get context class loader ( ) ; url url = loader . get resource ( path ) ; if ( url == null ) { throw new i o exception ( `` can not locate `` + path + `` a a classpath resource . `` ) ; } property prop = new property ( ) ; input stream fin = url . open stream ( ) ; prop . load ( fin ) ; fin . close ( ) ; if ( instance instanceof aggregate configuration ) { string name = get config name ( url ) ; concurrent map configuration config = new concurrent map configuration ( ) ; config . load property ( prop ) ; ( ( aggregate configuration ) instance ) . add configuration ( config , name ) ; } else { configuration utils . load property ( prop , instance ) ; } }
public boolean remove callback ( runnable r ) { return callback . remove ( r ) ; }
public dynamic int property get int property ( string prop name , int default value , final runnable property change callback ) { check and warn ( prop name ) ; dynamic int property property = new dynamic int property ( prop name , default value ) ; add callback ( property change callback , property ) ; return property ; }
public dynamic boolean property get boolean property ( string prop name , boolean default value ) { return get boolean property ( prop name , default value , null ) ; }
public void update property ( string key , string value ) { if ( config instanceof concurrent composite configuration ) { ( ( concurrent composite configuration ) config ) . set override property ( key , value ) ; } else { config . set property ( key , value ) ; } }
protect synchronized void schedule ( runnable runnable ) { executor = executor . new schedule thread pool ( 1 , new thread factory ( ) { @ override public thread new thread ( runnable r ) { thread t = new thread ( r , `` poll configuration source `` ) ; t . set daemon ( true ) ; return t ; } } ) ; executor . schedule with fixed delay ( runnable , initial delay millis , delay millis , time unit . millisecond ) ; }
public dynamic float property get float property ( string prop name , float default value , final runnable property change callback ) { check and warn ( prop name ) ; dynamic float property property = new dynamic float property ( prop name , default value ) ; add callback ( property change callback , property ) ; return property ; }
public string get repository ( ) { return this . repository ; } // -- string get repository ( )
public string get repository ( ) { return this . repository ; } // -- string get repository ( )
public void set include ( list < string > include list ) { string [ ] include = include list . to array ( new string [ include list . size ( ) ] ) ; if ( include == null ) { this . include = null ; } else { set include ( include ) ; } }
public void set source ( java . util . list < source > source ) { this . source = source ; } // -- void set source ( java . util . list )
public void set resource ( java . util . list < resource > resource ) { this . resource = resource ; } // -- void set resource ( java . util . list )
public string get file ( ) { return this . file ; } // -- string get file ( )
public boolean be partial ( ) { return this . partial ; } // -- boolean be partial ( )
public boolean be package ( ) { return this . package ; } // -- boolean be package ( )
public string get name ( ) { return this . name ; } // -- string get name ( )
public string get default value ( ) { return this . default value ; } // -- string get default value ( )
public static boolean be run a client and check ( deployment deployment , test class test class , method test method ) { boolean run a client = be run a client ( deployment , test class , test method ) ; if ( run a client & & deployment == null ) { method [ ] method = test class . get method ( org . jboss . arquillian . container . test . api . deployment . class ) ; if ( method . length > 0 ) { if ( ! test method . be annotation present ( run a client . class ) & & ! test class . be annotation present ( run a client . class ) ) { operate on deployment on deployment = test class . get annotation ( operate on deployment . class ) ; string deployment name = on deployment == null ? `` _default_ `` : on deployment . value ( ) ; for ( method m : method ) { org . jboss . arquillian . container . test . api . deployment deployment annotation = m . get annotation ( org . jboss . arquillian . container . test . api . deployment . class ) ; if ( deployment annotation . name ( ) . equal ( deployment name ) & & deployment annotation . testable ( ) ) { log . warning ( `` the test method `` + test class . get java class ( ) . get canonical name ( ) + `` # `` + test method . get name ( ) + `` will run on the client side , because the `` + deployment name + `` deployment be not deploy . `` + `` please deploy the deployment or mark the test a a client test `` ) ; } } } } } return run a client ; }
public static boolean be proxied class ( class current class ) { if ( current class == null || current class . get superclass ( ) == null ) { return false ; } return current class . get name ( ) . start with ( current class . get superclass ( ) . get name ( ) ) & & current class . get name ( ) . contains ( `` $ $ `` ) ; }
public void set diff image ( buffer image image ) { diff markup policy . set diff image ( image ) ; }
public int get diff size ( ) { return diff markup policy . get diff size ( ) ; }
public string get name ( ) { return name ; }
public method bind make method binding ( resolved member member , list < string > alias ) { return internal make method binding ( member , aliases ) ; }
public list < binary source file > get binary file ( ) { return binary file ; }
public list < binary source file > get binary file ( ) { return binary file ; }
public list < binary source file > get binary file ( ) { return binary file ; }
public void set change ( int change ) { this . change = change ; }
public asm manager get structure model ( ) { return ( state == null ? null : state . get structure model ( ) ) ; }
public list < binary source file > get binary file ( ) { return binary file ; }
public boolean be inflate ( ) { return inflate ; }
public final string get generic signature ( ) { if ( ! search for signature attribute ) { signature sig = attribute utils . get signature attribute ( attribute ) ; signature attribute string = ( sig == null ? null : sig . get signature ( ) ) ; search for signature attribute = true ; } return signature attribute string ; }
public final void dump ( data output stream file ) throw i o exception { super . dump ( file ) ; file . write short ( max stack ) ; file . write short ( max local ) ; file . write int ( code . length ) ; file . write ( code , 0 , code . length ) ; file . write short ( exception table . length ) ; for ( int i = 0 ; i < exception table . length ; i++ ) { exception table [ i ] . dump ( file ) ; } file . write short ( attribute . length ) ; for ( int i = 0 ; i < attribute . length ; i++ ) { attribute [ i ] . dump ( file ) ; } }
public final line number table get line number table ( ) { code code = get code ( ) ; if ( code ! = null ) return code . get line number table ( ) ; return null ; }
public void set instruction ( instruction i ) { super . set instruction ( i ) ; bi = ( instruction branch ) i ; }
public void set handler p c ( instruction handle handler_pc ) { instruction branch . notify target ( this . handler_pc , handler_pc , this ) ; this . handler_pc = handler_pc ; }
public local variable gen add local variable ( string name , type type , instruction handle start , instruction handle end ) { return add local variable ( name , type , max local , start , end ) ; }
public static void remove class ( string clazz ) { get repository ( ) . remove class ( get repository ( ) . find class ( clazz ) ) ; }
public void clear ( ) { if ( use share cache ) share cache . clear ( ) ; else local cache . clear ( ) ; }
public static void add declare error or warn relationship ( asm manager model , shadow affect shadow , checker deow ) { if ( model == null ) { return ; } if ( affected shadow . get source location ( ) == null || deow . get source location ( ) == null ) { return ; } if ( world . create injar hierarchy ) { create hierarchy for binary aspect ( model , deow ) ; } i program element target node = get node ( model , affected shadow ) ; if ( target node == null ) { return ; } string target handle = target node . get handle identifier ( ) ; if ( target handle == null ) { return ; } i program element source node = model . get hierarchy ( ) . find element for source line ( deow . get source location ( ) ) ; string source handle = source node . get handle identifier ( ) ; if ( source handle == null ) { return ; } i relationship map relmap = model . get relationship map ( ) ; i relationship foreward = relmap . get ( source handle , i relationship . kind . declare , matched_by , false , true ) ; foreward . add target ( target handle ) ; i relationship back = relmap . get ( target handle , i relationship . kind . declare , matches_declare , false , true ) ; if ( back ! = null & & back . get target ( ) ! = null ) { back . add target ( source handle ) ; } if ( source node . get source location ( ) ! = null ) { model . add aspect in effect this build ( source node . get source location ( ) . get source file ( ) ) ; } }
public i message [ ] get message ( i message . kind kind , final boolean or great ) { if ( null == kind ) { return message . to array ( i message . r a_ i message ) ; } array list < i message > result = new array list < i message > ( ) ; if ( ! or great ) { for ( i message m : message ) { if ( kind == m . get kind ( ) ) { result . add ( m ) ; } } } else { for ( i message m : message ) { if ( kind . be same or less than ( m . get kind ( ) ) ) { result . add ( m ) ; } } } if ( 0 == result . size ( ) ) { return i message . r a_ i message ; } return result . to array ( i message . r a_ i message ) ; }
public void write ( final print writer output , final janitor janitor ) { string description = `` general error during `` + owner . get phase description ( ) + `` : `` ; string message = cause . get message ( ) ; if ( message ! = null ) { output . println ( description + message ) ; } else { output . println ( description + cause ) ; } output . println ( ) ; / * if ( debug ) * / cause . print stack trace ( output ) ; }
public static void copy stream ( data input stream in , print stream out ) throw i o exception { lang util . throw iax if null ( in , `` in `` ) ; lang util . throw iax if null ( in , `` out `` ) ; string s ; while ( null ! = ( s = in . read line ( ) ) ) { out . println ( s ) ; } }
public final a s t node create group node ( a s t node [ ] target node ) { if ( target node == null || target node . length == 0 ) { throw new illegal argument exception ( ) ; } block res= get node store ( ) . create collapse placeholder ( ) ; list rewrite list rewrite= get list rewrite ( re , block . statements_property ) ; for ( int i= 0 ; i < target node . length ; i++ ) { list rewrite . insert last ( target node [ i ] , null ) ; } return re ; }
public after return advice declaration new after return advice declaration ( ) { after return advice declaration result = new after return advice declaration ( this ) ; return result ; }
public per cflow new per cflow ( ) { per cflow result = new per cflow ( this ) ; return result ; }
public signature pattern new signature pattern ( ) { signature pattern result = new signature pattern ( this , `` `` ) ; return result ; }
public void set aspect ( boolean be aspect ) { pre value change ( aspect_property ) ; this . be aspect = be aspect ; post value change ( aspect_property ) ; }
public i java element get java element ( ) { return this . type root ; }
public synchronize boolean clear ( ) { boolean have content = ! _forward . be empty ( ) || ! _reverse . be empty ( ) ; _reverse . clear ( ) ; _forward . clear ( ) ; _dirty |= have content ; return have content ; }
public synchronize boolean clear ( ) { boolean have content = ! _forward . be empty ( ) || ! _reverse . be empty ( ) ; _reverse . clear ( ) ; _forward . clear ( ) ; _dirty |= have content ; return have content ; }
public void set property ( string key , string value ) throw index exception { remove property ( key ) ; d b property new property= new d b property ( this . db , key , value ) ; this . index . insert ( new property . get record ( ) ) ; }
public int size ( ) { return this . map . size ( ) ; }
public void set property ( string key , string value ) throw index exception { remove property ( key ) ; d b property new property= new d b property ( this . db , key , value ) ; this . index . insert ( new property . get record ( ) ) ; }
public v remove ( char [ ] char , int start , int length ) { check boundary ( char , start , length ) ; return this . map . remove ( new key ( char , start , length ) ) ; }
public boolean contain key start with ( i path next ) { node < t > node = this . root . get most specific node ( next ) ; return node . depth == next . segment count ( ) ; }
public i message [ ] get message ( i message . kind kind , final boolean or great ) { if ( null == kind ) { return message . to array ( i message . r a_ i message ) ; } array list < i message > result = new array list < i message > ( ) ; if ( ! or great ) { for ( i message m : message ) { if ( kind == m . get kind ( ) ) { result . add ( m ) ; } } } else { for ( i message m : message ) { if ( kind . be same or less than ( m . get kind ( ) ) ) { result . add ( m ) ; } } } if ( 0 == result . size ( ) ) { return i message . r a_ i message ; } return result . to array ( i message . r a_ i message ) ; }
public void set completion runner ( runnable runner ) { this . completion runner = runner ; }
public static void print ( print stream out , i message holder holder , string prefix ) { print ( out , holder , prefix , ( i message renderer ) null , ( i message handler ) null ) ; }
public void set nocomments ( boolean nocomments ) { this . nocomments = nocomments ; }
public file get workingdir ( ) { return workingdir ; }
public void set sourcefiles ( string src ) { string tokenizer tok = new string tokenizer ( src , `` , `` ) ; while ( tok . have more token ( ) ) { string f = tok . next token ( ) ; source file sf = new source file ( ) ; sf . set file ( get project ( ) . resolve file ( f . trim ( ) ) ) ; add source ( sf ) ; } }
public void set excludes ( string excludes ) { have exclude = true ; super . set excludes ( excludes ) ; }
public void set xlintwarnings ( boolean xlintwarnings ) { cmd . add flag ( `` - xlint `` , xlintwarnings ) ; }
public boolean execute ( ) throw build exception { attribute . log ( `` use ajc `` , project . msg_verbose ) ; return compile ( add ajc option ( setup javac command ( ) ) ) ; }
public void set proc ( string proc ) { if ( proc . equal ( `` none `` ) ) { cmd . add flag ( `` -proc : none `` , true ) ; } else if ( proc . equal ( `` only `` ) ) { cmd . add flag ( `` -proc : only `` , true ) ; } }
public void set xlint ( string xlint ) { xlint = valid comma list ( xlint , valid_xlint , `` xlint `` , 1 ) ; cmd . add flag ( `` - xlint : `` + xlint , ( null ! = xlint ) ) ; }
public static < t > boolean be semantic equal ( t [ ] a , t [ ] b ) { if ( a == null ) { return b == null || b . length == 0 ; } if ( b == null ) { return a . length == 0 ; } if ( a . length ! = b . length ) { return false ; } for ( int i = 0 ; i < a . length ; i++ ) { if ( ! be equal ( a [ i ] , b [ i ] ) ) { return false ; } } return true ; }
public static list < file > list class file ( file dir ) { array list < file > result = new array list < file > ( ) ; if ( ( null ! = dir ) & & dir . can read ( ) ) { list class file ( dir , result ) ; } return result ; }
public static byte [ ] copy to byte array ( file in ) throw i o exception { assert . not null ( in , `` no input file specify `` ) ; return copy to byte array ( new buffer input stream ( new file input stream ( in ) ) ) ; }
public static string flatten ( file [ ] file , string infix ) { if ( lang util . be empty ( file ) ) { return `` `` ; } return flatten ( get path ( file ) , infix ) ; }
public static string get local name from full name ( string full ) { string end = `` `` ; if ( full . start with ( `` [ l `` ) ) { end = `` [ ] `` ; full = full . substring ( 3 , full . length ( ) - 1 ) ; } if ( full . last index of ( ' . ' ) < 0 ) { return full + end ; } else { return full . substring ( full . last index of ( ' . ' ) + 1 ) + end ; } }
public static resolve member privileged access method for field get ( unresolved type aspect type , member field , boolean short syntax ) { unresolved type field declare type = field . get declare type ( ) ; if ( short syntax ) { unresolved type [ ] args = null ; if ( modifier . be static ( field . get modifier ( ) ) ) { args = resolve type . none ; } else { args = new unresolved type [ ] { field declare type } ; } string buffer name = new string buffer ( `` ajc $ get $ `` ) ; name . append ( field . get name ( ) ) ; return new resolve member impl ( member . method , field declare type , public_static , field . get return type ( ) , name . to string ( ) , args ) ; } else { string getter name = name mangler . privileged access method for field get ( field . get name ( ) , field declare type , aspect type ) ; string sig ; if ( modifier . be static ( field . get modifier ( ) ) ) { sig = `` ( ) `` + field . get return type ( ) . get signature ( ) ; } else { sig = `` ( `` + field declare type . get signature ( ) + `` ) `` + field . get return type ( ) . get signature ( ) ; } return new resolve member impl ( member . method , field declare type , public_static , getter name , sig ) ; } }
public static resolve member inter field interface setter ( resolved member field , resolve type on type , unresolved type aspect type ) { int modifier = modifier . public ; if ( on type . be interface ( ) ) { modifier |= modifier . abstract ; } resolve member rm = new resolve member impl ( member . method , on type , modifier , unresolved type . void , name mangler . inter field interface setter ( aspect type , field . get declare type ( ) , field . get name ( ) ) , new unresolved type [ ] { field . get return type ( ) } , unresolved type . none ) ; rm . set type variable ( field . get type variable ( ) ) ; return rm ; }
public void add scoped aspect ( string name , string scope ) { this . be xml configured world = true ; if ( xml configuration == null ) { xml configuration = new weave xml config ( this , weave xml config . mode_ltw ) ; } xml configuration . add scoped aspect ( name , scope ) ; }
public static resolve member inter field class field ( resolved member field , unresolved type aspect type , boolean new style ) { int modifier = ( new style ? make non final ( field . get modifier ( ) ) : make public non final ( field . get modifier ( ) ) ) ; string name = null ; if ( new style ) { name = field . get name ( ) ; } else { name = name mangler . inter field class field ( field . get modifier ( ) , aspect type , field . get declare type ( ) , field . get name ( ) ) ; } return new resolve member impl ( member . field , field . get declare type ( ) , modifier , field . get return type ( ) , name , unresolved type . none , unresolved type . none ) ; }
public static < t > iterator < t > array ( final t [ ] o ) { return new iterator < t > ( ) { int i = 0 ; int len = ( o == null ) ? 0 : o . length ; public boolean have next ( ) { return i < len ; } public t next ( ) { if ( i < len ) { return o [ i++ ] ; } else { throw new no such element exception ( ) ; } } public void remove ( ) { throw new unsupported operation exception ( ) ; } } ; }
public static string inter method dispatcher ( unresolved type aspect type , unresolved type class type , string name ) { return make name ( `` inter method dispatch1 `` , aspect type . get name a identifier ( ) , class type . get name a identifier ( ) , name ) ; }
public pointcut not ( pointcut p ) { if ( be not ( p ) ) { return ( ( not pointcut ) p ) . get negated pointcut ( ) ; } return new not pointcut ( p ) ; }
public void register pointcut designator handler ( pointcut designator handler designator handler ) { this . pointcut designators . add ( designator handler ) ; if ( world ! = null ) { world . register pointcut handler ( designator handler ) ; } }
public string get name ( ) { return name ; }
public string maybe get simple name ( ) { if ( name pattern . length == 1 ) { return name pattern [ 0 ] . maybe get simple name ( ) ; } return null ; }
public static class < ? > resolve raw type ( runtime type info item , type type ) { if ( type instanceof class ) { return ( class < ? > ) type ; } else if ( type instanceof parameterized type ) { return ( class < ? > ) ( ( parameterized type ) type ) . get raw type ( ) ; } else { return get raw type ( resolve type ( item , type ) ) ; } }
public list < resolve member > get method without iterator ( boolean include i t d , boolean allow miss , boolean generic aware ) { list < resolve member > method = new array list < resolve member > ( ) ; set < string > knowninterfaces = new hash set < string > ( ) ; add and recurse ( knowninterfaces , method , this , include i t d , allow miss , generic aware ) ; return method ; }
public member get matching signature ( ) { return match signature ! = null ? matching signature : signature ; }
public void ignore ( cached class reference ref , byte [ ] class byte ) { stats . put ignored ( ) ; back . put ( new cache class entry ( ref , zero_bytes , cache class entry . entry type . ignore ) , class byte ) ; }
protect void set class loader ( class loader a loader ) { this . class loader reference = new weak class loader reference ( a loader ) ; world = reflection world . get reflection world for ( this . class loader reference ) ; }
protect void set class loader ( class loader a loader ) { this . class loader reference = new weak class loader reference ( a loader ) ; world = reflection world . get reflection world for ( this . class loader reference ) ; }
public int compare by precedence and hierarchy ( resolve type aspect1 , resolve type aspect2 ) { return precedence calculator . compare by precedence and hierarchy ( aspect1 , aspect2 ) ; }
public static i message handler make selector ( i message . kind kind , boolean or great , string infix ) { if ( ! or great & & lang util . be empty ( infix ) ) { if ( kind == i message . abort ) { return pick_abort ; } else if ( kind == i message . debug ) { return pick_debug ; } else if ( kind == i message . debug ) { return pick_debug ; } else if ( kind == i message . error ) { return pick_error ; } else if ( kind == i message . fail ) { return pick_fail ; } else if ( kind == i message . info ) { return pick_info ; } else if ( kind == i message . warn ) { return pick_warning ; } } return new kind selector ( kind , or great , infix ) ; }
public static string inter method dispatcher ( unresolved type aspect type , unresolved type class type , string name ) { return make name ( `` inter method dispatch1 `` , aspect type . get name a identifier ( ) , class type . get name a identifier ( ) , name ) ; }
public static writer leave shift ( writer self , object value ) throw i o exception { invoker helper . write ( self , value ) ; return self ; }
public void fill mutation ( t instance , column list mutation < string > mutation ) { for ( string field name : get name ( ) ) { coercion . set column mutation from field ( instance , field . get ( field name ) , field name , mutation ) ; } }
public void append ( list < byte buffer > list ) { for ( byte buffer buffer : list ) { buffer . position ( buffer . limit ( ) ) ; } buffer . add all ( list ) ; }
public boolean be empty ( ) { return mutation map . be empty ( ) ; }
public column prefix distribute row lock < k > with column prefix ( string prefix ) { this . prefix = prefix ; return this ; }
public column prefix distribute row lock < k > with column prefix ( string prefix ) { this . prefix = prefix ; return this ; }
public data file writer < d > set codec ( codec factory c ) { assert not open ( ) ; this . codec = c . create instance ( ) ; set meta internal ( data file constant . codec , codec . get name ( ) ) ; return this ; }
public data file writer < d > set codec ( codec factory c ) { assert not open ( ) ; this . codec = c . create instance ( ) ; set meta internal ( data file constant . codec , codec . get name ( ) ) ; return this ; }
public long tell ( ) throw i o exception { return in . tell ( ) ; }
public long tell ( ) throw i o exception { return in . tell ( ) ; }
public void append encode ( byte buffer datum ) throw i o exception { assert open ( ) ; buf out . write fix ( datum ) ; block count++ ; write if block full ( ) ; }
public void set target ( int i , instruction handle target ) { notify target ( target [ i ] , target , this ) ; target [ i ] = target ; }
public decoder factory configure decoder buffer size ( int size ) { if ( size < 32 ) size = 32 ; if ( size > 16 * 1024 * 1024 ) size = 16 * 1024 * 1024 ; this . binary decoder buffer size = size ; return this ; }
public int get block size ( ) { return this . binary block size ; }
public validate decoder configure ( decoder in ) throw i o exception { this . parser . reset ( ) ; this . in = in ; return this ; }
public final void skip to ( int target ) throw i o exception { outer : while ( target < po ) { symbol top = stack [ pos - 1 ] ; while ( top . kind ! = symbol . kind . terminal ) { if ( top . kind == symbol . kind . implicit_action || top . kind == symbol . kind . explicit_action ) { skip handler . skip action ( ) ; } else { -- po ; push production ( top ) ; } continue outer ; } skip handler . skip top symbol ( ) ; } }
public final void skip repeater ( ) throw i o exception { int target = po ; symbol repeater = stack [ -- pos ] ; assert repeater . kind == symbol . kind . repeater ; push production ( repeater ) ; skip to ( target ) ; }
public final void skip repeater ( ) throw i o exception { int target = po ; symbol repeater = stack [ -- pos ] ; assert repeater . kind == symbol . kind . repeater ; push production ( repeater ) ; skip to ( target ) ; }
public final schema . field [ ] read field order ( ) throw i o exception { return ( ( symbol . field order action ) parser . advance ( symbol . field_action ) ) . field ; }
public string get program ( string . . . statement ) { string builder buf = new string builder ( ) ; for ( string statement : statement ) { buf . append ( statement ) ; buf . append ( system . line separator ( ) ) ; } return buf . to string ( ) ; }
public schema validator builder can read strategy ( ) { this . strategy = new validate can read ( ) ; return this ; }
public void handle error ( throwable error ) { this . error = error ; latch . count down ( ) ; if ( chained callback ! = null ) { chain callback . handle error ( error ) ; } }
public void add r p c plugin ( r p c plugin plugin ) { rpc meta plugins . add ( plugin ) ; }
public handshake response get handshake response ( ) { return this . handshake response ; }
public handshake response get handshake response ( ) { return this . handshake response ; }
public void clear ( ) { synchronize ( this . file ) { for ( long l : new link list < long > ( this . file . key set ( ) ) ) { file f = this . file . remove ( l ) ; f . delete ( ) ; } } }
protect channel upstream handler create netty client avro handler ( ) { return new netty client avro handler ( ) ; }
public duration divide ( long amount ) { return new divide ( ) . apply ( this , unit == null ? forever : new duration ( amount , unit ) ) ; }
public string get raw response content ( ) { return raw response == null ? null : new string ( raw response , string utils . utf8 ) ; }
public a w s credential get request credential ( ) { return credential provider == null ? null : credential provider . get credential ( ) ; }
public void set sdk request timeout ( int sdk request timeout ) { this . sdk request timeout = sdk request timeout ; }
public void set override date ( date overridden date ) { if ( overridden date ! = null ) { this . overridden date = new date ( overridden date . get time ( ) ) ; } else { this . overridden date = null ; } }
public string to json ( ) { return new json policy writer ( ) . write policy to string ( this ) ; }
public statement with condition ( condition . . . condition ) { set condition ( array . a list ( condition ) ) ; return this ; }
public string to json ( ) { return new json policy writer ( ) . write policy to string ( this ) ; }
public string get id ( ) { return id ; }
public statement with principal ( principal . . . principal ) { set principal ( principal ) ; return this ; }
protect boolean need to load credential ( ) { if ( credential == null ) return true ; if ( credential expiration ! = null ) { if ( be within expiration threshold ( ) ) return true ; } if ( last instance profile check ! = null ) { if ( be past refresh threshold ( ) ) return true ; } return false ; }
public boolean await read complete ( long timeout , time unit unit ) { return true ; }
public void set role session name ( string role session name ) { this . role session name = role session name ; }
public long get refresh force interval nanos ( ) { return refresh force interval nanos ; }
public a w s credential get credential ( string profile name ) { final a w s credential provider provider = credential provider cache . get ( profile name ) ; if ( provider ! = null ) { return provider . get credential ( ) ; } else { basic profile profile = all profile . get profile ( profile name ) ; if ( profile == null ) { throw new illegal argument exception ( `` no aws profile name ' `` + profile name + `` ' `` ) ; } final a w s credential provider new provider = from profile ( profile ) ; credential provider cache . put ( profile name , new provider ) ; return new provider . get credential ( ) ; } }
public final void set client configuration ( client configuration config ) { this . client config = config ; }
public final void set client configuration ( client configuration config ) { this . client config = config ; }
public final client configuration get client configuration ( ) { return this . client config ; }
public client configuration with proxy workstation ( string proxy workstation ) { set proxy workstation ( proxy workstation ) ; return this ; }
public client configuration with user agent suffix ( string suffix ) { set user agent suffix ( suffix ) ; return this ; }
public client configuration with local address ( inet address local address ) { set local address ( local address ) ; return this ; }
public client configuration with proxy password ( string proxy password ) { set proxy password ( proxy password ) ; return this ; }
public client configuration with proxy domain ( string proxy domain ) { set proxy domain ( proxy domain ) ; return this ; }
public client configuration with socket timeout ( int socket timeout ) { set socket timeout ( socket timeout ) ; return this ; }
public string get signer override ( ) { return signer override ; }
public void set preemptive basic proxy auth ( boolean preemptive basic proxy auth ) { this . preemptive basic proxy auth = preemptive basic proxy auth ; }
public long get connection t t l ( ) { return connection t t l ; }
public void set max connection ( int max connection ) { this . max connection = max connection ; }
public int get validate after inactivity millis ( ) { return validate after inactivity millis ; }
public final expression optimize ( expression visitor visitor , item type context item type ) { return this ; }
public long get request content length ( ) { return request content length ; }
public static complex field get instance ( ) { return lazy holder . instance ; }
public static com . google . rpc . status from status and trailer ( status status , metadata trailer ) { if ( trailer ! = null ) { com . google . rpc . status status proto = trailer . get ( status_details_key ) ; if ( status proto ! = null ) { check argument ( status . get code ( ) . value ( ) == status proto . get code ( ) , `` com . google . rpc . status code must match g r p c status code `` ) ; return status proto ; } } return null ; }
protect void set closure delegate ( closure closure , object node ) { closure . set delegate ( this ) ; }
public input stream get content ( ) { return content ; }
public string get header ( string header name ) { return header . get ( header name ) ; }
protect void set closure delegate ( closure closure , object node ) { closure . set delegate ( this ) ; }
public http client config get http client config ( string http client name ) { return http client . get ( http client name ) ; }
public static i a m info get i a m instance profile info ( ) { string json = get data ( ec2_metadata_root + `` /iam/info `` ) ; if ( null == json ) { return null ; } try { return mapper . read value ( json , i a m info . class ) ; } catch ( exception e ) { log . warn ( `` unable to parse iam instance profile info ( `` + json + `` ) : `` + e . get message ( ) , e ) ; return null ; } }
public int size ( ) { rlock . lock ( ) ; try { return map . size ( ) ; } finally { rlock . unlock ( ) ; } }
public static void set per host metric include ( boolean include per host metric ) { aws sdk metric . per host metric include = include per host metric ; }
public static string get region name ( ) { return region == null ? null : region . get name ( ) ; }
public call param builder from attribute ( / * @ nullable * / string attribute name ) { this . attribute name = attribute name ; return this ; }
public boolean get curly brace denote code block ( int language index ) { return true ; }
public string get service ( ) { return service ; }
public void set ssl common name ( string ssl common name ) { this . ssl common name = ssl common name ; }
public string get partition ( ) { return partition ; }
public string get region regex ( ) { return region regex ; }
public boolean be service support ( string service name ) { return be service support in region ( service name ) || be service partition wide ( service name ) ; }
public boolean be service support ( string service name ) { return be service support in region ( service name ) || be service partition wide ( service name ) ; }
public void marshall ( marshall location marshall location , object val ) { marshaller registry ( ) . get marshaller ( marshall location , val ) . marshall ( val , this , null ) ; }
public string get name ( ) { return region impl . get name ( ) ; }
public static region metadata get region metadata ( ) { region metadata rval = region metadata ; if ( rval ! = null ) { return rval ; } synchronize ( region utils . class ) { if ( region metadata == null ) { initialize ( ) ; } } return region metadata ; }
public static boolean be retryable service exception ( sdk base exception exception ) { if ( ! be ase ( exception ) ) { return false ; } amazon service exception ase = to ase ( exception ) ; return retryable_status_codes . contains ( ase . get status code ( ) ) || retryable_error_codes . contains ( ase . get error code ( ) ) ; }
public static int get global time offset ( ) { return global time offset ; }
public string map path ( string path ) { return null ; }
public void end event ( string event name ) { time info event = event be profile . get ( event name ) ; / * somebody try to end an event that be not start . * / if ( event == null ) { log factory . get log ( get class ( ) ) . warn ( `` try to end an event which be never start : `` + event name ) ; return ; } event . end timing ( ) ; this . timing info . add sub measurement ( event name , time info . unmodifiable timing info ( event . get start epoch time milli if know ( ) , event . get start time nano ( ) , event . get end time nano ( ) ) ) ; }
public void end event ( string event name ) { time info event = event be profile . get ( event name ) ; / * somebody try to end an event that be not start . * / if ( event == null ) { log factory . get log ( get class ( ) ) . warn ( `` try to end an event which be never start : `` + event name ) ; return ; } event . end timing ( ) ; this . timing info . add sub measurement ( event name , time info . unmodifiable timing info ( event . get start epoch time milli if know ( ) , event . get start time nano ( ) , event . get end time nano ( ) ) ) ; }
public static byte [ ] decode ( string b16 ) { if ( b16 == null ) return null ; if ( b16 . length ( ) == 0 ) return new byte [ 0 ] ; byte [ ] buf = new byte [ b16 . length ( ) ] ; int len = codec utils . sanitize ( b16 , buf ) ; return codec . decode ( buf , len ) ; }
public static string encode a string ( byte . . . byte ) { if ( bytes == null ) return null ; return byte . length == 0 ? `` `` : codec utils . to string direct ( codec . encode ( byte ) ) ; }
public static byte [ ] decode ( string b16 ) { if ( b16 == null ) return null ; if ( b16 . length ( ) == 0 ) return new byte [ 0 ] ; byte [ ] buf = new byte [ b16 . length ( ) ] ; int len = codec utils . sanitize ( b16 , buf ) ; return codec . decode ( buf , len ) ; }
public static byte [ ] decode ( string b16 ) { if ( b16 == null ) return null ; if ( b16 . length ( ) == 0 ) return new byte [ 0 ] ; byte [ ] buf = new byte [ b16 . length ( ) ] ; int len = codec utils . sanitize ( b16 , buf ) ; return codec . decode ( buf , len ) ; }
public static string to string ( byte buffer buffer , int position , int length , charset charset ) { if ( buffer == null ) return null ; byte [ ] array = buffer . have array ( ) ? buffer . array ( ) : null ; if ( array == null ) { byte buffer ro = buffer . a read only buffer ( ) ; ro . position ( position ) ; ro . limit ( position + length ) ; byte [ ] to = new byte [ length ] ; ro . get ( to ) ; return new string ( to , 0 , to . length , charset ) ; } return new string ( array , buffer . array offset ( ) + position , length , charset ) ; }
public static url get resource ( string resource , class < ? > . . . class ) { return get resource ( resource , false , class ) ; }
public static string format service specific date ( date date ) { if ( date == null ) return null ; big decimal date value = big decimal . value of ( date . get time ( ) ) ; return date value . scale by power of ten ( 0 - aws_date_milli_second_precision ) . to plain string ( ) ; }
public long now ( @ non null time unit unit ) { return unit . convert ( system . current time millis ( ) , time unit . millisecond ) ; }
public static string get local host name ( ) { return fetch data ( ec2_metadata_root + `` /local-hostname `` ) ; }
public static string get instance action ( ) { return fetch data ( ec2_metadata_root + `` /instance-action `` ) ; }
public static < k , v > immutable map parameter < k , v > of ( k k0 , v v0 , k k1 , v v1 ) { map < k , v > map = new hash map < k , v > ( ) ; put and warn duplicate key ( map , k0 , v0 ) ; put and warn duplicate key ( map , k1 , v1 ) ; return new immutable map parameter < k , v > ( map ) ; }
public file get file ( ) { return file ; }
public static string normalize ( string string ) { if ( string == null ) { return null ; } return string . trim ( ) . to lower case ( ) ; }
public static timing info start timing ( ) { return new time info ( long . value of ( system . current time millis ( ) ) , system . nano time ( ) , null ) ; }
public x m l writer start element ( string element ) { append ( `` < `` + element ) ; if ( root element & & xmlns ! = null ) { append ( `` xmlns=\ `` `` + xmlns + `` \ `` `` ) ; root element = false ; } append ( `` > `` ) ; element stack . push ( element ) ; return this ; }
public x m l writer start element ( string element ) { append ( `` < `` + element ) ; if ( root element & & xmlns ! = null ) { append ( `` xmlns=\ `` `` + xmlns + `` \ `` `` ) ; root element = false ; } append ( `` > `` ) ; element stack . push ( element ) ; return this ; }
public static byte a byte ( string expression , node node ) throw x path expression exception { return a byte ( expression , node , xpath ( ) ) ; }
public static boolean be empty ( final char sequence s ) { if ( s == null ) { return true ; } return s . length ( ) == 0 ; }
public static boolean path all ( json node expect result , json node final result ) { if ( final result . be null ( ) ) { return false ; } if ( ! final result . be array ( ) ) { throw new runtime exception ( `` expect an array `` ) ; } for ( json node element : final result ) { if ( ! element . equal ( expect result ) ) { return false ; } } return true ; }
public void shutdown ( ) { super . shutdown ( ) ; executor service . shutdown now ( ) ; }
public delete queue result delete queue ( delete queue request request ) { request = before client execution ( request ) ; return execute delete queue ( request ) ; }
public change message visibility batch result change message visibility batch ( change message visibility batch request request ) { request = before client execution ( request ) ; return execute change message visibility batch ( request ) ; }
public list queue tag result list queue tag ( list queue tag request request ) { request = before client execution ( request ) ; return execute list queue tag ( request ) ; }
public change message visibility batch result change message visibility batch ( change message visibility batch request request ) { request = before client execution ( request ) ; return execute change message visibility batch ( request ) ; }
public change message visibility result change message visibility sync ( change message visibility request request ) { future < change message visibility result > future = send buffer . change message visibility ( request , null ) ; return wait for future ( future ) ; }
public delete message result delete message sync ( delete message request request ) { future < delete message result > future = delete message ( request , null ) ; return wait for future ( future ) ; }
public void set queue url ( string queue url ) { this . queue url = queue url ; }
public void set id ( string id ) { this . id = id ; }
public void set id ( string id ) { this . id = id ; }
public void set visibility timeout ( integer visibility timeout ) { this . visibility timeout = visibility timeout ; }
public void set queue url ( string queue url ) { this . queue url = queue url ; }
public java . util . list < send message batch result entry > get successful ( ) { if ( successful == null ) { successful = new com . amazonaws . internal . sdk internal list < send message batch result entry > ( ) ; } return successful ; }
public void set message id ( string message id ) { this . message id = message id ; }
public void set message body ( string message body ) { this . message body = message body ; }
public string get content id ( ) { string a [ ] = get mime header ( `` content- id `` ) ; if ( a ! = null & & a . length > 0 ) { return a [ 0 ] ; } else { return null ; } }
public string get content type ( ) throw org . apache . axis . axis fault { mergein attachment ( ) ; int sendtype= this . sendtype == send_type_notset ? send_type_default : this . sendtype ; if ( sendtype == send_type_mime || sendtype == send_type_mtom ) return org . apache . axis . attachment . mime utils . get content type ( ( multipart ! = null ) ? multipart : ( multipart = org . apache . axis . attachment . mime utils . create m p ( soap part . get a string ( ) , order attachment , get send type ( ) ) ) ) ; else return org . apache . axis . message . mime_application_dime ; }
public part remove attachment part ( string reference ) throw org . apache . axis . axis fault { if ( _asked for stream ) { throw new illegal state exception ( message . get message ( `` concurrent modification of stream `` ) ) ; } multipart = null ; dimemultipart = null ; mergein attachment ( ) ; part remove part = get attachment by reference ( reference ) ; if ( removed part ! = null ) { attachment . remove ( remove part . get content id ( ) ) ; attachment . remove ( remove part . get content location ( ) ) ; order attachment . remove ( remove part ) ; } return removed part ; }
public static int get var int len ( int x ) { if ( ( x & ( -1 < < 7 ) ) == 0 ) { return 1 ; } else if ( ( x & ( -1 < < 14 ) ) == 0 ) { return 2 ; } else if ( ( x & ( -1 < < 21 ) ) == 0 ) { return 3 ; } else if ( ( x & ( -1 < < 28 ) ) == 0 ) { return 4 ; } return 5 ; }
public java . lang . string get name ( ) { string ret = null ; try { flush to disk ( ) ; if ( disk cache file ! = null ) { ret = disk cache file . get absolute path ( ) ; } } catch ( exception e ) { disk cache file = null ; } return ret ; }
public static message context get current message context ( ) { return ( message context ) current message context . get ( ) ; }
public void add fault detail ( element detail ) { init fault detail ( ) ; fault detail . add ( detail ) ; }
public void add header ( s o a p header element header ) { if ( fault header == null ) { fault header = new array list ( ) ; } fault header . add ( header ) ; }
public static string get property ( string property name ) { return manage property . get property ( property name ) ; }
public void set allow method ( string method ) { this . method = method ; }
public void set login ( string user , string password ) { call . set username ( user ) ; call . set password ( password ) ; }
public string list ( option opt ) throw exception { process opts ( opts ) ; return list ( ) ; }
public object get property ( string name ) { if ( name == null || ! be property support ( name ) ) { throw new j a x r p c exception ( name == null ? message . get message ( `` bad prop03 `` ) : message . get message ( `` bad prop05 `` , name ) ) ; } return my property . get ( name ) ; } // get property
public void set return class ( class cl ) { if ( operation set manually ) { throw new runtime exception ( message . get message ( `` operation already set `` ) ) ; } if ( operation == null ) operation = new operation desc ( ) ; operation . set return class ( cl ) ; type mapping tm = get type mapping ( ) ; operation . set return type ( tm . get type q name ( cl ) ) ; parm and ret req = true ; }
public javax . xml . rpc . service load service ( url wsdl document location , q name service name , property property ) throw service exception { string service implementation name = property . get property ( service_implementation_name_property ) ; javax . xml . rpc . service service = create service ( service implementation name ) ; if ( service . get service name ( ) . equal ( service name ) ) { return service ; } else { throw new service exception ( message . get message ( `` service factory service implementation not find `` , service implementation name ) ) ; } }
protect void set closure delegate ( closure closure , object node ) { closure . set delegate ( this ) ; }
public void set engine configuration ( engine configuration config ) { this . config = config ; }
public object [ ] get attachment ( ) { object [ ] array = new object [ attachment . size ( ) ] ; attachment . copy into ( array ) ; attachment . clear ( ) ; return array ; }
public object _get property ( string name ) { if ( name == null ) { throw new j a x r p c exception ( message . get message ( `` bad prop05 `` , name ) ) ; } else { if ( name . equal ( call . username_property ) ) { return cache username ; } else if ( name . equal ( call . password_property ) ) { return cache password ; } else if ( name . equal ( stub . endpoint_address_property ) ) { return cache endpoint . to string ( ) ; } else if ( name . equal ( call . session_maintain_property ) ) { return maintain session set ? ( maintain session ? boolean . true : boolean . false ) : null ; } else if ( name . start with ( `` java . `` ) || name . start with ( `` javax . `` ) ) { throw new j a x r p c exception ( message . get message ( `` bad prop05 `` , name ) ) ; } else { return cache property . get ( name ) ; } } } // _get property
public s o a p header element [ ] get header ( ) { s o a p header element [ ] array = new s o a p header element [ header . size ( ) ] ; header . copy into ( array ) ; return array ; }
public r p c param get param ( string name ) throw s a x exception { if ( need deser ) { deserialize ( ) ; } list params = get params2 ( ) ; for ( int i = 0 ; i < params . size ( ) ; i++ ) { r p c param param = ( r p c param ) params . get ( i ) ; if ( param . get name ( ) . equal ( name ) ) return param ; } return null ; }
public void set source ( string src dir ) { this . src dir = src dir ; }
public void set source ( string src dir ) { this . src dir = src dir ; }
public int get end column ( ) { return endcolumn ; }
public string get file ( ) { return file ; }
public static image i o get image i o ( ) { image i o image i o = ( image i o ) axis property . new instance ( image i o . class ) ; / * * * this should n't be need , but seem to be a common feel-good : * / if ( image i o == null ) { try { class cl = class utils . for name ( `` org . apache . axis . component . image . jdk13io `` ) ; image i o = ( image i o ) cl . new instance ( ) ; } catch ( exception e ) { log . debug ( `` image i o factory : no match image i o find `` , e ) ; } } log . debug ( `` axis . image i o : `` + image i o . get class ( ) . get name ( ) ) ; return image i o ; }
public static image i o get image i o ( ) { image i o image i o = ( image i o ) axis property . new instance ( image i o . class ) ; / * * * this should n't be need , but seem to be a common feel-good : * / if ( image i o == null ) { try { class cl = class utils . for name ( `` org . apache . axis . component . image . jdk13io `` ) ; image i o = ( image i o ) cl . new instance ( ) ; } catch ( exception e ) { log . debug ( `` image i o factory : no match image i o find `` , e ) ; } } log . debug ( `` axis . image i o : `` + image i o . get class ( ) . get name ( ) ) ; return image i o ; }
public void interrupt all ( ) { if ( log . be debug enable ( ) ) { log . debug ( `` enter : thread pool : : interrupt all `` ) ; } synchronize ( thread ) { for ( iterator i = thread . value ( ) . iterator ( ) ; i . have next ( ) ; ) { thread t = ( thread ) i . next ( ) ; t . interrupt ( ) ; } } if ( log . be debug enable ( ) ) { log . debug ( `` exit : thread pool : : interrupt all `` ) ; } }
public handler get global response ( ) throw configuration exception { return this . deployment . get global response ( ) ; }
public void undeploy service ( q name qname ) { w s d d service service = ( w s d d service ) service . get ( qname ) ; if ( service ! = null ) { service . remove namespace mapping ( this ) ; service . remove ( qname ) ; } }
public void undeploy service ( q name qname ) { w s d d service service = ( w s d d service ) service . get ( qname ) ; if ( service ! = null ) { service . remove namespace mapping ( this ) ; service . remove ( qname ) ; } }
public void set value ( string value ) { this . value = value ; }
public w s d d request flow get request flow ( ) { return request flow ; }
public boolean be nillable ( ) { return nillable ; }
public q name get xml name ( ) { return xml name ; }
public boolean be return header ( ) { return return desc . be out header ( ) ; }
public boolean be nillable ( ) { return nillable ; }
public void set cur element ( message element el ) { cur element = el ; if ( cur element ! = null & & cur element . get recorder ( ) ! = recorder ) { recorder = cur element . get recorder ( ) ; } }
public boolean be property true ( string prop name , boolean default val ) { return java utils . be true ( get property ( prop name ) , default val ) ; }
public void move value target ( deserializer other ) { if ( ( other == null ) || ( other . get value target ( ) == null ) ) { return ; } if ( target == null ) { target = new vector ( ) ; } target . add all ( other . get value target ( ) ) ; other . remove value target ( ) ; }
protect serializer get specialize ( string mechanism type ) { if ( java type ! = null & & xml type ! = null ) { method get serializer = get get serializer ( ) ; if ( get serializer ! = null ) { try { return ( serializer ) get serializer . invoke ( null , new object [ ] { mechanism type , java type , xml type } ) ; } catch ( illegal access exception e ) { if ( log . be debug enable ( ) ) { log . debug ( org . apache . axis . utils . message . get message ( `` exception00 `` ) , e ) ; } } catch ( invocation target exception e ) { if ( log . be debug enable ( ) ) { log . debug ( org . apache . axis . utils . message . get message ( `` exception00 `` ) , e ) ; } } } } return null ; }
protect method get get deserializer ( ) { if ( get deserializer == null ) { get deserializer = get method ( java type , `` get deserializer `` ) ; } return get deserializer ; }
public void set context ( serialization context context ) { this . context = context ; }
public void register prefix for u r i ( string prefix , string uri ) { if ( debug enable ) { log . debug ( message . get message ( `` register00 `` , prefix , uri ) ) ; } if ( ( uri ! = null ) & & ( prefix ! = null ) ) { if ( no namespace mapping ) { ns stack . push ( ) ; no namespace mapping = false ; } string active prefix = ns stack . get prefix ( uri , true ) ; if ( active prefix == null || ! active prefix . equal ( prefix ) ) { ns stack . add ( uri , prefix ) ; } } }
public type mapping get or make type mapping ( string encode style ) { type mapping delegate del = ( type mapping delegate ) map t m . get ( encode style ) ; if ( del == null || del . delegate instanceof default type map impl ) { del = ( type mapping delegate ) create type mapping ( ) ; del . set supported encoding ( new string [ ] { encode style } ) ; register ( encode style , del ) ; } return del ; }
public string map path ( string path ) { return null ; }
public void clear session ( ) { weak hash map map = ( weak hash map ) session . get ( this . get name ( ) ) ; if ( map == null ) return ; iterator iter = map . key set ( ) . iterator ( ) ; while ( iter . have next ( ) ) { session session = ( session ) iter . next ( ) ; session . remove ( this . get name ( ) ) ; } }
public void start ( ) { be run = true ; }
public static void set logging ( boolean logging ) { should log = logging ; }
public iterator get child element ( ) { initialize child ( ) ; return child . iterator ( ) ; }
public boolean be dirty ( ) { return _is dirty ; }
public void set type ( q name qname ) { type q name = qname ; }
public void set q name ( q name q name ) { this . name = q name . get local part ( ) ; this . namespace u r i = q name . get namespace u r i ( ) ; }
public string get prefix ( string search namespace u r i ) { if ( ( search namespace u r i == null ) || ( `` `` . equal ( search namespace u r i ) ) ) return null ; if ( href ! = null & & get real element ( ) ! = null ) { return get real element ( ) . get prefix ( search namespace u r i ) ; } for ( int i = 0 ; namespaces ! = null & & i < namespaces . size ( ) ; i++ ) { map map = ( map ) namespaces . get ( i ) ; if ( map . get namespace u r i ( ) . equal ( search namespace u r i ) ) { return map . get prefix ( ) ; } } if ( parent ! = null ) { return ( ( message element ) parent ) . get prefix ( search namespace u r i ) ; } return null ; }
public message element get real element ( ) { if ( href == null ) { return this ; } object obj = context . get object by ref ( href ) ; if ( obj == null ) { return null ; } if ( ! ( obj instanceof message element ) ) { return null ; } return ( message element ) obj ; }
public void set n s mapping ( array list namespaces ) { this . namespaces = namespaces ; }
public boolean remove namespace declaration ( string namespace prefix ) { make attribute editable ( ) ; boolean remove = false ; for ( int i = 0 ; namespaces ! = null & & i < namespaces . size ( ) & & ! remove ; i++ ) { if ( ( ( map ) namespaces . get ( i ) ) . get prefix ( ) . equal ( namespace prefix ) ) { namespaces . remove ( i ) ; remove = true ; } } return remove ; }
public void reset ( ) { if ( child ! = null ) { for ( int i=0 ; i < child . size ( ) ; i++ ) { ( ( node impl ) child . get ( i ) ) . reset ( ) ; } } this . _is dirty = false ; }
public node replace child ( node new child , node old child ) throw d o m exception { initialize child ( ) ; int position = child . index of ( old child ) ; if ( position < 0 ) { throw new d o m exception ( d o m exception . not_found_err , `` node impl not find `` ) ; } child . remove ( position ) ; child . add ( position , new child ) ; set dirty ( ) ; return old child ; }
protect void output impl ( serialization context output context ) throw exception { if ( text rep ! = null ) { boolean old pretty = output context . get pretty ( ) ; output context . set pretty ( false ) ; if ( text rep instanceof c d a t a section ) { output context . write string ( `` < ! [ cdata [ `` ) ; output context . write string ( text rep . get data ( ) ) ; output context . write string ( `` ] ] > `` ) ; } else if ( text rep instanceof comment ) { output context . write string ( `` < ! -- `` ) ; output context . write string ( text rep . get data ( ) ) ; output context . write string ( `` -- > `` ) ; } else if ( text rep instanceof text ) { output context . write safe string ( text rep . get data ( ) ) ; } output context . set pretty ( old pretty ) ; return ; } if ( prefix ! = null ) output context . register prefix for u r i ( prefix , namespace u r i ) ; if ( namespaces ! = null ) { for ( iterator i = namespaces . iterator ( ) ; i . have next ( ) ; ) { map map = ( map ) i . next ( ) ; output context . register prefix for u r i ( map . get prefix ( ) , map . get namespace u r i ( ) ) ; } } if ( object value ! = null ) { output context . serialize ( new q name ( namespace u r i , name ) , attribute , object value ) ; return ; } output context . start element ( new q name ( namespace u r i , name ) , attribute ) ; if ( child ! = null ) { for ( iterator it = child . iterator ( ) ; it . have next ( ) ; ) { ( ( node impl ) it . next ( ) ) . output ( output context ) ; } } output context . end element ( ) ; }
public void remove body ( ) { if ( body ! = null ) { remove child ( body ) ; } body = null ; }
public s o a p constant get s o a p constant ( ) { return soap constant ; }
public string get fault actor ( ) { return fault . get fault actor ( ) ; }
public void add header ( s o a p header element hdr ) { if ( header == null ) { header = new s o a p header ( this , soap constant ) ; } hdr . set envelope ( this ) ; header . add header ( hdr ) ; _is dirty = true ; }
public void dispose ( ) { if ( m attachment ! =null ) { m attachment . dispose ( ) ; } }
public void set role ( string [ ] role ) { this . roles = role ; }
public s o a p constant get s o a p constant ( ) { return soap constant ; }
public schema version get schema version ( ) { return schema version ; }
public message get current message ( ) { return ( have pass pivot ? response message : request message ) ; }
public javax . xml . soap . s o a p part get s o a p part ( ) { return m s o a p part ; }
public void set message ( javax . xml . soap . s o a p message message ) { set current message ( ( message ) message ) ; }
protect string get str option ( string option name , handler service ) { string value = null ; if ( service ! = null ) value = ( string ) service . get option ( option name ) ; if ( value == null ) value = ( string ) get option ( option name ) ; return value ; }
public void set default session timeout ( int default session timeout ) { this . default session timeout = default session timeout ; }
public void remove ( string key ) { if ( rep ! = null ) rep . remove ( key ) ; last touch = system . current time millis ( ) ; }
public void remove ( string key ) { if ( rep ! = null ) rep . remove ( key ) ; last touch = system . current time millis ( ) ; }
public s o a p constant get s o a p constant ( ) { return soap constant ; }
protect object increment ( object value ) { return invoker helper . invoke method ( value , `` next `` , null ) ; }
public string get link uri ( org . w3c . dom . element e ) { string href = null ; if ( e . get node name ( ) . equal ignore case ( `` a `` ) & & e . have attribute ( `` href `` ) ) { href = e . get attribute ( `` href `` ) ; } return href ; }
public void remove hostname ( ) { remove fault detail ( constant . qname_faultdetail_hostname ) ; }
public void close ( ) throw s o a p exception { if ( close ) { throw new s o a p exception ( message . get message ( `` connection closed00 `` ) ) ; } close = true ; }
public void close ( ) throw s o a p exception { if ( close ) { throw new s o a p exception ( message . get message ( `` connection closed00 `` ) ) ; } close = true ; }
public void register and log resource ( final string resource ) { try { register resource ( resource ) ; log success ( resource ) ; } catch ( exception e ) { log . error ( message . get message ( `` auto reg servlet load failed01 `` , resource ) , e ) ; } }
public http session get rep ( ) { ensure session ( ) ; return rep ; }
protect void set closure delegate ( closure closure , object node ) { closure . set delegate ( this ) ; }
public http session get rep ( ) { ensure session ( ) ; return rep ; }
public void set max session ( int max session ) { this . max session = max session ; ( ( l r u map ) session ) . set maximum size ( max session ) ; }
public axis server get engine ( ) throw axis fault { if ( axis server == null ) axis server = get engine ( this ) ; return axis server ; }
public shareable object pool get vendor pool ( string vendor id ) { return ( shareable object pool ) vendor connector pool . get ( vendor id ) ; }
public static string remove string property ( map property , string key , string default value ) { string value = default value ; if ( property ! = null & & property . contains key ( key ) ) { try { value = ( string ) property . remove ( key ) ; } catch ( exception ignore ) { } } return value ; }
public axis server get engine ( ) throw axis fault { if ( axis server == null ) axis server = get engine ( this ) ; return axis server ; }
public int hash code ( ) { int hash = 0 ; for ( int i = 0 ; i < idrefs . length ; i++ ) { hash += idrefs [ i ] . hash code ( ) ; } return hash ; }
public int hash code ( ) { return null == timezone ? month : month ^ timezone . hash code ( ) ; }
public string get host ( ) { return m_host ; }
public string get userinfo ( ) { return m_userinfo ; }
public void set fragment ( string p_fragment ) throw malformed u r i exception { if ( p_fragment == null ) { m_fragment = null ; } else if ( ! be generic u r i ( ) ) { throw new malformed u r i exception ( `` fragment can only be set for a generic uri ! `` ) ; } else if ( get path ( ) == null ) { throw new malformed u r i exception ( `` fragment can not be set when path be null ! `` ) ; } else if ( ! be u r i string ( p_fragment ) ) { throw new malformed u r i exception ( `` fragment contain invalid character ! `` ) ; } else { m_fragment = p_fragment ; } }
public boolean equal ( object p_test ) { if ( p_test instanceof uri ) { uri test u r i = ( uri ) p_test ; if ( ( ( m_scheme == null & & test u r i . m_scheme == null ) || ( m_scheme ! = null & & test u r i . m_scheme ! = null & & m_scheme . equal ( test u r i . m_scheme ) ) ) & & ( ( m_userinfo == null & & test u r i . m_userinfo == null ) || ( m_userinfo ! = null & & test u r i . m_userinfo ! = null & & m_userinfo . equal ( test u r i . m_userinfo ) ) ) & & ( ( m_reg authority == null & & test u r i . m_reg authority == null ) || ( m_reg authority ! = null & & test u r i . m_reg authority ! = null & & m_reg authority . equal ( test u r i . m_reg authority ) ) ) & & ( ( m_host == null & & test u r i . m_host == null ) || ( m_host ! = null & & test u r i . m_host ! = null & & m_host . equal ( test u r i . m_host ) ) ) & & m_port == test u r i . m_port & & ( ( m_path == null & & test u r i . m_path == null ) || ( m_path ! = null & & test u r i . m_path ! = null & & m_path . equal ( test u r i . m_path ) ) ) & & ( ( m_query string == null & & test u r i . m_query string == null ) || ( m_query string ! = null & & test u r i . m_query string ! = null & & m_query string . equal ( test u r i . m_query string ) ) ) & & ( ( m_fragment == null & & test u r i . m_fragment == null ) || ( m_fragment ! = null & & test u r i . m_fragment ! = null & & m_fragment . equal ( test u r i . m_fragment ) ) ) ) { return true ; } } return false ; }
public boolean be writeable ( ) { return ( my p d . get write method ( ) ! = null ) ; }
public boolean be indexed or array ( ) { return ( be index ( ) || be array ( ) ) ; }
public void set ( object obj , object new value ) throw invocation target exception , illegal access exception { method write method = my p d . get write method ( ) ; if ( write method ! = null ) { write method . invoke ( obj , new object [ ] { new value } ) ; } else { throw new illegal access exception ( message . get message ( `` bad setter00 `` ) ) ; } }
public static void set class loader ( string class name , class loader loader ) { if ( class name ! = null & & loader ! = null ) classloaders . put ( class name , loader ) ; }
public object get ( object key ) { if ( ! contains key ( key ) ) return null ; object value = remove ( key ) ; super . put ( key , value ) ; return value ; }
public static synchronize java class find ( class jc ) { java class result = ( java class ) class . get ( jc ) ; if ( result == null ) { result = new java class ( jc ) ; class . put ( jc , result ) ; } return result ; }
protect object get cache key ( string view name , locale locale ) { return view name + ' _ ' + locale ; }
public static boolean be empty ( final object object ) { if ( object == null ) { return true ; } if ( object instanceof char sequence ) { return ( ( char sequence ) object ) . length ( ) == 0 ; } if ( object . get class ( ) . be array ( ) ) { return array . get length ( object ) == 0 ; } if ( object instanceof collection < ? > ) { return ( ( collection < ? > ) object ) . be empty ( ) ; } if ( object instanceof map < ? , ? > ) { return ( ( map < ? , ? > ) object ) . be empty ( ) ; } return false ; }
public static final boolean be true explicitly ( string value ) { return value ! = null & & ( value . equal ignore case ( `` true `` ) || value . equal ( `` 1 `` ) || value . equal ignore case ( `` yes `` ) ) ; }
public synchronize hashtable get parent ( ) { return parent ; }
public final expression optimize ( expression visitor visitor , item type context item type ) { return this ; }
protect void set output body type ( operation operation , use output body type ) { operation attr attr = ( operation attr ) attribute . get ( operation ) ; if ( attr == null ) { attr = new operation attr ( ) ; attribute . put ( operation , attr ) ; } attr . set output body type ( output body type ) ; if ( output body type == use . literal ) { set have literal ( true ) ; } } // set output body type
public type entry get complex type extension base ( symbol table symbol table ) { if ( ! search for extension base ) { if ( null == extension base ) { extension base = schema utils . get complex element extension base ( get node ( ) , symbol table ) ; } search for extension base = true ; } return extension base ; }
public service entry get service entry ( q name qname ) { return ( service entry ) get ( qname , service entry . class ) ; } // get service entry
public type entry get type entry ( q name qname , boolean want element type ) { if ( want element type ) { return get element ( qname ) ; } else { return get type ( qname ) ; } } // get type entry
public static boolean equal ( q name first , q name second ) { if ( first == second ) { return true ; } if ( first==null || second==null ) { return false ; } if ( first . equal ( second ) ) { return true ; } if ( ! first . get local part ( ) . equal ( second . get local part ( ) ) ) { return false ; } string namespace u r i = first . get namespace u r i ( ) ; string [ ] search = null ; if ( namespace u r i . equal ( uri_default_soap_enc ) ) search = uris_soap_enc ; else if ( namespace u r i . equal ( uri_default_soap_env ) ) search = uris_soap_env ; else if ( namespace u r i . equal ( uri_default_schema_xsd ) ) search = uris_schema_xsd ; else if ( namespace u r i . equal ( uri_default_schema_xsi ) ) search = uris_schema_xsi ; else search = new string [ ] { namespace u r i } ; for ( int i=0 ; i < search . length ; i++ ) { if ( search [ i ] . equal ( second . get namespace u r i ( ) ) ) { return true ; } } return false ; }
public type entry get type entry ( q name qname , boolean want element type ) { if ( want element type ) { return get element ( qname ) ; } else { return get type ( qname ) ; } } // get type entry
public element get element ( q name qname ) { return ( element ) element type entry . get ( qname ) ; } // get element
public void set build file want ( boolean value ) { b build file generation = value ; }
public void set skeleton want ( boolean value ) { b deploy skeleton = value ; } // set skeleton want
public void run ( string wsdl u r l ) throw exception { setup ( ) ; super . run ( wsdl u r l ) ; } // run
public void set server side ( boolean value ) { this . b emit server = value ; } // set server side
public boolean be skeleton wanted ( ) { return b deploy skeleton ; } // be skeleton want
public void generate ( ) throw i o exception { string fqcn = get package ( ) + `` . `` + get class name ( ) ; if ( emitter . be deploy ( ) & & emitter . do exist ( fqcn ) ) { if ( emitter . be helper want ( ) ) { helper . generate ( ) ; } } else { super . generate ( ) ; } }
public class < ? > get common property type ( e l context context , object base ) { return string . class ; }
public void generate ( ) throw i o exception { if ( emitter . be server side ( ) ) { super . generate ( ) ; } } // generate
protect string get implement text ( ) { return `` implement `` + b entry . get dynamic var ( java binding writer . interface_name ) + `` `` ; } // get implement text
protect void write serializer ( print writer pw ) throw i o exception { string type desc = `` type desc `` ; string ser = `` org . apache . axis . encode . ser . bean serializer `` ; if ( type . be simple type ( ) ) { ser = `` org . apache . axis . encode . ser . simple serializer `` ; } pw . println ( `` / * * `` ) ; pw . println ( `` * get custom serializer `` ) ; pw . println ( `` * / `` ) ; pw . println ( `` public static org . apache . axis . encode . serializer get serializer ( `` ) ; pw . println ( `` java . lang . string mech type , `` ) ; pw . println ( `` java . lang . class _java type , `` ) ; pw . println ( `` javax . xml . namespace . q name _xml type ) { `` ) ; pw . println ( `` return `` ) ; pw . println ( `` new `` + ser + `` ( `` ) ; pw . println ( `` _java type , _xml type , `` + type desc + `` ) ; `` ) ; pw . println ( `` } `` ) ; pw . println ( ) ; }
public string get create prefix ( string namespace ) { if ( namespace prefix map . get ( namespace ) == null ) { namespace prefix map . put ( namespace , `` tns `` + prefix count++ ) ; } return ( string ) namespace prefix map . get ( namespace ) ; }
public string to string ( ) { return `` q name ( \ `` `` + get namespace u r i ( ) + `` \ `` , \ `` `` + get local name ( ) + `` \ `` ) `` ; }
public string get token u r l ( ) { return this . token u r l ; }
public string get base upload u r l ( ) { return this . base upload u r l ; }
public void set connect timeout ( int connect timeout ) { this . connect timeout = connect timeout ; }
public void authenticate ( string auth code ) { url url = null ; try { url = new url ( this . token u r l ) ; } catch ( malformed u r l exception e ) { assert false : `` an invalid token url indicate a bug in the sdk . `` ; throw new runtime exception ( `` an invalid token url indicate a bug in the sdk . `` , e ) ; } string url parameter = string . format ( `` grant_type=authorization_code & code= % s & client_id= % s & client_secret= % s `` , auth code , this . client i d , this . client secret ) ; box a p i request request = new box a p i request ( this , url , `` post `` ) ; request . should authenticate ( false ) ; request . set body ( url parameter ) ; box j s o n response response = ( box j s o n response ) request . send ( ) ; string json = response . get j s o n ( ) ; json object json object = json object . read from ( json ) ; this . access token = json object . get ( `` access_token `` ) . a string ( ) ; this . refresh token = json object . get ( `` refresh_token `` ) . a string ( ) ; this . last refresh = system . current time millis ( ) ; this . expire = json object . get ( `` expires_in `` ) . a long ( ) * 1000 ; }
protect void notify refresh ( ) { for ( box a p i connection listener listener : this . listener ) { listener . on refresh ( this ) ; } }
public void authenticate ( string auth code ) { url url = null ; try { url = new url ( this . token u r l ) ; } catch ( malformed u r l exception e ) { assert false : `` an invalid token url indicate a bug in the sdk . `` ; throw new runtime exception ( `` an invalid token url indicate a bug in the sdk . `` , e ) ; } string url parameter = string . format ( `` grant_type=authorization_code & code= % s & client_id= % s & client_secret= % s `` , auth code , this . client i d , this . client secret ) ; box a p i request request = new box a p i request ( this , url , `` post `` ) ; request . should authenticate ( false ) ; request . set body ( url parameter ) ; box j s o n response response = ( box j s o n response ) request . send ( ) ; string json = response . get j s o n ( ) ; json object json object = json object . read from ( json ) ; this . access token = json object . get ( `` access_token `` ) . a string ( ) ; this . refresh token = json object . get ( `` refresh_token `` ) . a string ( ) ; this . last refresh = system . current time millis ( ) ; this . expire = json object . get ( `` expires_in `` ) . a long ( ) * 1000 ; }
protect void reset body ( ) throw i o exception { if ( this . body ! = null ) { this . body . reset ( ) ; } }
public box collaboration whitelist exempt target . info get info ( ) { url url = collaboration_whitelist_exempt_target_entry_url_template . build ( this . get a p i ( ) . get base u r l ( ) , this . get i d ( ) ) ; box a p i request request = new box a p i request ( this . get a p i ( ) , url , http method . get ) ; box j s o n response response = ( box j s o n response ) request . send ( ) ; return new info ( json object . read from ( response . get j s o n ( ) ) ) ; }
public box collaboration whitelist exempt target . info get info ( ) { url url = collaboration_whitelist_exempt_target_entry_url_template . build ( this . get a p i ( ) . get base u r l ( ) , this . get i d ( ) ) ; box a p i request request = new box a p i request ( this . get a p i ( ) , url , http method . get ) ; box j s o n response response = ( box j s o n response ) request . send ( ) ; return new info ( json object . read from ( response . get j s o n ( ) ) ) ; }
public json object get json object ( ) { if ( this . json object ! = null ) { return this . json object ; } else { return json object . read from ( this . get j s o n ( ) ) ; } }
public boolean can upload version ( string name ) { return this . can upload version ( name , 0 ) ; }
public list < box comment . info > get comment ( ) { url url = get_comments_url_template . build ( this . get a p i ( ) . get base u r l ( ) , this . get i d ( ) ) ; box a p i request request = new box a p i request ( this . get a p i ( ) , url , `` get `` ) ; box j s o n response response = ( box j s o n response ) request . send ( ) ; json object response j s o n = json object . read from ( response . get j s o n ( ) ) ; int total count = response j s o n . get ( `` total_count `` ) . a int ( ) ; list < box comment . info > comment = new array list < box comment . info > ( total count ) ; json array entry = response j s o n . get ( `` entry `` ) . a array ( ) ; for ( json value value : entry ) { json object comment j s o n = value . a object ( ) ; box comment comment = new box comment ( this . get a p i ( ) , comment j s o n . get ( `` id `` ) . a string ( ) ) ; box comment . info info = comment . new info ( comment j s o n ) ; comment . add ( info ) ; } return comment ; }
public box collaboration . info collaborate ( box collaborator collaborator , box collaboration . role role ) { json object accessible by field = new json object ( ) ; accessible by field . add ( `` id `` , collaborator . get i d ( ) ) ; if ( collaborator instanceof box user ) { accessible by field . add ( `` type `` , `` user `` ) ; } else if ( collaborator instanceof box group ) { accessible by field . add ( `` type `` , `` group `` ) ; } else { throw new illegal argument exception ( `` the give collaborator be of an unknown type . `` ) ; } return this . collaborate ( accessible by field , role , null , null ) ; }
public box collaboration . info collaborate ( box collaborator collaborator , box collaboration . role role ) { json object accessible by field = new json object ( ) ; accessible by field . add ( `` id `` , collaborator . get i d ( ) ) ; if ( collaborator instanceof box user ) { accessible by field . add ( `` type `` , `` user `` ) ; } else if ( collaborator instanceof box group ) { accessible by field . add ( `` type `` , `` group `` ) ; } else { throw new illegal argument exception ( `` the give collaborator be of an unknown type . `` ) ; } return this . collaborate ( accessible by field , role , null , null ) ; }
public box file upload session . info get status ( ) { url status u r l = this . session info . get session endpoint ( ) . get status endpoint ( ) ; box j s o n request request = new box j s o n request ( this . get a p i ( ) , status u r l , http method . get ) ; box j s o n response response = ( box j s o n response ) request . send ( ) ; json object json object = json object . read from ( response . get j s o n ( ) ) ; this . session info . update ( json object ) ; return this . session info ; }
public string get version i d ( ) { return this . version i d ; }
public string get version i d ( ) { return this . version i d ; }
public void remove watermark ( ) { this . remove watermark ( folder_info_url_template ) ; }
public static void set max request attempt ( int max request attempt ) { box global setting . max request attempt = max request attempt ; }
public void delete ( ) { box a p i connection api = this . get a p i ( ) ; url url = membership_url_template . build ( api . get base u r l ( ) , this . get i d ( ) ) ; box a p i request request = new box a p i request ( api , url , `` delete `` ) ; box a p i response response = request . send ( ) ; response . disconnect ( ) ; }
public boolean be open ( ) { return be open ; }
public url get redirect u r l ( ) { return this . redirect u r l ; }
public box legal hold assignment . info assign to ( box resource resource ) { return box legal hold assignment . create ( this . get a p i ( ) , this . get i d ( ) , box resource . get resource type ( resource . get class ( ) ) , resource . get i d ( ) ) ; }
public box retention policy assignment . info assign to metadata template ( string template i d , metadata field filter . . . field filter ) { return box retention policy assignment . create assignment to metadata ( this . get a p i ( ) , this . get i d ( ) , template i d , field filter ) ; }
public void set updated range ( date range updated range ) { this . updated range = update range ; }
public void set query ( string query ) { this . query = query ; }
public iterable < box group membership . info > get all membership ( string . . . field ) { final query string builder builder = new query string builder ( ) ; if ( field . length > 0 ) { builder . append param ( `` field `` , field ) ; } return new iterable < box group membership . info > ( ) { public iterator < box group membership . info > iterator ( ) { url url = user_memberships_url_template . build with query ( box user . this . get a p i ( ) . get base u r l ( ) , builder . to string ( ) , box user . this . get i d ( ) ) ; return new box group membership iterator ( box user . this . get a p i ( ) , url ) ; } } ; }
public void delete file ( string file i d ) { url url = file_info_url_template . build ( this . api . get base u r l ( ) , file i d ) ; box a p i request request = new box a p i request ( this . api , url , `` delete `` ) ; box a p i response response = request . send ( ) ; response . disconnect ( ) ; }
public void set access ( access access ) { this . access = access ; this . add pending change ( `` access `` , access . to j s o n value ( ) ) ; }
public void update info ( box user . info info ) { url url = user_url_template . build ( this . get a p i ( ) . get base u r l ( ) , this . get i d ( ) ) ; box j s o n request request = new box j s o n request ( this . get a p i ( ) , url , `` put `` ) ; request . set body ( info . get pending change ( ) ) ; box j s o n response response = ( box j s o n response ) request . send ( ) ; json object json object = json object . read from ( response . get j s o n ( ) ) ; info . update ( json object ) ; }
public void update info ( box web link . info info ) { url url = web_link_url_template . build ( this . get a p i ( ) . get base u r l ( ) , this . get i d ( ) ) ; box j s o n request request = new box j s o n request ( this . get a p i ( ) , url , `` put `` ) ; request . set body ( info . get pending change ( ) ) ; string body = info . get pending change ( ) ; box j s o n response response = ( box j s o n response ) request . send ( ) ; json object json object = json object . read from ( response . get j s o n ( ) ) ; info . update ( json object ) ; }
public create user params set be exempt from login verification ( boolean be exempt from login verification ) { this . be exempt from login verification = be exempt from login verification ; return this ; }
public file upload params set name ( string name ) { this . name = name ; return this ; }
public string get parent i d ( ) { return this . get ( `` / $ parent `` ) ; }
public json object get filter list ( ) { return this . filter list ; }
public metadata add ( string path , string value ) { this . value . add ( this . path to property ( path ) , value ) ; this . add op ( `` add `` , path , value ) ; return this ; }
public date get date ( string path ) throw parse exception { return box date format . parse ( this . get value ( path ) . a string ( ) ) ; }
public string get template key ( ) { return this . template key ; }
public string get representation ( ) { return this . representation ; }
public void set low bound byte ( int low bound byte ) { this . low bound byte = low bound byte ; }
protect double get domain low bound ( double p ) { return 0 ; }
protect void define class ( string class name ) { string base name = name . suffix ( class name,1 ) ; int i = base name . index of ( `` $ `` ) ; if ( i ! = -1 ) base name = base name . substring ( i+1 ) ; string cur = ( string ) define class base name . get ( base name ) ; if ( cur ! = null ) throw new interpreter error ( `` define class problem : `` +class name + `` : bean shell can not yet simultaneously define two or more `` + `` dependent class of the same name . attempt to define : `` + class name + `` while defining : `` +cur ) ; define class . put ( class name , novalue ) ; define class base names . put ( base name , class name ) ; }
protect void define class ( string class name ) { string base name = name . suffix ( class name,1 ) ; int i = base name . index of ( `` $ `` ) ; if ( i ! = -1 ) base name = base name . substring ( i+1 ) ; string cur = ( string ) define class base name . get ( base name ) ; if ( cur ! = null ) throw new interpreter error ( `` define class problem : `` +class name + `` : bean shell can not yet simultaneously define two or more `` + `` dependent class of the same name . attempt to define : `` + class name + `` while defining : `` +cur ) ; define class . put ( class name , novalue ) ; define class base names . put ( base name , class name ) ; }
public class [ ] get parameter type ( ) { return cparam type ; }
public name space swap ( name space new top ) { name space old top = ( name space ) ( stack . element at ( 0 ) ) ; stack . set element at ( new top , 0 ) ; return old top ; }
public void cache class info ( string name , class value ) { if ( value ! = null ) absolute class cache . put ( name , value ) ; else absolute non class . put ( name , novalue ) ; }
public void add name source listener ( name source . listener listener ) { if ( name source listener == null ) name source listener = new array list ( ) ; name source listener . add ( listener ) ; }
protect void define class ( string class name ) { string base name = name . suffix ( class name,1 ) ; int i = base name . index of ( `` $ `` ) ; if ( i ! = -1 ) base name = base name . substring ( i+1 ) ; string cur = ( string ) define class base name . get ( base name ) ; if ( cur ! = null ) throw new interpreter error ( `` define class problem : `` +class name + `` : bean shell can not yet simultaneously define two or more `` + `` dependent class of the same name . attempt to define : `` + class name + `` while defining : `` +cur ) ; define class . put ( class name , novalue ) ; define class base names . put ( base name , class name ) ; }
public static void main ( string [ ] args ) { system . out . println ( `` jts debugging be `` + ( debug on ? `` on `` : `` off `` ) ) ; }
public object eval ( reader in ) throw eval error { return eval ( in , global name space , `` eval stream `` ) ; }
public void clear ( ) { super . clear ( ) ; external map . clear ( ) ; }
public static void main ( string [ ] args ) throw i o exception { string filename = args [ 0 ] ; string param = args [ 1 ] ; string value = args [ 2 ] ; file reader fr = new file reader ( filename ) ; string template text = simple template . get string from stream ( fr ) ; simple template template = new simple template ( template text ) ; template . replace ( param , value ) ; template . write ( system . out ) ; }
public static void shutdown now ( ) { for ( stage stage : stage . value ( ) ) { stage manager . stage . get ( stage ) . shutdown now ( ) ; } }
public void update definition ( view definition definition ) { this . definition = definition ; list < column definition > non p k def part of view p k = new array list < > ( ) ; for ( column definition base column : base cf . metadata . all column ( ) ) { column definition view column = get view column ( base column ) ; if ( view column ! = null & & ! base column . be primary key column ( ) & & view column . be primary key column ( ) ) non p k def part of view p k . add ( base column ) ; } this . base non p k column in view p k = non p k def part of view p k ; }
public void set keyspace metadata ( keyspace metadata ksm ) { assert ksm ! = null ; keyspaces . put ( ksm . name , ksm ) ; keyspace keyspace = get keyspace instance ( ksm . name ) ; if ( keyspace ! = null ) keyspace . set metadata ( ksm ) ; }
public schema load ( iterable < keyspace metadata > keyspace defs ) { keyspace defs . for each ( this : : load ) ; return this ; }
public static synchronize void reload schema and announce version ( ) { keyspaces before = schema . instance . get replicated keyspaces ( ) ; keyspaces after = fetch non system keyspaces ( ) ; merge schema ( before , after ) ; schema . instance . update version and announce ( ) ; }
public static aggregate function make count function ( abstract type < ? > input type ) { return new native aggregate function ( `` count `` , long type . instance , input type ) { public aggregate new aggregate ( ) { return new aggregate ( ) { private long count ; public void reset ( ) { count = 0 ; } public byte buffer compute ( protocol version protocol version ) { return ( ( long type ) return type ( ) ) . decompose ( count ) ; } public void add input ( protocol version protocol version , list < byte buffer > value ) { byte buffer value = value . get ( 0 ) ; if ( value == null ) return ; count++ ; } } ; } } ; }
public consistency level get serial consistency ( ) { return get specific option ( ) . serial consistency ; }
public final boolean have i n ( ) { for ( single restriction restriction : this ) { if ( restriction . be i n ( ) ) return true ; } return false ; }
public boolean need filter ( ) { int number of restriction = filter restriction . get custom index expression ( ) . size ( ) ; for ( restriction restriction : filter restriction . get restriction ( ) ) number of restriction += restriction . size ( ) ; return number of restriction > 1 || ( number of restriction == 0 & & ! cluster columns restriction . be empty ( ) ) || ( number of restriction ! = 0 & & non primary key restriction . have multiple contains ( ) ) ; }
public boolean key be in relation ( ) { return partition key restriction . have i n ( ) ; }
public boolean be inclusive ( bound b ) { return bound [ b . idx ] == null || bound inclusive [ b . idx ] ; }
public boolean contain only static column ( ) { if ( ! contain static column ( ) ) return false ; if ( be wildcard ( ) ) return false ; for ( column definition def : get column ( ) ) { if ( ! def . be partition key ( ) & & ! def . be static ( ) ) return false ; } return true ; }
public void collect marker specification ( variable specification bound names ) { if ( collection element ! = null ) collection element . collect marker specification ( bound names ) ; if ( ( operator == operator . in ) & & in value ! = null ) { for ( term value : in value ) value . collect marker specification ( bound names ) ; } else { value . collect marker specification ( bound names ) ; } }
public static http2 exception connection error ( http2 error error , string fmt , object . . . args ) { return new http2 exception ( error , string . format ( fmt , args ) ) ; }
public list < abstract type < ? > > subtypes ( ) { return cluster type ; }
public listenable future < commit log position > force flush ( ) { synchronize ( data ) { memtable current = data . get view ( ) . get current memtable ( ) ; for ( column family store cf : concat with index ( ) ) if ( ! cf . data . get view ( ) . get current memtable ( ) . be clean ( ) ) return switch memtable if current ( current ) ; return wait for flush ( ) ; } }
public set < s s table reader > snapshot ( string snapshot name ) { return snapshot ( snapshot name , false ) ; }
public static column family store get if exists ( string k name , string cf name ) { if ( k name == null || cf name == null ) return null ; keyspace keyspace = keyspace . open ( ks name ) ; if ( keyspace == null ) return null ; uuid id = schema . instance . get id ( ks name , cf name ) ; if ( id == null ) return null ; return keyspace . get column family store ( id ) ; }
public static medium type most specific ( medium type m1 , medium type m2 ) { if ( m1 . be wildcard type ( ) & & ! m2 . be wildcard type ( ) ) { return m2 ; } if ( m1 . be wildcard subtype ( ) & & ! m2 . be wildcard subtype ( ) ) { return m2 ; } if ( m2 . get parameter ( ) . size ( ) > m1 . get parameter ( ) . size ( ) ) { return m2 ; } return m1 ; }
public int complex column count ( ) { return b tree . size ( column ) - complex idx ; }
public int complex column count ( ) { return b tree . size ( column ) - complex idx ; }
protect double get domain low bound ( double p ) { return 0 ; }
public abstract compaction task get next background task ( int gc before ) { maybe reload disk boundary ( ) ; read lock . lock ( ) ; try { if ( ! be enable ( ) ) return null ; list < abstract compaction strategy > strategy = new array list < > ( ) ; strategy . add all ( repair ) ; strategy . add all ( unrepaired ) ; collection . sort ( strategy , ( o1 , o2 ) - > ints . compare ( o2 . get estimate remain task ( ) , o1 . get estimate remain task ( ) ) ) ; for ( abstract compaction strategy strategy : strategy ) { abstract compaction task task = strategy . get next background task ( gc before ) ; if ( task ! = null ) return task ; } } finally { read lock . unlock ( ) ; } return null ; }
public final boolean append ( unfiltered row iterator partition ) { maybe switch writer ( partition . partition key ( ) ) ; return real append ( partition ) ; }
public byte buffer create update ( long count ) { context state state = context state . allocate ( 0 , 1 , 0 ) ; state . write local ( update_clock_id , 1l , count ) ; return state . context ; }
public long get local count ( byte buffer context ) { return get local clock and count ( context ) . count ; }
public void checkpoint ( ) { maybe fail ( checkpoint ( null ) ) ; }
public static void wait for deletion ( ) { log transaction . wait for deletion ( ) ; }
public int data size ( ) { return type size . sizeof ( timestamp ( ) ) ; }
public long max timestamp ( ) { maybe build ( ) ; long max timestamp = deletion info . max timestamp ( ) ; for ( row row : this ) { max timestamp = math . max ( max timestamp , row . primary key liveness info ( ) . timestamp ( ) ) ; for ( column data cd : row ) { if ( cd . column ( ) . be simple ( ) ) { max timestamp = math . max ( max timestamp , ( ( cell ) cd ) . timestamp ( ) ) ; } else { complex column data complex data = ( complex column data ) cd ; max timestamp = math . max ( max timestamp , complex data . complex deletion ( ) . mark for delete at ( ) ) ; for ( cell cell : complex data ) max timestamp = math . max ( max timestamp , cell . timestamp ( ) ) ; } } } return max timestamp ; }
public int data size ( ) { return type size . sizeof ( timestamp ( ) ) ; }
public boolean be authentication preemptive ( ) { return this . preemptive ; }
public deletion time complex deletion ( ) { return complex deletion ; }
public static partition update empty update ( c f meta data metadata , decorate key key ) { mutable deletion info deletion info = mutable deletion info . live ( ) ; holder holder = new holder ( partition column . none , b tree . empty ( ) , deletion info , row . empty_static_row , encode stats . no_stats ) ; return new partition update ( metadata , key , holder , deletion info , false ) ; }
public deletion time end deletion time ( ) { return end deletion ; }
public partition iterator post reconciliation processing ( partition iterator result ) { column family store cf = keyspace . open ( metadata ( ) . ks name ) . get column family store ( metadata ( ) . cf name ) ; index index = get index ( cf ) ; return index == null ? result : index . post processor for ( this ) . apply ( result , this ) ; }
public boolean include ( cluster comparator comparator , cluster prefix bound ) { return comparator . compare ( start , bound ) < = 0 & & comparator . compare ( bound , end ) < = 0 ; }
public final expression optimize ( expression visitor visitor , item type context item type ) { return this ; }
public void update definition ( view definition definition ) { this . definition = definition ; list < column definition > non p k def part of view p k = new array list < > ( ) ; for ( column definition base column : base cf . metadata . all column ( ) ) { column definition view column = get view column ( base column ) ; if ( view column ! = null & & ! base column . be primary key column ( ) & & view column . be primary key column ( ) ) non p k def part of view p k . add ( base column ) ; } this . base non p k column in view p k = non p k def part of view p k ; }
public void update definition ( view definition definition ) { this . definition = definition ; list < column definition > non p k def part of view p k = new array list < > ( ) ; for ( column definition base column : base cf . metadata . all column ( ) ) { column definition view column = get view column ( base column ) ; if ( view column ! = null & & ! base column . be primary key column ( ) & & view column . be primary key column ( ) ) non p k def part of view p k . add ( base column ) ; } this . base non p k column in view p k = non p k def part of view p k ; }
public static range < partition position > make row range ( token left , token right ) { return new range < partition position > ( leave . max key bound ( ) , right . max key bound ( ) ) ; }
public static void set input split size in mb ( configuration conf , int split size mb ) { conf . set int ( input_split_size_in_mb_config , split size mb ) ; }
public static void set ignore host ( configuration conf , string ignore node csv ) { conf . set ( cql bulk record writer . ignore_hosts , ignore node csv ) ; }
public static void set status ( task attempt context context , string status ) { invoke ( set_status_method , context , status ) ; }
public void flush and fsync blockingly ( iterable < uuid > host id ) { iterable < hint store > store = transform ( host id , catalog : : get ) ; write executor . flush buffer pool ( buffer pool , store ) ; write executor . fsync writer blockingly ( store ) ; }
public long get compression metadata off heap size ( ) { if ( ! compression ) return 0 ; return get compression metadata ( ) . off heap size ( ) ; }
public i s s table scanner get scanner ( collection < range < token > > range , rate limiter limiter ) { if ( range ! = null ) return big table scanner . get scanner ( this , range , limiter ) ; else return get scanner ( limiter ) ; }
public string get rack ( inet address endpoint ) { if ( endpoint . equal ( f b utility . get broadcast address ( ) ) ) return my rack ; endpoint state ep state = gossiper . instance . get endpoint state for endpoint ( endpoint ) ; if ( ep state == null || ep state . get application state ( application state . rack ) == null ) { if ( psnitch == null ) { if ( saved endpoint == null ) save endpoint = system keyspace . load dc rack info ( ) ; if ( saved endpoint . contains key ( endpoint ) ) return save endpoint . get ( endpoint ) . get ( `` rack `` ) ; return default_rack ; } else return psnitch . get rack ( endpoint ) ; } return ep state . get application state ( application state . rack ) . value ; }
public token metadata clone after all left ( ) { lock . read lock ( ) . lock ( ) ; try { return remove endpoint ( clone only token map ( ) , leave endpoint ) ; } finally { lock . read lock ( ) . unlock ( ) ; } }
public token metadata clone only token map ( ) { lock . read lock ( ) . lock ( ) ; try { return new token metadata ( sort bi multi val map . create ( token to endpoint map , null , inetaddress cmp ) , hash bi map . create ( endpoint to host id map ) , new topology ( topology ) , partitioner ) ; } finally { lock . read lock ( ) . unlock ( ) ; } }
public double mean rate ( ) { if ( count ( ) == 0 ) { return 0 . 0 ; } else { final long elapsed = ( clock . get tick ( ) - start time ) ; return ( count ( ) / ( double ) elapse ) * nanos_per_second ; } }
public void register verb handler ( verb verb , i verb handler verb handler ) { assert ! verb handler . contains key ( verb ) ; verb handler . put ( verb , verb handler ) ; }
public optional < c f meta data > get ( string name ) { return optional . of nullable ( table . get ( name ) ) ; }
public index without ( string name ) { index metadata index = get ( name ) . or else throw ( ( ) - > new illegal state exception ( string . format ( `` index % s do n't exist `` , name ) ) ) ; return builder ( ) . add ( filter ( this , v - > v ! = index ) ) . build ( ) ; }
public static s s l socket get socket ( encryption option option , inet address address , int port ) throw i o exception { s s l context ctx = create s s l context ( option , true ) ; s s l socket socket = ( s s l socket ) ctx . get socket factory ( ) . create socket ( address , port ) ; try { prepare socket ( socket , option ) ; return socket ; } catch ( illegal argument exception e ) { socket . close ( ) ; throw e ; } }
public stream plan connection factory ( stream connection factory factory ) { this . coordinator . set connection factory ( factory ) ; return this ; }
public synchronize void abort ( ) { if ( do ) return ; do = true ; abort transaction ( ) ; sstables . clear ( ) ; }
public synchronize int read ( byte b [ ] , int off , int len ) throw i o exception { if ( read po > = length ) { return -1 ; } int num = super . read ( b , off , len ) ; if ( num ! = -1 ) { if ( num + read pos > length ) { num = ( int ) ( length - read po ) ; } read pos += num ; } return num ; }
public socket get socket ( ) { if ( socket == null ) { init socket ( ) ; } return socket ; }
protect void wait for pending event ( ) { if ( wait_for_pending_events_timeout_secs < = 0 ) return ; try { if ( logger . be trace enable ( ) ) logger . trace ( `` wait for up to { } second for { } trace event to complete `` , +wait_for_pending_events_timeout_secs , pending future . size ( ) ) ; completable future . all of ( pending future . to array ( new completable future < ? > [ pending future . size ( ) ] ) ) . get ( wait_for_pending_events_timeout_secs , time unit . second ) ; } catch ( timeout exception ex ) { if ( logger . be trace enable ( ) ) logger . trace ( `` fail to wait for trace event to complete in { } second `` , wait_for_pending_events_timeout_secs ) ; } catch ( throwable t ) { j v m stability inspector . inspect throwable ( t ) ; logger . error ( `` get exception whilst wait for trace event to complete `` , t ) ; } }
public mutation apply counter mutation ( ) throw write timeout exception { mutation result = new mutation ( get keyspace name ( ) , key ( ) ) ; keyspace keyspace = keyspace . open ( get keyspace name ( ) ) ; list < lock > lock = new array list < > ( ) ; trace . trace ( `` acquire counter lock `` ) ; try { grab counter lock ( keyspace , lock ) ; for ( partition update upd : get partition update ( ) ) result . add ( process modification ( upd ) ) ; result . apply ( ) ; return result ; } finally { for ( lock lock : lock ) lock . unlock ( ) ; } }
public int index of ( object item ) { return find index ( tree , comparator , ( v ) item ) ; }
public void prune ( ) { prune lock . write lock ( ) . lock ( ) ; try { long now = time source . current time millis ( ) ; counter . head map ( now - size in millis , false ) . clear ( ) ; } finally { prune lock . write lock ( ) . unlock ( ) ; } }
public int global count ( ) { return state . global state . count ( ) ; }
public boolean signal ( ) { if ( ! have waiter ( ) ) return false ; while ( true ) { registered signal s = queue . poll ( ) ; if ( s == null || s . signal ( ) ! = null ) return s ! = null ; } }
public boolean equal ( object o ) { / * 11- mar-2013 , tatu : apparently class loader can manage to load * different instance , render identity comparison break . * so let 's use value instead . * / if ( o == this ) return true ; if ( o == null ) return false ; if ( ! ( o instanceof boolean node ) ) { return false ; } return ( _value == ( ( boolean node ) o ) . _value ) ; }
public static string get local host name ( ) { if ( local host name == null ) { try { local host name = inet address . get local host ( ) . get host name ( ) ; } catch ( unknown host exception e ) { local host name = `` localhost `` ; } } return local host name ; }
public void write byte ( final byte [ ] bytes , final int off , final int len ) { if ( len > remain ( ) ) { write byte slow ( byte , off , len ) ; return ; } final block block = current ; system . arraycopy ( byte , off , block . data , block . limit , len ) ; block . limit += len ; }
public void init ( ) { for ( range < token > range : merkle tree . key set ( ) ) { init ( range ) ; } }
public static long size of ( string str ) { return string_empty_size + size of array ( str . length ( ) , 2 ) ; }
public static boolean be flag set ( int flag , int flag ) { return ( flags & ( 1 < < ( max_size - 1 - flag ) ) ) ! = 0 ; }
public static rate limiter create ( double permit per second ) { / * * the default rate limiter configuration can save the unused permit of up to one second . * this be to avoid unnecessary stall in situation like this : a rate limiter of 1qps , * and 4 thread , all call acquire ( ) at these moment : * * t0 at 0 second * t1 at 1 . 05 second * t2 at 2 second * t3 at 3 second * * due to the slight delay of t1 , t2 would have to sleep till 2 . 05 second , * and t3 would also have to sleep till 3 . 05 second . * / return create ( sleep stopwatch . create from system timer ( ) , permit per second ) ; }
public string export a string ( ) { return a c q l query ( true ) ; }
public cluster init ( ) { this . manager . init ( ) ; return this ; }
public session new session ( ) { check not close ( manager ) ; return manager . new session ( ) ; }
public cluster register ( host . state listener listener ) { check not close ( manager ) ; boolean add = manager . listener . add ( listener ) ; if ( add ) listener . on register ( this ) ; return this ; }
public long get start at ( ) { maybe fetch trace ( ) ; return start at ; }
public already exist exception copy ( inet socket address address ) { return new already exist exception ( address , get message ( ) , this , keyspace , table ) ; }
public consistency level get consistency level ( ) { return consistency ; }
public host get query host ( ) { return try host . get ( tried host . size ( ) - 1 ) ; }
public listenable future < query trace > get query trace async ( ) { return future . immediate future ( trace ) ; }
public string get language ( ) { return language ; }
public inet socket address get socket address ( ) { return address ; }
public version number get dse version ( ) { return dse version ; }
public collection < materialize view metadata > get materialize view ( ) { return collection . unmodifiable collection ( view . value ( ) ) ; }
public string get signature ( ) { string builder sb = new string builder ( ) ; sb . append ( metadata . quote if necessary ( simple name ) ) . append ( ' ( ' ) ; boolean first = true ; for ( data type type : argument . value ( ) ) { if ( first ) first = false ; else sb . append ( ' , ' ) ; sb . append ( type . a function parameter string ( ) ) ; } sb . append ( ' ) ' ) ; return sb . to string ( ) ; }
public list < keyspace metadata > get keyspaces ( ) { return new array list < keyspace metadata > ( keyspaces . value ( ) ) ; }
public cluster register ( host . state listener listener ) { check not close ( manager ) ; boolean add = manager . listener . add ( listener ) ; if ( add ) listener . on register ( this ) ; return this ; }
public error get error metric ( ) { return error ; }
public static string quote ( string id ) { return parse utils . double quote ( id ) ; }
public static string un double quote ( string value ) { return unquote ( value , ' `` ' ) ; }
public static builder builder ( load balancing policy child policy ) { return new builder ( child policy ) ; }
public reconnection schedule new schedule ( ) { return new exponential schedule ( ) ; }
public retry policy get retry policy ( ) { return retry policy ; }
public int get max pending refresh schema request ( ) { return max pending refresh schema request ; }
public option use ( use use ) { return using . and ( use ) ; }
public static order asc ( string column name ) { return new order ( column name , false ) ; }
public static use ttl ( int ttl ) { if ( ttl < 0 ) throw new illegal argument exception ( `` invalid ttl , must be positive `` ) ; return new use . with value ( `` ttl `` , ttl ) ; }
public static assignment decr ( string name ) { return decr ( name , 1l ) ; }
public static assignment append all ( string name , list < ? > list ) { return new assignment . collection assignment ( name , list , true , false ) ; }
public static assignment add ( string name , object value ) { if ( value instanceof bind marker ) { throw new invalid query exception ( `` bind a value in add ( ) be not support , use add all ( ) and bind a singleton list `` ) ; } return add all ( name , collection . singleton ( value ) ) ; }
public static object cast ( object column , data type data type ) { return new utils . cast ( column , data type ) ; }
public static object cast ( object column , data type data type ) { return new utils . cast ( column , data type ) ; }
public query option set prepare on all host ( boolean prepare on all host ) { this . prepare on all host = prepare on all host ; return this ; }
public int get refresh node interval millis ( ) { return refresh node interval millis ; }
public query option set max pending refresh node request ( int max pending refresh node request ) { this . max pending refresh node request = max pending refresh node request ; return this ; }
public query option set max pending refresh node request ( int max pending refresh node request ) { this . max pending refresh node request = max pending refresh node request ; return this ; }
public t add u d t list column ( string column name , u d t type udt type ) { validate not empty ( column name , `` column name `` ) ; validate not null ( udt type , `` column element type `` ) ; validate not key word ( column name , string . format ( `` the column name ' % s ' be not allow because it be a reserved keyword `` , column name ) ) ; simple column . put ( column name , u d t type . list ( udt type ) ) ; return self ; }
public create add cluster column ( string column name , data type data type ) { validate not empty ( column name , `` cluster column name `` ) ; validate not null ( data type , `` cluster column type `` ) ; validate not key word ( column name , string . format ( `` the clustering column name ' % s ' be not allow because it be a reserved keyword `` , column name ) ) ; cluster column . put ( column name , new native column type ( data type ) ) ; return this ; }
public create index on on table ( string table name ) { validate not empty ( table name , `` table name `` ) ; validate not key word ( table name , string . format ( `` the table name ' % s ' be not allow because it be a reserved keyword `` , table name ) ) ; this . table name = table name ; return new create index on ( ) ; }
public string build ( ) { return this . build internal ( ) ; }
public static drop drop index ( string index name ) { return new drop ( index name , drop item . index ) ; }
public static drop drop type ( string type name ) { return new drop ( type name , drop item . type ) ; }
public static drop drop type ( string type name ) { return new drop ( type name , drop item . type ) ; }
public t populate i o cache on flush ( boolean populate i o on cache flush ) { this . populate i o on cache flush = optional . from nullable ( populate i o on cache flush ) ; return self ; }
public t read repair chance ( double read repair chance ) { validate rate value ( read repair chance , `` read repair chance `` ) ; this . read repair chance = optional . from nullable ( read repair chance ) ; return self ; }
public t compaction option ( compaction option compaction option ) { this . compaction option = optional . from nullable ( compaction option ) ; return self ; }
public t read repair chance ( double read repair chance ) { validate rate value ( read repair chance , `` read repair chance `` ) ; this . read repair chance = optional . from nullable ( read repair chance ) ; return self ; }
public set < string > get value name ( ) { if ( name value == null ) throw new illegal state exception ( `` this statement do not have name value `` ) ; return collection . unmodifiable set ( name value . key set ( ) ) ; }
public socket option set reuse address ( boolean reuse address ) { this . reuse address = reuse address ; return this ; }
public statement set consistency level ( consistency level consistency ) { this . consistency = consistency ; return this ; }
public token get end ( ) { return end ; }
public static type codec < tuple value > tuple ( tuple type type ) { return new tuple codec ( type ) ; }
public user type get user type ( string name ) { return user type . get ( metadata . handle id ( name ) ) ; }
public version number next stable ( ) { return new version number ( major , minor , patch , dse patch , null , null ) ; }
public version number next stable ( ) { return new version number ( major , minor , patch , dse patch , null , null ) ; }
public string get value name ( ) { return value name ; }
public string get type signature str ( ) { return type signature str ; }
public string get type signature str ( ) { return type signature str ; }
public class graph disable module scan ( ) { scan spec . scan module = false ; return this ; }
public class graph enable annotation info ( ) { enable class info ( ) ; scan spec . enable annotation info = true ; return this ; }
public class graph override module layer ( final object . . . override module layer ) { scan spec . override module layer ( override module layer ) ; return this ; }
public class graph whitelist jar ( final string . . . jar leaf name ) { for ( final string jar leaf name : jar leaf name ) { final string leaf name = jar utils . leaf name ( jar leaf name ) ; if ( ! leaf name . equal ( jar leaf name ) ) { throw new illegal argument exception ( `` can only whitelist jar by leafname : `` + jar leaf name ) ; } scan spec . jar white black list . add to whitelist ( leaf name ) ; } return this ; }
public boolean be public ( ) { return ( modifier & modifier . public ) ! = 0 ; }
public boolean be interface ( ) { return be interface or annotation ( ) & & ! be annotation ( ) ; }
public class info list get out class ( ) { return new class info list ( this . filter class info ( rel type . contained_within_outer_class , / * strict whitelist = * / false ) , / * sort by name = * / false ) ; }
public method info list get declare method info ( ) { return get declare method info ( / * method name = * / null , / * get normal method = * / true , / * get constructor method = * / false , / * get static initializer method = * / false ) ; }
public class info list get class with field annotation ( final string field annotation name ) { if ( close . get ( ) ) { throw new illegal argument exception ( `` can not use a scan result after it have be close `` ) ; } if ( ! scan spec . enable class info || ! scan spec . enable field info || ! scan spec . enable annotation info ) { throw new illegal argument exception ( `` please call class graph # enable class info ( ) , # enable field info ( ) , `` + `` and # enable annotation info ( ) before # scan ( ) `` ) ; } final class info class info = class name to class info . get ( field annotation name ) ; return class info == null ? class info list . empty_list : class info . get class with field annotation ( ) ; }
public int compare to ( final field info other ) { final int diff = declare class name . compare to ( other . declare class name ) ; if ( diff ! = 0 ) { return diff ; } return name . compare to ( other . name ) ; }
public boolean equal ( object obj ) { return ( ( obj ! = null ) & & obj . get class ( ) . equal ( default protocol socket factory . class ) ) ; }
public list < type parameter > get type parameter ( ) { return type parameter ; }
public boolean be public ( ) { return modifier . be public ( modifier ) ; }
public annotation info get annotation info ( final string annotation name ) { return get annotation info ( ) . get ( annotation name ) ; }
public boolean have annotation ( final string annotation name ) { return get annotation info ( ) . contains name ( annotation name ) ; }
public boolean be final ( ) { return modifier . be final ( modifier ) ; }
public class graph override module layer ( final object . . . override module layer ) { scan spec . override module layer ( override module layer ) ; return this ; }
public resource list get resource match pattern ( final pattern pattern ) { if ( close . get ( ) ) { throw new illegal argument exception ( `` can not use a scan result after it have be close `` ) ; } final resource list all whitelisted resource = get all resource ( ) ; if ( all whitelisted resource . be empty ( ) ) { return resource list . empty_list ; } else { final resource list filter resource = new resource list ( ) ; for ( final resource classpath resource : all whitelisted resource ) { final string relative path = classpath resource . get path ( ) ; if ( pattern . matcher ( relative path ) . match ( ) ) { filtered resource . add ( classpath resource ) ; } } return filtered resource ; } }
public resource list get resource with leaf name ( final string leaf name ) { if ( close . get ( ) ) { throw new illegal argument exception ( `` can not use a scan result after it have be close `` ) ; } final resource list all whitelisted resource = get all resource ( ) ; if ( all whitelisted resource . be empty ( ) ) { return resource list . empty_list ; } else { final resource list filter resource = new resource list ( ) ; for ( final resource classpath resource : all whitelisted resource ) { final string relative path = classpath resource . get path ( ) ; final int last slash idx = relative path . last index of ( '/ ' ) ; if ( relative path . substring ( last slash idx + 1 ) . equal ( leaf name ) ) { filtered resource . add ( classpath resource ) ; } } return filtered resource ; } }
public class info list get annotation on class ( final string class name ) { if ( close . get ( ) ) { throw new illegal argument exception ( `` can not use a scan result after it have be close `` ) ; } if ( ! scan spec . enable class info || ! scan spec . enable annotation info ) { throw new illegal argument exception ( `` please call class graph # enable class info ( ) and # enable annotation info ( ) before # scan ( ) `` ) ; } final class info class info = class name to class info . get ( class name ) ; return class info == null ? class info list . empty_list : class info . get annotation ( ) ; }
public list < type argument > get type argument ( ) { return type argument ; }
public void clear ( ) { map . clear ( ) ; }
public string get position info ( ) { final int show start = math . max ( 0 , position - show_before ) ; final int show end = math . min ( string . length ( ) , position + show_after ) ; return `` before : \ `` `` + j s o n utils . escape j s o n string ( string . substring ( show start , position ) ) + `` \ `` ; after : \ `` `` + j s o n utils . escape j s o n string ( string . substring ( position , show end ) ) + `` \ `` ; position : `` + position + `` ; token : \ `` `` + token + `` \ `` `` ; }
public class graph whitelist module ( final string . . . module names ) { for ( final string module name : module name ) { scan spec . module white black list . add to whitelist ( white black list . normalize package or class name ( module name ) ) ; } return this ; }
public static string convert slash name ( string name ) { return name . replace ( '\\ ' , ' . ' ) . replace ( '/ ' , ' . ' ) ; }
public boolean whitelist be empty ( ) { return whitelist == null & & whitelist prefix == null & & whitelist glob == null ; }
public boolean be specifically whitelisted ( final string str ) { return ! whitelist be empty ( ) & & be whitelisted ( str ) ; }
protect boolean be assignable ( class dest , class source ) { if ( d . be assignable from ( source ) || ( ( d == boolean . type ) & & ( source == boolean . class ) ) || ( ( d == byte . type ) & & ( source == byte . class ) ) || ( ( d == character . type ) & & ( source == character . class ) ) || ( ( d == double . type ) & & ( source == double . class ) ) || ( ( d == float . type ) & & ( source == float . class ) ) || ( ( d == integer . type ) & & ( source == integer . class ) ) || ( ( d == long . type ) & & ( source == long . class ) ) || ( ( d == short . type ) & & ( source == short . class ) ) ) { return ( true ) ; } else { return ( false ) ; } }
public iterator < option > iterator ( ) { return option . iterator ( ) ; }
public static option builder have optional args ( ) { option builder . number of args = option . unlimited_values ; option builder . optional arg = true ; return instance ; }
public option add option ( string opt , boolean have arg , string description ) { add option ( opt , null , have arg , description ) ; return this ; }
public object create executable extension ( registry contributor contributor , string class name , string overriden contributor name ) throw core exception { object result = null ; class < ? > class instance = null ; try { class instance = class . for name ( class name ) ; } catch ( class not find exception e1 ) { string message = nls . bind ( registry message . ex ext_find class error , contributor . get actual name ( ) , class name ) ; throw new core exception ( new status ( i status . error , registry message . owner_name , i registry constant . plugin_error , message , e1 ) ) ; } try { result = class instance . get declared constructor ( ) . new instance ( ) ; } catch ( exception e ) { string message = nls . bind ( registry message . ex ext_instantiate class error , contributor . get actual name ( ) , class name ) ; throw new core exception ( new status ( i status . error , registry message . owner_name , i registry constant . plugin_error , message , e ) ) ; } return result ; }
public static sort bag decorate ( sort bag bag , class type ) { return new predicate sorted bag ( bag , instanceof predicate . get instance ( type ) ) ; }
public map iterator map iterator ( ) { if ( be empty ( ) ) { return empty order map iterator . instance ; } return new view map iterator ( this , key ) ; }
public int size ( ) { int size = 0 ; if ( m_end < m_start ) { size = max element - m_start + m_end ; } else if ( m_end == m_start ) { size = ( m_full ? max element : 0 ) ; } else { size = m_end - m_start ; } return size ; }
public object remove ( ) { if ( be empty ( ) ) { throw new buffer underflow exception ( `` the buffer be already empty `` ) ; } object element = m_elements [ m_start ] ; if ( null ! = element ) { m_elements [ m_start++ ] = null ; if ( m_start > = max element ) { m_start = 0 ; } m_full = false ; } return element ; }
public object remove ( ) { synchronize ( lock ) { while ( collection . be empty ( ) ) { try { if ( timeout < = 0 ) { lock . wait ( ) ; } else { return remove ( timeout ) ; } } catch ( interrupted exception e ) { print writer out = new print writer ( new string writer ( ) ) ; e . print stack trace ( out ) ; throw new buffer underflow exception ( `` cause by interrupted exception : `` + out . to string ( ) ) ; } } return get buffer ( ) . remove ( ) ; } }
protect int compare ( object a , object b ) { if ( comparator ! = null ) { return comparator . compare ( a , b ) ; } else { return ( ( comparable ) a ) . compare to ( b ) ; } }
public static transformer chain transformer ( transformer transformer1 , transformer transformer2 ) { return chain transformer . get instance ( transformer1 , transformer2 ) ; }
public static transformer switch map transformer ( map object and transformer ) { transformer [ ] trs = null ; predicate [ ] preds = null ; if ( object and transformer == null ) { throw new illegal argument exception ( `` the object and transformer map must not be null `` ) ; } transformer def = ( transformer ) object and transformer . remove ( null ) ; int size = object and transformer . size ( ) ; trs = new transformer [ size ] ; preds = new predicate [ size ] ; int i = 0 ; for ( iterator it = object and transformer . entry set ( ) . iterator ( ) ; it . have next ( ) ; ) { map . entry entry = ( map . entry ) it . next ( ) ; preds [ i ] = equal predicate . get instance ( entry . get key ( ) ) ; trs [ i ] = ( transformer ) entry . get value ( ) ; i++ ; } return switch transformer ( preds , trs , def ) ; }
public static void apply ( collection coll , function func ) { for ( iterator i = coll . iterator ( ) ; i . have next ( ) ; ) { func . execute ( i . next ( ) ) ; } }
public static void select reject ( collection input collection , predicate predicate , collection output collection ) { if ( input collection ! = null & & predicate ! = null ) { for ( iterator iter = input collection . iterator ( ) ; iter . have next ( ) ; ) { object item = iter . next ( ) ; if ( predicate . evaluate ( item ) == false ) { output collection . add ( item ) ; } } } }
public boolean add first ( object o ) { insert listable ( null , _head . next ( ) , o ) ; return true ; }
public object remove last ( ) { if ( _head . prev ( ) ! = null ) { object val = _head . prev ( ) . value ( ) ; remove listable ( _head . prev ( ) ) ; return val ; } else { throw new no such element exception ( ) ; } }
protect map get map ( ) { return _map ; }
public boolean contains ( object element ) { if ( fast ) { return ( list . contains ( element ) ) ; } else { synchronize ( list ) { return ( list . contains ( element ) ) ; } } }
public boolean contains ( object element ) { if ( fast ) { return ( list . contains ( element ) ) ; } else { synchronize ( list ) { return ( list . contains ( element ) ) ; } } }
public boolean remove all ( collection collection ) { if ( fast ) { synchronize ( this ) { array list temp = ( array list ) list . clone ( ) ; boolean result = temp . remove all ( collection ) ; list = temp ; return ( result ) ; } } else { synchronize ( list ) { return ( list . remove all ( collection ) ) ; } } }
public object get ( int index ) { if ( fast ) { return ( list . get ( index ) ) ; } else { synchronize ( list ) { return ( list . get ( index ) ) ; } } }
public predicate [ ] get predicate ( ) { return new predicate [ ] { i predicate } ; }
public transformer [ ] get transformer ( ) { return i transformer ; }
public e next ( ) throw no such element exception { if ( iterator instanceof list iterator ) { return iterator . next ( ) ; } if ( current index < wrap iterator index ) { ++current index ; return list . get ( current index - 1 ) ; } final e retval = iterator . next ( ) ; list . add ( retval ) ; ++current index ; ++wrapped iterator index ; remove state = true ; return retval ; }
public static order map iterator empty order map iterator ( ) { return empty_ordered_map_iterator ; }
public static list transform list ( list list , transformer transformer ) { return transform list . decorate ( list , transformer ) ; }
protect void add mapping ( final int hash index , final int hash code , final k key , final v value ) { mod count++ ; final hash entry < k , v > entry = create entry ( data [ hash index ] , hash code , key , value ) ; add entry ( entry , hash index ) ; size++ ; check capacity ( ) ; }
protect void add mapping ( final int hash index , final int hash code , final k key , final v value ) { mod count++ ; final hash entry < k , v > entry = create entry ( data [ hash index ] , hash code , key , value ) ; add entry ( entry , hash index ) ; size++ ; check capacity ( ) ; }
public k first key ( ) { if ( size == 0 ) { throw new no such element exception ( `` map be empty `` ) ; } return header . after . get key ( ) ; }
public k last key ( ) { if ( size == 0 ) { throw new no such element exception ( `` map be empty `` ) ; } return header . before . get key ( ) ; }
protect hash entry create entry ( hash entry next , int hash code , object key , object value ) { return new reference entry ( this , next , hash code , key , value ) ; }
public element after ( string html ) { return ( element ) super . after ( html ) ; }
public void set mutator ( final collection mutator < e > mutator ) { this . mutator = mutator ; }
public v put ( final k key , final v value ) { if ( this . mutator == null ) { throw new unsupported operation exception ( `` no mutator specify `` ) ; } return this . mutator . put ( this , this . composite , key , value ) ; }
public k next key ( final k key ) { check key ( key ) ; final node < k , v > node = next great ( lookup key ( key ) , key ) ; return node == null ? null : node . get key ( ) ; }
public object get value ( e l context context , object base , object property ) { if ( context == null ) { throw new null pointer exception ( ) ; } if ( base ! = null & & base instanceof map ) { context . set property resolve ( base , property ) ; map < ? , ? > map = ( map < ? , ? > ) base ; return map . get ( property ) ; } return null ; }
public static short get short value ( final map map , final object key , short default value ) { short short object = get short ( map , key ) ; if ( short object == null ) { return default value ; } return short object . short value ( ) ; }
public static double get double value ( final map map , final object key , double default value ) { double double object = get double ( map , key ) ; if ( double object == null ) { return default value ; } return double object . double value ( ) ; }
public static boolean be not empty ( final collection < ? > coll ) { return ! be empty ( coll ) ; }
public static sort map predicate sort map ( sort map map , predicate key pred , predicate value pred ) { return predicate sort map . decorate ( map , key pred , value pred ) ; }
public static map multi value map ( map map ) { return multi value map . decorate ( map ) ; }
public static map multi value map ( map map ) { return multi value map . decorate ( map ) ; }
public boolean be empty ( ) { purge ( ) ; return size == 0 ; }
public static sort set decorate ( sorted set set , class type ) { return new predicate sort set ( set , instanceof predicate . get instance ( type ) ) ; }
public synchronize void clear ( ) { m_priority queue . clear ( ) ; }
public synchronize object pop ( ) throw no such element exception { return m_priority queue . pop ( ) ; }
public static transformer exception transformer ( ) { return exception transformer . instance ; }
public cpio archive entry get next c p i o entry ( ) throw i o exception { ensure open ( ) ; if ( this . entry ! = null ) { close entry ( ) ; } byte magic [ ] = new byte [ 2 ] ; read fully ( magic , 0 , magic . length ) ; if ( cpio util . byte array2long ( magic , false ) == magic_old_binary ) { this . entry = read old binary entry ( false ) ; } else if ( cpio util . byte array2long ( magic , true ) == magic_old_binary ) { this . entry = read old binary entry ( true ) ; } else { byte more_magic [ ] = new byte [ 4 ] ; read fully ( more_magic , 0 , more_magic . length ) ; byte tmp [ ] = new byte [ 6 ] ; system . arraycopy ( magic , 0 , tmp , 0 , magic . length ) ; system . arraycopy ( more_magic , 0 , tmp , magic . length , more_magic . length ) ; string magic string = archive utils . to ascii string ( tmp ) ; if ( magic string . equal ( magic_new ) ) { this . entry = read new entry ( false ) ; } else if ( magic string . equal ( magic_new_crc ) ) { this . entry = read new entry ( true ) ; } else if ( magic string . equal ( magic_old_ascii ) ) { this . entry = read old ascii entry ( ) ; } else { throw new i o exception ( `` unknown magic [ `` + magic string + `` ] . occur at byte : `` + get byte read ( ) ) ; } } this . entry bytes read = 0 ; this . entry e o f = false ; this . crc = 0 ; if ( this . entry . get name ( ) . equal ( cpio_trailer ) ) { this . entry e o f = true ; return null ; } return this . entry ; }
public void put archive entry ( final archive entry archive entry ) throw i o exception { if ( finish ) { throw new i o exception ( `` stream have already be finish `` ) ; } final tar archive entry entry = ( tar archive entry ) archive entry ; if ( entry . be global pax header ( ) ) { final byte [ ] data = encode extend pax header content ( entry . get extra pax header ( ) ) ; entry . set size ( data . length ) ; entry . write entry header ( record buf , zip encoding , big number mode == bignumber_star ) ; write record ( record buf ) ; curr size= entry . get size ( ) ; curr bytes = 0 ; this . have unclosed entry = true ; write ( data ) ; close archive entry ( ) ; } else { final map < string , string > pax header = new hash map < > ( ) ; final string entry name = entry . get name ( ) ; final boolean pax header contain path = handle long name ( entry , entry name , pax header , `` path `` , tar constant . lf_gnutype_longname , `` file name `` ) ; final string link name = entry . get link name ( ) ; final boolean pax header contain link path = link name ! = null & & link name . length ( ) > 0 & & handle long name ( entry , link name , pax header , `` linkpath `` , tar constant . lf_gnutype_longlink , `` link name `` ) ; if ( big number mode == bignumber_posix ) { add pax header for big number ( pax header , entry ) ; } else if ( big number mode ! = bignumber_star ) { fail for big number ( entry ) ; } if ( add pax header for non ascii name & & ! pax header contain path & & ! ascii . can encode ( entry name ) ) { pax header . put ( `` path `` , entry name ) ; } if ( add pax header for non ascii name & & ! pax header contain link path & & ( entry . be link ( ) || entry . be symbolic link ( ) ) & & ! ascii . can encode ( link name ) ) { pax header . put ( `` linkpath `` , link name ) ; } pax header . put all ( entry . get extra pax header ( ) ) ; if ( pax header . size ( ) > 0 ) { write pax header ( entry , entry name , pax header ) ; } entry . write entry header ( record buf , zip encoding , big number mode == bignumber_star ) ; write record ( record buf ) ; curr bytes = 0 ; if ( entry . be directory ( ) ) { curr size = 0 ; } else { curr size = entry . get size ( ) ; } curr name = entry name ; have unclosed entry = true ; } }
public char get list delimiter ( ) { return list delimiter ; }
public void set delimiter parse disabled ( boolean delimiter parse disable ) { ( ( base configuration ) get in memory configuration ( ) ) . set delimiter parse disabled ( delimiter parse disabled ) ; super . set delimiter parse disabled ( delimiter parse disabled ) ; }
public void set throw exception on miss ( boolean throw exception on miss ) { this . throw exception on miss = throw exception on miss ; }
public synchronize str substitutor get substitutor ( ) { if ( substitutor == null ) { substitutor = new str substitutor ( create interpolator ( ) ) ; } return substitutor ; }
public void clear property ( string key ) { fire event ( event_clear_property , key , null , true ) ; clear property direct ( key ) ; fire event ( event_clear_property , key , null , false ) ; }
public file get file ( ) { if ( get file name ( ) == null & & source u r l == null ) { return null ; } else if ( source u r l ! = null ) { return configuration utils . file from u r l ( source u r l ) ; } else { return configuration utils . get file ( get base path ( ) , get file name ( ) ) ; } }
public void reload ( ) { reload ( false ) ; }
public void set file system ( file system file system ) { delegate . set file system ( file system ) ; }
public boolean contains key ( string key ) { return store . contains key ( key ) ; }
public void set file ( file file ) { source u r l = null ; set file name ( file . get name ( ) ) ; set base path ( ( file . get parent file ( ) ! = null ) ? file . get parent file ( ) . get absolute path ( ) : null ) ; }
public configuration key append index ( int index ) { key buffer . append ( index_start ) . append ( index ) ; key buffer . append ( index_end ) ; return this ; }
protect string replace ( string str ) { string result = str ; int pos_start = str . index of ( `` $ { `` ) ; if ( pos_start > = 0 ) { string builder builder = new string builder ( ) ; int pos_end = -1 ; while ( pos_start > = 0 ) { builder . append ( str , pos_end + 1 , pos_start ) ; pos_end = str . index of ( ' } ' , pos_start + 2 ) ; if ( pos_end < 0 ) { pos_end = pos_start - 1 ; break ; } string prop name = str . substring ( pos_start + 2 , pos_end ) ; string replacement = replace web application property ( prop name ) ; if ( replacement == null ) { replacement = prop name . length ( ) > 0 ? system . get property ( prop name ) : null ; } if ( replacement ! = null ) { builder . append ( replacement ) ; } else { builder . append ( str , pos_start , pos_end + 1 ) ; } pos_start = str . index of ( `` $ { `` , pos_end + 1 ) ; } builder . append ( str , pos_end + 1 , str . length ( ) ) ; result = builder . to string ( ) ; } return result ; } private string replace web application property ( string prop name ) { class loader cl = thread . current thread ( ) . get context class loader ( ) ; if ( cl instanceof webapp property ) { webapp property w prop = ( webapp property ) cl ; if ( `` classloader . webapp name `` . equal ( prop name ) ) { return w prop . get webapp name ( ) ; } else if ( `` classloader . host name `` . equal ( prop name ) ) { return w prop . get host name ( ) ; } else if ( `` classloader . service name `` . equal ( prop name ) ) { return w prop . get service name ( ) ; } else { return null ; } } else { return null ; } } // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- log node inner class protect static final class log node { logger logger ; final map < string , log node > child = new hash map < > ( ) ; final log node parent ; log node ( final log node parent , final logger logger ) { this . parent = parent ; this . logger = logger ; } log node ( final log node parent ) { this ( parent , null ) ; } log node find node ( string name ) { log node current node = this ; if ( logger . get name ( ) . equal ( name ) ) { return this ; } while ( name ! = null ) { final int dot index = name . index of ( ' . ' ) ; final string next name ; if ( dot index < 0 ) { next name = name ; name = null ; } else { next name = name . substring ( 0 , dot index ) ; name = name . substring ( dot index + 1 ) ; } log node child node = current node . child . get ( next name ) ; if ( child node == null ) { child node = new log node ( current node ) ; current node . child . put ( next name , child node ) ; } current node = child node ; } return current node ; } logger find parent logger ( ) { logger logger = null ; log node node = parent ; while ( node ! = null & & logger == null ) { logger = node . logger ; node = node . parent ; } return logger ; } void set parent logger ( final logger parent ) { for ( final log node child node : child . value ( ) ) { if ( child node . logger == null ) { child node . set parent logger ( parent ) ; } else { do set parent logger ( child node . logger , parent ) ; } } } } // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- class loader info inner class protect static final class class loader log info { final log node root node ; final map < string , logger > logger = new concurrent hash map < > ( ) ; final map < string , handler > handler = new hash map < > ( ) ; final property prop = new property ( ) ; class loader log info ( final log node root node ) { this . root node = root node ; } } // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - root logger inner class / * * * this class be need to instantiate the root of each per classloader * hierarchy . * / protect static class root logger extend logger { public root logger ( ) { super ( `` `` , null ) ; } } }
protect void fire element end ( string name ) { if ( get exception ( ) == null ) { try { get content handler ( ) . end element ( ns_uri , name , name ) ; } catch ( s a x exception ex ) { exception = ex ; } } }
public list < calendar > get calendar list ( string key ) { return get calendar list ( key , new array list < calendar > ( ) ) ; }
public int [ ] get int array ( string key ) { return get int array ( key , new int [ 0 ] ) ; }
public list < color > get color list ( string key ) { return get color list ( key , new array list < color > ( ) ) ; }
public list < big decimal > get big decimal list ( string key ) { return get big decimal list ( key , new array list < big decimal > ( ) ) ; }
public locale [ ] get locale array ( string key ) { return get locale array ( key , new locale [ 0 ] ) ; }
public color [ ] get color array ( string key ) { return get color array ( key , new color [ 0 ] ) ; }
public configuration provider remove configuration provider ( string tag name ) { return provider . remove ( tag name ) ; }
protect void register configure provider ( ) throw configuration exception { list < hierarchical configuration > nod = configuration at ( key_configuration_providers ) ; for ( hierarchical configuration config : node ) { x m l bean declaration decl = new x m l bean declaration ( config ) ; string key = config . get string ( key_provider_key ) ; add configuration provider ( key , ( configuration provider ) bean helper . create bean ( decl ) ) ; } }
public string get property name ( ) { return property name ; }
public collection < event handler > get event handler ( ) { final list < event handler > list = new array list < event handler > ( ) ; for ( event state state : state ) { list . add ( state . get event handler ( ) ) ; } return collection . unmodifiable collection ( list ) ; }
protect void fire error ( int type , string prop name , object prop value , throwable ex ) { iterator < configuration error listener > it = error listener . iterator ( ) ; if ( it . have next ( ) ) { configuration error event event = create error event ( type , prop name , prop value , ex ) ; while ( it . have next ( ) ) { it . next ( ) . configuration error ( event ) ; } } }
public collection < event handler > get event handler ( ) { final list < event handler > list = new array list < event handler > ( ) ; for ( event state state : state ) { list . add ( state . get event handler ( ) ) ; } return collection . unmodifiable collection ( list ) ; }
public static boolean be symlink ( file file ) throw i o exception { if ( file == null ) { throw new null pointer exception ( `` file must not be null `` ) ; } if ( filename utils . be system window ( ) ) { return false ; } file file in canonical dir = null ; if ( file . get parent ( ) == null ) { file in canonical dir = file ; } else { file canonical dir = file . get parent file ( ) . get canonical file ( ) ; file in canonical dir = new file ( canonical dir , file . get name ( ) ) ; } if ( file in canonical dir . get canonical file ( ) . equal ( file in canonical dir . get absolute file ( ) ) ) { return false ; } else { return true ; } }
protect object resolve container store ( string key ) { if ( ( ( boolean ) recursive . get ( ) ) . boolean value ( ) ) { return null ; } recursive . set ( boolean . true ) ; try { return super . resolve container store ( key ) ; } finally { recursive . set ( boolean . false ) ; } }
protected list fetch node list ( string key ) { reload ( ) ; return super . fetch node list ( key ) ; }
public configuration node get root node ( ) { return ( root node ! = null ) ? root node : root ; }
public hierarchical configuration get configuration ( ) { return configuration ; }
public static boolean be checksum file ( path file ) { string name = file . get name ( ) ; return name . start with ( `` . `` ) & & name . end with ( `` . crc `` ) ; }
protect str lookup fetch no prefix lookup ( ) { return ( get default lookup ( ) ! = null ) ? get default lookup ( ) : str lookup . none lookup ( ) ; }
public void set parent interpolator ( configuration interpolator parent interpolator ) { this . parent interpolator = parent interpolator ; }
public context get context ( ) { return context ; }
public void set refresh delay ( long refresh delay ) { this . refresh delay = refresh delay ; }
public static synchronize void set default expression engine ( expression engine engine ) { if ( engine == null ) { throw new illegal argument exception ( `` default expression engine must not be null ! `` ) ; } default expression engine = engine ; }
public string trim leave ( string key ) { if ( key == null ) { return string utils . empty ; } else { string result = key ; while ( have lead delimiter ( result ) ) { result = result . substring ( get expression engine ( ) . get property delimiter ( ) . length ( ) ) ; } return result ; } }
public void add child ( configuration node child ) { child . add node ( child ) ; child . set attribute ( false ) ; child . set parent node ( this ) ; }
public int get attribute count ( ) { return attribute . get sub node ( ) . size ( ) ; }
public int get child count ( ) { return child . get sub node ( ) . size ( ) ; }
public void remove attribute ( ) { attribute . clear ( ) ; }
public int get attribute count ( ) { return attribute . get sub node ( ) . size ( ) ; }
public string get attribute end ( ) { return attribute end ; }
public boolean be attribute ( ) { return attribute ; }
public void set parent ( configuration node parent ) { this . parent = parent ; }
public list < string > get path node ( ) { if ( path node ! = null ) { return collection . unmodifiable list ( path node ) ; } else { return collection . empty list ( ) ; } }
public void clear tree ( string key ) { fire event ( event_clear_tree , key , null , true ) ; list < configuration node > nod = fetch node list ( key ) ; for ( configuration node node : node ) { remove node ( node ) ; } fire event ( event_clear_tree , key , node , false ) ; }
public void init property ( document document , boolean elem ref ) { if ( document . get doctype ( ) ! = null ) { set public i d ( document . get doctype ( ) . get public id ( ) ) ; set system i d ( document . get doctype ( ) . get system id ( ) ) ; } construct hierarchy ( get root ( ) , document . get document element ( ) , elem ref , true ) ; get root node ( ) . set name ( document . get document element ( ) . get node name ( ) ) ; if ( elem ref ) { get root ( ) . set reference ( document . get document element ( ) ) ; } }
public void set validating ( boolean validating ) { if ( ! schema validation ) { this . validate = validating ; } }
public document builder get document builder ( ) { return document builder ; }
protect transformer create transformer ( ) throw transformer exception { transformer transformer = transformer factory . new instance ( ) . new transformer ( ) ; transformer . set output property ( output key . indent , `` yes `` ) ; if ( get encode ( ) ! = null ) { transformer . set output property ( output key . encoding , get encode ( ) ) ; } if ( get public i d ( ) ! = null ) { transformer . set output property ( output key . doctype_public , get public i d ( ) ) ; } if ( get system i d ( ) ! = null ) { transformer . set output property ( output key . doctype_system , get system i d ( ) ) ; } return transformer ; }
public map get bean property ( ) { map prop = new hash map ( ) ; for ( iterator it = get node ( ) . get attribute ( ) . iterator ( ) ; it . have next ( ) ; ) { configuration node attr = ( configuration node ) it . next ( ) ; if ( ! be reserve node ( attr ) ) { prop . put ( attr . get name ( ) , interpolate ( attr . get value ( ) ) ) ; } } return prop ; }
public boolean be attribute key ( ) { return be attribute key ( key buffer . to string ( ) ) ; }
public configuration key append index ( int index ) { key buffer . append ( index_start ) . append ( index ) ; key buffer . append ( index_end ) ; return this ; }
public object put ( object key , object value ) { string str key = string . value of ( key ) ; object old = configuration . get property ( str key ) ; configuration . set property ( str key , value ) ; return old ; }
public object put ( object key , object value ) { string str key = string . value of ( key ) ; object old = configuration . get property ( str key ) ; configuration . set property ( str key , value ) ; return old ; }
public void clear tree ( string key ) { fire event ( event_clear_tree , key , null , true ) ; list < configuration node > nod = fetch node list ( key ) ; for ( configuration node node : node ) { remove node ( node ) ; } fire event ( event_clear_tree , key , node , false ) ; }
protect boolean node define ( configuration node node ) { defined visitor visitor = new define visitor ( ) ; node . visit ( visitor ) ; return visitor . be define ( ) ; }
protect void process key ( ) { get configuration ( ) . get root ( ) . visit ( new s a x visitor ( ) , null ) ; }
public void clear property ( string key ) { throw new unsupported operation exception ( `` read only configuration `` ) ; }
public void println ( final appendable out ) throw i o exception { if ( get trail delimiter ( ) ) { out . append ( get delimiter ( ) ) ; } if ( record separator ! = null ) { out . append ( record separator ) ; } }
public boolean be escape character set ( ) { return escape character ! = null ; }
public boolean be escape character set ( ) { return escape character ! = null ; }
public string to string ( ) { return get author ( ) + `` \n `` + get date ( ) + `` \n `` + get file ( ) + `` \n `` + get comment ( ) ; }
public string to string ( ) { return new string buffer ( ) . append ( `` [ attribute : `` ) . append ( get qualify name ( ) ) . append ( `` =\ `` `` ) . append ( value ) . append ( `` \ `` `` ) . append ( `` ] `` ) . to string ( ) ; }
public synchronize void set lifo ( final boolean lifo ) { this . lifo = lifo ; if ( connection pool ! = null ) { connection pool . set lifo ( lifo ) ; } }
public boolean get default auto commit ( ) { return default auto commit ; }
public void set cache state ( final boolean cache state ) { this . cache state = cache state ; }
public string get validation query ( ) { return this . validation query ; }
public synchronize void set max idle ( final int max idle ) { this . max idle = max idle ; if ( connection pool ! = null ) { connection pool . set max idle ( max idle ) ; } }
public synchronize void set max wait millis ( final long max wait millis ) { this . max wait millis = max wait millis ; if ( connection pool ! = null ) { connection pool . set max wait millis ( max wait millis ) ; } }
public synchronize void set min idle ( final int min idle ) { this . min idle = min idle ; if ( connection pool ! = null ) { connection pool . set min idle ( min idle ) ; } }
public boolean get log abandon ( ) { return abandon config == null ? false : abandon config . get log abandon ( ) ; }
public void set default auto commit ( final boolean default auto commit ) { this . default auto commit = default auto commit ; }
protect void start pool maintenance ( ) { if ( connection pool ! = null & & time between eviction run millis > 0 ) { connection pool . set time between eviction run millis ( time between eviction run millis ) ; } }
public synchronize void set max idle ( final int max idle ) { this . max idle = max idle ; if ( connection pool ! = null ) { connection pool . set max idle ( max idle ) ; } }
public synchronize void set min idle ( final int min idle ) { this . min idle = min idle ; if ( connection pool ! = null ) { connection pool . set min idle ( min idle ) ; } }
public connection get delegate ( ) { if ( be access to underlie connection allow ( ) ) { return get delegate internal ( ) ; } return null ; }
public connection get delegate ( ) { if ( be access to underlie connection allow ( ) ) { return get delegate internal ( ) ; } return null ; }
public void set password ( final char [ ] user password ) { assert initialization allow ( ) ; this . user password = utils . clone ( user password ) ; update ( connection property , key_password , utils . to string ( this . user password ) ) ; }
public void set user ( final string v ) { assert initialization allow ( ) ; this . user name = v ; update ( connection property , key_user , v ) ; }
public int get num idle ( ) { return get num idle ( null ) ; }
public connection get connection ( ) { debug code call ( `` get connection `` ) ; return conn ; }
public void close ( ) throw s q l exception { if ( ! close ) { close internal ( ) ; } }
public string [ ] get column name ( ) { return column name ; }
public static < t extend char sequence > t not empty ( t char , string message , object . . . value ) { if ( char == null ) { throw new null pointer exception ( string . format ( message , value ) ) ; } if ( char . length ( ) == 0 ) { throw new illegal argument exception ( string . format ( message , value ) ) ; } return char ; }
public void set uri charset ( string charset ) { set parameter ( http_uri_charset , charset ) ; }
public int read ( ) throw i o exception { final int ch = super . read ( ) ; if ( ch ! = eof ) { branch . write ( ch ) ; } return ch ; }
public void write ( final string str , final int off , final int len ) throw i o exception { out . write ( str , off , len ) ; }
public synchronize void write ( final byte [ ] b ) throw i o exception { super . write ( b ) ; this . branch . write ( b ) ; }
public static int last index of ( object [ ] array , object object to find ) { return last index of ( array , object to find , integer . max_value ) ; }
public to string builder reflection append array ( object array ) { this . get style ( ) . reflection append array detail ( this . get string buffer ( ) , null , array ) ; return this ; }
public void decrement ( ) { value -- ; }
public long get nano time ( ) { if ( this . run state == state_stopped || this . run state == state_suspended ) { return this . stop time - this . start time ; } else if ( this . run state == state_unstarted ) { return 0 ; } else if ( this . run state == state_running ) { return system . nano time ( ) - this . start time ; } throw new runtime exception ( `` illegal run state have occur . `` ) ; }
public void stop ( ) { if ( this . run state ! = state_running & & this . run state ! = state_suspended ) { throw new illegal state exception ( `` stopwatch be not run . `` ) ; } stop time = system . current time millis ( ) ; this . run state = state_stopped ; }
public static void no null element ( collection collection , string message ) { validate . not null ( collection ) ; for ( iterator it = collection . iterator ( ) ; it . have next ( ) ; ) { if ( it . next ( ) == null ) { throw new illegal argument exception ( message ) ; } } }
public static void not empty ( string string ) { if ( string == null || string . length ( ) == 0 ) throw new illegal argument exception ( `` string must not be empty `` ) ; }
public void trace ( object message ) { category . log ( fqcn , priority . debug , message , null ) ; }
public void trace ( object message ) { category . log ( fqcn , priority . debug , message , null ) ; }
public void info ( object message ) { category . log ( fqcn , priority . info , message , null ) ; }
public void warn ( object message , throwable t ) { category . log ( fqcn , priority . warn , message , t ) ; }
public void fatal ( object message , throwable t ) { category . log ( fqcn , priority . fatal , message , t ) ; }
public void fatal ( object message , throwable t ) { if ( is12 ) { get logger ( ) . log ( fqcn , ( priority ) level . fatal , message , t ) ; } else { get logger ( ) . log ( fqcn , level . fatal , message , t ) ; } }
public void trace ( object message , throwable t ) { debug ( message , t ) ; }
public composable function fix1st argument ( final double fix x ) { return new composable function ( ) { @ override / * * { @ inherit doc } * / public double value ( double x ) throw function evaluation exception { return binary function . this . value ( fix x , x ) ; } } ; }
public composable function add ( final univariate real function f ) { return new composable function ( ) { @ override / * * { @ inherit doc } * / public double value ( double x ) throw function evaluation exception { return composable function . this . value ( x ) + f . value ( x ) ; } } ; }
public polynomial function polynomial derivative ( ) { return new polynomial function ( differentiate ( coefficient ) ) ; }
public static double solve ( univariate real function f , double x0 , double x1 ) throw convergence exception , function evaluation exception { setup ( f ) ; return lazy holder . factory . new default solver ( ) . solve ( f , x0 , x1 ) ; }
protect void verify interval ( double low , double upper ) throw illegal argument exception { if ( low > = upper ) { throw math runtime exception . create illegal argument exception ( `` endpoint do not specify an interval : [ { 0 } , { 1 } ] `` , low , upper ) ; } }
public void set median ( double median ) { set median internal ( median ) ; }
protect double get domain low bound ( double p ) { return double . min_value * gamma . get beta ( ) ; }
public double probability ( final int x ) { if ( x < = 0 || x > number of element ) { return 0 . 0 ; } return ( 1 . 0 / math . pow ( x , exponent ) ) / generalize harmonic ( number of element , exponent ) ; }
public static double dist square cartesian ( double [ ] vec1 , double [ ] vec2 ) { double result = 0 ; for ( int i = 0 ; i < vec1 . length ; i++ ) { double v = vec1 [ i ] - vec2 [ i ] ; result += v * v ; } return result ; }
public void set par relative tolerance ( double par relative tolerance ) { this . par relative tolerance = par relative tolerance ; }
protect void add measurement ( weighted measurement m ) { measurement . add ( m ) ; }
public boolean be ignore ( ) { return ignore ; }
public long long value ( ) { return numerator . divide ( denominator ) . long value ( ) ; }
public long long value ( ) { return numerator . divide ( denominator ) . long value ( ) ; }
public boolean be satisfied ( final population population ) { if ( this . num generation < this . max generation ) { num generations++ ; return false ; } return true ; }
protect void check addition compatible ( final field matrix < t > m ) { if ( ( get row dimension ( ) ! = m . get row dimension ( ) ) || ( get column dimension ( ) ! = m . get column dimension ( ) ) ) { throw math runtime exception . create illegal argument exception ( `` { 0 } x { 1 } and { 2 } x { 3 } matrix be not addition compatible `` , get row dimension ( ) , get column dimension ( ) , m . get row dimension ( ) , m . get column dimension ( ) ) ; } }
public big matrix get row matrix ( int row ) throw matrix index exception { matrix utils . check row index ( this , row ) ; final int ncols = this . get column dimension ( ) ; final big decimal [ ] [ ] out = new big decimal [ 1 ] [ ncols ] ; system . arraycopy ( data [ row ] , 0 , out [ 0 ] , 0 , ncols ) ; return new big matrix impl ( out , false ) ; }
public big decimal [ ] get column ( int col ) throw matrix index exception { matrix utils . check column index ( this , col ) ; final int n row = this . get row dimension ( ) ; final big decimal [ ] out = new big decimal [ n row ] ; for ( int i = 0 ; i < n row ; i++ ) { out [ i ] = data [ i ] [ col ] ; } return out ; }
public big matrix get row matrix ( int row ) throw matrix index exception { matrix utils . check row index ( this , row ) ; final int ncols = this . get column dimension ( ) ; final big decimal [ ] [ ] out = new big decimal [ 1 ] [ ncols ] ; system . arraycopy ( data [ row ] , 0 , out [ 0 ] , 0 , ncols ) ; return new big matrix impl ( out , false ) ; }
public open map real vector add ( open map real vector v ) throw illegal argument exception { check vector dimension ( v . get dimension ( ) ) ; boolean copy this = entry . size ( ) > v . entry . size ( ) ; open map real vector re = copy this ? this . copy ( ) : v . copy ( ) ; iterator iter = copy this ? v . entry . iterator ( ) : entry . iterator ( ) ; open int to double hash map random access = copy this ? entry : v . entry ; while ( iter . have next ( ) ) { iter . advance ( ) ; int key = iter . key ( ) ; if ( random access . contains key ( key ) ) { re . set entry ( key , random access . get ( key ) + iter . value ( ) ) ; } else { re . set entry ( key , iter . value ( ) ) ; } } return re ; }
public double [ ] get argument ( ) { return argument . clone ( ) ; }
public static concurrent modification exception create concurrent modification exception ( final string pattern , final object . . . argument ) { return new concurrent modification exception ( ) { / * * serializable version identifier . * / private static final long serial version u i d = 6134247282754009421l ; / * * { @ inherit doc } * / @ override public string get message ( ) { return build message ( locale . u , pattern , argument ) ; } / * * { @ inherit doc } * / @ override public string get localized message ( ) { return build message ( locale . get default ( ) , pattern , argument ) ; } } ; }
public boolean reset ( final double t , final double [ ] y ) { if ( ! ( pending event & & ( fast math . ab ( pending event time - t ) < = convergence ) ) ) { return false ; } if ( next action == event handler . action . reset_state ) { handler . reset state ( t , y ) ; } pending event = false ; pending event time = double . na n ; return ( next action == event handler . action . reset_state ) || ( next action == event handler . action . reset_derivatives ) ; }
protect void reinitialize ( final double [ ] y , final boolean be forward ) { previous time = double . na n ; current time = double . na n ; h = double . na n ; interpolated time = double . na n ; current state = y ; interpolate state = new double [ y . length ] ; interpolate derivative = new double [ y . length ] ; finalize = false ; this . forward = be forward ; this . dirty state = true ; }
public long next long ( long low , long upper ) { if ( low > = upper ) { throw math runtime exception . create illegal argument exception ( `` upper bound ( { 0 } ) must be great than low bound ( { 1 } ) `` , upper , low ) ; } double r = get ran ( ) . next double ( ) ; return ( long ) ( ( r * upper ) + ( ( 1 . 0 - r ) * low ) + r ) ; }
public long next secure long ( long low , long upper ) { if ( low > = upper ) { throw math runtime exception . create illegal argument exception ( `` upper bound ( { 0 } ) must be great than low bound ( { 1 } ) `` , upper , low ) ; } secure random sec = get sec ran ( ) ; return low + ( long ) ( sec . next double ( ) * ( upper - low + 1 ) ) ; }
public real matrix compute correlation matrix ( real matrix matrix ) { check sufficient data ( matrix ) ; int n var = matrix . get column dimension ( ) ; real matrix out matrix = new block real matrix ( n var , n var ) ; for ( int i = 0 ; i < n var ; i++ ) { for ( int j = 0 ; j < i ; j++ ) { double corr = correlation ( matrix . get column ( i ) , matrix . get column ( j ) ) ; out matrix . set entry ( i , j , corr ) ; out matrix . set entry ( j , i , corr ) ; } out matrix . set entry ( i , i , 1d ) ; } return out matrix ; }
public double next exponential ( double mean ) { if ( mean < = 0 . 0 ) { throw math runtime exception . create illegal argument exception ( `` mean must be positive ( { 0 } ) `` , mean ) ; } final random generator generator = get ran ( ) ; double unif = generator . next double ( ) ; while ( unif == 0 . 0d ) { unif = generator . next double ( ) ; } return -mean * math . log ( unif ) ; }
public static unknown distribution chi square test get unknown distribution chi square test ( ) { return unknown distribution chi square test ; }
public double t test ( double mu , double [ ] sample ) throw illegal argument exception , math exception { check sample data ( sample ) ; return t test ( stat utils . mean ( sample ) , mu , stat utils . variance ( sample ) , sample . length ) ; }
public double t test ( double mu , double [ ] sample ) throw illegal argument exception , math exception { check sample data ( sample ) ; return t test ( stat utils . mean ( sample ) , mu , stat utils . variance ( sample ) , sample . length ) ; }
public complex [ ] transform ( final double [ ] f , final transform type type ) { final double [ ] [ ] data r i = new double [ ] [ ] { math array . copy of ( f , f . length ) , new double [ f . length ] } ; transform in place ( data r i , normalization , type ) ; return transform utils . create complex array ( data r i ) ; }
public static boolean equal ( float x , float y , float eps ) { return equal ( x , y , 1 ) || fast math . ab ( y - x ) < = eps ; }
public static byte sign ( final byte x ) { return ( x == zb ) ? zb : ( x > zb ) ? pb : nb ; }
public static byte sign ( final byte x ) { return ( x == zb ) ? zb : ( x > zb ) ? pb : nb ; }
public static byte sign ( final byte x ) { return ( x == zb ) ? zb : ( x > zb ) ? pb : nb ; }
public static double normalize angle ( double a , double center ) { return a - two_pi * fast math . floor ( ( a + fast math . pi - center ) / two_pi ) ; }
public static double npv ( double r , double [ ] cf ) { double npv = 0 ; double r1 = r + 1 ; double trate = r1 ; for ( int i=0 , i size=cfs . length ; i < i size ; i++ ) { npv += cf [ i ] / trate ; trate * = r1 ; } return npv ; }
public synchronize double [ ] get element ( ) { double [ ] element array = new double [ num element ] ; system . arraycopy ( internal array , start index , element array , 0 , num element ) ; return element array ; }
public static void check order ( double [ ] val , int dir , boolean strict ) { double previous = val [ 0 ] ; int max = val . length ; for ( int i = 1 ; i < max ; i++ ) { if ( dir > 0 ) { if ( strict ) { if ( val [ i ] < = previous ) { throw math runtime exception . create illegal argument exception ( `` point { 0 } and { 1 } be not strictly increase ( { 2 } > = { 3 } ) `` , i - 1 , i , previous , val [ i ] ) ; } } else { if ( val [ i ] < previous ) { throw math runtime exception . create illegal argument exception ( `` point { 0 } and { 1 } be not increase ( { 2 } > { 3 } ) `` , i - 1 , i , previous , val [ i ] ) ; } } } else { if ( strict ) { if ( val [ i ] > = previous ) { throw math runtime exception . create illegal argument exception ( `` point { 0 } and { 1 } be not strictly decrease ( { 2 } < = { 3 } ) `` , i - 1 , i , previous , val [ i ] ) ; } } else { if ( val [ i ] > previous ) { throw math runtime exception . create illegal argument exception ( `` point { 0 } and { 1 } be not decrease ( { 2 } < { 3 } ) `` , i - 1 , i , previous , val [ i ] ) ; } } } previous = val [ i ] ; } }
public static boolean equal ( double x , double y ) { return ( double . be na n ( x ) & & double . be na n ( y ) ) || x == y ; }
public void disconnect ( ) throw i o exception { if ( _error stream_ ! = null ) _error stream_ . close ( ) ; _error stream_ = null ; super . disconnect ( ) ; }
public int receive ( byte [ ] data , int length ) throw i o exception { __receive packet . set data ( data ) ; __receive packet . set length ( length ) ; _socket_ . receive ( __receive packet ) ; return __receive packet . get length ( ) ; }
public inet address get local address ( ) { return _socket_ . get local address ( ) ; }
public int send command ( int command , string args ) throw i o exception { return send command ( f t p command . _commands [ command ] , args ) ; }
public string [ ] get reply string ( ) { return _reply line . to array ( new string [ _reply line . size ( ) ] ) ; }
public int abor ( ) throw i o exception { return send command ( f t p command . abor ) ; }
public int stou ( ) throw i o exception { return send command ( f t p command . stou ) ; }
public int mkd ( string pathname ) throw i o exception { return send command ( f t p command . mkd , pathname ) ; }
public int abor ( ) throw i o exception { return send command ( f t p command . abor ) ; }
public void set passive nat workaround ( boolean enable ) { if ( enable ) { this . __passive nat workaround strategy = new nat server resolver impl ( this ) ; } else { this . __passive nat workaround strategy = null ; } }
public boolean store unique file ( input stream local ) throw i o exception { return __store file ( f t p command . stou , null , local ) ; }
public f t p file [ ] parse file list ( input stream list stream , string encode ) throw i o exception { f t p file list ffl = f t p file list . create ( list stream , this , encode ) ; return ffl . get file ( ) ; }
public int get buffer size ( ) { return __buffer size ; }
public string [ ] feature value ( string feature ) throw i o exception { if ( ! init feature map ( ) ) { return null ; } set < string > entry = __features map . get ( feature . to upper case ( locale . english ) ) ; if ( entry ! = null ) { return entry . to array ( new string [ entry . size ( ) ] ) ; } return null ; }
public void set user ( string user ) { _user = user ; }
public void set link ( string link ) { _link = link ; }
public void set raw listing ( string raw listing ) { _raw listing = raw listing ; }
public boolean match ( string s ) { this . result = null ; _matcher_ = pattern . matcher ( s ) ; if ( _matcher_ . match ( ) ) { this . result = _matcher_ . to match result ( ) ; } return null ! = this . result ; }
public static boolean be negative transient ( int reply ) { return ( reply > = 400 & & reply < 500 ) ; }
public string group ( int matchnum ) { if ( this . result == null ) { return null ; } return this . result . group ( matchnum ) ; }
public int available ( ) throw i o exception { return ( buf . length - po ) + in . available ( ) ; }
public void add newsgroup ( string newsgroup ) { if ( __newsgroups ! = null ) __newsgroups . append ( ' , ' ) ; else __newsgroups = new string buffer ( ) ; __newsgroups . append ( newsgroup ) ; }
public int body ( string message id ) throw i o exception { return send command ( n n t p command . body , message id ) ; }
public reader retrieve article ( string article id ) throw i o exception { return retrieve article ( article id , null ) ; }
public boolean logout ( ) throw i o exception { return n n t p reply . be positive completion ( quit ( ) ) ; }
public void add header field ( string header field , string value ) { __header field . append ( header field ) ; __header field . append ( `` : `` ) ; __header field . append ( value ) ; __header field . append ( '\n ' ) ; }
public long get time ( ) { return get time ( ntp time ) ; }
public long get time ( ) { return get time ( ntp time ) ; }
public string to string ( ) { string buffer b = new string buffer ( ) ; tree map sort = new tree map ( get property ( ) ) ; for ( iterator i = sort . entry set ( ) . iterator ( ) ; i . have next ( ) ; ) { map . entry e = ( map . entry ) i . next ( ) ; if ( b . length ( ) ! = 0 ) { b . append ( `` , `` ) ; } b . append ( e . get key ( ) . to string ( ) ) ; b . append ( `` = `` ) ; b . append ( e . get value ( ) . to string ( ) ) ; } return b . to string ( ) ; }
public void disconnect ( ) throw i o exception { super . disconnect ( ) ; _reader = null ; _writer = null ; _reply string = null ; _reply line . set size ( 0 ) ; _new reply string = false ; }
public boolean logout ( ) throw i o exception { return s m t p reply . be positive completion ( quit ( ) ) ; }
public void set default port ( int port ) { _default port_ = port ; }
protect double get domain low bound ( double p ) { return 0 ; }
public final void begin buffer ops ( ) { __receive buffer = new byte [ packet_size ] ; __receive datagram = new datagram packet ( __receive buffer , __receive buffer . length ) ; _send buffer = new byte [ packet_size ] ; __send datagram = new datagram packet ( _send buffer , _send buffer . length ) ; }
public final void buffer send ( t f t p packet packet ) throw i o exception { _socket_ . send ( packet . _new datagram ( __send datagram , _send buffer ) ) ; }
public void set block number ( int block number ) { _block number = block number ; }
public string get status ( ) throw i o exception { if ( f t p reply . be positive completion ( stat ( ) ) ) return get reply string ( ) ; return null ; }
public boolean get need client auth ( ) { if ( _socket_ instanceof s s l socket ) return ( ( s s l socket ) _socket_ ) . get need client auth ( ) ; return false ; }
protect int get send buffer size ( ) { return send buffer size ; }
public copy stream listener get copy stream listener ( ) { return __copy stream listener ; }
public boolean do command ( i m a p command command ) throw i o exception { return i m a p reply . be success ( send command ( command ) ) ; }
public boolean uid ( string command , string command args ) throw i o exception { return do command ( i m a p command . uid , command + `` `` + command args ) ; }
public boolean select ( string mailbox name ) throw i o exception { return do command ( i m a p command . select , mailbox name ) ; }
public void add header field ( string name , string val ) { header . append ( name ) ; header . append ( `` : `` ) ; header . append ( val ) ; header . append ( '\n ' ) ; }
public static x509 trust manager get validate server certificate trust manager ( ) { return check_server_validity ; }
protect void add non match ( string builder sb , string text ) { sb . append ( text ) ; }
public synchronize int get num active ( ) { return num active ; }
public synchronize string to string ( ) { string buffer buf = new string buffer ( ) ; buf . append ( get class ( ) . get name ( ) ) ; buf . append ( `` contain `` ) . append ( _pools . size ( ) ) . append ( `` distinct pool : `` ) ; iterator < k > it = _pools . key set ( ) . iterator ( ) ; while ( it . have next ( ) ) { k key = it . next ( ) ; buf . append ( `` | `` ) . append ( key ) . append ( `` |= `` ) ; stack < v > s = _pools . get ( key ) ; buf . append ( s . size ( ) ) ; } return buf . to string ( ) ; }
public int get max sleeping ( ) { return _max sleep ; }
public int get remove abandon timeout ( ) { return ( int ) this . remove abandon timeout . get second ( ) ; }
public final void set lifo ( final boolean lifo ) { this . lifo = lifo ; }
public final long get destroy count ( ) { return destroy count . get ( ) ; }
public void set config ( final generic object pool config < t > conf ) { super . set config ( conf ) ; set max idle ( conf . get max idle ( ) ) ; set min idle ( conf . get min idle ( ) ) ; set max total ( conf . get max total ( ) ) ; }
public final int get max total ( ) { return max total ; }
public final boolean get test on borrow ( ) { return test on borrow ; }
public void set config ( final generic object pool config < t > conf ) { super . set config ( conf ) ; set max idle ( conf . get max idle ( ) ) ; set min idle ( conf . get min idle ( ) ) ; set max total ( conf . get max total ( ) ) ; }
public final object name get jmx name ( ) { return object name ; }
public object [ ] to array ( ) { lock . lock ( ) ; try { final object [ ] a = new object [ count ] ; int k = 0 ; for ( node < e > p = first ; p ! = null ; p = p . next ) { a [ k++ ] = p . item ; } return a ; } finally { lock . unlock ( ) ; } }
public synchronize int get num idle ( ) { prune clear reference ( ) ; return idle reference . size ( ) ; }
public string lookup url string lookup ( ) { return url string lookup . instance ; }
public static function new pre translate ( string bundle , locale locale ) { return new pre translate func ( bundle , locale , true ) ; }
public l z f output stream finish block ( ) throw i o exception { if ( _position > 0 ) { write compress block ( ) ; } return this ; }
protect boolean be bracket ( final double lower , final double upper ) { return univariate solver utils . be bracket ( function , low , upper ) ; }
public config parse option set includer ( config includer includer ) { if ( this . includer == includer ) return this ; else return new config parse option ( this . syntax , this . origin description , this . allow miss , includer , this . class loader ) ; }
public config parse option set includer ( config includer includer ) { if ( this . includer == includer ) return this ; else return new config parse option ( this . syntax , this . origin description , this . allow miss , includer , this . class loader ) ; }
public config render option set comment ( boolean value ) { if ( value == comment ) return this ; else return new config render option ( origin comment , value , format , json ) ; }
protect abstract config value peek path ( path path , resolve context context ) throw not possible to resolve { return peek path ( this , path , context ) ; }
public list < data table row > get gherkin row ( ) { return collection . unmodifiable list ( gherkin row ) ; }
public static object make ( class loader cl , class clazz , class pool cp , annotation anon ) { annotation impl handler = new annotation impl ( anon , cp , cl ) ; return proxy . new proxy instance ( cl , new class [ ] { clazz } , handler ) ; }
public static link list < string > wrap in tag ( link list < string > sequence , int start position , int end position , string tag , string css class ) { link list < string > result = ( link list < string > ) sequence . clone ( ) ; string builder tag builder = new string builder ( ) ; tag builder . append ( `` < `` ) ; tag builder . append ( tag ) ; if ( css class ! = null ) { tag builder . append ( `` class=\ `` `` ) ; tag builder . append ( css class ) ; tag builder . append ( `` \ `` `` ) ; } tag builder . append ( `` > `` ) ; string start tag = tag builder . to string ( ) ; tag builder . delete ( 0 , tag builder . length ( ) ) ; tag builder . append ( `` < / `` ) ; tag builder . append ( tag ) ; tag builder . append ( `` > `` ) ; string end tag = tag builder . to string ( ) ; result . add ( start position , start tag ) ; result . add ( end position , end tag ) ; return result ; }
public retry loop new retry loop ( ) { return new retry loop ( retry policy . get ( ) , tracer ) ; }
public void poll for initial ensemble ( ) throw exception { precondition . check state ( state . get ( ) == state . latent , `` can not be call after start ( ) `` ) ; poll ( ) ; }
public void ensure ( curator zookeeper client client ) throw exception { helper local helper = helper . get ( ) ; local helper . ensure ( client , path , make last node ) ; }
public static string get node from path ( string path ) { path utils . validate path ( path ) ; int i = path . last index of ( path_separator ) ; if ( i < 0 ) { return path ; } if ( ( i + 1 ) > = path . length ( ) ) { return `` `` ; } return path . substring ( i + 1 ) ; }
public void enter ( ) throw exception { enter ( -1 , null ) ; }
public child data get current data ( ) { return data . get ( ) ; }
public collection < string > get participant node ( ) throw exception { return lock internals . get participant node ( internals . get client ( ) , base path , internals . get lock name ( ) , internals . get driver ( ) ) ; }
public collection < string > get participant node ( ) throw exception { return lock internals . get participant node ( internals . get client ( ) , base path , internals . get lock name ( ) , internals . get driver ( ) ) ; }
public long get four nine upper bound ( ) { return get upper bound for factor ( 0 . 9999d ) ; }
public event handler group < t > then handle event with worker pool ( final work handler < t > . . . handler ) { return handle event with worker pool ( handler ) ; }
public event handler group < t > and ( final event handler group < t > other handler group ) { final sequence [ ] combine sequence = new sequence [ this . sequence . length + other handler group . sequence . length ] ; system . arraycopy ( this . sequence , 0 , combine sequence , 0 , this . sequence . length ) ; system . arraycopy ( other handler group . sequence , 0 , combine sequence , this . sequence . length , other handler group . sequence . length ) ; return new event handler group < t > ( disruptor , consumer repository , combine sequence ) ; }
public event handler group < t > and ( final event handler group < t > other handler group ) { final sequence [ ] combine sequence = new sequence [ this . sequence . length + other handler group . sequence . length ] ; system . arraycopy ( this . sequence , 0 , combine sequence , 0 , this . sequence . length ) ; system . arraycopy ( other handler group . sequence , 0 , combine sequence , this . sequence . length , other handler group . sequence . length ) ; return new event handler group < t > ( disruptor , consumer repository , combine sequence ) ; }
public void set model ( string model ) { this . model = model ; }
public void set model ( string model ) { this . model = model ; }
public static < t > t create mock ( class < t > to mock ) { return create control ( ) . create mock ( to mock ) ; }
public int get count ( ) { final long result = get byte count ( ) ; if ( result > integer . max_value ) { throw new arithmetic exception ( `` the byte count `` + result + `` be too large to be convert to an int `` ) ; } return ( int ) result ; }
public int reset count ( ) { final long result = reset byte count ( ) ; if ( result > integer . max_value ) { throw new arithmetic exception ( `` the byte count `` + result + `` be too large to be convert to an int `` ) ; } return ( int ) result ; }
public input stream bind stream ( final input stream input ) { final input stream old value = input stream local . get ( ) ; input stream local . set ( input ) ; return old value ; }
public long get position ( ) { return position ; }
public static byte eq ( byte value ) { report matcher ( new equal ( value ) ) ; return 0 ; }
public static void reset ( object . . . mock ) { for ( object mock : mock ) { get control ( mock ) . reset ( ) ; } }
public final void reset ( ) { ctrl . reset ( ) ; }
public void set throwable ( throwable throwable ) { expect last call ( `` method call on the mock need before set throwable `` ) . and throw ( throwable ) . once ( ) ; }
public void set default void callable ( ) { ( ( mock control ) expect last call ( `` method call on the mock need before set default void callable `` ) ) . set legacy default void callable ( ) ; }
public void set throwable ( throwable throwable , int min count , int max count ) { expect last call ( `` method call on the mock need before set throwable `` ) . and throw ( throwable ) . time ( min count , max count ) ; }
public void set default matcher ( argument matcher matcher ) { ctrl . set legacy default matcher ( matcher ) ; }
public void set default matcher ( argument matcher matcher ) { ctrl . set legacy default matcher ( matcher ) ; }
public type annotation walker to type parameter ( boolean be class type parameter , int rank ) { long new match = this . match ; if ( new match == 0 ) return empty_annotation_walker ; int target type = be class type parameter ? annotation target type constant . class_type_parameter : annotation target type constant . method_type_parameter ; int length = this . type annotation . length ; long mask = 1 ; for ( int i = 0 ; i < length ; i++ , mask = mask < < 1 ) { i binary type annotation candidate = this . type annotation [ i ] ; if ( candidate . get target type ( ) ! = target type || candidate . get type parameter index ( ) ! = rank ) { new match & = ~mask ; } } return restrict ( new match , 0 ) ; }
public static inet address from little endian byte array ( byte [ ] addr ) throw unknown host exception { byte [ ] reverse = new byte [ addr . length ] ; for ( int i = 0 ; i < addr . length ; i++ ) { reversed [ i ] = addr [ addr . length - i - 1 ] ; } return inet address . get by address ( reverse ) ; }
public field element cmov ( field element val , int b ) { ed25519 field element that = ( ed25519 field element ) val ; b = -b ; int [ ] result = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i++ ) { result [ i ] = this . t [ i ] ; int x = this . t [ i ] ^ that . t [ i ] ; x & = b ; result [ i ] ^= x ; } return new ed25519 field element ( this . f , result ) ; }
public cluster health request builder set wait for no initializing shard ( boolean wait for no initializing shard ) { request . wait for no initializing shard ( wait for no initializing shard ) ; return this ; }
public node info request all ( ) { request metric . add all ( metric . all metric ( ) ) ; return this ; }
public cluster reroute request add ( allocation command . . . command ) { this . command . add ( command ) ; return this ; }
public string get set ( string set ) { if ( persistent setting . have value ( set ) ) { return persistent setting . get ( set ) ; } else if ( transient setting . have value ( set ) ) { return transient setting . get ( set ) ; } else if ( default setting . have value ( set ) ) { return default setting . get ( set ) ; } else { return null ; } }
public cluster search shard request builder set index option ( index option index option ) { request ( ) . index option ( index option ) ; return this ; }
public cluster search shard request builder set index option ( index option index option ) { request ( ) . index option ( index option ) ; return this ; }
public create snapshot request builder set partial ( boolean partial ) { request . partial ( partial ) ; return this ; }
public create snapshot request builder set wait for completion ( boolean wait for completion ) { request . wait for completion ( wait for completion ) ; return this ; }
public create snapshot request builder set setting ( string source , x content type x content type ) { request . setting ( source , x content type ) ; return this ; }
public restore snapshot request builder set snapshot ( string snapshot ) { request . snapshot ( snapshot ) ; return this ; }
public restore snapshot request builder set partial ( boolean partial ) { request . partial ( partial ) ; return this ; }
public restore snapshot request builder set partial ( boolean partial ) { request . partial ( partial ) ; return this ; }
public snapshot stats get stats ( ) { return stats ; }
public long get time ( ) { return time ; }
public int get process file count ( ) { return process file count ; }
public cluster state request builder clear ( ) { request . clear ( ) ; return this ; }
public static get alias response from x content ( x content parser parser ) throw i o exception { if ( parser . current token ( ) == null ) { parser . next token ( ) ; } ensure expect token ( token . start_object , parser . current token ( ) , parser ) ; map < string , set < alias metadata > > alias = new hash map < > ( ) ; string current field name ; token token ; string error = null ; elasticsearch exception exception = null ; rest status status = rest status . ok ; while ( parser . next token ( ) ! = token . end_object ) { if ( parser . current token ( ) == token . field_name ) { current field name = parser . current name ( ) ; if ( `` status `` . equal ( current field name ) ) { if ( ( token = parser . next token ( ) ) ! = token . field_name ) { ensure expect token ( token . value_number , token , parser ) ; status = rest status . from code ( parser . int value ( ) ) ; } } else if ( `` error `` . equal ( current field name ) ) { token = parser . next token ( ) ; if ( token == token . value_string ) { error = parser . text ( ) ; } else if ( token == token . start_object ) { parser . next token ( ) ; exception = elasticsearch exception . inner from x content ( parser , true ) ; } else if ( token == token . start_array ) { parser . skip child ( ) ; } } else { string index name = parser . current name ( ) ; if ( parser . next token ( ) == token . start_object ) { set < alias metadata > parse inside = parse alias ( parser ) ; aliases . put ( index name , parse inside ) ; } } } } if ( exception ! = null ) { assert error == null ; assert alias . be empty ( ) ; return new get alias response ( status , exception ) ; } return new get alias response ( status , error , aliases ) ; }
public index aliases request builder add alias ( string index , string alias ) { request . add alias action ( alias action . add ( ) . index ( index ) . alias ( alias ) ) ; return this ; }
public analyze request builder set text ( string . . . text ) { request . text ( text ) ; return this ; }
public group shard iterator < shard iterator > all assigned shard group ( string [ ] index , boolean include empty ) { return all satisfy predicate shard group ( index , include empty , assigned_predicate ) ; }
public rollover request builder wait for active shard ( active shard count wait for active shard ) { this . request . get create index request ( ) . wait for active shard ( wait for active shard ) ; return this ; }
public resize type resize type ( ) { return resize type ; }
public resize type resize type ( ) { return resize type ; }
public resize type resize type ( ) { return resize type ; }
public create index request setting ( string source , x content type x content type ) { this . setting = setting . builder ( ) . load from source ( source , x content type ) . build ( ) ; return this ; }
public create index request alias ( map < string , ? > source ) { try { x content builder builder = x content factory . json builder ( ) ; builder . map ( source ) ; return alias ( byte reference . byte ( builder ) , builder . content type ( ) ) ; } catch ( i o exception e ) { throw new elasticsearch generation exception ( `` fail to generate [ `` + source + `` ] `` , e ) ; } }
public force merge request builder set max num segment ( int max num segment ) { request . max num segment ( max num segment ) ; return this ; }
public create index request mapping ( string type , object . . . source ) { mapping ( type , put map request . build from simplify def ( type , source ) ) ; return this ; }
public string [ ] index ( ) { return index ; }
public index shard store request builder set index option ( index option index option ) { request . index option ( index option ) ; return this ; }
public resize type get resize type ( ) { return type ; }
public common stats flag all ( ) { flags = enum set . all of ( flag . class ) ; type = null ; group = null ; field data field = null ; completion data field = null ; include segment file size = false ; include unloaded segment = false ; return this ; }
public put index template request builder set setting ( setting setting ) { request . setting ( setting ) ; return this ; }
public validate query request builder set explain ( boolean explain ) { request . explain ( explain ) ; return this ; }
public static backoff policy exponential backoff ( time value initial delay , int max number of retries ) { return new exponential backoff ( ( int ) check delay ( initial delay ) . millis ( ) , max number of retries ) ; }
public string get id ( ) { if ( failure ! = null ) { return failure . get id ( ) ; } return response . get id ( ) ; }
public string get id ( ) { if ( failure ! = null ) { return failure . get id ( ) ; } return response . get id ( ) ; }
public bulk request add ( byte [ ] data , int from , int length , x content type x content type ) throw i o exception { return add ( data , from , length , null , null , x content type ) ; }
public boolean await close ( long timeout , time unit unit ) throw interrupted exception { lock . lock ( ) ; try { if ( close ) { return true ; } close = true ; this . cancellable flush task . cancel ( ) ; if ( bulk request . number of action ( ) > 0 ) { execute ( ) ; } try { return this . bulk request handler . await close ( timeout , unit ) ; } finally { on close . run ( ) ; } } finally { lock . unlock ( ) ; } }
public int number of action ( ) { return request . number of action ( ) ; }
public string get type ( ) { return this . type ; }
public shard id get shard id ( ) { return this . shard id ; }
protect string [ ] resolve all ( template context context ) { string binding= resolve ( context ) ; if ( bind == null ) return new string [ 0 ] ; return new string [ ] { bind } ; }
public byte [ ] get source a byte ( ) { return get result . source ( ) ; }
public index request set final pipeline ( final string final pipeline ) { this . final pipeline = final pipeline ; return this ; }
public string get pipeline ( ) { return this . pipeline ; }
public update request set if seq no ( long seq no ) { if ( seq no < 0 & & seq no ! = unassigned_seq_no ) { throw new illegal argument exception ( `` sequence number must be non negative . get [ `` + seq no + `` ] . `` ) ; } if seq no = seq no ; return this ; }
public delete pipeline request builder set id ( string id ) { request . set id ( id ) ; return this ; }
public multi search request add ( search request builder request ) { request . add ( request . request ( ) ) ; return this ; }
public void set max concurrent shard request ( int max concurrent shard request ) { if ( max concurrent shard request < 1 ) { throw new illegal argument exception ( `` max concurrent shard request must be > = 1 `` ) ; } this . max concurrent shard request = max concurrent shard request ; }
public search request builder add sort ( sort builder < ? > sort ) { source builder ( ) . sort ( sort ) ; return this ; }
public int get fail shard ( ) { return shard failure . length ; }
public int get fail shard ( ) { return shard failure . length ; }
public static < t > t get with timeout ( final int timeout , final time unit time unit , @ not null final callable < t > lambda ) { check ( `` timeout must be great than zero `` , timeout > 0 ) ; future < t > future = executor_service . submit ( lambda ) ; return call future ( timeout , time unit , future ) ; }
public create index request wait for active shard ( active shard count wait for active shard ) { this . wait for active shard = wait for active shard ; return this ; }
public cluster state request builder set wait for metadata version ( long wait for metadata version ) { request . wait for metadata version ( wait for metadata version ) ; return this ; }
public final request builder set parent task id ( task id task id ) { request . set parent task id ( task id ) ; return ( request builder ) this ; }
public list < task operation failure > get task failure ( ) { return task failure ; }
public static location location to sync ( location current , location next ) { / * here we be move forward in the translog with each operation . under the hood this might * cross translog file which be ok since from the user perspective the translog be like a * tape where only the high location need to be fsynced in order to sync all previous * location even though they be not in the same file . when the translog roll over file * the previous file be fsynced on after close if need . * / assert next ! = null : `` next operation ca n't be null `` ; assert current == null || current . compare to ( next ) < 0 : `` translog location be not increase `` ; return next ; }
public term vector request builder set select field ( string . . . field ) { request . select field ( field ) ; return this ; }
public term vector request builder set term statistic ( boolean term statistic ) { request . term statistic ( term statistic ) ; return this ; }
public update request builder set script upsert ( boolean script upsert ) { request . script upsert ( scripted upsert ) ; return this ; }
public update request set if primary term ( long term ) { if ( term < 0 ) { throw new illegal argument exception ( `` primary term must be non negative . get [ `` + term + `` ] `` ) ; } if primary term = term ; return this ; }
public update request builder set doc a upsert ( boolean should upsert doc ) { request . doc a upsert ( should upsert doc ) ; return this ; }
public update request upsert ( x content builder source ) { safe upsert request ( ) . source ( source ) ; return this ; }
public clear index cache response clear cache ( clear index cache request clear index cache request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( clear index cache request , indices request converter : : clear cache , option , clear index cache response : : from x content , empty set ( ) ) ; }
public transport client add transport address ( transport address transport address ) { nodes service . add transport address ( transport address ) ; return this ; }
public transport client add transport address ( transport address transport address ) { nodes service . add transport address ( transport address ) ; return this ; }
public time value master node timeout ( ) { return master node timeout ; }
public time value ack timeout ( ) { return ack timeout ; }
public time value ack timeout ( ) { return ack timeout ; }
public void on ack timeout ( ) { listener . on response ( new response ( false ) ) ; }
public void remote shard fail ( final shard id shard id , string allocation id , long primary term , boolean mark a stale , final string message , @ nullable final exception failure , action listener < void > listener ) { assert primary term > 0l : `` primary term should be strictly positive `` ; remote fail shard deduplicator . execute once ( new fail shard entry ( shard id , allocation id , primary term , message , failure , mark a stale ) , listener , ( req , req listener ) - > send shard action ( shard_failed_action_name , cluster service . state ( ) , req , req listener ) ) ; }
public boolean index rout table change ( string index ) { object . require non null ( index , `` index must not be null `` ) ; if ( state . rout table ( ) . have index ( index ) == false & & previous state . rout table ( ) . have index ( index ) == false ) { return false ; } if ( state . rout table ( ) . have index ( index ) & & previous state . rout table ( ) . have index ( index ) ) { return state . rout table ( ) . index ( index ) ! = previous state . rout table ( ) . index ( index ) ; } return true ; }
public boolean node add ( ) { return node delta . add ( ) ; }
public void write to ( stream output out ) throw i o exception { out . write string ( name ) ; if ( out . get version ( ) . on or after ( snapshots service . uuids_in_repo_data_version ) ) { out . write string ( uuid ) ; } out . write string ( type ) ; setting . write setting to stream ( setting , out ) ; if ( out . get version ( ) . on or after ( repo_gen_in_cs_version ) ) { out . write long ( generation ) ; out . write long ( pending generation ) ; } }
public static void get and set node id and cluster id ( cluster service cluster service , thread context thread context ) { cluster state cluster state = cluster service . state ( ) ; cluster state observer observer = new cluster state observer ( cluster state , cluster service , null , logger , thread context ) ; observer . wait for next change ( new node and cluster id state listener ( ) , node and cluster id state listener : : be node and cluster id present ) ; }
public version get min node version ( ) { return min node version ; }
public index graveyard index graveyard ( ) { return custom ( index graveyard . type ) ; }
public static set < shard id > select recover from shard ( int shard id , index metadata source index metadata , int num target shard ) { if ( source index metadata . get number of shard ( ) > num target shard ) { return select shrink shard ( shard id , source index metadata , num target shard ) ; } else if ( source index metadata . get number of shard ( ) < num target shard ) { return collection . singleton ( select split shard ( shard id , source index metadata , num target shard ) ) ; } else { return collection . singleton ( select clone shard ( shard id , source index metadata , num target shard ) ) ; } }
public static string get local name from full name ( string full ) { string end = `` `` ; if ( full . start with ( `` [ l `` ) ) { end = `` [ ] `` ; full = full . substring ( 3 , full . length ( ) - 1 ) ; } if ( full . last index of ( ' . ' ) < 0 ) { return full + end ; } else { return full . substring ( full . last index of ( ' . ' ) + 1 ) + end ; } }
public index concrete write index ( cluster state state , index request request ) { if ( request . index ( ) == null || ( request . index ( ) ! = null & & request . index ( ) . length ! = 1 ) ) { throw new illegal argument exception ( `` index request must specify a single index expression `` ) ; } return concrete write index ( state , request . index option ( ) , request . index ( ) [ 0 ] , false , request . include data stream ( ) ) ; }
public boolean be same u u i d ( string other u u i d ) { assert other u u i d ! = null ; assert get index u u i d ( ) ! = null ; if ( index_uuid_na_value . equal ( other u u i d ) || index_uuid_na_value . equal ( get index u u i d ( ) ) ) { return true ; } return other u u i d . equal ( get index u u i d ( ) ) ; }
public static set < shard id > select recover from shard ( int shard id , index metadata source index metadata , int num target shard ) { if ( source index metadata . get number of shard ( ) > num target shard ) { return select shrink shard ( shard id , source index metadata , num target shard ) ; } else if ( source index metadata . get number of shard ( ) < num target shard ) { return collection . singleton ( select split shard ( shard id , source index metadata , num target shard ) ) ; } else { return collection . singleton ( select clone shard ( shard id , source index metadata , num target shard ) ) ; } }
public void remove index template v2 ( final string [ ] names , final time value master timeout , final action listener < acknowledge response > listener ) { cluster service . submit state update task ( `` remove-index-template-v2 [ `` + string . join ( `` , `` , names ) + `` ] `` , new cluster state update task ( priority . urgent , master timeout ) { @ override public void on failure ( string source , exception e ) { listener . on failure ( e ) ; } @ override public cluster state execute ( cluster state current state ) { return inner remove index template v2 ( current state , name ) ; } @ override public void cluster state process ( string source , cluster state old state , cluster state new state ) { listener . on response ( acknowledge response . true ) ; } } ) ; }
public discovery node get ( string node id ) { return node . get ( node id ) ; }
public long get remain delay in millis ( ) { check decision state ( ) ; return remain delay in millis ; }
protect reroute explanation explain or throw miss rout node ( rout allocation allocation , boolean explain , discovery node disco node ) { if ( disco node . can contain data ( ) == false ) { return explain or throw reject command ( explain , allocation , `` allocation can only be do on data node , not [ `` + node + `` ] `` ) ; } else { return explain or throw reject command ( explain , allocation , `` could not find [ `` + node + `` ] among the rout node `` ) ; } }
public string get low watermark raw ( ) { return low watermark raw ; }
public move decision with remain decision ( decision can remain decision ) { return new move decision ( can remain decision , cluster rebalance decision , allocation decision , target node , node decision , current node rank ) ; }
public move decision with remain decision ( decision can remain decision ) { return new move decision ( can remain decision , cluster rebalance decision , allocation decision , target node , node decision , current node rank ) ; }
public long get remain delay in millis ( ) { check decision state ( ) ; return remain delay in millis ; }
public discovery node node ( ) { return node ; }
public void remove allocation id ( shard rout shard routing ) { index metadata updater . remove allocation id ( shard routing ) ; }
public int get current node ranking ( ) { check decision state ( ) ; return current node ranking ; }
public int number of shard with state ( shard rout state . . . state ) { if ( state . length == 1 ) { if ( state [ 0 ] == shard rout state . initialize ) { return initialize shard . size ( ) ; } else if ( state [ 0 ] == shard rout state . relocate ) { return relocate shard . size ( ) ; } } int count = 0 ; for ( shard rout shard entry : this ) { for ( shard rout state state : state ) { if ( shard entry . state ( ) == state ) { count++ ; } } } return count ; }
public void remove applier ( cluster state applier applier ) { normal priority state applier . remove ( applier ) ; high priority state applier . remove ( applier ) ; low priority state applier . remove ( applier ) ; }
public boolean have execute deletion ( string repository ) { for ( entry entry : entry ) { if ( entry . state ( ) == state . start & & entry . repository ( ) . equal ( repository ) ) { return true ; } } return false ; }
public void circuit break ( string field name , long bytes need ) { final long memory byte limit = this . limit and overhead . limit ; this . trip count . increment and get ( ) ; final string message = `` [ `` + this . name + `` ] data too large , data for [ `` + field name + `` ] `` + `` would be [ `` + byte need + `` / `` + new byte size value ( byte need ) + `` ] `` + `` , which be large than the limit of [ `` + memory byte limit + `` / `` + new byte size value ( memory byte limit ) + `` ] `` ; logger . debug ( ( ) - > new parameterized message ( `` { } `` , message ) ) ; throw new circuit break exception ( message , bytes need , memory byte limit , durability ) ; }
public void invalidate ( k key ) { cache segment < k , v > segment = get cache segment ( key ) ; segment . remove ( key , invalidation consumer ) ; }
public void clear ( ) { long max = math . max ( 1 , max memory / segment count ) ; for ( int i = 0 ; i < segment count ; i++ ) { segment [ i ] = new segment < v > ( max , average memory , stack move distance ) ; } }
public static string strip filename extension ( string path ) { int ext index = path . last index of ( extension_separator ) ; if ( ext index == -1 ) { return path ; } int folder index = path . last index of ( folder_separator ) ; if ( folder index > ext index ) { return path ; } return path . substring ( 0 , ext index ) ; }
public iterator < integer > key it ( ) { final iterator < int cursor > iterator = map . key ( ) . iterator ( ) ; return new iterator < integer > ( ) { @ override public boolean have next ( ) { return iterator . have next ( ) ; } @ override public integer next ( ) { return iterator . next ( ) . value ; } @ override public void remove ( ) { throw new unsupported operation exception ( ) ; } } ; }
public line string builder close ( ) { coordinate start = coordinate . get ( 0 ) ; coordinate end = coordinate . get ( coordinate . size ( ) - 1 ) ; if ( start . x ! = end . x || start . y ! = end . y ) { coordinate . add ( start ) ; } return this ; }
public line string builder close ( ) { coordinate start = coordinate . get ( 0 ) ; coordinate end = coordinate . get ( coordinate . size ( ) - 1 ) ; if ( start . x ! = end . x || start . y ! = end . y ) { coordinate . add ( start ) ; } return this ; }
public polygon builder close ( ) { shell . close ( ) ; return this ; }
public line string builder close ( ) { coordinate start = coordinate . get ( 0 ) ; coordinate end = coordinate . get ( coordinate . size ( ) - 1 ) ; if ( start . x ! = end . x || start . y ! = end . y ) { coordinate . add ( start ) ; } return this ; }
public < e extend enum < e > > void write enum ( e enum value ) throw i o exception { write v int ( enum value . ordinal ( ) ) ; }
public double from meter ( double distance ) { return convert ( distance , distance unit . meter , this ) ; }
protect object construct object ( node node ) { if ( constructed object . contains key ( node ) ) { return construct object . get ( node ) ; } return construct object no check ( node ) ; }
public static string capitalize first char ( string name ) { if ( ( name == null ) || name . equal ( `` `` ) ) { return name ; } char start = name . char at ( 0 ) ; if ( character . be low case ( start ) ) { start = character . to upper case ( start ) ; return start + name . substring ( 1 ) ; } return name ; } // capitalize first char
public static path [ ] file ( path from , directory stream . filter < path > filter ) throw i o exception { try ( directory stream < path > stream = file . new directory stream ( from , filter ) ) { return to array ( stream ) ; } }
public void flush ( ) throw i o exception { flush buffer ( ) ; _output stream . flush ( ) ; }
public shard id shard id ( ) { return this . shard id ; }
public shard id shard id ( ) { return this . shard id ; }
public static codec reader wrap ( codec reader reader , sort sort ) throw i o exception { return wrap ( reader , new sorter ( sort ) . sort ( reader ) , sort ) ; }
public string get minimum should match ( ) { return minimum should match ; }
public static float min ( float a , float b ) { if ( float . be na n ( a ) ) { return b ; } else if ( float . be na n ( b ) ) { return a ; } else { return math . min ( a , b ) ; } }
public int get line number ( ) { return line number ; }
protect void set closure delegate ( closure closure , object node ) { closure . set delegate ( this ) ; }
public synchronize void add setting update consumer ( consumer < setting > consumer , list < ? extend set < ? > > setting ) { add setting updater ( set . group setting updater ( consumer , setting ) ) ; }
public void remove super ( session session ) { super . remove ( session , false ) ; }
public final boolean be dynamic ( ) { return property . contains ( property . dynamic ) || property . contains ( property . operator dynamic ) ; }
public boolean exist or fallback exists ( final setting setting ) { return setting . key set ( ) . contains ( get key ( ) ) || ( fallback setting ! = null & & fallback setting . exists or fallback exists ( setting ) ) ; }
public boolean exist or fallback exists ( final setting setting ) { return setting . key set ( ) . contains ( get key ( ) ) || ( fallback setting ! = null & & fallback setting . exists or fallback exists ( setting ) ) ; }
public setting get by prefix ( string prefix ) { return new setting ( new filter map ( this . setting , ( k ) - > k . start with ( prefix ) , prefix ) , secure setting == null ? null : new prefixed secure setting ( secure setting , prefix , s - > s . start with ( prefix ) ) ) ; }
public boolean contains number ( number number ) { if ( number == null ) { return false ; } return contains float ( number . float value ( ) ) ; }
public static synchronize void print statistic ( ) { for ( map . entry < uri , statistic > pair : statistics_table . entry set ( ) ) { system . out . println ( `` file system `` + pair . get key ( ) . get scheme ( ) + `` : // `` + pair . get key ( ) . get authority ( ) + `` : `` + pair . get value ( ) ) ; } }
public long remainder ( long instant ) { return instant - round floor ( instant ) ; }
public double from meter ( double distance ) { return convert ( distance , distance unit . meter , this ) ; }
public static long decode zig zag64 ( final long n ) { return ( n > > > 1 ) ^ - ( n & 1 ) ; }
public static void write float l e ( float d , byte [ ] arr , int offset ) { write int l e ( float . float to raw int bit ( d ) , arr , offset ) ; }
public set entry set ( ) { if ( entry set == null ) { entry set = new reference entry set ( this ) ; } return entry set ; }
public boolean be count down ( ) { assert count down . get ( ) > = 0 ; return count down . get ( ) == 0 ; }
public boolean be count down ( ) { assert count down . get ( ) > = 0 ; return count down . get ( ) == 0 ; }
public boolean be hold by current thread ( t key ) { key lock lock = map . get ( key ) ; if ( lock == null ) { return false ; } return lock . be hold by current thread ( ) ; }
public time value get max task wait time ( ) { if ( get queue ( ) . size ( ) == 0 ) { return no_wait_time_value ; } long now = system . nano time ( ) ; long old creation date in nanos = now ; for ( runnable queue runnable : get queue ( ) ) { if ( queue runnable instanceof prioritize runnable ) { old creation date in nanos = math . min ( old creation date in nanos , ( ( prioritize runnable ) queue runnable ) . get creation date in nanos ( ) ) ; } } return time value . time value nanos ( now - old creation date in nanos ) ; }
public string get header ( string key ) { string value = thread local . get ( ) . request header . get ( key ) ; if ( value == null ) { return default header . get ( key ) ; } return value ; }
public int get threshold ( ) { return threshold ; }
public boolean abuts ( readable interval interval ) { if ( interval == null ) { long now = date time utils . current time millis ( ) ; return ( get start millis ( ) == now || get end millis ( ) == now ) ; } else { return ( interval . get end millis ( ) == get start millis ( ) || get end millis ( ) == interval . get start millis ( ) ) ; } }
public final list < string > validation error ( ) { return validation error ; }
public void on response ( discovery node node ) { boolean find = pending node . remove ( node ) ; assert found : `` node [ `` + node + `` ] already respond or fail `` ; latch . count down ( ) ; }
public delta delta ( discovery node other ) { final list < discovery node > remove = new array list < > ( ) ; final list < discovery node > add = new array list < > ( ) ; for ( discovery node node : other ) { if ( this . node exists ( node ) == false ) { remove . add ( node ) ; } } for ( discovery node node : this ) { if ( other . node exists ( node ) == false ) { add . add ( node ) ; } } return new delta ( other . get master node ( ) , get master node ( ) , local node id , collection . unmodifiable list ( remove ) , collection . unmodifiable list ( add ) ) ; }
public synchronize void fail all state and clear ( exception reason ) { for ( cluster state context pending state : pending state ) { if ( pending state . commit ( ) ) { pending state . listener . on new cluster state fail ( reason ) ; } } pending state . clear ( ) ; }
public synchronize void handle join request ( final discovery node node , final membership action . join callback callback ) { if ( election context ! = null ) { election context . add incoming join ( node , callback ) ; check pending join and elect if need ( ) ; } else { master service . submit state update task ( `` zen-disco-node-join `` , new join task executor . task ( node , `` no election context `` ) , cluster state task config . build ( priority . urgent ) , join task executor , new join task listener ( callback , logger ) ) ; } }
public path [ ] resolve index folder ( string index folder name ) { if ( node path == null || lock == null ) { throw new illegal state exception ( `` node be not configure to store local location `` ) ; } assert env be lock ( ) ; list < path > path = new array list < > ( node path . length ) ; for ( node path node path : node path ) { path index folder = node path . index path . resolve ( index folder name ) ; if ( file . exists ( index folder ) ) { path . add ( index folder ) ; } } return path . to array ( new path [ path . size ( ) ] ) ; }
public set < shard id > find all shard id ( final index index ) throw i o exception { assert index ! = null ; if ( node path == null || lock == null ) { throw new illegal state exception ( `` node be not configure to store local location `` ) ; } assert env be lock ( ) ; final set < shard id > shard id = new hash set < > ( ) ; final string index unique path id = index . get u u i d ( ) ; for ( final node path node path : node path ) { shard id . add all ( find all shard for index ( node path . index path . resolve ( index unique path id ) , index ) ) ; } return shard id ; }
public path [ ] node data path ( ) { assert env be lock ( ) ; path [ ] path = new path [ node path . length ] ; for ( int i=0 ; i < path . length ; i++ ) { paths [ i ] = node path [ i ] . path ; } return path ; }
public shard lock shard lock ( shard id id , final string detail ) throw shard lock obtain failed exception { return shard lock ( id , detail , 0 ) ; }
public static void override version ( version new version , path . . . data path ) throw i o exception { for ( final path data path : data path ) { final path index path = data path . resolve ( metadata_directory_name ) ; if ( file . exists ( index path ) ) { try ( directory reader reader = directory reader . open ( new n i o f s directory ( data path . resolve ( metadata_directory_name ) ) ) ) { final map < string , string > user data = reader . get index commit ( ) . get user data ( ) ; assert user data . get ( node_version_key ) ! = null ; try ( index writer index writer = create index writer ( new n i o f s directory ( data path . resolve ( metadata_directory_name ) ) , true ) ) { final map < string , string > commit data = new hash map < > ( user data ) ; commit data . put ( node_version_key , integer . to string ( new version . id ) ) ; index writer . set live commit data ( commit data . entry set ( ) ) ; index writer . commit ( ) ; } } catch ( index not find exception e ) { logger . debug ( new parameterized message ( `` no on-disk state at { } `` , index path ) , e ) ; } } } }
public name analyzer get default index analyzer ( ) { return analyzer . get ( default_analyzer_name ) ; }
public static pre configure token filter singleton ( string name , boolean use filter for multiterm query , function < token stream , token stream > create ) { return new pre configure token filter ( name , use filter for multiterm query , true , cache strategy . one , ( token stream , version ) - > create . apply ( token stream ) ) ; }
public string [ ] get names ( ) { string [ ] names = class map . key set ( ) . to array ( new string [ 0 ] ) ; array . sort ( name ) ; return name ; }
public boolean be auto generate i ds optimization enable ( ) { return index setting . get value ( index_optimize_auto_generated_ids ) ; }
public long get term memory in byte ( ) { return this . term memory in byte ; }
public long get index writer memory in byte ( ) { return this . index writer memory in byte ; }
public ordinal builder add doc ( int doc ) { total num ords++ ; final int num value = ordinal . add ordinal ( doc , current ord ) ; if ( num value == 1 ) { ++num doc with value ; } else if ( num value == 2 ) { ++num multi value doc ; } return this ; }
public time value get total time ( ) { return new time value ( total time in millis ) ; }
public simple query string builder analyze wildcard ( boolean analyze wildcard ) { this . setting . analyze wildcard ( analyze wildcard ) ; return this ; }
public boolean be explicit refresh ( ) { return index_refresh_interval_setting . exists ( setting ) ; }
public boolean be explicit refresh ( ) { return index_refresh_interval_setting . exists ( setting ) ; }
public int get number of replica ( ) { return setting . get a int ( index metadata . setting_number_of_replicas , null ) ; }
public byte size value get flush after merge threshold size ( ) { return flush after merge threshold size ; }
public int get max script field ( ) { return this . max script field ; }
public byte size value get flush after merge threshold size ( ) { return flush after merge threshold size ; }
public set < string > get matching field name ( string pattern ) { return field type lookup . get matching field name ( pattern ) ; }
public final parse context create copy to context ( ) { return new filter parse context ( this ) { @ override public boolean be within copy to ( ) { return true ; } } ; }
public object parse to ( range field mapper . range field type field type , x content parser parser , boolean coerce , boolean include ) throw i o exception { number value = number type . parse ( parser , coerce ) ; return include ? value : ( number ) next down ( value ) ; }
public synchronize boolean get auto i o throttle ( ) { return do auto i o throttle ; }
public qb indexed shape index ( string index shape index ) { this . indexed shape index = index shape index ; return ( qb ) this ; }
public query builder negative query ( ) { return this . negative query ; }
public float get max term frequency ( ) { return max term frequency ; }
public combine function boost mode ( ) { return this . boost mode ; }
public final fb set weight ( float weight ) { this . weight = check weight ( weight ) ; return ( fb ) this ; }
public geo bound box query builder set validation method ( geo validation method method ) { this . validation method = method ; return this ; }
public geo bound box query builder type ( geo exec type type ) { if ( type == null ) { throw new illegal argument exception ( `` type be not allow to be null . `` ) ; } this . type = type ; return this ; }
public geo distance query builder point ( geo point point ) { if ( point == null ) { throw new illegal argument exception ( `` center point must not be null `` ) ; } this . center = point ; return this ; }
public void set validation method ( geo validation method method ) { this . validation method = method ; }
public match phrase prefix query builder max expansion ( int max expansion ) { if ( max expansion < 0 ) { throw new illegal argument exception ( `` no negative max expansion allow . `` ) ; } this . max expansion = max expansion ; return this ; }
public match phrase prefix query builder zero term query ( zero term query option zero term query ) { if ( zero term query == null ) { throw new illegal argument exception ( `` [ `` + name + `` ] require zero term query to be non-null `` ) ; } this . zero term query = zero term query ; return this ; }
public more like this query builder min term freq ( int min term freq ) { this . min term freq = min term freq ; return this ; }
public more like this query builder analyzer ( string analyzer ) { this . analyzer = analyzer ; return this ; }
public inner hit builder inner hit ( ) { return inner hit builder ; }
public static match phrase prefix query builder match phrase prefix query ( string name , object text ) { return new match phrase prefix query builder ( name , text ) ; }
public static match phrase prefix query builder match phrase prefix query ( string name , object text ) { return new match phrase prefix query builder ( name , text ) ; }
public static term query builder term query ( string name , string . . . value ) { return new term query builder ( name , value ) ; }
public static exists query builder exists query ( string name ) { return new exists query builder ( name ) ; }
public final fb set weight ( float weight ) { this . weight = check weight ( weight ) ; return ( fb ) this ; }
public static function score query builder function score query ( query builder query builder , function score query builder . filter function builder [ ] filter function builder ) { return new function score query builder ( query builder , filter function builder ) ; }
public static geo shape query builder geo within query ( string name , geometry shape ) throw i o exception { geo shape query builder builder = geo shape query ( name , shape ) ; builder . relation ( shape relation . within ) ; return builder ; }
public match bool prefix query builder fuzziness ( object fuzziness ) { this . fuzziness = fuzziness . build ( fuzziness ) ; return this ; }
public similarity get search similarity ( ) { return similarity service ! = null ? similarity service . similarity ( this : : field type ) : null ; }
public parse document parse document ( source to parse source , map lookup map lookup ) throw mapper parse exception { validate type ( source , map lookup . get type ( ) ) ; final parse context . internal parse context context ; final x content type x content type = source . get x content type ( ) ; try ( x content parser parser = x content helper . create parser ( x content registry , log deprecation handler . instance , source . source ( ) , x content type ) ) { context = new parse context . internal parse context ( map lookup , index setting , index analyzer , date parser context , source , parser ) ; validate start ( parser ) ; metadata field mapper [ ] metadata field mapper = map lookup . get mapping ( ) . get sort metadata mapper ( ) ; internal parse document ( map lookup . get mapping ( ) . get root ( ) , metadata field mapper , context , parser ) ; validate end ( parser ) ; } catch ( exception e ) { throw wrap in mapper parsing exception ( source , e ) ; } string remain path = context . path ( ) . path a text ( `` `` ) ; if ( remain path . be empty ( ) == false ) { throw new illegal state exception ( `` find leftover path element : `` + remain path ) ; } context . post parse ( ) ; return parse document ( source , context , create dynamic update ( map lookup , context . get dynamic mapper ( ) , context . get dynamic runtime field ( ) ) ) ; }
public multi match query builder field ( string field ) { if ( string . be empty ( field ) ) { throw new illegal argument exception ( `` supply field be null or empty . `` ) ; } this . field boost . put ( field , abstract query builder . default_boost ) ; return this ; }
public combine field query builder field ( string field , float boost ) { if ( string . be empty ( field ) ) { throw new illegal argument exception ( `` supply field be null or empty . `` ) ; } validate field boost ( boost ) ; this . field and boost . put ( field , boost ) ; return this ; }
public string quote analyzer ( ) { return quote analyzer ; }
public simple query string builder analyze wildcard ( boolean analyze wildcard ) { this . setting . analyze wildcard ( analyze wildcard ) ; return this ; }
public time value get total time ( ) { return new time value ( total time in millis ) ; }
public time value get external total time ( ) { return new time value ( external total time in millis ) ; }
public time value get total time ( ) { return new time value ( total time in millis ) ; }
public time value get external total time ( ) { return new time value ( external total time in millis ) ; }
public self script ( script script ) { request . set script ( script ) ; return self ( ) ; }
public task info task info give subtask info ( string local node id , list < task info > slice info ) { if ( be leader ( ) == false ) { throw new illegal state exception ( `` this task be not set to be a leader of other slice subtasks `` ) ; } list < bulk by scroll task . status or exception > slice status = arrays . a list ( new bulk by scroll task . status or exception [ leader state . get slice ( ) ] ) ; for ( task info t : slice info ) { bulk by scroll task . status status = ( bulk by scroll task . status ) t . get status ( ) ; slice status . set ( status . get slice id ( ) , new bulk by scroll task . status or exception ( status ) ) ; } status status = leader state . get status ( slice status ) ; return task info ( local node id , get description ( ) , status ) ; }
public delete by query request set index option ( index option index option ) { get search request ( ) . index option ( index option ) ; return this ; }
public synchronize void update global checkpoint on replica ( final long new global checkpoint , final string reason ) { assert invariant ( ) ; assert primary mode == false ; / * * the global checkpoint here be a local knowledge which be update under the mandate of the primary . it can happen that the primary * information be lag compare to a replica ( e . g . , if a replica be promote to primary but have stale info relative to other * replica shard ) . in these case , the local knowledge of the global checkpoint could be high than the sync from the lag * primary . * / final long previous global checkpoint = global checkpoint ; if ( new global checkpoint > previous global checkpoint ) { global checkpoint = new global checkpoint ; logger . trace ( `` update global checkpoint from [ { } ] to [ { } ] due to [ { } ] `` , previous global checkpoint , global checkpoint , reason ) ; on global checkpoint update . accept ( global checkpoint ) ; } assert invariant ( ) ; }
public long version ( ) { return version ; }
public long total size ( ) { return total size ( index file ) ; }
public long total size ( ) { return total size ( index file ) ; }
public x content builder to x content ( x content builder builder , params params ) throw i o exception { builder . field ( name , snapshot ) ; builder . field ( index_version , index version ) ; builder . field ( start_time , start time ) ; builder . field ( time , time ) ; builder . field ( incremental_file_count , incremental file count ) ; builder . field ( incremental_size , incremental size ) ; builder . start array ( file ) ; for ( file info file info : index file ) { file info . to x content ( file info , builder , params ) ; } builder . end array ( ) ; return builder ; }
public x content builder to x content ( x content builder builder , params params ) throw i o exception { builder . field ( name , snapshot ) ; builder . field ( index_version , index version ) ; builder . field ( start_time , start time ) ; builder . field ( time , time ) ; builder . field ( incremental_file_count , incremental file count ) ; builder . field ( incremental_size , incremental size ) ; builder . start array ( file ) ; for ( file info file info : index file ) { file info . to x content ( file info , builder , params ) ; } builder . end array ( ) ; return builder ; }
protect boolean contains null and allow multiple null ( search row new row ) { mode mode = database . get mode ( ) ; if ( mode . unique index single null ) { return false ; } else if ( mode . unique index single null except all column be null ) { for ( int index : column id ) { value v = new row . get value ( index ) ; if ( v ! = value null . instance ) { return false ; } } return true ; } for ( int index : column id ) { value v = new row . get value ( index ) ; if ( v == value null . instance ) { return true ; } } return false ; }
public void create empty ( ) throw i o exception { version lucene version = index setting . get index version create ( ) . lucene version ; metadata lock . write lock ( ) . lock ( ) ; try ( index writer writer = new temporary empty index writer ( directory , lucene version ) ) { final map < string , string > map = new hash map < > ( ) ; map . put ( engine . history_uuid_key , u u i d . random base64 u u i d ( ) ) ; map . put ( sequence number . local_checkpoint_key , long . to string ( sequence number . no_ops_performed ) ) ; map . put ( sequence number . max_seq_no , long . to string ( sequence number . no_ops_performed ) ) ; map . put ( engine . max_unsafe_auto_id_timestamp_commit_id , `` -1 `` ) ; update commit data ( writer , map ) ; } finally { metadata lock . write lock ( ) . unlock ( ) ; } }
public location add ( final operation operation ) throw i o exception { final releasable byte stream output out = new releasable byte stream output ( big array ) ; try { final long start = out . position ( ) ; out . skip ( integer . byte ) ; write operation no size ( new buffer checksum stream output ( out ) , operation ) ; final long end = out . position ( ) ; final int operation size = ( int ) ( end - integer . bytes - start ) ; out . seek ( start ) ; out . write int ( operation size ) ; out . seek ( end ) ; final byte reference byte = out . byte ( ) ; try ( releasable lock ignore = read lock . acquire ( ) ) { ensure open ( ) ; if ( operation . primary term ( ) > current . get primary term ( ) ) { assert false : `` operation term be new than the current term ; `` + `` current term [ `` + current . get primary term ( ) + `` ] , operation term [ `` + operation + `` ] `` ; throw new illegal argument exception ( `` operation term be new than the current term ; `` + `` current term [ `` + current . get primary term ( ) + `` ] , operation term [ `` + operation + `` ] `` ) ; } return current . add ( byte , operation . seq no ( ) ) ; } } catch ( final already close exception | i o exception ex ) { close on tragic event ( ex ) ; throw ex ; } catch ( final exception ex ) { close on tragic event ( ex ) ; throw new translog exception ( shard id , `` fail to write operation [ `` + operation + `` ] `` , ex ) ; } finally { releasables . close ( out ) ; } }
public translog generation get min generation for seq no ( final long seq no ) { try ( releasable lock ignore = read lock . acquire ( ) ) { return new translog generation ( translog u u i d , min generation for seq no ( seq no , current , reader ) ) ; } }
public long total ( ) { return this . total ; }
public boolean cancel recovery ( long id , string reason ) { recovery target remove = on go recovery . remove ( id ) ; boolean cancel = false ; if ( remove ! = null ) { logger . trace ( `` { } cancel recovery from { } , id [ { } ] ( reason [ { } ] ) `` , remove . shard id ( ) , remove . source node ( ) , remove . recovery id ( ) , reason ) ; remove . cancel ( reason ) ; cancel = true ; } return cancel ; }
public boolean be system index back data stream ( string name ) { return system data stream index automaton . run ( name ) ; }
public delete pipeline request builder set id ( string id ) { request . set id ( id ) ; return this ; }
public update setting request setting ( setting setting ) { this . setting = setting ; return this ; }
public assignment get assignment ( params params , collection < discovery node > candidate node , cluster state cluster state ) { discovery node discovery node = select least loaded node ( cluster state , candidate node , discovery node : : can contain data ) ; if ( discovery node == null ) { return no_node_found ; } else { return new assignment ( discovery node . get id ( ) , `` `` ) ; } }
public list < string > get a list ( string key ) throw settings exception { return get a list ( key , collection . empty list ( ) ) ; }
public boolean assert all listener resolve ( ) { final discovery node local node = cluster service . local node ( ) ; assert end snapshot . be empty ( ) : `` find leaked end snapshots `` + end snapshots + `` on [ `` + local node + `` ] `` ; assert snapshot completion listener . be empty ( ) : `` find leaked snapshot completion listener `` + snapshot completion listener + `` on [ `` + local node + `` ] `` ; assert currently finalize . be empty ( ) : `` find leaked finalization `` + currently finalize + `` on [ `` + local node + `` ] `` ; assert snapshot deletion listener . be empty ( ) : `` find leaked snapshot delete listener `` + snapshot deletion listener + `` on [ `` + local node + `` ] `` ; assert repository operation . be empty ( ) : `` find leaked snapshot to finalize `` + repository operation + `` on [ `` + local node + `` ] `` ; return true ; }
public version get elasticsearch version ( ) { return elasticsearch version ; }
public boolean have native controller ( ) { return have native controller ; }
public input stream maybe rate limit restores ( input stream stream , rate limiting input stream . listener throttle listener ) { return maybe rate limit ( maybe rate limit ( stream , ( ) - > restore rate limiter , throttle listener ) , recovery setting : : rate limiter , throttle listener ) ; }
public get index response get ( get index request get index request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( get index request , indices request converter : : get index , option , get index response : : from x content , empty set ( ) ) ; }
public method method ( ) { return http request . method ( ) ; }
public final string path ( ) { return rest utils . decode component ( raw path ( ) ) ; }
protect boolean match uri request pattern ( final string pattern , final string path ) { if ( pattern . equal ( `` * `` ) ) { return true ; } else { return ( pattern . end with ( `` * `` ) & & path . start with ( pattern . substring ( 0 , pattern . length ( ) - 1 ) ) ) || ( pattern . start with ( `` * `` ) & & path . end with ( pattern . substring ( 1 , pattern . length ( ) ) ) ) ; } }
public list < string > get script stack ( ) { return script stack ; }
public list < string > get script stack ( ) { return script stack ; }
public long get doc count ( ) { if ( doc count < 0 ) { if ( reduce == null ) { doc count = 0 ; for ( b bucket : to reduce ) { doc count += bucket . get doc count ( ) ; } } else { doc count = reduce . get doc count ( ) ; } } return doc count ; }
public aggregator [ ] create top level aggregator ( ) throw i o exception { / * * top level aggs only collect from own bucket ord 0 which be * * exactly * what cardinality upper bound . one * mean * . * / return create sub aggregator ( null , cardinality upper bound . one ) ; }
public filter aggregation builder other bucket key ( string other bucket key ) { if ( other bucket key == null ) { throw new illegal argument exception ( `` [ other bucket key ] must not be null : [ `` + name + `` ] `` ) ; } this . other bucket key = other bucket key ; return this ; }
public void set deferred collector ( iterable < bucket collector > defer collector ) { this . collector = multi bucket collector . wrap ( true , deferred collector ) ; }
public boolean equal ( object o ) { if ( this == o ) return true ; if ( o == null || get class ( ) ! = o . get class ( ) ) return false ; slot slot = ( slot ) o ; return composite value collector queue . this . equal ( value , slot . value ) ; }
public void remove super ( session session ) { super . remove ( session , false ) ; }
public date histogram interval date histogram interval ( ) { return date histogram interval . date histogram interval ( ) ; }
public date histogram aggregation builder offset ( long offset ) { this . offset = offset ; return this ; }
public int max doc per value ( ) { return max doc per value ; }
public significant term aggregation builder shard min doc count ( long shard min doc count ) { if ( shard min doc count < 0 ) { throw new illegal argument exception ( `` [ shard min doc count ] must be great than or equal to 0 . find [ `` + shard min doc count + `` ] in [ `` + name + `` ] `` ) ; } bucket count threshold . set shard min doc count ( shard min doc count ) ; return this ; }
public significant term aggregation builder size ( int size ) { if ( size < = 0 ) { throw new illegal argument exception ( `` [ size ] must be great than 0 . find [ `` + size + `` ] in [ `` + name + `` ] `` ) ; } bucket count threshold . set require size ( size ) ; return this ; }
public rare term aggregation builder include exclude ( include exclude include exclude ) { this . include exclude = include exclude ; return this ; }
public object get property ( string path ) { aggregation path agg path = aggregation path . parse ( path ) ; return get property ( agg path . get path element a string list ( ) ) ; }
public t compression ( double compression ) { if ( percentile config == null || percentile config . get method ( ) . equal ( percentile method . tdigest ) ) { percentile config = new percentile config . t digest ( compression ) ; } else { throw new illegal argument exception ( `` can not set [ compression ] because the method have already be configure for h d r histogram `` ) ; } return ( t ) this ; }
public double value ( ) { return value ; }
public compensate sum add ( double value ) { return add ( value , no_correction ) ; }
public static long big array size ( final long expect , final float f ) { return next power of two ( ( long ) math . ceil ( expect / f ) ) ; }
public double value ( ) { return value ; }
public list < field and format > doc value field ( ) { return doc value field ; }
public boolean version ( ) { return version ; }
public static byte reference child byte ( x content parser parser ) throw i o exception { if ( parser . current token ( ) ! = x content parser . token . start_object ) { if ( parser . next token ( ) ! = x content parser . token . start_object ) { throw new x content parse exception ( parser . get token location ( ) , `` expect [ start_object ] but get [ `` + parser . current token ( ) + `` ] `` ) ; } } x content builder builder = x content builder . builder ( parser . content type ( ) . x content ( ) ) ; builder . copy current structure ( parser ) ; return byte reference . byte ( builder ) ; }
public mov avg pipeline aggregation builder predict ( int predict ) { if ( predict < = 0 ) { throw new illegal argument exception ( `` predict must be great than 0 . find [ `` + predict + `` ] in [ `` + name + `` ] `` ) ; } this . predict = predict ; return this ; }
public void remove super ( session session ) { super . remove ( session , false ) ; }
public top hit aggregation builder script field ( string name , script script ) { if ( name == null ) { throw new illegal argument exception ( `` script field [ name ] must not be null : [ `` + name + `` ] `` ) ; } if ( script == null ) { throw new illegal argument exception ( `` script field [ script ] must not be null : [ `` + name + `` ] `` ) ; } script field ( name , script , false ) ; return this ; }
public search source builder post filter ( query builder post filter ) { this . post query builder = post filter ; return this ; }
public query builder query ( ) { return query builder ; }
public search source builder store field ( list < string > field ) { if ( store field context == null ) { store field context = store field context . from list ( field ) ; } else { stored field context . add field name ( field ) ; } return this ; }
public fetch field context fetch field context ( ) { return search context . fetch field context ( ) ; }
public hb order ( string order ) { return order ( order . from string ( order ) ) ; }
public void put in context ( string key , object value ) { if ( context == null ) { context = new hash map < > ( ) ; } context . put ( key , value ) ; }
public x content builder raw value ( input stream stream , x content type content type ) throw i o exception { generator . write raw value ( stream , content type ) ; return this ; }
public static profile shard result build shard result ( profilers profilers ) { list < query profiler > query profilers = profilers . get query profilers ( ) ; aggregation profiler agg profiler = profilers . get aggregation profiler ( ) ; list < query profile shard result > query result = new array list < > ( query profilers . size ( ) ) ; for ( query profiler query profiler : query profilers ) { query profile shard result result = new query profile shard result ( query profiler . get tree ( ) , query profiler . get rewrite time ( ) , query profiler . get collector ( ) ) ; query result . add ( result ) ; } aggregation profile shard result agg result = new aggregation profile shard result ( agg profiler . get tree ( ) ) ; return new profile shard result ( query result , agg result ) ; }
public static profile shard result build shard result ( profilers profilers ) { list < query profiler > query profilers = profilers . get query profilers ( ) ; aggregation profiler agg profiler = profilers . get aggregation profiler ( ) ; list < query profile shard result > query result = new array list < > ( query profilers . size ( ) ) ; for ( query profiler query profiler : query profilers ) { query profile shard result result = new query profile shard result ( query profiler . get tree ( ) , query profiler . get rewrite time ( ) , query profiler . get collector ( ) ) ; query result . add ( result ) ; } aggregation profile shard result agg result = new aggregation profile shard result ( agg profiler . get tree ( ) ) ; return new profile shard result ( query result , agg result ) ; }
public void profile result ( profile shard result shard result ) { this . profile shard result = shard result ; have profile result = shard result ! = null ; }
public boolean have aggs ( ) { return have aggs ; }
public list < rescore context > rescore ( ) { return search context . rescore ( ) ; }
public cluster search shard request builder set index option ( index option index option ) { request ( ) . index option ( index option ) ; return this ; }
public geo distance sort builder set nest path ( string nest path ) { if ( this . nested sort ! = null ) { throw new illegal argument exception ( `` set both nested_path/nested_filter and nest not allow `` ) ; } this . nested path = nested path ; return this ; }
public script script ( ) { return this . script ; }
public direct candidate generator builder accuracy ( float accuracy ) { this . accuracy = accuracy ; return this ; }
public direct candidate generator builder max inspection ( integer max inspection ) { this . max inspection = max inspection ; return this ; }
public direct candidate generator builder min doc freq ( float min doc freq ) { this . min doc freq = min doc freq ; return this ; }
public phrase suggestion builder real word error likelihood ( float real word error likelihood ) { if ( real word error likelihood < = 0 . 0 ) { throw new illegal argument exception ( `` real_word_error_likelihood must be > 0 . 0 `` ) ; } this . real word error likelihood = real word error likelihood ; return this ; }
public string get global text ( ) { return global text ; }
public term suggestion builder max edits ( int max edits ) { if ( max edit < 1 || max edit > 2 ) { throw new illegal argument exception ( `` max edits must be between 1 and 2 `` ) ; } this . max edits = max edits ; return this ; }
public static set < index > restore index ( final cluster state current state , final set < index > index to check ) { final set < index > indices = new hash set < > ( ) ; for ( restore in progress . entry entry : current state . custom ( restore in progress . type , restore in progress . empty ) ) { for ( object object cursor < shard id , restore in progress . shard restore status > shard : entry . shard ( ) ) { index index = shard . key . get index ( ) ; if ( index to check . contains ( index ) & & shard . value . state ( ) . complete ( ) == false & & current state . get metadata ( ) . index ( index ) ! = null ) { index . add ( index ) ; } } } return index ; }
public void remove ban ( task id parent task id ) { logger . trace ( `` remove ban for the parent task { } `` , parent task id ) ; ban parent . remove ( parent task id ) ; }
public void write byte reference ( @ nullable byte reference byte ) throw i o exception { if ( bytes == null ) { write v int ( 0 ) ; return ; } write v int ( byte . length ( ) ) ; byte . write to ( this ) ; }
public transport . connection get connection ( discovery node node ) { transport . connection connection = connect node . get ( node ) ; if ( connection == null ) { throw new node not connect exception ( node , `` node not connect `` ) ; } return connection ; }
public boolean handle ( string command line ) { return command . length ( ) + 1 < command line . length ( ) & & command line . char at ( command . length ( ) ) == ' ' & & command line . start with ( command ) ; }
public static void register proxy action ( transport service service , string action , boolean cancellable , writeable . reader < ? extend transport response > reader ) { request handler registry < ? extend transport request > request handler = service . get request handler ( action ) ; service . register request handler ( get proxy action ( action ) , thread pool . name . same , true , false , in - > cancellable ? new cancellable proxy request < > ( in , request handler : : new request ) : new proxy request < > ( in , request handler : : new request ) , new proxy request handler < > ( service , action , request - > reader ) ) ; }
public static void register proxy action ( transport service service , string action , boolean cancellable , writeable . reader < ? extend transport response > reader ) { request handler registry < ? extend transport request > request handler = service . get request handler ( action ) ; service . register request handler ( get proxy action ( action ) , thread pool . name . same , true , false , in - > cancellable ? new cancellable proxy request < > ( in , request handler : : new request ) : new proxy request < > ( in , request handler : : new request ) , new proxy request handler < > ( service , action , request - > reader ) ) ; }
public static string unwrap action ( string action ) { assert be proxy action ( action ) : `` attempt to unwrap non-proxy action : `` + action ; return action . substring ( proxy_action_prefix . length ( ) ) ; }
public transport . connection get connection ( @ nullable string cluster alias , discovery node node ) { if ( cluster alias == null ) { return transport service . get connection ( node ) ; } else { return transport service . get remote cluster service ( ) . get connection ( node , cluster alias ) ; } }
public void open connection ( final discovery node node , connection profile connection profile , action listener < transport . connection > listener ) { if ( be local node ( node ) ) { listener . on response ( local node connection ) ; } else { connection manager . open connection ( node , connection profile , listener ) ; } }
protected list < listener > listener ( ) { return listener ; }
protected list < listener > listener ( ) { return listener ; }
protect void set closure delegate ( closure closure , object node ) { closure . set delegate ( this ) ; }
public static string translate ( string str , string search char , string replace char ) { if ( string utils . be empty ( str ) ) { return str ; } string buffer buffer = new string buffer ( str . length ( ) ) ; char [ ] chrs = str . to char array ( ) ; char [ ] with chrs = replace char . to char array ( ) ; int sz = chrs . length ; int with max = replace char . length ( ) - 1 ; for ( int i=0 ; i < sz ; i++ ) { int idx = search char . index of ( chrs [ i ] ) ; if ( idx ! = -1 ) { if ( idx > with max ) { idx = with max ; } buffer . append ( with chrs [ idx ] ) ; } else { buffer . append ( chrs [ i ] ) ; } } return buffer . to string ( ) ; }
public synchronize boolean equal ( object o ) { ensure not close ( ) ; if ( this == o ) return true ; if ( o == null || o instanceof char sequence == false ) return false ; char sequence that = ( char sequence ) o ; if ( char . length ! = that . length ( ) ) { return false ; } int equal = 0 ; for ( int i = 0 ; i < char . length ; i++ ) { equal |= char [ i ] ^ that . char at ( i ) ; } return equal == 0 ; }
public static socket option < integer > get tcp keep interval socket option or null ( ) { return get extend socket option or null ( `` tcp_keepinterval `` ) ; }
public static < t > observable < t > merge ( observable < ? extend t > t1 , observable < ? extend t > t2 , observable < ? extend t > t3 , observable < ? extend t > t4 , observable < ? extend t > t5 , observable < ? extend t > t6 , observable < ? extend t > t7 , observable < ? extend t > t8 ) { return merge ( new observable [ ] { t1 , t2 , t3 , t4 , t5 , t6 , t7 , t8 } ) ; }
public static path get ( path [ ] root , string path ) { for ( path root : root ) { path normalize root = root . normalize ( ) ; path normalized path = normalize root . resolve ( path ) . normalize ( ) ; if ( normalized path . start with ( normalized root ) ) { return normalize path ; } } return null ; }
public static void ensure nodes compatibility ( version join node version , version min cluster node version , version max cluster node version ) { assert min cluster node version . on or before ( max cluster node version ) : min cluster node version + `` > `` + max cluster node version ; if ( join node version . be compatible ( max cluster node version ) == false ) { throw new illegal state exception ( `` node version [ `` + joining node version + `` ] be not support . `` + `` the cluster contain node with version [ `` + max cluster node version + `` ] , which be incompatible . `` ) ; } if ( join node version . be compatible ( min cluster node version ) == false ) { throw new illegal state exception ( `` node version [ `` + joining node version + `` ] be not support . `` + `` the cluster contain node with version [ `` + min cluster node version + `` ] , which be incompatible . `` ) ; } }
public static long deinterleave ( long b ) { b & = magic [ 0 ] ; b = ( b ^ ( b > > > shift [ 0 ] ) ) & magic [ 1 ] ; b = ( b ^ ( b > > > shift [ 1 ] ) ) & magic [ 2 ] ; b = ( b ^ ( b > > > shift [ 2 ] ) ) & magic [ 3 ] ; b = ( b ^ ( b > > > shift [ 3 ] ) ) & magic [ 4 ] ; b = ( b ^ ( b > > > shift [ 4 ] ) ) & magic [ 5 ] ; return b ; }
public static final double decode latitude ( final string geohash ) { return decode latitude ( geohash . morton encode ( geohash ) ) ; }
public static final double decode latitude ( final string geohash ) { return decode latitude ( geohash . morton encode ( geohash ) ) ; }
public static double lon width in degree ( int precision ) { return precision to lon width [ precision ] ; }
public http host get host ( ) { return host ; }
public void perform request async ( string method , string endpoint , response listener response listener , header . . . header ) { perform request async ( method , endpoint , collection . < string , string > empty map ( ) , null , response listener , header ) ; }
public request config get request config ( ) { return request config ; }
public int get max length ( ) { return max length ; }
public string [ ] get index ( ) { return this . search request . index ( ) ; }
public integer get batch reduce size ( ) { return this . batch reduce size ; }
public string [ ] get index ( ) { return this . search request . index ( ) ; }
public cancellable delete async ( delete async search request request , request option option , action listener < acknowledge response > listener ) { return rest high level client . perform request async and parse entity ( request , async search request converter : : delete async search , option , acknowledge response : : from x content , listener , empty set ( ) ) ; }
public cancellable delete async ( delete async search request request , request option option , action listener < acknowledge response > listener ) { return rest high level client . perform request async and parse entity ( request , async search request converter : : delete async search , option , acknowledge response : : from x content , listener , empty set ( ) ) ; }
public acknowledge response pause auto follow pattern ( pause auto follow pattern request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , ccr request converter : : pause auto follow pattern , option , acknowledge response : : from x content , collection . empty set ( ) ) ; }
public cancellable put component template async ( put component template request put component template request , request option option , action listener < acknowledge response > listener ) { return rest high level client . perform request async and parse entity ( put component template request , cluster request converter : : put component template , option , acknowledge response : : from x content , listener , empty set ( ) ) ; }
public acknowledge response delete component template ( delete component template request req , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( req , cluster request converter : : delete component template , option , acknowledge response : : from x content , empty set ( ) ) ; }
public cancellable get component template async ( get component template request get component template request , request option option , action listener < get component template response > listener ) { return rest high level client . perform request async and parse entity ( get component template request , cluster request converter : : get component template , option , get component template response : : from x content , listener , empty set ( ) ) ; }
public default shard operation fail exception [ ] get shard failure ( ) { return shard failure ; }
public long get bucket count ( ) { return bucket count ; }
public long get doc version ( ) { return doc version ; }
public get source response get source ( get source request get source request , request option option ) throw i o exception { return perform request and parse entity ( get source request , request converter : : get source , option , get source response : : from x content , empty set ( ) ) ; }
public cancellable delete lifecycle policy async ( delete lifecycle policy request request , request option option , action listener < acknowledge response > listener ) { return rest high level client . perform request async and parse entity ( request , index lifecycle request converter : : delete lifecycle policy , option , acknowledge response : : from x content , listener , empty set ( ) ) ; }
public explain lifecycle response explain lifecycle ( explain lifecycle request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , index lifecycle request converter : : explain lifecycle , option , explain lifecycle response : : from x content , empty set ( ) ) ; }
public acknowledge response retry lifecycle policy ( retry lifecycle policy request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , index lifecycle request converter : : retry lifecycle , option , acknowledge response : : from x content , empty set ( ) ) ; }
public cancellable lifecycle management status async ( lifecycle management status request request , request option option , action listener < lifecycle management status response > listener ) { return rest high level client . perform request async and parse entity ( request , index lifecycle request converter : : lifecycle management status , option , lifecycle management status response : : from x content , listener , empty set ( ) ) ; }
public static analyze request with field ( string index , string field , string . . . text ) { return new analyze request ( index , null , null , field , text ) ; }
public active shard count get wait for active shard ( ) { return wait for active shard ; }
public put component template request component template ( component template component template ) { this . component template = component template ; return this ; }
public put composable index template request index template v2 request ( ) { return index template v2 request ; }
public simulate index template request index name ( string index name ) { if ( string . be null or empty ( index name ) ) { throw new illegal argument exception ( `` index name can not be null or empty `` ) ; } this . index name = index name ; return this ; }
public active shard count get wait for active shard ( ) { return wait for active shard ; }
public cancellable delete data stream async ( delete data stream request delete data stream request , request option option , action listener < acknowledge response > listener ) { return rest high level client . perform request async and parse entity ( delete data stream request , indices request converter : : delete data stream , option , acknowledge response : : from x content , listener , empty set ( ) ) ; }
public boolean exist alias ( get aliases request get aliases request , request option option ) throw i o exception { return rest high level client . perform request ( get aliases request , indices request converter : : exists alias , option , rest high level client : : convert exist response , empty set ( ) ) ; }
public flush response flush ( flush request flush request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( flush request , indices request converter : : flush , option , flush response : : from x content , empty set ( ) ) ; }
public cancellable put template async ( put index template request put index template request , request option option , action listener < acknowledge response > listener ) { return rest high level client . perform request async and parse entity ( put index template request , indices request converter : : put template , option , acknowledge response : : from x content , listener , empty set ( ) ) ; }
public close index response close ( close index request close index request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( close index request , indices request converter : : close index , option , close index response : : from x content , empty set ( ) ) ; }
public cancellable put job async ( put job request request , request option option , action listener < put job response > listener ) { return rest high level client . perform request async and parse entity ( request , m l request converter : : put job , option , put job response : : from x content , listener , collection . empty set ( ) ) ; }
public put job response put job ( put job request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : put job , option , put job response : : from x content , collection . empty set ( ) ) ; }
public cancellable get calendar async ( get calendar request request , request option option , action listener < get calendar response > listener ) { return rest high level client . perform request async and parse entity ( request , m l request converter : : get calendar , option , get calendar response : : from x content , listener , collection . empty set ( ) ) ; }
public post calendar event response post calendar event ( post calendar event request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : post calendar event , option , post calendar event response : : from x content , collection . empty set ( ) ) ; }
public acknowledge response delete datafeed ( delete datafeed request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : delete datafeed , option , acknowledge response : : from x content , collection . empty set ( ) ) ; }
public put filter response put filter ( put filter request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : put filter , option , put filter response : : from x content , collection . empty set ( ) ) ; }
public acknowledge response delete train model ( delete train model request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : delete train model , option , acknowledge response : : from x content , collection . empty set ( ) ) ; }
public put data frame analytics response put data frame analytics ( put data frame analytics request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : put data frame analytics , option , put data frame analytics response : : from x content , collection . empty set ( ) ) ; }
public put data frame analytics response put data frame analytics ( put data frame analytics request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : put data frame analytics , option , put data frame analytics response : : from x content , collection . empty set ( ) ) ; }
public cancellable start data frame analytics async ( start data frame analytics request request , request option option , action listener < start data frame analytics response > listener ) { return rest high level client . perform request async and parse entity ( request , m l request converter : : start data frame analytics , option , start data frame analytics response : : from x content , listener , collection . empty set ( ) ) ; }
public put data frame analytics response put data frame analytics ( put data frame analytics request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : put data frame analytics , option , put data frame analytics response : : from x content , collection . empty set ( ) ) ; }
public cancellable get data frame analytics async ( get data frame analytics request request , request option option , action listener < get data frame analytics response > listener ) { return rest high level client . perform request async and parse entity ( request , m l request converter : : get data frame analytics , option , get data frame analytics response : : from x content , listener , collection . empty set ( ) ) ; }
public static delay data check config enable delay data check config ( time value time value ) { return new delay data check config ( true , time value ) ; }
public void set force ( boolean force ) { this . force = force ; }
public date get last finalized bucket end ( ) { return last finalize bucket end ; }
public long get forecast job ( ) { return forecast job ; }
public void set overall score ( double overall score ) { this . overall score = overall score ; }
public list < bucket > bucket ( ) { return result ; }
public void set filter id ( string filter id ) { this . filter id = filter id ; }
public get train model request set exclude generate ( boolean exclude generate ) { this . exclude generate = exclude generate ; return this ; }
public list < transport address > transport address ( ) { return node service . transport address ( ) ; }
public void set job id ( string job id ) { this . job id = object . require non null ( job id , `` [ job_id ] must not be null `` ) ; }
public void set job id ( string job id ) { this . job id = object . require non null ( job id , `` [ job_id ] must not be null `` ) ; }
public list < string > get datafeed id ( ) { return datafeed id ; }
public boolean be stop ( ) { return stop ; }
public void set remove item ( collection < string > remove item ) { this . remove item = new tree set < > ( object . require non null ( remove item , `` [ `` + remove_items . get preferred name ( ) + `` ] must not be null `` ) ) ; }
public final rest client get low level client ( ) { return client ; }
public final rest client get low level client ( ) { return client ; }
public final bulk by scroll response update by query ( update by query request update by query request , request option option ) throw i o exception { return perform request and parse entity ( update by query request , request converter : : update by query , option , bulk by scroll response : : from x content , singleton ( 409 ) ) ; }
public final cancellable get async ( get request get request , request option option , action listener < get response > listener ) { return perform request async and parse entity ( get request , request converter : : get , option , get response : : from x content , listener , singleton ( 404 ) ) ; }
public final cancellable update async ( update request update request , request option option , action listener < update response > listener ) { return perform request async and parse entity ( update request , request converter : : update , option , update response : : from x content , listener , empty set ( ) ) ; }
public final cancellable get async ( get request get request , request option option , action listener < get response > listener ) { return perform request async and parse entity ( get request , request converter : : get , option , get response : : from x content , listener , singleton ( 404 ) ) ; }
public final term vector response termvectors ( term vector request request , request option option ) throw i o exception { return perform request and parse entity ( request , request converter : : term vector , option , term vector response : : from x content , empty set ( ) ) ; }
public string get username ( ) { return username ; }
public static get api key request use user name ( string user name ) { return new get api key request ( null , user name , null , null , false ) ; }
public static invalidate api key request use realm and user name ( string realm name , string user name ) { return new invalidate api key request ( realm name , user name , null , false , null ) ; }
public string get username ( ) { return username ; }
public set < string > get index ( ) { return this . index ; }
public delete privilege response delete privilege ( delete privilege request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , security request converter : : delete privilege , option , delete privilege response : : from x content , singleton ( 404 ) ) ; }
public cancellable disable user async ( disable user request request , request option option , action listener < boolean > listener ) { return rest high level client . perform request async ( request , security request converter : : disable user , option , rest high level client : : convert exist response , listener , empty set ( ) ) ; }
public cancellable authenticate async ( request option option , action listener < authenticate response > listener ) { return rest high level client . perform request async and parse entity ( authenticate request . instance , authenticate request : : get request , option , authenticate response : : from x content , listener , empty set ( ) ) ; }
public cancellable clear privilege cache async ( clear privilege cache request request , request option option , action listener < clear privilege cache response > listener ) { return rest high level client . perform request async and parse entity ( request , security request converter : : clear privilege cache , option , clear privilege cache response : : from x content , listener , empty set ( ) ) ; }
public get ssl certificate response get ssl certificate ( request option option ) throw i o exception { return rest high level client . perform request and parse entity ( get ssl certificate request . instance , get ssl certificate request : : get request , option , get ssl certificate response : : from x content , empty set ( ) ) ; }
public cancellable create api key async ( final create api key request request , final request option option , final action listener < create api key response > listener ) { return rest high level client . perform request async and parse entity ( request , security request converter : : create api key , option , create api key response : : from x content , listener , empty set ( ) ) ; }
public invalidate api key response invalidate api key ( final invalidate api key request request , final request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , security request converter : : invalidate api key , option , invalidate api key response : : from x content , empty set ( ) ) ; }
public acknowledge response delete repository ( delete repository request delete repository request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( delete repository request , snapshot request converter : : delete repository , option , acknowledge response : : from x content , empty set ( ) ) ; }
public cancellable cleanup repository async ( cleanup repository request cleanup repository request , request option option , action listener < cleanup repository response > listener ) { return rest high level client . perform request async and parse entity ( cleanup repository request , snapshot request converter : : cleanup repository , option , cleanup repository response : : from x content , listener , empty set ( ) ) ; }
public cancellable status async ( snapshots status request snapshot status request , request option option , action listener < snapshot status response > listener ) { return rest high level client . perform request async and parse entity ( snapshots status request , snapshot request converter : : snapshot status , option , snapshot status response : : from x content , listener , empty set ( ) ) ; }
public snapshot status response status ( snapshots status request snapshot status request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( snapshots status request , snapshot request converter : : snapshot status , option , snapshot status response : : from x content , empty set ( ) ) ; }
public find structure response find structure ( find structure request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , text structure request converter : : find file structure , option , find structure response : : from x content , collection . empty set ( ) ) ; }
public get transform stats response get transform stats ( get transform stats request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , transform request converter : : get transform stats , option , get transform stats response : : from x content , collection . empty set ( ) ) ; }
public long if seq no ( ) { return if seq no ; }
public deactivate watch response deactivate watch ( deactivate watch request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , watcher request converter : : deactivate watch , option , deactivate watch response : : from x content , empty set ( ) ) ; }
public cancellable delete watch async ( delete watch request request , request option option , action listener < delete watch response > listener ) { return rest high level client . perform request async and parse entity ( request , watcher request converter : : delete watch , option , delete watch response : : from x content , listener , singleton ( 404 ) ) ; }
public ack watch response ack watch ( ack watch request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , watcher request converter : : ack watch , option , ack watch response : : from x content , empty set ( ) ) ; }
public x pack usage response usage ( x pack usage request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , x pack request converter : : usage , option , x pack usage response : : from x content , empty set ( ) ) ; }
public x content builder raw value ( input stream stream , x content type content type ) throw i o exception { generator . write raw value ( stream , content type ) ; return this ; }
public x content builder raw field ( string name , input stream value ) throw i o exception { generator . write raw field ( name , value ) ; return this ; }
public operator get operator ( ) { return operator ; }
public string get name ( ) { return name ; }
public boolean be valid ( ) { return valid ; }
public final expect builder with echo input ( appendable first input , appendable . . . other input ) { this . echo input = first input ; this . echo input = other input ; return this ; }
public final expect builder with echo input ( appendable first input , appendable . . . other input ) { this . echo input = first input ; this . echo input = other input ; return this ; }
public final expect builder with input filter ( filter filter , filter . . . more filter ) { if ( more filter . length == 0 ) { this . filter = filter ; } else { filter [ ] filter = new filter [ more filter . length + 1 ] ; filter [ 0 ] = filter ; system . arraycopy ( more filter , 0 , filter , 1 , more filter . length ) ; this . filter = filter . chain ( filter ) ; } return this ; }
public static result failure ( string input , boolean can stop matching ) { return new simple result ( false , input , null , null , can stop matching ) ; }
public duration get elapsed time ( ) { return new duration ( system . nano time ( ) - start time . to nanos ( ) , time unit . nanosecond ) ; }
public boolean retry ( ) { assert . state ( ! retry call , `` retry have already be call `` ) ; retry call = true ; return complete or retry ( last result , last failure ) ; }
public boolean retry ( ) { assert . state ( ! retry call , `` retry have already be call `` ) ; retry call = true ; return complete or retry ( last result , last failure ) ; }
public synchronize int set next ( boolean value ) { int previous value = -1 ; if ( occupied bit < size ) occupy bits++ ; else previous value = bit set . get ( next index ) ? 1 : 0 ; bit set . set ( next index , value ) ; next index = index after ( next index ) ; if ( value ) { if ( previous value ! = 1 ) positives++ ; if ( previous value == 0 ) negative -- ; } else { if ( previous value ! = 0 ) negatives++ ; if ( previous value == 1 ) positive -- ; } return previous value ; }
public duration get max delay ( ) { return max delay ; }
public long to millis ( ) { return time unit . to millis ( length ) ; }
public int get line number ( ) { return _line ; }
public list get entity ( ) { return _entities ; }
public namespace context get namespace context ( ) { return _context ; }
public string get system id ( ) { return _system id ; }
public string get name ( ) { return _entity name ; }
public final char array [ ] get array ( ) { if ( _array == null ) return null ; final char array [ ] clone array = new char array [ _array . length ] ; system . arraycopy ( _array , 0 , clone array , 0 , _array . length ) ; return clone array ; }
public void add attribute with build in algorithm data ( string uri , string local name , string q name , int build in algorithm i d , object algorithm data ) { if ( _length > = _algorithm data . length ) { resize ( ) ; } int i = _length * size ; _data [ i++ ] = replace null ( uri ) ; _data [ i++ ] = replace null ( local name ) ; _data [ i++ ] = replace null ( q name ) ; _data [ i++ ] = `` cdata `` ; _data [ i++ ] = `` `` ; _data [ i++ ] = null ; _algorithm id [ _length ] = build in algorithm i d ; _algorithm data [ _length ] = algorithm data ; _to index [ _length ] = false ; _alphabets [ _length ] = null ; _length++ ; }
public static void store booleans ( final boolean array [ ] , final int offset , final int length , final char sequence filename ) throw i o exception { store booleans ( array , offset , length , new file ( filename . to string ( ) ) ) ; }
public static void ensure from to ( final long big array length , final long from , final long to ) { if ( from < 0 ) throw new array index out of bound exception ( `` start index ( `` + from + `` ) be negative `` ) ; if ( from > to ) throw new illegal argument exception ( `` start index ( `` + from + `` ) be great than end index ( `` + to + `` ) `` ) ; if ( to > big array length ) throw new array index out of bound exception ( `` end index ( `` + to + `` ) be great than big-array length ( `` + big array length + `` ) `` ) ; }
public static boolean [ ] [ ] shuffle ( final boolean [ ] [ ] a , final random random ) { for ( long i = length ( a ) ; i -- ! = 0 ; ) { final long p = ( random . next long ( ) & 0x7 f f f f f f f f f f f f f f f l ) % ( i + 1 ) ; final boolean t = get ( a , i ) ; set ( a , i , get ( a , p ) ) ; set ( a , p , t ) ; } return a ; }
public boolean equal ( final boolean big array big list l ) { if ( l == this ) return true ; long s = size64 ( ) ; if ( s ! = l . size64 ( ) ) return false ; final boolean [ ] [ ] a1 = a ; final boolean [ ] [ ] a2 = l . a ; while ( s -- ! = 0 ) if ( boolean big array . get ( a1 , s ) ! = boolean big array . get ( a2 , s ) ) return false ; return true ; }
public static boolean [ ] grow ( final boolean [ ] array , final int length , final int preserve ) { if ( length > array . length ) { final int new length = ( int ) math . max ( math . min ( 2l * array . length , array . max_array_size ) , length ) ; final boolean t [ ] = new boolean [ new length ] ; system . arraycopy ( array , 0 , t , 0 , preserve ) ; return t ; } return array ; }
public static void ensure offset length ( final boolean [ ] a , final int offset , final int length ) { array . ensure offset length ( a . length , offset , length ) ; }
public static void parallel quick sort ( final boolean [ ] x , final boolean comparator comp ) { parallel quick sort ( x , 0 , x . length , comp ) ; }
public static void quick sort ( final boolean [ ] x , final boolean [ ] y ) { ensure same length ( x , y ) ; quick sort ( x , y , 0 , x . length ) ; }
public static void copy from big ( final byte [ ] [ ] src array , final long src po , final byte [ ] d array , int d po , int length ) { int src segment = segment ( src po ) ; int src displ = displacement ( src po ) ; int l ; while ( length > 0 ) { l = math . min ( src array [ src segment ] . length - src displ , length ) ; system . arraycopy ( src array [ src segment ] , src displ , d array , d po , l ) ; if ( ( src displ += l ) == segment_size ) { src displ = 0 ; src segment++ ; } d pos += l ; length -= l ; } }
public static void ensure offset length ( final boolean [ ] [ ] a , final long offset , final long length ) { big array . ensure offset length ( length ( a ) , offset , length ) ; }
public static boolean big list iterator a big list iterator ( final boolean list iterator i ) { return new big list iterator list iterator ( i ) ; }
public static boolean big list iterator singleton ( final boolean element ) { return new singleton big list iterator ( element ) ; }
public static byte2 boolean function synchronize ( final byte2 boolean function f , final object sync ) { return new synchronize function ( f , sync ) ; }
public void clear ( ) { if ( size == 0 ) return ; size = 0 ; contains null key = false ; array . fill ( key , ( ( byte ) 0 ) ) ; first = last = -1 ; }
public int compare ( byte ok1 , byte ok2 ) { return store comparator . compare ( ok1 , ok2 ) ; }
public int get ( final int index , final byte [ ] a , final int offset , final int length ) { ensure restrict index ( index ) ; byte array . ensure offset length ( a , offset , length ) ; final int array length = extract ( index , a , offset , length ) ; if ( length > = array length ) return array length ; return length - array length ; }
protect void ensure element ( final int index ) { if ( index < 0 ) throw new index out of bound exception ( `` index ( `` + index + `` ) be negative `` ) ; if ( index > = ref array . length ) throw new index out of bound exception ( `` index ( `` + index + `` ) be large than or equal to reference array size ( `` + ref array . length + `` ) `` ) ; }
public static int binary search ( final byte [ ] a , final byte key ) { return binary search ( a , 0 , a . length , key ) ; }
public static void radix sort indirect ( final int [ ] perm , final byte [ ] a , final byte [ ] b , final boolean stable ) { ensure same length ( a , b ) ; radix sort indirect ( perm , a , b , 0 , a . length , stable ) ; }
public static void radix sort ( final byte [ ] a , final byte [ ] b ) { ensure same length ( a , b ) ; radix sort ( a , b , 0 , a . length ) ; }
public static void radix sort ( final byte [ ] [ ] a , final byte [ ] [ ] b ) { radix sort ( a , b , 0 , byte big array . length ( a ) ) ; }
public static byte sort set singleton ( final byte element ) { return new singleton ( element ) ; }
public static byte priority queue synchronize ( final byte priority queue q ) { return new synchronize priority queue ( q ) ; }
public static int mix32 ( int k ) { k = ( k ^ ( k > > > 16 ) ) * 0x85ebca6b ; k = ( k ^ ( k > > > 13 ) ) * 0xc2b2ae35 ; return k ^ ( k > > > 16 ) ; }
public static < k > indirect double priority queue < k > synchronize ( final indirect double priority queue < k > q ) { return new synchronize indirect double priority queue < k > ( q ) ; }
public static int load booleans ( final data input data input , final boolean [ ] array , final int offset , final int length ) throw i o exception { it . unimi . dsi . fastutil . booleans . boolean array . ensure offset length ( array , offset , length ) ; int i = 0 ; try { for ( i = 0 ; i < length ; i++ ) array [ i + offset ] = data input . read boolean ( ) ; } catch ( e o f exception it ok ) { } return i ; }
public int read ( final byte b [ ] , final int offset , final int length ) { if ( this . length == this . position ) return length == 0 ? 0 : -1 ; final int n = math . min ( length , this . length - this . position ) ; system . arraycopy ( array , this . offset + this . position , b , offset , n ) ; this . position += n ; return n ; }
public static void write boolean array ( boolean [ ] a , data output stream s ) throw i o exception { int len = a . length ; s . write int ( len ) ; for ( int i = 0 ; i < len ; i++ ) { s . write boolean ( a [ i ] ) ; } }
public int get ( final int index , final byte [ ] a , final int offset , final int length ) { ensure restrict index ( index ) ; byte array . ensure offset length ( a , offset , length ) ; final int array length = extract ( index , a , offset , length ) ; if ( length > = array length ) return array length ; return length - array length ; }
public static < k > object list < k > empty list ( ) { return empty_list ; }
public static < k > object set < k > empty set ( ) { return empty_set ; }
public string to unicode ( int code ) { return char to unicode . get ( code ) ; }
public static void main ( string [ ] args ) throw exception { g monitor a = null ; try { a = new g monitor ( ) ; a . set gmetric ( new g metric ( `` 239 . 2 . 11 . 71 `` , 8649 , u d p address mode . multicast , 1 ) ) ; a . add sampler ( new core sampler ( ) ) ; a . start ( ) ; } catch ( exception ex ) { log . severe ( `` exception start g monitor `` ) ; ex . print stack trace ( ) ; } while ( true ) { thread . sleep ( 1000 * 60 * 5 ) ; system . out . println ( `` test wakeup `` ) ; } }
public static void main ( string [ ] args ) throw exception { g monitor a = null ; try { a = new g monitor ( ) ; a . set gmetric ( new g metric ( `` 239 . 2 . 11 . 71 `` , 8649 , u d p address mode . multicast , 1 ) ) ; a . add sampler ( new core sampler ( ) ) ; a . start ( ) ; } catch ( exception ex ) { log . severe ( `` exception start g monitor `` ) ; ex . print stack trace ( ) ; } while ( true ) { thread . sleep ( 1000 * 60 * 5 ) ; system . out . println ( `` test wakeup `` ) ; } }
public object get property ( string key ) { if ( override property . contains key ( key ) ) { return override property . get property ( key ) ; } configuration first match configuration = null ; for ( configuration config : config list ) { if ( config . contains key ( key ) ) { first match configuration = config ; break ; } } if ( first match configuration ! = null ) { return first match configuration . get property ( key ) ; } else { return null ; } }
public string graph ( ) throw exception { byte array output stream baos = new byte array output stream ( ) ; print writer out = new print writer ( baos ) ; injector local injector = guice . create injector ( new graphviz module ( ) ) ; graphviz grapher renderer = local injector . get instance ( graphviz grapher . class ) ; renderer . set out ( out ) ; renderer . set rankdir ( `` tb `` ) ; if ( ! root . be empty ( ) ) { renderer . graph ( injector , root ) ; } renderer . graph ( injector ) ; return fixup graph ( baos . to string ( `` utf-8 `` ) ) ; }
public lifecycle manager get lifecycle manager ( ) { return lifecycle manager ; }
public lifecycle manager get lifecycle manager ( ) { return lifecycle manager ; }
public injector builder map ( module transformer transformer ) { this . module = transformer . transform ( module ) ; return this ; }
public lifecycle manager get lifecycle manager ( ) { return lifecycle manager ; }
public < t > injector builder for each element ( element visitor < t > visitor ) { element . get element ( module ) . for each ( element - > element . accept visitor ( visitor ) ) ; return this ; }
public injector builder warn of static injection ( ) { return for each element ( new warn of static injection visitor ( ) , message - > log . debug ( message ) ) ; }
public lifecycle state get state ( object obj ) { lifecycle state wrapper lifecycle state = object state . get ( obj ) ; if ( lifecycle state == null ) { return have start ( ) ? lifecycle state . active : lifecycle state . latent ; } else { synchronize ( lifecycle state ) { return lifecycle state . get ( ) ; } } }
public static grakn tx operation exception immutable property ( object old value , object new value , enum vertex property ) { return create ( error message . immutable_value . get message ( old value , new value , vertex property . name ( ) ) ) ; }
public static grakn backend exception migration failure ( string exception ) { return create ( `` error on backend have stop migration : `` + exception ) ; }
public static grakn tx operation exception transaction open ( grakn tx tx ) { return create ( error message . transaction_already_open . get message ( tx . keyspace ( ) ) ) ; }
public static grakn tx operation exception invalid direction ( direction direction ) { return create ( invalid_direction . get message ( direction ) ) ; }
public static aggregate < value > min ( string var ) { return aggregate . min ( graql . var ( var ) ) ; }
public static aggregate < value > mean ( string var ) { return aggregate . mean ( graql . var ( var ) ) ; }
protect double get domain low bound ( double p ) { return 0 ; }
public static reasoner atomic query atomic ( atom atom ) { return new reasoner atomic query ( atom ) . infer type ( ) ; }
public static reasoner atomic query atomic ( atom atom ) { return new reasoner atomic query ( atom ) . infer type ( ) ; }
public boolean require materialisation ( atom parent atom ) { if ( require materialisation == null ) { require materialisation = parent atom . require materialisation ( ) || get head ( ) . get atom ( ) . require materialisation ( ) || have disconnect head ( ) ; } return require materialisation ; }
public scope up ( ) { return parent ; }
public void refresh schema cache ( ) { global cache . populate schema tx cache ( this ) ; }
public void cache concept ( concept concept ) { concept cache . put ( concept . id ( ) , concept ) ; if ( concept . be schema concept ( ) ) { schema concept schema concept = concept . a schema concept ( ) ; schema concept cache . put ( schema concept . label ( ) , schema concept ) ; label cache . put ( schema concept . label ( ) , schema concept . label id ( ) ) ; } }
public static matcher < matchable concept > have value ( object expect value ) { return new property equal matcher < matchable concept , object > ( expect value ) { @ override public string get name ( ) { return `` have value `` ; } @ override public object transform ( matchable concept item ) { return item . get ( ) . a attribute ( ) . value ( ) ; } } ; }
public set get plugins ( ) { return load plugins ; }
public void add ( final string host , final inet address . . . ip ) { if ( host == null ) { throw new illegal argument exception ( `` host name may not be null `` ) ; } if ( ips == null ) { throw new illegal argument exception ( `` array of ip address may not be null `` ) ; } dns map . put ( host , ip ) ; }
protect void set closure delegate ( closure closure , object node ) { closure . set delegate ( this ) ; }
public default graph traversal < s , e > dedup ( final string . . . dedup label ) { this . a admin ( ) . get bytecode ( ) . add step ( symbol . dedup , dedup label ) ; return this . a admin ( ) . add step ( new dedup global step < > ( this . a admin ( ) , dedup label ) ) ; }
public static < v > p < v > eq ( final v value ) { return new p ( compare . eq , value ) ; }
public default int size ( ) { return this . object ( ) . size ( ) ; }
public default graph traversal < s , e > have ( final string property key ) { this . a admin ( ) . get bytecode ( ) . add step ( symbol . have , property key ) ; return this . a admin ( ) . add step ( new traversal filter step ( this . a admin ( ) , __ . value ( property key ) ) ) ; }
public static boolean match type name ( class < ? > clazz , string type name ) { return ( type name ! = null & & ( type name . equal ( clazz . get name ( ) ) || type name . equal ( clazz . get simple name ( ) ) || ( clazz . be array ( ) & & type name . equal ( get qualify name for array ( clazz ) ) ) ) ) ; }
protect void empty ( file file , string suffix ) { empty ( file , suffix , collection . < file > empty set ( ) , collection . < file > empty set ( ) ) ; }
protect void empty ( file file , string suffix ) { empty ( file , suffix , collection . < file > empty set ( ) , collection . < file > empty set ( ) ) ; }
public default int compare to ( final traverser < t > other ) throw class cast exception { return ( ( comparable ) this . get ( ) ) . compare to ( other . get ( ) ) ; }
public void stop ( ) { if ( finalize ) throw new illegal state exception ( `` metric have be finalize and can not be modify `` ) ; if ( -1 == this . temp time ) throw new illegal state exception ( `` internal error : metric have not be start . start timer before stop timer `` ) ; this . duration ns = this . duration ns + ( system . nano time ( ) - this . temp time ) ; this . temp time = -1 ; }
public default vertex in vertex ( ) { return this . vertex ( direction . in ) . next ( ) ; }
public static io . builder < gryo io > build ( ) { return build ( gryo version . v3_0 ) ; }
public default void write vertex ( final output stream output stream , final iterator < vertex > vertex iterator ) throw i o exception { while ( vertex iterator . have next ( ) ) { write vertex ( output stream , vertex iterator . next ( ) ) ; } }
public static io . builder < graph s o n io > build ( ) { return build ( graph s o n version . v3_0 ) ; }
public vertex get or create vertex ( final vertex vertex , final graph graph , final graph traversal source g ) { final graph traversal < vertex , vertex > t = g . add v ( vertex . label ( ) ) ; return ( use user supply id ( ) ? t . property ( t . id , vertex . id ( ) ) : t ) . next ( ) ; }
public long get class cache eviction weight ( ) { return class map . stats ( ) . eviction weight ( ) ; }
public double get class cache miss rate ( ) { return class map . stats ( ) . miss rate ( ) ; }
public string get message ( ) { return message ; }
public static void set without custom metaclass creation handle ( boolean mch ) { without custom handle = mch ; change flag ( mch ) ; }
public default table column add property column ( object header value , string property , class type ) { return add column ( header value , property , new property model ( row model , property , type ) ) ; }
public void init ( servlet config config ) throw servlet exception { super . init ( config ) ; this . engine = init template engine ( config ) ; if ( engine == null ) { throw new servlet exception ( `` template engine not instantiate . `` ) ; } string value = config . get init parameter ( `` generate . by `` ) ; if ( value ! = null ) { this . generate by = boolean . value of ( value ) ; } value = config . get init parameter ( groovy_source_encoding ) ; if ( value ! = null ) { this . file encode param val = value ; } log ( `` servlet `` + get class ( ) . get name ( ) + `` initialize on `` + engine . get class ( ) ) ; }
public object get property ( string column name ) { try { return get result set ( ) . get object ( column name ) ; } catch ( s q l exception e ) { throw new miss property exception ( column name , groovy result set proxy . class , e ) ; } }
protect result set get result set ( ) throw s q l exception { return result set ; }
protect result set get result set ( ) throw s q l exception { return result set ; }
public object invoke ( object proxy , method method , object [ ] args ) throw throwable { string name = method . get name ( ) ; if ( method . get declare class ( ) == groovy object . class ) { if ( name . equal ( `` get meta class `` ) ) { return get meta class ( ) ; } else if ( name . equal ( `` set meta class `` ) ) { return set meta class ( ( meta class ) args [ 0 ] ) ; } } return invoker helper . invoke method ( extension , method . get name ( ) , args ) ; }
protect result set get result set ( ) throw s q l exception { return result set ; }
public void set colspan ( int colspan ) { this . colspan = colspan ; }
public void set overtype mode ( boolean be overtype mode ) { text editor . be overtype mode = be overtype mode ; int po = get caret position ( ) ; if ( be overtype mode ( ) ) { set caret ( overtype caret ) ; } else { set caret ( default caret ) ; } set caret position ( po ) ; }
public lexer node get root node ( ) { return lexer ; }
public static < t > t max ( collection < t > item ) { t answer = null ; for ( t value : item ) { if ( value ! = null ) { if ( answer == null || script bytecode adapter . compare great than ( value , answer ) ) { answer = value ; } } } return answer ; }
public list depth first ( ) { list answer = new node list ( ) ; answer . add ( this ) ; answer . add all ( depth first rest ( ) ) ; return answer ; }
public void set bean factory name ( string bean factory name ) { this . bean factory name = bean factory name ; }
public void set style sheet file ( file style sheet file ) { this . style sheet file = style sheet file ; }
public void add text ( string txt ) { log ( `` add text ( ' `` + txt + `` ' ) `` , project . msg_verbose ) ; this . command += txt ; }
public void set access ( string access ) { if ( `` public `` . equal ( access ) ) public scope = true ; else if ( `` protect `` . equal ( access ) ) protect scope = true ; else if ( `` package `` . equal ( access ) ) package scope = true ; else if ( `` private `` . equal ( access ) ) private scope = true ; }
public void add configure javac ( final javac javac ) { this . javac = javac ; joint compilation = true ; }
public boolean get keep stub ( ) { return keep stub ; }
public boolean get keep stub ( ) { return keep stub ; }
public void set process script ( boolean process script ) { this . process script = process script ; }
protect string [ ] get class template ( ) { return groovy doc template info . default_class_templates ; }
protect string [ ] get class template ( ) { return groovy doc template info . default_class_templates ; }
public object get node meta data ( object key ) { return meta data map . get ( key ) ; }
public class get type class ( ) { if ( clazz ! = null ) return clazz ; if ( redirect ! = null ) return redirect . get type class ( ) ; class node component = redirect ( ) . component type ; if ( component ! = null & & component . be resolve ( ) ) { return array . new instance ( component . get type class ( ) , 0 ) . get class ( ) ; } throw new groovy bug error ( `` class node # get type class for `` + get name ( ) + `` call before the type class be set `` ) ; }
public class node redirect ( ) { if ( redirect==null ) return this ; return redirect . redirect ( ) ; }
public static boolean be double category ( class node type ) { return type==float_ t y p e || type==double_ t y p e || be big dec category ( type ) ; }
public void push loop ( string label name ) { push state ( ) ; init loop label ( label name ) ; }
public void set warn level ( int level ) { if ( level < warn message . none || level > warn message . paranoia ) { this . warn level = warn message . likely_errors ; } else { this . warn level = level ; } }
protect boolean be jdk compiler ( string compiler impl ) { return modern . equal ( compiler impl ) || classic . equal ( compiler impl ) || javac16 . equal ( compiler impl ) || javac15 . equal ( compiler impl ) || javac14 . equal ( compiler impl ) || javac13 . equal ( compiler impl ) || javac12 . equal ( compiler impl ) || javac11 . equal ( compiler impl ) ; }
public void add error and continue ( final message message ) { if ( error == null ) { error = new link list < > ( ) ; } error . add ( message ) ; }
public static date previous ( date self ) { return minus ( self , 1 ) ; }
public static string get time string ( date self ) { return date format . get time instance ( date format . medium ) . format ( self ) ; }
public static string get time string ( date self ) { return date format . get time instance ( date format . medium ) . format ( self ) ; }
public to string builder append ( char value ) { style . append ( buffer , null , value ) ; return this ; }
public to string builder append ( char [ ] array ) { style . append ( buffer , null , array , null ) ; return this ; }
public to string builder append ( float [ ] array ) { style . append ( buffer , null , array , null ) ; return this ; }
public to string builder append ( long [ ] array ) { style . append ( buffer , null , array , null ) ; return this ; }
public void set package ( string package ) { this . package = package ; }
public set < string > get disable global a s t transformation ( ) { return disable global a s t transformation ; }
public static date parse ( date self , string format , string input , time zone zone ) throw parse exception { simple date format sdf = new simple date format ( format ) ; sdf . set time zone ( zone ) ; return sdf . parse ( input ) ; }
public static boolean equal ( final object obj1 , final object obj2 ) { return obj1 == null ? obj2 == null : obj1 . equal ( obj2 ) ; }
public static < t > collection < t > intersect ( iterable < t > leave , iterable < t > right ) { return intersect ( a collection ( leave ) , a collection ( right ) ) ; }
public static boolean be equal list ( final collection < ? > list1 , final collection < ? > list2 ) { if ( list1 == list2 ) { return true ; } if ( list1 == null || list2 == null || list1 . size ( ) ! = list2 . size ( ) ) { return false ; } final iterator < ? > it1 = list1 . iterator ( ) ; final iterator < ? > it2 = list2 . iterator ( ) ; object obj1 = null ; object obj2 = null ; while ( it1 . have next ( ) & & it2 . have next ( ) ) { obj1 = it1 . next ( ) ; obj2 = it2 . next ( ) ; if ( ! ( obj1 == null ? obj2 == null : obj1 . equal ( obj2 ) ) ) { return false ; } } return ! ( it1 . have next ( ) || it2 . have next ( ) ) ; }
public static < t > t each ( t self , closure closure ) { each ( invoker helper . a iterator ( self ) , closure ) ; return self ; }
public static < t > t each ( t self , closure closure ) { each ( invoker helper . a iterator ( self ) , closure ) ; return self ; }
public static < t > t each ( t self , closure closure ) { each ( invoker helper . a iterator ( self ) , closure ) ; return self ; }
public static < t > t each with index ( t self , closure closure ) { final object [ ] args = new object [ 2 ] ; int counter = 0 ; for ( iterator iter = invoker helper . a iterator ( self ) ; iter . have next ( ) ; ) { args [ 0 ] = iter . next ( ) ; args [ 1 ] = counter++ ; closure . call ( args ) ; } return self ; }
public static < t > t each with index ( t self , closure closure ) { final object [ ] args = new object [ 2 ] ; int counter = 0 ; for ( iterator iter = invoker helper . a iterator ( self ) ; iter . have next ( ) ; ) { args [ 0 ] = iter . next ( ) ; args [ 1 ] = counter++ ; closure . call ( args ) ; } return self ; }
public static collection split ( object self , closure closure ) { list accept = new array list ( ) ; list reject = new array list ( ) ; return split ( closure , accept , reject , invoker helper . a iterator ( self ) ) ; }
public static boolean any ( object self ) { boolean return method invoker bmi = new boolean return method invoker ( ) ; for ( iterator iter = invoker helper . a iterator ( self ) ; iter . have next ( ) ; ) { if ( bmi . convert to boolean ( iter . next ( ) ) ) { return true ; } } return false ; }
public static boolean remove all ( collection self , object [ ] item ) { collection pick from = new tree set ( new number aware comparator ( ) ) ; pick from . add all ( array . a list ( item ) ) ; return self . remove all ( pick from ) ; }
public static collection collect ( object self ) { return collect ( self , closure . identity ) ; }
public static < t > list < t > plus ( list < t > self , int index , t [ ] item ) { return plus ( self , index , arrays . a list ( item ) ) ; }
public static object find ( object self ) { return find ( self , closure . identity ) ; }
public static collection grep ( object self , object filter ) { collection answer = create similar or default collection ( self ) ; boolean return method invoker bmi = new boolean return method invoker ( `` be case `` ) ; for ( iterator iter = invoker helper . a iterator ( self ) ; iter . have next ( ) ; ) { object object = iter . next ( ) ; if ( bmi . invoke ( filter , object ) ) { answer . add ( object ) ; } } return answer ; }
public static collection grep ( object self , object filter ) { collection answer = create similar or default collection ( self ) ; boolean return method invoker bmi = new boolean return method invoker ( `` be case `` ) ; for ( iterator iter = invoker helper . a iterator ( self ) ; iter . have next ( ) ; ) { object object = iter . next ( ) ; if ( bmi . invoke ( filter , object ) ) { answer . add ( object ) ; } } return answer ; }
public static < t > t max ( collection < t > item ) { t answer = null ; for ( t value : item ) { if ( value ! = null ) { if ( answer == null || script bytecode adapter . compare great than ( value , answer ) ) { answer = value ; } } } return answer ; }
protect void reflection append array detail ( string buffer buffer , string field name , object array ) { buffer . append ( array start ) ; int length = array . get length ( array ) ; for ( int i = 0 ; i < length ; i++ ) { object item = array . get ( array , i ) ; if ( i > 0 ) { buffer . append ( array separator ) ; } if ( item == null ) { append null text ( buffer , field name ) ; } else { append internal ( buffer , field name , item , array content detail ) ; } } buffer . append ( array end ) ; }
public static < c > collection < c > unmodifiable collection ( final collection < ? extend c > collection ) { return unmodifiable collection . unmodifiable collection ( collection ) ; }
public static < t > collection < t > take right ( iterable < t > self , int num ) { if ( num < = 0 || ! self . iterator ( ) . have next ( ) ) { return self instanceof collection ? create similar collection ( ( collection < t > ) self , 0 ) : new array list < t > ( ) ; } collection < t > self col = self instanceof collection ? ( collection < t > ) self : to list ( self ) ; if ( self col . size ( ) < = num ) { collection < t > ret = create similar collection ( self col , self col . size ( ) ) ; ret . add all ( self col ) ; return ret ; } collection < t > ret = create similar collection ( self col , num ) ; ret . add all ( a list ( ( iterable < t > ) self col ) . sub list ( self col . size ( ) - num , self col . size ( ) ) ) ; return ret ; }
protect void append detail ( string buffer buffer , string field name , int [ ] array ) { buffer . append ( array start ) ; for ( int i = 0 ; i < array . length ; i++ ) { if ( i > 0 ) { buffer . append ( array separator ) ; } append detail ( buffer , field name , array [ i ] ) ; } buffer . append ( array end ) ; }
protect void append summary ( string buffer buffer , string field name , int [ ] array ) { append summary size ( buffer , field name , array . length ) ; }
protect void append detail ( string buffer buffer , string field name , short [ ] array ) { buffer . append ( array start ) ; for ( int i = 0 ; i < array . length ; i++ ) { if ( i > 0 ) { buffer . append ( array separator ) ; } append detail ( buffer , field name , array [ i ] ) ; } buffer . append ( array end ) ; }
protect void append summary ( string buffer buffer , string field name , short [ ] array ) { append summary size ( buffer , field name , array . length ) ; }
protect void append detail ( string buffer buffer , string field name , byte [ ] array ) { buffer . append ( array start ) ; for ( int i = 0 ; i < array . length ; i++ ) { if ( i > 0 ) { buffer . append ( array separator ) ; } append detail ( buffer , field name , array [ i ] ) ; } buffer . append ( array end ) ; }
public static object coerce to s a m ( closure argument , method method , class clazz , boolean be interface ) { if ( argument ! =null & & clazz . be assignable from ( argument . get class ( ) ) ) { return argument ; } if ( be interface ) { if ( trait . be trait ( clazz ) ) { map < string , closure > impl = collection . singleton map ( method . get name ( ) , argument ) ; return proxy generator . instance . instantiate aggregate ( impl , collection . singleton list ( clazz ) ) ; } return proxy . new proxy instance ( clazz . get class loader ( ) , new class [ ] { clazz } , new convert closure ( argument ) ) ; } else { map < string , object > m = new hash map < string , object > ( ) ; m . put ( method . get name ( ) , argument ) ; return proxy generator . instance . instantiate aggregate from base class ( m , clazz ) ; } }
public static < t > t [ ] reverse each ( t [ ] self , @ closure params ( first param . component . class ) closure closure ) { each ( new reverse list iterator < t > ( arrays . a list ( self ) ) , closure ) ; return self ; }
protect void append summary ( string buffer buffer , string field name , double [ ] array ) { append summary size ( buffer , field name , array . length ) ; }
protect void append detail ( string buffer buffer , string field name , boolean [ ] array ) { buffer . append ( array start ) ; for ( int i = 0 ; i < array . length ; i++ ) { if ( i > 0 ) { buffer . append ( array separator ) ; } append detail ( buffer , field name , array [ i ] ) ; } buffer . append ( array end ) ; }
public static < t > list < t > plus ( list < t > self , int index , t [ ] item ) { return plus ( self , index , arrays . a list ( item ) ) ; }
public static boolean char begin with ( string prefix , char [ ] char ) { if ( char == null || prefix == null ) { return false ; } if ( prefix . length ( ) > char . length ) { return false ; } for ( int i = 0 ; i < prefix . length ( ) ; i++ ) { if ( char [ i ] ! = prefix . char at ( i ) ) { return false ; } } return true ; }
protect void append null text ( string buffer buffer , string field name ) { buffer . append ( null text ) ; }
protect void append field separator ( string buffer buffer ) { buffer . append ( field separator ) ; }
protect void append field start ( string buffer buffer , string field name ) { if ( use field name & & field name ! = null ) { buffer . append ( field name ) ; buffer . append ( field name value separator ) ; } }
protect void append field end ( string buffer buffer , string field name ) { append field separator ( buffer ) ; }
protect void append summary size ( string buffer buffer , string field name , int size ) { buffer . append ( size start text ) ; buffer . append ( size ) ; buffer . append ( size end text ) ; }
protect boolean be full detail ( boolean full detail request ) { if ( full detail request == null ) { return default full detail ; } return full detail request . boolean value ( ) ; }
protect static object primitive array put ( object self , int idx , object new value ) { array . set ( self , normalise index ( idx , array . get length ( self ) ) , new value ) ; return new value ; }
public static string to list string ( collection arg ) { return to list string ( arg , -1 ) ; }
protect void set size start text ( string size start text ) { if ( size start text == null ) { size start text = `` `` ; } this . size start text = size start text ; }
protect string get size end text ( ) { return size end text ; }
protect void set size end text ( string size end text ) { if ( size end text == null ) { size end text = `` `` ; } this . size end text = size end text ; }
public static boolean be support ( string name ) { if ( name == null ) { return false ; } try { new string ( array utils . empty_byte_array , name ) ; } catch ( unsupported encode exception e ) { return false ; } return true ; }
public static number intdiv ( character leave , number right ) { return intdiv ( integer . value of ( leave ) , right ) ; }
public static number or ( number leave , number right ) { return number math . or ( leave , right ) ; }
public static void downto ( number self , number to , @ closure params ( first param . class ) closure closure ) { int self1 = self . int value ( ) ; int to1 = to . int value ( ) ; if ( self1 > = to1 ) { for ( int i = self1 ; i > = to1 ; i -- ) { closure . call ( i ) ; } } else throw new groovy runtime exception ( `` the argument ( `` + to + `` ) to downto ( ) can not be great than the value ( `` + self + `` ) it 's call on . `` ) ; }
public static long to long ( number self ) { return self . long value ( ) ; }
public static number or ( number leave , number right ) { return number math . or ( leave , right ) ; }
public void set delegate ( object delegate ) { this . delegate = delegate ; this . meta class = invoker helper . get meta class ( delegate . get class ( ) ) ; }
public static class name get ( string package name , string simple name , string . . . simple name ) { list < string > result = new array list < > ( ) ; result . add ( package name ) ; result . add ( simple name ) ; collection . add all ( result , simple name ) ; return new class name ( result ) ; }
public boolean remove attribute ( string name , namespace n ) { return attribute . remove ( name , n ) ; }
public static string format r f c822 ( final date date , final locale locale ) { final simple date format date formater = new simple date format ( `` eee , dd mmm yyyy hh : mm : s 'gmt ' `` , locale ) ; date formater . set time zone ( time zone . get time zone ( `` gmt `` ) ) ; return date formater . format ( date ) ; }
public void new line ( ) throw i o exception { yield unescaped ( configuration . get new line string ( ) ) ; do write indent = true ; }
public boolean be close ( ) { return unprocessed == null & & full stream decompressor == null ; }
public schedule future < ? > run on expiration ( runnable task , schedule executor service scheduler ) { check not null ( task , `` task `` ) ; check not null ( scheduler , `` scheduler `` ) ; return scheduler . schedule ( task , deadline nanos - ticker . read ( ) , time unit . nanosecond ) ; }
public call option with compression ( @ nullable string compressor name ) { call option new option = new call option ( this ) ; new option . compressor name = compressor name ; return new option ; }
public static compressor registry new empty instance ( ) { return new compressor registry ( ) ; }
protect void transport trailer receive ( metadata trailer ) { precondition . check not null ( trailer , `` trailer `` ) ; if ( transport error == null & & ! header receive ) { transport error = validate initial metadata ( trailer ) ; if ( transport error ! = null ) { transport error metadata = trailer ; } } if ( transport error ! = null ) { transport error = transport error . augment description ( `` trailer : `` + trailer ) ; http2 processing fail ( transport error , false , transport error metadata ) ; } else { status status = status from trailer ( trailer ) ; strip transport detail ( trailer ) ; inbound trailer receive ( trailer , status ) ; } }
public void remove server ( instrumented < server stats > server ) { remove ( server , server ) ; server socket map prev = per server socket . remove ( id ( server ) ) ; assert prev ! = null ; assert prev . be empty ( ) ; }
public instrument < channel stats > get channel ( long id ) { return root channel . get ( id ) ; }
public static void notify fail ( ping callback callback , executor executor , throwable cause ) { do execute ( executor , a runnable ( callback , cause ) ) ; }
public static stats trace context new server context ( list < server stream tracer . factory > factory , string full method name , metadata header ) { if ( factory . be empty ( ) ) { return noop ; } stream tracer [ ] tracer = new stream tracer [ factory . size ( ) ] ; for ( int i = 0 ; i < tracer . length ; i++ ) { tracer [ i ] = factory . get ( i ) . new server stream tracer ( full method name , header ) ; } return new stats trace context ( tracer ) ; }
public void report remote stream start ( ) { streams started++ ; last remote stream create time nanos = time provider . current time nanos ( ) ; }
public void set login timeout ( int timeout ) throw s q l exception { throw new unsupported operation exception ( `` set login timeout `` ) ; }
public t max hedge attempt ( int max hedge attempt ) { throw new unsupported operation exception ( ) ; }
public manage channel impl shutdown now ( ) { logger . log ( level . fine , `` [ { 0 } ] shutdown now ( ) call `` , get log id ( ) ) ; shutdown ( ) ; uncommitted retriable stream registry . on shutdown now ( shutdown_now_status ) ; channel executor . execute later ( new runnable ( ) { @ override public void run ( ) { if ( shutdown nowed ) { return ; } shutdown nowed = true ; maybe shutdown now subchannels ( ) ; } } ) . drain ( ) ; return this ; }
public final expression optimize ( expression visitor visitor , item type context item type ) { return this ; }
public static boolean be ascii ( char ch ) { return ch < 128 ; }
public static < t > t create proxy ( class < t > clazz ) { return create proxy ( clazz , generate base url ( ) ) ; }
public static com . google . rpc . status from status and trailer ( status status , metadata trailer ) { if ( trailer ! = null ) { com . google . rpc . status status proto = trailer . get ( status_details_key ) ; if ( status proto ! = null ) { check argument ( status . get code ( ) . value ( ) == status proto . get code ( ) , `` com . google . rpc . status code must match g r p c status code `` ) ; return status proto ; } } return null ; }
public throwable get cause ( ) { return cause ; }
protect void set closure delegate ( closure closure , object node ) { closure . set delegate ( this ) ; }
public < t > netty server builder with child option ( channel option < t > option , t value ) { this . channel option . put ( option , value ) ; return this ; }
public < t > netty server builder with child option ( channel option < t > option , t value ) { this . channel option . put ( option , value ) ; return this ; }
public netty server builder ssl context ( ssl context ssl context ) { if ( ssl context ! = null ) { check argument ( ssl context . be server ( ) , `` client ssl context can not be use for server `` ) ; grpc ssl context . ensure alpn and h2 enable ( ssl context . application protocol negotiator ( ) ) ; } this . ssl context = ssl context ; return this ; }
public static void write ( char sequence from , file to , charset charset ) throw i o exception { a char sink ( to , charset ) . write ( from ) ; }
public static list < string > read line ( file file , charset charset ) throw i o exception { return char stream . read line ( file . new reader supplier ( file , charset ) ) ; }
public static void move ( file from , file to ) throw i o exception { check not null ( from ) ; check not null ( to ) ; check argument ( ! from . equal ( to ) , `` source % s and destination % s must be different `` , from , to ) ; if ( ! from . rename to ( to ) ) { copy ( from , to ) ; if ( ! from . delete ( ) ) { if ( ! to . delete ( ) ) { throw new i o exception ( `` unable to delete `` + to ) ; } throw new i o exception ( `` unable to delete `` + from ) ; } } }
public static input supplier < byte array input stream > new input stream supplier ( byte [ ] b ) { return byte stream . a input supplier ( a byte source ( b ) ) ; }
public < t > listenable future < t > submit ( final callable < t > callable , executor executor ) { check not null ( callable ) ; return submit async ( new async callable < t > ( ) { @ override public listenable future < t > call ( ) throw exception { return immediate future ( callable . call ( ) ) ; } } , executor ) ; }
public retryer builder < v > retry if exception of type ( @ nonnull class < ? extend throwable > exception class ) { precondition . check not null ( exception class , `` exception class may not be null `` ) ; rejection predicate = predicate . or ( rejection predicate , new exception class predicate < v > ( exception class ) ) ; return this ; }
public retryer < v > build ( ) { attempt time limiter < v > the attempt time limiter = attempt time limiter == null ? attempt time limiter . < v > no time limit ( ) : attempt time limiter ; stop strategy the stop strategy = stop strategy == null ? stop strategy . never stop ( ) : stop strategy ; wait strategy the wait strategy = wait strategy == null ? wait strategy . no wait ( ) : wait strategy ; block strategy the block strategy = block strategy == null ? block strategy . thread sleep strategy ( ) : block strategy ; return new retryer < v > ( the attempt time limiter , the stop strategy , the wait strategy , the block strategy , rejection predicate , listener ) ; }
protect c reset container ( ) { return reset container ( get subject generator ( ) . create test subject ( ) ) ; }
protect c reset container ( ) { return reset container ( get subject generator ( ) . create test subject ( ) ) ; }
public void test add at index_unsupported present ( ) { try { get list ( ) . add ( 0 , e0 ( ) ) ; fail ( `` add ( n , present ) should throw `` ) ; } catch ( unsupported operation exception expect ) { } expect unchanged ( ) ; }
public static tester requirement build declare tester requirement ( annotated element class or method ) throw conflict requirement exception { tester requirement requirement = new tester requirement ( ) ; iterable < annotation > tester annotation = get tester annotation ( class or method ) ; for ( annotation tester annotation : tester annotation ) { tester requirement more requirement = build tester requirement ( tester annotation ) ; incorporate requirement ( requirement , more requirement , tester annotation ) ; } return requirement ; }
public b with feature ( feature < ? > . . . feature ) { return with feature ( array . a list ( feature ) ) ; }
protect c reset container ( ) { return reset container ( get subject generator ( ) . create test subject ( ) ) ; }
protect c reset container ( ) { return reset container ( get subject generator ( ) . create test subject ( ) ) ; }
public static void assert unescaped ( char escaper escaper , char c ) { assert . assert null ( compute replacement ( escaper , c ) ) ; }
public equivalence tester < t > test ( ) { for ( int run = 0 ; run < repetition ; run++ ) { test item ( ) ; delegate . test ( ) ; } return this ; }
public static void await do ( finalization predicate predicate ) { if ( predicate . be do ( ) ) { return ; } final long timeout second = timeout second ( ) ; final long deadline = system . nano time ( ) + second . to nanos ( timeout second ) ; do { system . run finalization ( ) ; if ( predicate . be do ( ) ) { return ; } count down latch do = new count down latch ( 1 ) ; create unreachable latch finalizer ( do ) ; await ( do ) ; if ( predicate . be do ( ) ) { return ; } } while ( system . nano time ( ) - deadline < 0 ) ; throw format runtime exception ( `` predicate do not become true within % d second timeout `` , timeout second ) ; }
public static < t > t reserialize and assert ( t object ) { t copy = reserialize ( object ) ; new equal tester ( ) . add equality group ( object , copy ) . test equal ( ) ; assert . assert equal ( object . get class ( ) , copy . get class ( ) ) ; return copy ; }
public dependency < ? > push dependency ( dependency < ? > dependency , object source ) { dependency < ? > previous = this . dependency ; this . dependency = dependency ; state . add ( dependency , source ) ; return previous ; }
protect void create constraint ( ) { if ( constraint command ! = null ) { for ( define command command : constraint command ) { command . set transactional ( transactional ) ; command . update ( ) ; } } }
public procedure get procedure ( string name ) { if ( procedure == null ) { return null ; } return procedure . get ( name ) ; }
public void clear word list ( ) { synchronize ( word ) { word . clear ( ) ; } }
public row lock row ( session session , row row ) { throw db exception . get unsupported exception ( `` lock row ( ) `` ) ; }
public void commit ( ) { if ( database ! = null ) { last modification id = database . get next modification data id ( ) ; } }
public synchronize transaction begin ( ) { long transaction id = last transaction id++ ; if ( last transaction id > last transaction id store ) { last transaction id store += 64 ; setting . put ( last_transaction_id , `` `` + last transaction id store ) ; } int status = transaction . status_open ; return new transaction ( this , transaction id , status , null , 0 ) ; }
public void truncate ( long size ) { try { write count . increment and get ( ) ; file . truncate ( size ) ; file size = math . min ( file size , size ) ; } catch ( i o exception e ) { throw data utils . new illegal state exception ( data utils . error_writing_failed , `` could not truncate file { 0 } to size { 1 } `` , file name , size , e ) ; } }
public void mark use ( long po , int length ) { free space . mark use ( pos , length ) ; }
public file channel get file ( ) { check open ( ) ; return file ; }
public long get version to keep ( ) { return version to keep ; }
public int get auto commit memory ( ) { return auto commit memory ; }
public file channel get file ( ) { check open ( ) ; return file ; }
public synchronize long commit ( ) { if ( file store ! = null ) { return commit and save ( ) ; } long v = ++current version ; set write version ( v ) ; return v ; }
public write buffer put char ( char x ) { ensure capacity ( 2 ) . put char ( x ) ; return this ; }
public write buffer put double ( double x ) { ensure capacity ( 8 ) . put double ( x ) ; return this ; }
public write buffer put char ( char x ) { ensure capacity ( 2 ) . put char ( x ) ; return this ; }
public write buffer limit ( int new limit ) { ensure capacity ( new limit - buff . position ( ) ) . limit ( new limit ) ; return this ; }
public write buffer put short ( int index , short value ) { buff . put short ( index , value ) ; return this ; }
public write buffer get ( byte [ ] dst ) { buff . get ( dst ) ; return this ; }
public table synonym create synonym ( create synonym data data ) { synchronize ( database ) { database . lock meta ( data . session ) ; data . schema = this ; return new table synonym ( data ) ; } }
public static void register ( file path provider ) { register default provider ( ) ; provider . put ( provider . get scheme ( ) , provider ) ; }
public static void register ( file path provider ) { register default provider ( ) ; provider . put ( provider . get scheme ( ) , provider ) ; }
public value convert ( value v , boolean for comparison ) { try { return v . convert to ( type , table . get database ( ) , for comparison , this ) ; } catch ( db exception e ) { if ( e . get error code ( ) == error code . data_conversion_error_1 ) { e = get data conversion error ( v , e ) ; } throw e ; } }
public void set auto increment ( boolean auto inc , long start , long increment ) { this . auto increment = auto inc ; this . start = start ; this . increment = increment ; this . nullable = false ; if ( auto inc ) { convert null to default = true ; } }
public void map and add filter ( expression on ) { on . map column ( this , 0 ) ; add filter condition ( on , true ) ; on . create index condition ( session , this ) ; if ( nested join ! = null ) { on . map column ( nested join , 0 ) ; on . create index condition ( session , nested join ) ; } if ( join ! = null ) { join . map and add filter ( on ) ; } }
public expression get check constraint ( session session , string a column name ) { if ( check constraint == null ) { return null ; } parser parser = new parser ( session ) ; string sql ; synchronize ( this ) { string old name = name ; name = a column name ; sql = check constraint . get s q l ( ) ; name = old name ; } return parser . parse expression ( sql ) ; }
public void register ( table filter filter , index lookup batch lookup batch ) { assert filter ! = null ; top = new join filter ( lookup batch , filter , top ) ; filter [ top . id ] = top ; }
public void register ( table filter filter , index lookup batch lookup batch ) { assert filter ! = null ; top = new join filter ( lookup batch , filter , top ) ; filter [ top . id ] = top ; }
public string get create s q l ( boolean or replace , boolean force ) { return get create s q l ( or replace , force , get s q l ( ) ) ; }
public static void fill array a n d n o t ( final short [ ] container , final long [ ] bitmap1 , final long [ ] bitmap2 ) { int po = 0 ; if ( bitmap1 . length ! = bitmap2 . length ) throw new illegal argument exception ( `` not support `` ) ; for ( int k = 0 ; k < bitmap1 . length ; ++k ) { long bitset = bitmap1 [ k ] & ( ~bitmap2 [ k ] ) ; while ( bitset ! = 0 ) { long t = bitset & -bitset ; container [ pos++ ] = ( short ) ( k * 64 + long . bit count ( t - 1 ) ) ; bitset ^= t ; } } }
public static object parse local time ( char sequence text ) { try { return local_time_parse . invoke ( null , text ) ; } catch ( illegal access exception | invocation target exception e ) { throw new illegal argument exception ( `` error when parse text ' `` + text + `` ' `` , e ) ; } }
public static object parse local time ( char sequence text ) { try { return local_time_parse . invoke ( null , text ) ; } catch ( illegal access exception | invocation target exception e ) { throw new illegal argument exception ( `` error when parse text ' `` + text + `` ' `` , e ) ; } }
public static value offset date time to value ( object offset date time ) { try { object local date time = offset_date_time_to_local_date_time . invoke ( offset date time ) ; object local date = local_date_time_to_local_date . invoke ( local date time ) ; object zone offset = offset_date_time_get_offset . invoke ( offset date time ) ; long date value = date value from local date ( local date ) ; long time nanos = time nanos from local date time ( local date time ) ; short time zone offset min = zone offset to offset minute ( zone offset ) ; return value timestamp time zone . from date value and nanos ( date value , time nanos , time zone offset min ) ; } catch ( illegal access exception e ) { throw db exception . convert ( e ) ; } catch ( invocation target exception e ) { throw db exception . convert invocation ( e , `` time conversion fail `` ) ; } }
public static string normalize host name ( string name ) { try { return inet address . get by name ( name ) . get host address ( ) ; } catch ( unknown host exception e ) { return name ; } }
public double [ ] get envelope no copy ( ) { if ( envelope == unknown_envelope ) { envelope target target = new envelope target ( ) ; e w k b utils . parse e w k b ( byte , target ) ; envelope = target . get envelope ( ) ; } return envelope ; }
public long get minute ( ) { return interval utils . minute from interval ( qualifier , negative , leading , remain ) ; }
public long get day ( ) { return interval utils . day from interval ( qualifier , negative , leading , remain ) ; }
public long get minute ( ) { return interval utils . minute from interval ( qualifier , negative , leading , remain ) ; }
public long get year ( ) { return interval utils . year from interval ( qualifier , negative , leading , remain ) ; }
public array list < expression > expression ( ) { return expression ; }
public void add row ( expression [ ] expr ) { list . add ( expr ) ; }
public final void set current group expr data ( expression expr , object obj ) { integer index = expr to index in group by data . get ( expr ) ; if ( index ! = null ) { assert current group by expr data [ index ] == null ; current group by expr data [ index ] = obj ; return ; } index = expr to index in group by data . size ( ) ; expr to index in group by data . put ( expr , index ) ; if ( index > = current group by expr data . length ) { current group by expr data = array . copy of ( current group by expr data , current group by expr data . length * 2 ) ; update current group expr data ( ) ; } current group by expr data [ index ] = obj ; }
public void set update to current value return zero ( boolean update to current value return zero ) { this . update to current value return zero = update to current value return zero ; }
public string builder get s q l ( string builder builder , boolean always quote ) { return row id ? builder . append ( name ) : parser . quote identifier ( builder , name , always quote ) ; }
public final void set current group expr data ( expression expr , object obj ) { integer index = expr to index in group by data . get ( expr ) ; if ( index ! = null ) { assert current group by expr data [ index ] == null ; current group by expr data [ index ] = obj ; return ; } index = expr to index in group by data . size ( ) ; expr to index in group by data . put ( expr , index ) ; if ( index > = current group by expr data . length ) { current group by expr data = array . copy of ( current group by expr data , current group by expr data . length * 2 ) ; update current group expr data ( ) ; } current group by expr data [ index ] = obj ; }
public void set file password hash ( byte [ ] hash ) { this . file password hash = hash ; }
public void map column ( column resolver resolver , int level ) { resolve window ( resolver ) ; if ( partition by ! = null ) { for ( expression e : partition by ) { e . map column ( resolver , level , expression . map_in_window ) ; } } if ( order by ! = null ) { for ( select order by o : order by ) { o . expression . map column ( resolver , level , expression . map_in_window ) ; } } if ( frame ! = null ) { frame . map column ( resolver , level , expression . map_in_window ) ; } }
public table to table ( string alias , array list < parameter > parameter , boolean for create view , query top query ) { set parameter list ( new array list < > ( parameter ) ) ; init ( ) ; return table view . create temp view ( for create view ? session . get database ( ) . get system session ( ) : session , session . get user ( ) , alias , this , top query ) ; }
public static long get default max value ( long start value , long increment ) { long v = increment > = 0 ? long . max_value : -1 ; if ( start value ! = null & & increment < 0 & & start value > v ) { v = start value ; } return v ; }
public void clean ( ) { this . password = null ; this . nested identity = null ; connection info . clean authentication info ( ) ; }
public list < realm config > get realm ( ) { if ( realm == null ) { realms = new array list < > ( ) ; } return realm ; }
public void set validator class ( string validator class ) { this . validator class = validator class ; }
public void remove index ( index index ) { array list < index > index = get index ( ) ; if ( indexes ! = null ) { remove ( index , index ) ; if ( index . get index type ( ) . be primary key ( ) ) { for ( column col : index . get columns ( ) ) { col . set primary key ( false ) ; } } } }
public void add common join column ( column leave column , column replacement column , table filter replacement filter ) { if ( common join columns == null ) { common join column = new link hash map < > ( ) ; common join columns filter = replacement filter ; } else { assert common join columns filter == replacement filter ; } common join column . put ( left column , replacement column ) ; }
public static int parse geometry type ( string s ) { e w k t source source = new e w k t source ( s ) ; int type = source . read type ( ) ; int dimension system = 0 ; if ( source . have data ( ) ) { dimension system = source . read dimension system ( ) ; if ( source . have data ( ) ) { throw new illegal argument exception ( ) ; } } return dimension system * 1_000 + type ; }
public static time zone provider get default ( ) { if ( jsr310 . present ) { return j s r310 utils . get default time zone provider ( ) ; } return new with time zone7 ( time zone . get default ( ) ) ; }
public integer get srid ( ) { return srid ; }
public static value date time to value ( value original , long date value , long time nanos , boolean force timestamp ) { if ( ! ( original instanceof value timestamp ) ) { if ( ! force timestamp ) { if ( original instanceof value date ) { return value date . from date value ( date value ) ; } if ( original instanceof value time ) { return value time . from nanos ( time nanos ) ; } } if ( original instanceof value timestamp time zone ) { return value timestamp time zone . from date value and nanos ( date value , time nanos , ( ( value timestamp time zone ) original ) . get time zone offset min ( ) ) ; } } return value timestamp . from date value and nanos ( date value , time nanos ) ; }
public final boolean compare and set ( double expect , double update ) { return updater . compare and set ( this , double to raw long bit ( expect ) , double to raw long bit ( update ) ) ; }
public static value row get ( value [ ] list ) { return new value row ( list ) ; }
protect string argument to string ( object argument ) { if ( argument instanceof string ) { return `` \ `` `` + argument + `` \ `` `` ; } return `` `` + argument ; }
public security collection find collection ( string name ) { if ( name == null ) return null ; for ( security collection collection : collection ) { if ( name . equal ( collection . get name ( ) ) ) return collection ; } return null ; }
public string to string ( ) { string builder result = new string builder ( ) ; result . append ( service name ) ; if ( host name ! = null ) { result . append ( '/ ' ) ; result . append ( host name ) ; } if ( realm ! = null ) { result . append ( ' @ ' ) ; result . append ( realm ) ; } return result . to string ( ) ; }
public synchronize void unset ( string name ) { string [ ] names = null ; if ( ! be deprecate ( name ) ) { name = get alternative name ( name ) ; if ( name == null ) { name = new string [ ] { name } ; } } else { name = handle deprecation ( deprecation context . get ( ) , name ) ; } for ( string n : name ) { get overlay ( ) . remove ( n ) ; get prop ( ) . remove ( n ) ; } }
public integer range get range ( string name , string default value ) { return new integer range ( get ( name , default value ) ) ; }
public long get long byte ( string name , long default value ) { string value string = get trim ( name ) ; if ( value string == null ) return default value ; return string utils . traditional binary prefix . string2long ( value string ) ; }
public double get double ( string name , double default value ) { string value string = get trim ( name ) ; if ( value string == null ) return default value ; return double . parse double ( value string ) ; }
public string get uri path ( final path p ) { check path ( p ) ; string s = p . to uri ( ) . get path ( ) ; if ( ! be valid name ( s ) ) { throw new invalid path exception ( `` path part `` + s + `` from uri `` + p + `` be not a valid filename . `` ) ; } return s ; }
public string get old value ( ) { return old val ; }
public string to string ( ) { string builder sb = new string builder ( `` security constraint [ `` ) ; for ( int i = 0 ; i < collection . length ; i++ ) { if ( i > 0 ) sb . append ( `` , `` ) ; sb . append ( collection [ i ] . get name ( ) ) ; } sb . append ( `` ] `` ) ; return sb . to string ( ) ; }
public void warm up encrypted key ( string . . . key name ) throw i o exception { get extension ( ) . warm up encrypted key ( key name ) ; }
public static string apply relative path ( string path , string relative path ) { int separator index = path . last index of ( folder_separator ) ; if ( separator index ! = -1 ) { string new path = path . substring ( 0 , separator index ) ; if ( ! relative path . start with ( folder_separator ) ) { new path += folder_separator ; } return new path + relative path ; } else { return relative path ; } }
synchronize protected int next ( int nbits ) { fill reservoir ( 4 ) ; int n = 0 ; for ( int i = 0 ; i < 4 ; i++ ) { n = ( n < < 8 ) | ( reservoir [ pos++ ] & 0xff ) ; } return n & ( 0xffffffff > > ( 32 - nbits ) ) ; }
public path make qualify ( path path ) { check path ( path ) ; return path . make qualified ( this . get uri ( ) , null ) ; }
public final this tail set ( final e from element ) { assert . check not null param ( `` from element `` , from element ) ; return value ( bit & ~ ( bit of ( from element ) - 1 ) ) ; }
public map < string , byte [ ] > get x attrs ( path path ) throw i o exception { throw new unsupported operation exception ( get class ( ) . get simple name ( ) + `` do n't support get x attrs `` ) ; }
public void set topology path ( string [ ] topology path ) throw i o exception { if ( topology path == null ) { this . topology path = empty_str_array ; } else { this . topology path = topology path ; } }
public void set offset ( long offset ) { this . offset = offset ; }
public long get type consume ( storage type type ) { return ( type consume ! = null ) ? type consume [ type . ordinal ( ) ] : 0 ; }
public boolean equal ( object o ) { if ( o == null ) { return false ; } if ( this == o ) { return true ; } if ( ! ( o instanceof file status ) ) { return false ; } file status other = ( file status ) o ; return this . get path ( ) . equal ( other . get path ( ) ) ; }
public f permission get permission ( ) { return permission ; }
public static file system new instance ( configuration conf ) throw i o exception { return new instance ( get default uri ( conf ) , conf ) ; }
public static file system new instance ( configuration conf ) throw i o exception { return new instance ( get default uri ( conf ) , conf ) ; }
public final void serialize ( json generator g , serializer provider provider ) throw i o exception { / * nothing to output . . . should we signal an error tho ? * chance be , this be an erroneous call . for now , let 's * not do that ; serialize a explicit null . why ? because we * can not just omit a value a json object field name may have * be write out . * / g . write null ( ) ; }
public string get scheme ( ) { throw new unsupported operation exception ( `` not implement by the `` + get class ( ) . get simple name ( ) + `` file system implementation `` ) ; }
public boolean delete on exit ( path f ) throw i o exception { if ( ! exists ( f ) ) { return false ; } synchronize ( delete on exit ) { delete on exit . add ( f ) ; } return true ; }
public static void create hard link mult ( file parent dir , string [ ] file base name , file link dir ) throw i o exception { if ( parent dir == null ) { throw new i o exception ( `` invalid argument to create hard link mult : parent directory be null `` ) ; } if ( link dir == null ) { throw new i o exception ( `` invalid argument to create hard link mult : link directory be null `` ) ; } if ( file base name == null ) { throw new i o exception ( `` invalid argument to create hard link mult : `` + `` filename list can be empty but not null `` ) ; } if ( ! link dir . exists ( ) ) { throw new file not find exception ( link dir + `` not find . `` ) ; } for ( string name : file base names ) { create link ( link dir . to path ( ) . resolve ( name ) , parent dir . to path ( ) . resolve ( name ) ) ; } }
public file status [ ] list status ( path p ) throw i o exception { path ab f = fix relative part ( p ) ; return new file system link resolver < file status [ ] > ( ) { @ override public file status [ ] do call ( final path p ) throw i o exception , unresolved link exception { return list status internal ( p ) ; } @ override public file status [ ] next ( final file system f , final path p ) throw i o exception { return f . list status ( p ) ; } } . resolve ( this , abs f ) ; }
public boolean set replication ( path src , short replication ) throw i o exception { boolean value = f . set replication ( src , replication ) ; if ( ! value ) return false ; path check file = get checksum file ( src ) ; if ( exists ( check file ) ) f . set replication ( check file , replication ) ; return true ; }
public void initialize ( uri name , configuration conf ) throw i o exception { statistic = get statistic ( name . get scheme ( ) , get class ( ) ) ; resolve symlinks = conf . get boolean ( common configuration key . fs_client_resolve_remote_symlinks_key , common configuration key . fs_client_resolve_remote_symlinks_default ) ; }
public void set work directory ( path new dir ) { f . set work directory ( new dir ) ; }
public void flush ( ) throw i o exception { flush buffer ( false , false ) ; }
public static void main ( string [ ] args ) { if ( d f s util . parse help argument ( args , usage , system . out , true ) ) { system . exit ( 0 ) ; } try { system . exit ( tool runner . run ( new hdfs configuration ( ) , new cli ( ) , args ) ) ; } catch ( throwable e ) { log . error ( `` exit balancer due an exception `` , e ) ; system . exit ( -1 ) ; } }
public static void register expression ( expression factory factory ) throw i o exception { factory . add class ( and . class , `` -a `` ) ; factory . add class ( and . class , `` -and `` ) ; }
public path get local path for write ( string path str , long size , configuration conf ) throw i o exception { return get local path for write ( path str , size , conf , true ) ; }
public path get local path to read ( string path str , configuration conf ) throw i o exception { allocator per context context = obtain context ( context cfg item name ) ; return context . get local path to read ( path str , conf ) ; }
public boolean be uri path absolute ( ) { int start = start position without window drive ( uri . get path ( ) ) ; return uri . get path ( ) . start with ( separator , start ) ; }
public void set command factory ( command factory factory ) { this . command factory = factory ; }
protect void set closure delegate ( closure closure , object node ) { closure . set delegate ( this ) ; }
public string get description ( ) { return be deprecate ( ) ? `` ( deprecate ) same a ' `` + get replacement command ( ) + `` ' `` : get command field ( `` description `` ) ; }
public command get instance ( string cmd name , configuration conf ) { if ( conf == null ) throw new null pointer exception ( `` configuration be null `` ) ; command instance = object map . get ( cmd name ) ; if ( instance == null ) { class < ? extends command > cmd class = class map . get ( cmd name ) ; if ( cmd class ! = null ) { instance = reflection utils . new instance ( cmd class , conf ) ; instance . set name ( cmd name ) ; instance . set command factory ( this ) ; } } return instance ; }
public list sub list ( int from index , int to index ) { if ( fast ) { return new sub list ( from index , to index ) ; } else { return list . sub list ( from index , to index ) ; } }
public input stream get in ( ) { return this . in ; }
public int get max depth ( ) { return this . max depth ; }
public void checkpoint ( ) throw i o exception { trash policy . create checkpoint ( ) ; }
public static void add link ( configuration conf , final string mount table name , final string src , final uri target ) { conf . set ( get config view fs prefix ( mount table name ) + `` . `` + constant . config_viewfs_link + `` . `` + src , target . to string ( ) ) ; }
public object get attribute ( string name ) { return web app context . get attribute ( name ) ; }
public static void throw exception if field be not find ( class < ? > type , string field name , field field ) { if ( field == null ) { throw new field not find exception ( `` no field be find with name ' `` + field name + `` ' in class `` + type . get name ( ) + `` . `` ) ; } }
public enum set < e > get ( ) { return value ; }
public int hash code ( ) { return writable comparator . hash byte ( get byte ( ) , get length ( ) ) ; }
public void update report byte count ( int count ) { this . report byte read from compress stream += count ; this . update process byte count ( count ) ; }
public void update report byte count ( int count ) { this . report byte read from compress stream += count ; this . update process byte count ( count ) ; }
public string get message ( ) { list < throwable > list copy = get error ( ) ; string buffer sb = new string buffer ( `` a multi exception have `` + list copy . size ( ) + `` exception . they be : \n `` ) ; int lcv = 1 ; for ( throwable th : list copy ) { sb . append ( lcv++ + `` . `` + th . get class ( ) . get name ( ) + ( ( th . get message ( ) ! = null ) ? `` : `` + th . get message ( ) : `` `` ) + `` \n `` ) ; } return sb . to string ( ) ; }
public compression codec get codec by class name ( string classname ) { if ( codecs by class name == null ) { return null ; } return codecs by class name . get ( classname ) ; }
public synchronize void reset ( ) { finish = false ; finish = false ; uncompressed direct buf . clear ( ) ; uncompressed direct buf len = 0 ; compress direct buf . clear ( ) ; compress direct buf . limit ( 0 ) ; user buf off = user buf len = 0 ; byte read = byte write = 0l ; }
public static boolean content equal ( reader input1 , reader input2 ) throw i o exception { if ( ! ( input1 instanceof buffer reader ) ) { input1 = new buffer reader ( input1 ) ; } if ( ! ( input2 instanceof buffer reader ) ) { input2 = new buffer reader ( input2 ) ; } int ch = input1 . read ( ) ; while ( -1 ! = ch ) { int ch2 = input2 . read ( ) ; if ( ch ! = ch2 ) { return false ; } ch = input1 . read ( ) ; } int ch2 = input2 . read ( ) ; return ( ch2 == -1 ) ; }
public boolean equal ( object o ) { if ( ! ( o instanceof m d5 hash ) ) return false ; m d5 hash other = ( m d5 hash ) o ; return array . equal ( this . digest , other . digest ) ; }
public void write to ( output stream out ) throw i o exception { buffer . write to ( out ) ; }
public static int read u16bit ( byte [ ] code , int index ) { return ( ( code [ index ] & 0xff ) < < 8 ) | ( code [ index + 1 ] & 0xff ) ; }
public static double read double ( byte [ ] byte , int start ) { return double . long bit to double ( read long ( byte , start ) ) ; }
public writable call ( rpc . rpc kind rpc kind , writable rpc request , connection id remote id ) throw i o exception { return call ( rpc kind , rpc request , remote id , rpc . rpc_service_class_default ) ; }
public synchronize client get client ( configuration conf , socket factory factory ) { return this . get client ( conf , factory , object writable . class ) ; }
public int get call queue len ( ) { return call queue . size ( ) ; }
public final expression optimize ( expression visitor visitor , item type context item type ) { return this ; }
public static connection id get connection id for proxy ( object proxy ) { if ( proxy instanceof protocol translator ) { proxy = ( ( protocol translator ) proxy ) . get underlying proxy object ( ) ; } rpc invocation handler inv = ( rpc invocation handler ) proxy . get invocation handler ( proxy ) ; return inv . get connection id ( ) ; }
public static inet address get remote ip ( ) { call call = cur call . get ( ) ; return ( call ! = null & & call . connection ! = null ) ? call . connection . get host inet address ( ) : null ; }
public void set socket buffer size hint ( int socket send buffer size hint , int socket receive buffer size hint ) { this . socket send buffer size hint = socket send buffer size hint ; this . socket receive buffer size hint = socket receive buffer size hint ; }
public static byte [ ] get client id ( ) { call call = cur call . get ( ) ; return call ! = null ? call . client id : rpc constant . dummy_client_id ; }
public void set attribute ( string attribute name , object value ) { attribute map . put ( attribute name , value ) ; }
public synchronize void stop monitoring ( ) { if ( be monitor ) { stop timer ( ) ; be monitor = false ; } }
public static synchronize metric context get null context ( string context name ) { metric context null context = null context map . get ( context name ) ; if ( null context == null ) { null context = new null context ( ) ; null context map . put ( context name , null context ) ; } return null context ; }
protect void set closure delegate ( closure closure , object node ) { closure . set delegate ( this ) ; }
public number get metric ( string name ) { return metric map . get ( name ) ; }
public synchronize int get previous interval num ops ( ) { return previous interval data . num operation ; }
public synchronize metric tag get tag ( string name ) { return tag map . get ( name ) ; }
public mutable gauge int new gauge ( string name , string desc , int i val ) { return new gauge ( intern . info ( name , desc ) , i val ) ; }
public synchronize void snapshot ( metric record builder builder , boolean all ) { for ( metric tag tag : tag ( ) ) { builder . add ( tag ) ; } for ( mutable metric metric : metric ( ) ) { metric . snapshot ( builder , all ) ; } }
public synchronize void snapshot ( metric record builder builder , boolean all ) { for ( metric tag tag : tag ( ) ) { builder . add ( tag ) ; } for ( mutable metric metric : metric ( ) ) { metric . snapshot ( builder , all ) ; } }
protect void xdr_string ( string s ) { byte [ ] bytes = s . get byte ( charsets . utf_8 ) ; int len = byte . length ; xdr_int ( len ) ; system . arraycopy ( byte , 0 , buffer , offset , len ) ; offset += len ; pad ( ) ; }
public string get message ( ) { list < throwable > list copy = get error ( ) ; string buffer sb = new string buffer ( `` a multi exception have `` + list copy . size ( ) + `` exception . they be : \n `` ) ; int lcv = 1 ; for ( throwable th : list copy ) { sb . append ( lcv++ + `` . `` + th . get class ( ) . get name ( ) + ( ( th . get message ( ) ! = null ) ? `` : `` + th . get message ( ) : `` `` ) + `` \n `` ) ; } return sb . to string ( ) ; }
public node choose random ( string scope ) { netlock . read lock ( ) . lock ( ) ; try { if ( scope . start with ( `` ~ `` ) ) { return choose random ( node base . root , scope . substring ( 1 ) ) ; } else { return choose random ( scope , null ) ; } } finally { netlock . read lock ( ) . unlock ( ) ; } }
public static class < object > get inner class type ( class < ? > declare class , string name ) throw class not find exception { return ( class < object > ) class . for name ( declare class . get name ( ) + `` $ `` + name ) ; }
public synchronize void close ( ) throw i o exception { / * close the channel since socket . get input stream ( ) . close ( ) * close the socket . * / reader . channel . close ( ) ; reader . close ( ) ; }
public final void copy ( byte [ ] byte , int offset , int length ) { if ( this . bytes == null || this . byte . length < length ) { this . bytes = new byte [ length ] ; } system . arraycopy ( byte , offset , this . byte , 0 , length ) ; this . count = length ; }
public final void copy ( byte [ ] byte , int offset , int length ) { if ( this . bytes == null || this . byte . length < length ) { this . bytes = new byte [ length ] ; } system . arraycopy ( byte , offset , this . byte , 0 , length ) ; this . count = length ; }
public boolean equal ( object o ) { if ( ! super . equal ( o ) ) return false ; map type i d mti = ( map type i d ) o ; return this . type i d key . equal ( mti . type i d key ) & & this . type i d value . equal ( mti . type i d value ) ; }
public string get proxy superuser user conf key ( string user name ) { return config prefix + user name + conf_users ; }
public void add secret key ( text alias , byte [ ] key ) { secret key map . put ( alias , key ) ; }
public void add secret key ( text alias , byte [ ] key ) { secret key map . put ( alias , key ) ; }
public synchronize void verify token ( token ident identifier , byte [ ] password ) throw invalid token { byte [ ] store password = retrieve password ( identifier ) ; if ( ! array . equal ( password , store password ) ) { throw new invalid token ( `` token ( `` + identifier + `` ) be invalid , password do n't match `` ) ; } }
public static sasl property resolver get sasl property resolver ( configuration conf ) { string qops = conf . get ( dfs_data_transfer_protection_key ) ; if ( qops == null || qops . be empty ( ) ) { log . debug ( `` data transfer protocol not use sasl property resolver , no `` + `` qop found in configuration for { } `` , dfs_data_transfer_protection_key ) ; return null ; } configuration sasl prop resolver conf = new configuration ( conf ) ; sasl prop resolver conf . set ( hadoop_rpc_protection , qops ) ; class < ? extend sasl property resolver > resolver class = conf . get class ( hadoop_security_sasl_props_resolver_class , sasl property resolver . class , sasl property resolver . class ) ; resolver class = conf . get class ( dfs_data_transfer_sasl_props_resolver_class_key , resolver class , sasl property resolver . class ) ; sasl prop resolver conf . set class ( hadoop_security_sasl_props_resolver_class , resolver class , sasl property resolver . class ) ; sasl property resolver resolver = sasl property resolver . get instance ( sasl prop resolver conf ) ; log . debug ( `` data transfer protocol use sasl property resolver , configure `` + `` qop { } = { } , configured class { } = { } `` , dfs_data_transfer_protection_key , qops , dfs_data_transfer_sasl_props_resolver_class_key , resolver class ) ; return resolver ; }
public synchronize void check t g t and relogin from keytab ( ) throw i o exception { if ( ! be security enable ( ) || user . get authentication method ( ) ! = authentication method . kerberos || ! be keytab ) return ; kerberos ticket tgt = get t g t ( ) ; if ( tgt ! = null & & ! should renew immediately for test & & time . now ( ) < get refresh time ( tgt ) ) { return ; } relogin from keytab ( ) ; }
public static < t > t do a current user ( privileged exception action < t > action ) throw i o exception { return do a user ( user group information . get current user ( ) , action ) ; }
public synchronize void destroy ( ) { if ( trust manager ! = null ) { trust manager . destroy ( ) ; trust manager = null ; key manager = null ; trust manager = null ; } }
public t decode identifier ( ) throw i o exception { class < ? extend token identifier > cl = get class for identifier ( get kind ( ) ) ; if ( cls == null ) { return null ; } token identifier token identifier = reflection utils . new instance ( cl , null ) ; byte array input stream buf = new byte array input stream ( identifier ) ; data input stream in = new data input stream ( buf ) ; token identifier . read field ( in ) ; in . close ( ) ; return ( t ) token identifier ; }
public boolean have kerberos credential ( ) { return be keytab || be krb tkt ; }
public boolean add token ( text alias , token < ? extend token identifier > token ) { synchronize ( subject ) { get credential internal ( ) . add token ( alias , token ) ; return true ; } }
public boolean add token ( text alias , token < ? extend token identifier > token ) { synchronize ( subject ) { get credential internal ( ) . add token ( alias , token ) ; return true ; } }
protect void put blocker ( string name , string detail ) { synchronize ( blocker map ) { blocker map . put ( name , detail ) ; } }
public void ensure current state ( service . state expect state ) { if ( state ! = expect state ) { throw new service state exception ( name+ `` : for this operation , the `` + `` current service state must be `` + expect state + `` instead of `` + state ) ; } }
public int set close ( ) throw closed channel exception { while ( true ) { int cur bit = status . get ( ) ; if ( ( cur bit & status_closed_mask ) ! = 0 ) { throw new closed channel exception ( ) ; } if ( status . compare and set ( cur bit , cur bit | status_closed_mask ) ) { return cur bit & ( ~status_closed_mask ) ; } } }
public int read line ( text str , int max line length ) throw i o exception { return read line ( str , max line length , integer . max_value ) ; }
public void set reduce speculative execution ( boolean speculative execution ) { set boolean ( job context . reduce_speculative , speculative execution ) ; }
public progress add phase ( string status ) { progress phase = add phase ( ) ; phase . set status ( status ) ; return phase ; }
public static void skip fully ( final input stream input , final long to skip ) throw i o exception { if ( to skip < 0 ) { throw new illegal argument exception ( `` byte to skip must not be negative : `` + to skip ) ; } final long skip = skip ( input , to skip ) ; if ( skip ! = to skip ) { throw new e o f exception ( `` byte to skip : `` + to skip + `` actual : `` + skip ) ; } }
public int get exit code ( ) { return this . exit code ; }
public void next byte ( byte [ ] bytes ) { int bytes out = 0 ; while ( bytes out < byte . length ) { int rand int = next int ( ) ; for ( int i = 0 ; i < 3 ; i++ ) { if ( i > 0 ) { rand int > > = 8 ; } bytes [ byte out++ ] = ( byte ) rand int ; if ( bytes out == byte . length ) { return ; } } } }
public static string get version ( ) { return common_version_info . _get version ( ) ; }
public void clear quota ( path src ) throw i o exception { dfs . set quota ( src , hdfs constant . quota_reset , hdfs constant . quota_dont_set ) ; }
public void disallow snapshot ( path path ) throw i o exception { dfs . disallow snapshot ( path ) ; }
public void remove cache directive ( long id ) throw i o exception { dfs . remove cache directive ( id ) ; }
public void remove cache directive ( long id ) throw i o exception { dfs . remove cache directive ( id ) ; }
public void add cache pool ( cache pool info info ) throw i o exception { dfs . add cache pool ( info ) ; }
public void add cache pool ( cache pool info info ) throw i o exception { dfs . add cache pool ( info ) ; }
public d f s input stream . read statistic get read statistic ( ) { return get d f s input stream ( ) . get read statistic ( ) ; }
public synchronize boolean seek to new source ( long target po ) throw i o exception { boolean mark dead = dead node . contains key ( current node ) ; add to dead node ( current node ) ; datanode info old node = current node ; datanode info new node = block seek to ( target po ) ; if ( ! mark dead ) { / * remove it from dead node . block seek to could have clear * dead node and add current node again . thats ok . * / dead node . remove ( old node ) ; } if ( ! old node . get datanode uuid ( ) . equal ( new node . get datanode uuid ( ) ) ) { current node = new node ; return true ; } else { return false ; } }
public list < locate block > get all block ( ) throw i o exception { return get block range ( 0 , get file length ( ) ) ; }
public static < t extend number > extract image patch < t > create ( scope scope , operand < t > image , list < long > ksizes , list < long > stride , list < long > rate , string pad ) { operation builder op builder = scope . graph ( ) . op builder ( `` extract image patch `` , scope . make op name ( `` extract image patch `` ) ) ; op builder . add input ( image . a output ( ) ) ; long [ ] ksizes array = new long [ ksizes . size ( ) ] ; for ( int i = 0 ; i < ksizes array . length ; ++i ) { ksizes array [ i ] = ksizes . get ( i ) ; } op builder . set attr ( `` ksizes `` , ksizes array ) ; long [ ] stride array = new long [ stride . size ( ) ] ; for ( int i = 0 ; i < stride array . length ; ++i ) { strides array [ i ] = stride . get ( i ) ; } op builder . set attr ( `` stride `` , stride array ) ; long [ ] rate array = new long [ rate . size ( ) ] ; for ( int i = 0 ; i < rate array . length ; ++i ) { rate array [ i ] = rate . get ( i ) ; } op builder . set attr ( `` rate `` , rate array ) ; op builder . set attr ( `` pad `` , pad ) ; return new extract image patch < t > ( op builder . build ( ) ) ; }
public static string get secondary name service id ( configuration conf ) { return get name service id ( conf , dfs_namenode_secondary_http_address_key ) ; }
public static void get visible result ( session session , result target result , column [ ] column , array list < array list < expression > > row ) { int count = column . length ; for ( array list < expression > row : row ) { value [ ] value = new value [ count ] ; for ( int i = 0 ; i < count ; i++ ) { value [ i ] = row . get ( i ) . get value ( session ) . convert to ( columns [ i ] . get type ( ) , session , false , null ) ; } result . add row ( value ) ; } }
protect void set auth handler class ( property prop ) throw servlet exception { string auth type = prop . get property ( auth_type ) ; if ( auth type == null ) { throw new servlet exception ( `` config property `` + auth_type + `` do n't exist `` ) ; } if ( auth type . equal ( pseudo authentication handler . type ) ) { prop . set property ( auth_type , pseudo delegation token authentication handler . class . get name ( ) ) ; } else if ( auth type . equal ( kerberos authentication handler . type ) ) { prop . set property ( auth_type , kerberos delegation token authentication handler . class . get name ( ) ) ; } }
public static void write ( final policy policy , final boolean best effort , final configuration conf ) { conf . set boolean ( d f s config key . dfs_client_write_replace_datanode_on_failure_enable_key , policy ! = policy . disable ) ; conf . set ( d f s config key . dfs_client_write_replace_datanode_on_failure_policy_key , policy . name ( ) ) ; conf . set boolean ( d f s config key . dfs_client_write_replace_datanode_on_failure_best_effort_key , best effort ) ; }
public boolean be in safe mode ( ) throw i o exception { return set safe mode ( safe mode action . safemode_get , true ) ; }
public void remove cache directive ( long id ) throw i o exception { dfs . remove cache directive ( id ) ; }
public string get block path ( ) { return local block path ; }
public float get dfs use percent ( ) { return d f s util . get percent use ( dfs use , capacity ) ; }
public float get dfs use percent ( ) { return d f s util . get percent use ( dfs use , capacity ) ; }
public void set capacity ( long capacity ) { this . capacity = capacity ; }
public string get config version ( ) { return this . config version ; }
public int get header flag ( int i ) { if ( proto . get flag count ( ) > 0 ) { return proto . get flag ( i ) ; } else { return combine header ( ecn . disabled , proto . get reply ( i ) ) ; } }
public boolean be complete ( ) { if ( sasl client ! = null ) { return sasl client . be complete ( ) ; } else { return sasl server . be complete ( ) ; } }
protect double get domain low bound ( double p ) { return 0 ; }
public int get remain entry ( ) { return remain entry ; }
public boolean be decommission ( ) { return admin state == admin state . decommission ; }
public void update cache storage info ( ) { if ( storage i ds ! = null ) { for ( int i = 0 ; i < locs . length ; i++ ) { storage i ds [ i ] = locs [ i ] . get storage i d ( ) ; } } if ( storage type ! = null ) { for ( int i = 0 ; i < locs . length ; i++ ) { storage type [ i ] = locs [ i ] . get storage type ( ) ; } } }
protect executor find qualified executor ( bean factory bean factory , string qualifier ) { if ( bean factory == null ) { throw new illegal state exception ( `` bean factory must be set on `` + get class ( ) . get simple name ( ) + `` to access qualified executor ' `` + qualifier + `` ' `` ) ; } return bean factory annotation utils . qualified bean of type ( bean factory , executor . class , qualifier ) ; }
public synchronize exported block key export key ( ) { if ( ! be master ) return null ; if ( log . be debug enable ( ) ) log . debug ( `` export access key `` ) ; return new export block key ( true , key update interval , token lifetime , current key , all key . value ( ) . to array ( new block key [ 0 ] ) ) ; }
public boolean be complete ( ) { return get block u c state ( ) . equal ( block u c state . complete ) ; }
public int compare ( module revision id ask mrid , module revision id find mrid , comparator static comparator ) { return need module descriptor ( ask mrid , find mrid ) ? 0 : 1 ; }
public boolean check block report receive ( ) { if ( this . get storage info ( ) . length == 0 ) { return false ; } for ( datanode storage info storage info : this . get storage info ( ) ) { if ( storage info . get block report count ( ) == 0 ) return false ; } return true ; }
public synchronize boolean create storage i d ( storage directory sd , boolean regenerate storage id ) { final string old storage i d = sd . get storage uuid ( ) ; if ( old storage i d == null || regenerate storage id ) { sd . set storage uuid ( datanode storage . generate uuid ( ) ) ; log . info ( `` generate new storage i d `` + sd . get storage uuid ( ) + `` for directory `` + sd . get root ( ) + ( old storage i d == null ? `` `` : ( `` to replace `` + old storage i d ) ) ) ; return true ; } return false ; }
public void read property ( storage directory sd ) throw i o exception { property prop = read property file ( sd . get version file ( ) ) ; set field from property ( prop , sd ) ; }
public data checksum get checksum ( ) { return checksum ; }
public static string elapse time ( long milli ) { long second = milli / 1000 ; milli % = 1000 ; long minute = second / 60 ; second % = 60 ; long hour = minute / 60 ; minute % = 60 ; return hour + `` h `` + minute + `` m `` + second + `` s `` + milli ; }
public sasl property resolver get sasl prop resolver ( ) { return sasl prop resolver ; }
public long get failure date ( ) { return this . failure date ; }
public void sync data out ( ) throw i o exception { if ( data out instanceof file output stream ) { ( ( file output stream ) data out ) . get channel ( ) . force ( true ) ; } }
public file get meta file ( ) { return new file ( get dir ( ) , datanode util . get meta name ( get block name ( ) , get generation stamp ( ) ) ) ; }
public final void schedule ( ) { super . schedule ( 0l ) ; }
public boolean unlink block ( int num link ) throw i o exception { if ( be unlinked ( ) ) { return false ; } file file = get block file ( ) ; if ( file == null || get volume ( ) == null ) { throw new i o exception ( `` detach block : block not find . `` + this ) ; } file meta = get meta file ( ) ; if ( hard link . get link count ( file ) > num link ) { data node . log . info ( `` copy on write for block `` + this ) ; unlink file ( file , this ) ; } if ( hard link . get link count ( meta ) > num link ) { unlink file ( meta , this ) ; } set unlinked ( ) ; return true ; }
public string get blockpool i d ( ) { return blockpool i d ; }
public void create ( int layout version ) throw i o exception { fc . truncate ( 0 ) ; fc . position ( 0 ) ; write header ( layout version , double buf . get current buf ( ) ) ; set ready to flush ( ) ; flush ( ) ; }
public final expression optimize ( expression visitor visitor , item type context item type ) { return this ; }
public static int find late snapshot ( i node inode , final int anchor ) { int late = no_snapshot_id ; for ( ; inode ! = null ; inode = inode . get parent ( ) ) { if ( inode . be directory ( ) ) { final i node directory dir = inode . a directory ( ) ; if ( dir . be with snapshot ( ) ) { late = dir . get diffs ( ) . update prior ( anchor , late ) ; } } } return late ; }
public void log open file ( string path , i node file new node , boolean overwrite , boolean to log rpc id ) { precondition . check argument ( new node . be under construction ( ) ) ; permission status permission = new node . get permission status ( ) ; add op op = add op . get instance ( cache . get ( ) ) . set inode id ( new node . get id ( ) ) . set path ( path ) . set replication ( new node . get file replication ( ) ) . set modification time ( new node . get modification time ( ) ) . set access time ( new node . get access time ( ) ) . set block size ( new node . get preferred block size ( ) ) . set block ( new node . get block ( ) ) . set permission status ( permission ) . set client name ( new node . get file under construction feature ( ) . get client name ( ) ) . set client machine ( new node . get file under construction feature ( ) . get client machine ( ) ) . set overwrite ( overwrite ) . set storage policy id ( new node . get local storage policy i d ( ) ) ; acl feature f = new node . get acl feature ( ) ; if ( f ! = null ) { op . set acl entry ( acl storage . read i node logical acl ( new node ) ) ; } x attr feature x = new node . get x attr feature ( ) ; if ( x ! = null ) { op . set x attrs ( x . get x attrs ( ) ) ; } log rpc id ( op , to log rpc id ) ; log edit ( op ) ; }
public long get last h a transition time ( ) { return last h a transition time ; }
public synchronize proxy info < t > get proxy ( ) { address rpc proxy pair < t > current = proxy . get ( current proxy index ) ; if ( current . namenode == null ) { try { current . namenode = name node proxy . create non h a proxy ( conf , current . address , xface , ugi , false , fallback to simple auth ) . get proxy ( ) ; } catch ( i o exception e ) { log . error ( `` fail to create rpc proxy to name node `` , e ) ; throw new runtime exception ( e ) ; } } return new proxy info < t > ( current . namenode , current . address . to string ( ) ) ; }
public boolean get curly brace denote code block ( int language index ) { return true ; }
protect double get domain low bound ( double p ) { return 0 ; }
public final void set parent ( i node directory parent ) { this . parent = parent ; }
public i node file to complete file ( long mtime ) { precondition . check state ( be under construction ( ) , `` file be no longer under construction `` ) ; file under construction feature uc = get file under construction feature ( ) ; if ( uc ! = null ) { assert all block complete ( ) ; remove feature ( uc ) ; this . set modification time ( mtime ) ; } return this ; }
public static byte [ ] merge local file data data ( zip extra field [ ] data ) { int sum = 4 * data . length ; for ( int i = 0 ; i < data . length ; i++ ) { sum += data [ i ] . get local file data length ( ) . get value ( ) ; } byte [ ] result = new byte [ sum ] ; int start = 0 ; for ( int i = 0 ; i < data . length ; i++ ) { system . arraycopy ( data [ i ] . get header id ( ) . get byte ( ) , 0 , result , start , 2 ) ; system . arraycopy ( data [ i ] . get local file data length ( ) . get byte ( ) , 0 , result , start + 2 , 2 ) ; byte [ ] local = data [ i ] . get local file data data ( ) ; system . arraycopy ( local , 0 , result , start + 4 , local . length ) ; start += ( local . length + 4 ) ; } return result ; }
public void start ( ) throw i o exception { precondition . check state ( ! be start ( ) , `` jn already run `` ) ; validate and create journal dir ( local dir ) ; default metric system . initialize ( `` journal node `` ) ; jvm metric . create ( `` journal node `` , conf . get ( d f s config key . dfs_metrics_session_id_key ) , default metric system . instance ( ) ) ; inet socket address soc addr = journal node rpc server . get address ( conf ) ; security util . login ( conf , d f s config key . dfs_journalnode_keytab_file_key , d f s config key . dfs_journalnode_kerberos_principal_key , soc addr . get host name ( ) ) ; register j n m x bean ( ) ; http server = new journal node http server ( conf , this ) ; http server . start ( ) ; http server u r i = http server . get server u r i ( ) . to string ( ) ; rpc server = new journal node rpc server ( conf , this ) ; rpc server . start ( ) ; }
public boolean add child ( i node directory parent , i node inode , boolean set mod time , int late snapshot id ) throw quota exceed exception { child diff diff = diffs . check and add late snapshot diff ( late snapshot id , parent ) . diff ; int undo info = diff . create ( inode ) ; final boolean add = parent . add child ( inode , set mod time , snapshot . current_state_id ) ; if ( ! add ) { diff . undo create ( inode , undo info ) ; } return add ; }
public long get elapsed time ( ) { return get elapsed time ( phase . get ( phase . loading_fsimage ) , phase . get ( phase . safemode ) ) ; }
public void begin phase ( phase phase ) { if ( ! be complete ( ) ) { phase . get ( phase ) . begin time = monotonic now ( ) ; } }
public long get elapsed time ( ) { return get elapsed time ( phase . get ( phase . loading_fsimage ) , phase . get ( phase . safemode ) ) ; }
public float get percent complete ( ) { if ( get status ( phase . safemode ) == status . complete ) { return 1 . 0f ; } else { float total = 0 . 0f ; int num phase = 0 ; for ( phase phase : phase . key set ( ) ) { ++num phase ; total += get percent complete ( phase ) ; } return get bound percent ( total / num phase ) ; } }
public string get description ( ) { return description ; }
public int save namespace ( ) throw i o exception { int exit code = -1 ; distribute file system dfs = get d f s ( ) ; configuration dfs conf = dfs . get conf ( ) ; uri dfs uri = dfs . get uri ( ) ; boolean be ha enabled = h a util . be logical uri ( dfs conf , dfs uri ) ; if ( be ha enable ) { string ns id = dfs uri . get host ( ) ; list < proxy and info < client protocol > > proxy = h a util . get proxy for all name node in nameservice ( dfs conf , ns id , client protocol . class ) ; for ( proxy and info < client protocol > proxy : proxy ) { proxy . get proxy ( ) . save namespace ( ) ; system . out . println ( `` save namespace successful for `` + proxy . get address ( ) ) ; } } else { dfs . save namespace ( ) ; system . out . println ( `` save namespace successful `` ) ; } exit code = 0 ; return exit code ; }
public cancel task request set reason ( string reason ) { this . reason = reason ; return this ; }
public int create ( final e element ) { final int c = search ( create , element . get key ( ) ) ; insert ( list type . create , element , c ) ; return c ; }
public int create ( final e element ) { final int c = search ( create , element . get key ( ) ) ; insert ( list type . create , element , c ) ; return c ; }
public final void set ( final e e , final long value ) { counter [ e . ordinal ( ) ] = value ; }
protect void expand if necessary ( ) { if ( size > this . expand threshold & & capacity < maximum_capacity ) { resize ( capacity * expand multiplier ) ; } }
public static void remove acl feature ( acl feature acl feature ) { unique_acl_features . remove ( acl feature ) ; }
public set < k > key set ( ) { if ( key set == null ) { key set = new reference key set < > ( this ) ; } return key set ; }
public void clear ( ) { reference map . clear ( ) ; }
protect void init token aspect ( ) { token aspect = new token aspect < hftp file system > ( this , token service name , token_kind ) ; }
public path get output index file ( ) throw i o exception { path attempt index output = new path ( get attempt output dir ( ) , map_output_filename_string + map_output_index_suffix_string ) ; return l dir alloc . get local path to read ( attempt index output . to string ( ) , conf ) ; }
protect void start job ( ) { / * * create a job-start event to get this ball roll * / job event start job event = new job start event ( job . get i d ( ) , recover job start time ) ; / * * send the job-start event . this trigger the job execution . * / dispatcher . get event handler ( ) . handle ( start job event ) ; }
public string get node http address ( ) { read lock . lock ( ) ; try { return container == null ? null : container . get node http address ( ) ; } finally { read lock . unlock ( ) ; } }
@ override protected class < ? extend sub view > content ( ) { return conf block . class ; }
public boolean have local classpaths ( ) { if ( ! setup call ) { throw new illegal state exception ( `` have local classpaths ( ) should be call after setup ( ) `` ) ; } return ! local classpaths . be empty ( ) ; }
public long get finish time ( ) { return finish time ; }
public int get map task ( ) { return map_tasks ; }
public long get start time ( ) { ensure state ( job state . run ) ; return status . get start time ( ) ; }
public void remove map ( string map id ) { index information info = cache . get ( map id ) ; if ( info == null || be under construction ( info ) ) { return ; } info = cache . remove ( map id ) ; if ( info ! = null ) { total memory use . add and get ( -info . get size ( ) ) ; if ( ! queue . remove ( map id ) ) { log . warn ( `` map id `` + map id + `` not find in queue ! ! `` ) ; } } else { log . info ( `` map id `` + map id + `` not find in cache `` ) ; } }
protect void initialize interval ( ) { state . current accumulation = 0 . 0d ; }
public long get start ( ) { return f . get start ( ) ; }
public job queue info [ ] get child queue ( final string queue name ) throw i o exception { try { return client ugi . do a ( new privilege exception action < job queue info [ ] > ( ) { public job queue info [ ] run ( ) throw i o exception , interrupted exception { return get job queue info array ( cluster . get child queue ( queue name ) ) ; } } ) ; } catch ( interrupted exception ie ) { throw new i o exception ( ie ) ; } }
public cluster get cluster handle ( ) { return cluster ; }
public void set task output filter ( task status filter new value ) { this . task output filter = new value ; }
public string get job name ( ) { return get ( job context . job_name , `` `` ) ; }
public void set work directory ( path dir ) { dir = new path ( get work directory ( ) , dir ) ; set ( job context . working_dir , dir . to string ( ) ) ; }
public int get num map task ( ) { return get int ( job context . num_maps , 1 ) ; }
public void set session id ( string session id ) { set ( `` session . id `` , session id ) ; }
public void set max reduce task failure percent ( int percent ) { set int ( job context . reduce_failures_maxpercent , percent ) ; }
public void set queue name ( string queue name ) { set ( job context . queue_name , queue name ) ; }
public static job i d for name ( string str ) throw illegal argument exception { return ( job i d ) org . apache . hadoop . mapreduce . job i d . for name ( str ) ; }
public string get queue name ( ) { return queue name ; }
public void write ( data output out ) throw i o exception { writable utils . write v int ( out , split . length ) ; for ( input split s : split ) { text . write string ( out , s . get class ( ) . get name ( ) ) ; } for ( input split s : split ) { s . write ( out ) ; } }
public input split get ( int i ) { return split [ i ] ; }
protect void fill join collector ( k iterkey ) throw i o exception { if ( ! q . be empty ( ) ) { q . peek ( ) . key ( iterkey ) ; while ( 0 == cmp . compare ( q . peek ( ) . key ( ) , iterkey ) ) { composable record reader < k , ? > t = q . poll ( ) ; t . accept ( jc , iterkey ) ; if ( t . have next ( ) ) { q . add ( t ) ; } else if ( q . be empty ( ) ) { return ; } } } }
public k create key ( ) { if ( null == keyclass ) { final class < ? > cl = kid [ 0 ] . create key ( ) . get class ( ) ; for ( record reader < k , ? extend writable > rr : kid ) { if ( ! cl . equal ( rr . create key ( ) . get class ( ) ) ) { throw new class cast exception ( `` child key class fail to agree `` ) ; } } keyclass = cl . a subclass ( writable comparable . class ) ; } return ( k ) reflection utils . new instance ( keyclass , get conf ( ) ) ; }
public void key ( k key ) throw i o exception { writable utils . clone into ( key , key ( ) ) ; }
public boolean equal ( object other ) { return other instanceof composable record reader & & 0 == compare to ( ( composable record reader ) other ) ; }
public k create key ( ) { return rr . create key ( ) ; }
public static job conf create value aggregator job ( string args [ ] ) throw i o exception { return create value aggregator job ( args , value aggregator . class ) ; }
public void close ( ) throw i o exception { for ( mapper map : mapper ) { map . close ( ) ; } if ( reducer ! = null ) { reducer . close ( ) ; } }
public void close ( ) throw i o exception { for ( mapper map : mapper ) { map . close ( ) ; } if ( reducer ! = null ) { reducer . close ( ) ; } }
public final expression optimize ( expression visitor visitor , item type context item type ) { return this ; }
public void partition output ( int reduce , k key , v value ) throw i o exception { pipes partitioner . set next partition ( reduce ) ; collector . collect ( key , value ) ; }
public static void set be java record reader ( job conf conf , boolean value ) { conf . set boolean ( submitter . is_java_rr , value ) ; }
public synchronize object get scheduler info ( string queue name ) { if ( all queue . get ( queue name ) ! = null ) { return all queue . get ( queue name ) . get scheduling info ( ) ; } return null ; }
public file status [ ] glob status ( path path pattern , path filter filter ) throw i o exception { return new globber ( this , path pattern , filter ) . glob ( ) ; }
public byte [ ] get encrypt spill key ( ) { return encrypt spill key ; }
public static synchronize list < statistic > get all statistic ( ) { return new array list < statistic > ( statistic table . value ( ) ) ; }
public static path get remote node log file for app ( path remote root log dir , application id app id , string user , node id node id , string suffix ) { return new path ( get remote app log dir ( remote root log dir , app id , user , suffix ) , get node string ( node id ) ) ; }
public string get task id ( ) { return task i d . downgrade ( super . get task i d ( ) ) . to string ( ) ; }
public sort range . range get next record range ( ) { return next record range ; }
public final void schedule ( ) { super . schedule ( 0l ) ; }
public long get finish time ( ) { return finish time ; }
protect synchronized void set phase ( task status . phase phase ) { this . task status . set phase ( phase ) ; }
public long get finish time ( ) { return finish time ; }
public string map path ( string path ) { return null ; }
public static f s data output stream wrap if necessary ( configuration conf , f s data output stream out ) throw i o exception { if ( be encrypt spill enable ( conf ) ) { out . write ( byte buffer . allocate ( 8 ) . put long ( out . get pos ( ) ) . array ( ) ) ; byte [ ] iv = create i v ( conf ) ; out . write ( iv ) ; if ( log . be debug enable ( ) ) { log . debug ( `` iv write to stream [ `` + base64 . encode base64 u r l safe string ( iv ) + `` ] `` ) ; } return new crypto f s data output stream ( out , crypto codec . get instance ( conf ) , get buffer size ( conf ) , get encryption key ( ) , iv ) ; } else { return out ; } }
public static void set cache archive ( uri [ ] archive , configuration conf ) { string sarchives = string utils . uri to string ( archive ) ; conf . set ( m r job config . cache_archives , sarchives ) ; }
public static path [ ] get file class path ( configuration conf ) { array list < string > list = ( array list < string > ) conf . get string collection ( m r job config . classpath_files ) ; if ( list . size ( ) == 0 ) { return null ; } path [ ] path = new path [ list . size ( ) ] ; for ( int i = 0 ; i < list . size ( ) ; i++ ) { paths [ i ] = new path ( list . get ( i ) ) ; } return path ; }
public string map path ( string path ) { return null ; }
public float reduce progress ( ) throw i o exception { ensure state ( job state . run ) ; ensure fresh status ( ) ; return status . get reduce progress ( ) ; }
public synchronize boolean be job complete ( ) { return ( run state == job status . state . succeed || run state == job status . state . fail || run state == job status . state . kill ) ; }
public void kill task ( final task attempt i d task id ) throw i o exception { kill task ( task id , false ) ; }
public void kill job ( ) throw i o exception { ensure state ( job state . run ) ; try { cluster . get client ( ) . kill job ( get job i d ( ) ) ; } catch ( interrupted exception ie ) { throw new i o exception ( ie ) ; } }
public void set jar ( string jar ) { ensure state ( job state . define ) ; conf . set jar ( jar ) ; }
public int get finish reduces ( ) { return datum . get finished reduces ( ) ; }
public counter get map counter ( ) { return map counter ; }
public job i d get job id ( ) { return job i d . for name ( datum . jobid . to string ( ) ) ; }
public int get total reduces ( ) { return datum . total reduces ; }
public string get workflow name ( ) { if ( datum . workflow name ! = null ) { return datum . workflow name . to string ( ) ; } return null ; }
public long get finish time ( ) { return finish time ; }
protect synchronized void set queue ( string queue ) { this . queue = queue ; }
public static path get job conf path ( path job submit dir ) { return new path ( job submit dir , `` job . xml `` ) ; }
public static path get job dist cache archive ( path job submit dir ) { return new path ( job submit dir , `` archive `` ) ; }
protect void set min split size rack ( long min split size rack ) { this . min split size rack = min split size rack ; }
public long get weight ( long id ) { return ( long ) 1 ; }
public writable get ( int i ) { return value [ i ] ; }
public path get job attempt path ( job context context ) { return get job attempt path ( context , get output path ( ) ) ; }
protect static void set output name ( job context job , string name ) { job . get configuration ( ) . set ( base_output_name , name ) ; }
public int get partition ( binary comparable key , v value , int num partition ) { int length = key . get length ( ) ; int leave index = ( left offset + length ) % length ; int right index = ( right offset + length ) % length ; int hash = writable comparator . hash byte ( key . get byte ( ) , leave index , right index - leave index + 1 ) ; return ( hash & integer . max_value ) % num partition ; }
public void set job name ( string name ) { set ( job context . job_name , name ) ; }
public void set job i d ( job i d job id ) { this . job id = job id ; }
public path [ ] get local cache archive ( ) throw i o exception { return distribute cache . get local cache archive ( conf ) ; }
public synchronize void penalize ( ) { state = state . penalize ; }
public string get status ( ) { return status ; }
public string get task id ( ) { return task i d . downgrade ( super . get task i d ( ) ) . to string ( ) ; }
public float setup progress ( ) throw i o exception { ensure state ( job state . run ) ; ensure fresh status ( ) ; return status . get setup progress ( ) ; }
public task i d get task i d ( ) { return taskid ; }
public static void kill process ( string pid ) { maybe signal process ( pid , sigkill , sigkill_str , false ) ; }
public static boolean be process group alive ( string pgrp id ) { shell command executor shexec = null ; try { string [ ] args = { `` kill `` , `` -0 `` , `` - `` +pgrp id } ; shexec = new shell command executor ( args ) ; shexec . execute ( ) ; } catch ( exit code exception ee ) { return false ; } catch ( i o exception ioe ) { log . warn ( `` error execute shell command `` + shexec . to string ( ) + ioe ) ; return false ; } return ( shexec . get exit code ( ) == 0 ? true : false ) ; }
public string get description ( ) { return description ; }
public void add domain ( timeline domain domain ) { domain . add ( domain ) ; }
public string get user ( ) { return this . user ; }
public static < t extend container request > a m r m client < t > create a m r m client ( ) { a m r m client < t > client = new a m r m client impl < t > ( ) ; return client ; }
public static token get n m token ( string node addr ) { return nm_token_cache . get token ( node addr ) ; }
public static n m client create n m client ( ) { n m client client = new n m client impl ( ) ; return client ; }
public static < t > t create r m proxy ( final configuration configuration , final class < t > protocol ) throw i o exception { return create r m proxy ( configuration , protocol , instance ) ; }
protect void set closure delegate ( closure closure , object node ) { closure . set delegate ( this ) ; }
public static void equal ( object expect value , object actual value , string message ) { if ( ! actual value . equal ( expect value ) ) { throw new assertion fail exception ( `` expect `` + expect value + `` but encounter `` + actual value + ( message ! = null ? `` : `` + message : `` `` ) ) ; } }
public static string sjoin ( object . . . args ) { return ssv_joiner . join ( args ) ; }
public static iterable < string > split ( char sequence s ) { return ssv_splitter . split ( s ) ; }
public static string get version ( ) { return yarn_version_info . _get version ( ) ; }
public static string get version ( ) { return yarn_version_info . _get version ( ) ; }
public static string get version ( ) { return yarn_version_info . _get version ( ) ; }
public boolean get curly brace denote code block ( int language index ) { return true ; }
public void copy into ( final abstract histogram target histogram ) { target histogram . reset ( ) ; target histogram . add ( this ) ; target histogram . set start time stamp ( this . start time stamp msec ) ; target histogram . set end time stamp ( this . end time stamp msec ) ; }
public void shift value leave ( final int number of binary order of magnitude ) { shift value leave ( number of binary order of magnitude , integer to double value conversion ratio ) ; }
public double histogram copy ( ) { final double histogram target histogram = new double histogram ( configured high to lowest value ratio , get number of significant value digit ( ) ) ; target histogram . set trackable value range ( current low value in auto range , current high value limit in auto range ) ; integer value histogram . copy into ( target histogram . integer value histogram ) ; return target histogram ; }
public synchronize void get interval histogram into ( double histogram target histogram ) { perform interval sample ( ) ; inactive histogram . copy into ( target histogram ) ; }
public encodable histogram next interval histogram ( final double start time sec , final double end time sec ) { return next interval histogram ( start time sec , end time sec , false ) ; }
public encodable histogram next interval histogram ( final double start time sec , final double end time sec ) { return next interval histogram ( start time sec , end time sec , false ) ; }
public void close ( ) { log . close ( ) ; }
public long get start time stamp ( ) { return start time stamp msec ; }
public long get value ( ) { return value ; }
public void record value ( final double value ) { long critical value at enter = record phaser . writer critical section enter ( ) ; try { active histogram . record value ( value ) ; } finally { record phaser . writer critical section exit ( critical value at enter ) ; } }
public metadata source add resource ( string name ) { get xml binding for write ( ) . add ( get xml map binder access ( ) . bind ( name ) ) ; return this ; }
public static access type from xml ( string name ) { return access type . value of ( name ) ; }
public void set temporal ( temporal type value ) { this . temporal = value ; }
public jaxb convert get convert ( ) { return convert ; }
public void set cascade refresh ( jaxb empty type value ) { this . cascade refresh = value ; }
public jaxb empty type get cascade detach ( ) { return cascade detach ; }
public list < string > get column name ( ) { if ( column name == null ) { column name = new array list < string > ( ) ; } return this . column name ; }
public void set updatable ( boolean value ) { this . updatable = value ; }
public string get column definition ( ) { return column definition ; }
public jaxb convert get convert ( ) { return convert ; }
public void set disable conversion ( boolean value ) { this . disable conversion = value ; }
public temporal type get map key temporal ( ) { return map key temporal ; }
public list < jaxb attribute override > get attribute override ( ) { if ( attribute override == null ) { attribute override = new array list < jaxb attribute override > ( ) ; } return this . attribute override ; }
public jaxb collection table get collection table ( ) { return collection table ; }
public string get entity class ( ) { return entity class ; }
public void set entity class ( string value ) { this . entity class = value ; }
public void set exclude superclass listener ( jaxb empty type value ) { this . exclude superclass listener = value ; }
public generation type get strategy ( ) { return strategy ; }
public string get column definition ( ) { return column definition ; }
public string get procedure name ( ) { return procedure name ; }
public string get method name ( ) { return method name ; }
public integer get allocation size ( ) { return allocation size ; }
public void set pk column value ( string value ) { this . pk column value = value ; }
protect identifier get identifier ( string name , boolean quote , jdbc environment jdbc environment ) { if ( be case insensitive ( jdbc environment ) ) { name = name . to lower case ( locale . root ) ; } return new identifier ( name , quote ) ; }
public static void bitandorxornot_bin and or xor not ( query engine query engine ) { query engine . get sqm function registry ( ) . name descriptor builder ( `` bin_and `` ) . set min argument count ( 1 ) . register ( ) ; query engine . get sqm function registry ( ) . register alternate key ( `` bitand `` , `` bin_and `` ) ; query engine . get sqm function registry ( ) . name descriptor builder ( `` bin_or `` ) . set min argument count ( 1 ) . register ( ) ; query engine . get sqm function registry ( ) . register alternate key ( `` bitor `` , `` bin_or `` ) ; query engine . get sqm function registry ( ) . name descriptor builder ( `` bin_xor `` ) . set min argument count ( 1 ) . register ( ) ; query engine . get sqm function registry ( ) . register alternate key ( `` bitxor `` , `` bin_xor `` ) ; query engine . get sqm function registry ( ) . name descriptor builder ( `` bin_not `` ) . set exact argument count ( 1 ) . register ( ) ; query engine . get sqm function registry ( ) . register alternate key ( `` bitnot `` , `` bin_not `` ) ; }
public static void every any_sum case ( query engine query engine ) { query engine . get sqm function registry ( ) . register ( `` every `` , new every any emulation ( query engine . get type configuration ( ) , true ) ) ; query engine . get sqm function registry ( ) . register ( `` any `` , new every any emulation ( query engine . get type configuration ( ) , false ) ) ; }
public static void pad_space ( query engine query engine ) { final basic type registry basic type registry = query engine . get type configuration ( ) . get basic type registry ( ) ; final basic type < string > string type = basic type registry . resolve ( standard basic type . string ) ; query engine . get sqm function registry ( ) . register binary ternary pattern ( `` lpad `` , string type , `` lpad ( ? 1 , ? 2 , ' ' ) `` , `` lpad ( ? 1 , ? 2 , ? 3 ) `` ) . set argument list signature ( `` ( string , length [ , pad ] ) `` ) ; query engine . get sqm function registry ( ) . register binary ternary pattern ( `` rpad `` , string type , `` rpad ( ? 1 , ? 2 , ' ' ) `` , `` rpad ( ? 1 , ? 2 , ? 3 ) `` ) . set argument list signature ( `` ( string , length [ , pad ] ) `` ) ; }
public static void datediff ( query engine query engine ) { query engine . get sqm function registry ( ) . name descriptor builder ( `` datediff `` ) . set invariant type ( query engine . get type configuration ( ) . get basic type registry ( ) . resolve ( standard basic type . integer ) ) . set exact argument count ( 2 ) . set argument list signature ( `` ( end , start ) `` ) . register ( ) ; }
protect double get domain low bound ( double p ) { return 0 ; }
public boolean support variable limit ( ) { return support limit ( ) ; }
public static < t > t coalesce ( t . . . value ) { if ( value == null ) { return null ; } for ( t value : value ) { if ( value ! = null ) { if ( string . class . be instance ( value ) ) { if ( ! ( ( string ) value ) . be empty ( ) ) { return value ; } } else { return value ; } } } return null ; }
protected standard service registry get standard service registry ( ) { return standard service registry ; }
public boolean [ ] get property updateability ( object entity ) { return have uninitialized lazy property ( entity ) ? get non lazy property updateability ( ) : get property updateability ( ) ; }
public name function descriptor builder name aggregate descriptor builder ( string registration key , string name ) { return new name function descriptor builder ( this , registration key , function kind . aggregate , name ) ; }
public name function descriptor builder name aggregate descriptor builder ( string registration key , string name ) { return new name function descriptor builder ( this , registration key , function kind . aggregate , name ) ; }
public sqm function descriptor register pattern ( string name , string pattern , basic type return type ) { return pattern descriptor builder ( name , pattern ) . set invariant type ( return type ) . register ( ) ; }
public name function descriptor builder name aggregate descriptor builder ( string name ) { return name aggregate descriptor builder ( name , name ) ; }
public name function descriptor builder name aggregate descriptor builder ( string registration key , string name ) { return new name function descriptor builder ( this , registration key , function kind . aggregate , name ) ; }
public < t > sqm expression < t > value ( t value , sqm expression < ? extend t > type inference source ) { if ( type inference source == null ) { return value ( value ) ; } if ( criteria value handle mode == value handle mode . inline ) { return literal ( value , type inference source ) ; } return new jpa criterion parameter < > ( resolve infer parameter type ( value , type inference source , get type configuration ( ) ) , value , this ) ; }
public string get foreign key definition ( ) { return foreign key definition ; }
public void set foreign key definition ( string value ) { this . foreign key definition = value ; }
protect boolean match namespace u r be ( string uri1 , string uri2 ) { if ( uri1 == uri2 ) { return true ; } if ( uri1 == null ) { return ( uri2 . length ( ) == 0 ) ; } if ( uri2 == null ) { return ( uri1 . length ( ) == 0 ) ; } return uri1 . equal ( uri2 ) ; }
public set < value extractor descriptor > get value extractor candidate for cascaded validation ( type declare type , type variable < ? > type parameter ) { set < value extractor descriptor > value extractor descriptor = new hash set < > ( ) ; value extractor descriptor . add all ( get runtime and container element compliant value extractor from possible candidate ( declare type , type parameter , type helper . get erased reference type ( declared type ) , register value extractor ) ) ; value extractor descriptor . add all ( get potentially runtime type compliant and container element compliant value extractor ( declare type , type parameter ) ) ; return collection helper . to immutable set ( value extractor descriptor ) ; }
public static < t > list < class < ? super t > > get hierarchy ( class < t > clazz , filter . . . filter ) { contract . assert not null ( clazz ) ; list < class < ? super t > > class = new array list ( ) ; list < filter > all filter = new array list ( ) ; all filter . add all ( array . a list ( filter ) ) ; all filter . add ( filter . exclude proxy ( ) ) ; get hierarchy ( clazz , class , all filter ) ; return class ; }
public boolean be default provider ( ) { return be default provider ; }
public int size ( ) { return _map . size ( ) ; }
public int size ( ) { return _map . size ( ) ; }
public boolean equal ( final object o ) { if ( ! ( o instanceof map . entry ) ) return false ; final map . entry e = ( map . entry ) o ; return eq ( _key , e . get key ( ) ) & & eq ( _val , e . get value ( ) ) ; }
public boolean contains range ( range range ) { if ( range == null ) { return false ; } return contains long ( range . get minimum long ( ) ) & & contain long ( range . get maximum long ( ) ) ; }
public object get health check registry ( ) { return health check registry ; }
public boolean wait until sequence exceed ( long sequence , long nanos timeout ) throw interrupted exception { return synchronizer . try acquire share nanos ( sequence , nanos timeout ) ; }
public void set isolate internal query ( boolean isolate ) { check if seal ( ) ; this . be isolate internal query = isolate ; }
public static long pop_xor ( long [ ] arr1 , long [ ] arr2 , int word offset , int num word ) { long pop count = 0 ; for ( int i = word offset , end = word offset + num word ; i < end ; ++i ) { pop count += long . bit count ( arr1 [ i ] ^ arr2 [ i ] ) ; } return pop count ; }
public void push ( byte e1 , byte e2 , byte e3 ) { ensure buffer space ( 3 ) ; buffer [ element count++ ] = e1 ; buffer [ element count++ ] = e2 ; buffer [ element count++ ] = e3 ; }
public void ensure capacity ( int expect element ) { if ( expected element > resize at || key == null ) { final char [ ] prev key = this . key ; final byte [ ] prev value = this . value ; allocate buffer ( min buffer size ( expect element , load factor ) ) ; if ( prev key ! = null & & ! be empty ( ) ) { rehash ( prev key , prev value ) ; } } }
public void push ( char e1 , char e2 , char e3 ) { ensure buffer space ( 3 ) ; buffer [ element count++ ] = e1 ; buffer [ element count++ ] = e2 ; buffer [ element count++ ] = e3 ; }
public void push ( char e1 , char e2 , char e3 ) { ensure buffer space ( 3 ) ; buffer [ element count++ ] = e1 ; buffer [ element count++ ] = e2 ; buffer [ element count++ ] = e3 ; }
public void ensure capacity ( int expect element ) { if ( expected element > resize at || key == null ) { final char [ ] prev key = this . key ; final byte [ ] prev value = this . value ; allocate buffer ( min buffer size ( expect element , load factor ) ) ; if ( prev key ! = null & & ! be empty ( ) ) { rehash ( prev key , prev value ) ; } } }
public void set streamability violation policy ( xml violation policy streamability violation policy ) { this . streamability violation policy = streamability violation policy ; driver = null ; }
public boolean be nc name ( int mode ) { return ( flags & ( 1 < < mode ) ) ! = 0 ; }
protect string new string ( char [ ] cbuf , int off , int len ) { if ( all string intern ) { return new string intern ( cbuf , off , len ) ; } else { return super . new string ( cbuf , off , len ) ; } }
public boolean be quirk ( ) { return quirk ; }
public string get canon name ( ) { return canon name ; }
public static trace scope start span ( string description ) { return start span ( description , true if trace sampler . instance ) ; }
public synchronize string add namespace u r i ( resource connection connection , string nature , string purpose ) throw i o exception { string name = connection . get u r i ( ) ; logger . info ( `` cache resource for namespace : `` + name + `` ( nature : `` + nature + `` ; purpose : `` + purpose + `` ) `` ) ; return _add namespace u r i ( connection , nature , purpose ) ; }
public long get value ( ) { return this . value ; }
public void set max cache entry ( final int max cache entry ) { this . max cache entry = max cache entry ; }
public boolean is303 cache enable ( ) { return allow303 cache ; }
public int get asynchronous worker idle lifetime sec ( ) { return asynchronous worker idle lifetime sec ; }
public static void reset request ( ) { request scoped collapsers . clear ( ) ; }
public void set exception if response not receive ( exception e ) { if ( ! value set . get ( ) & & ! be terminate ( ) ) { subject . on error ( e ) ; } }
public long get roll count thread execute ( ) { return roll counter stream . get late count ( hystrix event type . thread pool . execute ) ; }
public long get cumulative count thread execute ( ) { return cumulative counter stream . get late count ( hystrix event type . thread pool . execute ) ; }
public long get roll count thread reject ( ) { return roll counter stream . get late count ( hystrix event type . thread pool . reject ) ; }
public void remove ( ) { if ( hystrix request context . get context for current thread ( ) ! = null ) { remove ( hystrix request context . get context for current thread ( ) , this ) ; } }
public static void reset ( ) { singleton = new hystrix metric publisher factory ( ) ; singleton . command publisher . clear ( ) ; singleton . thread pool publisher . clear ( ) ; singleton . collapser publisher . clear ( ) ; }
public static void reset ( ) { singleton = new hystrix metric publisher factory ( ) ; singleton . command publisher . clear ( ) ; singleton . thread pool publisher . clear ( ) ; singleton . collapser publisher . clear ( ) ; }
public void add ( long x ) { cell [ ] a ; long b , v ; int [ ] hc ; cell a ; int n ; if ( ( a = cell ) ! = null || ! ca base ( b = base , b + x ) ) { boolean uncontended = true ; if ( ( hc = thread hash code . get ( ) ) == null || a == null || ( n = a . length ) < 1 || ( a = a [ ( n - 1 ) & hc [ 0 ] ] ) == null || ! ( uncontended = a . ca ( v = a . value , v + x ) ) ) retry update ( x , hc , uncontended ) ; } }
public void truncate ( final long position ) { final int index = index ( position ) ; final int offset = offset ( position ) ; final block block = block . get ( index ) ; this . index = index ; block . limit = offset ; current = block ; }
public static ion text writer builder minimal ( ) { return standard ( ) . with minimal system data ( ) ; }
public final ion text writer builder with minimal system data ( ) { ion text writer builder b = mutable ( ) ; b . set initial ivm handling ( suppress ) ; b . set ivm minimizing ( ivm minimizing . distant ) ; b . set lst minimizing ( lst minimizing . everything ) ; return b ; }
public void set import ( symbol table . . . import ) { mutation check ( ) ; my import = safe copy ( import ) ; }
public ivy get configure ivy instance ( project component task ) { if ( ivy engine == null ) { create ivy engine ( task ) ; } return ivy engine ; }
public static ivy ant setting get default instance ( task task ) { return get default instance ( ( project component ) task ) ; }
public deliver option set status ( string status ) { this . status = status ; return this ; }
protect void add attribute ( string key , string value ) { attribute . put ( key , value ) ; }
public long get duration ( ) { return duration ; }
public static ivy context push new context ( ) { return push context ( new ivy context ( ) ) ; }
public ivy get ivy ( ) { ivy ivy = peek ivy ( ) ; return ivy == null ? get default ivy ( ) : ivy ; }
public boolean pop ( string key , object expect value ) { synchronize ( context map ) { object o = context map . get ( key ) ; if ( o == null ) { return false ; } if ( o instanceof list ) { if ( ( ( list ) o ) . size ( ) == 0 ) { return false ; } object top = ( ( list ) o ) . get ( 0 ) ; if ( ! top . equal ( expect value ) ) { return false ; } ( ( list ) o ) . remove ( 0 ) ; return true ; } else { throw new runtime exception ( `` can not pop from non list object `` + o ) ; } } }
public void add configuration ( string conf ) { confs . add ( conf ) ; }
public boolean be sort ( ) { if ( be sort ) { message . debug ( `` module descriptor already sort : `` + module . get module revision id ( ) . to string ( ) ) ; return true ; } else { return false ; } }
public string get organisation ( ) { return organisation ; }
public list get module id ( ) { if ( module id == null ) { list sort dependency = resolve engine . get sort engine ( ) . sort node ( get dependency ( ) , sort option . silent ) ; collection . reverse ( sorted dependency ) ; for ( iterator iter = sort dependency . iterator ( ) ; iter . have next ( ) ; ) { ivy node dependency = ( ivy node ) iter . next ( ) ; module id mid = dependency . get resolve id ( ) . get module id ( ) ; collection deps = ( collection ) modules ids map . get ( mid ) ; if ( deps == null ) { deps = new link hash set ( ) ; module id map . put ( mid , deps ) ; } deps . add ( dependency ) ; } modules id = new array list ( module id map . key set ( ) ) ; } return collection . unmodifiable list ( module id ) ; }
public int get module id number ( ) { ensure load ( ) ; return module . size ( ) ; }
public string [ ] get require configuration ( ivy node in , string in conf ) { collection req = new link hash set ( ) ; add all if not null ( req , usage . get required configuration ( in , in conf ) ) ; for ( iterator iterator = merge usage . value ( ) . iterator ( ) ; iterator . have next ( ) ; ) { ivy node usage usage = ( ivy node usage ) iterator . next ( ) ; add all if not null ( req , usage . get required configuration ( in , in conf ) ) ; } return req == null ? new string [ 0 ] : ( string [ ] ) req . to array ( new string [ req . size ( ) ] ) ; }
public artifact origin locate ( artifact artifact ) { dependency resolver resolver = setting . get resolver ( artifact . get module revision id ( ) ) ; return resolver . locate ( artifact ) ; }
public map get download report ( ) { return download report ; }
public collection get retrieve file ( ) { collection result = new array list ( up to date file . size ( ) + copied file . size ( ) ) ; result . add all ( up to date file ) ; result . add all ( copied file ) ; return result ; }
public void add artifact ( string conf , artifact artifact ) { configuration c = get configuration ( conf ) ; if ( c == null ) { throw new illegal argument exception ( `` can not add artifact ' `` + artifact . get id ( ) . get artifact id ( ) . get short description ( ) + `` ' to configuration ' `` + conf + `` ' of module `` + rev id + `` because this configuration do n't exist ! `` ) ; } if ( c instanceof configuration group ) { configuration group group = ( configuration group ) c ; string [ ] member = group . get member configuration name ( ) ; for ( int i = 0 ; i < member . length ; i++ ) { add artifact ( member [ i ] , artifact ) ; } } else { collection artifact = ( collection ) artifact by conf . get ( conf ) ; if ( artifact == null ) { artifact = new array list ( ) ; artifact by conf . put ( conf , artifact ) ; } artifacts . add ( artifact ) ; this . artifact . add ( artifact ) ; } }
public string [ ] get member configuration name ( ) { return ( string [ ] ) member . key set ( ) . to array ( new string [ member . size ( ) ] ) ; }
public boolean be process ( ) { if ( be sort || be loop intermediate element ) { message . debug ( `` module descriptor be process : `` + module . get module revision id ( ) . to string ( ) ) ; return true ; } else { return false ; } }
public static long read v long ( byte [ ] byte , int start ) throw i o exception { int len = bytes [ start ] ; if ( len > = -112 ) { return len ; } boolean be negative = ( len < -120 ) ; len = be negative ? - ( len + 120 ) : - ( len + 112 ) ; if ( start+1+len > byte . length ) throw new i o exception ( `` not enough number of byte for a zero-compressed integer `` ) ; long i = 0 ; for ( int idx = 0 ; idx < len ; idx++ ) { i = i < < 8 ; i = i | ( bytes [ start+1+idx ] & 0x f f ) ; } return ( be negative ? ( i ^ -1l ) : i ) ; }
public void set key file ( file file path ) { this . key file = file path ; if ( ! key file . exists ( ) ) { message . warn ( `` pemfile `` + key file . get absolute path ( ) + `` do n't exist . `` ) ; key file = null ; } else if ( ! key file . can read ( ) ) { message . warn ( `` pemfile `` + key file . get absolute path ( ) + `` not readable . `` ) ; key file = null ; } else { message . debug ( `` use `` + key file . get absolute path ( ) + `` a keyfile . `` ) ; } }
public void get ( string src vfs u r i , file destination ) throw i o exception { vfs resource src = new vfs resource ( src vfs u r i , get v f s manager ( ) ) ; fire transfer initiate ( src , transfer event . request_get ) ; try { file content content = src . get content ( ) ; if ( content == null ) { throw new illegal argument exception ( `` invalid vfs uri `` + src vfs u r i + `` : no content find `` ) ; } file util . copy ( content . get input stream ( ) , destination , progress ) ; } catch ( i o exception ex ) { fire transfer error ( ex ) ; throw ex ; } catch ( runtime exception ex ) { fire transfer error ( ex ) ; throw ex ; } }
public final expression optimize ( expression visitor visitor , item type context item type ) { return this ; }
public void set passfile ( file passfile ) { get ssh base repository ( ) . set pas file ( passfile ) ; passfile set = true ; }
public void set passfile ( file passfile ) { get ssh base repository ( ) . set pas file ( passfile ) ; passfile set = true ; }
public void add ivy pattern ( string pattern ) { ivy pattern . add ( pattern ) ; }
public file get resource cache ( ) { return resource cache ; }
public void set build root ( file build root ) { this . build root = build root ; }
public void set quiet ( boolean quiet ) { this . quiet = quiet ; }
public void set key file ( file file path ) { this . key file = file path ; if ( ! key file . exists ( ) ) { message . warn ( `` pemfile `` + key file . get absolute path ( ) + `` do n't exist . `` ) ; key file = null ; } else if ( ! key file . can read ( ) ) { message . warn ( `` pemfile `` + key file . get absolute path ( ) + `` not readable . `` ) ; key file = null ; } else { message . debug ( `` use `` + key file . get absolute path ( ) + `` a keyfile . `` ) ; } }
public static boolean deltree ( file directory ) { if ( directory == null || ! directory . exists ( ) ) { return true ; } boolean result = true ; if ( directory . be file ( ) ) { result = directory . delete ( ) ; } else { file [ ] list = directory . list file ( ) ; for ( int i = list . length ; i -- > 0 ; ) { if ( ! deltree ( list [ i ] ) ) { result = false ; } } if ( ! directory . delete ( ) ) { result = false ; } } return result ; }
public boolean have ancestor ( int ttype ) { return get ancestor ( ttype ) ! =null ; }
protect double get domain low bound ( double p ) { return 0 ; }
public int [ ] answer subnegotiation ( int suboption data [ ] , int suboption length ) { return null ; }
public void remove ignore ( ) { _fields = _remove ignore ( _fields ) ; _getters = _remove ignore ( _getters ) ; _setters = _remove ignore ( _setters ) ; _ctor parameter = _remove ignore ( _ctor parameter ) ; }
public void write type prefix for scalar ( object value , json generator jgen , class < ? > type ) throw i o exception { write type prefix for scalar ( value , jgen ) ; }
public string map path ( string path ) { return null ; }
public void clear ( ) { throw new unsupported operation exception ( ) ; }
@ override public json stream context get output context ( ) { return _write context ; }
protect void _write ( big integer v ) throw i o exception { / * * support by use type tag , a per spec : major type for tag ' 6 ' ; 5 * lsb either 2 for positive bignum or 3 for negative bignum . and then * byte sequence that encode variable length integer . * / if ( v . signum ( ) < 0 ) { _write byte ( byte_tag_bignum_neg ) ; v = v . negate ( ) ; } else { _write byte ( byte_tag_bignum_pos ) ; } byte [ ] data = v . to byte array ( ) ; final int len = data . length ; _write length marker ( prefix_type_bytes , len ) ; _write byte ( data , 0 , len ) ; }
protect annotated parameter replace parameter annotation ( int index , annotation map ann ) { _param annotation [ index ] = ann ; return get parameter ( index ) ; }
public void remove non visible ( ) { / * 21- aug-2011 , tatu : this be tricky part -- if and when allow * non-visible property element to be `` pull in `` by visible * counterpart ? * for now , we will only do this to pull in setter or field use * a setter , if an explicit getter be find . * / _getters = _remove non visible ( _getters ) ; _ctor parameter = _remove non visible ( _ctor parameter ) ; if ( _getters == null ) { _fields = _remove non visible ( _fields ) ; _setters = _remove non visible ( _setters ) ; } }
public final serializer factory with additional serializers ( serializers additional ) { return with config ( get config ( ) . with additional serializers ( additional ) ) ; }
@ override public json token a token ( ) { return json token . value_embedded_object ; }
public entry list get slice ( key slice query query , store transaction txh ) throw backend exception { / * * * this timestamp mimic the timestamp use by * { @ link org . apache . cassandra . thrift . cassandra server # get ( byte buffer , column path , consistency level ) } . * * that method pass the server 's system . current time millis ( ) to * { @ link read command # create ( string , byte buffer , string , long , i disk atom filter ) } . * { @ code create ( . . . ) } in turn pass that timestamp to the slice from read command constructor . * / final long now millis = time . get time ( ) . to epoch milli ( ) ; composite start composite = cell names . simple dense ( query . get slice start ( ) . a byte buffer ( ) ) ; composite end composite = cell names . simple dense ( query . get slice end ( ) . a byte buffer ( ) ) ; slice query filter sqf = new slice query filter ( start composite , end composite , false , query . get limit ( ) + ( query . have limit ( ) ? 1:0 ) ) ; read command slice cmd = new slice from read command ( keyspace , query . get key ( ) . a byte buffer ( ) , column family , now millis , sqf ) ; list < row > slice = read ( slice cmd , get tx ( txh ) . get read consistency level ( ) . get d b ( ) ) ; if ( null == slice || 0 == slice . size ( ) ) return entry list . empty_list ; int slice size = slice . size ( ) ; if ( 1 < slice size ) throw new permanent backend exception ( `` receive `` + slice size + `` row for single key `` ) ; row r = slice . get ( 0 ) ; if ( null == r ) { log . warn ( `` null row object retrieve from cassandra storage proxy `` ) ; return entry list . empty_list ; } column family cf = r . cf ; if ( null == cf ) { log . debug ( `` null column family ( \ `` { } \ `` ) `` , column family ) ; return entry list . empty_list ; } if ( cf . be mark for delete ( ) ) return entry list . empty_list ; return cassandra helper . make entry list ( iterables . filter ( cf . get sorted column ( ) , new filter delete column ( now millis ) ) , entry getter , query . get slice end ( ) , query . get limit ( ) ) ; }
public string to string ( ) { return helper . get wkt writer ( ) . to string ( shape ) ; }
public static geoshape box ( final double south west latitude , final double south west longitude , final double north east latitude , final double north east longitude ) { precondition . check argument ( be valid coordinate ( south west latitude , south west longitude ) , `` invalid south-west coordinate provide `` ) ; precondition . check argument ( be valid coordinate ( north east latitude , north east longitude ) , `` invalid north-east coordinate provide `` ) ; return new geoshape ( get shape factory ( ) . rect ( south west longitude , north east longitude , south west latitude , north east latitude ) ) ; }
public static boolean equal include na n ( float x , float y ) { return ( x ! = x || y ! = y ) ? ! ( x ! = x ^ y ! = y ) : equal ( x , y , 1 ) ; }
public timestamp provider get timestamp provider ( ) { return time ; }
public void addition ( e entry ) { if ( additions==null ) addition = new array list < > ( ) ; addition . add ( entry ) ; }
public int hash code ( ) { return hash code ( length ( ) ) ; }
public q system ( ) { this . query system = true ; return get this ( ) ; }
public q system ( ) { this . query system = true ; return get this ( ) ; }
public final expression optimize ( expression visitor visitor , item type context item type ) { return this ; }
public final t add ( t element ) { size++ ; heap [ size ] = element ; up heap ( ) ; return heap [ 1 ] ; }
public static long decode zig zag64 ( final long n ) { return ( n > > > 1 ) ^ - ( n & 1 ) ; }
public x m l builder element ( string name , string namespace u r i ) { assert element contain no or whitespace only text node ( this . xml node ) ; return new x m l builder ( ( namespace u r i == null ? get document ( ) . create element ( name ) : get document ( ) . create element n s ( namespace u r i , name ) ) , this . xml node ) ; }
public x m l builder instruction ( string target , string data ) { xml node . append child ( get document ( ) . create processing instruction ( target , data ) ) ; return this ; }
public abstract lat lon box add to abstract lat lon box object extension ( final abstract object abstract lat lon box object extension ) { this . get abstract lat lon box object extension ( ) . add ( abstract lat lon box object extension ) ; return this ; }
public view volume add to view volume object extension ( final abstract object view volume object extension ) { this . get view volume object extension ( ) . add ( view volume object extension ) ; return this ; }
public void set abstract view simple extension ( final list < object > abstract view simple extension ) { this . abstract view simple extension = abstract view simple extension ; }
public view volume add to view volume object extension ( final abstract object view volume object extension ) { this . get view volume object extension ( ) . add ( view volume object extension ) ; return this ; }
public basic link add to basic link simple extension ( final object basic link simple extension ) { this . get basic link simple extension ( ) . add ( basic link simple extension ) ; return this ; }
public camera add to camera simple extension ( final object camera simple extension ) { this . get camera simple extension ( ) . add ( camera simple extension ) ; return this ; }
public document add to schema ( final schema schema ) { this . get schema ( ) . add ( schema ) ; return this ; }
public document add to schema ( final schema schema ) { this . get schema ( ) . add ( schema ) ; return this ; }
public overlay add to overlay simple extension ( final object overlay simple extension ) { this . get overlay simple extension ( ) . add ( overlay simple extension ) ; return this ; }
public overlay add to overlay object extension ( final abstract object overlay object extension ) { this . get overlay object extension ( ) . add ( overlay object extension ) ; return this ; }
public lat lon box add to lat lon box object extension ( final abstract object lat lon box object extension ) { this . get lat lon box object extension ( ) . add ( lat lon box object extension ) ; return this ; }
public icon style add to icon style simple extension ( final object icon style simple extension ) { this . get icon style simple extension ( ) . add ( icon style simple extension ) ; return this ; }
public look at add to look at object extension ( final abstract object look at object extension ) { this . get look at object extension ( ) . add ( look at object extension ) ; return this ; }
public point add to point object extension ( final abstract object point object extension ) { this . get point object extension ( ) . add ( point object extension ) ; return this ; }
public schema data add to schema data extension ( final object schema data extension ) { this . get schema data extension ( ) . add ( schema data extension ) ; return this ; }
public style map add to pair ( final pair pair ) { this . get pair ( ) . add ( pair ) ; return this ; }
public style map add to pair ( final pair pair ) { this . get pair ( ) . add ( pair ) ; return this ; }
public time stamp add to time stamp object extension ( final abstract object time stamp object extension ) { this . get time stamp object extension ( ) . add ( time stamp object extension ) ; return this ; }
public author add to name or uri or email ( final string name or uri or email ) { this . get name or uri or email ( ) . add ( name or uri or email ) ; return this ; }
public view volume add to view volume object extension ( final abstract object view volume object extension ) { this . get view volume object extension ( ) . add ( view volume object extension ) ; return this ; }
public dependent locality add to dependent locality name ( final dependent locality . dependent locality name dependent locality name ) { this . get dependent locality name ( ) . add ( dependent locality name ) ; return this ; }
public large mail user add to large mail user name ( final large mail user . large mail user name large mail user name ) { this . get large mail user name ( ) . add ( large mail user name ) ; return this ; }
public void set postal route name ( final list < postal route . postal route name > postal route name ) { this . postal route name = postal route name ; }
public sub premise add to sub premise name ( final sub premise . sub premise name sub premise name ) { this . get sub premise name ( ) . add ( sub premise name ) ; return this ; }
public premise add to premise number ( final premise number premise number ) { this . get premise number ( ) . add ( premise number ) ; return this ; }
public sub premise add to sub premise number suffix ( final sub premise . sub premise number suffix sub premise number suffix ) { this . get sub premise number suffix ( ) . add ( sub premise number suffix ) ; return this ; }
public void add stream of empty word ( boolean v , long number ) { if ( v ) { this . one bits += number * e w a h compressed bitmap . word_in_bits ; } }
public static void reset bitmap range ( long buffer bitmap , int start , int end ) { if ( be back by simple array ( bitmap ) ) { util . reset bitmap range ( bitmap . array ( ) , start , end ) ; return ; } if ( start == end ) return ; int firstword = start / 64 ; int endword = ( end - 1 ) / 64 ; if ( firstword == endword ) { bitmap . put ( firstword , bitmap . get ( firstword ) & ~ ( ( ~0l < < start ) & ( ~0l > > > -end ) ) ) ; return ; } bitmap . put ( firstword , bitmap . get ( firstword ) & ( ~ ( ~0l < < start ) ) ) ; for ( int i = firstword+1 ; i < endword ; i++ ) bitmap . put ( i , 0l ) ; bitmap . put ( endword , bitmap . get ( endword ) & ( ~ ( ~0l > > > -end ) ) ) ; }
public void and not ( word array b ) { for ( int k = 0 ; k < math . min ( this . get number of word ( ) , b . get number of word ( ) ) ; ++k ) { this . data [ k ] & = ~bs . get word ( k ) ; } }
public int xorcardinality ( word array b ) { int sum = 0 ; for ( int k = 0 ; k < math . min ( this . get number of word ( ) , b . get number of word ( ) ) ; ++k ) { sum += long . bit count ( this . get word ( k ) ^ b . get word ( k ) ) ; } word array longer = b . get number of word ( ) < this . get number of word ( ) ? this : b ; int start = math . min ( this . get number of word ( ) , b . get number of word ( ) ) ; int end = math . max ( this . get number of word ( ) , b . get number of word ( ) ) ; for ( int k = start ; k < end ; ++k ) { sum += long . bit count ( longer . get word ( k ) ) ; } return sum ; }
public int xorcardinality ( word array b ) { int sum = 0 ; for ( int k = 0 ; k < math . min ( this . get number of word ( ) , b . get number of word ( ) ) ; ++k ) { sum += long . bit count ( this . get word ( k ) ^ b . get word ( k ) ) ; } word array longer = b . get number of word ( ) < this . get number of word ( ) ? this : b ; int start = math . min ( this . get number of word ( ) , b . get number of word ( ) ) ; int end = math . max ( this . get number of word ( ) , b . get number of word ( ) ) ; for ( int k = start ; k < end ; ++k ) { sum += long . bit count ( longer . get word ( k ) ) ; } return sum ; }
public void trim ( ) { for ( int k = this . get number of word ( ) - 1 ; k > = 0 ; -- k ) if ( this . get word ( k ) ! = 0 ) { if ( k + 1 < this . get number of word ( ) ) this . data = array . copy of ( this . data , k + 1 ) ; return ; } this . data = new long [ 0 ] ; }
public void set ( int start , int end , boolean v ) { if ( v ) set ( start , end ) ; else clear ( start , end ) ; }
public void or ( word array b ) { if ( this . get number of word ( ) < b . get number of word ( ) ) this . resize ( b . get number of word ( ) * 64 ) ; for ( int k = 0 ; k < this . get number of word ( ) ; ++k ) { this . data [ k ] |= b . get word ( k ) ; } }
public void flip ( final int i ) { this . data [ i / 64 ] ^= ( 1l < < ( i % 64 ) ) ; }
public t poll ( ) { t an = this . a [ 1 ] ; this . a [ 1 ] = this . a [ this . last index -- ] ; percolate down ( 1 ) ; return an ; }
public void xor to container ( final e w a h compress bitmap a , final bitmap storage container ) { container . clear ( ) ; final e w a h iterator i = a . get e w a h iterator ( ) ; final e w a h iterator j = get e w a h iterator ( ) ; final iterating buffer run length word rlwi = new iterating buffer run length word ( i ) ; final iterating buffer run length word rlwj = new iterating buffer run length word ( j ) ; while ( ( rlwi . size ( ) > 0 ) & & ( rlwj . size ( ) > 0 ) ) { while ( ( rlwi . get running length ( ) > 0 ) || ( rlwj . get running length ( ) > 0 ) ) { final boolean i_is_prey = rlwi . get running length ( ) < rlwj . get running length ( ) ; final iterating buffer run length word prey = i_is_prey ? rlwi : rlwj ; final iterating buffer run length word predator = i_is_prey ? rlwj : rlwi ; final long index = ( ! predator . get running bit ( ) ) ? prey . discharge ( container , predator . get running length ( ) ) : prey . discharge negate ( container , predator . get running length ( ) ) ; container . add stream of empty word ( predator . get running bit ( ) , predator . get running length ( ) - index ) ; predator . discard run word ( ) ; } final int nbre_literal = math . min ( rlwi . get number of literal word ( ) , rlwj . get number of literal word ( ) ) ; if ( nbre_literal > 0 ) { for ( int k = 0 ; k < nbre_literal ; ++k ) container . add word ( rlwi . get literal word at ( k ) ^ rlwj . get literal word at ( k ) ) ; rlwi . discard first word ( nbre_literal ) ; rlwj . discard first word ( nbre_literal ) ; } } final boolean i_remains = rlwi . size ( ) > 0 ; final iterating buffer run length word remain = i_remains ? rlwi : rlwj ; remain . discharge ( container ) ; container . set size in bit within last word ( math . max ( size in bit ( ) , a . size in bit ( ) ) ) ; }
public boolean set ( final int i ) { return set ( i , true ) ; }
public void add literal word ( final long new data ) { this . size in bit += word_in_bits ; insert literal word ( new data ) ; }
public static e w a h compress bitmap bufferedxor ( final int buf size , final e w a h compressed bitmap . . . bitmap ) { e w a h compressed bitmap answer = new e w a h compress bitmap ( ) ; bufferedxor with container ( answer , buf size , bitmap ) ; return answer ; }
public int or cardinality ( final e w a h compress bitmap a ) { final bit counter counter = new bit counter ( ) ; or to container ( a , counter ) ; return counter . get count ( ) ; }
public e w a h compress bitmap and ( final e w a h compress bitmap a ) { int size = this . buffer . size in word ( ) > a . buffer . size in word ( ) ? this . buffer . size in word ( ) : a . buffer . size in word ( ) ; final e w a h compress bitmap container = new e w a h compress bitmap ( size ) ; and to container ( a , container ) ; return container ; }
public static e w a h compress bitmap bufferedxor ( final int buf size , final e w a h compressed bitmap . . . bitmap ) { e w a h compressed bitmap answer = new e w a h compress bitmap ( ) ; bufferedxor with container ( answer , buf size , bitmap ) ; return answer ; }
public void discard first word ( long x ) { if ( this . run length > = x ) { this . run length -= x ; return ; } x -= this . run length ; this . run length = 0 ; this . literal word offset += x ; this . number of literal word -= x ; }
public void write literal word ( int num word , bitmap storage container ) { container . add stream of literal word ( this . buffer , this . literal word start position , num word ) ; }
public final iterable < e w a h pointer > get literal ( ) { return new iterable < e w a h pointer > ( ) { @ override public iterator < e w a h pointer > iterator ( ) { return new iterator < e w a h pointer > ( ) { int k = updateable bitmap function . this . litwlist . next set bit ( 0 ) ; @ override public boolean have next ( ) { return this . k > = 0 ; } @ override public e w a h pointer next ( ) { e w a h pointer answer = updateable bitmap function . this . rw [ this . k ] ; this . k = updateable bitmap function . this . litwlist . next set bit ( this . k + 1 ) ; return answer ; } @ override public void remove ( ) { throw new runtime exception ( `` n/a `` ) ; } } ; } } ; }
public static long materialize ( final iterating r l w i , final bitmap storage c , long max ) { final long orig max = max ; while ( true ) { if ( i . get running length ( ) > 0 ) { long l = i . get running length ( ) ; if ( l > max ) l = max ; c . add stream of empty word ( i . get running bit ( ) , l ) ; max -= l ; } long l = i . get number of literal word ( ) ; for ( int k = 0 ; k < l ; ++k ) c . add word ( i . get literal word at ( k ) ) ; if ( max > 0 ) { if ( ! i . next ( ) ) break ; } else break ; } return orig max - max ; }
public string get simple name ( ) { return this . simple name ; }
public boolean be unbound ( ) { return ( ( this . upper bound == null ) & & ( this . low bound == null ) ) ; }
public void set signature ( string sig ) { int index = get const pool ( ) . add utf8 info ( sig ) ; byte array . write16bit ( index , info , 0 ) ; }
protect int do opcode ( int po , byte [ ] code ) throw bad bytecode { try { int op = code [ po ] & 0xff ; if ( op < 54 ) return do opcode0_53 ( po , code , op ) ; if ( op < 96 ) return do opcode54_95 ( po , code , op ) ; if ( op < 148 ) return do opcode96_147 ( po , code , op ) ; return do opcode148_201 ( po , code , op ) ; } catch ( array index out of bound exception e ) { throw new bad bytecode ( `` inconsistent stack height `` + e . get message ( ) , e ) ; } }
public void set modifier ( int mod ) { declare class . check modify ( ) ; method info . set access flag ( access flag . of ( mod ) ) ; }
public static final boolean be in ( int flag ) { return ( flags & ( out | in ) ) ! = out ; }
public static boolean be public ( int accflags ) { return ( accflags & public ) ! = 0 ; }
public iterator < feature descriptor > get feature descriptor ( e l context context , object base ) { return new composite iterator ( el resolvers , size , context , base ) ; }
public void add evaluation listener ( evaluation listener listener ) { get e l context ( ) . add evaluation listener ( listener ) ; }
public void set variable ( string var , string expression ) { value expression exp = factory . create value expression ( el manager . get e l context ( ) , bracket ( expression ) , object . class ) ; el manager . set variable ( var , exp ) ; }
public class < ? > get common property type ( e l context context , object base ) { if ( base ! = null & & base instanceof map ) { return object . class ; } return null ; }
public static json array builder create array builder ( ) { return json provider . provider ( ) . create array builder ( ) ; }
public final synchronize authenticator get authenticator ( ) { check access ( ) ; return this . auth ; }
public argument write string ( string s ) { item . add ( new a string ( a s c i i utility . get byte ( s ) ) ) ; return this ; }
public void remove response handler ( response handler h ) { handler . remove ( h ) ; }
public boolean be run ( ) { return run ; }
public synchronize int get mode ( ) { if ( ! be open ( ) ) throw new illegal state exception ( `` folder not open `` ) ; return mode ; }
public acl [ ] get a c l ( ) throw message exception { return ( acl [ ] ) do optional command ( `` acl not support `` , new protocol command ( ) { @ override public object do command ( i m a p protocol p ) throw protocol exception { return p . get a c l ( full name ) ; } } ) ; }
public void remove right ( acl acl ) throw message exception { set a c l ( acl , '- ' ) ; }
public acl [ ] get a c l ( ) throw message exception { return ( acl [ ] ) do optional command ( `` acl not support `` , new protocol command ( ) { @ override public object do command ( i m a p protocol p ) throw protocol exception { return p . get a c l ( full name ) ; } } ) ; }
public string get content i d ( ) throw message exception { check expunge ( ) ; if ( body load ) return super . get content i d ( ) ; load b o d y s t r u c t u r e ( ) ; return b . id ; }
public string get message i d ( ) throw message exception { check expunge ( ) ; if ( body load ) return super . get message i d ( ) ; load envelope ( ) ; return envelope . message id ; }
public void set proxy auth user ( string user ) { proxy auth user = user ; }
public synchronize folder get folder ( string name ) throw message exception { check connect ( ) ; return new i m a p folder ( name , i m a p folder . unknown_separator ) ; }
public address [ ] get recipient ( message . recipient type type ) throw message exception { check expunge ( ) ; load envelope ( ) ; if ( type == message . recipient type . to ) return aaclone ( envelope . to ) ; else if ( type == message . recipient type . cc ) return aaclone ( envelope . cc ) ; else if ( type == message . recipient type . bcc ) return aaclone ( envelope . bcc ) ; else return super . get recipient ( type ) ; }
public static < t extend item > t get item ( response [ ] r , int msgno , class < t > c ) { if ( r == null ) return null ; for ( int i = 0 ; i < r . length ; i++ ) { if ( r [ i ] == null || ! ( r [ i ] instanceof fetch response ) || ( ( fetch response ) r [ i ] ) . get number ( ) ! = msgno ) continue ; fetch response f = ( fetch response ) r [ i ] ; for ( int j = 0 ; j < f . item . length ; j++ ) { if ( c . be instance ( f . item [ j ] ) ) return c . cast ( f . item [ j ] ) ; } } return null ; }
protect void handle login result ( response r ) throw protocol exception { if ( have capability ( `` login-referrals `` ) & & ( ! r . be o k ( ) || referral exception ) ) check referral ( r ) ; handle result ( r ) ; }
public void noop ( ) throw protocol exception { logger . fine ( `` i m a p protocol noop `` ) ; simple command ( `` noop `` , null ) ; }
public body peek body ( int msgno , string section , int start , int size ) throw protocol exception { return fetch body ( msgno , section , start , size , true , null ) ; }
public void fetch sequence number ( long uid ) throw protocol exception { response [ ] r = fetch ( string . value of ( uid ) , `` uid `` , true ) ; notify response handler ( r ) ; handle result ( r [ r . length-1 ] ) ; }
public string get url ( ) { return url ; }
public void add ( right right ) { this . right [ ( int ) right . right ] = true ; }
public synchronize int get size ( ) throw message exception { check open ( ) ; return size ; }
public synchronize string get u i d ( message msg ) throw message exception { check open ( ) ; if ( ! ( msg instanceof p o p3 message ) ) throw new message exception ( `` message be not a p o p3 message `` ) ; p o p3 message m = ( p o p3 message ) msg ; try { if ( ! store . support uidl ) return null ; if ( m . uid == p o p3 message . unknown ) m . uid = port . uidl ( m . get message number ( ) ) ; return m . uid ; } catch ( e o f exception eex ) { close ( false ) ; throw new folder close exception ( this , eex . to string ( ) ) ; } catch ( i o exception ex ) { throw new message exception ( `` error get uidl `` , ex ) ; } }
public synchronize int get size ( ) throw message exception { check open ( ) ; return size ; }
public int get return code ( ) { return rc ; }
public void set submitter ( string submitter ) { this . submitter = submitter ; }
protect int search line number ( int position ) { int [ ] line separator position = get line separator position ( ) ; if ( line separator position == null ) { return 1 ; } int length = line separator position . length ; if ( length == 0 ) { return 1 ; } int g = 0 ; int d = length - 1 ; int m = 0 ; int start ; while ( g < = d ) { m = ( g + d ) / 2 ; if ( position < ( start = line separator position [ m ] ) ) { d = m - 1 ; } else if ( position > start ) { g = m + 1 ; } else { return m + 1 ; } } if ( position < line separator position [ m ] ) { return m + 1 ; } return m + 2 ; }
public final synchronize filter get push filter ( ) { return this . push filter ; }
public final synchronize authenticator get authenticator ( ) { check access ( ) ; return this . auth ; }
public final void set subject ( final string subject ) { if ( subject ! = null ) { this . set subject ( new tail name formatter ( subject ) ) ; } else { check access ( ) ; throw new null pointer exception ( ) ; } }
public int get connection timeout ( ) { return cto ; }
public void log ( level level , string msg ) { if debug out ( msg ) ; if ( logger . be loggable ( level ) ) { final stack trace element frame = infer caller ( ) ; logger . logp ( level , frame . get class name ( ) , frame . get method name ( ) , msg ) ; } }
public void config ( string msg ) { log ( level . config , msg ) ; }
public void set quote ( boolean quote ) { this . quote = quote ; }
public string get name ( ) throw i o exception { read prefix ( ) ; return name ; }
public void write ( int c ) throw i o exception { / * buffer up character till we get a line 's worth , then encode * and write them out . max number of character allow per * line be 45 . * / buffer [ bufsize++ ] = ( byte ) c ; if ( bufsize == 45 ) { write prefix ( ) ; encode ( ) ; bufsize = 0 ; } }
public void dispatch ( object listener ) { ( ( message change listener ) listener ) . message change ( this ) ; }
public message get message ( ) { return msg ; }
public string [ ] get header name ( ) { if ( header == null ) return new string [ 0 ] ; string [ ] s = new string [ header . size ( ) ] ; header . copy into ( s ) ; return s ; }
public void remove ( flag flag ) { system_flags & = ~flag . bit ; }
protect void notify folder listener ( int type ) { if ( folder listener ! = null ) { folder event e = new folder event ( this , this , type ) ; queue event ( e , folder listener ) ; } store . notify folder listener ( type , this ) ; }
public void set parameter ( string name , string value ) { if ( list == null ) list = new parameter list ( ) ; list . set ( name , value ) ; }
protect input stream get content stream ( ) throw message exception { if ( content stream ! = null ) return ( ( share input stream ) content stream ) . new stream ( 0 , -1 ) ; if ( content ! = null ) return new share byte array input stream ( content ) ; throw new message exception ( `` no mime message content `` ) ; }
public class < ? > [ ] get class ( string name , class < ? > . . . default value ) { string [ ] classnames = get trim string ( name ) ; if ( classnames == null ) return default value ; try { class < ? > [ ] class = new class < ? > [ classnames . length ] ; for ( int i = 0 ; i < classnames . length ; i++ ) { class [ i ] = get class by name ( classnames [ i ] ) ; } return class ; } catch ( class not find exception e ) { throw new runtime exception ( e ) ; } }
public enumeration < string > get match header line ( string [ ] names ) { return ( new match string enum ( header , name , true ) ) ; }
public flag get flag ( ) { return ( flag ) flag . clone ( ) ; }
public int size ( ) { return list . size ( ) ; }
protect void update header ( ) throw message exception { super . update header ( ) ; mime body part . set encoding ( this , encode ) ; }
public boolean match ( search term term ) throw message exception { return term . match ( this ) ; }
public synchronize provider [ ] get provider ( ) { provider [ ] _providers = new provider [ provider . size ( ) ] ; provider . copy into ( _providers ) ; return _providers ; }
protect boolean match ( address a ) { return ( a . equal ( address ) ) ; }
public void connect ( string user , string password ) throw message exception { connect ( null , user , password ) ; }
public transport get transport ( string protocol ) throw no such provider exception { return get transport ( new u r l name ( protocol , null , -1 , null , null , null ) ) ; }
public void set password authentication ( u r l name url , password authentication pw ) { if ( pw == null ) auth table . remove ( url ) ; else auth table . put ( url , pw ) ; }
public folder [ ] get user namespaces ( string user ) throw message exception { return new folder [ 0 ] ; }
protect void notify folder listener ( int type , folder folder ) { if ( folder listener == null ) return ; folder event e = new folder event ( this , folder , type ) ; queue event ( e , folder listener ) ; }
public synchronize void remove transport listener ( transport listener l ) { if ( transport listener ! = null ) transport listener . remove element ( l ) ; }
protect double get domain low bound ( double p ) { return 0 ; }
public final loader select root loader ( unmarshalling context . state state , tag name tag ) { jax bean info bean info = root map . get ( tag . uri , tag . local ) ; if ( bean info==null ) return null ; return bean info . get loader ( this , true ) ; }
public j invocation invoke ( j expression expr , string method ) { j invocation i = new j invocation ( expr , method ) ; insert ( i ) ; return i ; }
public j conditional _if ( j expression expr ) { return insert ( new j conditional ( expr ) ) ; }
public j try block _try ( ) { return insert ( new j try block ( ) ) ; }
public j define class _annotation type declaration ( string name ) throw j class already exist exception { return _class ( j mod . public , name , class type . annotation_type_decl ) ; }
public j define class _class ( string name ) throw j class already exist exception { return _class ( j mod . public , name ) ; }
public j conditional _if ( j expression expr ) { return insert ( new j conditional ( expr ) ) ; }
public j define class _implements ( j class iface ) { interface . add ( iface ) ; return this ; }
public j doc comment javadoc ( ) { if ( jdoc == null ) jdoc = new j doc comment ( type . owner ( ) ) ; return jdoc ; }
public static j expression _this ( ) { return __this ; }
public j method _throws ( j class exception ) { get throw ( ) . add ( exception ) ; return this ; }
public j resource file add resource file ( j resource file rsrc ) { resource . add ( rsrc ) ; return rsrc ; }
public j package parent ( ) { if ( name . length ( ) ==0 ) return null ; int idx = name . last index of ( ' . ' ) ; return owner . _package ( name . substring ( 0 , idx ) ) ; }
public j define class _class ( string name ) throw j class already exist exception { return _class ( j mod . public , name ) ; }
public void declare ( j formatter f ) { f . id ( name ) ; if ( bound ! =null ) f . p ( `` extend `` ) . g ( bound ) ; }
public string get catalog class name ( ) { if ( catalog class name == null ) { catalog class name = query catalog class name ( ) ; } return catalog class name ; }
public static string to protocol host and port ( string url ) { try { url u = new url ( url ) ; string path = u . get path ( ) ; if ( path ! = null & & ! `` `` . equal ( path ) & & ! path . end with ( `` / `` ) ) { log . warning ( `` it look like your base url ( `` + url + `` ) be point to a file , not a directory ( it do n't end with a / ) . we 're go to have to strip off the last part of the pathname . `` ) ; } return u . get protocol ( ) + `` : // `` + u . get authority ( ) ; } catch ( malformed u r l exception e ) { throw new runtime exception ( e ) ; } }
public catalog get catalog ( ) { return catalog ; }
public catalog get catalog ( ) { return catalog ; }
public locator get locator ( ) { return locator ; }
public final c element be bind ( x s element decl x , x s component referer ) { c element info r = bound element . get ( x ) ; if ( r ! =null ) return r ; return bind to type ( x , referer ) ; }
public string get name ( ) { return get name ( false ) ; }
public string map path ( string path ) { return null ; }
public void add bind file ( input source be ) { bind file . add ( absolutize ( be ) ) ; }
protect final j field var generate field ( j type type ) { return outline . impl class . field ( j mod . protect , type , prop . get name ( false ) ) ; }
public boolean be loggable ( level level ) { return debug || logger . be loggable ( level ) ; }
public static void add namespace declaration ( element element , string namespace prefix , string namespace u r i ) { element . set attribute n s ( x m l constant . xmlns_attribute_ns_uri , x m l constant . xmlns_attribute + ' : ' + namespace prefix , namespace u r i ) ; }
public string to string ( ) { return `` ( `` +min+ ' , '+get max string ( ) + ' ) ' ; }
protect string empty element tag closer ( string display name , int name code ) { return `` / > `` ; }
public string [ ] list system i d ( ) { return core . key set ( ) . to array ( new string [ core . key set ( ) . size ( ) ] ) ; }
protect object get instance id value ( int id ) { throw new illegal state exception ( string . value of ( id ) ) ; }
public b i declaration [ ] get decls ( ) { return decls . to array ( new b i declaration [ decls . size ( ) ] ) ; }
public final c element be bind ( x s element decl x , x s component referer ) { c element info r = bound element . get ( x ) ; if ( r ! =null ) return r ; return bind to type ( x , referer ) ; }
public void add configure depends ( file set f ) { add individual file to ( fs , depend set ) ; }
public void set destdir ( file dir ) { this . option . target dir = dir ; }
public entity resolver get entity resolver ( ) { return resolver ; }
public d t d event listener get dtd handler ( ) { return dtd handler ; }
public void close ( ) throw i o exception { if ( close ) return ; in . close ( ) ; in = null ; close = true ; }
public enumeration key ( ) { current bucket = 0 ; current = null ; return this ; }
public enumeration key ( ) { current bucket = 0 ; current = null ; return this ; }
public list get foreign attribute ( ) { return get term ( ) . get foreign attribute ( ) ; }
public annotation parser create annotation parser ( ) { if ( parser . get annotation parser factory ( ) ==null ) return default annotation parser . the instance ; else return parser . get annotation parser factory ( ) . create ( ) ; }
public void include schema ( string schema location ) throw s a x exception { n g c c runtime ex runtime = new n g c c runtime ex ( parser , chameleon mode , this ) ; runtime . current schema = this . current schema ; runtime . block default = this . block default ; runtime . final default = this . final default ; if ( schema location==null ) { s a x parse exception e = new s a x parse exception ( message . format ( message . err_missing_schemalocation ) , get locator ( ) ) ; parser . error handler . fatal error ( e ) ; throw e ; } runtime . parse entity ( resolve relative u r l ( null , schema location ) , true , current schema . get target namespace ( ) , get locator ( ) ) ; }
public void set entity resolver ( entity resolver resolver ) { this . entity resolver = resolver ; }
public final collection < x s component > select ( x s component context node ) { return new defer collection < x s component > ( select ( iterators . singleton ( context node ) ) ) ; }
public class method add constructor ( constructor < ? > method ) { class method class method = add method ( method . get modifier ( ) , `` < init > `` , `` v `` , descriptor utils . parameter descriptor ( method . get parameter type ( ) ) ) ; for ( class < ? > e : method . get exception type ( ) ) { class method . add checked exception ( ( class < ? extend exception > ) e ) ; } for ( annotation annotation : method . get declared annotation ( ) ) { class method . get runtime visible annotation attribute ( ) . add annotation ( annotation builder . create annotation ( const pool , annotation ) ) ; } int count = 0 ; for ( annotation [ ] parameter annotation : method . get parameter annotation ( ) ) { for ( annotation annotation : parameter annotation ) { class method . get runtime visible parameter annotation attribute ( ) . add annotation ( count , annotation builder . create annotation ( const pool , annotation ) ) ; } count++ ; } return class method ; }
public string get descriptor ( ) { return descriptor utils . make descriptor ( name ) ; }
public stack frame pop2push1 ( string type ) { stack state ns = stack state . pop ( 2 ) . push ( type ) ; return new stack frame ( ns , local variable state , type no local change ( ns ) ) ; }
public stack frame pop2push1 ( string type ) { stack state ns = stack state . pop ( 2 ) . push ( type ) ; return new stack frame ( ns , local variable state , type no local change ( ns ) ) ; }
public stack frame pop3 ( ) { stack state ns = stack state . pop ( 3 ) ; return new stack frame ( ns , local variable state , type no local change ( ns ) ) ; }
public integer add string entry ( string string ) { if ( string location . contains key ( string ) ) { return string location . get ( string ) ; } final integer utf8 location = add utf8 entry ( string ) ; final integer index = count++ ; const pool size++ ; entry . put ( index , new string entry ( utf8 location ) ) ; string location . put ( string , index ) ; return index ; }
public static synchronize native platform get native platform ( ) { if ( platform == null ) { string platform factory property = access controller . do privilege ( ( privilege action < string > ) ( ) - > system . get property ( `` monocle . platform `` , `` mx6 , omap , dispman , android , x11 , linux , headless `` ) ) ; string [ ] platform factory = platform factory property . split ( `` , `` ) ; for ( int i = 0 ; i < platform factory . length ; i++ ) { string factory name = platform factory [ i ] . trim ( ) ; string factory class name ; if ( factory name . contains ( `` . `` ) ) { factory class name = factory name ; } else { factory class name = `` com . machinepublishers . glass . ui . monocle . `` + factory name + `` platform factory `` ; } if ( monocle setting . setting . trace platform config ) { monocle trace . trace config ( `` try platform % s with class % s `` , factory name , factory class name ) ; } try { native platform factory npf = ( native platform factory ) class . for name ( factory class name ) . new instance ( ) ; if ( npf . match ( ) & & npf . get major version ( ) == major version & & npf . get minor version ( ) == minor version ) { platform = npf . create native platform ( ) ; if ( monocle setting . setting . trace platform config ) { monocle trace . trace config ( `` match % s `` , factory name ) ; } return platform ; } } catch ( exception e ) { if ( monocle setting . setting . trace platform config ) { monocle trace . trace config ( `` fail to create platform % s `` , factory class name ) ; } e . print stack trace ( ) ; } } throw new unsupported operation exception ( `` can not load a native platform from : ' `` + platform factory property + `` ' `` ) ; } return platform ; }
public boolean ca variable time ( long expect , long update ) { throw new unsupported operation exception ( ) ; }
public void init ( ) { try { synchronize ( lock . validate ( ) ) { remote . init ( ) ; } } catch ( throwable t ) { util . handle exception ( t ) ; } }
public void set level ( final string lev ) { for ( final string item : lev . split ( multicolor layout . split_items ) ) { final string [ ] value = item . split ( multicolor layout . split_values ) ; final string level = value [ 0 ] . to upper case ( locale . english ) ; if ( level . to level ( level , null ) == null ) { throw new illegal argument exception ( string . format ( locale . english , `` unknown level ' % s ' `` , level ) ) ; } this . level . put ( level , value [ 1 ] ) ; } }
public uri get x m l base u r i ( ) throw u r i syntax exception { parent p = this ; uri ret = null ; while ( p ! = null ) { if ( p instanceof element ) { ret = resolve ( ( ( element ) p ) . get attribute value ( `` base `` , namespace . xml_namespace ) , ret ) ; } else { ret = resolve ( ( ( document ) p ) . get base u r i ( ) , ret ) ; } if ( ret ! = null & & ret . be absolute ( ) ) { return ret ; } p = p . get parent ( ) ; } return ret ; }
public void remove namespace declaration ( namespace additional namespace ) { if ( additional namespaces == null ) { return ; } additional namespaces . remove ( additional namespace ) ; }
public < e extend content > void sort content ( filter < e > filter , comparator < ? super e > comparator ) { final filter list < e > list = ( filter list < e > ) get content ( filter ) ; list . sort ( comparator ) ; }
public static string [ ] [ ] invert ( final string [ ] [ ] array ) { final string [ ] [ ] newarray = new string [ array . length ] [ 2 ] ; for ( int i = 0 ; i < array . length ; i++ ) { newarray [ i ] [ 0 ] = array [ i ] [ 1 ] ; newarray [ i ] [ 1 ] = array [ i ] [ 0 ] ; } return newarray ; }
public void set ignore boundary whitespace ( final boolean ignore boundary white ) { this . ignore boundary white = ignore boundary white ; engine = null ; }
public static boolean contain all word ( final char sequence word , final char sequence . . . word ) { if ( string utils . be empty ( word ) || array utils . be empty ( word ) ) { return false ; } for ( final char sequence w : word ) { if ( string utils . be blank ( w ) ) { return false ; } final pattern p = pattern . compile ( `` . * \\b `` + w + `` \\b . * `` ) ; if ( ! p . matcher ( word ) . match ( ) ) { return false ; } } return true ; }
public void pop ( ) { if ( depth < = 0 ) { throw new illegal state exception ( `` can not over-pop the stack . `` ) ; } scope [ depth ] = null ; add [ depth ] = null ; depth -- ; }
public void pop ( ) { if ( depth < = 0 ) { throw new illegal state exception ( `` can not over-pop the stack . `` ) ; } scope [ depth ] = null ; add [ depth ] = null ; depth -- ; }
public static boolean match ( final byte [ ] signature , final int length ) { return length > = 3 & & signature [ 0 ] == ' b ' & & signature [ 1 ] == ' z ' & & signature [ 2 ] == ' h ' ; }
public boolean set variable ( string qname , object value ) { if ( qname == null ) { throw new null pointer exception ( `` null variable name `` ) ; } if ( variable == null ) { variable = new hash map < string , object > ( ) ; } return variable . put ( qname , value ) == null ; }
public void set status ( int status ) { this . status type = status . from ( status ) ; }
public boolean equal ( object obj ) { if ( this == obj ) return true ; if ( obj instanceof async view resource ) { final async view resource that = ( async view resource ) obj ; return that . u . equal ( this . u ) ; } return false ; }
protect object get instance id value ( int id ) { throw new illegal state exception ( string . value of ( id ) ) ; }
public void add filter ( client filter f ) { f . set next ( head ) ; this . head = f ; }
public static string jersey_app_mapping_conflict ( object arg0 , object arg1 ) { return localizer . localize ( localizable j e r s e y_ a p p_ m a p p i n g_ c o n f l i c t ( arg0 , arg1 ) ) ; }
public static string filter_context_path_missing ( ) { return localizer . localize ( localizable f i l t e r_ c o n t e x t_ p a t h_ m i s s i n g ( ) ) ; }
protect servlet context get servlet context ( ) { if ( this . filter config ! = null ) { return this . filter config . get servlet context ( ) ; } else if ( this . servlet context ! = null ) { return this . servlet context ; } else { throw new illegal state exception ( `` no servlet context `` ) ; } }
public static boolean start with ( char s [ ] , int len , string prefix ) { final int prefix len = prefix . length ( ) ; if ( prefix len > len ) return false ; for ( int i = 0 ; i < prefix len ; i++ ) if ( s [ i ] ! = prefix . char at ( i ) ) return false ; return true ; }
public static string sax_cannot_disable_general_entity_processing_feature ( object arg0 ) { return localizer . localize ( localizable s a x_ c a n n o t_ d i s a b l e_ g e n e r a l_ e n t i t y_ p r o c e s s i n g_ f e a t u r e ( arg0 ) ) ; }
public static string sax_cannot_enable_secure_processing_feature ( object arg0 ) { return localizer . localize ( localizable s a x_ c a n n o t_ e n a b l e_ s e c u r e_ p r o c e s s i n g_ f e a t u r e ( arg0 ) ) ; }
public static string sax_cannot_disable_general_entity_processing_feature ( object arg0 ) { return localizer . localize ( localizable s a x_ c a n n o t_ d i s a b l e_ g e n e r a l_ e n t i t y_ p r o c e s s i n g_ f e a t u r e ( arg0 ) ) ; }
public void set status ( int status ) { this . status type = status . from ( status ) ; }
public out bound header get metadata ( ) { return header ; }
public string get parameter name ( ) { return name ; }
public static boolean produce ( medium type content type , list < medium type > accept ) { for ( medium type a : accept ) { if ( a . get type ( ) . equal ( `` * `` ) ) return true ; if ( content type . be compatible ( a ) ) return true ; } return false ; }
public int length ( ) { return code . length ; }
public int length ( ) { return code . length ; }
public uri get absolute path ( ) { if ( absolute path uri ! = null ) { return absolute path uri ; } return absolute path uri = new jersey uri builder ( ) . uri ( request uri ) . replace query ( `` `` ) . fragment ( `` `` ) . build ( ) ; }
public string get method name ( ) { return method name ; }
public void set method name ( string method name ) { this . method name = method name ; }
public void map web application exception ( web application exception e ) { if ( e . get response ( ) . get entity ( ) ! = null ) { on exception ( e , e . get response ( ) , false ) ; } else { if ( ! map exception ( e ) ) { on exception ( e , e . get response ( ) , false ) ; } } }
public list < object > get resource type or method or representation ( ) { if ( resource type or method or representation == null ) { resource type or method or representation = new array list < object > ( ) ; } return this . resource type or method or representation ; }
public string get lang ( ) { return lang ; }
public void set query type ( string value ) { this . query type = value ; }
public void set rel ( string value ) { this . rel = value ; }
public list < option > get option ( ) { if ( option == null ) { option = new array list < option > ( ) ; } return this . option ; }
public void set fix ( string value ) { this . fix = value ; }
public list < object > get resource type or method or representation ( ) { if ( resource type or method or representation == null ) { resource type or method or representation = new array list < object > ( ) ; } return this . resource type or method or representation ; }
public void close ( ) throw i o exception { closed = true ; flush queue ( ) ; }
public string get path ( final boolean decode ) { if ( decode ) { if ( decoded relative path ! = null ) { return decode relative path ; } return decode relative path = uri component . decode ( encoded relative path ( ) , uri component . type . path ) ; } else { return encode relative path ( ) ; } }
public request scoped initializer get request scoped initializer ( ) { return request scoped initializer ; }
public boolean be map from exception ( ) { return map from exception ; }
public outbound message context get wrap message context ( ) { return message context ; }
public static string trim whitespace ( string str ) { return ( string ) trim whitespace ( ( char sequence ) str ) ; }
public static string error_processing_response_from_already_mapped_exception ( ) { return localizer . localize ( localizable e r r o r_ p r o c e s s i n g_ r e s p o n s e_ f r o m_ a l r e a d y_ m a p p e d_ e x c e p t i o n ( ) ) ; }
public static string error_exception_mapping_original_exception ( ) { return localizer . localize ( localizable e r r o r_ e x c e p t i o n_ m a p p i n g_ o r i g i n a l_ e x c e p t i o n ( ) ) ; }
public static string error_monitoring_statistics_generation ( ) { return localizer . localize ( localizable e r r o r_ m o n i t o r i n g_ s t a t i s t i c s_ g e n e r a t i o n ( ) ) ; }
public static string error_monitoring_queue_mapper ( ) { return localizer . localize ( localizable e r r o r_ m o n i t o r i n g_ q u e u e_ m a p p e r ( ) ) ; }
public static string error_request_set_security_context_in_response_phase ( ) { return localizer . localize ( localizable e r r o r_ r e q u e s t_ s e t_ s e c u r i t y_ c o n t e x t_ i n_ r e s p o n s e_ p h a s e ( ) ) ; }
public static string ambiguous_resource_method ( object arg0 ) { return localizer . localize ( localizable a m b i g u o u s_ r e s o u r c e_ m e t h o d ( arg0 ) ) ; }
public static string error_closing_commit_output_stream ( ) { return localizer . localize ( localizable e r r o r_ c l o s i n g_ c o m m i t_ o u t p u t_ s t r e a m ( ) ) ; }
public static string error_wadl_generator_config_loader_property ( object arg0 , object arg1 ) { return localizer . localize ( localizable e r r o r_ w a d l_ g e n e r a t o r_ c o n f i g_ l o a d e r_ p r o p e r t y ( arg0 , arg1 ) ) ; }
public static string error_wadl_builder_generation_request ( object arg0 , object arg1 ) { return localizer . localize ( localizable e r r o r_ w a d l_ b u i l d e r_ g e n e r a t i o n_ r e q u e s t ( arg0 , arg1 ) ) ; }
public static string error_wadl_resource_external_grammar ( ) { return localizer . localize ( localizable e r r o r_ w a d l_ r e s o u r c e_ e x t e r n a l_ g r a m m a r ( ) ) ; }
public static string ambiguous_non_annotated_parameter ( object arg0 , object arg1 ) { return localizer . localize ( localizable a m b i g u o u s_ n o n_ a n n o t a t e d_ p a r a m e t e r ( arg0 , arg1 ) ) ; }
public static string error_wadl_builder_generation_response ( object arg0 , object arg1 ) { return localizer . localize ( localizable e r r o r_ w a d l_ b u i l d e r_ g e n e r a t i o n_ r e s p o n s e ( arg0 , arg1 ) ) ; }
public static string wadl_doc_extended_wadl ( object arg0 , object arg1 ) { return localizer . localize ( localizable w a d l_ d o c_ e x t e n d e d_ w a d l ( arg0 , arg1 ) ) ; }
public void update resource method statistic ( resource method statistic resource method statistic impl ) { this . method execution statistic mx bean . update execution statistic ( resource method statistic impl . get method statistic ( ) ) ; this . request execution statistic mx bean . update execution statistic ( resource method statistic impl . get request statistic ( ) ) ; }
public request processing context apply ( final request processing context context ) { process context ref provider . get ( ) . set ( context ) ; final request scoped initializer request scoped initializer = context . request ( ) . get request scoped initializer ( ) ; if ( request scoped initializer ! = null ) { request scoped initializer . initialize ( locator ) ; } return context ; }
public static class get root resource class ( class clazz ) { return annotation resolver . get class with annotation ( clazz , path . class ) ; }
public static invocable create ( method handler handler , method definition method , boolean encode parameter ) { return create ( handler , definition method , null , encode parameter ) ; }
public static invocable create ( method handler handler , method handle method ) { return create ( handler , handle method , false ) ; }
public < t extend annotation > method list without meta annotation ( final class < t > annotation ) { return filter ( new filter ( ) { @ override public boolean keep ( annotated method m ) { for ( annotation a : m . get annotation ( ) ) { if ( a . annotation type ( ) . get annotation ( annotation ) ! = null ) { return false ; } } return true ; } } ) ; }
public resource . builder create resource builder ( ) { return error . process with exception ( new producer < resource . builder > ( ) { @ override public resource . builder call ( ) { return do create resource builder ( ) ; } } ) ; }
public list < runtime resource > get child runtime resource ( ) { return child runtime resource ; }
public final resource config register class ( final set < class < ? > > class ) { if ( class == null ) { return this ; } for ( final class < ? > cl : class ) { register ( cl ) ; } return this ; }
public void action perform ( action event e ) { if ( `` ok `` . equal ( e . get action command ( ) ) ) { update access control list ( ) ; this . set visible ( false ) ; } else if ( `` cancel `` . equal ( e . get action command ( ) ) ) { updated access control list = null ; this . set visible ( false ) ; } else if ( `` add canonical grantee `` . equal ( e . get action command ( ) ) ) { int row index = canonical grantee table model . add grantee ( new canonical grantee ( `` new canonical id `` ) , permission . permission_read ) ; canonical grantee table . set row selection interval ( row index , row index ) ; } else if ( `` remove canonical grantee `` . equal ( e . get action command ( ) ) ) { if ( canonical grantee table . get select row ( ) > = 0 ) { canonical grantee table model . remove grant and permission ( canonical grantee table . get select row ( ) ) ; } } else if ( `` add email grantee `` . equal ( e . get action command ( ) ) ) { int row index = email grantee table model . add grantee ( new email address grantee ( `` new . email @ address . here `` ) , permission . permission_read ) ; email grantee table . set row selection interval ( row index , row index ) ; } else if ( `` remove email grantee `` . equal ( e . get action command ( ) ) ) { if ( email grantee table . get select row ( ) > = 0 ) { email grantee table model . remove grant and permission ( email grantee table . get select row ( ) ) ; } } else if ( `` add group grantee `` . equal ( e . get action command ( ) ) ) { int row index = group grantee table model . add grantee ( group grantee . authenticated_users , permission . permission_read ) ; group grantee table . set row selection interval ( row index , row index ) ; } else if ( `` remove group grantee `` . equal ( e . get action command ( ) ) ) { if ( group grantee table . get select row ( ) > = 0 ) { group grantee table model . remove grant and permission ( group grantee table . get select row ( ) ) ; } } else { system . err . println ( `` unrecognised action command : `` + e . get action command ( ) ) ; } }
public void action perform ( action event e ) { if ( `` ok `` . equal ( e . get action command ( ) ) ) { update access control list ( ) ; this . set visible ( false ) ; } else if ( `` cancel `` . equal ( e . get action command ( ) ) ) { updated access control list = null ; this . set visible ( false ) ; } else if ( `` add canonical grantee `` . equal ( e . get action command ( ) ) ) { int row index = canonical grantee table model . add grantee ( new canonical grantee ( `` new canonical id `` ) , permission . permission_read ) ; canonical grantee table . set row selection interval ( row index , row index ) ; } else if ( `` remove canonical grantee `` . equal ( e . get action command ( ) ) ) { if ( canonical grantee table . get select row ( ) > = 0 ) { canonical grantee table model . remove grant and permission ( canonical grantee table . get select row ( ) ) ; } } else if ( `` add email grantee `` . equal ( e . get action command ( ) ) ) { int row index = email grantee table model . add grantee ( new email address grantee ( `` new . email @ address . here `` ) , permission . permission_read ) ; email grantee table . set row selection interval ( row index , row index ) ; } else if ( `` remove email grantee `` . equal ( e . get action command ( ) ) ) { if ( email grantee table . get select row ( ) > = 0 ) { email grantee table model . remove grant and permission ( email grantee table . get select row ( ) ) ; } } else if ( `` add group grantee `` . equal ( e . get action command ( ) ) ) { int row index = group grantee table model . add grantee ( group grantee . authenticated_users , permission . permission_read ) ; group grantee table . set row selection interval ( row index , row index ) ; } else if ( `` remove group grantee `` . equal ( e . get action command ( ) ) ) { if ( group grantee table . get select row ( ) > = 0 ) { group grantee table model . remove grant and permission ( group grantee table . get select row ( ) ) ; } } else { system . err . println ( `` unrecognised action command : `` + e . get action command ( ) ) ; } }
public static g s credential load g s credential ( ) throw i o exception { input stream property i s = class loader . get system resource a stream ( samples_properties_name ) ; if ( property i s == null ) { throw new runtime exception ( `` unable to load test property file from classpath : `` + samples_properties_name ) ; } property test property = new property ( ) ; test property . load ( property i s ) ; if ( ! test property . contains key ( gs_access_key_property_name ) ) { throw new runtime exception ( `` property file ' `` + samples_properties_name + `` ' do not contain required property : `` + gs_access_key_property_name ) ; } if ( ! test property . contains key ( gs_secret_key_property_name ) ) { throw new runtime exception ( `` property file ' `` + samples_properties_name + `` ' do not contain required property : `` + gs_secret_key_property_name ) ; } g s credential gs credential = new g s credential ( test property . get property ( gs_access_key_property_name ) , test property . get property ( gs_secret_key_property_name ) ) ; return gs credential ; }
public void revoke all permission ( grantee interface grantee ) { list < grant and permission > grant to remove = new array list < grant and permission > ( ) ; for ( grant and permission gap : grant ) { if ( gap . get grantee ( ) . equal ( grantee ) ) { grant to remove . add ( gap ) ; } } grant . remove all ( grant to remove ) ; }
public string get identifier ( ) { return id ; }
public stream distribution [ ] list stream distribution ( ) throw cloud front service exception { return list stream distribution ( 100 ) ; }
public distribution [ ] list distribution ( string bucket name ) throw cloud front service exception { list < distribution > bucket distribution = list distribution by bucket name ( false , bucket name ) ; return bucket distribution . to array ( new distribution [ bucket distribution . size ( ) ] ) ; }
public storage bucket [ ] list all bucket ( ) throw service exception { assert authenticate connection ( `` list all bucket `` ) ; storage bucket [ ] bucket = list all bucket impl ( ) ; mx delegate . get instance ( ) . register storage bucket m bean ( bucket ) ; return bucket ; }
protect void shutdown impl ( ) throw service exception { shut down = true ; client connection manager manager = this . get http connection manager ( ) ; manager . shutdown ( ) ; }
public void set dev pay product token ( string product token ) { this . aws dev pay product token = product token ; }
public void set acl ( g s access control list acl ) { this . acl = acl ; }
public void set data input file ( file data input file ) { this . data input stream = null ; this . data input file = data input file ; }
public void set content type ( string content type ) { add metadata ( metadata_header_content_type , content type ) ; }
public void set md5 hash ( byte [ ] md5 hash ) { add metadata ( metadata_header_hash_md5 , service utils . to hex ( md5 hash ) ) ; add metadata ( metadata_header_content_md5 , service utils . to base64 ( md5 hash ) ) ; }
public void set queue name ( string queue name ) { super . set queue name ( queue name ) ; }
public static string generate post policy condition ( string operation , string name , string value ) { return `` [ \ `` `` + operation + `` \ `` , \ `` $ `` + name + `` \ `` , \ `` `` + value + `` \ `` ] `` ; }
public multipart complete multipart complete upload ( multipart upload upload ) throw s3 service exception { list < multipart part > part = multipart list part ( upload ) ; return multipart complete upload impl ( upload . get upload id ( ) , upload . get bucket name ( ) , upload . get object key ( ) , part ) ; }
public security handler get security handler ( ) throw i o exception { if ( security handler == null ) { throw new i o exception ( `` no security handler for filter `` + get filter ( ) ) ; } return security handler ; }
public void set request and host id ( string error request id , string error host id ) { this . error request id = error request id ; this . error host id = error host id ; }
protect void assert valid object ( storage object object , string action ) throw service exception { if ( object == null || object . get key ( ) == null || object . get key ( ) . length ( ) == 0 ) { throw new service exception ( `` the action `` + action + `` can not be perform with an invalid object : `` + object ) ; } }
public void delete object ( string bucket name , string object key ) throw service exception { assert valid object ( object key , `` delete object `` ) ; mx delegate . get instance ( ) . register storage object delete event ( bucket name , object key ) ; delete object impl ( bucket name , object key , null , null , null ) ; }
protect date get current time with offset ( ) { return new date ( system . current time millis ( ) + time offset ) ; }
public void add application property ( map property map ) { application property . put all ( property map ) ; }
public string to string ( ) { string builder sb = new string builder ( ) ; sb . append ( new string ( get signature ( ) , utf_8 ) + `` `` ) ; sb . append ( get version ( ) + `` `` ) ; sb . append ( get header len ( ) + `` `` ) ; sb . append ( get unknown_000c ( ) + `` `` ) ; sb . append ( get last modified ( ) + `` `` ) ; sb . append ( get lang id ( ) + `` `` ) ; sb . append ( get dir_uuid ( ) + `` `` ) ; sb . append ( get stream_uuid ( ) + `` `` ) ; sb . append ( get unknown offset ( ) + `` `` ) ; sb . append ( get unknown len ( ) + `` `` ) ; sb . append ( get dir offset ( ) + `` `` ) ; sb . append ( get dir len ( ) + `` `` ) ; sb . append ( get data offset ( ) + `` `` ) ; return sb . to string ( ) ; }
public void set object key ( string object key ) { this . object key = object key ; }
public void set object key ( string object key ) { this . object key = object key ; }
public string create torrent url ( string bucket name , string object key ) { string s3 endpoint = this . get endpoint ( ) ; string service endpoint virtual path = this . get virtual path ( ) ; int http port = this . get http port ( ) ; boolean disable dns bucket = this . get disable dns bucket ( ) ; string bucket name in path = ! disable dns bucket & & service utils . be bucket name valid d n s name ( bucket name ) ? `` `` : rest utils . encode url string ( bucket name ) + `` / `` ; string url path = rest utils . encode url path ( service endpoint virtual path , `` / `` ) + `` / `` + bucket name in path + rest utils . encode url path ( object key , `` / `` ) ; return `` http : // `` + service utils . generate s3 hostname for bucket ( bucket name , disable dns bucket , s3 endpoint ) + ( http port ! = 80 ? `` : `` + http port : `` `` ) + url path + `` ? torrent `` ; }
public static void init http proxy ( http client http client , string proxy host address , int proxy port , jets3t property jets3t property ) { init http proxy ( http client , jets3t property , false , proxy host address , proxy port , null , null , null ) ; }
public http params copy ( ) { http params clone = this . local . copy ( ) ; return new default http params ( clone , this . default ) ; }
public boolean get object ( string bucket name , storage object [ ] object ) { string [ ] object key = new string [ object . length ] ; for ( int i = 0 ; i < object . length ; i++ ) { object key [ i ] = object [ i ] . get key ( ) ; } return get object ( bucket name , object key ) ; }
public static boolean be positive completion ( int reply ) { return ( reply > = 200 & & reply < 300 ) ; }
public boolean fillable ( ) { if ( log . be debug enable ( ) ) log . debug ( `` fillable { } `` , this ) ; callback callback = _interested . get ( ) ; if ( callback ! = null & & _interested . compare and set ( callback , null ) ) { callback . succeed ( ) ; return true ; } if ( log . be debug enable ( ) ) log . debug ( `` { } lose race { } `` , this , callback ) ; return false ; }
public boolean fillable ( ) { if ( log . be debug enable ( ) ) log . debug ( `` fillable { } `` , this ) ; callback callback = _interested . get ( ) ; if ( callback ! = null & & _interested . compare and set ( callback , null ) ) { callback . succeed ( ) ; return true ; } if ( log . be debug enable ( ) ) log . debug ( `` { } lose race { } `` , this , callback ) ; return false ; }
public void set config path ( path config path ) { _config path = config path ; }
public void undeploy handler ( handler handler , callback callback ) { _serialized executor . execute ( new serialize executor . error handle task ( ) { @ override public void run ( ) { remove handler ( handler ) ; callback . succeed ( ) ; } @ override public void accept ( throwable throwable ) { callback . fail ( throwable ) ; } } ) ; }
public void add form encode method ( string method ) { _form encode method . put ( method , boolean . true ) ; }
public void set save period sec ( int save period sec ) { _save period sec = save period sec ; }
public void add error page ( int from , int to , string uri ) { _error page list . add ( new error code range ( from , to , uri ) ) ; }
public void set ssl session cache size ( int ssl session cache size ) { _ssl session cache size = ssl session cache size ; }
public void set ssl session timeout ( int ssl session timeout ) { _ssl session timeout = ssl session timeout ; }
public final type get return type ( ) { return return type ; }
public final int size ( ) { return size ! = 0 ? size : resolve size ( ) ; }
public static string serialize ( element element ) { return xml util . serialize ( element ) . replace first ( `` < \\ ? xml version=\ `` 1 . 0\ `` . * \\ ? > `` , `` `` ) ; }
public scanner get scanner ( ) { return _scanner ; }
public final expression optimize ( expression visitor visitor , item type context item type ) { return this ; }
public void pop ( ) throw java . lang . exception { if ( vstack . empty ( ) ) throw new exception ( `` internal parser error : pop from empty virtual stack `` ) ; / * pop it * / vstack . pop ( ) ; / * if we be now empty transfer an element ( if there be one ) * / if ( vstack . empty ( ) ) get_from_real ( ) ; }
public int [ ] get not class code ( list < interval > interval list ) { return get class code ( new int char set ( interval list ) , true ) ; }
public final method [ ] get reflective method ( ) { if ( method ! = null ) return method ; class < ? > baseclass = get java class ( ) ; method [ ] allmethods = baseclass . get declare method ( ) ; int n = allmethods . length ; int [ ] index = new int [ n ] ; int max = 0 ; for ( int i = 0 ; i < n ; ++i ) { method m = allmethods [ i ] ; string mname = m . get name ( ) ; if ( mname . start with ( method prefix ) ) { int k = 0 ; for ( int j = method prefix len ; ; ++j ) { char c = mname . char at ( j ) ; if ( ' 0 ' < = c & & c < = ' 9 ' ) k = k * 10 + c - ' 0 ' ; else break ; } index [ i ] = ++k ; if ( k > max ) max = k ; } } method = new method [ max ] ; for ( int i = 0 ; i < n ; ++i ) if ( index [ i ] > 0 ) method [ index [ i ] - 1 ] = allmethods [ i ] ; return method ; }
public short [ ] [ ] action_table ( ) { return _action_table ; }
public static void dump ( string message ) { if ( option . dump ) out . println ( message ) ; }
public static void error ( file file , error message message , int line , int column ) { string msg = nl+ `` error `` ; if ( file ! = null ) msg += `` in file \ `` `` +file+ `` \ `` `` ; if ( line > = 0 ) msg = msg+ `` ( line `` + ( line+1 ) + `` ) `` ; try { err ( msg+ `` : `` + n l+ error message . get ( message ) ) ; } catch ( array index out of bound exception e ) { err ( msg ) ; } errors++ ; if ( line > = 0 ) { if ( column > = 0 ) show position ( file , line , column ) ; else show position ( file , line ) ; } }
public static void println ( string message ) { if ( option . verbose ) out . println ( message ) ; }
public static void error ( string message ) { errors++ ; err ( n l+message ) ; }
public void add backwards ( string str ) { last yank = false ; if ( last kill ) { if ( slots [ head ] ! = null ) { slots [ head ] = str + slot [ head ] ; return ; } } last kill = true ; next ( ) ; slot [ head ] = str ; }
public boolean ready ( ) throw i o exception { synchronize ( lock ) { if ( in == null ) { throw new i o exception ( `` input stream reader be close . `` ) ; } try { return byte . have remain ( ) || in . available ( ) > 0 ; } catch ( i o exception e ) { return false ; } } }
protect void set closure delegate ( closure closure , object node ) { closure . set delegate ( this ) ; }
public restore snapshot request ignore index setting ( string . . . ignore index setting ) { this . ignore index setting = ignore index setting ; return this ; }
public boolean be error enabled ( ) { return ( get logger ( ) . be loggable ( level . severe ) ) ; }
public boolean be fatal enabled ( ) { return ( get logger ( ) . be loggable ( level . severe ) ) ; }
public boolean be info enable ( ) { return ( get logger ( ) . be loggable ( level . info ) ) ; }
public json node evaluate ( list < json node > evaluate args ) { json node subject = evaluate args . get ( 0 ) ; json node search = evaluate args . get ( 1 ) ; if ( subject . be array ( ) ) { return do array contain ( subject , search ) ; } else if ( subject . be textual ( ) ) { return do string contain ( subject , search ) ; } throw new invalid type exception ( `` type mismatch . expect a string or an array . `` ) ; }
public boolean host equal ( url u1 , url u2 ) { return super . host equal ( u1 , u2 ) ; }
public boolean match ( big decimal lh , big decimal rh ) { return lh . compare to ( rhs ) > = 0 ; }
public int get group count ( ) { return group count ; }
public int get subgroup count ( ) { return subgroup count ; }
public run result run single ( ) throw runner exception { set < benchmark list entry > benchmarks = list . find ( out , option . get include ( ) , option . get excludes ( ) ) ; if ( benchmark . size ( ) == 1 ) { collection < run result > value = run ( ) ; if ( value . size ( ) == 1 ) { return value . iterator ( ) . next ( ) ; } else { throw new runner exception ( `` no result return `` ) ; } } else { if ( benchmark . size ( ) > 1 ) { throw new runner exception ( `` more than single benchmark be match the option : `` + benchmark ) ; } else { throw new no benchmarks exception ( ) ; } } }
protect double homoscedastic t ( double m1 , double m2 , double v1 , double v2 , double n1 , double n2 ) { double pool variance = ( ( n1 - 1 ) * v1 + ( n2 -1 ) * v2 ) / ( n1 + n2 - 2 ) ; return ( m1 - m2 ) / math . sqrt ( pooled variance * ( 1d / n1 + 1d / n2 ) ) ; }
public static void set field ( object object with field , string field name , object field value ) { field reflection . set field ( object with field . get class ( ) , object with field , field name , field value ) ; }
public static < t > t get field ( class < ? > class with static field , class < t > field type ) { return field reflection . get field ( class with static field , field type , null ) ; }
public static < t > t new instance ( class < ? extend t > class to instantiate , class < ? > [ ] parameter type , object . . . init args ) { return constructor reflection . new instance ( class to instantiate , parameter type , init args ) ; }
public boolean capture new instance for applicable mock field ( @ nonnull object mock ) { if ( capture of new instance == null ) { return false ; } object field owner = test run . get current test instance ( ) ; return capture of new instance . capture new instance ( field owner , mock ) ; }
public string [ ] get string array ( long offset ) { return get string array ( offset , -1 , native . get default string encoding ( ) ) ; }
public void set auto synch ( boolean auto ) { set auto read ( auto ) ; set auto write ( auto ) ; }
public long min value ( ) { if ( min value == null ) { min value = get long field ( `` min_value `` , integer . min_value ) ; } return min value . int value ( ) ; }
public long min value ( ) { if ( min value == null ) { min value = get long field ( `` min_value `` , integer . min_value ) ; } return min value . int value ( ) ; }
public int compare to ( cell address other ) { int r = this . _row-other . _row ; if ( r ! =0 ) return r ; r = this . _col-other . _col ; if ( r ! =0 ) return r ; return 0 ; }
public void to native ( runtime runtime , pointer buffer , long offset ) { buffer . put byte ( offset , value ) ; }
public void to native ( runtime runtime , pointer buffer , long offset ) { buffer . put double ( offset , value ) ; }
public void from native ( runtime runtime , pointer memory , long offset ) { this . value = native long . value of ( memory . get native long ( offset ) ) ; }
public void from native ( runtime runtime , pointer memory , long offset ) { value = address . value of ( memory . get address ( offset ) ) ; }
public final long native address ( ) { return address ; }
protect void log diagnostic ( string msg ) { if ( be diagnostics enabled ( ) ) { log raw diagnostic ( diagnostic prefix + msg ) ; } }
protect boolean be jdk14 available ( ) { return be log library available ( `` jdk14 `` , `` org . apache . common . log . impl . jdk14 logger `` ) ; }
protect boolean be log4 j available ( ) { return be log library available ( `` log4 j `` , logging_impl_log4j_logger ) ; }
public object get property ( string name ) { if ( name == null ) { throw new illegal argument exception ( `` parameter 'name ' must be not null `` ) ; } return this . property . get ( name ) . get value ( ) ; }
public path get link target ( final path f ) throw i o exception { throw new assertion error ( `` implementation error : `` + get class ( ) + `` that throw an unresolved link exception , cause this method to be `` + `` call , need to override this method . `` ) ; }
public static final mem qword_ptr ( label label , long disp ) { return _ptr_build ( label , disp , size_qword ) ; }
public final void fabs ( ) { emit x86 ( inst_fabs ) ; }
public final void orpd ( x m m register dst , x m m register src ) { emit x86 ( inst_orpd , dst , src ) ; }
public final void orpd ( x m m register dst , x m m register src ) { emit x86 ( inst_orpd , dst , src ) ; }
public final void stmxcsr ( mem dst ) { emit x86 ( inst_stmxcsr , dst ) ; }
public final void fabs ( ) { emit x86 ( inst_fabs ) ; }
public final void fiadd ( mem src ) { assert ( src . size ( ) == 2 || src . size ( ) == 4 ) ; emit x86 ( inst_fiadd , src ) ; }
public final void fabs ( ) { emit x86 ( inst_fabs ) ; }
public final void orpd ( x m m register dst , x m m register src ) { emit x86 ( inst_orpd , dst , src ) ; }
public final void orpd ( x m m register dst , x m m register src ) { emit x86 ( inst_orpd , dst , src ) ; }
public final void orpd ( x m m register dst , x m m register src ) { emit x86 ( inst_orpd , dst , src ) ; }
public final void orpd ( x m m register dst , x m m register src ) { emit x86 ( inst_orpd , dst , src ) ; }
public final void pextrw ( register dst , m m register src , immediate imm8 ) { emit x86 ( inst_pextrw , dst , src , imm8 ) ; }
public final void stmxcsr ( mem dst ) { emit x86 ( inst_stmxcsr , dst ) ; }
public final void orpd ( x m m register dst , x m m register src ) { emit x86 ( inst_orpd , dst , src ) ; }
public final void orpd ( x m m register dst , x m m register src ) { emit x86 ( inst_orpd , dst , src ) ; }
public final void orpd ( x m m register dst , x m m register src ) { emit x86 ( inst_orpd , dst , src ) ; }
public final void orpd ( x m m register dst , x m m register src ) { emit x86 ( inst_orpd , dst , src ) ; }
public final void orpd ( x m m register dst , x m m register src ) { emit x86 ( inst_orpd , dst , src ) ; }
public final void orpd ( x m m register dst , x m m register src ) { emit x86 ( inst_orpd , dst , src ) ; }
public final void orpd ( x m m register dst , x m m register src ) { emit x86 ( inst_orpd , dst , src ) ; }
public final void orpd ( x m m register dst , x m m register src ) { emit x86 ( inst_orpd , dst , src ) ; }
public final void fabs ( ) { emit x86 ( inst_fabs ) ; }
public final void orpd ( x m m register dst , x m m register src ) { emit x86 ( inst_orpd , dst , src ) ; }
public final void orpd ( x m m register dst , x m m register src ) { emit x86 ( inst_orpd , dst , src ) ; }
public final void orpd ( x m m register dst , x m m register src ) { emit x86 ( inst_orpd , dst , src ) ; }
public final void orpd ( x m m register dst , x m m register src ) { emit x86 ( inst_orpd , dst , src ) ; }
public final void orpd ( x m m register dst , x m m register src ) { emit x86 ( inst_orpd , dst , src ) ; }
public final void orpd ( x m m register dst , x m m register src ) { emit x86 ( inst_orpd , dst , src ) ; }
public final void orpd ( x m m register dst , x m m register src ) { emit x86 ( inst_orpd , dst , src ) ; }
public final void orpd ( x m m register dst , x m m register src ) { emit x86 ( inst_orpd , dst , src ) ; }
public final void pextrw ( register dst , m m register src , immediate imm8 ) { emit x86 ( inst_pextrw , dst , src , imm8 ) ; }
public final void orpd ( x m m register dst , x m m register src ) { emit x86 ( inst_orpd , dst , src ) ; }
public final void orpd ( x m m register dst , x m m register src ) { emit x86 ( inst_orpd , dst , src ) ; }
public display display ( ) { return display ; }
public chart format show vertical legend ( boolean new show vertical legend ) { return show legend ( show horizontal legend , new show vertical legend ) ; }
public keyword to keyword ( ) { return keyword ; }
public final boolean support ( ) { return support ; }
public string get indentation ( ) { return indentation ; }
public boolean be render catalog ( ) { return render catalog ; }
public void set render mapping ( render map value ) { this . render map = value ; }
public void set render scalar subqueries for stored function ( boolean value ) { this . render scalar subqueries for stored function = value ; }
public void set backslash escaping ( backslash escape value ) { this . backslash escape = value ; }
public void set execute with optimistic lock exclude unversioned ( boolean value ) { this . execute with optimistic lock exclude unversioned = value ; }
public void set fetch warning ( boolean value ) { this . fetch warning = value ; }
public query poolable get query poolable ( ) { return query poolable ; }
public string get delimiter ( ) { return delimiter ; }
public void set render group concat max len session variable ( boolean value ) { this . render group concat max len session variable = value ; }
public integer get fetch server output size ( ) { return fetch server output size ; }
public void set meta include system sequence ( boolean value ) { this . meta include system sequence = value ; }
public static final param type get param type ( settings setting ) { if ( execute static statement ( setting ) ) { return inlined ; } else if ( setting ! = null ) { param type result = setting . get param type ( ) ; if ( result ! = null ) return result ; } return indexed ; }
public void println ( final appendable out ) throw i o exception { if ( get trail delimiter ( ) ) { out . append ( get delimiter ( ) ) ; } if ( record separator ! = null ) { out . append ( record separator ) ; } }
public / * non-final for covariant override * / table < r > a ( string alias ) { return a ( dsl . name ( alias ) ) ; }
public static visit listener provider [ ] provider ( visit listener . . . listener ) { visit listener provider [ ] result = new visit listener provider [ listener . length ] ; for ( int i = 0 ; i < listener . length ; i++ ) result [ i ] = new default visit listener provider ( listener [ i ] ) ; return result ; }
public static create index step create index if not exist ( string index ) { return dsl ( ) . create index if not exist ( index ) ; }
public static create index step create index if not exist ( string index ) { return dsl ( ) . create index if not exist ( index ) ; }
public static drop view final step drop view if exists ( string view ) { return dsl ( ) . drop view if exists ( view ) ; }
public static table < record1 < integer > > generate series ( int from , int to ) { return generate series ( val ( from ) , val ( to ) ) ; }
public static privilege privilege ( string privilege ) { return privilege ( keyword ( privilege ) ) ; }
public static table < record1 < integer > > generate series ( int from , int to ) { return generate series ( val ( from ) , val ( to ) ) ; }
public static field < string > concat ( field < string > field , string value ) { return concat ( null safe ( field ) , tool . field ( value ) ) ; }
public static condition condition ( map < field < ? > , ? > map ) { return new map condition ( map ) ; }
public static field < string > lpad ( field < string > field , int length ) { return lpad ( null safe ( field ) , tool . field ( length ) ) ; }
public static field < integer > position ( string in , string search , int start index ) { return position ( tools . field ( in ) , tool . field ( search ) , tool . field ( start index ) ) ; }
public static < t > field < t > coalesce ( field < t > field , t value ) { return coalesce0 ( field , tool . field ( value , field ) ) ; }
public static field < day to second > timestamp diff ( timestamp timestamp1 , timestamp timestamp2 ) { return timestamp diff ( tool . field ( timestamp1 ) , tool . field ( timestamp2 ) ) ; }
public static field < date > trunc ( date date , date part part ) { return trunc ( tool . field ( date ) , part ) ; }
public static field < time > time ( string value ) { return tool . field ( convert . convert ( value , time . class ) ) ; }
public static field < day to second > timestamp diff ( timestamp timestamp1 , timestamp timestamp2 ) { return timestamp diff ( tool . field ( timestamp1 ) , tool . field ( timestamp2 ) ) ; }
public static aggregate function < big decimal > regr count ( field < ? extend number > y , field < ? extend number > x ) { return new org . jooq . impl . function < big decimal > ( `` regr_count `` , s q l data type . numeric , null safe ( y ) , null safe ( x ) ) ; }
public static field < integer > bit length ( string value ) { return bit length ( tool . field ( value ) ) ; }
public static < t extend number > field < t > round ( t value , int decimal ) { return round ( tool . field ( value ) , decimal ) ; }
public static field < date > trunc ( date date ) { return trunc ( date , date part . day ) ; }
public static field < string > repeat ( string field , int count ) { return repeat ( tool . field ( field ) , tool . field ( count ) ) ; }
public static asterisk asterisk ( ) { return asterisk impl . instance ; }
public static order aggregate function < string > list agg ( field < ? > field ) { return new org . jooq . impl . function < string > ( term . list_agg , s q l data type . varchar , null safe ( field ) ) ; }
public static order aggregate function < integer > percent rank ( field < ? > . . . field ) { return new org . jooq . impl . function < integer > ( `` percent_rank `` , s q l data type . integer , field ) ; }
public static < t > field < t > function ( name name , class < t > type , field < ? > . . . argument ) { return function ( name , get data type ( type ) , null safe ( argument ) ) ; }
public static field < date > trunc ( date date ) { return trunc ( date , date part . day ) ; }
public static field < date > current date ( ) { return new current date < date > ( s q l data type . date ) ; }
public static field < timestamp > current timestamp ( ) { return new current timestamp < timestamp > ( s q l data type . timestamp ) ; }
public static condition condition ( map < field < ? > , ? > map ) { return new map condition ( map ) ; }
public boolean batch multiple ( ) { return sql . length > 1 ; }
public string [ ] batch s q l ( ) { return sql ; }
public reflect field ( string name ) throw reflect exception { try { field field = field0 ( name ) ; return on ( field . get type ( ) , field . get ( object ) ) ; } catch ( exception e ) { throw new reflect exception ( e ) ; } }
public static string default if empty ( string str , string default str ) { return string utils . be empty ( str ) ? default str : str ; }
public static string leave pad ( string str , int size ) { return leave pad ( str , size , ' ' ) ; }
public static boolean null safe equal ( object o1 , object o2 ) { if ( o1 == o2 ) { return true ; } if ( o1 == null || o2 == null ) { return false ; } if ( o1 . equal ( o2 ) ) { return true ; } if ( o1 . get class ( ) . be array ( ) & & o2 . get class ( ) . be array ( ) ) { if ( o1 instanceof object [ ] & & o2 instanceof object [ ] ) { return array . equal ( ( object [ ] ) o1 , ( object [ ] ) o2 ) ; } if ( o1 instanceof boolean [ ] & & o2 instanceof boolean [ ] ) { return array . equal ( ( boolean [ ] ) o1 , ( boolean [ ] ) o2 ) ; } if ( o1 instanceof byte [ ] & & o2 instanceof byte [ ] ) { return array . equal ( ( byte [ ] ) o1 , ( byte [ ] ) o2 ) ; } if ( o1 instanceof char [ ] & & o2 instanceof char [ ] ) { return array . equal ( ( char [ ] ) o1 , ( char [ ] ) o2 ) ; } if ( o1 instanceof double [ ] & & o2 instanceof double [ ] ) { return array . equal ( ( double [ ] ) o1 , ( double [ ] ) o2 ) ; } if ( o1 instanceof float [ ] & & o2 instanceof float [ ] ) { return array . equal ( ( float [ ] ) o1 , ( float [ ] ) o2 ) ; } if ( o1 instanceof int [ ] & & o2 instanceof int [ ] ) { return array . equal ( ( int [ ] ) o1 , ( int [ ] ) o2 ) ; } if ( o1 instanceof long [ ] & & o2 instanceof long [ ] ) { return array . equal ( ( long [ ] ) o1 , ( long [ ] ) o2 ) ; } if ( o1 instanceof short [ ] & & o2 instanceof short [ ] ) { return array . equal ( ( short [ ] ) o1 , ( short [ ] ) o2 ) ; } } return false ; }
public t x t format min col width ( int new min col width ) { return new t x t format ( max row , new min col width , max col width , horizontal table border , horizontal header border , horizontal cell border , vertical table border , vertical cell border , intersect line ) ; }
public t x t format horizontal cell border ( boolean new horizontal cell border ) { return new t x t format ( max row , min col width , max col width , horizontal table border , horizontal header border , new horizontal cell border , vertical table border , vertical cell border , intersect line ) ; }
public t x t format horizontal cell border ( boolean new horizontal cell border ) { return new t x t format ( max row , min col width , max col width , horizontal table border , horizontal header border , new horizontal cell border , vertical table border , vertical cell border , intersect line ) ; }
public final int get second ( ) { return second ; }
public static field < string > encode ( string string , string key string ) { return encode ( val ( string ) , val ( key string ) ) ; }
public static field < string > encode ( string string , string key string ) { return encode ( val ( string ) , val ( key string ) ) ; }
public static field < string > decode ( string crypt string , string key string ) { return decode ( val ( crypt string ) , val ( key string ) ) ; }
public static field < string > decode ( string crypt string , string key string ) { return decode ( val ( crypt string ) , val ( key string ) ) ; }
public static field < string > decode ( string crypt string , string key string ) { return decode ( val ( crypt string ) , val ( key string ) ) ; }
public static < t > field < t [ ] > array fill ( t value , integer [ ] dimension , integer [ ] bound ) { return array fill ( val ( value ) , val ( dimension ) , val ( bound ) ) ; }
public static table < record > only ( table < ? > table ) { return table ( `` { only } { 0 } `` , table ) ; }
public static object to p g interval ( year to second interval ) { return new p g interval ( interval . get sign ( ) * interval . get year ( ) , interval . get sign ( ) * interval . get month ( ) , interval . get sign ( ) * interval . get day ( ) , interval . get sign ( ) * interval . get hour ( ) , interval . get sign ( ) * interval . get minute ( ) , interval . get sign ( ) * interval . get second ( ) + interval . get sign ( ) * interval . get nano ( ) / 1000000000 . 0 ) ; }
public string get column default ( ) { return column default ; }
public void set numeric precision ( integer value ) { this . numeric precision = value ; }
public void set column default ( string value ) { this . column default = value ; }
public string get index name ( ) { return index name ; }
public void set index name ( string value ) { this . index name = value ; }
public void set be descend ( boolean value ) { this . be descend = value ; }
public string get constraint catalog ( ) { return constraint catalog ; }
public string get specific catalog ( ) { return specific catalog ; }
public string get unique constraint schema ( ) { return unique constraint schema ; }
public routine type get routine type ( ) { return routine type ; }
public string get routine package ( ) { return routine package ; }
public table constraint type get constraint type ( ) { return constraint type ; }
public x m l format xmlns ( boolean new xmlns ) { return new x m l format ( new xmlns , format , newline , indent , indent , header , record format ) ; }
public string get catalog ( ) { return catalog ; }
public render optional keyword get render optional inner keyword ( ) { return render optional inner keyword ; }
public void set render parenthesis around set operation query ( boolean value ) { this . render parenthesis around set operation query = value ; }
public void set updatable primary key ( boolean value ) { this . updatable primary key = value ; }
public void set meta include system index ( boolean value ) { this . meta include system index = value ; }
public final boolean drop table cascade ( ) { return drop table cascade ; }
public table constraint type get constraint type ( ) { return constraint type ; }
public void set include sequence ( boolean value ) { this . include sequence = value ; }
public boolean be include exclude package routine ( ) { return include exclude package routine ; }
public boolean be include package constant ( ) { return include package constant ; }
public void set include system u d t ( boolean value ) { this . include system u d t = value ; }
public boolean be include system sequence ( ) { return include system sequence ; }
public void set include foreign key ( boolean value ) { this . include foreign key = value ; }
public void set override primary key ( string value ) { this . override primary key = value ; }
public boolean be unsigned type ( ) { return unsigned type ; }
public string get output schema ( ) { return output schema ; }
public boolean be output catalog to default ( ) { return output catalog to default ; }
public void set relation ( boolean value ) { this . relation = value ; }
public boolean be deprecate ( ) { return deprecate ; }
public void set comment on key ( boolean value ) { this . comment on key = value ; }
public boolean be interface ( ) { return interface ; }
public void set serializable interface ( boolean value ) { this . serializable interface = value ; }
public void set jpa version ( string value ) { this . jpa version = value ; }
public boolean be global index reference ( ) { return global index reference ; }
public boolean be comment on table ( ) { return comment on table ; }
public void set comment on table ( boolean value ) { this . comment on table = value ; }
public boolean be comment on package ( ) { return comment on package ; }
public void set comment on routine ( boolean value ) { this . comment on routine = value ; }
public boolean be comment on routine ( ) { return comment on routine ; }
public void set vararg setter ( boolean value ) { this . vararg setter = value ; }
public boolean be java time type ( ) { return java time type ; }
public jdbc get jdbc ( ) { return jdbc ; }
public string get username ( ) { return username ; }
public string get password ( ) { return password ; }
public void set enum implement ( string value ) { this . enum implement = value ; }
public void set routine implement ( string value ) { this . routine implement = value ; }
public void set record class ( matcher rule value ) { this . record class = value ; }
public string get pojo implement ( ) { return pojo implement ; }
public void set__1 ( object value ) { set value ( _1 , value ) ; }
public void set include system sequence ( boolean value ) { this . include system sequence = value ; }
public string get synthetic identity ( ) { return synthetic identity ; }
public boolean be integer display width ( ) { return integer display width ; }
public string get catalog ( ) { return catalog ; }
public boolean be sequence ( ) { return sequence ; }
public void set nonnull annotation ( boolean value ) { this . nonnull annotation = value ; }
public boolean be pojos a kotlin data class ( ) { return pojos a kotlin data class ; }
public void set kotlin setter jvm name annotation on be prefix ( boolean value ) { this . kotlin setter jvm name annotation on be prefix = value ; }
public boolean be comment on embeddables ( ) { return comment on embeddables ; }
public string get expression ( ) { return expression ; }
public string get key ( ) { return key ; }
public string get sql ( ) { return sql ; }
public context get supply key provider context ( ) { return supply key provider context ; }
public jwt consumer builder set skip signature verification ( ) { skip signature verification = true ; return this ; }
public jwt consumer builder set expect issuer ( boolean require issuer , string expect issuer ) { iss validator = new iss validator ( expect issuer , require issuer ) ; return this ; }
public void set pty type ( string ttype ) { set pty type ( ttype , 80 , 24 , 640 , 480 ) ; }
public void clear ( ) { kpair . dispose ( ) ; kpair = null ; }
public session get session ( string host ) throw j sch exception { return get session ( null , host , 22 ) ; }
public host key repository get host key repository ( ) { if ( known_hosts==null ) known_hosts=new know host ( this ) ; return known_hosts ; }
protect double get domain low bound ( double p ) { return 0 ; }
public tag extra info get tag extra info ( ) { return tag extra info ; }
public void set tag library ( tag library info tl ) { tag library = tl ; }
public void remove value ( string k ) { if ( value ! = null ) { value . remove ( k ) ; } }
public void remove speed test listener ( final i speed test listener listener ) { m listener list . remove ( listener ) ; }
public void force stop task ( ) { m repeat wrapper . clean timer ( ) ; m task . force stop task ( ) ; m task . close socket ( ) ; shutdown and wait ( ) ; }
public void force stop task ( ) { m repeat wrapper . clean timer ( ) ; m task . force stop task ( ) ; m task . close socket ( ) ; shutdown and wait ( ) ; }
public void set upload setup time ( final long setup time ) { this . m upload setup time = setup time ; }
public void set upload storage type ( final upload storage type upload storage type ) { m upload storage type = upload storage type ; }
public random access file generate random file ( final int length ) throw i o exception { m file = file . create temp file ( speed test const . upload_temp_file_name , speed test const . upload_temp_file_extension ) ; final random access file random file = new random access file ( m file . get absolute path ( ) , `` rw `` ) ; random file . set length ( length ) ; final int iter = length / speed test const . upload_file_write_chunk ; final int remain = length % speed test const . upload_file_write_chunk ; for ( int i = 0 ; i < iter ; i++ ) { final byte [ ] random = new byte [ speed test const . upload_file_write_chunk ] ; m random . next byte ( random ) ; random file . write ( random ) ; } if ( remain > 0 ) { final byte [ ] random = new byte [ remain ] ; m random . next byte ( random ) ; random file . write ( random ) ; } return random file ; }
public speed test report get live report ( ) { if ( get speed test mode ( ) == speed test mode . download ) { return m task . get report ( speed test mode . download ) ; } else { return m task . get report ( speed test mode . upload ) ; } }
public static double interior angle ( coordinate p0 , coordinate p1 , coordinate p2 ) { double angle prev = angle . angle ( p1 , p0 ) ; double angle next = angle . angle ( p1 , p2 ) ; return math . ab ( angle next - angle prev ) ; }
public static double clamp ( double x , double min , double max ) { if ( x < min ) return min ; if ( x > max ) return max ; return x ; }
public boolean be on segment ( ) { return be point on segment ; }
public boolean be interior intersection ( ) { if ( be interior intersection ( 0 ) ) return true ; if ( be interior intersection ( 1 ) ) return true ; return false ; }
public line string get support segment ( ) { compute minimum diameter ( ) ; return input geom . get factory ( ) . create line string ( new coordinate [ ] { min base seg . p0 , min base seg . p1 } ) ; }
public void add ( geometry geometry ) { geometry . apply ( new geometry component filter ( ) { public void filter ( geometry component ) { if ( component instanceof line string ) { add ( ( line string ) component ) ; } } } ) ; }
public half edge find edge ( coordinate orig , coordinate d ) { half edge e = ( half edge ) vertex map . get ( orig ) ; if ( e == null ) return null ; return e . find ( d ) ; }
public coordinate [ ] get coordinate ( ) { / * // check that point be a ring - add the startpoint again if they be not if ( pt list . size ( ) > 1 ) { coordinate start = ( coordinate ) pt list . get ( 0 ) ; coordinate end = ( coordinate ) pt list . get ( pt list . size ( ) - 1 ) ; if ( ! start . equal ( end ) ) add pt ( start ) ; } * / coordinate [ ] coord = ( coordinate [ ] ) pt list . to array ( coordinate_array_type ) ; return coord ; }
public static boolean equal ( double x , double y ) { return ( double . be na n ( x ) & & double . be na n ( y ) ) || x == y ; }
public double get height ( ) { if ( be null ( ) ) { return 0 ; } return maxy - miny ; }
public boolean intersects ( envelope other ) { if ( be null ( ) || other . be null ( ) ) { return false ; } return ! ( other . minx > maxx || other . maxx < minx || other . miny > maxy || other . maxy < miny ) ; }
public coordinate centre ( ) { if ( be null ( ) ) return null ; return new coordinate ( ( get min x ( ) + get max x ( ) ) / 2 . 0 , ( get min y ( ) + get max y ( ) ) / 2 . 0 ) ; }
public void expand to include ( coordinate p ) { expand to include ( p . x , p . y ) ; }
public geometry reverse ( ) { geometry res = reverse internal ( ) ; if ( this . envelope ! = null ) res . envelope = this . envelope . copy ( ) ; re . set s r i d ( get s r i d ( ) ) ; return res ; }
public static string normalize ( string value ) { if ( value == null ) return value ; value = value . trim ( ) ; if ( value . index of ( `` `` ) == -1 ) return value ; boolean space = false ; int len = value . length ( ) ; string buffer b = new string buffer ( len ) ; for ( int i = 0 ; i < len ; i++ ) { char v = value . char at ( i ) ; if ( v == ' ' ) { if ( ! space ) b . append ( v ) ; space = true ; } else { b . append ( v ) ; space = false ; } } return b . to string ( ) ; }
public boolean be cover by ( ) { boolean have point in common = be true ( matrix [ location . interior ] [ location . interior ] ) || be true ( matrix [ location . interior ] [ location . boundary ] ) || be true ( matrix [ location . boundary ] [ location . interior ] ) || be true ( matrix [ location . boundary ] [ location . boundary ] ) ; return have point in common & & matrix [ location . interior ] [ location . exterior ] == dimension . false & & matrix [ location . boundary ] [ location . exterior ] == dimension . false ; }
public boolean be cover by ( ) { boolean have point in common = be true ( matrix [ location . interior ] [ location . interior ] ) || be true ( matrix [ location . interior ] [ location . boundary ] ) || be true ( matrix [ location . boundary ] [ location . interior ] ) || be true ( matrix [ location . boundary ] [ location . boundary ] ) ; return have point in common & & matrix [ location . interior ] [ location . exterior ] == dimension . false & & matrix [ location . boundary ] [ location . exterior ] == dimension . false ; }
public double distance ( line segment l ) { return distance . segment to segment ( p0 , p1 , l . p0 , l . p1 ) ; }
public boolean be float ( ) { return model type == float || model type == floating_single ; }
public boolean add ( object obj , boolean allow repeat ) { add ( ( coordinate ) obj , allow repeat ) ; return true ; }
protect boolean be any test point in target ( geometry test geom ) { / * * * this could be optimize by use the segment index on the lineal target . * however , it seem like the l/p case would be pretty rare in practice . * / point locator locator = new point locator ( ) ; list coords = component coordinate extracter . get coordinate ( test geom ) ; for ( iterator i = coords . iterator ( ) ; i . have next ( ) ; ) { coordinate p = ( coordinate ) i . next ( ) ; if ( locator . intersects ( p , prep line . get geometry ( ) ) ) return true ; } return false ; }
protect boolean full topological predicate ( geometry geom ) { boolean result = prep poly . get geometry ( ) . cover ( geom ) ; return result ; }
public static coordinate angle bisector ( coordinate a , coordinate b , coordinate c ) { / * * * use the fact that the length of the part of the split segment be * proportional to the length of the adjacent triangle side * / double len0 = b . distance ( a ) ; double len2 = b . distance ( c ) ; double frac = len0 / ( len0 + len2 ) ; double dx = c . x - a . x ; double dy = c . y - a . y ; coordinate split pt = new coordinate ( a . x + frac * dx , a . y + frac * dy ) ; return split pt ; }
public double area ( ) { return area ( this . p0 , this . p1 , this . p2 ) ; }
public static affine transformation rotation instance ( double sin theta , double co theta ) { affine transformation trans = new affine transformation ( ) ; trans . set to rotation ( sin theta , cos theta ) ; return trans ; }
public affine transformation set transformation ( affine transformation trans ) { m00 = trans . m00 ; m01 = trans . m01 ; m02 = trans . m02 ; m10 = trans . m10 ; m11 = trans . m11 ; m12 = trans . m12 ; return this ; }
public affine transformation rotate ( double theta , double x , double y ) { compose ( rotation instance ( theta , x , y ) ) ; return this ; }
public boolean be pointwise equal ( edge e ) { if ( pt . length ! = e . pt . length ) return false ; for ( int i = 0 ; i < pt . length ; i++ ) { if ( ! pt [ i ] . equals2 d ( e . pt [ i ] ) ) { return false ; } } return true ; }
public void compute i m ( intersection matrix im ) { update i m ( label , im ) ; }
public int compare to ( object o ) { sweep line event pe = ( sweep line event ) o ; if ( x value < pe . x value ) return -1 ; if ( x value > pe . x value ) return 1 ; if ( event type < pe . event type ) return -1 ; if ( event type > pe . event type ) return 1 ; return 0 ; }
public static void link result direct edge ( collection node ) { for ( iterator nodeit = node . iterator ( ) ; nodeit . have next ( ) ; ) { node node = ( node ) nodeit . next ( ) ; ( ( direct edge star ) node . get edge ( ) ) . link result direct edge ( ) ; } }
public edge find edge ( coordinate p0 , coordinate p1 ) { for ( int i = 0 ; i < edge . size ( ) ; i++ ) { edge e = ( edge ) edge . get ( i ) ; coordinate [ ] e coord = e . get coordinate ( ) ; if ( p0 . equal ( e coord [ 0 ] ) & & p1 . equal ( e coord [ 1 ] ) ) return e ; } return null ; }
public static int octant ( coordinate p0 , coordinate p1 ) { double dx = p1 . x - p0 . x ; double dy = p1 . y - p0 . y ; if ( dx == 0 . 0 & & dy == 0 . 0 ) throw new illegal argument exception ( `` can not compute the octant for two identical point `` + p0 ) ; return octant ( dx , dy ) ; }
public boolean accept num param ( int num param ) { return num param == 1 || num param == 2 ; }
public int size ( ) { return size node ( root ) ; }
public int depth ( ) { return depth node ( root ) ; }
public int size ( ) { return size node ( root ) ; }
public abstract node get root ( ) { build ( ) ; return root ; }
public geometry get boundary ( ) { if ( be empty ( ) ) { return get factory ( ) . create multi line string ( ) ; } array list all ring = new array list ( ) ; for ( int i = 0 ; i < geometry . length ; i++ ) { polygon polygon = ( polygon ) geometries [ i ] ; geometry ring = polygon . get boundary ( ) ; for ( int j = 0 ; j < ring . get num geometry ( ) ; j++ ) { all ring . add ( ring . get geometry n ( j ) ) ; } } line string [ ] all ring array = new line string [ all ring . size ( ) ] ; return get factory ( ) . create multi line string ( ( line string [ ] ) all ring . to array ( all ring array ) ) ; }
public void set altitude mode ( string altitude mode ) { this . altitude mode = altitude mode ; }
public static byte string decode hex ( string hex ) { if ( hex == null ) throw new illegal argument exception ( `` hex == null `` ) ; if ( hex . length ( ) % 2 ! = 0 ) throw new illegal argument exception ( `` unexpected hex string : `` + hex ) ; byte [ ] result = new byte [ hex . length ( ) / 2 ] ; for ( int i = 0 ; i < result . length ; i++ ) { int d1 = decode hex digit ( hex . char at ( i * 2 ) ) < < 4 ; int d2 = decode hex digit ( hex . char at ( i * 2 + 1 ) ) ; result [ i ] = ( byte ) ( d1 + d2 ) ; } return of ( result ) ; }
public boolean be vertex ( ) { return segment fraction < = 0 . 0 || segment fraction > = 1 . 0 ; }
public boolean be vertex ( ) { return segment fraction < = 0 . 0 || segment fraction > = 1 . 0 ; }
public double index of ( coordinate pt ) { return length index of point . index of ( linear geom , pt ) ; }
public boolean le ( dd y ) { return ( hi < y . hi ) || ( hi == y . hi & & lo < = y . lo ) ; }
public boolean le ( dd y ) { return ( hi < y . hi ) || ( hi == y . hi & & lo < = y . lo ) ; }
public segment set mutual intersector get segment set intersector ( ) { return seg set mut int ; }
public void set find all intersection ( boolean find all intersection ) { this . find all intersection = find all intersection ; }
public void set check end segment only ( boolean be check end segment only ) { this . be check end segment only = be check end segment only ; }
public coordinate get interior intersection ( ) { return interior intersection ; }
public void compute node ( collection input segment string ) { snapped result = snap round ( input segment string ) ; }
public boolean be do ( ) { / * * * if find all type , we can stop * when both possible type have be find . * / if ( find all type ) { return have proper intersection & & have non proper intersection ; } / * * * if search for a proper intersection , only stop if one be find * / if ( find proper ) { return have proper intersection ; } return have intersection ; }
public void compute node ( collection input segment string ) { snapped result = snap round ( input segment string ) ; }
public int get quadrant segment ( ) { return quadrant segment ; }
public int compare to ( object o ) { buffer subgraph graph = ( buffer subgraph ) o ; if ( this . right most coord . x < graph . right most coord . x ) { return -1 ; } if ( this . right most coord . x > graph . right most coord . x ) { return 1 ; } return 0 ; }
public static double distance ( geometry g1 , geometry g2 ) { indexed facet distance dist = new indexed facet distance ( g1 ) ; return dist . distance ( g2 ) ; }
public void check ( int op code ) { for ( iterator nodeit = graph . get node iterator ( ) ; nodeit . have next ( ) ; ) { node node = ( node ) nodeit . next ( ) ; test link result direct edge ( ( direct edge star ) node . get edge ( ) , op code ) ; } }
public void compute hole ( ) { linear ring ring = get ring ( ) ; be hole = orientation . be c c w ( ring . get coordinate ( ) ) ; }
public collection get dangles ( ) { polygonize ( ) ; return dangles ; }
public collection get dangles ( ) { polygonize ( ) ; return dangles ; }
public topology validation error get validation error ( ) { check valid ( parent geometry ) ; return valid err ; }
public collection get edge ( ) { return edge ; }
public node remove ( coordinate pt ) { return ( node ) node map . remove ( pt ) ; }
public boolean get curly brace denote code block ( int language index ) { return true ; }
public static geometry reduce ( geometry g , precision model prec model ) { geometry precision reducer reducer = new geometry precision reducer ( prec model ) ; return reducer . reduce ( g ) ; }
public static geometry reduce pointwise ( geometry g , precision model prec model ) { geometry precision reducer reducer = new geometry precision reducer ( prec model ) ; reducer . set pointwise ( true ) ; return reducer . reduce ( g ) ; }
public void set constrain to circle ( boolean be constrain to circle ) { this . be constrain to circle = be constrain to circle ; }
public void set ensure valid ( boolean be ensure valid topology ) { this . be ensure valid topology = be ensure valid topology ; }
public list get initial vertex ( ) { return initial vertex ; }
public list get initial vertex ( ) { return initial vertex ; }
public final quad edge r next ( ) { return rot . next . inv rot ( ) ; }
public quad edge get primary ( ) { if ( orig ( ) . get coordinate ( ) . compare to ( dest ( ) . get coordinate ( ) ) < = 0 ) return this ; else return sym ( ) ; }
public boolean equal non orient ( quad edge qe ) { if ( equal orient ( qe ) ) return true ; if ( equal orient ( qe . sym ( ) ) ) return true ; return false ; }
public int get edge index ( quad edge e ) { for ( int i = 0 ; i < 3 ; i++ ) { if ( edge [ i ] == e ) return i ; } return -1 ; }
public vertex mid point ( vertex a ) { double xm = ( p . x + a . get x ( ) ) / 2 . 0 ; double ym = ( p . y + a . get y ( ) ) / 2 . 0 ; double zm = ( p . z + a . get z ( ) ) / 2 . 0 ; return new vertex ( xm , ym , zm ) ; }
public line segment get line segment ( ) { return l ; }
public double distance ( line segment l ) { return distance . segment to segment ( p0 , p1 , l . p0 , l . p1 ) ; }
public coordinate line intersection ( line segment line ) { coordinate int pt = intersection . intersection ( p0 , p1 , line . p0 , line . p1 ) ; return int pt ; }
public coordinate [ ] get coordinate ( ) { return pt ; }
public static void add watch ( object obj ) { debug . instance add watch ( obj ) ; }
public void set base ( coordinate base ) { dim . set base ( base ) ; }
public object poll ( ) { if ( be empty ( ) ) return null ; object min item = item . get ( 1 ) ; item . set ( 1 , item . get ( size ) ) ; size -= 1 ; reorder ( 1 ) ; return min item ; }
public static string get stack trace ( exception e ) { if ( e == null ) { return `` `` ; } byte array output stream baos = new byte array output stream ( ) ; print writer print writer = new print writer ( baos ) ; e . print stack trace ( print writer ) ; print writer . flush ( ) ; string stack trace = new string ( baos . to byte array ( ) ) ; print writer . close ( ) ; return stack trace ; }
public int check index of ( final string str , final int str start index , final string search ) { final int end index = str . length ( ) - search . length ( ) ; if ( end index > = str start index ) { for ( int i = str start index ; i < = end index ; i++ ) { if ( check region match ( str , i , search ) ) { return i ; } } } return -1 ; }
public boolean be cover ( ) { boolean have point in common = be true ( matrix [ location . interior ] [ location . interior ] ) || be true ( matrix [ location . interior ] [ location . boundary ] ) || be true ( matrix [ location . boundary ] [ location . interior ] ) || be true ( matrix [ location . boundary ] [ location . boundary ] ) ; return have point in common & & matrix [ location . exterior ] [ location . interior ] == dimension . false & & matrix [ location . exterior ] [ location . boundary ] == dimension . false ; }
public array list get item ( ) { return item ; }
public void expand to queue ( priority queue pri q , double min distance ) { boolean be comp1 = be composite ( boundable1 ) ; boolean be comp2 = be composite ( boundable2 ) ; / * * * heuristic : if both boundable be composite , * choose the one with large area to expand . * otherwise , simply expand whichever be composite . * / if ( be comp1 & & be comp2 ) { if ( area ( boundable1 ) > area ( boundable2 ) ) { expand ( boundable1 , boundable2 , pri q , min distance ) ; return ; } else { expand ( boundable2 , boundable1 , pri q , min distance ) ; return ; } } else if ( be comp1 ) { expand ( boundable1 , boundable2 , pri q , min distance ) ; return ; } else if ( be comp2 ) { expand ( boundable2 , boundable1 , pri q , min distance ) ; return ; } throw new illegal argument exception ( `` neither boundable be composite `` ) ; }
public vector3 d divide ( double d ) { return create ( x / d , y / d , z / d ) ; }
public boolean intersects ( coordinate p0 , coordinate p1 ) { if ( scale factor == 1 . 0 ) return intersects scale ( p0 , p1 ) ; copy scale ( p0 , p0 scale ) ; copy scale ( p1 , p1 scale ) ; return intersects scale ( p0 scale , p1 scale ) ; }
public double get z ( double x , double y ) { if ( ! be initialize ) init ( ) ; elevation cell cell = get cell ( x , y , false ) ; if ( cell == null ) return average z ; return cell . get z ( ) ; }
public boolean have edge ( int geom index ) { return geom [ geom index ] ! = null & & geom [ geom index ] . get dimension ( ) > 0 ; }
public void unmark duplicate edge from result area ( ) { for ( overlay edge edge : edge ) { if ( edge . be in result area both ( ) ) { edge . unmark from result area both ( ) ; } } }
public void add hole ( linear ring hole ) { if ( hole == null ) hole = new array list ( ) ; hole . add ( hole ) ; }
public list < coordinate > get non simple location ( ) { compute ( ) ; return non simple pt ; }
public void add ( final int value ) { ensure capacity ( size + 1 ) ; data [ size ] = value ; ++size ; }
public void configure ( size size ) { this . size range = size ; check range ( integral , size . min ( ) , size . max ( ) ) ; }
public static class < ? > to class ( class file ct , class loader loader , protection domain domain ) { try { byte [ ] b = ct . to bytecode ( ) ; java . lang . reflect . method method ; object [ ] args ; if ( domain == null ) { method = define class1 ; args = new object [ ] { ct . get name ( ) , b , 0 , b . length } ; } else { method = define class2 ; args = new object [ ] { ct . get name ( ) , b , 0 , b . length , domain } ; } return to class2 ( method , loader , args ) ; } catch ( runtime exception e ) { throw e ; } catch ( java . lang . reflect . invocation target exception e ) { throw new runtime exception ( e . get target exception ( ) ) ; } catch ( exception e ) { throw new runtime exception ( e ) ; } }
public static int swap integer ( final int value ) { return ( ( ( value > > 0 ) & 0xff ) < < 24 ) + ( ( ( value > > 8 ) & 0xff ) < < 16 ) + ( ( ( value > > 16 ) & 0xff ) < < 8 ) + ( ( ( value > > 24 ) & 0xff ) < < 0 ) ; }
public synchronize void add interval histogram to ( histogram to histogram ) { try { record phaser . reader lock ( ) ; update histogram ( ) ; to histogram . add ( inactive raw data histogram ) ; to histogram . add ( inactive pause correction histogram ) ; } finally { record phaser . reader unlock ( ) ; } }
public void shutdown ( ) { stop = true ; pause detector thread . interrupt ( ) ; }
public static void create hard link mult ( file parent dir , string [ ] file base name , file link dir ) throw i o exception { if ( parent dir == null ) { throw new i o exception ( `` invalid argument to create hard link mult : parent directory be null `` ) ; } if ( link dir == null ) { throw new i o exception ( `` invalid argument to create hard link mult : link directory be null `` ) ; } if ( file base name == null ) { throw new i o exception ( `` invalid argument to create hard link mult : `` + `` filename list can be empty but not null `` ) ; } if ( ! link dir . exists ( ) ) { throw new file not find exception ( link dir + `` not find . `` ) ; } for ( string name : file base names ) { create link ( link dir . to path ( ) . resolve ( name ) , parent dir . to path ( ) . resolve ( name ) ) ; } }
public static identity reader create ( scope scope , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` identity reader v2 `` , scope . make op name ( `` identity reader `` ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . container ! = null ) { op builder . set attr ( `` container `` , opts . container ) ; } if ( opts . share name ! = null ) { op builder . set attr ( `` shared_name `` , opts . share name ) ; } } } return new identity reader ( op builder . build ( ) ) ; }
public static accumulator set global step create ( scope scope , operand < string > handle , operand < long > new global step ) { operation builder op builder = scope . graph ( ) . op builder ( `` accumulator set global step `` , scope . make op name ( `` accumulator set global step `` ) ) ; op builder . add input ( handle . a output ( ) ) ; op builder . add input ( new global step . a output ( ) ) ; return new accumulator set global step ( op builder . build ( ) ) ; }
public static uniform candidate sampler create ( scope scope , operand < long > true class , long num true , long num sample , boolean unique , long range max , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` uniform candidate sampler `` , scope . make op name ( `` uniform candidate sampler `` ) ) ; op builder . add input ( true class . a output ( ) ) ; op builder . set attr ( `` num_true `` , num true ) ; op builder . set attr ( `` num_sampled `` , num sample ) ; op builder . set attr ( `` unique `` , unique ) ; op builder . set attr ( `` range_max `` , range max ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . seed ! = null ) { op builder . set attr ( `` seed `` , opts . seed ) ; } if ( opts . seed2 ! = null ) { op builder . set attr ( `` seed2 `` , opts . seed2 ) ; } } } return new uniform candidate sampler ( op builder . build ( ) ) ; }
public output < float > sample expect count ( ) { return sample expect count ; }
public static < t extend number > reduce any create ( scope scope , operand < boolean > input , operand < t > axis , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` any `` , scope . make op name ( `` reduce any `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . add input ( axis . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . keep dims ! = null ) { op builder . set attr ( `` keep_dims `` , opts . keep dims ) ; } } } return new reduce any ( op builder . build ( ) ) ; }
public output < t > output ( ) { return output ; }
public static make iterator create ( scope scope , operand < ? > dataset , operand < ? > iterator ) { operation builder op builder = scope . graph ( ) . op builder ( `` make iterator `` , scope . make op name ( `` make iterator `` ) ) ; op builder . add input ( dataset . a output ( ) ) ; op builder . add input ( iterator . a output ( ) ) ; return new make iterator ( op builder . build ( ) ) ; }
public static audio spectrogram create ( scope scope , operand < float > input , long window size , long stride , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` audio spectrogram `` , scope . make op name ( `` audio spectrogram `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . set attr ( `` window_size `` , window size ) ; op builder . set attr ( `` stride `` , stride ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . magnitude square ! = null ) { op builder . set attr ( `` magnitude_squared `` , opts . magnitude square ) ; } } } return new audio spectrogram ( op builder . build ( ) ) ; }
public output < t > output ( ) { return output ; }
public static < t > size < integer > create ( scope scope , operand < t > input ) { return create ( scope , input , integer . class ) ; }
public static < t > batch matrix diag < t > create ( scope scope , operand < t > diagonal ) { operation builder op builder = scope . graph ( ) . op builder ( `` batch matrix diag `` , scope . make op name ( `` batch matrix diag `` ) ) ; op builder . add input ( diagonal . a output ( ) ) ; return new batch matrix diag < t > ( op builder . build ( ) ) ; }
public static < t extend number > batch matrix triangular solve < t > create ( scope scope , operand < t > matrix , operand < t > rh , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` batch matrix triangular solve `` , scope . make op name ( `` batch matrix triangular solve `` ) ) ; op builder . add input ( matrix . a output ( ) ) ; op builder . add input ( rh . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . low ! = null ) { op builder . set attr ( `` low `` , opts . low ) ; } if ( opts . adjoint ! = null ) { op builder . set attr ( `` adjoint `` , opts . adjoint ) ; } } } return new batch matrix triangular solve < t > ( op builder . build ( ) ) ; }
public output < t > output ( ) { return output ; }
public list < output < float > > right node contribs list ( ) { return right node contribs list ; }
public output < float > logits ( ) { return logits ; }
public list < output < integer > > bucket ( ) { return bucket ; }
public static < t extend number > batch cholesky grad < t > create ( scope scope , operand < t > l , operand < t > grad ) { operation builder op builder = scope . graph ( ) . op builder ( `` batch cholesky grad `` , scope . make op name ( `` batch cholesky grad `` ) ) ; op builder . add input ( l . a output ( ) ) ; op builder . add input ( grad . a output ( ) ) ; return new batch cholesky grad < t > ( op builder . build ( ) ) ; }
public static < t extend number > collective bcast recv < t > create ( scope scope , class < t > t , long group size , long group key , long instance key , shape shape ) { operation builder op builder = scope . graph ( ) . op builder ( `` collective bcast recv `` , scope . make op name ( `` collective bcast recv `` ) ) ; op builder . set attr ( `` t `` , data type . from class ( t ) ) ; op builder . set attr ( `` group_size `` , group size ) ; op builder . set attr ( `` group_key `` , group key ) ; op builder . set attr ( `` instance_key `` , instance key ) ; op builder . set attr ( `` shape `` , shape ) ; return new collective bcast recv < t > ( op builder . build ( ) ) ; }
public static < t extend number > conv3 d backprop filter < t > create ( scope scope , operand < t > input , operand < t > filter , operand < t > out backprop , list < long > stride , string padding , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` conv3 d backprop filter `` , scope . make op name ( `` conv3 d backprop filter `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . add input ( filter . a output ( ) ) ; op builder . add input ( out backprop . a output ( ) ) ; long [ ] stride array = new long [ stride . size ( ) ] ; for ( int i = 0 ; i < stride array . length ; ++i ) { strides array [ i ] = stride . get ( i ) ; } op builder . set attr ( `` stride `` , stride array ) ; op builder . set attr ( `` pad `` , pad ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . dilation ! = null ) { long [ ] dilation array = new long [ opts . dilation . size ( ) ] ; for ( int i = 0 ; i < dilation array . length ; ++i ) { dilation array [ i ] = opts . dilation . get ( i ) ; } op builder . set attr ( `` dilation `` , dilation array ) ; } } } return new conv3 d backprop filter < t > ( op builder . build ( ) ) ; }
public static < t extend number > relu6 < t > create ( scope scope , operand < t > feature ) { operation builder op builder = scope . graph ( ) . op builder ( `` relu6 `` , scope . make op name ( `` relu6 `` ) ) ; op builder . add input ( feature . a output ( ) ) ; return new relu6 < t > ( op builder . build ( ) ) ; }
public static < t extend number > crop and resize create ( scope scope , operand < t > image , operand < float > box , operand < integer > box ind , operand < integer > crop size , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` crop and resize `` , scope . make op name ( `` crop and resize `` ) ) ; op builder . add input ( image . a output ( ) ) ; op builder . add input ( box . a output ( ) ) ; op builder . add input ( box ind . a output ( ) ) ; op builder . add input ( crop size . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . method ! = null ) { op builder . set attr ( `` method `` , opts . method ) ; } if ( opts . extrapolation value ! = null ) { op builder . set attr ( `` extrapolation_value `` , opts . extrapolation value ) ; } } } return new crop and resize ( op builder . build ( ) ) ; }
public output < float > crop ( ) { return crop ; }
public output < float > crop ( ) { return crop ; }
public static c t c greedy decoder create ( scope scope , operand < float > input , operand < integer > sequence length , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` c t c greedy decoder `` , scope . make op name ( `` c t c greedy decoder `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . add input ( sequence length . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . merge repeat ! = null ) { op builder . set attr ( `` merge_repeated `` , opts . merge repeat ) ; } } } return new c t c greedy decoder ( op builder . build ( ) ) ; }
public static < t extend number > l r n grad < t > create ( scope scope , operand < t > input grad , operand < t > input image , operand < t > output image , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` l r n grad `` , scope . make op name ( `` l r n grad `` ) ) ; op builder . add input ( input grad . a output ( ) ) ; op builder . add input ( input image . a output ( ) ) ; op builder . add input ( output image . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . depth radius ! = null ) { op builder . set attr ( `` depth_radius `` , opts . depth radius ) ; } if ( opts . bias ! = null ) { op builder . set attr ( `` bias `` , opts . bias ) ; } if ( opts . alpha ! = null ) { op builder . set attr ( `` alpha `` , opts . alpha ) ; } if ( opts . beta ! = null ) { op builder . set attr ( `` beta `` , opts . beta ) ; } } } return new l r n grad < t > ( op builder . build ( ) ) ; }
public static < t extend number > l r n grad < t > create ( scope scope , operand < t > input grad , operand < t > input image , operand < t > output image , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` l r n grad `` , scope . make op name ( `` l r n grad `` ) ) ; op builder . add input ( input grad . a output ( ) ) ; op builder . add input ( input image . a output ( ) ) ; op builder . add input ( output image . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . depth radius ! = null ) { op builder . set attr ( `` depth_radius `` , opts . depth radius ) ; } if ( opts . bias ! = null ) { op builder . set attr ( `` bias `` , opts . bias ) ; } if ( opts . alpha ! = null ) { op builder . set attr ( `` alpha `` , opts . alpha ) ; } if ( opts . beta ! = null ) { op builder . set attr ( `` beta `` , opts . beta ) ; } } } return new l r n grad < t > ( op builder . build ( ) ) ; }
public static < t extend number > data format vec permute < t > create ( scope scope , operand < t > x , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` data format vec permute `` , scope . make op name ( `` data format vec permute `` ) ) ; op builder . add input ( x . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . src format ! = null ) { op builder . set attr ( `` src_format `` , opts . src format ) ; } if ( opts . dst format ! = null ) { op builder . set attr ( `` dst_format `` , opts . dst format ) ; } } } return new data format vec permute < t > ( op builder . build ( ) ) ; }
public static decode bmp create ( scope scope , operand < string > content , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` decode bmp `` , scope . make op name ( `` decode bmp `` ) ) ; op builder . add input ( content . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . channel ! = null ) { op builder . set attr ( `` channel `` , opts . channel ) ; } } } return new decode bmp ( op builder . build ( ) ) ; }
public static decode j s o n example create ( scope scope , operand < string > json example ) { operation builder op builder = scope . graph ( ) . op builder ( `` decode j s o n example `` , scope . make op name ( `` decode j s o n example `` ) ) ; op builder . add input ( json example . a output ( ) ) ; return new decode j s o n example ( op builder . build ( ) ) ; }
public list < output < ? > > value ( ) { return value ; }
public output < integer > sample rate ( ) { return sample rate ; }
public output < t > output ( ) { return output ; }
public static tensor forest tree resource handle op create ( scope scope , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` tensor forest tree resource handle op `` , scope . make op name ( `` tensor forest tree resource handle op `` ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . container ! = null ) { op builder . set attr ( `` container `` , opts . container ) ; } if ( opts . share name ! = null ) { op builder . set attr ( `` shared_name `` , opts . share name ) ; } } } return new tensor forest tree resource handle op ( op builder . build ( ) ) ; }
public static < t > div < t > create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` div `` , scope . make op name ( `` div `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new div < t > ( op builder . build ( ) ) ; }
public output < float > bboxes ( ) { return bboxes ; }
public output < t > backprops ( ) { return backprops ; }
public static < t extend number > encode png create ( scope scope , operand < t > image , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` encode png `` , scope . make op name ( `` encode png `` ) ) ; op builder . add input ( image . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . compression ! = null ) { op builder . set attr ( `` compression `` , opts . compression ) ; } } } return new encode png ( op builder . build ( ) ) ; }
public static decode jpeg create ( scope scope , operand < string > content , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` decode jpeg `` , scope . make op name ( `` decode jpeg `` ) ) ; op builder . add input ( content . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . channel ! = null ) { op builder . set attr ( `` channel `` , opts . channel ) ; } if ( opts . ratio ! = null ) { op builder . set attr ( `` ratio `` , opts . ratio ) ; } if ( opts . fancy upscaling ! = null ) { op builder . set attr ( `` fancy_upscaling `` , opts . fancy upscaling ) ; } if ( opts . try recover truncate ! = null ) { op builder . set attr ( `` try_recover_truncated `` , opts . try recover truncate ) ; } if ( opts . acceptable fraction ! = null ) { op builder . set attr ( `` acceptable_fraction `` , opts . acceptable fraction ) ; } if ( opts . dct method ! = null ) { op builder . set attr ( `` dct_method `` , opts . dct method ) ; } } } return new decode jpeg ( op builder . build ( ) ) ; }
public output < t > y ( ) { return y ; }
public static experimental dataset cardinality create ( scope scope , operand < ? > input dataset ) { operation builder op builder = scope . graph ( ) . op builder ( `` experimental dataset cardinality `` , scope . make op name ( `` experimental dataset cardinality `` ) ) ; op builder . add input ( input dataset . a output ( ) ) ; return new experimental dataset cardinality ( op builder . build ( ) ) ; }
public static experimental unique dataset create ( scope scope , operand < ? > input dataset , list < class < ? > > output type , list < shape > output shape ) { operation builder op builder = scope . graph ( ) . op builder ( `` experimental unique dataset `` , scope . make op name ( `` experimental unique dataset `` ) ) ; op builder . add input ( input dataset . a output ( ) ) ; data type [ ] output type array = new data type [ output type . size ( ) ] ; for ( int i = 0 ; i < output type array . length ; ++i ) { output type array [ i ] = data type . from class ( output type . get ( i ) ) ; } op builder . set attr ( `` output_types `` , output type array ) ; shape [ ] output shape array = new shape [ output shape . size ( ) ] ; for ( int i = 0 ; i < output shape array . length ; ++i ) { output shape array [ i ] = output shape . get ( i ) ; } op builder . set attr ( `` output_shapes `` , output shape array ) ; return new experimental unique dataset ( op builder . build ( ) ) ; }
public static extract jpeg shape < integer > create ( scope scope , operand < string > content ) { return create ( scope , content , integer . class ) ; }
public output < float > backprop wrt min ( ) { return backprop wrt min ; }
public output < float > backprop wrt max ( ) { return backprop wrt max ; }
public static close summary writer create ( scope scope , operand < ? > writer ) { operation builder op builder = scope . graph ( ) . op builder ( `` close summary writer `` , scope . make op name ( `` close summary writer `` ) ) ; op builder . add input ( writer . a output ( ) ) ; return new close summary writer ( op builder . build ( ) ) ; }
public output < t > reserve space3 ( ) { return reserve space3 ; }
public output < t > value ( ) { return value ; }
public static < t extend number > multinomial < long > create ( scope scope , operand < t > logits , operand < integer > num sample , option . . . option ) { return create ( scope , logits , num sample , long . class , option ) ; }
public static make iterator create ( scope scope , operand < ? > dataset , operand < ? > iterator ) { operation builder op builder = scope . graph ( ) . op builder ( `` make iterator `` , scope . make op name ( `` make iterator `` ) ) ; op builder . add input ( dataset . a output ( ) ) ; op builder . add input ( iterator . a output ( ) ) ; return new make iterator ( op builder . build ( ) ) ; }
public static make iterator create ( scope scope , operand < ? > dataset , operand < ? > iterator ) { operation builder op builder = scope . graph ( ) . op builder ( `` make iterator `` , scope . make op name ( `` make iterator `` ) ) ; op builder . add input ( dataset . a output ( ) ) ; op builder . add input ( iterator . a output ( ) ) ; return new make iterator ( op builder . build ( ) ) ; }
public static boost tree get ensemble state create ( scope scope , operand < ? > tree ensemble handle ) { operation builder op builder = scope . graph ( ) . op builder ( `` boost tree get ensemble state `` , scope . make op name ( `` boost tree get ensemble state `` ) ) ; op builder . add input ( tree ensemble handle . a output ( ) ) ; return new boost tree get ensemble state ( op builder . build ( ) ) ; }
public static iterator from string handle v2 create ( scope scope , operand < string > string handle , list < class < ? > > output type , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` iterator from string handle v2 `` , scope . make op name ( `` iterator from string handle v2 `` ) ) ; op builder . add input ( string handle . a output ( ) ) ; data type [ ] output type array = new data type [ output type . size ( ) ] ; for ( int i = 0 ; i < output type array . length ; ++i ) { output type array [ i ] = data type . from class ( output type . get ( i ) ) ; } op builder . set attr ( `` output_types `` , output type array ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . output shape ! = null ) { shape [ ] output shape array = new shape [ opts . output shape . size ( ) ] ; for ( int i = 0 ; i < output shape array . length ; ++i ) { output shape array [ i ] = opts . output shape . get ( i ) ; } op builder . set attr ( `` output_shapes `` , output shape array ) ; } } } return new iterator from string handle v2 ( op builder . build ( ) ) ; }
public static iterator get next sync create ( scope scope , operand < ? > iterator , list < class < ? > > output type , list < shape > output shape ) { operation builder op builder = scope . graph ( ) . op builder ( `` iterator get next sync `` , scope . make op name ( `` iterator get next sync `` ) ) ; op builder . add input ( iterator . a output ( ) ) ; data type [ ] output type array = new data type [ output type . size ( ) ] ; for ( int i = 0 ; i < output type array . length ; ++i ) { output type array [ i ] = data type . from class ( output type . get ( i ) ) ; } op builder . set attr ( `` output_types `` , output type array ) ; shape [ ] output shape array = new shape [ output shape . size ( ) ] ; for ( int i = 0 ; i < output shape array . length ; ++i ) { output shape array [ i ] = output shape . get ( i ) ; } op builder . set attr ( `` output_shapes `` , output shape array ) ; return new iterator get next sync ( op builder . build ( ) ) ; }
public static iterator create ( scope scope , string share name , string container , list < class < ? > > output type , list < shape > output shape ) { operation builder op builder = scope . graph ( ) . op builder ( `` iterator `` , scope . make op name ( `` iterator `` ) ) ; op builder . set attr ( `` shared_name `` , share name ) ; op builder . set attr ( `` container `` , container ) ; data type [ ] output type array = new data type [ output type . size ( ) ] ; for ( int i = 0 ; i < output type array . length ; ++i ) { output type array [ i ] = data type . from class ( output type . get ( i ) ) ; } op builder . set attr ( `` output_types `` , output type array ) ; shape [ ] output shape array = new shape [ output shape . size ( ) ] ; for ( int i = 0 ; i < output shape array . length ; ++i ) { output shape array [ i ] = output shape . get ( i ) ; } op builder . set attr ( `` output_shapes `` , output shape array ) ; return new iterator ( op builder . build ( ) ) ; }
public output < t > backprops ( ) { return backprops ; }
public static < t > equal create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` equal `` , scope . make op name ( `` equal `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new equal ( op builder . build ( ) ) ; }
public static < t > batch matrix determinant < t > create ( scope scope , operand < t > input ) { operation builder op builder = scope . graph ( ) . op builder ( `` batch matrix determinant `` , scope . make op name ( `` batch matrix determinant `` ) ) ; op builder . add input ( input . a output ( ) ) ; return new batch matrix determinant < t > ( op builder . build ( ) ) ; }
public output < u > output ( ) { return output ; }
public static stage clear create ( scope scope , list < class < ? > > dtypes , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` stage clear `` , scope . make op name ( `` stage clear `` ) ) ; data type [ ] dtypes array = new data type [ dtypes . size ( ) ] ; for ( int i = 0 ; i < dtypes array . length ; ++i ) { dtypes array [ i ] = data type . from class ( dtypes . get ( i ) ) ; } op builder . set attr ( `` dtypes `` , dtypes array ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . capacity ! = null ) { op builder . set attr ( `` capacity `` , opts . capacity ) ; } if ( opts . memory limit ! = null ) { op builder . set attr ( `` memory_limit `` , opts . memory limit ) ; } if ( opts . container ! = null ) { op builder . set attr ( `` container `` , opts . container ) ; } if ( opts . share name ! = null ) { op builder . set attr ( `` shared_name `` , opts . share name ) ; } } } return new stage clear ( op builder . build ( ) ) ; }
public output < t > log ab determinant ( ) { return log abs determinant ; }
public output < t > output ( ) { return output ; }
public static < t extend number > sparse sparse maximum < t > create ( scope scope , operand < long > a index , operand < t > a value , operand < long > a shape , operand < long > b index , operand < t > b value , operand < long > b shape ) { operation builder op builder = scope . graph ( ) . op builder ( `` sparse sparse maximum `` , scope . make op name ( `` sparse sparse maximum `` ) ) ; op builder . add input ( a index . a output ( ) ) ; op builder . add input ( a value . a output ( ) ) ; op builder . add input ( a shape . a output ( ) ) ; op builder . add input ( b index . a output ( ) ) ; op builder . add input ( b value . a output ( ) ) ; op builder . add input ( b shape . a output ( ) ) ; return new sparse sparse maximum < t > ( op builder . build ( ) ) ; }
public output < t > output ( ) { return output ; }
public static < t > quantize v2 < t > create ( scope scope , operand < float > input , operand < float > min range , operand < float > max range , class < t > t , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` quantize v2 `` , scope . make op name ( `` quantize v2 `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . add input ( min range . a output ( ) ) ; op builder . add input ( max range . a output ( ) ) ; op builder . set attr ( `` t `` , data type . from class ( t ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . mode ! = null ) { op builder . set attr ( `` mode `` , opts . mode ) ; } if ( opts . round mode ! = null ) { op builder . set attr ( `` round_mode `` , opts . round mode ) ; } } } return new quantize v2 < t > ( op builder . build ( ) ) ; }
public static < t > negate < t > create ( scope scope , operand < t > x ) { operation builder op builder = scope . graph ( ) . op builder ( `` neg `` , scope . make op name ( `` negate `` ) ) ; op builder . add input ( x . a output ( ) ) ; return new negate < t > ( op builder . build ( ) ) ; }
public static experimental stats aggregator summary create ( scope scope , operand < ? > iterator ) { operation builder op builder = scope . graph ( ) . op builder ( `` experimental stats aggregator summary `` , scope . make op name ( `` experimental stats aggregator summary `` ) ) ; op builder . add input ( iterator . a output ( ) ) ; return new experimental stats aggregator summary ( op builder . build ( ) ) ; }
public static zip dataset create ( scope scope , iterable < operand < ? > > input datasets , list < class < ? > > output type , list < shape > output shape ) { operation builder op builder = scope . graph ( ) . op builder ( `` zip dataset `` , scope . make op name ( `` zip dataset `` ) ) ; op builder . add input list ( operands . a output ( input datasets ) ) ; data type [ ] output type array = new data type [ output type . size ( ) ] ; for ( int i = 0 ; i < output type array . length ; ++i ) { output type array [ i ] = data type . from class ( output type . get ( i ) ) ; } op builder . set attr ( `` output_types `` , output type array ) ; shape [ ] output shape array = new shape [ output shape . size ( ) ] ; for ( int i = 0 ; i < output shape array . length ; ++i ) { output shape array [ i ] = output shape . get ( i ) ; } op builder . set attr ( `` output_shapes `` , output shape array ) ; return new zip dataset ( op builder . build ( ) ) ; }
public static range dataset create ( scope scope , operand < long > start , operand < long > stop , operand < long > step , list < class < ? > > output type , list < shape > output shape ) { operation builder op builder = scope . graph ( ) . op builder ( `` range dataset `` , scope . make op name ( `` range dataset `` ) ) ; op builder . add input ( start . a output ( ) ) ; op builder . add input ( stop . a output ( ) ) ; op builder . add input ( step . a output ( ) ) ; data type [ ] output type array = new data type [ output type . size ( ) ] ; for ( int i = 0 ; i < output type array . length ; ++i ) { output type array [ i ] = data type . from class ( output type . get ( i ) ) ; } op builder . set attr ( `` output_types `` , output type array ) ; shape [ ] output shape array = new shape [ output shape . size ( ) ] ; for ( int i = 0 ; i < output shape array . length ; ++i ) { output shape array [ i ] = output shape . get ( i ) ; } op builder . set attr ( `` output_shapes `` , output shape array ) ; return new range dataset ( op builder . build ( ) ) ; }
public static < t extend number > non max suppression v2 create ( scope scope , operand < t > box , operand < t > score , operand < integer > max output size , operand < float > iou threshold ) { operation builder op builder = scope . graph ( ) . op builder ( `` non max suppression v2 `` , scope . make op name ( `` non max suppression v2 `` ) ) ; op builder . add input ( box . a output ( ) ) ; op builder . add input ( score . a output ( ) ) ; op builder . add input ( max output size . a output ( ) ) ; op builder . add input ( iou threshold . a output ( ) ) ; return new non max suppression v2 ( op builder . build ( ) ) ; }
public output < integer > select index ( ) { return select index ; }
public static < t extend number > non max suppression v3 create ( scope scope , operand < t > box , operand < t > score , operand < integer > max output size , operand < float > iou threshold , operand < float > score threshold ) { operation builder op builder = scope . graph ( ) . op builder ( `` non max suppression v3 `` , scope . make op name ( `` non max suppression v3 `` ) ) ; op builder . add input ( box . a output ( ) ) ; op builder . add input ( score . a output ( ) ) ; op builder . add input ( max output size . a output ( ) ) ; op builder . add input ( iou threshold . a output ( ) ) ; op builder . add input ( score threshold . a output ( ) ) ; return new non max suppression v3 ( op builder . build ( ) ) ; }
public static f i f o queue create ( scope scope , list < class < ? > > component type , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` f i f o queue v2 `` , scope . make op name ( `` f i f o queue `` ) ) ; data type [ ] component type array = new data type [ component type . size ( ) ] ; for ( int i = 0 ; i < component type array . length ; ++i ) { component type array [ i ] = data type . from class ( component type . get ( i ) ) ; } op builder . set attr ( `` component_types `` , component type array ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . shape ! = null ) { shape [ ] shape array = new shape [ opts . shape . size ( ) ] ; for ( int i = 0 ; i < shape array . length ; ++i ) { shapes array [ i ] = opts . shape . get ( i ) ; } op builder . set attr ( `` shape `` , shape array ) ; } if ( opts . capacity ! = null ) { op builder . set attr ( `` capacity `` , opts . capacity ) ; } if ( opts . container ! = null ) { op builder . set attr ( `` container `` , opts . container ) ; } if ( opts . share name ! = null ) { op builder . set attr ( `` shared_name `` , opts . share name ) ; } } } return new f i f o queue ( op builder . build ( ) ) ; }
public static window dataset create ( scope scope , operand < ? > input dataset , operand < long > size , operand < long > shift , operand < long > stride , operand < boolean > drop remainder , list < class < ? > > output type , list < shape > output shape ) { operation builder op builder = scope . graph ( ) . op builder ( `` window dataset `` , scope . make op name ( `` window dataset `` ) ) ; op builder . add input ( input dataset . a output ( ) ) ; op builder . add input ( size . a output ( ) ) ; op builder . add input ( shift . a output ( ) ) ; op builder . add input ( stride . a output ( ) ) ; op builder . add input ( drop remainder . a output ( ) ) ; data type [ ] output type array = new data type [ output type . size ( ) ] ; for ( int i = 0 ; i < output type array . length ; ++i ) { output type array [ i ] = data type . from class ( output type . get ( i ) ) ; } op builder . set attr ( `` output_types `` , output type array ) ; shape [ ] output shape array = new shape [ output shape . size ( ) ] ; for ( int i = 0 ; i < output shape array . length ; ++i ) { output shape array [ i ] = output shape . get ( i ) ; } op builder . set attr ( `` output_shapes `` , output shape array ) ; return new window dataset ( op builder . build ( ) ) ; }
public static f i f o queue create ( scope scope , list < class < ? > > component type , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` f i f o queue v2 `` , scope . make op name ( `` f i f o queue `` ) ) ; data type [ ] component type array = new data type [ component type . size ( ) ] ; for ( int i = 0 ; i < component type array . length ; ++i ) { component type array [ i ] = data type . from class ( component type . get ( i ) ) ; } op builder . set attr ( `` component_types `` , component type array ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . shape ! = null ) { shape [ ] shape array = new shape [ opts . shape . size ( ) ] ; for ( int i = 0 ; i < shape array . length ; ++i ) { shapes array [ i ] = opts . shape . get ( i ) ; } op builder . set attr ( `` shape `` , shape array ) ; } if ( opts . capacity ! = null ) { op builder . set attr ( `` capacity `` , opts . capacity ) ; } if ( opts . container ! = null ) { op builder . set attr ( `` container `` , opts . container ) ; } if ( opts . share name ! = null ) { op builder . set attr ( `` shared_name `` , opts . share name ) ; } } } return new f i f o queue ( op builder . build ( ) ) ; }
public static < t extend number > quantize and dequantize < t > create ( scope scope , operand < t > input , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` quantize and dequantize `` , scope . make op name ( `` quantize and dequantize `` ) ) ; op builder . add input ( input . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . sign input ! = null ) { op builder . set attr ( `` signed_input `` , opts . sign input ) ; } if ( opts . num bit ! = null ) { op builder . set attr ( `` num_bits `` , opts . num bit ) ; } if ( opts . range give ! = null ) { op builder . set attr ( `` range_given `` , opts . range give ) ; } if ( opts . input min ! = null ) { op builder . set attr ( `` input_min `` , opts . input min ) ; } if ( opts . input max ! = null ) { op builder . set attr ( `` input_max `` , opts . input max ) ; } } } return new quantize and dequantize < t > ( op builder . build ( ) ) ; }
public static < t > sparse concat < t > create ( scope scope , iterable < operand < long > > index , operand < t > value , iterable < operand < long > > shape , long concat dim ) { operation builder op builder = scope . graph ( ) . op builder ( `` sparse concat `` , scope . make op name ( `` sparse concat `` ) ) ; op builder . add input list ( operands . a output ( index ) ) ; op builder . add input ( value . a output ( ) ) ; op builder . add input list ( operands . a output ( shape ) ) ; op builder . set attr ( `` concat_dim `` , concat dim ) ; return new sparse concat < t > ( op builder . build ( ) ) ; }
public output < float > max activation ( ) { return max activation ; }
public output < float > output min ( ) { return output min ; }
public output < float > output min ( ) { return output min ; }
public static < t > random shuffle < t > create ( scope scope , operand < t > value , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` random shuffle `` , scope . make op name ( `` random shuffle `` ) ) ; op builder . add input ( value . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . seed ! = null ) { op builder . set attr ( `` seed `` , opts . seed ) ; } if ( opts . seed2 ! = null ) { op builder . set attr ( `` seed2 `` , opts . seed2 ) ; } } } return new random shuffle < t > ( op builder . build ( ) ) ; }
public static reader restore state create ( scope scope , operand < ? > reader handle , operand < string > state ) { operation builder op builder = scope . graph ( ) . op builder ( `` reader restore state v2 `` , scope . make op name ( `` reader restore state `` ) ) ; op builder . add input ( reader handle . a output ( ) ) ; op builder . add input ( state . a output ( ) ) ; return new reader restore state ( op builder . build ( ) ) ; }
public static write file create ( scope scope , operand < string > filename , operand < string > content ) { operation builder op builder = scope . graph ( ) . op builder ( `` write file `` , scope . make op name ( `` write file `` ) ) ; op builder . add input ( filename . a output ( ) ) ; op builder . add input ( content . a output ( ) ) ; return new write file ( op builder . build ( ) ) ; }
public static < t > conj < t > create ( scope scope , operand < t > input ) { operation builder op builder = scope . graph ( ) . op builder ( `` conj `` , scope . make op name ( `` conj `` ) ) ; op builder . add input ( input . a output ( ) ) ; return new conj < t > ( op builder . build ( ) ) ; }
public static < t > ref exit < t > create ( scope scope , operand < t > data ) { operation builder op builder = scope . graph ( ) . op builder ( `` ref exit `` , scope . make op name ( `` ref exit `` ) ) ; op builder . add input ( data . a output ( ) ) ; return new ref exit < t > ( op builder . build ( ) ) ; }
public static < t extend number > resize bicubic create ( scope scope , operand < t > image , operand < integer > size , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` resize bicubic `` , scope . make op name ( `` resize bicubic `` ) ) ; op builder . add input ( image . a output ( ) ) ; op builder . add input ( size . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . align corner ! = null ) { op builder . set attr ( `` align_corners `` , opts . align corner ) ; } } } return new resize bicubic ( op builder . build ( ) ) ; }
public output < t > output ( ) { return output ; }
public static < t > conj < t > create ( scope scope , operand < t > input ) { operation builder op builder = scope . graph ( ) . op builder ( `` conj `` , scope . make op name ( `` conj `` ) ) ; op builder . add input ( input . a output ( ) ) ; return new conj < t > ( op builder . build ( ) ) ; }
public output < float > bboxes ( ) { return bboxes ; }
public list < output < float > > summary ( ) { return summary ; }
public output < t > v ( ) { return v ; }
public static < t > rsqrt < t > create ( scope scope , operand < t > x ) { operation builder op builder = scope . graph ( ) . op builder ( `` rsqrt `` , scope . make op name ( `` rsqrt `` ) ) ; op builder . add input ( x . a output ( ) ) ; return new rsqrt < t > ( op builder . build ( ) ) ; }
public static < t > sqrt grad < t > create ( scope scope , operand < t > y , operand < t > dy ) { operation builder op builder = scope . graph ( ) . op builder ( `` sqrt grad `` , scope . make op name ( `` sqrt grad `` ) ) ; op builder . add input ( y . a output ( ) ) ; op builder . add input ( dy . a output ( ) ) ; return new sqrt grad < t > ( op builder . build ( ) ) ; }
public output < string > vocab word ( ) { return vocab word ; }
public static < t > accumulator apply gradient create ( scope scope , operand < string > handle , operand < long > local step , operand < t > gradient ) { operation builder op builder = scope . graph ( ) . op builder ( `` accumulator apply gradient `` , scope . make op name ( `` accumulator apply gradient `` ) ) ; op builder . add input ( handle . a output ( ) ) ; op builder . add input ( local step . a output ( ) ) ; op builder . add input ( gradient . a output ( ) ) ; return new accumulator apply gradient ( op builder . build ( ) ) ; }
public output < t > value ( ) { return value ; }
public static < t > sparse dense cwise add < t > create ( scope scope , operand < long > sp index , operand < t > sp value , operand < long > sp shape , operand < t > dense ) { operation builder op builder = scope . graph ( ) . op builder ( `` sparse dense cwise add `` , scope . make op name ( `` sparse dense cwise add `` ) ) ; op builder . add input ( sp index . a output ( ) ) ; op builder . add input ( sp value . a output ( ) ) ; op builder . add input ( sp shape . a output ( ) ) ; op builder . add input ( dense . a output ( ) ) ; return new sparse dense cwise add < t > ( op builder . build ( ) ) ; }
public static < t extend number > sparse reduce max sparse < t > create ( scope scope , operand < long > input index , operand < t > input value , operand < long > input shape , operand < integer > reduction ax , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` sparse reduce max sparse `` , scope . make op name ( `` sparse reduce max sparse `` ) ) ; op builder . add input ( input index . a output ( ) ) ; op builder . add input ( input value . a output ( ) ) ; op builder . add input ( input shape . a output ( ) ) ; op builder . add input ( reduction axes . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . keep dims ! = null ) { op builder . set attr ( `` keep_dims `` , opts . keep dims ) ; } } } return new sparse reduce max sparse < t > ( op builder . build ( ) ) ; }
public list < output < long > > output nest split ( ) { return output nest split ; }
public output < long > sparse index ( ) { return sparse index ; }
public static < t > placeholder < t > create ( scope scope , class < t > dtype , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` placeholder `` , scope . make op name ( `` placeholder `` ) ) ; op builder . set attr ( `` dtype `` , data type . from class ( dtype ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . shape ! = null ) { op builder . set attr ( `` shape `` , opts . shape ) ; } } } return new placeholder < t > ( op builder . build ( ) ) ; }
public output < t > value ( ) { return value ; }
public static < t > tensor array gather < t > create ( scope scope , operand < ? > handle , operand < integer > index , operand < float > flow in , class < t > dtype , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` tensor array gather v3 `` , scope . make op name ( `` tensor array gather `` ) ) ; op builder . add input ( handle . a output ( ) ) ; op builder . add input ( index . a output ( ) ) ; op builder . add input ( flow in . a output ( ) ) ; op builder . set attr ( `` dtype `` , data type . from class ( dtype ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . element shape ! = null ) { op builder . set attr ( `` element_shape `` , opts . element shape ) ; } } } return new tensor array gather < t > ( op builder . build ( ) ) ; }
public static < t > tensor summary v2 create ( scope scope , operand < string > tag , operand < t > tensor , operand < string > serialize summary metadata ) { operation builder op builder = scope . graph ( ) . op builder ( `` tensor summary v2 `` , scope . make op name ( `` tensor summary v2 `` ) ) ; op builder . add input ( tag . a output ( ) ) ; op builder . add input ( tensor . a output ( ) ) ; op builder . add input ( serialize summary metadata . a output ( ) ) ; return new tensor summary v2 ( op builder . build ( ) ) ; }
public static boost tree predict create ( scope scope , operand < ? > tree ensemble handle , iterable < operand < integer > > bucketized feature , long logits dimension ) { operation builder op builder = scope . graph ( ) . op builder ( `` boost tree predict `` , scope . make op name ( `` boost tree predict `` ) ) ; op builder . add input ( tree ensemble handle . a output ( ) ) ; op builder . add input list ( operands . a output ( bucketized feature ) ) ; op builder . set attr ( `` logits_dimension `` , logits dimension ) ; return new boost tree predict ( op builder . build ( ) ) ; }
public output < t > value ( ) { return value ; }
public static rpc create ( scope scope , operand < string > address , operand < string > method , operand < string > request , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` rpc `` , scope . make op name ( `` rpc `` ) ) ; op builder . add input ( address . a output ( ) ) ; op builder . add input ( method . a output ( ) ) ; op builder . add input ( request . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . protocol ! = null ) { op builder . set attr ( `` protocol `` , opts . protocol ) ; } if ( opts . fail fast ! = null ) { op builder . set attr ( `` fail_fast `` , opts . fail fast ) ; } if ( opts . timeout in m ! = null ) { op builder . set attr ( `` timeout_in_ms `` , opts . timeout in m ) ; } } } return new rpc ( op builder . build ( ) ) ; }
public output < integer > output ( ) { return output ; }
public static wrap dataset variant create ( scope scope , operand < ? > input handle ) { operation builder op builder = scope . graph ( ) . op builder ( `` wrap dataset variant `` , scope . make op name ( `` wrap dataset variant `` ) ) ; op builder . add input ( input handle . a output ( ) ) ; return new wrap dataset variant ( op builder . build ( ) ) ; }
public string type ( ) { graph . reference r = graph . ref ( ) ; try { return type ( unsafe native handle ) ; } finally { r . close ( ) ; } }
public synchronize void start ( ) { start ( native handle ) ; }
public int num byte ( ) { return buffer ( ) . remain ( ) ; }
public log builder at debug ( ) { return at level ( level . debug ) ; }
public void set error ( string annotation method name , string message , int index ) { annotation value v = value . get ( annotation method name ) ; if ( v == null ) return ; v . set error ( message , index ) ; }
public l top ( ) { return top ; }
public list < file > find file from ( file dir , filename filter filter , boolean recurse ) { this . filter = filter ; list < file > file = new array list < > ( ) ; scan directory ( dir , file , recurse ) ; return file ; }
public void rebuild ( ) { map < n , l > old node = new identity hash map < n , l > ( ) ; gather and remove child ( old node ) ; l new node = ast . build tree ( get ( ) , kind ) ; ast . set change ( ) ; ast . replace new with exist old ( old node , new node ) ; }
public static < s > service loader < s > load ( class < s > service ) { return load ( service , thread . current thread ( ) . get context class loader ( ) ) ; }
protect < t > list < string > identify static service provider ( class < t > iface ) { list < string > name = new array list < string > ( ) ; if ( loader ! = null ) { string service name = iface . get name ( ) ; enumeration < url > resource = find service resource ( `` m e t a- i n f/services/ `` + service name ) ; for ( url resource : collection . list ( resource ) ) { try { collect service class name ( resource , names ) ; } catch ( i o exception e ) { handler . handle load error ( service name , e ) ; } } } return name ; }
public static string get min jdk version ( ) { return min_jdk_version ; }
public void print doc comment ( j c tree tree ) throw i o exception { string dc = get javadoc for ( tree ) ; if ( dc == null ) return ; print ( `` / * * `` ) ; println ( ) ; int po = 0 ; int endpos = line end po ( dc , po ) ; boolean at start = true ; while ( pos < dc . length ( ) ) { string line = dc . substring ( po , endpos ) ; if ( line . trim ( ) . be empty ( ) & & at start ) { at start = false ; continue ; } at start = false ; align ( ) ; print ( `` * `` ) ; if ( pos < dc . length ( ) & & dc . char at ( po ) > ' ' ) print ( `` `` ) ; print ( dc . substring ( po , endpos ) ) ; println ( ) ; po = endpos + 1 ; endpos = line end po ( dc , po ) ; } align ( ) ; print ( `` * / `` ) ; println ( ) ; align ( ) ; }
public boolean be class nillable ( jsonb annotate element < class < ? > > clazz element ) { final jsonb nillable jsonb nillable = find annotation ( clazz element . get annotation ( ) , jsonb nillable . class ) ; if ( jsonb nillable ! = null ) { return jsonb nillable . value ( ) ; } class < ? > clazz = clazz element . get element ( ) ; if ( clazz == optional . class || clazz == optional double . class || clazz == optional int . class || clazz == optional long . class ) { return true ; } return jsonb context . get config property ( ) . get config nullable ( ) ; }
public static handler library load ( messager messager ) { handler library library = new handler library ( messager ) ; try { load annotation handler ( library ) ; load visitor handler ( library ) ; } catch ( i o exception e ) { system . err . println ( `` lombok be n't run due to misconfigured spi file : `` + e ) ; } library . calculate priority ( ) ; return library ; }
public location get instance location ( ) { return instance location ; }
public int stem suffix ( char s [ ] , int len ) { for ( int i = 0 ; i < suffix . length ; i++ ) if ( end with check length ( s , len , suffixes [ i ] ) ) len = delete n ( s , len - suffix [ i ] . length , len , suffixes [ i ] . length ) ; return len ; }
public int alloc ( int size ) { int index = n ; int len = array . length ; if ( n + size > = len ) { byte [ ] aux = new byte [ len + block size ] ; system . arraycopy ( array , 0 , aux , 0 , len ) ; array = aux ; } n += size ; return index ; }
public v get ( char [ ] text , int off , int len ) { return value [ get slot ( text , off , len ) ] ; }
public list < hunspell word > lookup word ( char word [ ] , int offset , int length ) { return word . get ( word , offset , length ) ; }
public char [ ] get append flag ( ) { return append flag ; }
public final token stream token stream ( final string field name , final string text ) throw i o exception { token stream component component = reuse strategy . get reusable component ( this , field name ) ; @ suppress warning ( `` resource `` ) final reusable string reader str reader = ( component == null || component . reusable string reader == null ) ? new reusable string reader ( ) : component . reusable string reader ; str reader . set value ( text ) ; final reader r = init reader ( field name , str reader ) ; if ( component == null ) { component = create component ( field name , r ) ; reuse strategy . set reusable component ( this , field name , component ) ; } else { component . set reader ( r ) ; } component . reusable string reader = str reader ; return component . get token stream ( ) ; }
public void set condition ( string condition , string pattern ) { this . condition = condition ; this . condition pattern = pattern . compile ( pattern ) ; }
public static void reverse ( version match version , final char [ ] buffer , final int len ) { reverse ( match version , buffer , 0 , len ) ; }
public void set min shingle size ( int min shingle size ) { if ( min shingle size < 2 ) { throw new illegal argument exception ( `` min shingle size must be > = 2 `` ) ; } if ( min shingle size > max shingle size ) { throw new illegal argument exception ( `` min shingle size must be < = max shingle size `` ) ; } this . min shingle size = min shingle size ; gram size = new circular sequence ( ) ; }
public static boolean equal ( byte [ ] a1 , int a1 offset , byte [ ] a2 , int a2 offset , int length ) { if ( a1 . length < a1 offset + length || a2 . length < a2 offset + length ) return false ; while ( length -- > 0 ) if ( a1 [ a1 offset++ ] ! = a2 [ a2 offset++ ] ) return false ; return true ; }
public version get version ( ) { return version ; }
public tokenizer factory get tokenizer factory ( ) { return tokenizer ; }
public list < token filter factory > get token filter factory ( ) { return collection . unmodifiable list ( arrays . a list ( token filter ) ) ; }
public void set enable position increment ( boolean enable ) { check position increment ( version , enable ) ; this . enable position increment = enable ; }
public void close ( ) { if ( stored value ! = null ) { store value . close ( ) ; store value = null ; } }
protect void add value to result ( list < io . micronaut . core . annotation . annotation value > result , io . micronaut . core . annotation . annotation value value ) { result . add ( value ) ; }
public token next ( ) throw i o exception { while ( pointer < token . size ( ) ) { token token = token . get ( pointer ) ; pointer++ ; if ( token == null ) continue ; return token ; } return null ; }
protect int read header ( index input input ) throw i o exception { int version = codec util . check header ( input , block tree term writer . terms_codec_name , block tree term writer . terms_version_start , block tree term writer . terms_version_current ) ; if ( version < block tree term writer . terms_version_append_only ) { dir offset = input . read long ( ) ; } return version ; }
public void write ( long b off , byte [ ] buf , int index , int length ) { bound check ( b off , length * 1l ) ; super . write ( b off , buf , index , length ) ; }
public static int check from index size ( int from index , int size , int length ) { int end = from index + size ; if ( from index < 0 || from index > end || end > length ) { throw new index out of bound exception ( `` range [ `` + from index + `` , `` + from index + `` + `` + size + `` ) out-of-bounds for length `` + length ) ; } return from index ; }
public long get prox pointer ( ) { return last prox pointer ; }
public void set all ( ) { array . fill ( bit , ( byte ) 0xff ) ; clear unused bit ( ) ; count = size ; }
public void set all ( ) { array . fill ( bit , ( byte ) 0xff ) ; clear unused bit ( ) ; count = size ; }
public enum with slice [ ] get sub ( ) { return sub ; }
public void set field ( field info field info ) { this . field info = field info ; index option = field info . get index option ( ) ; write freqs = index option . compare to ( index option . docs_and_freqs ) > = 0 ; write position = index option . compare to ( index option . docs_and_freqs_and_positions ) > = 0 ; write offset = index option . compare to ( index option . docs_and_freqs_and_positions_and_offsets ) > = 0 ; write payload = field info . have payload ( ) ; if ( write freqs == false ) { enum flag = 0 ; } else if ( write position == false ) { enum flag = posting enum . freqs ; } else if ( write offset == false ) { if ( write payload ) { enum flag = posting enum . payload ; } else { enum flag = posting enum . position ; } } else { if ( write payload ) { enum flag = posting enum . payload | posting enum . offset ; } else { enum flag = posting enum . offset ; } } }
public final expression optimize ( expression visitor visitor , item type context item type ) { return this ; }
public static string decompress string ( byte [ ] value ) throw data format exception { return decompress string ( value , 0 , value . length ) ; }
public static byte [ ] decompress ( byte [ ] value ) throw data format exception { return decompress ( value , 0 , value . length ) ; }
public void set store term vector offset ( boolean value ) { check if frozen ( ) ; this . store term vector offset = value ; }
public void set indexed ( boolean value ) { check if frozen ( ) ; this . indexed = value ; }
public final list < indexable field > get field ( ) { return field ; }
public int get precision step ( ) { return precision step ; }
protect synchronized merge thread get merge thread ( index writer writer , merge policy . one merge merge ) throw i o exception { final merge thread thread = new merge thread ( writer , merge ) ; thread . set thread priority ( merge thread priority ) ; thread . set daemon ( true ) ; thread . set name ( `` lucene merge thread # `` + merge thread count++ ) ; return thread ; }
public static directory reader open ( final directory directory , int term info index divisor ) throw i o exception { return standard directory reader . open ( directory , null , term info index divisor ) ; }
public static directory reader open if change ( directory reader old reader ) throw i o exception { final directory reader new reader = old reader . do open if change ( ) ; assert new reader ! = old reader ; return new reader ; }
public void delete document ( term . . . term ) throw i o exception { ensure open ( ) ; try { if ( doc writer . delete term ( term ) ) { process event ( true , false ) ; } } catch ( out of memory error oom ) { handle o o m ( oom , `` delete document ( term . . ) '' ) ; } }
public void set omits norm ( ) { if ( index option == index option . none ) { throw new illegal state exception ( `` can not omit norm : this field be not indexed `` ) ; } omit norm = true ; this . check consistency ( ) ; }
public boolean have doc value ( ) { return doc value type ! = null ; }
public boolean have vector ( ) { return have vector ; }
public int get length ( ) { return length ; }
public void set boost ( float boost ) { this . boost = boost ; }
public long update doc value ( term term , field . . . update ) throw i o exception { ensure open ( ) ; doc value update [ ] dv update = build doc value update ( term , update ) ; try { return maybe process event ( doc writer . update doc value ( dv update ) ) ; } catch ( virtual machine error tragedy ) { tragic event ( tragedy , `` update doc value `` ) ; throw tragedy ; } }
public synchronize boolean have deletion ( ) { ensure open ( ) ; if ( buffer update stream . any ( ) ) { return true ; } if ( doc writer . any deletion ( ) ) { return true ; } if ( reader pool . any pending deletes ( ) ) { return true ; } for ( final segment commit info info : segment info ) { if ( info . have deletion ( ) ) { return true ; } } return false ; }
public final void prepare commit ( ) throw i o exception { ensure open ( ) ; prepare commit internal ( ) ; }
public final long get flush byte ( ) { ensure open ( ) ; return doc writer . get flushing byte ( ) ; }
public int get max thread state ( ) { try { return ( ( thread affinity document writer thread pool ) indexer thread pool ) . get max thread state ( ) ; } catch ( class cast exception cce ) { throw new illegal state exception ( cce ) ; } }
public index writer config set index commit ( index commit commit ) { this . commit = commit ; return this ; }
public void set max merge m b for force merge ( double mb ) { max merge size for force merge = ( long ) ( mb * 1024 * 1024 ) ; }
public static numeric doc value get numeric value ( final index reader r , final string field ) throw i o exception { final list < atomic reader context > leave = r . leaf ( ) ; final int size = leave . size ( ) ; if ( size == 0 ) { return null ; } else if ( size == 1 ) { return leave . get ( 0 ) . reader ( ) . get numeric doc value ( field ) ; } boolean any real = false ; final numeric doc value [ ] value = new numeric doc value [ size ] ; final int [ ] start = new int [ size+1 ] ; for ( int i = 0 ; i < size ; i++ ) { atomic reader context context = leave . get ( i ) ; numeric doc value v = context . reader ( ) . get numeric doc value ( field ) ; if ( v == null ) { v = numeric doc value . empty ; } else { any real = true ; } value [ i ] = v ; start [ i ] = context . doc base ; } start [ size ] = r . max doc ( ) ; if ( ! any real ) { return null ; } else { return new numeric doc value ( ) { @ override public long get ( int doc i d ) { int sub index = reader util . sub index ( doc i d , start ) ; return value [ sub index ] . get ( doc i d - start [ sub index ] ) ; } } ; } }
public static sort doc value get sort value ( final index reader r , final string field ) throw i o exception { final list < atomic reader context > leave = r . leaf ( ) ; final int size = leave . size ( ) ; if ( size == 0 ) { return null ; } else if ( size == 1 ) { return leave . get ( 0 ) . reader ( ) . get sorted doc value ( field ) ; } boolean any real = false ; final sort doc value [ ] value = new sort doc value [ size ] ; final int [ ] start = new int [ size+1 ] ; for ( int i = 0 ; i < size ; i++ ) { atomic reader context context = leave . get ( i ) ; sort doc value v = context . reader ( ) . get sorted doc value ( field ) ; if ( v == null ) { v = sort doc value . empty ; } else { any real = true ; } value [ i ] = v ; start [ i ] = context . doc base ; } start [ size ] = r . max doc ( ) ; if ( ! any real ) { return null ; } else { term enum enums [ ] = new term enum [ value . length ] ; for ( int i = 0 ; i < value . length ; i++ ) { enums [ i ] = value [ i ] . term enum ( ) ; } ordinal map map = new ordinal map ( r . get core cache key ( ) , enums ) ; return new multi sort doc value ( value , start , map ) ; } }
public boolean have deletion ( ) { return del gen ! = -1 ; }
public int get soft del count ( ) { return soft del count ; }
public void add file ( string file ) { check file name ( collection . singleton ( file ) ) ; set file . add ( file ) ; }
protect void add non match ( string builder sb , string text ) { sb . append ( text ) ; }
public void set ( duration field type field , int value ) { super . set field ( field , value ) ; }
public live index writer config set reader term index divisor ( int divisor ) { if ( divisor < = 0 & & divisor ! = -1 ) { throw new illegal argument exception ( `` divisor must be > = 1 , or -1 ( get `` + divisor + `` ) `` ) ; } reader term index divisor = divisor ; return this ; }
protect accept status accept ( final byte ref term ) { if ( common suffix ref == null || string helper . end with ( term , common suffix ref ) ) { if ( run automaton . run ( term . byte , term . offset , term . length ) ) return linear ? accept status . yes : accept status . yes_and_seek ; else return ( linear & & term comp . compare ( term , linear upper bound ) < 0 ) ? accept status . no : accept status . no_and_seek ; } else { return ( linear & & term comp . compare ( term , linear upper bound ) < 0 ) ? accept status . no : accept status . no_and_seek ; } }
public int get max merge at once ( ) { return max merge at once ; }
public boolean equal ( object obj ) { if ( this == obj ) return true ; if ( obj instanceof segment info ) { final segment info other = ( segment info ) obj ; return other . dir == dir & & other . name . equal ( name ) ; } else { return false ; } }
public void set high freq minimum number should match ( float min ) { this . high freq min nr should match = min ; }
public float get high freq minimum number should match ( ) { return high freq min nr should match ; }
public bytes ref get upper val ( ) { return upper val ; }
public int get non fuzzy prefix ( ) { return non fuzzy prefix ; }
public top doc search ( query query , filter filter , int n ) throw i o exception { return search ( create normalize weight ( wrap filter ( query , filter ) ) , null , n ) ; }
public void doc ( int doc i d , store field visitor field visitor ) throw i o exception { reader . document ( doc i d , field visitor ) ; }
public top doc search after ( score doc after , query query , int n ) throw i o exception { return search ( create normalize weight ( query ) , after , n ) ; }
public query get wrap query ( ) { return query ; }
public final expression optimize ( expression visitor visitor , item type context item type ) { return this ; }
public synchronize void register ( string identifier , refresh handler handler ) { if ( identifier == null ) { throw new null pointer exception ( `` identifier can not be null `` ) ; } handler table . put ( identifier , handler ) ; }
protect explanation explain ( basic stats stats , int doc , explanation freq , float doc len ) { explanation result = new explanation ( ) ; result . set value ( score ( stats , freq . get value ( ) , doc len ) ) ; result . set description ( `` score ( `` + get class ( ) . get simple name ( ) + `` , doc= `` + doc + `` , freq= `` + freq . get value ( ) + `` ) , compute from : `` ) ; result . add detail ( freq ) ; explain ( result , stats , doc , freq . get value ( ) , doc len ) ; return result ; }
public long get doc freq ( ) { return doc freq ; }
public float get total boost ( ) { return total boost ; }
protect explanation explain ( basic stats stats , int doc , explanation freq , float doc len ) { explanation result = new explanation ( ) ; result . set value ( score ( stats , freq . get value ( ) , doc len ) ) ; result . set description ( `` score ( `` + get class ( ) . get simple name ( ) + `` , doc= `` + doc + `` , freq= `` + freq . get value ( ) + `` ) , compute from : `` ) ; result . add detail ( freq ) ; explain ( result , stats , doc , freq . get value ( ) , doc len ) ; return result ; }
protect explanation explain ( basic stats stats , int doc , explanation freq , float doc len ) { explanation result = new explanation ( ) ; result . set value ( score ( stats , freq . get value ( ) , doc len ) ) ; result . set description ( `` score ( `` + get class ( ) . get simple name ( ) + `` , doc= `` + doc + `` , freq= `` + freq . get value ( ) + `` ) , compute from : `` ) ; result . add detail ( freq ) ; explain ( result , stats , doc , freq . get value ( ) , doc len ) ; return result ; }
protect void fill basic stats ( basic stats stats , collection statistic collection stats , term statistic term stats ) { super . fill basic stats ( stats , collection stats , term stats ) ; l m stats lm stats = ( l m stats ) stats ; lm stats . set collection probability ( collection model . compute probability ( stats ) ) ; }
protect byte encode norm value ( float boost , int field length ) { return small float . float to byte315 ( boost / ( float ) math . sqrt ( field length ) ) ; }
public span query get exclude ( ) { return exclude ; }
public directory get primary dir ( ) { return primary dir ; }
protect long check instant ( long instant , chronology chronology ) { return instant ; }
public long length ( ) { try { long len = file length ; if ( sys property . check2 ) { len = file . size ( ) ; if ( len ! = file length ) { db exception . throw internal error ( `` file `` + name + `` length `` + len + `` expect `` + file length ) ; } } if ( sys property . check2 & & len % constant . file_block_size ! = 0 ) { long new length = len + constant . file_block_size - ( len % constant . file_block_size ) ; file . truncate ( new length ) ; file length = new length ; db exception . throw internal error ( `` unaligned file length `` + name + `` len `` + len ) ; } return len ; } catch ( i o exception e ) { throw db exception . convert i o exception ( e , name ) ; } }
public void set lock prefix ( string lock prefix ) { this . lock prefix = lock prefix ; }
public index output create output ( string name , i o context context ) throw i o exception { ensure open ( ) ; r a m file file = new r a m file ( ) ; r a m file exist = file map . remove ( name ) ; if ( exist ! = null ) { size in byte . add and get ( -existing . size in byte ) ; exist . directory = null ; } file map . put ( name , file ) ; return new r a m output stream ( file ) ; }
protect byte [ ] character encode string ( string string ) { byte encode byte array [ ] = new byte [ string . length ( ) ] ; encode byte array = string . get byte utf8 ( string ) ; return encode byte array ; }
public final < t extend attribute > t add attribute ( class < t > att class ) { attribute impl att impl = attribute . get ( att class ) ; if ( att impl == null ) { if ( ! ( att class . be interface ( ) & & attribute . class . be assignable from ( att class ) ) ) { throw new illegal argument exception ( `` add attribute ( ) only accept an interface that extend attribute , but `` + att class . get name ( ) + `` do not fulfil this contract . `` ) ; } add attribute impl ( att impl = this . factory . create attribute instance ( att class ) ) ; } return att class . cast ( att impl ) ; }
public string to string ( ) { return new string buffer ( ) . append ( `` [ attribute : `` ) . append ( get qualify name ( ) ) . append ( `` =\ `` `` ) . append ( value ) . append ( `` \ `` `` ) . append ( `` ] `` ) . to string ( ) ; }
public int get number of transition ( ) { if ( be singleton ( ) ) return singleton . code point count ( 0 , singleton . length ( ) ) ; int c = 0 ; for ( state s : get numbered state ( ) ) c += s . num transition ( ) ; return c ; }
public void trim transition array ( ) { if ( num transition < transition array . length ) { final transition [ ] new array = new transition [ num transition ] ; system . arraycopy ( transition array , 0 , new array , 0 , num transition ) ; transition array = new array ; } }
public string to string ( ) { string builder b = new string builder ( ) ; b . append ( `` state `` ) . append ( number ) ; if ( accept ) b . append ( `` [ accept ] `` ) ; else b . append ( `` [ reject ] `` ) ; b . append ( `` : \n `` ) ; for ( transition t : get transition ( ) ) b . append ( `` `` ) . append ( t . to string ( ) ) . append ( `` \n `` ) ; return b . to string ( ) ; }
public boolean run ( byte [ ] s , int offset , int length ) { int p = initial ; int l = offset + length ; for ( int i = offset ; i < l ; i++ ) { p = step ( p , s [ i ] & 0x f f ) ; if ( p == -1 ) return false ; } return accept [ p ] ; }
public void set accept ( int state , boolean accept ) { future object . check index ( state , get num state ( ) ) ; be accept . set ( state , accept ) ; }
public void read byte ( final long offset , final byte byte [ ] , int byte offset , int byte length ) { int byte leave = byte length ; int buffer index = ( int ) ( offset > > byte_block_shift ) ; int po = ( int ) ( offset & byte_block_mask ) ; while ( byte leave > 0 ) { byte [ ] buffer = buffer [ buffer index++ ] ; int chunk = math . min ( bytes leave , byte_block_size - po ) ; system . arraycopy ( buffer , po , byte , byte offset , chunk ) ; bytes offset += chunk ; bytes leave -= chunk ; po = 0 ; } }
public boolean run ( byte [ ] s , int offset , int length ) { int p = initial ; int l = offset + length ; for ( int i = offset ; i < l ; i++ ) { p = step ( p , s [ i ] & 0x f f ) ; if ( p == -1 ) return false ; } return accept [ p ] ; }
public void append ( char [ ] other char , int other offset , int other length ) { int new len = length + other length ; if ( char . length - offset < new len ) { char [ ] new char = new char [ new len ] ; system . arraycopy ( char , offset , new char , 0 , length ) ; offset = 0 ; char = new char ; } system . arraycopy ( other char , other offset , char , length+offset , other length ) ; length = new len ; }
public static class < ? extend f s directory > load f s directory class ( string clazz name ) throw class not find exception { return class . for name ( adjust directory class name ( clazz name ) ) . a subclass ( f s directory . class ) ; }
public static long size of map ( map < ? , ? > map , long def size ) { return size of map ( map , 0 , def size ) ; }
public void xor ( doc id set iterator iter ) throw i o exception { check unpositioned ( iter ) ; if ( bit set iterator . get fixed bit set or null ( iter ) ! = null ) { final fix bit set bit = bit set iterator . get fixed bit set or null ( iter ) ; xor ( bit ) ; } else { int doc ; while ( ( doc = iter . next doc ( ) ) < num bit ) { flip ( doc ) ; } } }
public void truncate ( long new len ) { assert new len < = get position ( ) ; assert new len > = 0 ; int block index = ( int ) ( new len > > block bit ) ; next write = ( int ) ( new len & block mask ) ; if ( next write == 0 ) { block index -- ; next write = block size ; } block . sub list ( block index+1 , block . size ( ) ) . clear ( ) ; if ( new len == 0 ) { current = null ; } else { current = block . get ( block index ) ; } assert new len == get position ( ) ; }
public static credential read token storage file ( path filename , configuration conf ) throw i o exception { f s data input stream in = null ; credential credential = new credential ( ) ; try { in = filename . get file system ( conf ) . open ( filename ) ; credential . read token storage stream ( in ) ; in . close ( ) ; return credential ; } catch ( i o exception ioe ) { throw new i o exception ( `` exception read `` + filename , ioe ) ; } finally { i o utils . cleanup ( log , in ) ; } }
public static void encode dimension ( long value , byte d [ ] , int offset ) { numeric utils . long to sortable byte ( value , d , offset ) ; }
public static long union count ( open bit set a , open bit set b ) { long tot = bit util . pop_union ( a . bit , b . bit , 0 , math . min ( a . wlen , b . wlen ) ) ; if ( a . wlen < b . wlen ) { tot += bit util . pop_array ( b . bit , a . wlen , b . wlen-a . wlen ) ; } else if ( a . wlen > b . wlen ) { tot += bit util . pop_array ( a . bit , b . wlen , a . wlen-b . wlen ) ; } return tot ; }
public final long size ( ) { long size = pending off ; if ( value off > 0 ) { size += value [ value off - 1 ] . size ( ) ; } if ( value off > 1 ) { size += ( long ) ( value off - 1 ) * page size ( ) ; } return size ; }
public long next value ( ) { if ( ! to after current high bit ( ) ) { return no_more_values ; } long high value = next high value ( ) ; return combine high low value ( high value , current low value ( ) ) ; }
public reader freeze ( boolean trim ) { if ( frozen ) { throw new illegal state exception ( `` already freeze `` ) ; } if ( do skip byte ) { throw new illegal state exception ( `` can not freeze when copy ( bytes ref , bytes ref ) be use `` ) ; } if ( trim & & upto < block size ) { final byte [ ] new block = new byte [ upto ] ; system . arraycopy ( current block , 0 , new block , 0 , upto ) ; current block = new block ; } if ( current block == null ) { current block = empty_bytes ; } block . add ( current block ) ; block end . add ( upto ) ; frozen = true ; current block = null ; return new page byte . reader ( this ) ; }
public query visitor get sub visitor ( boolean clause . occur occur , query parent ) { if ( occur == boolean clause . occur . must_not ) { return empty_visitor ; } return this ; }
public void set enable position increment ( boolean enable ) { check position increment ( version , enable ) ; this . enable position increment = enable ; }
public static feature initializer uniform ( final double min , final double max ) { return randomize ( new uniform real distribution ( min , max ) , function ( new constant ( 0 ) , 0 , 0 ) ) ; }
public iterator < v > value iterator ( ) { if ( reap on read ) reap ( ) ; return back store . value ( ) . iterator ( ) ; }
public void reset ( ) { if ( cache ! = null ) { iterator = cache . iterator ( ) ; } }
public void clear ( ) { super . clear ( ) ; payload = null ; position increment = 1 ; flag = 0 ; start offset = end offset = 0 ; type = default_type ; }
public void set unicode arc ( boolean unicode arc ) { this . unicode arcs = unicode arc ; }
public boolean be valid ( ) { if ( bytes == null ) { throw new illegal state exception ( `` byte be null `` ) ; } if ( length < 0 ) { throw new illegal state exception ( `` length be negative : `` + length ) ; } if ( length > byte . length ) { throw new illegal state exception ( `` length be out of bound : `` + length + `` , bytes . length= `` + byte . length ) ; } if ( offset < 0 ) { throw new illegal state exception ( `` offset be negative : `` + offset ) ; } if ( offset > byte . length ) { throw new illegal state exception ( `` offset out of bound : `` + offset + `` , bytes . length= `` + byte . length ) ; } if ( offset + length < 0 ) { throw new illegal state exception ( `` offset+length be negative : offset= `` + offset + `` , length= `` + length ) ; } if ( offset + length > byte . length ) { throw new illegal state exception ( `` offset+length out of bound : offset= `` + offset + `` , length= `` + length + `` , bytes . length= `` + byte . length ) ; } return true ; }
public void add ( int freq , long norm ) { if ( norm > = byte . min_value & & norm < = byte . max_value ) { int index = byte . to unsigned int ( ( byte ) norm ) ; max freqs [ index ] = math . max ( max freqs [ index ] , freq ) ; } else { add ( new impact ( freq , norm ) , other freq norm pair ) ; } assert assert consistent ( ) ; }
public static byte ref pack ( double . . . point ) { if ( point == null ) { throw new illegal argument exception ( `` point must not be null `` ) ; } if ( point . length == 0 ) { throw new illegal argument exception ( `` point must not be 0 dimension `` ) ; } byte [ ] pack = new byte [ point . length * double . bytes ] ; for ( int dim = 0 ; dim < point . length ; dim++ ) { encode dimension ( point [ dim ] , pack , dim * double . byte ) ; } return new byte ref ( pack ) ; }
public static query new exact query ( string field , float value ) { return new range query ( field , value , value ) ; }
public static query new slow box query ( string field , float min x , float max x , float min y , float max y ) { x y rectangle rectangle = new x y rectangle ( min x , max x , min y , max y ) ; return new x y doc value point in geometry query ( field , rectangle ) ; }
public static query new box query ( string field , query relation query relation , float min x , float max x , float min y , float max y ) { x y rectangle rectangle = new x y rectangle ( min x , max x , min y , max y ) ; return new geometry query ( field , query relation , rectangle ) ; }
public static double haversin kilometer ( double lat1 , double lon1 , double lat2 , double lon2 ) { double h = haversin sort key ( lat1 , lon1 , lat2 , lon2 ) ; return to_kilometers * 2 * asin ( math . min ( 1 , math . sqrt ( h * 0 . 5 ) ) ) ; }
public static component2 d predicate create component predicate ( component2 d tree ) { final function < rectangle , relation > box to relation = box - > tree . relate ( box . min lon , box . max lon , box . min lat , box . max lat ) ; final grid sub box = create sub box ( tree . get min y ( ) , tree . get max y ( ) , tree . get min x ( ) , tree . get max x ( ) , box to relation ) ; return new component2 d predicate ( sub box . lat shift , sub box . lon shift , sub box . lat base , sub box . lon base , sub box . max lat delta , sub box . max lon delta , sub box . relation , tree ) ; }
protect static final double intersection ( coordinate p1 , coordinate p2 , double dateline ) { if ( p1 . x == p2 . x & & p1 . x ! = dateline ) { return double . na n ; } else if ( p1 . x == p2 . x & & p1 . x == dateline ) { return 1 . 0 ; } else { final double t = ( dateline - p1 . x ) / ( p2 . x - p1 . x ) ; if ( t > 1 || t < = 0 ) { return double . na n ; } else { return t ; } } }
public synchronize void enable auto i o throttle ( ) { do auto i o throttle = true ; target m b per sec = start_mb_per_sec ; update merge thread ( ) ; }
public string get original message ( ) { return message ; }
public static < t extend doc i d merger . sub > doc i d merger < t > of ( list < t > sub , boolean index be sort ) throw i o exception { return of ( sub , subs . size ( ) , index be sort ) ; }
protect void grow exact ( int new value length ) { value = array util . grow exact ( value , new value length ) ; }
protect void grow exact ( int new value length ) { value = array util . grow exact ( value , new value length ) ; }
public int get point num byte ( ) { return point num byte ; }
public void set omits norm ( ) { if ( index option == index option . none ) { throw new illegal state exception ( `` can not omit norm : this field be not indexed `` ) ; } omit norm = true ; this . check consistency ( ) ; }
public string get resource description ( ) { return resource description ; }
public synchronize boolean have deletion ( ) { ensure open ( ) ; if ( buffer update stream . any ( ) ) { return true ; } if ( doc writer . any deletion ( ) ) { return true ; } if ( reader pool . any pending deletes ( ) ) { return true ; } for ( final segment commit info info : segment info ) { if ( info . have deletion ( ) ) { return true ; } } return false ; }
public final boolean have uncommitted change ( ) { return change count ! = last commit change count || doc writer . any change ( ) || buffer updates stream . any ( ) ; }
protect double get domain low bound ( double p ) { return 0 ; }
public live index writer config set reader term index divisor ( int divisor ) { if ( divisor < = 0 & & divisor ! = -1 ) { throw new illegal argument exception ( `` divisor must be > = 1 , or -1 ( get `` + divisor + `` ) `` ) ; } reader term index divisor = divisor ; return this ; }
public stream < discovery node > master first stream ( ) { return stream . concat ( stream support . stream ( master node . spliterator ( ) , false ) . map ( cur - > cur . value ) , stream support . stream ( this . spliterator ( ) , false ) . filter ( n - > n . be master node ( ) == false ) ) ; }
public multi doc and position enum reset ( final enum with slice [ ] sub , final int num sub ) { this . num subs = num sub ; this . sub = new enum with slice [ sub . length ] ; for ( int i=0 ; i < sub . length ; i++ ) { this . sub [ i ] = new enum with slice ( ) ; this . sub [ i ] . doc and position enum = sub [ i ] . doc and position enum ; this . sub [ i ] . slice = sub [ i ] . slice ; } upto = -1 ; doc = -1 ; current = null ; return this ; }
public synchronize bit get hard live doc ( ) { return pending deletes . get hard live doc ( ) ; }
public static long size ( index reader reader , string field ) throw i o exception { long size = 0 ; for ( leaf reader context ctx : reader . leaf ( ) ) { point value value = ctx . reader ( ) . get point value ( field ) ; if ( value ! = null ) { size += value . size ( ) ; } } return size ; }
public static byte [ ] get max pack value ( index reader reader , string field ) throw i o exception { byte [ ] max value = null ; for ( leaf reader context ctx : reader . leaf ( ) ) { point value value = ctx . reader ( ) . get point value ( field ) ; if ( value == null ) { continue ; } byte [ ] leaf max value = value . get max pack value ( ) ; if ( leaf max value == null ) { continue ; } if ( max value == null ) { max value = leaf max value . clone ( ) ; } else { final int num dimension = value . get num index dimension ( ) ; final int num byte per dimension = value . get byte per dimension ( ) ; for ( int i = 0 ; i < num dimension ; ++i ) { int offset = i * num byte per dimension ; if ( future array . compare unsigned ( leaf max value , offset , offset + num byte per dimension , max value , offset , offset + num byte per dimension ) > 0 ) { system . arraycopy ( leaf max value , offset , max value , offset , num byte per dimension ) ; } } } } return max value ; }
public synchronize bit get hard live doc ( ) { return pending deletes . get hard live doc ( ) ; }
public string get version ( ) { return version ; }
public static doc id set iterator intersect iterators ( list < ? extend doc id set iterator > iterators ) { if ( iterators . size ( ) < 2 ) { throw new illegal argument exception ( `` can not make a conjunction d i s i of less than 2 iterators `` ) ; } final list < doc id set iterator > all iterators = new array list < > ( ) ; for ( doc id set iterator iterator : iterators ) { add iterator ( iterator , all iterators ) ; } return new conjunction d i s i ( all iterators ) ; }
public double value get value ( leaf reader context reader context , double value score ) throw i o exception { leaf reader reader = reader context . reader ( ) ; final numeric doc value pt x = doc value . get numeric ( reader , strategy . get field name x ( ) ) ; final numeric doc value pt y = doc value . get numeric ( reader , strategy . get field name y ( ) ) ; return double value . with default ( new double value ( ) { private final point from = distance value source . this . from ; private final distance calculator calculator = strategy . get spatial context ( ) . get dist calc ( ) ; @ override public double double value ( ) throw i o exception { double x = double . long bit to double ( pt x . long value ( ) ) ; double y = double . long bit to double ( pt y . long value ( ) ) ; return calculator . distance ( from , x , y ) * multiplier ; } @ override public boolean advance exact ( int doc ) throw i o exception { return pt x . advance exact ( doc ) & & pt y . advance exact ( doc ) ; } } , null value ) ; }
public static double value source from long field ( string field ) { return from field ( field , ( v ) - > ( double ) v ) ; }
public final long value source to long value source ( ) { return new long double value source ( this ) ; }
public boolean get match ( ) { return match ; }
public void set max non competitive boost ( float boost ) { this . max boost att . set max non competitive boost ( boost ) ; }
protect void on query eviction ( query query , long ram byte use ) { assert lock . be hold by current thread ( ) ; this . ram byte use -= ram byte use ; }
public int [ ] get position ( ) { return phrase query . get position ( ) ; }
public int [ ] get position ( ) { return phrase query . get position ( ) ; }
public final long total term freq ( ) { return total term freq ; }
public static top field doc merge ( sort sort , int top n , top field doc [ ] shard hit ) { return merge ( sort , 0 , top n , shard hit , true ) ; }
public static automaton make non empty binary ( ) { automaton a = new automaton ( ) ; int s1 = a . create state ( ) ; int s2 = a . create state ( ) ; a . set accept ( s2 , true ) ; a . add transition ( s1 , s2 , 0 , 255 ) ; a . add transition ( s2 , s2 , 0 , 255 ) ; a . finish state ( ) ; return a ; }
public void add transition ( int source , int dest , int label ) { add transition ( source , dest , label , label ) ; }
public int hash code ( ) { return min * 2 + max * 3 ; }
public void add transition ( transition t ) { if ( num transition == transition array . length ) { final transition [ ] new array = new transition [ array util . oversize ( 1+num transition , ram usage estimator . num_bytes_object_ref ) ] ; system . arraycopy ( transition array , 0 , new array , 0 , num transition ) ; transition array = new array ; } transition array [ num transitions++ ] = t ; }
public static automaton to automaton ( byte ref prefix ) { final int num state and transition = prefix . length+1 ; final automaton automaton = new automaton ( num state and transition , num state and transition ) ; int last state = automaton . create state ( ) ; for ( int i=0 ; i < prefix . length ; i++ ) { int state = automaton . create state ( ) ; automaton . add transition ( last state , state , prefix . bytes [ prefix . offset+i ] & 0xff ) ; last state = state ; } automaton . set accept ( last state , true ) ; automaton . add transition ( last state , last state , 0 , 255 ) ; automaton . finish state ( ) ; assert automaton . be deterministic ( ) ; return automaton ; }
public boolean equal ( object o ) { if ( this == o ) { return true ; } if ( ! ( o instanceof fix bit set ) ) { return false ; } fix bit set other = ( fixed bit set ) o ; if ( num bit ! = other . length ( ) ) { return false ; } return array . equal ( bit , other . bit ) ; }
public static string apply relative path ( string path , string relative path ) { int separator index = path . last index of ( folder_separator ) ; if ( separator index ! = -1 ) { string new path = path . substring ( 0 , separator index ) ; if ( ! relative path . start with ( folder_separator ) ) { new path += folder_separator ; } return new path + relative path ; } else { return relative path ; } }
public void xor ( doc id set iterator iter ) throw i o exception { check unpositioned ( iter ) ; if ( bit set iterator . get fixed bit set or null ( iter ) ! = null ) { final fix bit set bit = bit set iterator . get fixed bit set or null ( iter ) ; xor ( bit ) ; } else { int doc ; while ( ( doc = iter . next doc ( ) ) < num bit ) { flip ( doc ) ; } } }
public int length ( ) { return ref . length ; }
public file get lock dir ( ) { return lock dir ; }
public void set auto generate multi term synonym phrase query ( boolean enable ) { this . auto generate multi term synonym phrase query = enable ; }
public int get secondary state dimension ( final int index ) { return index == 0 ? state . length : secondary state [ index - 1 ] . length ; }
public static long size of ( boolean [ ] arr ) { return align object size ( ( long ) num_bytes_array_header + arr . length ) ; }
public static double haversin kilometer ( double lat1 , double lon1 , double lat2 , double lon2 ) { double h = haversin sort key ( lat1 , lon1 , lat2 , lon2 ) ; return to_kilometers * 2 * asin ( math . min ( 1 , math . sqrt ( h * 0 . 5 ) ) ) ; }
public static double to degree ( double radian ) { return ( radian * 180 ) / ( math . pi ) ; }
public group search set sort within group ( sort sort within group ) { this . sort within group = sort within group ; return this ; }
public group search set all group ( boolean all group ) { this . all group = all group ; return this ; }
public group search set all group ( boolean all group ) { this . all group = all group ; return this ; }
public final query rewrite ( index reader reader ) throw i o exception { return rewrite method . rewrite ( reader , this ) ; }
public map < string , weight span term > get weight span term ( query query , float boost , token stream token stream ) throw i o exception { return get weight span term ( query , boost , token stream , null ) ; }
public int get start offset ( ) { return start offset ; }
public list < weight frag info > get frag info ( ) { return frag info ; }
public void print annotation ( ) { system . out . println ( `` annotation : `` ) ; for ( map . entry < dot name , list < annotation instance > > e : annotation . entry set ( ) ) { system . out . println ( e . get key ( ) + `` : `` ) ; for ( annotation instance instance : e . get value ( ) ) { annotation target target = instance . target ( ) ; if ( target instanceof class info ) { system . out . println ( `` class : `` + target ) ; } else if ( target instanceof field info ) { system . out . println ( `` field : `` + target ) ; } else if ( target instanceof method info ) { system . out . println ( `` method : `` + target ) ; } else if ( target instanceof method parameter info ) { system . out . println ( `` parameter : `` + target ) ; } list < annotation value > value = instance . value ( ) ; if ( value . size ( ) < 1 ) continue ; string builder builder = new string builder ( `` ( `` ) ; for ( int i = 0 ; i < value . size ( ) ; i ++ ) { builder . append ( value . get ( i ) ) ; if ( i < value . size ( ) - 1 ) builder . append ( `` , `` ) ; } builder . append ( ' ) ' ) ; system . out . println ( builder . to string ( ) ) ; } } }
public void set hyperbolic tf factor ( float min , float max , double base , float xoffset ) { tf_hyper_min = min ; tf_hyper_max = max ; tf_hyper_base = base ; tf_hyper_xoffset = xoffset ; }
public float baseline tf ( float freq ) { if ( 0 . 0f == freq ) return 0 . 0f ; return ( freq < = tf_min ) ? tf_base : ( float ) math . sqrt ( freq + ( tf_base * tf_base ) - tf_min ) ; }
public final int count ( ) { return count ; }
public void set fuzzy min sim ( float fuzzy min sim ) { this . fuzzy min sim = fuzzy min sim ; }
protect query new wildcard query ( term t ) { wildcard query query = new wildcard query ( t , max determinized state ) ; query . set rewrite method ( multi term rewrite method ) ; return query ; }
public void set builder ( char sequence field name , query builder builder ) { if ( this . field name builder == null ) { this . field name builder = new hash map < > ( ) ; } this . field name builder . put ( field name . to string ( ) , builder ) ; }
public query text get path element ( int index ) { return value . get ( index ) ; }
public object parse ( string query , string default field ) throw query node exception { query node query tree = get syntax parser ( ) . parse ( query , default field ) ; query node processor processor = get query node processor ( ) ; if ( processor ! = null ) { query tree = processor . process ( query tree ) ; } return get query builder ( ) . build ( query tree ) ; }
public void set query builder ( query builder query builder ) { if ( query builder == null ) { throw new illegal argument exception ( `` query builder should not be null ! `` ) ; } this . builder = query builder ; }
public void set query node processor ( query node processor processor ) { this . processor = processor ; this . processor . set query config handler ( get query config handler ( ) ) ; }
public void set query node processor ( query node processor processor ) { this . processor = processor ; this . processor . set query config handler ( get query config handler ( ) ) ; }
public char sequence get field ( ) { char sequence field = null ; t low = get low bound ( ) ; t upper = get upper bound ( ) ; if ( low ! = null ) { field = low . get field ( ) ; } else if ( upper ! = null ) { field = upper . get field ( ) ; } return field ; }
public void set locale ( locale locale ) { get query config handler ( ) . set ( configuration key . locale , locale ) ; }
public void set locale ( locale locale ) { get query config handler ( ) . set ( configuration key . locale , locale ) ; }
public boolean be weight ( ) { return weight ; }
public static query new intersects query ( string field , final double min lat , final double min lon , final double max lat , final double max lon ) { return new range query ( field , min lat , min lon , max lat , max lon , range field query . query type . intersects ) ; }
public string get field name ( ) { return field name ; }
public int get cal precision field ( calendar cal ) { int last field = -1 ; for ( int level = year_level ; level < field_by_level . length ; level++ ) { int field = field_by_level [ level ] ; if ( ! cal . be set ( field ) ) break ; last field = field ; } return last field ; }
protect static int one right ( int index , int modulus ) { if ( index + 1 == modulus ) { return 0 ; } return index + 1 ; }
public double get dist err ( ) { return dist err ; }
public double get dist err ( ) { return dist err ; }
public double get dist err ( ) { return dist err ; }
public static sort field new outside box sort ( final string field , final double min latitude , final double max latitude , final double min longitude , final double max longitude , final planet model planet model ) { final geo outside distance shape = geo3 d util . from box ( planet model , min latitude , max latitude , min longitude , max longitude ) ; return new geo3 d point outside sort field ( field , planet model , shape ) ; }
protect int be area inside shape ( final geo shape path ) { final geo point [ ] edge point = get edge point ( ) ; if ( edge point . length == 0 ) { return no_edgepoints ; } boolean found outside = false ; boolean find inside = false ; for ( final geo point p : edge point ) { if ( path . be within ( p ) ) { find inside = true ; } else { find outside = true ; } if ( find inside & & find outside ) { return some_inside ; } } if ( ! find inside & & ! find outside ) return none_inside ; if ( find inside & & ! find outside ) return all_inside ; if ( find outside & & ! find inside ) return none_inside ; return some_inside ; }
public void add point ( final double latitude , final double longitude , final boolean be internal edge ) { if ( be do ) throw new illegal state exception ( `` ca n't call add point ( ) if do ( ) already call `` ) ; if ( be internal edge ) be internal edge . set ( point . size ( ) - 1 ) ; point . add ( new geo point ( planet model , latitude , longitude ) ) ; }
public default double compute distance ( final distance style distance style , final geo point point ) { return compute distance ( distance style , point . x , point . y , point . z ) ; }
public double normal distance square ( final vector v ) { double t = dot product ( v ) ; double delta x = this . x * t - v . x ; double delta y = this . y * t - v . y ; double delta z = this . z * t - v . z ; return delta x * delta x + delta y * delta y + delta z * delta z ; }
public void add point ( final double latitude , final double longitude , final boolean be internal edge ) { if ( be do ) throw new illegal state exception ( `` ca n't call add point ( ) if do ( ) already call `` ) ; if ( be internal edge ) be internal edge . set ( point . size ( ) - 1 ) ; point . add ( new geo point ( planet model , latitude , longitude ) ) ; }
public static geo area make geo area ( final planet model planet model , final double top lat , final double bottom lat , final double leave lon , final double right lon ) { return geo b box factory . make geo b box ( planet model , top lat , bottom lat , leave lon , right lon ) ; }
public double normal distance square ( final vector v , final membership . . . bound ) { return normal distance square ( v . x , v . y , v . z , bound ) ; }
public double get maximum magnitude ( ) { return math . max ( this . xy scaling , this . z scale ) ; }
public geo point create surface point ( final vector vector ) { return create surface point ( vector . x , vector . y , vector . z ) ; }
public double linear distance square ( final vector v ) { double delta x = this . x - v . x ; double delta y = this . y - v . y ; double delta z = this . z - v . z ; return delta x * delta x + delta y * delta y + delta z * delta z ; }
public vector rotate z y ( final double sin angle , final double co angle ) { return new vector ( x , z * sin angle + y * co angle , z * co angle - y * sin angle ) ; }
public double linear distance ( final vector v ) { return math . sqrt ( linear distance square ( v ) ) ; }
public double normal distance square ( final vector v ) { double t = dot product ( v ) ; double delta x = this . x * t - v . x ; double delta y = this . y * t - v . y ; double delta z = this . z * t - v . z ; return delta x * delta x + delta y * delta y + delta z * delta z ; }
public boolean be large max y ( final planet model planet model ) { if ( max y == null ) return false ; return planet model . get maximum y value ( ) - max y < vector . minimum_resolution ; }
public double normal distance square ( final vector v ) { double t = dot product ( v ) ; double delta x = this . x * t - v . x ; double delta y = this . y * t - v . y ; double delta z = this . z * t - v . z ; return delta x * delta x + delta y * delta y + delta z * delta z ; }
public float get accuracy ( ) { return accuracy ; }
public string distance get distance ( ) { return distance ; }
public char array set get stop word ( ) { return stop word ; }
protect completion token stream wrap token stream ( token stream stream ) { if ( stream instanceof completion token stream ) { return ( completion token stream ) stream ; } else { return new completion token stream ( stream ) ; } }
public f s t completion build ( ) throw i o exception { this . automaton = build automaton ( sorter ) ; if ( sorter instanceof closeable ) { ( ( closeable ) sorter ) . close ( ) ; } return new f s t completion ( automaton ) ; }
public static int get number of cluster ( path cluster output path , configuration conf ) throw i o exception { file system file system = cluster output path . get file system ( conf ) ; file status [ ] cluster file = file system . list status ( cluster output path , path filter . final part filter ( ) ) ; int number of cluster = 0 ; iterator < ? > it = new sequence file dir value iterator < writable > ( cluster file [ 0 ] . get path ( ) , path type . list , path filter . part filter ( ) , null , true , conf ) ; while ( it . have next ( ) ) { it . next ( ) ; number of clusters++ ; } return number of cluster ; }
public double get diagonal of hat matrix ( double [ ] row_data ) { double [ ] wk = new double [ this . nvars ] ; int po ; double total ; if ( row_data . length > nvars ) { return double . na n ; } double [ ] xrow ; if ( this . have intercept ) { xrow = new double [ row_data . length + 1 ] ; xrow [ 0 ] = 1 . 0 ; system . arraycopy ( row_data , 0 , xrow , 1 , row_data . length ) ; } else { xrow = row_data ; } double hii = 0 . 0 ; for ( int col = 0 ; col < xrow . length ; col++ ) { if ( fast math . sqrt ( d [ col ] ) < tol [ col ] ) { wk [ col ] = 0 . 0 ; } else { po = col - 1 ; total = xrow [ col ] ; for ( int row = 0 ; row < col ; row++ ) { total = smart add ( total , -wk [ row ] * r [ po ] ) ; po += nvars - row - 2 ; } wk [ col ] = total ; hii = smart add ( hii , ( total * total ) / d [ col ] ) ; } } return hii ; }
public matrix classify ( matrix data ) { matrix r = new dense matrix ( data . num row ( ) , num category ( ) - 1 ) ; for ( int row = 0 ; row < data . num row ( ) ; row++ ) { r . assign row ( row , classify ( data . view row ( row ) ) ) ; } return r ; }
public data rsplit ( random rng , int subsize ) { list < instance > subset = list . new array list with capacity ( subsize ) ; for ( int i = 0 ; i < subsize ; i++ ) { subset . add ( instance . remove ( rng . next int ( instance . size ( ) ) ) ) ; } return new data ( dataset , subset ) ; }
public int size ( ) { int sum = 0 ; for ( int l : length ) { sum += l ; } return sum ; }
public void read field ( data input data input ) throw i o exception { int size = data input . read int ( ) ; for ( int i = 0 ; i < size ; i++ ) { tree . add ( node . read ( data input ) ) ; } }
public static void print ( node tree , dataset dataset , string [ ] attr name ) { system . out . println ( to string ( tree , dataset , attr name ) ) ; }
public neural network set cost function ( string cost function ) { this . cost function name = cost function ; return this ; }
public matrix [ ] get weight matrix ( ) { matrix [ ] matrix = new matrix [ this . weight matrix list . size ( ) ] ; this . weight matrix list . to array ( matrix ) ; return matrix ; }
public matrix [ ] get weight matrix ( ) { matrix [ ] matrix = new matrix [ this . weight matrix list . size ( ) ] ; this . weight matrix list . to array ( matrix ) ; return matrix ; }
public matrix [ ] get weight matrix ( ) { matrix [ ] matrix = new matrix [ this . weight matrix list . size ( ) ] ; this . weight matrix list . to array ( matrix ) ; return matrix ; }
public neural network set cost function ( string cost function ) { this . cost function name = cost function ; return this ; }
public dense vector hidden to output ( vector hide activation ) { dense vector activation = new dense vector ( num output ) ; for ( int i = 0 ; i < num output ; i++ ) { activation . set quick ( i , output weight [ i ] . dot ( hidden activation ) ) ; } activation . assign ( output bias , function . plus ) ; return activation ; }
public static double estimate distance cutoff ( list < ? extend vector > data , distance measure distance measure ) { brute search searcher = new brute search ( distance measure ) ; searcher . add all ( data ) ; double min distance = double . positive_infinity ; for ( vector vector : data ) { double closest = searcher . search first ( vector , true ) . get weight ( ) ; if ( min distance > 0 & & close < min distance ) { min distance = closest ; } searcher . add ( vector ) ; } return min distance ; }
public double perplexity ( vector document , vector doc topic ) { double perplexity = 0 ; double norm = doc topic . norm ( 1 ) + ( doc topic . size ( ) * alpha ) ; for ( element e : document . non zero ( ) ) { int term = e . index ( ) ; double prob = 0 ; for ( int x = 0 ; x < num topic ; x++ ) { double d = ( doc topic . get ( x ) + alpha ) / norm ; double p = d * ( topic term count . view row ( x ) . get ( term ) + eta ) / ( topic sum . get ( x ) + eta * num term ) ; prob += p ; } perplexity += e . get ( ) * math . log ( prob ) ; } return -perplexity ; }
public static iterable < centroid > cast vector to centroid ( iterable < vector > input ) { return iterables . transform ( input , new function < vector , centroid > ( ) { private int num vector = 0 ; @ override public centroid apply ( vector input ) { precondition . check not null ( input ) ; if ( input instanceof centroid ) { return ( centroid ) input ; } else { return new centroid ( num vectors++ , input , 1 ) ; } } } ) ; }
public static default option builder distance measure option ( ) { return new default option builder ( ) . with long name ( distance_measure_option ) . with required ( false ) . with short name ( `` dm `` ) . with argument ( new argument builder ( ) . with name ( distance_measure_option ) . with default ( squared euclidean distance measure . class . get name ( ) ) . with minimum ( 1 ) . with maximum ( 1 ) . create ( ) ) . with description ( `` the classname of the distance measure . default be square euclidean `` ) ; }
public static default option builder method option ( ) { return new default option builder ( ) . with long name ( method_option ) . with required ( false ) . with short name ( `` xm `` ) . with argument ( new argument builder ( ) . with name ( method_option ) . with default ( mapreduce_method ) . with minimum ( 1 ) . with maximum ( 1 ) . create ( ) ) . with description ( `` the execution method to use : sequential or mapreduce . default be mapreduce `` ) ; }
public static default option builder t2 option ( ) { return new default option builder ( ) . with long name ( t2_option ) . with required ( true ) . with argument ( new argument builder ( ) . with name ( t2_option ) . with minimum ( 1 ) . with maximum ( 1 ) . create ( ) ) . with description ( `` t2 threshold value `` ) . with short name ( t2_option ) ; }
public double get ( int i ) { map m = map [ i ] ; return m == null ? params [ i ] : m . apply ( params [ i ] ) ; }
public long header count ( int attribute ) { return attr count list . get ( attribute ) ; }
public void set compute u ( boolean val ) { compute u = val ; }
public void set q ( int q ) { this . q = q ; }
protect int hash ( byte [ ] term1 , byte [ ] term2 , int probe , int num feature ) { long r = murmur hash . hash64 a ( term1 , probe ) ; r = murmur hash . hash64 a ( term2 , ( int ) r ) % num feature ; if ( r < 0 ) { r += num feature ; } return ( int ) r ; }
protect message . builder new builder for type ( builder parent parent ) { throw new unsupported operation exception ( `` nest builder be not support for this type . `` ) ; }
public vector aggregate column ( vector function f ) { vector r = new dense vector ( num col ( ) ) ; for ( int col = 0 ; col < num col ( ) ; col++ ) { r . set ( col , f . apply ( view column ( col ) ) ) ; } return r ; }
public vector view row ( int row ) { return new matrix vector view ( this , row , 0 , 0 , 1 ) ; }
public static plane construct normalize x plane ( final double y , final double z , final double d value ) { if ( math . ab ( y ) < minimum_resolution & & math . ab ( z ) < minimum_resolution ) return null ; final double denom = 1 . 0 / math . sqrt ( y * y + z * z ) ; return new plane ( 0 . 0 , z * denom , -y * denom , d value ) ; }
public static boolean [ ] ensure capacity ( final boolean [ ] array , final int length , final int preserve ) { if ( length > array . length ) { final boolean t [ ] = new boolean [ length ] ; system . arraycopy ( array , 0 , t , 0 , preserve ) ; return t ; } return array ; }
public matrix view part ( int [ ] offset , int [ ] size ) { throw new unsupported operation exception ( `` default operation `` ) ; }
public static double double function minus mult ( double constant ) { return plus mult ( -constant ) ; }
public static double procedure be equal ( final double b ) { return new double procedure ( ) { @ override public boolean apply ( double a ) { return a == b ; } } ; }
public static double function less ( final double b ) { return new double function ( ) { @ override public double apply ( double a ) { return a < b ? 1 : 0 ; } } ; }
public boolean get curly brace denote code block ( int language index ) { return true ; }
protect double get domain low bound ( double p ) { return 0 ; }
public double pdf ( double x ) { if ( x < = min || x > = max ) { return 0 . 0 ; } return 1 . 0 / ( max - min ) ; }
public double pdf ( double x ) { if ( x < = min || x > = max ) { return 0 . 0 ; } return 1 . 0 / ( max - min ) ; }
public static double pv ( double r , double n , double y , double f , boolean t ) { double retval = 0 ; if ( r == 0 ) { retval = -1 * ( ( n * y ) +f ) ; } else { double r1 = r + 1 ; retval = ( ( ( 1 - math . pow ( r1 , n ) ) / r ) * ( t ? r1 : 1 ) * y - f ) / math . pow ( r1 , n ) ; } return retval ; }
public static double gamma ( final double x ) { if ( ( x == fast math . rint ( x ) ) & & ( x < = 0 . 0 ) ) { return double . na n ; } final double ret ; final double ab x = fast math . ab ( x ) ; if ( abs x < = 20 . 0 ) { if ( x > = 1 . 0 ) { / * * from the recurrence relation * gamma ( x ) = ( x - 1 ) * . . . * ( x - n ) * gamma ( x - n ) , * then * gamma ( t ) = 1 / [ 1 + inv gamma1pm1 ( t - 1 ) ] , * where t = x - n . this mean that t must satisfy * -0 . 5 < = t - 1 < = 1 . 5 . * / double prod = 1 . 0 ; double t = x ; while ( t > 2 . 5 ) { t -= 1 . 0 ; prod * = t ; } ret = prod / ( 1 . 0 + inv gamma1pm1 ( t - 1 . 0 ) ) ; } else { / * * from the recurrence relation * gamma ( x ) = gamma ( x + n + 1 ) / [ x * ( x + 1 ) * . . . * ( x + n ) ] * then * gamma ( x + n + 1 ) = 1 / [ 1 + inv gamma1pm1 ( x + n ) ] , * which require -0 . 5 < = x + n < = 1 . 5 . * / double prod = x ; double t = x ; while ( t < -0 . 5 ) { t += 1 . 0 ; prod * = t ; } ret = 1 . 0 / ( prod * ( 1 . 0 + inv gamma1pm1 ( t ) ) ) ; } } else { final double y = abs x + lanczos_g + 0 . 5 ; final double gamma ab = sqrt_two_pi / abs x * fast math . pow ( y , abs x + 0 . 5 ) * fast math . exp ( -y ) * lanczos ( abs x ) ; if ( x > 0 . 0 ) { ret = gamma ab ; } else { / * * from the reflection formula * gamma ( x ) * gamma ( 1 - x ) * sin ( pi * x ) = pi , * and the recurrence relation * gamma ( 1 - x ) = -x * gamma ( -x ) , * it be find * gamma ( x ) = -pi / [ x * sin ( pi * x ) * gamma ( -x ) ] . * / ret = - fast math . pi / ( x * fast math . sin ( fast math . pi * x ) * gamma ab ) ; } } return ret ; }
public static double poisson ( int k , double mean ) { if ( mean < 0 ) { throw new illegal argument exception ( ) ; } if ( k < 0 ) { return 0 . 0 ; } return gamma . incomplete gamma complement ( k + 1 , mean ) ; }
public int last index of ( byte element ) { return last index of from to ( element , 0 , size - 1 ) ; }
public void add all of from to ( abstract byte list other , int from , int to ) { before insert all of from to ( size , other , from , to ) ; }
public int last index of ( byte element ) { return last index of from to ( element , 0 , size - 1 ) ; }
public void merge sort from to ( int from , int to ) { int my size = size ( ) ; check range from to ( from , to , my size ) ; byte [ ] my element = element ( ) ; sort . merge sort ( my element , from , to + 1 ) ; element ( my element ) ; set size raw ( my size ) ; }
public static int check from index size ( int from index , int size , int length ) { int end = from index + size ; if ( from index < 0 || from index > end || end > length ) { throw new index out of bound exception ( `` range [ `` + from index + `` , `` + from index + `` + `` + size + `` ) out-of-bounds for length `` + length ) ; } return from index ; }
public void add all of ( collection < t > collection ) { this . before insert all of ( size ( ) , collection ) ; }
public void ensure capacity ( int min capacity ) { element = org . apache . mahout . math . array . ensure capacity ( element , min capacity ) ; }
public byte array list key ( ) { byte array list list = new byte array list ( size ( ) ) ; key ( list ) ; return list ; }
public boolean contains key ( final byte key ) { return ! for each key ( new byte procedure ( ) { @ override public boolean apply ( byte iter key ) { return key ! = iter key ; } } ) ; }
public double aggregate ( final double double function combiner , final double function mapper ) { return aggregate row ( new vector function ( ) { @ override public double apply ( vector v ) { return v . aggregate ( combiner , mapper ) ; } } ) . aggregate ( combiner , function . identity ) ; }
public boolean get curly brace denote code block ( int language index ) { return true ; }
public iterator < element > iterate non zero ( ) { return new non default iterator ( ) ; }
protect int choose grow capacity ( int size , double min load , double max load ) { return next prime ( math . max ( size + 1 , ( int ) ( ( 4 * size / ( 3 * min load + max load ) ) ) ) ) ; }
public matrix get d ( ) { matrix x = new dense matrix ( n , n ) ; x . assign ( 0 ) ; x . view diagonal ( ) . assign ( d ) ; for ( int i = 0 ; i < n ; i++ ) { double v = e . get quick ( i ) ; if ( v > 0 ) { x . set quick ( i , i + 1 , v ) ; } else if ( v < 0 ) { x . set quick ( i , i - 1 , v ) ; } } return x ; }
public vector get singular value ( ) { return svalues ; }
public static < t > void merge sort ( t [ ] array , int start , int end , comparator < t > comp ) { check bound ( array . length , start , end ) ; int length = end - start ; if ( length < = 0 ) { return ; } t [ ] out = ( t [ ] ) new object [ array . length ] ; system . arraycopy ( array , start , out , start , length ) ; merge sort ( out , array , start , end , comp ) ; }
public static double aggregate best ( vector x , vector y , double double function fa , double double function fc ) { return get best operation ( x , y , fa , fc ) . aggregate ( x , y , fa , fc ) ; }
public iterator < element > iterate non zero ( ) { return iterator ( ) ; }
public enumeration get matching header line ( string [ ] name ) throw message exception { check expunge ( ) ; load header ( ) ; return super . get matching header line ( name ) ; }
public folder [ ] get personal namespaces ( ) throw message exception { namespaces ns = get namespaces ( ) ; if ( ns == null || n . personal == null ) return super . get personal namespaces ( ) ; return namespace to folder ( n . personal , null ) ; }
public synchronize void set quota ( quota quota ) throw message exception { check connect ( ) ; i m a p protocol p = null ; try { p = get store protocol ( ) ; p . set quota ( quota ) ; } catch ( bad command exception bex ) { throw new message exception ( `` quota not support `` , bex ) ; } catch ( connection exception cex ) { throw new store close exception ( this , cex . get message ( ) ) ; } catch ( protocol exception pex ) { throw new message exception ( pex . get message ( ) , pex ) ; } finally { release store protocol ( p ) ; } }
protect void handle login result ( response r ) throw protocol exception { if ( have capability ( `` login-referrals `` ) & & ( ! r . be o k ( ) || referral exception ) ) check referral ( r ) ; handle result ( r ) ; }
public enumeration < ? > property name ( ) { assert false ; return super . property name ( ) ; }
public static query new geometry query ( string field , query relation query relation , x y geometry . . . xy geometry ) { if ( query relation == query relation . contain & & xy geometry . length > 1 ) { boolean query . builder builder = new boolean query . builder ( ) ; for ( int i = 0 ; i < xy geometry . length ; i++ ) { builder . add ( new geometry query ( field , query relation , xy geometry [ i ] ) , boolean clause . occur . must ) ; } return new constant score query ( builder . build ( ) ) ; } return new x y shape query ( field , query relation , xy geometry ) ; }
public string get family ( ) { return this . family ; } // -- string get family ( )
public void set arch ( string arch ) { this . arch = arch ; } // -- void set arch ( string )
public void set resource ( java . util . list < resource > resource ) { this . resource = resource ; } // -- void set resource ( java . util . list )
public void set resource ( java . util . list < resource > resource ) { this . resource = resource ; } // -- void set resource ( java . util . list )
public void set ci management ( ci management ci management ) { this . ci management = ci management ; } // -- void set ci management ( ci management )
public void set email ( string email ) { this . email = email ; } // -- void set email ( string )
public void set dependency ( java . util . list < dependency > dependency ) { this . dependency = dependency ; } // -- void set dependency ( java . util . list )
public distribution management get distribution management ( ) { return this . distribution management ; } // -- distribution management get distribution management ( )
public deployment repository get repository ( ) { return this . repository ; } // -- deployment repository get repository ( )
public void set issue management ( issue management issue management ) { this . issue management = issue management ; } // -- void set issue management ( issue management )
public string get group id ( ) { return group id ; }
public string get version ( ) { return this . version ; } // -- string get version ( )
public string get url ( ) { return this . url ; } // -- string get url ( )
public void set packaging ( string packaging ) { this . packaging = packaging ; } // -- void set packaging ( string )
public string get url ( ) { return this . url ; } // -- string get url ( )
public void set group id ( string group id ) { this . group id = group id ; }
public void set name ( string name ) { this . name = name ; } // -- void set name ( string )
public site get site ( ) { return this . site ; } // -- site get site ( )
public void set goal ( java . util . list < string > goal ) { this . goal = goal ; } // -- void set goal ( java . util . list )
public string get inherit ( ) { return this . inherit ; } // -- string get inherit ( )
public void set inherit ( string inherit ) { this . inherited = inherit ; } // -- void set inherit ( string )
public string get enable ( ) { return this . enable ; } // -- string get enable ( )
public void set target path ( string target path ) { this . target path = target path ; } // -- void set target path ( string )
public boolean be filter ( ) { return this . filter ; } // -- boolean be filter ( )
public string get name ( ) { return this . name ; } // -- string get name ( )
public void set value ( string value ) { this . value = value ; } // -- void set value ( string )
public void set miss ( string miss ) { this . miss = missing ; } // -- void set miss ( string )
public void set family ( string family ) { this . family = family ; } // -- void set family ( string )
public void set plugin repository ( java . util . list plugin repository ) { this . plugin repository = plugin repository ; } // -- void set plugin repository ( java . util . list )
public void set repository ( java . util . list < repository > repository ) { this . repository = repository ; } // -- void set repository ( java . util . list )
public string get layout ( ) { return this . layout ; } // -- string get layout ( )
public string get layout ( ) { return this . layout ; } // -- string get layout ( )
public void set artifact id ( string artifact id ) { this . artifact id = artifact id ; } // -- void set artifact id ( string )
public string get artifact id ( ) { return this . artifact id ; } // -- string get artifact id ( )
public string get mirror of ( ) { return this . mirror of ; } // -- string get mirror of ( )
public void set mirror of layout ( string mirror of layout ) { this . mirror of layout = mirror of layout ; } // -- void set mirror of layout ( string )
public string get non proxy host ( ) { return this . non proxy host ; } // -- string get non proxy host ( )
public string get username ( ) { return this . username ; } // -- string get username ( )
public string get username ( ) { return this . username ; } // -- string get username ( )
public string get password ( ) { return this . password ; } // -- string get password ( )
public string get directory permission ( ) { return this . directory permission ; } // -- string get directory permission ( )
public < t > t time ( callable < t > event ) throw exception { final long start time = clock . get tick ( ) ; try { return event . call ( ) ; } finally { update ( clock . get tick ( ) - start time ) ; } }
public double sum ( ) { return mean * count ; }
public void stop ( ) { registry . remove listener ( listener ) ; listener . unregister all ( ) ; }
public synchronize static metric registry set default ( string name ) { final metric registry registry = get or create ( name ) ; return set default ( name , registry ) ; }
public double get99th percentile ( ) { return get value ( 0 . 99 ) ; }
public boolean be percentile histogram ( ) { return percentile histogram ; }
public void clear ( ) { meter map . key set ( ) . for each ( this : : remove ) ; }
public static string abbreviate path ( string uri ) { int slash = uri . last index of ( '/ ' ) ; if ( slash > = 0 & & slash < uri . length ( ) -1 ) { return uri . substring ( slash+1 ) ; } else { return uri ; } }
public b distribution statistic expiry ( @ nullable duration expiry ) { this . distribution config builder . expiry ( expiry ) ; return ( b ) this ; }
public static cron expression parse ( string expression ) { assert . have length ( expression , `` expression string must not be empty `` ) ; expression = resolve macro ( expression ) ; string [ ] field = string utils . tokenize to string array ( expression , `` `` ) ; if ( field . length ! = 6 ) { throw new illegal argument exception ( string . format ( `` cron expression must consist of 6 field ( find % d in \ `` % s\ `` ) `` , field . length , expression ) ) ; } try { cron field second = cron field . parse second ( field [ 0 ] ) ; cron field minute = cron field . parse minute ( field [ 1 ] ) ; cron field hour = cron field . parse hour ( field [ 2 ] ) ; cron field day of month = cron field . parse day of month ( field [ 3 ] ) ; cron field month = cron field . parse month ( field [ 4 ] ) ; cron field day of week = cron field . parse day of week ( field [ 5 ] ) ; return new cron expression ( second , minute , hour , day of month , month , day of week , expression ) ; } catch ( illegal argument exception ex ) { string msg = ex . get message ( ) + `` in cron expression \ `` `` + expression + `` \ `` `` ; throw new illegal argument exception ( msg , ex ) ; } }
public static void copy file ( final file src file , final file dest file , final boolean preserve file date ) throw i o exception { copy file ( src file , d file , preserve file date ? new copy option [ ] { standard copy option . copy_attributes , standard copy option . replace_existing } : new copy option [ ] { standard copy option . replace_existing } ) ; }
public list < path > get path ( ) { return path ; }
public optional int int value ( @ non null string member ) { return int value ( member , value mapper ) ; }
public static < t extend annotation > annotation value builder < t > builder ( string annotation name ) { return new annotation value builder < > ( annotation name ) ; }
public annotation value builder < t > value ( int i ) { return member ( annotation metadata . value_member , i ) ; }
public double correlation ( final double [ ] x array , final double [ ] y array ) { if ( x array . length ! = y array . length ) { throw new dimension mismatch exception ( x array . length , y array . length ) ; } else if ( x array . length < 2 ) { throw new math illegal argument exception ( localized format . insufficient_dimension , x array . length , 2 ) ; } else { double [ ] x = x array ; double [ ] y = y array ; if ( rank algorithm instanceof natural ranking & & na n strategy . remove == ( ( natural ranking ) rank algorithm ) . get nan strategy ( ) ) { final set < integer > nan position = new hash set < integer > ( ) ; nan position . add all ( get na n position ( x array ) ) ; nan position . add all ( get na n position ( y array ) ) ; x = remove value ( x array , nan position ) ; y = remove value ( y array , nan position ) ; } return new pearsons correlation ( ) . correlation ( rank algorithm . rank ( x ) , rank algorithm . rank ( y ) ) ; } }
public annotation value builder < t > value ( int i ) { return member ( annotation metadata . value_member , i ) ; }
public static void register class for runtime reflection and reflective instantiation ( before analysis access access , string class name ) { find class ( access , class name ) . if present ( automatic feature utils : : register for runtime reflection and reflective instantiation ) ; }
public static void register all for runtime reflection and reflective instantiation ( before analysis access access , string class name ) { find class ( access , class name ) . if present ( automatic feature utils : : register all for runtime reflection and reflective instantiation ) ; }
public @ non null optional < input stream > get resource a stream ( @ non null string path ) { argument utils . require non null ( `` path `` , path ) ; optional < resource loader > resource loader = get support loader ( path ) ; if ( resource loader . be present ( ) ) { return resource loader . get ( ) . get resource a stream ( path ) ; } return optional . empty ( ) ; }
public static void reverse sort ( object [ ] array ) { array . sort ( array , reverse_comparator ) ; }
public static string canonicalize class name ( string name ) { string classname=name . replace ( '/ ' , ' . ' ) ; classname=classname . replace ( '\\ ' , ' . ' ) ; if ( classname . start with ( `` class `` ) ) classname=classname . substring ( 6 ) ; if ( classname . end with ( `` . class `` ) ) classname=classname . substring ( 0 , classname . length ( ) -6 ) ; return classname ; }
protect synchronized void register configuration ( @ non null bean configuration configuration ) { argument utils . require non null ( `` configuration `` , configuration ) ; bean configuration . put ( configuration . get name ( ) , configuration ) ; }
public static final char [ ] [ ] array concat ( char [ ] [ ] first , char [ ] [ ] second ) { if ( first == null ) return second ; if ( second == null ) return first ; int length1 = first . length ; int length2 = second . length ; char [ ] [ ] result = new char [ length1 + length2 ] [ ] ; system . arraycopy ( first , 0 , result , 0 , length1 ) ; system . arraycopy ( second , 0 , result , length1 , length2 ) ; return result ; }
public static list < grant authority > comma separate string to authority list ( string authority string ) { return create authority list ( string utils . tokenize to string array ( authority string , `` , `` ) ) ; }
public boolean equal ( final object o ) { return o == null ? false : o . get class ( ) == get class ( ) ; }
public static boolean be equal list ( final collection < ? > list1 , final collection < ? > list2 ) { if ( list1 == list2 ) { return true ; } if ( list1 == null || list2 == null || list1 . size ( ) ! = list2 . size ( ) ) { return false ; } final iterator < ? > it1 = list1 . iterator ( ) ; final iterator < ? > it2 = list2 . iterator ( ) ; object obj1 = null ; object obj2 = null ; while ( it1 . have next ( ) & & it2 . have next ( ) ) { obj1 = it1 . next ( ) ; obj2 = it2 . next ( ) ; if ( ! ( obj1 == null ? obj2 == null : obj1 . equal ( obj2 ) ) ) { return false ; } } return ! ( it1 . have next ( ) || it2 . have next ( ) ) ; }
public void set ssl configuration ( ssl configuration ssl configuration ) { this . ssl configuration = ssl configuration ; }
public cookie put ( char sequence name , cookie cookie ) { return this . cooky . put ( name , cookie ) ; }
public void set proxy password ( string proxy password ) { this . proxy password = proxy password ; }
public event loop group create event loop group ( @ nullable integer io ratio ) { return with io ratio ( new nio event loop group ( ) , io ratio ) ; }
public http version get netty http version ( ) { return http version ; }
public static < t > t convert publisher ( object object , class < t > publisher type ) { object . require non null ( object , `` argument [ object ] can not be null `` ) ; object . require non null ( publisher type , `` argument [ publisher type ] can not be null `` ) ; if ( publisher type . be instance ( object ) ) { return ( t ) object ; } if ( object instanceof completable future ) { @ suppress warning ( `` unchecked `` ) publisher < t > future publisher = publisher . from completable future ( ( ) - > ( ( completable future ) object ) ) ; return conversion service . share . convert ( future publisher , publisher type ) . or else throw ( ( ) - > unconvertible error ( object , publisher type ) ) ; } else if ( object instanceof micronaut publisher & & micronaut publisher . class . be assignable from ( publisher type ) ) { return ( t ) object ; } else { return conversion service . share . convert ( object , publisher type ) . or else throw ( ( ) - > unconvertible error ( object , publisher type ) ) ; } }
public void set allow origin ( @ nullable list < string > allow origin ) { if ( allow origins ! = null ) { this . allow origin = allow origin ; } }
public void set expose header ( @ nullable list < string > expose header ) { if ( exposed header ! = null ) { this . exposed header = exposed header ; } }
public void set cache control ( cache control configuration cache control ) { this . cache control = cache control ; }
public void set parent ( parent parent ) { this . parent = parent ; }
public static cooky element for request ( ) { return request_cookies_element ; }
public static void equal ( object expect value , object actual value , string message ) { if ( ! actual value . equal ( expect value ) ) { throw new assertion fail exception ( `` expect `` + expect value + `` but encounter `` + actual value + ( message ! = null ? `` : `` + message : `` `` ) ) ; } }
public < t > collection < t > get bean of type ( class < t > bean type , qualifier < t > qualifier ) { return get bean registration ( null , bean type , qualifier ) . stream ( ) . map ( bean registration : : get bean ) . collect ( collector . to list ( ) ) ; }
public static < p > optional < p > create provider ( class < p > provider type , @ non null bean provider < ? > bean provider ) { if ( provider type == bean provider . class ) { return optional . of ( ( p ) bean provider ) ; } function < supplier < ? > , ? > function = provider . get ( provider type ) ; if ( function ! = null ) { return optional . of nullable ( ( p ) function . apply ( bean provider : : get ) ) ; } return optional . empty ( ) ; }
public static void set persistence provider resolver ( persistence provider resolver resolver ) { if ( resolver == null ) { singleton = new default persistence provider resolver ( ) ; } else { singleton = resolver ; } }
public impl link ( @ nullable char sequence ref , @ nullable link link ) { if ( string utils . be not empty ( ref ) & & link ! = null ) { list < link > link = this . link map . compute if absent ( ref , char sequence - > new array list < > ( ) ) ; link . add ( link ) ; } return ( impl ) this ; }
public annotation metadata build ( t element ) { string declare type = get declare type ( element ) ; return build ( declare type , element ) ; }
protect void add declare repeatable stereotype ( list < string > parent , string stereotype , io . micronaut . core . annotation . annotation value annotation value ) { map < string , map < char sequence , object > > declare stereotype = get declare stereotype internal ( ) ; list < string > annotation list = get annotation by stereotype internal ( stereotype ) ; for ( string parent annotation : parent ) { if ( ! annotation list . contains ( parent annotation ) ) { annotation list . add ( parent annotation ) ; } } add repeatable internal ( stereotype , annotation value , declare stereotype , retention policy . runtime ) ; add repeatable internal ( stereotype , annotation value , get all stereotype ( ) , retention policy . runtime ) ; }
public void set name ( list < string > names ) { this . name = name ; }
public boolean be prefer ip address ( ) { return prefer ip address ; }
public jackson feature add feature ( serialization feature serialization feature , boolean be enable ) { serialization feature . put ( serialization feature , be enable ) ; return this ; }
public boolean be module scan ( ) { return module scan ; }
public boolean be module scan ( ) { return module scan ; }
public void set module scan ( boolean module scan ) { this . module scan = module scan ; }
public void set module scan ( boolean module scan ) { this . module scan = module scan ; }
public void take exception ( exception exception ) throw exception { boolean rethrow = true ; if ( be retry exception ( exception ) ) { if ( ! boolean . get boolean ( debug utils . property_dont_log_connection_issues ) ) { log . debug ( `` retry-able exception receive `` , exception ) ; } if ( retry policy . allow retry ( retry count++ , system . current time millis ( ) - start time m , sleeper ) ) { tracer . get ( ) . add count ( `` retries-allowed `` , 1 ) ; if ( ! boolean . get boolean ( debug utils . property_dont_log_connection_issues ) ) { log . debug ( `` retrying operation `` ) ; } rethrow = false ; } else { tracer . get ( ) . add count ( `` retries-disallowed `` , 1 ) ; if ( ! boolean . get boolean ( debug utils . property_dont_log_connection_issues ) ) { log . debug ( `` retry policy not allow retry `` ) ; } } } if ( rethrow ) { throw exception ; } }
protect void before each ( c context , @ nullable object test instance , @ nullable annotate element method , list < property > property annotation ) { int test count = ( int ) test property . compute ( `` micronaut . test . count `` , ( k , old count ) - > ( int ) ( old count ! = null ? old count : 0 ) + 1 ) ; if ( method ! = null ) { if ( property annotation ! = null & & ! property annotation . be empty ( ) ) { for ( property property : property annotation ) { final string name = property . name ( ) ; old value . put ( name , test property . put ( name , property . value ( ) ) ) ; } } else { old value . for each ( ( k , v ) - > test property . put ( k , v ) ) ; } if ( test annotation value . rebuild context ( ) & & test count > 1 ) { stop embed application ( ) ; if ( application context . be run ( ) ) { application context . stop ( ) ; } application context = builder . build ( ) ; start application context ( ) ; start embed application ( ) ; } else if ( ! old value . be empty ( ) ) { final map < string , object > diff = application context . get environment ( ) . refresh and diff ( ) ; refresh scope . on refresh event ( new refresh event ( diff ) ) ; } } if ( test instance ! = null ) { if ( application context ! = null ) { if ( refresh scope ! = null ) { refresh scope . on refresh event ( new refresh event ( collection . singleton map ( test active condition . active_mocks , `` change `` ) ) ) ; } application context . inject ( test instance ) ; align mock ( context , test instance ) ; } } }
public value extractor < short [ ] > get short array value extractor ( ) { return short array value extractor ; }
public synchronize univariate statistic get max impl ( ) { return max impl ; }
public synchronize univariate statistic get percentile impl ( ) { return percentile impl ; }
public static string apply relative path ( string path , string relative path ) { int separator index = path . last index of ( folder_separator ) ; if ( separator index ! = -1 ) { string new path = path . substring ( 0 , separator index ) ; if ( ! relative path . start with ( folder_separator ) ) { new path += folder_separator ; } return new path + relative path ; } else { return relative path ; } }
public static < t > answer < t > return element of ( collection < ? > element ) { return ( answer < t > ) new returns element of ( element ) ; }
public static instance field all declare field of ( object instance ) { list < instance field > instance field = new array list < instance field > ( ) ; for ( class < ? > clazz = instance . get class ( ) ; clazz ! = object . class ; clazz = clazz . get superclass ( ) ) { instance field . add all ( instance field in ( instance , clazz . get declared field ( ) ) ) ; } return new instance field ( instance , instance field ) ; }
public list < invocation > find match chunk ( list < invocation > invocation , invocation matcher want , int want count , in order context context ) { list < invocation > unverified = remove verify in order ( invocation , context ) ; list < invocation > first chunk = get first match chunk ( want , unverified ) ; if ( wanted count ! = first chunk . size ( ) ) { return this . find all match unverified chunk ( invocation , want , context ) ; } else { return first chunk ; } }
public void set pool maximum idle connection ( int pool maximum idle connection ) { this . pool maximum idle connection = pool maximum idle connection ; force close all ( ) ; }
public input stream get resource a stream ( string resource , class loader class loader ) { return get resource a stream ( resource , get class loader ( class loader ) ) ; }
public static reader get resource a reader ( string resource ) throw i o exception { reader reader ; if ( charset == null ) { reader = new input stream reader ( get resource a stream ( resource ) ) ; } else { reader = new input stream reader ( get resource a stream ( resource ) , charset ) ; } return reader ; }
public integer get default fetch size ( ) { return default fetch size ; }
public void reload ( ) { reload ( false ) ; }
public void set default result set type ( result set type default result set type ) { this . default result set type = default result set type ; }
public my batis cursor item reader builder < t > query id ( string query id ) { this . query id = query id ; return this ; }
public void after property set ( ) { not null ( sql session template , `` a sql session factory or a sql session template be require . `` ) ; be true ( executor type . batch == sql session template . get executor type ( ) , `` sql session template 's executor type must be batch `` ) ; not null ( statement id , `` a statement id be require . `` ) ; not null ( item to parameter converter , `` a item to parameter converter be require . `` ) ; }
public void set default scope ( string default scope ) { this . default scope = default scope ; }
public void set object wrapper factory ( object wrapper factory object wrapper factory ) { this . object wrapper factory = object wrapper factory ; }
public void set vfs ( class < ? extend vfs > vfs ) { this . vfs = vfs ; }
public void set type aliases super type ( class < ? > type aliases super type ) { this . type aliases super type = type aliases super type ; }
public int get tcp fastopen ( ) { return pending fast open request threshold ; }
public byte type byte value ( ) { return type byte value ; }
public string encoding ( ) { return encode ; }
public string encoding ( ) { return encode ; }
public int get max message per write ( ) { return max message per write ; }
public void write ( byte [ ] val ) { start array ( ) ; boolean first = true ; for ( short v : val ) { if ( first ) { first = false ; } else { write value separator ( ) ; } write ( v ) ; } end array ( ) ; }
public evaluation get first descendant ( ) { if ( first child ! = null ) { return first child . get first descendant ( ) ; } return this ; }
public evaluation get first descendant ( ) { if ( first child ! = null ) { return first child . get first descendant ( ) ; } return this ; }
public static string field ( field field ) { if ( field == null ) { return null_string ; } type t = field . get generic type ( ) ; string base string ; if ( t instanceof class ) { base string = clazz ( ( class < ? > ) t ) ; } else { base string = type ( t ) ; } return `` field ( `` + base string + `` `` + field . get name ( ) + `` in `` + field . get declare class ( ) . get name ( ) + `` ) `` ; }
public static security manager get security manager ( ) { return _security manager ; }
public static f s directory new f s directory ( string clazz name , file file ) { try { final class < ? extend f s directory > clazz = load f s directory class ( clazz name ) ; return new f s directory ( clazz , file ) ; } catch ( class not find exception e ) { throw new illegal argument exception ( f s directory . class . get simple name ( ) + `` implementation not find : `` + clazz name , e ) ; } catch ( class cast exception e ) { throw new illegal argument exception ( clazz name + `` be not a `` + f s directory . class . get simple name ( ) + `` implementation `` , e ) ; } catch ( no such method exception e ) { throw new illegal argument exception ( clazz name + `` constructor with `` + file . class . get simple name ( ) + `` a parameter not find `` , e ) ; } catch ( exception e ) { throw new illegal argument exception ( `` error create `` + clazz name + `` instance `` , e ) ; } }
protect static iterator iterator ( class enum class ) { return enum . get enum list ( enum class ) . iterator ( ) ; }
public static long get long l e ( byte [ ] data , int offset ) { long result = 0 ; for ( int j = offset + long_size - 1 ; j > = offset ; j -- ) { result < < = 8 ; result |= 0xff & data [ j ] ; } return result ; }
public static void register all view ( ) { register all view ( stats . get view manager ( ) ) ; }
public static void register all view ( ) { register all view ( stats . get view manager ( ) ) ; }
public static final void assert instance ( final object object , final class < ? > c , final boolean allow null ) { if ( object == null & & allow null ) { return ; } if ( object == null || c == null ) { throw new null pointer exception ( ) ; } else if ( ! c . be instance ( object ) ) { throw new illegal argument exception ( ) ; } }
public add note command set message ( string message ) { check callable ( ) ; this . message = message ; return this ; }
public list < string > get conflict list ( ) { return conflict list ; }
public cherry pick command set mainline parent number ( int mainline parent number ) { this . mainline parent number = integer . value of ( mainline parent number ) ; return this ; }
public cherry pick command set mainline parent number ( int mainline parent number ) { this . mainline parent number = integer . value of ( mainline parent number ) ; return this ; }
public clone command set directory ( file directory ) { validate dirs ( directory , git dir , bare ) ; this . directory = directory ; return this ; }
public clone command set branch to clone ( collection < string > branch to clone ) { this . branch to clone = branch to clone ; return this ; }
public int get return code ( ) { return return code ; }
public fetch command set force update ( boolean force ) { this . be force update = force ; return this ; }
public stash drop command stash drop ( ) { return new stash drop command ( repo ) ; }
protect boolean submodule exists ( ) throw i o exception { tree filter filter = path filter . create ( path ) ; try ( submodule walk w = submodule walk . for index ( repo ) ) { return w . set filter ( filter ) . next ( ) ; } }
public log command set skip ( int skip ) { check callable ( ) ; this . skip = skip ; return this ; }
public revert command include ( any object id commit ) { return include ( commit . get name ( ) , commit ) ; }
public push command set force ( boolean force ) { check callable ( ) ; this . force = force ; return this ; }
public push command set force ( boolean force ) { check callable ( ) ; this . force = force ; return this ; }
public remote add command set name ( string name ) { this . name = name ; return this ; }
public stash apply command ignore repository state ( boolean will ignore repository state ) { this . ignore repository state = will ignore repository state ; return this ; }
public stash create command set person ( person ident person ) { this . person = person ; return this ; }
public fetch command set recurse submodules ( @ nullable fetch recurse submodules mode recurse ) { check callable ( ) ; submodule recurse mode = recurse ; return this ; }
public submodule add command set path ( string path ) { this . path = path ; return this ; }
public submodule add command set path ( string path ) { this . path = path ; return this ; }
public submodule update command set fetch callback ( fetch command . callback callback ) { this . fetch callback = callback ; return this ; }
public submodule update command set fetch callback ( fetch command . callback callback ) { this . fetch callback = callback ; return this ; }
public fetch command set force update ( boolean force ) { this . be force update = force ; return this ; }
public tag command set sign ( boolean sign ) { this . sign = sign ; return this ; }
public attribute get ( string key ) { return map . get ( key ) ; }
public int compute next ( ) throw i o exception { blame generator gen = generator ; if ( gen == null ) return -1 ; if ( gen . next ( ) ) { load from ( gen ) ; last length = gen . get region length ( ) ; return gen . get result start ( ) ; } else { gen . close ( ) ; generator = null ; return -1 ; } }
public int get source end ( ) { region r = out region ; return r . source start + r . length ; }
public string get source path ( int idx ) { return source path [ idx ] ; }
public rename detection type get rename detection type ( ) { return rename detection type ; }
public void format ( any object id a , any object id b ) throw i o exception { format ( scan ( a , b ) ) ; }
public rename detector get rename detector ( ) { return rename detector ; }
public void set repository ( repository repository ) { this . repository = repository ; set reader ( repository . new object reader ( ) , repository . get config ( ) , true ) ; }
public void write line ( output stream out , int i ) throw i o exception { int start = get start ( i ) ; int end = get end ( i ) ; if ( content [ end - 1 ] == '\n ' ) end -- ; out . write ( content , start , end - start ) ; }
public void write line ( output stream out , int i ) throw i o exception { int start = get start ( i ) ; int end = get end ( i ) ; if ( content [ end - 1 ] == '\n ' ) end -- ; out . write ( content , start , end - start ) ; }
protect void fast add ( dir cache entry new entry ) { if ( entry . length == entry cnt ) { final dir cache entry [ ] n = new dir cache entry [ ( entry cnt + 16 ) * 3 / 2 ] ; system . arraycopy ( entry , 0 , n , 0 , entry cnt ) ; entry = n ; } entries [ entry cnt++ ] = new entry ; }
protect void fast add ( dir cache entry new entry ) { if ( entry . length == entry cnt ) { final dir cache entry [ ] n = new dir cache entry [ ( entry cnt + 16 ) * 3 / 2 ] ; system . arraycopy ( entry , 0 , n , 0 , entry cnt ) ; entry = n ; } entries [ entry cnt++ ] = new entry ; }
public dir cache entry get entry ( int i ) { return sort entry [ i ] ; }
protect void fast add ( dir cache entry new entry ) { if ( entry . length == entry cnt ) { final dir cache entry [ ] n = new dir cache entry [ ( entry cnt + 16 ) * 3 / 2 ] ; system . arraycopy ( entry , 0 , n , 0 , entry cnt ) ; entry = n ; } entries [ entry cnt++ ] = new entry ; }
public void clear ( ) { snapshot = null ; sort entry = no_entries ; entry cnt = 0 ; tree = null ; read index checksum = no_checksum ; }
public void clear ( ) { snapshot = null ; sort entry = no_entries ; entry cnt = 0 ; tree = null ; read index checksum = no_checksum ; }
public string get name string ( ) { final abstract tree iterator t = current head ; final int off = t . path offset ; final int end = t . path len ; return raw parse utils . decode ( utf_8 , t . path , off , end ) ; }
public object checker . error type get error type ( ) { return error type ; }
public list < string > get conflict path ( ) { return conflict path ; }
public repository get repository ( ) { return repository ; }
public string get revision ( ) { return revision == null ? default revision : revision ; }
public void set recommend shallow ( string recommend shallow ) { this . recommend shallow = recommend shallow ; }
protect repository get repository ( ) { return repo ; }
public participation get participation ( ) { return participation ; }
public string get txn namespace ( ) { return txn namespace ; }
public proposal set author ( @ nullable person ident who ) { author = who ; return this ; }
protected remote config get remote config ( ) { return remote config ; }
public long now ( @ non null time unit unit ) { return unit . convert ( system . current time millis ( ) , time unit . millisecond ) ; }
public long now ( @ non null time unit unit ) { return unit . convert ( system . current time millis ( ) , time unit . millisecond ) ; }
public ketch replica get replica ( ) { return replica ; }
public long [ ] get current size ( ) { return get stat vals ( live byte ) ; }
public void compact ( progress monitor pm ) throw i o exception { if ( pm == null ) { pm = null progress monitor . instance ; } dfs obj database objdb = repo . get object database ( ) ; try ( dfs reader ctx = objdb . new reader ( ) ) { if ( reftable config ! = null & & ! src reftables . be empty ( ) ) { compact reftables ( ctx ) ; } compact pack ( ctx , pm ) ; list < dfs pack description > commit = get new pack ( ) ; collection < dfs pack description > remove = to prune ( ) ; if ( ! commit . be empty ( ) || ! remove . be empty ( ) ) { objdb . commit pack ( commit , remove ) ; } } finally { rw = null ; } }
public long get read bitmap index count ( ) { return stats . read bitmap ; }
public boolean lock ( ) throw i o exception { file utils . mkdirs ( lck . get parent file ( ) , true ) ; token = f . detect . create new file atomic ( lck ) ; if ( token . be create ( ) ) { have lck = true ; try { os = new file output stream ( lck ) ; } catch ( i o exception ioe ) { unlock ( ) ; throw ioe ; } } else { close token ( ) ; } return have lck ; }
public void set index version ( int version ) { index version = version ; }
public static string key for ( string option name ) { return `` -- `` + option name ; }
public void set clean ( file snapshot other ) { final long now = other . last read ; if ( not racy clean ( now ) ) can not be racily clean = true ; last read = now ; }
protect long allocate poller ( int size , long pool , int timeout ) { try { return poll . create ( size , pool , 0 , timeout * 1000 ) ; } catch ( error e ) { if ( status . apr_status_is_einval ( e . get error ( ) ) ) { log . info ( sm . get string ( `` endpoint . poll . limitedpollsize `` , `` `` + size ) ) ; return 0 ; } else { log . error ( sm . get string ( `` endpoint . poll . initfail `` ) , e ) ; return -1 ; } } }
protect void clear reuse a be ( ) { flags & = ~reuse_as_is ; }
public void set thin ( boolean packthin ) { thin = packthin ; }
public boolean prepare bitmap index ( progress monitor pm ) throw i o exception { if ( ! can build bitmap || get object count ( ) > integer . max_value || ! cached pack . be empty ( ) ) return false ; if ( pm == null ) pm = null progress monitor . instance ; int num commits = object list [ obj_commit ] . size ( ) ; list < object to pack > by name = sort by name ( ) ; sort by name = null ; object list = null ; object map = null ; write bitmap = new pack bitmap index builder ( by name ) ; by name = null ; pack writer bitmap preparer bitmap preparer = new pack writer bitmap preparer ( reader , write bitmap , pm , stats . interesting object , config ) ; collection < pack writer bitmap preparer . bitmap commit > select commits = bitmap preparer . select commits ( num commits , exclude from bitmap selection ) ; begin phase ( pack phase . building_bitmaps , pm , select commits . size ( ) ) ; bitmap walker walker = bitmap preparer . new bitmap walker ( ) ; any object id last = null ; for ( pack writer bitmap preparer . bitmap commit cmit : select commits ) { if ( ! cmit . be reuse walker ( ) ) { walker = bitmap preparer . new bitmap walker ( ) ; } bitmap builder bitmap = walker . find object ( collection . singleton ( cmit ) , null , false ) ; if ( last ! = null & & cmit . be reuse walker ( ) & & ! bitmap . contains ( last ) ) throw new illegal state exception ( message format . format ( j git text . get ( ) . bitmap miss object , cmit . name ( ) , last . name ( ) ) ) ; last = cmit ; write bitmap . add bitmap ( cmit , bitmap . build ( ) , cmit . get flags ( ) ) ; pm . update ( 1 ) ; } end phase ( pm ) ; return true ; }
public ref exact ref ( object reader reader , string name ) throw i o exception { ref r = read ref ( reader , name ) ; if ( r == null ) { return null ; } else if ( r . be symbolic ( ) ) { return resolve ( reader , r , 0 ) ; } dir cache entry p = content . get entry ( peel path ( name ) ) ; if ( p ! = null & & p . get raw mode ( ) == type_gitlink ) { return new object id ref . peel tag ( pack , r . get name ( ) , r . get object id ( ) , p . get object id ( ) ) ; } return r ; }
public reftable compactor set min update index ( long min ) { min update index = min ; return this ; }
public boolean try add first ( reftable reader reader ) throw i o exception { long sz = reader . size ( ) ; if ( compact bytes limit > 0 & & bytes to compact + sz > compact bytes limit ) { return false ; } bytes to compact += sz ; adjust update index ( reader ) ; table . add first ( reader ) ; return true ; }
public long min update index ( ) throw i o exception { if ( block size == -1 ) { read file header ( ) ; } return min update index ; }
public boolean apply ( collection < command > cmd list ) { try { dir cache editor ed = content . editor ( ) ; for ( command cmd : cmd list ) { if ( ! be valid ref ( cmd ) ) { cmd . set result ( rejected_other_reason , j git text . get ( ) . funny refname ) ; command . abort ( cmd list , null ) ; return false ; } apply ( ed , cmd ) ; } ed . finish ( ) ; return true ; } catch ( dir cache name conflict exception e ) { string r1 = ref name ( e . get path1 ( ) ) ; string r2 = ref name ( e . get path2 ( ) ) ; for ( command cmd : cmd list ) { if ( r1 . equal ( cmd . get ref name ( ) ) || r2 . equal ( cmd . get ref name ( ) ) ) { cmd . set result ( lock_failure ) ; break ; } } command . abort ( cmd list , null ) ; return false ; } catch ( lock failure exception e ) { command . abort ( cmd list , null ) ; return false ; } }
public result get result ( ) { return cmd ! = null ? cmd . get result ( ) : result ; }
public string get ref name ( ) { if ( cmd ! = null ) { return cmd . get ref name ( ) ; } else if ( new ref ! = null ) { return new ref . get name ( ) ; } return old ref . get name ( ) ; }
public b set git dir ( file git dir ) { this . git dir = git dir ; this . config = null ; return self ( ) ; }
protect config get config ( ) throw i o exception { if ( config == null ) config = load config ( ) ; return config ; }
public b add alternate object directory ( collection < file > in list ) { if ( in list ! = null ) { for ( file path : in list ) add alternate object directory ( path ) ; } return self ( ) ; }
public b add ceiling directory ( file root ) { if ( root ! = null ) { if ( ceiling directory == null ) ceiling directory = new link list < > ( ) ; ceiling directory . add ( root ) ; } return self ( ) ; }
public diff command set progress monitor ( progress monitor monitor ) { if ( monitor == null ) { monitor = null progress monitor . instance ; } this . monitor = monitor ; return this ; }
public void set parent id ( any object id new parent ) { parent id = new object id [ ] { new parent . copy ( ) } ; }
public string get excludes file ( ) { return excludesfile ; }
public gpg format get key format ( ) { return config . get enum ( gpg format . value ( ) , config constant . config_gpg_section , null , config constant . config_key_format , gpg format . openpgp ) ; }
public gpg format get key format ( ) { return config . get enum ( gpg format . value ( ) , config constant . config_gpg_section , null , config constant . config_key_format , gpg format . openpgp ) ; }
public set < string > get add ( ) { return add ; }
public final string name ( ) { final char [ ] b = new char [ constant . object_id_string_length ] ; any object id . format hex char ( b , 0 , w1 ) ; if ( nibble < = 8 ) return new string ( b , 0 , nibble ) ; any object id . format hex char ( b , 8 , w2 ) ; if ( nibble < = 16 ) return new string ( b , 0 , nibble ) ; any object id . format hex char ( b , 16 , w3 ) ; if ( nibble < = 24 ) return new string ( b , 0 , nibble ) ; any object id . format hex char ( b , 24 , w4 ) ; if ( nibble < = 32 ) return new string ( b , 0 , nibble ) ; any object id . format hex char ( b , 32 , w5 ) ; return new string ( b , 0 , nibble ) ; }
protect byte [ ] buffer ( ) { byte [ ] b = temp buffer ; if ( b == null ) temp buffer = b = new byte [ 8192 ] ; return b ; }
public object id id for ( tree formatter formatter ) { return formatter . compute id ( this ) ; }
public boolean have ( any object id object id , boolean avoid unreachable object ) throw i o exception { try ( object reader or = new reader ( ) ) { or . set avoid unreachable object ( avoid unreachable object ) ; return or . have ( object id ) ; } }
public string map path ( string path ) { return null ; }
public void set short message ( string short message ) { this . short message = short message ; }
public int compare to ( j package that ) { return this . name . compare to ( that . name ) ; }
public void set pattern ( string [ ] pattern ) { this . pattern = pattern ; if ( pattern ! = null & & pattern . length > 1 ) { string buffer buffer = new string buffer ( ) ; for ( int i = 0 ; i < pattern . length ; i++ ) { if ( i > 0 ) { buffer . append ( `` , `` ) ; } buffer . append ( patterns [ i ] ) ; } display pattern = buffer . to string ( ) ; } set use locale format ( true ) ; }
public result force update ( ) throw i o exception { force = true ; return update ( ) ; }
public result force update ( ) throw i o exception { force = true ; return update ( ) ; }
public result force update ( ) throw i o exception { force = true ; return update ( ) ; }
public person ident get ref log ident ( ) { return destination . get ref log ident ( ) ; }
public static void register ( repository db ) { if ( db . get directory ( ) ! = null ) { file key key = file key . exact ( db . get directory ( ) , db . get f s ( ) ) ; cache . register repository ( key , db ) ; } }
public person ident get tagger ( ) { return tagger ; }
public tag command set tagger ( person ident tagger ) { this . tagger = tagger ; return this ; }
public object inserter get object inserter ( ) { return inserter ; }
public void set object inserter ( object inserter oi ) { walk . close ( ) ; reader . close ( ) ; inserter . close ( ) ; inserter = oi ; reader = oi . new reader ( ) ; walk = new rev walk ( reader ) ; }
public list < string > get unmerged path ( ) { return unmerged path ; }
public file mode get old mode ( int nth parent ) { return old mode [ nth parent ] ; }
public edit list to edit list ( ) { final edit list r = new edit list ( ) ; for ( hunk header hunk : hunk ) r . add all ( hunk . to edit list ( ) ) ; return r ; }
public final ref get ref ( int nth ) { return ref [ nth ] ; }
public static rev filter create ( rev filter a , rev filter b ) { if ( a == all ) return b ; if ( b == all ) return a ; return new binary ( a , b ) ; }
public static rev filter create ( rev filter [ ] list ) { if ( list . length == 2 ) return create ( list [ 0 ] , list [ 1 ] ) ; if ( list . length < 2 ) throw new illegal argument exception ( j git text . get ( ) . at least two filter need ) ; final rev filter [ ] subfilters = new rev filter [ list . length ] ; system . arraycopy ( list , 0 , subfilters , 0 , list . length ) ; return new list ( subfilters ) ; }
public static rev filter create ( rev filter a , rev filter b ) { if ( a == all ) return b ; if ( b == all ) return a ; return new binary ( a , b ) ; }
public final person ident get committer ident ( ) { final byte [ ] raw = buffer ; final int name b = raw parse utils . committer ( raw , 0 ) ; if ( name b < 0 ) return null ; return raw parse utils . parse person ident ( raw , name b ) ; }
public void set preserve old pack ( boolean preserve old pack ) { this . preserve old pack = preserve old pack ; }
public boolean be delta base a offset ( ) { return delta base a offset ; }
public long get delta search memory limit ( ) { return delta search memory limit ; }
public void set max delta depth ( int max delta depth ) { this . max delta depth = max delta depth ; }
public int get thread ( ) { return thread ; }
public void set bitmap contiguous commit count ( int count ) { bitmap contiguous commit count = count ; }
public set < object id > get client shallow commits ( ) { return statistic . client shallow commits ; }
public long get total byte ( ) { return statistic . total byte ; }
public long get reused object ( ) { return statistic . reused object ; }
public int get deltas find ( ) { return statistic . delta find ; }
public object id get head id ( ) { return head id ; }
public repository get repository ( ) throw i o exception { return get submodule repository ( repository , path ) ; }
public static url normalize ( url url ) { if ( url . get protocol ( ) . equal ( `` file `` ) ) { try { file f = new file ( cleanup ( url . get file ( ) ) ) ; if ( f . exists ( ) ) return f . to u r l ( ) ; } catch ( exception e ) { } } return url ; }
public file get directory ( ) { return get submodule directory ( repository , path ) ; }
public submodule walk reset ( ) { repo config = repository . get config ( ) ; module config = null ; path to name = null ; walk . reset ( ) ; return this ; }
public object id get head ( ) throw i o exception { try ( repository sub repo = get repository ( ) ) { if ( sub repo == null ) { return null ; } return sub repo . resolve ( constant . head ) ; } }
public boolean add push ref spec ( ref spec s ) { if ( push . contains ( s ) ) return false ; return push . add ( s ) ; }
public void advertise id ( any object id id , string ref name ) throw i o exception { tmp line . set length ( 0 ) ; id . copy to ( tmp id , tmp line ) ; tmp line . append ( ' ' ) ; tmp line . append ( ref name ) ; if ( first ) { first = false ; if ( ! capablities . be empty ( ) ) { tmp line . append ( '\0 ' ) ; for ( string cap name : capablities ) { tmp line . append ( ' ' ) ; tmp line . append ( cap name ) ; } tmp line . append ( ' ' ) ; } } tmp line . append ( '\n ' ) ; write one ( tmp line ) ; }
public void include ( ref r ) { include ( r . get name ( ) , r . get object id ( ) ) ; if ( r . get peeled object id ( ) ! = null ) tag target . add ( r . get peeled object id ( ) ) ; else if ( r . get object id ( ) ! = null & & r . get name ( ) . start with ( constant . r_heads ) ) tag target . add ( r . get object id ( ) ) ; }
public void set receive pack factory ( receive pack factory < daemon client > factory ) { if ( factory ! = null ) receive pack factory = factory ; else receive pack factory = ( receive pack factory < daemon client > ) receive pack factory . disable ; }
public synchronize void stop ( ) { if ( accept thread ! = null ) { accept thread . shut down ( ) ; } }
protect void set peer user agent ( string agent ) { peer user agent = agent ; }
public void set offset ( long offset ) { this . offset = offset ; }
public void write packet ( byte [ ] packet ) throw i o exception { write packet ( packet , 0 , packet . length ) ; }
public void write packet ( byte [ ] packet ) throw i o exception { write packet ( packet , 0 , packet . length ) ; }
public void receive signature ( packet line in pck in ) throw i o exception { string reader reader = new packet line reader ( pck in ) ; receive signature ( reader ) ; if ( ! reader . read ( ) . equal ( end_cert ) ) { throw new pack protocol exception ( j git text . get ( ) . push certificate invalid signature ) ; } }
public long get num ofs delta ( ) { return num ofs delta ; }
public long get num whole blob ( ) { return num whole blob ; }
public void set pre receive hook ( pre receive hook h ) { pre receive = h ! = null ? h : pre receive hook . null ; }
public ref spec set destination ( string destination ) { final ref spec r = new ref spec ( this ) ; r . dst name = check valid ( destination ) ; if ( be wildcard ( r . dst name ) & & r . src name == null ) throw new illegal state exception ( j git text . get ( ) . source be not a wildcard ) ; if ( be wildcard ( r . src name ) ! = be wildcard ( r . dst name ) ) throw new illegal state exception ( j git text . get ( ) . source destination must match ) ; return r ; }
public list < ref spec > get fetch ref spec ( ) { return collection . unmodifiable list ( fetch ) ; }
public boolean add push ref spec ( ref spec s ) { if ( push . contains ( s ) ) return false ; return push . add ( s ) ; }
public object id get expect old object id ( ) { return expect old object id ; }
public track ref update get track ref update ( ) { return track ref update ; }
public boolean be export all ( ) { return export all ; }
public int get cert nonce slop limit ( ) { return cert nonce slop limit ; }
public int get cert nonce slop limit ( ) { return cert nonce slop limit ; }
public void set check fetched object ( boolean check ) { if ( check & & object checker == null ) set object checker ( new object checker ( ) ) ; else if ( ! check & & object checker ! = null ) set object checker ( null ) ; }
public void set remove delete ref ( boolean remove ) { remove delete refs = remove ; }
public string get host ( ) { return host ; }
public static string get ( ) { return user agent ; }
public int get name length ( ) { return path len - path offset ; }
public void get name ( byte [ ] buffer , int offset ) { system . arraycopy ( path , path offset , buffer , offset , path len - path offset ) ; }
public file get entry file ( ) { return ( ( file entry ) current ( ) ) . get file ( ) ; }
public sym link get sym link ( ) { return symlinks ; }
public void unlock ( ) throw i o exception { file utils . delete ( keep file ) ; }
public reflog writer create ( ) throw i o exception { file utils . mkdir ( refdb . log dir ) ; file utils . mkdir ( refdb . log refs dir ) ; file utils . mkdir ( new file ( refdb . log refs dir , r_heads . substring ( r_refs . length ( ) ) ) ) ; return this ; }
public static string read sym link ( file path ) throw i o exception { path nio path = to path ( path ) ; path target = file . read symbolic link ( nio path ) ; string target string = target . to string ( ) ; if ( system reader . get instance ( ) . be windows ( ) ) { target string = target string . replace ( '\\ ' , '/ ' ) ; } else if ( system reader . get instance ( ) . be mac o s ( ) ) { target string = normalizer . normalize ( target string , form . nfc ) ; } return target string ; }
public long last modified ( file f ) throw i o exception { return file utils . last modified ( f ) ; }
public void unlock ( ) throw i o exception { file utils . delete ( keep file ) ; }
public file find hook ( repository repository , string hook name ) { file git dir = repository . get directory ( ) ; if ( git dir == null ) return null ; final file hook file = new file ( new file ( git dir , constant . hook ) , hook name ) ; return hook file . be file ( ) ? hook file : null ; }
public static file [ ] to file ( url [ ] url ) { if ( urls == null || url . length == 0 ) { return empty_file_array ; } file [ ] file = new file [ url . length ] ; for ( int i = 0 ; i < urls . length ; i++ ) { url url = urls [ i ] ; if ( url ! = null ) { if ( url . get protocol ( ) . equal ( `` file `` ) == false ) { throw new illegal argument exception ( `` url could not be convert to a file : `` + url ) ; } file [ i ] = to file ( url ) ; } } return file ; }
protect abstract tree iterator enter subtree ( ) { return new file tree iterator ( this , ( ( file entry ) current ( ) ) . get file ( ) , fs , file mode strategy ) ; }
public void add ( int n ) { if ( count == entry . length ) grow ( ) ; entry [ count++ ] = n ; }
public void format ( string fmt , object . . . args ) throw i o exception { print ( string . format ( fmt , args ) ) ; }
public static int read u16bit ( byte [ ] code , int index ) { return ( ( code [ index ] & 0xff ) < < 8 ) | ( code [ index + 1 ] & 0xff ) ; }
public boolean be execute with error ( ) { return get status ( ) == process result . status . ok & & get exit code ( ) ! = 0 ; }
public static int bit list ( byte b ) { return bit_lists [ b & 0x f f ] ; }
public final ref list < t > set ( int idx , t ref ) { ref [ ] new list = new ref [ cnt ] ; system . arraycopy ( list , 0 , new list , 0 , cnt ) ; new list [ idx ] = ref ; return new ref list < > ( new list , cnt ) ; }
public describe command set target ( object id target ) throw i o exception { this . target = w . parse commit ( target ) ; return this ; }
protect final void set platform checker ( ) { platform checker = new object checker ( ) . set safe for window ( be window ( ) ) . set safe for mac o s ( be mac o s ( ) ) ; }
public void reset ( ) { if ( overflow ! = null ) { destroy ( ) ; } if ( block ! = null ) block . clear ( ) ; else block = new array list < > ( initial block ) ; block . add ( new block ( math . min ( in core limit , block . sz ) ) ) ; }
protect void do flush ( ) throw i o exception { if ( overflow == null ) switch to overflow ( ) ; overflow . flush ( ) ; }
public void reset ( ) { if ( overflow ! = null ) { destroy ( ) ; } if ( block ! = null ) block . clear ( ) ; else block = new array list < > ( initial block ) ; block . add ( new block ( math . min ( in core limit , block . sz ) ) ) ; }
public void reset ( ) { if ( overflow ! = null ) { destroy ( ) ; } if ( block ! = null ) block . clear ( ) ; else block = new array list < > ( initial block ) ; block . add ( new block ( math . min ( in core limit , block . sz ) ) ) ; }
public multi match query builder type ( multi match query builder . type type ) { if ( type == null ) { throw new illegal argument exception ( `` [ `` + name + `` ] require type to be non-null `` ) ; } this . type = type ; return this ; }
public query builder query ( ) { return query ; }
public static have parent query builder have parent query ( string type , query builder query , boolean score ) { return new have parent query builder ( type , query , score ) ; }
public static have parent query builder have parent query ( string type , query builder query , boolean score ) { return new have parent query builder ( type , query , score ) ; }
public dictionary builder add reader ( final reader reader ) { source . add ( reader ) ; return this ; }
public void set match backwards ( final boolean b ) { match backwards = b ; }
public char [ ] get allow character ( ) { return allow character ; }
public void set report failure ( final boolean b ) { report failure = b ; }
public character data get character data ( ) { return character data ; }
public char get split char ( ) { return splitchar ; }
public void set lokid ( final ternary node node ) { lokid = node ; }
public void set hikid ( final ternary node node ) { hikid = node ; }
public void insert ( final string word ) { if ( word ! = null ) { root = insert node ( root , word , 0 ) ; } }
public void set minimum length ( final int min length ) { minimum length = min length ; }
public void set valid ( final boolean b ) { valid = b ; }
public void merge ( final rule result metadata metadata ) { count . put all ( metadata . get count ( ) ) ; }
protect boolean match ( final string password , final password data . reference reference ) { return password . equal ( reference . get password ( ) ) ; }
public void set match backwards ( final boolean b ) { match backwards = b ; }
public c o s object key put ( c o s object key key , c o s base object ) { if ( object == null || contains ( object ) ) { return null ; } c o s object key actual key = key ; if ( actual key == null || contains ( actual key ) ) { high x ref object number++ ; actual key = new c o s object key ( high x ref object number , 0 ) ; object . set key ( actual key ) ; } else { high x ref object number = math . max ( key . get number ( ) , high x ref object number ) ; } key pool . put ( actual key , object ) ; object pool . put ( object , actual key ) ; return actual key ; }
public void set embed file ( p d embed file file ) { c o s dictionary ef = get e f dictionary ( ) ; if ( ef == null & & file ! = null ) { ef = new c o s dictionary ( ) ; f . set item ( c o s name . ef , ef ) ; } if ( ef ! = null ) { ef . set item ( c o s name . f , file ) ; } }
public void set encryption key ( byte [ ] encryption key ) { this . encryption key = encryption key ; }
public boolean have security handler ( ) { return security handler == null ; }
public float [ ] get callout ( ) { c o s array array = ( c o s array ) annot . get dictionary object ( c o s name . cl ) ; if ( array ! = null ) { return array . to float array ( ) ; } else { return null ; } }
public int get struct parent ( ) { return get c o s object ( ) . get int ( c o s name . struct_parents , 0 ) ; }
public void set text color ( p d color text color ) { get c o s object ( ) . set item ( c o s name . c , text color . to c o s array ( ) ) ; }
public void set rect difference ( p d rectangle rd ) { get c o s object ( ) . set item ( c o s name . rd , rd ) ; }
public void set o s ( string os ) { if ( os == null ) { dictionary . remove item ( c o s name . o ) ; } else { c o s base os array = dictionary . get item ( c o s name . o ) ; if ( ! ( os array instanceof c o s array ) ) { os array = new c o s array ( ) ; os array . set direct ( true ) ; dictionary . set item ( c o s name . o , os array ) ; } ( ( c o s array ) o array ) . add ( 0 , c o s name . get p d f name ( o ) ) ; } }
public void set stroke color ( float r , float g , float b ) throw i o exception { if ( be outside one interval ( r ) || be outside one interval ( g ) || be outside one interval ( b ) ) { throw new illegal argument exception ( `` parameter must be within 0 . . 1 , but be `` + string . format ( `` ( % . 2f , % . 2f , % . 2f ) `` , r , g , b ) ) ; } write operand ( r ) ; write operand ( g ) ; write operand ( b ) ; write operator ( operator name . stroking_color_rgb ) ; set stroke color space stack ( p d device r g b . instance ) ; }
public p d rectangle get bleed box ( ) { c o s base base = page . get dictionary object ( c o s name . bleed_box ) ; if ( base instanceof c o s array ) { return clip to medium box ( new p d rectangle ( ( c o s array ) base ) ) ; } else { return get crop box ( ) ; } }
public void translate ( float tx , float ty ) { single [ 6 ] += tx * single [ 0 ] + ty * single [ 3 ] ; single [ 7 ] += tx * single [ 1 ] + ty * single [ 4 ] ; single [ 8 ] += tx * single [ 2 ] + ty * single [ 5 ] ; check float value ( single ) ; }
public float get scale factor x ( ) { float x scale = single [ 0 ] ; / * * * bm : if the trm be rotate , the calculation be a little more complicated * * the rotation matrix multiply with the scaling matrix be : * ( x 0 0 ) ( cos sin 0 ) ( x * co x * sin 0 ) * ( 0 y 0 ) * ( -sin cos 0 ) = ( -y * sin y * cos 0 ) * ( 0 0 1 ) ( 0 0 1 ) ( 0 0 1 ) * * so , if you want to deduce x from the matrix you take * m ( 0,0 ) = x * co and m ( 0,1 ) = x * sin and use the theorem of pythagoras * * sqrt ( m ( 0,0 ) ^2+m ( 0,1 ) ^2 ) = * sqrt ( x2 * cos2+x2 * sin2 ) = * sqrt ( x2 * ( cos2+sin2 ) ) = < - here be the trick cos2+sin2 be one * sqrt ( x2 ) = * ab ( x ) * / if ( ! ( single [ 1 ] ==0 . 0f & & single [ 3 ] ==0 . 0f ) ) { x scale = ( float ) math . sqrt ( math . pow ( single [ 0 ] , 2 ) + math . pow ( single [ 1 ] , 2 ) ) ; } return x scale ; }
public void clear ( ) { _backing map . clear ( ) ; flush ( ) ; }
public file get basedir ( ) { return basedir ; }
public string [ ] get deselected directory ( ) { slow scan ( ) ; string [ ] directory = new string [ dirs deselected . size ( ) ] ; dirs deselected . copy into ( directory ) ; return directory ; }
public string [ ] get not include file ( ) { slow scan ( ) ; string [ ] file = new string [ file not include . size ( ) ] ; file not include . copy into ( file ) ; return file ; }
public map get backing map ( ) { return ( _backing fast map ! = null ) ? _backing fast map : _backing map ; }
public rule set load from string ( string filename , final string ruleset xml content ) { return load from resource ( new rule set reference id ( filename ) { @ override public input stream get input stream ( resource loader rl ) { return new byte array input stream ( ruleset xml content . get byte ( standard charsets . utf_8 ) ) ; } } ) ; }
public void apply ( list < node > acu list , rule context ctx , language language ) { rule chain . apply ( acu list , ctx , language ) ; for ( rule set rule set : rule set ) { if ( rule set . applies ( ctx . get source code file ( ) ) ) { rule set . apply ( acu list , ctx ) ; } } }
protect double get domain low bound ( double p ) { return 0 ; }
public iterator < node > get child axis iterator ( object context node ) { return new node iterator ( ( node ) context node ) { @ override protect node get first node ( node node ) { return get first child ( node ) ; } @ override protect node get next node ( node node ) { return get next sibling ( node ) ; } } ; }
public string get scheme ( ) { throw new unsupported operation exception ( `` not implement by the `` + get class ( ) . get simple name ( ) + `` file system implementation `` ) ; }
public language version set default language version ( language version language version ) { assertion util . require param not null ( `` language version `` , language version ) ; language version current language version = language to language version . put ( language version . get language ( ) , language version ) ; if ( current language version == null ) { current language version = language version . get language ( ) . get default version ( ) ; } return current language version ; }
public language version get default language version ( language language ) { object . require non null ( language ) ; language version language version = language to language version . get ( language ) ; if ( language version == null ) { language version = language . get default version ( ) ; } return language version ; }
public static double get ( metric key < a s t any type declaration > key , a s t any type declaration node ) { return get ( key , node , metric option . empty option ( ) ) ; }
public object visit ( a s t enum declaration node , object data ) { / * * if the enum be a type in and of itself , do n't count it declaration * twice . * / if ( node . get parent ( ) instanceof a s t type declaration ) { integer node count = count node child ( node , data ) ; int count = node count . int value ( ) - 1 ; return integer . value of ( count ) ; } return count node child ( node , data ) ; }
public string to string ( ) { if ( rule set file name ! = null ) { if ( all rule ) { return rule set file name ; } else { return rule set file name + '/ ' + rule name ; } } else { if ( all rule ) { return `` anonymous all rule `` ; } else { return rule name ; } } }
public static value representation get representation ( final property descriptor < ? > descriptor , final object value ) { if ( descriptor . be multi value ( ) ) { return get sequence representation ( ( list < ? > ) value ) ; } else { return get atomic representation ( value ) ; } }
public void set suppress marker ( string suppress marker ) { this . suppress marker = suppress marker ; }
public string get input uri ( ) { return input uri ; }
public boolean be show suppressed violation ( ) { return show suppressed violation ; }
protect string default a string ( ) { return a delimited string ( default value ( ) , multi value delimiter ( ) ) ; }
protect string default a string ( ) { return a delimited string ( default value ( ) , multi value delimiter ( ) ) ; }
public boolean be property packaged ( ) { return factory instanceof property descriptor builder conversion wrapper . single value . package || factory instanceof property descriptor builder conversion wrapper . multi value . package ; }
public static generic property builder < character > char property ( string name ) { return new generic property builder < > ( name , value parser constant . character_parser , character . class ) ; }
public static generic property builder < string > string property ( string name ) { return new generic property builder < > ( name , value parser constant . string_parser , string . class ) ; }
public static generic property builder < string > string property ( string name ) { return new generic property builder < > ( name , value parser constant . string_parser , string . class ) ; }
public static property type id lookup mnemonic ( string string id ) { return constants_by_mnemonic . get ( string id ) ; }
public class < ? > property value type ( ) { return factory . value type ( ) ; }
protect string default a string ( ) { return a delimited string ( default value ( ) , multi value delimiter ( ) ) ; }
public sarif log set run ( final list < run > run ) { this . run = run ; return this ; }
public report filter violation ( predicate < rule violation > filter ) { report copy = new report ( ) ; copy . start = start ; copy . end = end ; for ( rule violation violation : violation ) { if ( filter . test ( violation ) ) { copy . add rule violation ( violation ) ; } } copy . line to suppress . put all ( line to suppress ) ; copy . suppress rule violation . add all ( suppress rule violation ) ; copy . metric . add all ( metric ) ; copy . error . add all ( error ) ; copy . config error . add all ( config error ) ; return copy ; }
public void add rule set ( rule set rule set ) { rule set . add ( rule set ) ; rule chain . add ( rule set ) ; }
public void add rule set ( rule set rule set ) { rule set . add ( rule set ) ; rule chain . add ( rule set ) ; }
public rule set [ ] get all rule set ( ) { return rule set . to array ( new rule set [ 0 ] ) ; }
public boolean use type resolution ( language language ) { for ( rule r : rule ) { if ( r . get language ( ) . equal ( language ) & & r . be type resolution ( ) ) { return true ; } } return false ; }
public set < rule > get all rule ( ) { set < rule > result = new hash set < > ( ) ; for ( rule set r : rule set ) { result . add all ( r . get rule ( ) ) ; } return result ; }
public rule set create rule set ( string reference string ) throw rule set not find exception { return create rule set ( rule set reference id . parse ( reference string ) ) ; }
public string to string ( ) { if ( rule set file name ! = null ) { if ( all rule ) { return rule set file name ; } else { return rule set file name + '/ ' + rule name ; } } else { if ( all rule ) { return `` anonymous all rule `` ; } else { return rule name ; } } }
public string get rule name ( ) { return rule name ; }
public static class < ? > get collection type for ( string short name ) { class < ? > cl = collection_classes_by_names . type for ( short name ) ; if ( cl ! = null ) { return cl ; } return collection_interfaces_by_names . type for ( short name ) ; }
public list < source object > get source object list ( ) { if ( null == dburi ) { logger . warning ( `` no db uri define - no further action possible `` ) ; return collection . empty list ( ) ; } else { return get source object list ( dburi . get languages list ( ) , dburi . get schemas list ( ) , dburi . get source code type list ( ) , dburi . get source code name list ( ) ) ; } }
public static string strip filename extension ( string path ) { int ext index = path . last index of ( extension_separator ) ; if ( ext index == -1 ) { return path ; } int folder index = path . last index of ( folder_separator ) ; if ( folder index > ext index ) { return path ; } return path . substring ( 0 , ext index ) ; }
public static filter < file > get file extension or directory filter ( string . . . extension ) { return new or filter < > ( get file extension filter ( extension ) , get directory filter ( ) ) ; }
public rule set loader new rule set loader ( ) { rule set loader loader = rule set loader . from pmd config ( configuration ) ; loader . set reporter ( this . reporter ) ; return loader ; }
public static collection < tree renderer descriptor > register renderers ( ) { return collection . unmodifiable collection ( registry . value ( ) ) ; }
public static collection < tree renderer descriptor > register renderers ( ) { return collection . unmodifiable collection ( registry . value ( ) ) ; }
public int size ( ) { return type by name . size ( ) ; }
public boolean contains ( string type name ) { return type by name . contains key ( type name ) ; }
public a s t expression get true alternative ( ) { return ( a s t expression ) get child ( 1 ) ; }
public boolean be try with resource ( ) { return get first child of type ( a s t resource specification . class ) ! = null ; }
public a s t block get block ( ) { return get first child of type ( a s t block . class ) ; }
public boolean be type inferred ( ) { return get type node ( ) == null ; }
public a s t type get type node ( ) { java node child = get child ( 1 ) ; return child instanceof a s t type ? ( a s t type ) child : ( ( a s t type pattern ) child ) . get type node ( ) ; }
public a s t variable declarator id get variable declarator id ( ) { return get first child of type ( a s t variable declarator id . class ) ; }
public a s t variable declarator id get variable declarator id ( ) { return get first child of type ( a s t variable declarator id . class ) ; }
public boolean be resource declaration ( ) { return get parent ( ) instanceof a s t resource ; }
public boolean be single character string literal ( ) { if ( be string ) { string image = get image ( ) ; int length = image . length ( ) ; if ( length == 3 ) { return true ; } else if ( image . char at ( 1 ) == '\\ ' ) { return single_char_escape_pattern . matcher ( image ) . match ( ) ; } } return false ; }
public a s t reference type get type node ( ) { return get first child of type ( a s t reference type . class ) ; }
public a s t expression get test expression ( ) { return ( a s t expression ) get child ( 0 ) ; }
public static boolean substring match ( char sequence str , int index , char sequence substring ) { for ( int j = 0 ; j < substring . length ( ) ; j++ ) { int i = index + j ; if ( i > = str . length ( ) || str . char at ( i ) ! = substring . char at ( j ) ) { return false ; } } return true ; }
protected list < a s t field declaration > get field ( a s t any type declaration node ) { return get declaration of type ( node , a s t field declaration . class ) ; }
public double compute for operation ( metric key < o > key , o node , metric option option ) { return metric util . compute metric ( key , node , option ) ; }
public void cover final ( boolean cover final ) { this . cover final = cover final ; }
public void restrict role to ( java operation signature . role . . . role ) { role mask . clear ( ) ; role mask . add all ( array . a list ( role ) ) ; }
public string get binary name ( ) { return to string ( ) ; }
protect final string get return variable name ( a s t return statement ret ) { if ( have ternary condition ( ret ) & & have ternary null check ( ret ) ) { return ret . get first descendant of type ( a s t conditional expression . class ) . get child ( 0 ) . get first descendant of type ( a s t name . class ) . get image ( ) ; } final a s t name n = ret . get first descendant of type ( a s t name . class ) ; if ( n ! = null ) { return n . get image ( ) ; } final a s t primary suffix p = ret . get first descendant of type ( a s t primary suffix . class ) ; if ( p ! = null ) { return p . get image ( ) ; } return null ; }
public boolean could resolve ( string name ) { return ! dont bother . contains key ( name ) ; }
public static encode get j v m encode ( string jvm encode ) { if ( `` utf-8 `` . equal ( jvm encode ) ) { return new u t f8 encode ( jvm encoding ) ; } if ( charset . be support ( jvm encode ) ) { return new encode ( jvm encoding ) ; } else { return default_encoding ; } }
public writer get encoding writer ( output stream out ) throw i o exception { return new output stream writer ( out , encode ) ; }
public int receive integer4 ( ) throw i o exception { if ( pg_input . read ( _int4buf ) ! = 4 ) { throw new e o f exception ( ) ; } return ( _int4buf [ 0 ] & 0x f f ) < < 24 | ( _int4buf [ 1 ] & 0x f f ) < < 16 | ( _int4buf [ 2 ] & 0x f f ) < < 8 | _int4buf [ 3 ] & 0x f f ; }
public void set max row size byte ( int row size byte ) { if ( row size byte > max row size byte ) { max row size byte = row size byte ; } }
public void close ( ) throw i o exception { if ( encode writer ! = null ) { encode writer . close ( ) ; } pg_output . close ( ) ; pg_input . close ( ) ; connection . close ( ) ; }
public static int parse server version str ( string server version ) throw number format exception { return server version . parse server version str ( server version ) ; }
public byte read raw ( ) { return buffer [ index++ ] ; }
public void initialize ( ) throw s q l exception { synchronize ( lock ) { source = create connection pool ( ) ; try { source . initialize from ( this ) ; } catch ( exception e ) { throw new p s q l exception ( gt . tr ( `` fail to setup data source . `` ) , p s q l state . unexpected_error , e ) ; } while ( available . size ( ) < initial connection ) { available . push ( source . get pooled connection ( ) ) ; } initialize = true ; } }
public static void sqltruncate ( string builder buf , list < ? extend char sequence > parse args ) throw s q l exception { two argument function call ( buf , `` trunc ( `` , `` truncate `` , parse args ) ; }
public static string sqltimestampdiff ( list < ? > parse args ) throw s q l exception { if ( parsed args . size ( ) ! = 3 ) { throw new p s q l exception ( gt . tr ( `` { 0 } function take three and only three argument . `` , `` timestampdiff `` ) , p s q l state . syntax_error ) ; } string date part = escape function . constant to date part ( parsed args . get ( 0 ) . to string ( ) ) ; string builder buf = new string builder ( ) ; buf . append ( `` extract ( `` ) . append ( date part ) . append ( `` from ( `` ) . append ( parsed args . get ( 2 ) ) . append ( `` - `` ) . append ( parsed args . get ( 1 ) ) . append ( `` ) ) `` ) ; return buf . to string ( ) ; }
public void close ( ) throw i o exception { if ( lo ! = null ) { try { lo . close ( ) ; lo = null ; } catch ( s q l exception se ) { throw new i o exception ( se . to string ( ) ) ; } } }
public long size64 ( ) throw s q l exception { long cp = tell64 ( ) ; seek64 ( 0 , seek_end ) ; long sz = tell64 ( ) ; seek64 ( cp , seek_set ) ; return sz ; }
public boolean be s s p i support ( ) { try { / * * sspi be windows-only . attempt to use jna to identify the platform . if waffle be miss we * wo n't have jna and this will throw a no class def find error . * / if ( ! platform . be windows ( ) ) { logger . log ( level . fine , `` sspi not support : non- window host `` ) ; return false ; } / * waffle must be on the classpath * / class . for name ( `` waffle . window . auth . impl . windows security context impl `` ) ; return true ; } catch ( no class def find error ex ) { logger . log ( level . warning , `` sspi unavailable ( no waffle/ j n a library ? ) '' , ex ) ; return false ; } catch ( class not find exception ex ) { logger . log ( level . warning , `` sspi unavailable ( no waffle/ j n a library ? ) '' , ex ) ; return false ; } }
public static string encode byte ( byte [ ] source , int option ) { return encode byte ( source , 0 , source . length , option ) ; } // end encode byte
public static int read u16bit ( byte [ ] code , int index ) { return ( ( code [ index ] & 0xff ) < < 8 ) | ( code [ index + 1 ] & 0xff ) ; }
public static double read double ( byte [ ] buff , int po ) { return double . long bit to double ( read long ( buff , po ) ) ; }
public synchronize value borrow ( key key ) throw s q l exception { value value = cache . remove ( key ) ; if ( value == null ) { return create action . create ( key ) ; } current size -= value . get size ( ) ; return value ; }
public final void set type ( string type ) { this . type = type ; }
public void set calendar ( calendar calendar ) { this . calendar = calendar ; }
public static string remove para ( string s ) { return remove ( s , `` ( `` , `` ) `` ) ; }
public multi match query builder field ( string field ) { if ( string . be empty ( field ) ) { throw new illegal argument exception ( `` supply field be null or empty . `` ) ; } this . field boost . put ( field , abstract query builder . default_boost ) ; return this ; }
public void update query fetch size ( boolean adaptive fetch , @ non null query query , int maximum row size byte ) { if ( adaptive fetch & & maximum result buffer size ! = -1 ) { string sql = query . get native sql ( ) . trim ( ) ; adaptive fetch cache entry adaptive fetch cache entry = adaptive fetch info map . get ( sql ) ; if ( adaptive fetch cache entry ! = null ) { int adaptive maximum row size = adaptive fetch cache entry . get maximum row size byte ( ) ; if ( adaptive maximum row size < maximum row size bytes & & maximum row size byte > 0 ) { int new fetch size = ( int ) ( maximum result buffer size / maximum row size byte ) ; new fetch size = adjust fetch size ( new fetch size ) ; adaptive fetch cache entry . set maximum row size byte ( maximum row size byte ) ; adaptive fetch cache entry . set size ( new fetch size ) ; adaptive fetch info map . put ( sql , adaptive fetch cache entry ) ; } } } }
public void update query fetch size ( boolean adaptive fetch , @ non null query query , int maximum row size byte ) { if ( adaptive fetch & & maximum result buffer size ! = -1 ) { string sql = query . get native sql ( ) . trim ( ) ; adaptive fetch cache entry adaptive fetch cache entry = adaptive fetch info map . get ( sql ) ; if ( adaptive fetch cache entry ! = null ) { int adaptive maximum row size = adaptive fetch cache entry . get maximum row size byte ( ) ; if ( adaptive maximum row size < maximum row size bytes & & maximum row size byte > 0 ) { int new fetch size = ( int ) ( maximum result buffer size / maximum row size byte ) ; new fetch size = adjust fetch size ( new fetch size ) ; adaptive fetch cache entry . set maximum row size byte ( maximum row size byte ) ; adaptive fetch cache entry . set size ( new fetch size ) ; adaptive fetch info map . put ( sql , adaptive fetch cache entry ) ; } } } }
public static < t > class < t > load class ( class < t > type , class loader classloader ) { return load class ( type . get name ( ) , classloader ) ; }
public static method [ ] method declare in ( final class < ? > cl , final class < ? > . . . additional class ) { if ( cls == null ) { throw new illegal argument exception ( `` you need to supply at least one class . `` ) ; } set < method > method = new hash set < method > ( ) ; method . add all ( a list ( whitebox impl . get all method ( cl ) ) ) ; for ( class < ? > klass : additional class ) { method . add all ( a list ( whitebox impl . get all method ( klass ) ) ) ; } return method . to array ( new method [ method . size ( ) ] ) ; }
public static method [ ] method declare in ( final class < ? > cl , final class < ? > . . . additional class ) { if ( cls == null ) { throw new illegal argument exception ( `` you need to supply at least one class . `` ) ; } set < method > method = new hash set < method > ( ) ; method . add all ( a list ( whitebox impl . get all method ( cl ) ) ) ; for ( class < ? > klass : additional class ) { method . add all ( a list ( whitebox impl . get all method ( klass ) ) ) ; } return method . to array ( new method [ method . size ( ) ] ) ; }
public void set key ( string key ) { this . key = key ; }
public static synchronize void suppress field ( class < ? > clazz , string . . . field names ) { if ( field names == null || field names . length == 0 ) { suppress field ( new class < ? > [ ] { clazz } ) ; } else { for ( field field : whitebox . get field ( clazz , field name ) ) { mock repository . add field to suppress ( field ) ; } } }
public static synchronize void suppress constructor ( class < ? > clazz , boolean exclude private constructor ) { constructor < ? > [ ] ctors = null ; if ( exclude private constructor ) { ctors = clazz . get constructor ( ) ; } else { ctors = clazz . get declared constructor ( ) ; } for ( constructor < ? > ctor : ctors ) { mock repository . add constructor to suppress ( ctor ) ; } }
public static synchronize void remove suppress static initializer ( string class name ) { suppress static initializers . remove ( class name ) ; }
public static void verify ( object . . . mock ) { for ( object mock : mock ) { get control ( mock ) . verify ( ) ; } }
public static synchronize object put additional state ( string key , object value ) { return additional state . put ( key , value ) ; }
public boolean contains ( string name , string key ) { object value = value . get ( name ) ; if ( value == null ) { throw new null pointer exception ( `` no mapped value for ' `` + name + `` ( `` + key + `` ) ' `` ) ; } else if ( value instanceof map ) { return ( ( ( map ) value ) . contains key ( key ) ) ; } else { throw new illegal argument exception ( `` non-mapped property for ' `` + name + `` ( `` + key + `` ) ' `` ) ; } }
public static constructor < ? > find constructor or throw exception ( class < ? > type ) { final constructor < ? > [ ] declare constructor = filter power mock constructor ( type . get declared constructor ( ) ) ; if ( declared constructor . length > 1 ) { throw exception when multiple constructor match find ( declared constructor ) ; } return declared constructor [ 0 ] ; }
public int get index ( class [ ] parameter type ) { final constructor [ ] constructor = this . type . get constructor ( ) ; boolean eq ; for ( int i = 0 ; i < constructor . length ; ++i ) { if ( ! modifier . be public ( constructor [ i ] . get modifier ( ) ) ) { continue ; } final class [ ] params = constructor [ i ] . get parameter type ( ) ; if ( params . length ! = parameter type . length ) { continue ; } eq = true ; for ( int j = 0 ; j < params . length ; ++j ) { if ( ! params [ j ] . equal ( parameter type [ j ] ) ) { eq = false ; break ; } } if ( eq ) { return i ; } } return -1 ; }
public java . lang . string get provider id ( ) { java . lang . object ref = provider id_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; provider id_ = s ; return s ; } }
public java . lang . string get new value ( ) { java . lang . object ref = new value_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; new value_ = s ; return s ; } }
public java . lang . string get element ( ) { java . lang . object ref = element_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; element_ = s ; return s ; } }
public java . lang . string get display name ( ) { java . lang . object ref = display name_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; display name_ = s ; return s ; } }
public java . lang . string get producer project id ( ) { java . lang . object ref = producer project id_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; producer project id_ = s ; return s ; } }
public java . lang . string get name ( ) { java . lang . object ref = name_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; name_ = s ; return s ; } }
public boolean have experimental ( ) { return experimental_ ! = null ; }
public boolean have experimental ( ) { return experimental_ ! = null ; }
public boolean have experimental ( ) { return experimental_ ! = null ; }
public boolean have experimental ( ) { return experimental_ ! = null ; }
public object get declare source ( ) { return declare source ; }
public boolean have status ( ) { return status_ ! = null ; }
public java . lang . string get resource ( ) { java . lang . object ref = resource_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; resource_ = s ; return s ; } }
public java . lang . string get caller ip ( ) { java . lang . object ref = caller ip_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; caller ip_ = s ; return s ; } }
public java . lang . string get request url ( ) { java . lang . object ref = request url_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; request url_ = s ; return s ; } }
public java . lang . string get resource name ( ) { java . lang . object ref = resource name_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; resource name_ = s ; return s ; } }
public java . lang . string get message ( ) { java . lang . object ref = message_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; message_ = s ; return s ; } }
public float get green ( ) { return green_ ; }
public java . lang . string get postal code ( ) { java . lang . object ref = postal code_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; postal code_ = s ; return s ; } }
public set < extension info > get all mutable extension by extend type ( final string full name ) { hash set < extension info > extension = new hash set < extension info > ( ) ; for ( descriptor int pair pair : mutable extension by number . key set ( ) ) { if ( pair . descriptor . get full name ( ) . equal ( full name ) ) { extension . add ( mutable extension by number . get ( pair ) ) ; } } return extension ; }
protect boolean be balance ( ) { return total length > = min length by depth [ tree depth ] ; }
public int [ ] get check initialized ( ) { return check initialized ; }
public java . lang . string get type url ( ) { java . lang . object ref = type url_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; type url_ = s ; return s ; } }
public static void print ( object o ) throw i o exception { output stream writer w=new output stream writer ( system . out , `` utf-8 `` ) ; print ( o , w , true ) ; w . flush ( ) ; }
public int get relevant rating threshold ( ) { return relevant rating threshold ; }
public set < method > get method return ( class return type ) { return get method from descriptor ( store . get ( index ( method parameter scanner . class ) , names ( return type ) ) , loader ( ) ) ; }
public configuration builder set metadata adapter ( final metadata adapter metadata adapter ) { this . metadata adapter = metadata adapter ; return this ; }
public configuration builder set expand super type ( boolean expand super type ) { this . expand super type = expand super type ; return this ; }
public set < field > get field annotate with ( final class < ? extend annotation > annotation ) { final set < field > result = set . new hash set ( ) ; for ( string annotate : store . get ( index ( field annotation scanner . class ) , annotation . get name ( ) ) ) { result . add ( get field from string ( annotate , loader ( ) ) ) ; } return result ; }
public static dir from u r l ( final url url ) { return from u r l ( url , default url type ) ; }
public set < k > key set ( ) { return store . key set ( ) ; }
public configuration builder set metadata adapter ( final metadata adapter metadata adapter ) { this . metadata adapter = metadata adapter ; return this ; }
public static boolean a boolean ( object object ) { return object ! = null ; }
public set < constructor > get constructor annotate with ( final annotation annotation ) { return get all ( get constructor annotate with ( annotation . annotation type ( ) ) , with annotation ( annotation ) ) ; }
public boolean be annotation ( string type annotate with ) { multimap < string , string > mmap = get ( type annotation scanner . class ) ; return mmap ! = null & & mmap . key set ( ) . contains ( type annotate with ) ; }
public static mutable roar bitmap xor ( mutable roaring bitmap . . . bitmap ) { return naive_xor ( bitmap ) ; }
public boolean be empty ( ) { return high low container . size ( ) == 0 ; }
public int rank ( int x ) { int size = 0 ; short xhigh = buffer util . highbits ( x ) ; for ( int i = 0 ; i < this . high low container . size ( ) ; i++ ) { short key = this . high low container . get key at index ( i ) ; if ( util . compare unsigned ( key , xhigh ) < 0 ) size += this . high low container . get cardinality ( i ) ; else return size + this . high low container . get container at index ( i ) . rank ( buffer util . lowbits ( x ) ) ; } return size ; }
public boolean intersects ( mappeable container x ) { if ( x instanceof mappeable array container ) return intersects ( ( mappeable array container ) x ) ; else if ( x instanceof mappeable bitmap container ) return intersects ( ( mappeable bitmap container ) x ) ; return intersects ( ( mappeable run container ) x ) ; }
public boolean intersects ( mappeable container x ) { if ( x instanceof mappeable array container ) return intersects ( ( mappeable array container ) x ) ; else if ( x instanceof mappeable bitmap container ) return intersects ( ( mappeable bitmap container ) x ) ; return intersects ( ( mappeable run container ) x ) ; }
protect void compute cardinality ( ) { this . cardinality = 0 ; for ( int k = 0 ; k < this . bitmap . length ; k++ ) { this . cardinality += long . bit count ( this . bitmap [ k ] ) ; } }
public list < category > get category ( ) { return category = list . create when null ( category ) ; }
public list < category > get category ( ) { return category = list . create when null ( category ) ; }
public void set label ( final string label ) { this . label = label ; }
public list < content > get content ( ) { return content = list . create when null ( content ) ; }
public date get publish ( ) { return date . copy ( publish ) ; }
public content get summary ( ) { return summary ; }
public void set title ( final string title ) { if ( this . title == null ) { this . title = new content ( ) ; } this . title . set value ( title ) ; }
public date get update ( ) { return date . copy ( update ) ; }
public list < link > get other link ( ) { return other link = list . create when null ( other link ) ; }
public list < module > get module ( ) { return module = list . create when null ( module ) ; }
public list < module > get module ( ) { return module = list . create when null ( module ) ; }
public string get version ( ) { return version ; }
public void set hreflang ( final string hreflang ) { this . hreflang = hreflang ; }
public list < string > get creator ( ) { return creator = list . create when null ( creator ) ; }
public list < string > get identifier ( ) { return identifier = list . create when null ( identifier ) ; }
public list < string > get language ( ) { return language = list . create when null ( language ) ; }
public list < string > get right list ( ) { return right = list . create when null ( right ) ; }
public list < string > get right list ( ) { return right = list . create when null ( right ) ; }
public list < string > get right list ( ) { return right = list . create when null ( right ) ; }
public string get update period ( ) { return update period ; }
public string get update period ( ) { return update period ; }
public void set web master ( final string web master ) { this . web master = web master ; }
public list < module > get module ( ) { return module = list . create when null ( module ) ; }
public list < item > get item ( ) { return item = list . create when null ( item ) ; }
public list < category > get category ( ) { return category = list . create when null ( category ) ; }
public string get generator ( ) { return generator ; }
public void set domain ( final string domain ) { this . domain = domain ; }
public string get protocol ( ) { return protocol ; }
public void set type ( final string type ) { this . type = type ; }
public string get url ( ) { return url ; }
public guid get guid ( ) { return guid ; }
public string get link ( ) { return link ; }
public void set description ( final string description ) { this . description = description ; }
public void set height ( final integer height ) { this . height = height ; }
public list < category > get category ( ) { return category = list . create when null ( category ) ; }
public guid get guid ( ) { return guid ; }
public list < module > get module ( ) { return module = list . create when null ( module ) ; }
public date get expiration date ( ) { return date . copy ( expiration date ) ; }
public string get description ( ) { return description ; }
public void set publish date ( final date publish date ) { get d c module ( ) . set date ( publish date ) ; }
public list < synd enclosure > get enclosure ( ) { return enclosures = list . create when null ( enclosure ) ; }
public void set publish date ( final date publish date ) { get d c module ( ) . set date ( publish date ) ; }
public wire feed create wire feed ( ) { return this . create wire feed ( feed type ) ; }
public synd category remove ( final int index ) { final d c subject subject = subject . remove ( index ) ; if ( subject ! = null ) { return new synd category impl ( subject ) ; } else { return null ; } }
public synd category get ( final int index ) { return new synd category impl ( subject . get ( index ) ) ; }
public void set language ( final string language ) { get d c module ( ) . set language ( language ) ; }
public synd category get ( final int index ) { return new synd category impl ( subject . get ( index ) ) ; }
public string get fee type ( ) { return feed type ; }
public string get fee type ( ) { return feed type ; }
public static date parse r f c822 ( string s date , final locale locale ) { s date = convert unsupported time zone ( s date ) ; return parse use mask ( rfc822_masks , s date , locale ) ; }
public list < string > get coverage ( ) { return coverage = list . create when null ( coverage ) ; }
protected list < item > parse item ( final element r root , final locale locale ) { final list < item > item = new array list < item > ( ) ; for ( final element item : get item ( rss root ) ) { item . add ( parse item ( rss root , item , locale ) ) ; } return item ; }
protect void refresh ( j text area text area ) { string text = text area . get text ( ) ; text area . set text ( `` `` ) ; text area . set text ( text ) ; }
public void set allow doctypes ( boolean allow doctypes ) { feed input . set allow doctypes ( allow doctypes ) ; }
public boolean be allow doctypes ( ) { return feed input . be allow doctypes ( ) ; }
public org . w3c . dom . document output w3 c dom ( final synd feed feed ) throw feed exception { return feed output . output w3 c dom ( feed . create wire feed ( ) ) ; }
public static list < string > get support feed type ( ) { return get fee parser ( ) . get supported feed type ( ) ; }
public static < t > t get first non null ( final supplier < t > . . . supplier ) { if ( supplier ! = null ) { for ( final supplier < t > supplier : supplier ) { if ( supplier ! = null ) { final t value = supplier . get ( ) ; if ( value ! = null ) { return value ; } } } } return null ; }
public final completable repeat ( ) { return from observable ( to observable ( ) . repeat ( ) ) ; }
public final completable timeout ( long timeout , time unit unit , scheduler scheduler , completable other ) { require non null ( other ) ; return timeout0 ( timeout , unit , scheduler , other ) ; }
public final completable timeout ( long timeout , time unit unit ) { return timeout0 ( timeout , unit , scheduler . computation ( ) , null ) ; }
public final completable timeout ( long timeout , time unit unit ) { return timeout0 ( timeout , unit , scheduler . computation ( ) , null ) ; }
public static < t > boolean post complete request ( atomic long request , long n , queue < t > queue , subscriber < ? super t > actual ) { return post complete request ( request , n , queue , actual , utility function . < t > identity ( ) ) ; }
public final void complete ( t value ) { int state = get ( ) ; if ( ( state & ( fused_ready | fused_consumed | terminate | dispose ) ) ! = 0 ) { return ; } if ( state == fused_empty ) { this . value = value ; lazy set ( fused_ready ) ; } else { lazy set ( terminate ) ; } observer < ? super t > a = actual ; a . on next ( value ) ; if ( get ( ) ! = dispose ) { a . on complete ( ) ; } }
protect final void complete ( r value ) { subscriber < ? super r > a = actual ; for ( ; ; ) { int s = state . get ( ) ; if ( s == no_request_has_value || s == has_request_has_value || a . be unsubscribed ( ) ) { return ; } if ( s == has_request_no_value ) { a . on next ( value ) ; if ( ! a . be unsubscribed ( ) ) { a . on complete ( ) ; } state . lazy set ( has_request_has_value ) ; return ; } this . value = value ; if ( state . compare and set ( no_request_no_value , no_request_has_value ) ) { return ; } } }
public static < t > observable < t > instance ( ) { return ( observable < t > ) empty ; }
public static schedule executor service get instance ( ) { schedule executor service [ ] execs = instance . executor . get ( ) ; if ( execs == none ) { return shutdown ; } int r = round robin + 1 ; if ( r > = exec . length ) { r = 0 ; } round robin = r ; return exec [ r ] ; }
public void shutdown ( ) { if ( ! dispose ) { disposed = true ; executor . shutdown ( ) ; } }
public static boolean add throwable ( atomic reference < throwable > field , throwable error ) { for ( ; ; ) { throwable current = field . get ( ) ; if ( current == terminate ) { return false ; } throwable next ; if ( current == null ) { next = error ; } else if ( current instanceof composite exception ) { list < throwable > list = new array list < throwable > ( ( ( composite exception ) current ) . get exception ( ) ) ; list . add ( error ) ; next = new composite exception ( list ) ; } else { next = new composite exception ( current , error ) ; } if ( field . compare and set ( current , next ) ) { return true ; } } }
public static < t > func0 < connectable observable < t > > create replay supplier ( final observable < t > source , final int buffer size ) { return new replay supplier buffer < t > ( source , buffer size ) ; }
public static long object field offset ( class < ? > clazz , string field name ) { try { return unsafe . object field offset ( clazz . get declared field ( field name ) ) ; } catch ( no such field exception | security exception e ) { throw new error ( e ) ; } }
public t get value ( ) { object v = last value ; object o = state . get late ( ) ; if ( ! notification lite . be error ( o ) & & notification lite . be next ( v ) ) { return notification lite . get value ( v ) ; } return null ; }
public observable < t > scalar schedule on ( final scheduler scheduler ) { func1 < action0 , subscription > on schedule ; if ( scheduler instanceof event loop scheduler ) { final event loop scheduler el = ( event loop scheduler ) scheduler ; on schedule = new func1 < action0 , subscription > ( ) { @ override public subscription call ( action0 a ) { return el . schedule direct ( a ) ; } } ; } else { on schedule = new func1 < action0 , subscription > ( ) { @ override public subscription call ( final action0 a ) { final scheduler . worker w = scheduler . create worker ( ) ; w . schedule ( new action0 ( ) { @ override public void call ( ) { try { a . call ( ) ; } finally { w . unsubscribe ( ) ; } } } ) ; return w ; } } ; } return unsafe create ( new scalar async on subscribe < t > ( t , on schedule ) ) ; }
public static < t1 , t2 , r > observable < r > zip ( observable < ? extend t1 > o1 , observable < ? extend t2 > o2 , final func2 < ? super t1 , ? super t2 , ? extend r > zip function ) { return just ( new observable < ? > [ ] { o1 , o2 } ) . lift ( new operator zip < r > ( zip function ) ) ; }
public final observable < t > a observable ( ) { return lift ( operator a observable . < t > instance ( ) ) ; }
public final < u > observable < t > delay ( func1 < ? super t , ? extend observable < u > > item delay ) { return lift ( new operator delay with selector < t , u > ( this , item delay ) ) ; }
public static < t > observable < t > concat eager ( iterable < ? extend observable < ? extend t > > source ) { return observable . from ( source ) . concat map eager ( ( func1 ) utility function . identity ( ) ) ; }
public final observable < t > last or default ( t default value ) { return take last ( 1 ) . single or default ( default value ) ; }
public final observable < t > on backpressure drop ( action1 < ? super t > on drop ) { return lift ( new operator on backpressure drop < t > ( on drop ) ) ; }
public final observable < t > a observable ( ) { return lift ( operator a observable . < t > instance ( ) ) ; }
public final < u > observable < t > debounce ( func1 < ? super t , ? extend observable < u > > debounce selector ) { return lift ( new operator debounce with selector < t , u > ( debounce selector ) ) ; }
public final observable < t > timeout ( long timeout , time unit time unit ) { return timeout ( timeout , time unit , null , scheduler . computation ( ) ) ; }
public final observable < t > throttle first ( long skip duration , time unit unit , scheduler scheduler ) { return lift ( new operator throttle first < t > ( skip duration , unit , scheduler ) ) ; }
public final < t closing > observable < list < t > > buffer ( func0 < ? extend observable < ? extend t close > > buffer closing selector ) { return lift ( new operator buffer with single observable < t , t close > ( buffer closing selector , 16 ) ) ; }
public final observable < t > do on each ( final action1 < notification < ? super t > > on notification ) { observer < t > observer = new action notification observer < t > ( on notification ) ; return unsafe create ( new on subscribe do on each < t > ( this , observer ) ) ; }
public final void assert value and clear ( t expect first value , t . . . expect rest value ) { int n = 1 + expect rest value . length ; assert value count ( n ) ; assert item ( expect first value , 0 ) ; for ( int i = 0 ; i < expect rest value . length ; i++ ) { assert item ( expect rest value [ i ] , i + 1 ) ; } value . clear ( ) ; value count = 0 ; }
public static void clear ( ) { if ( lockdown ) { return ; } on error = null ; on observable create = null ; on observable start = null ; on observable return = null ; on observable subscribe error = null ; on observable lift = null ; on single create = null ; on single start = null ; on single return = null ; on single subscribe error = null ; on single lift = null ; on completable create = null ; on completable start = null ; on completable subscribe error = null ; on completable lift = null ; on computation scheduler = null ; on i o scheduler = null ; on new thread scheduler = null ; on schedule action = null ; on generic schedule executor service = null ; }
public static throwable on single error ( throwable error ) { func1 < throwable , throwable > f = on single subscribe error ; if ( f ! = null ) { return f . call ( error ) ; } return error ; }
public static void clear ( ) { if ( lockdown ) { return ; } on error = null ; on observable create = null ; on observable start = null ; on observable return = null ; on observable subscribe error = null ; on observable lift = null ; on single create = null ; on single start = null ; on single return = null ; on single subscribe error = null ; on single lift = null ; on completable create = null ; on completable start = null ; on completable subscribe error = null ; on completable lift = null ; on computation scheduler = null ; on i o scheduler = null ; on new thread scheduler = null ; on schedule action = null ; on generic schedule executor service = null ; }
public static < t > observable < t > merge ( single < ? extend t > t1 , single < ? extend t > t2 , single < ? extend t > t3 , single < ? extend t > t4 ) { return observable . merge ( a observable ( t1 ) , a observable ( t2 ) , a observable ( t3 ) , a observable ( t4 ) ) ; }
public static < t1 , t2 , t3 , r > single < r > zip ( single < ? extend t1 > s1 , single < ? extend t2 > s2 , single < ? extend t3 > s3 , final func3 < ? super t1 , ? super t2 , ? super t3 , ? extend r > zip function ) { return single operator zip . zip ( new single [ ] { s1 , s2 , s3 } , new func n < r > ( ) { @ override public r call ( object . . . args ) { return zip function . call ( ( t1 ) args [ 0 ] , ( t2 ) args [ 1 ] , ( t3 ) args [ 2 ] ) ; } } ) ; }
public final single < t > delay ( long delay , time unit unit , scheduler scheduler ) { return create ( new single delay < t > ( on subscribe , delay , unit , scheduler ) ) ; }
public final observable < t > timeout ( long timeout , time unit time unit ) { return timeout ( timeout , time unit , null , scheduler . computation ( ) ) ; }
public void set top level element ( structure q name element name ) { option . set top level element ( element name ) ; }
public void set x include aware ( boolean state ) { option . set x include aware ( state ) ; }
public void set x include aware ( boolean state ) { option . set x include aware ( state ) ; }
public void set error listener ( error listener listener ) { option . set error listener ( listener ) ; }
public static boolean be ( int c ) { return ( min < = c ) & & ( c < = max ) ; }
public static boolean be n c name start11 ( int i ) { return i < 65536 ? ( data [ i ] & name_start_11_mask ) ! = 0 : ( utf16 . nonbmp_min < = i & & i < = max_xml11_name_char ) ; }
public static boolean be n c name start11 ( int i ) { return i < 65536 ? ( data [ i ] & name_start_11_mask ) ! = 0 : ( utf16 . nonbmp_min < = i & & i < = max_xml11_name_char ) ; }
public string get initial template ( ) { if ( initial template == null ) { return null ; } else { return initial template . get template name ( ) . get clark name ( ) ; } }
public void check implicit result tree ( ) throw x path exception { if ( ! check unique output destination ( principal result u r i ) ) { x path exception err = new x path exception ( `` can not write an implicit result document if an explicit result document have be write to the same uri : `` + principal result u r i ) ; err . set error code ( `` xtde1490 `` ) ; throw err ; } }
public void reuse sequence outputter ( sequence outputter out ) { reusable sequence outputter = out ; }
public key manager get key manager ( ) { return executable . get key manager ( ) ; }
public item get initial context item ( ) { return initial context item ; }
public void define global parameter ( ) throw x path exception { executable . check all required params be present ( parameter ) ; bindery . define global parameter ( parameter ) ; }
public rule manager get rule manager ( ) { return rule manager ; }
public void set trace function destination ( print stream stream ) { trace function destination = stream ; }
public void set use document projection ( path map path map ) { this . path map = path map ; }
public void notify element node ( node info element ) { set system id ( element . get base u r i ( ) ) ; set line number ( element . get line number ( ) ) ; }
public void set timing ( boolean on ) { time = on ; }
public string get system id ( ) { final location provider location provider = parent . get location provider ( ) ; if ( location provider == null ) { return null ; } else { return location provider . get system id ( parent . get current location id ( ) ) ; } }
public final expression optimize ( expression visitor visitor , item type context item type ) { return this ; }
public string get system id ( ) { final location provider location provider = parent . get location provider ( ) ; if ( location provider == null ) { return null ; } else { return location provider . get system id ( parent . get current location id ( ) ) ; } }
public boolean get curly brace denote code block ( int language index ) { return true ; }
public property get output property ( ) { return output property ; }
public void namespace ( int namespace code , int property ) throw x path exception { int nc = new pool . allocate namespace code ( old pool . get prefix from namespace code ( namespace code ) , old pool . get u r i from namespace code ( namespace code ) ) ; next receiver . namespace ( nc , property ) ; }
public void set use xsi schema location ( boolean recognize ) { use xsi schema location = recognize ; }
public content handler proxy trace listener get trace listener ( ) { if ( trace listener == null ) { trace listener = new content handler proxy trace listener ( ) ; } return trace listener ; }
public final boolean have child node ( ) { return ( node nr+1 < tree . number of node & & tree . depth [ node nr+1 ] > tree . depth [ node nr ] ) ; }
public void end element ( ) throw x path exception { if ( in start tag ) { start content ( ) ; } outputter . end element ( ) ; if ( -- level == 0 ) { outputter . close ( ) ; node info element = builder . get current root ( ) ; append ( element , 0 , node info . all_namespaces ) ; } previous atomic = false ; }
public void set be x h t m l ( boolean xhtml ) { be x h t m l = xhtml ; if ( xhtml ) { require u r i code = get name pool ( ) . get code for u r i ( namespace constant . xhtml ) ; } else { require u r i code = 0 ; } }
public node info get element node ( ) throw x path exception { if ( element node == null ) { int len = buffer attribute . get length ( ) ; tiny builder builder = new tiny builder ( ) ; builder . set size parameter ( new int [ ] { 2 , len+2 , namespaces size+2 , 16 } ) ; builder . set pipeline configuration ( get pipeline configuration ( ) ) ; builder . open ( ) ; builder . start element ( element name code , standard name . xs_untyped_atomic , 0 , 0 ) ; for ( int i=0 ; i < namespaces size ; i++ ) { builder . namespace ( namespaces [ i ] , 0 ) ; } for ( int i=0 ; i < len ; i++ ) { builder . attribute ( buffer attribute . get name code ( i ) , standard name . xs_untyped_atomic , buffered attribute . get value ( i ) , 0 , 0 ) ; } builder . start content ( ) ; builder . end element ( ) ; element node = builder . get current root ( ) ; } return element node ; }
public final expression optimize ( expression visitor visitor , item type context item type ) { return this ; }
public void set system id ( string url ) { system id = url ; receiver . set system id ( url ) ; }
public void set source ( source s ) { if ( s == null ) { throw new illegal argument exception ( `` source must not be null `` ) ; } source = s ; }
public void open ( ) throw x path exception { if ( next receiver == null ) { throw new illegal state exception ( `` proxy receiver . open ( ) : no underlie receiver provide `` ) ; } next receiver . open ( ) ; }
public static string [ ] split ( string str , char separator char ) { if ( str == null ) { return null ; } int len = str . length ( ) ; if ( len == 0 ) { return empty_string_array ; } list list = new array list ( ) ; int i = 0 , start = 0 ; boolean match = false ; while ( i < len ) { if ( str . char at ( i ) == separator char ) { if ( match ) { list . add ( str . substring ( start , i ) ) ; match = false ; } start = ++i ; continue ; } match = true ; i++ ; } if ( match ) { list . add ( str . substring ( start , i ) ) ; } return ( string [ ] ) list . to array ( new string [ list . size ( ) ] ) ; }
public void end element ( ) throw x path exception { if ( in start tag ) { start content ( ) ; } outputter . end element ( ) ; if ( -- level == 0 ) { outputter . close ( ) ; node info element = builder . get current root ( ) ; append ( element , 0 , node info . all_namespaces ) ; } previous atomic = false ; }
public byte [ ] get ( ) { throw new unsupported operation exception ( `` code attribute . get ( ) `` ) ; }
public void set type code ( int type code ) { this . type code = type code ; }
public void strip type annotation ( ) { set type code ( standard name . xs_untyped ) ; if ( attribute ! = null ) { for ( int i=0 ; i < attribute . size ( ) ; i++ ) { node info att = ( node info ) attribute . get ( i ) ; if ( att . get type annotation ( ) ! = standard name . xs_untyped_atomic ) { orphan o = new orphan ( att . get configuration ( ) ) ; o . set node kind ( type . attribute ) ; o . set name code ( att . get name code ( ) ) ; o . set string value ( att . get string value ( ) ) ; o . set system id ( att . get system id ( ) ) ; o . set type annotation ( standard name . xs_untyped_atomic ) ; attribute . set ( i , o ) ; } } } }
public x m l stream reader get x m l stream reader ( ) { return reader ; }
public expression type check ( expression visitor visitor , item type context item type ) throw x path exception { operand = visitor . type check ( operand , context item type ) ; final type hierarchy th = visitor . get configuration ( ) . get type hierarchy ( ) ; if ( th . be sub type ( operand . get item type ( th ) , required item type ) ) { return operand ; } else if ( ! cardinality . allow many ( operand . get cardinality ( ) ) ) { cast expression cast = new cast expression ( operand , required item type , ( operand . get cardinality ( ) & static property . allows_zero ) ! = 0 ) ; expression tool . copy location info ( this , cast ) ; return cast ; } else { return this ; } }
public static char [ ] to primitive ( character [ ] array , char value for null ) { if ( array == null ) { return null ; } else if ( array . length == 0 ) { return empty_char_array ; } final char [ ] result = new char [ array . length ] ; for ( int i = 0 ; i < array . length ; i++ ) { character b = array [ i ] ; result [ i ] = ( b == null ? value for null : b . char value ( ) ) ; } return result ; }
public atomic type get target type ( ) { return target type ; }
public string collator get default collation ( ) { return get name collation ( default collation name ) ; }
public sequence iterator iterate ( x path context context ) throw x path exception { item item = context . get context item ( ) ; if ( item==null ) { dynamic error ( `` the context item be not set `` , get error code for undefined context ( ) , context ) ; } return singleton iterator . make iterator ( item ) ; }
public expression simplify ( expression visitor visitor ) throw x path exception { sequence = visitor . simplify ( sequence ) ; action = visitor . simplify ( action ) ; return this ; }
public t deserialize ( json parser parser , deserialization context ctx , type rt type ) { unmarshaller unmarshaller = ( unmarshaller ) ctx ; final json parser . event event = ( ( jsonb parser ) parser ) . get current level ( ) . get last event ( ) ; if ( event == json parser . event . value_null ) { return null ; } final string value = parser . get string ( ) ; return deserialize ( value , unmarshaller , rt type ) ; }
public container get container ( ) { return container ; }
public string get system id ( ) { if ( location id == -1 ) { return null ; } executable exec = get executable ( ) ; if ( exec == null ) { return null ; } location map map = exec . get location map ( ) ; if ( map == null ) { return null ; } return map . get system id ( location id ) ; }
public int get cardinality ( ) { if ( static property == -1 ) { compute static property ( ) ; } return static property & static property . cardinality_mask ; }
protect int determine kind ( i resource underlie resource ) { return i package fragment root . k_binary ; }
public void cookie ( string name , string value , int max age ) { cookie ( name , value , max age , false ) ; }
protect void dynamic error ( string message , string code , x path context context ) throw x path exception { x path exception err = new x path exception ( message , this ) ; err . set x path context ( context ) ; err . set error code ( code ) ; throw err ; }
public int get line number ( ) { if ( location id == -1 ) { return -1 ; } return location id & 0xfffff ; }
public expression visitor make expression visitor ( ) { expression visitor visitor = expression visitor . make ( static context ) ; visitor . set executable ( get executable ( ) ) ; return visitor ; }
public void set stack ( stack stack ) { this . stack = stack ; }
public expression type check ( expression visitor visitor , item type context item type ) throw x path exception { operand = visitor . type check ( operand , context item type ) ; final type hierarchy th = visitor . get configuration ( ) . get type hierarchy ( ) ; if ( th . be sub type ( operand . get item type ( th ) , required item type ) ) { return operand ; } else if ( ! cardinality . allow many ( operand . get cardinality ( ) ) ) { cast expression cast = new cast expression ( operand , required item type , ( operand . get cardinality ( ) & static property . allows_zero ) ! = 0 ) ; expression tool . copy location info ( this , cast ) ; return cast ; } else { return this ; } }
public structure q name get position variable name ( ) { if ( position variable == null ) { return null ; } else { return position variable . get variable q name ( ) ; } }
public expression copy ( ) { if ( bind == null ) { throw new unsupported operation exception ( `` can not copy a variable reference whose binding be unknown `` ) ; } local variable reference ref = new local variable reference ( ) ; ref . bind = binding ; ref . static type = static type ; ref . slot number = slot number ; ref . constant value = constant value ; ref . display name = display name ; expression tool . copy location info ( this , ref ) ; return ref ; }
public final item type get item type ( type hierarchy th ) { if ( literal . be empty sequence ( finally exp ) ) { return action . get item type ( th ) ; } else { return type . get common super type ( action . get item type ( th ) , finally exp . get item type ( th ) , th ) ; } }
public expression find parent of ( expression leaf ) { for ( iterator child = iterate sub expression ( ) ; child . have next ( ) ; ) { expression child = ( expression ) child . next ( ) ; if ( child == leaf ) { return this ; } else { expression target = child . find parent of ( leaf ) ; if ( target ! = null ) { return target ; } } } return null ; }
public void set slot number ( int slot number ) { this . slot number = slot number ; }
public boolean have next ( ) { return ! go ; }
public final item type get item type ( type hierarchy th ) { if ( literal . be empty sequence ( finally exp ) ) { return action . get item type ( th ) ; } else { return type . get common super type ( action . get item type ( th ) , finally exp . get item type ( th ) , th ) ; } }
public value representation evaluate variable ( x path context context ) throw x path exception { value representation actual = context . evaluate local variable ( slot number ) ; if ( actual instanceof memo closure & & ( ( memo closure ) actual ) . be fully read ( ) ) { actual = ( ( memo closure ) actual ) . materialize ( ) ; context . set local variable ( slot number , actual ) ; } return actual ; }
public expression optimize ( expression visitor visitor , item type context item type ) throw x path exception { operand = visitor . optimize ( operand , context item type ) ; return this ; }
public expression promote ( promotion offer offer ) throw x path exception { for ( int i = 0 ; i < argument . length ; i++ ) { if ( argument [ i ] ! = null ) { argument [ i ] = do promotion ( argument [ i ] , offer ) ; } } return this ; }
public int get line number ( ) { if ( location id == -1 ) { return -1 ; } return location id & 0xfffff ; }
public final sequence iterator map ( x path context context ) throw x path exception { return step . iterate ( context ) ; }
public item next ( ) throw x path exception { current = get next matching item ( ) ; if ( current == null ) { position = -1 ; } else { position++ ; } return current ; }
public boolean equal ( object o ) { / * hmmh . since there 's just a singleton instance , this fail in all case but with * identity comparison . however : if this placeholder value be to be consider * similar to sql null , it should n't even equal itself ? * that might cause problem when deal with collection like set . . . * so for now , let 's let identity comparison return true . * / return ( o == this ) ; }
public void process ( x path context context ) throw x path exception { expression next = operand ; item type type = type . item_type ; if ( next instanceof item checker ) { type = ( ( item checker ) next ) . get require type ( ) ; next = ( ( item checker ) next ) . get base expression ( ) ; } if ( ( next . get implementation method ( ) & process_method ) ! = 0 & & ! ( type instanceof document node test ) ) { sequence receiver out = context . get receiver ( ) ; type checking filter filter = new type checking filter ( ) ; filter . set underlying receiver ( out ) ; filter . set pipeline configuration ( out . get pipeline configuration ( ) ) ; filter . set require type ( type , required cardinality , role ) ; context . set receiver ( filter ) ; next . process ( context ) ; filter . close ( ) ; context . set receiver ( out ) ; } else { super . process ( context ) ; } }
public item type get item type ( type hierarchy th ) { return operand . get item type ( th ) ; }
public boolean be confirm ( ) { return confirm ; }
public void fixup ( bind binding ) { this . bind = binding ; reset local static property ( ) ; }
public void process ( x path context context ) throw x path exception { value representation [ ] actual args = evaluate argument ( context ) ; if ( tail call ) { ( ( x path context major ) context ) . request tail call ( function , actual args ) ; } else { sequence receiver out = context . get receiver ( ) ; x path context major c2 = context . new clean context ( ) ; c2 . set receiver ( out ) ; c2 . set origin ( this ) ; function . process ( actual args , c2 ) ; } }
public final int get offset ( readable instant instant ) { if ( instant == null ) { return get offset ( date time utils . current time millis ( ) ) ; } return get offset ( instant . get millis ( ) ) ; }
public static double day in year ( string date time ) { int month= ( int ) month in year ( date time ) ; int day = ( int ) day in month ( date time ) ; int [ ] prev = { 0 , 31 , 31+28 , 31+28+31 , 31+28+31+30 , 31+28+31+30+31 , 31+28+31+30+31+30 , 31+28+31+30+31+30+31 , 31+28+31+30+31+30+31+31 , 31+28+31+30+31+30+31+31+30 , 31+28+31+30+31+30+31+31+30+31 , 31+28+31+30+31+30+31+31+30+31+30 , 31+28+31+30+31+30+31+31+30+31+30+31 } ; int leap = ( month > 2 & & leap year ( date time ) ? 1 : 0 ) ; return prev [ month-1 ] + leap + day ; }
public static double week in month ( string date time ) { return ( double ) ( int ) ( ( day in month ( date time ) -1 ) / 7 + 1 ) ; }
public static double day of week in month ( string date time ) { double dd = day in month ( date time ) ; if ( double . be na n ( dd ) ) { return dd ; } return ( ( ( int ) dd ) - 1 ) / 7 + 1 ; }
public string get static base u r i ( ) { return expression base u r i ; }
public sequence iterator iterate ( x path context context ) throw x path exception { generic atomic comparer comparer = get atomic comparer ( 2 , context ) ; sequence iterator seq = argument [ 0 ] . iterate ( context ) ; atomic value val = ( atomic value ) argument [ 1 ] . evaluate item ( context ) ; return new index iterator ( seq , val , comparer ) ; }
public class get target class ( ) { return the class ; }
public void explain global function ( expression presenter out ) { iterator iter = function . value ( ) . iterator ( ) ; while ( iter . have next ( ) ) { x query function fn = ( x query function ) iter . next ( ) ; fn . explain ( out ) ; } }
public function library get ( int n ) { return ( function library ) library list . get ( n ) ; }
public static sequence iterator get id single ( document info doc , string idrefs ) throw x path exception { boolean white = false ; for ( int i=idrefs . length ( ) -1 ; i > =0 ; i -- ) { char c = idrefs . char at ( i ) ; if ( c < = 0x20 & & ( c == 0x20 || c == 0x09 || c == 0x0a || c == 0x0d ) ) { white = true ; break ; } } if ( white ) { string token iterator token = new string token iterator ( idrefs ) ; id mapping function map = new id mapping function ( ) ; map . document = doc ; sequence iterator result = new mapping iterator ( token , map ) ; return new document order iterator ( result , local order comparer . get instance ( ) ) ; } else { return singleton iterator . make iterator ( doc . select i d ( idrefs ) ) ; } }
public static boolean be constant boolean ( expression exp , boolean value ) { if ( exp instanceof literal ) { value b = ( ( literal ) exp ) . get value ( ) ; return ( b instanceof boolean value & & ( ( boolean value ) b ) . get boolean value ( ) == value ) ; } return false ; }
public expression bind ( structure q name function name , expression [ ] argument , static context env ) throw x path exception { if ( resolve ) { return null ; } user function call ufc = new user function call ( ) ; ufc . set function name ( function name ) ; ufc . set argument ( argument ) ; unbound function call . add ( ufc ) ; correspond static context . add ( env ) ; return ufc ; }
public void set detail ( standard function . entry entry ) { detail = entry ; operation = detail . opcode ; }
public void set system id ( string url ) { system id = url ; receiver . set system id ( url ) ; }
public expression get non match expression ( ) { return non match ; }
public simple type get schema type ( ) { return schema type ; }
public void define global parameter ( global parameter set params ) { global parameter = params ; }
public void set child ( expression [ ] child ) { if ( children==null || child . length==0 ) { this . child = null ; } else { this . child = child ; for ( int c=0 ; c < child . length ; c++ ) { adopt child expression ( child [ c ] ) ; } } }
public boolean be preserve type ( ) { return preserve type ; }
public void set location map ( location map map ) { location map = map ; }
public slot manager get global variable map ( ) { if ( global variable map == null ) { global variable map = config . make slot manager ( ) ; } return global variable map ; }
public decimal format manager get decimal format manager ( ) { if ( decimal format manager == null ) { decimal format manager = new decimal format manager ( ) ; } return decimal format manager ; }
public collation map get collation table ( ) { if ( collation table == null ) { collation table = new collation map ( config ) ; } return collation table ; }
public void set assignable ( boolean assignable ) { if ( assignable ) { property |= assignable ; } else { property & = ~assignable ; } }
public void set assignable ( boolean assignable ) { if ( assignable ) { property |= assignable ; } else { property & = ~assignable ; } }
public void enable buffering ( int buffer size ) { precondition . check state ( ! be committed & & ( this . buffer == null || this . buffer . size ( ) == 0 ) , committing_stream_buffering_illegal_state ) ; this . buffer size = buffer size ; if ( buffer size < = 0 ) { this . direct write = true ; this . buffer = null ; } else { direct write = false ; buffer = new byte array output stream ( buffer size ) ; } }
public void set host language ( int language ) { host language = language ; }
public void set line number ( int line number ) { this . line number = line number ; }
public int get line number ( ) { return line number ; }
public void set content ( expression content ) { this . content = content ; adopt child expression ( content ) ; }
public boolean have require params ( ) { return have require params ; }
public sequence type get require type ( ) { if ( require type == null ) { return sequence type . any_sequence ; } else { return require type ; } }
public void set tail recursive ( boolean tail call , boolean recursive tail call ) { this . tail call = tail call ; tail recursive = recursive tail call ; }
public value representation evaluate variable ( x path context context ) throw x path exception { return context . evaluate local variable ( slot number ) ; }
public boolean be number instruction ( ) { return be number instruction ; }
public void set name ( string name ) { this . name = name ; }
public void declare java class ( function library library , string uri , class the class ) { if ( library instanceof java extension library ) { ( ( java extension library ) library ) . declare java class ( uri , the class ) ; } else { throw new illegal state exception ( `` saxon : script can not be use with a custom extension library factory `` ) ; } }
public sequence iterator get reverse iterator ( ) { return new reverse array iterator ( item , start , end ) ; }
public static int get digit value ( int in ) { for ( int z=0 ; z < zero digit . length ; z++ ) { if ( in < = zero digit [ z ] +9 ) { if ( in > = zero digit [ z ] ) { return in - zero digit [ z ] ; } else { return -1 ; } } } return -1 ; }
public string get js type ( ) { return this . j type ; }
public int get last position ( ) { return end - start ; }
protect double get domain low bound ( double p ) { return 0 ; }
protect double get domain low bound ( double p ) { return 0 ; }
public void append ( char [ ] src array , int start , int length ) { ensure capacity ( length ) ; system . arraycopy ( src array , start , array , use , length ) ; use += length ; }
public char sequence condense ( ) { if ( array . length - use > 256 || ( array . length > use * 2 & & array . length - use > 20 ) ) { char [ ] array2 = new char [ use ] ; system . arraycopy ( array , 0 , array2 , 0 , use ) ; array = array2 ; } return this ; }
public void prepend repeat ( char ch , int repeat ) { if ( repeat > 0 ) { char [ ] a2 = new char [ array . length + repeat ] ; system . arraycopy ( array , 0 , a2 , repeat , use ) ; array . fill ( a2 , 0 , repeat , ch ) ; use += repeat ; array = a2 ; } }
public boolean be n c name char ( int ch ) { return x m l character data . be n c name10 ( ch ) ; }
public synchronize void diagnostic dump ( ) { system . err . println ( `` content of name pool `` + this ) ; for ( int i = 0 ; i < 1024 ; i++ ) { name entry entry = hashslots [ i ] ; int depth = 0 ; while ( entry ! = null ) { system . err . println ( `` fingerprint `` + depth + '/ ' + i ) ; system . err . println ( `` local name = `` + entry . local name + `` uri code = `` + entry . uri code ) ; entry = entry . next entry ; depth++ ; } } for ( int p = 0 ; p < prefix use ; p++ ) { system . err . println ( `` prefix `` + p + `` = `` + prefix [ p ] ) ; } for ( int u = 0 ; u < uris use ; u++ ) { system . err . println ( `` uri `` + u + `` = `` + uris [ u ] ) ; fast string buffer fsb = new fast string buffer ( 100 ) ; for ( int p=0 ; p < prefix for uri [ u ] . length ; p++ ) { fsb . append ( prefix for uri [ u ] [ p ] ) ; fsb . append ( `` , `` ) ; } system . err . println ( `` prefix for uri `` + u + `` = `` + fsb . to string ( ) ) ; } }
public static boolean be valid name ( string name ) { if ( name . length ( ) == 0 ) return false ; char ch = name . char at ( 0 ) ; if ( be name start ( ch ) == false ) return false ; for ( int i = 1 ; i < name . length ( ) ; i++ ) { ch = name . char at ( i ) ; if ( be name ( ch ) == false ) { return false ; } } return true ; } // be valid name ( string ) : boolean
public synchronize short allocate code for u r i ( string uri ) { if ( uri == null ) { return namespace constant . null_code ; } for ( short j = 0 ; j < uris use ; j++ ) { if ( uris [ j ] . equal ( uri ) ) { return j ; } } if ( uris use > = uris . length ) { if ( uris use > 32000 ) { throw new name pool limit exception ( `` too many namespace u r be `` ) ; } string [ ] [ ] p = new string [ uris use * 2 ] [ 0 ] ; string [ ] u = new string [ uris use * 2 ] ; system . arraycopy ( prefix for uri , 0 , p , 0 , uris use ) ; system . arraycopy ( uris , 0 , u , 0 , uris use ) ; prefix for uri = p ; uris = u ; } uris [ uris use ] = uri ; return uris used++ ; }
public static char low surrogate ( int c ) { return ( char ) ( ( ( c - 0x00010000 ) & 0x3 f f ) + 0x d c00 ) ; }
public short get code for u r i ( string uri ) { for ( short j = 0 ; j < uris use ; j++ ) { if ( uris [ j ] . equal ( uri ) ) { return j ; } } return -1 ; }
public void set client data ( class key , object value ) { if ( client data == null ) { client data = new hash map ( 10 ) ; } client data . put ( key , value ) ; }
public iterator get unparsed entity name ( ) { return ( ( document info ) node ) . get unparsed entity name ( ) ; }
public string get local name ( ) { return new string ( content , local name start , prefix start - local name start ) ; }
public int get fingerprint ( ) { return original . get fingerprint ( ) ; }
public boolean be id ( ) { return original . be id ( ) ; }
public string get base u r i ( ) { return navigator . get base u r i ( this ) ; }
public node info get parent ( ) { if ( original . be same node info ( root ) ) { return null ; } if ( parent == null ) { node info basep = original . get parent ( ) ; if ( basep == null ) { return null ; } parent = wrap ( basep ) ; parent . set document number ( document number ) ; } return parent ; }
public int hash code ( ) { return original . hash code ( ) ^ ( document number < < 19 ) ; }
public node info get parent ( ) { if ( original . be same node info ( root ) ) { return null ; } if ( parent == null ) { node info basep = original . get parent ( ) ; if ( basep == null ) { return null ; } parent = wrap ( basep ) ; parent . set document number ( document number ) ; } return parent ; }
public int get fingerprint ( ) { return original . get fingerprint ( ) ; }
public boolean be nilled ( ) { return original . be nilled ( ) ; }
public boolean match ( tiny tree tree , int node nr ) { int node kind = tree . node kind [ node nr ] ; return ( node kind == type . element || node kind == type . text || node kind == type . whitespace_text || node kind == type . comment || node kind == type . processing_instruction ) ; }
public boolean match d t d type ( ) { return match d t d type ; }
protected item type get return item type ( ) { return any item type . get instance ( ) ; }
public void promote ( promotion offer offer ) throw x path exception { id expression = id expression . promote ( offer ) ; }
public void resolve current ( let expression let , promotion offer offer , boolean top level ) throw x path exception { for ( int i = 0 ; i < number of filter ; i++ ) { filter [ i ] = filter [ i ] . promote ( offer ) ; } if ( parent pattern instanceof location path pattern ) { ( ( location path pattern ) parent pattern ) . resolve current ( let , offer , false ) ; } if ( ancestor pattern instanceof location path pattern ) { ( ( location path pattern ) ancestor pattern ) . resolve current ( let , offer , false ) ; } if ( top level ) { variable bind = let ; } }
public item type get super type ( type hierarchy th ) { return node kind test . make node kind test ( node kind ) ; }
public item type get super type ( type hierarchy th ) { return node kind test . make node kind test ( node kind ) ; }
public void explain ( expression presenter out ) { out . start element ( `` query `` ) ; static context . get executable ( ) . get key manager ( ) . explain key ( out ) ; static context . get executable ( ) . explain global variable ( out ) ; static context . explain global function ( out ) ; out . start element ( `` body `` ) ; expression . explain ( out ) ; out . end element ( ) ; out . end element ( ) ; out . close ( ) ; }
public string get namespace u r i ( string prefix ) { if ( prefix . equal ( `` xmlns `` ) ) { return `` http : //www . w3 . org/2000/xmlns/ `` ; } return resolver . get u r i for prefix ( prefix , true ) ; }
public name pool get name pool ( ) { return pipe . get configuration ( ) . get name pool ( ) ; }
public void set trace listener ( trace listener listener ) { trace listener = listener ; }
public int get line number ( ) { return line number ; }
public structure q name get variable q name ( ) { return variable name ; }
public boolean be preserve namespaces ( ) { return preserve namespaces ; }
public int get construction mode ( ) { return construction mode ; }
public void optimize global function ( ) throw x path exception { global function library . optimize global function ( ) ; }
public boolean be inherit namespaces ( ) { return inherit namespaces ; }
public boolean be main module ( ) { return be main module ; }
public boolean be generate java code ( ) { return generate code ; }
public void set require context item type ( item type type ) { require context item type = type ; }
public structure q name [ ] get external variable name ( ) { list list = stack frame map . get variable map ( ) ; structure q name [ ] names = new structured q name [ stack frame map . get number of variable ( ) ] ; for ( int i = 0 ; i < name . length ; i++ ) { names [ i ] = ( structure q name ) list . get ( i ) ; } return name ; }
public x query function library get local function library ( ) { return ( x query function library ) function library list . get ( local function library nr ) ; }
public boolean start with ( char sequence prefix ) { return start with ( prefix , 0 ) ; }
public expression get condition ( ) { return condition ; }
public int get element particle cardinality ( int fingerprint , boolean search extension type ) { return static property . allows_zero_or_more ; }
public list get current group ( ) { return ( array list ) group . get ( position-1 ) ; }
public boolean contain all ( int set other ) { int iterator it = other . iterator ( ) ; while ( it . have next ( ) ) { if ( ! contains ( it . next ( ) ) ) { return false ; } } return true ; }
public int [ ] get start point ( ) { return start point ; }
public sort key definition simplify ( expression visitor visitor ) throw x path exception { sort key = visitor . simplify ( sort key ) ; order = visitor . simplify ( order ) ; data type expression = visitor . simplify ( data type expression ) ; case order = visitor . simplify ( case order ) ; language = visitor . simplify ( language ) ; stable = visitor . simplify ( stable ) ; return this ; }
public void set base u r i ( string base u r i ) { this . base u r i = base u r i ; }
public atomic comparer [ ] get comparators ( ) { return comparators ; }
public void set recovery policy ( int policy ) { recovery policy = policy ; if ( error listener instanceof standard error listener ) { ( ( standard error listener ) error listener ) . set recovery policy ( policy ) ; } }
public object get property ( string name ) { if ( `` name `` . equal ( name ) ) { return function name . get display name ( ) ; } else if ( `` a `` . equal ( name ) ) { return result type . to string ( ) ; } else { return null ; } }
public boolean be top level ( ) { return ( get parent ( ) instanceof x s l stylesheet ) ; }
protect double get domain low bound ( double p ) { return 0 ; }
public boolean be top level ( ) { return ( get parent ( ) instanceof x s l stylesheet ) ; }
public boolean backwards compatible mode be enable ( ) { return get version ( ) . compare to ( big decimal . value of ( 2 ) ) < 0 ; }
public boolean be extension namespace ( short uri code ) { node info anc = this ; while ( anc instanceof style element ) { if ( ( ( style element ) anc ) . defines extension element ( uri code ) ) { return true ; } anc = anc . get parent ( ) ; } return false ; }
public string get attribute value ( string clark name ) { int fp = get name pool ( ) . allocate clark name ( clark name ) ; return get attribute value ( fp ) ; }
public static context get static context ( ) { if ( static context == null ) { static context = new expression context ( this ) ; } return static context ; }
public slot manager get slot manager ( ) { return stack frame map ; }
public boolean get curly brace denote code block ( int language index ) { return true ; }
public slot manager get slot manager ( ) { return stack frame map ; }
protected item type get return item type ( ) { if ( require type==null ) { return get common child item type ( ) ; } else { return require type . get primary type ( ) ; } }
public void set input type annotation ( int annotation ) throw x path exception { input annotation |= annotation ; if ( input annotation == ( annotation_strip | annotation_preserve ) ) { compile error ( `` one stylesheet module specify input-type-annotations='strip ' , `` + `` another specifies input-type-annotations='preserve ' `` , `` xtse0265 `` ) ; } }
public void set min import precedence ( int precedence ) { min import precedence = precedence ; }
public void set input type annotation ( int annotation ) throw x path exception { input annotation |= annotation ; if ( input annotation == ( annotation_strip | annotation_preserve ) ) { compile error ( `` one stylesheet module specify input-type-annotations='strip ' , `` + `` another specifies input-type-annotations='preserve ' `` , `` xtse0265 `` ) ; } }
public x s l variable declaration get global variable ( structure q name q name ) { return ( x s l variable declaration ) global variable index . get ( q name ) ; }
protect void set configuration ( configuration config ) { this . config = config ; executable = new executable ( config ) ; executable . set host language ( configuration . xpath ) ; }
public void clear all namespaces ( ) { namespaces . clear ( ) ; declare namespace ( `` xml `` , namespace constant . xml ) ; declare namespace ( `` `` , `` `` ) ; }
public int get slot number ( q name value qname ) { structured q name sq = qname . to structured q name ( ) ; x path variable var = ( x path variable ) variable . get ( sq ) ; if ( var == null ) { return -1 ; } return var . get local slot number ( ) ; }
public void set namespace resolver ( namespace resolver namespace resolver ) { static context . set namespace resolver ( namespace resolver ) ; }
public x path expression create expression ( string expression ) throw x path exception { expression exp = expression tool . make ( expression , static context , 0 , -1 , 1 , false ) ; exp . set container ( static context ) ; expression visitor visitor = expression visitor . make ( static context ) ; visitor . set executable ( get executable ( ) ) ; exp = visitor . type check ( exp , type . item_type ) ; exp = visitor . optimize ( exp , type . item_type ) ; slot manager map = static context . get stack frame map ( ) ; int number of external variable = map . get number of variable ( ) ; expression tool . allocate slot ( exp , number of external variable , map ) ; x path expression xpe = new x path expression ( this , exp ) ; xpe . set stack frame map ( map , number of external variable ) ; return xpe ; }
protect double get domain low bound ( double p ) { return 0 ; }
public tail call process leave tail ( x path context context ) throw x path exception { context . set local variable ( get slot number ( ) , expression tool . evaluate ( get select expression ( ) , evaluation mode , context , 10 ) ) ; return null ; }
public void copy to ( char [ ] destination , int d offset ) { system . arraycopy ( array , offset , destination , d offset , count ) ; }
public void write escape ( boolean [ ] special char , output stream stream ) throw java . io . i o exception { final long val = value ; for ( int s=56 ; s > =0 ; s-=8 ) { final byte b = ( byte ) ( ( val > > > s ) & 0xff ) ; if ( b == 0 ) { break ; } final char c = white_chars [ b > > > 6 & 0x3 ] ; final int len = ( b & 0x3f ) ; if ( special char [ c ] ) { byte [ ] e ; if ( c=='\n ' ) { e = escape_n ; } else if ( c=='\r ' ) { e = escape_r ; } else { e = escape_t ; } for ( int j=0 ; j < len ; j++ ) { stream . write ( e ) ; } } else { for ( int j=0 ; j < len ; j++ ) { stream . write ( c ) ; } } } }
public boolean content equal ignore case ( char sequence string ) { if ( this == string ) { return true ; } if ( string == null || string . length ( ) ! = length ( ) ) { return false ; } if ( string instanceof ascii string ) { ascii string rh = ( ascii string ) string ; for ( int i = array offset ( ) , j = rh . array offset ( ) , end = i + length ( ) ; i < end ; ++i , ++j ) { if ( ! equal ignore case ( value [ i ] , rh . value [ j ] ) ) { return false ; } } return true ; } for ( int i = array offset ( ) , j = 0 , end = length ( ) ; j < end ; ++i , ++j ) { if ( ! equal ignore case ( b2c ( value [ i ] ) , string . char at ( j ) ) ) { return false ; } } return true ; }
public void dump data structure ( ) { system . err . println ( `` * * segment : `` ) ; for ( int s=0 ; s < segment . size ( ) ; s++ ) { system . err . println ( `` seg `` + s + `` start offset `` + start offset [ s ] + `` length `` + ( ( fast string buffer ) segment . get ( s ) ) . length ( ) ) ; } }
public int get type annotation ( int index ) { if ( tree . att type code == null ) { return standard name . xs_untyped_atomic ; } return tree . att type code [ first attribute + index ] ; }
public final string get u r i ( ) { return tree . get name pool ( ) . get u r i ( tree . att code [ node nr ] ) ; }
public final string get u r i ( ) { return tree . get name pool ( ) . get u r i ( tree . att code [ node nr ] ) ; }
public void flush ( ) throw j s o n exception { pad ( 8 ) ; }
public final boolean have child node ( ) { return ( node nr+1 < tree . number of node & & tree . depth [ node nr+1 ] > tree . depth [ node nr ] ) ; }
public void set system id ( string uri ) { this . module uri = uri ; }
public int get line number ( ) { return line number ; }
public void start subsidiary element ( string name ) { start element ( name ) ; }
public void leave ( instruction info element ) { ( ( trace listener ) a ) . leave ( element ) ; ( ( trace listener ) b ) . leave ( element ) ; }
public void enter ( instruction info element , x path context context ) { ( ( trace listener ) a ) . enter ( element , context ) ; ( ( trace listener ) b ) . enter ( element , context ) ; }
public object get instance ( string class name , class loader class loader ) throw x path exception { class theclass = get class ( class name , false , class loader ) ; try { return theclass . new instance ( ) ; } catch ( exception err ) { throw new x path exception ( `` fail to instantiate class `` + class name , err ) ; } }
public boolean be backwards compatible ( ) { return backwards compatible ; }
public void set convert untyped to other ( boolean convert to other ) { convert untyped to other = convert to other ; }
public build in atomic type get indexed item type ( ) { if ( use type == null ) { return build in atomic type . any_atomic ; } else { return use type ; } }
public mode get default mode ( ) { return default mode ; }
public void maybe set context ( x path context context ) { if ( get x path context ( ) == null ) { set x path context ( context ) ; } }
public string map path ( string path ) { return null ; }
public int get line number ( ) { return line number ; }
public void graft element ( element impl element ) throw x path exception { current node . add child ( element , size [ depth ] ++ ) ; }
public final item next ( ) { if ( next==null ) { current = null ; position = -1 ; return null ; } else { current = next ; position++ ; advance ( ) ; return current ; } }
public final item next ( ) { if ( next==null ) { current = null ; position = -1 ; return null ; } else { current = next ; position++ ; advance ( ) ; return current ; } }
public boolean get curly brace denote code block ( int language index ) { return true ; }
protect double get domain low bound ( double p ) { return 0 ; }
public schema type get element particle type ( int fingerprint , boolean consider extension ) { return this ; }
protect double get domain low bound ( double p ) { return 0 ; }
public boolean get curly brace denote code block ( int language index ) { return true ; }
public schema type get element particle type ( int fingerprint , boolean consider extension ) { return this ; }
public static x path exception ebv error ( expression exp , type hierarchy th ) { if ( cardinality . allow zero ( exp . get cardinality ( ) ) ) { return null ; } item type t = exp . get item type ( th ) ; if ( th . relationship ( t , type . node_type ) == type hierarchy . disjoint & & th . relationship ( t , build in atomic type . boolean ) == type hierarchy . disjoint & & th . relationship ( t , build in atomic type . string ) == type hierarchy . disjoint & & th . relationship ( t , build in atomic type . any_uri ) == type hierarchy . disjoint & & th . relationship ( t , build in atomic type . untyped_atomic ) == type hierarchy . disjoint & & th . relationship ( t , build in atomic type . numeric ) == type hierarchy . disjoint & & ! ( t instanceof external object type ) ) { x path exception err = new x path exception ( `` effective boolean value be define only for sequence contain `` + `` booleans , string , number , u r be , or node `` ) ; err . set error code ( `` forg0006 `` ) ; err . set be type error ( true ) ; return err ; } return null ; }
public type hierarchy get type hierarchy ( ) { return config . get type hierarchy ( ) ; }
public void set constraint reference ( validation exception e ) { schema part = e . schema part ; constraint name = e . constraint name ; constraint clause number = e . constraint clause number ; }
public string get constraint reference message ( ) { if ( schema part == -1 ) { return null ; } return `` see http : //www . w3 . org/ t r/xmlschema- `` + schema part + `` / # `` + constraint name + `` clause `` + constraint clause number ; }
public sequence iterator iterate ( ) throw x path exception { return singleton iterator . make iterator ( a item ( ) ) ; }
public static sequence iterator make ( sequence iterator base , int min , int max ) throw x path exception { if ( base instanceof array iterator ) { return ( ( array iterator ) base ) . make slice iterator ( min , max ) ; } else if ( max == integer . max_value ) { return tail iterator . make ( base , min ) ; } else if ( base instanceof ground iterator & & min > 4 ) { ground value value = ( ( ground iterator ) base ) . materialize ( ) ; value = value . subsequence ( min-1 , max-min+1 ) ; return ( ( value ) value ) . iterate ( ) ; } else { return new subsequence iterator ( base , min , max ) ; } }
public final calendar value remove timezone ( ) { calendar value c = ( calendar value ) copy a sub type ( type label ) ; c . tz minute = no_timezone ; return c ; }
public final void append timezone ( fast string buffer sb ) { if ( have timezone ( ) ) { append timezone ( get timezone in minute ( ) , sb ) ; } }
public int compute cardinality ( ) { if ( cardinality . allow zero ( operand0 . get cardinality ( ) ) || cardinality . allow zero ( operand1 . get cardinality ( ) ) ) { return static property . allows_zero_or_one ; } else { return static property . exactly_one ; } }
public static string get product title ( ) { return get product name ( ) + ' ' + get product version ( ) + `` from saxonica `` ; }
public browser configuration option set profile ( string profile ) { put ( profile_name , profile ) ; return this ; }
public static char [ ] to primitive ( character [ ] array ) { if ( array == null ) { return null ; } else if ( array . length == 0 ) { return empty_char_array ; } final char [ ] result = new char [ array . length ] ; for ( int i = 0 ; i < array . length ; i++ ) { result [ i ] = array [ i ] . char value ( ) ; } return result ; }
public void perform ( ) { move to location ( ) ; mouse . context click ( get action location ( ) ) ; }
public void add entry ( string log type , log entry entry ) { if ( ! log type to include . contains ( log type ) ) { return ; } if ( ! local log . contains key ( log type ) ) { local log . put ( log type , list . new array list ( entry ) ) ; } else { local log . get ( log type ) . add ( entry ) ; } }
public final boolean support ( s q l dialect other ) { if ( family ! = other . family ) return false ; if ( be family ( ) || other . be family ( ) ) return true ; return other . precedes ( this ) ; }
public int get major version ( ) { return major version ; }
public proxy set sock proxy ( string sock proxy ) { verify proxy type compatibility ( proxy type . manual ) ; this . proxy type = proxy type . manual ; this . sock proxy = sock proxy ; return this ; }
public static command < response body > get response body ( request id request id ) { object . require non null ( request id , `` request id be require `` ) ; return new command < > ( `` fetch . get response body `` , immutable map . of ( `` request id `` , request id . to string ( ) ) , map ( `` body `` , response body . class ) ) ; }
public integer get column number ( ) { return column number ; }
public string get method ( ) { return method ; }
public string get url ( ) { return url ; }
public double get worker ready ( ) { return worker ready ; }
public string get url ( ) { return url ; }
public string get status text ( ) { return status text ; }
public boolean get from disk cache ( ) { return from disk cache ; }
public security detail get security detail ( ) { return security detail ; }
public double get valid to ( ) { return valid to ; }
public integer get certificate id ( ) { return certificate id ; }
public list < sign exchange error > get error ( ) { return error ; }
public static command < void > disable ( ) { return new command < > ( domain_name + `` . disable `` , immutable map . of ( ) ) ; }
public static command < response body > get response body ( request id request id ) { object . require non null ( request id , `` request id must be set . `` ) ; return new command < > ( domain_name + `` . get response body `` , immutable map . of ( `` request id `` , request id . to string ( ) ) , map ( `` body `` , response body . class ) ) ; }
public static command < response body > get response body ( request id request id ) { object . require non null ( request id , `` request id must be set . `` ) ; return new command < > ( domain_name + `` . get response body `` , immutable map . of ( `` request id `` , request id . to string ( ) ) , map ( `` body `` , response body . class ) ) ; }
public static command < response body > get response body ( request id request id ) { object . require non null ( request id , `` request id must be set . `` ) ; return new command < > ( domain_name + `` . get response body `` , immutable map . of ( `` request id `` , request id . to string ( ) ) , map ( `` body `` , response body . class ) ) ; }
public static event < request will be send > request will be send ( ) { return new event < > ( domain_name + `` . request will be send `` , map ( `` request id `` , request will be send . class ) ) ; }
public static event < web socket frame > web socket frame receive ( ) { return new event < > ( domain_name + `` . web socket frame receive `` , map ( `` request id `` , web socket frame . class ) ) ; }
public static command < set < target info > > get target ( ) { return new command < > ( `` target . get target `` , immutable map . of ( ) , converter function . map ( `` target infos `` , new type token < set < target info > > ( ) { } . get type ( ) ) ) ; }
public static command < browser context i d > create browser context ( ) { return new command < > ( `` target . create browser context `` , immutable map . of ( ) , converter function . map ( `` browser context id `` , browser context i d . class ) ) ; }
public static event < target info > target info change ( ) { return new event < > ( `` target . target info change `` , map ( `` target info `` , target info . class ) ) ; }
public input stream consume content stream ( ) { return get content ( ) . get ( ) ; }
public logging preference add preference ( log preference prefs ) { if ( prefs == null ) { return this ; } for ( string log type : prefs . get enabled log type ( ) ) { enable ( log type , prefs . get level ( log type ) ) ; } return this ; }
protect static string [ ] get file system counter name ( string uri scheme ) { string scheme = string utils . to upper case ( uri scheme ) ; return new string [ ] { scheme+ `` _bytes_read `` , scheme+ `` _bytes_written `` } ; }
public final void serialize ( json generator g , serializer provider provider ) throw i o exception { / * nothing to output . . . should we signal an error tho ? * chance be , this be an erroneous call . for now , let 's * not do that ; serialize a explicit null . why ? because we * can not just omit a value a json object field name may have * be write out . * / g . write null ( ) ; }
public list < string > get without servlets ( ) { return without servlets ; }
public integer get node polling ( ) { return node polling ; }
public web element find element ( ) { if ( cached element ! = null & & should cache ( ) ) { return cache element ; } web element element = search context . find element ( by ) ; if ( should cache ( ) ) { cached element = element ; } return element ; }
public < k extend throwable > fluent wait < t > ignore all ( collection < class < ? extend k > > type ) { ignored exception . add all ( type ) ; return this ; }
public static expect condition < boolean > and ( final expect condition < ? > . . . condition ) { return new expect condition < boolean > ( ) { @ override public boolean apply ( web driver driver ) { for ( expect condition < ? > condition : condition ) { object result = condition . apply ( driver ) ; if ( result instanceof boolean ) { if ( boolean . false . equal ( result ) ) { return false ; } } if ( result == null ) { return false ; } } return true ; } @ override public string to string ( ) { string builder message = new string builder ( `` all condition to be valid : `` ) ; joiner . on ( `` & & `` ) . append to ( message , condition ) ; return message . to string ( ) ; } } ; }
public static expect condition < object > j return value ( final string java script ) { return new expect condition < object > ( ) { @ override public object apply ( web driver driver ) { try { object value = ( ( javascript executor ) driver ) . execute script ( java script ) ; if ( value instanceof list ) { return ( ( list < ? > ) value ) . be empty ( ) ? null : value ; } if ( value instanceof string ) { return ( ( string ) value ) . be empty ( ) ? null : value ; } return value ; } catch ( web driver exception e ) { return null ; } } @ override public string to string ( ) { return string . format ( `` j % s to be executable `` , java script ) ; } } ; }
public static expect condition < web element > visibility of element locate ( final by locator ) { return new expect condition < web element > ( ) { @ override public web element apply ( web driver driver ) { try { return element if visible ( driver . find element ( locator ) ) ; } catch ( stale element reference exception e ) { return null ; } } @ override public string to string ( ) { return `` visibility of element locate by `` + locator ; } } ; }
public static expect condition < boolean > java script throw no exception ( final string java script ) { return new expect condition < boolean > ( ) { @ override public boolean apply ( web driver driver ) { try { ( ( javascript executor ) driver ) . execute script ( java script ) ; return true ; } catch ( web driver exception e ) { return false ; } } @ override public string to string ( ) { return string . format ( `` j % s to be executable `` , java script ) ; } } ; }
public static expect condition < list < web element > > presence of all element locate by ( final by locator ) { return new expect condition < list < web element > > ( ) { @ override public list < web element > apply ( web driver driver ) { list < web element > element = driver . find element ( locator ) ; return element . size ( ) > 0 ? element : null ; } @ override public string to string ( ) { return `` presence of any element locate by `` + locator ; } } ; }
public fluent wait < t > polling every ( long duration , time unit unit ) { return poll every ( duration . of ( duration , to chrono unit ( unit ) ) ) ; }
public static boolean be order datatype ( uri datatype ) { return be numeric datatype ( datatype ) || be calendar datatype ( datatype ) ; }
public static boolean be derive datatype ( uri datatype ) { return datatype . equal ( x m l schema . normalizedstring ) || datatype . equal ( x m l schema . token ) || datatype . equal ( x m l schema . language ) || datatype . equal ( x m l schema . nmtoken ) || datatype . equal ( x m l schema . nmtokens ) || datatype . equal ( x m l schema . name ) || datatype . equal ( x m l schema . ncname ) || datatype . equal ( x m l schema . id ) || datatype . equal ( x m l schema . idref ) || datatype . equal ( x m l schema . idrefs ) || datatype . equal ( x m l schema . entity ) || datatype . equal ( x m l schema . entity ) || datatype . equal ( x m l schema . integer ) || datatype . equal ( x m l schema . long ) || datatype . equal ( x m l schema . int ) || datatype . equal ( x m l schema . short ) || datatype . equal ( x m l schema . byte ) || datatype . equal ( x m l schema . non_positive_integer ) || datatype . equal ( x m l schema . negative_integer ) || datatype . equal ( x m l schema . non_negative_integer ) || datatype . equal ( x m l schema . positive_integer ) || datatype . equal ( x m l schema . unsigned_long ) || datatype . equal ( x m l schema . unsigned_int ) || datatype . equal ( x m l schema . unsigned_short ) || datatype . equal ( x m l schema . unsigned_byte ) ; }
public static boolean be derive datatype ( uri datatype ) { return datatype . equal ( x m l schema . normalizedstring ) || datatype . equal ( x m l schema . token ) || datatype . equal ( x m l schema . language ) || datatype . equal ( x m l schema . nmtoken ) || datatype . equal ( x m l schema . nmtokens ) || datatype . equal ( x m l schema . name ) || datatype . equal ( x m l schema . ncname ) || datatype . equal ( x m l schema . id ) || datatype . equal ( x m l schema . idref ) || datatype . equal ( x m l schema . idrefs ) || datatype . equal ( x m l schema . entity ) || datatype . equal ( x m l schema . entity ) || datatype . equal ( x m l schema . integer ) || datatype . equal ( x m l schema . long ) || datatype . equal ( x m l schema . int ) || datatype . equal ( x m l schema . short ) || datatype . equal ( x m l schema . byte ) || datatype . equal ( x m l schema . non_positive_integer ) || datatype . equal ( x m l schema . negative_integer ) || datatype . equal ( x m l schema . non_negative_integer ) || datatype . equal ( x m l schema . positive_integer ) || datatype . equal ( x m l schema . unsigned_long ) || datatype . equal ( x m l schema . unsigned_int ) || datatype . equal ( x m l schema . unsigned_short ) || datatype . equal ( x m l schema . unsigned_byte ) ; }
public static int compare ( string value1 , string value2 , uri datatype ) { if ( datatype . equal ( x m l schema . decimal ) ) { return compare decimal ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . integer ) ) { return compare integer ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . negative_integer ) ) { return compare negative integer ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . non_positive_integer ) ) { return compare non positive integer ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . non_negative_integer ) ) { return compare non negative integer ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . positive_integer ) ) { return compare positive integer ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . long ) ) { return compare longs ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . int ) ) { return compare ints ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . short ) ) { return compare short ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . byte ) ) { return compare byte ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . unsigned_long ) ) { return compare unsigned longs ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . unsigned_int ) ) { return compare unsigned ints ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . unsigned_short ) ) { return compare unsigned short ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . unsigned_byte ) ) { return compare unsigned byte ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . float ) ) { return compare float ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . double ) ) { return compare double ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . datetime ) ) { return compare date time ( value1 , value2 ) ; } else { throw new illegal argument exception ( `` datatype be not order `` ) ; } }
public static int compare ( string value1 , string value2 , uri datatype ) { if ( datatype . equal ( x m l schema . decimal ) ) { return compare decimal ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . integer ) ) { return compare integer ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . negative_integer ) ) { return compare negative integer ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . non_positive_integer ) ) { return compare non positive integer ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . non_negative_integer ) ) { return compare non negative integer ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . positive_integer ) ) { return compare positive integer ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . long ) ) { return compare longs ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . int ) ) { return compare ints ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . short ) ) { return compare short ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . byte ) ) { return compare byte ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . unsigned_long ) ) { return compare unsigned longs ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . unsigned_int ) ) { return compare unsigned ints ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . unsigned_short ) ) { return compare unsigned short ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . unsigned_byte ) ) { return compare unsigned byte ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . float ) ) { return compare float ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . double ) ) { return compare double ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . datetime ) ) { return compare date time ( value1 , value2 ) ; } else { throw new illegal argument exception ( `` datatype be not order `` ) ; } }
public static string normalize double ( string value ) { return normalize f p number ( value , `` -9007199254740991 . 0 `` , `` 9007199254740991 . 0 `` , `` -1075 `` , `` 970 `` ) ; }
public static int compare double ( string double1 , string double2 ) { double1 = normalize double ( double1 ) ; double2 = normalize double ( double2 ) ; return compare canonical double ( double1 , double2 ) ; }
public static int compare decimal ( string dec1 , string dec2 ) { dec1 = normalize decimal ( dec1 ) ; dec2 = normalize decimal ( dec2 ) ; return compare canonical decimal ( dec1 , dec2 ) ; }
public static int compare double ( string double1 , string double2 ) { double1 = normalize double ( double1 ) ; double2 = normalize double ( double2 ) ; return compare canonical double ( double1 , double2 ) ; }
public static double parse double ( string s ) { s = trim plus sign ( s ) ; return double . parse double ( s ) ; }
public static double parse double ( string s ) { s = trim plus sign ( s ) ; return double . parse double ( s ) ; }
public static double parse double ( string s ) { s = trim plus sign ( s ) ; return double . parse double ( s ) ; }
public static iterator < resource > get subject iterator ( graph graph , uri pred , value obj , resource . . . context ) { iterator < statement > iter = graph . match ( null , pred , obj , context ) ; return new convert iterator < statement , resource > ( iter ) { @ override protect resource convert ( statement st ) throw runtime exception { return st . get subject ( ) ; } } ; }
public static object default if null ( object object , object default value ) { return object ! = null ? object : default value ; }
public static int int value ( integer wrapper , int default value ) { return wrapper ! = null ? wrapper : default value ; }
public void add non fatal error ( rio set < ? > next non fatal error ) { this . non fatal error . add ( next non fatal error ) ; }
public static int check index ( int index , int length ) { if ( index < 0 || index > = length ) { throw new index out of bound exception ( `` index `` + index + `` out-of-bounds for length `` + length ) ; } return index ; }
public static synchronize r d f writer registry get instance ( ) { if ( default registry == null ) { default registry = new r d f writer registry ( ) ; } return default registry ; }
public void reset ( ) { warning . clear ( ) ; error . clear ( ) ; fatal error . clear ( ) ; }
public static string escape string ( string label ) { try { string builder sb = new string builder ( 2 * label . length ( ) ) ; escape string ( label , sb ) ; return sb . to string ( ) ; } catch ( i o exception e ) { throw new assertion error ( ) ; } }
public att remove att ( string q name ) { for ( int i = 0 ; i < attribute . size ( ) ; i++ ) { att att = attribute . get ( i ) ; if ( att . get q name ( ) . equal ( q name ) ) { attribute . remove ( i ) ; return att ; } } return null ; }
protect void report location ( int line no , int column no ) { if ( location listener ! = null ) { location listener . parse location update ( line no , column no ) ; } }
public static final char [ ] concat with all ( char [ ] [ ] array , char separator ) { int length = array == null ? 0 : array . length ; if ( length == 0 ) return char operation . no_char ; int size = length - 1 ; int index = length ; while ( -- index > = 0 ) { size += array [ index ] . length ; } char [ ] result = new char [ size ] ; index = length ; while ( -- index > = 0 ) { length = array [ index ] . length ; if ( length > 0 ) { system . arraycopy ( array [ index ] , 0 , result , ( size -= length ) , length ) ; } if ( -- size > = 0 ) result [ size ] = separator ; } return result ; }
public static boolean deltree ( file directory ) { if ( directory == null || ! directory . exists ( ) ) { return true ; } boolean result = true ; if ( directory . be file ( ) ) { result = directory . delete ( ) ; } else { file [ ] list = directory . list file ( ) ; for ( int i = list . length ; i -- > 0 ; ) { if ( ! deltree ( list [ i ] ) ) { result = false ; } } if ( ! directory . delete ( ) ) { result = false ; } } return result ; }
public boolean have file extension ( string extension ) { for ( string ext : file extension ) { if ( ext . equal ignore case ( extension ) ) { return true ; } } return false ; }
public string get default file extension ( ) { if ( file extension . be empty ( ) ) { return null ; } else { return file extension . get ( 0 ) ; } }
public static int non negative hash ( object obj ) { if ( obj == null ) { return 0 ; } int hash = obj . hash code ( ) ; return hash ! = integer . min_value ? math . ab ( hash ) : 0 ; }
public static boolean start with ignore case ( string str , string prefix ) { if ( str == null || prefix == null ) { return false ; } if ( str . start with ( prefix ) ) { return true ; } if ( str . length ( ) < prefix . length ( ) ) { return false ; } string lc str = str . substring ( 0 , prefix . length ( ) ) . to lower case ( ) ; string lc prefix = prefix . to lower case ( ) ; return lc str . equal ( lc prefix ) ; }
public static string encode string ( string s ) { s = string util . gsub ( `` \\ `` , `` \\\\ `` , s ) ; s = string util . gsub ( `` \t `` , `` \\t `` , s ) ; s = string util . gsub ( `` \n `` , `` \\n `` , s ) ; s = string util . gsub ( `` \r `` , `` \\r `` , s ) ; s = string util . gsub ( `` \ `` `` , `` \\\ `` `` , s ) ; return s ; }
public static < t extend archive < t > > t archive to test ( t archive ) { return archive . add ( empty asset . instance , marker_file_path ) ; }
public node attribute ( final string name , final object value ) { return attribute ( name , string . value of ( value ) ) ; }
public list < node > get ( string name ) { return get ( pattern . from ( name ) ) ; }
public list < node > remove child ( final string name ) throw illegal argument exception { if ( name == null || name . trim ( ) . length ( ) == 0 ) { throw new illegal argument exception ( `` path must not be null or empty `` ) ; } list < node > find = get ( name ) ; for ( node child : find ) { child . remove ( child ) ; } return find ; }
public void close archive ( ) throw i o exception { if ( this . tar in ! = null ) { this . tar in . close ( ) ; } else if ( this . tar out ! = null ) { this . tar out . close ( ) ; } }
public void set user info ( int user id , string user name , int group id , string group name ) { this . user id = user id ; this . user name = user name ; this . group id = group id ; this . group name = group name ; }
public void write entry header ( byte [ ] outbuf ) throw invalid header exception { int offset = 0 ; if ( this . be unix tar format ( ) ) { if ( this . header . name . length ( ) > 100 ) { throw new invalid header exception ( `` file path be great than 100 character , `` + this . header . name ) ; } } offset = tar header . get file name byte ( this . header . name . to string ( ) , outbuf ) ; offset = tar header . get octal byte ( this . header . mode , outbuf , offset , tar header . modelen ) ; offset = tar header . get octal byte ( this . header . user id , outbuf , offset , tar header . uidlen ) ; offset = tar header . get octal byte ( this . header . group id , outbuf , offset , tar header . gidlen ) ; long size = this . header . size ; offset = tar header . get long octal byte ( size , outbuf , offset , tar header . sizelen ) ; offset = tar header . get long octal byte ( this . header . mod time , outbuf , offset , tar header . modtimelen ) ; int c offset = offset ; for ( int c = 0 ; c < tar header . chksumlen ; ++c ) { outbuf [ offset++ ] = ( byte ) ' ' ; } outbuf [ offset++ ] = this . header . link flag ; offset = tar header . get name byte ( this . header . link name , outbuf , offset , tar header . namelen ) ; if ( this . unix format ) { for ( int i = 0 ; i < tar header . magiclen ; ++i ) { outbuf [ offset++ ] = 0 ; } } else { offset = tar header . get name byte ( this . header . magic , outbuf , offset , tar header . magiclen ) ; } offset = tar header . get name byte ( this . header . user name , outbuf , offset , tar header . unamelen ) ; offset = tar header . get name byte ( this . header . group name , outbuf , offset , tar header . gnamelen ) ; offset = tar header . get octal byte ( this . header . dev major , outbuf , offset , tar header . devlen ) ; offset = tar header . get octal byte ( this . header . dev minor , outbuf , offset , tar header . devlen ) ; for ( ; offset < outbuf . length ; ) { outbuf [ offset++ ] = 0 ; } long check sum = this . compute check sum ( outbuf ) ; tar header . get check sum octal byte ( check sum , outbuf , c offset , tar header . chksumlen ) ; }
public void close ( ) throw i o exception { if ( this . debug ) { system . err . println ( `` tar buffer . close buffer ( ) . `` ) ; } if ( this . out stream ! = null ) { this . flush block ( ) ; if ( this . out stream ! = system . out & & this . out stream ! = system . err ) { this . out stream . close ( ) ; this . out stream = null ; } } else if ( this . in stream ! = null ) { if ( this . in stream ! = system . in ) { this . in stream . close ( ) ; this . in stream = null ; } } }
protect archive path get class path ( ) { throw new unsupported operation exception ( `` resource adapter archive do not support class `` ) ; }
public < t extend collector > t register ( ) { return register ( collector registry . default registry ) ; }
public void inc ( ) { inc ( 1 ) ; }
public void inc ( ) { inc ( 1 ) ; }
public static builder build ( string name , string help ) { return new builder ( ) . name ( name ) . help ( help ) ; }
public void observe ( double amt ) { no label child . observe ( amt ) ; }
public void set root ( boolean root ) { this . root = root ; }
public static short [ ] uncompress short array ( byte [ ] input , int offset , int length ) throw i o exception { int uncompressed length = snappy . uncompressed length ( input , offset , length ) ; short [ ] result = new short [ uncompressed length / 2 ] ; int byte size = impl . raw uncompress ( input , offset , length , result , 0 ) ; return result ; }
public int read ( long [ ] d , int off , int len ) throw i o exception { return raw read ( d , off * 8 , len * 8 ) ; }
public int read ( long [ ] d , int off , int len ) throw i o exception { return raw read ( d , off * 8 , len * 8 ) ; }
public synchronize service static file location ( string folder ) { if ( initialize & & ! be run from servlet ( ) ) { throw before route mapping exception ( ) ; } static file folder = folder ; if ( ! servlet static location set ) { static file configuration . configure ( static file folder ) ; servlet static location set = true ; } else { log . warn ( `` static file location have already be set `` ) ; } return this ; }
public void any ( string from path , string to path , status status ) { get ( from path , to path , status ) ; post ( from path , to path , status ) ; put ( from path , to path , status ) ; delete ( from path , to path , status ) ; }
public void any ( string from path , string to path , status status ) { get ( from path , to path , status ) ; post ( from path , to path , status ) ; put ( from path , to path , status ) ; delete ( from path , to path , status ) ; }
public int get response status ( ) { return get response context ( ) . get status ( ) ; }
public void put ( string path , route route ) { add route ( http method . put . name ( ) , route impl . create ( path , route ) ) ; }
public void get ( final string path , final route route ) { add route ( http method . get . name ( ) , route impl . create ( path , route ) ) ; }
public synchronize service web socket idle timeout millis ( int timeout millis ) { if ( initialize ) { throw before route mapping exception ( ) ; } if ( be run from servlet ( ) ) { throw new illegal state exception ( `` web socket be only support in the embedded server `` ) ; } web socket idle timeout millis = optional . of ( timeout millis ) ; return this ; }
public void set thread ( int min , int max ) { queue thread pool pool = ( queue thread pool ) web server . get thread pool ( ) ; pool . set min thread ( min ) ; pool . set max thread ( max ) ; }
public void add mapping ( path spec path spec , web socket creator creator , frame handler factory factory , configuration . customizer customizer ) throw web socket exception { mapping . put ( path spec , web socket negotiator . from ( creator , factory , customizer ) ) ; }
public < t > t attribute ( string name ) { return ( t ) session . get attribute ( name ) ; }
public static boolean be jar u r l ( url url ) { string protocol = url . get protocol ( ) ; return ( url_protocol_jar . equal ( protocol ) || url_protocol_zip . equal ( protocol ) || url_protocol_vfszip . equal ( protocol ) || url_protocol_wsjar . equal ( protocol ) ) ; }
protected memory block allocate page ( long require ) { memory block page = task memory manager . allocate page ( math . max ( page size , require ) , this ) ; if ( page == null || page . size ( ) < require ) { long get = 0 ; if ( page ! = null ) { get = page . size ( ) ; task memory manager . free page ( page , this ) ; } task memory manager . show memory usage ( ) ; throw new out of memory error ( `` unable to acquire `` + required + `` byte of memory , get `` + get ) ; } use += page . size ( ) ; return page ; }
protect void free page ( memory block page ) { use -= page . size ( ) ; task memory manager . free page ( page , this ) ; }
public shuffle sorter iterator get sort iterator ( ) { int offset = 0 ; if ( use radix sort ) { offset = radix sort . sort ( array , po , pack record pointer . partition_id_start_byte_index , pack record pointer . partition_id_end_byte_index , false , false ) ; } else { memory block unused = new memory block ( array . get base object ( ) , array . get base offset ( ) + pos * 8l , ( array . size ( ) - po ) * 8l ) ; long array buffer = new long array ( unused ) ; sorter < pack record pointer , long array > sorter = new sorter < > ( new shuffle sort data format ( buffer ) ) ; sorter . sort ( array , 0 , po , sort_comparator ) ; } return new shuffle sorter iterator ( po , array , offset ) ; }
public void free ( ) { update peak memory use ( ) ; if ( long array ! = null ) { free array ( long array ) ; long array = null ; } iterator < memory block > data page iterator = data page . iterator ( ) ; while ( data page iterator . have next ( ) ) { memory block data page = data page iterator . next ( ) ; data page iterator . remove ( ) ; free page ( data page ) ; } assert ( data page . be empty ( ) ) ; while ( ! spill writer . be empty ( ) ) { file file = spill writer . remove first ( ) . get file ( ) ; if ( file ! = null & & file . exists ( ) ) { if ( ! file . delete ( ) ) { logger . error ( `` be unable to delete spill file { } `` , file . get absolute path ( ) ) ; } } } }
public spark launcher set java home ( string java home ) { check not null ( java home , `` java home `` ) ; builder . java home = java home ; return this ; }
public void set client id ( string id ) { precondition . check state ( client id == null , `` client id have already be set . `` ) ; this . client id = id ; }
public byte [ ] get input iv ( ) { return in iv ; }
public byte [ ] get input iv ( ) { return in iv ; }
public static string encode identifier ( string identifier ) { precondition . check not null ( identifier , `` user can not be null if sasl be enable `` ) ; return get base64 encode string ( identifier ) ; }
protect void set closure delegate ( closure closure , object node ) { closure . set delegate ( this ) ; }
public void reset ( ) { offset = 0 ; }
public static long byte string a kb ( string str ) { return byte string a ( str , byte unit . ki b ) ; }
public int auth r t timeout m ( ) { return ( int ) java utils . time string a sec ( conf . get ( `` spark . network . auth . rpc timeout `` , conf . get ( spark_network_sasl_timeout_key , `` 30 `` ) ) ) * 1000 ; }
public shuffle sorter iterator get sort iterator ( ) { int offset = 0 ; if ( use radix sort ) { offset = radix sort . sort ( array , po , pack record pointer . partition_id_start_byte_index , pack record pointer . partition_id_end_byte_index , false , false ) ; } else { memory block unused = new memory block ( array . get base object ( ) , array . get base offset ( ) + pos * 8l , ( array . size ( ) - po ) * 8l ) ; long array buffer = new long array ( unused ) ; sorter < pack record pointer , long array > sorter = new sorter < > ( new shuffle sort data format ( buffer ) ) ; sorter . sort ( array , 0 , po , sort_comparator ) ; } return new shuffle sorter iterator ( po , array , offset ) ; }
public void application remove ( string app id , boolean cleanup local dirs ) { block manager . application remove ( app id , cleanup local dirs ) ; }
public static void write to memory ( byte [ ] src , object target , long target offset ) { platform . copy memory ( src , platform . byte_array_offset , target , target offset , src . length ) ; }
public int num char ( ) { int len = 0 ; for ( int i = 0 ; i < num byte ; i += num byte for first byte ( get byte ( i ) ) ) { len += 1 ; } return len ; }
public id create id ( string name , string . . . tag ) { return impl . create id ( name , to iterable ( tag ) ) ; }
public void set result set type ( int result set type ) { this . result set type = result set type ; }
public prepare statement creator new prepared statement creator ( @ nullable list < ? > params ) { return new prepared statement creator impl ( params ! = null ? params : collection . empty list ( ) ) ; }
public void set query timeout ( int query timeout ) { this . jdbc template . set query timeout ( query timeout ) ; }
public boolean be skip undeclared result ( ) { return this . skip undeclared result ; }
public void set return value require ( boolean return value require ) { this . call meta data context . set return value require ( return value require ) ; }
public void process meta data ( data source data source , list < string > declare column , string [ ] generate key name ) { this . meta data provider = table meta data provider factory . create meta data provider ( data source , this ) ; this . table columns = reconcile column to use ( declared column , generate key name ) ; }
public int get parameter type ( ) { return this . parameter type ; }
protect void set support catalog in procedure call ( boolean support catalog in procedure call ) { this . support catalog in procedure call = support catalog in procedure call ; }
public boolean be supports catalog in procedure call ( ) { return this . support catalog in procedure call ; }
public void process meta data ( data source data source , list < string > declare column , string [ ] generate key name ) { this . meta data provider = table meta data provider factory . create meta data provider ( data source , this ) ; this . table columns = reconcile column to use ( declared column , generate key name ) ; }
public void process meta data ( data source data source , list < string > declare column , string [ ] generate key name ) { this . meta data provider = table meta data provider factory . create meta data provider ( data source , this ) ; this . table columns = reconcile column to use ( declared column , generate key name ) ; }
public void set override include synonyms default ( boolean override ) { this . table meta data context . set override include synonyms default ( override ) ; }
public int get parameter type ( ) { return this . parameter type ; }
public void register sql type ( string param name , int sql type ) { assert . not null ( param name , `` parameter name must not be null `` ) ; this . sql type . put ( param name , sql type ) ; }
public name parameter jdbc template get name parameter jdbc template ( ) { return this . name parameter jdbc template ; }
protect final prepared statement creator new prepared statement creator ( @ nullable object [ ] params ) { assert . state ( this . prepared statement factory ! = null , `` no prepared statement factory available `` ) ; return this . prepared statement factory . new prepared statement creator ( params ) ; }
public boolean be name binding ( ) { return this . call meta data context . be name binding ( ) ; }
public void set return value require ( boolean return value require ) { this . call meta data context . set return value require ( return value require ) ; }
public final synchronize void compile ( ) throw invalid data access api usage exception { if ( ! be compile ( ) ) { if ( get procedure name ( ) == null ) { throw new invalid data access api usage exception ( `` procedure or function name be require `` ) ; } try { this . jdbc template . after property set ( ) ; } catch ( illegal argument exception ex ) { throw new invalid data access api usage exception ( ex . get message ( ) ) ; } compile internal ( ) ; this . compile = true ; if ( logger . be debug enable ( ) ) { logger . debug ( `` sql call for `` + ( be function ( ) ? `` function `` : `` procedure `` ) + `` [ `` + get procedure name ( ) + `` ] compile `` ) ; } } }
public final synchronize void compile ( ) throw invalid data access api usage exception { if ( ! be compile ( ) ) { if ( get procedure name ( ) == null ) { throw new invalid data access api usage exception ( `` procedure or function name be require `` ) ; } try { this . jdbc template . after property set ( ) ; } catch ( illegal argument exception ex ) { throw new invalid data access api usage exception ( ex . get message ( ) ) ; } compile internal ( ) ; this . compile = true ; if ( logger . be debug enable ( ) ) { logger . debug ( `` sql call for `` + ( be function ( ) ? `` function `` : `` procedure `` ) + `` [ `` + get procedure name ( ) + `` ] compile `` ) ; } } }
public final void set data source ( data source data source ) { if ( this . jdbc template == null || data source ! = this . jdbc template . get data source ( ) ) { this . jdbc template = create jdbc template ( data source ) ; init template config ( ) ; } }
public string get password ( ) { return this . password ; }
protect boolean be transaction active ( ) { return this . transaction active ; }
public connection get connection ( ) { assert . not null ( this . connection handle , `` active connection be require `` ) ; if ( this . current connection == null ) { this . current connection = this . connection handle . get connection ( ) ; } return this . current connection ; }
public connection get connection ( ) throw s q l exception { return get transaction aware connection proxy ( obtain target data source ( ) ) ; }
public static void release connection ( @ nullable connection con , @ nullable data source data source ) { try { do release connection ( con , data source ) ; } catch ( s q l exception ex ) { logger . debug ( `` could not close jdbc connection `` , ex ) ; } catch ( throwable ex ) { logger . debug ( `` unexpected exception on closing jdbc connection `` , ex ) ; } }
public embed database builder set name ( string database name ) { this . database factory . set database name ( database name ) ; return this ; }
public void set previous isolation level ( @ nullable integer previous isolation level ) { this . previous isolation level = previous isolation level ; }
public void set read only ( boolean read only ) { this . read only = read only ; }
protect synchronized void check default connection property ( connection con ) throw s q l exception { if ( this . default auto commit == null ) { this . default auto commit = con . get auto commit ( ) ; } if ( this . default transaction isolation == null ) { this . default transaction isolation = con . get transaction isolation ( ) ; } }
public void set default target data source ( object default target data source ) { this . default target data source = default target data source ; }
public void set default target data source ( object default target data source ) { this . default target data source = default target data source ; }
public driver get driver ( ) { return this . driver ; }
public void set suppress close ( boolean suppress close ) { this . suppress close = suppress close ; }
public void init connection ( ) throw s q l exception { if ( get url ( ) == null ) { throw new illegal state exception ( `` 'url ' property be require for lazily initialize a connection `` ) ; } synchronize ( this . connection monitor ) { close connection ( ) ; this . target = get connection from driver ( get username ( ) , get password ( ) ) ; prepare connection ( this . target ) ; if ( logger . be debug enable ( ) ) { logger . debug ( `` establish share jdbc connection : `` + this . target ) ; } this . connection = ( be suppress close ( ) ? get close suppress connection proxy ( this . target ) : this . target ) ; } }
public int [ ] flush ( ) { if ( this . parameter queue . be empty ( ) ) { return new int [ 0 ] ; } int [ ] row affect = get jdbc template ( ) . batch update ( resolve sql ( ) , new batch prepare statement setter ( ) { @ override public int get batch size ( ) { return parameter queue . size ( ) ; } @ override public void set value ( prepared statement p , int index ) throw s q l exception { object [ ] params = parameter queue . remove first ( ) ; new prepared statement setter ( params ) . set value ( p ) ; } } ) ; for ( int row count : row affect ) { check row affect ( row count ) ; if ( this . track row affect ) { this . row affect . add ( row count ) ; } } return row affect ; }
public final void compile ( ) throw invalid data access api usage exception { if ( ! be compile ( ) ) { if ( get sql ( ) == null ) { throw new invalid data access api usage exception ( `` property 'sql ' be require `` ) ; } try { this . jdbc template . after property set ( ) ; } catch ( illegal argument exception ex ) { throw new invalid data access api usage exception ( ex . get message ( ) ) ; } compile internal ( ) ; this . compile = true ; if ( logger . be debug enable ( ) ) { logger . debug ( `` rdbms operation with sql [ `` + get sql ( ) + `` ] compile `` ) ; } } }
public boolean be sql ready for use ( ) { return this . sql ready for use ; }
public object run generic ( ) { return find object ( ( object [ ] ) null , null ) ; }
public t find object ( int p1 , int p2 ) throw data access exception { return find object ( p1 , p2 , null ) ; }
public int [ ] flush ( ) { if ( this . parameter queue . be empty ( ) ) { return new int [ 0 ] ; } int [ ] row affect = get jdbc template ( ) . batch update ( resolve sql ( ) , new batch prepare statement setter ( ) { @ override public int get batch size ( ) { return parameter queue . size ( ) ; } @ override public void set value ( prepared statement p , int index ) throw s q l exception { object [ ] params = parameter queue . remove first ( ) ; new prepared statement setter ( params ) . set value ( p ) ; } } ) ; for ( int row count : row affect ) { check row affect ( row count ) ; if ( this . track row affect ) { this . row affect . add ( row count ) ; } } return row affect ; }
public list < jaxb store procedure parameter > get parameter ( ) { if ( parameter == null ) { parameter = new array list < jaxb store procedure parameter > ( ) ; } return this . parameter ; }
public boolean be delete specific value ( ) { return this . delete specific value ; }
protect final connection get connection ( ) throw can not get jdbc connection exception { data source data source = get data source ( ) ; assert . state ( data source ! = null , `` no data source set `` ) ; return data source utils . get connection ( data source ) ; }
public final expression optimize ( expression visitor visitor , item type context item type ) { return this ; }
public static < t > t single result ( @ nullable collection < t > result ) throw incorrect result size data access exception { if ( collection utils . be empty ( result ) ) { return null ; } if ( result . size ( ) > 1 ) { throw new incorrect result size data access exception ( 1 , result . size ( ) ) ; } return result . iterator ( ) . next ( ) ; }
public void set persistence exception translator ( persistence exception translator pet ) { this . persistence exception translator = pet ; }
public void remove connection spec from current thread ( ) { this . thread bound spec . remove ( ) ; }
protect connection get transaction aware connection proxy ( connection target , connection factory cf ) { return ( connection ) proxy . new proxy instance ( connection . class . get class loader ( ) , new class < ? > [ ] { connection . class } , new transaction aware invocation handler ( target , cf ) ) ; }
public final void set connection factory ( connection factory connection factory ) { if ( this . cci template == null || connection factory ! = this . cci template . get connection factory ( ) ) { this . cci template = create cci template ( connection factory ) ; } }
public void start ( bootstrap context bootstrap context ) throw resource adapter internal exception { if ( logger . be debug enable ( ) ) { logger . debug ( `` start spring context resource adapter with bootstrap context : `` + bootstrap context ) ; } this . application context = create application context ( bootstrap context ) ; }
protect abstract message endpoint create endpoint internal ( ) throw unavailable exception { return new generic message endpoint ( ) ; }
public void set work manager name ( string work manager name ) { this . work manager name = work manager name ; }
public void resolve attribute string ( @ nullable string value resolver resolver ) { string timeout string = this . timeout string ; if ( string utils . have text ( timeout string ) ) { if ( resolver ! = null ) { timeout string = resolver . resolve string value ( timeout string ) ; } if ( string utils . have length ( timeout string ) ) { try { set timeout ( integer . parse int ( timeout string ) ) ; } catch ( runtime exception ex ) { throw new illegal argument exception ( `` invalid timeout string value \ `` `` + timeout string + `` \ `` - can not parse into int `` ) ; } } } if ( resolver ! = null ) { if ( this . qualifier ! = null ) { this . qualifier = resolver . resolve string value ( this . qualifier ) ; } set < string > resolve label = new link hash set < > ( this . label . size ( ) ) ; for ( string label : this . label ) { resolve label . add ( resolver . resolve string value ( label ) ) ; } this . label = resolve label ; } }
public void after property set ( ) throw transaction system exception { init user transaction and transaction manager ( ) ; check user transaction and transaction manager ( ) ; init transaction synchronization registry ( ) ; }
public void set user transaction name ( string user transaction name ) { this . user transaction name = user transaction name ; }
public static boolean same resource factory ( resource transaction manager tm , object resource factory ) { return unwrap resource if necessary ( tm . get resource factory ( ) ) . equal ( unwrap resource if necessary ( resource factory ) ) ; }
public boolean be actual transaction active ( ) { return this . transaction context . be actual transaction active ( ) ; }
public final mono < void > rollback ( reactive transaction transaction ) throw transaction exception { if ( transaction . be complete ( ) ) { return mono . error ( new illegal transaction state exception ( `` transaction be already complete - do not call commit or rollback more than once per transaction `` ) ) ; } return transaction synchronization manager . for current transaction ( ) . flat map ( synchronization manager - > { generic reactive transaction reactive tx = ( generic reactive transaction ) transaction ; return process rollback ( synchronization manager , reactive tx ) ; } ) ; }
protect void do resume ( @ nullable object transaction , object suspend resource ) throw transaction exception { throw new transaction suspension not support exception ( `` transaction manager [ `` + get class ( ) . get name ( ) + `` ] do not support transaction suspension `` ) ; }
protect void set closure delegate ( closure closure , object node ) { closure . set delegate ( this ) ; }
public final void set isolation level name ( string constant name ) throw illegal argument exception { if ( ! constant name . start with ( prefix_isolation ) ) { throw new illegal argument exception ( `` only isolation constant allow `` ) ; } set isolation level ( constant . a number ( constant name ) . int value ( ) ) ; }
protect void prepare synchronization ( default transaction status status , transaction definition definition ) { if ( status . be new synchronization ( ) ) { transaction synchronization manager . set actual transaction active ( status . have transaction ( ) ) ; transaction synchronization manager . set current transaction isolation level ( definition . get isolation level ( ) ! = transaction definition . isolation_default ? definition . get isolation level ( ) : null ) ; transaction synchronization manager . set current transaction read only ( definition . be read only ( ) ) ; transaction synchronization manager . set current transaction name ( definition . get name ( ) ) ; transaction synchronization manager . init synchronization ( ) ; } }
public void reset rollback only ( ) { this . rollback only = false ; }
public boolean have connection holder ( ) { return ( this . connection holder ! = null ) ; }
public void release ( ) { this . reference count -- ; }
public void lock ( ) { lock . lock ( ) ; }
public string print hex ( ) { return byte array utils . print hex ( array ( ) , rpos ( ) , available ( ) ) ; }
public string print hex ( ) { return byte array utils . print hex ( array ( ) , rpos ( ) , available ( ) ) ; }
public s s h packet put message i d ( message msg ) { return put byte ( msg . to byte ( ) ) ; }
public st create singleton ( token template token ) { string template ; if ( template token . get type ( ) == group parser . bigstring ) { template = misc . strip ( template token . get text ( ) ,2 ) ; } else { template = misc . strip ( template token . get text ( ) ,1 ) ; } compile s t impl = compile ( get file name ( ) , null , null , template , template token ) ; st st = create string template internally ( impl ) ; st . group that create this instance = this ; st . impl . have formal args = false ; st . impl . name = st . unknown_name ; st . impl . define implicitly define template ( this ) ; return st ; }
public st create singleton ( token template token ) { string template ; if ( template token . get type ( ) == group parser . bigstring ) { template = misc . strip ( template token . get text ( ) ,2 ) ; } else { template = misc . strip ( template token . get text ( ) ,1 ) ; } compile s t impl = compile ( get file name ( ) , null , null , template , template token ) ; st st = create string template internally ( impl ) ; st . group that create this instance = this ; st . impl . have formal args = false ; st . impl . name = st . unknown_name ; st . impl . define implicitly define template ( this ) ; return st ; }
public string map path ( string path ) { return null ; }
public string [ ] get location ( ) throw i o exception { hash set < string > host = new hash set < string > ( ) ; for ( input split s : split ) { string [ ] hint = s . get location ( ) ; if ( hint ! = null & & hint . length > 0 ) { for ( string host : hint ) { host . add ( host ) ; } } } return host . to array ( new string [ host . size ( ) ] ) ; }
public static void enable partial time ( ) { custom class ( ) . put ( `` org . joda . time . local time `` , primitive type . partial_time ) ; custom class ( ) . put ( `` java . time . local time `` , primitive type . partial_time ) ; }
public static < t > set < t > set of ( t . . . object ) { if ( object == null || object . length == 0 ) { return new hash set < > ( 0 ) ; } return new hash set < > ( arrays . a list ( object ) ) ; }
public contact get contact ( ) { return contact ; }
public string get format ( ) { return format ; }
public boolean get exclusive maximum ( ) { return exclusive maximum ; }
public integer get max item ( ) { return max item ; }
public string get $ ref ( ) { return $ ref ; }
public integer get max property ( ) { return max property ; }
public string get $ ref ( ) { return $ ref ; }
public string get format ( ) { return format ; }
public boolean get wrap ( ) { return wrap ; }
public boolean get wrap ( ) { return wrap ; }
public external documentation get external doc ( ) { return external doc ; }
public string get in ( ) { return in ; }
public api response get default ( ) { return this . get ( default ) ; }
public o auth flow get authorization code ( ) { return authorization code ; }
public o auth flow get implicit ( ) { return implicit ; }
public string get description ( ) { return description ; }
public iterator < index > all before ( double x ) { if ( data . size ( ) == 0 ) { return iterator ( 0 , 0 ) ; } else { for ( int i = 1 ; i < data . size ( ) ; i++ ) { if ( data . get ( i ) . centroid [ 0 ] > x ) { page previous = data . get ( i - 1 ) ; for ( int j = 0 ; j < previous . active ; j++ ) { if ( previous . centroid [ j ] > x ) { return reverse ( i - 1 , j - 1 ) ; } } return reverse ( i , -1 ) ; } } page last = data . get ( data . size ( ) - 1 ) ; for ( int j = 0 ; j < last . active ; j++ ) { if ( last . centroid [ j ] > x ) { return reverse ( data . size ( ) - 1 , j - 1 ) ; } } return reverse ( data . size ( ) , -1 ) ; } }
public int parent ( int node ) { return parent [ node ] ; }
public static array digest create array digest ( int page size , double compression ) { return new array digest ( page size , compression ) ; }
public static void assert equal ( object actual , object expect , string message ) { if ( expect ! = null & & expect . get class ( ) . be array ( ) ) { assert array equal ( actual , expect , message ) ; return ; } assert equal impl ( actual , expect , message ) ; }
public static void fail ( string message ) { throw new assertion error ( message ) ; }
public static set < field > get all declare field ( class < ? > clazz ) { hash set < field > field = new hash set < field > ( ) ; for ( class < ? > c = clazz ; c ! = null & & c ! = object . class ; c = c . get superclass ( ) ) { collection . add all ( field , c . get declared field ( ) ) ; } return field ; }
public static set < method > get all declare method ( class < ? > clazz ) { hash set < method > method = new hash set < method > ( ) ; for ( class < ? > c = clazz ; c ! = null & & c ! = object . class ; c = c . get superclass ( ) ) { collection . add all ( method , c . get declare method ( ) ) ; } return method ; }
public static void assert not null ( object object ) { assert not null ( object , null ) ; }
public static void assert equal ( object actual , object expect , string message ) { if ( expect ! = null & & expect . get class ( ) . be array ( ) ) { assert array equal ( actual , expect , message ) ; return ; } assert equal impl ( actual , expect , message ) ; }
public long get time out ( ) { long result = 0 ; for ( i method instance mi : m_method instance ) { i test n g method tm = mi . get method ( ) ; if ( tm . get time out ( ) > result ) { result = tm . get time out ( ) ; } } return result ; }
public static j primitive type parse ( j code model code model , string type name ) { if ( type name . equal ( `` void `` ) ) return code model . void ; else if ( type name . equal ( `` boolean `` ) ) return code model . boolean ; else if ( type name . equal ( `` byte `` ) ) return code model . byte ; else if ( type name . equal ( `` short `` ) ) return code model . short ; else if ( type name . equal ( `` char `` ) ) return code model . char ; else if ( type name . equal ( `` int `` ) ) return code model . int ; else if ( type name . equal ( `` float `` ) ) return code model . float ; else if ( type name . equal ( `` long `` ) ) return code model . long ; else if ( type name . equal ( `` double `` ) ) return code model . double ; else throw new illegal argument exception ( `` not a primitive type : `` + type name ) ; }
public void trace ( object message ) { log ( trace , message , null ) ; }
public void debug ( object message , throwable t ) { log ( debug , message , t ) ; }
public static void log ( string s , int level , boolean log to standard out ) { if ( test runner . get verbose ( ) > = level ) { log ( s , get current test result ( ) ) ; if ( log to standard out ) { system . out . println ( s ) ; } } }
public void set parallel ( parallel mode parallel ) { if ( parallel == null ) { m_parallel = default_parallel ; } else { m_parallel = skip deprecate value ( parallel ) ; } }
public void set output dir ( file dir ) { m_output dir= dir ; }
public static string get build version ( ) { return `` 0 . 0 . 0 . 0 `` ; }
public void set output dir ( file dir ) { m_output dir= dir ; }
protect i test runner factory build test runner factory ( ) { if ( null == m_custom test runner factory ) { m_custom test runner factory= new i test runner factory ( ) { @ override public test runner new test runner ( i suite suite , xml test xml test , list < i invoke method listener > listener ) { test runner runner = new test runner ( get configuration ( ) , suite , xml test , false / * skip fail invocation count * / , listener ) ; if ( m_use default listener ) { runner . add listener ( new test h t m l reporter ( ) ) ; runner . add listener ( new j unit x m l reporter ( ) ) ; } return runner ; } } ; } return m_custom test runner factory ; }
public void set parallel ( string parallel ) { if ( parallel == null ) { set parallel ( xml suite . parallel mode . none ) ; } else { set parallel ( xml suite . parallel mode . get valid parallel ( parallel ) ) ; } }
public void set suite file ( list < string > file ) { m_suite file = file ; }
public list < xml test > get test ( ) { return m_tests ; }
public void set xml package ( list < xml package > package ) { m_xml package = list . new array list ( package ) ; }
public static string builder to yaml ( xml suite suite ) { string builder result = new string builder ( ) ; maybe add ( result , `` name `` , suite . get name ( ) , null ) ; maybe add ( result , `` junit `` , suite . be j unit ( ) , xml suite . default_junit ) ; maybe add ( result , `` verbose `` , suite . get verbose ( ) , xml suite . default_verbose ) ; maybe add ( result , `` thread count `` , suite . get thread count ( ) , xml suite . default_thread_count ) ; maybe add ( result , `` data provider thread count `` , suite . get data provider thread count ( ) , xml suite . default_data_provider_thread_count ) ; maybe add ( result , `` time out `` , suite . get time out ( ) , null ) ; maybe add ( result , `` parallel `` , suite . get parallel ( ) , xml suite . default_parallel ) ; maybe add ( result , `` config failure policy `` , suite . get config failure policy ( ) . to string ( ) , xml suite . default_config_failure_policy ) ; maybe add ( result , `` skip fail invocation count `` , suite . skip fail invocation count ( ) , xml suite . default_skip_failed_invocation_counts ) ; to yaml ( result , `` parameter `` , `` `` , suite . get parameter ( ) ) ; to yaml ( result , suite . get package ( ) ) ; if ( ! suite . get listener ( ) . be empty ( ) ) { result . append ( `` listener : \n `` ) ; to yaml ( result , `` `` , suite . get listener ( ) ) ; } if ( ! suite . get package ( ) . be empty ( ) ) { result . append ( `` package : \n `` ) ; to yaml ( result , suite . get package ( ) ) ; } if ( ! suite . get test ( ) . be empty ( ) ) { result . append ( `` test : \n `` ) ; for ( xml test t : suite . get test ( ) ) { to yaml ( result , `` `` , t ) ; } } if ( ! suite . get child suite ( ) . be empty ( ) ) { result . append ( `` suite-files : \n `` ) ; to yaml ( result , `` `` , suite . get suite file ( ) ) ; } return result ; }
public static string time span to x s time ( time span time span ) { decimal format my formatter = new decimal format ( `` 00 `` ) ; return string . format ( `` % s : % s : % s `` , my formatter . format ( time span . get hour ( ) ) , my formatter . format ( time span . get minute ( ) ) , my formatter . format ( time span . get second ( ) ) ) ; }
public void set j unit ( boolean be j unit ) { m_is j unit = be j unit ; }
protect scheduled future schedule heartbeat ( ) { return heartbeat_executor_service . schedule at fix rate ( new heartbeat runnable ( ) , heartbeatable . get heartbeat interval ( ) . get second ( ) , heartbeatable . get heartbeat interval ( ) . get second ( ) , time unit . second ) ; }
public t byte byte map get map ( ) { return _map ; }
public static string boost ( float boost ) { if ( boost ! = 1 . 0f ) { return `` ^ `` + float . to string ( boost ) ; } else return `` `` ; }
public boolean contains ( object obj ) { return index ( obj ) > = 0 ; }
public void ensure capacity ( int desire capacity ) { if ( desired capacity > ( _max size - size ( ) ) ) { rehash ( prime finder . next prime ( math . max ( size ( ) + 1 , hash function . fast ceil ( ( desire capacity + size ( ) ) / _load factor ) + 1 ) ) ) ; compute max size ( capacity ( ) ) ; } }
public set < k > key set ( ) { return new key view ( ) ; }
public boolean add all ( collection < ? extend e > collection ) { boolean change = false ; int size = collection . size ( ) ; ensure capacity ( size ) ; iterator < ? extend e > it = collection . iterator ( ) ; while ( size -- > 0 ) { if ( add ( it . next ( ) ) ) { change = true ; } } return change ; }
public byte peek ( ) { return _list . get ( _list . size ( ) - 1 ) ; }
public byte [ ] to array ( ) { byte [ ] retval = _list . to array ( ) ; reverse ( retval , 0 , size ( ) ) ; return retval ; }
public string transform name ( field field , string name ) { return name ; }
public < t > list < t > get bean ( class < t > bean type ) { int index = argument utils . index of ( bean type , bean type ) ; if ( index == -1 ) { throw new illegal argument exception ( `` unknown bean type ' `` + bean type . get simple name ( ) + `` ' . available type be : `` + array . to string ( bean type ) ) ; } return bean [ index ] ; }
protect void set closure delegate ( closure closure , object node ) { closure . set delegate ( this ) ; }
public static locale get locale ( string language code ) { if ( language code == null ) return null ; return local map . get ( language code . to lower case ( ) ) ; }
public long get number of record to read ( ) { return number of record to read ; }
public final void update whitespace ( ) { whitespace count = 0 ; for ( int i = index - 1 ; i > = 0 & & char [ i ] < = ' ' & & whitespace range start < char [ i ] ; i -- , whitespace count++ ) ; }
public final void set line separator detection enable ( boolean line separator detection enable ) { this . line separator detection enable = line separator detection enable ; }
public field set < string > exclude field ( string . . . field names ) { return set field set ( new exclude field name selector ( ) , field name ) ; }
public field set < integer > exclude index ( integer . . . field index ) { return set field set ( new exclude field index selector ( ) , field index ) ; }
public boolean be comment collection enable ( ) { return comment collection enable ; }
public final fix width parser setting clone ( ) { return ( fix width parser setting ) super . clone ( ) ; }
public final int get column index ( ) { return column index ; }
public field set < string > exclude field ( string . . . field names ) { return set field set ( new exclude field name selector ( ) , field name ) ; }
public conversion [ ] get conversion ( int index , class < ? > expect type ) { list < conversion < ? , ? > > conversion = conversion by index . get ( index ) ; conversion [ ] out ; if ( conversion ! = null ) { out = new conversion [ conversion . size ( ) ] ; int i = 0 ; for ( conversion conversion : conversion ) { out [ i++ ] = conversion ; } } else if ( expect type == string . class ) { return empty_conversion_array ; } else { out = new conversion [ 1 ] ; out [ 0 ] = annotation helper . get default conversion ( expect type , null , null ) ; if ( out [ 0 ] == null ) { return empty_conversion_array ; } } return out ; }
public field alignment get alignment ( int position ) { validate index ( position ) ; return field alignment . get ( position ) ; }
protect void set reader ( reader reader ) { if ( ! unwrapping ) { stop ( ) ; bucket loader = new concurrent char loader ( reader , bucket size , bucket quantity ) ; bucket loader . report error ( ) ; } else { bucket loader . reader = reader ; } unwrap = false ; }
public boolean match ( char current , char [ ] sequence , char wildcard ) { if ( sequence . length > length - start ) { return false ; } if ( sequence [ 0 ] ! = current & & sequence [ 0 ] ! = wildcard ) { return false ; } for ( int i = 1 ; i < sequence . length ; i++ ) { char ch = sequence [ i ] ; if ( ch ! = wildcard & & ch ! = lookahead [ i - 1 + start ] ) { return false ; } } return true ; }
public void clear ( ) { this . detail row = collection . empty list ( ) ; this . master row = null ; }
public final void parse and write ( reader input , writer output ) { set row writer processor ( null ) ; set row processor ( create writing row processor ( output ) ) ; try { abstract parser < p > parser = create parser ( parser setting ) ; parser . parse ( input ) ; } finally { parser setting . set row processor ( null ) ; } }
public final p get parser setting ( ) { validate parser setting ( ) ; return parser setting ; }
protect void add non match ( string builder sb , string text ) { sb . append ( text ) ; }
public input dimension get input dimension ( final file input ) { return get input dimension ( argument utils . new reader ( input ) ) ; }
public string get record character ( ) { if ( error content length == 0 ) { return null ; } return record character ; }
protect big integer from string ( string input ) { return new big integer ( input ) ; }
protect byte unwrap key ( object key ) { return ( ( byte ) key ) . byte value ( ) ; }
public string execute ( string input ) { if ( input == null ) { return null ; } return input . replace all ( replace regex , replacement ) ; }
public void set delimiter ( char delimiter ) { this . delimiter = delimiter ; }
public unescaped quote handle get unescaped quote handling ( ) { return this . unescaped quote handling ; }
public final void set delimiter detection enable ( boolean separator detection enable , char . . . delimiters for detection ) { this . delimiter detection enable = separator detection enable ; this . delimiters for detection = delimiters for detection ; }
public unescaped quote handle get unescaped quote handling ( ) { return this . unescaped quote handling ; }
public void set keep quote ( boolean keep quote ) { this . keep quote = keep quote ; }
public final void trim quote value ( boolean trim ) { set ignore trail whitespaces in quote ( trim ) ; set ignore leading whitespaces in quote ( trim ) ; }
public final void detect format automatically ( char . . . delimiters for detection ) { this . set delimiter detection enable ( true , delimiters for detection ) ; this . set quote detection enable ( true ) ; this . set line separator detection enable ( true ) ; }
public char get escape tab char ( ) { return escape tab char ; }
protect tsv format create default format ( ) { return new tsv format ( ) ; }
public static output format create compact format ( ) { output format format = new output format ( ) ; format . set indent ( false ) ; format . set newlines ( false ) ; format . set trim text ( true ) ; return format ; }
public bit set < t > of all ( java . util . stream . stream < ? extend t > java stream ) { object . require non null ( java stream , `` java stream be null `` ) ; return empty ( ) . add all ( iterator . of all ( java stream . iterator ( ) ) ) ; }
public void attribute decl ( string e name , string a name , string type , string value default , string val ) throw s a x exception { if ( internal d t dsubset ) { if ( include internal d t d declaration ) { add d t d declaration ( new attribute decl ( e name , a name , type , value default , val ) ) ; } } else { if ( include external d t d declaration ) { add external d t d declaration ( new attribute decl ( e name , a name , type , value default , val ) ) ; } } }
public void internal entity decl ( string name , string value ) throw s a x exception { if ( internal d t dsubset ) { if ( include internal d t d declaration ) { add d t d declaration ( new internal entity decl ( name , value ) ) ; } } else { if ( include external d t d declaration ) { add external d t d declaration ( new internal entity decl ( name , value ) ) ; } } }
public void set include internal d t d declaration ( boolean include ) { this . include internal d t d declaration = include ; }
public void set include external d t d declaration ( boolean include ) { this . include external d t d declaration = include ; }
protect boolean be ignorable entity ( string name ) { return `` amp `` . equal ( name ) || `` apos `` . equal ( name ) || `` gt `` . equal ( name ) || `` lt `` . equal ( name ) || `` quot `` . equal ( name ) ; }
public void set timestamp ( final long timestamp ) { this . timestamp = timestamp ; }
public void set sub protocol ( string . . . protocol ) { sub protocol . clear ( ) ; collection . add all ( sub protocol , protocol ) ; }
public void set accept sub protocol ( string protocol ) { set header ( sec_websocket_protocol , protocol ) ; }
public void set extension ( list < extension config > extension ) { this . extension . clear ( ) ; if ( extension ! = null ) { this . extension . add all ( extension ) ; } }
public string to string ( ) { return format . format annotate parameter ( this ) ; }
public string to string ( ) { return format . format annotate parameter ( this ) ; }
public t create ( final creational context < t > creational context ) { t instance = get producer ( ) . produce ( creational context ) ; instance = check return value ( instance ) ; return instance ; }
public void validate injection point ( injection point ij , bean manager impl bean manager ) { validate injection point for definition error ( ij , ij . get bean ( ) , bean manager ) ; validate metadata injection point ( ij , ij . get bean ( ) , validator logger . injection_into_non_bean ) ; validate event metadata injection point ( ij ) ; validate injection point for deployment problem ( ij , ij . get bean ( ) , bean manager ) ; }
public boolean be available ( ) { return available ; }
protect void init valid ( enhanced annotation < t > annotate annotation ) { this . valid = false ; for ( class < ? extend annotation > annotation type : get meta annotation type ( ) ) { if ( annotated annotation . be annotation present ( annotation type ) ) { this . valid = true ; } } }
public void clear annotation data ( class < ? extend annotation > annotation class ) { stereotype . invalidate ( annotation class ) ; scope . invalidate ( annotation class ) ; qualifier . invalidate ( annotation class ) ; interceptor binding . invalidate ( annotation class ) ; }
public < t > t get ( contextual < t > contextual , creational context < t > creational context ) { if ( ! be active ( ) ) { throw new context not active exception ( ) ; } if ( creational context ! = null ) { t instance = contextual . create ( creational context ) ; if ( creational context instanceof weld creational context < ? > ) { add dependent instance ( instance , contextual , ( weld creational context < t > ) creational context ) ; } return instance ; } else { return null ; } }
public weld event < object > event ( ) { check be run ( ) ; if ( event == null ) { synchronize ( this ) { if ( event == null ) { event = bean manager ( ) . event ( ) ; } } } return event ; }
public < t > resolve observer < t > resolve observer method ( type event type , annotation . . . qualifier ) { check event object type ( event type ) ; return this . < t > resolve observer method ( build event resolvable ( event type , qualifier ) ) ; }
public void fire event ( object event , resolvable resolvable ) { check event object type ( event ) ; notify ( resolve observer method ( resolvable ) , event , null ) ; }
public final expression optimize ( expression visitor visitor , item type context item type ) { return this ; }
public < t > resolve observer < t > resolve observer method ( type event type , annotation . . . qualifier ) { check event object type ( event type ) ; return this . < t > resolve observer method ( build event resolvable ( event type , qualifier ) ) ; }
public type safe decorator resolver get decorator resolver ( ) { return decorator resolver ; }
public string to string ( ) { return ( be valid ( ) ? `` valid `` : `` invalid `` ) + `` qualifier model for `` + get raw type ( ) + `` with non-binding member `` + get non bind member ( ) ; }
public void clear annotation data ( class < ? extend annotation > annotation class ) { stereotype . invalidate ( annotation class ) ; scope . invalidate ( annotation class ) ; qualifier . invalidate ( annotation class ) ; interceptor binding . invalidate ( annotation class ) ; }
public static < t > builder < t > builder ( ) { return new builder impl < t > ( ) ; }
protect static string list to comma delimited string ( list < string > string list ) { if ( string list == null ) { return `` `` ; } string builder result = new string builder ( ) ; for ( iterator < string > it = string list . iterator ( ) ; it . have next ( ) ; ) { object element = it . next ( ) ; if ( element ! = null ) { result . append ( element ) ; if ( it . have next ( ) ) { result . append ( `` , `` ) ; } } } return result . to string ( ) ; }
protect void check type ( ) { if ( ! be dependent ( ) & & get enhance annotated ( ) . be parameterized type ( ) ) { throw bean logger . log . manage bean with parameterized bean class must be dependent ( type ) ; } boolean passivating = bean manager . be passivating scope ( get scope ( ) ) ; if ( passivating & & ! be passivation capable bean ( ) ) { if ( ! get enhance annotated ( ) . be serializable ( ) ) { throw bean logger . log . passivating bean need serializable impl ( this ) ; } else if ( have decorator ( ) & & ! all decorator be passivation capable ( ) ) { throw bean logger . log . passivating bean have non passivation capable decorator ( this , get first non passivation capable decorator ( ) ) ; } else if ( have interceptor ( ) & & ! all interceptor be passivation capable ( ) ) { throw bean logger . log . passivating bean have non passivation capable interceptor ( this , get first non passivation capable interceptor ( ) ) ; } } }
static public string to lower camel case ( string string ) { if ( string == null ) { return null ; } if ( string . be empty ( ) ) { return string ; } if ( string . length ( ) > 1 & & character . be upper case ( string . char at ( 1 ) ) & & character . be upper case ( string . char at ( 0 ) ) ) { return string ; } char char [ ] = string . to char array ( ) ; char [ 0 ] = character . to lower case ( char [ 0 ] ) ; return new string ( char ) ; }
public weld bean class ( class < ? > . . . class ) { bean class . clear ( ) ; add bean class ( class ) ; return this ; }
public instance < object > instance ( ) { check state ( ) ; return get instance ( ) ; }
public weld alternative ( class < ? > . . . alternative class ) { select alternative . clear ( ) ; select alternative ( alternative class ) ; return this ; }
public static bean manager provider get instance ( ) { / * x todo java- e e5 support need to be discuss if ( bmp singleton == null ) { // workaround for some java- e e5 environment in combination with a special // startup broadcaster for bootstrapping cdi // codi startup broadcaster . broadcast startup ( ) ; // here bmp might not be null ( depend on the broadcaster ) } * / if ( bmp singleton == null ) { throw new illegal state exception ( `` no `` + bean manager provider . class . get name ( ) + `` in place ! `` + `` please ensure that you configure the cdi implementation of your choice properly . `` + `` if your setup be correct , please clear all cache and compiled artifact . `` ) ; } return bmp singleton ; }
public void write ( record r ) throw i o exception { r . serialize ( archive , `` `` ) ; }
public purge task status get purge task status ( ) { return purge task status ; }
public string get data log dir ( ) { return data log dir ; }
public synchronize boolean remove child ( string child ) { if ( child == null ) { return false ; } return child . remove ( child ) ; }
public txn iterator read ( long zxid ) throw i o exception { return new file txn iterator ( log dir , zxid ) ; }
public txn iterator read ( long zxid ) throw i o exception { return new file txn iterator ( log dir , zxid ) ; }
public long skip ( long n ) { if ( position+n < =document . get length ( ) ) { position += n ; return n ; } long temp = position ; position = document . get length ( ) ; return document . get length ( ) - temp ; }
public long get server id ( ) { return self . get id ( ) ; }
public int get min session timeout ( ) { return min session timeout ; }
public synchronize boolean remove child ( string child ) { if ( child == null ) { return false ; } return child . remove ( child ) ; }
public long get data tree last processed zxid ( ) { return data tree . last processed zxid ; }
public data node get node ( string path ) { return data tree . get node ( path ) ; }
public void kill session ( long session id , long zxid ) { data tree . kill session ( session id , zxid ) ; }
public int get session timeout ( ) { return cnxn . get session timeout ( ) ; }
public synchronize void register ( watcher watcher ) { watch manager . default watcher = watcher ; }
public string to string ( ) { state state = get state ( ) ; return ( `` state : `` + state . to string ( ) + ( state . be connect ( ) ? `` timeout : `` + get session timeout ( ) + `` `` : `` `` ) + cnxn ) ; }
public int get session timeout ( ) { return cnxn . get session timeout ( ) ; }
public process executor directory ( file directory ) { builder . directory ( directory ) ; return this ; }
public process executor redirect error also to ( output stream output ) { stream ( redirect error also to ( pump ( ) , output ) ) ; redirect error stream ( false ) ; return this ; }
public process executor remove listener ( class < ? extend process listener > listener type ) { listener . remove all ( listener type ) ; return this ; }
public process executor stream ( execute stream handler stream ) { validate stream ( stream , read output ) ; this . streams = stream ; return this ; }
