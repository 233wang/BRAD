public x content builder human readable ( boolean human readable ) { this . human readable = human readable ; return this ; }
public string get data type ( ) { return data type ; }
public allocation command get command ( ) { return command ; }
public string get name ( ) { return name ; }
public final method parameter get parameter ( ) { return this . parameter ; }
public int size ( ) { return data . length ; }
public string to j s o n string ( ) { return to j s o n string ( this , j s o n value . compression ) ; }
public void set o ( activation o s o ) { this . os = o ; } // -- void set o ( activation o s )
public boolean get use context class loader ( ) { return use context class loader ; }
public string get package ( ) { return package ; }
public static class get class ( string class name ) throw class not find exception { return get class ( class name , true ) ; }
public void set class loader ( class loader class loader ) { this . class loader = class loader ; }
public project get project ( ) { return project ; }
public exception get exception ( ) { return this . exception ; }
public throwable get cause ( ) { return cause ; }
public final client handler get next ( ) { return next ; }
public project get project ( ) { return project ; }
public void set excludes ( list < string > excludes list ) { string [ ] exclude = excludes list . to array ( new string [ excludes list . size ( ) ] ) ; if ( excludes == null ) { this . exclude = null ; } else { set excludes ( excludes ) ; } }
public void set case sensitive ( boolean case sensitive ) { this . case sensitive = case sensitive ; }
public resource get resource ( string name ) { return new file resource ( get base dir ( ) , name ) ; }
public int get status ( ) { return status type . get status code ( ) ; }
public reader chain ( final reader rdr ) { tail filter new filter = new tail filter ( rdr ) ; new filter . set line ( get line ( ) ) ; new filter . set skip ( get skip ( ) ) ; new filter . set initialized ( true ) ; return new filter ; }
public element prepend child ( node child ) { validate . not null ( child ) ; add child ( 0 , child ) ; return this ; }
public char get end ( ) { return this . end ; }
public float next tab stop ( float x , int tab offset ) { if ( tab size == 0 ) { return x ; } int ntabs = ( ( int ) x - tab base ) / tab size ; return tab base + ( ( ntabs + 1f ) * tab size ) ; }
public void set filter ( boolean filter ) { this . filter = filter ; }
public void set project ( project project ) { this . project = project ; ant type table = new ant type table ( project ) ; }
public void set name ( string name ) { this . name = name ; }
public tag get tag ( ) { return this . tag ; }
public void register value target ( target target ) { if ( target == null ) { target = new vector ( ) ; } target . add element ( target ) ; }
public void add handler ( handler handler ) { set handler ( array util . add to array ( get handler ( ) , handler , handler . class ) ) ; }
public final expect builder with input ( input stream . . . input ) { this . input = input ; return this ; }
public boolean be valid ( ) { return valid ; }
public synchronize void add configure ( property helper property helper ) { if ( this . property helper ! = null ) { throw new build exception ( `` only one property helper can be instal `` ) ; } this . property helper = property helper ; }
public object get additional property ( ) { return additional property ; }
public void set filter ( boolean filter ) { this . filter = filter ; }
public token filter filter start array ( ) { return this ; }
public void set basedir ( file dir ) { base dir = dir ; }
public string get mode ( ) { return mode ; }
public task create task ( string task type ) throw build exception { return component helper . get component helper ( this ) . create task ( task type ) ; }
public void add task definition ( string task name , class task class ) throw build exception { component helper . get component helper ( this ) . add task definition ( task name , task class ) ; }
public static event < target info > target create ( ) { return new event < > ( `` target . target destroyed `` , map ( `` target info `` , target info . class ) ) ; }
public void set message ( string message ) { this . message = message ; }
public synchronize resource get resource ( string name ) { return new file resource ( basedir , name ) ; }
public project get project ( ) { return project ; }
public type component ( ) { return component ; }
public string get property name ( ) { return property name ; }
public static boolean a boolean ( enumeration enumeration ) { if ( null == enumeration ) { return false ; } return enumeration . have more element ( ) ; }
public string location ( ) { return location ; }
public void fail task ( final task attempt i d task id ) throw i o exception { kill task ( task id , true ) ; }
public void handle output ( string output ) { if ( ant ! = null ) { ant . handle output ( output ) ; } else { super . handle output ( output ) ; } }
public string get proxy ( ) { return proxy ; }
public allocation command get command ( ) { return command ; }
protect void load ( string srv record ) throw dns exception { super . load ( null ) ; string tokenizer str tokens = new string tokenizer ( srv record ) ; try { while ( str token . have more token ( ) ) { string priority = str token . next token ( ) ; this . priority = integer . parse int ( priority ) ; string weight = str token . next token ( ) ; this . weight = integer . parse int ( weight ) ; string port = str token . next token ( ) ; this . port = integer . parse int ( port ) ; string target = str token . next token ( ) ; this . target = target ; } } catch ( number format exception ne ) { throw new dns exception ( `` number format exception `` + ne . get message ( ) ) ; } catch ( no such element exception ne ) { throw new dns exception ( `` no such element exception `` + ne . get message ( ) ) ; } }
public void set max memory ( long max memory ) { data utils . check argument ( max memory > 0 , `` max memory must be large than 0 , be { 0 } `` , max memory ) ; this . max memory = max memory ; if ( segment ! = null ) { long max = 1 + max memory / segment . length ; for ( segment < v > s : segment ) { s . set max memory ( max ) ; } } }
public void set output ( file output ) { this . output = output ; }
public set < string > get reference string ( ) { return reference string ; }
public string get compiler ( ) { return super . get compiler ( ) ; }
public void set compiler ( string compiler ) { log ( error_ignoring_compiler_option , project . msg_warn ) ; }
public file get dir ( ) { return dir ; }
public void set parent ( element type parent ) { the parent = parent ; }
public void set file ( file file ) { this . file = file ; }
public final expect builder with buffer size ( int buffer size ) { if ( buffer size < = 0 ) { throw new illegal argument exception ( `` buffer size must be > 0 `` ) ; } this . buffer size = buffer size ; return this ; }
public static void set default configuration ( engine configuration config ) { default configuration . set ( config ) ; }
public boolean be valid ( ) { return valid ; }
public void set function name ( name name ) { function name = name ; if ( name ! = null ) name . set parent ( this ) ; }
public string get condition ( ) { return condition ; }
public uri get u r i ( ) { return u ; }
public int get num sub ( ) { return num sub ; }
public void start boolean ( ) { }
public output < t > begin ( ) { return begin ; }
public void set file ( file file ) { this . file = file ; }
public string get version ( ) { return version == null ? `` `` : version ; }
public mapping metadata default mapping ( ) { return mapping . get ( mapper service . default_mapping ) ; }
protect void internal set encoding ( string encode ) { if ( native_encoding . equal ( encode ) ) { encode = null ; } this . encode = encoding ; }
public resource get resource ( string name ) { return new file resource ( get base dir ( ) , name ) ; }
public void set file i d ( string file i d ) { this . file i d = file i d ; }
public string get user ( ) { return user ; }
public void set user ( string user ) { debug code call ( `` set user `` , user ) ; this . user name = user ; }
public void set display name ( string display name ) { assert . have length ( display name , `` display name must not be empty `` ) ; this . display name = display name ; }
public void set classpath ref ( reference r ) { create classpath ( ) . set refid ( r ) ; }
public void add ( file selector selector ) { append selector ( selector ) ; }
public void add selector ( select selector selector ) { used match task = true ; super . add selector ( selector ) ; }
public void add selector ( select selector selector ) { used match task = true ; super . add selector ( selector ) ; }
public void set depend ( boolean depend ) { this . depend = depend ; }
public void add create ( i resource create ) { if ( f create == null ) f create= new array list < > ( 2 ) ; f create . add ( create ) ; if ( f ignore count == 0 ) { internal add ( new create description ( create ) ) ; } }
public void set file ( file file ) { this . file = file ; }
public string password ( ) { return password ; }
public address get address ( ) { return address ; }
public token peek token ( ) { while ( need more token ( ) ) { fetch more token ( ) ; } return this . token . get ( 0 ) ; }
public address get address ( ) { return address ; }
public void set value ( string value ) { this . value = value ; }
public void set text ( string text ) { this . text = text ; }
public output stream wrap out if need ( output stream out ) { return out ; }
public void set environment ( string [ ] env ) { this . env = env ; }
public string [ ] get environment ( ) { return ( env == null || new environment ) ? env : patch environment ( ) ; }
public void interrupt ( ) { interrupted . set ( true ) ; thread . current thread ( ) . interrupt ( ) ; }
public configuration builder set parallel ( boolean parallel ) { be parallel = parallel ; return this ; }
public void set force ( boolean force ) { this . force = force ; }
public mapper get first map ( ) { return ( mapper . size ( ) > 0 ) ? mapper . get ( 0 ) : null ; }
public void add setup ( sequential sequence ) { log override ( `` setup `` , setup ) ; setup = sequence ; }
public void set src ( final file src file ) { this . src file = src file ; }
public void set d ( p d action d ) { action . set item ( c o s name . d , d ) ; }
public void set d ( file d ) { this . d = d ; }
protect output stream wrap stream ( output stream out ) throw i o exception { return new g z i p output stream ( out ) ; }
public static extension [ ] get option ( final manifest manifest ) { return get list ( manifest , optional_extension_list ) ; }
public void set classpath ( string classpath ) { this . classpath = classpath ; }
public void set classpath ( path classpath ) { if ( compile classpath == null ) { compile classpath = classpath ; } else { compile classpath . append ( classpath ) ; } }
public void set classpath ref ( reference r ) { create classpath ( ) . set refid ( r ) ; }
public boolean get listfiles ( ) { return list file ; }
public void set listfiles ( boolean list ) { list file = list ; }
public string get deprecation message ( ) { return deprecation message ; }
public t get maximum ( ) { return maximum ; }
public void set optimize predicate ( boolean optimize predicate ) { this . optimize predicate = optimize predicate ; }
public void set sourcepath ( final string p ) { if ( src path ! = null ) throw new build exception ( `` src path can not be specify twice . `` ) ; src path = new path ( get project ( ) , p ) ; }
public string get private key ( ) { return private key ; }
public static i file info create file info ( ) { return new file info ( ) ; }
public void set last author ( final string last author ) { set1st property ( property i d map . pid_lastauthor , last author ) ; }
public void set private ( boolean b ) { add arg if ( b , `` -private `` ) ; }
public void set private ( boolean b ) { add arg if ( b , `` -private `` ) ; }
public void set private ( boolean b ) { add arg if ( b , `` -private `` ) ; }
public void set classpath ref ( reference r ) { create classpath ( ) . set refid ( r ) ; }
public void start boolean ( ) { }
public int get user id ( ) { return this . user id ; }
public string get user id ( ) { return user id ; }
public void set to list ( string list ) { string tokenizer token = new string tokenizer ( list , `` , `` ) ; while ( token . have more token ( ) ) { to list . add element ( new email address ( token . next token ( ) ) ) ; } }
public void add resource ( string name ) { add resource object ( new resource ( name ) ) ; }
public void set quiet ( boolean quiet ) { this . quiet = quiet ; }
protect filter chain new filter chain ( filter holder filter holder , filter chain chain ) { return new chain ( filter holder , chain ) ; }
public void set element ( string element ) { assert . have text ( element , `` 'element ' can not be null or blank `` ) ; this . element = element ; }
public void rethrow any build exception ( ) { build exception ex = get build exception ( ) ; if ( ex ! = null ) { throw ex ; } }
public static void main ( string [ ] args ) { main main = new main ( `` rhino java script debugger `` ) ; main . do break ( ) ; main . set exit action ( new i proxy ( i proxy . exit_action ) ) ; system . set in ( main . get in ( ) ) ; system . set out ( main . get out ( ) ) ; system . set err ( main . get err ( ) ) ; global global = org . mozilla . javascript . tool . shell . main . get global ( ) ; global . set in ( main . get in ( ) ) ; global . set out ( main . get out ( ) ) ; global . set err ( main . get err ( ) ) ; main . attach to ( org . mozilla . javascript . tool . shell . main . shell context factory ) ; main . set scope ( global ) ; main . pack ( ) ; main . set size ( 600 , 460 ) ; main . set visible ( true ) ; org . mozilla . javascript . tool . shell . main . exec ( args ) ; }
public void set level ( int level ) { this . trace level = level ; }
public string get mode ( ) { return mode ; }
public item get item ( ) { return null ; }
public void add ( file selector selector ) { append selector ( selector ) ; }
public void set d dir ( file d dir ) { this . d dir = d dir ; }
public void set thread priority ( int thread priority ) { this . thread priority = thread priority ; }
public void set src resource ( resource src ) { if ( ! src . be exists ( ) ) { throw new build exception ( `` the archive do n't exist `` ) ; } if ( src . be directory ( ) ) { throw new build exception ( `` the archive ca n't be a directory `` ) ; } if ( src instanceof file resource ) { source = ( ( file resource ) src ) . get file ( ) ; } else if ( ! support non file resource ( ) ) { throw new build exception ( `` only file system resource be `` + `` support . `` ) ; } src resource = src ; }
protect zip file get archive ( ) throw i o exception { return get zip file ( get name ( ) ) ; }
public void set ignore ( boolean ignore ) { this . ignore = ignore ; }
public r pattern get r context ( ) { return this . r context ; }
public reference get refid ( ) { return ref ; }
public void set value ( string value ) { this . value = value ; }
protect synchronized final void error ( string err ) throw s q l exception { check context ( ) ; db . result_error ( context , err ) ; }
public io . vertx . axle . core . stream . pump start ( ) { delegate . start ( ) ; return this ; }
public synchronize state mark available ( ) { if ( map . be empty ( ) ) { state = state . idle ; } else { state = state . pending ; } return state ; }
public string get event ( ) { return event ; }
public void set file ( file file ) { this . file = file ; }
public void set property ( string property ) { this . property = property ; }
public commandline get vm command ( ) { return get actual v m command ( ) ; }
public void set source ( file source ) { this . source = source ; }
public void set cache stub ( boolean cache stub ) { this . cache stub = cache stub ; }
public list < path > get file list ( ) { return file list ; }
public void set include ( string value ) { this . include = value ; }
public integer get error arg ( ) { return error arg ; }
public void fail task ( final task attempt i d task id ) throw i o exception { kill task ( task id , true ) ; }
public file get dir ( ) { return dir ; }
public output < string > output ( ) { return output ; }
public void set file ( file file ) { this . file = file ; }
public void set fail on error ( boolean value ) { fail on error = value ; }
public void set style ( string s ) { get c o s object ( ) . set name ( `` s `` , s ) ; }
public string [ ] get included directory ( ) { return dirs include . to array ( new string [ dirs include . size ( ) ] ) ; }
public void execute ( ) throw build exception { if ( property == null ) { throw new build exception ( `` property attribute be require . `` , get location ( ) ) ; } boolean up to date = eval ( ) ; if ( up to date ) { get project ( ) . set new property ( property , get value ( ) ) ; if ( mapper element == null ) { log ( `` file \ `` `` + target file . get absolute path ( ) + `` \ `` be up-to-date . `` , project . msg_verbose ) ; } else { log ( `` all target file be up-to-date . `` , project . msg_verbose ) ; } } }
public file get directory ( ) { return f directory ; }
public void set property ( final string property ) { this . property name = property ; }
public void set src resource ( resource src ) { if ( src . be directory ( ) ) { throw new build exception ( `` the source ca n't be a directory `` ) ; } if ( src instanceof file resource ) { source = ( ( file resource ) src ) . get file ( ) ; } else if ( ! support non file resource ( ) ) { throw new build exception ( `` only file system resource be `` + `` support . `` ) ; } this . src = src ; }
public void set file ( file file ) { this . file = file ; }
protect boolean check ( file basedir , string [ ] file ) { boolean up to date = true ; if ( ! archive be up to date ( file , basedir ) ) { up to date = false ; } for ( int i = 0 ; i < file . length ; ++i ) { if ( tar file . equal ( new file ( basedir , file [ i ] ) ) ) { throw new build exception ( `` a tar file can not include `` + `` itself `` , get location ( ) ) ; } } return up to date ; }
public file get dir ( ) { return dir ; }
public x509 certificate get decryption certificate ( ) { return decryption certificate ; }
public void set timeout ( int timeout ) { this . timeout = timeout ; }
public catalog get catalog ( ) { return catalog resolver . get catalog ( ) ; }
public file get dir ( ) { return dir ; }
public void set in ( input stream in ) { this . in = in ; }
public project get project ( ) { return project ; }
public void clear ( ) { lock . lock ( ) ; try { for ( node < e > f = first ; f ! = null ; ) { f . item = null ; final node < e > n = f . next ; f . prev = null ; f . next = null ; f = n ; } first = last = null ; count = 0 ; not full . signal all ( ) ; } finally { lock . unlock ( ) ; } }
public void set allow duplicate key ( boolean allow duplicate key ) { this . allow duplicate key = allow duplicate key ; }
public int get level ( ) { return level ; }
public static void main ( string [ ] args ) { main main = new main ( `` rhino java script debugger `` ) ; main . do break ( ) ; main . set exit action ( new i proxy ( i proxy . exit_action ) ) ; system . set in ( main . get in ( ) ) ; system . set out ( main . get out ( ) ) ; system . set err ( main . get err ( ) ) ; global global = org . mozilla . javascript . tool . shell . main . get global ( ) ; global . set in ( main . get in ( ) ) ; global . set out ( main . get out ( ) ) ; global . set err ( main . get err ( ) ) ; main . attach to ( org . mozilla . javascript . tool . shell . main . shell context factory ) ; main . set scope ( global ) ; main . pack ( ) ; main . set size ( 600 , 460 ) ; main . set visible ( true ) ; org . mozilla . javascript . tool . shell . main . exec ( args ) ; }
public element remove ( ) { for ( element element : this ) { element . remove ( ) ; } return this ; }
public string [ ] get include pattern ( project p ) { if ( be reference ( ) ) { return get ref ( p ) . get include pattern ( p ) ; } else { read file ( p ) ; return make array ( include list , p ) ; } }
public void add ( file selector selector ) { append selector ( selector ) ; }
public void set classpath ( string classpath ) { this . classpath = classpath ; }
public void set src ( final file src file ) { this . src file = src file ; }
public void set src ( final file src file ) { this . src file = src file ; }
public string get prefix ( ) { return prefix ; }
public iterator property file ( ) { return resource . iterator ( ) ; }
public iterator property file ( ) { return resource . iterator ( ) ; }
public void apply ( ) { assertion . set allow compare private field ( compare private field enable ( ) ) ; assertion . set allow extract private field ( extract private field enable ( ) ) ; assertion . set extract bare name property method ( bare name property extraction enable ( ) ) ; assertion . set lenient date parsing ( lenient date parsing enable ( ) ) ; assertion . set max element for printing ( max element for printing ( ) ) ; assertion . set max length for single line description ( max length for single line description ( ) ) ; assertion . set remove assert j related element from stack trace ( remove assert j related element from stack trace enable ( ) ) ; assertion . use representation ( representation ( ) ) ; additional date format ( ) . for each ( assertion : : register custom date format ) ; }
public executable get executable ( ) { return executable ; }
public static final string get command ( i m a p command command ) { return command . get i m a p command ( ) ; }
public string get path ( ) { return path ; }
public boolean be reference ( ) { return refid ! = null ; }
public object clone ( ) { if ( be reference ( ) ) { return ( ( zip file set ) get ref ( get project ( ) ) ) . clone ( ) ; } else { return super . clone ( ) ; } }
public file get file ( ) { return be reference ( ) ? ( ( file resource ) get check ref ( ) ) . get file ( ) : file ; }
public string get comment ( ) { return comment ; }
public synchronize void add filter ( filter filter ) { if ( be reference ( ) ) { throw no child allow ( ) ; } filter . add element ( filter ) ; filter hash = null ; }
public void set filter ( boolean filter ) { this . filter = filter ; }
public synchronize void add filter ( filter filter ) { if ( be reference ( ) ) { throw no child allow ( ) ; } filter . add element ( filter ) ; filter hash = null ; }
public file filter get file filter ( ) { return file filter ; }
public void set filter ( boolean filter ) { this . filter = filter ; }
public void add configure ( file name mapper file name mapper ) { add ( file name mapper ) ; }
public int compare to ( object o ) { sweep line event pe = ( sweep line event ) o ; if ( x value < pe . x value ) return -1 ; if ( x value > pe . x value ) return 1 ; if ( event type < pe . event type ) return -1 ; if ( event type > pe . event type ) return 1 ; return 0 ; }
public void set classpath ( string classpath ) { this . classpath = classpath ; }
public synchronize pattern set merge pattern ( project p ) { if ( be reference ( ) ) { return get ref ( ) . merge pattern ( p ) ; } pattern set p = new pattern set ( ) ; p . append ( default pattern , p ) ; final int count = additional pattern . size ( ) ; for ( int i = 0 ; i < count ; i++ ) { object o = additional pattern . element at ( i ) ; p . append ( ( pattern set ) o , p ) ; } return p ; }
public static void set security manager ( security manager value ) { _security manager = value ; }
public void append regex ( string regex ) { property ref r = new property ref ( ) ; r . set regex ( regex ) ; add propertyref ( r ) ; }
public void set regex ( string regex ) { if ( regex ! = null & & regex . length ( ) ! = 0 ) { this . regex = regex ; property set p = new property set ( ) ; p . set project ( get project ( ) ) ; p . append regex ( regex ) ; add propertyset ( p ) ; } }
public mapper create mapper ( ) throw build exception { if ( mapper element ! = null ) { throw new build exception ( `` can not define more than one mapper `` , get location ( ) ) ; } mapper element = new mapper ( get project ( ) ) ; return mapper element ; }
public project get project ( ) { return project ; }
public void set name ( string name ) { this . name = name ; }
public long get last modified ( ) { if ( be reference ( ) ) { return ( ( resource ) get check ref ( ) ) . get last modified ( ) ; } if ( ! be exists ( ) || lastmodified == null ) { return unknown_datetime ; } long result = lastmodified . long value ( ) ; return result < unknown_datetime ? unknown_datetime : result ; }
public sequence iterator get another ( ) throw x path exception { throw new unsupported operation exception ( `` get another `` ) ; }
public void push enclose binary expression ( binary expression binary expression ) { enclose binary expression . add first ( binary expression ) ; }
public void set last modified date ( final long ntfs last modified date ) { this . last modified date = ntfs last modified date ; }
public int hash code ( ) { return name . hash code ( ) ; } // hash code
public void set name ( string name ) { if ( name == null ) { throw new illegal argument exception ( `` name must not be null `` ) ; } this . name = name ; }
public boolean have next ( ) { return ( this . next obj ! = null ) ; }
public i file get file ( ) { return f file ; }
public string get file ( ) { return file ; }
public file get file ( ) { return be reference ( ) ? ( ( file resource ) get check ref ( ) ) . get file ( ) : file ; }
public boolean have next ( ) { return ! empty ; }
public string get pattern ( ) { return pattern ; }
public static object output stream new object output stream ( output stream output stream ) throw i o exception { return new object output stream ( output stream ) ; }
public set < string > get reference string ( ) { return reference string ; }
public date time with early offset at overlap ( ) { long new millis = get zone ( ) . adjust offset ( get millis ( ) , false ) ; return with millis ( new millis ) ; }
public static int join r g b ( byte r , byte g , byte b ) { return join r g b ( new byte [ ] { r , g , b } ) ; }
public void set block when exhaust ( boolean block when exhaust ) { this . block when exhaust = block when exhaust ; }
public string get type ( ) { return type ; }
public string get name ( ) { return ( string ) get value ( name ) ; }
public url find ( string classname ) { if ( this . classname . equal ( classname ) ) { string cname = classname . replace ( ' . ' , '/ ' ) + `` . class `` ; try { return new url ( null , `` file : / byte array class path/ `` + cname , new bytecode u r l stream handler ( ) ) ; } catch ( malformed u r l exception e ) { } } return null ; }
public void set classpath ( path classpath ) { if ( be reference ( ) ) { throw too many attribute ( ) ; } if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } }
public string [ ] get parameter key ( ) { if ( parameter == null ) return new string [ 0 ] ; return parameter . key set ( ) . to array ( new string [ parameter . size ( ) ] ) ; }
public boolean be file ( ) { return be file ; }
public boolean test unless condition ( object value ) { return null or empty ( value ) || ! eval a boolean or property name ( value ) ; }
public void set user id ( int uid ) { this . uid = uid ; }
public void set group name ( string group name ) { this . group name = new string buffer ( group name ) ; }
public long get g i d ( ) { return zip util . big to long ( gid ) ; }
protect abstract file set get ref ( project p ) { die on circular reference ( p ) ; object o = get refid ( ) . get referenced object ( p ) ; if ( o instanceof zip file set ) { return ( abstract file set ) o ; } else if ( o instanceof file set ) { zip file set zfs = new zip file set ( ( file set ) o ) ; configure file set ( zfs ) ; return zfs ; } else { string msg = get refid ( ) . get ref id ( ) + `` doesn\'t denote a zipfileset or a fileset `` ; throw new build exception ( msg ) ; } }
public static < t1 , t2 , t3 > tuple3 < t1 , t2 , t3 > tuple ( t1 v1 , t2 v2 , t3 v3 ) { return new tuple3 < > ( v1 , v2 , v3 ) ; }
public void set pa enc t enc ( pa enc t enc pa enc t enc ) { this . pa enc t enc = pa enc t enc ; }
protect abstract file set get ref ( project p ) { die on circular reference ( p ) ; object o = get refid ( ) . get referenced object ( p ) ; if ( o instanceof tar file set ) { return ( abstract file set ) o ; } else if ( o instanceof file set ) { tar file set zfs = new tar file set ( ( file set ) o ) ; configure file set ( zfs ) ; return zfs ; } else { string msg = get refid ( ) . get ref id ( ) + `` doesn\'t denote a tarfileset or a fileset `` ; throw new build exception ( msg ) ; } }
public object clone ( ) { if ( be reference ( ) ) { return ( ( dir set ) get ref ( get project ( ) ) ) . clone ( ) ; } else { return super . clone ( ) ; } }
public void set ignore ( boolean ignore ) { this . ignore = ignore ; }
public void add configure ( file name mapper file name mapper ) { add ( file name mapper ) ; }
public string to string ( ) { string builder sb = new string builder ( ) ; sb . append ( `` atts [ `` ) ; for ( int i = 0 ; i < attribute . size ( ) ; i++ ) { att att = attribute . get ( i ) ; sb . append ( att . get q name ( ) ) ; sb . append ( `` = `` ) ; sb . append ( att . get value ( ) ) ; sb . append ( `` ; `` ) ; } sb . append ( `` ] `` ) ; return sb . to string ( ) ; }
public option add choice ( string choice ) { this . choice . add ( choice ) ; return this ; }
public int get length ( ) { return get impl ( ) . get length ( impl ) ; }
public file create temp file ( string prefix , string suffix , file parent dir ) { return create temp file ( prefix , suffix , parent dir , false , false ) ; }
public string get description ( ) { return `` file [ `` + this . file . get absolute path ( ) + `` ] `` ; }
public static void move ( file from , file to ) throw i o exception { check not null ( from ) ; check not null ( to ) ; check argument ( ! from . equal ( to ) , `` source % s and destination % s must be different `` , from , to ) ; if ( ! from . rename to ( to ) ) { copy ( from , to ) ; if ( ! from . delete ( ) ) { if ( ! to . delete ( ) ) { throw new i o exception ( `` unable to delete `` + to ) ; } throw new i o exception ( `` unable to delete `` + from ) ; } } }
public static class loader default class loader ( ) { return thread . current thread ( ) . get context class loader ( ) ; }
public default boolean be available ( ) { return true ; }
public integer get error arg ( ) { return error arg ; }
public void add text ( string text ) { script += text ; }
static public test result run ( test test ) { test runner runner= new test runner ( ) ; return runner . do run ( test ) ; }
protect void start monitoring ( ) { synchronize ( this ) { if ( f thread == null ) { f do . set ( false ) ; f thread = new thread ( ( runnable ) this : : read , debug core message . output stream monitor_label ) ; f thread . set daemon ( true ) ; f thread . set priority ( thread . min_priority ) ; f thread . start ( ) ; } } }
public final static void debug ( string s ) { if ( debug ) debug . println ( `` // debug : `` + s ) ; }
public int get user id ( ) { return this . user id ; }
public void set group ( string group name ) { check tar file set attribute allow ( ) ; group name set = true ; this . group name = group name ; }
public boolean be g n u long link entry ( ) { return link flag == lf_gnutype_longlink & & name . equal ( gnu_longlink ) ; }
public int length ( ) { return this . len ; }
public void set header ( header [ ] header ) { clear ( ) ; for ( int i = 0 ; i < header . length ; i++ ) { add header ( header [ i ] ) ; } }
public void set uid ( int uid ) { check tar file set attribute allow ( ) ; user id set = true ; this . uid = uid ; }
protect int get mode ( ) { return this . mode ; }
public zip short get central directory length ( ) { return zero ; }
public void set local data source ( boolean local data source ) { this . local data source = local data source ; }
public boolean be external ( ) { return external ; }
protect final zip extra field [ ] get current extra field ( ) { return ( zip extra field [ ] ) current_zip_extra . get ( ) ; }
public byte to byte ( ) { return new byte ( byte value ( ) ) ; }
public static method [ ] get all declare method ( class < ? > leaf class ) { final list < method > method = new array list < method > ( 32 ) ; do with method ( leaf class , new method callback ( ) { @ override public void do with ( method method ) { method . add ( method ) ; } } ) ; return method . to array ( new method [ method . size ( ) ] ) ; }
public byte [ ] get ( ) { if ( bytes == null ) { byte = new byte [ 0 ] ; } return byte ; }
public boolean be restrict ( ) { return restrict ; }
public void set input ( string input ) { this . input = input ; }
public string get version ( ) { return version == null ? `` `` : version ; }
public void set file separator ( string sep ) { if ( sep == null || sep . length ( ) ! = 1 ) { throw new illegal argument exception ( `` file separator have to be a single character and not `` + sep ) ; } ( ( ssh repository ) get repository ( ) ) . set file separator ( sep . trim ( ) . char at ( 0 ) ) ; }
protect final boolean be in include mode ( ) { return `` include `` . equal ( get task type ( ) ) ; }
public void set value ( boolean value ) { this . value = value ; }
public void restore ( ) throw exception { setting . restore ( ) ; super . restore ( ) ; }
public void add resource ( string name ) { add resource object ( new resource ( name ) ) ; }
public void set encoding ( string encode ) { this . encode = encoding ; }
protect final zip extra field [ ] get current extra field ( ) { return ( zip extra field [ ] ) current_zip_extra . get ( ) ; }
public static void set in include mode ( boolean include mode ) { in include mode . set ( boolean . value of ( include mode ) ) ; }
public static collection flatten ( object [ ] self ) { return flatten ( to list ( self ) , new array list ( ) ) ; }
public project get project ( ) { return project ; }
public boolean be trim string ( ) { return trim string ; }
public void add attribute ( string name ) { synchronize ( name ) { name . add ( name ) ; } }
public static void set dir ( string dir name ) { set dir ( new file ( dir name ) ) ; }
public list < file > get file ( ) { return file ; }
public static string get n l ( ) { return internal platform . get default ( ) . get n l ( ) ; }
public string get comment ( ) { return m comment ; }
public boolean be preserve old pack ( ) { return preserve old pack ; }
public object get data ( ) { return data ; }
public final int leave ( int m ) { return wip . add and get ( m ) ; }
public string get comment ( ) { return comment ; }
public class < ? > type for ( string type name ) { return type by name . get ( type name ) ; }
public void set ci management ( ci management ci management ) { this . ci management = ci management ; } // -- void set ci management ( ci management )
public void set max local ( int m ) { max local = m ; }
public string get v o b ( ) { return m v o b ; }
public void set v o b ( string vob ) { m v o b = vob ; }
public boolean be global ( ) { return false ; }
public kind get kind ( ) { return kind ; }
public string get path ( ) { return path ; }
public void read ( data input stream cp stream ) throw i o exception { set value ( new double ( cp stream . read double ( ) ) ) ; }
public void read ( data input stream cp stream ) throw i o exception { index = cp stream . read unsigned short ( ) ; class name = `` unresolved `` ; }
public void reset for clinit ( int constant pool index , int constant pool offset ) { this . current index = constant pool index ; this . current offset = constant pool offset ; if ( this . u t f8 cache . get ( attribute name constant . code name ) > = constant pool index ) { this . u t f8 cache . remove ( attribute name constant . code name ) ; } if ( this . u t f8 cache . get ( constant pool . clinit signature ) > = constant pool index ) { this . u t f8 cache . remove ( constant pool . clinit signature ) ; } if ( this . u t f8 cache . get ( constant pool . clinit ) > = constant pool index ) { this . u t f8 cache . remove ( constant pool . clinit ) ; } }
public string get field name ( ) { return field name ; }
public string get method class name ( ) { return method class name ; }
public string get class name ( ) { return class name ; }
public void set failonerror ( boolean fail on error ) { this . fail on error = fail on error ; }
public static regex property builder regex property ( string name ) { return new regex property builder ( name ) ; }
public int verify ( ) { return verify ; }
public string get in ( ) { return in ; }
public string get id ( ) { return id ; }
public boolean get a boolean ( ) { if ( element . size ( ) == 1 ) { return element . get ( 0 ) . get a boolean ( ) ; } throw new illegal state exception ( ) ; }
public void set classpath ( string classpath ) { this . classpath = classpath ; }
public static class get class ( string class name ) throw class not find exception { return get class ( class name , true ) ; }
public void set dtd handler ( d t d event listener handler ) { dtd handler = handler ; if ( handler ! = null ) handler . set document locator ( new locator ( ) { public string get public id ( ) { return d t d parser . this . get public id ( ) ; } public string get system id ( ) { return d t d parser . this . get system id ( ) ; } public int get line number ( ) { return d t d parser . this . get line number ( ) ; } public int get column number ( ) { return d t d parser . this . get column number ( ) ; } } ) ; }
public void set manifest ( file manifest file ) { if ( ! manifest file . exists ( ) ) { throw new build exception ( `` manifest file : `` + manifest file + `` do not exist . `` , get location ( ) ) ; } this . manifest file = manifest file ; }
public string get extension ( ) { return this . extension ; } // -- string get extension ( )
public void set version ( final string version ) { this . version = version ; }
public void set property ( string property ) { this . property = property ; }
public string location ( ) { return location ; }
public token get start ( ) { return start ; }
public string get action ( ) { return action ; }
public string password ( ) { return password ; }
public boolean be valid ( ) { return valid ; }
public source get source ( ) { return source ; }
public void set args ( string [ ] args ) { if ( args == null ) { args = new string [ ] { } ; } this . args = args ; this . args list = collection . unmodifiable list ( new array list < string > ( arrays . a list ( args ) ) ) ; }
public void set text ( boolean text ) { this . text = text ; }
public table get table ( ) { return table ; }
public void set prefix ( string prefix ) { this . prefix = prefix ; } // -- void set prefix ( string )
public static string get name ( final class < ? > cl , final string value if null ) { return cl == null ? value if null : cl . get name ( ) ; }
public string get file ( ) { return file ; }
public void set port ( int port ) { this . port = port ; }
public void set filename format ( string f ) { filename format = f ; }
public string get filename format ( ) { return filename format ; }
protect boolean be section line ( string line ) { if ( line == null ) { return false ; } return line . start with ( `` [ `` ) & & line . end with ( `` ] `` ) ; }
public project get project ( ) { return project ; }
public void set revision number ( int revision number ) { if ( revision number < 0 ) { throw new illegal argument exception ( `` the revision number shall be > -1 `` ) ; } this . get c o s object ( ) . set int ( c o s name . r , revision number ) ; }
public static matcher < string > match regex ( string regex ) { return string regular expression . match regex ( pattern . compile ( regex ) ) ; }
public void set output ( string output file ) { this . output = output file ; }
public void set schema location ( list < string > schema location ) { this . schema location = schema location ; }
public static x m l reader create x m l reader ( boolean validating , boolean namespace aware ) throw exception { s a x parser factory factory = s a x parser factory . new instance ( ) ; factory . set validating ( validate ) ; factory . set namespace aware ( namespace aware ) ; s a x parser parser = factory . new s a x parser ( ) ; return parser . get x m l reader ( ) ; }
public string get script ( ) { return script ; }
public void set manager ( manager manager ) { this . manager = manager ; }
public object get attribute ( string attribute name ) { return attribute map . get ( attribute name ) ; }
protect static void fail ( i message handler handler , string message , throwable thrown ) { handler . handle message ( new message ( message , i message . fail , throw , null ) ) ; }
public string get server ( ) { return server ; }
public string get home page ( ) { return home page ; }
public void set label ( string label ) { this . label = label ; }
public void set version ( string version ) { super . set internal version ( version ) ; }
public long get download setup time ( ) { return m download setup time ; }
public exception get exception ( ) { return this . exception ; }
public commandline get vm command ( ) { return get actual v m command ( ) ; }
public void start boolean ( ) { }
public void set label ( string label ) { this . label = label ; }
public string get version ( ) { return version == null ? `` `` : version ; }
public string get path ( ) { return path ; }
public boolean be recursive query detect ( ) { return be recursive query detect ; }
public void set version ( string version ) { super . set internal version ( version ) ; }
public date to date ( ) { return new date ( get millis ( ) ) ; }
public string get comment ( ) { return comment ; }
public void set classpath ref ( reference r ) { create classpath ( ) . set refid ( r ) ; }
public date time parser get parser ( ) { return internal parser date time parser . of ( i parser ) ; }
public void set failonerror ( boolean fail on error ) { this . fail on error = fail on error ; }
public static synchronize introspection helper get helper ( class c ) { return get helper ( null , c ) ; }
public void set fail on no resource ( boolean b ) { fail on no resource = b ; }
public void set d dir ( file d dir ) { this . d dir = d dir ; }
public static class signature to class signature ( string sig ) throw bad bytecode { try { return parse sig ( sig ) ; } catch ( index out of bound exception e ) { throw error ( sig ) ; } }
public final long row count ( ) { return row ; }
public int get return code ( ) { return rc ; }
public void set fail on error ( boolean value ) { fail on error = value ; }
public void set fail on no replacement ( boolean b ) { fail on no replacement = b ; }
public byte [ ] get local file data extra ( ) { byte [ ] extra = get extra ( ) ; return extra ! = null ? extra : new byte [ 0 ] ; }
public void add custom ( extend selector selector ) { append selector ( selector ) ; }
public void set value ( string value ) { this . value = value ; }
public long get last modified ( ) { if ( be reference ( ) ) { return ( ( resource ) get check ref ( ) ) . get last modified ( ) ; } if ( ! be exists ( ) || lastmodified == null ) { return unknown_datetime ; } long result = lastmodified . long value ( ) ; return result < unknown_datetime ? unknown_datetime : result ; }
public file get src ( project p ) { if ( be reference ( ) ) { return ( ( archive file set ) get ref ( p ) ) . get src ( p ) ; } return get src ( ) ; }
public void append regex ( string regex ) { property ref r = new property ref ( ) ; r . set regex ( regex ) ; add propertyref ( r ) ; }
public void set text ( string text ) { this . text = text ; }
public string get path ( ) { return path ; }
public int size ( ) { check tokenized ( ) ; return token . length ; }
public file create temp file ( string prefix , string suffix , file parent dir ) { return create temp file ( prefix , suffix , parent dir , false ) ; }
public void add text ( string text ) { this . script += text ; }
public int get index ( ) { return index ; }
public void set link exception ( exception ex ) { link exception = ex ; }
public boolean be g n u long name entry ( ) { return link flag == lf_gnutype_longname & & name . to string ( ) . equal ( gnu_longlink ) ; }
public long get offset ( ) { return offset ; }
public void set lenient fallback ( boolean lenient fallback ) { this . lenient fallback = lenient fallback ; }
public void mark ( final int read ahead limit ) { mark = idx ; }
public static move decision stay ( decision can remain decision ) { if ( can remain decision ! = null ) { assert can remain decision . type ( ) ! = type . no ; return new move decision ( can remain decision , null , allocation decision . no_attempt , null , null , 0 ) ; } else { return cached_stay_decision ; } }
public boolean seek exact ( bytes ref text ) throw i o exception { return seek ceil ( text ) == seek status . find ; }
public boolean equal ( object other ) { return this==other ; }
public long interval ( ) { return date histogram interval . interval ( ) ; }
public long interval ( ) { return date histogram interval . interval ( ) ; }
public boolean equal ( object obj ) { if ( obj == this ) { return true ; } if ( obj instanceof char set == false ) { return false ; } char set other = ( char set ) obj ; return set . equal ( other . set ) ; }
public int get min element ( ) { if ( be nil ( ) ) { return label . invalid ; } int n = interval . size ( ) ; for ( int i = 0 ; i < n ; i++ ) { interval i = interval . get ( i ) ; int a = i . a ; int b = i . b ; for ( int v=a ; v < =b ; v++ ) { if ( v > =0 ) return v ; } } return label . invalid ; }
public void set factory ( j d o m factory factory ) { this . factory = factory ; }
public final observable < t > serialize ( ) { return lift ( operator serialize . < t > instance ( ) ) ; }
public terminal node add child ( token match token ) { terminal node impl t = new terminal node impl ( match token ) ; add any child ( t ) ; t . set parent ( this ) ; return t ; }
public static < t > t [ ] array ( t . . . value ) { return value ; }
public terminal node add child ( token match token ) { terminal node impl t = new terminal node impl ( match token ) ; add any child ( t ) ; t . set parent ( this ) ; return t ; }
public terminal node add child ( terminal node t ) { t . set parent ( this ) ; return add any child ( t ) ; }
public static string format file string ( info info ) { return format file string ( info . get template name ( ) , info . get line ( ) , info . get column ( ) ) ; }
public void set interpreter delay foreign key declaration ( boolean value ) { this . interpreter delay foreign key declaration = value ; }
public boolean succeed ( ) { boolean ret = delegate . succeed ( ) ; return ret ; }
public void visit attribute ( final attribute attribute ) { if ( fv ! = null ) { fv . visit attribute ( attribute ) ; } }
public string get subtype ( ) { return subtype ; }
public void set module ( final list < module > module ) { this . module = module ; }
public object get bootstrap method argument ( final int index ) { return bootstrap method argument [ index ] ; }
public handle get bootstrap method ( ) { return bootstrap method ; }
public void visit attribute ( final attribute attribute ) { if ( cv ! = null ) { cv . visit attribute ( attribute ) ; } }
public tag get tag ( ) { return this . tag ; }
public static annotation [ ] get resource annotation ( method method ) { map < class < ? > , annotation > annotation = new hash map < class < ? > , annotation > ( ) ; for ( annotation annotation : method . get declare class ( ) . get annotation ( ) ) { annotation . put ( annotation . get class ( ) , annotation ) ; } for ( annotation annotation : method . get annotation ( ) ) { annotation . put ( annotation . get class ( ) , annotation ) ; } return annotation . value ( ) . to array ( new annotation [ annotation . size ( ) ] ) ; }
protect void on visit var insn ( int opcode , int offset ) { super . visit var insn ( opcode , offset ) ; }
public void set line number ( int line number ) { this . line number = line number ; }
public void visit pre order ( query visitor visitor ) { visit impl ( visitor , true ) ; }
public void accept ( final module visitor module visitor ) { module visitor . visit open ( packaze , access , module == null ? null : module . to array ( new string [ 0 ] ) ) ; }
public void set descriptor ( change descriptor descriptor ) { f descriptor= descriptor ; }
public type get type ( ) { return type ; }
public abstract insn node [ ] to array ( ) { int current insn index = 0 ; abstract insn node current insn = first insn ; abstract insn node [ ] insn node array = new abstract insn node [ size ] ; while ( current insn ! = null ) { insn node array [ current insn index ] = current insn ; current insn . index = current insn index++ ; current insn = current insn . next insn ; } return insn node array ; }
public boolean contains ( final abstract insn node insn ) { abstract insn node i = first ; while ( i ! = null & & i ! = insn ) { i = i . next ; } return i ! = null ; }
public void clear ( ) { object . clear ( ) ; }
protect module visitor create module remapper ( final module visitor module visitor ) { return new module remapper ( api , module visitor , remapper ) ; }
public exception get exception ( ) { return this . exception ; }
public big decimal to big decimal ( ) { if ( text be empty or null ( ) ) { return null ; } return string groovy method . to big decimal ( ( char sequence ) text ( ) ) ; }
public self be great than or equal to ( big decimal other ) { return super . be great than or equal to ( other ) ; }
public self be less than or equal to ( big decimal other ) { return super . be less than or equal to ( other ) ; }
public self do not contain sequence ( @ suppress warning ( `` unchecked `` ) element . . . sequence ) { array . assert do not contain sequence ( info , actual , sequence ) ; return myself ; }
public boolean contains key ( t key key ) { return this . item . contains key ( key ) ; }
public self contains key ( k key ) { return contain key ( key ) ; }
public atomic reference array assert < t > contain only null ( ) { array . assert contain only null ( info , array ) ; return myself ; }
public self contains sequence ( boolean . . . sequence ) { array . assert contain sequence ( info , actual , sequence ) ; return myself ; }
public self be equal to ignore null field ( object other ) { object . assert be equal to ignore null field ( info , actual , other , comparator by property or field , comparator by type ) ; return myself ; }
public self have no null field or property except ( string . . . property or field to ignore ) { object . assert have no null field or property except ( info , actual , property or field to ignore ) ; return myself ; }
public static < t > comparator < t > null high ( comparator < t > comparator ) { return new null safe comparator < > ( comparator , false ) ; }
public void set time zone ( time zone time zone ) { this . time zone = time zone ; }
public void set charset ( string charset ) { this . charset = charset ; }
public self contain only null ( ) { array . assert contain only null ( info , actual ) ; return myself ; }
public atomic reference array assert < t > be ( condition < ? super t > condition ) { array . assert be ( info , array , condition ) ; return myself ; }
public atomic reference array assert < t > be ( condition < ? super t > condition ) { array . assert be ( info , array , condition ) ; return myself ; }
public predicate [ ] get predicate ( ) { return i predicate ; }
public string [ ] get error message ( ) { return init error message ( ) ; }
public temporal type get temporal ( ) { return temporal ; }
public void assert contain only null ( assertion info info , object [ ] actual ) { array . assert contain only null ( info , failure , actual ) ; }
public string to string ( ) { if ( stack trace == null ) { return super . to string ( ) ; } return stack trace ; }
public void assert have size in byte ( assertion info info , file actual , long expect size in byte ) { assert be file ( info , actual ) ; if ( expect size in byte == actual . length ( ) ) return ; throw failure . failure ( info , should have size ( actual , expect size in byte ) ) ; }
public void assert be in ( assertion info info , object actual , object [ ] value ) { check be not null and not empty ( value ) ; assert be in ( info , actual , a list ( value ) ) ; }
public void assert be not positive ( assertion info info , number actual ) { assert less than or equal to ( info , actual , zero ( ) ) ; }
public void assert be not positive ( assertion info info , number actual ) { assert less than or equal to ( info , actual , zero ( ) ) ; }
public void assert be not negative ( assertion info info , number actual ) { assert great than or equal to ( info , actual , zero ( ) ) ; }
public self contain only null ( ) { array . assert contain only null ( info , actual ) ; return myself ; }
public void assert be subset of ( assertion info info , iterable < ? > actual , iterable < ? > value ) { assert not null ( info , actual ) ; check iterable be not null ( info , value ) ; list < object > extra = stream ( actual ) . filter ( actual element - > ! iterable contains ( value , actual element ) ) . collect ( to list ( ) ) ; if ( extra . size ( ) > 0 ) throw failure . failure ( info , should be subset of ( actual , value , extra , comparison strategy ) ) ; }
public void assert be not zero ( assertion info info , number actual ) { assert not equal by comparison ( info , actual , zero ( ) ) ; }
public static string get date string ( date self ) { return date format . get date instance ( date format . short ) . format ( self ) ; }
public calendar get calendar ( ) { return calendar ; }
public static calendar to calendar ( date date ) { if ( date == null ) { return null ; } calendar calendar = calendar . get instance ( ) ; calendar . set time ( date ) ; return calendar ; }
public double delta ( ) { return delta ; }
public list < string > get private field ( ) { if ( private field == null ) { private field = new array list < string > ( ) ; } return private field ; }
public property [ ] get property ( ) { return property . value ( ) . to array ( new property [ 0 ] ) ; }
public self have size less than ( int boundary ) { iterables . assert have size less than ( info , actual , boundary ) ; return myself ; }
public self have size great than ( int boundary ) { array . assert have size great than ( info , actual , boundary ) ; return myself ; }
public self contain only null ( ) { array . assert contain only null ( info , actual ) ; return myself ; }
public self have no null field or property except ( string . . . property or field to ignore ) { object . assert have no null field or property except ( info , actual , property or field to ignore ) ; return myself ; }
public static abstract character assert < ? > give ( char actual ) { return assume that ( actual ) ; }
public static abstract int array assert < ? > give ( int [ ] actual ) { return assume that ( actual ) ; }
public static abstract int array assert < ? > give ( int [ ] actual ) { return assume that ( actual ) ; }
public static abstract int array assert < ? > give ( int [ ] actual ) { return assume that ( actual ) ; }
public void set ignore ( boolean ignore ) { this . ignore = ignore ; }
public set < class < ? > > get ignore type ( ) { return ignore type ; }
public recursive comparison assert < ? > ignore field of type ( class < ? > . . . type to ignore ) { recursive comparison configuration . ignore field of type ( type to ignore ) ; return myself ; }
public assertion get assertion ( ) { return assertion ; }
public void assert start with ( assertion info info , byte [ ] actual , byte [ ] sequence ) { array . assert start with ( info , failure , actual , sequence ) ; }
public static < t > t eq ( t value ) { return ( t ) report matcher ( new equal ( value ) ) . < t > return for ( value ) ; }
public final u assert error message ( string message ) { int s = error . size ( ) ; if ( s == 0 ) { throw fail ( `` no error `` ) ; } else if ( s == 1 ) { throwable e = error . get ( 0 ) ; string error message = e . get message ( ) ; if ( ! object helper . equal ( message , error message ) ) { throw fail ( `` error message differs ; expect : `` + message + `` , actual : `` + error message ) ; } } else { throw fail ( `` multiple error `` ) ; } return ( u ) this ; }
public self have field or property ( string name ) { object . assert have field or property ( info , actual , name ) ; return myself ; }
public final u assert value set ( collection < ? extend t > expect ) { if ( expect . be empty ( ) ) { assert no value ( ) ; return ( u ) this ; } for ( t v : this . value ) { if ( ! expect . contains ( v ) ) { throw fail ( `` value not in the expected collection : `` + value and class ( v ) ) ; } } return ( u ) this ; }
public static abstract int array assert < ? > give ( int [ ] actual ) { return assume that ( actual ) ; }
public self be equal to ignore give field ( object other , string . . . property or field to ignore ) { object . assert be equal to ignore give field ( info , actual , other , comparator by property or field , get comparators by type ( ) , property or field to ignore ) ; return myself ; }
public self have no null field or property except ( string . . . property or field to ignore ) { object . assert have no null field or property except ( info , actual , property or field to ignore ) ; return myself ; }
public self have field or property ( string name ) { object . assert have field or property ( info , actual , name ) ; return myself ; }
public self be equal to ignore null field ( object other ) { object . assert be equal to ignore null field ( info , actual , other , comparator by property or field , comparator by type ) ; return myself ; }
public void set short ( long offset , short value ) { bound check ( offset , 2 ) ; super . set short ( offset , value ) ; }
public atomic reference array assert < t > be ( condition < ? super t > condition ) { array . assert be ( info , array , condition ) ; return myself ; }
public collection < v > value ( ) { return super . value ( ) ; }
protect void index node ( node node ) { list < node > nod = node name to node . get ( node . get x path node name ( ) ) ; if ( node ! = null ) { node . add ( node ) ; } }
public static < e > queue < e > synchronize queue ( queue < e > queue ) { return synchronize . queue ( queue , null ) ; }
public string buffer get class buffer ( ) { return class buffer ; }
public thread . uncaught exception handler get exception handler ( ) { return exception handler ; }
public string get condition ( ) { return condition ; }
public map field type get field type ( string field ) { return field type lookup ( ) . get ( field ) ; }
public field get field ( ) { return field ; }
public class < ? extend object > get type ( ) { return type ; }
public void set exception ( throwable exception ) { this . exception = exception ; }
public condition factory condition evaluation listener ( condition evaluation listener condition evaluation listener ) { return new condition factory ( alias , timeout , poll interval , poll delay , catch uncaught exception , condition evaluation listener ) ; }
public static matcher < method > return ( final matcher < ? super class < ? > > return type ) { return new return ( return type ) ; }
public modifier adjustment with constructor modifier ( modifier contributor . for method . . . modifier contributor ) { return with constructor modifier ( array . a list ( modifier contributor ) ) ; }
public modifier adjustment with method modifier ( element matcher < ? super method description > matcher , modifier contributor . for method . . . modifier contributor ) { return with method modifier ( matcher , arrays . a list ( modifier contributor ) ) ; }
public boolean be reference type ( ) { return get reference type ( ) ! = null ; }
protect method [ ] get method ( class < ? > type ) { return type . get method ( ) ; }
public class get type ( ) { return ( this . type ) ; }
public static object output stream new object output stream ( output stream output stream ) throw i o exception { return new object output stream ( output stream ) ; }
public void set definition ( x m l table definition definition ) { this . definition = definition ; }
public map field type get field type ( string field ) { return field type lookup ( ) . get ( field ) ; }
public void set service locator exception class ( class < ? extend exception > service locator exception class ) { if ( service locator exception class ! = null & & ! exception . class . be assignable from ( service locator exception class ) ) { throw new illegal argument exception ( `` service locator exception [ `` + service locator exception class . get name ( ) + `` ] be not a subclass of exception `` ) ; } this . service locator exception constructor = determine service locator exception constructor ( service locator exception class ) ; }
public static method [ ] get all declare method ( class < ? > leaf class ) { final list < method > method = new array list < method > ( 32 ) ; do with method ( leaf class , new method callback ( ) { @ override public void do with ( method method ) { method . add ( method ) ; } } ) ; return method . to array ( new method [ method . size ( ) ] ) ; }
public static < t > matcher < t > null value ( ) { return new be null < t > ( ) ; }
public void visit int insn ( final int opcode , final int operand ) { if ( mv ! = null ) { mv . visit int insn ( opcode , operand ) ; } }
public void set label ( string label ) { this . label = label ; }
public long count ( ) { return count . get ( ) ; }
public void set eviction policy ( final eviction policy < t > eviction policy ) { this . eviction policy = eviction policy ; }
public static value time from nanos ( long nanos ) { return ( value time ) value . cache ( new value time ( nanos ) ) ; }
public void set sourcepath ( path src ) { if ( source path == null ) { source path = src ; } else { source path . append ( src ) ; } }
public standalone mock mvc builder set conversion service ( format conversion service conversion service ) { this . conversion service = conversion service ; return this ; }
public static string to unsigned string ( @ unsigned short s , int radix ) { return integer . to unsigned string ( short . to unsigned int ( s ) , radix ) ; }
public static @ unsigned short to unsigned short ( @ unsigned byte b ) { return ( short ) ( ( ( int ) b ) & 0xff ) ; }
public field get field ( ) { return field ; }
public boolean get fast ( ) { return ( this . fast ) ; }
public void add composited ( final set < e > . . . set ) { for ( final set < e > set : set ) { add composited ( set ) ; } }
public url to u r l ( ) throw malformed u r l exception { return base . to u r l ( ) ; }
public void remove ( listener listener ) { listener . remove ( listener ) ; }
public long interval ( ) { return date histogram interval . interval ( ) ; }
public string id ( ) { return id ; }
protect input stream get content stream ( ) { return this . content stream ; }
public tag get tag ( ) { return this . tag ; }
public boolean be active ( ) { return this . active ; }
public static class loader get context class loader ( ) { thread current thread = thread . current thread ( ) ; return current thread . get context class loader ( ) ; }
public static object remove object property ( map property , string key , object default value ) { object value = default value ; if ( property ! = null & & property . contains key ( key ) ) { value = property . remove ( key ) ; } return value ; }
public dyna bean [ ] to dyna bean array ( ) { if ( size ( ) == 0 & & element dyna bean type == null ) { return new lazy dyna bean [ 0 ] ; } dyna bean [ ] array = ( dyna bean [ ] ) array . new instance ( element dyna bean type , size ( ) ) ; for ( int i = 0 ; i < size ( ) ; i++ ) { array [ i ] = ( dyna bean ) get ( i ) ; } return array ; }
public comparator comparator ( ) { return comparator ; }
public void add bean ( string name , object bean ) { this . bean . put ( name , bean ) ; }
public throwable get cause ( ) { return cause ; }
public boolean get fast ( ) { return ( this . fast ) ; }
public void set convert ( ) { this . convert = true ; }
public long get initial len ( ) { return initial file size ; }
public string get converter ( ) { return converter ; }
public void set time zone ( time zone time zone ) { this . time zone = time zone ; }
public string get pattern ( ) { return pattern ; }
public string get pattern ( ) { return pattern ; }
public string to string ( ) { string buffer buffer = new string buffer ( ) ; enumeration host ; buffer . append ( ' < ' ) ; host = _path . element ( ) ; if ( host . have more element ( ) ) { buffer . append ( ' @ ' ) ; buffer . append ( ( string ) host . next element ( ) ) ; while ( host . have more element ( ) ) { buffer . append ( `` , @ `` ) ; buffer . append ( ( string ) host . next element ( ) ) ; } buffer . append ( ' : ' ) ; } buffer . append ( _email address ) ; buffer . append ( ' > ' ) ; return buffer . to string ( ) ; }
public static void set default boolean ( boolean new default boolean ) { convert utils bean . get instance ( ) . set default boolean ( new default boolean ) ; }
public static boolean get default boolean ( ) { return ( convert utils bean . get instance ( ) . get default boolean ( ) ) ; }
public type get type ( ) { return type ; }
public static boolean be simple value type ( class < ? > type ) { return ( void . class ! = type & & void . class ! = type & & ( class utils . be primitive or wrapper ( type ) || enum . class . be assignable from ( type ) || char sequence . class . be assignable from ( type ) || number . class . be assignable from ( type ) || date . class . be assignable from ( type ) || temporal . class . be assignable from ( type ) || uri . class == type || url . class == type || locale . class == type || class . class == type ) ) ; }
public string get expression ( ) { return expression ; }
public boolean have nest ( string expression ) { if ( expression == null || expression . length ( ) == 0 ) { return false ; } else { return ( remove ( expression ) ! = null ) ; } }
public boolean be restrict ( ) { return restrict ; }
protect dyna property get dyna property ( string name ) { dyna property descriptor = get dyna class ( ) . get dyna property ( name ) ; if ( descriptor == null ) { throw new illegal argument exception ( `` invalid property name ' `` + name + `` ' `` ) ; } return ( descriptor ) ; }
public void set convert ( jaxb convert value ) { this . convert = value ; }
public void set map write method ( method map setter ) throw introspection exception { map write method ref = new map method reference ( mapped setter ) ; find mapped property type ( ) ; }
public method get map write method ( ) { return map write method ref . get ( ) ; }
public t get bean instance ( ) { return this . bean instance ; }
public boolean have more element ( ) { if ( current ! = null ) return true ; while ( current bucket < table . length ) { current = table [ current bucket++ ] ; if ( current ! = null ) return true ; } return false ; }
public int hash code ( ) { int h = 3542 ; for ( final t a : data ) { h ^= a . hash code ( ) ; } return h ; }
public t get instance ( ) { return instance ; }
public string miss padding message ( ) { return string . format ( `` unexpected end of base64-encoded string : base64 variant ' % s ' expect padding ( one or more ' % c ' character ) at the end `` , get name ( ) , get pad char ( ) ) ; }
public void set option comparator ( comparator < option > comparator ) { this . option comparator = comparator ; }
public comparator < option > get option comparator ( ) { return option comparator ; }
public option add option ( string opt , string long opt , boolean have arg , string description ) { add option ( new option ( opt , long opt , have arg , description ) ) ; return this ; }
public void set return value require ( boolean return value require ) { this . return value require = return value require ; }
public string raw string ( ) { return raw string ; }
public static field < string > decode ( string crypt string , string key string ) { return decode ( val ( crypt string ) , val ( key string ) ) ; }
public static message digest get sha3_224 digest ( ) { return get digest ( message digest algorithms . sha3_224 ) ; }
public void update message digest ( message digest message digest ) throw i o exception { int data ; while ( ( data = read ( ) ) ! = -1 ) { message digest . update ( ( byte ) data ) ; } }
public static hash function hmac sha256 ( key key ) { return new mac hash function ( `` hmac s h a256 `` , key , hmac to string ( `` hmac sha256 `` , key ) ) ; }
public static string hmac sha512 hex ( final byte [ ] key , final byte [ ] value to digest ) { return hex . encode hex string ( hmac sha512 ( key , value to digest ) ) ; }
public static string hmac md5 hex ( final byte [ ] key , final byte [ ] value to digest ) { return hex . encode hex string ( hmac md5 ( key , value to digest ) ) ; }
public static string crypt ( final string key ) { return crypt ( key , null ) ; }
public char [ ] get type name ( ) { return this . type name ; }
public static field < string > concat ( string . . . value ) { return concat ( tool . field ( value ) . to array ( empty_field ) ) ; }
public string get name ( ) { return this . name ; }
public void set reverse ( boolean r ) { if ( r ) { cmd . create argument ( ) . set value ( `` -r `` ) ; } }
public boolean start with ( string s1 , string s2 ) { return s1 . start with ( s2 ) ; }
public void set charset ( string charset ) { this . charset = charset ; }
public int length ( object obj ) { if ( be array ( obj ) ) { return ( ( list ) obj ) . size ( ) ; } else if ( be map ( obj ) ) { return get property key ( obj ) . size ( ) ; } else if ( obj instanceof string ) { return ( ( string ) obj ) . length ( ) ; } throw new json path exception ( `` length operation can not be apply to `` + obj ! =null ? obj . get class ( ) . get name ( ) : `` null `` ) ; }
public static boolean be valid ( string name ) { try { from ( name ) ; return true ; } catch ( illegal argument exception e ) { return false ; } }
public static message digest get md5 digest ( ) { return get digest ( message digest algorithms . md5 ) ; }
public static message digest get md5 digest ( ) { return get digest ( message digest algorithms . md5 ) ; }
static public byte [ ] string to byte ( string hex encode ) { return decode ( hex encode . get byte ( ) ) ; }
public string get encode ( ) { return encode ; }
public boolean be empty ( ) { return empty ; }
public iterator iterator ( ) { return new iterator ( ) ; }
public void set unique ( boolean value ) { this . unique = value ; }
public static bag decorate ( bag bag , class type ) { return new predicate bag ( bag , instanceof predicate . get instance ( type ) ) ; }
public set < v > get ( final k key ) { return wrap collection ( key ) ; }
public value node number node ( byte value ) { return ( value == null ) ? null node ( ) : int node . value of ( value . int value ( ) ) ; }
public self contains key ( k key ) { return contain key ( key ) ; }
public string to string ( ) { return key buffer . to string ( ) ; }
public void add composite ( composite composite ) { composite . add ( composite ) ; }
public list get dependency list ( ) { return collection . unmodifiable list ( this . dependency list ) ; }
public static < e > list < e > fix size list ( final list < e > list ) { return fix size list . fix size list ( list ) ; }
public static < e > long count match ( final iterable < e > input , final predicate < ? super e > predicate ) { if ( predicate == null ) { throw new null pointer exception ( `` predicate must not be null . `` ) ; } return size ( filter iterable ( empty if null ( input ) , predicate ) ) ; }
public static void select ( collection input collection , predicate predicate , collection output collection ) { if ( input collection ! = null & & predicate ! = null ) { for ( iterator iter = input collection . iterator ( ) ; iter . have next ( ) ; ) { object item = iter . next ( ) ; if ( predicate . evaluate ( item ) ) { output collection . add ( item ) ; } } } }
public constant get constant ( long value ) { return value to constant . get ( value ) ; }
public static < e > iterable < e > unique iterable ( final iterable < e > iterable ) { check not null ( iterable ) ; return new fluent iterable < e > ( ) { @ override public iterator < e > iterator ( ) { return new unique filter iterator < > ( iterable . iterator ( ) ) ; } } ; }
public static boolean a boolean ( enumeration enumeration ) { if ( null == enumeration ) { return false ; } return enumeration . have more element ( ) ; }
public static < t > iterable < t > each ( iterable < t > self , @ closure params ( first param . first generic type . class ) closure closure ) { each ( self . iterator ( ) , closure ) ; return self ; }
public boolean evaluate ( final t object ) { for ( final predicate < ? super t > i predicate : i predicate ) { if ( i predicate . evaluate ( object ) ) { return false ; } } return true ; }
public boolean evaluate ( final t object ) { return i predicate1 . evaluate ( object ) & & i predicate2 . evaluate ( object ) ; }
public predicate [ ] get predicate ( ) { return i predicate ; }
public void set input ( string input ) { this . input = input ; }
public void add transformer ( class file transformer transformer ) { if ( transformer == null ) { throw new illegal argument exception ( `` transformer must not be null `` ) ; } this . transformer . add ( transformer ) ; }
public predicate < ? super e > get predicate ( ) { return predicate ; }
public static < t > fluent iterable < t > of ( final iterable < t > iterable ) { iterable utils . check not null ( iterable ) ; if ( iterable instanceof fluent iterable < ? > ) { return ( fluent iterable < t > ) iterable ; } return new fluent iterable < > ( iterable ) ; }
public static < e > long count match ( final iterable < e > input , final predicate < ? super e > predicate ) { if ( predicate == null ) { throw new null pointer exception ( `` predicate must not be null . `` ) ; } return size ( filter iterable ( empty if null ( input ) , predicate ) ) ; }
public predicate < ? super e > get predicate ( ) { return predicate ; }
public static < t > fluent iterable < t > of ( final iterable < t > iterable ) { iterable utils . check not null ( iterable ) ; if ( iterable instanceof fluent iterable < ? > ) { return ( fluent iterable < t > ) iterable ; } return new fluent iterable < > ( iterable ) ; }
public boolean have ( int index ) { return get ( index ) ! = null ; }
public static boolean be empty ( object [ ] array ) { return ( array == null || array . length == 0 ) ; }
public void remove ( ) { if ( remove allow ) { if ( remove || before first ) { throw new illegal state exception ( ) ; } object = null ; remove = true ; } else { throw new unsupported operation exception ( ) ; } }
public iterator iterator ( ) { return new iterator ( ) ; }
public predicate < ? super e > get predicate ( ) { return i predicate ; }
public iterator < ? extend e > get iterator ( ) { return iterator ; }
public iterator iterator ( ) { return new iterator ( ) ; }
public e next ( ) { update current iterator ( ) ; if ( have next == false ) { throw new no such element exception ( `` no more element in the iteration `` ) ; } last used iterator = current iterator ; final e result = current value ; current value = null ; have next = false ; return result ; }
public boolean be remove ( ) { return remove ; }
public int length ( object obj ) { if ( be array ( obj ) ) { return ( ( list ) obj ) . size ( ) ; } else if ( be map ( obj ) ) { return get property key ( obj ) . size ( ) ; } else if ( obj instanceof string ) { return ( ( string ) obj ) . length ( ) ; } throw new json path exception ( `` length operation can not be apply to `` + obj ! =null ? obj . get class ( ) . get name ( ) : `` null `` ) ; }
public e next ( ) { if ( collection . size ( ) == 0 ) { throw new no such element exception ( `` there be no element for this iterator to loop on `` ) ; } if ( iterator . have next ( ) == false ) { reset ( ) ; } return iterator . next ( ) ; }
public boolean have next ( ) { return ! empty ; }
public void remove ( ) { throw new unsupported operation exception ( ) ; }
public void set cache size ( int cache size ) { this . cache size = cache size ; }
protect void index node ( node node ) { list < node > nod = node name to node . get ( node . get x path node name ( ) ) ; if ( node ! = null ) { node . add ( node ) ; } }
public static boolean be protect ( int mod ) { return ( mod & protect ) ! = 0 ; }
public final int hash code ( ) { return i hash code ; }
public static int size ( object list ) { if ( list == null ) return 0 ; if ( list instanceof list ) return ( ( list < ? > ) list ) . size ( ) ; return 1 ; }
public set < k > key set ( ) { return new key set ( ) ; }
public static int hash code for list ( final collection < ? > list ) { if ( list == null ) { return 0 ; } int hash code = 1 ; final iterator < ? > it = list . iterator ( ) ; while ( it . have next ( ) ) { final object obj = it . next ( ) ; hash code = 31 * hash code + ( obj == null ? 0 : obj . hash code ( ) ) ; } return hash code ; }
public void set check ( string value ) { this . check = value ; }
public void remove header ( ) { if ( header ! = null ) { remove child ( header ) ; } header = null ; }
public void shutdown ( ) { if ( purge task status . start == purge task status ) { log . info ( `` shut down purge task . `` ) ; timer . cancel ( ) ; purge task status = purge task status . complete ; } else { log . warn ( `` purge task not start . ignore shutdown ! `` ) ; } }
public void add composite ( composite composite ) { composite . add ( composite ) ; }
public object last key ( ) { if ( size == 0 ) { throw new no such element exception ( `` map be empty `` ) ; } return header . before . get key ( ) ; }
public set < k > key set ( ) { return new key set ( ) ; }
public string to string ( ) { string builder buf = new string builder ( ) ; iterator < map . entry < string , compression codec > > itr = codecs . entry set ( ) . iterator ( ) ; buf . append ( `` { `` ) ; if ( itr . have next ( ) ) { map . entry < string , compression codec > entry = itr . next ( ) ; buf . append ( entry . get key ( ) ) ; buf . append ( `` : `` ) ; buf . append ( entry . get value ( ) . get class ( ) . get name ( ) ) ; while ( itr . have next ( ) ) { entry = itr . next ( ) ; buf . append ( `` , `` ) ; buf . append ( entry . get key ( ) ) ; buf . append ( `` : `` ) ; buf . append ( entry . get value ( ) . get class ( ) . get name ( ) ) ; } } buf . append ( `` } `` ) ; return buf . to string ( ) ; }
public void set parse unescaped quote until delimiter ( boolean parse unescaped quote until delimiter ) { if ( parse unescaped quote until delimiter ) { parse unescaped quote = true ; } this . parse unescaped quote until delimiter = parse unescaped quote until delimiter ; }
public long get h ( ) { if ( h == null ) { return 0l ; } else { return h ; } }
public string get key ( ) { return key ; }
public predicate [ ] get predicate ( ) { return i predicate ; }
public set < k > key set ( ) { if ( key set == null ) { key set = new key set < > ( this ) ; } return key set ; }
public byte to byte ( ) { return new byte ( byte value ( ) ) ; }
public short [ ] get short array ( string key ) { return get short array ( key , new short [ 0 ] ) ; }
public void put ( int type code , string value ) { final integer integer = integer . value of ( type code ) ; default . put ( integer , value ) ; }
public void put all ( map map ) { for ( object o : map . entry set ( ) ) { entry entry = ( entry ) o ; put ( entry . get key ( ) , entry . get value ( ) ) ; } }
public set < k > key set ( ) { return new key set ( ) ; }
public static < e > multiset . entry < e > immutable entry ( @ nullable e e , int n ) { return new immutable entry < e > ( e , n ) ; }
public argument set multi value ( boolean multi value ) { this . multi value = multi value ; return this ; }
public predicate [ ] get predicate ( ) { return i predicate ; }
public static < t > predicate < t > null predicate ( ) { return null predicate . null predicate ( ) ; }
public static < t > predicate < t > null predicate ( ) { return null predicate . null predicate ( ) ; }
public static < e > queue < e > synchronize queue ( queue < e > queue ) { return synchronize . queue ( queue , null ) ; }
public int get index ( ) { return index ; }
public void visit pre order ( query visitor visitor ) { visit impl ( visitor , true ) ; }
protect queue < e > decorate ( ) { return ( queue < e > ) super . decorate ( ) ; }
public void set mutator ( final set mutator < e > mutator ) { this . mutator = mutator ; }
public void set mutator ( map mutator mutator ) { this . mutator = mutator ; }
public void add composited ( final set < e > . . . set ) { for ( final set < e > set : set ) { add composited ( set ) ; } }
public synchronize void add composited ( final set < e > set ) { for ( final set < e > exist set : get set ( ) ) { final collection < e > intersect = collection utils . intersection ( exist set , set ) ; if ( intersects . size ( ) > 0 ) { if ( this . mutator == null ) { throw new unsupported operation exception ( `` collision add composited set with no set mutator set `` ) ; } get mutator ( ) . resolve collision ( this , exist set , set , intersects ) ; if ( collection utils . intersection ( exist set , set ) . size ( ) > 0 ) { throw new illegal argument exception ( `` attempt to add illegal entry unresolved by set mutator . resolve collision ( ) `` ) ; } } } all . add ( set ) ; }
public transformer get transformer ( ) { return i transformer ; }
public final synchronize level get push level ( ) { return this . push level ; }
protect void update process byte count ( int count ) { this . bytes read from compress stream += count ; }
public long count ( ) { return count . get ( ) ; }
public boolean be delete ( ) { return f be delete ; }
public string get type ( ) { return type ; }
public final int size ( ) { return size ; }
public date get date time ( ) { return date time ; }
public int get level ( ) { return level ; }
public item get item ( ) { return null ; }
public void set last modified date ( date last modified date ) { add metadata ( metadata_header_last_modified_date , last modified date ) ; }
public void close ( ) throw i o exception { channel . close ( ) ; }
public final callable < object > create callable ( final zip archive entry zip archive entry , final input stream supplier source ) { final int method = zip archive entry . get method ( ) ; if ( method == zip method . unknown_code ) { throw new illegal argument exception ( `` method must be set on zip archive entry : `` + zip archive entry ) ; } final zip archive entry request zip archive entry request = create zip archive entry request ( zip archive entry , source ) ; return new callable < object > ( ) { @ override public object call ( ) throw exception { tl scatter stream . get ( ) . add archive entry ( zip archive entry request ) ; return null ; } } ; }
public t put byte ( byte [ ] b ) { return put byte ( b , 0 , b . length ) ; }
public int get skip count ( ) { return skip count ; }
public int get object alignment ( ) { return parent . get object alignment ( ) ; }
public date get create java time ( ) { return zip to date ( create time ) ; }
public date time to date time ( ) { return this ; }
public boolean be bit2_create time present ( ) { return bit2_create time present ; }
public boolean be bit0_modify time present ( ) { return bit0_modify time present ; }
public date get access java time ( ) { return zip to date ( access time ) ; }
public void set gid ( int gid ) { check tar file set attribute allow ( ) ; group id set = true ; this . gid = gid ; }
public byte [ ] get central directory data ( ) { return no_bytes ; }
public int get flag ( ) { return flag ; }
public term vector request builder set payload ( boolean payload ) { request . payload ( payload ) ; return this ; }
public static void set dir ( string dir name ) { set dir ( new file ( dir name ) ) ; }
public long get offset ( ) { return offset ; }
public void append ( final char array buffer b , int off , int len ) { if ( b == null ) { return ; } append ( b . buffer , off , len ) ; }
public static u d t type udt literal ( string literal ) { return u d t type . literal ( literal ) ; }
public int length ( ) { return byte . length ; }
public boolean contains ( int integer ) { for ( int i=0 ; i < size ; i++ ) { if ( data [ i ] ==integer ) { return true ; } } return false ; }
public void set cache size ( int cache size ) { this . cache size = cache size ; }
public static builder builder ( ) { return new builder ( ) ; }
public output < long > sparse shape ( ) { return sparse shape ; }
public void set encoding ( string encode ) { this . encode = encoding ; }
public void delete dir ( final string dir name ) { add deletion ( new change ( dir name , change . type_delete_dir ) ) ; }
public void add stream ( stream stream ) { if ( this . stream == null ) { this . stream = new hash set < stream > ( ) ; } this . stream . add ( stream ) ; }
public string get filename ( ) { return this . file . get name ( ) ; }
public static object input stream new object input stream ( file file , final class loader class loader ) throw i o exception { return i o groovy method . new object input stream ( new file input stream ( file ) , class loader ) ; }
public void set large mail user name ( final list < large mail user . large mail user name > large mail user name ) { this . large mail user name = large mail user name ; }
public byte [ ] get small ( ) { return small ; }
public content get content ( ) { return this . content ; }
public boolean be attribute ( ) { return attribute ; }
public immutable double array sub array ( int start index , int end index ) { precondition . check position index ( start index , end index , length ( ) ) ; return start index == end index ? empty : new immutable double array ( array , start + start index , start + end index ) ; }
public void set interface ( class < ? > . . . interface ) { assert . not null ( interface , `` interface must not be null `` ) ; this . interface . clear ( ) ; for ( class < ? > ifc : interface ) { add interface ( ifc ) ; } }
public boolean support outer join ( ) { debug code call ( `` support outer join `` ) ; return true ; }
public log get s a x logger ( ) { return sax log ; }
public void notation decl ( string name , string public id , string system id ) throw s a x exception { process x m l catalog p i = false ; super . notation decl ( name , public id , system id ) ; }
@ override public void set entity resolver ( entity resolver resolver ) { this . entity resolver = resolver ; }
public void set method ( int method ) { this . method = method ; }
public void add set property ( string pattern , string [ ] attribute name , string [ ] property name ) { add rule ( pattern , new set property rule ( attribute name , property name ) ) ; }
public object peek params ( ) { try { return params . peek ( ) ; } catch ( empty stack exception e ) { log . warn ( sm . get string ( `` digester . empty stack `` ) ) ; return null ; } }
public string id ( ) { return id ; }
public void external entity decl ( string name , string public id , string sys id ) throw s a x exception { external entity decl declaration = new external entity decl ( name , public id , sys id ) ; if ( internal d t dsubset ) { if ( include internal d t d declaration ) { add d t d declaration ( declaration ) ; } } else { if ( include external d t d declaration ) { add external d t d declaration ( declaration ) ; } } }
public node parent ( ) { return parent ; }
public static plugin get plugin ( string id ) { return null ; }
public final i scheduling rule get rule ( ) { return super . get rule ( ) ; }
public dictionary < digester > get digester ( ) { return digester ; }
public string get element name ( ) { return element name ; }
static public log get instance ( string name ) { log log = ( log ) log . get ( name ) ; if ( null == log ) { log = make new log instance ( name ) ; log . put ( name , log ) ; } return log ; }
public void set digester ( digester digester ) { this . digester = digester ; }
public j w t claim set get exact match claim ( ) { return exact match claim ; }
protect void fail with message ( string error message , object . . . argument ) { throw failure ( error message , argument ) ; }
public plugin create rule builder create plugin ( ) { return add provider ( new plugin create rule builder ( key pattern , namespace u r i , main binder , this ) ) ; }
public object create builder create object ( ) { return add provider ( new object create builder ( key pattern , namespace u r i , main binder , this , class loader ) ) ; }
public constructor < ? > get constructor ( ) { return this . constructor ; }
public log get s a x logger ( ) { return sax log ; }
public void set class loader ( class loader class loader ) { this . class loader = class loader ; }
public content get content ( ) { return this . content ; }
public url to u r l ( ) throw malformed u r l exception { return base . to u r l ( ) ; }
public void add set property ( string pattern ) { add rule ( pattern , new set property rule ( ) ) ; }
public void set ignore ( boolean ignore ) { this . ignore = ignore ; }
public boolean accept ( final file file ) { return file . be file ( ) ; }
public void flush buffer ( ) throw i o exception { output buffer . flush ( ) ; }
public boolean be debug enabled ( ) { return be enable ( trace system . debug ) ; }
public credential scope get credential scope ( ) { return credential scope ; }
public final string get i d ( ) { return i i d ; }
public string get parameter ( final string name ) { args . not null ( name , `` parameter name `` ) ; return null ; }
public static op read ( data input in ) throw i o exception { return value of ( in . read byte ( ) ) ; }
public boolean be cache ( ) { return cache ! = null ; }
public string get path ( ) { return path ; }
public void set version ( string version ) { this . version = version ; } // -- void set version ( string )
public object get parameter value ( string parameter class name ) { return this . parameter . get ( parameter class name ) ; }
public void set value ( member value [ ] element ) { value = element ; if ( element ! = null & & element . length > 0 ) type = element [ 0 ] ; }
public http header get header ( ) { return this . header ; }
public http header get header ( ) { return this . header ; }
public synchronize string get proxy host ( ) { if ( this . proxy host ! = null ) { return this . proxy host . get host name ( ) ; } else { return null ; } }
public string get host ( ) { return this . host ; }
public static host and port from part ( string host , int port ) { check argument ( be valid port ( port ) , `` port out of range : % s `` , port ) ; host and port parse host = from string ( host ) ; check argument ( ! parse host . have port ( ) , `` host have a port : % s `` , host ) ; return new host and port ( parsed host . host , port , parse host . have bracketless colon ) ; }
public string get proxy host ( ) { return proxy host name ; }
public inet address get local address ( ) { return local address ; }
public static void assert not equal ( string expect str , j s o n array actual , boolean strict ) throw j s o n exception { assert not equal ( expect str , actual , strict ? j s o n compare mode . strict : j s o n compare mode . lenient ) ; }
public static s s l socket get socket ( encryption option option ) throw i o exception { s s l context ctx = create s s l context ( option , true ) ; s s l socket socket = ( s s l socket ) ctx . get socket factory ( ) . create socket ( ) ; try { prepare socket ( socket , option ) ; return socket ; } catch ( illegal argument exception e ) { socket . close ( ) ; throw e ; } }
public synchronize string get proxy host ( ) { if ( this . proxy host ! = null ) { return this . proxy host . get host name ( ) ; } else { return null ; } }
public io . vertx . axle . core . http . cookie set secure ( boolean secure ) { delegate . set secure ( secure ) ; return this ; }
public boolean be connection stale checking enable ( ) { return this . params . be stale check enable ( ) ; }
public static input stream sub stream ( input stream input stream , long start , int length ) { return new binary stream impl ( extract byte ( input stream , start , length ) ) ; }
public void release connection ( ) { log . trace ( `` enter http connection . release connection ( ) `` ) ; if ( lock ) { log . debug ( `` connection be lock . call to release connection ( ) ignore . `` ) ; } else if ( http connection manager ! = null ) { log . debug ( `` release connection back to connection manager . `` ) ; http connection manager . release connection ( this ) ; } else { log . warn ( `` http connection manager be null . connection can not be release . `` ) ; } }
public http connection manager get http connection manager ( ) { return http connection manager ; }
public int get send buffer size ( ) { return send buffer size ; }
public static string to ascii string ( final byte [ ] raw ) { return new string ( to ascii char ( raw ) ) ; }
public boolean be authentication enabled ( ) { return authentication enable ; }
public http header get header ( ) { return this . header ; }
public static boolean node get true ( ) { return true ; }
public string get password ( ) { return password ; }
public final void set follow ( final boolean new value ) { follow = new value ; }
public int get content length ( ) { return this . request . get content length ( ) ; }
public void write thin ( stream output out ) throw i o exception { super . write to ( out ) ; out . write v int ( byte . length ( ) ) ; }
public void set configuration file name ( string configuration file name ) { file file = new file ( configuration file name ) . get absolute file ( ) ; this . configuration file name = file . get name ( ) ; implicit base path = file . get parent ( ) ; }
public void send ( byte [ ] message ) throw exception { m_connector . get send connection ( ) . send ( this , message , null ) ; }
public void set name ( string name ) { this . name = name ; }
public part builder part ( string name , object part ) { return part ( name , part , null ) ; }
public name value pair [ ] get parameter ( ) { return this . parameter ; }
public boolean close if stale ( ) throw i o exception { if ( be open & & be stale ( ) ) { log . debug ( `` connection be stale , close . . . `` ) ; close ( ) ; return true ; } return false ; }
public string get in ( ) { return in ; }
public void set value ( boolean value ) { this . value = value ; }
public string get host ( ) { return host ; }
public synchronize void set max total ( final int max total ) { this . max total = max total ; if ( connection pool ! = null ) { connection pool . set max total ( max total ) ; } }
public void set timeout ( int timeout ) { this . timeout = timeout ; }
public int get size ( ) { return size [ parameter ] [ order ] ; }
public void set value ( string value ) { this . value = value ; }
public part builder part ( string name , object part ) { return part ( name , part , null ) ; }
public void set server authority ( host port authority ) { if ( authority == null ) _server authority = null ; else if ( ! authority . have host ( ) ) throw new illegal state exception ( `` server authority must have host declare `` ) ; else _server authority = authority ; }
public void set default charset ( charset default charset ) { if ( default charset ! = null ) this . default charset = default charset ; else this . default charset = get default system charset ( ) ; }
public static string get default document charset ( ) { return default document charset ; }
public string raw string ( ) { return raw string ; }
public string get path ( ) { return path ; }
public string get fragment ( ) { return fragment ; }
public string get user name ( ) { return user name ; }
public int hash code ( ) { return name . hash code ( ) ; } // hash code
public boolean be connect ( ) { return false ; }
public void set always create ( boolean always create ) { this . always create = always create ; }
public void set unescaped quote handling ( unescaped quote handle unescaped quote handle ) { this . unescaped quote handle = unescaped quote handling ; }
public void set length ( int length ) { assert . be true ( length > = 0 ) ; this . length= length ; }
public void set file ( file file ) { this . file = file ; }
public string to string ( ) { return delegate . to string ( ) ; }
public static double get double ( byte [ ] data ) { return double . long bit to double ( get long ( data , 0 ) ) ; }
public static int load byte ( final input stream input stream , final byte [ ] array , final int offset , final int length ) throw i o exception { return read ( input stream , array , offset , length ) ; }
public list < file > get file ( ) { return file ; }
public directory directory ( ) { return directory ; }
public counter get task counter ( ) { return counter ; }
public static path [ ] file ( path directory ) throw i o exception { try ( directory stream < path > stream = file . new directory stream ( directory ) ) { return to array ( stream ) ; } }
public string to string ( ) { return name ; }
public boolean accept ( final file file ) { return file . be file ( ) ; }
public boolean accept ( final file file ) { return accept ( file == null ? null : file . get name ( ) ) ; }
public string get file prefix ( ) { return file prefix ; }
protect string [ ] get property method suffix ( string property name ) { string suffix = get property method suffix ( property name ) ; if ( suffix . length ( ) > 0 & & character . be upper case ( suffix . char at ( 0 ) ) ) { return new string [ ] { suffix } ; } return new string [ ] { suffix , string utils . capitalize ( suffix ) } ; }
public void set filter ( boolean filter ) { this . filter = filter ; }
public boolean accept ( final file file ) { return accept ( file == null ? null : file . get name ( ) ) ; }
public boolean accept ( final file file ) { return accept base name ( file . get name ( ) ) ; }
public static string normalize ( string path ) { return normalize ( path , true ) ; }
public string separator ( ) { return separator ; }
public long get byte reserve ( ) { return 0 ; }
public void set file ( file file ) { this . file = file ; }
public string get user ( ) { return user ; }
public static boolean delete file ( file directory ) { boolean result = true ; if ( directory . be directory ( ) ) { file [ ] list = directory . list file ( ) ; for ( int i = list . length ; i -- > 0 ; ) { file file = list [ i ] ; if ( file . be file ( ) ) { result = result & & file . delete ( ) ; } } } return result ; }
public string get file ( ) { return file ; }
public void set file ( file file ) { this . file = file ; }
public int mark ( ) { return -1 ; }
public int read ( char [ ] array , int offset , int length ) { if ( idx > = char sequence . length ( ) ) { return -1 ; } if ( array == null ) { throw new null pointer exception ( `` character array be miss `` ) ; } if ( length < 0 || offset < 0 || offset + length > array . length ) { throw new index out of bound exception ( `` array size= `` + array . length + `` , offset= `` + offset + `` , length= `` + length ) ; } int count = 0 ; for ( int i = 0 ; i < length ; i++ ) { int c = read ( ) ; if ( c == -1 ) { return count ; } array [ offset + i ] = ( char ) c ; count++ ; } return count ; }
public long get position ( ) { return position ; }
public long get position ( ) { return position ; }
public int mark ( ) { return -1 ; }
public static void put u short ( byte [ ] data , int offset , int value ) { int i = offset ; data [ i++ ] = ( byte ) ( ( value > > > 0 ) & 0x f f ) ; data [ i++ ] = ( byte ) ( ( value > > > 8 ) & 0x f f ) ; }
public random access file get random access file ( ) { return random access file ; }
public void set random access ( ) { this . random access = true ; }
public void close ( ) throw i o exception { }
public static boolean be tag with ( final throwable throwable , final object tag ) { return tag ! = null & & throwable instanceof tag i o exception & & tag . equal ( ( ( tag i o exception ) throwable ) . tag ) ; }
public t with delay ( delay delay ) { this . delay = delay ; return ( t ) this ; }
public static input stream to input stream ( final string input , final charset charset ) { return new byte array input stream ( input . get byte ( charsets . to charset ( charset ) ) ) ; }
public static input stream to input stream ( final string input ) { return to input stream ( input , charset . default charset ( ) ) ; }
public file filter get file filter ( ) { if ( filter == null ) filter = new extension file filter ( file type + `` file ( * . `` + default extension + `` ) `` , default extension ) ; return filter ; }
public void add listener ( listener listener ) { listener . add ( listener ) ; }
public void set length ( long length ) { this . length = length ; }
public string get exists ( ) { return this . exist ; } // -- string get exists ( )
public void write ( final int c ) throw i o exception { appendable . append ( ( char ) c ) ; }
protect boolean include ( i document doc , int off , int len ) { return doc == f document & & off > = offset & & len + off < = offset + length ; }
public void write ( int c ) { buffer . append ( ( char ) c ) ; }
public void close ( ) throw i o exception { super . close ( ) ; this . branch . close ( ) ; }
public final t get ( string name ) { int idx = find ( name ) ; return 0 < = idx ? get ( idx ) : null ; }
public throwable get cause ( ) { return cause ; }
public void close ( ) throw i o exception { super . close ( ) ; close = true ; }
public void set default encode ( string default encode ) { this . file upload . set header encode ( default encode ) ; }
public string get pattern ( ) { return pattern ; }
public boolean be cause of ( final throwable exception ) { return tag i o exception . be tag with ( exception , tag ) ; }
public long last modified ( ) throw i o exception { long last modify = get file for last modified check ( ) . last modified ( ) ; if ( last modify == 0l ) { throw new file not find exception ( get description ( ) + `` can not be resolve in the file system for resolve it last-modified timestamp `` ) ; } return last modify ; }
public file filter get file filter ( ) { return file filter ; }
public string get full name ( ) { return full name ; }
public void set system ( string system ) { this . system = system ; } // -- void set system ( string )
public int mark ( ) { return -1 ; }
public int read ( final char [ ] array , final int offset , final int length ) { if ( idx > = end ( ) ) { return eof ; } object . require non null ( array , `` array `` ) ; if ( length < 0 || offset < 0 || offset + length > array . length ) { throw new index out of bound exception ( `` array size= `` + array . length + `` , offset= `` + offset + `` , length= `` + length ) ; } if ( char sequence instanceof string ) { final int count = math . min ( length , end ( ) - idx ) ; ( ( string ) char sequence ) . get char ( idx , idx + count , array , offset ) ; idx += count ; return count ; } if ( char sequence instanceof string builder ) { final int count = math . min ( length , end ( ) - idx ) ; ( ( string builder ) char sequence ) . get char ( idx , idx + count , array , offset ) ; idx += count ; return count ; } if ( char sequence instanceof string buffer ) { final int count = math . min ( length , end ( ) - idx ) ; ( ( string buffer ) char sequence ) . get char ( idx , idx + count , array , offset ) ; idx += count ; return count ; } int count = 0 ; for ( int i = 0 ; i < length ; i++ ) { final int c = read ( ) ; if ( c == eof ) { return count ; } array [ offset + i ] = ( char ) c ; count++ ; } return count ; }
public void set handle ( handle handle ) { this . handle = handle ; }
public static char [ ] to char array ( final input stream be ) throw i o exception { return to char array ( be , charset . default charset ( ) ) ; }
public static list < string > read line ( input stream input , charset encode ) throw i o exception { input stream reader reader = new input stream reader ( input , charsets . to charset ( encode ) ) ; return read line ( reader ) ; }
public static void copy ( input stream input , writer output , charset encode ) throw i o exception { input stream reader in = new input stream reader ( input , charsets . to charset ( encode ) ) ; copy ( in , output ) ; }
public static input stream to input stream ( final string input ) { return to input stream ( input , charset . default charset ( ) ) ; }
public static void write ( string buffer data , output stream output , string encode ) throw i o exception { if ( data ! = null ) { output . write ( data . to string ( ) . get byte ( charsets . to charset ( encode ) ) ) ; } }
public static void write ( string data , writer output ) throw i o exception { if ( data ! = null ) { output . write ( data ) ; } }
public static void copy ( input stream input , writer output , charset encode ) throw i o exception { input stream reader in = new input stream reader ( input , charsets . to charset ( encode ) ) ; copy ( in , output ) ; }
public static void copy ( input stream input , writer output ) throw i o exception { copy ( input , output , charset . default charset ( ) ) ; }
public static boolean content equal ( input stream input1 , input stream input2 ) throw i o exception { if ( input1 == input2 ) { return true ; } if ( ! ( input1 instanceof buffer input stream ) ) { input1 = new buffer input stream ( input1 ) ; } if ( ! ( input2 instanceof buffer input stream ) ) { input2 = new buffer input stream ( input2 ) ; } int ch = input1 . read ( ) ; while ( eof ! = ch ) { final int ch2 = input2 . read ( ) ; if ( ch ! = ch2 ) { return false ; } ch = input1 . read ( ) ; } final int ch2 = input2 . read ( ) ; return ch2 == eof ; }
public < t > void notify ( resolved observer < t > observer , t event , event metadata metadata ) { if ( ! observer . be metadata require ( ) ) { metadata = null ; } notify sync observer ( observer . get immediate sync observer ( ) , event , metadata , observer exception handler . immediate_handler ) ; notify transaction observer ( observer . get transaction observer ( ) , event , metadata , observer exception handler . immediate_handler ) ; }
public static stack manipulation of ( serializable value ) { if ( value == null ) { return null constant . instance ; } try { byte array output stream byte array output stream = new byte array output stream ( ) ; object output stream object output stream = new object output stream ( byte array output stream ) ; try { object output stream . write object ( value ) ; } finally { object output stream . close ( ) ; } return new serialize constant ( byte array output stream . to string ( charset ) ) ; } catch ( i o exception exception ) { throw new illegal state exception ( `` can not serialize `` + value , exception ) ; } }
public static flushable closeable wrap ( final handler handler ) { return handler instanceof flushable closeable ? ( flushable closeable ) handler : new flushable closeable ( ) { public void close ( ) { handler . close ( ) ; } public void flush ( ) { handler . flush ( ) ; } } ; }
public static input stream to input stream ( final string input , final charset charset ) { return new byte array input stream ( input . get byte ( charsets . to charset ( charset ) ) ) ; }
public static input stream to input stream ( char sequence input , charset encode ) { return to input stream ( input . to string ( ) , encode ) ; }
public static boolean content equal ( input stream input1 , input stream input2 ) throw i o exception { if ( ! ( input1 instanceof buffer input stream ) ) { input1 = new buffer input stream ( input1 ) ; } if ( ! ( input2 instanceof buffer input stream ) ) { input2 = new buffer input stream ( input2 ) ; } int ch = input1 . read ( ) ; while ( eof ! = ch ) { int ch2 = input2 . read ( ) ; if ( ch ! = ch2 ) { return false ; } ch = input1 . read ( ) ; } int ch2 = input2 . read ( ) ; return ch2 == eof ; }
public boolean accept ( final file file ) { return file . be file ( ) ; }
public static void copy ( input stream input , writer output ) throw i o exception { copy ( input , output , charset . default charset ( ) ) ; }
public static boolean constant time equal ( string a , string b ) { object . require non null ( a , `` string must not be null for constant time equal `` ) ; object . require non null ( b , `` string must not be null for constant time equal `` ) ; if ( a . length ( ) ! = b . length ( ) ) { return false ; } int equal = 0 ; for ( int i = 0 ; i < a . length ( ) ; i++ ) { equal |= a . char at ( i ) ^ b . char at ( i ) ; } return equal == 0 ; }
public static boolean be empty ( object [ ] array ) { return ( array == null || array . length == 0 ) ; }
public immutable double array sub array ( int start index , int end index ) { precondition . check position index ( start index , end index , length ( ) ) ; return start index == end index ? empty : new immutable double array ( array , start + start index , start + end index ) ; }
public static int index of ( double [ ] array , double value to find , int start index , double tolerance ) { if ( array utils . be empty ( array ) ) { return index_not_found ; } if ( start index < 0 ) { start index = 0 ; } double min = value to find - tolerance ; double max = value to find + tolerance ; for ( int i = start index ; i < array . length ; i++ ) { if ( array [ i ] > = min & & array [ i ] < = max ) { return i ; } } return index_not_found ; }
public static int index of ( char [ ] array , char value to find ) { return index of ( array , value to find , 0 ) ; }
public static int last index of ( object [ ] array , object object to find , int start index ) { if ( array == null ) { return index_not_found ; } if ( start index < 0 ) { return index_not_found ; } else if ( start index > = array . length ) { start index = array . length - 1 ; } if ( object to find == null ) { for ( int i = start index ; i > = 0 ; i -- ) { if ( array [ i ] == null ) { return i ; } } } else { for ( int i = start index ; i > = 0 ; i -- ) { if ( object to find . equal ( array [ i ] ) ) { return i ; } } } return index_not_found ; }
public static float [ ] to primitive ( float [ ] array , float value for null ) { if ( array == null ) { return null ; } else if ( array . length == 0 ) { return empty_float_array ; } final float [ ] result = new float [ array . length ] ; for ( int i = 0 ; i < array . length ; i++ ) { float b = array [ i ] ; result [ i ] = ( b == null ? value for null : b . float value ( ) ) ; } return result ; }
public short [ ] get short array ( string key ) { return get short array ( key , new short [ 0 ] ) ; }
public static long [ ] to primitive ( long [ ] array , long value for null ) { if ( array == null ) { return null ; } else if ( array . length == 0 ) { return empty_long_array ; } final long [ ] result = new long [ array . length ] ; for ( int i = 0 ; i < array . length ; i++ ) { long b = array [ i ] ; result [ i ] = ( b == null ? value for null : b . long value ( ) ) ; } return result ; }
public static boolean be empty ( object [ ] array ) { return ( array == null || array . length == 0 ) ; }
public equal builder append ( object [ ] lh , object [ ] rh ) { if ( be equal == false ) { return this ; } if ( lhs == rh ) { return this ; } if ( lhs == null || rh == null ) { this . set equal ( false ) ; return this ; } if ( lh . length ! = rh . length ) { this . set equal ( false ) ; return this ; } for ( int i = 0 ; i < lh . length & & be equal ; ++i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
public equal builder append ( short lh , short rh ) { if ( be equal == false ) { return this ; } be equals = ( lhs == rh ) ; return this ; }
public void reset ( ) { this . element= null ; }
public float float value ( ) { return ( ( float ) numerator ) / ( ( float ) denominator ) ; }
public int hash code ( ) { return name . hash code ( ) ; } // hash code
public static string to string exclude ( object object , collection / * string * / exclude field name ) { return to string exclude ( object , to no null string array ( exclude field name ) ) ; }
public static string to string exclude ( object object , final string exclude field name ) { return to string exclude ( object , new string [ ] { exclude field name } ) ; }
public static string to string exclude ( object object , collection / * string * / exclude field name ) { return to string exclude ( object , to no null string array ( exclude field name ) ) ; }
public int get identity hash code ( ) { return this . identity hash code ; }
public token get start ( ) { return start ; }
public string separator ( ) { return separator ; }
public string get field separator write ( ) { return field separator write ; }
public string get text ( ) { return text ; }
public to string builder append ( long value ) { style . append ( buffer , null , value ) ; return this ; }
public to string builder append ( long value ) { style . append ( buffer , null , value ) ; return this ; }
public to string builder append ( double value ) { style . append ( buffer , null , value ) ; return this ; }
public to string builder append ( long value ) { style . append ( buffer , null , value ) ; return this ; }
public to string builder append ( long value ) { style . append ( buffer , null , value ) ; return this ; }
public static string identity to string ( object object ) { if ( object == null ) { return null ; } string buffer buffer = new string buffer ( ) ; identity to string ( buffer , object ) ; return buffer . to string ( ) ; }
protect void append summary ( string buffer buffer , string field name , boolean [ ] array ) { append summary size ( buffer , field name , array . length ) ; }
protect void append summary ( string buffer buffer , string field name , boolean [ ] array ) { append summary size ( buffer , field name , array . length ) ; }
protect void append summary ( string buffer buffer , string field name , boolean [ ] array ) { append summary size ( buffer , field name , array . length ) ; }
protect void append summary ( string buffer buffer , string field name , char [ ] array ) { append summary size ( buffer , field name , array . length ) ; }
protect void set name source end ( int end ) { this . name end= end ; }
public static char to char ( string str , char default value ) { if ( string utils . be empty ( str ) ) { return default value ; } return str . char at ( 0 ) ; }
public boolean equal ( final object obj ) { if ( obj == this ) { return true ; } else if ( ! ( obj instanceof class info ) ) { return false ; } final class info other = ( class info ) obj ; return name . equal ( other . name ) ; }
public string to string ( ) { return to string ( 0 ) ; }
static public char represent char ( final class type ) { character ch = ( character ) representing_char . get ( type ) ; return ch == null ? 0 : ch . char value ( ) ; }
public static character char from ( string char str ) { return character_parser . value of ( char str ) ; }
protect boolean be token separator ( char ch ) { return ( ch == ' , ' ) ; }
public void set interface ( class < ? > . . . interface ) { assert . not null ( interface , `` interface must not be null `` ) ; this . interface . clear ( ) ; for ( class < ? > ifc : interface ) { add interface ( ifc ) ; } }
public static class get class ( string class name ) throw class not find exception { return get class ( class name , true ) ; }
public string get class name ( ) { return class name ; }
public static void no null element ( object [ ] array , string message ) { validate . not null ( array ) ; for ( int i = 0 ; i < array . length ; i++ ) { if ( array [ i ] == null ) { throw new illegal argument exception ( message ) ; } } }
public string get object name ( ) { return this . object name ; }
protect static list get enum list ( class enum class ) { entry entry = get entry ( enum class ) ; if ( entry == null ) { return collection . empty_list ; } return entry . unmodifiable list ; }
protect static map get enum map ( class enum class ) { entry entry = get entry ( enum class ) ; if ( entry == null ) { return empty_map ; } return entry . unmodifiable map ; }
public int hash code ( ) { return name . hash code ( ) ; } // hash code
public throwable get throwable ( ) { return throwable ; }
public boolean have error ( ) { return ( ( throwables ! = null ) & & ( ! throwables . be empty ( ) ) ) ; }
public void clear ( ) { lock . lock ( ) ; try { for ( node < e > f = first ; f ! = null ; ) { f . item = null ; final node < e > n = f . next ; f . prev = null ; f . next = null ; f = n ; } first = last = null ; count = 0 ; not full . signal all ( ) ; } finally { lock . unlock ( ) ; } }
public void set maxmemory ( string max ) { max memory = max ; }
public int get maximum value ( ) { return i max ; }
public long get numerator a long ( ) { return numerator . long value ( ) ; }
public static float next float ( ) { return next float ( 0 , float . max_value ) ; }
public big fraction add ( final big fraction fraction ) { if ( fraction == null ) { throw new null argument exception ( localized format . fraction ) ; } if ( fraction . numerator . signum ( ) == 0 ) { return this ; } if ( numerator . signum ( ) == 0 ) { return fraction ; } big integer num = null ; big integer den = null ; if ( denominator . equal ( fraction . denominator ) ) { num = numerator . add ( fraction . numerator ) ; den = denominator ; } else { num = ( numerator . multiply ( fraction . denominator ) ) . add ( ( fraction . numerator ) . multiply ( denominator ) ) ; den = denominator . multiply ( fraction . denominator ) ; } if ( num . signum ( ) == 0 ) { return zero ; } return new big fraction ( num , den ) ; }
public string get method doc ( i method child ) throw java model exception { if ( this . content == null ) return null ; int [ ] range = null ; synchronize ( this ) { if ( this . method doc range == null ) { this . method doc range = new hashtable of object to int array ( ) ; } else { range = this . method doc range . get ( child ) ; } if ( range == null ) { range = compute method range ( child ) ; this . method doc range . put ( child , range ) ; } } if ( range ! = null ) { if ( range == unknown_format ) { throw new java model exception ( new java model status ( i java model status constant . unknown_javadoc_format , child ) ) ; } return new string ( this . content , range [ 0 ] , range [ 1 ] - range [ 0 ] ) ; } return null ; }
public boolean equal ( object obj ) { if ( obj == null ) { return false ; } if ( this == obj ) { return true ; } if ( this . get class ( ) == obj . get class ( ) ) { mutable object < ? > that = ( mutable object < ? > ) obj ; return this . value . equal ( that . value ) ; } else { return false ; } }
public byte [ ] get ( ) { if ( bytes == null ) { byte = new byte [ 0 ] ; } return byte ; }
public static double get double ( byte [ ] data ) { return double . long bit to double ( get long ( data , 0 ) ) ; }
public double double value ( ) { return value ; }
public double double value ( ) { return value ; }
public static void print root cause stack trace ( throwable t ) { print root cause stack trace ( t , system . err ) ; }
protect void append cyclic object ( string buffer buffer , string field name , object value ) { object utils . identity to string ( buffer , value ) ; }
public field get field ( ) { return field ; }
public static void write declare static field ( class cl , string field name , object value ) throw illegal access exception { write declare static field ( cls , field name , value , false ) ; }
public static object read declare static field ( class cl , string field name ) throw illegal access exception { return read declare static field ( cls , field name , false ) ; }
protect method [ ] get method ( class < ? > type ) { return type . get method ( ) ; }
public static file get java io tmp dir ( ) { return new file ( system . get property ( java_io_tmpdir_key ) ) ; }
public boolean be empty ( ) { return size == 0 ; }
public int index of ( string str , int start index ) { start index = ( start index < 0 ? 0 : start index ) ; if ( str == null || start index > = size ) { return -1 ; } int str len = str . length ( ) ; if ( str len == 1 ) { return index of ( str . char at ( 0 ) , start index ) ; } if ( str len == 0 ) { return start index ; } if ( str len > size ) { return -1 ; } char [ ] this buf = buffer ; int len = size - str len + 1 ; outer : for ( int i = start index ; i < len ; i++ ) { for ( int j = 0 ; j < str len ; j++ ) { if ( str . char at ( j ) ! = this buf [ i + j ] ) { continue outer ; } } return i ; } return -1 ; }
public text string builder appendln ( final string builder str ) { return append ( str ) . append new line ( ) ; }
public static void ensure offset length ( final long big array length , final long offset , final long length ) { if ( offset < 0 ) throw new array index out of bound exception ( `` offset ( `` + offset + `` ) be negative `` ) ; if ( length < 0 ) throw new illegal argument exception ( `` length ( `` + length + `` ) be negative `` ) ; if ( offset + length > big array length ) throw new array index out of bound exception ( `` last index ( `` + ( offset + length ) + `` ) be great than big-array length ( `` + big array length + `` ) `` ) ; }
public str builder replace all ( string search str , string replace str ) { int search len = ( search str == null ? 0 : search str . length ( ) ) ; if ( search len > 0 ) { int replace len = ( replace str == null ? 0 : replace str . length ( ) ) ; int index = index of ( search str , 0 ) ; while ( index > = 0 ) { replace impl ( index , index + search len , search len , replace str , replace len ) ; index = index of ( search str , index + replace len ) ; } } return this ; }
public str builder replace first ( char search , char replace ) { if ( search ! = replace ) { for ( int i = 0 ; i < size ; i++ ) { if ( buffer [ i ] == search ) { buffer [ i ] = replace ; break ; } } } return this ; }
public str builder append ( char [ ] char ) { if ( char == null ) { return append null ( ) ; } int str len = char . length ; if ( str len > 0 ) { int len = length ( ) ; ensure capacity ( len + str len ) ; system . arraycopy ( char , 0 , buffer , len , str len ) ; size += str len ; } return this ; }
public int length ( ) { return value . size ( ) ; }
public static byte byte that ( matcher < byte > matcher ) { report matcher ( matcher ) ; return 0 ; }
public str builder append ( char [ ] char ) { if ( char == null ) { return append null ( ) ; } int str len = char . length ; if ( str len > 0 ) { int len = length ( ) ; ensure capacity ( len + str len ) ; system . arraycopy ( char , 0 , buffer , len , str len ) ; size += str len ; } return this ; }
public string get reader ( ) { return reader ; }
public boolean contains ( str matcher matcher ) { return index of ( matcher , 0 ) > = 0 ; }
protect string [ ] get property method suffix ( string property name ) { string suffix = get property method suffix ( property name ) ; if ( suffix . length ( ) > 0 & & character . be upper case ( suffix . char at ( 0 ) ) ) { return new string [ ] { suffix } ; } return new string [ ] { suffix , string utils . capitalize ( suffix ) } ; }
public tokenized pattern to pattern ( ) { return new tokenized pattern ( path , tokenized path ) ; }
public void set ignore ( boolean ignore ) { this . ignore = ignore ; }
public calendar get calendar ( ) { return calendar ; }
public static void no null element ( object [ ] array ) { validate . not null ( array ) ; for ( int i = 0 ; i < array . length ; i++ ) { if ( array [ i ] == null ) { throw new illegal argument exception ( `` the validated array contain null element at index : `` + i ) ; } } }
public static void no null element ( object [ ] array ) { validate . not null ( array ) ; for ( int i = 0 ; i < array . length ; i++ ) { if ( array [ i ] == null ) { throw new illegal argument exception ( `` the validated array contain null element at index : `` + i ) ; } } }
public boolean contain all ( collection < ? > collection ) { for ( iterator i = collection . iterator ( ) ; i . have next ( ) ; ) { if ( ! contains ( i . next ( ) ) ) { return false ; } } return true ; }
public str builder append ( char [ ] char ) { if ( char == null ) { return append null ( ) ; } int str len = char . length ; if ( str len > 0 ) { int len = length ( ) ; ensure capacity ( len + str len ) ; system . arraycopy ( char , 0 , buffer , len , str len ) ; size += str len ; } return this ; }
public static file get java io tmp dir ( ) { return new file ( system . get property ( java_io_tmpdir_key ) ) ; }
public boolean be enable ( ) { return this . enable ; } // -- boolean be enable ( )
public double get priority ( ) { return priority ; }
public int get group thread count ( ) { return group thread count ; }
protect groovy bean definition reader invoke bean defining closure ( closure callable ) { callable . set delegate ( this ) ; callable . call ( ) ; finalize deferred property ( ) ; return this ; }
public t get object ( ) { return this . object ; }
public executor service get executor service ( ) { return executor service ; }
public l [ ] get listener ( ) { return listener . to array ( prototype array ) ; }
public string name ( ) { return name . to string ( ) ; }
public int length ( object obj ) { if ( be array ( obj ) ) { return ( ( list ) obj ) . size ( ) ; } else if ( be map ( obj ) ) { return get property key ( obj ) . size ( ) ; } else if ( obj instanceof string ) { return ( ( string ) obj ) . length ( ) ; } throw new json path exception ( `` length operation can not be apply to `` + obj ! =null ? obj . get class ( ) . get name ( ) : `` null `` ) ; }
public int get maximum value ( long instant ) { return get maximum value ( ) ; }
public field get field ( ) { return field ; }
public type get type ( ) { return type ; }
public static final string unescape xml ( string input ) { return unescape_xml . translate ( input ) ; }
public static final string unescape html3 ( string input ) { return unescape_html3 . translate ( input ) ; }
public index request set if seq no ( long seq no ) { if ( seq no < 0 & & seq no ! = unassigned_seq_no ) { throw new illegal argument exception ( `` sequence number must be non negative . get [ `` + seq no + `` ] . `` ) ; } if seq no = seq no ; return this ; }
public t index ( index [ ] index ) { this . index = index ; return ( t ) this ; }
public str builder insert ( int index , char char [ ] , int offset , int length ) { validate index ( index ) ; if ( char == null ) { return insert ( index , null text ) ; } if ( offset < 0 || offset > char . length ) { throw new string index out of bound exception ( `` invalid offset : `` + offset ) ; } if ( length < 0 || offset + length > char . length ) { throw new string index out of bound exception ( `` invalid length : `` + length ) ; } if ( length > 0 ) { ensure capacity ( size + length ) ; system . arraycopy ( buffer , index , buffer , index + length , size - index ) ; system . arraycopy ( char , offset , buffer , index , length ) ; size += length ; } return this ; }
public static < t > void inclusive between ( t start , t end , comparable < t > value , string message , object . . . value ) { if ( value . compare to ( start ) < 0 || value . compare to ( end ) > 0 ) { throw new illegal argument exception ( string . format ( message , value ) ) ; } }
public static < t > void inclusive between ( t start , t end , comparable < t > value ) { if ( value . compare to ( start ) < 0 || value . compare to ( end ) > 0 ) { throw new illegal argument exception ( string . format ( default_inclusive_between_ex_message , value , start , end ) ) ; } }
public static boolean be simple value type ( class < ? > type ) { return ( void . class ! = type & & void . class ! = type & & ( class utils . be primitive or wrapper ( type ) || enum . class . be assignable from ( type ) || char sequence . class . be assignable from ( type ) || number . class . be assignable from ( type ) || date . class . be assignable from ( type ) || temporal . class . be assignable from ( type ) || uri . class == type || url . class == type || locale . class == type || class . class == type ) ) ; }
public static boolean a boolean ( byte [ ] array ) { if ( null == array ) { return false ; } return array . length > 0 ; }
public int array length ( final int index ) { ensure restrict index ( index ) ; return length ( index ) ; }
public int read ( char [ ] array , int offset , int length ) { if ( idx > = char sequence . length ( ) ) { return -1 ; } if ( array == null ) { throw new null pointer exception ( `` character array be miss `` ) ; } if ( length < 0 || offset < 0 || offset + length > array . length ) { throw new index out of bound exception ( `` array size= `` + array . length + `` , offset= `` + offset + `` , length= `` + length ) ; } int count = 0 ; for ( int i = 0 ; i < length ; i++ ) { int c = read ( ) ; if ( c == -1 ) { return count ; } array [ offset + i ] = ( char ) c ; count++ ; } return count ; }
public static void swap ( final byte [ ] array , int offset1 , int offset2 , int len ) { if ( be empty ( array ) || offset1 > = array . length || offset2 > = array . length ) { return ; } if ( offset1 < 0 ) { offset1 = 0 ; } if ( offset2 < 0 ) { offset2 = 0 ; } len = math . min ( math . min ( len , array . length - offset1 ) , array . length - offset2 ) ; for ( int i = 0 ; i < len ; i++ , offset1++ , offset2++ ) { final byte aux = array [ offset1 ] ; array [ offset1 ] = array [ offset2 ] ; array [ offset2 ] = aux ; } }
public static void swap ( final byte [ ] array , final int offset1 , final int offset2 ) { if ( be empty ( array ) ) { return ; } swap ( array , offset1 , offset2 , 1 ) ; }
public string get field name ( ) { return field name ; }
public long interval ( ) { return date histogram interval . interval ( ) ; }
public void set output threshold ( long threshold ) { this . threshold = threshold ; }
public boolean try interval lock ( long interval ) { long now = time source . current time millis ( ) ; boolean acquire = ( now - last acquire . get ( ) > = interval ) & & write lock ( ) . try lock ( ) ; if ( acquire ) last acquire . set ( now ) ; return acquire ; }
public l [ ] get listener ( ) { return listener . to array ( prototype array ) ; }
public static boolean node get true ( ) { return true ; }
public string get value ( ) { return value ; }
public float float value ( ) { return ( ( float ) numerator ) / ( ( float ) denominator ) ; }
public static string get user directory path ( ) { return system . get property ( `` user . home `` ) ; }
public object clone ( ) { if ( be reference ( ) ) { return ( ( dir set ) get ref ( get project ( ) ) ) . clone ( ) ; } else { return super . clone ( ) ; } }
public int get group thread count ( ) { return group thread count ; }
public static date plus ( date self , int day ) { calendar calendar = ( calendar ) calendar . get instance ( ) . clone ( ) ; calendar . set time ( self ) ; calendar . add ( calendar . day_of_year , day ) ; return calendar . get time ( ) ; }
public boolean parse ( final string source , final parse position po , final calendar calendar ) { final list iterator < strategy and width > lt = pattern . list iterator ( ) ; while ( lt . have next ( ) ) { final strategy and width strategy and width = lt . next ( ) ; final int max width = strategy and width . get max width ( lt ) ; if ( ! strategy and width . strategy . parse ( this , calendar , source , po , max width ) ) { return false ; } } return true ; }
public void set watch ( long relative zxid , list < string > data watch , list < string > exist watch , list < string > child watch , watcher watcher ) { data tree . set watch ( relative zxid , data watch , exist watch , child watch , watcher ) ; }
public boolean equal ( final object obj ) { if ( obj == this ) { return true ; } else if ( ! ( obj instanceof class info ) ) { return false ; } final class info other = ( class info ) obj ; return name . equal ( other . name ) ; }
public boolean be empty ( ) { return size == 0 ; }
public boolean parse ( final string source , final parse position po , final calendar calendar ) { final list iterator < strategy and width > lt = pattern . list iterator ( ) ; while ( lt . have next ( ) ) { final strategy and width strategy and width = lt . next ( ) ; final int max width = strategy and width . get max width ( lt ) ; if ( ! strategy and width . strategy . parse ( this , calendar , source , po , max width ) ) { return false ; } } return true ; }
public static boolean be alphanumeric ( int codepoint ) { return alphanumerics . contains ( codepoint ) ; }
public time unit get time unit ( ) { return this . time unit ; }
public static string get name ( final class < ? > cl , final string value if null ) { return cl == null ? value if null : cl . get name ( ) ; }
public static string get name ( final class < ? > cl ) { return get name ( cl , string utils . empty ) ; }
public void set logger ( log logger ) { this . logger = logger ; }
public void trace ( object message ) { debug ( message ) ; }
public void set fatal ( boolean fatal ) { }
public void set log ( log log ) { this . log = log ; }
public void free ( long po , int length ) { free space . free ( po , length ) ; }
public int get size ( ) { return size ; }
public double evaluate ( double x ) throw convergence exception { return evaluate ( x , default_epsilon , integer . max_value ) ; }
public static double to radian ( final double degree ) { return degree * to_radians ; }
public double get argument ( ) { return fast math . atan2 ( get imaginary ( ) , get real ( ) ) ; }
public static boolean equal include na n ( float x , float y ) { return ( float . be na n ( x ) & & float . be na n ( y ) ) || equal ( x , y , 1 ) ; }
public complex tanh ( ) { if ( be na n || double . be infinite ( imaginary ) ) { return na n ; } if ( real > 20 . 0 ) { return create complex ( 1 . 0 , 0 . 0 ) ; } if ( real < -20 . 0 ) { return create complex ( -1 . 0 , 0 . 0 ) ; } double real2 = 2 . 0 * real ; double imaginary2 = 2 . 0 * imaginary ; double d = fast math . cosh ( real2 ) + fast math . co ( imaginary2 ) ; return create complex ( fast math . sinh ( real2 ) / d , fast math . sin ( imaginary2 ) / d ) ; }
public complex sin ( ) { if ( be na n ) { return na n ; } return create complex ( fast math . sin ( real ) * fast math . cosh ( imaginary ) , fast math . co ( real ) * fast math . sinh ( imaginary ) ) ; }
public complex sin ( ) { if ( be na n ) { return na n ; } return create complex ( fast math . sin ( real ) * fast math . cosh ( imaginary ) , fast math . co ( real ) * fast math . sinh ( imaginary ) ) ; }
public part builder part ( string name , object part ) { return part ( name , part , null ) ; }
public static boolean equal ( double x , double y , double eps ) { return equal ( x , y ) || ( math . ab ( y - x ) < = eps ) ; }
public boolean equal ( final quaternion q , final double eps ) { return precision . equal ( q0 , q . get q0 ( ) , eps ) & & precision . equal ( q1 , q . get q1 ( ) , eps ) & & precision . equal ( q2 , q . get q2 ( ) , eps ) & & precision . equal ( q3 , q . get q3 ( ) , eps ) ; }
public string get mode ( ) { return mode ; }
public void add ( input split s ) throw i o exception { if ( null == split ) { throw new i o exception ( `` uninitialized input split `` ) ; } if ( fill == split . length ) { throw new i o exception ( `` too many split `` ) ; } split [ fill++ ] = s ; totsize += s . get length ( ) ; }
protect boolean eq ( object x , object y ) { return x == y || x . equal ( y ) ; }
public location get location ( ) { return location ; }
public void add all ( c o s array object list ) { if ( object list ! = null ) { object . add all ( object list . object ) ; } }
public int next int ( int least , int bound ) { if ( least > = bound ) { throw new illegal argument exception ( ) ; } return next int ( bound - least ) + least ; }
public void clear ( ) { object . clear ( ) ; }
public big fraction subtract ( final big fraction fraction ) { if ( fraction == null ) { throw new null argument exception ( localized format . fraction ) ; } if ( fraction . numerator . signum ( ) == 0 ) { return this ; } if ( numerator . signum ( ) == 0 ) { return fraction . negate ( ) ; } big integer num = null ; big integer den = null ; if ( denominator . equal ( fraction . denominator ) ) { num = numerator . subtract ( fraction . numerator ) ; den = denominator ; } else { num = ( numerator . multiply ( fraction . denominator ) ) . subtract ( ( fraction . numerator ) . multiply ( denominator ) ) ; den = denominator . multiply ( fraction . denominator ) ; } return new big fraction ( num , den ) ; }
public big fraction add ( final big fraction fraction ) { if ( fraction == null ) { throw new null argument exception ( localized format . fraction ) ; } if ( fraction . numerator . signum ( ) == 0 ) { return this ; } if ( numerator . signum ( ) == 0 ) { return fraction ; } big integer num = null ; big integer den = null ; if ( denominator . equal ( fraction . denominator ) ) { num = numerator . add ( fraction . numerator ) ; den = denominator ; } else { num = ( numerator . multiply ( fraction . denominator ) ) . add ( ( fraction . numerator ) . multiply ( denominator ) ) ; den = denominator . multiply ( fraction . denominator ) ; } if ( num . signum ( ) == 0 ) { return zero ; } return new big fraction ( num , den ) ; }
public big fraction subtract ( final big fraction fraction ) { if ( fraction == null ) { throw new null argument exception ( localized format . fraction ) ; } if ( fraction . numerator . signum ( ) == 0 ) { return this ; } if ( numerator . signum ( ) == 0 ) { return fraction . negate ( ) ; } big integer num = null ; big integer den = null ; if ( denominator . equal ( fraction . denominator ) ) { num = numerator . subtract ( fraction . numerator ) ; den = denominator ; } else { num = ( numerator . multiply ( fraction . denominator ) ) . subtract ( ( fraction . numerator ) . multiply ( denominator ) ) ; den = denominator . multiply ( fraction . denominator ) ; } return new big fraction ( num , den ) ; }
public int get first index ( ) { return first index ; }
public void set random access ( ) { this . random access = true ; }
public double get rate ( time unit rate unit ) { return rate * ( double ) rate unit . to nanos ( 1 ) ; }
public boolean be satisfied ( population population ) { if ( this . num generation < this . max generation ) { num generations++ ; return false ; } return true ; }
public void set generator ( final string generator ) { this . generator = generator ; }
public statement set retry policy ( retry policy policy ) { this . retry policy = policy ; return this ; }
public static int get max level ( int arity ) { return s2 cell id . m a x_ l e v e l/arity + 1 ; }
public void set margin left ( double point ) { if ( point ! = null || _p . be set p pr ( ) ) { get or create property ( ) . set margin leave ( point ) ; } }
public static number multiply ( number leave , character right ) { return number number multiply . multiply ( integer . value of ( right ) , leave ) ; }
public object get array ( ) { return array ; }
public void set d ( file d ) { this . d = d ; }
public void prepend ( char ch ) { char [ ] a2 = new char [ array . length + 1 ] ; system . arraycopy ( array , 0 , a2 , 1 , use ) ; a2 [ 0 ] = ch ; use += 1 ; array = a2 ; }
public object get instance ( ) { return instance ; }
public void set cost relative tolerance ( double cost relative tolerance ) { this . cost relative tolerance = cost relative tolerance ; }
public void set style ( string s ) { get c o s object ( ) . set name ( `` s `` , s ) ; }
public sub hyperplane < s > inside touch ( ) { return inside touch ; }
public sub hyperplane < s > get plus inside ( ) { return plus inside ; }
public double [ ] get point ( ) { return point ; }
protect int be shape inside area ( final geo shape path ) { final geo point [ ] path point = path . get edge point ( ) ; if ( path point . length == 0 ) return no_edgepoints ; boolean find outside = false ; boolean find inside = false ; for ( final geo point p : path point ) { if ( be within ( p ) ) { find inside = true ; } else { find outside = true ; } if ( find inside & & find outside ) { return some_inside ; } } if ( ! find inside & & ! find outside ) return none_inside ; if ( find inside & & ! find outside ) return all_inside ; if ( find outside & & ! find inside ) return none_inside ; return some_inside ; }
public affine transformation rotate ( double sin theta , double co theta , double x , double y ) { compose ( rotation instance ( sin theta , cos theta ) ) ; return this ; }
public double get double ( string name ) { double ret = delegate . get double ( name ) ; return ret ; }
public boolean row have cell ( int row ) { if ( row > = record . length ) { return false ; } cell value record interface [ ] row cells=records [ row ] ; if ( row cells==null ) return false ; for ( int col=0 ; col < row cell . length ; col++ ) { if ( row cell [ col ] ! =null ) return true ; } return false ; }
public final column definition column ( ) { return column ; }
protect int hash ( final object key1 , final object key2 ) { int h = 0 ; if ( key1 ! = null ) { h ^= key1 . hash code ( ) ; } if ( key2 ! = null ) { h ^= key2 . hash code ( ) ; } h += ~ ( h < < 9 ) ; h ^= h > > > 14 ; h += h < < 4 ; h ^= h > > > 10 ; return h ; }
public locale get locale ( ) { return locale ; }
public boolean have norm ( ) { return norm type ! = null ; }
public boolean be function ( ) { return this . function ; }
public void add ( map value ) throw s q l exception { get result set ( ) . move to insert row ( ) ; for ( iterator iter = value . entry set ( ) . iterator ( ) ; iter . have next ( ) ; ) { map . entry entry = ( map . entry ) iter . next ( ) ; get result set ( ) . update object ( entry . get key ( ) . to string ( ) , entry . get value ( ) ) ; } get result set ( ) . insert row ( ) ; }
public int size ( ) { return size ; }
public t get ( ) { return o ; }
public int get index ( ) { return index ; }
public void set primary ( boolean primary ) { this . primary = primary ; }
public directory get secondary dir ( ) { return secondary dir ; }
public void set scale ( double s ) { set scale internal ( s ) ; }
public long get h ( ) { if ( h == null ) { return 0l ; } else { return h ; } }
public package relationship collection get relationship ( ) throw invalid format exception { return get relationship core ( null ) ; }
public final long row count ( ) { return row ; }
protect void set cost ( double cost ) { this . cost = cost ; }
public double get chi square ( ) { return cost * cost ; }
public type target ( ) { return target ; }
public int next int ( int lower , int upper ) { if ( low > = upper ) { throw math runtime exception . create illegal argument exception ( `` upper bound ( { 0 } ) must be great than low bound ( { 1 } ) `` , upper , low ) ; } double r = get ran ( ) . next double ( ) ; return ( int ) ( ( r * upper ) + ( ( 1 . 0 - r ) * low ) + r ) ; }
public void start ( ) { }
public double get chi square ( ) { return cost * cost ; }
public double get double ( string name ) { double ret = delegate . get double ( name ) ; return ret ; }
public boolean be na n ( ) { return be na n ; }
public static double procedure be great ( final double b ) { return new double procedure ( ) { @ override public boolean apply ( double a ) { return a > b ; } } ; }
public int num point ( ) { return point bag . size ( ) ; }
public real matrix compute correlation matrix ( double [ ] [ ] data ) { return compute correlation matrix ( new block real matrix ( data ) ) ; }
public void update weight matrix ( matrix [ ] matrix ) { for ( int i = 0 ; i < matrix . length ; ++i ) { matrix matrix = this . weight matrix list . get ( i ) ; this . weight matrix list . set ( i , matrix . plus ( matrix [ i ] ) ) ; } }
public static double sumsq ( double [ ] value ) { double sumsq = 0 ; for ( int i=0 , i size=values . length ; i < i size ; i++ ) { sumsq += value [ i ] * value [ i ] ; } return sumsq ; }
public synchronize void set min impl ( univariate statistic min impl ) { this . min impl = min impl ; }
public synchronize univariate statistic get min impl ( ) { return min impl ; }
public double evaluate ( final double [ ] value , final double [ ] weight , final double mean ) throw math illegal argument exception { return evaluate ( value , weight , mean , 0 , value . length ) ; }
public boolean be boolean ( ) { return false ; }
public double evaluate ( final double [ ] value , final double [ ] weight , final double mean ) throw math illegal argument exception { return evaluate ( value , weight , mean , 0 , value . length ) ; }
public double evaluate ( final double [ ] value , final double [ ] weight ) throw math illegal argument exception { return evaluate ( value , weight , 0 , value . length ) ; }
public int get ( int i ) { int n = interval . size ( ) ; int index = 0 ; for ( int j = 0 ; j < n ; j++ ) { interval i = interval . get ( j ) ; int a = i . a ; int b = i . b ; for ( int v=a ; v < =b ; v++ ) { if ( index==i ) { return v ; } index++ ; } } return -1 ; }
public void set quantile ( final double p ) { if ( p < = 0 || p > 100 ) { throw math runtime exception . create illegal argument exception ( `` out of bound quantile value : { 0 } , must be in ( 0 , 100 ] `` , p ) ; } quantile = p ; }
public run average and std dev get normalize stats ( ) { run average and std dev summer = new full running average and std dev ( ) ; for ( int d = 0 ; d < confusion matrix . length ; d++ ) { double total = 0 ; for ( int j = 0 ; j < confusion matrix . length ; j++ ) { total += confusion matrix [ d ] [ j ] ; } summer . add datum ( confusion matrix [ d ] [ d ] / ( total + 0 . 000001 ) ) ; } return summer ; }
public synchronize void set min impl ( univariate statistic min impl ) { this . min impl = min impl ; }
public string to string ( ) { string buffer buffer = new string buffer ( ) ; buffer . append ( to string ( get class ( ) ) ) ; buffer . append ( `` [ use default= `` ) ; buffer . append ( be use default ( ) ) ; buffer . append ( `` , use locale format= `` ) ; buffer . append ( use locale format ) ; if ( pattern ! = null ) { buffer . append ( `` , pattern= `` ) ; buffer . append ( pattern ) ; } if ( locale ! = null ) { buffer . append ( `` , locale= `` ) ; buffer . append ( locale ) ; } buffer . append ( ' ] ' ) ; return buffer . to string ( ) ; }
public void clear ( ) { object . clear ( ) ; }
public boolean be alpha source ( ) { return alpha source ; }
protect boolean eq ( object x , object y ) { return x == y || x . equal ( y ) ; }
public int get confidence ( ) { return f confidence ; }
public void set y ( string value ) { this . y = value ; }
protect void new y sample data ( double [ ] y ) { if ( y == null ) { throw new null argument exception ( ) ; } if ( y . length == 0 ) { throw new no data exception ( ) ; } this . y vector = new array real vector ( y ) ; }
public double get chi square ( estimation problem problem ) { weighted measurement [ ] wm = problem . get measurement ( ) ; double chi square = 0 ; for ( int i = 0 ; i < wm . length ; ++i ) { double residual = wm [ i ] . get residual ( ) ; chi square += residual * residual / wm [ i ] . get weight ( ) ; } return chi square ; }
public void name ( string n ) { this . name = n ; }
protect boolean eq ( object x , object y ) { return x == y || x . equal ( y ) ; }
public vector3 d normalize ( ) { double length = length ( ) ; if ( length > 0 . 0 ) return divide ( length ( ) ) ; return create ( 0 . 0 , 0 . 0 , 0 . 0 ) ; }
public double evaluate ( final double [ ] value , final double [ ] weight ) throw math illegal argument exception { return evaluate ( value , weight , 0 , value . length ) ; }
public double evaluate ( final double [ ] value , final double [ ] weight , final double mean ) throw math illegal argument exception { return evaluate ( value , weight , mean , 0 , value . length ) ; }
public double value ( double x ) { return evaluate ( coefficient , x ) ; }
public int get size ( ) { return size ; }
public final void set cache second ( int second ) { this . cache second = second ; }
public static object wrap ( object o ) { if ( o == null ) { return null ; } if ( o instanceof j s o n array || o instanceof j s o n object ) { return o ; } if ( o . equal ( null ) ) { return o ; } try { if ( o instanceof collection ) { return new j s o n array ( ( collection ) o ) ; } else if ( o . get class ( ) . be array ( ) ) { return new j s o n array ( o ) ; } if ( o instanceof map ) { return new j s o n object ( ( map ) o ) ; } if ( o instanceof boolean || o instanceof byte || o instanceof character || o instanceof double || o instanceof float || o instanceof integer || o instanceof long || o instanceof short || o instanceof string ) { return o ; } if ( o . get class ( ) . get package ( ) . get name ( ) . start with ( `` java . `` ) ) { return o . to string ( ) ; } } catch ( exception ignore ) { } return null ; }
public static boolean equal ( double x , double y , double eps ) { return equal ( x , y ) || ( math . ab ( y - x ) < = eps ) ; }
public transformer get transformer ( ) { return i transformer ; }
public string lookup property string lookup ( ) { return property string lookup . instance ; }
public void set right ( final string right ) { this . right = list . create ( right ) ; }
public void set ignore ( boolean ignore ) { this . ignore = ignore ; }
public static char to char ( character ch , char default value ) { if ( ch == null ) { return default value ; } return ch . char value ( ) ; }
public str builder appendln ( double value ) { return append ( value ) . append new line ( ) ; }
public char array buffer append ( char c ) { append ( new char [ ] { c } , 0 , 1 ) ; return this ; }
public string separator ( ) { return separator ; }
public string get key ( ) { return key ; }
public int get size ( ) { return size ; }
public void register value target ( target target ) { if ( target == null ) { target = new vector ( ) ; } target . add element ( target ) ; }
public static inet address validator get instance ( ) { return validator ; }
public void set prefer ip address ( boolean prefer ip address ) { this . prefer ip address = prefer ip address ; }
public string get indexed property ( ) { return this . indexed property ; }
public void set depend ( boolean depend ) { this . depend = depend ; }
public list < collection < e > > get collection ( ) { return unmodifiable list . unmodifiable list ( all ) ; }
public string get indexed property ( ) { return this . indexed property ; }
public language result get language ( ) { return writer . get language ( ) ; }
public boolean be valid ( ) { return valid ; }
public boolean be valid ( ) { return valid ; }
public date validate ( string value , string pattern , time zone time zone ) { return ( date ) parse ( value , pattern , ( locale ) null , time zone ) ; }
public object get value ( ) { return value ; }
public big integer get big integer value ( ) throw i o exception { return delegate . get big integer value ( ) ; }
public calendar validate ( string value , string pattern , locale locale , time zone time zone ) { return ( calendar ) parse ( value , pattern , locale , time zone ) ; }
public calendar validate ( string value , string pattern , time zone time zone ) { return ( calendar ) parse ( value , pattern , ( locale ) null , time zone ) ; }
protect int calculate modulus ( string code , boolean include check digit ) throw check digit exception { if ( code . length ( ) > 7 ) { throw new check digit exception ( `` invalid code length = `` + code . length ( ) ) ; } return super . calculate modulus ( code , include check digit ) ; }
public string calculate ( string code ) throw check digit exception { if ( code == null || code . length ( ) < 5 ) { throw new check digit exception ( `` invalid code length= `` + ( code == null ? 0 : code . length ( ) ) ) ; } int modulus result = calculate modulus ( code ) ; int char value = ( 98 - modulus result ) ; string check digit = integer . to string ( char value ) ; return ( char value > 9 ? check digit : `` 0 `` + check digit ) ; }
public string calculate ( string code ) throw check digit exception { if ( code == null || code . length ( ) < 5 ) { throw new check digit exception ( `` invalid code length= `` + ( code == null ? 0 : code . length ( ) ) ) ; } int modulus result = calculate modulus ( code ) ; int char value = ( 98 - modulus result ) ; string check digit = integer . to string ( char value ) ; return ( char value > 9 ? check digit : `` 0 `` + check digit ) ; }
public calendar validate ( string value , string pattern , time zone time zone ) { return ( calendar ) parse ( value , pattern , ( locale ) null , time zone ) ; }
public string get domain ( ) { return domain ; }
public boolean be valid local tld ( string i tld ) { return local_tld_list . contains ( chomp lead dot ( i tld . to lower case ( ) ) ) ; }
public boolean be valid infrastructure tld ( string i tld ) { return infrastructure_tld_list . contains ( chomp lead dot ( i tld . to lower case ( ) ) ) ; }
public calendar validate ( string value , string pattern ) { return ( calendar ) parse ( value , pattern , ( locale ) null , ( time zone ) null ) ; }
public string get validator class ( ) { return validator class ; }
public calendar validate ( string value , string pattern , time zone time zone ) { return ( calendar ) parse ( value , pattern , ( locale ) null , time zone ) ; }
public object get parameter ( string name ) { return parameter . get ( name ) ; }
protect string update message ( string msg ) { return msg ; }
public boolean be function ( ) { return this . function ; }
public string get validator class ( ) { return validator class ; }
public string get action ( ) { return action ; }
public result get result ( ) { return result ; }
public string get value ( ) { return value ; }
public j w k set get j w k set ( ) { j s o n object jwk set j s o n object = get j s o n object claim ( jwks_claim_name ) ; if ( jwk set j s o n object == null ) { return null ; } try { return j w k set . parse ( jwk set j s o n object ) ; } catch ( java . text . parse exception e ) { return null ; } }
public boolean us writer ( ) { return true ; }
public static boolean get cache token ( ) { return option . boolean value ( option . useroption__cache_tokens ) ; }
public static int int value ( final string option ) { return ( ( integer ) option . option value . get ( option ) ) . int value ( ) ; }
public string get package ( ) { return package ; }
public request option get option ( ) { return option ; }
public static boolean get cache token ( ) { return option . boolean value ( option . useroption__cache_tokens ) ; }
public static boolean get debug token manager ( ) { return option . boolean value ( option . useroption__debug_token_manager ) ; }
public static int int value ( final string option ) { return ( ( integer ) option . option value . get ( option ) ) . int value ( ) ; }
public static int int value ( final string option ) { return ( ( integer ) option . option value . get ( option ) ) . int value ( ) ; }
public double double value ( ) { return value ; }
public long interval ( ) { return date histogram interval . interval ( ) ; }
public static simple curve fitter create ( parametric univariate function f , double [ ] start ) { return new simple curve fitter ( f , start , integer . max_value ) ; }
public double [ ] get point ( ) { return point ; }
public int get from int ( ) { return get from ( ) ; }
public common stats flag group ( string . . . group ) { this . group = group ; return this ; }
public boolean be close ( ) { return close ; }
public int get capacity ( ) { return capacity ; }
public static list < string > parse expression ( string expression ) { return convert for j s s e ( parse ( expression ) ) ; }
public double of ( double [ ] d , int num param ) { return math . log ( d [ 0 ] + math . sqrt ( 1 + d [ 0 ] * d [ 0 ] ) ) ; }
public double of ( double [ ] d , int num param ) { return java . lang . math . sqrt ( d [ 0 ] ) ; }
public double of ( double [ ] d , int num param ) { return java . lang . math . sqrt ( d [ 0 ] ) ; }
public boolean num exist ( big integer num i d ) { for ( x w p f num num : nums ) { if ( num . get c t num ( ) . get num id ( ) . equal ( num i d ) ) return true ; } return false ; }
public static double acosh ( double d ) { return math . log ( math . sqrt ( math . pow ( d , 2 ) - 1 ) + d ) ; }
public double of ( double [ ] d , int num param ) { return java . lang . math . sqrt ( d [ 0 ] ) ; }
public double of ( double [ ] d , int num param ) { return java . lang . math . floor ( d [ 0 ] ) ; }
public function [ ] get function ( ) { function [ ] arr = new function [ num func ] ; for ( int i = 0 ; i < arr . length ; i++ ) arr [ i ] = func [ i ] ; return arr ; }
public string [ ] get function name ( ) { string [ ] arr = new string [ num func ] ; for ( int i = 0 ; i < arr . length ; i++ ) arr [ i ] = name [ i ] ; return arr ; }
public boolean be share cache ( ) { return be share cache ; }
public string [ ] get function name ( ) { string [ ] arr = new string [ num func ] ; for ( int i = 0 ; i < arr . length ; i++ ) arr [ i ] = name [ i ] ; return arr ; }
public void set view ( view view ) { this . view = view ; }
public autowire capable bean factory get autowire capable bean factory ( ) throw illegal state exception { return get bean factory ( ) ; }
public static class loader get class loader a privileged ( final class clazz ) { if ( ! has_get_class_loader_permission ) return null ; else return access controller . do privilege ( new privilege action < class loader > ( ) { public class loader run ( ) { return clazz . get class loader ( ) ; } } ) ; }
public static local aware executor service get stage ( stage stage ) { return stage . get ( stage ) ; }
public void set member ( final i member [ ] member ) { assert . be not null ( member ) ; f members= member ; }
public static boolean be valid lifecycle callback ( method method ) { if ( method . get parameter type ( ) . length ! = 0 || modifier . be static ( method . get modifier ( ) ) || method . get exception type ( ) . length > 0 || ! method . get return type ( ) . get name ( ) . equal ( `` void `` ) ) { return false ; } return true ; }
public list < t n e f attribute > get attribute ( ) { return attribute ; }
public void add bean ( string name , object bean ) { this . bean . put ( name , bean ) ; }
public object get attribute ( string attribute name ) { return attribute map . get ( attribute name ) ; }
public boolean get be not support ( ) { return this . be not support ; }
public void add alias ( string element name , string property name ) { element name . put ( element name , property name ) ; }
public void set default value ( string default value ) { this . default value = default value ; }
public void set name ( string name ) { this . name = name ; }
public error handler get handler ( ) { return handler ; }
public document get document ( ) { return document ; }
protect x m l reader create default reader ( ) { s a x parser factory factory = s a x parser factory . new instance ( ) ; factory . set validating ( true ) ; factory . set namespace aware ( true ) ; x m l reader reader = null ; try { s a x parser sax parser = factory . new s a x parser ( ) ; reader = sax parser . get x m l reader ( ) ; } catch ( parser configuration exception e ) { throw new build exception ( error_parser_creation_failure , e ) ; } catch ( s a x exception e ) { throw new build exception ( error_parser_creation_failure , e ) ; } return reader ; }
protect void add external d t d declaration ( decl declaration ) { if ( external d t d declaration == null ) { external d t d declaration = new array list < decl > ( ) ; } external d t d declaration . add ( declaration ) ; }
public void external entity decl ( string name , string public id , string sys id ) throw s a x exception { external entity decl declaration = new external entity decl ( name , public id , sys id ) ; if ( internal d t dsubset ) { if ( include internal d t d declaration ) { add d t d declaration ( declaration ) ; } } else { if ( include external d t d declaration ) { add external d t d declaration ( declaration ) ; } } }
public void add source ( input stream source ) { source . add ( source ) ; }
public void set encoding ( string encode ) { this . encode = encoding ; }
public content handler get custom content handler ( ) { return custom content handler ; }
public final integer get priority ( ) { return priority ; }
public extend property definition get property definition ( ) { return this . property definition ; }
public void set object name ( structure q name q name ) { object name = q name ; }
protect void write char sequence ( char sequence seq , char buf buffer ) { if ( seq . length ( ) > 0 ) { buffer . add json escape string ( seq . to string ( ) , disable unicode escape ) ; } else { buffer . add char ( empty_string_chars ) ; } }
public static void sort ( list < ? > list ) { if ( list . size ( ) > 1 ) { collection . sort ( list , instance ) ; } }
public static < t > param < t > param ( string name , field < t > type ) { return param ( name , type . get data type ( ) ) ; }
public iterator iterator ( ) { return new iterator ( ) ; }
public void add server ( instrumented < server stats > server ) { server socket map prev = per server socket . put ( id ( server ) , new server socket map ( ) ) ; assert prev == null ; add ( server , server ) ; }
public string get dns suffix ( ) { return dns suffix ; }
public error get error ( ) { return this . error ; }
public int get port ( ) { return this . port ; }
public string get action ( ) { return action ; }
public void read end element ( string namespace prefix , string element name ) throw exception { this . internal read element ( namespace prefix , element name , new xml node type ( xml node type . end_element ) ) ; }
public service response get response ( ) { return response ; }
public static < t extend enum < t > > t value of ( final class < t > enum type , final string name , final t default value ) { return name == null ? default value : enum . value of ( enum type , name . to upper case ( locale . english ) ) ; }
public void read end element ( string namespace prefix , string element name ) throw exception { this . internal read element ( namespace prefix , element name , new xml node type ( xml node type . end_element ) ) ; }
public string read element value ( ) throw exception { this . ensure current node be start element ( ) ; return this . read element value ( this . get namespace prefix ( ) , this . get local name ( ) ) ; }
public string read element value ( ) throw exception { this . ensure current node be start element ( ) ; return this . read element value ( this . get namespace prefix ( ) , this . get local name ( ) ) ; }
public void set element ( string element ) { assert . have text ( element , `` 'element ' can not be null or blank `` ) ; this . element = element ; }
public object response ( ) { return response ; }
public int get minor version ( ) { return minor version ; }
public int get minor version ( ) { return minor version ; }
public int get index create version major ( ) { return create version major ; }
public change collection < folder change > end sync folder hierarchy ( i async result async result ) throw exception { sync folder hierarchy request request = async request result . extract service request ( this , async result ) ; return request . end execute ( async result ) . get response at index ( 0 ) . get change ( ) ; }
public void set email address ( email address email address ) { this . email address = email address ; }
public void set trace ( boolean trace ) { this . trace = trace ; }
public void set proxy ( string value ) { this . proxy = value ; }
public extend property definition get property definition ( ) { return this . property definition ; }
public static object remove object property ( map property , string key , object default value ) { object value = default value ; if ( property ! = null & & property . contains key ( key ) ) { value = property . remove ( key ) ; } return value ; }
public property set get property set ( ) { return this . property set ; }
public string get user ( ) { return user ; }
public string get xml ( ) { return xml ; }
public void set parent folder id ( folder id value ) { this . parent folder id = value ; }
public folder id get parent folder id ( ) { return this . parent folder id ; }
public email address dictionary get email address ( ) throw service local exception { return get property bag ( ) . get object from property definition ( contact schema . email address ) ; }
public folder id get parent folder id ( ) { return this . parent folder id ; }
public string get query ( ) { return query ; }
public void add woven permission ( package permission permission ) { if ( ! permission . get action ( ) . equal ( package permission . import ) ) throw new security exception ( ) ; weave permission . add ( permission ) ; }
public default extend property set get property set ( ) { return this . property set ; }
public string get name ( ) { return this . name ; }
public static object output stream new object output stream ( output stream output stream ) throw i o exception { return new object output stream ( output stream ) ; }
public response builder set status code ( int status code ) { rest assure response . set status code ( status code ) ; return this ; }
public authenticate response authenticate ( request option option ) throw i o exception { return rest high level client . perform request and parse entity ( authenticate request . instance , authenticate request : : get request , option , authenticate response : : from x content , empty set ( ) ) ; }
public cors config builder allow request method ( final http method . . . method ) { request method . add all ( array . a list ( method ) ) ; return this ; }
public int get item id ( ) { return id ; }
public boolean be resolve ( ) { return resolve ; }
public oof setting get oof setting ( ) { return this . oof setting ; }
public void set parent folder id ( folder id value ) { this . parent folder id = value ; }
public email address get mailbox ( ) { return this . mailbox ; }
public string [ ] get conflict file ( ) { return conflicting ; }
public oof setting get oof setting ( ) { return this . oof setting ; }
protect void internal throw if necessary ( ) throw service response exception { if ( this . result == service result . error ) { throw new service response exception ( this ) ; } }
protect void internal throw if necessary ( ) throw service response exception { if ( this . get error code ( ) ! = service error . error name resolution no result ) { super . internal throw if necessary ( ) ; } }
public int get change ( ) { return this . change ; }
public boolean be update ( ) { return be update ; }
public folder id get parent folder id ( ) { return this . parent folder id ; }
public string get mode ( ) { return mode ; }
public boolean be accept ( ) { return accept ; }
public date get original start ( ) throw service local exception { return get property bag ( ) . get object from property definition ( appointment schema . original start ) ; }
public date get end ( ) throw service local exception { return get property bag ( ) . get object from property definition ( appointment schema . end ) ; }
public date get end ( ) throw service local exception { return get property bag ( ) . get object from property definition ( appointment schema . end ) ; }
public meeting attendee type get attendee type ( ) { return attendee type ; }
public date get end ( ) throw service local exception { return get property bag ( ) . get object from property definition ( appointment schema . end ) ; }
public contact get contact ( ) { return this . contact ; }
public string get alias ( ) throw service local exception { return get property bag ( ) . get object from property definition ( contact schema . alias ) ; }
public string get display name ( ) throw service local exception { return get property bag ( ) . get object from property definition ( contact schema . display name ) ; }
public void set email address ( email address email address ) { this . email address = email address ; }
public void set profession ( string value ) throw exception { this . get property bag ( ) . set object from property definition ( contact schema . profession , value ) ; }
public string get alias ( ) throw service local exception { return get property bag ( ) . get object from property definition ( contact schema . alias ) ; }
public void set generation ( string value ) throw exception { this . get property bag ( ) . set object from property definition ( contact schema . generation , value ) ; }
public void set generation ( string value ) throw exception { this . get property bag ( ) . set object from property definition ( contact schema . generation , value ) ; }
public string get display name ( ) throw service local exception { return get property bag ( ) . get object from property definition ( contact schema . display name ) ; }
public string get alias ( ) throw service local exception { return get property bag ( ) . get object from property definition ( contact schema . alias ) ; }
public email address collection get cc recipient ( ) throw service local exception { return get property bag ( ) . get object from property definition ( email message schema . cc recipient ) ; }
public byte [ ] get conversation index ( ) throw service local exception { return get property bag ( ) . get object from property definition ( email message schema . conversation index ) ; }
public email address dictionary get email address ( ) throw service local exception { return get property bag ( ) . get object from property definition ( contact schema . email address ) ; }
public boolean get global have attachment ( ) throw service local exception { return get property bag ( ) . < boolean > get object from property definition ( conversation schema . global have attachment ) ; }
public email address dictionary get email address ( ) throw service local exception { return get property bag ( ) . get object from property definition ( contact schema . email address ) ; }
public void set from ( email address value ) throw exception { this . get property bag ( ) . set object from property definition ( email message schema . from , value ) ; }
public boolean get be cancel ( ) throw service local exception { return get property bag ( ) . get object from property definition ( appointment schema . be cancel ) ; }
public void visit item ( object item ) { item . add ( item ) ; }
public date get end ( ) throw service local exception { return get property bag ( ) . get object from property definition ( appointment schema . end ) ; }
public date get end ( ) throw service local exception { return get property bag ( ) . get object from property definition ( appointment schema . end ) ; }
public date get end ( ) throw service local exception { return get property bag ( ) . get object from property definition ( appointment schema . end ) ; }
public boolean be boolean ( ) { return false ; }
public void set message body ( string message body ) { this . message body = message body ; }
public object get instance ( ) { return instance ; }
public void set property ( string property ) { this . property = property ; }
public change collection < t change > get change ( ) { return this . change ; }
public t get item ( ) { return item ; }
public boolean contains key ( long key ) { return get ( key ) ! = null ; }
public void set key ( boolean value ) { this . key = value ; }
public string get host ( ) { return host ; }
public url get url ( ) { return this . url ; }
public void set to list ( string list ) { string tokenizer token = new string tokenizer ( list , `` , `` ) ; while ( token . have more token ( ) ) { to list . add element ( new email address ( token . next token ( ) ) ) ; } }
public file new folder ( string folder ) throw i o exception { return new folder ( new string [ ] { folder } ) ; }
public t get item ( ) { return item ; }
public meeting attendee type get attendee type ( ) { return attendee type ; }
public attendee collection get optional attendee ( ) throw service local exception { return get property bag ( ) . get object from property definition ( appointment schema . optional attendee ) ; }
public collection < suggestion > get suggestion ( ) throw service response exception { if ( this . suggestion response == null ) { return null ; } else { this . suggestion response . throw if necessary ( ) ; return this . suggestion response . get suggestion ( ) ; } }
public collection < suggestion > get suggestion ( ) throw service response exception { if ( this . suggestion response == null ) { return null ; } else { this . suggestion response . throw if necessary ( ) ; return this . suggestion response . get suggestion ( ) ; } }
public duration to duration ( ) { return this ; }
public long get window size ( ) { return window size ; }
public void set detailed suggestion window ( time window value ) { this . detailed suggestion window = value ; }
public i java element delta get delta ( ) { return this . operation . delta builder . delta ; }
public date time plus month ( int month ) { if ( month == 0 ) { return this ; } long instant = get chronology ( ) . month ( ) . add ( get millis ( ) , month ) ; return with millis ( instant ) ; }
public oof setting get oof setting ( ) { return this . oof setting ; }
public void end ( ) { end ( date utils . get current date time ( ) ) ; }
public void set receive copy of meeting message ( boolean value ) { this . receive copy of meeting message = value ; }
public string get action ( ) { return action ; }
public void set category ( final list < category > category ) { this . category = category ; }
public void set id ( string id ) { this . id = id ; }
public void add ( number number ) { element . add ( number == null ? json null . instance : new json primitive ( number ) ) ; }
public mailbox get mailbox ( ) { return this . mailbox ; }
public void remove contact picture ( ) throw exception { ews utility . validate method version ( this . get service ( ) , exchange version . exchange2010 , `` remove contact picture `` ) ; if ( ! this . get property bag ( ) . be property loaded ( contact schema . attachment ) ) { throw new property exception ( `` the attachment collection must be load . `` ) ; } internal remove contact picture ( ) ; }
protect void set fault code ( string fault code ) { this . fault code = fault code ; }
protect string get fault code ( ) { return fault code ; }
protect void set fault code ( string fault code ) { this . fault code = fault code ; }
public int get line number ( ) { return line number ; }
public string get name ( ) { return this . name ; }
public void end unsubscribe ( i async result async result ) throw exception { unsubscribe request request = async request result . extract service request ( this , async result ) ; request . end execute ( async result ) ; }
public list < exception > get exception ( ) { return exception ; }
public string get content type ( ) { return content type ; }
public boolean be data ( ) { return ! can contain inline & & ! be empty ( ) ; }
public void clear ( ) { this . internal clear ( ) ; }
public void clear ( ) { this . internal clear ( ) ; }
public day of the week get week collection at index ( int index ) { return this . item . get ( index ) ; }
public long get start time ( ) { return start time ; }
public t get item ( ) { return item ; }
protected list < t complex property > get modify item ( ) { return this . modified item ; }
public delegate folder permission level get calendar folder permission level ( ) { return this . delegate folder permission . get ( xml element name . calendar folder permission level ) . get permission level ( ) ; }
public receive message result receive message sync ( receive message request rq ) { future < receive message result > future = receive message ( rq , null ) ; return wait for future ( future ) ; }
public string get name ( ) { return name ; }
public address get address ( ) { return address ; }
public mailbox get mailbox ( ) { return this . mailbox ; }
public address get address ( ) { return address ; }
public boolean be property updated ( property definition property definition ) { return this . modified property . contains ( property definition ) || this . added property . contains ( property definition ) ; }
public void add stream ( stream stream ) { if ( this . stream == null ) { this . stream = new hash set < stream > ( ) ; } this . stream . add ( stream ) ; }
public void set mailbox type ( mailbox type mailbox type ) { if ( this . can set field value ( this . mailbox type , mailbox type ) ) { this . mailbox type = mailbox type ; this . change ( ) ; } }
public string get owner ( ) { return owner ; }
public service object get service object ( ) { return this . service object ; }
public void set page ( p d page page ) { this . page = page ; }
public string get name ( ) { return this . name ; }
public static duration get daylight saving offset ( date self ) { time zone time zone = get time zone ( self ) ; int millis = ( time zone . use daylight time ( ) & & time zone . in daylight time ( self ) ) ? time zone . get d s t saving ( ) : 0 ; return new time duration ( 0 , 0 , 0 , millis ) ; }
public void set country or region ( string value ) { this . property bag . set simple property bag ( physical address schema . country or region , value ) ; }
public void set state ( string value ) { this . property bag . set simple property bag ( physical address schema . state , value ) ; }
public static < t > t coalesce ( t . . . value ) { if ( value == null ) { return null ; } for ( t value : value ) { if ( value ! = null ) { if ( value instanceof string ) { if ( string helper . be not empty ( ( string ) value ) ) { return value ; } } else { return value ; } } } return null ; }
public void never end ( ) { this . number of occurrence = null ; this . end date = null ; this . change ( ) ; }
public boolean have end ( ) { return ( ( this . number of occurrence ! = null ) || ( this . end date ! = null ) ) ; }
public context support get context support ( ) { return this . context support ; }
public boolean be delete ( ) { return be delete ; }
public string get server ( ) { return server ; }
protect void _report unsupported operation ( ) { throw new unsupported operation exception ( `` operation not support by parser of type `` +get class ( ) . get name ( ) ) ; }
protect void set date time ( date date time ) { this . date time = date time ; }
public date get date time ( ) { return date time ; }
public period to period ( ) { return new period ( this ) ; }
public void set date ( string date ) { super . set internal date ( date ) ; }
public void set message body ( string message body ) { this . message body = message body ; }
public http request with body ( body body ) { this . body = body ; return this ; }
public string get index ( ) { return this . index ; }
public boolean be enable ( ) { return true ; }
public string uri ( ) { return uri ; }
public long get available ( ) { return this . available ; }
public int get change ( ) { return this . change ; }
public void service object change ( service object service object ) { this . item change ( service object ) ; }
public string id ( ) { return id ; }
public void set date ( string date ) { super . set internal date ( date ) ; }
public static cascade style get cascade style ( string cascade ) { cascade style style = style . get ( cascade ) ; if ( style == null ) { throw new map exception ( `` unsupported cascade style : `` + cascade ) ; } else { return style ; } }
public static list < medium type > parse medium type ( @ nullable list < string > medium type ) { if ( collection utils . be empty ( medium type ) ) { return collection . empty list ( ) ; } else if ( medium type . size ( ) == 1 ) { return parse medium type ( medium type . get ( 0 ) ) ; } else { list < medium type > result = new array list < > ( 8 ) ; for ( string medium type : medium type ) { result . add all ( parse medium type ( medium type ) ) ; } return result ; } }
public cors registration allow origin ( string . . . origin ) { this . config . set allow origin ( array . a list ( origin ) ) ; return this ; }
public string get title ( ) { return title ; }
public boolean be share cache ( ) { return be share cache ; }
public rectangle get fix rectangle ( ) { if ( enclose scroll pane ! = null ) { return enclose scroll pane . get viewport border bound ( ) ; } else { dimension dim = get size ( ) ; return new rectangle ( 0 , 0 , dim . width , dim . height ) ; } }
public void set resource loader ( resource loader resource loader ) { this . resource loader = resource loader ; }
public void reset ( ) { this . element= null ; }
public static void clear image ( buffer image image ) { clear image ( image , color . white ) ; }
public void remove ( listener listener ) { listener . remove ( listener ) ; }
public int get dimension ( ) { return dim ; }
public void append byte ( int val ) { buf [ pos++ ] = ( byte ) val ; }
public string get raw value ( string name ) { final config value config value = get config value ( name ) ; return config value ! = null & & config value . get value ( ) ! = null ? config value . get value ( ) : null ; }
public void write to ( writer writer ) throw i o exception { write to ( writer , writer config . minimal ) ; }
public buffer image get opaque image ( ) throw i o exception { return sample image reader . get r g b image ( this , null ) ; }
public void set image ( string image ) { x m l util . set string value ( parent , `` xap g img : image `` , image ) ; }
public final synchronize metric record create record ( string record name ) { if ( buffer data . get ( record name ) == null ) { buffer data . put ( record name , new record map ( ) ) ; } return new record ( record name ) ; }
public void insert handler ( handler wrapper wrapper ) { if ( wrapper == null ) throw new illegal argument exception ( ) ; handler wrapper tail = wrapper ; while ( tail . get handler ( ) instanceof handler wrapper ) { tail = ( handler wrapper ) tail . get handler ( ) ; } if ( tail . get handler ( ) ! = null ) throw new illegal argument exception ( `` bad tail of inserted wrapper chain `` ) ; handler next = get handler ( ) ; set handler ( wrapper ) ; tail . set handler ( next ) ; }
public void add metric ( metric metric ) { metric . add ( metric ) ; for ( thread safe report listener listener : listener ) { listener . metric add ( metric ) ; } }
public void put ( c o s name name , p d font font ) { put ( c o s name . font , name , font ) ; }
public default resource get conf resource ( string name ) throw i o exception { string full name = `` conf/ `` + name ; return get resource ( full name ) ; }
public string get scheme ( ) { return scheme ; }
public character a character ( ) { return ( character ) this ; }
public void set v vector ( float [ ] v vector value ) { v vector = v vector value ; }
public float [ ] get v vector ( ) { return this . v vector ; }
public integer get height ( ) { return height ; }
public void set italic angle ( float angle ) { dic . set float ( c o s name . italic_angle , angle ) ; }
public void set width ( final integer width ) { this . width = width ; }
public void add track kern ( track kern kern ) { track kern . add ( kern ) ; }
public void set track kern ( list < track kern > track kern value ) { track kern = track kern value ; }
public boolean be composite ( ) { return false ; }
public void set width ( final integer width ) { this . width = width ; }
public void add track kern ( track kern kern ) { track kern . add ( kern ) ; }
public double [ ] get point ( ) { return point ; }
public static i extension registry get registry ( ) { i registry provider default registry provider = registry provider factory . get default ( ) ; if ( default registry provider == null ) return null ; return default registry provider . get registry ( ) ; }
public string get key ( ) { return key ; }
public int get position ( ) { return position ; }
public int read ( ) throw i o exception { int b = in . read ( ) ; if ( b ! = -1 ) { hasher . put byte ( ( byte ) b ) ; } return b ; }
public int get int ( ) { int b1 = buf [ pos++ ] & 0x f f ; int b2 = buf [ pos++ ] & 0x f f ; validate po ( po ) ; return ( b1 < < 8 ) + b2 ; }
public string buffer get class buffer ( ) { return class buffer ; }
public sequence get sequence ( string sequence name ) { sequence sequence = sequence . get ( sequence name ) ; if ( sequence == null ) { throw db exception . get ( error code . sequence_not_found_1 , sequence name ) ; } return sequence ; }
public void set name ( string name ) { this . name = name ; }
public int get from int ( ) { return get from ( ) ; }
public void set name code ( int name code ) { this . name code = name code ; }
public double get double ( string name ) { double ret = delegate . get double ( name ) ; return ret ; }
protect boolean eq ( object x , object y ) { return x == y || x . equal ( y ) ; }
public static boolean parse boolean ( char sequence char ) { return ( char . length ( ) == 4 ) & & ( char . char at ( 0 ) == 't ' || char . char at ( 0 ) == 't ' ) & & ( char . char at ( 1 ) == ' r ' || char . char at ( 1 ) == ' r ' ) & & ( char . char at ( 2 ) == ' u ' || char . char at ( 2 ) == ' u ' ) & & ( char . char at ( 3 ) == ' e ' || char . char at ( 3 ) == ' e ' ) ; }
public string get script ( ) { return script ; }
public horizontal metric table get horizontal metric ( ) throw i o exception { return ( horizontal metric table ) get table ( horizontal metric table . tag ) ; }
public horizontal header table get horizontal header ( ) throw i o exception { return ( horizontal header table ) get table ( horizontal header table . tag ) ; }
public string get read name ( ) { return read name ; }
public string get read name ( ) { return read name ; }
public parser notice . level get level threshold ( ) { return level threshold ; }
public string get family ( ) { return this . family ; } // -- string get family ( )
public type1 font get type1 font ( ) { return type1 ; }
public static boolean be collection ( final interface itf ) { if ( itf instanceof type interface ) { type interface t itf = ( type interface ) itf ; return type interface . collection_cardinality . equal ( t itf . get cardinality ( ) ) ; } return false ; }
public static boolean be optional ( final interface itf ) { if ( itf instanceof type interface ) { type interface t itf = ( type interface ) itf ; return type interface . optional_contingency . equal ( t itf . get contingency ( ) ) ; } return false ; }
protect void write to log ( string message ) { logger . warn ( message ) ; }
public int get warn level ( ) { return this . warn level ; }
public static < a extend annotation > list < a > get repeatable annotation ( method method , class < a > annotation class ) { a [ ] annotation = method . get annotation by type ( annotation class ) ; if ( annotation == null || annotation . length == 0 ) { for ( annotation meta annotation : method . get annotation ( ) ) { annotation = meta annotation . annotation type ( ) . get annotation by type ( annotation class ) ; if ( annotation ! = null & & annotation . length > 0 ) { return array . a list ( annotation ) ; } } method superclass method = get overridden method ( method ) ; if ( superclass method ! = null ) { return get repeatable annotation ( superclass method , annotation class ) ; } } if ( annotation == null ) { return null ; } return array . a list ( annotation ) ; }
public feature map get feature ( ) { return feature ; } //get feature ( )
public void error ( s a x parse exception exception ) throw s a x exception { throw exception ; }
public document get document ( ) { return document ; }
public document get document ( ) { return document ; }
public void set annotation name ( string annotation name ) { this . annotation name = annotation name ; } // set annotation name
public static annotation [ ] get resource annotation ( method method ) { map < class < ? > , annotation > annotation = new hash map < class < ? > , annotation > ( ) ; for ( annotation annotation : method . get declare class ( ) . get annotation ( ) ) { annotation . put ( annotation . get class ( ) , annotation ) ; } for ( annotation annotation : method . get annotation ( ) ) { annotation . put ( annotation . get class ( ) , annotation ) ; } return annotation . value ( ) . to array ( new annotation [ annotation . size ( ) ] ) ; }
public void set type ( string type ) { this . type = type ; }
public void set subtype ( string mime type ) { get c o s object ( ) . set name ( c o s name . subtype , mime type ) ; }
public string get parameter name ( ) { return parameter name ; }
public document doc ( int doc i d ) throw i o exception { return reader . document ( doc i d ) ; }
public list < list < pattern annotation > > get gate annotation ( ) { return this . gate annotation ; }
public execution result execute ( execution input . builder execution input builder ) { return execute ( execution input builder . build ( ) ) ; }
public object id get object id ( ) { return id ; }
protect void cleanup ( ) { }
public void set feature ( feature map feature ) { this . feature = feature ; }
public void set feature ( feature map feature ) { this . feature = feature ; }
public void set target ( object target ) { set target source ( new singleton target source ( target ) ) ; }
public boolean be request handle ( ) { return this . request handle ; }
public float get boost ( ) { return boost ; }
public string get store name ( ) { return store name ; }
public directory get directory ( ) { return directory ; }
public string get description ( ) { return description ; }
public byte array list value ( ) { byte array list list = new byte array list ( size ( ) ) ; value ( list ) ; return list ; }
public context index searcher searcher ( ) { return search context . searcher ( ) ; }
public string get reader ( ) { return reader ; }
public directory directory ( ) { return directory ; }
public void set file ( file file ) { this . file = file ; }
public int size ( ) { / * if ( element . size ( ) ! =super . size ( ) ) { error manager . internal error ( `` order hash set : element and set size differs ; `` + element . size ( ) + `` ! = `` +super . size ( ) ) ; } * / return element . size ( ) ; }
public int size ( ) { return size ; }
public static annotation [ ] get resource annotation ( method method ) { map < class < ? > , annotation > annotation = new hash map < class < ? > , annotation > ( ) ; for ( annotation annotation : method . get declare class ( ) . get annotation ( ) ) { annotation . put ( annotation . get class ( ) , annotation ) ; } for ( annotation annotation : method . get annotation ( ) ) { annotation . put ( annotation . get class ( ) , annotation ) ; } return annotation . value ( ) . to array ( new annotation [ annotation . size ( ) ] ) ; }
public void set export all ( boolean export ) { export all = export ; }
public string get query ( ) { return query ; }
public void set type ( string type ) { this . type = type ; }
public void set text ( boolean text ) { this . text = text ; }
public feature map get feature ( ) { return feature ; } //get feature ( )
public int get position ( ) { return this . position ; }
public boolean have annotation ( final string annotation name ) { return get annotation info ( ) . contains name ( annotation name ) ; }
public static s a x parser new s a x parser ( string schema language , file schema ) throw s a x exception , parser configuration exception { return new s a x parser ( schema language , true , false , schema ) ; }
public synchronize void cleanup ( ) { factory . delete resource ( analyser ) ; if ( corpus ! = null ) { factory . delete resource ( corpus ) ; } }
public void cleanup ( ) { }
public spring application builder main ( class < ? > main application class ) { this . application . set main application class ( main application class ) ; return this ; }
public resource get resource ( string name ) { return new file resource ( get base dir ( ) , name ) ; }
public list < field > get field ( ) { return field ; }
public url to u r l ( ) throw malformed u r l exception { return base . to u r l ( ) ; }
public parameter list get parameter list ( ) { return list ; }
protect void on parameter status ( string parameter name , string parameter status ) { if ( parameter name == null || parameter name . equal ( `` `` ) ) { throw new illegal state exception ( `` attempt to set guc_report parameter with null or empty-string name `` ) ; } parameter status . put ( parameter name , parameter status ) ; }
public version get version ( ) { return version ; }
public int hash code ( ) { return to hash code ( ) ; }
public void add instantiation ( resource resource ) { instantiation stack . add ( 0 , resource ) ; } // add instantiation
public list < resource > get instantiation ( ) { return unmodifiable instantiation stack ; } // get instantiation
public string get class name ( ) { return class name ; }
public url get url ( ) { return this . url ; }
public url get url ( ) { return this . url ; }
public gate . resource get resource ( ) { return resource ; }
public void add ( int index , e o ) { do add ( index , o ) ; }
public file filter get file filter ( ) { return file filter ; }
public string get document i d ( ) { return x m l util . get string value ( parent , `` st ref : document i d `` ) ; }
public final void set resource ( p d resource resource ) { get c o s object ( ) . set item ( c o s name . resource , resource ) ; }
public void add resource ( string name ) { add resource object ( new resource ( name ) ) ; }
public void put all ( map map ) { for ( object o : map . entry set ( ) ) { entry entry = ( entry ) o ; put ( entry . get key ( ) , entry . get value ( ) ) ; } }
public void set engine ( axis engine engine ) { this . engine = engine ; }
public void add r p c plugin ( r p c plugin plugin ) { rpc meta plugins . add ( plugin ) ; }
public string get file ( ) { return file ; }
public string get extension ( ) { return this . extension ; } // -- string get extension ( )
public document get document ( ) { return document ; }
public int get tag ( ) { return tag ; }
public set < string > get name ( ) { return new hash set < string > ( this . parameter . key set ( ) ) ; }
public void end subsidiary element ( ) { end element ( ) ; }
public icon style add to icon style object extension ( final abstract object icon style object extension ) { this . get icon style object extension ( ) . add ( icon style object extension ) ; return this ; }
public boolean be relation ( ) { return relation ; }
public type component ( ) { return component ; }
protect final graphics2 d get graphic ( ) { return graphic ; }
public long get thread count ( ) { return thread counter . get ( ) ; }
public void set file ( file f ) { check attribute allow ( ) ; file = f ; }
public void set enable ( string enable ) { this . enable = enable ; } // -- void set enable ( string )
public comparator get comparator ( ) { return comparator ; }
public void set feature ( feature map feature ) { this . feature = feature ; } // set feature ( )
public boolean be enable ( ) { return this . enable ; } // -- boolean be enable ( )
public static string to size string ( long i , int width ) { string result = `` `` + i ; int size = result . length ( ) ; if ( width > size ) { final string pad = `` `` ; final int pad length = pad . length ( ) ; if ( width > pad length ) { width = pad length ; } int topad = width - size ; result = pad . substring ( 0 , topad ) + result ; } return result ; }
public static string convert resource path to class name ( string resource path ) { assert . not null ( resource path , `` resource path must not be null `` ) ; return resource path . replace ( path_separator , package_separator ) ; }
public void set class loader ( class loader class loader ) { this . class loader = class loader ; }
public void resource unload ( creole event e ) { super . resource unload ( e ) ; if ( e . get resource ( ) == corpus ) { set corpus ( null ) ; } }
public file get dir ( ) { return dir ; }
public boolean contains key ( object key ) { purge ( ) ; entry entry = get entry ( key ) ; if ( entry == null ) return false ; return entry . get value ( ) ! = null ; }
public byte [ ] get code from unicode ( string unicode ) { return unicode to byte code . get ( unicode ) ; }
public version get version ( ) { return version ; }
public string to x m l ( final x stream xstream , final object obj ) throw object stream exception { final writer writer = new string writer ( ) ; try { to x m l ( xstream , obj , writer ) ; } catch ( final object stream exception e ) { throw e ; } catch ( final i o exception e ) { throw new stream exception ( `` unexpected io error from a string writer `` , e ) ; } return writer . to string ( ) ; }
public document get document ( ) { return document ; }
public list < doc > get doc ( ) { if ( doc == null ) { doc = new array list < doc > ( ) ; } return this . doc ; }
public static annotation set get coextensive annotation ( annotation set source , annotation coext ann , string type ) { return get coextensive annotation worker ( source , type , start ( coext ann ) , end ( coext ann ) ) ; }
public static annotation set get coextensive annotation ( annotation set source , annotation coext ann ) { return get coextensive annotation worker ( source , null , start ( coext ann ) , end ( coext ann ) ) ; }
public static plugin get plugin ( string id ) { return null ; }
protect boolean be section line ( string line ) { if ( line == null ) { return false ; } return line . start with ( `` [ `` ) & & line . end with ( `` ] `` ) ; }
public string get text ( ) { return text ; }
public for stmt set compare ( final expression compare ) { if ( compare == this . compare ) { return this ; } notify property change ( observable property . compare , this . compare , compare ) ; if ( this . compare ! = null ) this . compare . set parent node ( null ) ; this . compare = compare ; set a parent node of ( compare ) ; return this ; }
public static boolean be empty ( final char sequence c ) { return c == null || c . length ( ) == 0 ; }
public boolean be local pointer ( ) { boolean ret = delegate . be local pointer ( ) ; return ret ; }
public string get package ( ) { return package ; }
public static < t > constructor < t > get default constructor ( class < t > clazz ) throw property not find exception { if ( be abstract class ( clazz ) ) { return null ; } try { constructor < t > constructor = clazz . get declared constructor ( no_param_signature ) ; ensure accessibility ( constructor ) ; return constructor ; } catch ( no such method exception nme ) { throw new property not find exception ( `` object class [ `` + clazz . get name ( ) + `` ] must declare a default ( no-argument ) constructor `` ) ; } }
public static boolean contains ( class < ? > key ) { if ( ! image info . in image code ( ) ) { return false ; } return image singleton support . get ( ) . contains ( key ) ; }
public static void clear image ( buffer image image ) { clear image ( image , color . white ) ; }
public identity assurance process get assurance process ( ) { return assurance process ; }
public void set name ( string name ) { this . name = name ; }
public boolean get deprecation ( ) { return deprecation ; }
public void set language ( final string language ) { this . language = list . create ( language ) ; }
public static builder new builder ( string language , file file ) { return empty . new builder ( language , file ) ; }
public void check cancel ( ) { if ( this . monitor ! = null & & this . monitor . be cancel ( ) ) throw new operation cancel exception ( ) ; }
public string get id ( ) { return id ; }
public string lookup property string lookup ( ) { return property string lookup . instance ; }
public void set interactive mode ( boolean interactive mode ) { this . interactive mode = interactive mode ; } // -- void set interactive mode ( boolean )
public request option get option ( ) { return option ; }
public boolean be root ( ) { return root ; }
public void set implementation ( string impl ) { this . impl = impl ; }
public error get error ( ) { return this . error ; }
public void set implementation ( string impl ) { this . impl = impl ; }
public character a character ( ) { return ( character ) this ; }
public int get line number ( ) { return line number ; }
public list < language > get language for file ( path source file ) { return get language for file ( source file . get file name ( ) . to string ( ) ) ; }
public static url find ( url url ) { return find support . find ( url ) ; }
public int get line length ( int line number ) throw illegal argument exception { return get impl ( ) . get line length ( impl , line number ) ; }
public string get index end ( ) { return index end ; }
public element remove ( ) { for ( element element : this ) { element . remove ( ) ; } return this ; }
public void set underlying receiver ( receiver receiver ) { next receiver = receiver ; }
public serialization context get context ( ) { return context ; }
public void accept ( final command visitor < t > visitor ) { visitor . visit keep command ( get object ( ) ) ; }
public completable future < execution result > execute async ( execution input . builder execution input builder ) { return execute async ( execution input builder . build ( ) ) ; }
public field get field ( ) { return field ; }
public void set locale ( locale locale ) { super . set locale ( locale ) ; }
public completable future < execution result > execute async ( execution input . builder execution input builder ) { return execute async ( execution input builder . build ( ) ) ; }
public execution result execute ( execution input . builder execution input builder ) { return execute ( execution input builder . build ( ) ) ; }
public static builder builder ( ) { return new builder ( ) ; }
public list < node > get node ( ) { return node ; }
public date time parser get parser ( ) { return internal parser date time parser . of ( i parser ) ; }
public string get field name ( ) { return field name ; }
protect object default value ( field field ) throw i o exception { return data . deep copy ( field . schema ( ) , data . get default value ( field ) ) ; }
public graph q l input object type transform ( consumer < builder > builder consumer ) { builder builder = new input object ( this ) ; builder consumer . accept ( builder ) ; return builder . build ( ) ; }
public graph q l schema transform ( consumer < builder > builder consumer ) { builder builder = new schema ( this ) ; builder consumer . accept ( builder ) ; return builder . build ( ) ; }
public list < graph q l directive > get schema directive ( ) { return schema directive . get directive ( ) ; }
public list < graph q l directive > get directive ( string directive name ) { return directive . get directive ( directive name ) ; }
public graph q l input object type transform ( consumer < builder > builder consumer ) { builder builder = new input object ( this ) ; builder consumer . accept ( builder ) ; return builder . build ( ) ; }
public schema get schema ( ) { return schema ; }
public t get object ( ) { return this . object ; }
public final validation exception add validation error ( string error ) { validation error . add ( error ) ; return this ; }
public string get checksum policy ( ) { return this . checksum policy ; } // -- string get checksum policy ( )
public static void print ( object obj ) { if ( ! debug on ) return ; debug . instance print ( obj ) ; }
public string get read name ( ) { return read name ; }
public static void enable globally ( ) { default meta class info . set without custom metaclass creation handle ( false ) ; expando meta class creation handle . enable ( ) ; }
public string get method class name ( ) { return method class name ; }
public void set from ( integer from ) { this . from = from ; }
public object invoke constructor ( final object [ ] argument ) { return do call ( the class , `` ctor `` , argument , interceptor , ( ) - > adaptee . invoke constructor ( argument ) ) ; }
public object do method invoke ( object object , object [ ] argument array ) { argument array = coerce argument to class ( argument array ) ; try { return invoke ( object , argument array ) ; } catch ( exception e ) { throw process do method invoke exception ( e , object , argument array ) ; } }
public object get property value ( ) { return property value ; }
public final type get element type ( ) { return element type ; }
public static int compare ( long t1 , long t2 ) { return compare ( t1 , t2 , file_utils . get file timestamp granularity ( ) ) ; }
public part builder part ( string name , object part ) { return part ( name , part , null ) ; }
public string get local part ( ) { return local part ; }
public db exception add s q l ( string sql ) { s q l exception e = get s q l exception ( ) ; if ( e instanceof jdbc s q l exception ) { jdbc s q l exception j = ( jdbc s q l exception ) e ; if ( j . get s q l ( ) == null ) { j . set s q l ( sql ) ; } return this ; } e = new jdbc s q l exception ( e . get message ( ) , sql , e . get s q l state ( ) , e . get error code ( ) , e , null ) ; return new db exception ( e ) ; }
public static date plus ( date self , int day ) { calendar calendar = ( calendar ) calendar . get instance ( ) . clone ( ) ; calendar . set time ( self ) ; calendar . add ( calendar . day_of_year , day ) ; return calendar . get time ( ) ; }
public void set time zone ( time zone time zone ) { this . time zone = time zone ; }
public static rt parameter [ ] parameter of ( rt method method ) { rt parameter [ ] parameter = new rt parameter [ method . get parameter type ( ) . length ] ; for ( int index = 0 ; index < method . get parameter type ( ) . length ; index++ ) { parameter [ index ] = new rt parameter ( null , method . get parameter type ( ) [ index ] , method . get generic parameter type ( ) [ index ] , method , null , index ) ; } return parameter ; }
public void set charset ( string charset ) { this . charset = charset ; }
public void set method ( int method ) { this . method = method ; }
protect void set proxy builder ( factory builder support proxy builder ) { global proxy builder = proxy builder ; }
protected factory builder support get proxy builder ( ) { factory builder support proxy = local proxy builder . get ( ) ; if ( proxy == null ) { return global proxy builder ; } else { return proxy ; } }
public query builder post filter ( ) { return post query builder ; }
public static int sum ( int [ ] value ) { int sum = 0 ; for ( int value : value ) { sum += value ; } return sum ; }
public value node number node ( byte value ) { return ( value == null ) ? null node ( ) : int node . value of ( value . int value ( ) ) ; }
public void remove child ( ) { child . clear ( ) ; }
public configuration node get parent node ( ) { return parent ; }
protect big decimal from string ( string input ) { return new big decimal ( input ) ; }
public void add text ( string text ) { buffer . append ( text ) ; }
protect void index node ( node node ) { list < node > nod = node name to node . get ( node . get x path node name ( ) ) ; if ( node ! = null ) { node . add ( node ) ; } }
public static boolean be name ( int c ) { return c < 0x10000 & & ( char [ c ] & mask_name ) ! = 0 ; } // be name ( int ) : boolean
public synchronize long get max size ( ) { return max size ; }
public output < t > e ( ) { return e ; }
protect void set up ( ) throw exception { }
public synthetic object type get synthetic object ( ) { return synthetic object ; }
public static string method ( method method ) { if ( method == null ) return null_string ; return method . get name ( ) + pretty print parameter ( method . get parameter type ( ) ) ; }
public string get method class name ( ) { return method class name ; }
public option use ( use use ) { return using . and ( use ) ; }
public static boolean be double category ( class node type ) { return type==float_ t y p e || type== float_ t y p e || type==double_ t y p e || type== double_ t y p e || be big dec category ( type ) ; }
public static boolean be double category ( class node type ) { return type==float_ t y p e || type== float_ t y p e || type==double_ t y p e || type== double_ t y p e || be big dec category ( type ) ; }
public class node build map type ( class node key type , class node value type ) { return parameterized type ( class helper . map_type , key type , value type ) ; }
public void set variable ( list < variable initializer > variable ) { assert not null ( variable ) ; this . variable . clear ( ) ; for ( variable initializer vi : variable ) { add variable ( vi ) ; } }
public int child ( ) { int size = size ( ) ; if ( size > 1 ) { return size - 1 ; } return 0 ; }
public void set source name ( string source name ) { this . source name = source name ; }
public output < ? > output ( ) { return output ; }
public void fatal ( object message ) { category . log ( fqcn , priority . fatal , message , null ) ; }
public boolean be specifically whitelisted and not blacklist ( final string str ) { return ! whitelist be empty ( ) & & be whitelisted and not blacklist ( str ) ; }
public void set underlying receiver ( receiver receiver ) { next receiver = receiver ; }
public int get error ( ) { return error ; }
public void write to ( writer writer ) throw i o exception { write to ( writer , writer config . minimal ) ; }
public void set configuration ( configuration configuration ) { this . configuration = configuration ; }
public int get level ( ) { return level ; }
public boolean be env entry type ( class < ? > clazz ) { return env_entry_types . contains ( clazz ) ; }
public static boolean z array get ( boolean [ ] a , int i ) { try { return a [ i ] ; } catch ( throwable t ) { return a [ default groovy method support . normalise index ( i , a . length ) ] ; } }
public static char c array get ( char [ ] a , int i ) { try { return a [ i ] ; } catch ( throwable t ) { return a [ default groovy method support . normalise index ( i , a . length ) ] ; } }
public static boolean z array get ( boolean [ ] a , int i ) { try { return a [ i ] ; } catch ( throwable t ) { return a [ default groovy method support . normalise index ( i , a . length ) ] ; } }
public < t > t plugin proxy ( class loader class loader , final class < t > type ) { object proxy = proxy . new proxy instance ( class loader , new class < ? > [ ] { type } , new invocation handler ( ) { @ override public object invoke ( object target , method method , object [ ] args ) throw throwable { for ( object plugin : get plugins ( ) ) { if ( type . be instance ( plugin ) ) { utils . invoke ( plugin , method , 0 , args ) ; } } return null ; } } ) ; return type . cast ( proxy ) ; }
public string to string ( ) { return super . to string ( ) + `` [ `` + delegate . to string ( ) + `` ] `` ; }
public static int millisecond of ( date date ) { return to calendar ( date ) . get ( calendar . millisecond ) ; }
public object do method invoke ( object object , object [ ] argument array ) { argument array = coerce argument to class ( argument array ) ; try { return invoke ( object , argument array ) ; } catch ( exception e ) { throw process do method invoke exception ( e , object , argument array ) ; } }
public static long calculate checksum ( input stream stream ) throw i o exception { checksum sum = new crc32 ( ) ; byte [ ] buf = new byte [ 4096 ] ; int count ; while ( ( count = stream . read ( buf ) ) ! = -1 ) { if ( count > 0 ) { sum . update ( buf , 0 , count ) ; } } return sum . get value ( ) ; }
public output stream get output stream ( ) { return output stream ; }
public byte [ ] get ( ) { if ( bytes == null ) { byte = new byte [ 0 ] ; } return byte ; }
public boolean have next ( ) { return next index ( ) > = 0 ; }
public string get reader ( ) { return reader ; }
public static < t > set < t > each with index ( set < t > self , @ closure params ( value= from string . class , options= `` t , integer `` ) closure closure ) { return ( set < t > ) each with index ( ( iterable < t > ) self , closure ) ; }
public synchronize object get ( object key ) { if ( ! contains key ( key ) ) { return null ; } object value = remove ( key ) ; super . put ( key , value ) ; return value ; }
public table get table ( ) { return table ; }
public boolean contains ( double x , double y ) { if ( component2 d . contains point ( x , y , min x , max x , min y , max y ) & & tree . contains ( x , y ) ) { return hole == null || hole . contains ( x , y ) == false ; } return false ; }
public list < entry > get entry ( ) { return entry ; }
public static void set orig long ( boolean v ) { orig long = v ; orig long re = without custom handle & & orig long ; }
public static void set orig byte ( boolean v ) { orig byte = v ; orig byte re = without custom handle & & orig byte ; }
public static void set orig long ( boolean v ) { orig long = v ; orig long re = without custom handle & & orig long ; }
public static void enable globally ( ) { default meta class info . set without custom metaclass creation handle ( false ) ; expando meta class creation handle . enable ( ) ; }
public class < ? > define ( class loader loader , protection domain domain ) { return define internal ( loader , domain ) ; }
public string to string ( ) { final string buffer sb = new string buffer ( ) ; for ( int i = 0 ; i < component . length ; i++ ) { if ( i ! = 0 ) { sb . append ( ' . ' ) ; } sb . append ( component [ i ] ) ; } return sb . to string ( ) ; }
public static int read ( final file file , final byte [ ] array ) throw i o exception { try ( file input stream input stream = new file input stream ( file ) ) { return read fully ( input stream , array , 0 , array . length ) ; } }
public static buffer reader new reader ( file file , charset charset ) throw file not find exception { check not null ( file ) ; check not null ( charset ) ; return new buffer reader ( new input stream reader ( new file input stream ( file ) , charset ) ) ; }
public void set file ( file file ) { this . file = file ; }
public static output stream new output stream ( string file name , boolean append ) throw i o exception { return file path . get ( file name ) . new output stream ( append ) ; }
public static void each byte ( url url , int buffer len , @ closure params ( value = from string . class , option = `` byte [ ] , integer `` ) closure closure ) throw i o exception { input stream be = url . open connection ( ) . get input stream ( ) ; i o groovy method . each byte ( be , buffer len , closure ) ; }
public static void each byte ( file self , @ closure params ( value = simple type . class , option = `` byte `` ) closure closure ) throw i o exception { buffered input stream be = new input stream ( self ) ; i o groovy method . each byte ( be , closure ) ; }
protect socket get socket ( ) { return this . socket ; }
public char array buffer append ( char c ) { append ( new char [ ] { c } , 0 , 1 ) ; return this ; }
public int size ( ) { return size ; }
public byte [ ] element ( ) { return element ; }
public static void main ( string [ ] args ) throw exception { }
public boolean get delete ( ) { return this . delete ; }
public void copy node meta data ( a s t node other ) { meta data map . put all ( other . meta data map ) ; }
public list < binary expression > get enclose binary expression stack ( ) { return collection . unmodifiable list ( enclose binary expression ) ; }
public void push enclose binary expression ( binary expression binary expression ) { enclose binary expression . add first ( binary expression ) ; }
public list < switch statement > get enclose switch statement ( ) { return collection . unmodifiable list ( switch statement ) ; }
public switch statement get enclose switch statement ( ) { if ( switch statement . be empty ( ) ) return null ; return switch statement . get first ( ) ; }
public list < class node > get enclose class node ( ) { return collection . unmodifiable list ( enclose class node ) ; }
public class node pop enclose class node ( ) { return enclose class node . remove first ( ) ; }
public enclose method info enclose method ( ) { return nest info ! = null ? nest info . enclose method : null ; }
public list < node > get node ( ) { return node ; }
public void set redirect ( class node cn ) { if ( be primary node ) throw new groovy bug error ( `` try to set a redirect for a primary class node ( `` +get name ( ) + `` - > `` +cn . get name ( ) + `` ) . `` ) ; if ( cn ! =null ) cn = cn . redirect ( ) ; if ( cn==this ) return ; redirect = cn ; }
public class get type ( ) { return ( this . type ) ; }
public static class get class ( string class name ) throw class not find exception { return get class ( class name , true ) ; }
protect method [ ] get method ( class < ? > type ) { return type . get method ( ) ; }
public boolean be optional ( ) { return this . optional ; }
public static < t > t max ( iterable < t > self ) { return groovy collection . max ( self ) ; }
public string get u r i ( ) { return uri ; }
public static boolean end with whitespace ( final char sequence char seq ) { if ( char seq . length ( ) == 0 ) { return false ; } return character . be whitespace ( char seq . char at ( char seq . length ( ) - 1 ) ) ; }
public static string format date time ( java . util . date date , string format , string locale , string time zone ) { simple date format date format = get date format ( format , locale , time zone ) ; synchronize ( date format ) { return date format . format ( date ) ; } }
public type argument < t > set converter ( converter < t > converter ) { this . converter = converter ; return this ; }
public static boolean be simple value type ( class < ? > type ) { return ( void . class ! = type & & void . class ! = type & & ( class utils . be primitive or wrapper ( type ) || enum . class . be assignable from ( type ) || char sequence . class . be assignable from ( type ) || number . class . be assignable from ( type ) || date . class . be assignable from ( type ) || temporal . class . be assignable from ( type ) || uri . class == type || url . class == type || locale . class == type || class . class == type ) ) ; }
public content get content ( ) { return this . content ; }
public final object get ( object key ) { object object = null ; / * if the map be null , then we create it . * / if ( map == null ) { build map ( ) ; } object = map . get ( key ) ; lazy chop if need ( object ) ; return object ; }
public final t get object ( ) { return object ; }
public boolean get delegate ( ) { return this . delegate ; }
public boolean be boolean ( ) { return false ; }
public hierarchical stream writer create writer ( writer out ) { return new json writer ( out ) ; }
public void set child ( hash set < string > child ) { this . child = child ; }
public iterator < node > get precede sibling axis iterator ( object context node ) { return new node iterator ( ( node ) context node ) { @ override protect node get first node ( node node ) { return get next node ( node ) ; } @ override protect node get next node ( node node ) { return get previous sibling ( node ) ; } } ; }
public static synchronize void set global keep ignorable whitespace ( boolean keep ignorable whitespace ) { d o m category . keep ignorable whitespace = keep ignorable whitespace ; }
public boolean be keep ignorable whitespace ( ) { return keep ignorable whitespace ; }
public string get reader ( ) { return reader ; }
public format set omit declaration ( boolean omit declaration ) { this . omit declaration = omit declaration ; return this ; }
protect q name create q name ( string local name , string qualify name , namespace namespace ) { return document factory . create q name ( local name , namespace ) ; }
public x s schema set get result ( ) throw s a x exception { return context . get result ( ) ; }
public void set src ( final file src file ) { this . src file = src file ; }
public executable get executable ( ) { return executable ; }
public reflection to string builder set exclude field name ( string [ ] exclude field name param ) { if ( exclude field name param == null ) { this . exclude field name = null ; } else { this . exclude field name = to no null string array ( exclude field name param ) ; array . sort ( this . exclude field name ) ; } return this ; }
public statement set retry policy ( retry policy policy ) { this . retry policy = policy ; return this ; }
public json config number return type ( json path config . number return type number return type ) { return new json config ( number return type , true ) ; }
public void add configure element ( template element element ) { if ( element . get name ( ) == null ) { throw new build exception ( `` the element nest element need a \ `` name\ `` attribute `` ) ; } if ( element . get ( element . get name ( ) ) ! = null ) { throw new build exception ( `` the element `` + element . get name ( ) + `` have already be specify `` ) ; } if ( have implicit element || ( element . be implicit ( ) & & element . size ( ) ! = 0 ) ) { throw new build exception ( `` only one element allow when use implicit element `` ) ; } have implicit element = element . be implicit ( ) ; element . put ( element . get name ( ) , element ) ; }
protect unsupported operation exception create unsupported operation exception ( string name ) { return new unsupported operation exception ( name + `` be not implement by `` + this . get class ( ) . get name ( ) ) ; }
public json object merge ( json object object ) { if ( object == null ) { throw new null pointer exception ( `` object be null `` ) ; } for ( member member : object ) { this . set ( member . name , member . value ) ; } return this ; }
public void set class ( string cl ) { this . cl = cl ; }
public boolean be empty ( ) { return empty ; }
public static boolean equal ( object a , object b ) { return a == b || ( a ! = null & & a . equal ( b ) ) ; }
public string to string ( ) { return set . to string ( ) ; }
public class get type ( ) { return ( this . type ) ; }
public immutable sort set < k > key set ( ) { return key set ; }
public set < k > key set ( ) { return new key set ( ) ; }
public static < e > immutable sort set < e > copy of ( e [ ] element ) { throw new unsupported operation exception ( ) ; }
public static < e > immutable sort set < e > copy of ( e [ ] element ) { throw new unsupported operation exception ( ) ; }
public static < e > immutable sort set < e > of ( ) { return ( immutable sort set < e > ) natural_empty_set ; }
public static int size ( object list ) { if ( list == null ) return 0 ; if ( list instanceof list ) return ( ( list < ? > ) list ) . size ( ) ; return 1 ; }
public e peek last ( ) { return be empty ( ) ? null : element data ( get max element index ( ) ) ; }
public e remove last ( ) { if ( be empty ( ) ) { throw new no such element exception ( ) ; } return remove and get ( get max element index ( ) ) ; }
public void set order ( array list < select order by > order ) { order list = order ; }
public static < e > predicate queue < e > predicate queue ( final queue < e > queue , final predicate < ? super e > predicate ) { return new predicate queue < > ( queue , predicate ) ; }
public comparator comparator ( ) { return comparator ; }
public static boolean be bit ( string string , int index ) { if ( string == null ) { return false ; } int length = string . length ( ) ; if ( ( length == 0 ) || ( index < 0 ) || ( index > = length ) ) { return false ; } else { char c = string . char at ( index ) ; return ( ( c == ' 0 ' ) || ( c == ' 1 ' ) ) ; } }
public boolean run ( char [ ] s , int offset , int length ) { int p = initial ; int l = offset + length ; for ( int i = offset , cp = 0 ; i < l ; i += character . char count ( cp ) ) { p = step ( p , cp = character . code point at ( s , i , l ) ) ; if ( p == -1 ) return false ; } return accept [ p ] ; }
public static boolean be empty ( final char sequence c ) { return c == null || c . length ( ) == 0 ; }
public source get source ( ) { return source ; }
public byte string md5 ( ) { return digest ( `` md5 `` ) ; }
public int hash code ( ) { return name . hash code ( ) ; } // hash code
public int read unsigned byte ( ) throw i o exception { int b = read ( ) ; if ( b < 0 ) { throw new e o f exception ( ) ; } return b ; }
public string get encode ( ) { return encode ; }
public long get total ( ) { return this . total ; }
public void read stream ( input stream stream , string encode ) throw i o exception { buffered reader reader = new buffer reader ( new input stream reader ( stream , encode ) ) ; string line = this . parser . read next entry ( reader ) ; while ( line ! = null ) { this . line . add ( line ) ; line = this . parser . read next entry ( reader ) ; } reader . close ( ) ; }
public static void append ( file file , reader reader , string charset ) throw i o exception { append ( file , reader , charset , false ) ; }
public memory usage setting set temp dir ( file temp dir ) { this . temp dir = temp dir ; return this ; }
public url get url ( ) { return this . url ; }
public synchronize int get port ( ) { if ( this . host ! = null ) { return this . host . get port ( ) ; } else { return -1 ; } }
public static string get host name ( string local address ) { try { inet address addr = inet address . get by name ( local address ) ; return addr . get host name ( ) ; } catch ( exception e ) { return `` unknown `` ; } }
public part builder part ( string name , object part ) { return part ( name , part , null ) ; }
public string get domain ( ) { return domain ; }
public static boolean be available ( final string name ) { try { mac . get instance ( name ) ; return true ; } catch ( final no such algorithm exception e ) { return false ; } }
public string get class name ( ) { return get class info ( this class info ) ; }
public void set type ( string type ) { this . type = type ; }
public static double get double ( byte [ ] data ) { return double . long bit to double ( get long ( data , 0 ) ) ; }
public void wait for uninterruptibly ( guard guard ) { if ( ! ( ( guard . monitor == this ) & lock . be hold by current thread ( ) ) ) { throw new illegal monitor state exception ( ) ; } if ( ! guard . be satisfied ( ) ) { await uninterruptibly ( guard , true ) ; } }
public boolean enter if interruptibly ( guard guard ) throw interrupted exception { if ( guard . monitor ! = this ) { throw new illegal monitor state exception ( ) ; } final reentrant lock lock = this . lock ; lock . lock interruptibly ( ) ; boolean satisfy = false ; try { return satisfied = guard . be satisfied ( ) ; } finally { if ( ! satisfy ) { lock . unlock ( ) ; } } }
public static < t > fluent iterable < t > of ( final iterable < t > iterable ) { iterable utils . check not null ( iterable ) ; if ( iterable instanceof fluent iterable < ? > ) { return ( fluent iterable < t > ) iterable ; } return new fluent iterable < > ( iterable ) ; }
public boolean be compatible ( bloom filter < t > that ) { check not null ( that ) ; return ( this ! = that ) & & ( this . num hash function == that . num hash function ) & & ( this . bit size ( ) == that . bit size ( ) ) & & ( this . strategy . equal ( that . strategy ) ) & & ( this . funnel . equal ( that . funnel ) ) ; }
public byte string hmac sha512 ( byte string key ) { return hmac ( `` hmac s h a512 `` , key ) ; }
public string get encode ( ) { return encode ; }
public long get total ( ) { return this . total ; }
public void write ( byte [ ] buffer ) { output buffer . write ( buffer , 0 , buffer . length ) ; }
public static scale percentile ( ) { return scale ( 100 ) ; }
public void set scale ( double s ) { set scale internal ( s ) ; }
public static < t > fluent iterable < t > of ( final iterable < t > iterable ) { iterable utils . check not null ( iterable ) ; if ( iterable instanceof fluent iterable < ? > ) { return ( fluent iterable < t > ) iterable ; } return new fluent iterable < > ( iterable ) ; }
public boolean be compatible ( bloom filter < t > that ) { check not null ( that ) ; return ( this ! = that ) & & ( this . num hash function == that . num hash function ) & & ( this . bit size ( ) == that . bit size ( ) ) & & ( this . strategy . equal ( that . strategy ) ) & & ( this . funnel . equal ( that . funnel ) ) ; }
public boolean be compatible ( bloom filter < t > that ) { check not null ( that ) ; return ( this ! = that ) & & ( this . num hash function == that . num hash function ) & & ( this . bit size ( ) == that . bit size ( ) ) & & ( this . strategy . equal ( that . strategy ) ) & & ( this . funnel . equal ( that . funnel ) ) ; }
public boolean have parameter ( ) { return ! parameter . be empty ( ) ; }
public string get index end ( ) { return index end ; }
public static completable from future ( future < ? > future ) { require non null ( future ) ; return from observable ( observable . from ( future ) ) ; }
public expression get sort key ( ) { return sort key ; }
public static < t > fluent iterable < t > of ( final iterable < t > iterable ) { iterable utils . check not null ( iterable ) ; if ( iterable instanceof fluent iterable < ? > ) { return ( fluent iterable < t > ) iterable ; } return new fluent iterable < > ( iterable ) ; }
public iterator < ? extend e > get iterator ( ) { return iterator ; }
public iterator iterator ( ) { return new iterator ( ) ; }
public collection < v > value ( ) { return new value view ( ) ; }
public immutable list < e > get entry ( ) { return new immutable list . builder < e > ( ) . add all ( reference map . key set ( ) ) . build ( ) ; }
public byte to byte ( ) { return new byte ( byte value ( ) ) ; }
public object [ ] to array ( object array [ ] ) { if ( fast ) { return ( list . to array ( array ) ) ; } else { synchronize ( list ) { return ( list . to array ( array ) ) ; } } }
public boolean partial ( ) { return partial ; }
public source get source ( ) { return source ; }
public set < field > get field annotate with ( final annotation annotation ) { return get all ( get field annotate with ( annotation . annotation type ( ) ) , with annotation ( annotation ) ) ; }
public matcher < ? super type literal < ? > > get type matcher ( ) { return type matcher ; }
public binding bind ( bind binding ) { internal binding . add ( bind ) ; return binding ; }
public double [ ] get point ( ) { return point ; }
public static annotation [ ] get resource annotation ( method method ) { map < class < ? > , annotation > annotation = new hash map < class < ? > , annotation > ( ) ; for ( annotation annotation : method . get declare class ( ) . get annotation ( ) ) { annotation . put ( annotation . get class ( ) , annotation ) ; } for ( annotation annotation : method . get annotation ( ) ) { annotation . put ( annotation . get class ( ) , annotation ) ; } return annotation . value ( ) . to array ( new annotation [ annotation . size ( ) ] ) ; }
public object get instance ( ) { return instance ; }
public static matcher < method > return ( final matcher < ? super class < ? > > return type ) { return new return ( return type ) ; }
public void set module ( final list < module > module ) { this . module = module ; }
public table get table ( ) { return table ; }
public string get query ( ) { return query ; }
public ref exact ref ( string name ) throw i o exception { ref ref = get ref ( name ) ; if ( ref == null || ! name . equal ( ref . get name ( ) ) ) { return null ; } return ref ; }
public void set method ( int method ) { this . method = method ; }
public hash set < db table or view > get table ( ) { return table ; }
public void insert row ( value [ ] row ) throw s q l exception { statement builder buff = new statement builder ( `` insert into `` ) ; append table name ( buff ) ; buff . append ( ' ( ' ) ; append column list ( buff , false ) ; buff . append ( `` ) value ( `` ) ; buff . reset count ( ) ; for ( int i = 0 ; i < column count ; i++ ) { buff . append except first ( `` , `` ) ; value v = row [ i ] ; if ( v == null ) { buff . append ( `` default `` ) ; } else { buff . append ( ' ? ' ) ; } } buff . append ( ' ) ' ) ; prepare statement prep = conn . prepare statement ( buff . to string ( ) ) ; for ( int i = 0 , j = 0 ; i < column count ; i++ ) { value v = row [ i ] ; if ( v ! = null ) { v . set ( prep , j++ + 1 ) ; } } int count = prep . execute update ( ) ; if ( count ! = 1 ) { throw db exception . get ( error code . no_data_available ) ; } }
public string get script ( ) { return script ; }
public string get action ( ) { return action ; }
public index [ ] index ( ) { return index ; }
public string get server ( ) { return server ; }
public long count ( ) { return count . get ( ) ; }
public void set auto commit on return ( final boolean auto commit on return ) { this . auto commit on return = auto commit on return ; }
public boolean be remove ( ) { return remove ; }
public void set trace ( boolean trace ) { this . trace = trace ; }
public void set key ( boolean value ) { this . key = value ; }
public boolean be boolean ( ) { return false ; }
public static object alias ( object column , string alias ) { return new utils . alias ( column , alias ) ; }
public stream priority set dependency ( int dependency ) { this . dependency = dependency ; return this ; }
public object id id for ( int type , byte [ ] data ) { return id for ( type , data , 0 , data . length ) ; }
public string get table ( ) { return table ; }
public index [ ] index ( ) { return index ; }
public boolean be persistent type ( string type ) { return cache . be persistent ( type ) ; }
public long array allocate array ( long size ) { long require = size * 8l ; memory block page = task memory manager . allocate page ( require , this ) ; if ( page == null || page . size ( ) < require ) { long get = 0 ; if ( page ! = null ) { get = page . size ( ) ; task memory manager . free page ( page , this ) ; } task memory manager . show memory usage ( ) ; throw new out of memory error ( `` unable to acquire `` + required + `` byte of memory , get `` + get ) ; } use += require ; return new long array ( page ) ; }
public output stream set ascii stream ( long po ) throw s q l exception { throw unsupported ( `` lob update `` ) ; }
public time get time ( int parameter index ) throw s q l exception { check register ( parameter index ) ; return get open result set ( ) . get time ( parameter index ) ; }
public byte get byte ( int parameter index ) throw s q l exception { check register ( parameter index ) ; return get open result set ( ) . get byte ( parameter index ) ; }
public byte get byte ( int parameter index ) throw s q l exception { check register ( parameter index ) ; return get open result set ( ) . get byte ( parameter index ) ; }
public final long row count ( ) { return row ; }
public db exception add s q l ( string sql ) { s q l exception e = get s q l exception ( ) ; if ( e instanceof jdbc s q l exception ) { jdbc s q l exception j = ( jdbc s q l exception ) e ; if ( j . get s q l ( ) == null ) { j . set s q l ( sql ) ; } return this ; } e = new jdbc s q l exception ( e . get message ( ) , sql , e . get s q l state ( ) , e . get error code ( ) , e , null ) ; return new db exception ( e ) ; }
public void set object ( string parameter name , object x ) throw s q l exception { set object ( get index for name ( parameter name ) , x ) ; }
public object get parameter ( string name ) { return parameter . get ( name ) ; }
public input stream get binary stream ( long po , long length ) throw s q l exception { throw unsupported ( `` lob update `` ) ; }
public output stream set ascii stream ( long po ) throw s q l exception { throw unsupported ( `` lob update `` ) ; }
public int get max procedure name length ( ) { debug code call ( `` get max procedure name length `` ) ; return 0 ; }
public int get type ( ) { return type ; }
public string get table name ( ) { return this . table name ; }
public boolean be current group ( ) { return current group by expr data ! = null ; }
public string outer class string ( ) { return cache outer class string ; }
public catalog get catalog ( ) { return catalog resolver . get catalog ( ) ; }
protect void set support schemas in procedure call ( boolean support schema in procedure call ) { this . support schema in procedure call = support schema in procedure call ; }
public int get position ( ) { return position ; }
public final void commit ( ) throw i o exception { ensure open ( ) ; commit internal ( ) ; }
public integer get max row ( ) { return max row ; }
public int get max procedure name length ( ) { debug code call ( `` get max procedure name length `` ) ; return 0 ; }
public void set procedure name ( string value ) { this . procedure name = value ; }
public void set stack trace pattern ( string stack trace pattern ) { this . stack trace pattern = stack trace pattern ; }
public hierarchical stream writer create writer ( writer out ) { return new json writer ( out ) ; }
public void set user ( string user ) { debug code call ( `` set user `` , user ) ; this . user name = user ; }
public string get user ( ) { debug code call ( `` get user `` ) ; return user name ; }
public void start ( xid xid , int flag ) throw x a exception { if ( be debug enabled ( ) ) { debug code ( `` start ( `` + jdbc xid . to string ( xid ) + `` , `` +quote flag ( flag ) + `` ) ; `` ) ; } if ( flags == tmresume ) { return ; } if ( flags == tmjoin ) { if ( current transaction ! = null & & ! current transaction . equal ( xid ) ) { throw new x a exception ( x a exception . xaer_rmerr ) ; } } else if ( current transaction ! = null ) { throw new x a exception ( x a exception . xaer_nota ) ; } try { physical conn . set auto commit ( false ) ; } catch ( s q l exception e ) { throw convert exception ( e ) ; } current transaction = xid ; prepare = false ; }
public void rollback ( xid xid ) throw x a exception { if ( be debug enabled ( ) ) { debug code ( `` rollback ( `` + jdbc xid . to string ( xid ) + `` ) ; `` ) ; } try { physical conn . rollback ( ) ; physical conn . set auto commit ( true ) ; if ( prepared ) { statement stat = null ; try { stat = physical conn . create statement ( ) ; stat . execute ( `` rollback transaction `` + jdbc xid . to string ( xid ) ) ; } finally { jdbc utils . close silently ( stat ) ; } prepare = false ; } } catch ( s q l exception e ) { throw convert exception ( e ) ; } current transaction = null ; }
public string to s q l ( ) { return sql ; }
public string get value ( ) { return value ; }
public int get level ( ) { return level ; }
public web security debug ( boolean debug enable ) { this . debug enable = debug enable ; return this ; }
public void set trace ( boolean trace ) { this . trace = trace ; }
public void set id type ( string value ) { this . id type = value ; }
static public byte [ ] string to byte ( string hex encode ) { return decode ( hex encode . get byte ( ) ) ; }
public db exception add s q l ( string sql ) { s q l exception e = get s q l exception ( ) ; if ( e instanceof jdbc s q l exception ) { jdbc s q l exception j = ( jdbc s q l exception ) e ; if ( j . get s q l ( ) == null ) { j . set s q l ( sql ) ; } return this ; } e = new jdbc s q l exception ( e . get message ( ) , sql , e . get s q l state ( ) , e . get error code ( ) , e , null ) ; return new db exception ( e ) ; }
public void set maxmemory ( string max ) { max memory = max ; }
public set < string > get name ( ) { return new hash set < string > ( this . parameter . key set ( ) ) ; }
public static void write long ( byte [ ] buff , int po , long x ) { write int ( buff , po , ( int ) ( x > > 32 ) ) ; write int ( buff , po + 4 , ( int ) x ) ; }
public long get unsigned int ( int po ) { long ret = delegate . get unsigned int ( po ) ; return ret ; }
public evaluation get last descendant ( ) { if ( last child ! = null ) { return last child . get last descendant ( ) ; } return this ; }
public k previous key ( final k key ) { check key ( key ) ; final node < k , v > node = next small ( lookup key ( key ) , key ) ; return node == null ? null : node . get key ( ) ; }
protect void before write ( ) { if ( read only ) { check open ( ) ; throw data utils . new unsupported operation exception ( `` this map be read-only `` ) ; } check concurrent write ( ) ; store . before write ( ) ; write = true ; }
public string get store name ( ) { return store name ; }
public boolean be read only ( ) { return this . read only ; }
public string get store name ( ) { return store name ; }
public void set page size ( int page size ) { if ( page size ! = this . page size ) { this . page size = page size ; if ( ! this . new page set ) { this . page = 0 ; } } }
public int get version ( ) { return version ; }
public class < v > value type ( ) { return value type ; }
public int get dimension ( ) { return dim ; }
public random access file get random access file ( ) { return random access file ; }
public boolean be updatable ( ) { return updatable ; }
protect static string get s q l ( value [ ] value ) { statement builder buff = new statement builder ( ) ; for ( value v : value ) { buff . append except first ( `` , `` ) ; if ( v ! = null ) { buff . append ( v . get s q l ( ) ) ; } } return buff . to string ( ) ; }
public boolean be map ( object obj ) { return ( obj instanceof map ) ; }
public index [ ] index ( ) { return index ; }
public void set trigger class name ( string trigger class name , boolean force ) { this . trigger class name = trigger class name ; try { load ( ) ; } catch ( db exception e ) { if ( ! force ) { throw e ; } } }
public index [ ] index ( ) { return index ; }
public final void remove sequence ( sequence sequence ) { remove ( sequence , sequence ) ; }
public synchronize void set object ( final map map ) { if ( map == null ) { throw new illegal argument exception ( `` map of handler may not be null `` ) ; } this . map . clear ( ) ; this . map . put all ( map ) ; }
public trigger object find trigger ( string name ) { return trigger . get ( name ) ; }
public trigger object find trigger ( string name ) { return trigger . get ( name ) ; }
public static byte [ ] get hash ( byte [ ] data , boolean null data ) { int len = data . length ; int int len = get int count ( len ) ; byte [ ] byte buff = new byte [ int len * 4 ] ; int [ ] int buff = new int [ int len ] ; sha256 sha = new sha256 ( ) ; sha . calculate hash ( data , len , byte buff , int buff ) ; if ( null data ) { sha . fill with null ( ) ; array . fill ( int buff , 0 ) ; array . fill ( byte buff , ( byte ) 0 ) ; array . fill ( data , ( byte ) 0 ) ; } return sha . result ; }
public static byte [ ] get h m a c ( byte [ ] key , byte [ ] message ) { key = normalize key for h m a c ( key ) ; int len = message . length ; int byte len = 64 + math . max ( 32 , len ) ; int int len = get int count ( byte len ) ; byte [ ] byte buff = new byte [ int len * 4 ] ; int [ ] int buff = new int [ int len ] ; sha256 sha = new sha256 ( ) ; byte [ ] i key = new byte [ 64 + len ] ; byte [ ] o key = new byte [ 64 + 32 ] ; sha . calculate h m a c ( key , message , len , i key , o key , byte buff , int buff ) ; return sha . result ; }
public void shutdown ( ) { }
public long ticket key new ( ) { lock reader lock = context . ctx lock . read lock ( ) ; reader lock . lock ( ) ; try { return s s l context . session ticket key new ( context . ctx ) ; } finally { reader lock . unlock ( ) ; } }
public file get dir ( ) { return dir ; }
public io . vertx . reactivex . circuitbreaker . circuit breaker open handler ( handler < void > handler ) { delegate . open handler ( handler ) ; return this ; }
public boolean delete ( ) { return new file ( uri ) . delete ( ) ; }
public void sync ( ) { try { file . force ( true ) ; } catch ( i o exception e ) { throw data utils . new illegal state exception ( data utils . error_writing_failed , `` could not sync file { 0 } `` , file name , e ) ; } }
public void set provider ( string provider ) { this . provider = provider ; }
public long last modified ( ) throw i o exception { long last modify = get file for last modified check ( ) . last modified ( ) ; if ( last modify == 0l ) { throw new file not find exception ( get description ( ) + `` can not be resolve in the file system for resolve it last-modified timestamp `` ) ; } return last modify ; }
public static object output stream new object output stream ( output stream output stream ) throw i o exception { return new object output stream ( output stream ) ; }
public static void copy file ( file in , file out ) throw i o exception { try ( file input stream fis = new file input stream ( in ) ; file output stream fo = new file output stream ( out ) ; file channel source channel = fis . get channel ( ) ; file channel destination channel = fo . get channel ( ) ) { source channel . transfer to ( 0 , source channel . size ( ) , destination channel ) ; source channel . close ( ) ; } }
public final property tester descriptor internal create descriptor ( ) { return new property tester descriptor ( f config element , f namespace , f property ) ; }
public sequence get sequence ( string sequence name ) { sequence sequence = sequence . get ( sequence name ) ; if ( sequence == null ) { throw db exception . get ( error code . sequence_not_found_1 , sequence name ) ; } return sequence ; }
public void set view ( view view ) { this . view = view ; }
public trigger object find trigger ( string name ) { return trigger . get ( name ) ; }
public final long row count ( ) { return row ; }
public static argument check check ( check check ) { return new argument check ( check ) ; }
public vector aggregate row ( vector function f ) { vector r = new dense vector ( num row ( ) ) ; int n = num row ( ) ; for ( int row = 0 ; row < n ; row++ ) { r . set ( row , f . apply ( view row ( row ) ) ) ; } return r ; }
public void set table ( table table , int column id ) { this . table = table ; this . column id = column id ; }
public boolean be null ( ) { return be null ; }
public db exception add s q l ( string sql ) { s q l exception e = get s q l exception ( ) ; if ( e instanceof jdbc s q l exception ) { jdbc s q l exception j = ( jdbc s q l exception ) e ; if ( j . get s q l ( ) == null ) { j . set s q l ( sql ) ; } return this ; } e = new jdbc s q l exception ( e . get message ( ) , sql , e . get s q l state ( ) , e . get error code ( ) , e , null ) ; return new db exception ( e ) ; }
public void set field separator ( string field separator ) { super . set field separator ( field separator ) ; }
public string get field separator write ( ) { return field separator write ; }
public char get delimiter ( ) { return delimiter ; }
public void set line separator ( string line separator ) { this . line separator = line separator ; }
public final column definition column ( ) { return column ; }
public long interleave ( int . . . value ) { int dimension = value . length ; long max = get max value ( dimension ) ; int bit per value = get bit per value ( dimension ) ; long x = 0 ; for ( int i = 0 ; i < dimension ; i++ ) { long k = value [ i ] ; if ( k < 0 || k > max ) { throw new illegal argument exception ( 0 + `` < `` + k + `` < `` + max ) ; } for ( int b = 0 ; b < bit per value ; b++ ) { x |= ( k & ( 1l < < b ) ) < < ( i + ( dimension - 1 ) * b ) ; } } return x ; }
public boolean be parallel ( final double other x , final double other y , final double other z ) { final double this x = y * other z - z * other y ; final double this y = z * other x - x * other z ; final double this z = x * other y - y * other x ; return this x * this x + this y * this y + this z * this z < minimum_resolution_squared ; }
public string get server ( ) { return server ; }
public static server create tcp server ( string . . . args ) throw s q l exception { tcp server service = new tcp server ( ) ; server server = new server ( service , args ) ; service . set shutdown handler ( server ) ; return server ; }
public static void execute ( string zip file name , string directory , string db , boolean quiet ) throw s q l exception { try { new backup ( ) . process ( zip file name , directory , db , quiet ) ; } catch ( exception e ) { throw db exception . to s q l exception ( e ) ; } }
public void set addr type ( host addr type addr type ) { this . addr type = addr type ; }
public string get a text ( ) { date value = ( date ) get value ( ) ; return ( value ! = null ? this . date format . format ( value ) : `` `` ) ; }
public calendar get calendar ( ) { return calendar ; }
public static calendar to calendar ( date date ) { if ( date == null ) { return null ; } calendar calendar = calendar . get instance ( ) ; calendar . set time ( date ) ; return calendar ; }
public static string get date time string ( date self ) { return date format . get date time instance ( date format . short , date format . medium ) . format ( self ) ; }
public static date time formatter date ( ) { return year month day ( ) ; }
public int block size ( ) throw i o exception { if ( block size == -1 ) { read file header ( ) ; } return block size ; }
public void set secure random algorithm ( string secure random algorithm ) { this . secure random algorithm = secure random algorithm ; }
public static < t > value hash map < t > new instance ( ) { return new value hash map < t > ( ) ; }
public boolean contains ( int value ) { for ( int i = 0 ; i < count ; i++ ) if ( entry [ i ] == value ) return true ; return false ; }
public block [ ] basic block ( ) { return basic block ; }
public statement builder append ( long x ) { builder . append ( x ) ; return this ; }
public statement builder append ( string s ) { builder . append ( s ) ; return this ; }
public void insert row ( value [ ] row ) throw s q l exception { statement builder buff = new statement builder ( `` insert into `` ) ; append table name ( buff ) ; buff . append ( ' ( ' ) ; append column list ( buff , false ) ; buff . append ( `` ) value ( `` ) ; buff . reset count ( ) ; for ( int i = 0 ; i < column count ; i++ ) { buff . append except first ( `` , `` ) ; value v = row [ i ] ; if ( v == null ) { buff . append ( `` default `` ) ; } else { buff . append ( ' ? ' ) ; } } buff . append ( ' ) ' ) ; prepare statement prep = conn . prepare statement ( buff . to string ( ) ) ; for ( int i = 0 , j = 0 ; i < column count ; i++ ) { value v = row [ i ] ; if ( v ! = null ) { v . set ( prep , j++ + 1 ) ; } } int count = prep . execute update ( ) ; if ( count ! = 1 ) { throw db exception . get ( error code . no_data_available ) ; } }
public static void write var long ( byte buffer buff , long x ) { while ( ( x & ~0x7f ) ! = 0 ) { buff . put ( ( byte ) ( 0x80 | ( x & 0x7f ) ) ) ; x > > > = 7 ; } buff . put ( ( byte ) x ) ; }
public int length ( ) { return byte . length ; }
public static class get class ( string class name ) throw class not find exception { return get class ( class name , true ) ; }
public void set default value ( string default value ) { this . default value = default value ; } // -- void set default value ( string )
public static < t > hash set < t > hash set ( ) { return new hash set < t > ( ) ; }
public void set locale ( locale l ) throw s a x exception { if ( l ! = null & & ! message . be locale support ( l . to string ( ) ) ) { throw new s a x exception ( message . get message ( locale , `` p-078 `` , new object [ ] { l } ) ) ; } locale = l ; }
public counter get task counter ( ) { return counter ; }
public t get value ( ) { return value ; }
public long small ( ) { return small ; }
public long time remain ( time unit unit ) { final long now nanos = ticker . read ( ) ; if ( ! expire & & deadline nanos - now nanos < = 0 ) { expired = true ; } return unit . convert ( deadline nanos - now nanos , time unit . nanosecond ) ; }
public static < t > matcher < t > be in ( t [ ] element ) { return in ( element ) ; }
public static byte byte that ( matcher < byte > matcher ) { report matcher ( matcher ) ; return 0 ; }
public string get description ( ) { return description ; }
public static < t > matcher < t [ ] > have item in array ( t element ) { return have item in array ( equal to ( element ) ) ; }
public string get description ( ) { return description ; }
public static < t > matcher < t > not null value ( class < t > type ) { return not ( null value ( type ) ) ; }
public static < t > matcher < t > null value ( ) { return new be null < t > ( ) ; }
public void set match ( string match ) { if ( regex ! = null ) { throw new build exception ( `` only one regular expression be allow `` ) ; } regex = new regular expression ( ) ; regex . set pattern ( match ) ; }
public string get character set ( ) { return character set ; }
public int get max usage count ( ) { return max usage count ; }
public void set file ( file file ) { this . file = file ; }
public static cascade style get cascade style ( string cascade ) { cascade style style = style . get ( cascade ) ; if ( style == null ) { throw new map exception ( `` unsupported cascade style : `` + cascade ) ; } else { return style ; } }
public void set id ( string id ) { this . id = id ; } // -- void set id ( string )
public void set string index ( int string index ) { this . string index = string index ; }
public boolean be execute with optimistic lock exclude unversioned ( ) { return execute with optimistic lock exclude unversioned ; }
public boolean be cache ( ) { return cache ! = null ; }
public void set value ( member value [ ] element ) { value = element ; if ( element ! = null & & element . length > 0 ) type = element [ 0 ] ; }
public void set class loader ( class loader class loader ) { this . class loader = class loader ; }
public static argument check check ( check check ) { return new argument check ( check ) ; }
public string get embed ( ) { return embed ; }
public string get schema ( ) { return schema ; }
public string get schema ( ) { return schema ; }
public void set index catalog ( string value ) { this . index catalog = value ; }
public boolean support subselect ( ) { return support subselect ; }
public final column definition column ( ) { return column ; }
public void set length ( long length ) { this . length = length ; }
public set < e > unique set ( ) { if ( unique set == null ) { unique set = unmodifiable set . < e > unmodifiable set ( map . key set ( ) ) ; } return unique set ; }
public void set generator ( final string generator ) { this . generator = generator ; }
public string get proxy ( ) { return proxy ; }
public string get proxy ( ) { return proxy ; }
public boolean be update ( ) { return be update ; }
public void set formula ( string value ) { this . formula = value ; }
public string get formula ( ) { return formula ; }
public void set condition ( ast node condition ) { assert not null ( condition ) ; this . condition = condition ; condition . set parent ( this ) ; }
public object get parameter ( string name ) { return parameter . get ( name ) ; }
public filter def find filter def ( string filter name ) { synchronize ( filter defs ) { return filter defs . get ( filter name ) ; } }
public compilation unit set import ( final node list < import declaration > import ) { assert not null ( import ) ; if ( import == this . import ) { return this ; } notify property change ( observable property . import , this . import , import ) ; if ( this . import ! = null ) this . import . set parent node ( null ) ; this . import = import ; set a parent node of ( import ) ; return this ; }
public void set access ( access access ) { this . access = access ; this . add pending change ( `` access `` , access . to j s o n value ( ) ) ; }
public void set lazy init handler ( boolean lazy init handler ) { this . lazy init handler = lazy init handler ; }
public string get $ ref ( ) { return $ ref ; }
public io . vertx . reactivex . redis . redis client zrem many ( string key , list < string > member , handler < async result < long > > handler ) { delegate . zrem many ( key , member , handler ) ; return this ; }
public boolean have region ( string region ) { return region . contains key ( region ) || match region regex ( region ) || have service endpoint ( region ) ; }
public configuration add cacheable file ( string xml file ) throw map exception { metadata source . add cacheable file ( xml file ) ; return this ; }
public integer get fetch size ( ) { return fetch size ; }
public boolean be flush ( ) { return flush ; }
public void set timestamp ( final long timestamp ) { this . timestamp = timestamp ; }
public argument set multi value ( boolean multi value ) { this . multi value = multi value ; return this ; }
public void set entity mode ( entity mode value ) { this . entity mode = value ; }
public entity mode get entity mode ( ) { return entity mode ; }
public static builder builder ( ) { return new builder ( ) ; }
public void set class name ( string class name ) { this . class name = class name ; }
public final column definition column ( ) { return column ; }
public ct class get declare class ( ) throw not find exception { return null ; }
public map get attribute ( ) { return attribute ; }
public class get type ( ) { return ( this . type ) ; }
public context get context ( ) { return impl . get context ( ) ; }
public void add file ( collection < string > file ) { check file name ( file ) ; set file . add all ( file ) ; }
public entity persister find entity descriptor ( string entity name ) { return entity persister map . get ( entity name ) ; }
public t add u d t column ( string column name , u d t type udt type ) { validate not empty ( column name , `` column name `` ) ; validate not null ( udt type , `` column type `` ) ; validate not key word ( column name , string . format ( `` the column name ' % s ' be not allow because it be a reserved keyword `` , column name ) ) ; simple column . put ( column name , udt type ) ; return self ; }
public property get property ( ) { return property ; }
protect void count ( final int write ) { count ( ( long ) write ) ; }
public session get session ( ) { return this . session ; }
public string to string ( ) { string builder buf = new string builder ( ) ; iterator < map . entry < string , compression codec > > itr = codecs . entry set ( ) . iterator ( ) ; buf . append ( `` { `` ) ; if ( itr . have next ( ) ) { map . entry < string , compression codec > entry = itr . next ( ) ; buf . append ( entry . get key ( ) ) ; buf . append ( `` : `` ) ; buf . append ( entry . get value ( ) . get class ( ) . get name ( ) ) ; while ( itr . have next ( ) ) { entry = itr . next ( ) ; buf . append ( `` , `` ) ; buf . append ( entry . get key ( ) ) ; buf . append ( `` : `` ) ; buf . append ( entry . get value ( ) . get class ( ) . get name ( ) ) ; } } buf . append ( `` } `` ) ; return buf . to string ( ) ; }
public void set factory ( j d o m factory factory ) { this . factory = factory ; }
public session get session ( ) { return this . session ; }
public static detach criterion for class ( class clazz ) { return new detach criterion ( clazz . get name ( ) ) ; }
public static detach criterion for entity name ( string entity name ) { return new detach criterion ( entity name ) ; }
public void set order ( int order ) { this . order = order ; }
public static detach criterion for class ( class clazz ) { return new detach criterion ( clazz . get name ( ) ) ; }
public long count ( ) { return count . get ( ) ; }
public static criterion property lt some ( string property name , detach criterion dc ) { return new property subquery expression ( property name , `` < `` , `` some `` , dc ) ; }
public criterion be ( object o ) { this . criterion type = relational operator . eq ; this . right = value node . to value node ( o ) ; return this ; }
public equal builder append ( object [ ] lh , object [ ] rh ) { if ( be equal == false ) { return this ; } if ( lhs == rh ) { return this ; } if ( lhs == null || rh == null ) { this . set equal ( false ) ; return this ; } if ( lh . length ! = rh . length ) { this . set equal ( false ) ; return this ; } for ( int i = 0 ; i < lh . length & & be equal ; ++i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
public static conjunction conjunction ( ) { return new conjunction ( ) ; }
public int get sql type ( ) { return this . sql type ; }
public static conjunction and ( criterion . . . predicate ) { return conjunction ( predicate ) ; }
public boolean be ignore case ( ) { return ignore case ; }
public static criterion property eq ( string [ ] property name , detach criterion dc ) { return new property subquery expression ( property name , `` = `` , dc ) ; }
public static criterion property eq ( string [ ] property name , detach criterion dc ) { return new property subquery expression ( property name , `` = `` , dc ) ; }
public static criterion property le all ( string property name , detach criterion dc ) { return new property subquery expression ( property name , `` < = `` , `` all `` , dc ) ; }
public static criterion property eq ( string [ ] property name , detach criterion dc ) { return new property subquery expression ( property name , `` = `` , dc ) ; }
public string get method call syntax ( string obj , string m , string . . . args ) { string builder buf = new string builder ( ) ; buf . append ( `` $ { `` ) ; buf . append ( obj ) ; buf . append ( `` . `` ) ; buf . append ( m ) ; buf . append ( `` ( `` ) ; if ( args . length ! = 0 ) { int i = 0 ; for ( ; i < args . length - 1 ; i++ ) { buf . append ( `` $ `` ) . append ( args [ i ] ) ; buf . append ( `` , `` ) ; } buf . append ( `` $ `` ) . append ( args [ i ] ) ; } buf . append ( `` ) } `` ) ; return buf . to string ( ) ; }
public string get in ( ) { return in ; }
public boolean bind limit parameter in reverse order ( ) { return false ; }
public int get first index ( ) { return first index ; }
public object [ ] get insert ( ) { return this . insert ; }
public void put ( int type code , string value ) { final integer integer = integer . value of ( type code ) ; default . put ( integer , value ) ; }
public string get ( final int type code ) throw map exception { final integer integer = integer . value of ( type code ) ; final string result = default . get ( integer ) ; if ( result == null ) { throw new map exception ( `` no dialect map for jdbc type : `` + type code ) ; } return result ; }
public void un stash invalid natural id reference ( ) { for ( natural id resolution cache natural id resolution cache : natural id resolution cache map . value ( ) ) { natural id resolution cache . un stash invalid natural id reference ( ) ; } }
public boolean same a cache ( entity persister persister , serializable pk , object [ ] natural id value ) { final natural id resolution cache entity natural id resolution cache = natural id resolution cache map . get ( persister ) ; return entity natural id resolution cache ! = null & & entity natural id resolution cache . same a cache ( pk , natural id value ) ; }
public void un stash invalid natural id reference ( ) { for ( natural id resolution cache natural id resolution cache : natural id resolution cache map . value ( ) ) { natural id resolution cache . un stash invalid natural id reference ( ) ; } }
public void resolve non nullable transient entity ( object entity ) { if ( property path by transient entity ! = null & & property path by transient entity . remove ( entity ) == null ) { throw new illegal state exception ( `` attempt to resolve a non-nullable , transient entity that be not a dependency . `` ) ; } }
public boolean be empty ( ) { return property path by transient entity == null || property path by transient entity . be empty ( ) ; }
public boolean be enable ( ) { return this . enable ; } // -- boolean be enable ( )
public void set connection property ( final property prop ) { assert initialization allow ( ) ; connection property = prop ; if ( connection property ! = null ) { if ( connection property . contains key ( key_user ) ) { set user ( connection property . get property ( key_user ) ) ; } if ( connection property . contains key ( key_password ) ) { set password ( connection property . get property ( key_password ) ) ; } } }
public static value result set get ( simple result result ) { return new value result set ( result ) ; }
public string get action ( ) { return action ; }
public string get action ( ) { return action ; }
public set < k > key set ( ) { if ( key set == null ) { key set = new key set < > ( this ) ; } return key set ; }
public string get cascade ( ) { return cascade ; }
public boolean same a cache ( entity persister persister , serializable pk , object [ ] natural id value ) { final natural id resolution cache entity natural id resolution cache = natural id resolution cache map . get ( persister ) ; return entity natural id resolution cache ! = null & & entity natural id resolution cache . same a cache ( pk , natural id value ) ; }
public boolean contain value ( object manage entity ) { if ( manage entity == null ) { throw new null pointer exception ( `` null copy be not support by `` + get class ( ) . get name ( ) ) ; } return manage to merge entity xref . contains key ( manage entity ) ; }
public boolean contains key ( object merge entity ) { if ( merge entity == null ) { throw new null pointer exception ( `` null entity be not support by `` + get class ( ) . get name ( ) ) ; } return merge to manage entity xref . contains key ( merge entity ) ; }
public list < entry > get entry ( ) { return entry ; }
public type get type ( ) { return type ; }
public void set constraint reference ( int schema part , string constraint name , string clause ) { this . schema part = schema part ; this . constraint name = constraint name ; this . constraint clause number = clause ; }
public void set fragment ( final string fragment ) { this . fragment = fragment ; }
public void add child ( evaluation child ) { if ( first child == null ) { first child = last child = child ; } else { if ( first child == last child ) { first child . next = child ; last child = child ; last child . previous = first child ; } else { child . previous = last child ; last child . next = child ; last child = child ; } } child . parent = this ; }
public string identifier ( ) { return identifier ; }
public compilation unit set import ( final node list < import declaration > import ) { assert not null ( import ) ; if ( import == this . import ) { return this ; } notify property change ( observable property . import , this . import , import ) ; if ( this . import ! = null ) this . import . set parent node ( null ) ; this . import = import ; set a parent node of ( import ) ; return this ; }
public type find function return type ( string function name , ast first ) { s q l function sql function = require s q l function ( function name ) ; return find function return type ( function name , sql function , first ) ; }
public s q l function find s q l function ( string function name ) { return sfi . get sql function registry ( ) . find s q l function ( function name ) ; }
public string identifier ( ) { return identifier ; }
public counter get task counter ( ) { return counter ; }
public boolean column exists ( c t col col , long index ) { return column exists1 base ( col , index+1 ) ; }
public string get parameter name ( ) { return parameter name ; }
public object get property value ( ) { return property value ; }
public void set to list ( string list ) { string tokenizer token = new string tokenizer ( list , `` , `` ) ; while ( token . have more token ( ) ) { to list . add element ( new email address ( token . next token ( ) ) ) ; } }
public int get error code ( ) { return this . error code ; }
public void set interface ( class < ? > . . . interface ) { assert . not null ( interface , `` interface must not be null `` ) ; this . interface . clear ( ) ; for ( class < ? > ifc : interface ) { add interface ( ifc ) ; } }
public constructor < ? > get constructor ( ) { return this . constructor ; }
public static class loader get context class loader ( ) { thread current thread = thread . current thread ( ) ; return current thread . get context class loader ( ) ; }
public static final char [ ] [ ] array concat ( char [ ] [ ] first , char [ ] second ) { if ( second == null ) return first ; if ( first == null ) return new char [ ] [ ] { second } ; int length = first . length ; char [ ] [ ] result = new char [ length + 1 ] [ ] ; system . arraycopy ( first , 0 , result , 0 , length ) ; result [ length ] = second ; return result ; }
protect void set alias ( string alias ) { this . alias = alias ; }
public boolean be include foreign key ( ) { return include foreign key ; }
public string get owner ( ) { return owner ; }
public boolean be value set ( ) { return false ; }
public string get mode ( ) { return mode ; }
public lock option set time out ( int timeout ) { this . timeout = timeout ; return this ; }
public void set timeout ( int timeout ) { this . timeout = timeout ; }
public string get scope ( ) { return this . get ( `` / $ scope `` ) ; }
public void set copy ( short copy ) { print setup record . set copy ( copy ) ; }
public string get name ( ) { return name ; }
public string get column list ( ) { return column list ; }
public string identifier ( ) { return identifier ; }
public name get superclass ( ) { return internal get superclass ( ) ; }
public iterator iterator ( ) { return new iterator ( ) ; }
public boolean get delete ( ) { return this . delete ; }
protect unsupported operation exception create unsupported operation exception ( string name ) { return new unsupported operation exception ( name + `` be not implement by `` + this . get class ( ) . get name ( ) ) ; }
public lock mode get lock mode ( ) { return lock mode ; }
public string to string ( ) { string builder builder = new string builder ( ) ; builder . append ( `` map length = `` ) . append ( key . length ) . append ( `` , count = `` ) . append ( count ) . append ( `` , resize count = `` ) . append ( resize count ) . append ( '\n ' ) ; for ( int i = 0 ; i < key . length ; i ++ ) { builder . append ( ' [ ' ) . append ( i ) . append ( `` ] = `` ) ; if ( key [ i ] ! = null ) { final int hc = system . identity hash code ( keys [ i ] ) ; builder . append ( `` { `` ) . append ( keys [ i ] ) . append ( `` ( hash `` ) . append ( hc ) . append ( `` , modulus `` ) . append ( hc % key . length ) . append ( `` ) = > `` ) . append ( value [ i ] ) . append ( `` } `` ) ; } else { builder . append ( `` ( blank ) `` ) ; } builder . append ( '\n ' ) ; } return builder . to string ( ) ; }
public static boolean have bind ( session factory factory ) { return exist session ( factory ) ! = null ; }
public static object alias ( object column , string alias ) { return new utils . alias ( column , alias ) ; }
public lock option set time out ( int timeout ) { this . timeout = timeout ; return this ; }
public final void set follow ( final boolean new value ) { follow = new value ; }
public string get key ( ) { return key ; }
public compilation unit set import ( final node list < import declaration > import ) { assert not null ( import ) ; if ( import == this . import ) { return this ; } notify property change ( observable property . import , this . import , import ) ; if ( this . import ! = null ) this . import . set parent node ( null ) ; this . import = import ; set a parent node of ( import ) ; return this ; }
public string get format ( ) { return format ; }
public void set failonerror ( boolean fail on error ) { this . fail on error = fail on error ; }
public list < exception > get exception ( ) { return exception ; }
public void set quiet ( final boolean quiet ) { this . quiet = quiet ; if ( quiet ) { this . fail on error = false ; } }
public constructor < ? > get constructor ( ) { return this . constructor ; }
public constructor < ? > get constructor ( ) { return this . constructor ; }
public void on input stream ( input stream stream ) { / * ignore , handle by binary stream message * / }
public e get entity ( ) { return entity ; }
public static string get version ( ) { return version ; }
public void pause ( ) { write lock . lock ( ) ; try { be active = false ; } finally { write lock . unlock ( ) ; } }
public boolean be remove ( ) { return remove ; }
public void set filter ( boolean filter ) { this . filter = filter ; }
public string get descriptor ( ) { return descriptor ; }
public static url a local u r l ( url url ) throw i o exception { return file locator . to file u r l ( url ) ; }
public synchronize boolean remove metadata ( string key , string value ) { if ( metadata == null ) return false ; return reflection helper . remove metadata ( metadata , key , value ) ; }
public synchronize void add metadata ( string key , string value ) { if ( metadata == null ) metadata = new link hash map < string , list < string > > ( ) ; reflection helper . add metadata ( metadata , key , value ) ; }
public void set service locator exception class ( class < ? extend exception > service locator exception class ) { if ( service locator exception class ! = null & & ! exception . class . be assignable from ( service locator exception class ) ) { throw new illegal argument exception ( `` service locator exception [ `` + service locator exception class . get name ( ) + `` ] be not a subclass of exception `` ) ; } this . service locator exception constructor = determine service locator exception constructor ( service locator exception class ) ; }
public void set distribution ( string distribution ) { this . distribution = distribution ; } // -- void set distribution ( string )
public void set service locator exception class ( class < ? extend exception > service locator exception class ) { if ( service locator exception class ! = null & & ! exception . class . be assignable from ( service locator exception class ) ) { throw new illegal argument exception ( `` service locator exception [ `` + service locator exception class . get name ( ) + `` ] be not a subclass of exception `` ) ; } this . service locator exception constructor = determine service locator exception constructor ( service locator exception class ) ; }
public static string [ ] get root cause stack trace ( throwable throwable ) { if ( throwable == null ) { return array utils . empty_string_array ; } throwable throwables [ ] = get throwables ( throwable ) ; int count = throwables . length ; array list frame = new array list ( ) ; list next trace = get stack frame list ( throwables [ count - 1 ] ) ; for ( int i = count ; -- i > = 0 ; ) { list trace = next trace ; if ( i ! = 0 ) { next trace = get stack frame list ( throwables [ i - 1 ] ) ; remove common frame ( trace , next trace ) ; } if ( i == count - 1 ) { frame . add ( throwables [ i ] . to string ( ) ) ; } else { frame . add ( wrapped_marker + throwables [ i ] . to string ( ) ) ; } for ( int j = 0 ; j < trace . size ( ) ; j++ ) { frame . add ( trace . get ( j ) ) ; } } return ( string [ ] ) frames . to array ( new string [ 0 ] ) ; }
public void set updated key collector ( hash set < long > update key collector ) { this . updated key collector = update key collector ; }
public void register ( collector m ) { list < string > name = collector name ( m ) ; synchronize ( collector to name ) { for ( string name : name ) { if ( name to collector . contains key ( name ) ) { throw new illegal argument exception ( `` collector already register that provide name : `` + name ) ; } } for ( string name : name ) { name to collector . put ( name , m ) ; } collector to name . put ( m , names ) ; } }
public void set class loader ( class loader class loader ) { this . class loader = class loader ; }
public void set key ( boolean value ) { this . key = value ; }
public final void accept incoming request ( ) { final boolean start with this call = handle incoming request . compare and set ( false , true ) ; assert start with this call : `` transport service be already accept incoming request `` ; logger . debug ( `` now accept incoming request `` ) ; }
public void set logger ( log logger ) { this . logger = logger ; }
public method node get declare method ( string name , parameter [ ] parameter ) { for ( method node method : get declare method ( name ) ) { if ( parameter equal ( method . get parameter ( ) , parameter ) ) { return method ; } } return null ; }
public static < t > t get field ( class < ? > class with static field , string field name ) { return field reflection . get field ( class with static field , field name , null ) ; }
public static boolean be resolve type ( type type ) { if ( type instanceof parameterized type ) { for ( type type arg : ( ( parameterized type ) type ) . get actual type argument ( ) ) { if ( ! be resolve type ( type arg ) ) { return false ; } } return true ; } return type instanceof class < ? > ; }
public static boolean be resolve type ( type type ) { if ( type instanceof parameterized type ) { for ( type type arg : ( ( parameterized type ) type ) . get actual type argument ( ) ) { if ( ! be resolve type ( type arg ) ) { return false ; } } return true ; } return type instanceof class < ? > ; }
protect boolean be qualifier ( class < ? extend annotation > annotation type ) { for ( class < ? extend annotation > qualifier type : this . qualifier type ) { if ( annotation type . equal ( qualifier type ) || annotation type . be annotation present ( qualifier type ) ) { return true ; } } return false ; }
public t get ( ) { return o ; }
public static < k > object set < k > empty set ( ) { return empty_set ; }
public http connection manager get http connection manager ( ) { return http connection manager ; }
public static string format http response header ( http web request response ) throw e w s http exception { final int code = response . get response code ( ) ; final string content type = response . get response content type ( ) ; final map < string , string > header = response . get response header ( ) ; return code + `` `` + content type + `` \n `` + ew utility . format http header ( header ) + `` \n `` ; }
public io . vertx . axle . core . http . http client create http client ( http client option option ) { io . vertx . axle . core . http . http client ret = io . vertx . axle . core . http . http client . new instance ( delegate . create http client ( option ) ) ; return ret ; }
public tag get tag ( ) { return this . tag ; }
public static http params create default http params ( ) { http params params = new sync basic http params ( ) ; http protocol params . set version ( params , http version . http_1_1 ) ; http protocol params . set content charset ( params , http . default_content_charset ) ; http connection params . set tcp no delay ( params , true ) ; http connection params . set socket buffer size ( params , 8192 ) ; return params ; }
public final string get name ( ) { return name ; }
public final u assert value count ( int count ) { int s = value . size ( ) ; if ( s ! = count ) { throw fail ( `` value count differ ; expect : `` + count + `` , actual : `` + s ) ; } return ( u ) this ; }
public static http params create default http params ( ) { http params params = new sync basic http params ( ) ; http protocol params . set version ( params , http version . http_1_1 ) ; http protocol params . set content charset ( params , http . default_content_charset ) ; http connection params . set tcp no delay ( params , true ) ; http connection params . set socket buffer size ( params , 8192 ) ; return params ; }
public string uri ( ) { return uri ; }
protect void set line tracker ( i line tracker tracker ) { f tracker= tracker ; }
public history limit respect global max entry ( int p global max entry ) { if ( max entry > p global max entry || max entry == 0 ) { max entry = p global max entry ; } return this ; }
public list < entry > get entry ( ) { return entry ; }
protect void release ( connection conn ) { if ( data source ! = null ) { close ( conn ) ; } }
public string get domain ( ) { return domain ; }
public void remove cookie ( http servlet response response ) { assert . not null ( response , `` http servlet response must not be null `` ) ; cookie cookie = create cookie ( `` `` ) ; cookie . set max age ( 0 ) ; if ( be cookie secure ( ) ) { cookie . set secure ( true ) ; } if ( be cookie http only ( ) ) { cookie . set http only ( true ) ; } response . add cookie ( cookie ) ; if ( logger . be trace enable ( ) ) { logger . trace ( `` remove cookie ' `` + get cookie name ( ) + `` ' `` ) ; } }
public static request matcher query param ( string name , string . . . expect value ) { return request - > { multi value map < string , string > params = get query params ( request ) ; assert value count ( `` query param `` , name , params , expect value . length ) ; for ( int i = 0 ; i < expect value . length ; i++ ) { assert equal ( `` query param [ `` + name + `` ] `` , expect value [ i ] , params . get ( name ) . get ( i ) ) ; } } ; }
public static s s l socket get socket ( encryption option option ) throw i o exception { s s l context ctx = create s s l context ( option , true ) ; s s l socket socket = ( s s l socket ) ctx . get socket factory ( ) . create socket ( ) ; try { prepare socket ( socket , option ) ; return socket ; } catch ( illegal argument exception e ) { socket . close ( ) ; throw e ; } }
public void set input ( string input ) { this . input = input ; }
public void set do authentication ( boolean do authentication ) { this . do authentication = do authentication ; }
public void add auth info ( string scheme , byte auth [ ] ) { cnxn . add auth info ( scheme , auth ) ; }
public boolean be enable ( ) { return this . enable ; } // -- boolean be enable ( )
public boolean be accept gzip ( ) { return accept gzip ; }
public string get parameter name ( ) { return parameter name ; }
public void evict ( ) throw exception { if ( connection pool ! = null ) { connection pool . evict ( ) ; } }
public client configuration with connection timeout ( int connection timeout ) { set connection timeout ( connection timeout ) ; return this ; }
public metadata builder get metadata builder ( ) { metadata builder impl default builder = new metadata builder impl ( this ) ; return get custom builder or default ( default builder ) ; }
public void consume all token ( ) throw i o exception { while ( increment token ( ) ) { } }
public boolean be boolean ( ) { return false ; }
public static boolean be low case ( char ch ) { return character . to lower case ( ch ) == ch ; }
public graphic create ( ) { try { return ( graphic ) clone ( ) ; } catch ( clone not support exception e ) { throw new runtime exception ( e ) ; } }
public static void not empty ( map map ) { if ( map == null || map . size ( ) == 0 ) { throw new illegal argument exception ( `` the validated map be empty `` ) ; } }
public string get index end ( ) { return index end ; }
protect final int read back reference ( final byte [ ] b , final int off , final int len ) { final int avail = available ( ) ; if ( len > avail ) { try to copy ( len - avail ) ; } return read from buffer ( b , off , len ) ; }
public static boolean parse boolean ( char sequence char ) { return ( char . length ( ) == 4 ) & & ( char . char at ( 0 ) == 't ' || char . char at ( 0 ) == 't ' ) & & ( char . char at ( 1 ) == ' r ' || char . char at ( 1 ) == ' r ' ) & & ( char . char at ( 2 ) == ' u ' || char . char at ( 2 ) == ' u ' ) & & ( char . char at ( 3 ) == ' e ' || char . char at ( 3 ) == ' e ' ) ; }
public int stem prefix ( char s [ ] , int len ) { for ( int i = 0 ; i < prefix . length ; i++ ) if ( start with check length ( s , len , prefixes [ i ] ) ) return delete n ( s , 0 , len , prefix [ i ] . length ) ; return len ; }
public void set module ( final list < module > module ) { this . module = module ; }
public void release ( ) { state . release ( false ) ; }
public void set timestamp ( final long timestamp ) { this . timestamp = timestamp ; }
public string [ ] get parameter key ( ) { if ( parameter == null ) return new string [ 0 ] ; return parameter . key set ( ) . to array ( new string [ parameter . size ( ) ] ) ; }
public static void set default pool ( buffer pool pool ) { if ( pool == null ) { throw new illegal argument exception ( `` pool be null `` ) ; } default pool = pool ; }
public charset get charset ( ) { return this . charset ; }
public final void append ( byte b ) { if ( pos > = buf . length ) { grow buffer ( ) ; } buf [ po ] = b ; pos++ ; }
public e get entity ( ) { return entity ; }
public static boolean be blank ( final string s ) { if ( s == null || s . be empty ( ) ) { return true ; } for ( int i = 0 ; i < s . length ( ) ; i++ ) { char c = s . char at ( i ) ; if ( ! character . be whitespace ( c ) ) { return false ; } } return true ; }
public void close ( ) throw i o exception { super . close ( ) ; close = true ; }
protect void queue close session ( final i o session session ) { if ( session ! = null ) { this . closed session . add ( session ) ; } }
protect void session create ( final selection key key , final i o session session ) { }
public session get session ( ) { return this . session ; }
public long get remain ( ) { return remain ; }
public period to period ( ) { return new period ( this ) ; }
public void set factory ( j d o m factory factory ) { this . factory = factory ; }
public void set logger ( log logger ) { this . logger = logger ; }
public string get mode ( ) { return mode ; }
public int get capacity ( ) { return capacity ; }
public void set method ( int method ) { this . method = method ; }
public string get reason ( ) { return this . reason ; }
public static marker get detach marker ( string name ) { return marker factory . get detached marker ( name ) ; }
public string get name ( ) { return ( _name ) ; }
public static string to ascii string ( final byte [ ] raw ) { return new string ( to ascii char ( raw ) ) ; }
public void set desc padding ( int padding ) { this . default desc pad = padding ; }
public void add filter ( string token , string value ) { if ( token == null ) { return ; } global filter set . add filter ( new filter set . filter ( token , value ) ) ; }
public token filter filter start array ( ) { return this ; }
public void set include ( string value ) { this . include = value ; }
public boolean be match ( ) { return match ; }
public char get escape char ( ) { return escape char ; }
public object get instance ( ) { return instance ; }
public result get result ( ) { return result ; }
public int length ( ) { return byte . length ; }
public schema get schema ( ) { return schema ; }
public void set input ( string input ) { this . input = input ; }
public string get source ( ) { return source ; }
public boolean be boolean ( ) { return false ; }
@ override public json token a token ( ) { return json token . start_array ; }
public t get value ( ) { return value ; }
protect unsupported operation exception create unsupported operation exception ( string name ) { return new unsupported operation exception ( name + `` be not implement by `` + this . get class ( ) . get name ( ) ) ; }
public io . vertx . axle . core . json . pointer . json pointer copy ( ) { io . vertx . axle . core . json . pointer . json pointer ret = io . vertx . axle . core . json . pointer . json pointer . new instance ( delegate . copy ( ) ) ; return ret ; }
protect string [ ] get property method suffix ( string property name ) { string suffix = get property method suffix ( property name ) ; if ( suffix . length ( ) > 0 & & character . be upper case ( suffix . char at ( 0 ) ) ) { return new string [ ] { suffix } ; } return new string [ ] { suffix , string utils . capitalize ( suffix ) } ; }
public int size ( ) { return count ; }
public boolean be reference ( ) { return false ; }
public int compare to ( final class info o ) { return this . name . compare to ( o . name ) ; }
public void remove last token ( ) { if ( previous token==null ) { first token = current token = null ; } else { current token = previous token ; current token . set next token ( null ) ; } }
public string get text ( ) { return text ; }
public boolean be internal error ( ) { return impl . be internal error ( ) ; }
public string get field name ( ) { return field name ; }
public byte buf buffer ( ) { return buffer ; }
public set < string > get reference string ( ) { return reference string ; }
public location get location ( ) { return location ; }
public list < big integer > get big integer list ( string key ) { return get big integer list ( key , new array list < big integer > ( ) ) ; }
public static boolean equal ( object a , object b ) { return a == b || ( a ! = null & & a . equal ( b ) ) ; }
public io . vertx . axle . core . json . pointer . json pointer append ( list < string > token ) { delegate . append ( token ) ; return this ; }
public < t > t get ( string key ) { t ret = ( t ) delegate . get ( key ) ; return ret ; }
public object find serializer ( annotate be ) { return null ; }
public json creator . mode find creator binding ( annotate a ) { return null ; }
public string get content type ( ) { return _type ; }
public class get type ( ) { return ( this . type ) ; }
public jsonb annotate element < method > get setter element ( ) { return setter element ; }
public static void set default time zone ( @ nullable time zone time zone ) { default time zone = time zone ; }
protect void _add class mix in ( annotation map annotation , class < ? > to mask ) { if ( _mix in resolver ! = null ) { _add class mix in ( annotation , to mask , _mix in resolver . find mix in class for ( to mask ) ) ; } }
public void add creator property ( settable bean property prop ) { add property ( prop ) ; }
public settable bean property find property ( string property name ) { settable bean property prop = ( _bean property == null ) ? null : _bean property . find ( property name ) ; if ( prop == null & & _property base creator ! = null ) { prop = _property base creator . find creator property ( property name ) ; } return prop ; }
public string [ ] get property order ( ) { return property order ; }
public boolean be null ( ) { return be null ; }
public serialization config with feature ( json generator . feature . . . feature ) { int new set = _generator feature ; int new mask = _generator feature to change ; for ( json generator . feature f : feature ) { int mask = f . get mask ( ) ; new set |= mask ; new mask |= mask ; } return ( ( _generator feature == new set ) & & ( _generator feature to change == new mask ) ) ? this : new serialization config ( this , _mapper feature , _ser feature , new set , new mask , _format write feature , _format write feature to change ) ; }
public static class type pair of ( class < ? > raw class ) { return new class type pair ( raw class , raw class ) ; }
public void set config ( string config ) { _config = config ; }
public ref exact ref ( string name ) throw i o exception { ref ref = get ref ( name ) ; if ( ref == null || ! name . equal ( ref . get name ( ) ) ) { return null ; } return ref ; }
public set < string > get reference string ( ) { return reference string ; }
public void set handle ( handle handle ) { this . handle = handle ; }
public string get subtype ( ) { return subtype ; }
protected array node _add ( json node node ) { _children . add ( node ) ; return this ; }
public array node array node ( int capacity ) { return new array node ( this , capacity ) ; }
protect void index node ( node node ) { list < node > nod = node name to node . get ( node . get x path node name ( ) ) ; if ( node ! = null ) { node . add ( node ) ; } }
static public string byte to string ( byte [ ] binary data ) { if ( binary data == null ) return null ; return new string ( encode ( binary data ) ) ; }
public k get key ( final object value ) { check value ( value ) ; final node < k , v > node = lookup value ( value ) ; return node == null ? null : node . get key ( ) ; }
public static byte [ ] trim to capacity ( byte [ ] array , int max capacity ) { if ( array . length > max capacity ) { byte [ ] old array = array ; array = new byte [ max capacity ] ; system . arraycopy ( old array , 0 , array , 0 , max capacity ) ; } return array ; }
public matcher rule get pojo class ( ) { return pojo class ; }
protect node create node ( string name ) { return new node ( name ) ; }
public int hash code ( ) { return _value == null ? 0 : _value . hash code ( ) ; }
public value node pojo node ( object pojo ) { return new p o j o node ( pojo ) ; }
public void set visibility timeout ( integer visibility timeout ) { this . visibility timeout = visibility timeout ; }
public boolean be enable ( ) { return this . enable ; } // -- boolean be enable ( )
public class get type ( ) { return ( this . type ) ; }
public json generator use default pretty printer ( ) { return this ; }
public setting get setting ( ) { return setting ; }
public boolean be flush ( ) { return flush ; }
public void set filter ( boolean filter ) { this . filter = filter ; }
public final boolean have deserialization feature ( int feature mask ) { return ( _deser feature & feature mask ) == feature mask ; }
public json serializer < object > find null value serializer ( bean property property ) throw json map exception { return _null value serializer ; }
public void set config ( string config ) { _config = config ; }
public string get provider ( ) { return provider ; }
public void set null value serializer ( json serializer < object > nv ) { if ( nvs == null ) { throw new illegal argument exception ( `` can not pass null json serializer `` ) ; } _null value serializer = nv ; }
public static map multi value map ( map map , class collection class ) { return multi value map . decorate ( map , collection class ) ; }
public int get modifier ( ) { return modifier ; }
public void add text ( string text ) { buffer . append ( text ) ; }
public static string identity to string ( object object ) { if ( object == null ) { return null ; } string buffer buffer = new string buffer ( ) ; identity to string ( buffer , object ) ; return buffer . to string ( ) ; }
public chunk get writable chunk ( ) { chunk result = this . f database . get chunk ( ( long ) this . f sequence number * database . chunk_size ) ; result . make dirty ( ) ; return result ; }
public string get name ( ) { return name ; }
public string get extension ( ) { return this . extension ; } // -- string get extension ( )
public metadata source add annotated class name ( string annotate class name ) { if ( annotated class name == null ) { annotated class name = new link hash set < > ( ) ; } annotate class name . add ( annotated class name ) ; return this ; }
public void add creator property ( settable bean property prop ) { add property ( prop ) ; }
public int get from int ( ) { return get from ( ) ; }
public object find content serializer ( annotate be ) { return null ; }
public json serialize . type find serialization typing ( annotate a ) { return null ; }
public static annotation [ ] get resource annotation ( method method ) { map < class < ? > , annotation > annotation = new hash map < class < ? > , annotation > ( ) ; for ( annotation annotation : method . get declare class ( ) . get annotation ( ) ) { annotation . put ( annotation . get class ( ) , annotation ) ; } for ( annotation annotation : method . get annotation ( ) ) { annotation . put ( annotation . get class ( ) , annotation ) ; } return annotation . value ( ) . to array ( new annotation [ annotation . size ( ) ] ) ; }
public void set msg ( string msg ) { this . msg = msg ; }
public final int mix in count ( ) { return _mix in . local size ( ) ; }
public void set member ( final i member [ ] member ) { assert . be not null ( member ) ; f members= member ; }
public list < string > get command line ( string executable , string . . . argument ) { string builder sb = new string builder ( ) ; sb . append ( ' `` ' ) ; sb . append ( super . get command line ( executable , argument ) . get ( 0 ) ) ; sb . append ( ' `` ' ) ; return array . a list ( sb . to string ( ) ) ; }
public document default definition get default ( ) { return this . default ; }
public object get node ( ) { return this . node ; }
public void set value ( member value [ ] element ) { value = element ; if ( element ! = null & & element . length > 0 ) type = element [ 0 ] ; }
public json serializer < object > find null value serializer ( bean property property ) throw json map exception { return _null value serializer ; }
public < t > t get object ( ) { return ( t ) object ; }
public static char to char ( string str , char default value ) { if ( string utils . be empty ( str ) ) { return default value ; } return str . char at ( 0 ) ; }
public void set true ( ) { this . value = true ; }
public static int count dot ( final string s ) { int count = 0 ; for ( int i = 0 ; i < s . length ( ) ; i++ ) { if ( s . char at ( i ) == ' . ' ) { count++ ; } } return count ; }
public static int append char ( automaton a , int state , int c ) { int new state = a . create state ( ) ; a . add transition ( state , new state , c , c ) ; return new state ; }
public string get expression ( ) { return expression ; }
public object get property value ( ) { return property value ; }
public void add listener ( listener listener ) { listener . add ( listener ) ; }
public boolean be lambda ( ) { return be lambda ; }
public void add bean name resolver ( bean name resolver bnr ) { get e l context ( ) . add e l resolver ( new bean name e l resolver ( bnr ) ) ; }
public void add e l resolver ( e l resolver elr ) { get e l context ( ) . add e l resolver ( elr ) ; }
public void add bean ( string name , object bean ) { this . bean . put ( name , bean ) ; }
public object eval ( string expression ) { return get value ( expression , object . class ) ; }
public static void throw exception if method be not find ( class < ? > type , string method name , method method to mock , object . . . argument ) { if ( method to mock == null ) { string method name data = `` `` ; if ( method name ! = null ) { method name data = `` with name ' `` + method name + `` ' `` ; } throw new method not find exception ( `` no method find `` + method name data + `` with parameter type : [ `` + get argument type a string ( argument ) + `` ] in class `` + get unmocked type ( type ) . get name ( ) + `` . `` ) ; } }
public json object set ( string name , string value ) { set ( name , json . value ( value ) ) ; return this ; }
public string [ ] get property order ( ) { return property order ; }
public list get medium ( ) { return medium type ; }
public void set value ( final string value ) { this . value = value ; }
public int get default max age ( ) { return default max age ; }
public string get private key ( ) { return private key ; }
public final boolean be store ( ) { return be store ; }
public string get value ( ) { return value ; }
public version get version ( ) { return version ; }
public string to string ( ) { return set . to string ( ) ; }
public string uri ( ) { return uri ; }
public int status ( ) { return response . get status ( ) ; }
public tag get tag ( ) { return this . tag ; }
public string get manager variant ( ) { return x m l util . get string value ( parent , `` st ref : manager variant `` ) ; }
public big decimal to big decimal ( ) { if ( text be empty or null ( ) ) { return null ; } return string groovy method . to big decimal ( ( char sequence ) text ( ) ) ; }
public void set schema location ( list < string > schema location ) { this . schema location = schema location ; }
public event handler group < t > then ( final event handler < t > . . . handler ) { return handle event with ( handler ) ; }
public string get value ( ) { return value ; }
public string to string ( ) { return super . to string ( ) + `` [ `` + delegate . to string ( ) + `` ] `` ; }
public void set method name ( string value ) { this . method name = value ; }
protect token stream component wrap component ( string field name , token stream component component ) { return component ; }
public constructor < ? > get constructor ( ) { return this . constructor ; }
public list < expression > get enclose method call ( ) { return collection . unmodifiable list ( enclose method call ) ; }
public void record inner peer ( object inner peer ) { if ( assoc ! =null ) assoc . add inner ( current element , inner peer ) ; }
public final string get name ( ) { return name ; }
public type get type ( ) { return type ; }
public boolean have annotation ( final string annotation name ) { return get annotation info ( ) . contains name ( annotation name ) ; }
public index [ ] index ( ) { return index ; }
public string get jar ( ) { return get ( job context . jar ) ; }
public string get parameter name ( ) { return parameter name ; }
public string get owner ( ) { return owner ; }
public void register value target ( target target ) { if ( target == null ) { target = new vector ( ) ; } target . add element ( target ) ; }
public string identifier ( ) { return identifier ; }
public k previous key ( final k key ) { check key ( key ) ; final node < k , v > node = next small ( lookup key ( key ) , key ) ; return node == null ? null : node . get key ( ) ; }
public data loader option set cache exception enable ( boolean cache exception enable ) { this . cache exception enable = cache exception enable ; return this ; }
public boolean cache exception enable ( ) { return cache exception enable ; }
public long count ( ) { return count . get ( ) ; }
static public void fail ( ) { fail ( null ) ; }
public boolean have diff ( ) { return diff markup policy . have diff ( ) ; }
public string print ( readable period period ) { check printer ( ) ; check period ( period ) ; period printer printer = get printer ( ) ; string buffer buf = new string buffer ( printer . calculate print length ( period , i locale ) ) ; printer . print to ( buf , period , i locale ) ; return buf . to string ( ) ; }
public schema export set import file ( string import file ) { this . import file = import file ; return this ; }
public string get class name ( ) { return class name ; }
public string literal expr set string ( string value ) { this . value = escape java ( value ) ; return this ; }
public boolean be resolve ( ) { return resolve ; }
public static char literal expr escape ( string string ) { return new char literal expr ( utils . escape end of line ( string ) ) ; }
public boolean be null ( ) { return be null ; }
public string get name ( ) { return name ; }
public int compare to ( final object object ) { final command cast object = ( command ) object ; int compare to = util . compare ( category , cast object . category ) ; if ( compare to == 0 ) { compare to = util . compare ( define , cast object . define ) ; if ( compare to == 0 ) { compare to = util . compare ( description , cast object . description ) ; if ( compare to == 0 ) { compare to = util . compare ( handler , cast object . handler ) ; if ( compare to == 0 ) { compare to = util . compare ( id , casted object . id ) ; if ( compare to == 0 ) { compare to = util . compare ( name , cast object . name ) ; if ( compare to == 0 ) { compare to = util . compare ( parameter , cast object . parameter ) ; } } } } } } return compare to ; }
public boolean have else block ( ) { return else stmt instanceof block stmt ; }
public boolean have then block ( ) { return then stmt instanceof block stmt ; }
public name get name ( ) { return name ; }
public string get symbol ( ) { return symbol ; }
public request option get option ( ) { return option ; }
public pretty printer configuration set indent type ( indent type indent type ) { indentation indentation = get indentation ( ) . set type ( assert not null ( indent type ) ) ; set indentation ( indentation ) ; return this ; }
public boolean strictly contain ( range other ) { boolean begin result = ( begin . be before ( other . begin ) ) ; boolean end result = ( end . be after ( other . end ) ) ; return begin result & & end result ; }
public boolean contains ( range other ) { boolean begin result = ( begin . be before or equal ( other . begin ) ) ; boolean end result = ( end . be after or equal ( other . end ) ) ; return begin result & & end result ; }
public void set position ( int position ) { buffer position = position ; }
public constructor < ? > get constructor ( ) { return this . constructor ; }
public string get qualify name ( ) { return type declaration . get qualified name ( ) ; }
public java type qualify name get qualify name ( ) { return qualify name ; }
public boolean equal ( object o ) { if ( ! ( o instanceof edge ) ) return false ; edge e = ( edge ) o ; if ( pt . length ! = e . pt . length ) return false ; boolean be equal forward = true ; boolean be equal reverse = true ; int i rev = pt . length ; for ( int i = 0 ; i < pt . length ; i++ ) { if ( ! pt [ i ] . equals2 d ( e . pt [ i ] ) ) { be equal forward = false ; } if ( ! pt [ i ] . equals2 d ( e . pt [ -- i rev ] ) ) { be equal reverse = false ; } if ( ! be equal forward & & ! be equal reverse ) return false ; } return true ; }
public string get format ( ) { return format ; }
public string get format ( ) { return format ; }
public void clear ( ) { object . clear ( ) ; }
public void set need client auth ( boolean need client auth ) { this . need client auth = need client auth ; }
public name get name ( ) { return name ; }
public boolean be low bound ( ) { return ! be upper bound ( ) ; }
public string get filename format ( ) { return filename format ; }
public character a character ( ) { return ( character ) this ; }
public output < t > begin ( ) { return begin ; }
public int get from index ( ) { return from index ; }
public static boolean end with whitespace ( final char sequence char seq ) { if ( char seq . length ( ) == 0 ) { return false ; } return character . be whitespace ( char seq . char at ( char seq . length ( ) - 1 ) ) ; }
public static link hash set < float > of all ( float [ ] array ) { object . require non null ( array , `` array be null `` ) ; return link hash set . of all ( iterator . of all ( array ) ) ; }
public static < k , v > java . util . map < k , v > of ( k k1 , v v1 , k k2 , v v2 , k k3 , v v3 ) { return map n ( k1 , v1 , k2 , v2 , k3 , v3 ) ; }
public static hash set < byte > of all ( byte [ ] array ) { object . require non null ( array , `` array be null `` ) ; return hash set . of all ( iterator . of all ( array ) ) ; }
public static tree set < float > of all ( float [ ] array ) { object . require non null ( array , `` array be null `` ) ; return tree set . of all ( iterator . of all ( array ) ) ; }
public static tree set < long > of all ( long [ ] array ) { object . require non null ( array , `` array be null `` ) ; return tree set . of all ( iterator . of all ( array ) ) ; }
public static tree set < character > of all ( char [ ] array ) { object . require non null ( array , `` array be null `` ) ; return tree set . of all ( iterator . of all ( array ) ) ; }
public static tree set < character > of all ( char [ ] array ) { object . require non null ( array , `` array be null `` ) ; return tree set . of all ( iterator . of all ( array ) ) ; }
public static < t > variable value copy of ( final iterable < t > iterable ) { return new builder ( ) . add all ( iterable ) . build ( ) ; }
public void selector create ( ) { if ( classname ! = null & & classname . length ( ) > 0 ) { try { class c = null ; if ( classpath == null ) { c = class . for name ( classname ) ; } else { ant class loader al = get project ( ) . create class loader ( classpath ) ; c = class . for name ( classname , true , al ) ; } dynselector = ( file selector ) c . new instance ( ) ; final project p = get project ( ) ; if ( p ! = null ) { p . set project reference ( dynselector ) ; } } catch ( class not find exception cnfexcept ) { set error ( `` selector `` + classname + `` not initialize , no such class `` ) ; } catch ( instantiation exception iexcept ) { set error ( `` selector `` + classname + `` not initialize , could not create class `` ) ; } catch ( illegal access exception iaexcept ) { set error ( `` selector `` + classname + `` not initialize , class not accessible `` ) ; } } else { set error ( `` there be no classname specify `` ) ; } }
public void set package ( boolean package ) { this . package = package ; } // -- void set package ( boolean )
public int get block ( ) { return 0 ; }
public void set type ( string type ) { this . type = type ; }
public slot manager get stack frame map ( ) { return stack frame map ; }
public final boolean create new node ( ) { return ( action . get special property ( ) & finally exp . get special property ( ) & static property . non_creative ) == 0 ; }
public string get method call syntax ( string obj , string m , string . . . args ) { string builder buf = new string builder ( ) ; buf . append ( `` $ { `` ) ; buf . append ( obj ) ; buf . append ( `` . `` ) ; buf . append ( m ) ; buf . append ( `` ( `` ) ; if ( args . length ! = 0 ) { int i = 0 ; for ( ; i < args . length - 1 ; i++ ) { buf . append ( `` $ `` ) . append ( args [ i ] ) ; buf . append ( `` , `` ) ; } buf . append ( `` $ `` ) . append ( args [ i ] ) ; } buf . append ( `` ) } `` ) ; return buf . to string ( ) ; }
public void accept ( final command visitor < t > visitor ) { visitor . visit keep command ( get object ( ) ) ; }
public byte [ ] element ( ) { return element ; }
public const pool get const pool ( ) { return const pool ; }
public double [ ] get map params ( ) { double [ ] r = array . copy of ( params , params . length ) ; for ( int i = 0 ; i < params . length ; i++ ) { r [ i ] = get ( i ) ; } return r ; }
public float max ( int dim ) { return min max [ dim + dim + 1 ] ; }
protect byte [ ] new buffer ( int size ) { return new byte [ size ] ; }
public int get flag ( ) { return flag ; }
public name get superclass ( ) { return internal get superclass ( ) ; }
public void set interface ( class < ? > . . . interface ) { assert . not null ( interface , `` interface must not be null `` ) ; this . interface . clear ( ) ; for ( class < ? > ifc : interface ) { add interface ( ifc ) ; } }
public string [ ] get interface ( ) { if ( cached interface ! = null ) return cache interface ; string [ ] rtn = null ; if ( interface == null ) rtn = new string [ 0 ] ; else { string [ ] list = new string [ interface . length ] ; for ( int i = 0 ; i < interface . length ; ++i ) list [ i ] = const pool . get class info ( interface [ i ] ) ; rtn = list ; } cache interface = rtn ; return rtn ; }
public void set minor version ( int minor version ) { this . minor version = minor version ; }
public static int get page type ( long po ) { return ( ( int ) po ) & 1 ; }
public int length ( ) { return byte . length ; }
public static int get page type ( long po ) { return ( ( int ) po ) & 1 ; }
public int get skip count ( ) { return skip count ; }
protect void visit j s r ( int po , byte [ ] code ) throw bad bytecode { throw bad bytecode ( po , `` jsr `` ) ; }
public int get this class info ( ) { return this class info ; }
public string get class name ( ) { return get class info ( this class info ) ; }
public int get tag ( ) { return tag ; }
public string get fieldref type ( int index ) { fieldref info f = ( fieldref info ) get item ( index ) ; if ( f == null ) return null ; name and type info n = ( name and type info ) get item ( f . name and type index ) ; if ( n == null ) return null ; return get utf8 info ( n . type descriptor ) ; }
public int get name and type descriptor ( int index ) { name and type info ntinfo = ( name and type info ) get item ( index ) ; return ntinfo . type descriptor ; }
protect void add index info ( index info index ) { index . put ( index . id , index ) ; }
public boolean be dynamic update ( ) { if ( dynamic update == null ) { return false ; } else { return dynamic update ; } }
public int host class index ( ) { return byte array . read u16bit ( info , 0 ) ; }
public int size ( ) { return size ; }
public table get table ( ) { return table ; }
public int host class index ( ) { return byte array . read u16bit ( info , 0 ) ; }
public const pool get const pool ( ) { return const pool ; }
public void set exception attribute ( @ nullable string exception attribute ) { this . exception attribute = exception attribute ; }
public int get line number ( ) { return line number ; }
public int method index ( ) { return byte array . read u16bit ( get ( ) , 2 ) ; }
public void add signature ( p d signature sig object , signature option option ) throw i o exception { add signature ( sig object , null , option ) ; }
public boolean be list type ( ) { return false ; }
public string get message ( ) { return message ; }
public static class get class ( string class name ) throw class not find exception { return get class ( class name , true ) ; }
public string to string ( ) { return set . to string ( ) ; }
public ct field [ ] get field ( ) { return new ct field [ 0 ] ; }
public static int size ( object list ) { if ( list == null ) return 0 ; if ( list instanceof list ) return ( ( list < ? > ) list ) . size ( ) ; return 1 ; }
public void at call expr ( call expr expr ) throw compile error { a s tree method = expr . oprand1 ( ) ; if ( method instanceof member ) { string name = ( ( member ) method ) . get ( ) ; if ( proc handler ! = null & & name . equal ( proceed name ) ) { proc handler . doit ( this , bytecode , ( a s t list ) expr . oprand2 ( ) ) ; return ; } else if ( name . equal ( cflow name ) ) { at cflow ( ( a s t list ) expr . oprand2 ( ) ) ; return ; } } super . at call expr ( expr ) ; }
public static string name a string ( node name ) { if ( ! be a name ( name ) ) { throw new illegal argument exception ( `` a name be expect `` ) ; } if ( name instanceof name ) { return ( ( name ) name ) . a string ( ) ; } else if ( name instanceof simple name ) { return ( ( simple name ) name ) . get identifier ( ) ; } else if ( name instanceof class or interface type ) { return ( ( class or interface type ) name ) . a string ( ) ; } else if ( name instanceof field access expr ) { field access expr field access expr = ( field access expr ) name ; if ( be a name ( field access expr . get scope ( ) ) ) { return name a string ( field access expr . get scope ( ) ) + `` . `` + name a string ( field access expr . get name ( ) ) ; } else { throw new illegal argument exception ( ) ; } } else if ( name instanceof name expr ) { return ( ( name expr ) name ) . get name a string ( ) ; } else { throw new unsupported operation exception ( `` unknown type of name find : `` + name + `` ( `` + name . get class ( ) . get canonical name ( ) + `` ) `` ) ; } }
public a s t expression get expr ( ) { return ( a s t expression ) get child ( 0 ) ; }
public void before insert ( int index , byte element ) { before insert dummy ( index , 1 ) ; set ( index , element ) ; }
public static class get class ( string class name ) throw class not find exception { return get class ( class name , true ) ; }
public ct class get superclass ( ) throw not find exception { return null ; }
public ct class get declare class ( ) throw not find exception { return null ; }
public ct class get superclass ( ) throw not find exception { return null ; }
public ct field get field ( string name ) throw not find exception { return get field ( name , null ) ; }
public string get field name ( ) { return field name ; }
public ct method get method ( ) throw not find exception { return get ct class ( ) . get method ( get method name ( ) , get signature ( ) ) ; }
public element id get first undefined ( ) { / * since the link list be prune to always start with * the first ( in doc order ) undefined id , we can just * return head : * / return m head ; }
public ct class get type ( ) throw not find exception { int type = etable . catch type ( index ) ; if ( type == 0 ) return null ; const pool cp = get const pool ( ) ; string name = cp . get class info ( type ) ; return this class . get class pool ( ) . get ct class ( name ) ; }
public void set initializer ( object literal initializer ) { this . initializer = initializer ; if ( initializer ! = null ) initializer . set parent ( this ) ; }
public string get name ( ) { return name ; }
public < t > ct constructor < t > create ( ct class < t > target , set < modifier kind > modifier , list < ct parameter < ? > > parameter , set < ct type reference < ? extend throwable > > thrown type , ct block < t > body ) { ct constructor < t > constructor = create ( target , modifier , parameter , thrown type ) ; constructor . set body ( body ) ; return constructor ; }
public ct class get type ( ) throw not find exception { int type = etable . catch type ( index ) ; if ( type == 0 ) return null ; const pool cp = get const pool ( ) ; string name = cp . get class info ( type ) ; return this class . get class pool ( ) . get ct class ( name ) ; }
public void edit ( cast c ) throw can not compile exception { }
public void edit ( constructor call c ) throw can not compile exception { }
public class get type ( ) { return ( this . type ) ; }
public ct method [ ] get method ( ) { return new ct method [ 0 ] ; }
public static boolean be private ( int mod ) { return ( mod & private ) ! = 0 ; }
public static boolean be protect ( int mod ) { return ( mod & protect ) ! = 0 ; }
public boolean get use context class loader ( ) { return use context class loader ; }
public type get type ( ) { return type ; }
public boolean be cache ( ) { return cache ! = null ; }
protect final object write replace ( ) { return new serialize logger ( name ) ; }
public frame [ ] get frames ( ) { return frame ; }
public static input stream sub stream ( input stream input stream , long start , int length ) { return new binary stream impl ( extract byte ( input stream , start , length ) ) ; }
public http header get header ( ) { return this . header ; }
public string get request method ( ) { return request method ; }
public void set x path context ( x path context context ) { this . context = context ; }
protect void parse session ssl id ( request request ) { if ( request . get requested session id ( ) == null & & ssl_only . equal ( request . get servlet context ( ) . get effective session track mode ( ) ) & & request . connector . secure ) { string session id = ( string ) request . get attribute ( s s l support . session_id_key ) ; if ( session id ! = null ) { request . set requested session id ( session id ) ; request . set requested session s s l ( true ) ; } } }
public int status ( ) { return response . get status ( ) ; }
public void println ( double d ) throw i o exception { print ( d ) ; println ( ) ; }
public void println ( float f ) throw i o exception { print ( f ) ; println ( ) ; }
public transfer resource set content length ( long content length ) { this . content length = content length ; return this ; }
public string get remote ( ) { return remote ; }
public void set remote host field ( string remote host field ) { this . remote host field = remote host field ; }
public void set addr type ( host addr type addr type ) { this . addr type = addr type ; }
public static class < ? > get wrapper type ( class < ? > type ) { return primitive to wrapper map . get ( type ) ; }
public content type get type ( ) { return type ; }
public int get size ( ) { return size ; }
public collection < string > get target preferred auth scheme ( ) { return target prefer auth scheme ; }
public session get session ( ) { return this . session ; }
public object get session ( ) { return session ; }
public decl handler get decl handler ( ) { return this . decl handler ; }
public void set x path context ( x path context context ) { this . context = context ; }
public q name get xml name ( ) { return null ; }
public int get flag ( ) { return flag ; }
public void write thin ( stream output out ) throw i o exception { super . write to ( out ) ; out . write v int ( byte . length ( ) ) ; }
public synchronize void finish ( ) { finish = true ; }
public object get variable ( string qname ) { if ( qname == null ) { throw new null pointer exception ( `` null qname `` ) ; } if ( variable == null ) { return null ; } return variable . get ( qname ) ; }
public void set factory ( j d o m factory factory ) { this . factory = factory ; }
public boolean be inner ( ) { return inner class ; }
public void set connection spec for current thread ( connection spec spec ) { this . thread bound spec . set ( spec ) ; }
public output < t > e ( ) { return e ; }
public static x m l reader create x m l reader ( boolean validating , boolean namespace aware ) throw exception { s a x parser factory factory = s a x parser factory . new instance ( ) ; factory . set validating ( validate ) ; factory . set namespace aware ( namespace aware ) ; s a x parser parser = factory . new s a x parser ( ) ; return parser . get x m l reader ( ) ; }
public list breadth first ( ) { list answer = new node list ( ) ; answer . add ( this ) ; answer . add all ( breadth first rest ( ) ) ; return answer ; }
public context get context ( ) { return impl . get context ( ) ; }
public feature map get feature ( ) { return feature ; } //get feature ( )
public object get data ( ) { return data ; }
public boolean be match ( ) { return match ; }
public string to string ( ) { string buffer buf = new string buffer ( `` @ `` ) ; buf . append ( get type name ( ) ) ; if ( member ! = null ) { buf . append ( `` ( `` ) ; for ( string name : member . key set ( ) ) { buf . append ( name ) . append ( `` = `` ) . append ( get member value ( name ) ) . append ( `` , `` ) ; } buf . set length ( buf . length ( ) -2 ) ; buf . append ( `` ) `` ) ; } return buf . to string ( ) ; }
protect int convert text ( string text , locale locale ) { return g j locale symbol . for locale ( locale ) . day of week text to value ( text ) ; }
public token peek token ( ) { while ( need more token ( ) ) { fetch more token ( ) ; } return this . token . get ( 0 ) ; }
public int length ( object obj ) { if ( be array ( obj ) ) { return ( ( list ) obj ) . size ( ) ; } else if ( be map ( obj ) ) { return get property key ( obj ) . size ( ) ; } else if ( obj instanceof string ) { return ( ( string ) obj ) . length ( ) ; } throw new json path exception ( `` length operation can not be apply to `` + obj ! =null ? obj . get class ( ) . get name ( ) : `` null `` ) ; }
public string get uri ( ) { return uri ; }
public string get path ( ) { return this . path ; }
public boolean have next ( ) { return next index ( ) > = 0 ; }
public int get position ( ) { return position ; }
public void rethrow any build exception ( ) { build exception ex = get build exception ( ) ; if ( ex ! = null ) { throw ex ; } }
public void write ( uuid host id , hint hint ) { write ( collection . singleton ( host id ) , hint ) ; }
public path get work directory ( ) { return f . get work directory ( ) ; }
public void error ( object message , throwable t ) { category . log ( fqcn , priority . error , message , t ) ; }
public void fatal ( object message ) { if ( is12 ) { get logger ( ) . log ( fqcn , ( priority ) level . fatal , message , null ) ; } else { get logger ( ) . log ( fqcn , level . fatal , message , null ) ; } }
public boolean be use write replace ( ) { return factory write replace ; }
public boolean be flush ( ) { return flush ; }
public final synchronize metric record create record ( string record name ) { if ( buffer data . get ( record name ) == null ) { buffer data . put ( record name , new record map ( ) ) ; } return new record ( record name ) ; }
public static format step ndc format step ( final boolean leave justify , final int minimum width , final int maximum width ) { return ndc format step ( left justify , minimum width , default_truncate_beginning , maximum width , 0 ) ; }
public static format step exception format step ( final boolean leave justify , final int minimum width , final int maximum width , final boolean extend ) { return exception format step ( left justify , minimum width , default_truncate_beginning , maximum width , null ) ; }
public synchronize step filter manager get step filter manager ( ) { if ( f step filter manager == null ) { f step filter manager = new step filter manager ( ) ; } return f step filter manager ; }
public error handler get handler ( ) { return handler ; }
public string get encode ( ) { return encode ; }
public void set limit ( int limit ) { this . limit = limit ; }
protect string [ ] get property method suffix ( string property name ) { string suffix = get property method suffix ( property name ) ; if ( suffix . length ( ) > 0 & & character . be upper case ( suffix . char at ( 0 ) ) ) { return new string [ ] { suffix } ; } return new string [ ] { suffix , string utils . capitalize ( suffix ) } ; }
public string get protocol ( ) { return protocol ; }
public synchronize order lock new lock ( ) { return new order lock ( this ) ; }
public string get hostname ( ) { return get node ( ) . get host name ( ) ; }
public void set logger ( log logger ) { this . logger = logger ; }
public object get instance ( ) { return instance ; }
public void clear ( ) { object . clear ( ) ; }
public boolean get trim ( ) { return trim ! = null & & trim . boolean value ( ) ; }
public runnable preserve context ( runnable command ) { if ( command instanceof context preserve abstract runnable ) { return command ; } if ( command instanceof context preserve runnable ) { return command ; } if ( command instanceof abstract runnable ) { return new context preserving abstract runnable ( ( abstract runnable ) command ) ; } return new context preserving runnable ( command ) ; }
protect void start monitoring ( ) { synchronize ( this ) { if ( f thread == null ) { f do . set ( false ) ; f thread = new thread ( ( runnable ) this : : read , debug core message . output stream monitor_label ) ; f thread . set daemon ( true ) ; f thread . set priority ( thread . min_priority ) ; f thread . start ( ) ; } } }
public error handler get handler ( ) { return handler ; }
public void fail task ( final task attempt i d task id ) throw i o exception { kill task ( task id , true ) ; }
public static < e > queue < e > synchronize queue ( queue < e > queue ) { return synchronize . queue ( queue , null ) ; }
public long get thread count ( ) { return thread counter . get ( ) ; }
public executor get resolver executor ( ) { return default executor ; }
public string get jar ( ) { return get ( job context . jar ) ; }
public void set transaction manager ( @ nullable transaction manager transaction manager ) { this . transaction manager = transaction manager ; }
public void set transaction manager ( @ nullable transaction manager transaction manager ) { this . transaction manager = transaction manager ; }
public void remove ( listener listener ) { listener . remove ( listener ) ; }
public container get container ( ) { return container ; }
public int get type ( ) { return type ; }
public final int hash code ( ) { return i hash code ; }
public string get text ( ) { string buffer buf = new string buffer ( 64 ) ; buf . append ( get axis name ( ) ) . append ( `` : : `` ) ; if ( get prefix ( ) ! = null & & get prefix ( ) . length ( ) > 0 ) { buf . append ( get prefix ( ) ) . append ( ' : ' ) ; } return buf . append ( get local name ( ) ) . append ( super . get text ( ) ) . to string ( ) ; }
public property get property ( ) { return property ; }
public void set element ( string element ) { assert . have text ( element , `` 'element ' can not be null or blank `` ) ; this . element = element ; }
public content get content ( ) { return this . content ; }
public static boolean be null or empty ( string str ) { return ( ( str == null ) || str . trim ( ) . length ( ) == 0 ) ; }
public void set entity ref visible ( boolean visible ) { if ( visible ) { filter mask |= entityref ; } else { filter mask & = ~entityref ; } }
public void set whitespace visible ( boolean visible ) { if ( whitespace visible ! =visible ) { this . whitespace visible = visible ; token painter = visible ? new visible whitespace token painter ( ) : ( token painter ) new default token painter ( ) ; repaint ( ) ; fire property change ( visible_whitespace_property , ! visible , visible ) ; } }
public void add configure element ( template element element ) { if ( element . get name ( ) == null ) { throw new build exception ( `` the element nest element need a \ `` name\ `` attribute `` ) ; } if ( element . get ( element . get name ( ) ) ! = null ) { throw new build exception ( `` the element `` + element . get name ( ) + `` have already be specify `` ) ; } if ( have implicit element || ( element . be implicit ( ) & & element . size ( ) ! = 0 ) ) { throw new build exception ( `` only one element allow when use implicit element `` ) ; } have implicit element = element . be implicit ( ) ; element . put ( element . get name ( ) , element ) ; }
public j d o m factory get factory ( ) { return this . factory ; }
public string get system id ( ) { return system id ; }
public string get driver class ( ) { return driver class ; }
public boolean get reuse address ( ) { return reuse address ; }
public void set ignore element content whitespace ( final boolean ignore white ) { this . ignore white = ignore white ; engine = null ; }
public throwable get cause ( ) { return cause ; }
public uri get u r i ( ) { return u ; }
public string get format ( ) { return format ; }
public void set omit empty attribute ( boolean omit empty attribute ) { this . omit empty attribute = omit empty attribute ; }
public list < node > get node ( ) { return node ; }
public void set xml decl ( boolean _write xml decl ) { this . write xml decl = _write xml decl ; }
public object get report ( ) { return this . report ; } // -- object get report ( )
public map data ( ) { return this . value ; }
public string to string ( ) { return new string buffer ( 64 ) . append ( `` [ cdata : `` ) . append ( get text ( ) ) . append ( `` ] `` ) . to string ( ) ; }
public static string normalize ( string path ) { return normalize ( path , true ) ; }
public void set factory ( j d o m factory factory ) { this . factory = factory ; }
public list < node > get node ( ) { return node ; }
public void evaluate input source ( x m l input source input source ) { f document scanner . evaluate input source ( input source ) ; } // evaluate input source ( x m l input source )
public document transform ( document input doc ) throw x s l transform exception { j d o m source source = new j d o m source ( input doc ) ; j d o m result result = new j d o m result ( ) ; try { template . new transformer ( ) . transform ( source , result ) ; return result . get document ( ) ; } catch ( transformer exception e ) { throw new x s l transform exception ( `` could not perform transformation `` , e ) ; } }
public list transform ( list input node ) throw x s l transform exception { j d o m source source = new j d o m source ( input node ) ; j d o m result result = new j d o m result ( ) ; try { template . new transformer ( ) . transform ( source , result ) ; return result . get result ( ) ; } catch ( transformer exception e ) { throw new x s l transform exception ( `` could not perform transformation `` , e ) ; } }
public static boolean be x m l letter ( final char c ) { return ( byte ) 0 ! = ( byte ) ( charflags [ c ] & maskxmlletter ) ; }
public void set x path context ( x path context context ) { this . context = context ; }
public list < string > get variable name ( ) { return this . variable name ; }
public boolean be attribute ( ) { return attribute ; }
public void set prefix ( string prefix ) { this . prefix = prefix ; } // -- void set prefix ( string )
public string get document i d ( ) { return x m l util . get string value ( parent , `` st ref : document i d `` ) ; }
public static response builder not acceptable ( list < variant > variant ) { return status ( status . not_acceptable ) . variant ( variant ) ; }
public string get instance i d ( ) { return x m l util . get string value ( parent , `` st evt : instance i d `` ) ; }
public static void clear image ( buffer image image ) { clear image ( image , color . white ) ; }
public x m p schema basic add basic schema ( ) { x m p schema basic schema = new x m p schema basic ( this ) ; return ( x m p schema basic ) basic add schema ( schema ) ; }
protect x m p schema basic add schema ( x m p schema schema ) { element rdf = get r d f element ( ) ; rdf . append child ( schema . get element ( ) ) ; return schema ; }
public document get document ( ) { return document ; }
public void add schema ( x m p schema schema ) { element rdf = get r d f element ( ) ; rdf . append child ( schema . get element ( ) ) ; }
protect x m p schema basic add schema ( x m p schema schema ) { element rdf = get r d f element ( ) ; rdf . append child ( schema . get element ( ) ) ; return schema ; }
public x m l input factory get x m l input factory ( ) { x m l input factory factory = get ( x m l input factory . class ) ; if ( factory ! = null ) { return factory ; } return x m l reader utils . get x m l input factory ( ) ; }
protect void set list attribute ( element element ) throw core exception { string list key = element . get attribute ( key ) ; node list node list = element . get child node ( ) ; int entry count = node list . get length ( ) ; list < string > list = new array list < > ( entry count ) ; node node = null ; element selement = null ; for ( int i = 0 ; i < entry count ; i++ ) { node = node list . item ( i ) ; if ( node . get node type ( ) == node . element_node ) { selement = ( element ) node ; if ( ! selement . get node name ( ) . equal ignore case ( list_entry ) ) { throw get invalid format debug exception ( ) ; } list . add ( get value attribute ( selement ) ) ; } } set attribute ( list key , list ) ; }
public list < string > get advisory ( ) { return get bag list ( prefix + `` : advisory `` ) ; }
public void remove advisory ( string advisory ) { remove bag value ( prefix + `` : advisory `` , advisory ) ; }
public void set date ( string date ) { super . set internal date ( date ) ; }
public void set metadata date ( calendar date ) { set date property ( prefix + `` : metadata date `` , date ) ; }
public list < string > get thumbnail language ( ) { return get language property language ( prefix + `` : thumbnails `` ) ; }
public void set language ( final string language ) { this . language = list . create ( language ) ; }
public string get description ( ) { return description ; }
public void set language ( final string language ) { this . language = list . create ( language ) ; }
public relationship get relationship ( ) { return relationship ; }
public void set right ( final string right ) { this . right = list . create ( right ) ; }
public list < string > get subject ( ) { return get bag list ( prefix + `` : subject `` ) ; }
public void remove subject ( string subject ) { remove bag value ( prefix + `` : subject `` , subject ) ; }
public void set title ( string title ) { this . title = title ; }
public void set title ( string title ) { set language property ( prefix + `` : title `` , null , title ) ; }
public void set ci management ( ci management ci management ) { this . ci management = ci management ; } // -- void set ci management ( ci management )
public string get i d ( ) { return this . get ( `` / $ id `` ) ; }
public string get event ( ) { return event ; }
public static boolean be reserve cql keyword ( string id ) { if ( id == null ) { return false ; } int hash = case insensitive hash ( id ) ; list < char [ ] > keywords = reserved_keywords . get ( hash ) ; if ( keywords == null ) { return false ; } else { for ( char [ ] keyword : keywords ) { if ( equal ignore case ascii ( id , keyword ) ) { return true ; } } return false ; } }
public void set category ( string category ) { this . category = category ; }
public string get owner ( ) { return owner ; }
public void set language ( final string language ) { this . language = list . create ( language ) ; }
public boolean be sync ( ) { return sync ; }
public list < client http request interceptor > get interceptor ( ) { return this . interceptor ; }
public static string error_reading_entity_from_input_stream ( ) { return localizer . localize ( localizable e r r o r_ r e a d i n g_ e n t i t y_ f r o m_ i n p u t_ s t r e a m ( ) ) ; }
public static string redirect_infinite_loop ( ) { return localizer . localize ( localizable r e d i r e c t_ i n f i n i t e_ l o o p ( ) ) ; }
public static string sax_cannot_disable_parameter_entity_processing_feature ( object arg0 ) { return localizer . localize ( localizable s a x_ c a n n o t_ d i s a b l e_ p a r a m e t e r_ e n t i t y_ p r o c e s s i n g_ f e a t u r e ( arg0 ) ) ; }
public static string http_header_no_chars_between_separators ( object arg0 , object arg1 ) { return localizer . localize ( localizable h t t p_ h e a d e r_ n o_ c h a r s_ b e t w e e n_ s e p a r a t o r s ( arg0 , arg1 ) ) ; }
public static string uri_component_encoded_octet_malformed ( object arg0 ) { return localizer . localize ( localizable u r i_ c o m p o n e n t_ e n c o d e d_ o c t e t_ m a l f o r m e d ( arg0 ) ) ; }
public static string exception_mapper_failed_for_exception ( ) { return localizer . localize ( localizable e x c e p t i o n_ m a p p e r_ f a i l e d_ f o r_ e x c e p t i o n ( ) ) ; }
public static string error_service_locator_provider_instance_request ( object arg0 ) { return localizer . localize ( localizable e r r o r_ s e r v i c e_ l o c a t o r_ p r o v i d e r_ i n s t a n c e_ r e q u e s t ( arg0 ) ) ; }
public static string error_interceptor_writer_proceed ( ) { return localizer . localize ( localizable e r r o r_ i n t e r c e p t o r_ w r i t e r_ p r o c e e d ( ) ) ; }
public static string unable_to_secure_xml_transformer_processing ( ) { return localizer . localize ( localizable u n a b l e_ t o_ s e c u r e_ x m l_ t r a n s f o r m e r_ p r o c e s s i n g ( ) ) ; }
public static string resource_config_error_null_applicationclass ( ) { return localizer . localize ( localizable r e s o u r c e_ c o n f i g_ e r r o r_ n u l l_ a p p l i c a t i o n c l a s s ( ) ) ; }
public static string format http response header ( http web request response ) throw e w s http exception { final int code = response . get response code ( ) ; final string content type = response . get response content type ( ) ; final map < string , string > header = response . get response header ( ) ; return code + `` `` + content type + `` \n `` + ew utility . format http header ( header ) + `` \n `` ; }
public static boolean fatal issue find ( ) { for ( final error message message : get instance ( ) . issue ) { if ( message . get severity ( ) == severity . fatal ) { return true ; } } return false ; }
public static void fatal ( final object source , final string message ) { error ( source , message , severity . fatal ) ; }
public void fail task ( final task attempt i d task id ) throw i o exception { kill task ( task id , true ) ; }
public throwable get throwable ( ) { return throwable ; }
public void set binding ( bind binding ) { this . bind = binding ; }
public binding bind ( bind binding ) { internal binding . add ( bind ) ; return binding ; }
public simple query string builder analyzer ( string analyzer ) { this . analyzer = analyzer ; return this ; }
public int [ ] get rank ( ) { int [ ] result = new int [ _ranks . length ] ; system . arraycopy ( _ranks , 0 , result , 0 , result . length ) ; return result ; }
public void set descriptor ( change descriptor descriptor ) { f descriptor= descriptor ; }
public object get instance ( ) { return instance ; }
public static string error_wadl_generator_config_loader ( object arg0 ) { return localizer . localize ( localizable e r r o r_ w a d l_ g e n e r a t o r_ c o n f i g_ l o a d e r ( arg0 ) ) ; }
public static string injection_error_nonstatic_member_class_not_supported ( object arg0 ) { return localizer . localize ( localizable i n j e c t i o n_ e r r o r_ n o n s t a t i c_ m e m b e r_ c l a s s_ n o t_ s u p p o r t e d ( arg0 ) ) ; }
public static string error_wadl_builder_generation_param ( object arg0 , object arg1 , object arg2 ) { return localizer . localize ( localizable e r r o r_ w a d l_ b u i l d e r_ g e n e r a t i o n_ p a r a m ( arg0 , arg1 , arg2 ) ) ; }
public static string error_monitoring_mbeans_unregistration_destroy ( ) { return localizer . localize ( localizable e r r o r_ m o n i t o r i n g_ m b e a n s_ u n r e g i s t r a t i o n_ d e s t r o y ( ) ) ; }
public static string error_wadl_builder_generation_param ( object arg0 , object arg1 , object arg2 ) { return localizer . localize ( localizable e r r o r_ w a d l_ b u i l d e r_ g e n e r a t i o n_ p a r a m ( arg0 , arg1 , arg2 ) ) ; }
public static string injection_error_suitable_constructor_not_found ( object arg0 ) { return localizer . localize ( localizable i n j e c t i o n_ e r r o r_ s u i t a b l e_ c o n s t r u c t o r_ n o t_ f o u n d ( arg0 ) ) ; }
public static string http_header_no_chars_between_separators ( object arg0 , object arg1 ) { return localizer . localize ( localizable h t t p_ h e a d e r_ n o_ c h a r s_ b e t w e e n_ s e p a r a t o r s ( arg0 , arg1 ) ) ; }
public static string error_service_locator_provider_instance_request ( object arg0 ) { return localizer . localize ( localizable e r r o r_ s e r v i c e_ l o c a t o r_ p r o v i d e r_ i n s t a n c e_ r e q u e s t ( arg0 ) ) ; }
public static string error_wadl_builder_generation_method ( object arg0 , object arg1 ) { return localizer . localize ( localizable e r r o r_ w a d l_ b u i l d e r_ g e n e r a t i o n_ m e t h o d ( arg0 , arg1 ) ) ; }
public static string error_marshalling_jaxb ( object arg0 ) { return localizer . localize ( localizable e r r o r_ m a r s h a l l i n g_ j a x b ( arg0 ) ) ; }
public static string injection_error_nonstatic_member_class_not_supported ( object arg0 ) { return localizer . localize ( localizable i n j e c t i o n_ e r r o r_ n o n s t a t i c_ m e m b e r_ c l a s s_ n o t_ s u p p o r t e d ( arg0 ) ) ; }
public string routing ( ) { return this . routing ; }
public static service finder < ? > find ( final string service name ) throw service configuration error { return new service finder < object > ( object . class , service name , _get context class loader ( ) , false ) ; }
public static < t > service finder < t > find ( final class < t > service , final class loader loader ) throw service configuration error { return find ( service , loader , false ) ; }
public enumeration < test > test ( ) { return f test . element ( ) ; }
public final class < ? > get raw class ( ) { return _class ; }
public output < t > e ( ) { return e ; }
public static void not empty ( collection collection , string message ) { if ( collection . be empty ( collection ) ) { throw new illegal argument exception ( message ) ; } }
public string get ( string key ) { map < string , string > map = get property map ( ) ; if ( ( map ! = null ) & & ( key ! = null ) ) { return map . get ( key ) ; } else { return null ; } }
public type get type ( ) { return type ; }
public index get concrete index ( ) { return concrete index ; }
public void set to list ( string list ) { string tokenizer token = new string tokenizer ( list , `` , `` ) ; while ( token . have more token ( ) ) { to list . add element ( new email address ( token . next token ( ) ) ) ; } }
public static op read ( data input in ) throw i o exception { return value of ( in . read byte ( ) ) ; }
public void put date field ( http header name , long date ) { string d = date generator . format date ( date ) ; put ( name , d ) ; }
public void close ( ) throw i o exception { super . close ( ) ; close = true ; }
public string get reader ( ) { return reader ; }
public static annotation [ ] get resource annotation ( method method ) { map < class < ? > , annotation > annotation = new hash map < class < ? > , annotation > ( ) ; for ( annotation annotation : method . get declare class ( ) . get annotation ( ) ) { annotation . put ( annotation . get class ( ) , annotation ) ; } for ( annotation annotation : method . get annotation ( ) ) { annotation . put ( annotation . get class ( ) , annotation ) ; } return annotation . value ( ) . to array ( new annotation [ annotation . size ( ) ] ) ; }
public q name get role attribute q name ( ) { return role q name ; }
public type component ( ) { return component ; }
public set < string > get reference string ( ) { return reference string ; }
public static local aware executor service get stage ( stage stage ) { return stage . get ( stage ) ; }
public static boolean parse boolean ( char sequence char ) { return ( char . length ( ) == 4 ) & & ( char . char at ( 0 ) == 't ' || char . char at ( 0 ) == 't ' ) & & ( char . char at ( 1 ) == ' r ' || char . char at ( 1 ) == ' r ' ) & & ( char . char at ( 2 ) == ' u ' || char . char at ( 2 ) == ' u ' ) & & ( char . char at ( 3 ) == ' e ' || char . char at ( 3 ) == ' e ' ) ; }
protect void validate variable ( template variable [ ] variable ) throw template exception { }
protect final uri template get template ( ) { return template ; }
public date to date ( ) { return new date ( get millis ( ) ) ; }
public static boolean be blank ( final string s ) { if ( s == null || s . be empty ( ) ) { return true ; } for ( int i = 0 ; i < s . length ( ) ; i++ ) { char c = s . char at ( i ) ; if ( ! character . be whitespace ( c ) ) { return false ; } } return true ; }
public static list < medium type > parse medium type ( @ nullable list < string > medium type ) { if ( collection utils . be empty ( medium type ) ) { return collection . empty list ( ) ; } else if ( medium type . size ( ) == 1 ) { return parse medium type ( medium type . get ( 0 ) ) ; } else { list < medium type > result = new array list < > ( 8 ) ; for ( string medium type : medium type ) { result . add all ( parse medium type ( medium type ) ) ; } return result ; } }
public static void make accessible ( field field ) { if ( ( ! modifier . be public ( field . get modifier ( ) ) || ! modifier . be public ( field . get declare class ( ) . get modifier ( ) ) || modifier . be final ( field . get modifier ( ) ) ) & & ! field . be accessible ( ) ) { field . set accessible ( true ) ; } }
public static type get first type argument ( type type ) { if ( type instanceof class ) { return object . class ; } if ( ! ( type instanceof parameterized type ) ) return object . class ; parameterized type pt = ( parameterized type ) type ; type argument [ ] = pt . get actual type argument ( ) ; if ( argument . length < = 0 ) return object . class ; return argument [ 0 ] ; }
public static string injection_error_nonstatic_member_class_not_supported ( object arg0 ) { return localizer . localize ( localizable i n j e c t i o n_ e r r o r_ n o n s t a t i c_ m e m b e r_ c l a s s_ n o t_ s u p p o r t e d ( arg0 ) ) ; }
public static string error_wadl_builder_generation_method ( object arg0 , object arg1 ) { return localizer . localize ( localizable e r r o r_ w a d l_ b u i l d e r_ g e n e r a t i o n_ m e t h o d ( arg0 , arg1 ) ) ; }
public static string error_unmarshalling_jaxb ( object arg0 ) { return localizer . localize ( localizable e r r o r_ u n m a r s h a l l i n g_ j a x b ( arg0 ) ) ; }
public string get domain ( ) { return domain ; }
public string get path ( ) { return path ; }
public int hash code ( ) { return this . path . hash code ( ) ; }
public string get value ( ) { return value ; }
public int hash code ( ) { return to hash code ( ) ; }
public static < t > t get field ( class < ? > class with static field , string field name ) { return field reflection . get field ( class with static field , field name , null ) ; }
public static list < class < ? > > get generic type argument class ( final type type ) throw illegal argument exception { final type [ ] type = get type argument ( type ) ; if ( type == null ) { return collection . empty list ( ) ; } return array . stream ( type ) . map ( ( function < type , class < ? > > ) reflection helper : : erasure ) . collect ( collector . to list ( ) ) ; }
public void set scope provider ( scope provider scope provider ) { this . scope provider = scope provider ; }
public static list < medium type > parse medium type ( @ nullable list < string > medium type ) { if ( collection utils . be empty ( medium type ) ) { return collection . empty list ( ) ; } else if ( medium type . size ( ) == 1 ) { return parse medium type ( medium type . get ( 0 ) ) ; } else { list < medium type > result = new array list < > ( 8 ) ; for ( string medium type : medium type ) { result . add all ( parse medium type ( medium type ) ) ; } return result ; } }
public static void set meta class ( object self , meta class meta class ) { if ( meta class instanceof handle meta class ) meta class = ( ( handle meta class ) meta class ) . get adaptee ( ) ; if ( self instanceof class ) { groovy system . get meta class registry ( ) . set meta class ( ( class ) self , meta class ) ; } else { ( ( meta class registry impl ) groovy system . get meta class registry ( ) ) . set meta class ( self , meta class ) ; } }
public static int dimension ( class clazz ) { check array type ( clazz ) ; int result = 0 ; while ( clazz . be array ( ) ) { result++ ; clazz = clazz . get component type ( ) ; } return result ; }
public void add header ( string name , string value ) { header . put ( name , value ) ; }
public final string get field name ( ) { return field name ; }
public void set date ( string date ) { super . set internal date ( date ) ; }
public byte buf buffer ( ) { return buffer ; }
public boolean get reuse address ( ) { return reuse address ; }
public string buffer get class buffer ( ) { return class buffer ; }
public string get init method ( ) { return this . init method ; }
public default void init ( filter config filter config ) throw servlet exception { }
public final servlet context get servlet context ( ) { return this . servlet context ; }
public http servlet request get http servlet request ( ) { return request ; }
public http servlet request get http servlet request ( ) { return request ; }
public void session destroy ( http session event event ) { http session session = event . get session ( ) ; destroy session ( session ) ; }
public default void attribute remove ( servlet context attribute event scae ) { }
public string get reason ( ) { return this . reason ; }
public encoder config default query parameter charset ( string charset ) { return new encoder config ( default content charset , charset , should append default content charset to content type if undefined , content encoders , content type to default charset , true ) ; }
public synchronize long get max size ( ) { return max size ; }
public error handler get handler ( ) { return handler ; }
public void set apply index ( boolean apply index ) { this . apply index = apply index ; }
public void set exclude pattern ( string . . . exclude pattern ) { assert . not empty ( excluded pattern , `` 'excluded pattern ' must not be empty `` ) ; this . exclude pattern = new string [ exclude pattern . length ] ; for ( int i = 0 ; i < exclude pattern . length ; i++ ) { this . exclude pattern [ i ] = string utils . trim whitespace ( exclude pattern [ i ] ) ; } init exclude pattern representation ( this . exclude pattern ) ; }
public http request base get http request ( ) { return http request ; }
public call option with authority ( @ nullable string authority ) { call option new option = new call option ( this ) ; new option . authority = authority ; return new option ; }
public protocol get protocol ( ) { return protocol ; }
public long get start time ( ) { return start time ; }
public string get driver class ( ) { return driver class ; }
public long get long ( ) { long ret = delegate . get long ( ) ; return ret ; }
public address get address ( ) { return address ; }
public void set method ( int method ) { this . method = method ; }
public string [ ] get include pattern ( project p ) { if ( be reference ( ) ) { return get ref ( p ) . get include pattern ( p ) ; } else { read file ( p ) ; return make array ( include list , p ) ; } }
public void add exclude method ( string . . . method ) { for ( string m : method ) { _methods . exclude ( m ) ; } }
public void set addr type ( host addr type addr type ) { this . addr type = addr type ; }
public header [ ] get request header ( ) { return get request header group ( ) . get all header ( ) ; }
public void set object factory ( object factory object factory ) { this . object factory = object factory ; }
public final void add filter chain ( filter chain filter ) { filter chain . add element ( filter ) ; }
public boolean gt ( dd y ) { return ( hi > y . hi ) || ( hi == y . hi & & lo > y . lo ) ; }
public t put byte ( byte [ ] b ) { return put byte ( b , 0 , b . length ) ; }
public void read byte ( final long offset , final byte byte [ ] , final int off , final int length ) { if ( length == 0 ) { return ; } int byte offset = off ; int bytes length = length ; int buffer index = ( int ) ( offset > > byte_block_shift ) ; byte [ ] buffer = buffer [ buffer index ] ; int po = ( int ) ( offset & byte_block_mask ) ; int overflow = ( pos + length ) - byte_block_size ; do { if ( overflow < = 0 ) { system . arraycopy ( buffer , po , byte , byte offset , byte length ) ; break ; } else { final int byte to copy = length - overflow ; system . arraycopy ( buffer , po , byte , byte offset , bytes to copy ) ; po = 0 ; byte length -= byte to copy ; byte offset += byte to copy ; buffer = buffer [ ++buffer index ] ; overflow = overflow - byte_block_size ; } } while ( true ) ; }
public static string identity to string ( object object ) { if ( object == null ) { return null ; } string buffer buffer = new string buffer ( ) ; identity to string ( buffer , object ) ; return buffer . to string ( ) ; }
public static void sort ( list < ? > list ) { if ( list . size ( ) > 1 ) { collection . sort ( list , instance ) ; } }
public int get identity hash code ( ) { return this . identity hash code ; }
public boolean compare and set ( long encode , int hi , int lo ) { long update = encode ( hi , lo ) ; return compare and set ( encoded , update ) ; }
protect void set alias ( string alias ) { this . alias = alias ; }
public proposal set push certificate ( @ nullable push certificate cert ) { push cert = cert ; return this ; }
public x509 certificate get client x509 certificate ( ) { return client x509 certificate ; }
public duration idle timeout ( ) { return idle timeout ; }
public static void shutdown ( ) { }
public jaxb cfg cache usage enum get usage ( ) { return usage ; }
public i file get file ( ) { return f file ; }
public string get expression ( ) { return expression ; }
public static void have text ( @ nullable string text , string message ) { if ( ! string utils . have text ( text ) ) { throw new illegal argument exception ( message ) ; } }
public static string collection ( collection < ? > collection ) { if ( collection == null ) { return null_string ; } return array ( collection . to array ( new object [ collection . size ( ) ] ) ) ; }
public static boolean be empty ( object [ ] array ) { return ( array == null || array . length == 0 ) ; }
public object get array ( ) { return array ; }
public object get source ( ) { return source ; }
public int length ( object obj ) { if ( be array ( obj ) ) { return ( ( list ) obj ) . size ( ) ; } else if ( be map ( obj ) ) { return get property key ( obj ) . size ( ) ; } else if ( obj instanceof string ) { return ( ( string ) obj ) . length ( ) ; } throw new json path exception ( `` length operation can not be apply to `` + obj ! =null ? obj . get class ( ) . get name ( ) : `` null `` ) ; }
public int length ( object obj ) { if ( be array ( obj ) ) { return ( ( list ) obj ) . size ( ) ; } else if ( be map ( obj ) ) { return get property key ( obj ) . size ( ) ; } else if ( obj instanceof string ) { return ( ( string ) obj ) . length ( ) ; } throw new json path exception ( `` length operation can not be apply to `` + obj ! =null ? obj . get class ( ) . get name ( ) : `` null `` ) ; }
public str substitutor set variable suffix ( char suffix ) { return set variable suffix matcher ( str matcher . char matcher ( suffix ) ) ; }
public java type qualify name get qualify name ( ) { return qualify name ; }
public static boolean a boolean ( enumeration enumeration ) { if ( null == enumeration ) { return false ; } return enumeration . have more element ( ) ; }
public string get value ( ) { return value ; }
public int get index ( ) { return index ; }
public long get offset ( ) { return offset ; }
public self be close to ( short expect , offset < short > offset ) { short . assert be close to ( info , actual , expect , offset ) ; return myself ; }
public float get float ( long offset ) { return native . get float ( this , this . peer , offset ) ; }
public void set float ( long offset , float value ) { bound check ( offset , 4 ) ; super . set float ( offset , value ) ; }
public int [ ] get int array ( long offset , int array size ) { int [ ] buf = new int [ array size ] ; read ( offset , buf , 0 , array size ) ; return buf ; }
public short [ ] get short array ( long offset , int array size ) { short [ ] buf = new short [ array size ] ; read ( offset , buf , 0 , array size ) ; return buf ; }
public list < field > get field ( ) { return field ; }
public object get data ( ) { return data ; }
public static < t > t [ ] array ( t . . . value ) { return value ; }
protected list < field > get field list ( ) { list < field > flist = new array list < field > ( ) ; for ( class < ? > cl = get class ( ) ; ! cl . equal ( structure . class ) ; cls = cl . get superclass ( ) ) { list < field > class field = new array list < field > ( ) ; field [ ] field = cl . get declared field ( ) ; for ( int i=0 ; i < field . length ; i++ ) { int modifier = field [ i ] . get modifier ( ) ; if ( modifier . be static ( modifier ) || ! modifier . be public ( modifier ) ) { continue ; } class field . add ( field [ i ] ) ; } flist . add all ( 0 , class field ) ; } return flist ; }
public static void clear image ( buffer image image ) { clear image ( image , color . white ) ; }
public void set x attr ( path path , string name , byte [ ] value ) throw i o exception { set x attr ( path , name , value , enum set . of ( x attr set flag . create , x attr set flag . replace ) ) ; }
public int get port ( ) { return port ; }
public static int get master port ( ) { int by reference port = new int by reference ( ) ; io . i o master port ( 0 , port ) ; return port . get value ( ) ; }
public void set prevent dispatch loop ( boolean prevent dispatch loop ) { this . prevent dispatch loop = prevent dispatch loop ; }
public object invoke ( string method name , class arg type , object arg ) { return reflect util . invoke ( obj , method name , arg type , arg ) ; }
public void write ( byte [ ] buffer ) { output buffer . write ( buffer , 0 , buffer . length ) ; }
public int get flag ( ) { return flag ; }
public static string format file string ( info info ) { return format file string ( info . get template name ( ) , info . get line ( ) , info . get column ( ) ) ; }
public object get ( ) { return value ; }
public object get data ( ) { return data ; }
public void set group name ( string group name ) { this . group name = new string buffer ( group name ) ; }
public void set guid ( final guid guid ) { this . guid = guid ; }
protect void release ( connection conn ) { if ( data source ! = null ) { close ( conn ) ; } }
public string get path ( ) { return path ; }
public w32 service open service ( string service name , int permission ) { sc_handle service handle = advapi32 . instance . open service ( _handle , service name , permission ) ; if ( service handle == null ) { throw new win32 exception ( kernel32 . instance . get last error ( ) ) ; } return new w32 service ( service handle ) ; }
public list < service > get service ( ) { synchronize ( service list ) { return new array list < service > ( service list ) ; } }
public property [ ] get property ( ) { return property . value ( ) . to array ( new property [ 0 ] ) ; }
public static time zone get time zone ( date self ) { calendar calendar = calendar . get instance ( ) ; calendar . set time ( self ) ; return calendar . get time zone ( ) ; }
public date time to date time ( ) { return this ; }
public void set date ( string date ) { super . set internal date ( date ) ; }
public long round ceiling ( long instant ) { long new instant = round floor ( instant ) ; if ( new instant ! = instant ) { instant = add ( new instant , 1 ) ; } return instant ; }
public static final readable interval get readable interval ( readable interval interval ) { if ( interval == null ) { long now = date time utils . current time millis ( ) ; interval = new interval ( now , now ) ; } return interval ; }
public date time field [ ] get field ( ) { date time field [ ] result = new date time field [ size ( ) ] ; for ( int i = 0 ; i < result . length ; i++ ) { result [ i ] = get field ( i ) ; } return result ; }
public date time field type [ ] get field type ( ) { date time field type [ ] result = new date time field type [ size ( ) ] ; for ( int i = 0 ; i < result . length ; i++ ) { result [ i ] = get field type ( i ) ; } return result ; }
public type get type ( ) { if ( field type == null ) { field type = type . get return type ( get signature ( ) ) ; } return field type ; }
public date time field type [ ] get field type ( ) { date time field type [ ] result = new date time field type [ size ( ) ] ; for ( int i = 0 ; i < result . length ; i++ ) { result [ i ] = get field type ( i ) ; } return result ; }
public period to period ( period type type ) { return new period ( get millis ( ) , type ) ; }
public period type get period type ( ) { return i type ; }
public period to period ( period type type ) { return new period ( get millis ( ) , type ) ; }
public void set value ( string value ) { this . value = value ; }
public date time field year of century ( ) { return unsupported date time field . get instance ( date time field type . year of century ( ) , year ( ) ) ; }
public date time field year ( ) { return unsupported date time field . get instance ( date time field type . year ( ) , year ( ) ) ; }
public chronology get chronology ( object object , date time zone zone ) { chronology chrono = ( ( readable instant ) object ) . get chronology ( ) ; if ( chrono == null ) { return i s o chronology . get instance ( zone ) ; } date time zone chrono zone = chrono . get zone ( ) ; if ( chrono zone ! = zone ) { chrono = chrono . with zone ( zone ) ; if ( chrono == null ) { return i s o chronology . get instance ( zone ) ; } } return chrono ; }
public static coptic chronology get instance ( ) { return get instance ( date time zone . get default ( ) , 4 ) ; }
public static gregorian chronology get instance ( date time zone zone ) { return get instance ( zone , 4 ) ; }
protect long check instant ( long instant , chronology chronology ) { return chronology . day of month ( ) . round floor ( instant ) ; }
public locale get locale ( ) { return locale ; }
public static final date time zone get zone ( date time zone zone ) { if ( zone == null ) { return date time zone . get default ( ) ; } return zone ; }
public static coptic chronology get instance ( ) { return get instance ( date time zone . get default ( ) , 4 ) ; }
public string get converter ( ) { return converter ; }
public static gregorian chronology get instance ( date time zone zone ) { return get instance ( zone , 4 ) ; }
public int get ( long instant ) { return i chronology . get day of week ( instant ) ; }
public date time minus week ( int week ) { if ( week == 0 ) { return this ; } long instant = get chronology ( ) . week ( ) . subtract ( get millis ( ) , week ) ; return with millis ( instant ) ; }
public int get day ( ) { return day ; }
public interval with duration before end ( readable duration duration ) { long duration millis = date time utils . get duration millis ( duration ) ; if ( duration millis == to duration millis ( ) ) { return this ; } chronology chrono = get chronology ( ) ; long end millis = get end millis ( ) ; long start millis = chrono . add ( end millis , duration millis , -1 ) ; return new interval ( start millis , end millis , chrono ) ; }
public date time with week of weekyear ( int week of weekyear ) { return with millis ( get chronology ( ) . week of weekyear ( ) . set ( get millis ( ) , week of weekyear ) ) ; }
public date time with date ( int year , int month of year , int day of month ) { chronology chrono = get chronology ( ) ; long instant = get millis ( ) ; instant = chrono . year ( ) . set ( instant , year ) ; instant = chrono . month of year ( ) . set ( instant , month of year ) ; instant = chrono . day of month ( ) . set ( instant , day of month ) ; return with millis ( instant ) ; }
protect int get month ( ) { return this . month ; }
protect void set date time ( date date time ) { this . date time = date time ; }
public static date time zone for offset millis ( int millis offset ) { if ( millis offset < -max_millis || millis offset > max_millis ) { throw new illegal argument exception ( `` millis out of range : `` + millis offset ) ; } string id = print offset ( millis offset ) ; return fix offset zone ( id , millis offset ) ; }
public date midnight with month of year ( int month of year ) { return with millis ( get chronology ( ) . month of year ( ) . set ( get millis ( ) , month of year ) ) ; }
protect int get month ( ) { return this . month ; }
public date midnight plus week ( int week ) { if ( week == 0 ) { return this ; } long instant = get chronology ( ) . week ( ) . add ( get millis ( ) , week ) ; return with millis ( instant ) ; }
public date midnight with weekyear ( int weekyear ) { return with millis ( get chronology ( ) . weekyear ( ) . set ( get millis ( ) , weekyear ) ) ; }
public void set limit ( int limit ) { this . limit = limit ; }
public date midnight with weekyear ( int weekyear ) { return with millis ( get chronology ( ) . weekyear ( ) . set ( get millis ( ) , weekyear ) ) ; }
public string get fix ( ) { return fix ; }
public long interval ( ) { return date histogram interval . interval ( ) ; }
public static cache date time zone for zone ( date time zone zone ) { if ( zone instanceof cache date time zone ) { return ( cached date time zone ) zone ; } return new cache date time zone ( zone ) ; }
public int get day ( ) { return day ; }
public date time with early offset at overlap ( ) { long new millis = get zone ( ) . adjust offset ( get millis ( ) , false ) ; return with millis ( new millis ) ; }
public long get available ( ) { return this . available ; }
public string get provider ( ) { return provider ; }
public void set file i d ( string file i d ) { this . file i d = file i d ; }
public duration plus ( duration duration ) { return new plus ( ) . apply ( this , duration ) ; }
public duration field type get duration field type ( ) { return i duration field type ; }
public string get string ( ) { return string ; }
public string get a text ( readable partial partial , int field value , locale locale ) { return get a text ( field value , locale ) ; }
public int get maximum value ( ) { return get field ( ) . get maximum value ( get readable partial ( ) ) ; }
public int get maximum value overall ( ) { return get field ( ) . get maximum value ( ) ; }
public string get a text ( locale locale ) { return get field ( ) . get a text ( get readable partial ( ) , get ( ) , locale ) ; }
public long round ceiling ( long instant ) { long new instant = round floor ( instant ) ; if ( new instant ! = instant ) { instant = add ( new instant , 1 ) ; } return instant ; }
public t get maximum ( ) { return maximum ; }
public long add ( long instant , int amount ) { instant = super . add ( instant , amount ) ; field utils . verify value bound ( this , get ( instant ) , i min , i max ) ; return instant ; }
public int get maximum integer ( ) { return ( int ) max ; }
public field get field ( ) { return field ; }
public long round ceiling ( long instant ) { long new instant = round floor ( instant ) ; if ( new instant ! = instant ) { instant = add ( new instant , 1 ) ; } return instant ; }
public void set date formatter ( date time formatter formatter ) { this . formatters . put ( type . date , formatter ) ; }
public parser get ( ) { return ( parser ) pool . get ( ) ; }
public static final date time zone get zone ( date time zone zone ) { if ( zone == null ) { return date time zone . get default ( ) ; } return zone ; }
public date time parser get parser ( ) { return internal parser date time parser . of ( i parser ) ; }
public date get date time ( ) { return date time ; }
public static long date value ( long year , int month , int day ) { return ( year < < shift_year ) | ( month < < shift_month ) | day ; }
public date time to date time ( ) { return new date time ( get millis ( ) , get zone ( ) ) ; }
public static date time formatter date time no millis ( ) { return constant . dtx ; }
public int orcardinality ( word array b ) { int sum = 0 ; for ( int k = 0 ; k < math . min ( this . get number of word ( ) , b . get number of word ( ) ) ; ++k ) { sum += long . bit count ( this . get word ( k ) | b . get word ( k ) ) ; } word array longer = b . get number of word ( ) < this . get number of word ( ) ? this : b ; for ( int k = math . min ( this . get number of word ( ) , b . get number of word ( ) ) ; k < math . max ( this . get number of word ( ) , b . get number of word ( ) ) ; ++k ) { sum += long . bit count ( longer . get word ( k ) ) ; } return sum ; }
public period to period ( ) { return new period ( this ) ; }
public void set date formatter ( date time formatter formatter ) { this . formatters . put ( type . date , formatter ) ; }
public boolean clear ( final int i ) { return set ( i , false ) ; }
protect int get month ( ) { return this . month ; }
public static period type time ( ) { period type type = c time ; if ( type == null ) { type = new period type ( `` time `` , new duration field type [ ] { duration field type . hour ( ) , duration field type . minute ( ) , duration field type . second ( ) , duration field type . millis ( ) , } , new int [ ] { -1 , -1 , -1 , -1 , 0 , 1 , 2 , 3 , } ) ; c time = type ; } return type ; }
public duration to duration ( ) { return this ; }
public interval to interval ( ) { chronology chrono = get chronology ( ) ; long start = get millis ( ) ; long end = duration field type . day ( ) . get field ( chrono ) . add ( start , 1 ) ; return new interval ( start , end , chrono ) ; }
public period to period ( period type type ) { return new period ( get millis ( ) , type ) ; }
public date midnight plus week ( int week ) { if ( week == 0 ) { return this ; } long instant = get chronology ( ) . week ( ) . add ( get millis ( ) , week ) ; return with millis ( instant ) ; }
public int transform index ( field field , int index ) { return index ; }
public period minus day ( int day ) { return plus day ( -days ) ; }
public int get day ( ) { return day ; }
public duration field type get duration field type ( ) { return i duration field type ; }
public static final date time zone get zone ( date time zone zone ) { if ( zone == null ) { return date time zone . get default ( ) ; } return zone ; }
public cors registration allow origin ( string . . . origin ) { this . config . set allow origin ( array . a list ( origin ) ) ; return this ; }
public m bean server get m bean server ( ) { if ( server == null ) { synchronize ( server lock ) { if ( server == null ) { long t1 = system . current time millis ( ) ; if ( m bean server factory . find m bean server ( null ) . size ( ) > 0 ) { server = m bean server factory . find m bean server ( null ) . get ( 0 ) ; if ( log . be debug enable ( ) ) { log . debug ( `` use exist m bean server `` + ( system . current time millis ( ) - t1 ) ) ; } } else { server = management factory . get platform m bean server ( ) ; if ( log . be debug enable ( ) ) { log . debug ( `` create m bean server `` + ( system . current time millis ( ) - t1 ) ) ; } } } } } return server ; }
public m bean server get m bean server ( ) { if ( server == null ) { synchronize ( server lock ) { if ( server == null ) { long t1 = system . current time millis ( ) ; if ( m bean server factory . find m bean server ( null ) . size ( ) > 0 ) { server = m bean server factory . find m bean server ( null ) . get ( 0 ) ; if ( log . be debug enable ( ) ) { log . debug ( `` use exist m bean server `` + ( system . current time millis ( ) - t1 ) ) ; } } else { server = management factory . get platform m bean server ( ) ; if ( log . be debug enable ( ) ) { log . debug ( `` create m bean server `` + ( system . current time millis ( ) - t1 ) ) ; } } } } } return server ; }
public void set config ( string config ) { _config = config ; }
public static double product ( double [ ] value ) { double product = 0 ; if ( value ! =null & & value . length > 0 ) { product = 1 ; for ( int i=0 , i size=values . length ; i < i size ; i++ ) { product * = value [ i ] ; } } return product ; }
public j s o n object get request j s o n object ( ) { return request j s o n object ; }
public string get path ( ) { return path ; }
public boolean be value set ( ) { return false ; }
public final int get max entry ( ) { return max entry ; }
public int update ( string p ) throw data access exception { return update ( new object [ ] { p } ) ; }
protect void set fault string ( string fault string ) { this . fault string = fault string ; }
public j s o n object get request j s o n object ( ) { return request j s o n object ; }
public part builder part ( string name , object part ) { return part ( name , part , null ) ; }
public void set value default ( string value default ) { this . value default = value default ; }
public string get class name ( ) { return class name ; }
public string to j s o n string ( ) { return to j s o n string ( this , j s o n value . compression ) ; }
public static j s o n array to j s o n array ( j s o n array name , string string ) throw j s o n exception { return to j s o n array ( name , new j s o n tokener ( string ) ) ; }
public string to string ( ) { return set . to string ( ) ; }
public string to j s o n string ( ) { return to j s o n string ( this , j s o n value . compression ) ; }
public object get tag ( string name ) { return tag map . get ( name ) ; }
public static criterion id eq ( object value ) { return new identifier eq expression ( value ) ; }
public boolean be expect start array token ( ) { return current token ( ) == json token . start_array ; }
public int length ( object obj ) { if ( be array ( obj ) ) { return ( ( list ) obj ) . size ( ) ; } else if ( be map ( obj ) ) { return get property key ( obj ) . size ( ) ; } else if ( obj instanceof string ) { return ( ( string ) obj ) . length ( ) ; } throw new json path exception ( `` length operation can not be apply to `` + obj ! =null ? obj . get class ( ) . get name ( ) : `` null `` ) ; }
public object encode ( final object obj ) throw encoder exception { if ( obj == null ) { return null ; } else if ( obj instanceof byte [ ] ) { return encode ( ( byte [ ] ) obj ) ; } else if ( obj instanceof string ) { return encode ( ( string ) obj ) ; } else { throw new encoder exception ( `` object of type `` + obj . get class ( ) . get name ( ) + `` can not be quoted-printable encode `` ) ; } }
public char get char ( string path ) { return object converter . convert object to ( get ( path ) , character . class ) ; }
public boolean get boolean ( string path ) { return object converter . convert object to ( get ( path ) , boolean . class ) ; }
public json token peek ( ) throw i o exception { return null ; }
public void set pretty ( boolean pretty ) { if ( ! disable pretty x m l ) { this . pretty = pretty ; } }
public url get url ( ) { return this . url ; }
public json object get config ( ) { return config ; }
public void set regex ( string regex ) { if ( regex ! = null & & regex . length ( ) ! = 0 ) { this . regex = regex ; property set p = new property set ( ) ; p . set project ( get project ( ) ) ; p . append regex ( regex ) ; add propertyset ( p ) ; } }
public final string get name ( ) { return name ; }
public void execute validation ( int index , object value ) { list < validate conversion > validation = validation by index . get ( index ) ; if ( validation ! = null ) { for ( int i = 0 ; i < validation . size ( ) ; i++ ) { validation . get ( i ) . execute ( value ) ; } } }
public void set digester ( digester digester ) { this . digester = digester ; }
public string to j s o n string ( ) { return to j s o n string ( this , j s o n value . compression ) ; }
public static j s o n array to j s o n array ( j s o n array name , string string ) throw j s o n exception { return to j s o n array ( name , new j s o n tokener ( string ) ) ; }
public string to j s o n string ( ) { return to j s o n string ( this , j s o n value . compression ) ; }
public boolean have more element ( ) { if ( current ! = null ) return true ; while ( current bucket < table . length ) { current = table [ current bucket++ ] ; if ( current ! = null ) return true ; } return false ; }
public j s o n navi < ? > at next ( ) { if ( failure ) return this ; if ( ! ( current instanceof list ) ) return failure ( `` current node be not an array `` , null ) ; @ suppress warning ( `` unchecked `` ) list < object > lst = ( ( list < object > ) current ) ; return at ( lst . size ( ) ) ; }
public j s o n navi < t > array ( ) { if ( failure ) return this ; if ( current == null & & readonly ) failure ( `` can not create array child in readonly `` , null ) ; if ( current ! = null ) { if ( be array ( ) ) return this ; if ( be object ( ) ) failure ( `` can not use object feature on array . `` , null ) ; failure ( `` can not use current possition a object `` , null ) ; } else { current = mapper . create array ( ) ; } if ( root == null ) root = ( t ) current ; else store ( ) ; return this ; }
public hierarchical stream writer create writer ( writer out ) { return new json writer ( out ) ; }
public hierarchical stream writer create writer ( writer out ) { return new json writer ( out ) ; }
public static void assert not equal ( string expect str , string actual str , j s o n comparator comparator ) throw j s o n exception { assert not equal ( `` `` , expect str , actual str , comparator ) ; }
public static void assert not equal ( string expect str , j s o n array actual , boolean strict ) throw j s o n exception { assert not equal ( expect str , actual , strict ? j s o n compare mode . strict : j s o n compare mode . lenient ) ; }
public string get expect ( ) { return f expect ; }
public static document parse ( input stream in , string charset name , string base uri ) throw i o exception { return data util . load ( in , charset name , base uri ) ; }
public iterator < ? extend e > get iterator ( ) { return iterator ; }
public static string join ( string [ ] string , string sep ) { return join ( arrays . a list ( string ) , sep ) ; }
public static document create shell ( string base uri ) { validate . not null ( base uri ) ; document doc = new document ( base uri ) ; element html = doc . append element ( `` html `` ) ; html . append element ( `` head `` ) ; html . append element ( `` body `` ) ; return doc ; }
public static document load ( file in , string charset name , string base uri ) throw i o exception { byte buffer byte data = read file to byte buffer ( in ) ; return parse byte data ( byte data , charset name , base uri , parser . html parser ( ) ) ; }
public synchronize object get ( object key ) { if ( ! contains key ( key ) ) { return null ; } object value = remove ( key ) ; super . put ( key , value ) ; return value ; }
public element html ( string html ) { empty ( ) ; append ( html ) ; return this ; }
public location get location ( ) { return location ; }
public tag get tag ( ) { return this . tag ; }
public void add child ( final object child ) { this . child . add ( child ) ; }
public index [ ] index ( ) { return index ; }
public void set value ( string value ) { this . value = value ; }
public node after ( string html ) { add sibling html ( sibling index + 1 , html ) ; return this ; }
public element html ( string html ) { empty ( ) ; append ( html ) ; return this ; }
protect void index node ( node node ) { list < node > nod = node name to node . get ( node . get x path node name ( ) ) ; if ( node ! = null ) { node . add ( node ) ; } }
public node after ( node node ) { validate . not null ( node ) ; validate . not null ( parent node ) ; parent node . add child ( sibling index + 1 , node ) ; return this ; }
public void set be inline ( boolean value ) throw service version exception { ews utility . validate property version ( this . get owner ( ) . get service ( ) , exchange version . exchange2010 , `` be inline `` ) ; if ( this . can set field value ( this . be inline , value ) ) { this . be inline = value ; this . change ( ) ; } }
public static boolean parse boolean ( char sequence char ) { return ( char . length ( ) == 4 ) & & ( char . char at ( 0 ) == 't ' || char . char at ( 0 ) == 't ' ) & & ( char . char at ( 1 ) == ' r ' || char . char at ( 1 ) == ' r ' ) & & ( char . char at ( 2 ) == ' u ' || char . char at ( 2 ) == ' u ' ) & & ( char . char at ( 3 ) == ' e ' || char . char at ( 3 ) == ' e ' ) ; }
public int get first index ( ) { return first index ; }
public boolean be empty ( ) { return empty ; }
public void consume content ( ) throw i o exception { }
public void add attribute use ( u name name , attribute use impl a ) { attribute . put ( name , a ) ; }
public byte [ ] element ( ) { return element ; }
public string get query ( ) { return query ; }
protect void index node ( node node ) { list < node > nod = node name to node . get ( node . get x path node name ( ) ) ; if ( node ! = null ) { node . add ( node ) ; } }
public object get root ( ) { return root ; }
public static string join ( collection string , string sep ) { return join ( string . iterator ( ) , sep ) ; }
public object get data ( ) { return data ; }
public boolean contain some ( int hash set other ) { int iterator it = other . iterator ( ) ; while ( it . have next ( ) ) { if ( contains ( it . next ( ) ) ) { return true ; } } return false ; }
public logger config get root logger ( ) { return root ; }
public boolean fail ( ) { return state . fail ; }
public void set up ( ) { }
public static string truncate ( string string , int max length ) { if ( string . length ( ) > max length ) { return string . substring ( 0 , max length ) ; } return string ; }
public result run ( junit . framework . test test ) { return run ( new old test class runner ( test ) ) ; }
public enumeration < test > test ( ) { return f test . element ( ) ; }
protect test result create test result ( ) { return new test result ( ) ; }
public static void assert null ( object object ) { assert null ( object , null ) ; }
protect final void expect add ( e . . . element ) { list < e > expect = helper . copy to list ( get sample element ( ) ) ; expect . add all ( array . a list ( element ) ) ; expect content ( expect ) ; }
public long time ( ) { return time ; }
public string get description ( ) { return description ; }
public static transport request unwrap request ( transport request request ) { if ( request instanceof proxy request ) { return ( ( proxy request ) request ) . wrap ; } return request ; }
static public test result run ( test test ) { test runner runner= new test runner ( ) ; return runner . do run ( test ) ; }
public void add listener ( listener listener ) { listener . add ( listener ) ; }
public file new folder ( string folder ) throw i o exception { return new folder ( new string [ ] { folder } ) ; }
public boolean be failure ( ) { return be failure ; }
public folder get folder ( ) { return null ; }
public throwable get error ( ) { return error ; }
public static class get class ( string class name ) throw class not find exception { return get class ( class name , true ) ; }
public throwable get exception ( ) { return cause ; }
public string get message ( ) { return message ; }
public static < t > combinable matcher < t > either ( matcher < t > matcher ) { return new combinable matcher < t > ( matcher ) ; }
public static byte byte that ( matcher < byte > matcher ) { report matcher ( matcher ) ; return 0 ; }
public result get result ( ) { return result ; }
public void set method ( int method ) { this . method = method ; }
public static annotation [ ] get resource annotation ( method method ) { map < class < ? > , annotation > annotation = new hash map < class < ? > , annotation > ( ) ; for ( annotation annotation : method . get declare class ( ) . get annotation ( ) ) { annotation . put ( annotation . get class ( ) , annotation ) ; } for ( annotation annotation : method . get annotation ( ) ) { annotation . put ( annotation . get class ( ) , annotation ) ; } return annotation . value ( ) . to array ( new annotation [ annotation . size ( ) ] ) ; }
public static < t > combinable matcher < t > either ( matcher < t > matcher ) { return new combinable matcher < t > ( matcher ) ; }
public static < t > t eq ( t value ) { return ( t ) report matcher ( new equal ( value ) ) . < t > return for ( value ) ; }
public static < t extend throwable > matcher < t > have cause ( final matcher < ? extend throwable > matcher ) { return new throwable cause matcher < t > ( matcher ) ; }
public void delete ( ) { delegate . delete ( ) ; }
public condition factory condition evaluation listener ( condition evaluation listener condition evaluation listener ) { return new condition factory ( alias , timeout , poll interval , poll delay , catch uncaught exception , condition evaluation listener ) ; }
public static boolean be assignable value ( class < ? > type , object value ) { assert . not null ( type , `` type must not be null `` ) ; return ( value ! = null ? be assignable ( type , value . get class ( ) ) : ! type . be primitive ( ) ) ; }
public class get type ( ) { return ( this . type ) ; }
public vector3 d normalize ( ) { double length = length ( ) ; if ( length > 0 . 0 ) return divide ( length ( ) ) ; return create ( 0 . 0 , 0 . 0 , 0 . 0 ) ; }
public static byte byte that ( matcher < byte > matcher ) { report matcher ( matcher ) ; return 0 ; }
public string raw path ( ) { return raw path ; }
protect boolean apply follow on lock hint ( boolean follow on lock ) { get lock option ( ) . set follow on locking ( follow on lock ) ; return true ; }
public string get label ( ) { return label ; }
public void parse ( log broker monitor monitor ) throw runtime exception { _monitor = monitor ; thread t = new thread ( this ) ; t . start ( ) ; }
public final static void main ( string [ ] args ) { log broker monitor monitor = new log broker monitor ( log level . get log4 j level ( ) ) ; monitor . set frame size ( l f5 appender . get default monitor width ( ) , l f5 appender . get default monitor height ( ) ) ; monitor . set font size ( 12 ) ; monitor . show ( ) ; }
public string format message ( log record record ) { return super . format message ( record ) ; }
protect object read resolve ( ) { return base64 variant . value of ( _name ) ; }
public void set resource u r l ( string resource u r l ) { this . resource u r l = resource u r l ; }
protect void index node ( node node ) { list < node > nod = node name to node . get ( node . get x path node name ( ) ) ; if ( node ! = null ) { node . add ( node ) ; } }
public synchronize long get max size ( ) { return max size ; }
public type component ( ) { return component ; }
public url get url ( ) { return this . url ; }
public void set level ( int level ) { this . trace level = level ; }
public void fatal ( object message ) { if ( is12 ) { get logger ( ) . log ( fqcn , ( priority ) level . fatal , message , null ) ; } else { get logger ( ) . log ( fqcn , level . fatal , message , null ) ; } }
public void set address ( string address ) { if ( this . can set field value ( this . address , address ) ) { this . address = address ; this . change ( ) ; } }
public string get protocol ( ) { return protocol ; }
public void set conf ( configuration conf ) { this . conf = conf ; }
public set < string > get application type ( ) { return collection . unmodifiable set ( application type ) ; }
public static string format date time ( java . util . date date , string format , string locale , string time zone ) { simple date format date format = get date format ( format , locale , time zone ) ; synchronize ( date format ) { return date format . format ( date ) ; } }
public synchronize void leave ( ) throw exception { leave ( -1 , null ) ; }
public property set get property set ( ) { return this . property set ; }
public void set relative path ( string relative path ) { this . relative path = relative path ; } // -- void set relative path ( string )
public throwable get throwable ( ) { return throwable ; }
public level get status level ( ) { return this . level ; }
public boolean get use context class loader ( ) { return use context class loader ; }
public bundle get bundle ( ) { return registration . get bundle ( ) ; }
public static throwable [ ] get throwables ( throwable throwable ) { list list = get throwable list ( throwable ) ; return ( throwable [ ] ) list . to array ( new throwable [ list . size ( ) ] ) ; }
public java method find java method ( expression [ ] args ) { load ( ) ; int parameter count = args . length ; for ( java method m : java method ) { int count = m . get parameter count ( ) ; if ( count == parameter count || ( m . be var args ( ) & & count < = parameter count + 1 ) ) { return m ; } } throw db exception . get ( error code . method_not_found_1 , method name + `` ( `` + class name + `` , parameter count : `` + parameter count + `` ) `` ) ; }
public string get type ( ) { return type ; }
public log builder at fatal ( ) { return at level ( level . fatal ) ; }
public boolean be frozen ( ) { return this . frozen ; }
public int get level ( ) { return level ; }
public void set enum class ( matcher rule value ) { this . enum class = value ; }
public input supplier < input stream > get supplier ( ) { return supplier ; }
public dynamic double property get double property ( string prop name , double default value ) { return get double property ( prop name , default value , null ) ; }
public string get prefix ( ) { return prefix ; }
public static boolean be blank ( final char sequence s ) { if ( s == null ) { return true ; } for ( int i = 0 ; i < s . length ( ) ; i++ ) { if ( ! character . be whitespace ( s . char at ( i ) ) ) { return false ; } } return true ; }
public void add handler ( handler handler ) { set handler ( array util . add to array ( get handler ( ) , handler , handler . class ) ) ; }
public string get name ( ) { return name ; }
public boolean be flush ( ) { return flush ; }
public string get $ ref ( ) { return $ ref ; }
protect void write ( final byte [ ] bytes , final int offset , final int length ) { write byte ( byte , offset , length ) ; }
protect void write ( final byte [ ] bytes ) { write ( byte , 0 , byte . length , false ) ; }
protect void write ( final byte [ ] bytes , final int offset , final int length ) { write byte ( byte , offset , length ) ; }
public static < b extend builder < b > > b new builder ( ) { return new builder < b > ( ) . a builder ( ) ; }
public final string get action ( ) { return action ; }
public p d document get destination ( ) { return this . destination ; }
public void set binding ( bind binding ) { this . bind = binding ; }
public string get event ( ) { return event ; }
public static < b extend builder < b > > b new builder ( ) { return new builder < b > ( ) . a builder ( ) ; }
public void connect ( string path , route route ) { add route ( http method . connect . name ( ) , route impl . create ( path , route ) ) ; }
public void update logger ( final configuration config ) { final configuration old = this . configuration ; for ( final logger logger : logger registry . get logger ( ) ) { logger . update configuration ( config ) ; } fire property change event ( new property change event ( this , property_config , old , config ) ) ; }
public void remove ( listener listener ) { listener . remove ( listener ) ; }
public static void remove handler for root logger ( ) { java . util . log . logger root logger = get root logger ( ) ; java . util . log . handler [ ] handler = root logger . get handler ( ) ; for ( int i = 0 ; i < handler . length ; i++ ) { root logger . remove handler ( handler [ i ] ) ; } }
public void set logger ( log logger ) { this . logger = logger ; }
public int get level ( ) { return level ; }
public result get result ( ) { return result ; }
public gate . resource get resource ( ) { return resource ; }
public void set value default ( string value default ) { this . value default = value default ; }
public final single < t > timeout ( long timeout , time unit time unit ) { return timeout ( timeout , time unit , null , scheduler . computation ( ) ) ; }
public source get source ( ) { return source ; }
public file get destination ( ) { return this . destination ; }
public int get level ( ) { return level ; }
public void set context config location ( @ nullable string context config location ) { this . context config location = context config location ; }
public void set logger ( log logger ) { this . logger = logger ; }
public message get message ( ) { return msg ; }
public static method get static method ( class cl , string method name , class [ ] signature ) { try { method m = cl . get method ( method name , signature ) ; if ( ( m . get modifier ( ) & modifier . static ) == 0 ) throw new runtime exception ( `` method not a static method : `` + method name ) ; return m ; } catch ( no such method exception e ) { throw new runtime exception ( `` no such method : `` + method name ) ; } }
public int get line number ( ) { final location provider location provider = parent . get location provider ( ) ; if ( location provider == null ) { return -1 ; } else { return location provider . get line number ( parent . get current location id ( ) ) ; } }
protect static void destroy process ( string pid , long sleeptime before sigkill , boolean in background ) { terminate process ( pid ) ; sig kill ( pid , false , sleeptime before sigkill , in background ) ; }
public list < string > get raw value for argument ( argument argument ) { list < string > ret = delegate . get raw value for argument ( argument ) ; return ret ; }
public allocation command get command ( ) { return command ; }
public long time ( ) { return time ; }
public static void assert true ( boolean condition , string message ) { if ( ! condition ) { fail not equal ( condition , boolean . true , message ) ; } }
public string get key ( ) { return key ; }
public void shutdown ( ) { }
public string get queue binding name ( ) { return queue bind name ; }
public void set queue bind name ( string queue bind name ) { this . queue bind name = queue bind name ; }
public local metadata registration set context ( collection < string > context ) { if ( context ! = null ) { this . context = context ; } else { this . context = collection . empty list ( ) ; } return this ; }
public void set value default ( string value default ) { this . value default = value default ; }
public void set value default ( string value default ) { this . value default = value default ; }
public string get ( string key ) { map < string , string > map = get property map ( ) ; if ( ( map ! = null ) & & ( key ! = null ) ) { return map . get ( key ) ; } else { return null ; } }
public void put ( string key , string val ) { if ( key == null ) { throw new illegal argument exception ( `` key can not be null `` ) ; } hash map map = ( hash map ) inheritable thread local . get ( ) ; if ( map == null ) { map = new hash map ( ) ; inheritable thread local . set ( map ) ; } map . put ( key , val ) ; }
public void put ( string key , string val ) { if ( key == null ) { throw new illegal argument exception ( `` key can not be null `` ) ; } hash map map = ( hash map ) inheritable thread local . get ( ) ; if ( map == null ) { map = new hash map ( ) ; inheritable thread local . set ( map ) ; } map . put ( key , val ) ; }
public int get from int ( ) { return get from ( ) ; }
public tcp client secure ( consumer < ? super ssl provider . ssl context spec > ssl provider builder ) { require non null ( ssl provider builder , `` ssl provider builder `` ) ; tcp client dup = duplicate ( ) ; ssl provider . ssl context spec builder = ssl provider . builder ( ) ; ssl provider builder . accept ( builder ) ; dup . configuration ( ) . ssl provider = ( ( ssl provider . builder ) builder ) . build ( ) ; return dup ; }
public string to string ( ) { if ( stack trace == null ) { return super . to string ( ) ; } return stack trace ; }
public long get end time stamp ( ) { return end time stamp msec ; }
public void set driver class ( class < ? extend driver > driver class ) { this . driver = bean utils . instantiate class ( driver class ) ; }
public string get pattern ( ) { return pattern ; }
public boolean check entry condition ( ) { if ( ! this . start ) { add error ( `` attempt to append to a non-started appender : `` + this . get name ( ) ) ; return false ; } if ( this . mime msg == null ) { add error ( `` message object not configure . `` ) ; return false ; } if ( this . event evaluator == null ) { add error ( `` no event evaluator be set for appender [ `` + name + `` ] . `` ) ; return false ; } if ( this . layout == null ) { add error ( `` no layout set for appender name [ `` + name + `` ] . for more information , please visit http : //logback . qos . ch/codes . html # smtp_no_layout `` ) ; return false ; } return true ; }
public appender < e > get appender ( string name ) { if ( name == null ) { return null ; } appender < e > find = null ; r . lock ( ) ; try { for ( appender < e > appender : appender list ) { if ( name . equal ( appender . get name ( ) ) ) { find = appender ; break ; } } } finally { r . unlock ( ) ; } return find ; }
public appender < e > get appender ( string name ) { if ( name == null ) { return null ; } appender < e > find = null ; r . lock ( ) ; try { for ( appender < e > appender : appender list ) { if ( name . equal ( appender . get name ( ) ) ) { find = appender ; break ; } } } finally { r . unlock ( ) ; } return find ; }
public string get host ( ) { return host ; }
public int get port ( ) { return this . port ; }
public char get escape char ( ) { return escape char ; }
public median absolute deviation aggregation builder compression ( double compression ) { if ( compression < = 0d ) { throw new illegal argument exception ( `` [ `` + compression_field . get preferred name ( ) + `` ] must be great than 0 . find [ `` + compression + `` ] in [ `` + name + `` ] `` ) ; } this . compression = compression ; return this ; }
public void end ( interpretation context ec , string name ) { if ( in error ) { return ; } if ( appender instanceof life cycle ) { ( ( life cycle ) appender ) . start ( ) ; } object o = ec . peek object ( ) ; if ( o ! = appender ) { add warn ( `` the object at the of the stack be not the appender name [ `` + appender . get name ( ) + `` ] push earlier . `` ) ; } else { ec . pop object ( ) ; } }
public url get url ( ) { return this . url ; }
public static class loader get class loader ( object o ) { if ( system . get security manager ( ) ! = null ) { return access controller . do privilege ( new get class loader action ( o ) ) ; } else { return get class loader internal ( o ) ; } }
public void set class loader ( class loader class loader ) { this . class loader = class loader ; }
public context get context ( ) { return impl . get context ( ) ; }
public void add listener ( listener listener ) { listener . add ( listener ) ; }
public set < string > get name ( ) { return new hash set < string > ( this . parameter . key set ( ) ) ; }
public void set diff algorithm ( diff algorithm alg ) { diff algorithm = alg ; }
public string get provider ( ) { return provider ; }
public protocol get protocol ( ) { return protocol ; }
public boolean be want client auth ( ) { return want client auth ; }
public void set need client auth ( boolean need client auth ) { this . need client auth = need client auth ; }
public void set title ( final string title ) { if ( this . title == null ) { this . title = new content ( ) ; } this . title . set value ( title ) ; }
public static description create test description ( class clazz , string name ) { return new description ( string . format ( `` % s ( % s ) `` , name , clazz . get name ( ) ) ) ; }
public void set asynchronous worker idle lifetime sec ( final int sec ) { this . asynchronous worker idle lifetime sec = sec ; }
public int get origin ( ) { return origin ; }
public void set copy ( short copy ) { print setup record . set copy ( copy ) ; }
public static string default if blank ( string str , string default str ) { return string utils . be blank ( str ) ? default str : str ; }
public byte [ ] decompress ( byte [ ] src , int src off ) { final int d len = get decompress length ( src , src off ) ; return decompressor . decompress ( src , src off + 4 , d len ) ; }
public static int get decompress length ( byte [ ] src , int src off ) { return ( src [ src off ] & 0x f f ) | ( src [ src off + 1 ] & 0x f f ) < < 8 | ( src [ src off + 2 ] & 0x f f ) < < 16 | src [ src off + 3 ] < < 24 ; }
protect void expect content ( collection < e > expect ) { helper . assert equal ignoring order ( expect , actual content ( ) ) ; }
public boolean be private setting ( string key ) { return false ; }
public string get user ( ) { return user ; }
public void set filter ( boolean filter ) { this . filter = filter ; }
public throwable get cause ( ) { return cause ; }
public artifact get artifact ( ) { return artifact ; }
public node parent ( ) { return parent ; }
public artifact get artifact ( ) { return artifact ; }
public artifact get artifact ( ) { return artifact ; }
public void set property ( string property ) { this . property = property ; }
public void set logger ( log logger ) { this . logger = logger ; }
public void set file ( file file ) { this . file = file ; }
public static object wrap ( object o ) { if ( o == null ) { return null ; } if ( o instanceof j s o n array || o instanceof j s o n object ) { return o ; } if ( o . equal ( null ) ) { return o ; } try { if ( o instanceof collection ) { return new j s o n array ( ( collection ) o ) ; } else if ( o . get class ( ) . be array ( ) ) { return new j s o n array ( o ) ; } if ( o instanceof map ) { return new j s o n object ( ( map ) o ) ; } if ( o instanceof boolean || o instanceof byte || o instanceof character || o instanceof double || o instanceof float || o instanceof integer || o instanceof long || o instanceof short || o instanceof string ) { return o ; } if ( o . get class ( ) . get package ( ) . get name ( ) . start with ( `` java . `` ) ) { return o . to string ( ) ; } } catch ( exception ignore ) { } return null ; }
public void set exists ( final boolean exists ) { this . exist = exists ; }
public void set goal ( object goal ) { this . goal = goal ; } // -- void set goal ( object )
public directory directory ( ) { return directory ; }
public object get x path comparable ( boolean order , string collator collator , x path context context ) throw no dynamic context exception { if ( order & & ! ( this instanceof comparable ) ) { return null ; } return ( have timezone ( ) ? this : adjust timezone ( context . get implicit timezone ( ) ) ) ; }
public void set system ( string system ) { this . system = system ; } // -- void set system ( string )
public relocation get relocation ( ) { return this . relocation ; } // -- relocation get relocation ( )
public deployment repository get snapshot repository ( ) { return this . snapshot repository ; } // -- deployment repository get snapshot repository ( )
public relocation get relocation ( ) { return this . relocation ; } // -- relocation get relocation ( )
public void set status ( @ nullable http status status ) { this . status = status ; }
public int get column number ( ) { return column number ; }
public void set system path ( string system path ) { this . system path = system path ; } // -- void set system path ( string )
public string get url ( ) { return this . url ; } // -- string get url ( )
public stream distribution [ ] list stream distribution ( string bucket name ) throw cloud front service exception { list < distribution > stream distribution = list distribution by bucket name ( true , bucket name ) ; return stream distribution . to array ( new stream distribution [ stream distribution . size ( ) ] ) ; }
public void set name ( string name ) { this . name = name ; } // -- void set name ( string )
public void set issue management ( issue management issue management ) { this . issue management = issue management ; } // -- void set issue management ( issue management )
public distribution management get distribution management ( ) { return this . distribution management ; } // -- distribution management get distribution management ( )
public issue management get issue management ( ) { return this . issue management ; } // -- issue management get issue management ( )
public static int size ( object list ) { if ( list == null ) return 0 ; if ( list instanceof list ) return ( ( list < ? > ) list ) . size ( ) ; return 1 ; }
public void set version ( final string version ) { this . version = version ; }
public void set report set ( java . util . list report set ) { this . report set = report set ; } // -- void set report set ( java . util . list )
public void set module ( final list < module > module ) { this . module = module ; }
public void set url ( string url ) { this . url = url ; } // -- void set url ( string )
public resource create relative ( string relative path ) { return new path resource ( this . path . resolve ( relative path ) ) ; }
public list < string > get extension ( ) { return extension ; }
public string get group id ( ) { return this . group id ; } // -- string get group id ( )
public maven project get parent ( ) { return parent ; }
public void set id ( string id ) { this . id = id ; }
public string get version ( ) { return this . version ; } // -- string get version ( )
public void set group id ( string group id ) { this . group id = group id ; } // -- void set group id ( string )
public static string to string exclude ( object object , final string exclude field name ) { return to string exclude ( object , new string [ ] { exclude field name } ) ; }
public void set directory ( string directory ) { this . directory = directory ; } // -- void set directory ( string )
public string get id ( ) { return this . id ; } // -- string get id ( )
public static void set disable checksum ( boolean disable checksum ) { grape . disable checksum = disable checksum ; }
public boolean get enable ( ) { return this . enable ; }
public list < string > get accept ( ) { return ( ! this . active profile . be empty ( ) ) ? this . active profile : this . default profile ; }
public int problem id ( ) { return problem reason . no error ; }
public project get project ( ) { return project ; }
public artifact get artifact ( ) { return artifact ; }
public string get prefix ( ) { return prefix ; }
public string snapshot ( ) { return snapshot ; }
public stream priority set dependency ( int dependency ) { this . dependency = dependency ; return this ; }
public remote repository get repository ( ) { return repository ; }
public install request set metadata ( collection < metadata > metadata ) { if ( metadata == null ) { this . metadata = collection . empty list ( ) ; } else { this . metadata = metadata ; } return this ; }
public boolean be optional ( ) { return this . optional ; }
public deploy result set metadata ( collection < metadata > metadata ) { if ( metadata == null ) { this . metadata = collection . empty list ( ) ; } else { this . metadata = metadata ; } return this ; }
public string get key ( ) { return key ; }
public local metadata registration set context ( collection < string > context ) { if ( context ! = null ) { this . context = context ; } else { this . context = collection . empty list ( ) ; } return this ; }
public artifact get artifact ( ) { return artifact ; }
public local artifact registration set context ( collection < string > context ) { if ( context ! = null ) { this . context = context ; } else { this . context = collection . empty list ( ) ; } return this ; }
public artifact get artifact ( ) { return artifact ; }
public artifact get artifact ( ) { return artifact ; }
public relocation get relocation ( ) { return this . relocation ; } // -- relocation get relocation ( )
public list < node > get node ( ) { return node ; }
public artifact repository get repository ( ) { return repository ; }
public static transport request unwrap request ( transport request request ) { if ( request instanceof proxy request ) { return ( ( proxy request ) request ) . wrap ; } return request ; }
public deploy request set repository ( remote repository repository ) { this . repository = repository ; return this ; }
public exception get exception ( ) { return this . exception ; }
public version get version ( ) { return version ; }
public trust chain constraint get constraint ( ) { return constraint ; }
public artifact get artifact ( ) { return artifact ; }
public list get exception ( ) { return exception ; }
public artifact repository get repository ( ) { return repository ; }
public object get data ( ) { return data ; }
public int get content length ( ) { return this . request . get content length ( ) ; }
public void set trace ( boolean trace ) { this . trace = trace ; }
public list < service > get service ( ) { synchronize ( service list ) { return new array list < service > ( service list ) ; } }
public item get item ( ) { return null ; }
public artifact get artifact ( ) { return artifact ; }
public exception get exception ( ) { return this . exception ; }
public metadata metadata ( ) { return metadata ; }
public byte [ ] get local file data data ( ) { return local data ; }
public type get type ( ) { return type ; }
public list < file > get file ( ) { return file ; }
public void remove ( listener listener ) { listener . remove ( listener ) ; }
public void set username ( string username ) { this . username = username ; } // -- void set username ( string )
public authentication builder add password ( char [ ] password ) { return add secret ( authentication context . password , password ) ; }
public authentication builder add password ( string password ) { return add secret ( authentication context . password , password ) ; }
public void set mirror of ( string mirror of ) { this . mirror of = mirror of ; } // -- void set mirror of ( string )
public void set layout ( string layout ) { this . layout = layout ; } // -- void set layout ( string )
public void set name ( string name ) { this . name = name ; } // -- void set name ( string )
public void set plugin repository ( java . util . list plugin repository ) { this . plugin repository = plugin repository ; } // -- void set plugin repository ( java . util . list )
public void set property ( string property ) { this . property = property ; }
public string get proxy host ( ) { return proxy host name ; }
public object get configuration ( ) { return this . configuration ; } // -- object get configuration ( )
public void set directory permission ( string directory permission ) { this . directory permission = directory permission ; } // -- void set directory permission ( string )
public void add woven permission ( package permission permission ) { if ( ! permission . get action ( ) . equal ( package permission . import ) ) throw new security exception ( ) ; weave permission . add ( permission ) ; }
public boolean be interactive ( ) { return impl . be interactive ( ) ; }
protect set < string > do get default profile ( ) { synchronize ( this . default profile ) { if ( this . default profile . equal ( get reserve default profile ( ) ) ) { string profile = get property ( default_profiles_property_name ) ; if ( string utils . have text ( profile ) ) { set default profile ( comma delimit list to string array ( trim all whitespace ( profile ) ) ) ; } } return this . default profile ; } }
public string to string ( ) { string builder sb = new string builder ( ) ; sb . append ( `` atts [ `` ) ; for ( int i = 0 ; i < attribute . size ( ) ; i++ ) { att att = attribute . get ( i ) ; sb . append ( att . get q name ( ) ) ; sb . append ( `` = `` ) ; sb . append ( att . get value ( ) ) ; sb . append ( `` ; `` ) ; } sb . append ( `` ] `` ) ; return sb . to string ( ) ; }
public string [ ] get not include directory ( ) { slow scan ( ) ; string [ ] directory = new string [ dirs not include . size ( ) ] ; dirs not include . copy into ( directory ) ; return directory ; }
public string [ ] get included directory ( ) { return dirs include . to array ( new string [ dirs include . size ( ) ] ) ; }
public string get extension ( ) { return this . extension ; } // -- string get extension ( )
public int get tag ( ) { return tag ; }
public int get tag ( ) { return tag ; }
public static class loader get class loader a privileged ( final class clazz ) { if ( ! has_get_class_loader_permission ) return null ; else return access controller . do privilege ( new privilege action < class loader > ( ) { public class loader run ( ) { return clazz . get class loader ( ) ; } } ) ; }
public json object set ( string name , string value ) { set ( name , json . value ( value ) ) ; return this ; }
public byte [ ] array ( ) { return value ; }
public void start ( ) { }
public string get object name ( ) { return this . object name ; }
public static json value value ( int value ) { return new json number ( integer . to string ( value , 10 ) ) ; }
public json object set ( string name , string value ) { set ( name , json . value ( value ) ) ; return this ; }
public void set member ( final i member [ ] member ) { assert . be not null ( member ) ; f members= member ; }
public boolean be value set ( ) { return false ; }
public float float value ( ) { return ( ( float ) numerator ) / ( ( float ) denominator ) ; }
public static void print ( object o , java . io . writer writer , boolean typeheader ) throw i o exception { if ( o == null ) { if ( typeheader ) writer . write ( `` null object\n `` ) ; writer . write ( `` null\n `` ) ; writer . flush ( ) ; return ; } class < ? > arraytype = o . get class ( ) . get component type ( ) ; if ( arraytype ! = null ) { if ( typeheader ) writer . write ( `` array of `` + arraytype+ `` \n `` ) ; if ( ! arraytype . be primitive ( ) ) { writer . write ( array . deep to string ( ( object [ ] ) o ) ) ; writer . write ( `` \n `` ) ; } else if ( arraytype . equal ( integer . type ) ) { writer . write ( array . to string ( ( int [ ] ) o ) ) ; writer . write ( `` \n `` ) ; } else if ( arraytype . equal ( double . type ) ) { writer . write ( array . to string ( ( double [ ] ) o ) ) ; writer . write ( `` \n `` ) ; } else if ( arraytype . equal ( boolean . type ) ) { writer . write ( array . to string ( ( boolean [ ] ) o ) ) ; writer . write ( `` \n `` ) ; } else if ( arraytype . equal ( short . type ) ) { writer . write ( array . to string ( ( short [ ] ) o ) ) ; writer . write ( `` \n `` ) ; } else if ( arraytype . equal ( long . type ) ) { writer . write ( array . to string ( ( long [ ] ) o ) ) ; writer . write ( `` \n `` ) ; } else if ( arraytype . equal ( float . type ) ) { writer . write ( array . to string ( ( float [ ] ) o ) ) ; writer . write ( `` \n `` ) ; } else if ( arraytype . equal ( character . type ) ) { writer . write ( array . to string ( ( char [ ] ) o ) ) ; writer . write ( `` \n `` ) ; } else if ( arraytype . equal ( byte . type ) ) { writer . write ( array . to string ( ( byte [ ] ) o ) ) ; writer . write ( `` \n `` ) ; } else { writer . write ( `` ? ? ? ? ? ? ? ? ? \n `` ) ; } } else if ( o instanceof set ) { @ suppress warning ( `` unchecked `` ) set < object > set = ( set < object > ) o ; array list < string > list=new array list < string > ( set . size ( ) ) ; for ( object obj : set ) { list . add ( obj . to string ( ) ) ; } collection . sort ( list ) ; if ( typeheader ) { writer . write ( o . get class ( ) . get name ( ) ) ; writer . write ( `` \n `` ) ; } writer . write ( list . to string ( ) ) ; writer . write ( `` \n `` ) ; } else if ( o instanceof map ) { @ suppress warning ( `` unchecked `` ) map < object , object > map= ( map < object , object > ) o ; array list < string > list=new array list < string > ( map . size ( ) ) ; for ( object key : map . key set ( ) ) { list . add ( key . to string ( ) + `` = `` +map . get ( key ) ) ; } collection . sort ( list ) ; if ( typeheader ) { writer . write ( o . get class ( ) . get name ( ) ) ; writer . write ( `` \n `` ) ; } writer . write ( list . to string ( ) ) ; writer . write ( `` \n `` ) ; } else if ( o instanceof collection ) { if ( typeheader ) { writer . write ( o . get class ( ) . get name ( ) ) ; writer . write ( `` \n `` ) ; } writer . write ( o . to string ( ) ) ; writer . write ( `` \n `` ) ; } else if ( o instanceof string ) { if ( typeheader ) writer . write ( `` string\n `` ) ; writer . write ( o . to string ( ) ) ; writer . write ( `` \n `` ) ; } else if ( o instanceof java . util . calendar ) { if ( typeheader ) writer . write ( `` java . util . calendar\n `` ) ; date format f = date format . get date time instance ( date format . medium , date format . medium , locale . uk ) ; calendar c = ( calendar ) o ; writer . write ( f . format ( c . get time ( ) ) + `` millisec= `` + c . get ( calendar . millisecond ) + `` \n `` ) ; } else { if ( typeheader ) { writer . write ( o . get class ( ) . get name ( ) ) ; writer . write ( `` \n `` ) ; } writer . write ( o . to string ( ) ) ; writer . write ( `` \n `` ) ; } writer . flush ( ) ; }
public final column definition column ( ) { return column ; }
public static long leq ( long value ) { return report matcher ( new less or equal < long > ( value ) ) . return zero ( ) ; }
public static long leq ( long value ) { return report matcher ( new less or equal < long > ( value ) ) . return zero ( ) ; }
public static long lt ( long value ) { return report matcher ( new less than < long > ( value ) ) . return zero ( ) ; }
public static long lt ( long value ) { return report matcher ( new less than < long > ( value ) ) . return zero ( ) ; }
public static int lt ( int value ) { return report matcher ( new less than < integer > ( value ) ) . return zero ( ) ; }
public static < t > t eq ( t value ) { return ( t ) report matcher ( new equal ( value ) ) . < t > return for ( value ) ; }
public static char or ( char first , char second ) { return mock progress . get argument matcher storage ( ) . report or ( ) . return char ( ) ; }
public static double leq ( double value ) { return report matcher ( new less or equal < double > ( value ) ) . return zero ( ) ; }
public static char and ( char first , char second ) { return mock progress . get argument matcher storage ( ) . report and ( ) . return char ( ) ; }
public static double or ( double first , double second ) { return mock progress . get argument matcher storage ( ) . report or ( ) . return zero ( ) ; }
public static double eq ( double value , double delta ) { report matcher ( new equal with delta ( value , delta ) ) ; return 0 ; }
public string get description ( ) { return description ; }
public boolean be enable ( ) { return true ; }
public annotation value builder < t > member ( @ non null string name , @ nullable annotation class value < ? > . . . class value ) { if ( class value ! = null ) { value . put ( name , class value ) ; } return this ; }
public int get position ( ) { return position ; }
public void on frame ( frame frame ) { / * ignore in jsr-356 * / }
public abstract insn node [ ] to array ( ) { int current insn index = 0 ; abstract insn node current insn = first insn ; abstract insn node [ ] insn node array = new abstract insn node [ size ] ; while ( current insn ! = null ) { insn node array [ current insn index ] = current insn ; current insn . index = current insn index++ ; current insn = current insn . next insn ; } return insn node array ; }
public string get method call syntax ( string obj , string m , string . . . args ) { string builder buf = new string builder ( ) ; buf . append ( `` $ { `` ) ; buf . append ( obj ) ; buf . append ( `` . `` ) ; buf . append ( m ) ; buf . append ( `` ( `` ) ; if ( args . length ! = 0 ) { int i = 0 ; for ( ; i < args . length - 1 ; i++ ) { buf . append ( `` $ `` ) . append ( args [ i ] ) ; buf . append ( `` , `` ) ; } buf . append ( `` $ `` ) . append ( args [ i ] ) ; } buf . append ( `` ) } `` ) ; return buf . to string ( ) ; }
public void set class loader ( class loader class loader ) { this . class loader = class loader ; }
public void add callback ( runnable callback ) { if ( callback ! = null ) delegate . add callback ( callback ) ; }
public static void quick sort ( final boolean [ ] x ) { quick sort ( x , 0 , x . length ) ; }
public static boolean any boolean ( ) { return report matcher ( any . any ) . return false ( ) ; }
public static < t > t [ ] ary eq ( t [ ] value ) { return report matcher ( new array equal ( value ) ) . return null ( ) ; }
public void execute ( ) throw build exception { validate ( ) ; resource s = get src resource ( ) ; if ( ! s . be exists ( ) ) { log ( `` nothing to do : `` + s . to string ( ) + `` do n't exist . `` ) ; } else if ( zip file . last modified ( ) < s . get last modified ( ) ) { log ( `` building : `` + zip file . get absolute path ( ) ) ; pack ( ) ; } else { log ( `` nothing to do : `` + zip file . get absolute path ( ) + `` be up to date . `` ) ; } }
public int next int ( int least , int bound ) { if ( least > = bound ) { throw new illegal argument exception ( ) ; } return next int ( bound - least ) + least ; }
public static < t > answer < t > delegate to ( object delegate ) { return ( answer < t > ) new forward invocation ( delegate ) ; }
public string to string ( ) { if ( stack trace == null ) { return super . to string ( ) ; } return stack trace ; }
public static < t > matcher < t > be in ( t [ ] element ) { return in ( element ) ; }
public static void replay ( object . . . mock ) { for ( object mock : mock ) { get control ( mock ) . replay ( ) ; } }
public static instance field declare field of ( object instance ) { list < instance field > instance field = new array list < instance field > ( ) ; instance field . add all ( instance field in ( instance , instance . get class ( ) . get declared field ( ) ) ) ; return new instance field ( instance , instance field ) ; }
public field get field ( ) { return field ; }
public static instance field declare field of ( object instance ) { list < instance field > instance field = new array list < instance field > ( ) ; instance field . add all ( instance field in ( instance , instance . get class ( ) . get declared field ( ) ) ) ; return new instance field ( instance , instance field ) ; }
public static set any set ( ) { return report matcher ( any . any ) . return set ( ) ; }
public static short eq ( short value ) { report matcher ( new equal ( value ) ) ; return 0 ; }
public static byte byte that ( matcher < byte > matcher ) { report matcher ( matcher ) ; return 0 ; }
public static < t > t min ( collection < t > item ) { t answer = null ; for ( t value : item ) { if ( value ! = null ) { if ( answer == null || script bytecode adapter . compare less than ( value , answer ) ) { answer = value ; } } } return answer ; }
public static boolean any boolean ( ) { return report matcher ( any . any ) . return false ( ) ; }
public byte to byte ( ) { return new byte ( byte value ( ) ) ; }
public static long long that ( matcher < long > matcher ) { return report matcher ( matcher ) . return zero ( ) ; }
public boolean be want client auth ( ) { return want client auth ; }
public unused stubbings get unused stubbings ( iterable < object > mock ) { set < stub > stubbings = all invocation finder . find stubbings ( mock ) ; list < stub > unused = filter ( stubbings , new filter < stub > ( ) { public boolean be out ( stub s ) { return s . be use ( ) ; } } ) ; return new unused stubbings ( unused ) ; }
public void set cache stub ( boolean cache stub ) { this . cache stub = cache stub ; }
public string get description ( ) { return description ; }
public void add callback ( runnable callback ) { if ( callback ! = null ) delegate . add callback ( callback ) ; }
public void set port ( int port ) { this . port = port ; }
public boolean be stop ( ) { return stop ; }
public http request base get http request ( ) { return http request ; }
public long get delay ( ) { return delay millis ; }
public http request base get http request ( ) { return http request ; }
public body type get body type ( ) { return this . body type ; }
public void set header name ( string header name ) { assert . have length ( header name , `` header name ca n't be null `` ) ; this . header name = header name ; }
public cooky get cooky ( ) { return cooky ; }
public template [ ] get template ( ) { return get template ( null ) ; }
public string get condition ( ) { return condition ; }
public executor get resolver executor ( ) { return default executor ; }
public uni on item delay < t > on executor ( schedule executor service executor ) { this . executor = non null ( executor , `` executor `` ) ; return this ; }
public void set producer ( producer < t > producer ) { this . producer = producer ; }
public signature visitor visit class bound ( ) { return this ; }
public int get invoke dynamic bootstrap ( int index ) { invoke dynamic info iv = ( invoke dynamic info ) get item ( index ) ; return iv . bootstrap ; }
public void visit int insn ( final int opcode , final int operand ) { if ( mv ! = null ) { mv . visit int insn ( opcode , operand ) ; } }
public static < a extend annotation > list < a > get repeatable annotation ( method method , class < a > annotation class ) { a [ ] annotation = method . get annotation by type ( annotation class ) ; if ( annotation == null || annotation . length == 0 ) { for ( annotation meta annotation : method . get annotation ( ) ) { annotation = meta annotation . annotation type ( ) . get annotation by type ( annotation class ) ; if ( annotation ! = null & & annotation . length > 0 ) { return array . a list ( annotation ) ; } } method superclass method = get overridden method ( method ) ; if ( superclass method ! = null ) { return get repeatable annotation ( superclass method , annotation class ) ; } } if ( annotation == null ) { return null ; } return array . a list ( annotation ) ; }
static public int swap int ( int i ) { return ( ( i & 0x f f ) < < 24 ) | ( ( i & 0x f f00 ) < < 8 ) | ( ( i & 0x f f0000 ) > > 8 ) | ( ( i > > 24 ) & 0x f f ) ; }
public int get super type index ( ) { return ( short ) ( ( value & 0x00 f f f f00 ) > > 8 ) ; }
public printer visit try catch annotation ( final int type ref , final type path type path , final string desc , final boolean visible ) { throw new runtime exception ( `` must be overriden `` ) ; }
public void visit parameter ( string name , int access ) { throw new runtime exception ( `` must be overriden `` ) ; }
public object eval ( string expression ) { return get value ( expression , object . class ) ; }
public object eval ( string expression ) { return get value ( expression , object . class ) ; }
public void set object factory ( object factory object factory ) { this . object factory = object factory ; }
public void set method ( int method ) { this . method = method ; }
public final string get line ( int line i ) { return line . get ( line i ) ; }
protected factory bean < ? > get factory bean ( string bean name , object bean instance ) throw bean exception { if ( ! ( bean instance instanceof factory bean ) ) { throw new bean creation exception ( bean name , `` bean instance of type [ `` + bean instance . get class ( ) + `` ] be not a factory bean `` ) ; } return ( factory bean < ? > ) bean instance ; }
public period to period ( ) { return new period ( this ) ; }
public string get action ( ) { return action ; }
public static void set dir ( string dir name ) { set dir ( new file ( dir name ) ) ; }
public string identifier ( ) { return identifier ; }
public void set cache store hash ( int cache store hash ) { this . cache store hash = cache store hash ; }
public int get cache store remove item ( ) { if ( cache store remove item < 0 ) { return 0 ; } return cache store remove item ; }
public retry policy get retry policy ( ) { return retry policy . get ( ) ; }
public period to period ( ) { return new period ( this ) ; }
public void set transaction manager ( @ nullable transaction manager transaction manager ) { this . transaction manager = transaction manager ; }
public void set module ( final list < module > module ) { this . module = module ; }
public void set file ( file file ) { this . file = file ; }
public static void set default pool ( buffer pool pool ) { if ( pool == null ) { throw new illegal argument exception ( `` pool be null `` ) ; } default pool = pool ; }
public int get min length ( ) { return min length ; }
public string get prefix ( ) { return prefix ; }
public string get extension ( ) { return this . extension ; } // -- string get extension ( )
public file get store dir ( ) { return this . store dir ; }
public boolean be sync ( ) { return sync ; }
public string get content type ( ) { return _type ; }
public int length ( object obj ) { if ( be array ( obj ) ) { return ( ( list ) obj ) . size ( ) ; } else if ( be map ( obj ) ) { return get property key ( obj ) . size ( ) ; } else if ( obj instanceof string ) { return ( ( string ) obj ) . length ( ) ; } throw new json path exception ( `` length operation can not be apply to `` + obj ! =null ? obj . get class ( ) . get name ( ) : `` null `` ) ; }
public object lookup ( final string name ) throw name exception { if ( logger . be debug enable ( ) ) { logger . debug ( `` look up jndi object with name [ `` + name + `` ] `` ) ; } return execute ( new jndi callback < object > ( ) { @ override public object do in context ( context ctx ) throw name exception { object locate = ctx . lookup ( name ) ; if ( locate == null ) { throw new name not find exception ( `` jndi object with [ `` + name + `` ] not find : jndi implementation return null `` ) ; } return locate ; } } ) ; }
public context support get context support ( ) { return this . context support ; }
public void set xa resource map class name ( list < string > xa resource map class name ) { synchronize ( this ) { if ( xa resource map class name == null ) { this . xa resource map = null ; this . xa resource map class name = new array list < string > ( ) ; } else if ( ! xa resource map class name . equal ( this . xa resource map class name ) ) { this . xa resource map = null ; this . xa resource map class name = new array list < string > ( xa resource map class name ) ; } } }
protect final boolean be rollback ( test context test context ) throw exception { boolean rollback = be default rollback ( test context ) ; rollback rollback annotation = annotate element utils . find merged annotation ( test context . get test method ( ) , rollback . class ) ; if ( rollback annotation ! = null ) { boolean rollback override = rollback annotation . value ( ) ; if ( logger . be debug enable ( ) ) { logger . debug ( string . format ( `` method-level @ rollback ( % s ) override default rollback [ % s ] for test context % s . `` , rollback override , rollback , test context ) ) ; } rollback = rollback override ; } else { if ( logger . be debug enable ( ) ) { logger . debug ( string . format ( `` no method-level @ rollback override : use default rollback [ % s ] for test context % s . `` , rollback , test context ) ) ; } } return rollback ; }
public string get transaction synchronization registry j n d i context ( ) { return transaction synchronization registry j n d i context ; }
public void set transaction manager j n d i context ( string transaction manager j n d i context ) { this . transaction manager j n d i context = transaction manager j n d i context ; }
public list < string > get xa resource orphan filter class name ( ) { synchronize ( this ) { return new array list < string > ( xa resource orphan filter class name ) ; } }
public static string get class file name ( class < ? > clazz ) { assert . not null ( clazz , `` class must not be null `` ) ; string class name = clazz . get name ( ) ; int last dot index = class name . last index of ( package_separator ) ; return class name . substring ( last dot index + 1 ) + class_file_suffix ; }
public void set commit markable resource j n d i name ( list < string > commit markable resource j n d i name ) { synchronize ( this ) { if ( commit markable resource j n d i name == null ) { this . commit markable resource j n d i name = new array list < string > ( ) ; } else if ( ! commit markable resource j n d i name . equal ( this . commit markable resource j n d i name ) ) { this . commit markable resource j n d i name = new array list < string > ( commit markable resource j n d i name ) ; } } }
public list < string > get commit markable resource j n d i name ( ) { synchronize ( this ) { return new array list < string > ( commit markable resource j n d i name ) ; } }
public void set recovery module class name ( list < string > recovery module class name ) { synchronize ( this ) { if ( recovery module class name == null ) { this . recovery module = new array list < recovery module > ( ) ; this . recovery module class name = new array list < string > ( ) ; } else if ( ! recovery module class name . equal ( this . recovery module class name ) ) { this . recovery module = null ; this . recovery module class name = new array list < string > ( recovery module class name ) ; } } }
public string get transaction synchronization registry j n d i context ( ) { return transaction synchronization registry j n d i context ; }
public object get attribute ( string key ) { return attribute . get ( key ) ; }
public void set property ( final string property ) { this . property name = property ; }
public void error ( s a x parse exception exception ) throw s a x exception { throw exception ; }
public string get transaction synchronization registry j n d i context ( ) { return transaction synchronization registry j n d i context ; }
public void rollback ( xid xid ) throw x a exception { if ( be debug enabled ( ) ) { debug code ( `` rollback ( `` + jdbc xid . to string ( xid ) + `` ) ; `` ) ; } try { physical conn . rollback ( ) ; physical conn . set auto commit ( true ) ; if ( prepared ) { statement stat = null ; try { stat = physical conn . create statement ( ) ; stat . execute ( `` rollback transaction `` + jdbc xid . to string ( xid ) ) ; } finally { jdbc utils . close silently ( stat ) ; } prepare = false ; } } catch ( s q l exception e ) { throw convert exception ( e ) ; } current transaction = null ; }
public void set logger ( log logger ) { this . logger = logger ; }
public void set transaction manager ( @ nullable transaction manager transaction manager ) { this . transaction manager = transaction manager ; }
public void end c d a t a ( augmentation augs ) throw x n i exception { if ( f document handler ! = null ) { f document handler . end c d a t a ( aug ) ; } } // end c d a t a ( augmentation )
public void start c d a t a ( augmentation augs ) throw x n i exception { if ( f document handler ! = null ) { f document handler . start c d a t a ( aug ) ; } } // start c d a t a ( augmentation )
public void set feature ( feature map feature ) { this . feature = feature ; } // set feature ( )
protect printer get printer ( printer configuration config ) { printer printer = get printer ( ) . set configuration ( config ) ; printer ( printer ) ; return printer ; }
public void add source ( input stream source ) { source . add ( source ) ; }
public string get name ( ) { return ( string ) get value ( name ) ; }
public final string get string value ( ) { return get string value c s ( ) . to string ( ) ; }
public static double get double ( byte [ ] data ) { return double . long bit to double ( get long ( data , 0 ) ) ; }
public byte [ ] get buffer ( ) { return buf ; }
public void set cache size ( int cache size ) { this . cache size = cache size ; }
public int num direct arena ( ) { return direct arena metric . size ( ) ; }
public int num heap arena ( ) { return heap arena metric . size ( ) ; }
public void set c ( p d action c ) { action . set item ( c o s name . c , c ) ; }
public static list < cookie > parse all ( http url url , header header ) { list < string > cookie string = header . value ( `` set- cookie `` ) ; list < cookie > cooky = null ; for ( int i = 0 , size = cookie string . size ( ) ; i < size ; i++ ) { cookie cookie = cookie . parse ( url , cookie string . get ( i ) ) ; if ( cookie == null ) continue ; if ( cooky == null ) cookies = new array list < > ( ) ; cooky . add ( cookie ) ; } return cooky ! = null ? collection . unmodifiable list ( cooky ) : collection . < cookie > empty list ( ) ; }
public int get origin ( ) { return origin ; }
public credential scope get credential scope ( ) { return credential scope ; }
public void set allow header ( @ nullable list < string > allow header ) { if ( allow header ! = null ) { this . allow header = allow header ; } }
public void set cors ( cors configuration cors ) { this . cors = cors ; }
public void set method ( int method ) { this . method = method ; }
public header [ ] get request header ( ) { return get request header group ( ) . get all header ( ) ; }
public option set short name ( string short name ) { this . short name = short name ; return this ; }
public string to string ( ) { return name ; }
public content type get type ( ) { return type ; }
public void set output threshold ( long threshold ) { this . threshold = threshold ; }
public void add file ( collection < string > file ) { check file name ( file ) ; set file . add all ( file ) ; }
public static string reduce lead slash ( final string path ) { int length ; if ( path == null || ( length = path . length ( ) ) == 0 ) { return path ; } int start = 0 ; while ( start ! = length & & `` / `` . index of ( path . char at ( start ) ) ! = -1 ) { start++ ; } return path . substring ( start > 0 ? start - 1 : 0 ) ; }
public type component ( ) { return component ; }
public int get payload length ( ) { return last payload length ; }
public boolean be enforce ( ) { return enforce ; }
public void set request header size ( int request header size ) { _request header size = request header size ; }
public boolean be stream ( ) { return this . entry instanceof c o s stream ; }
public boolean be flag set ( short mask ) { return ( value & mask ) ! = 0 ; }
public http2 flag set flag ( boolean on , short mask ) { if ( on ) { value |= mask ; } else { value & = ~mask ; } return this ; }
public byte to byte ( ) { return new byte ( byte value ( ) ) ; }
public void start ( ) throw exception { start ( false ) ; }
public static type resolve member ( class < ? > topclass , type look for type , class < ? > declare class ) { map < string , type > type argument = type from sub class to declare class ( topclass , declare class ) ; if ( type argument == null ) return look for type ; if ( look for type instanceof parameterized type ) { return fix type variable ( ( parameterized type ) look for type , type argument ) ; } if ( look for type instanceof generic array type ) { return fix generic array type variable ( ( generic array type ) look for type , type argument ) ; } if ( ! ( look for type instanceof type variable ) ) { return look for type ; } type variable < ? > tv = ( type variable < ? > ) look for type ; string type variable name = tv . get name ( ) ; type ret val = type argument . get ( type variable name ) ; if ( ret val == null ) return look for type ; if ( ret val instanceof class ) return ret val ; if ( ret val instanceof parameterized type ) { return fix type variable ( ( parameterized type ) ret val , type argument ) ; } if ( ret val instanceof generic array type ) { return fix generic array type variable ( ( generic array type ) ret val , type argument ) ; } return ret val ; }
public composable with assigner ( assigner assigner , assigner . type type ) { return new method call ( method locator , target handler , argument loader , method invoker , termination handler , assigner , type ) ; }
public implementation . composable with assigner ( assigner assigner , assigner . type type ) { return new invoke dynamic ( bootstrap method , handle argument , invocation provider , termination handler , assigner , type ) ; }
public predicate < ? super e > get predicate ( ) { return predicate ; }
public zip entry source get zip archive ( ) { return zip archive ; }
public string get validator class ( ) { return validator class ; }
public int num curve ( ) { return curve bag . size ( ) ; }
public static double distance ( double [ ] p1 , double [ ] p2 ) { double sum = 0 ; for ( int i = 0 ; i < p1 . length ; i++ ) { final double dp = p1 [ i ] - p2 [ i ] ; sum += dp * dp ; } return math . sqrt ( sum ) ; }
public double dot product ( final vector v ) { return this . x * v . x + this . y * v . y + this . z * v . z ; }
public field vector3 d < t > add ( final field vector3 d < t > v ) { return new field vector3 d < t > ( x . add ( v . x ) , y . add ( v . y ) , z . add ( v . z ) ) ; }
public final string get line ( int line i ) { return line . get ( line i ) ; }
public t [ ] to array ( ) { final t [ ] array = math array . build array ( x . get field ( ) , 3 ) ; array [ 0 ] = x ; array [ 1 ] = y ; array [ 2 ] = z ; return array ; }
public void set method ( int method ) { this . method = method ; }
public object response ( ) { return response ; }
public static reader get url a reader ( string url string ) throw i o exception { reader reader ; if ( charset == null ) { reader = new input stream reader ( get url a stream ( url string ) ) ; } else { reader = new input stream reader ( get url a stream ( url string ) , charset ) ; } return reader ; }
public void set minor version ( int minor version ) { this . minor version = minor version ; }
public folder id add ( well know folder name folder name ) { folder id folder id = new folder id ( folder name ) ; if ( this . contains ( folder id ) ) { throw new illegal argument exception ( `` the id be already in the list . `` ) ; } this . internal add ( folder id ) ; return folder id ; }
public void end unsubscribe ( i async result async result ) throw exception { unsubscribe request request = async request result . extract service request ( this , async result ) ; request . end execute ( async result ) ; }
public void set id ( string id ) { this . id = id ; }
public void set user ( string user ) { debug code call ( `` set user `` , user ) ; this . user name = user ; }
public boolean be property updated ( property definition property definition ) { return this . modified property . contains ( property definition ) || this . added property . contains ( property definition ) ; }
public void end unsubscribe ( i async result async result ) throw exception { unsubscribe request request = async request result . extract service request ( this , async result ) ; request . end execute ( async result ) ; }
public folder id get parent folder id ( ) throw service local exception { return get property bag ( ) . get object from property definition ( folder schema . parent folder id ) ; }
protected item id get item id ( ) { return this . item id ; }
public final boolean be subscription dispose ( ) { return outbound_close . get ( this ) == operator . cancel subscription ( ) ; }
protect void validate add delegate ( ) throw service validation exception { for ( delegate folder permission delegate folder permission : this . delegate folder permission . value ( ) ) { if ( delegate folder permission . get permission level ( ) == delegate folder permission level . custom ) { throw new service validation exception ( `` this operation ca n't be perform because one or more folder `` + `` permission level be set to custom . `` ) ; } } }
public folder id get parent folder id ( ) { return this . parent folder id ; }
public collection < day of the week > get day of the week ( ) { return day of the week ; }
public void set absolute date ( date absolute date ) { this . absolute date = absolute date ; if ( absolute date ! = null ) { this . recurrence = null ; } }
public property set get property set ( ) { return this . property set ; }
public final t get ( string name ) { int idx = find ( name ) ; return 0 < = idx ? get ( idx ) : null ; }
public sort definition get sort ( ) { return this . sort ; }
protect void index node ( node node ) { list < node > nod = node name to node . get ( node . get x path node name ( ) ) ; if ( node ! = null ) { node . add ( node ) ; } }
public static user group information get remote user ( ) { call call = cur call . get ( ) ; return ( call ! = null & & call . connection ! = null ) ? call . connection . user : null ; }
public version get version ( ) { return version ; }
public void set creator ( final list < string > creator ) { creator = creator ; }
public static cascade style get cascade style ( string cascade ) { cascade style style = style . get ( cascade ) ; if ( style == null ) { throw new map exception ( `` unsupported cascade style : `` + cascade ) ; } else { return style ; } }
public final share session contract implementor get session ( ) { return session ; }
public static string collection ( collection < ? > collection ) { if ( collection == null ) { return null_string ; } return array ( collection . to array ( new object [ collection . size ( ) ] ) ) ; }
public void set member ( final i member [ ] member ) { assert . be not null ( member ) ; f members= member ; }
public class < ? > find serialization type ( annotate a ) { return null ; }
public void add property ( string property name , object value ) { list < object > property list = property . get ( property name ) ; if ( property list == null ) { property list = new array list < object > ( ) ; property . put ( property name , property list ) ; } property list . add ( value ) ; }
public void set creator ( final list < string > creator ) { creator = creator ; }
public object deserialize from boolean ( json parser p , deserialization context ctxt ) throw i o exception { json deserializer < object > delegate deser = _delegate deserializer ( ) ; if ( delegate deser ! = null ) { if ( ! _value instantiator . can create from boolean ( ) ) { object bean = _value instantiator . create use delegate ( ctxt , delegate deser . deserialize ( p , ctxt ) ) ; if ( _injectables ! = null ) { inject value ( ctxt , bean ) ; } return bean ; } } boolean value = ( p . get current token ( ) == json token . value_true ) ; return _value instantiator . create from boolean ( ctxt , value ) ; }
protect object deserialize with object id ( json parser p , deserialization context ctxt ) throw i o exception { return deserialize from object ( p , ctxt ) ; }
public class get type ( ) { return ( this . type ) ; }
public date get date ( property property ) { if ( property . get primary property ( ) . get property type ( ) ! = property . property type . simple ) { return null ; } if ( property . get primary property ( ) . get value type ( ) ! = property . value type . date ) { return null ; } string v = get ( property ) ; if ( v ! = null ) { return parse date ( v ) ; } else { return null ; } }
public json serializer < ? > get key serializer ( ) { return _key serializer ; }
public json serializer < object > find null value serializer ( bean property property ) throw json map exception { return _null value serializer ; }
public boolean be low bound ( ) { return ! be upper bound ( ) ; }
public final serializer factory with serializer modifier ( bean serializer modifier modifier ) { return with config ( get config ( ) . with serializer modifier ( modifier ) ) ; }
public load configuration builder preload schema ( final json node schema ) { final json node node = schema . path ( `` id `` ) ; bundle . check argument ( node . be textual ( ) , `` load cfg . no i d in schema `` ) ; return preload schema ( node . text value ( ) , schema ) ; }
public symbol reference < ? extend resolve value declaration > solve symbol in type ( resolve type declaration type declaration , string name ) { if ( type declaration instanceof java parser class declaration ) { context ctx = ( ( java parser class declaration ) type declaration ) . get context ( ) ; return ctx . solve symbol ( name ) ; } if ( type declaration instanceof java parser interface declaration ) { context ctx = ( ( java parser interface declaration ) type declaration ) . get context ( ) ; return ctx . solve symbol ( name ) ; } if ( type declaration instanceof java parser enum declaration ) { context ctx = ( ( java parser enum declaration ) type declaration ) . get context ( ) ; return ctx . solve symbol ( name ) ; } if ( type declaration instanceof reflection class declaration ) { return ( ( reflection class declaration ) type declaration ) . solve symbol ( name , type solver ) ; } if ( type declaration instanceof reflection interface declaration ) { return ( ( reflection interface declaration ) type declaration ) . solve symbol ( name , type solver ) ; } if ( type declaration instanceof reflection enum declaration ) { resolve enum constant declaration red = ( ( reflection enum declaration ) type declaration ) . get enum constant ( name ) ; return symbol reference . solve ( red ) ; } if ( type declaration instanceof javassist class declaration ) { return ( ( javassist class declaration ) type declaration ) . solve symbol ( name , type solver ) ; } if ( type declaration instanceof javassist enum declaration ) { return ( ( javassist enum declaration ) type declaration ) . solve symbol ( name , type solver ) ; } if ( type declaration instanceof javassist interface declaration ) { return ( ( javassist interface declaration ) type declaration ) . solve symbol ( name , type solver ) ; } return symbol reference . unsolved ( resolve value declaration . class ) ; }
public indent type get indent type ( ) { return get indentation ( ) . get type ( ) ; }
public set < configuration option > get ( ) { return default option ; }
protect node find contain type decl or object creation expr ( node node , string class name ) { node parent = node ; boolean detach flag = false ; while ( true ) { parent = demand parent node ( parent ) ; if ( parent instanceof body declaration ) { if ( parent instanceof type declaration & & ( ( type declaration < ? > ) parent ) . get fully qualify name ( ) . get ( ) . end with ( class name ) ) { return parent ; } else { detach flag = true ; } } else if ( parent instanceof object creation expr ) { if ( detach flag ) { return parent ; } } } }
protect node find contain type decl or object creation expr ( node node ) { node parent = node ; boolean detach flag = false ; while ( true ) { parent = demand parent node ( parent ) ; if ( parent instanceof body declaration ) { if ( parent instanceof type declaration ) { return parent ; } else { detach flag = true ; } } else if ( parent instanceof object creation expr ) { if ( detach flag ) { return parent ; } } } }
public resolve value declaration resolve ( ) { return get symbol resolver ( ) . resolve declaration ( this , resolve value declaration . class ) ; }
protect final void set state internal ( final h a context context , final h a state s ) throw service fail exception { prepare to exit state ( context ) ; s . prepare to enter state ( context ) ; context . write lock ( ) ; try { exit state ( context ) ; context . set state ( s ) ; s . enter state ( context ) ; s . update last h a transition time ( ) ; } finally { context . write unlock ( ) ; } }
public schema get schema ( ) { return schema ; }
public void set configuration ( configuration configuration ) { this . configuration = configuration ; }
public transformer get transformer ( ) { return i transformer ; }
public string get proxy ( ) { return proxy ; }
public artifact repository get repository ( ) { return repository ; }
public stream priority set dependency ( int dependency ) { this . dependency = dependency ; return this ; }
public void set factory ( j d o m factory factory ) { this . factory = factory ; }
public channel id get channel id ( ) { return this . channel id ; }
public http header get header ( ) { return this . header ; }
public final void remove ( ) { remove ( internal thread local map . get if set ( ) ) ; }
public void trace ( string format , object arg ) { if ( be trace enable ( ) ) { format tuple ft = message formatter . format ( format , arg ) ; logger . log ( fqcn , trace capable ? level . trace : level . debug , ft . get message ( ) , ft . get throwable ( ) ) ; } }
public void fine ( string msg ) { log ( level . fine , msg ) ; }
public void debug ( string msg , throwable t ) { if ( logger . be loggable ( level . fine ) ) { log ( self , level . fine , msg , t ) ; } }
public void trace ( string format , object arg ) { if ( logger . be loggable ( level . fine ) ) { format tuple ft = message formatter . format ( format , arg ) ; log ( self , level . fine , ft . get message ( ) , ft . get throwable ( ) ) ; } }
public void trace ( string format , object arg ) { if ( be trace enable ( ) ) { format tuple ft = message formatter . format ( format , arg ) ; logger . log ( fqcn , trace capable ? level . trace : level . debug , ft . get message ( ) , ft . get throwable ( ) ) ; } }
public void set msg ( string msg ) { this . msg = msg ; }
public static boolean be not empty ( object [ ] array ) { return ( array ! = null & & array . length ! = 0 ) ; }
public jackson2 object mapper builder default use wrapper ( boolean default use wrapper ) { this . default use wrapper = default use wrapper ; return this ; }
public short get alignment ( ) { return alignment ; }
public j type var bound ( j class c ) { if ( bound ! =null ) throw new illegal argument exception ( `` type variable have an exist class bound `` +bound ) ; bind = c ; return this ; }
public final void set thread local map ( internal thread local map thread local map ) { this . thread local map = thread local map ; }
public void set ticket key ( open ssl session ticket key . . . key ) { object util . check not null ( key , `` key `` ) ; session ticket key [ ] ticket key = new session ticket key [ key . length ] ; for ( int i = 0 ; i < ticket key . length ; i++ ) { ticket key [ i ] = key [ i ] . key ; } lock writer lock = context . ctx lock . write lock ( ) ; writer lock . lock ( ) ; try { s s l context . clear option ( context . ctx , ssl . ssl_op_no_ticket ) ; if ( ticket key . length > 0 ) { s s l context . set session ticket key ( context . ctx , ticket key ) ; } } finally { writer lock . unlock ( ) ; } }
public static x509 trust manager get accept all trust manager ( ) { return accept_all ; }
public void set read timeout ( int read timeout ) { this . read timeout = read timeout ; }
public long get offset ( ) { return offset ; }
public long ticket key new ( ) { lock reader lock = context . ctx lock . read lock ( ) ; reader lock . lock ( ) ; try { return s s l context . session ticket key new ( context . ctx ) ; } finally { reader lock . unlock ( ) ; } }
public boolean be empty ( ) { return empty ; }
public string get name ( ) { return name ; }
public void set provider ( string provider ) { this . provider = provider ; }
public static secret key to a e s key ( final secret key secret key ) { if ( secret key == null ) { return null ; } return new secret key spec ( secret key . get encoded ( ) , `` aes `` ) ; }
public void set algorithm ( string algorithm ) { this . algorithm = algorithm ; }
public j w s algorithm get request object j w s alg ( ) { return request object j w s alg ; }
public static boolean be support ( final j w s algorithm alg ) { if ( alg . get name ( ) . equal ( algorithm . none . get name ( ) ) ) { return true ; } for ( provider p : security . get provider ( ) ) { if ( be support ( alg , p ) ) { return true ; } } return false ; }
public void set provider ( string provider ) { this . provider = provider ; }
public void set encrypt spill key ( byte [ ] encrypt spill key ) { if ( encrypt spill key ! = null ) { this . encrypt spill key = encrypt spill key ; } }
public tag get tag ( ) { return this . tag ; }
public final static int murmur hash3 ( int x ) { x ^= x > > > 16 ; x * = 0x85ebca6b ; x ^= x > > > 13 ; x * = 0xc2b2ae35 ; x ^= x > > > 16 ; return x ; }
public output < integer > size ( ) { return size ; }
public j w k set to public j w k set ( ) { list < jwk > public key list = new link list < > ( ) ; for ( jwk key : key ) { jwk public key = key . to public j w k ( ) ; if ( public key ! = null ) { public key list . add ( public key ) ; } } return new j w k set ( public key list , custom member ) ; }
public list < jwk > select ( final j w k set jwk set ) { list < jwk > select key = new link list < > ( ) ; if ( jwk set == null ) return select key ; for ( jwk key : jwk set . get key ( ) ) { if ( matcher . match ( key ) ) { select key . add ( key ) ; } } return select key ; }
public void set identifier ( key value identifier ) { this . identifier = identifier ; }
public base64 u r l get first c r t coefficient ( ) { return qi ; }
public base64 u r l get x ( ) { return x ; }
public j w k set to public j w k set ( ) { list < jwk > public key list = new link list < > ( ) ; for ( jwk key : key ) { jwk public key = key . to public j w k ( ) ; if ( public key ! = null ) { public key list . add ( public key ) ; } } return new j w k set ( public key list , custom member ) ; }
public @ not null date get timestamp ( ) { return ( date ) timestamp . clone ( ) ; }
public string get encode ( ) { return encode ; }
public big integer get big integer value ( ) throw i o exception { return delegate . get big integer value ( ) ; }
public secret key get a e s key ( ) { return enc key ; }
public static marker get detach marker ( string name ) { return marker factory . get detached marker ( name ) ; }
public void validate ( key store key store , certificate cert ) throw certificate exception { certificate [ ] cert chain = null ; if ( cert ! = null & & cert instanceof x509 certificate ) { ( ( x509 certificate ) cert ) . check validity ( ) ; string cert alias = null ; try { if ( key store == null ) { throw new invalid parameter exception ( `` keystore can not be null `` ) ; } cert alias = key store . get certificate alias ( ( x509 certificate ) cert ) ; if ( cert alias == null ) { cert alias = `` jetty `` + string . format ( `` % 016x `` , __alias count . increment and get ( ) ) ; key store . set certificate entry ( cert alias , cert ) ; } cert chain = key store . get certificate chain ( cert alias ) ; if ( cert chain == null || cert chain . length == 0 ) { throw new illegal state exception ( `` unable to retrieve certificate chain `` ) ; } } catch ( key store exception kse ) { log . debug ( `` unable to validate certificate `` , kse ) ; throw new certificate exception ( `` unable to validate certificate `` + ( cert alias == null ? `` `` : `` for alias [ `` + cert alias + `` ] `` ) + `` : `` + kse . get message ( ) , kse ) ; } validate ( cert chain ) ; } }
public j w t claim set apply to ( final j w t claim set jwt claim set ) { map . entry < string , j s o n object > cnf claim = to j w t claim ( ) ; return new j w t claim set . builder ( jwt claim set ) . claim ( cnf claim . get key ( ) , cnf claim . get value ( ) ) . build ( ) ; }
public void set method ( int method ) { this . method = method ; }
public string get i d ( ) { return this . get ( `` / $ id `` ) ; }
public void remove subject ( string subject ) { remove bag value ( prefix + `` : subject `` , subject ) ; }
public void remove subject ( string subject ) { remove bag value ( prefix + `` : subject `` , subject ) ; }
public static < t > t cast ( object o ) { return ( t ) o ; }
public j w t claim set apply to ( final j w t claim set jwt claim set ) { map . entry < string , j s o n object > cnf claim = to j w t claim ( ) ; return new j w t claim set . builder ( jwt claim set ) . claim ( cnf claim . get key ( ) , cnf claim . get value ( ) ) . build ( ) ; }
protect void set code ( int code ) { this . code = code ; }
public error object get error object ( ) { return error ; }
public j w t claim set apply to ( final j w t claim set jwt claim set ) { map . entry < string , j s o n object > cnf claim = to j w t claim ( ) ; return new j w t claim set . builder ( jwt claim set ) . claim ( cnf claim . get key ( ) , cnf claim . get value ( ) ) . build ( ) ; }
public issuer get issuer ( ) { return issuer ; }
public void set access ( access access ) { this . access = access ; this . add pending change ( `` access `` , access . to j s o n value ( ) ) ; }
public string get message ( ) { return message ; }
public token introspection error response to error response ( ) { return ( token introspection error response ) this ; }
public void remove last token ( ) { if ( previous token==null ) { first token = current token = null ; } else { current token = previous token ; current token . set next token ( null ) ; } }
public metadata get metadata ( ) { return metadata ; }
public void set redirect u r l ( url redirect u r l ) { this . redirect u r l = redirect u r l ; }
public uri get u r i ( ) { return u ; }
public uri get u r i ( ) { return u ; }
public void set request object j w e alg ( final j w e algorithm request object j w e alg ) { this . request object j w e alg = request object j w e alg ; }
public j w s algorithm get request object j w s alg ( ) { return request object j w s alg ; }
public void set software version ( final software version software version ) { this . software version = software version ; }
public string get software version ( ) { return this . software version ; }
public void set request object j w e alg ( final j w e algorithm request object j w e alg ) { this . request object j w e alg = request object j w e alg ; }
public void set back channel logout u r i ( final uri back channel logout u r i ) { u r i utils . ensure scheme be h t t p sor h t t p ( back channel logout u r i ) ; this . back channel logout u r i = back channel logout u r i ; }
public refresh token get existing grant ( ) { return exist grant ; }
public uri get u r i ( ) { return u ; }
public j w t claim set apply to ( final j w t claim set jwt claim set ) { map . entry < string , j s o n object > cnf claim = to j w t claim ( ) ; return new j w t claim set . builder ( jwt claim set ) . claim ( cnf claim . get key ( ) , cnf claim . get value ( ) ) . build ( ) ; }
public void set cache size ( int cache size ) { this . cache size = cache size ; }
public void shutdown ( ) { }
public error get error ( ) { return this . error ; }
public void set fragment ( final string fragment ) { this . fragment = fragment ; }
public string get fragment ( ) { return fragment ; }
public x509 certificate get decryption certificate ( ) { return decryption certificate ; }
public string get string id ( ) { return string id ; }
public j s o n object get metadata policy j s o n object ( ) { return get j s o n object claim ( metadata_policy_claim_name ) ; }
public w s d d response flow get response flow ( ) { return response flow ; }
public void refresh ( ) { }
public static get api key request use realm name ( string realm name ) { return new get api key request ( realm name , null , null , null , false ) ; }
public static int size ( object list ) { if ( list == null ) return 0 ; if ( list instanceof list ) return ( ( list < ? > ) list ) . size ( ) ; return 1 ; }
public access token get access token ( ) { return access token ; }
public c i b a error response to error response ( ) { return ( c i b a error response ) this ; }
public static grant on step grant ( privilege privilege ) { return dsl ( ) . grant ( privilege ) ; }
public void set day ( int day ) { _d = day ; }
public string get uri ( ) { return uri ; }
public i s o3166_3 country code to i s o3166_3 country code ( ) { return ( i s o3166_3 country code ) this ; }
public void set country ( final country code country ) { if ( country ! = null ) { set claim ( country_claim_name , country . get value ( ) ) ; } else { set claim ( country_claim_name , null ) ; } }
protect void set code ( int code ) { this . code = code ; }
public type get type ( ) { return type ; }
public stream file attach ( string attachment name ) { this . attachment name = attachment name ; return this ; }
public type get type ( ) { return type ; }
public type get type ( ) { return type ; }
public date time to date time ( ) { return new date time ( get millis ( ) , get zone ( ) ) ; }
public reference type signature get type signature ( ) { return type signature ; }
public issuer get issuer ( ) { return issuer ; }
public issuer get issuer ( ) { return issuer ; }
public string get string ( ) { return string ; }
public trust channel resolver get trust channel resolver ( ) { return trust channel resolver ; }
public static long get process i d ( process process ) { return image singleton . lookup ( process property support . class ) . get process i d ( process ) ; }
public void set u r l claim ( final string name , final url value ) { if ( value ! = null ) set claim ( name , value . to string ( ) ) ; else claim . remove ( name ) ; }
public string get lang ( ) { return lang ; }
public void set claim ( final string name , final object value ) { if ( value ! = null ) claim . put ( name , value ) ; else claim . remove ( name ) ; }
public j s o n object get request j s o n object ( ) { return request j s o n object ; }
public date get date time ( ) { return date time ; }
public void set a m r ( final list < amr > amr ) { if ( amr ! = null ) { list < string > amr list = new array list < > ( amr . size ( ) ) ; for ( amr a : amr ) amr list . add ( a . get value ( ) ) ; set claim ( amr_claim_name , amr list ) ; } else { set claim ( amr_claim_name , null ) ; } }
public list < amr > get a m r ( ) { list < string > raw list = get string list claim ( amr_claim_name ) ; if ( raw list == null || raw list . be empty ( ) ) return null ; list < amr > amr list = new array list < > ( raw list . size ( ) ) ; for ( string s : raw list ) amr list . add ( new amr ( s ) ) ; return amr list ; }
public string get family name ( ) { return family name ; }
protect void set code ( int code ) { this . code = code ; }
public string get middle name ( ) throw service local exception { return get property bag ( ) . get object from property definition ( contact schema . middle name ) ; }
public collection < entry > remove verify user info claim ( final string claim name ) { return remove claim ( verify user info claim , claim name ) ; }
public collection < entry > remove user info claim ( final string claim name ) { return remove claim ( user info claim , claim name ) ; }
public j s o n object get metadata policy j s o n object ( ) { return get j s o n object claim ( metadata_policy_claim_name ) ; }
public j s o n object get request j s o n object ( ) { return request j s o n object ; }
public metadata metadata ( ) { return metadata ; }
public void set r p metadata ( final o i d c client metadata rp metadata ) { j s o n object o = rp metadata ! = null ? rp metadata . to j s o n object ( ) : null ; set metadata ( federation metadata type . openid_relying_party , o ) ; }
public j s o n object get request j s o n object ( ) { return request j s o n object ; }
public void destroy ( ) { for ( endpoint endpoint : this . publish endpoint ) { endpoint . stop ( ) ; } }
public static j s o n array to j s o n array ( j s o n array name , string string ) throw j s o n exception { return to j s o n array ( name , new j s o n tokener ( string ) ) ; }
public list < policy operation > get ( final string parameter name ) { return entry . get ( parameter name ) ; }
public string get parameter name ( ) { return parameter name ; }
public policy with statement ( statement . . . statement ) { set statement ( array . a list ( statement ) ) ; return this ; }
public integer get max length ( ) { return max length ; }
public string get constraint reference ( ) { return constraint name + ' . ' + constraint clause number ; }
public void resolve ( class scope scope ) { super . resolve ( scope ) ; internal resolve ( scope ) ; }
public j w e algorithm get authorization j w e alg ( ) { return authz j w e alg ; }
public void set method ( int method ) { this . method = method ; }
public final synchronize metric record create record ( string record name ) { if ( buffer data . get ( record name ) == null ) { buffer data . put ( record name , new record map ( ) ) ; } return new record ( record name ) ; }
public int get max age ( ) { return max age ; }
public void set term of service u r i ( final uri tos u r i ) { u r i utils . ensure scheme be h t t p sor h t t p ( tos u r i ) ; tos u r i entry . put ( null , tos u r i ) ; }
public object response ( ) { return response ; }
public final string get i d ( ) { return i i d ; }
public issuer get issuer ( ) { return issuer ; }
public url get url ( ) { return this . url ; }
public string get host ( ) { return host ; }
public void set max total connection ( int max total connection ) { set int parameter ( http connection manager params . max_total_connections , max total connection ) ; }
public string get password ( ) { return this . password ; } // -- string get password ( )
public synchronize void set max size ( long max size ) { this . max size = max size ; if ( initialize ) { executor . execute ( cleanup runnable ) ; } }
public synchronize long get max size ( ) { return max size ; }
public int get error code ( ) { return this . error code ; }
public list < doc write request < ? > > request ( ) { return this . request ; }
public static boolean equal ( @ nullable object a , @ nullable object b ) { return a == b || ( a ! = null & & a . equal ( b ) ) ; }
public boolean be failure ( ) { return be failure ; }
public static string to string ( final byte [ ] input , final string encode ) throw i o exception { return new string ( input , charsets . to charset ( encode ) ) ; }
public void set proxy address ( socket address proxy address ) { this . proxy address = proxy address ; }
public protocol get protocol ( ) { return protocol ; }
public void validate ( final cookie cookie , final cookie origin origin ) throw malformed cookie exception { if ( cookie == null ) { throw new illegal argument exception ( `` cookie may not be null `` ) ; } if ( cookie instanceof set cookie2 ) { if ( cookie instanceof client cookie & & ! ( ( client cookie ) cookie ) . contains attribute ( client cookie . version_attr ) ) { throw new cookie restriction violation exception ( `` violate rfc 2965 . version attribute be require . `` ) ; } } }
public int size ( ) { return size ; }
public synchronize error code get error code ( ) { return error code ; }
public static user group information get remote user ( ) { call call = cur call . get ( ) ; return ( call ! = null & & call . connection ! = null ) ? call . connection . user : null ; }
public object response ( ) { return response ; }
public void start ( ) throw exception { }
public int ping interval millis ( ) { return ping interval ; }
public string get scheme ( ) { return scheme ; }
public string get password ( ) { return password ; }
public int get timeout ( ) { return timeout ; }
public int ping interval millis ( ) { return ping interval ; }
public byte string hmac sha512 ( byte string key ) { return hmac ( `` hmac s h a512 `` , key ) ; }
public string to string ( ) { return set . to string ( ) ; }
public void set message digest ( byte [ ] digest ) { put ( message_digest , digest ) ; }
public byte string hmac sha512 ( byte string key ) { return hmac ( `` hmac s h a512 `` , key ) ; }
public int length ( ) { return value . size ( ) ; }
public boolean have timeout ( ) { return ( this . deadline ! = null ) ; }
public static hash function md5 ( ) { return md5 holder . md5 ; }
public string get type ( ) { return type ; }
public boolean be boolean ( ) { return false ; }
public string get key ( ) { return key ; }
public synchronize void set params ( http params params ) { default params = params ; }
public association session type get min assoc sess enc ( ) { return _min assoc sess enc ; }
public void set min assoc sess enc ( association session type min assoc sess enc ) { this . _min assoc sess enc = min assoc sess enc ; }
public void add auth info ( string scheme , byte auth [ ] ) { cnxn . add auth info ( scheme , auth ) ; }
public content type get type ( ) { return type ; }
public string to string ( ) { return set . to string ( ) ; }
public string get dh gen ( ) { string gen = get parameter value ( `` openid . dh_gen `` ) ; return gen ! = null ? gen : have parameter ( `` openid . dh_consumer_public `` ) ? diffie hellman session . default_generator_base64 : null ; }
public boolean have field update ( ) { return field info gen ! = -1 ; }
public void set key ( string key ) { super . set name ( key ) ; }
public list < string > get extension ( ) { return extension ; }
public boolean have parameter ( string name ) { return _parameters . have parameter ( name ) ; }
public string get extension ( ) { return this . extension ; } // -- string get extension ( )
public string uri ( ) { return uri ; }
public string get parameter value ( string name ) { return _parameters . get parameter value ( name ) ; }
public string get uri ( ) { return uri ; }
public string get uri ( ) { return uri ; }
public string get field ( ) { return field ; }
public io . vertx . axle . core . http . http client create http client ( http client option option ) { io . vertx . axle . core . http . http client ret = io . vertx . axle . core . http . http client . new instance ( delegate . create http client ( option ) ) ; return ret ; }
public boolean be failure ( ) { return be failure ; }
public boolean be use identity hash code ( ) { return super . be use identity hash code ( ) ; }
public string get provider ( ) { return provider ; }
public void destroy ( ) { for ( endpoint endpoint : this . publish endpoint ) { endpoint . stop ( ) ; } }
public void set category ( final list < category > category ) { this . category = category ; }
public for stmt set compare ( final expression compare ) { if ( compare == this . compare ) { return this ; } notify property change ( observable property . compare , this . compare , compare ) ; if ( this . compare ! = null ) this . compare . set parent node ( null ) ; this . compare = compare ; set a parent node of ( compare ) ; return this ; }
public void set category ( final list < category > category ) { this . category = category ; }
public allocation command get command ( ) { return command ; }
public void set category ( final list < category > category ) { this . category = category ; }
public void add listener ( listener listener ) { listener . add ( listener ) ; }
public object get ( ) { return value ; }
public void set id ( string id ) { this . id = id ; }
public object get default handler ( ) { return this . default handler ; }
public array list < expression > get expression ( ) { return expression ; }
public void set descriptor ( change descriptor descriptor ) { f descriptor= descriptor ; }
public static keytab read ( file file ) throw i o exception { byte buffer buffer = byte buffer . wrap ( get byte from file ( file ) ) ; return read keytab ( buffer ) ; }
public synchronize i access rule participant [ ] get access rule participant ( ) { initialize extension ( ) ; return f rule participant . to array ( new i access rule participant [ f rule participant . size ( ) ] ) ; }
public void set factory ( j d o m factory factory ) { this . factory = factory ; }
public location get location ( ) { return location ; }
public static string format file string ( info info ) { return format file string ( info . get template name ( ) , info . get line ( ) , info . get column ( ) ) ; }
public static i file system get local file system ( ) { return internal file system core . get instance ( ) . get local file system ( ) ; }
public static i file system get file system ( string scheme ) throw core exception { return internal file system core . get instance ( ) . get file system ( scheme ) ; }
public boolean be attribute ( ) { return attribute ; }
public long ticket key new ( ) { lock reader lock = context . ctx lock . read lock ( ) ; reader lock . lock ( ) ; try { return s s l context . session ticket key new ( context . ctx ) ; } finally { reader lock . unlock ( ) ; } }
public static void main ( string args [ ] ) throw i o exception { job conf job = value aggregator job . create value aggregator job ( args ) ; job client . run job ( job ) ; }
public job i d get job i d ( ) { return job id ; }
public static string get rule ( ) { string rule string = null ; if ( rule ! = null ) { string builder sb = new string builder ( ) ; for ( rule rule : rule ) { sb . append ( rule . to string ( ) ) . append ( `` \n `` ) ; } rule string = sb . to string ( ) . trim ( ) ; } return rule string ; }
public string get user ( ) { return user ; }
public job current job ( ) { return ( job ) current job ; }
protect abstract data tree node get root node ( ) { return root node ; }
public void set root ( node node ) { if ( node == null ) { throw new illegal argument exception ( `` root node must not be null ! `` ) ; } root = node ; root node = null ; }
public void write tree ( element tree tree , i path path , int depth , final data output output ) throw i o exception { / * write the format version number . * / write number ( current_format , output ) ; / * this actually just copy the root node , which be what we want * / delta data tree subtree = new delta data tree ( tree . get data tree ( ) . copy complete subtree ( path . root ) ) ; data tree writer . write tree ( subtree , path , depth , output ) ; }
public deletion time start deletion time ( ) { return start deletion ; }
protect boolean be project description file ( i resource resource ) { return resource . get type ( ) == i resource . file & & resource . get full path ( ) . segment count ( ) == 2 & & resource . get name ( ) . equal ( i project description . description_file_name ) ; }
public i marker [ ] find marker ( string type , boolean include subtypes ) throw core exception { if ( resource . length == 0 ) return new i marker [ 0 ] ; array list < i marker > result = new array list < > ( ) ; do find marker ( result , type , include subtypes ) ; return result . to array ( new i marker [ result . size ( ) ] ) ; }
public boolean be empty ( ) { return property path by transient entity == null || property path by transient entity . be empty ( ) ; }
public static index type create scan ( boolean persistent ) { index type type = new index type ( ) ; type . persistent = persistent ; type . scan = true ; return type ; }
public static boolean [ ] add first ( final boolean [ ] array , final boolean element ) { return array == null ? add ( array , element ) : insert ( 0 , array , element ) ; }
public string get resource description ( ) { return resource description ; }
public string get description ( ) { return description ; }
public store get store ( ) throw no such provider exception { return get store ( get property ( `` mail . store . protocol `` ) ) ; }
public int get flag ( ) { return flag ; }
public char [ ] get flag ( ) { return flag ; }
public static boolean be prefix of ( i path location1 , i path location2 ) { return compute overlap ( location1 , location2 , false ) ; }
public static boolean be overlap ( uri location1 , uri location2 ) { return compute overlap ( location1 , location2 , true ) ; }
public string get string ( ) { return string ; }
public delta data tree new empty delta tree ( ) { if ( ! be immutable ( ) ) throw new illegal argument exception ( message . dtree_not immutable ) ; delta data tree new tree = ( delta data tree ) this . copy ( ) ; new tree . set parent ( this ) ; new tree . empty delta ( ) ; return new tree ; }
public delta data tree new empty delta tree ( ) { if ( ! be immutable ( ) ) throw new illegal argument exception ( message . dtree_not immutable ) ; delta data tree new tree = ( delta data tree ) this . copy ( ) ; new tree . set parent ( this ) ; new tree . empty delta ( ) ; return new tree ; }
public synchronize state mark available ( ) { if ( map . be empty ( ) ) { state = state . idle ; } else { state = state . pending ; } return state ; }
public mapping metadata default mapping ( ) { return mapping . get ( mapper service . default_mapping ) ; }
public i marker [ ] find marker ( i resource target , final string type , final boolean include subtypes , int depth ) { array list < i marker > result = new array list < > ( ) ; do find marker ( target , result , type , include subtypes , depth ) ; if ( result . be empty ( ) ) return no_markers ; return result . to array ( new i marker [ result . size ( ) ] ) ; }
public static void refresh resource ( i launch configuration configuration , i progress monitor monitor ) throw core exception { string scope = configuration . get attribute ( attr_refresh_scope , ( string ) null ) ; if ( scope ! = null ) { i resource [ ] resource = to resource ( scope ) ; if ( resource ! = null & & resource . length > 0 ) { int depth = i resource . depth_one ; if ( be refresh recursive ( configuration ) ) { depth = i resource . depth_infinite ; } refresh resource ( resource , depth , monitor ) ; } } }
public boolean be attribute ( ) { return attribute ; }
public void set value ( string value ) { this . value = value ; }
public string get name ( ) { return this . name ; } // -- string get name ( )
public string get string ( string name ) { return get plugin preference ( true ) . get ( name , get default preference ( ) . get ( name , string_default_default ) ) ; }
public void add listener ( listener listener ) { listener . add ( listener ) ; }
public boolean have failure ( ) { return ! this . failure . be empty ( ) ; }
public url get u r l ( ) throw i o exception { url url = resolve u r l ( ) ; if ( url == null ) { throw new file not find exception ( get description ( ) + `` can not be resolve to url because it do not exist `` ) ; } return url ; }
public location get location ( ) { return location ; }
protect void set plugin ( string plugin id ) { assert . be legal ( plugin id ! = null & & plugin id . length ( ) > 0 ) ; this . plugin id = plugin id ; }
public string get platform ( ) { return platform ; }
public j w s algorithm get request object j w s alg ( ) { return request object j w s alg ; }
public bundle get bundle ( ) { return registration . get bundle ( ) ; }
public final i scheduling rule get rule ( ) { return super . get rule ( ) ; }
protect void fire document change ( document event event ) { super . fire document change ( f slave event ) ; }
protect tuple writable create internal value ( ) { writable [ ] vals = new writable [ kid . length ] ; for ( int i = 0 ; i < vals . length ; ++i ) { vals [ i ] = kid [ i ] . create value ( ) ; } return new tuple writable ( vals ) ; }
public long get norms memory in byte ( ) { return this . norm memory in byte ; }
public gate . resource get resource ( ) { return resource ; }
public void set id ( string id ) { this . id = id ; }
public static double value source from query ( query query ) { return new query double value source ( query ) ; }
public void set status ( string status ) { this . status = status ; } // -- void set status ( string )
public document get document ( ) { return document ; }
public string get file ( ) { return file ; }
public file get directory ( ) { return directory ; }
protect boolean be suppress close ( ) { return this . suppress close ; }
protect boolean internal remove launch ( i launch launch ) { if ( launch == null ) { return false ; } synchronize ( f launch ) { f launch set . remove ( launch ) ; return f launch . remove ( launch ) ; } }
public void set type ( string type ) { this . type = type ; }
public list < node > get node ( ) { return node ; }
protect void set attribute visibility ( string attribute , boolean visible ) { if ( f visible attribute ! = null ) { if ( visible ) { f visible attribute . add ( attribute ) ; } else { f visible attribute . remove ( attribute ) ; } } }
protect set < string > get visible attribute ( ) { if ( ! be prototype ( ) ) { return null ; } else if ( f visible attribute == null ) { initialize visible attribute ( ) ; } return f visible attribute ; }
public collection < object id > get candidate ( ) { return candidate ; }
protect boolean internal remove launch ( i launch launch ) { if ( launch == null ) { return false ; } synchronize ( f launch ) { f launch set . remove ( launch ) ; return f launch . remove ( launch ) ; } }
public void add sub launch ( i launch sub launch ) { synchronize ( sub launch ) { sub launch . put ( sub launch , new i process [ ] { } ) ; } }
public i java element delta get delta ( ) { return this . operation . delta builder . delta ; }
protect void set type ( i launch configuration type type ) { f type = type ; }
public synchronize boolean launch mode available ( string mode ) { if ( f active mode == null ) { f active mode = new hash set < > ( 3 ) ; for ( i launch configuration type type : get launch configuration type ( ) ) { for ( i launch mode launch mode : get launch mode ( ) ) { if ( type . support mode ( launch mode . get identifier ( ) ) ) { f active mode . add ( launch mode . get identifier ( ) ) ; } } } } return f active mode . contains ( mode ) ; }
public format step [ ] get step ( ) { return step . clone ( ) ; }
public string get launch mode name ( string id ) { i launch mode launch mode = get launch mode ( id ) ; if ( launch mode ! = null ) { return remove accelerator ( launch mode . get label ( ) ) ; } return null ; }
public void log ( string message ) { stream . println ( message + `` - thread : `` + thread . current thread ( ) . get name ( ) ) ; }
public string get key ( ) { return key ; }
public element prepend child ( node child ) { validate . not null ( child ) ; add child ( 0 , child ) ; return this ; }
public final string get action ( ) { return action ; }
public synchronize order lock new lock ( ) { return new order lock ( this ) ; }
public static boolean be fragment ( bundle bundle ) { return internal platform . get default ( ) . be fragment ( bundle ) ; }
public r text area get r text area ( ) { return text area ; }
public void remove listener ( user transaction listener listener ) { if ( listener == null ) throw new illegal argument exception ( `` null listener `` ) ; listener . remove ( listener ) ; log . debug ( this + `` remove listener `` + listener ) ; }
public url get url ( ) { return this . url ; }
public url get u r l ( ) throw i o exception { url url = resolve u r l ( ) ; if ( url == null ) { throw new file not find exception ( get description ( ) + `` can not be resolve to url because it do not exist `` ) ; } return url ; }
public int length ( ) { return value . size ( ) ; }
public void set status ( string status ) { this . status = status ; } // -- void set status ( string )
public set < autowire candidate qualifier > get qualifier ( ) { return new link hash set < autowire candidate qualifier > ( this . qualifier . value ( ) ) ; }
public void clear ( ) { object . clear ( ) ; }
public synchronize error code get error code ( ) { return error code ; }
public int get return code ( ) { return return code ; }
public static plugin get plugin ( string id ) { return null ; }
public string get registry ( ) { return registry ; }
public string get event ( ) { return event ; }
public object remove ( string key ) { return map . remove ( key ) ; }
public void set timestamp ( final long timestamp ) { this . timestamp = timestamp ; }
public list < string > get modify list ( ) { return modify list ; }
public string get registry ( ) { return registry ; }
public static marker get detach marker ( string name ) { return marker factory . get detached marker ( name ) ; }
public static final char [ ] concat ( char prefix , char [ ] array , char suffix ) { if ( array == null ) return new char [ ] { prefix , suffix } ; int length = array . length ; char [ ] result = new char [ length + 2 ] ; result [ 0 ] = prefix ; system . arraycopy ( array , 0 , result , 1 , length ) ; result [ length + 1 ] = suffix ; return result ; }
public static final char [ ] concat ( char prefix , char [ ] array , char suffix ) { if ( array == null ) return new char [ ] { prefix , suffix } ; int length = array . length ; char [ ] result = new char [ length + 2 ] ; result [ 0 ] = prefix ; system . arraycopy ( array , 0 , result , 1 , length ) ; result [ length + 1 ] = suffix ; return result ; }
public static final char [ ] append ( char [ ] array , char suffix ) { if ( array == null ) return new char [ ] { suffix } ; int length = array . length ; system . arraycopy ( array , 0 , array = new char [ length + 1 ] , 0 , length ) ; array [ length ] = suffix ; return array ; }
public static synchronize introspection helper get helper ( class c ) { return get helper ( null , c ) ; }
public synchronize void set case sensitive ( boolean be case sensitive ) { this . be case sensitive = be case sensitive ; }
public reference bind get resolve binding ( ) { return this . binding ; }
public double delta ( ) { return delta ; }
public static < t > result < t > error ( iterable < ? extend model problem > problem ) { return error ( null , problem ) ; }
public static < t > result < t > error ( iterable < ? extend model problem > problem ) { return error ( null , problem ) ; }
public void remove last token ( ) { if ( previous token==null ) { first token = current token = null ; } else { current token = previous token ; current token . set next token ( null ) ; } }
public node parent ( ) { return parent ; }
public void set value default ( string value default ) { this . value default = value default ; }
public i bind resolve binding ( ) { return this . ast . get binding resolver ( ) . resolve import ( this ) ; }
public simple name get label ( ) { return this . optional label ; }
public void set type ( type type ) { if ( type == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . type ; pre replace child ( old child , type , type_property ) ; this . type = type ; post replace child ( old child , type , type_property ) ; }
public t get node ( ) { return node ; }
public void set expression ( expression expression ) { if ( expression == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . expression ; pre replace child ( old child , expression , expression_property ) ; this . expression = expression ; post replace child ( old child , expression , expression_property ) ; }
public simple name get label ( ) { return this . optional label ; }
public void set expression ( expression expression ) { if ( expression == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . expression ; pre replace child ( old child , expression , expression_property ) ; this . expression = expression ; post replace child ( old child , expression , expression_property ) ; }
public i bind resolve binding ( ) { return this . ast . get binding resolver ( ) . resolve import ( this ) ; }
public void set name ( name name ) { a s t node old child = this . name ; pre replace child ( old child , name , name_property ) ; this . name = name ; post replace child ( old child , name , name_property ) ; }
public policy with statement ( statement . . . statement ) { set statement ( array . a list ( statement ) ) ; return this ; }
public void set body ( statement statement ) { if ( statement == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . body ; pre replace child ( old child , statement , body_property ) ; this . body = statement ; post replace child ( old child , statement , body_property ) ; }
public i method bind resolve binding ( ) { return this . ast . get binding resolver ( ) . resolve member ( this ) ; }
public void set default operator ( standard query config handler . operator operator ) { get query config handler ( ) . set ( configuration key . default_operator , operator ) ; }
public void set module ( final list < module > module ) { this . module = module ; }
public void set else statement ( statement statement ) { a s t node old child = this . optional else statement ; pre replace child ( old child , statement , else_statement_property ) ; this . optional else statement = statement ; post replace child ( old child , statement , else_statement_property ) ; }
public void set name ( name name ) { a s t node old child = this . name ; pre replace child ( old child , name , name_property ) ; this . name = name ; post replace child ( old child , name , name_property ) ; }
public void set qualifier ( name name ) { a s t node old child = this . optional qualifier ; pre replace child ( old child , name , qualifier_property ) ; this . optional qualifier = name ; post replace child ( old child , name , qualifier_property ) ; }
public static boolean be resolve type ( type type ) { if ( type instanceof parameterized type ) { for ( type type arg : ( ( parameterized type ) type ) . get actual type argument ( ) ) { if ( ! be resolve type ( type arg ) ) { return false ; } } return true ; } return type instanceof class < ? > ; }
public int get flag ( ) { if ( flags == -1 ) { flags = dic . get int ( c o s name . flag , 0 ) ; } return flag ; }
public static boolean be protect ( int flag ) { return ( flags & protect ) ! = 0 ; }
public void set module ( final list < module > module ) { this . module = module ; }
public static string make non java keyword ( string keyword ) { return keyword prefix + keyword ; }
public void set name ( simple name field name ) { if ( field name == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . field name ; pre replace child ( old child , field name , name_property ) ; this . field name = field name ; post replace child ( old child , field name , name_property ) ; }
public java type qualify name get qualify name ( ) { return qualify name ; }
public a s t node get cover node ( ) { return this . f cover node ; }
public a s t node get cover node ( ) { return this . f cover node ; }
public void set expression ( expression expression ) { if ( expression == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . expression ; pre replace child ( old child , expression , expression_property ) ; this . expression = expression ; post replace child ( old child , expression , expression_property ) ; }
public void set expression ( expression expression ) { if ( expression == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . expression ; pre replace child ( old child , expression , expression_property ) ; this . expression = expression ; post replace child ( old child , expression , expression_property ) ; }
public sub inheritance hierarchy resolver add super type ( ct type information super type ) { target super type . add ( super type . get qualified name ( ) ) ; if ( have super interface == false ) { have super interface = super type . be interface ( ) ; } return this ; }
public void set name ( name name ) { a s t node old child = this . name ; pre replace child ( old child , name , name_property ) ; this . name = name ; post replace child ( old child , name , name_property ) ; }
public static annotation [ ] get resource annotation ( method method ) { map < class < ? > , annotation > annotation = new hash map < class < ? > , annotation > ( ) ; for ( annotation annotation : method . get declare class ( ) . get annotation ( ) ) { annotation . put ( annotation . get class ( ) , annotation ) ; } for ( annotation annotation : method . get annotation ( ) ) { annotation . put ( annotation . get class ( ) , annotation ) ; } return annotation . value ( ) . to array ( new annotation [ annotation . size ( ) ] ) ; }
public string get text ( ) { return text ; }
public boolean be wildcard ( ) { return get type node ( ) == null ; }
public int get superclass id ( ) { return super class ; }
public void set type ( type type ) { if ( type == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . type ; pre replace child ( old child , type , type_property ) ; this . type = type ; post replace child ( old child , type , type_property ) ; }
public type get type ( ) { return type ; }
public static boolean be protect ( int flag ) { return ( flags & protect ) ! = 0 ; }
public boolean be synthetic public ( ) { return synthetic public ; }
public static boolean be final ( int flag ) { return ( flags & acc final ) ! = 0 ; }
public string get compiler ( ) { return super . get compiler ( ) ; }
public static string [ ] get variable name suggestion ( int variable kind , i java project project , string base name , int dimension , collection < string > exclude , boolean evaluate default ) { return name convention . suggest variable name ( variable kind , name convention . bk_type_name , remove type argument ( base name ) , project , dimension , get exclude array ( exclude ) , evaluate default ) ; }
public string get path ( ) { return this . path ; }
public boolean get allow partial search result ( ) { return this . search request . allow partial search result ( ) ; }
public void set requestor ( final i refactoring search requestor requestor ) { assert . be not null ( requestor ) ; f requestor= requestor ; }
public type get type ( ) { return type ; }
public boolean get scope ( ) { return scope ; }
public exception get exception ( ) { return this . exception ; }
public reference bind get resolve binding ( ) { return this . binding ; }
public w s d d response flow get response flow ( ) { return response flow ; }
public boolean get global ( ) { return m global ; }
public boolean be boolean ( ) { return false ; }
public type annotation walker to type parameter bound ( boolean be class type parameter , int parameter rank ) { long new match = this . match ; if ( new match == 0 ) return empty_annotation_walker ; int length = this . type annotation . length ; int target type = be class type parameter ? annotation target type constant . class_type_parameter_bound : annotation target type constant . method_type_parameter_bound ; long mask = 1 ; for ( int i = 0 ; i < length ; i++ , mask = mask < < 1 ) { i binary type annotation candidate = this . type annotation [ i ] ; if ( candidate . get target type ( ) ! = target type || ( short ) candidate . get type parameter index ( ) ! = parameter rank ) { new match & = ~mask ; } } return restrict ( new match , 0 ) ; }
public void remove cache pool ( string pool name ) throw i o exception { dfs . remove cache pool ( pool name ) ; }
public compilation unit set import ( final node list < import declaration > import ) { assert not null ( import ) ; if ( import == this . import ) { return this ; } notify property change ( observable property . import , this . import , import ) ; if ( this . import ! = null ) this . import . set parent node ( null ) ; this . import = import ; set a parent node of ( import ) ; return this ; }
public void find operation ( final compilation unit compilation unit , final set < compilation unit rewrite operation > operation , final set < a s t node > nodesprocessed ) { myfinder . finder ( this , compilation unit , operation , nodesprocessed ) ; }
public void set binding ( bind binding ) { this . bind = binding ; }
public boolean equal ( object other ) { if ( other==this ) { return true ; } if ( other instanceof document range ) { return this . compare to ( ( document range ) other ) ==0 ; } return false ; }
public static < t > result < t > error ( iterable < ? extend model problem > problem ) { return error ( null , problem ) ; }
public signature type get signature type ( ) { return signature type ; }
public boolean be final ( ) { return modifier . be final ( modifier ) ; }
protect void reset thread context class loader ( class loader original ) { if ( original ! = null ) { thread . current thread ( ) . set context class loader ( original ) ; } }
public constant get constant ( long value ) { return value to constant . get ( value ) ; }
public boolean have else block ( ) { return else stmt instanceof block stmt ; }
public void set initializer ( object literal initializer ) { this . initializer = initializer ; if ( initializer ! = null ) initializer . set parent ( this ) ; }
public char get end ( ) { return this . end ; }
public void close ( boolean cancel if execute ) { impl . close ( this , cancel if execute ) ; }
public categorize problem [ ] get problem ( string marker type ) { if ( this . operation . problem == null ) return null ; return ( categorize problem [ ] ) this . operation . problem . get ( marker type ) ; }
public boolean contains range ( range range ) { if ( range == null ) { return false ; } return contains integer ( range . get minimum integer ( ) ) & & contain integer ( range . get maximum integer ( ) ) ; }
public categorize problem [ ] get problem ( string marker type ) { if ( this . operation . problem == null ) return null ; return ( categorize problem [ ] ) this . operation . problem . get ( marker type ) ; }
public void exit interface ( int body end , int declaration end ) { exit type ( body end , declaration end ) ; }
protect void set name source end ( int end ) { this . name end= end ; }
protect void index node ( node node ) { list < node > nod = node name to node . get ( node . get x path node name ( ) ) ; if ( node ! = null ) { node . add ( node ) ; } }
public void set type ( string type ) { this . type = type ; } // -- void set type ( string )
public static < e > queue < e > synchronize queue ( queue < e > queue ) { return synchronize . queue ( queue , null ) ; }
public void delete index directory under lock ( index index , index setting index setting , consumer < path [ ] > listener ) throw i o exception { final path [ ] index path = index path ( index ) ; logger . trace ( `` delete index { } directory , path ( { } ) : [ { } ] `` , index , index path . length , index path ) ; listener . accept ( index path ) ; i o utils . rm ( index path ) ; if ( index setting . have custom data path ( ) ) { path custom location = resolve index custom location ( index setting . custom data path ( ) , index . get u u i d ( ) ) ; logger . trace ( `` delete custom index { } directory [ { } ] `` , index , custom location ) ; listener . accept ( new path [ ] { custom location } ) ; i o utils . rm ( custom location ) ; } }
public int hash code ( ) { return this . path . hash code ( ) ; }
public static string decapitalize ( string name ) { if ( name == null || name . length ( ) == 0 ) { return name ; } if ( name . length ( ) > 1 & & character . be upper case ( name . char at ( 1 ) ) & & character . be upper case ( name . char at ( 0 ) ) ) { return name ; } char [ ] char = name . to char array ( ) ; char [ 0 ] = character . to lower case ( char [ 0 ] ) ; return new string ( char ) ; }
public final void reset ( ) { reset ( 0l ) ; }
public signature type get signature type ( ) { return signature type ; }
public void write ( int c ) { buffer . append ( ( char ) c ) ; }
public string get index ( ) { return this . index ; }
public map field type get field type ( string field ) { return field type lookup ( ) . get ( field ) ; }
public name type get name type ( ) { return this . engine . get name type ( ) ; }
public string get name ( ) { return f name ; }
public int get super type index ( ) { return ( short ) ( ( value & 0x00 f f f f00 ) > > 8 ) ; }
protect string read body content ( ) throw i o exception { assert . state ( this . body content ! = null , `` no body content set `` ) ; return this . body content . get string ( ) ; }
public error get error ( ) { return this . error ; }
public string get descriptor ( ) { return descriptor ; }
public void set package ( boolean package ) { this . package = package ; } // -- void set package ( boolean )
public boolean get delegate ( ) { return this . delegate ; }
public void set deprecate ( boolean value ) { this . deprecate = value ; }
public void set type ( string type ) { this . type = type ; }
public boolean be delegate ( ) { return f delegate ; }
public void set member of ( int member of ) { the member of = member of ; }
public string get name ( ) { return f name ; }
public argument create argument ( ) { return this . create argument ( false ) ; }
public string get expression ( ) { return expression ; }
public char [ ] get file name ( ) { return this . openable . get element name ( ) . to char array ( ) ; }
public list < string > get variable name ( ) { return this . variable name ; }
protect boolean be token separator ( char ch ) { return ( ch == ' , ' ) ; }
public indent type get indent type ( ) { return get indentation ( ) . get type ( ) ; }
public void set expand multi term query ( boolean expand multi term query ) { this . expand multi term query = expand multi term query ; }
public void set ignore ( boolean ignore ) { this . ignore = ignore ; }
public boolean have more element ( ) { if ( current ! = null ) return true ; while ( current bucket < table . length ) { current = table [ current bucket++ ] ; if ( current ! = null ) return true ; } return false ; }
public float get progress ( ) { return progress ; }
public collection < cache operation > get cache operation ( method method , class < ? > target class ) { object cache key = get cache key ( method , target class ) ; collection < cache operation > cache = this . attribute cache . get ( cache key ) ; if ( cached ! = null ) { return ( cache ! = null_caching_attribute ? cache : null ) ; } else { collection < cache operation > cache ops = compute cache operation ( method , target class ) ; if ( cache ops ! = null ) { if ( logger . be debug enable ( ) ) { logger . debug ( `` add cacheable method ' `` + method . get name ( ) + `` ' with attribute : `` + cache ops ) ; } this . attribute cache . put ( cache key , cache ops ) ; } else { this . attribute cache . put ( cache key , null_caching_attribute ) ; } return cache ops ; } }
public declaration get declaration by id ( string id ) { declaration decl = ( declaration ) declaration by id . get ( id ) ; if ( ( decl == null ) & & ( parent ! = null ) ) { decl = parent . get declaration by id ( id ) ; } return decl ; }
public result get result ( ) { return result ; }
public list < node > get node ( ) { return node ; }
public void set operator ( infix expression . operator operator ) { if ( operator == null ) { throw new illegal argument exception ( ) ; } pre value change ( operator_property ) ; this . operator = operator ; post value change ( operator_property ) ; }
public string get in ( ) { return in ; }
public i compilation unit get compilation unit ( ) { return this . compilation unit ; }
public query rewrite ( index reader reader ) throw i o exception { return this ; }
public void search declaration of sent message ( i java element enclose element , search requestor requestor , i progress monitor monitor ) throw java model exception { this . basic engine . search declaration of sent message ( enclose element , requestor , monitor ) ; }
public binding bind ( bind binding ) { internal binding . add ( bind ) ; return binding ; }
public string get lang ( ) { return lang ; }
public structure q name get top level element ( ) { return option . get top level element ( ) ; }
public boolean be nest ( ) { return f parent environment ! = null ; }
public void set member ( final i member [ ] member ) { assert . be not null ( member ) ; f members= member ; }
public boolean be java lang object ( ) { return false ; }
public void set root ( node node ) { if ( node == null ) { throw new illegal argument exception ( `` root node must not be null ! `` ) ; } root = node ; root node = null ; }
public boolean visit ( multi text edit edit ) { return visit node ( edit ) ; }
protect metadata build context get context ( ) { return context ; }
public boolean be low bound ( ) { return ! be upper bound ( ) ; }
public date get overridden date ( ) { return overridden date == null ? null : new date ( overridden date . get time ( ) ) ; }
public file status [ ] list status ( path [ ] file ) throw file not find exception , i o exception { return list status ( file , default_filter ) ; }
public static uri get base u r i ( final uri uri ) { if ( uri == null ) return null ; try { return new uri ( uri . get scheme ( ) , null , uri . get host ( ) , uri . get port ( ) , uri . get path ( ) , null , null ) ; } catch ( u r i syntax exception e ) { return null ; } }
public type get type ( ) { return type ; }
public static string format file string ( info info ) { return format file string ( info . get template name ( ) , info . get line ( ) , info . get column ( ) ) ; }
public int get position ( ) { return position ; }
public void add composite ( composite composite ) { composite . add ( composite ) ; }
protected list < i document setup participant > get document setup participant ( string name or extension ) { set < i configuration element > set= f setup participant descriptor . get ( name or extension ) ; if ( set == null ) return null ; list < i document setup participant > participants= new array list < > ( ) ; iterator < i configuration element > e= set . iterator ( ) ; while ( e . have next ( ) ) { i configuration element entry= e . next ( ) ; i document setup participant participant= get extension ( entry , f setup participant , i document setup participant . class ) ; if ( participant ! = null ) participant . add ( participant ) ; } return participant ; }
protect void abort ( string message , throwable exception ) throw core exception { i status status = new status ( i status . error , debug plugin . get unique identifier ( ) , debug plugin . error , message , exception ) ; throw new core exception ( status ) ; }
protect x m l reader create default reader ( ) { s a x parser factory factory = s a x parser factory . new instance ( ) ; factory . set validating ( true ) ; factory . set namespace aware ( true ) ; x m l reader reader = null ; try { s a x parser sax parser = factory . new s a x parser ( ) ; reader = sax parser . get x m l reader ( ) ; } catch ( parser configuration exception e ) { throw new build exception ( error_parser_creation_failure , e ) ; } catch ( s a x exception e ) { throw new build exception ( error_parser_creation_failure , e ) ; } return reader ; }
public string get name ( ) { return f name ; }
public string [ ] get included directory ( ) { return dirs include . to array ( new string [ dirs include . size ( ) ] ) ; }
public void fire change event ( int detail ) { fire event ( new debug event ( this , debug event . change , detail ) ) ; }
public static < v > m v r tree map < v > create ( int dimension , data type value type ) { return new m v r tree map < v > ( dimension , value type ) ; }
public void set id ( string id ) { f id = id ; }
public object get attribute ( string key ) { return attribute . get ( key ) ; }
public string get message ( ) { return cmd ! = null ? cmd . get message ( ) : null ; }
public location get location ( ) { return location ; }
public object get value ( ) { return value ; }
public object id get old object id ( ) { return old value ; }
public zip entry source get zip archive ( ) { return zip archive ; }
public int get status ( ) { return status ; }
public change collection < t change > get change ( ) { return this . change ; }
public change collection < t change > get change ( ) { return this . change ; }
public string get type ( ) { return f type ; }
public boolean be update ( ) { return be update ; }
public collection < string > get processor alias ( string processor ) { return get alias ( processor . to lower case ( ) , processor alias table ) ; }
public string get element name ( ) { return element name ; }
public object checker get object checker ( ) { return object checker ; }
public refactoring status get status ( ) { return f status ; }
public string get provider ( ) { return provider ; }
public string get descriptor ( ) { return descriptor ; }
public container get container ( ) { return container ; }
public direct candidate generator builder max edits ( integer max edits ) { if ( max edit < 1 || max edits > levenshtein automaton . maximum_supported_distance ) { throw new illegal argument exception ( `` illegal max_edits value `` + max edits ) ; } this . max edits = max edits ; return this ; }
protect boolean need save ( ) { if ( ( f save mode & force_save ) ! = 0 ) { return true ; } if ( ( f save mode & keep_save_state ) ! = 0 ) { return f validation state == null || ! f validation state . be dirty ( ) ; } return false ; }
public void set save mode ( int save mode ) { f save mode= save mode ; }
public calendar get calendar ( ) { return calendar ; }
public void add resource ( string name ) { add resource object ( new resource ( name ) ) ; }
public void add srcfileset ( file set f ) { create source ( ) . add ( f ) ; }
public int get unexpected type ( ) { if ( input instanceof token stream ) { return token . get type ( ) ; } else if ( input instanceof tree node stream ) { tree node stream node = ( tree node stream ) input ; tree adaptor adaptor = node . get tree adaptor ( ) ; return adaptor . get type ( node ) ; } else { return c ; } }
public uni on item delay < t > on executor ( schedule executor service executor ) { this . executor = non null ( executor , `` executor `` ) ; return this ; }
public void set revision ( string r ) { revision = r ; }
public static list < capability > a list capability ( list < ? extend capability > l ) { return ( list < capability > ) l ; }
public void set name ( string name ) { this . name = name ; }
public collection < v > value ( ) { return super . value ( ) ; }
public boolean be file ( ) { return be file ; }
public boolean be boolean ( ) { return false ; }
public < t > list < t > a list ( class < t > item type ) { return table converter . to list ( this , item type ) ; }
public string get message ( ) { return message ; }
public pfx option set path ( string path ) { this . path = path ; return this ; }
public move processor get move processor ( ) { return f processor ; }
public configuration get configuration ( ) throw configuration exception { return get configuration ( true ) ; }
public bundle get bundle ( ) { return registration . get bundle ( ) ; }
public string get fragment ( ) { return fragment ; }
public void set file permission ( string file permission ) { this . file permission = file permission ; } // -- void set file permission ( string )
public void remove ( ) { iterator . remove ( ) ; }
public bundle file get bundle file ( ) { return bundlefile ; }
public void remove ( listener listener ) { listener . remove ( listener ) ; }
public version get version ( ) { return version ; }
public int get from int ( ) { return get from ( ) ; }
public void set right ( final string right ) { this . right = list . create ( right ) ; }
public synchronize void leave ( ) throw exception { leave ( -1 , null ) ; }
public boolean be empty ( ) { return map . be empty ( ) ; }
public result get result ( ) { return result ; }
public void set signer ( signer signer ) { }
public tracker get tracker ( ) { return data ; }
public element next ( ) { return the next ; }
public document get document ( ) { return document ; }
public void stop ( ) { stop ( true ) ; }
public @ nullable string get environment ( ) { return environment ; }
public int get position ( ) { return position ; }
public common stats flag group ( string . . . group ) { this . group = group ; return this ; }
public void write ( short [ ] f , int off , int len ) throw i o exception { raw write ( f , off * 2 , len * 2 ) ; }
public sequence get sequence ( string sequence name ) { sequence sequence = sequence . get ( sequence name ) ; if ( sequence == null ) { throw db exception . get ( error code . sequence_not_found_1 , sequence name ) ; } return sequence ; }
public void set length ( long length ) { this . length = length ; }
public boolean have region ( string region ) { return region . contains key ( region ) || match region regex ( region ) || have service endpoint ( region ) ; }
public void fire change event ( int detail ) { fire event ( new debug event ( this , debug event . change , detail ) ) ; }
public boolean be cache ( ) { return cache ! = null ; }
public int get offset ( ) { return offset ; }
public resource chain registration add resolver ( resource resolver resolver ) { assert . not null ( resolver , `` the provided resource resolver should not be null `` ) ; this . resolvers . add ( resolver ) ; if ( resolver instanceof version resource resolver ) { this . have version resolver = true ; } else if ( resolver instanceof path resource resolver ) { this . have path resolver = true ; } else if ( resolver instanceof web jar resource resolver ) { this . have webjars resolver = true ; } return this ; }
public final int get number of template variable ( ) { return template variable . size ( ) ; }
public string get type ( ) { return type ; }
public string get name ( ) { return f name ; }
public boolean visit ( copy target edit edit ) { return visit node ( edit ) ; }
public void add child ( final object child ) { this . child . add ( child ) ; }
protect void post process copy ( text edit copier copier ) { }
public final text edit copy ( ) { text edit copier copier= new text edit copier ( this ) ; return copier . perform ( ) ; }
public object get root ( ) { return root ; }
public boolean visit ( multi text edit edit ) { return visit node ( edit ) ; }
public boolean visit ( copy target edit edit ) { return visit node ( edit ) ; }
public boolean be delete ( ) { return be delete ; }
public void sync ( ) { check open ( ) ; file store f = file store ; if ( f ! = null ) { f . sync ( ) ; } }
protect final uri template get template ( ) { return template ; }
public string get template name ( ) { return template name ; }
public template [ ] get template ( ) { return get template ( null ) ; }
public string get action ( ) { return action ; }
public boolean equal ( final object obj ) { if ( obj == this ) { return true ; } else if ( ! ( obj instanceof class info ) ) { return false ; } final class info other = ( class info ) obj ; return name . equal ( other . name ) ; }
public final int hash code ( ) { return super . hash code ( ) ; }
public c t color get c t color ( string name ) { return _scheme color . get ( name ) ; }
public static void clear image ( buffer image image ) { clear image ( image , color . white ) ; }
protect final graphics2 d get graphic ( ) { return graphic ; }
public void clear ( ) { this . internal clear ( ) ; }
public static object [ ] flatten ( object [ ] array ) { final list < object > list = new array list < object > ( ) ; if ( array ! = null ) { for ( object o : array ) { if ( o instanceof object [ ] ) { for ( object o r : flatten ( ( object [ ] ) o ) ) { list . add ( o r ) ; } } else { list . add ( o ) ; } } } return list . to array ( ) ; }
public string get char set ( ) { string retval = null ; c o s string name = ( c o s string ) dic . get dictionary object ( c o s name . char_set ) ; if ( name ! = null ) { retval = name . get string ( ) ; } return retval ; }
public void set string index ( int string index ) { this . string index = string index ; }
public boolean be value set ( ) { return false ; }
public void set name ( string name ) { this . get c o s object ( ) . set name ( c o s name . name , name ) ; }
public c o s base get value ( ) { return get c o s object ( ) . get dictionary object ( c o s name . v ) ; }
public void set id ( string id ) { this . id = id ; } // -- void set id ( string )
public void write thin ( stream output out ) throw i o exception { super . write to ( out ) ; out . write v int ( byte . length ( ) ) ; }
public boolean have region ( string region ) { return region . contains key ( region ) || match region regex ( region ) || have service endpoint ( region ) ; }
public final static int murmur hash3 ( int x ) { x ^= x > > > 16 ; x * = 0x85ebca6b ; x ^= x > > > 13 ; x * = 0xc2b2ae35 ; x ^= x > > > 16 ; return x ; }
public file get dir ( ) { return dir ; }
public random access file get random access file ( ) { return random access file ; }
public void set odd page overlay p d f ( p d document odd page overlay p d f ) { odd page overlay = odd page overlay p d f ; }
public void set all page overlay p d f ( p d document all page overlay p d f ) { all page overlay = all page overlay p d f ; }
public file get destination ( ) { return this . destination ; }
public source get source ( ) { return source ; }
public void set page start ( string page start value ) { page start = page start value ; }
public document get document ( ) { return document ; }
public static collection < encryption type > get encryption type ( ) { return encryption type by name . value ( ) ; }
protect final p d document get source document ( ) { return source document ; }
public long get offset ( ) { return offset ; }
public final c o s dictionary get last trailer ( ) { if ( byte po to xref map . be empty ( ) ) { return null ; } set < long > offset = byte po to xref map . key set ( ) ; sort set < long > sort offset = new tree set < long > ( offset ) ; return byte po to xref map . get ( sort offset . last ( ) ) . trailer ; }
public output < ? > output ( ) { return output ; }
public void set file ( file file ) { this . file = file ; }
public void set embed file unicode ( p d embed file file ) { c o s dictionary ef = get e f dictionary ( ) ; if ( ef == null & & file ! = null ) { ef = new c o s dictionary ( ) ; f . set item ( c o s name . ef , ef ) ; } if ( ef ! = null ) { ef . set item ( c o s name . uf , file ) ; } }
public string get subtype ( ) { return subtype ; }
public string get date ( ) { return dictionary . get string ( c o s name . date ) ; }
public string get char set ( ) { string retval = null ; c o s string name = ( c o s string ) dic . get dictionary object ( c o s name . char_set ) ; if ( name ! = null ) { retval = name . get string ( ) ; } return retval ; }
public int get number of object ( ) { return get c o s object ( ) . get int ( c o s name . n , 0 ) ; }
public list < byte [ ] > get o i d ( ) { c o s base base = this . dictionary . get dictionary object ( c o s name . oid ) ; if ( base instanceof c o s array ) { c o s array array = ( c o s array ) base ; return get list of byte array from c o s array ( array ) ; } return null ; }
public float get x ( ) { return ( ( c o s number ) value . get ( 0 ) ) . float value ( ) ; }
public final void add first ( k key , v value ) { list < v > value = get value ( key ) ; if ( value ! = null ) { value . add ( 0 , value ) ; } else { add first null ( value ) ; } }
public sequence get sequence ( string sequence name ) { sequence sequence = sequence . get ( sequence name ) ; if ( sequence == null ) { throw db exception . get ( error code . sequence_not_found_1 , sequence name ) ; } return sequence ; }
public c o s object get c o s object ( c o s name key ) { c o s base object = get item ( key ) ; if ( object instanceof c o s object ) { return ( c o s object ) object ; } return null ; }
public void set page label ( p d page label label ) { root . set item ( c o s name . page_labels , label ) ; }
public void set low left y ( float value ) { rect array . set ( 1 , new c o s float ( value ) ) ; }
public void set low left x ( float value ) { rect array . set ( 0 , new c o s float ( value ) ) ; }
public static list < i o file filter > to list ( final i o file filter . . . filter ) { if ( filter == null ) { throw new illegal argument exception ( `` the filter must not be null `` ) ; } final list < i o file filter > list = new array list < > ( filter . length ) ; for ( int i = 0 ; i < filter . length ; i++ ) { if ( filter [ i ] == null ) { throw new illegal argument exception ( `` the filter [ `` + i + `` ] be null `` ) ; } list . add ( filter [ i ] ) ; } return list ; }
public metadata metadata ( ) { return metadata ; }
public string get owner ( ) { return owner ; }
public int get revision number ( ) { ensure load ( ) ; return revision . size ( ) ; }
public c o s base get value ( ) { return get c o s object ( ) . get dictionary object ( c o s name . v ) ; }
public string get property name ( ) { return property name ; }
public void set right ( final string right ) { this . right = list . create ( right ) ; }
public void set accent and hyperlink colour r g b ( int rgb ) { accent and hyperlink colour r g b = rgb ; }
public void set color ( p d gamma color ) { this . set color ( color , color ) ; }
public p d gamma get color ( ) { return this . get color ( color ) ; }
public x d d f space get space before ( ) { return find defined paragraph property ( props - > prop . be set spc bef ( ) , prop - > prop . get spc bef ( ) ) . map ( space - > extract space ( space ) ) . or else ( null ) ; }
public string get text ( ) { return this . text ; }
public void set t border style ( string [ ] t border style ) { this . set array of name ( t_border_style , t border style ) ; }
public void set all t border style ( string t border style ) { this . set name ( t_border_style , t border style ) ; }
public void set color ( p d gamma color ) { this . set color ( color , color ) ; }
public void set text decoration color ( p d gamma text decoration color ) { this . set color ( text_decoration_color , text decoration color ) ; }
public glyph list get glyph list ( ) { return glyph list . get adobe glyph list ( ) ; }
public void track column ( collection < integer > column ) { for ( final int column : column ) { track column ( column ) ; } }
protect void set name ( string name , string value ) { c o s base old base = this . get c o s object ( ) . get dictionary object ( name ) ; this . get c o s object ( ) . set name ( name , value ) ; c o s base new base = this . get c o s object ( ) . get dictionary object ( name ) ; this . potentially notify change ( old base , new base ) ; }
public c o s name get c o s name ( c o s name key ) { c o s base name = get dictionary object ( key ) ; if ( name instanceof c o s name ) { return ( c o s name ) name ; } return null ; }
protect void set string ( string name , string value ) { c o s base old base = this . get c o s object ( ) . get dictionary object ( name ) ; this . get c o s object ( ) . set string ( name , value ) ; c o s base new base = this . get c o s object ( ) . get dictionary object ( name ) ; this . potentially notify change ( old base , new base ) ; }
public final p d gamma get gamma ( ) { c o s array gamma array = ( c o s array ) dictionary . get dictionary object ( c o s name . gamma ) ; if ( gamma array == null ) { gamma array = new c o s array ( ) ; gamma array . add ( new c o s float ( 1 . 0f ) ) ; gamma array . add ( new c o s float ( 1 . 0f ) ) ; gamma array . add ( new c o s float ( 1 . 0f ) ) ; dictionary . set item ( c o s name . gamma , gamma array ) ; } return new p d gamma ( gamma array ) ; }
public schema validator builder can be read strategy ( ) { this . strategy = new validate can be read ( ) ; return this ; }
public boolean be owner permission ( ) { return ( this . can assemble document ( ) & & this . can extract content ( ) & & this . can extract for accessibility ( ) & & this . can fill in form ( ) & & this . can modify ( ) & & this . can modify annotation ( ) & & this . can print ( ) & & this . can print degrade ( ) ) ; }
public void set std crypt filter dictionary ( p d crypt filter dictionary crypt filter dictionary ) { set crypt filter dictionary ( c o s name . std_cf , crypt filter dictionary ) ; }
public c o s dictionary get c o s dictionary ( ) { return crypt filter dictionary ; }
public void set revision number ( int revision number ) { if ( revision number < 0 ) { throw new illegal argument exception ( `` the revision number shall be > -1 `` ) ; } this . get c o s object ( ) . set int ( c o s name . r , revision number ) ; }
public c o s dictionary get c o s dictionary ( ) { return crypt filter dictionary ; }
public void set certificate ( boolean certificate ) { this . certificate = certificate ; }
public void write ( final byte [ ] b ) throw i o exception { write ( b , 0 , b . length ) ; }
public void check ( final int api ) { if ( api == opcodes . asm4 ) { if ( visible type annotation ! = null & & visible type annotation . size ( ) > 0 ) { throw new runtime exception ( ) ; } if ( invisible type annotation ! = null & & invisible type annotation . size ( ) > 0 ) { throw new runtime exception ( ) ; } int n = try catch block == null ? 0 : try catch block . size ( ) ; for ( int i = 0 ; i < n ; ++i ) { try catch block node tcb = try catch block . get ( i ) ; if ( tcb . visible type annotation ! = null & & tcb . visible type annotation . size ( ) > 0 ) { throw new runtime exception ( ) ; } if ( tcb . invisible type annotation ! = null & & tcb . invisible type annotation . size ( ) > 0 ) { throw new runtime exception ( ) ; } } for ( int i = 0 ; i < instruction . size ( ) ; ++i ) { abstract insn node insn = instruction . get ( i ) ; if ( insn . visible type annotation ! = null & & insn . visible type annotation . size ( ) > 0 ) { throw new runtime exception ( ) ; } if ( insn . invisible type annotation ! = null & & insn . invisible type annotation . size ( ) > 0 ) { throw new runtime exception ( ) ; } if ( insn instanceof method insn node ) { boolean itf = ( ( method insn node ) insn ) . itf ; if ( itf ! = ( insn . opcode == opcodes . invokeinterface ) ) { throw new runtime exception ( ) ; } } } if ( visible local variable annotation ! = null & & visible local variable annotation . size ( ) > 0 ) { throw new runtime exception ( ) ; } if ( invisible local variable annotation ! = null & & invisible local variable annotation . size ( ) > 0 ) { throw new runtime exception ( ) ; } } }
public void set name ( string name ) { this . get c o s object ( ) . set name ( c o s name . name , name ) ; }
public string get rollover caption ( ) { return this . get c o s object ( ) . get string ( c o s name . rc ) ; }
public void set border effect ( p d border effect dictionary be ) { get c o s object ( ) . set item ( c o s name . be , be ) ; }
public void set ink list ( float [ ] [ ] ink list ) { if ( ink list == null ) { get c o s object ( ) . remove item ( c o s name . inklist ) ; return ; } c o s array array = new c o s array ( ) ; for ( float [ ] path : ink list ) { c o s array inner array = new c o s array ( ) ; inner array . set float array ( path ) ; array . add ( inner array ) ; } get c o s object ( ) . set item ( c o s name . inklist , array ) ; }
public void set float ( long offset , float value ) { bound check ( offset , 4 ) ; super . set float ( offset , value ) ; }
public float [ ] get vertex ( ) { c o s array array = annot . get c o s array ( c o s name . vertex ) ; return array ! = null ? array . to float array ( ) : null ; }
public void set embed f d f ( list < p d file specification > embed ) { fdf . set item ( c o s name . embedded_fdfs , c o s array list . converter to c o s array ( embed ) ) ; }
public void register value target ( target target ) { if ( target == null ) { target = new vector ( ) ; } target . add element ( target ) ; }
public string get embed ( ) { return embed ; }
public void set fit window ( boolean value ) { prefs . set boolean ( c o s name . fit_window , value ) ; }
public void default return value ( final boolean rv ) { def ret value = rv ; }
public static request specification give ( ) { return create test specification ( ) . get request specification ( ) ; }
public void add reference ( reference ref ) { reference . add element ( ref ) ; }
public c o s name get c o s name ( c o s name key ) { c o s base name = get dictionary object ( key ) ; if ( name instanceof c o s name ) { return ( c o s name ) name ; } return null ; }
public byte [ ] get code from unicode ( string unicode ) { return unicode to byte code . get ( unicode ) ; }
public string get font name ( ) { return font name ; }
public string get font name ( ) { return font name ; }
public int get return code ( ) { return return code ; }
public p d c i d font get c i d font ( ) throw i o exception { return new p d c i d font type2 ( cid font , parent , ttf ) ; }
public void put ( c o s name name , p d font font ) { put ( c o s name . font , name , font ) ; }
public final string get base font ( ) { return dict . get name a string ( c o s name . base_font ) ; }
public string get char set ( ) { string retval = null ; c o s string name = ( c o s string ) dic . get dictionary object ( c o s name . char_set ) ; if ( name ! = null ) { retval = name . get string ( ) ; } return retval ; }
public int get flag ( ) { return flag ; }
public float get italic angle ( ) { return italic angle ; }
public integer get height ( ) { return height ; }
public void set max width ( float max width ) { dic . set float ( c o s name . max_width , max width ) ; }
public void set width ( final integer width ) { this . width = width ; }
public void set max width ( float max width ) { dic . set float ( c o s name . max_width , max width ) ; }
public string get font stretch ( ) { string retval = null ; c o s name name = ( c o s name ) dic . get dictionary object ( c o s name . font_stretch ) ; if ( name ! = null ) { retval = name . get name ( ) ; } return retval ; }
public void add stream ( stream stream ) { if ( this . stream == null ) { this . stream = new hash set < stream > ( ) ; } this . stream . add ( stream ) ; }
public string get type ( ) { return dict . get name a string ( c o s name . type ) ; }
public void set glyph orientation vertical ( string glyph orientation vertical ) { this . set name ( glyph_orientation_vertical , glyph orientation vertical ) ; }
public type1 font parse ( byte [ ] segment1 , byte [ ] segment2 ) throw i o exception { font = new type1 font ( segment1 , segment2 ) ; parse a s c i i ( segment1 ) ; if ( segment2 . length > 0 ) { parse binary ( segment2 ) ; } return font ; }
public p d rectangle get crop box ( ) { c o s base base = p d page tree . get inheritable attribute ( page , c o s name . crop_box ) ; if ( base instanceof c o s array ) { return clip to medium box ( new p d rectangle ( ( c o s array ) base ) ) ; } else { return get medium box ( ) ; } }
public c o s dictionary get c o s dictionary ( ) { return crypt filter dictionary ; }
protect p d gamma get color ( string name ) { c o s array c = ( c o s array ) this . get c o s object ( ) . get dictionary object ( name ) ; if ( c ! = null ) { return new p d gamma ( c ) ; } return null ; }
public void put ( c o s name name , p d abstract pattern pattern ) { put ( c o s name . pattern , name , pattern ) ; }
public float [ ] get vertex ( ) { c o s array array = annot . get c o s array ( c o s name . vertex ) ; return array ! = null ? array . to float array ( ) : null ; }
public float get z ( ) { return ( ( c o s number ) value . get ( 2 ) ) . float value ( ) ; }
public float get x ( ) { return ( ( c o s number ) value . get ( 0 ) ) . float value ( ) ; }
public static void clear image ( buffer image image ) { clear image ( image , color . white ) ; }
public void add resource ( string name ) { add resource object ( new resource ( name ) ) ; }
public string get domain ( ) { return domain ; }
public c o s object get c o s object ( c o s name key ) { c o s base object = get item ( key ) ; if ( object instanceof c o s object ) { return ( c o s object ) object ; } return null ; }
public int get bit per sample ( ) { return get c o s object ( ) . get int ( c o s name . bits_per_sample ) ; }
public float get x ( ) { return ( ( c o s number ) value . get ( 0 ) ) . float value ( ) ; }
public list < byte [ ] > get o i d ( ) { c o s base base = this . dictionary . get dictionary object ( c o s name . oid ) ; if ( base instanceof c o s array ) { c o s array array = ( c o s array ) base ; return get list of byte array from c o s array ( array ) ; } return null ; }
public c o s base get transfer2 ( ) { c o s base base = dict . get dictionary object ( c o s name . tr2 ) ; if ( base instanceof c o s array & & ( ( c o s array ) base ) . size ( ) ! = 4 ) { return null ; } return base ; }
public boolean be alpha source ( ) { return alpha source ; }
public boolean kolmogorov smirnov test ( real distribution distribution , double [ ] data , double alpha ) { if ( ( alpha < = 0 ) || ( alpha > 0 . 5 ) ) { throw new out of range exception ( localized format . out_of_bound_significance_level , alpha , 0 , 0 . 5 ) ; } return kolmogorov smirnov test ( distribution , data ) < alpha ; }
public void set overprint mode ( double value ) { overprint mode = value ; }
public void set overprint ( boolean value ) { overprint = value ; }
public void set text state ( p d text state value ) { text state = value ; }
public p d text state get text state ( ) { return text state ; }
public void set color ( p d gamma color ) { this . set color ( color , color ) ; }
public string get path ( ) { return path ; }
public boolean be function ( ) { return this . function ; }
public string get font name ( ) { return font name ; }
public p d page get page ( ) { return page ; }
public boolean be repeat ( ) { return count > 1 ; }
public void set d ( file d ) { this . d = d ; }
public void set action ( p d action action ) { get c o s object ( ) . set item ( c o s name . a , action ) ; }
protect p d gamma get color ( string name ) { c o s array c = ( c o s array ) this . get c o s object ( ) . get dictionary object ( name ) ; if ( c ! = null ) { return new p d gamma ( c ) ; } return null ; }
public void set name mode ( string name , int mode ) { this . name = name ; this . mode = mode ; }
public string get type ( ) { return dict . get name a string ( c o s name . type ) ; }
public void set border effect ( p d border effect dictionary be ) { get c o s object ( ) . set item ( c o s name . be , be ) ; }
public c o s dictionary get c o s dictionary ( ) { return crypt filter dictionary ; }
public void set action ( p d action action ) { get c o s object ( ) . set item ( c o s name . a , action ) ; }
public c o s base get value ( ) { return get c o s object ( ) . get dictionary object ( c o s name . v ) ; }
public c o s object get c o s object ( c o s name key ) { c o s base object = get item ( key ) ; if ( object instanceof c o s object ) { return ( c o s object ) object ; } return null ; }
public void add stream ( stream stream ) { if ( this . stream == null ) { this . stream = new hash set < stream > ( ) ; } this . stream . add ( stream ) ; }
public c o s object get c o s object ( c o s name key ) { c o s base object = get item ( key ) ; if ( object instanceof c o s object ) { return ( c o s object ) object ; } return null ; }
public c o s array to c o s array ( ) { c o s array array = new c o s array ( ) ; array . set float array ( component ) ; if ( pattern name ! = null ) { array . add ( pattern name ) ; } return array ; }
public void set date ( string date ) { super . set internal date ( date ) ; }
public void set o i d require ( boolean flag ) { this . get c o s object ( ) . set flag ( c o s name . ff , flag_oid , flag ) ; }
public void set filter require ( boolean flag ) { get c o s object ( ) . set flag ( c o s name . ff , flag_filter , flag ) ; }
public reason get reason ( ) { return reason ; }
public void set filter require ( boolean flag ) { get c o s object ( ) . set flag ( c o s name . ff , flag_filter , flag ) ; }
public c o s base get transfer2 ( ) { c o s base base = dict . get dictionary object ( c o s name . tr2 ) ; if ( base instanceof c o s array & & ( ( c o s array ) base ) . size ( ) ! = 4 ) { return null ; } return base ; }
public c o s dictionary get c o s dictionary ( ) { return crypt filter dictionary ; }
public c o s name get c o s name ( c o s name key ) { c o s base name = get dictionary object ( key ) ; if ( name instanceof c o s name ) { return ( c o s name ) name ; } return null ; }
public list < byte [ ] > get o i d ( ) { c o s base base = this . dictionary . get dictionary object ( c o s name . oid ) ; if ( base instanceof c o s array ) { c o s array array = ( c o s array ) base ; return get list of byte array from c o s array ( array ) ; } return null ; }
public void set page ( p d page page ) { this . page = page ; }
public p d page get page ( ) { return page ; }
public mock http request add form header ( string name , string value ) { if ( decoded form parameter == null ) { decoded form parameter = new multivalued map impl < string , string > ( ) ; content type ( `` application/x-www-form-urlencoded `` ) ; } decode form parameter . add ( name , value ) ; return this ; }
public void set icon fit ( f d f icon fit fit ) { field . set item ( c o s name . if , fit ) ; }
public version get right ( ) { return right ; }
protect void set top ( l top ) { this . top = top ; }
public void set action ( p d action action ) { this . get c o s object ( ) . set item ( c o s name . a , action ) ; }
public p d name tree node < p d structure element > get i d tree ( ) { c o s base base = this . get c o s object ( ) . get dictionary object ( c o s name . id_tree ) ; if ( base instanceof c o s dictionary ) { return new p d structure element name tree node ( ( c o s dictionary ) base ) ; } return null ; }
public boolean get need appearance ( ) { return dictionary . get boolean ( c o s name . need_appearances , false ) ; }
public string get default appearance ( ) { return dictionary . get string ( c o s name . da , `` `` ) ; }
public void set o i d require ( boolean flag ) { this . get c o s object ( ) . set flag ( c o s name . ff , flag_oid , flag ) ; }
public list < string > get select export value ( ) throw i o exception { set < string > on value = get on value ( ) ; list < string > export value = get export value ( ) ; list < string > select export value = new array list < string > ( ) ; if ( export value . be empty ( ) ) { select export value . add ( get value ( ) ) ; return select export value ; } else { string field value = get value ( ) ; int idx = 0 ; for ( string on value : on value ) { if ( on value . compare to ( field value ) == 0 ) { select export value . add ( export value . get ( idx ) ) ; } } return select export value ; } }
public request option get option ( ) { return option ; }
public c o s object get c o s object ( c o s name key ) { c o s base object = get item ( key ) ; if ( object instanceof c o s object ) { return ( c o s object ) object ; } return null ; }
public void set export all ( boolean export ) { export all = export ; }
public c o s base get value ( ) { return get c o s object ( ) . get dictionary object ( c o s name . v ) ; }
public void set o i d require ( boolean flag ) { this . get c o s object ( ) . set flag ( c o s name . ff , flag_oid , flag ) ; }
public int get number of object ( ) { return get c o s object ( ) . get int ( c o s name . n , 0 ) ; }
public void set default value ( p d signature value ) throw i o exception { get c o s object ( ) . set item ( c o s name . dv , value ) ; }
public string get type ( ) { return type ; }
public c o s dictionary get c o s dictionary ( ) { return crypt filter dictionary ; }
public c o s name get c o s name ( c o s name key ) { c o s base name = get dictionary object ( key ) ; if ( name instanceof c o s name ) { return ( c o s name ) name ; } return null ; }
public void set rectangle ( p d rectangle rect ) { bead . set item ( c o s name . r , rect ) ; }
public p d rectangle get rectangle ( ) { p d rectangle rect = null ; c o s array array = ( c o s array ) bead . get dictionary object ( c o s name . r ) ; if ( array ! = null ) { rect = new p d rectangle ( array ) ; } return rect ; }
public void set fit window ( boolean value ) { prefs . set boolean ( c o s name . fit_window , value ) ; }
public void set hide toolbar ( boolean value ) { prefs . set boolean ( c o s name . hide_toolbar , value ) ; }
public string name ( ) { return name . to string ( ) ; }
public void set name ( string name ) { this . get c o s object ( ) . set name ( c o s name . name , name ) ; }
protect void set signature ( byte [ ] signature ) { this . signature = signature ; }
public list < field > get field ( ) { return field ; }
public filter spring security filter chain ( ) throw exception { boolean have configurers = this . web security configurers ! = null & & ! this . web security configurers . be empty ( ) ; boolean have filter chain = ! this . security filter chain . be empty ( ) ; assert . state ( ! ( have configurers & & have filter chain ) , `` find web security configurer adapter as well a security filter chain . please select just one . `` ) ; if ( ! have configurers & & ! have filter chain ) { web security configurer adapter adapter = this . object object post processor . post process ( new web security configurer adapter ( ) { } ) ; this . web security . apply ( adapter ) ; } for ( security filter chain security filter chain : this . security filter chain ) { this . web security . add security filter chain builder ( ( ) - > security filter chain ) ; for ( filter filter : security filter chain . get filter ( ) ) { if ( filter instanceof filter security interceptor ) { this . web security . security interceptor ( ( filter security interceptor ) filter ) ; break ; } } } for ( web security customizer customizer : this . web security customizers ) { customizer . customize ( this . web security ) ; } return this . web security . build ( ) ; }
public boolean be cache ( ) { return cache ! = null ; }
public p d name tree node < p d structure element > get i d tree ( ) { c o s base base = this . get c o s object ( ) . get dictionary object ( c o s name . id_tree ) ; if ( base instanceof c o s dictionary ) { return new p d structure element name tree node ( ( c o s dictionary ) base ) ; } return null ; }
public void set name ( string name ) { this . get c o s object ( ) . set name ( c o s name . name , name ) ; }
public void set name mode ( string name , int mode ) { this . name = name ; this . mode = mode ; }
public void set label ( string label ) { this . label = label ; }
public void set name ( string name ) { this . get c o s object ( ) . set name ( c o s name . name , name ) ; }
public boolean get separate by bead ( ) { return should separate by bead ; }
public p d color get stroke color ( ) { return stroke color ; }
public void shade fill ( p d shade shade ) throw i o exception { if ( in text mode ) { throw new illegal state exception ( `` error : shading fill be not allow within a text block . `` ) ; } write operand ( resource . add ( shade ) ) ; write operator ( `` sh `` ) ; }
public void put ( c o s name name , p d shade shade ) { put ( c o s name . shading , name , shade ) ; }
public tag get tag ( ) { return this . tag ; }
public void set space before ( float space before ) { this . set number ( space_before , space before ) ; }
public c o s base get value ( ) { return get c o s object ( ) . get dictionary object ( c o s name . v ) ; }
public void put ( c o s name name , p d font font ) { put ( c o s name . font , name , font ) ; }
public void put ( c o s name name , p d shade shade ) { put ( c o s name . shading , name , shade ) ; }
public c o s name get c o s name ( c o s name key ) { c o s base name = get dictionary object ( key ) ; if ( name instanceof c o s name ) { return ( c o s name ) name ; } return null ; }
public iterable < c o s name > get font name ( ) { return get name ( c o s name . font ) ; }
public iterable < c o s name > get shade name ( ) { return get name ( c o s name . shade ) ; }
public c o s name get pattern name ( ) { return pattern name ; }
public void render page to graphic ( int page index , graphics2 d graphic ) throw i o exception { render page to graphic ( page index , graphic , 1 ) ; }
protect final graphics2 d get graphic ( ) { return graphic ; }
public void set thread bead ( list < p d thread bead > bead ) { page . set item ( c o s name . b , c o s array list . converter to c o s array ( bead ) ) ; }
public void clear formatting ( ) { _string = clone string if require ( ) ; _string . clear formatting ( ) ; add to s s t if require ( ) ; }
public void set output threshold ( long threshold ) { this . threshold = threshold ; }
public paragraph get paragraph ( int index ) { init paragraph ( ) ; if ( index + _par start > = _par end ) throw new index out of bound exception ( `` paragraph # `` + index + `` ( `` + ( index + _par start ) + `` ) not in range [ `` + _par start + `` ; `` + _par end + `` ) `` ) ; papx papx = _paragraphs . get ( index + _par start ) ; return paragraph . new paragraph ( this , papx ) ; }
public void set start page ( int start ) { if ( start < = 0 ) { throw new illegal argument exception ( `` start page be small than one `` ) ; } start page = start ; }
public short get text rotation ( ) { return field_12_text rotation ; }
public void set width ( final integer width ) { this . width = width ; }
public t get node ( ) { return node ; }
public string to hex string ( ) { byte [ ] bytes = this . data . array ( ) ; char [ ] hex = new char [ this . data . remain ( ) * 2 ] ; for ( int i = this . data . position ( ) ; i < this . data . remain ( ) ; i++ ) { int b = bytes [ i ] & 0x f f ; hex [ i * 2 ] = hex_chars [ b > > > 4 ] ; hex [ i * 2 + 1 ] = hex_chars [ b & 0x0 f ] ; } return new string ( hex ) ; }
public list < byte [ ] > get o i d ( ) { c o s base base = this . dictionary . get dictionary object ( c o s name . oid ) ; if ( base instanceof c o s array ) { c o s array array = ( c o s array ) base ; return get list of byte array from c o s array ( array ) ; } return null ; }
public matrix multiply ( matrix other ) { return new matrix ( check float value ( multiply array ( single , other . single ) ) ) ; }
public float float value ( ) { return ( ( float ) numerator ) / ( ( float ) denominator ) ; }
public double get theta ( ) { return theta ; }
public boolean be boolean ( ) { return false ; }
static public int swap int ( int i ) { return ( ( i & 0x f f ) < < 24 ) | ( ( i & 0x f f00 ) < < 8 ) | ( ( i & 0x f f0000 ) > > 8 ) | ( ( i > > 24 ) & 0x f f ) ; }
public void set parent ( element type parent ) { the parent = parent ; }
public void add role ( string user , string role ) { list < string > role = user role . get ( user ) ; if ( role == null ) { role = new array list < > ( ) ; user role . put ( user , role ) ; } role . add ( role ) ; }
public static list < method > get setter ( class < ? > clazz ) { method [ ] method = clazz . get method ( ) ; list < method > list = new array list < method > ( ) ; for ( method method : method ) { if ( be setter ( method ) ) { list . add ( method ) ; } } return list ; }
public void set name ( string name ) { this . name = name ; } // -- void set name ( string )
public string [ ] get not include directory ( ) { slow scan ( ) ; string [ ] directory = new string [ dirs not include . size ( ) ] ; dirs not include . copy into ( directory ) ; return directory ; }
public void remove ( listener listener ) { listener . remove ( listener ) ; }
public synchronize throwable cause ( ) { return throwable ; }
public final void print partial stack trace ( print writer out ) { super . print stack trace ( out ) ; }
public static method [ ] get all declare method ( class < ? > leaf class ) { final list < method > method = new array list < method > ( 32 ) ; do with method ( leaf class , new method callback ( ) { @ override public void do with ( method method ) { method . add ( method ) ; } } ) ; return method . to array ( new method [ method . size ( ) ] ) ; }
public char char at ( int i ) { return this . buffer [ i ] ; }
public final string get line ( int line i ) { return line . get ( line i ) ; }
public string get char set ( ) { string retval = null ; c o s string name = ( c o s string ) dic . get dictionary object ( c o s name . char_set ) ; if ( name ! = null ) { retval = name . get string ( ) ; } return retval ; }
public object [ ] get argument ( ) { return argument . clone ( ) ; }
public static file create parent directory ( final file file ) throw i o exception { return mkdirs ( get parent file ( file ) ) ; }
public list < escher property > get escher property ( ) { return property ; }
public void add escher property ( escher property prop ) { property . add ( prop ) ; }
public static marker get detach marker ( string name ) { return marker factory . get detached marker ( name ) ; }
public list < x w p f picture data > get all package picture ( ) { return document . get all package picture ( ) ; }
public option set short name ( string short name ) { this . short name = short name ; return this ; }
public event bus option set cluster ( boolean cluster ) { this . cluster = cluster ; return this ; }
public void set save mode ( int save mode ) { f save mode= save mode ; }
protect final boolean be compress ( ) { return compress ; }
public short get shape type ( ) { return get instance ( ) ; }
public void set color1 ( int field_1_color1 ) { this . field_1_color1 = field_1_color1 ; }
public int get color1 ( ) { return field_1_color1 ; }
public set < string > get name ( ) { return new hash set < string > ( this . parameter . key set ( ) ) ; }
public short get instance ( ) { return f instance . get short value ( _options ) ; }
public unwrap by default value extractor < optional > get optional value extractor ( ) { return optional value extractor ; }
public void set summary ( final content summary ) { this . summary = summary ; }
public dictionary get dictionary ( ) { return dictionary ; }
public void set word count ( final int word count ) { set1st property ( property i d map . pid_wordcount , word count ) ; }
public void remove language ( ) { remove1st property ( property i d map . pid_language ) ; }
public void set byte count ( final int byte count ) { set1st property ( property i d map . pid_bytecount , byte count ) ; }
public void remove slide count ( ) { remove1st property ( property i d map . pid_slidecount ) ; }
public property get property ( ) { return property ; }
public void remove document version ( ) { remove1st property ( property i d map . pid_docversion ) ; }
public void remove language ( ) { remove1st property ( property i d map . pid_language ) ; }
public string get i d ( ) { return this . get ( `` / $ id `` ) ; }
public property get property ( ) { return property ; }
public string get comment ( ) { return comment ; }
public void set author ( boolean b ) { author = b ; }
public void remove language ( ) { remove1st property ( property i d map . pid_language ) ; }
public static long pop_intersect ( long [ ] arr1 , long [ ] arr2 , int word offset , int num word ) { long pop count = 0 ; for ( int i = word offset , end = word offset + num word ; i < end ; ++i ) { pop count += long . bit count ( arr1 [ i ] & arr2 [ i ] ) ; } return pop count ; }
public int get column number ( ) { return column number ; }
protect short process record ( record rec ) throw h s s f user exception { list < h s s f listener > listener = _records . get ( short . value of ( rec . get sid ( ) ) ) ; short user code = 0 ; if ( listener ! = null ) { for ( int k = 0 ; k < listener . size ( ) ; k++ ) { object listen obj = listener . get ( k ) ; if ( listen obj instanceof abortable h s s f listener ) { abortable h s s f listener listener = ( abortable h s s f listener ) listen obj ; user code = listener . abortable process record ( rec ) ; if ( user code ! = 0 ) break ; } else { h s s f listener listener = ( h s s f listener ) listen obj ; listener . process record ( rec ) ; } } } return user code ; }
protect short process record ( record rec ) throw h s s f user exception { list < h s s f listener > listener = _records . get ( short . value of ( rec . get sid ( ) ) ) ; short user code = 0 ; if ( listener ! = null ) { for ( int k = 0 ; k < listener . size ( ) ; k++ ) { object listen obj = listener . get ( k ) ; if ( listen obj instanceof abortable h s s f listener ) { abortable h s s f listener listener = ( abortable h s s f listener ) listen obj ; user code = listener . abortable process record ( rec ) ; if ( user code ! = 0 ) break ; } else { h s s f listener listener = ( h s s f listener ) listen obj ; listener . process record ( rec ) ; } } } return user code ; }
public void add listener ( run listener listener ) { f listener . add ( listener ) ; }
public boolean row have cell ( int row ) { if ( row > = record . length ) { return false ; } cell value record interface [ ] row cells=records [ row ] ; if ( row cells==null ) return false ; for ( int col=0 ; col < row cell . length ; col++ ) { if ( row cell [ col ] ! =null ) return true ; } return false ; }
public void print ( short value ) throw i o exception { print ( string . value of ( value ) ) ; }
public int [ ] get column index ( ) { return column index ; }
public boolean column exists ( c t col col , long index ) { return column exists1 base ( col , index+1 ) ; }
public void remove value record ( int row , cell value record interface col ) { log . log ( p o i logger . debug , `` remove value record row `` +row ) ; _rows aggregate . remove cell ( col ) ; }
public string get build label ( ) { return build ; }
public static int get page type ( long po ) { return ( ( int ) po ) & 1 ; }
public int leave ( int node ) { return leave [ node ] ; }
public void set all t border style ( string t border style ) { this . set name ( t_border_style , t border style ) ; }
public void set color ( p d gamma color ) { this . set color ( color , color ) ; }
public void set bold ( boolean bold ) { if ( bold ) font . set bold weight ( boldweight_bold ) ; else font . set bold weight ( boldweight_normal ) ; }
public static cell range address [ ] merge cell range ( cell range address [ ] cell range ) { if ( cell range . length < 1 ) { return new cell range address [ ] { } ; } list < cell range address > list = to list ( cell range ) ; list < cell range address > temp = merge cell range ( list ) ; return to array ( temp ) ; }
public void set output threshold ( long threshold ) { this . threshold = threshold ; }
public void set sheet ( h s l f sheet sheet ) { _sheet = sheet ; }
public void set pattern ( string pattern ) { this . pattern = pattern ; set use locale format ( true ) ; }
public void set category ( string category ) { this . category = category ; }
public void set minor unit value ( short field_5_minor unit value ) { this . field_5_minor unit value = field_5_minor unit value ; }
public short get minor unit value ( ) { return field_5_minor unit value ; }
public boolean be default cross ( ) { return default cross . be set ( field_9_options ) ; }
public void set default minimum ( boolean value ) { field_9_options = default minimum . set short boolean ( field_9_options , value ) ; }
public void set space before ( float space before ) { this . set number ( space_before , space before ) ; }
public int get flag ( ) { return flag ; }
public void add ( number number ) { element . add ( number == null ? json null . instance : new json primitive ( number ) ) ; }
public void set bubble series type ( short field_5_bubble series type ) { this . field_5_bubble series type = field_5_bubble series type ; }
public integer get height ( ) { return height ; }
public option set short name ( string short name ) { this . short name = short name ; return this ; }
public void set glyph orientation vertical ( string glyph orientation vertical ) { this . set name ( glyph_orientation_vertical , glyph orientation vertical ) ; }
public table get table ( ) { return table ; }
public string get pattern ( ) { return pattern ; }
public void set palette ( list < palette entry > palette ) { this . palette = palette ; }
public boolean be reference type ( ) { return get reference type ( ) ! = null ; }
public void set option ( short field_3_options ) { this . field_3_options = field_3_options ; }
public short get option ( ) { return field_3_options ; }
public index [ ] index ( ) { return index ; }
public boolean get show comment ( ) { return show comment ! = 0 ; }
public void set category data type ( short field_1_category data type ) { this . field_1_category data type = field_1_category data type ; }
public short get category data type ( ) { return field_1_category data type ; }
public void set num value ( short field_4_num value ) { this . field_4_num value = field_4_num value ; }
public short get num value ( ) { return field_4_num value ; }
public web test client . response spec is5xx server error ( ) { http status . series expect = http status . series . server_error ; return assert series and return ( expect ) ; }
public int get item id ( ) { return id ; }
public boolean be empty ( ) { return empty ; }
public void set whitespace visible ( boolean visible ) { if ( whitespace visible ! =visible ) { this . whitespace visible = visible ; token painter = visible ? new visible whitespace token painter ( ) : ( token painter ) new default token painter ( ) ; repaint ( ) ; fire property change ( visible_whitespace_property , ! visible , visible ) ; } }
public option set short name ( string short name ) { this . short name = short name ; return this ; }
public int get rotation ( ) { return rotation ; }
public set < string > get name ( ) { return new hash set < string > ( this . parameter . key set ( ) ) ; }
public boolean be null ( ) { return be null ; }
public void set category ( string category ) { this . category = category ; }
public synchronize order lock new lock ( ) { return new order lock ( this ) ; }
public long get total ( ) { return this . total ; }
public final synchronize metric record create record ( string record name ) { if ( buffer data . get ( record name ) == null ) { buffer data . put ( record name , new record map ( ) ) ; } return new record ( record name ) ; }
public float get italic angle ( ) { return italic angle ; }
public charset get charset ( ) { return this . charset ; }
public string get font name ( ) { return font name ; }
public void set value ( double value ) { field_4_value = value ; }
public boolean be file link ( ) { return ( _link opts & hlink_url ) > 0 & & ( _link opts & hlink_abs ) == 0 ; }
public boolean be url link ( ) { return ( _link opts & hlink_url ) > 0 & & ( _link opts & hlink_abs ) > 0 ; }
public ast node get iterate object ( ) { return iterate object ; }
public void set label ( string label ) { this . label = label ; }
public boolean contains key ( k k ) { return ! get ( k ) . be empty ( ) ; }
public name x ptg get name x ptg ( string name , sheet identifier sheet ) { int sheet ref index = get sheet ext ix ( sheet ) ; return _i book . get name x ptg ( name , sheet ref index , _u book . get u d f finder ( ) ) ; }
public void set value ( double value ) { field_4_value = value ; special cache value = null ; }
public static boolean be protect ( int flag ) { return ( flags & protect ) ! = 0 ; }
public void set type ( int type ) { little endian . put int ( _data , 4 , type ) ; }
public long get low long ( ) { long result = 0 ; for ( int i = 0 ; i < long . size / byte . size ; i++ ) { result < < = byte . size ; result |= ( bytes [ i ] & 0xff ) ; } if ( result < 0 ) { return -result ; } return result ; }
public void set level ( int level ) { this . trace level = level ; }
public boolean column exists ( c t col col , long index ) { return column exists1 base ( col , index+1 ) ; }
public final long row count ( ) { return row ; }
public string get id ( ) { return this . id ; } // -- string get id ( )
public double [ ] get point ( ) { return point ; }
public static h s s f workbook create workbook ( ) { return new h s s f workbook ( ) ; }
public static string quote ( string value ) { return quote ( value , '\ `` ) ; }
public void set order ( int order ) { this . order = order ; }
public final i scheduling rule get rule ( ) { return super . get rule ( ) ; }
public int get day ( ) { return day ; }
public void set sheet ( h s l f sheet sheet ) { _sheet = sheet ; }
public void set bold ( boolean bold ) { set font weight ( bold ? font_weight_bold : font_weight_normal ) ; }
public cell reference get last cell ( ) { return _last cell ; }
public static string eval to string ( string expression ) { return value of ( eval ( expression ) ) ; }
public boolean get no color ( ) { return print setup record . get no color ( ) ; }
public lock option make copy ( ) { final lock option copy = new lock option ( ) ; copy ( this , copy ) ; return copy ; }
public void set page start ( string page start value ) { page start = page start value ; }
public void set no color ( boolean mono ) { print setup record . set no color ( mono ) ; }
public boolean get no color ( ) { return print setup record . get no color ( ) ; }
public void set conflict resolution mode ( conflict resolution mode value ) { this . conflict resolution mode = value ; }
public void set add more formatting ( boolean new add more formatting ) { add more formatting = new add more formatting ; }
protect string elapsed time a string ( long run time ) { return number format . get instance ( ) . format ( ( double ) run time / 1000 ) ; }
public int get fill color ( ) { escher r g b property rgb property = _opt record . lookup ( escher property . fill__fillcolor ) ; return rgb property == null ? fill__fillcolor_default : rgb property . get rgb color ( ) ; }
public int get line style color ( ) { escher r g b property rgb property = _opt record . lookup ( escher property . linestyle__color ) ; return rgb property == null ? linestyle__color_default : rgb property . get rgb color ( ) ; }
public int get margin line position ( ) { return margin size in char ; }
public short get alignment ( ) { return alignment ; }
public string get data format string ( org . apache . poi . s . usermodel . workbook workbook ) { h s s f data format format = new h s s f data format ( ( ( h s s f workbook ) workbook ) . get workbook ( ) ) ; int idx = get data format ( ) ; return idx == -1 ? `` general `` : format . get format ( get data format ( ) ) ; }
public string to string ( ) { return get class ( ) . get simple name ( ) + ' @ ' + integer . to hex string ( system . identity hash code ( this ) ) + `` `` + reflect a string ( false ) ; }
public void set sheet ( h s l f sheet sheet ) { _sheet = sheet ; }
protect byte [ ] new buffer ( int size ) { return new byte [ size ] ; }
public string password ( ) { return password ; }
public void set root ( node node ) { if ( node == null ) { throw new illegal argument exception ( `` root node must not be null ! `` ) ; } root = node ; root node = null ; }
public document get document ( ) { return document ; }
public long small ( ) { return small ; }
public final string get i d ( ) { return i i d ; }
public void set size ( final long size ) { this . size = size ; }
protect void new y sample data ( double [ ] y ) { if ( y == null ) { throw new null argument exception ( ) ; } if ( y . length == 0 ) { throw new no data exception ( ) ; } this . y vector = new array real vector ( y ) ; }
public void set srgb clr ( c t s rgb color value ) { this . srgb clr = value ; }
public void set scrgb clr ( c t sc rgb color value ) { this . scrgb clr = value ; }
public void set srgb clr ( c t s rgb color value ) { this . srgb clr = value ; }
public final lst minimize get lst minimizing ( ) { return my lst minimizing ; }
public final lst minimize get lst minimizing ( ) { return my lst minimizing ; }
public final lst minimize get lst minimizing ( ) { return my lst minimizing ; }
public boolean be embed xml ( ) { return embed xml ; }
protect boolean be token separator ( char ch ) { return ( ch == ' , ' ) ; }
public final quad edge o prev ( ) { return rot . next . rot ; }
public v set value ( v value ) { throw new unsupported operation exception ( ) ; }
protect int hash ( final object key1 , final object key2 ) { int h = 0 ; if ( key1 ! = null ) { h ^= key1 . hash code ( ) ; } if ( key2 ! = null ) { h ^= key2 . hash code ( ) ; } h += ~ ( h < < 9 ) ; h ^= h > > > 14 ; h += h < < 4 ; h ^= h > > > 10 ; return h ; }
protect void pack ( ) { g z i p output stream z out = null ; try { z out = new g z i p output stream ( new file output stream ( zip file ) ) ; zip resource ( get src resource ( ) , z out ) ; } catch ( i o exception ioe ) { string msg = `` problem create gzip `` + ioe . get message ( ) ; throw new build exception ( msg , ioe , get location ( ) ) ; } finally { file utils . close ( z out ) ; } }
public int get min length ( ) { return min length ; }
public void set sx ( c t ratio value ) { this . sx = value ; }
public c t ratio get sx ( ) { return sx ; }
public static int quadrant ( double dx , double dy ) { if ( dx == 0 . 0 & & dy == 0 . 0 ) throw new illegal argument exception ( `` can not compute the quadrant for point ( `` + dx + `` , `` + dy + `` ) `` ) ; if ( dx > = 0 . 0 ) { if ( dy > = 0 . 0 ) return ne ; else return se ; } else { if ( dy > = 0 . 0 ) return nw ; else return sw ; } }
public double double value ( ) { return value ; }
public void set image ( string image ) { x m l util . set string value ( parent , `` xap g img : image `` , image ) ; }
public http params copy ( ) { try { return ( http params ) clone ( ) ; } catch ( clone not support exception ex ) { throw new unsupported operation exception ( `` clone not support `` ) ; } }
public static < t > collection < t > minus ( iterable < t > self , iterable < ? > remove me ) { return minus ( a collection ( self ) , a collection ( remove me ) ) ; }
public final value eval evaluate ( value eval [ ] args , int src row index , int src column index ) { if ( args . length ! = 2 ) { return error eval . value_invalid ; } return evaluate ( src row index , src column index , args [ 0 ] , args [ 1 ] ) ; }
public cell reference get last cell ( ) { return _last cell ; }
public void clear ( ) { object . clear ( ) ; }
public double double value ( ) { return value ; }
public final value eval evaluate ( value eval [ ] args , int src row index , int src column index ) { if ( args . length ! = 4 ) { return error eval . value_invalid ; } return evaluate ( src row index , src column index , args [ 0 ] , args [ 1 ] , args [ 2 ] , args [ 3 ] ) ; }
public final value eval evaluate ( value eval [ ] args , int src row index , int src column index ) { if ( args . length ! = 2 ) { return error eval . value_invalid ; } return evaluate ( src row index , src column index , args [ 0 ] , args [ 1 ] ) ; }
public static < t extend number > field < t > round ( t value ) { return round ( tool . field ( value ) ) ; }
public static int sum ( int [ ] value ) { int sum = 0 ; for ( int value : value ) { sum += value ; } return sum ; }
public double get sumsq ( ) { return apply ( sumsq impl ) ; }
public string get product ( ) { return product ; }
public double get min ( ) { return min impl . get result ( ) ; }
public double of ( double [ ] d , int num param ) { return ( math . pow ( math . e , d [ 0 ] ) + math . pow ( math . e , -d [ 0 ] ) ) / 2 ; }
protect static final string printable ( string s ) { if ( s == null ) return `` null `` ; string builder retval = new string builder ( s . length ( ) + 16 ) ; retval . append ( `` ' `` ) ; char ch ; for ( int i = 0 ; i < s . length ( ) ; i++ ) { add printable ( retval , s . char at ( i ) ) ; } retval . append ( `` ' `` ) ; return retval . to string ( ) ; }
public option set short name ( string short name ) { this . short name = short name ; return this ; }
public charset get charset ( ) { return this . charset ; }
public cell reference get last cell ( ) { return _last cell ; }
public cell range address base applies to ( table table , cell cell ) { if ( cell == null ) return null ; return applies to ( table , new cell reference ( cell . get sheet ( ) . get sheet name ( ) , cell . get row index ( ) , cell . get column index ( ) , true , true ) ) ; }
public void set cell range ( cell range address [ ] cell range ) { if ( cell range == null ) { throw new illegal argument exception ( `` cell range must not be null `` ) ; } cell range address list cral = new cell range address list ( ) ; cell range address enclose range = null ; for ( cell range address cr : cell range ) { enclose range = cell range util . create enclose cell range ( cr , enclose range ) ; cral . add cell range address ( cr ) ; } field_3_enclosing_cell_range = enclose range ; field_4_cell_ranges = cral ; }
public static void set bottom border color ( int color , cell range address region , sheet sheet ) { int col start = region . get first column ( ) ; int col end = region . get last column ( ) ; int row index = region . get last row ( ) ; cell property setter cps = new cell property setter ( cell util . bottom_border_color , color ) ; row row = cell util . get row ( row index , sheet ) ; for ( int i = col start ; i < = col end ; i++ ) { cps . set property ( row , i ) ; } }
public static void set vertical alignment ( cell cell , vertical alignment align ) { set cell style property ( cell , vertical_alignment , align ) ; }
public static void set alignment ( cell cell , horizontal alignment align ) { set cell style property ( cell , alignment , align ) ; }
public boolean row have cell ( int row ) { if ( row > = record . length ) { return false ; } cell value record interface [ ] row cells=records [ row ] ; if ( row cells==null ) return false ; for ( int col=0 ; col < row cell . length ; col++ ) { if ( row cell [ col ] ! =null ) return true ; } return false ; }
public int read ( ) throw i o exception { int b = in . read ( ) ; if ( b ! = -1 ) { hasher . put byte ( ( byte ) b ) ; } return b ; }
public static path [ ] file ( path directory ) throw i o exception { try ( directory stream < path > stream = file . new directory stream ( directory ) ) { return to array ( stream ) ; } }
public static output stream leave shift ( output stream self , input stream in ) throw i o exception { byte [ ] buf = new byte [ default_buffer_size ] ; for ( int count ; -1 ! = ( count = in . read ( buf ) ) ; ) { self . write ( buf , 0 , count ) ; } self . flush ( ) ; return self ; }
public static string get version ( ) { return version ; }
public static double read swap double ( final byte [ ] data , final int offset ) { return double . long bit to double ( read swap long ( data , offset ) ) ; }
public static void put u short ( byte [ ] data , int offset , int value ) { int i = offset ; data [ i++ ] = ( byte ) ( ( value > > > 0 ) & 0x f f ) ; data [ i++ ] = ( byte ) ( ( value > > > 8 ) & 0x f f ) ; }
public static long get u int l e ( byte [ ] data ) { return get u int l e ( data , 0 ) ; }
public void set float ( long offset , float value ) { bound check ( offset , 4 ) ; super . set float ( offset , value ) ; }
public static short get u byte ( byte [ ] data ) { return ( short ) ( data [ 0 ] & 0x f f ) ; }
static public void assert null ( string message , object object ) { assert true ( message , object == null ) ; }
public string get fix ( ) { return fix ; }
public document get x m p document ( ) { return xmp document ; }
public java type get type ( ) { return _type ; }
public boolean be relation ( ) { return relation ; }
public boolean contain part ( package part name part name ) { return ( this . get part ( part name ) ! = null ) ; }
public final method parameter get parameter ( ) { return this . parameter ; }
public channel future close ( channel channel , close web socket frame frame ) { object util . check not null ( channel , `` channel `` ) ; return close ( channel , frame , channel . new promise ( ) ) ; }
public k last key ( ) { return get first last ( false ) ; }
public static string path to package name ( final string path ) { return path . replace ( '/ ' , ' . ' ) ; }
public boolean contain part ( package part name part name ) { return ( this . get part ( part name ) ! = null ) ; }
public part builder part ( string name , object part ) { return part ( name , part , null ) ; }
public string get package ( ) { return package ; }
public relationship get relationship ( ) { return relationship ; }
public input stream get wrap stream ( ) { return in ; }
public string to string ( ) { string builder sb = new string builder ( ) ; sb . append ( `` atts [ `` ) ; for ( int i = 0 ; i < attribute . size ( ) ; i++ ) { att att = attribute . get ( i ) ; sb . append ( att . get q name ( ) ) ; sb . append ( `` = `` ) ; sb . append ( att . get value ( ) ) ; sb . append ( `` ; `` ) ; } sb . append ( `` ] `` ) ; return sb . to string ( ) ; }
public final callable < object > create callable ( final zip archive entry zip archive entry , final input stream supplier source ) { final int method = zip archive entry . get method ( ) ; if ( method == zip method . unknown_code ) { throw new illegal argument exception ( `` method must be set on zip archive entry : `` + zip archive entry ) ; } final zip archive entry request zip archive entry request = create zip archive entry request ( zip archive entry , source ) ; return new callable < object > ( ) { @ override public object call ( ) throw exception { tl scatter stream . get ( ) . add archive entry ( zip archive entry request ) ; return null ; } } ; }
public output stream get output stream ( ) { return output stream ; }
public void set layout ( string layout ) { this . layout = layout ; } // -- void set layout ( string )
public void set margin left ( double point ) { if ( point ! = null || _p . be set p pr ( ) ) { get or create property ( ) . set margin leave ( point ) ; } }
public void set indentation ( double point ) { if ( point ! = null || _p . be set p pr ( ) ) { get or create property ( ) . set indentation ( point ) ; ; } }
public void set space before ( float space before ) { this . set number ( space_before , space before ) ; }
public final void set follow ( final boolean new value ) { follow = new value ; }
public void set bold ( boolean bold ) { if ( bold ) font . set bold weight ( boldweight_bold ) ; else font . set bold weight ( boldweight_normal ) ; }
public void set superscript ( double offset ) { set baseline ( offset == null ? null : math . ab ( offset ) ) ; }
public void set baseline ( double offset ) { if ( offset == null ) { get or create property ( ) . set baseline ( null ) ; } else { get or create property ( ) . set baseline ( ( int ) ( offset * 1000 ) ) ; } }
public part builder part ( string name , object part ) { return part ( name , part , null ) ; }
public void set text ( boolean text ) { this . text = text ; }
public slide atom set [ ] get slide atom set ( ) { return slide atom set ; }
public xml get xml ( ) { return xml ; }
public void set name ( string name ) { this . name = name ; } // -- void set name ( string )
public void set color ( p d gamma color ) { this . set color ( color , color ) ; }
public string get input path ( ) { return input path ; }
public void set export all ( boolean export ) { export all = export ; }
public string get comment ( ) { return comment ; }
public void untrack all column ( ) { track all columns = false ; max column width . clear ( ) ; untracked column . clear ( ) ; }
public void track all column ( ) { track all columns = true ; untracked column . clear ( ) ; }
public final column definition column ( ) { return column ; }
public void set picture data ( byte [ ] picture data ) { set picture data ( picture data , 0 , ( picture data == null ? 0 : picture data . length ) ) ; }
public vector aggregate row ( vector function f ) { vector r = new dense vector ( num row ( ) ) ; int n = num row ( ) ; for ( int row = 0 ; row < n ; row++ ) { r . set ( row , f . apply ( view row ( row ) ) ) ; } return r ; }
public int [ ] get column index ( ) { return column index ; }
public final boolean be auto configuration enable ( ) { return auto configuration enable ; }
protect final boolean be compress ( ) { return compress ; }
public static theme get theme ( http servlet request request ) { theme resolver theme resolver = get theme resolver ( request ) ; theme source theme source = get theme source ( request ) ; if ( theme resolver ! = null & & theme source ! = null ) { string theme name = theme resolver . resolve theme name ( request ) ; return theme source . get theme ( theme name ) ; } else { return null ; } }
public void set leave col ( short leave col ) { if ( window two ! =null ) { window two . set leave col ( left col ) ; } }
public param style get style ( ) { return style ; }
public string get title ( ) { return title ; }
public static theme get theme ( http servlet request request ) { theme resolver theme resolver = get theme resolver ( request ) ; theme source theme source = get theme source ( request ) ; if ( theme resolver ! = null & & theme source ! = null ) { string theme name = theme resolver . resolve theme name ( request ) ; return theme source . get theme ( theme name ) ; } else { return null ; } }
protect final graphics2 d get graphic ( ) { return graphic ; }
public boolean be relation ( ) { return relation ; }
public string [ ] get location ( ) { return this . location ; }
public void set a text ( string text ) throw illegal argument exception { set value ( text ) ; }
public void set comment ( string comment ) { super . set internal comment ( comment ) ; }
public string get rel ( ) { return rel ; }
public field get field ( ) { return field ; }
public void set page ( p d page page ) { this . page = page ; }
public output < long > shape ( ) { return shape ; }
public string get font name ( ) { return font name ; }
public short get font at index ( int index ) { int size = _string . get format run count ( ) ; unicode string . format run current run = null ; for ( int i=0 ; i < size ; i++ ) { unicode string . format run r = _string . get format run ( i ) ; if ( r . get character po ( ) > index ) { break ; } current run = r ; } if ( current run == null ) { return no_font ; } return current run . get font index ( ) ; }
public x w p f footer get footer ( enum type ) { if ( type == s t hdr ftr . even ) { return even page footer ; } else if ( type == s t hdr ftr . first ) { return first page footer ; } return default footer ; }
public x w p f footer get footer ( int page number ) { if ( page number == 1 & & first page footer ! = null ) { return first page footer ; } if ( page number % 2 == 0 & & even page footer ! = null ) { return even page footer ; } return default footer ; }
public void set margin left ( int margin leave ) { set property value ( new escher simple property ( escher property . text__textleft , margin leave ) ) ; }
public x w p f table create table ( int row , int col ) { x w p f table table = new x w p f table ( ct document . get body ( ) . add new tbl ( ) , this , row , col ) ; body element . add ( table ) ; table . add ( table ) ; return table ; }
public table get table ( ) { return table ; }
public void set chart margin ( long top , long right , long bottom , long leave ) { this . set chart bottom margin ( bottom ) ; this . set chart right margin ( right ) ; this . set chart leave margin ( leave ) ; this . set chart right margin ( right ) ; }
public string get id ( ) { return f id ; }
public void set picture data ( byte [ ] picture data ) { set picture data ( picture data , 0 , ( picture data == null ? 0 : picture data . length ) ) ; }
public void clear ( ) { object . clear ( ) ; }
public string get id ( ) { return id ; }
public synchronize int get num element ( ) { return num element ; }
public param style get style ( ) { return style ; }
protect c t tc pr get tc pr ( ) { return ct tc . be set tc pr ( ) ? ct tc . get tc pr ( ) : ct tc . add new tc pr ( ) ; }
public void set color ( string rgb str ) { c t tc pr tcpr = get tc pr ( ) ; c t shd ctshd = tcpr . be set shd ( ) ? tcpr . get shd ( ) : tcpr . add new shd ( ) ; ctshd . set color ( `` auto `` ) ; ctshd . set val ( s t shd . clear ) ; ctshd . set fill ( rgb str ) ; }
public void add stream ( stream stream ) { if ( this . stream == null ) { this . stream = new hash set < stream > ( ) ; } this . stream . add ( stream ) ; }
protect byte [ ] new buffer ( int size ) { return new byte [ size ] ; }
public object get attribute ( string attribute name ) { return attribute map . get ( attribute name ) ; }
public string get extension ( ) { return this . extension ; } // -- string get extension ( )
public static string decompress string ( bytes ref byte ) throw data format exception { return decompress string ( byte . byte , byte . offset , byte . length ) ; }
public slide atom set [ ] get slide atom set ( ) { return slide atom set ; }
public string get new value ( ) { return new val ; }
public long get record type ( ) { return _type ; }
public void set start colour ( p d gamma colour ) { this . set colour by index ( 2 , colour ) ; }
public t put byte ( byte [ ] b ) { return put byte ( b , 0 , b . length ) ; }
public slide atom set [ ] get slide atom set ( ) { return slide atom set ; }
public void set text ( string text ) { this . text = text ; }
public static void store date ( date date , byte [ ] d ) { store date ( date , dest , 0 ) ; }
public string get title ( ) { return title ; }
public string get comment ( ) { return comment ; }
public long get record type ( ) { return _type ; }
public int get size b ( ) { return size b ; }
public void set other link ( final list < link > other link ) { this . other link = other link ; }
public void set type ( int type ) { little endian . put int ( _data , 4 , type ) ; }
public comment2000 atom get comment2000 atom ( ) { return comment atom ; }
public int get type ( ) { return type ; }
public void set type ( string type ) { this . type = type ; }
public long get record type ( ) { return _type ; }
public void set id ( string id ) { this . id = id ; }
public string get text ( ) { return text ; }
public long get record type ( ) { return _type ; }
public final synchronize metric record create record ( string record name ) { if ( buffer data . get ( record name ) == null ) { buffer data . put ( record name , new record map ( ) ) ; } return new record ( record name ) ; }
public final synchronize metric record create record ( string record name ) { if ( buffer data . get ( record name ) == null ) { buffer data . put ( record name , new record map ( ) ) ; } return new record ( record name ) ; }
public comment2000 atom get comment2000 atom ( ) { return comment atom ; }
public void cover static ( boolean cover static ) { this . cover static = cover static ; }
protect h s l f escher client data record get client data ( boolean create ) { h s l f escher client data record client data = get escher child ( escher client data record . record_id ) ; if ( client data == null & & create ) { client data = new h s l f escher client data record ( ) ; client data . set option ( ( short ) 15 ) ; client data . set record id ( escher client data record . record_id ) ; get sp container ( ) . add child before ( client data , escher textbox record . record_id ) ; } return client data ; }
public void set sheet ( h s l f sheet sheet ) { _sheet = sheet ; }
public double get width ( ) { return 1 . 0 / scale factor ; }
public string get embed ( ) { return embed ; }
public container get container ( ) { return container ; }
public static ptg [ ] parse formula ( string formula , h s s f sheet sheet ) { if ( formula == null ) { return null ; } int sheet index = sheet . get workbook ( ) . get sheet index ( sheet ) ; return h s s f formula parser . parse ( formula , sheet . get workbook ( ) , formula type . cell , sheet index ) ; }
public object get client data ( class key ) { if ( client data == null ) { return null ; } return client data . get ( key ) ; }
public void set property ( string p ) { property = p ; }
public void process event ( h s s f request req , input stream in ) { try { generic process event ( req , in ) ; } catch ( h s s f user exception hue ) { / * if an h s s f user exception user exception be throw , ignore it . * / } }
public byte to byte ( ) { return new byte ( byte value ( ) ) ; }
public void set date ( date date ) { system time utils . store date ( date , _data , 4 ) ; }
public http header get header ( ) { return this . header ; }
public string [ ] get header ( ) throw chunk not find exception { string header = get string from chunk ( main chunk . get message header ( ) ) ; if ( header == null ) { return null ; } return header . split ( `` \\r ? \\n `` ) ; }
protect static void set current message context ( message context mc ) { current message context . set ( mc ) ; }
public short get colour palette index ( ) { return field_5_colour palette index ; }
public void set picture data ( byte [ ] picture data ) { set picture data ( picture data , 0 , ( picture data == null ? 0 : picture data . length ) ) ; }
public string [ ] get index ( ) { return index ; }
public param style get style ( ) { return style ; }
public string get valid character ( ) { return character data . get character ( ) ; }
public short [ ] get short array ( string key ) { return get short array ( key , new short [ 0 ] ) ; }
public static value result set get ( simple result result ) { return new value result set ( result ) ; }
public byte to byte ( ) { return new byte ( byte value ( ) ) ; }
public set < string > get name ( ) { return new hash set < string > ( this . parameter . key set ( ) ) ; }
public boolean equal ( object other ) { return this==other ; }
public short get bar space ( ) { return field_1_bar space ; }
public short [ ] get short array ( string key ) { return get short array ( key , new short [ 0 ] ) ; }
public void set ya page n up ( int field_42_ya page n up ) { this . field_42_ya page n up = field_42_ya page n up ; }
public int get ya page n up ( ) { return field_42_ya page n up ; }
public byte to byte ( ) { return new byte ( byte value ( ) ) ; }
public byte to byte ( ) { return new byte ( byte value ( ) ) ; }
public void set max row ( integer value ) { this . max row = value ; }
protect fuzzy boolean match internal ( shadow shadow ) { return fuzzy boolean . no ; }
public frame [ ] get frames ( ) { return frame ; }
public string get text ( ) { return text ; }
public object [ ] get insert ( ) { return this . insert ; }
public string get paragraph end ( ) { return paragraph end ; }
public void write thin ( stream output out ) throw i o exception { super . write to ( out ) ; out . write v int ( byte . length ( ) ) ; }
public static int compute enum size ( final int field number , final int value ) { return compute tag size ( field number ) + compute enum size no tag ( value ) ; }
public static int compute int32 size ( final int field number , final int value ) { return compute tag size ( field number ) + compute int32 size no tag ( value ) ; }
public static int compute int32 size ( final int field number , final int value ) { return compute tag size ( field number ) + compute int32 size no tag ( value ) ; }
public string get message ( ) { return message ; }
public java . lang . string get display name ( ) { java . lang . object ref = display name_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; display name_ = s ; return s ; } }
public static code point iterator of utf8 byte ( final byte [ ] bytes ) { return of utf8 byte ( byte , 0 , byte . length ) ; }
public static transport request unwrap request ( transport request request ) { if ( request instanceof proxy request ) { return ( ( proxy request ) request ) . wrap ; } return request ; }
public java . util . list < com . google . protobuf . any > get detail list ( ) { return details_ ; }
public config parse option set syntax ( config syntax syntax ) { if ( this . syntax == syntax ) return this ; else return new config parse option ( syntax , this . origin description , this . allow miss , this . includer , this . class loader ) ; }
public string get message ( ) { return message ; }
public string get descriptor ( ) { return descriptor ; }
public field get field ( ) { return field ; }
public string get path ( ) { return this . path ; }
public string get path ( ) { return path ; }
public stream priority set dependency ( int dependency ) { this . dependency = dependency ; return this ; }
public string get remote ( ) { return remote ; }
public t get item ( ) { return item ; }
public string get key ( ) { return key ; }
public @ nullable string get path ( ) { return path ; }
public static < t extend panache entity base > list < t > list ( string query , sort sort , object . . . params ) { throw jpa operation . implementation injection miss ( ) ; }
public static < t extend panache entity base > list < t > list ( string query , object . . . params ) { throw jpa operation . implementation injection miss ( ) ; }
public static < t extend panache entity base > list < t > list ( string query , object . . . params ) { throw jpa operation . implementation injection miss ( ) ; }
public void set page size ( int page size ) { this . page size = page size ; }
public sort and ( string name , direction direction ) { column . add ( new column ( name , direction ) ) ; return this ; }
public sort and ( string name , direction direction ) { column . add ( new column ( name , direction ) ) ; return this ; }
public sort direction ( direction direction ) { for ( column column : column ) { column . direction = direction ; } return this ; }
public string get name ( ) { return identity ; }
public static < t > test subscriber < t > create ( ) { return new test subscriber < t > ( ) ; }
public void set ignore ( boolean ignore ) { this . ignore = ignore ; }
public line consumer get ignore line consumer ( ) { return ignore line consumer ; }
public duration to duration ( ) { return this ; }
public static < t > test subscriber < t > create ( ) { return new test subscriber < t > ( ) ; }
public boolean have next ( ) { return ( this . next obj ! = null ) ; }
public static < e > queue < e > synchronize queue ( queue < e > queue ) { return synchronize . queue ( queue , null ) ; }
public int leave ( int node ) { return leave [ node ] ; }
public int next unset bit ( final int i ) { int x = i / 64 ; if ( x > = this . get number of word ( ) ) return -1 ; long w = ~this . data [ x ] ; w > > > = i ; if ( w ! = 0 ) { return i + long . number of trail zero ( w ) ; } ++x ; for ( ; x < this . get number of word ( ) ; ++x ) { if ( this . data [ x ] ! = ~0 ) { return x * 64 + long . number of trail zero ( ~this . data [ x ] ) ; } } return -1 ; }
protect unsupported operation exception create unsupported operation exception ( string name ) { return new unsupported operation exception ( name + `` be not implement by `` + this . get class ( ) . get name ( ) ) ; }
public byte buf get byte buf ( ) { byte buf ret = delegate . get byte buf ( ) ; return ret ; }
public void remove subscription error ( i subscription error delegate subscription error ) { on subscription error . remove ( subscription error ) ; }
public s s l configuration get ssl ( ) { if ( ssl == null ) { ssl = new s s l configuration ( ) ; } return ssl ; }
public inet address get address ( ) { return address . get address ( ) ; }
public byte buf get byte buf ( ) { byte buf ret = delegate . get byte buf ( ) ; return ret ; }
public int get query timeout ( ) { return this . query timeout ; }
public boolean be accept ( ) { return accept ; }
public line consumer get ignore line consumer ( ) { return ignore line consumer ; }
public http header get header ( ) { return this . header ; }
public synchronize long get max size ( ) { return max size ; }
public http request with body ( body body ) { this . body = body ; return this ; }
public void set idle timeout ( int idle timeout ) { _idle timeout = idle timeout ; reserve thread executor reserve = get bean ( reserve thread executor . class ) ; if ( reserve ! = null ) reserve . set idle timeout ( idle timeout , time unit . millisecond ) ; }
public string get field name ( ) { return field name ; }
public request spec builder add multi part ( string control name , string file name , byte [ ] bytes ) { spec . multi part ( control name , file name , byte ) ; return this ; }
public web test client . response spec exists ( string name ) { get cookie ( name ) ; return this . response spec ; }
public multi part spec builder empty file name ( ) { return file name ( null ) ; }
public void add auth info ( string scheme , byte auth [ ] ) { cnxn . add auth info ( scheme , auth ) ; }
public void set port ( int port ) { this . port = port ; }
public service response get response ( ) { return response ; }
public void set status ( string status ) { this . status = status ; } // -- void set status ( string )
public int get status ( ) { return status type . get status code ( ) ; }
public response builder set status code ( int status code ) { rest assure response . set status code ( status code ) ; return this ; }
public result matcher date value ( string name , long value ) { return result - > { mock http servlet response response = result . get response ( ) ; string header value = response . get header ( name ) ; assert not null ( `` response do not contain header ' `` + name + `` ' `` , header value ) ; http header header = new http header ( ) ; header . set date ( `` expect `` , value ) ; header . set ( `` actual `` , header value ) ; assert equal ( `` response header ' `` + name + `` '= ' `` + header value + `` ' `` + `` do not match expect value ' `` + header . get first ( `` expect `` ) + `` ' `` , header . get first date ( `` expect `` ) , header . get first date ( `` actual `` ) ) ; } ; }
public encoder config default query parameter charset ( string charset ) { return new encoder config ( default content charset , charset , should append default content charset to content type if undefined , content encoders , content type to default charset , true ) ; }
public encoder config default content charset ( charset charset ) { string charset a string = not null ( charset , charset . class ) . to string ( ) ; return new encoder config ( charset a string , default query parameter charset , should append default content charset to content type if undefined , content encoders , content type to default charset , true ) ; }
public encoder config default query parameter charset ( string charset ) { return new encoder config ( default content charset , charset , should append default content charset to content type if undefined , content encoders , content type to default charset , true ) ; }
public void add ( number number ) { element . add ( number == null ? json null . instance : new json primitive ( number ) ) ; }
public document default definition get default ( ) { return this . default ; }
public json object get config ( ) { return config ; }
public string get key store password ( ) { return this . key store password ; }
public string get request u r i ( ) { return this . request u r i ; }
public void shutdown ( ) { }
public string get base u r l ( ) { return this . base u r l ; }
public url to u r l ( ) throw malformed u r l exception { return base . to u r l ( ) ; }
public e get entity ( ) { return entity ; }
public static uri get base u r i ( final uri uri ) { if ( uri == null ) return null ; try { return new uri ( uri . get scheme ( ) , null , uri . get host ( ) , uri . get port ( ) , uri . get path ( ) , null , null ) ; } catch ( u r i syntax exception e ) { return null ; } }
public int site ( string parameter ) throw i o exception { return send command ( f t p command . site , parameter ) ; }
public void set report d t d event ( boolean report dtd event ) { this . report dtd event = report dtd event ; }
public void set file specification ( p d file specification f ) { ref . set item ( c o s name . f , f ) ; }
protect boolean have forward header ( server http request request ) { http header header = request . get header ( ) ; for ( string header name : forwarded_header_names ) { if ( header . contains key ( header name ) ) { return true ; } } return false ; }
public int get port ( ) { return port ; }
public void set provider ( string provider ) { this . provider = provider ; }
public void set image form ( p d form x object image form ) { this . image form = image form ; }
public set < object > get provider instance ( ) { return collection . unmodifiable set ( provider instance ) ; }
public static iterable < annotation > get tester annotation ( annotate element class or method ) { synchronize ( annotation cache ) { list < annotation > annotation = annotation cache . get ( class or method ) ; if ( annotation == null ) { annotation = new array list < > ( ) ; for ( annotation a : class or method . get declared annotation ( ) ) { if ( a . annotation type ( ) . be annotation present ( tester annotation . class ) ) { annotation . add ( a ) ; } } annotation = collection . unmodifiable list ( annotation ) ; annotation cache . put ( class or method , annotation ) ; } return annotation ; } }
public byte [ ] element ( ) { return element ; }
public void set length ( long length ) { this . length = length ; }
public long skip ( final long n ) throw i o exception { if ( n < = 0 || be directory ( ) ) { return 0 ; } final long available = entry size - entry offset ; final long skip = i o utils . skip ( be , math . min ( n , available ) ) ; count ( skip ) ; entry offset += skip ; return skip ; }
public string get comment ( ) { return comment ; }
public string get value ( ) { return value ; }
public type target ( ) { return target ; }
public void register value target ( target target ) { if ( target == null ) { target = new vector ( ) ; } target . add element ( target ) ; }
public void remove last token ( ) { if ( previous token==null ) { first token = current token = null ; } else { current token = previous token ; current token . set next token ( null ) ; } }
public void set iteration ( boolean iterate ) { _flags = iteration on . set boolean ( _flags , iterate ) ; }
public void for each ( final closure < ? super e > closure ) { iterable utils . for each ( iterable , closure ) ; }
public int get position ( ) { return position ; }
public void set function name ( name name ) { function name = name ; if ( name ! = null ) name . set parent ( this ) ; }
public name get function name ( ) { return function name ; }
public value make closure ( expression expression , int ref , x path context context ) throw x path exception { if ( ref == 1 ) { return new closure ( ) ; } else { return new memo closure ( ) ; } }
public string get condition ( ) { return condition ; }
public int get from int ( ) { return get from ( ) ; }
public boolean be class initializer ( ) { return method info . be static initializer ( ) ; }
public static list < method > get setter ( class < ? > clazz ) { method [ ] method = clazz . get method ( ) ; list < method > list = new array list < method > ( ) ; for ( method method : method ) { if ( be setter ( method ) ) { list . add ( method ) ; } } return list ; }
public void set source ( file source ) { this . source = source ; }
public static string encode byte ( byte [ ] source ) { return encode byte ( source , 0 , source . length , no_options ) ; } // end encode byte
public list < string > get variable name ( ) { return this . variable name ; }
public type get type ( ) { return type ; }
public string get expression ( ) { return expression ; }
public policy with statement ( statement . . . statement ) { set statement ( array . a list ( statement ) ) ; return this ; }
public void set fragment ( final string fragment ) { this . fragment = fragment ; }
public xml get xml ( ) { return xml ; }
public void set require ( boolean require ) { this . require = require ; }
public void set allow header ( @ nullable list < string > allow header ) { if ( allow header ! = null ) { this . allow header = allow header ; } }
public static boolean class exist ( string name ) { object c = class . get ( name ) ; if ( c == null ) { try { / * note : do * not * change this to bsh class manager plain class for name ( ) or equivalent . this class must not touch any other bsh class . * / c = class . for name ( name ) ; } catch ( class not find exception e ) { } if ( c ! = null ) class . put ( c , `` unused `` ) ; } return c ! = null ; }
public int get slot ( ) { return slot ; }
public boolean get scope ( ) { return scope ; }
public t default value ( collection < ? extend v > val ) { this . default value = new array list < > ( val ) ; return ( t ) this ; }
public void set provider ( string provider ) { this . provider = provider ; }
public string get url ( ) { return url ; }
public static void main ( string [ ] args ) throw exception { }
public string get event ( ) { return event ; }
public string get message ( ) { return cmd ! = null ? cmd . get message ( ) : null ; }
public static < t > t get type property ( scriptable s , int index , class < t > type ) { object val = get property ( s , index ) ; if ( val == scriptable . not_found ) { val = null ; } return type . cast ( context . j to java ( val , type ) ) ; }
public void add action ( entity identity insert action action ) { log . tracev ( `` add an entity identity insert action for [ { 0 } ] object `` , action . get entity name ( ) ) ; add insert action ( action ) ; }
public void set language ( final string language ) { this . language = list . create ( language ) ; }
public token peek token ( ) { while ( need more token ( ) ) { fetch more token ( ) ; } return this . token . get ( 0 ) ; }
public boolean equal ( object other ) { return this==other ; }
public void remove ( int amount ) { int size = stack . size ( ) ; for ( int i=size-1 ; i > size-1-amount ; i -- ) { pop with message ( i ) ; } }
public int get level ( ) { return level ; }
public string get remote ( ) { return remote ; }
public void set right ( final string right ) { this . right = list . create ( right ) ; }
public void set syntax parser ( syntax parser syntax parser ) { if ( syntax parser == null ) { throw new illegal argument exception ( `` text parser should not be null ! `` ) ; } this . syntax parser = syntax parser ; }
public void set color ( p d gamma color ) { this . set color ( color , color ) ; }
public void set paint mark occurrence border ( boolean paint border ) { paint mark occurrence border = paint border ; if ( mark occurrences support ! =null ) { mark occurrences support . set paint border ( paint border ) ; } }
public long time ( ) { return time ; }
public string get pattern ( ) { return pattern ; }
public static x m l reader create x m l reader ( boolean validating , boolean namespace aware ) throw exception { s a x parser factory factory = s a x parser factory . new instance ( ) ; factory . set validating ( validate ) ; factory . set namespace aware ( namespace aware ) ; s a x parser parser = factory . new s a x parser ( ) ; return parser . get x m l reader ( ) ; }
public void set token factory ( token factory < ? > factory ) { _input . get token source ( ) . set token factory ( factory ) ; }
public static component get at ( j menu self , int index ) { return self . get menu component ( index ) ; }
public void set color ( p d gamma color ) { this . set color ( color , color ) ; }
public static marker get detach marker ( string name ) { return marker factory . get detached marker ( name ) ; }
public void set manager ( manager manager ) { this . manager = manager ; }
public float next tab stop ( float x , int tab offset ) { if ( tab size == 0 ) { return x ; } int ntabs = ( ( int ) x - tab base ) / tab size ; return tab base + ( ( ntabs + 1f ) * tab size ) ; }
public parser get ( ) { return ( parser ) pool . get ( ) ; }
public string get hyperlink id ( ) { return hyperlink . get id ( ) ; }
public boolean be flag set ( short mask ) { return ( value & mask ) ! = 0 ; }
public boolean get paint border ( ) { return p . get paint border ( ) ; }
protect set < string > get visible attribute ( ) { if ( ! be prototype ( ) ) { return null ; } else if ( f visible attribute == null ) { initialize visible attribute ( ) ; } return f visible attribute ; }
public string get action ( ) { return action ; }
public void set view ( view view ) { this . view = view ; }
public int hash code ( ) { return name . hash code ( ) ; } // hash code
public void set id ( string id ) { this . id = id ; }
public boolean be match after ( ) { return this . match after ; }
public boolean exists ( ) { return this . file . exists ( ) ; }
public boolean be read only ( ) { return this . read only ; }
public void set tablength ( final int tab length ) { this . tab length = tab length ; }
protect synchronized void set history file ( string history file ) { this . history file = history file ; }
protect synchronized void set history file ( string history file ) { this . history file = history file ; }
public string get font name ( ) { return font name ; }
public icon style add to icon style object extension ( final abstract object icon style object extension ) { this . get icon style object extension ( ) . add ( icon style object extension ) ; return this ; }
public r text area get r text area ( ) { return text area ; }
public static boolean parse boolean ( char sequence char ) { return ( char . length ( ) == 4 ) & & ( char . char at ( 0 ) == 't ' || char . char at ( 0 ) == 't ' ) & & ( char . char at ( 1 ) == ' r ' || char . char at ( 1 ) == ' r ' ) & & ( char . char at ( 2 ) == ' u ' || char . char at ( 2 ) == ' u ' ) & & ( char . char at ( 3 ) == ' e ' || char . char at ( 3 ) == ' e ' ) ; }
public string get name ( ) { return this . name ; } // -- string get name ( )
public void put ( string key , boolean value ) { if ( value ) put ( new boolean attribute ( key ) ) ; else remove ( key ) ; }
public boolean be boolean ( ) { return false ; }
public void set margin left ( int margin leave ) { set property value ( new escher simple property ( escher property . text__textleft , margin leave ) ) ; }
public int get margin line position ( ) { return margin size in char ; }
public r text area get r text area ( ) { return text area ; }
public r text area base get r text area base ( ) { return text area ; }
public boolean be match ( ) { return match ; }
public void set search selection only ( boolean selection only ) { if ( selection only ! =this . selection only ) { this . selection only = selection only ; fire property change ( property_selection_only , ! selection only , selection only ) ; if ( selection only ) { throw new unsupported operation exception ( `` search in selection be not currently support `` ) ; } } }
public boolean get search selection only ( ) { return selection only ; }
public boolean contains ( int value ) { for ( int i = 0 ; i < count ; i++ ) if ( entry [ i ] == value ) return true ; return false ; }
public index [ ] index ( ) { return index ; }
public static void run from servlet ( ) { be run from servlet . set ( true ) ; }
public boolean be connect ( ) { return false ; }
public static boolean set once ( atomic reference < disposable > upstream , disposable next , class < ? > observer ) { object helper . require non null ( next , `` next be null `` ) ; if ( ! upstream . compare and set ( null , next ) ) { next . dispose ( ) ; if ( upstream . get ( ) ! = disposable helper . dispose ) { report double subscription ( observer ) ; } return false ; } return true ; }
public void rethrow any build exception ( ) { build exception ex = get build exception ( ) ; if ( ex ! = null ) { throw ex ; } }
protect final void complete ( ) { actual . on complete ( ) ; }
public static throwable on observable error ( throwable error ) { func1 < throwable , throwable > f = on observable subscribe error ; if ( f ! = null ) { return f . call ( error ) ; } return error ; }
public c o s object get c o s object ( c o s name key ) { c o s base object = get item ( key ) ; if ( object instanceof c o s object ) { return ( c o s object ) object ; } return null ; }
public static boolean be array zero ( final byte [ ] a , final int size ) { for ( int i = 0 ; i < size ; i++ ) { if ( a [ i ] ! = 0 ) { return false ; } } return true ; }
public long get long ( ) { long ret = delegate . get long ( ) ; return ret ; }
public boolean set resource ( int index , disposable resource ) { for ( ; ; ) { disposable o = get ( index ) ; if ( o == disposable helper . dispose ) { resource . dispose ( ) ; return false ; } if ( compare and set ( index , o , resource ) ) { if ( o ! = null ) { o . dispose ( ) ; } return true ; } } }
public throwable get error ( ) { return error ; }
public t get value ( ) { return value ; }
public error get error ( ) { return this . error ; }
public final u assert value set ( collection < ? extend t > expect ) { if ( expect . be empty ( ) ) { assert no value ( ) ; return ( u ) this ; } for ( t v : this . value ) { if ( ! expect . contains ( v ) ) { throw fail ( `` value not in the expected collection : `` + value and class ( v ) ) ; } } return ( u ) this ; }
public boolean match ( t value ) { check predicate ( predicate ) ; return predicate . test ( value ) ; }
public long count ( ) { return count . get ( ) ; }
protect void reset ( ) { terminate = false ; }
public string [ ] get error message ( ) { return init error message ( ) ; }
public static int size ( object list ) { if ( list == null ) return 0 ; if ( list instanceof list ) return ( ( list < ? > ) list ) . size ( ) ; return 1 ; }
public static void assert null ( object object ) { assert null ( object , null ) ; }
public tag get tag ( ) { return this . tag ; }
public void await ( long timeout millis ) { delegate . await ( timeout millis ) ; }
public static void reset ( ) { if ( lockdown ) { return ; } init ( ) ; on computation scheduler = null ; on i o scheduler = null ; on new thread scheduler = null ; on generic schedule executor service = null ; }
public void start boolean ( ) { }
public void shutdown ( ) { }
public void set parse time ( long time ) { parse time = time ; }
public time unit get time unit ( ) { return this . time unit ; }
public boolean be function ( ) { return this . function ; }
public throwable get throwable ( ) { return throwable ; }
public throwable get throwable ( ) { if ( observer . get ( ) == terminate ) { return error ; } return null ; }
public j s o n object get request j s o n object ( ) { return request j s o n object ; }
public @ non null static message source add message ( @ non null string code , @ non null string message ) { if ( string utils . be not empty ( code ) & & string utils . be not empty ( message ) ) { message map . put ( new message key ( locale . get default ( ) , code ) , message ) ; } return this ; }
public final u assert never ( t value ) { int s = value . size ( ) ; for ( int i = 0 ; i < s ; i++ ) { t v = this . value . get ( i ) ; if ( object helper . equal ( v , value ) ) { throw fail ( `` value at position `` + i + `` be equal to `` + value and class ( value ) + `` ; expect them to be different `` ) ; } } return ( u ) this ; }
public static < t > predicate < t > null predicate ( ) { return null predicate . null predicate ( ) ; }
public void remove subscription error ( i subscription error delegate subscription error ) { on subscription error . remove ( subscription error ) ; }
public string buffer get class buffer ( ) { return class buffer ; }
public void add stream ( stream stream ) { if ( this . stream == null ) { this . stream = new hash set < stream > ( ) ; } this . stream . add ( stream ) ; }
public static void add breadcrumb ( final @ not null breadcrumb breadcrumb , final @ nullable object hint ) { get current hub ( ) . add breadcrumb ( breadcrumb , hint ) ; }
public date get date ( ) { return timestamp ; }
public int get level ( ) { return level ; }
public string get path ( ) { return path ; }
public string snapshot ( ) { return snapshot ; }
public void set id ( final string id ) { this . id = id ; }
public synchronize void touch ( final object key , final object value ) { remove ( key ) ; put ( key , value ) ; }
public boolean be enable ( ) { return this . enable ; } // -- boolean be enable ( )
public static @ not null breadcrumb http ( final @ not null string url , final @ not null string method ) { final breadcrumb breadcrumb = new breadcrumb ( ) ; breadcrumb . set type ( `` http `` ) ; breadcrumb . set category ( `` http `` ) ; breadcrumb . set data ( `` url `` , url ) ; breadcrumb . set data ( `` method `` , method . to upper case ( locale . root ) ) ; return breadcrumb ; }
protect object do suspend ( object transaction ) throw transaction exception { throw new transaction suspension not support exception ( `` transaction manager [ `` + get class ( ) . get name ( ) + `` ] do not support transaction suspension `` ) ; }
public void set environment prefix ( string environment prefix ) { this . environment prefix = environment prefix ; }
public void set include ( string value ) { this . include = value ; }
public file get disk cache file ( ) { return disk cache file ; }
protect string get session factory uuid ( ) { return session factory uuid ; }
public date get end time ( ) { return end time ; }
public string get id ( ) { return id ; }
public string get name ( ) { return name ; }
public string get email ( ) { return this . email ; } // -- string get email ( )
public string get comment ( ) { return comment ; }
public short get alignment ( ) { return alignment ; }
public string get ( string key ) { map < string , string > map = get property map ( ) ; if ( ( map ! = null ) & & ( key ! = null ) ) { return map . get ( key ) ; } else { return null ; } }
public void set trace enable ( boolean trace enable ) { this . trace enable = trace enable ; if ( this . trace enable & & ( this . trace listener == null ) ) { this . trace listener = new ew trace listener ( ) ; } }
public i marker [ ] find marker ( string type , boolean include subtypes ) throw core exception { if ( resource . length == 0 ) return new i marker [ 0 ] ; array list < i marker > result = new array list < > ( ) ; do find marker ( result , type , include subtypes ) ; return result . to array ( new i marker [ result . size ( ) ] ) ; }
public static m d c adapter get m d c adapter ( ) { return mdc adapter ; }
public metadata adapter get metadata adapter ( ) { if ( metadata adapter ! = null ) return metadata adapter ; else { try { return ( metadata adapter = new javassist adapter ( ) ) ; } catch ( throwable e ) { if ( reflection . log ! = null ) reflection . log . warn ( `` could not create javassist adapter , use java reflection adapter `` , e ) ; return ( metadata adapter = new java reflection adapter ( ) ) ; } } }
public void warn ( string format , object arg ) { format and log ( log_level_warn , format , arg , null ) ; }
public void info ( string format , object arg ) { format and log ( log_level_info , format , arg , null ) ; }
public string get format ( ) { return format ; }
public io . vertx . reactivex . core . buffer . buffer get buffer ( string name ) { io . vertx . reactivex . core . buffer . buffer ret = io . vertx . reactivex . core . buffer . buffer . new instance ( ( io . vertx . core . buffer . buffer ) delegate . get buffer ( name ) ) ; return ret ; }
public string to string ( ) { return delegate . to string ( ) ; }
public byte to byte ( ) { return new byte ( byte value ( ) ) ; }
public string get column name ( int po ) { string ret = delegate . get column name ( po ) ; return ret ; }
public io . vertx . axle . core . buffer . buffer set float ( int po , float f ) { delegate . set float ( po , f ) ; return this ; }
public io . vertx . axle . core . buffer . buffer set long l e ( int po , long l ) { delegate . set long l e ( po , l ) ; return this ; }
public byte [ ] get buffer ( ) { return buf ; }
public double get priority ( ) { return priority ; }
public argument create argument ( ) { return this . create argument ( false ) ; }
public static int int value ( final string option ) { return ( ( integer ) option . option value . get ( option ) ) . int value ( ) ; }
public json object get config ( ) { return config ; }
public double get worker start ( ) { return worker start ; }
public < t > t get ( string key ) { t ret = ( t ) delegate . get ( key ) ; return ret ; }
public io . vertx . axle . core . stream . read stream < io . vertx . axle . core . http . web socket > websocket stream ( int port , string host , string request u r i , io . vertx . axle . core . multi map header , websocket version version ) { io . vertx . axle . core . stream . read stream < io . vertx . axle . core . http . web socket > ret = io . vertx . axle . core . stream . read stream . new instance ( delegate . websocket stream ( port , host , request u r i , header . get delegate ( ) , version ) , type_arg_7 ) ; return ret ; }
public string get protocol ( ) { return protocol ; }
public string to string ( ) { string ret = delegate . to string ( ) ; return ret ; }
public io . vertx . reactivex . core . eventbus . message consumer register ( string address ) { io . vertx . reactivex . core . eventbus . message consumer ret = io . vertx . reactivex . core . eventbus . message consumer . new instance ( ( io . vertx . core . eventbus . message consumer ) delegate . register ( address ) ) ; return ret ; }
public completion stage < void > clear ( ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __clear ( handler ) ; } ) ; }
public long get long ( ) { long ret = delegate . get long ( ) ; return ret ; }
public boolean be double ( ) { boolean ret = delegate . be double ( ) ; return ret ; }
public int size ( ) { int ret = delegate . size ( ) ; return ret ; }
public completion stage < void > clear ( ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __clear ( handler ) ; } ) ; }
public completion stage < void > unlink ( string link ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __unlink ( link , handler ) ; } ) ; }
public completion stage < void > link ( string link , string exist ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __link ( link , exist , handler ) ; } ) ; }
public completion stage < void > unlink ( string link ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __unlink ( link , handler ) ; } ) ; }
public < v > io . vertx . axle . core . future < v > map ( v value ) { io . vertx . axle . core . future < v > ret = io . vertx . axle . core . future . new instance ( delegate . map ( value ) , io . vertx . lang . axle . type arg . unknown ( ) ) ; return ret ; }
public static < t > io . vertx . axle . core . future < t > succeed future ( t result ) { io . vertx . axle . core . future < t > ret = io . vertx . axle . core . future . new instance ( io . vertx . core . future . succeed future ( result ) , io . vertx . lang . axle . type arg . unknown ( ) ) ; return ret ; }
public string get path ( ) { return cookie path ; }
public boolean be secure ( ) { return protocol in use . be secure ( ) ; }
public io . vertx . axle . core . http . http client request get ( string request u r i ) { io . vertx . axle . core . http . http client request ret = io . vertx . axle . core . http . http client request . new instance ( delegate . get ( request u r i ) ) ; return ret ; }
public io . vertx . axle . core . http . http client request get ab ( string absolute u r i ) { io . vertx . axle . core . http . http client request ret = io . vertx . axle . core . http . http client request . new instance ( delegate . get abs ( absolute u r i ) ) ; return ret ; }
public io . vertx . axle . core . http . http client request post ab ( string absolute u r i ) { io . vertx . axle . core . http . http client request ret = io . vertx . axle . core . http . http client request . new instance ( delegate . post ab ( absolute u r i ) ) ; return ret ; }
public io . vertx . axle . core . http . http client request get ab ( string absolute u r i ) { io . vertx . axle . core . http . http client request ret = io . vertx . axle . core . http . http client request . new instance ( delegate . get abs ( absolute u r i ) ) ; return ret ; }
public completion stage < void > clear ( ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __clear ( handler ) ; } ) ; }
public io . vertx . axle . core . stream . read stream < io . vertx . axle . core . http . web socket > websocket stream ( string request u r i , io . vertx . axle . core . multi map header , websocket version version ) { io . vertx . axle . core . stream . read stream < io . vertx . axle . core . http . web socket > ret = io . vertx . axle . core . stream . read stream . new instance ( delegate . websocket stream ( request u r i , header . get delegate ( ) , version ) , type_arg_15 ) ; return ret ; }
public io . vertx . axle . core . stream . read stream < io . vertx . axle . core . http . web socket > websocket stream ( int port , string host , string request u r i , io . vertx . axle . core . multi map header , websocket version version ) { io . vertx . axle . core . stream . read stream < io . vertx . axle . core . http . web socket > ret = io . vertx . axle . core . stream . read stream . new instance ( delegate . websocket stream ( port , host , request u r i , header . get delegate ( ) , version ) , type_arg_7 ) ; return ret ; }
public io . vertx . axle . core . stream . write stream < io . vertx . axle . core . buffer . buffer > sender ( int port , string host ) { io . vertx . axle . core . stream . write stream < io . vertx . axle . core . buffer . buffer > ret = io . vertx . axle . core . stream . write stream . new instance ( delegate . sender ( port , host ) , type_arg_1 ) ; return ret ; }
public string get expect ( ) { return f expect ; }
public string write handler i d ( ) { string ret = delegate . write handler i d ( ) ; return ret ; }
public static boolean to boolean ( pointer base pointer ) { return pointer . be non null ( ) ; }
public io . vertx . axle . core . json . pointer . json pointer copy ( ) { io . vertx . axle . core . json . pointer . json pointer ret = io . vertx . axle . core . json . pointer . json pointer . new instance ( delegate . copy ( ) ) ; return ret ; }
public io . vertx . axle . core . json . pointer . json pointer append ( list < string > token ) { delegate . append ( token ) ; return this ; }
public boolean be double ( ) { boolean ret = delegate . be double ( ) ; return ret ; }
public string binary handler i d ( ) { string ret = delegate . binary handler i d ( ) ; return ret ; }
public boolean get delete ( ) { return this . delete ; }
public string get mode ( ) { return mode ; }
public completion stage < integer > size ( ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __size ( handler ) ; } ) ; }
public completion stage < void > clear ( ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __clear ( handler ) ; } ) ; }
public completion stage < long > add and get ( long value ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __add and get ( value , handler ) ; } ) ; }
public completion stage < long > increment and get ( ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __increment and get ( handler ) ; } ) ; }
public completion stage < long > add and get ( long value ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __add and get ( value , handler ) ; } ) ; }
public io . vertx . axle . core . stream . pump stop ( ) { delegate . stop ( ) ; return this ; }
public io . vertx . axle . core . stream . pump start ( ) { delegate . start ( ) ; return this ; }
public < v > io . vertx . axle . core . future < v > map ( v value ) { io . vertx . axle . core . future < v > ret = io . vertx . axle . core . future . new instance ( delegate . map ( value ) , io . vertx . lang . axle . type arg . unknown ( ) ) ; return ret ; }
public io . vertx . axle . core . http . http client request request ( http method method , request option option ) { io . vertx . axle . core . http . http client request ret = io . vertx . axle . core . http . http client request . new instance ( delegate . request ( method , option ) ) ; return ret ; }
public static i file system get local file system ( ) { return internal file system core . get instance ( ) . get local file system ( ) ; }
public io . vertx . axle . core . stream . write stream < io . vertx . axle . core . buffer . buffer > sender ( int port , string host ) { io . vertx . axle . core . stream . write stream < io . vertx . axle . core . buffer . buffer > ret = io . vertx . axle . core . stream . write stream . new instance ( delegate . sender ( port , host ) , type_arg_1 ) ; return ret ; }
public void deploy ( string verticle , vertx vertx , deployment option option , handler < async result < string > > completion handler ) { this . vertx = vertx ; string message = ( option . be worker ( ) ) ? `` deploy worker verticle `` : `` deploy verticle `` ; vertx . deploy verticle ( verticle , option , create handler ( message , completion handler ) ) ; }
public int length ( object obj ) { if ( be array ( obj ) ) { return ( ( list ) obj ) . size ( ) ; } else if ( be map ( obj ) ) { return get property key ( obj ) . size ( ) ; } else if ( obj instanceof string ) { return ( ( string ) obj ) . length ( ) ; } throw new json path exception ( `` length operation can not be apply to `` + obj ! =null ? obj . get class ( ) . get name ( ) : `` null `` ) ; }
public string get value ( ) { return value ; }
public completion stage < io . vertx . axle . core . http . web socket > web socket ( string request u r i ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __web socket ( request u r i , handler ) ; } ) ; }
public integer get max length ( ) { return max length ; }
public param style get style ( ) { return style ; }
public string get version ( ) { return version == null ? `` `` : version ; }
public void set duplicate ( duplicate df ) { duplicate = df . get value ( ) ; }
public int get tag ( ) { return tag ; }
public void set name to resolve ( string name to resolve ) { this . name to resolve = name to resolve ; }
public string get event ( ) { return event ; }
public int get index ( ) { return index ; }
public int size ( ) { return data . length ; }
public void remove last token ( ) { if ( previous token==null ) { first token = current token = null ; } else { current token = previous token ; current token . set next token ( null ) ; } }
public class get type ( ) { return ( this . type ) ; }
public void set property ( string p ) { property = p ; }
public static string identity to string ( object object ) { if ( object == null ) { return null ; } string buffer buffer = new string buffer ( ) ; identity to string ( buffer , object ) ; return buffer . to string ( ) ; }
public constructor < ? > get constructor ( ) { return this . constructor ; }
protect void set alias ( string alias ) { this . alias = alias ; }
public json serializer < ? > get key serializer ( ) { return _key serializer ; }
public static float [ ] unshuffle float array ( byte [ ] input ) throw i o exception { float [ ] output = new float [ input . length / 4 ] ; int num process = impl . unshuffle ( input , 0 , 4 , input . length , output , 0 ) ; assert ( num process == input . length ) ; return output ; }
public static int [ ] unshuffle int array ( byte [ ] input ) throw i o exception { int [ ] output = new int [ input . length / 4 ] ; int num process = impl . unshuffle ( input , 0 , 4 , input . length , output , 0 ) ; assert ( num process == input . length ) ; return output ; }
public static synchronize name pool get default name pool ( ) { if ( default name pool == null ) { default name pool = new name pool ( ) ; } return default name pool ; }
public void set additional type ( list < medium type > additional type ) { this . additional type = additional type ; }
public string get server ( ) { return server ; }
public license client license ( ) { return license client ; }
public location get location ( ) { return location ; }
public source get source ( ) { return source ; }
public a s tree parse expression ( symbol table tbl ) throw compile error { a s tree leave = parse conditional expr ( tbl ) ; if ( ! be assign op ( lex . look ahead ( ) ) ) return leave ; int t = lex . get ( ) ; a s tree right = parse expression ( tbl ) ; return assign expr . make assign ( t , leave , right ) ; }
protect void exit ( ct element e ) { ct element ret = element deque . pop ( ) ; if ( ret ! = e ) { throw new runtime exception ( `` inconsistent stack `` ) ; } super . exit ( e ) ; }
public item type get primitive item type ( ) { return this ; }
public final method parameter get parameter ( ) { return this . parameter ; }
public void set input ( string input ) { this . input = input ; }
public policy with statement ( statement . . . statement ) { set statement ( array . a list ( statement ) ) ; return this ; }
public name get name ( ) { return name ; }
public void set async annotation type ( class < ? extend annotation > async annotation type ) { assert . not null ( async annotation type , `` 'async annotation type ' must not be null `` ) ; set < class < ? extend annotation > > async annotation type = new hash set < class < ? extend annotation > > ( ) ; async annotation type . add ( async annotation type ) ; this . pointcut = build pointcut ( async annotation type ) ; }
public byte [ ] element ( ) { return element ; }
public final method parameter get parameter ( ) { return this . parameter ; }
public ct method [ ] get method ( ) { return new ct method [ 0 ] ; }
public ct enum < ? > create ( string qualify name ) { return create ( factory . package ( ) . get or create ( get package name ( qualified name ) ) , get simple name ( qualified name ) ) ; }
public void set variable ( list < variable initializer > variable ) { assert not null ( variable ) ; this . variable . clear ( ) ; for ( variable initializer vi : variable ) { add variable ( vi ) ; } }
public compilation unit remove from cache ( string file path ) { return cache compilation unit . remove ( file path ) ; }
public i compilation unit get compilation unit ( ) { return this . compilation unit ; }
public < t > ct constructor < t > create ( ct class < t > target , set < modifier kind > modifier , list < ct parameter < ? > > parameter , set < ct type reference < ? extend throwable > > thrown type , ct block < t > body ) { ct constructor < t > constructor = create ( target , modifier , parameter , thrown type ) ; constructor . set body ( body ) ; return constructor ; }
public < t > ct constructor < t > create ( ct class < t > target , set < modifier kind > modifier , list < ct parameter < ? > > parameter , set < ct type reference < ? extend throwable > > thrown type ) { ct constructor < t > constructor = factory . core ( ) . create constructor ( ) ; constructor . set modifier ( modifier ) ; constructor . set parameter ( parameter ) ; constructor . set thrown type ( thrown type ) ; target . add constructor ( constructor ) ; return constructor ; }
public < t > ct class < t > create ( string qualify name ) { if ( have inner type ( qualified name ) > 0 ) { ct class < ? > declare class = create ( get declare type name ( qualified name ) ) ; return create ( declare class , get simple name ( qualified name ) ) ; } return create ( factory . package ( ) . get or create ( get package name ( qualified name ) ) , get simple name ( qualified name ) ) ; }
public < t > ct type reference < t > create simply qualified reference ( string qualify name ) { ct type reference ref = create reference ( qualified name ) ; ref . get package ( ) . set implicit ( true ) ; return ref ; }
public ct type reference < long > long primitive type ( ) { return long_primitive . clone ( ) ; }
public ct type reference < long > long primitive type ( ) { return long_primitive . clone ( ) ; }
public ct type reference < long > long type ( ) { return long . clone ( ) ; }
public void add reference ( reference ref ) { reference . add element ( ref ) ; }
public static boolean get logging ( ) { return should log ; }
public final u assert not terminate ( ) { if ( do . get count ( ) == 0 ) { throw fail ( `` subscriber terminate ! `` ) ; } return ( u ) this ; }
public void check parent consistency ( ct element element ) { final set < ct element > inconsistent parent = new hash set < > ( ) ; new ct scanner ( ) { private deque < ct element > previous = new array deque < > ( ) ; @ override protect void enter ( ct element e ) { if ( e ! = null ) { if ( ! previous . be empty ( ) ) { try { if ( e . get parent ( ) ! = previous . get last ( ) ) { inconsistent parent . add ( e ) ; } } catch ( parent not initialize exception ignore ) { inconsistent parent . add ( e ) ; } } previous . add ( e ) ; } super . enter ( e ) ; } @ override protect void exit ( ct element e ) { if ( e == null ) { return ; } if ( e . equal ( previous . get last ( ) ) ) { previous . remove last ( ) ; } else { throw new runtime exception ( `` inconsistent stack `` ) ; } super . exit ( e ) ; } } . scan ( element ) ; assert equal ( `` all parent have to be consistent `` , 0 , inconsistent parent . size ( ) ) ; }
public < t > ct constructor < t > create ( ct class < t > target , set < modifier kind > modifier , list < ct parameter < ? > > parameter , set < ct type reference < ? extend throwable > > thrown type , ct block < t > body ) { ct constructor < t > constructor = create ( target , modifier , parameter , thrown type ) ; constructor . set body ( body ) ; return constructor ; }
public var get accessor for value ( resolve type value type , string formal name ) { return new annotation access field var ( this , value type , formal name ) ; }
public void add listener ( listener listener ) { listener . add ( listener ) ; }
public synchronize hashtable get filter hash ( ) { if ( filter hash == null ) { filter hash = new hashtable ( get filter ( ) . size ( ) ) ; for ( enumeration e = get filter ( ) . element ( ) ; e . have more element ( ) ; ) { filter filter = ( filter ) e . next element ( ) ; filter hash . put ( filter . get token ( ) , filter . get value ( ) ) ; } } return filter hash ; }
public synchronize void add filter ( filter filter ) { if ( be reference ( ) ) { throw no child allow ( ) ; } filter . add element ( filter ) ; filter hash = null ; }
public node parent ( ) { return parent ; }
public object get old value ( ) { return old value ; }
public void set target ( ast node target ) { assert not null ( target ) ; this . target = target ; target . set parent ( this ) ; }
public int get position ( ) { return position ; }
public object eval ( string expression ) { return get value ( expression , object . class ) ; }
public static synchronize map < string , statistic > get statistic ( ) { map < string , statistic > result = new hash map < string , statistic > ( ) ; for ( statistic stat : statistic table . value ( ) ) { result . put ( stat . get scheme ( ) , stat ) ; } return result ; }
public object create instance ( class < ? > clazz ) throw s a x exception { if ( ! factory . be empty ( ) ) { factory factory = factory . get ( clazz ) ; if ( factory ! =null ) return factory . create instance ( ) ; } return class factory . create ( clazz ) ; }
public final method parameter get parameter ( ) { return this . parameter ; }
public list super interface type ( ) { return this . super interface type ; }
public boolean be match ( ) { return match ; }
public cflow pointcut new cflow pointcut ( ) { cflow pointcut result = new cflow pointcut ( this ) ; return result ; }
public string get aspect name ( ) { return this . advice . get aspect name ( ) ; }
public void register value target ( target target ) { if ( target == null ) { target = new vector ( ) ; } target . add element ( target ) ; }
public void set service locator interface ( class < ? > interface type ) { this . service locator interface = interface type ; }
public static boolean equal ( object a , object b ) { return a == b || ( a ! = null & & a . equal ( b ) ) ; }
public static boolean equal in proxy ( advised support a , advised support b ) { return ( a == b || ( equal proxied interface ( a , b ) & & equal advisor ( a , b ) & & a . get target source ( ) . equal ( b . get target source ( ) ) ) ) ; }
public void set bean name ( string bean name ) { this . bean name = bean name ; }
public int hash code ( ) { return name . hash code ( ) ; } // hash code
public string get proxy ( ) { return proxy ; }
public void freeze ( ) { frozen = true ; }
protected factory builder support get proxy builder ( ) { factory builder support proxy = local proxy builder . get ( ) ; if ( proxy == null ) { return global proxy builder ; } else { return proxy ; } }
protect void remove singleton ( string bean name ) { synchronize ( this . singleton object ) { this . singleton object . remove ( bean name ) ; this . singleton factory . remove ( bean name ) ; this . early singleton object . remove ( bean name ) ; this . registered singleton . remove ( bean name ) ; } }
public int get exit code ( ) { return exit code ; }
public void set message ( string message ) { this . message = message ; }
public void set bean name ( string bean name ) { this . bean name = bean name ; }
public void exclude ( string pattern ) { _set . exclude ( pattern tuple . from ( pattern ) ) ; }
public void set method ( int method ) { this . method = method ; }
public string get advisor bean name prefix ( ) { return this . advisor bean name prefix ; }
public void set filter ( boolean filter ) { this . filter = filter ; }
public static matcher < method > return ( final matcher < ? super class < ? > > return type ) { return new return ( return type ) ; }
public void set name ( list < string > names ) { this . name = name ; }
public void set name ( string name ) { this . name = name ; }
public void set target bean name ( string target bean name ) { this . target bean name = string utils . trim all whitespace ( target bean name ) ; }
public synchronize int get max idle ( ) { return this . max idle ; }
public synchronize long get max wait millis ( ) { return this . max wait millis ; }
public synchronize void set when ( time comparison c ) { when = c ; }
public void set aspect bean name ( string aspect bean name ) { this . aspect bean name = aspect bean name ; }
public string get nest path ( ) { return this . nested path ; }
public object get attribute ( string attribute name ) { return attribute map . get ( attribute name ) ; }
public static < t > t a type ( closure cl , class < t > clazz ) { if ( clazz . be interface ( ) & & ! ( clazz . be instance ( cl ) ) ) { if ( trait . be trait ( clazz ) ) { method sam method = cache s a m class . get s a m method ( clazz ) ; if ( sam method ! =null ) { map impl = collection . singleton map ( sam method . get name ( ) , cl ) ; return ( t ) proxy generator . instance . instantiate aggregate ( impl , collection . < class > singleton list ( clazz ) ) ; } } return ( t ) proxy . new proxy instance ( clazz . get class loader ( ) , new class [ ] { clazz } , new convert closure ( cl ) ) ; } try { return a type ( ( object ) cl , clazz ) ; } catch ( groovy cast exception ce ) { try { return ( t ) proxy generator . instance . instantiate aggregate from base class ( cl , clazz ) ; } catch ( groovy runtime exception cause ) { throw new groovy cast exception ( `` error casting closure to `` + clazz . get name ( ) + `` , reason : `` + cause . get message ( ) ) ; } } }
public autowire capable bean factory get autowire capable bean factory ( ) throw illegal state exception { return get bean factory ( ) ; }
public void set return value require ( boolean return value require ) { this . return value require = return value require ; }
public static type codec < byte buffer > custom ( data type . custom type type ) { return new custom codec ( type ) ; }
public static boolean be annotation a qualifier ( annotation anno ) { class < ? extend annotation > anno type = anno . annotation type ( ) ; return anno type . be annotation present ( qualifier . class ) ; }
public throwable get cause ( ) { return cause ; }
public string get resource description ( ) { return resource description ; }
public string get bean factory name ( ) { return bean factory name ; }
protect void destroy instance ( t instance ) throw exception { }
public t get instance ( ) { return instance ; }
public boolean have index argument value ( int index ) { return this . indexed argument value . contains key ( index ) ; }
public void add indexed argument value ( int index , object value ) { add indexed argument value ( index , new value holder ( value ) ) ; }
public field get field ( ) { return field ; }
public void increase nest level ( ) { this . nesting level++ ; }
public dependency descriptor for fallback match ( ) { return new dependency descriptor ( this ) { @ override public boolean fallback match allow ( ) { return true ; } } ; }
public boolean fallback match allow ( ) { return false ; }
public static void warning ( final string message ) { log ( warn , message ) ; }
public void register value target ( target target ) { if ( target == null ) { target = new vector ( ) ; } target . add element ( target ) ; }
public void add bean ( string name , object bean ) { this . bean . put ( name , bean ) ; }
protect string resolve path ( string path ) { if ( this . property resolver == null ) { this . property resolver = new standard environment ( ) ; } return ( this . ignore unresolvable placeholder ? this . property resolver . resolve placeholder ( path ) : this . property resolver . resolve required placeholder ( path ) ) ; }
public void set bean name ( string bean name ) { this . bean name = bean name ; }
public boolean be boolean ( ) { return false ; }
public void set order ( int order ) { this . order = order ; }
public class < ? > get service interface ( ) { return this . service interface ; }
public static < t > t find or create service ( service locator locator , class < t > type , annotation . . . qualifier ) throw multi exception { if ( locator == null || type == null ) throw new illegal argument exception ( ) ; service handle < t > ret val = locator . get service handle ( type , qualifier ) ; if ( ret val == null ) { return locator . create and initialize ( type ) ; } return ret val . get service ( ) ; }
public type target ( ) { return target ; }
public boolean be match ( ) { return match ; }
public binding bind ( bind binding ) { internal binding . add ( bind ) ; return binding ; }
protect t initialize ( ) throw exception { return callable . call ( ) ; }
public void fire component register ( component definition component definition ) { this . event listener . component register ( component definition ) ; }
public string get dependency check ( ) { return this . dependency check ; }
public boolean be primary ( ) { return this . primary ; }
public void set primary ( boolean primary ) { this . primary = primary ; }
public string get qualifier component ( ) { return version . get qualifier ( ) ; }
public list < bean factory post processor > get bean factory post processor ( ) { return this . bean factory post processor ; }
public double bootstrap ( double [ ] x , double [ ] y , int iteration , boolean strict ) { final int x length = x . length ; final int y length = y . length ; final double [ ] combine = new double [ x length + y length ] ; system . arraycopy ( x , 0 , combine , 0 , x length ) ; system . arraycopy ( y , 0 , combine , x length , y length ) ; final enumerate real distribution dist = new enumerate real distribution ( rng , combine ) ; final long d = integral kolmogorov smirnov statistic ( x , y ) ; int great count = 0 ; int equal count = 0 ; double [ ] cur x ; double [ ] cur y ; long cur d ; for ( int i = 0 ; i < iteration ; i++ ) { cur x = dist . sample ( x length ) ; cur y = dist . sample ( y length ) ; cur d = integral kolmogorov smirnov statistic ( cur x , cur y ) ; if ( cur d > d ) { great count++ ; } else if ( cur d == d ) { equal count++ ; } } return strict ? great count / ( double ) iteration : ( great count + equal count ) / ( double ) iteration ; }
protect void copy custom editor to ( property editor registry target , string nested property ) { string actual property name = ( nested property ! = null ? property accessor utils . get property name ( nested property ) : null ) ; if ( this . custom editor ! = null ) { for ( map . entry < class < ? > , property editor > entry : this . custom editor . entry set ( ) ) { target . register custom editor ( entry . get key ( ) , entry . get value ( ) ) ; } } if ( this . custom editor for path ! = null ) { for ( map . entry < string , custom editor holder > entry : this . custom editor for path . entry set ( ) ) { string editor path = entry . get key ( ) ; custom editor holder editor holder = entry . get value ( ) ; if ( nested property ! = null ) { int po = property accessor utils . get first nested property separator index ( editor path ) ; if ( po ! = -1 ) { string editor nest property = editor path . substring ( 0 , po ) ; string editor nested path = editor path . substring ( pos + 1 ) ; if ( editor nest property . equal ( nested property ) || editor nest property . equal ( actual property name ) ) { target . register custom editor ( editor holder . get registered type ( ) , editor nest path , editor holder . get property editor ( ) ) ; } } } else { target . register custom editor ( editor holder . get registered type ( ) , editor path , editor holder . get property editor ( ) ) ; } } } }
public bean definition get bean definition ( ) { return this . bean definition ; }
public string get scope ( ) { return this . get ( `` / $ scope `` ) ; }
public bean definition get bean definition ( ) { return this . bean definition ; }
public boolean have target type ( ) { return ( this . target type instanceof class ) ; }
public void set id ( string id ) { this . id = id ; }
public comparator get comparator ( ) { return comparator ; }
public void set bean name ( string bean name ) { this . bean name = bean name ; }
public string [ ] get dependent bean ( string bean name ) { set < string > dependent bean = this . dependent bean map . get ( bean name ) ; if ( dependent bean == null ) { return new string [ 0 ] ; } return string utils . to string array ( dependent bean ) ; }
protect boolean have dependent bean ( string bean name ) { return this . dependent bean map . contains key ( bean name ) ; }
public void add bean ( string name , object bean ) { this . bean . put ( name , bean ) ; }
public void add bean ( string name , object bean ) { this . bean . put ( name , bean ) ; }
public void set access ( access access ) { this . access = access ; this . add pending change ( `` access `` , access . to j s o n value ( ) ) ; }
public final type get element type ( ) { return element type ; }
public boolean be boolean ( ) { return false ; }
public boolean be empty ( ) { return empty ; }
public bean definition get bean definition ( ) { return this . bean definition ; }
public void set bean name ( string bean name ) { this . bean name = bean name ; }
protect string get attribute name in session ( web request request , string attribute name ) { return this . attribute name prefix + attribute name ; }
public void parse property element ( element bean ele , bean definition bd ) { node list nl = bean ele . get child node ( ) ; for ( int i = 0 ; i < nl . get length ( ) ; i++ ) { node node = nl . item ( i ) ; if ( be candidate element ( node ) & & node name equal ( node , property_element ) ) { parse property element ( ( element ) node , bd ) ; } } }
public void parse qualifier element ( element bean ele , abstract bean definition bd ) { node list nl = bean ele . get child node ( ) ; for ( int i = 0 ; i < nl . get length ( ) ; i++ ) { node node = nl . item ( i ) ; if ( be candidate element ( node ) & & node name equal ( node , qualifier_element ) ) { parse qualifier element ( ( element ) node , bd ) ; } } }
public void parse property element ( element bean ele , bean definition bd ) { node list nl = bean ele . get child node ( ) ; for ( int i = 0 ; i < nl . get length ( ) ; i++ ) { node node = nl . item ( i ) ; if ( be candidate element ( node ) & & node name equal ( node , property_element ) ) { parse property element ( ( element ) node , bd ) ; } } }
public void parse property element ( element bean ele , bean definition bd ) { node list nl = bean ele . get child node ( ) ; for ( int i = 0 ; i < nl . get length ( ) ; i++ ) { node node = nl . item ( i ) ; if ( be candidate element ( node ) & & node name equal ( node , property_element ) ) { parse property element ( ( element ) node , bd ) ; } } }
public double get max merge m b for force merge ( ) { return ( ( double ) max merge size for force merge ) /1024/1024 ; }
public int get dependency check ( ) { return this . dependency check ; }
public string get init method name ( ) { return this . init method name ; }
public string get destroy method name ( ) { return this . destroy method name ; }
public bean definition get bean definition ( ) { return this . bean definition ; }
protect final p d document get source document ( ) { return source document ; }
public namespace resolver get namespace resolver ( ) { return namespace context ; }
public void set property ( final string property ) { this . property name = property ; }
public object get property value ( ) { return property value ; }
public void set convert ( jaxb convert value ) { this . convert = value ; }
public string get property name ( ) { return property name ; }
protect void register custom editor ( property editor registry registry ) { property editor registry support registry support = ( registry instanceof property editor registry support ? ( property editor registry support ) registry : null ) ; if ( registry support ! = null ) { registry support . use config value editor ( ) ; } if ( ! this . property editor registrar . be empty ( ) ) { for ( property editor registrar registrar : this . property editor registrar ) { try { registrar . register custom editor ( registry ) ; } catch ( bean creation exception ex ) { throwable root cause = ex . get most specific cause ( ) ; if ( root cause instanceof bean currently in creation exception ) { bean creation exception bce = ( bean creation exception ) root cause ; if ( be currently in creation ( bce . get bean name ( ) ) ) { if ( logger . be debug enable ( ) ) { logger . debug ( `` property editor registrar [ `` + registrar . get class ( ) . get name ( ) + `` ] failed because it try to obtain currently create bean ' `` + ex . get bean name ( ) + `` ' : `` + ex . get message ( ) ) ; } on suppressed exception ( ex ) ; continue ; } } throw ex ; } } } if ( ! this . custom editor . be empty ( ) ) { for ( map . entry < class < ? > , class < ? extend property editor > > entry : this . custom editor . entry set ( ) ) { class < ? > require type = entry . get key ( ) ; class < ? extend property editor > editor class = entry . get value ( ) ; registry . register custom editor ( require type , bean utils . instantiate class ( editor class ) ) ; } } }
public static string get date string ( date self ) { return date format . get date instance ( date format . short ) . format ( self ) ; }
public void set text ( string text ) { this . text = text ; }
public void set always create ( boolean always create ) { this . always create = always create ; }
public void set value ( string value ) { this . value = value ; }
public string get property name ( ) { return property name ; }
public sort get index sort ( ) { return index sort ; }
public void set page size ( int page size ) { this . page size = page size ; }
public void set page ( p d page page ) { this . page = page ; }
public void set page ( p d page page ) { this . page = page ; }
public static void be assignable from ( class < ? > super type , class < ? > type , string message , object . . . value ) { if ( super type . be assignable from ( type ) == false ) { throw new illegal argument exception ( string . format ( message , value ) ) ; } }
protected factory bean < ? > get factory bean ( string bean name , object bean instance ) throw bean exception { if ( ! ( bean instance instanceof factory bean ) ) { throw new bean creation exception ( bean name , `` bean instance of type [ `` + bean instance . get class ( ) + `` ] be not a factory bean `` ) ; } return ( factory bean < ? > ) bean instance ; }
public type get type ( ) { if ( field type == null ) { field type = type . get return type ( get signature ( ) ) ; } return field type ; }
public type component ( ) { return component ; }
public list < bean post processor > get bean post processor ( ) { return this . bean post processor ; }
public string get init method ( ) { return this . init method ; }
public string get destroy method name ( ) { return this . destroy method name ; }
public void set destroy method name ( @ nullable string destroy method name ) { this . destroy method name = ( string utils . have text ( destroy method name ) ? destroy method name : null ) ; }
protect void clear merge bean definition ( string bean name ) { this . merge bean definition . remove ( bean name ) ; }
public constructor < ? > get constructor ( ) { return this . constructor ; }
public void set value default ( string value default ) { this . value default = value default ; }
public boolean be optional ( ) { return boolean . true . equal ( optional ) ; }
public static < t > constructor < t > get default constructor ( class < t > clazz ) throw property not find exception { if ( be abstract class ( clazz ) ) { return null ; } try { constructor < t > constructor = clazz . get declared constructor ( no_param_signature ) ; ensure accessibility ( constructor ) ; return constructor ; } catch ( no such method exception nme ) { throw new property not find exception ( `` object class [ `` + clazz . get name ( ) + `` ] must declare a default ( no-argument ) constructor `` ) ; } }
public void set member ( final i member [ ] member ) { assert . be not null ( member ) ; f members= member ; }
public string get init method ( ) { return this . init method ; }
public spring application builder main ( class < ? > main application class ) { this . application . set main application class ( main application class ) ; return this ; }
public long get startup date ( ) { return this . startup date ; }
public spring application builder context class ( class < ? extend configurable application context > cl ) { this . application . set application context class ( cl ) ; return this ; }
public void set main application class ( class < ? > main application class ) { this . main application class = main application class ; }
public void set generator ( final string generator ) { this . generator = generator ; }
public name get name ( ) { return name ; }
public reason get reason ( ) { return reason ; }
public static void add collection converter ( converter registry converter registry ) { conversion service conversion service = ( conversion service ) converter registry ; converter registry . add converter ( new array to collection converter ( conversion service ) ) ; converter registry . add converter ( new collection to array converter ( conversion service ) ) ; converter registry . add converter ( new array to array converter ( conversion service ) ) ; converter registry . add converter ( new collection to collection converter ( conversion service ) ) ; converter registry . add converter ( new map to map converter ( conversion service ) ) ; converter registry . add converter ( new array to string converter ( conversion service ) ) ; converter registry . add converter ( new string to array converter ( conversion service ) ) ; converter registry . add converter ( new array to object converter ( conversion service ) ) ; converter registry . add converter ( new object to array converter ( conversion service ) ) ; converter registry . add converter ( new collection to string converter ( conversion service ) ) ; converter registry . add converter ( new string to collection converter ( conversion service ) ) ; converter registry . add converter ( new collection to object converter ( conversion service ) ) ; converter registry . add converter ( new object to collection converter ( conversion service ) ) ; converter registry . add converter ( new stream converter ( conversion service ) ) ; }
public static class < ? > get collection type ( class < ? extend collection > collection class ) { return resolvable type . for class ( collection class ) . a collection ( ) . resolve generic ( ) ; }
public string get description ( ) { return this . description ; }
public long get max wait ( ) { return this . max wait ; }
public void set config location ( final uri config location ) { this . config location = config location ; reconfigure ( config location ) ; }
public static parser option get default parser option ( ) { return default jvm parser option ; }
public void set source ( file source ) { this . source = source ; }
public client http request factory get request factory ( ) { return this . request factory ; }
public void set tld skip pattern ( collection < string > pattern ) { assert . not null ( pattern , `` pattern must not be null `` ) ; this . tld skip pattern = new link hash set < > ( pattern ) ; }
public set < string > get tld skip pattern ( ) { return this . tld skip pattern ; }
public string get i d ( ) { return this . get ( `` / $ id `` ) ; }
public void set allow eager init ( boolean allow eager init ) { this . allow eager init = allow eager init ; }
public charset get charset ( ) { return this . charset ; }
public boolean be enable ( ) { return this . enable ; } // -- boolean be enable ( )
public string get extension ( ) { return this . extension ; } // -- string get extension ( )
public int get port ( ) { return this . port ; }
public collection < object id > get candidate ( ) { return candidate ; }
public s s l config key store ( string password ) { validate . not empty ( password , `` password can not be empty `` ) ; return key store ( system . get property ( `` user . home `` ) + file . separator char + `` . keystore `` , password ) ; }
public string get servlet name ( ) { return config . get servlet name ( ) ; }
public boolean be match ( ) { return match ; }
protect string get name ( ) { return this . name ; }
public void set location ( resource location ) { this . location = location ; }
public void set store dir ( string store dir ) { this . store dir = store dir ; }
public list < profile > get active profile ( ) { return active profile ; }
protect void refresh application context ( application context context ) { if ( context instanceof configurable application context ) { configurable application context cac = ( configurable application context ) context ; if ( ! cac . be active ( ) ) { cac . refresh ( ) ; } } }
public thread . uncaught exception handler get exception handler ( ) { return exception handler ; }
public void set main application class ( class < ? > main application class ) { this . main application class = main application class ; }
public class < ? > get main application class ( ) { return this . main application class ; }
public string get source ( ) { return source ; }
public void set environment prefix ( string environment prefix ) { this . environment prefix = environment prefix ; }
public spring application builder environment prefix ( string environment prefix ) { this . application . set environment prefix ( environment prefix ) ; return this ; }
public resource chain registration add resolver ( resource resolver resolver ) { assert . not null ( resolver , `` the provided resource resolver should not be null `` ) ; this . resolvers . add ( resolver ) ; if ( resolver instanceof version resource resolver ) { this . have version resolver = true ; } else if ( resolver instanceof path resource resolver ) { this . have path resolver = true ; } else if ( resolver instanceof web jar resource resolver ) { this . have webjars resolver = true ; } return this ; }
public void add configure schema ( schema location location ) { log ( `` add schema `` + location , project . msg_debug ) ; location . validate namespace ( ) ; schema location old = ( schema location ) schema location . get ( location . get namespace ( ) ) ; if ( old ! = null & & ! old . equal ( location ) ) { throw new build exception ( error_duplicate_schema + location ) ; } schema location . put ( location . get namespace ( ) , location ) ; }
public void set location ( string location ) { this . location = location ; }
public void set excludes ( list < string > excludes list ) { string [ ] exclude = excludes list . to array ( new string [ excludes list . size ( ) ] ) ; if ( excludes == null ) { this . exclude = null ; } else { set excludes ( excludes ) ; } }
public void fire comparison perform ( comparison comparison , comparison result outcome ) { fire ( comparison , outcome , comp listener ) ; if ( outcome == comparison result . equal ) { fire ( comparison , outcome , match listener ) ; } else { fire ( comparison , outcome , diff listener ) ; } }
public void set resource loader ( resource loader resource loader ) { this . resource loader = resource loader ; }
public void set unique ( boolean value ) { this . unique = value ; }
public resource chain registration add resolver ( resource resolver resolver ) { assert . not null ( resolver , `` the provided resource resolver should not be null `` ) ; this . resolvers . add ( resolver ) ; if ( resolver instanceof version resource resolver ) { this . have version resolver = true ; } else if ( resolver instanceof path resource resolver ) { this . have path resolver = true ; } else if ( resolver instanceof web jar resource resolver ) { this . have webjars resolver = true ; } return this ; }
public void visit item ( object item ) { item . add ( item ) ; }
public boolean be active ( ) { return this . active ; }
public directory get directory ( ) { return directory ; }
public static char [ ] get char ( short num ) { char [ ] hex = new char [ 4 ] ; hex [ 0 ] = hex_chars [ ( num > > 12 ) & 0x0 f ] ; hex [ 1 ] = hex_chars [ ( num > > 8 ) & 0x0 f ] ; hex [ 2 ] = hex_chars [ ( num > > 4 ) & 0x0 f ] ; hex [ 3 ] = hex_chars [ num & 0x0 f ] ; return hex ; }
public void write to ( writer writer ) throw i o exception { write to ( writer , writer config . minimal ) ; }
public static string find single main class ( jar file jar file , string class location , string annotation name ) throw i o exception { single main class callback callback = new single main class callback ( annotation name ) ; main class finder . do with main class ( jar file , class location , callback ) ; return callback . get main class name ( ) ; }
public static string find main class ( file root directory ) throw i o exception { return do with main class ( root directory , main class : : get name ) ; }
public file get destination ( ) { return this . destination ; }
public < t > map assert < string , t > get bean ( class < t > type ) { return get bean ( type , scope . include_ancestors ) ; }
public class < ? > get bean type ( ) { return this . bean type ; }
public class get type ( ) { return ( this . type ) ; }
public type get type ( ) { return type ; }
public static json array array ( double . . . value ) { if ( value == null ) { throw new null pointer exception ( `` value be null `` ) ; } json array array = new json array ( ) ; for ( double value : value ) { array . add ( value ) ; } return array ; }
public final t get object ( ) { return object ; }
public final boolean be empty ( ) { return buf and listener pair . be empty ( ) ; }
public @ nullable string get environment ( ) { return environment ; }
public < t > response entity < t > get for entity ( uri url , class < t > response type ) throw rest client exception { return this . rest template . get for entity ( apply root uri if necessary ( url ) , response type ) ; }
public < t > t get for object ( uri url , class < t > response type ) throw rest client exception { return this . rest template . get for object ( apply root uri if necessary ( url ) , response type ) ; }
public e get entity ( ) { return entity ; }
public boolean be cache ( ) { return cache ! = null ; }
public boolean be cache ( ) { return cache ! = null ; }
public collection < cache operation > get cache operation ( method method , class < ? > target class ) { object cache key = get cache key ( method , target class ) ; collection < cache operation > cache = this . attribute cache . get ( cache key ) ; if ( cached ! = null ) { return ( cache ! = null_caching_attribute ? cache : null ) ; } else { collection < cache operation > cache ops = compute cache operation ( method , target class ) ; if ( cache ops ! = null ) { if ( logger . be debug enable ( ) ) { logger . debug ( `` add cacheable method ' `` + method . get name ( ) + `` ' with attribute : `` + cache ops ) ; } this . attribute cache . put ( cache key , cache ops ) ; } else { this . attribute cache . put ( cache key , null_caching_attribute ) ; } return cache ops ; } }
public void set manager ( manager manager ) { this . manager = manager ; }
public compilation unit set import ( final node list < import declaration > import ) { assert not null ( import ) ; if ( import == this . import ) { return this ; } notify property change ( observable property . import , this . import , import ) ; if ( this . import ! = null ) this . import . set parent node ( null ) ; this . import = import ; set a parent node of ( import ) ; return this ; }
public compilation unit set import ( final node list < import declaration > import ) { assert not null ( import ) ; if ( import == this . import ) { return this ; } notify property change ( observable property . import , this . import , import ) ; if ( this . import ! = null ) this . import . set parent node ( null ) ; this . import = import ; set a parent node of ( import ) ; return this ; }
public static class get class ( string class name ) throw class not find exception { return get class ( class name , true ) ; }
public object get property ( string name ) { if ( name . equal ( `` name `` ) ) { return get display name ( ) ; } return null ; }
public string get bean factory name ( ) { return bean factory name ; }
public spring application builder log startup info ( boolean log startup info ) { this . application . set log startup info ( log startup info ) ; return this ; }
public list < bean post processor > get bean post processor ( ) { return this . bean post processor ; }
public @ non null static message source add message ( @ non null string code , @ non null string message ) { if ( string utils . be not empty ( code ) & & string utils . be not empty ( message ) ) { message map . put ( new message key ( locale . get default ( ) , code ) , message ) ; } return this ; }
public string get bean factory name ( ) { return bean factory name ; }
public boolean be return value require ( ) { return this . call meta data context . be return value require ( ) ; }
public source get source ( ) { return source ; }
public void set resource loader ( resource loader resource loader ) { this . resource loader = resource loader ; }
public property source get apply property source ( ) throw illegal state exception { assert . state ( this . applied property source ! = null , `` property source have not yet be apply `` ) ; return this . applied property source ; }
public final void set cache second ( int second ) { this . cache second = second ; }
public string get encode ( ) { return encode ; }
public void set remote invocation executor ( remote invocation executor remote invocation executor ) { this . remote invocation executor = remote invocation executor ; }
public list < bean factory post processor > get bean factory post processor ( ) { return this . bean factory post processor ; }
public string get bean factory name ( ) { return bean factory name ; }
public void set time zone ( time zone time zone ) { this . time zone = time zone ; }
public boolean lenient ( ) { return this . setting . lenient ( ) ; }
public jsonb date formatter get date formatter ( ) { return date formatter ; }
public void set formatter ( date formatter date formatter ) { assert . not null ( date formatter , `` date formatter must not be null `` ) ; this . date formatter = date formatter ; }
public date get date time ( ) { return date time ; }
public document default definition get default ( ) { return this . default ; }
protect boolean be eligible for override ( string class name ) { return ! be exclude ( class name ) ; }
public transformer get transformer ( ) { return i transformer ; }
public string get domain ( ) { return domain ; }
public void set method ( int method ) { this . method = method ; }
public void set name mode ( string name , int mode ) { this . name = name ; this . mode = mode ; }
public void set eager init filter ( boolean eager init filter ) { this . eager init filter = eager init filter ; }
public void add bean ( string name , object bean ) { this . bean . put ( name , bean ) ; }
public string get description ( ) { return this . description ; }
public void set limit ( int limit ) { this . limit = limit ; }
public void set value default ( string value default ) { this . value default = value default ; }
public void set category ( final list < category > category ) { this . category = category ; }
public void add notification ( notification info notification ) { m bean info lock . write lock ( ) . lock ( ) ; try { notification info result [ ] = new notification info [ notification . length + 1 ] ; system . arraycopy ( notification , 0 , result , 0 , notification . length ) ; result [ notification . length ] = notification ; notification = result ; this . info = null ; } finally { m bean info lock . write lock ( ) . unlock ( ) ; } }
public string get description ( ) { return this . description ; }
public void set resource ref ( boolean resource ref ) { this . resource ref = resource ref ; }
public context get context ( ) { return impl . get context ( ) ; }
public string get object name ( ) { return this . object name ; }
public class get type ( ) { return ( this . type ) ; }
public string get stub version ( ) { return stub version ; }
protect boolean always create new map ( ) { return false ; }
public string get class name ( ) { return class name ; }
public string get remote ( ) { return remote ; }
public static class loader default class loader ( ) { return thread . current thread ( ) . get context class loader ( ) ; }
public void set async annotation type ( class < ? extend annotation > async annotation type ) { assert . not null ( async annotation type , `` 'async annotation type ' must not be null `` ) ; this . async annotation type = async annotation type ; }
public void set async annotation type ( class < ? extend annotation > async annotation type ) { assert . not null ( async annotation type , `` 'async annotation type ' must not be null `` ) ; set < class < ? extend annotation > > async annotation type = new hash set < class < ? extend annotation > > ( ) ; async annotation type . add ( async annotation type ) ; this . pointcut = build pointcut ( async annotation type ) ; }
public completable future < execution result > execute async ( execution input . builder execution input builder ) { return execute async ( execution input builder . build ( ) ) ; }
public long time ( @ non null time unit unit ) { return unit . convert ( time , this . unit ) ; }
public double get rate ( time unit rate unit ) { return rate * ( double ) rate unit . to nanos ( 1 ) ; }
public t with delay ( delay delay ) { this . delay = delay ; return ( t ) this ; }
public void register value target ( target target ) { if ( target == null ) { target = new vector ( ) ; } target . add element ( target ) ; }
public string get name ( ) { return this . name ; }
public mutable property value add property value ( property value other ) { if ( other ! = null ) { property value [ ] pvs = other . get property value ( ) ; for ( property value pv : pvs ) { add property value ( new property value ( pv ) ) ; } } return this ; }
protect sync invoker get sync invoker ( ) { return sync invoker ; }
public void set time zone ( time zone time zone ) { this . time zone = time zone ; }
public property source get apply property source ( ) throw illegal state exception { assert . state ( this . applied property source ! = null , `` property source have not get be apply `` ) ; return this . applied property source ; }
public boolean be resource ref ( ) { return this . resource ref ; }
public void sort ( list < node > list ) { sort ( list , false ) ; }
public static string collection ( collection < ? > collection ) { if ( collection == null ) { return null_string ; } return array ( collection . to array ( new object [ collection . size ( ) ] ) ) ; }
public static int null safe hash code ( object obj ) { if ( obj == null ) { return 0 ; } if ( obj . get class ( ) . be array ( ) ) { if ( obj instanceof object [ ] ) { return null safe hash code ( ( object [ ] ) obj ) ; } if ( obj instanceof boolean [ ] ) { return null safe hash code ( ( boolean [ ] ) obj ) ; } if ( obj instanceof byte [ ] ) { return null safe hash code ( ( byte [ ] ) obj ) ; } if ( obj instanceof char [ ] ) { return null safe hash code ( ( char [ ] ) obj ) ; } if ( obj instanceof double [ ] ) { return null safe hash code ( ( double [ ] ) obj ) ; } if ( obj instanceof float [ ] ) { return null safe hash code ( ( float [ ] ) obj ) ; } if ( obj instanceof int [ ] ) { return null safe hash code ( ( int [ ] ) obj ) ; } if ( obj instanceof long [ ] ) { return null safe hash code ( ( long [ ] ) obj ) ; } if ( obj instanceof short [ ] ) { return null safe hash code ( ( short [ ] ) obj ) ; } } return obj . hash code ( ) ; }
public type target ( ) { return target ; }
public type get return type ( ) { return type . get return type ( descriptor ) ; }
public void set package ( boolean package ) { this . package = package ; } // -- void set package ( boolean )
public void set profile ( java . util . list < profile > profile ) { this . profile = profile ; } // -- void set profile ( java . util . list )
public string separator ( ) { return separator ; }
public void set source name ( string source name ) { this . source name = source name ; }
public static < e > collection < e > create collection ( class < ? > collection type , int capacity ) { return create collection ( collection type , null , capacity ) ; }
public web test client . response spec last modify ( long last modify ) { return assert header ( `` last- modified `` , last modify , get header ( ) . get last modified ( ) ) ; }
public static url a local u r l ( url url ) throw i o exception { return file locator . to file u r l ( url ) ; }
public void set exists ( final boolean exists ) { this . exist = exists ; }
public void set length ( long length ) throw i o exception { }
public static string get compress filename ( final string file name ) { return file name util . get compressed filename ( file name ) ; }
public string get file ( ) { return this . file ; } // -- string get file ( )
public boolean equal ( object obj ) { return ( this == obj || ( obj instanceof path resource & & this . path . equal ( ( ( path resource ) obj ) . path ) ) ) ; }
public int hash code ( ) { return name . hash code ( ) ; } // hash code
public static path [ ] file ( path directory ) throw i o exception { try ( directory stream < path > stream = file . new directory stream ( directory ) ) { return to array ( stream ) ; } }
public boolean equal ( object obj ) { return ( obj == this || ( obj instanceof file system resource & & this . path . equal ( ( ( file system resource ) obj ) . path ) ) ) ; }
protect string resolve placeholder ( string placeholder , property prop ) { string path = null ; string key = placeholder ; int end of path = placeholder . last index of ( '/ ' ) ; if ( end of path ! = -1 ) { path = placeholder . substring ( 0 , end of path ) ; key = placeholder . substring ( end of path + 1 ) ; } string value = resolve placeholder ( path , key , this . user prefs ) ; if ( value == null ) { value = resolve placeholder ( path , key , this . system prefs ) ; if ( value == null ) { value = prop . get property ( placeholder ) ; } } return value ; }
public void set resource u r l ( string resource u r l ) { this . resource u r l = resource u r l ; }
public void set override include synonyms default ( boolean override ) { this . override include synonyms default = override ; }
public string get loader name for resource ( string resource name ) { resource loader loader = get loader for resource ( resource name ) ; if ( loader == null ) { return null ; } return loader . get class ( ) . to string ( ) ; }
public static property load all property ( string resource name , class loader class loader ) throw i o exception { assert . not null ( resource name , `` resource name must not be null `` ) ; class loader class loader to use = class loader ; if ( class loader to use == null ) { class loader to use = class utils . get default class loader ( ) ; } enumeration < url > url = ( class loader to use ! = null ? class loader to use . get resource ( resource name ) : class loader . get system resource ( resource name ) ) ; property prop = new property ( ) ; while ( urls . have more element ( ) ) { url url = url . next element ( ) ; u r l connection con = url . open connection ( ) ; resource utils . use cache if necessary ( con ) ; input stream be = con . get input stream ( ) ; try { if ( resource name . end with ( xml_file_extension ) ) { prop . load from x m l ( be ) ; } else { prop . load ( be ) ; } } finally { be . close ( ) ; } } return prop ; }
public int hash code ( ) { return name . hash code ( ) ; } // hash code
public constructor < ? > [ ] get preferred constructor ( ) { return null ; }
public void increase nest level ( ) { this . nesting level++ ; if ( this . method parameter ! = null ) { this . method parameter . increase nest level ( ) ; } }
protect integer find order ( object obj ) { return ( obj instanceof order ? ( ( order ) obj ) . get order ( ) : null ) ; }
protect int get order ( object obj ) { integer order = find order ( obj ) ; return ( order ! = null ? order : order . lowest_precedence ) ; }
protect boolean be eligible for shadow ( string class name ) { return ! be exclude ( class name ) ; }
public string get parameter name ( ) { return parameter name ; }
public string get key ( ) { return key ; }
public void set value ( final string value ) { this . value = value ; }
public to string builder append ( string field name , short value ) { style . append ( buffer , field name , value ) ; return this ; }
public void execute ( runnable task , executor executor ) { synchronize ( task ) { task . add ( new task ( task , executor ) ) ; if ( current == null ) { current = executor ; executor . execute ( runner ) ; } } }
public void set method ( int method ) { this . method = method ; }
public void set trim string ( boolean trim string ) { this . trim string = trim string ; }
public string get path ( ) { return this . path ; }
public long get initial len ( ) { return initial file size ; }
public static string decode component ( final string s ) { return decode component ( s , http constant . default_charset ) ; }
public static string get package name ( class < ? > clazz ) { string class name = clazz . get name ( ) ; int last dot index = class name . last index of ( package_separator ) ; return ( last dot index ! = -1 ? class name . substring ( 0 , last dot index ) : `` `` ) ; }
public static boolean be assignable ( type type , type to type ) { return be assignable ( type , to type , null ) ; }
public static string get resource path ( ) { return resource path ; }
public void set order ( int order ) { this . order = order ; }
public void set new priority ( int new priority ) { if ( new priority < thread . min_priority || new priority > thread . max_priority ) { throw new build exception ( `` the thread priority be out of the range 1-10 `` ) ; } this . new priority = new integer ( new priority ) ; }
public byte string md5 ( ) { return digest ( `` md5 `` ) ; }
public node clear attribute ( ) { iterator < attribute > it = attribute ( ) . iterator ( ) ; while ( it . have next ( ) ) { it . next ( ) ; it . remove ( ) ; } return this ; }
public url get u r l ( ) throw i o exception { url url = resolve u r l ( ) ; if ( url == null ) { throw new file not find exception ( get description ( ) + `` can not be resolve to url because it do not exist `` ) ; } return url ; }
public void set target ( object target ) { set target source ( new singleton target source ( target ) ) ; }
public static boolean be empty ( object [ ] array ) { return ( array == null || array . length == 0 ) ; }
protected list < field > get field list ( ) { list < field > flist = new array list < field > ( ) ; for ( class < ? > cl = get class ( ) ; ! cl . equal ( structure . class ) ; cls = cl . get superclass ( ) ) { list < field > class field = new array list < field > ( ) ; field [ ] field = cl . get declared field ( ) ; for ( int i=0 ; i < field . length ; i++ ) { int modifier = field [ i ] . get modifier ( ) ; if ( modifier . be static ( modifier ) || ! modifier . be public ( modifier ) ) { continue ; } class field . add ( field [ i ] ) ; } flist . add all ( 0 , class field ) ; } return flist ; }
public void set method ( int method ) { this . method = method ; }
public protocol get protocol ( ) { return protocol ; }
public void digest ( message digest digest ) { f b utility . update with long ( digest , timestamp ( ) ) ; }
public static < a extend annotation > list < a > get repeatable annotation ( method method , class < a > annotation class ) { a [ ] annotation = method . get annotation by type ( annotation class ) ; if ( annotation == null || annotation . length == 0 ) { for ( annotation meta annotation : method . get annotation ( ) ) { annotation = meta annotation . annotation type ( ) . get annotation by type ( annotation class ) ; if ( annotation ! = null & & annotation . length > 0 ) { return array . a list ( annotation ) ; } } method superclass method = get overridden method ( method ) ; if ( superclass method ! = null ) { return get repeatable annotation ( superclass method , annotation class ) ; } } if ( annotation == null ) { return null ; } return array . a list ( annotation ) ; }
public executable get executable ( ) { return executable ; }
public void set max in memory size ( int byte count ) { this . max in memory size = byte count ; }
public log get logger ( ) { return logger ; }
public void set logger ( log logger ) { this . logger = logger ; }
public static void add application converter ( converter registry registry ) { add delimit string converter ( registry ) ; registry . add converter ( new string to duration converter ( ) ) ; registry . add converter ( new duration to string converter ( ) ) ; registry . add converter ( new number to duration converter ( ) ) ; registry . add converter ( new duration to number converter ( ) ) ; registry . add converter ( new string to period converter ( ) ) ; registry . add converter ( new period to string converter ( ) ) ; registry . add converter ( new number to period converter ( ) ) ; registry . add converter ( new string to data size converter ( ) ) ; registry . add converter ( new number to data size converter ( ) ) ; registry . add converter ( new string to file converter ( ) ) ; registry . add converter ( new input stream source to byte array converter ( ) ) ; registry . add converter factory ( new lenient string to enum converter factory ( ) ) ; registry . add converter factory ( new lenient boolean to enum converter factory ( ) ) ; }
public void set relative path ( string relative path ) { this . relative path = relative path ; } // -- void set relative path ( string )
public void trace ( throwable cause , char sequence message ) { this . log . trace ( message , cause ) ; }
public void trace ( char sequence message ) { this . log . trace ( message ) ; }
public void set result ( result result ) { if ( result==null ) { throw new illegal argument exception ( `` result must not be null `` ) ; } this . result = result ; }
protect flowable < ? > instrument publisher ( channel handler context ctx , object result ) { flowable < ? > actual = publisher . convert publisher ( result , flowable . class ) ; return actual . subscribe on ( scheduler . from ( ctx . channel ( ) . event loop ( ) ) ) ; }
public static message get ( final message supplier supplier ) { if ( supplier == null ) { return null ; } return supplier . get ( ) ; }
public static void have text ( string text , string message ) { if ( ! string . have text ( text ) ) { throw new illegal argument exception ( message ) ; } }
public comparator comparator ( ) { return comparator ; }
public boolean equal ( object other ) { return this==other ; }
public field get field ( ) { return field ; }
public long get last task time millis ( ) throw illegal state exception { if ( this . last task info == null ) { throw new illegal state exception ( `` no task run : ca n't get last task interval `` ) ; } return this . last task info . get time millis ( ) ; }
public void start ( string task name ) throw illegal state exception { if ( this . current task name ! = null ) { throw new illegal state exception ( `` ca n't start stop watch : it 's already run `` ) ; } this . current task name = task name ; this . start time nanos = system . nano time ( ) ; }
public string to string ( ) { string builder sb = new string builder ( ) ; sb . append ( `` atts [ `` ) ; for ( int i = 0 ; i < attribute . size ( ) ; i++ ) { att att = attribute . get ( i ) ; sb . append ( att . get q name ( ) ) ; sb . append ( `` = `` ) ; sb . append ( att . get value ( ) ) ; sb . append ( `` ; `` ) ; } sb . append ( `` ] `` ) ; return sb . to string ( ) ; }
public static void copy byte ( input stream in , output stream out , configuration conf ) throw i o exception { copy byte ( in , out , conf . get int ( `` io . file . buffer . size `` , 4096 ) , true ) ; }
public void set ( byte [ ] bytes ) { this . count = ( bytes == null ) ? 0 : byte . length ; this . bytes = byte ; }
public class < v > value type ( ) { return value type ; }
public static int dimension ( class clazz ) { check array type ( clazz ) ; int result = 0 ; while ( clazz . be array ( ) ) { result++ ; clazz = clazz . get component type ( ) ; } return result ; }
public void set right list ( final list < string > right ) { this . right = right ; }
public void set method ( int method ) { this . method = method ; }
public void set property ( final string property ) { this . property name = property ; }
public void set suffix ( final string suffix ) { synchronize ( output lock ) { this . suffix rotator = suffix rotator . parse ( suffix ) ; } }
public string get no column insert string ( ) { return `` value ( default ) `` ; }
public void set bind type ( string bind type ) { this . bind type = bind type ; }
public string get expression ( ) { return expression ; }
public string get pattern ( ) { return pattern ; }
public void set resource ( string resource ) { assert src be java resource ( ) ; ( ( java resource ) src ) . set name ( resource ) ; }
public list < entry > get entry ( ) { return entry ; }
public string get path ( ) { return path ; }
public < t > t [ ] complete and clear buffer ( object [ ] last chunk , int last chunk entry , class < t > component type ) { int total size = last chunk entry + _size ; @ suppress warning ( `` unchecked `` ) t [ ] result = ( t [ ] ) array . new instance ( component type , total size ) ; _copy to ( result , total size , last chunk , last chunk entry ) ; _reset ( ) ; return result ; }
public chunk get writable chunk ( ) { chunk result = this . f database . get chunk ( ( long ) this . f sequence number * database . chunk_size ) ; result . make dirty ( ) ; return result ; }
public address get address ( ) { return address ; }
public signature type get signature type ( ) { return signature type ; }
public int get size ( ) { return size ; }
public void set enable multiple mapping ( boolean enable multiple mapping ) { this . enable multiple mapping = enable multiple mapping ; }
public string get line separator ( ) { return line separator ; }
protected list < grant authority > load group authority ( string username ) { return get jdbc template ( ) . query ( this . group authority by username query , new string [ ] { username } , ( r , row num ) - > { string role name = get role prefix ( ) + r . get string ( 3 ) ; return new simple grant authority ( role name ) ; } ) ; }
public string get user ( ) { return user ; }
public exception get exception ( ) { return this . exception ; }
protect t login page ( string login page ) { set login page ( login page ) ; update authentication default ( ) ; this . custom login page = true ; return get self ( ) ; }
public void set debug ( boolean debug ) { this . debug = debug ; }
public final void add filter chain ( filter chain filter ) { filter chain . add element ( filter ) ; }
public void set page ( p d page page ) { this . page = page ; }
public void set filter ( boolean filter ) { this . filter = filter ; }
protect t login page ( string login page ) { set login page ( login page ) ; update authentication default ( ) ; this . custom login page = true ; return get self ( ) ; }
public logout configurer < h > logout success url ( string logout success url ) { this . custom logout success = true ; this . logout success url = logout success url ; return this ; }
public boolean have protection policy ( ) { return protection policy ! = null ; }
protect final void update authentication default ( ) { if ( this . login process url == null ) { login process url ( this . login page ) ; } if ( this . failure handler == null ) { failure url ( this . login page + `` ? error `` ) ; } logout configurer < b > logout configurer = get builder ( ) . get configurer ( logout configurer . class ) ; if ( logout configurer ! = null & & ! logout configurer . be custom logout success ( ) ) { logout configurer . logout success url ( this . login page + `` ? logout `` ) ; } }
public authorization code get authorization code ( ) { return code ; }
public boolean should proceed ( ) { return should proceed ; }
public static int dimension ( class clazz ) { check array type ( clazz ) ; int result = 0 ; while ( clazz . be array ( ) ) { result++ ; clazz = clazz . get component type ( ) ; } return result ; }
public void add callback ( runnable callback ) { if ( callback ! = null ) delegate . add callback ( callback ) ; }
public void clear ( ) { object . clear ( ) ; }
public jdbc user detail manager configurer < b > authority by username query ( string query ) { get user detail service ( ) . set authority by username query ( query ) ; return this ; }
public byte [ ] get ( ) { if ( bytes == null ) { byte = new byte [ 0 ] ; } return byte ; }
public static secret key to a e s key ( final secret key secret key ) { if ( secret key == null ) { return null ; } return new secret key spec ( secret key . get encoded ( ) , `` aes `` ) ; }
public boolean get request cache ( ) { return this . search request . request cache ( ) ; }
public issue management get issue management ( ) { return this . issue management ; } // -- issue management get issue management ( )
public void set target ( ast node target ) { assert not null ( target ) ; this . target = target ; target . set parent ( this ) ; }
public void set redirect port ( int redirect port ) { this . redirect port = redirect port ; set property ( `` redirect port `` , string . value of ( redirect port ) ) ; }
public string change session id ( ) { assert . be true ( this . session ! = null , `` the request do not have a session `` ) ; if ( this . session instanceof mock http session ) { return ( ( mock http session ) this . session ) . change session id ( ) ; } return this . session . get id ( ) ; }
public boolean be throw exception on miss ( ) { return throw exception on miss ; }
public void remove cookie ( http servlet response response ) { assert . not null ( response , `` http servlet response must not be null `` ) ; cookie cookie = create cookie ( `` `` ) ; cookie . set max age ( 0 ) ; if ( be cookie secure ( ) ) { cookie . set secure ( true ) ; } if ( be cookie http only ( ) ) { cookie . set http only ( true ) ; } response . add cookie ( cookie ) ; if ( logger . be trace enable ( ) ) { logger . trace ( `` remove cookie ' `` + get cookie name ( ) + `` ' `` ) ; } }
public string get session id ( ) { return get ( `` session . id `` , `` `` ) ; }
public file get destination ( ) { return this . destination ; }
public void set exit message ( string exit message ) { assert . have text ( exit message , `` 'exit message ' must not be empty `` ) ; check for invalid placeholder ( exit message ) ; assert . do not contain ( exit message , placeholder_exception , `` exit message can not contain placeholder [ `` + placeholder_exception + `` ] `` ) ; this . exit message = exit message ; }
public source get source ( ) { return source ; }
public void set password ( string password ) { this . password = password ; }
public url get url ( ) { return this . url ; }
protect void push back byte ( final long push back ) { byte read -= push back ; }
public string get value ( ) { return value ; }
public boolean be failure ( ) { return be failure ; }
public string get parameter name ( ) { return parameter name ; }
public header get first header ( string name ) { for ( iterator header iter = header . iterator ( ) ; header iter . have next ( ) ; ) { header header = ( header ) header iter . next ( ) ; if ( header . get name ( ) . equal ignore case ( name ) ) { return header ; } } return null ; }
public string get domain ( ) { return domain ; }
public void set request context attribute ( @ nullable string request context attribute ) { this . request context attribute = request context attribute ; }
protect boolean have forward header ( server http request request ) { http header header = request . get header ( ) ; for ( string header name : forwarded_header_names ) { if ( header . contains key ( header name ) ) { return true ; } } return false ; }
public void set active ( boolean active ) { this . active = active ; }
public element set attribute ( final collection new attribute ) { attribute . clear and set ( new attribute ) ; return this ; }
public session get session ( ) { return this . session ; }
public void write to ( writer writer ) throw i o exception { write to ( writer , writer config . minimal ) ; }
public string location ( ) { return location ; }
protect int delete from table where ( string table name , string where clause , object . . . args ) { return jdbc test utils . delete from table where ( this . jdbc template , table name , where clause , args ) ; }
protect int delete from table where ( string table name , string where clause , object . . . args ) { return jdbc test utils . delete from table where ( this . jdbc template , table name , where clause , args ) ; }
protect int count row in table where ( string table name , string where clause ) { return jdbc test utils . count row in table where ( this . jdbc template , table name , where clause ) ; }
public result run ( junit . framework . test test ) { return run ( new old test class runner ( test ) ) ; }
public static string convert resource path to class name ( string resource path ) { assert . not null ( resource path , `` resource path must not be null `` ) ; return resource path . replace ( path_separator , package_separator ) ; }
protect final boolean be rollback ( test context test context ) throw exception { boolean rollback = be default rollback ( test context ) ; rollback rollback annotation = annotate element utils . find merged annotation ( test context . get test method ( ) , rollback . class ) ; if ( rollback annotation ! = null ) { boolean rollback override = rollback annotation . value ( ) ; if ( logger . be debug enable ( ) ) { logger . debug ( string . format ( `` method-level @ rollback ( % s ) override default rollback [ % s ] for test context % s . `` , rollback override , rollback , test context ) ) ; } rollback = rollback override ; } else { if ( logger . be debug enable ( ) ) { logger . debug ( string . format ( `` no method-level @ rollback override : use default rollback [ % s ] for test context % s . `` , rollback , test context ) ) ; } } return rollback ; }
public boolean be rollback only ( ) { return this . rollback only ; }
public xml get xml ( ) { return xml ; }
public void set request path ( string request path ) { this . request path = request path ; }
public u r i builder set parameter ( final string param , final string value ) { if ( this . query params == null ) { this . query params = new array list < name value pair > ( ) ; } if ( ! this . query params . be empty ( ) ) { for ( iterator < name value pair > it = this . query params . iterator ( ) ; it . have next ( ) ; ) { name value pair nvp = it . next ( ) ; if ( nvp . get name ( ) . equal ( param ) ) { it . remove ( ) ; } } } this . query params . add ( new basic name value pair ( param , value ) ) ; this . encoded query = null ; this . encoded scheme specific part = null ; return this ; }
public static content result matcher content ( ) { return new content result matcher ( ) ; }
public request matcher number ( matcher < ? super double > matcher ) { return ( xpath request matcher ) request - > this . xpath helper . assert number ( request . get body a byte ( ) , default_encoding , matcher ) ; }
public request matcher node count ( matcher < integer > matcher ) { return ( xpath request matcher ) request - > this . xpath helper . assert node count ( request . get body a byte ( ) , default_encoding , matcher ) ; }
public model map get model ( ) { if ( use default model ( ) ) { return this . default model ; } else { if ( this . redirect model == null ) { this . redirect model = new model map ( ) ; } return this . redirect model ; } }
public long last modified ( ) throw i o exception { long last modify = get file for last modified check ( ) . last modified ( ) ; if ( last modify == 0l ) { throw new file not find exception ( get description ( ) + `` can not be resolve in the file system for resolve it last-modified timestamp `` ) ; } return last modify ; }
public web test client . response spec value ( consumer < integer > consumer ) { int value = this . exchange result . get status ( ) . value ( ) ; this . exchange result . assert with diagnostics ( ( ) - > consumer . accept ( value ) ) ; return this . response spec ; }
public void set bubble series type ( short field_5_bubble series type ) { this . field_5_bubble series type = field_5_bubble series type ; }
public < t > web test client . body content spec value ( consumer < t > consumer , class < t > target type ) { object value = this . path helper . evaluate json path ( this . content , target type ) ; consumer . accept ( ( t ) value ) ; return this . body spec ; }
public void add servlet name ( string . . . servlet names ) { assert . not null ( servlet name , `` servlet name must not be null `` ) ; this . servlet name . add all ( array . a list ( servlet name ) ) ; }
public void attribute ( string name , object value ) { session . set attribute ( name , value ) ; }
public result matcher content type compatible with ( string content type ) { return content type compatible with ( medium type . parse medium type ( content type ) ) ; }
public result matcher content type ( medium type content type ) { return result - > { string actual = result . get response ( ) . get content type ( ) ; assert not null ( `` content type not set `` , actual ) ; assert equal ( `` content type `` , content type , medium type . parse medium type ( actual ) ) ; } ; }
public result get result ( ) { return result ; }
public int get max age ( ) { return max age ; }
public result matcher date value ( string name , long value ) { return result - > { mock http servlet response response = result . get response ( ) ; string header value = response . get header ( name ) ; assert not null ( `` response do not contain header ' `` + name + `` ' `` , header value ) ; http header header = new http header ( ) ; header . set date ( `` expect `` , value ) ; header . set ( `` actual `` , header value ) ; assert equal ( `` response header ' `` + name + `` '= ' `` + header value + `` ' `` + `` do not match expect value ' `` + header . get first ( `` expect `` ) + `` ' `` , header . get first date ( `` expect `` ) , header . get first date ( `` actual `` ) ) ; } ; }
public web test client . response spec value equal ( string header name , long value ) { string actual = get header ( ) . get first ( header name ) ; this . exchange result . assert with diagnostics ( ( ) - > assert true ( `` response do not contain header ' `` + header name + `` ' `` , actual ! = null ) ) ; return assert header ( header name , value , long . parse long ( actual ) ) ; }
public static content result matcher content ( ) { return new content result matcher ( ) ; }
public < t > result matcher value ( matcher < t > matcher ) { return result - > this . json path helper . assert value ( get content ( result ) , matcher ) ; }
public string get url ( ) { return url ; }
public static result matcher redirect url template ( string url template , object . . . uri var ) { string uri = uri component builder . from uri string ( url template ) . build and expand ( uri var ) . encode ( ) . to uri string ( ) ; return redirect url ( uri ) ; }
public static result matcher forward url template ( string url template , object . . . uri var ) { string uri = uri component builder . from uri string ( url template ) . build and expand ( uri var ) . encode ( ) . to uri string ( ) ; return forward url ( uri ) ; }
public static content request matcher content ( ) { return new content request matcher ( ) ; }
public error get error ( ) { return this . error ; }
public type argument < t > set converter ( converter < t > converter ) { this . converter = converter ; return this ; }
public static conversion category from conversion char ( char c ) { for ( conversion category v : new conversion category [ ] { general , char , int , float , time } ) { if ( v . char . contains ( string . value of ( c ) ) ) { return v ; } } throw new illegal argument exception ( ) ; }
public void set pattern ( string pattern ) { this . pattern = pattern ; set use locale format ( true ) ; }
public enumeration < test > test ( ) { return f test . element ( ) ; }
public request spec builder add cookie ( string name ) { spec . cookie ( name ) ; return this ; }
public result matcher date value ( string name , long value ) { return result - > { mock http servlet response response = result . get response ( ) ; string header value = response . get header ( name ) ; assert not null ( `` response do not contain header ' `` + name + `` ' `` , header value ) ; http header header = new http header ( ) ; header . set date ( `` expect `` , value ) ; header . set ( `` actual `` , header value ) ; assert equal ( `` response header ' `` + name + `` '= ' `` + header value + `` ' `` + `` do not match expect value ' `` + header . get first ( `` expect `` ) + `` ' `` , header . get first date ( `` expect `` ) , header . get first date ( `` actual `` ) ) ; } ; }
public boolean be cache ( ) { return cache ! = null ; }
public boolean contain part ( package part name part name ) { return ( this . get part ( part name ) ! = null ) ; }
public void set factory ( j d o m factory factory ) { this . factory = factory ; }
public http request base get http request ( ) { return http request ; }
public iterable < reader interceptor > get reader interceptor ( ) { return reader interceptor ; }
public void set max in memory size ( int byte count ) { this . max in memory size = byte count ; }
public static codec factory add codec ( string name , codec factory c ) { return register . put ( name , c ) ; }
public boolean be null string set ( ) { return null string ! = null ; }
public string get converter ( ) { return converter ; }
public static long long value ( long wrapper , long default value ) { return wrapper ! = null ? wrapper : default value ; }
public void set feature ( feature map feature ) { this . feature = feature ; }
public transfer resource set content length ( long content length ) { this . content length = content length ; return this ; }
public list get medium ( ) { return medium type ; }
public http url url ( ) { return url ; }
public void set read timeout ( int read timeout ) { this . read timeout = read timeout ; }
public void set codebase url ( @ nullable string codebase url ) { this . codebase url = codebase url ; }
protect object input stream create object input stream ( input stream be , @ nullable string codebase url ) throw i o exception { return new codebase aware object input stream ( be , get bean class loader ( ) , codebase url ) ; }
public < t extend annotation > qualifier model < t > get bind type model ( final class < t > bind type ) { return qualifier . get cast value ( bind type ) ; }
public final endpoint configuration get endpoint ( ) { return endpoint configuration ; }
public string get action ( ) { return action ; }
public void set service locator interface ( class < ? > interface type ) { this . service locator interface = interface type ; }
public void set class loader ( class loader class loader ) { this . class loader = class loader ; }
protect string get service class name ( handler service ) { return ( string ) service . get option ( get service class name option name ( ) ) ; }
public url get url ( ) { return this . url ; }
public void set servlet context ( servlet context servlet context ) { this . servlet context = servlet context ; }
public object get parameter value ( string parameter class name ) { return this . parameter . get ( parameter class name ) ; }
public static boolean have submit parameter ( servlet request request , string name ) { assert . not null ( request , `` request must not be null `` ) ; if ( request . get parameter ( name ) ! = null ) { return true ; } for ( string suffix : submit_image_suffixes ) { if ( request . get parameter ( name + suffix ) ! = null ) { return true ; } } return false ; }
public object get attribute ( string attribute name ) { return attribute map . get ( attribute name ) ; }
public static marker get detach marker ( string name ) { return marker factory . get detached marker ( name ) ; }
public void set bind type ( string bind type ) { this . bind type = bind type ; }
public final void set executor factory ( executor factory executor factory ) { this . executor factory = executor factory ; }
public object get attribute ( string attribute name ) { return attribute map . get ( attribute name ) ; }
public void set servlet context ( servlet context servlet context ) { this . servlet context = servlet context ; }
public void set config location ( final uri config location ) { this . config location = config location ; reconfigure ( config location ) ; }
public void set servlet context ( servlet context servlet context ) { this . servlet context = servlet context ; }
public static string get resource path ( ) { return resource path ; }
public term vector request builder set payload ( boolean payload ) { request . payload ( payload ) ; return this ; }
public void set prefix ( string prefix ) { this . prefix = prefix ; } // -- void set prefix ( string )
public void set msg ( string msg ) { this . msg = msg ; }
public void set servlet context ( servlet context servlet context ) { this . servlet context = servlet context ; }
public void add bean ( string name , object bean ) { this . bean . put ( name , bean ) ; }
public i dispatch get i dispatch ( ) { return i dispatch ; }
public list get medium ( ) { return medium type ; }
protect web application context get web application context ( face context face context ) { return face context utils . get require web application context ( face context ) ; }
protect bean factory get bean factory ( face context face context ) { return get web application context ( face context ) ; }
protected factory bean < ? > get factory bean ( string bean name , object bean instance ) throw bean exception { if ( ! ( bean instance instanceof factory bean ) ) { throw new bean creation exception ( bean name , `` bean instance of type [ `` + bean instance . get class ( ) + `` ] be not a factory bean `` ) ; } return ( factory bean < ? > ) bean instance ; }
public void set method ( int method ) { this . method = method ; }
public model map get model ( ) { if ( use default model ( ) ) { return this . default model ; } else { if ( this . redirect model == null ) { this . redirect model = new model map ( ) ; } return this . redirect model ; } }
public void set view ( view view ) { this . view = view ; }
public a r f f model get model ( ) { return model ; }
public void set status ( @ nullable http status status ) { this . status = status ; }
public void set binding ( bind binding ) { this . bind = binding ; }
public void set handle ( handle handle ) { this . handle = handle ; }
public string get default encode ( ) { return default encode ; }
public void set bind empty multipart file ( boolean bind empty multipart file ) { this . bind empty multipart file = bind empty multipart file ; }
public void add bean name resolver ( bean name resolver bean name resolver ) { get e l context ( ) . add e l resolver ( new bean name e l resolver ( bean name resolver ) ) ; }
protect void after refresh ( configurable application context context , application argument args ) { }
public http header get header ( ) { return this . header ; }
public int status ( ) { return response . get status ( ) ; }
public void add locale ( locale locale ) { locale . add ( locale ) ; }
public int get max session ( ) { return max session ; }
public void validate ( final cookie cookie , final cookie origin origin ) throw malformed cookie exception { if ( cookie == null ) { throw new illegal argument exception ( `` cookie may not be null `` ) ; } if ( cookie instanceof set cookie2 ) { if ( cookie instanceof client cookie & & ! ( ( client cookie ) cookie ) . contains attribute ( client cookie . version_attr ) ) { throw new cookie restriction violation exception ( `` violate rfc 2965 . version attribute be require . `` ) ; } } }
public synchronize void set case sensitive ( boolean be case sensitive ) { this . be case sensitive = be case sensitive ; }
public http url url ( ) { return url ; }
public type component ( ) { return component ; }
public void unset variable ( string name ) { if ( variable ! = null ) { variable . remove ( name ) ; name space change ( ) ; } }
protect final http servlet request get request ( ) { return this . request ; }
public static data buffer slice from ( data buffer buf , int idx ) { int len = buf . write position ( ) - idx - 1 ; return buf . retain slice ( idx + 1 , len ) ; }
public static data buffer slice to ( data buffer buf , int idx ) { int po = buf . read position ( ) ; int len = idx - po + 1 ; return buf . retain slice ( po , len ) ; }
public default void init ( ) { }
public static list < medium type > parse medium type ( @ nullable list < string > medium type ) { if ( collection utils . be empty ( medium type ) ) { return collection . empty list ( ) ; } else if ( medium type . size ( ) == 1 ) { return parse medium type ( medium type . get ( 0 ) ) ; } else { list < medium type > result = new array list < > ( 8 ) ; for ( string medium type : medium type ) { result . add all ( parse medium type ( medium type ) ) ; } return result ; } }
public static header builder < ? > delete ( string uri template , object . . . uri variable ) { return method ( http method . delete , uri template , uri variable ) ; }
public static header builder < ? > get ( string uri template , object . . . uri variable ) { return method ( http method . get , uri template , uri variable ) ; }
public < s > service binder < s > bind service ( final class < s > type ) { service binder impl < s > binder = new service binder impl < s > ( type ) ; binder . add ( binder ) ; return binder ; }
public void add resolver ( template variable resolver resolver ) { assert . be not null ( resolver ) ; f resolvers . put ( resolver . get type ( ) , resolver ) ; }
public void set view ( view view ) { this . view = view ; }
public exception handle configurer < http security > exception handling ( ) throw exception { return get or apply ( new exception handle configurer < > ( ) ) ; }
public void set view resolvers ( list < view resolver > view resolvers ) { this . view resolvers . clear ( ) ; if ( ! collection utils . be empty ( view resolvers ) ) { this . view resolvers . add all ( view resolvers ) ; } }
public void set order ( int order ) { this . order = order ; }
public boolean be default lazy ( ) { if ( default lazy == null ) { return true ; } else { return default lazy ; } }
public string get expression ( ) { return expression ; }
public set < medium type expression > get expression ( ) { return new link hash set < > ( this . expression ) ; }
public boolean be match ( ) { return match ; }
public string get registry ( ) { return registry ; }
public void override error message ( string new error message ) { override error message = new error message ; }
public static string to string ( @ nullable object [ ] array ) { string delimiter = `` , `` ; return to string ( delimiter , array ) ; }
public int get error ( ) { return error ; }
public configuration get configuration ( ) throw configuration exception { return get configuration ( true ) ; }
public template [ ] get template ( ) { return get template ( null ) ; }
public final query get query ( ) { return query ; }
public string get url ( ) { return url ; }
public error get error ( ) { return this . error ; }
public void set status ( string status ) { this . status = status ; } // -- void set status ( string )
public void set order ( int order ) { this . order = order ; }
public channel future close ( channel channel , close web socket frame frame ) { object util . check not null ( channel , `` channel `` ) ; return close ( channel , frame , channel . new promise ( ) ) ; }
public int get origin ( ) { return origin ; }
public void add servlet name ( string . . . servlet names ) { assert . not null ( servlet name , `` servlet name must not be null `` ) ; this . servlet name . add all ( array . a list ( servlet name ) ) ; }
public < t > result matcher value ( matcher < t > matcher ) { return result - > this . json path helper . assert value ( get content ( result ) , matcher ) ; }
public void set order ( int order ) { this . order = order ; }
public period to period ( ) { return new period ( this ) ; }
public void set redirect port ( int redirect port ) { this . redirect port = redirect port ; set property ( `` redirect port `` , string . value of ( redirect port ) ) ; }
public mapping metadata default mapping ( ) { return mapping . get ( mapper service . default_mapping ) ; }
public context get context ( ) { return impl . get context ( ) ; }
public void set strategy ( generation type value ) { this . strategy = value ; }
public http servlet request get http servlet request ( ) { return request ; }
protect string get request value for attribute ( string attribute name , native web request request ) { map < string , string > variable = get uri template variable ( request ) ; string variable value = variable . get ( attribute name ) ; if ( string utils . have text ( variable value ) ) { return variable value ; } string parameter value = request . get parameter ( attribute name ) ; if ( string utils . have text ( parameter value ) ) { return parameter value ; } return null ; }
public void set config location ( final uri config location ) { this . config location = config location ; reconfigure ( config location ) ; }
public void set publish ( final date publish ) { this . publish = date . copy ( publish ) ; }
public spring application builder context class ( class < ? extend configurable application context > cl ) { this . application . set application context class ( cl ) ; return this ; }
protect final http servlet request get request ( ) { return this . request ; }
public object response ( ) { return response ; }
public error handler get handler ( ) { return handler ; }
protect request map handler mapping create request map handler mapping ( ) { return new request mapping handler mapping ( ) ; }
public void remove exception attribute ( ) { attribute info . remove ( attribute , exception attribute . tag ) ; }
public int get depth ( ) { return statistic . depth ; }
public response builder set status code ( int status code ) { rest assure response . set status code ( status code ) ; return this ; }
public void set view ( view view ) { this . view = view ; }
public cooky get cooky ( ) { return cooky ; }
public locale get locale ( ) { return locale ; }
public static void set default time zone ( @ nullable time zone time zone ) { default time zone = time zone ; }
public http status get status ( ) { return this . status ; }
public boolean be empty ( ) { return empty ; }
public list < string > get variable name ( ) { return this . variable name ; }
public void set view ( @ nullable object view ) { this . view = view ; }
public void set view ( @ nullable object view ) { this . view = view ; }
protect void destroy instance ( t instance ) throw exception { }
public http servlet request get http servlet request ( ) { return request ; }
public locale get locale ( ) { return locale ; }
public static theme get theme ( http servlet request request ) { theme resolver theme resolver = get theme resolver ( request ) ; theme source theme source = get theme source ( request ) ; if ( theme resolver ! = null & & theme source ! = null ) { string theme name = theme resolver . resolve theme name ( request ) ; return theme source . get theme ( theme name ) ; } else { return null ; } }
public void set theme table ( theme table theme ) { this . _theme = theme ; }
public http servlet request get http servlet request ( ) { return request ; }
public void set cache second ( int cache second ) { this . cache millis = ( cache second * 1000 ) ; }
public void set name ( string name ) { this . name = name ; }
public string get nest path ( ) { return this . nested path ; }
protect void flush buffer body content ( body content body content ) throw jsp exception { try { body content . write out ( body content . get enclosing writer ( ) ) ; } catch ( i o exception ex ) { throw new jsp exception ( `` unable to write buffer body content . `` , ex ) ; } }
protect string read body content ( ) throw i o exception { assert . state ( this . body content ! = null , `` no body content set `` ) ; return this . body content . get string ( ) ; }
public byte [ ] element ( ) { return element ; }
public char get delimiter ( ) { return delimiter ; }
protect string get class text ( ) { return `` class `` ; } // get class string
public string separator ( ) { return separator ; }
public string get path ( ) { return path ; }
public void set value ( string value ) { this . value = value ; }
public void set filter ( boolean filter ) { this . filter = filter ; }
public locale get locale ( ) { return locale ; }
public boolean be expose proxy ( ) { return this . expose proxy ; }
public static request attribute get request attribute ( ) { request attribute attribute = request attribute holder . get ( ) ; if ( attribute == null ) { attribute = inheritable request attribute holder . get ( ) ; } return attribute ; }
public map get attribute ( ) { return attribute ; }
public void set strip markup ( boolean strip markup ) { this . strip markup = strip markup ; }
public void set encoding ( string encode ) { this . encode = encoding ; }
public string get template name ( ) { return template name ; }
public locale get locale ( ) { return locale ; }
public void set always create ( boolean always create ) { this . always create = always create ; }
public i dispatch get i dispatch ( ) { return i dispatch ; }
protect final http servlet request get request ( ) { return this . request ; }
public boolean be cache ( ) { return cache ! = null ; }
public boolean be expose proxy ( ) { return this . expose proxy ; }
public list < view resolver > get view resolvers ( ) { return collection . unmodifiable list ( this . view resolvers ) ; }
public void set view resolvers ( list < view resolver > view resolvers ) { this . view resolvers . clear ( ) ; if ( ! collection utils . be empty ( view resolvers ) ) { this . view resolvers . add all ( view resolvers ) ; } }
public void set location ( string location ) { this . location = location ; }
public void set factory ( j d o m factory factory ) { this . factory = factory ; }
protect synchronized final void error ( string err ) throw s q l exception { check context ( ) ; db . result_error ( context , err ) ; }
protect synchronized final void result ( byte [ ] value ) throw s q l exception { check context ( ) ; db . result_blob ( context , value ) ; }
public void set value ( string value ) { this . value = value ; }
public string get character set ( ) { return character set ; }
public boolean be remove ( ) { return remove ; }
public static cooky new client response holder ( http header header , client cookie decoder decoder ) { return new cooky ( header , http header name . set_cookie , true , decoder ) ; }
public string get string ( ) { return string ; }
public boolean have next ( ) { return next index ( ) > = 0 ; }
public string namespace ( ) { return the namespace ; }
public void set member of ( int member of ) { the member of = member of ; }
public string namespace ( ) { return the type . namespace ( ) ; }
public int member of ( ) { return the type . member of ( ) ; }
public synchronize void set parent ( hashtable parent ) { this . parent = parent ; }
public list < t > get list ( string entity name ) { not null ( entity name , `` entity name `` ) ; final list < t > entity list = new array list < t > ( ) ; for ( t entity : entity ) { if ( entity . get name ( ) . equal ignore case ( entity name ) ) { entity list . add ( entity ) ; } } return collection . unmodifiable list ( entity list ) ; }
public void fail task ( final task attempt i d task id ) throw i o exception { kill task ( task id , true ) ; }
public synchronize boolean be build ( ) { return this . build ; }
public predicate [ ] get predicate ( ) { return i predicate ; }
public void acquire ( double rate ) { rate limiter limiter = ref . get ( ) ; if ( limiter == null || limiter . get rate ( ) ! = rate ) { ref . compare and set ( limiter , rate limiter . create ( rate ) ) ; limiter = ref . get ( ) ; } limiter . acquire ( 1 ) ; }
protect < t > t get default strategy ( application context context , class < t > strategy interface ) { list < t > strategy = get default strategy ( context , strategy interface ) ; if ( strategy . size ( ) ! = 1 ) { throw new bean initialization exception ( `` dispatcher servlet need exactly 1 strategy for interface [ `` + strategy interface . get name ( ) + `` ] `` ) ; } return strategy . get ( 0 ) ; }
public http request base get http request ( ) { return http request ; }
public static boolean be valid ( string name ) { try { from ( name ) ; return true ; } catch ( illegal argument exception e ) { return false ; } }
public object get instance ( ) { return instance ; }
public detector get detector ( ) { return detector ; }
public channel config set max message per write ( int max message per write ) { this . max message per write = object util . check positive ( max message per write , `` max message per write `` ) ; return this ; }
public static long get u int ( byte [ ] data ) { return get u int ( data , 0 ) ; }
public string detect ( path path ) throw i o exception { metadata metadata = new metadata ( ) ; try ( input stream stream = tika input stream . get ( path , metadata ) ) { return detect ( stream , metadata ) ; } }
public string get file ( ) { return file ; }
public long get position ( ) { return position ; }
public void set language ( final string language ) { this . language = list . create ( language ) ; }
public void set language ( final string language ) { this . language = list . create ( language ) ; }
public void set language ( final string language ) { this . language = list . create ( language ) ; }
public void set profile ( java . util . list < profile > profile ) { this . profile = profile ; } // -- void set profile ( java . util . list )
public property get property ( ) { return property ; }
static public byte [ ] string to byte ( string hex encode ) { return decode ( hex encode . get byte ( ) ) ; }
public final method parameter get parameter ( ) { return this . parameter ; }
public medium type get medium type ( ) { return variant . get medium type ( ) ; }
public sort set < medium type > get type ( ) { return new tree set < medium type > ( registry . value ( ) ) ; }
public string get pattern ( ) { return pattern ; }
public void set ignored line consumer ( line consumer ignore line consumer ) { this . ignored line consumer = ignore line consumer ; }
public line consumer get ignore line consumer ( ) { return ignore line consumer ; }
public void set factory ( j d o m factory factory ) { this . factory = factory ; }
public synchronize state mark available ( ) { if ( map . be empty ( ) ) { state = state . idle ; } else { state = state . pending ; } return state ; }
public double get threshold ( ) { return threshold ; }
public void set max depth ( int max depth ) { this . max depth = max depth ; }
public void set output threshold ( long threshold ) { this . threshold = threshold ; }
public string to string ( ) { return to string ( 0 ) ; }
protect void set name source end ( int end ) { this . name end= end ; }
public boolean be match ( ) { return match ; }
public static tika input stream get ( path path , metadata metadata ) throw i o exception { metadata . set ( metadata . resource_name_key , path . get file name ( ) . to string ( ) ) ; metadata . set ( metadata . content_length , long . to string ( file . size ( path ) ) ) ; return new tika input stream ( path ) ; }
public encode detector get encode detector ( ) { return encode detector ; }
public int get from int ( ) { return get from ( ) ; }
public boolean be unknown ( ) { return true ; }
public file get dir ( ) { return dir ; }
public long get offset ( ) { return offset ; }
public long get long ( ) { long ret = delegate . get long ( ) ; return ret ; }
public int get delta search window size ( ) { return delta search window size ; }
public long get long ( ) { long ret = delegate . get long ( ) ; return ret ; }
public signature type get signature type ( ) { return signature type ; }
public void free ( long po , int length ) { free space . free ( po , length ) ; }
public string get descriptor ( ) { return descriptor ; }
public url to u r l ( ) throw malformed u r l exception { return base . to u r l ( ) ; }
public void set text ( string text ) { this . text = text ; }
public string get element name ( ) { return element name ; }
public frame [ ] get frames ( ) { return frame ; }
public e get entity ( ) { return entity ; }
public void set language ( final string language ) { this . language = list . create ( language ) ; }
public void set page ( p d page page ) { this . page = page ; }
public void add woven permission ( package permission permission ) { if ( ! permission . get action ( ) . equal ( package permission . import ) ) throw new security exception ( ) ; weave permission . add ( permission ) ; }
public final static int murmur hash3 ( int x ) { x ^= x > > > 16 ; x * = 0x85ebca6b ; x ^= x > > > 13 ; x * = 0xc2b2ae35 ; x ^= x > > > 16 ; return x ; }
public void set max memory ( long max memory ) { data utils . check argument ( max memory > 0 , `` max memory must be large than 0 , be { 0 } `` , max memory ) ; this . max memory = max memory ; if ( segment ! = null ) { long max = 1 + max memory / segment . length ; for ( segment < v > s : segment ) { s . set max memory ( max ) ; } } }
public context support get context support ( ) { return this . context support ; }
public static boolean be array zero ( final byte [ ] a , final int size ) { for ( int i = 0 ; i < size ; i++ ) { if ( a [ i ] ! = 0 ) { return false ; } } return true ; }
public static confidence interval get wilson score interval ( int number of trial , int number of success , double confidence level ) { return wilson_score . create interval ( number of trial , number of success , confidence level ) ; }
public void add strip line comment ( final strip line comment strip line comment ) { filter reader . add element ( strip line comment ) ; }
default public void init ( filter config filter config ) throw servlet exception { }
default public void init ( filter config filter config ) throw servlet exception { }
public void add servlet name ( string . . . servlet names ) { assert . not null ( servlet name , `` servlet name must not be null `` ) ; this . servlet name . add all ( array . a list ( servlet name ) ) ; }
public final metadata get trailer ( ) { return trailer ; }
default public void session will passivate ( http session event se ) { }
default public void attribute remove ( servlet request attribute event srae ) { }
public void set servlet context ( servlet context servlet context ) { this . servlet context = servlet context ; }
public void set algorithm ( string algorithm ) { this . algorithm = algorithm ; }
protect void session create ( final selection key key , final i o session session ) { }
public void set max save post size ( int max save post size ) { this . max save post size = max save post size ; }
public void set port ( int port ) { this . port = port ; }
public set < configuration class > get import by ( ) { return this . import by ; }
public string get host ( ) { return host ; }
public string get session id ( ) { return get ( `` session . id `` , `` `` ) ; }
public void set request ( org . apache . coyote . request request ) { request . set content length ( input . get length ( ) ) ; }
public object response ( ) { return response ; }
public locale get locale ( ) { return locale ; }
public context get context ( ) { return impl . get context ( ) ; }
protect synchronized void flush buffer ( ) throw i o exception { flush buffer ( false , true ) ; }
public container get container ( ) { return container ; }
public void set filter ( boolean filter ) { this . filter = filter ; }
public uri get u r i ( ) { return u ; }
public t with delay ( delay delay ) { this . delay = delay ; return ( t ) this ; }
public void set child ( hash set < string > child ) { this . child = child ; }
public void set class loader ( class loader class loader ) { this . class loader = class loader ; }
public void add child ( final object child ) { this . child . add ( child ) ; }
public index request set pipeline ( string pipeline ) { this . pipeline = pipeline ; return this ; }
public void set cache size ( int cache size ) { this . cache size = cache size ; }
public xml get xml ( ) { return xml ; }
protect void set delegate ( file configuration delegate delegate ) { this . delegate = delegate ; }
public string get path ( ) { return cookie path ; }
public http client option set keep alive ( boolean keep alive ) { this . keep alive = keep alive ; return this ; }
public void set filter ( boolean filter ) { this . filter = filter ; }
public string get parameter name ( ) { return parameter name ; }
public long get min time ( ) { long result = -1 ; long time ; container [ ] child = find child ( ) ; if ( child ! = null ) { for ( container child : child ) { time = ( ( standard wrapper ) child ) . get min time ( ) ; if ( result < 0 || time < result ) result = time ; } } return result ; }
public long get processing time ( ) { long result = 0 ; container [ ] child = find child ( ) ; if ( child ! = null ) { for ( container child : child ) { result += ( ( standard wrapper ) child ) . get processing time ( ) ; } } return result ; }
public identifier get i d ( ) { return id ; }
public route [ ] get route ( ) { return route ; }
public boolean be deploy ( ) { return be deploy ; }
public static set < string > get available i d ( ) { return c available i d ; }
public void set host header ( string host header ) { this . host header = host header ; }
public static request attribute get request attribute ( ) { request attribute attribute = request attribute holder . get ( ) ; if ( attribute == null ) { attribute = inheritable request attribute holder . get ( ) ; } return attribute ; }
public void set encoding ( string encode ) { this . encode = encoding ; }
public boolean be stop ( ) { return stop ; }
public boolean be boolean ( ) { return false ; }
public void set classpath ( string classpath ) { this . classpath = classpath ; }
protect void set signature ( byte [ ] signature ) { this . signature = signature ; }
public container get container ( ) { return container ; }
public void remove lifecycle listener ( string type ) throw m bean exception { container container = do get manage resource ( ) ; lifecycle listener [ ] listener = container . find lifecycle listener ( ) ; for ( lifecycle listener listener : listener ) { if ( listener . get class ( ) . get name ( ) . equal ( type ) ) { container . remove lifecycle listener ( listener ) ; } } }
public void add lifecycle listener ( string type ) throw m bean exception { lifecycle listener listener = ( lifecycle listener ) new instance ( type ) ; container container = do get manage resource ( ) ; container . add lifecycle listener ( listener ) ; }
public address get address ( ) { return address ; }
public int get local port ( ) { return _socket_ . get local port ( ) ; }
public int get port ( ) { return port ; }
public void remove role ( string rolename ) { user database database = ( user database ) this . resource ; role role = database . find role ( rolename ) ; if ( role == null ) { return ; } try { m bean utils . destroy m bean ( role ) ; database . remove role ( role ) ; } catch ( exception e ) { illegal argument exception iae = new illegal argument exception ( sm . get string ( `` user m bean . destroy error . role `` , rolename ) ) ; iae . init cause ( e ) ; throw iae ; } }
public string create role ( string rolename , string description ) { user database database = ( user database ) this . resource ; role role = database . create role ( rolename , description ) ; try { m bean utils . create m bean ( role ) ; } catch ( exception e ) { illegal argument exception iae = new illegal argument exception ( sm . get string ( `` user m bean . create m bean error . role `` , rolename ) ) ; iae . init cause ( e ) ; throw iae ; } return find role ( rolename ) ; }
public string get realm ( ) { return realm ; }
public void set data source ( final data source data source ) { this . data source = data source ; }
public static string authenticate ( username password credential credential , string charset ) { log . trace ( `` enter basic scheme . authenticate ( username password credential , string ) `` ) ; if ( credential == null ) { throw new illegal argument exception ( `` credential may not be null `` ) ; } if ( charset == null || charset . length ( ) == 0 ) { throw new illegal argument exception ( `` charset may not be null or empty `` ) ; } string buffer buffer = new string buffer ( ) ; buffer . append ( credential . get user name ( ) ) ; buffer . append ( `` : `` ) ; buffer . append ( credential . get password ( ) ) ; return `` basic `` + encoding util . get ascii string ( base64 . encode base64 ( encode util . get byte ( buffer . to string ( ) , charset ) ) ) ; }
public url to u r l ( ) throw malformed u r l exception { return base . to u r l ( ) ; }
public int get cache size ( ) { return cache j t be . size ( ) ; }
public static boolean be context loader available ( ) { return true ; }
public void set directory ( string directory ) { this . directory = directory ; } // -- void set directory ( string )
public string get name ( ) { return store . get map name ( id ) ; }
protect abstract conn pool create connection pool ( final http params params ) { return new conn pool by route ( conn operator , params ) ; }
public void attribute ( string name , object value ) { session . set attribute ( name , value ) ; }
public void set session attribute name filter ( string session attribute name filter ) throw pattern syntax exception { if ( session attribute name filter == null || session attribute name filter . length ( ) == 0 ) { session attribute name pattern = null ; } else { session attribute name pattern = pattern . compile ( session attribute name filter ) ; } }
public int get max active session ( ) { return max active session ; }
public session get session ( ) { return this . session ; }
public void set servlet context ( servlet context servlet context ) { this . servlet context = servlet context ; }
public void set manager ( string manager ) { helper . set manager ( manager ) ; }
public void set max active session ( int max ) { int old max active session = this . max active session ; this . max active session = max ; support . fire property change ( `` max active session `` , integer . value of ( old max active session ) , integer . value of ( this . max active session ) ) ; }
public jaxb cfg cache usage enum get usage ( ) { return usage ; }
public void set basedir ( string basedir ) { set basedir ( new file ( basedir . replace ( '/ ' , file . separator char ) . replace ( '\\ ' , file . separator char ) ) ) ; }
protect string to map key ( string role , string role hint ) { if ( role hint == null ) { return role ; } else { return role + `` : `` + role hint ; } }
protect void init strategy ( application context context ) { init multipart resolver ( context ) ; init locale resolver ( context ) ; init theme resolver ( context ) ; init handler mapping ( context ) ; init handler adapter ( context ) ; init handler exception resolvers ( context ) ; init request to view name translator ( context ) ; init view resolvers ( context ) ; init flash map manager ( context ) ; }
public string get name ( ) { return ( string ) get value ( name ) ; }
protect method [ ] get method ( class < ? > type ) { return type . get method ( ) ; }
protect void destroy instance ( t instance ) throw exception { }
public result matcher exists ( string name ) { return result - > get cookie ( result , name ) ; }
public string get session id ( ) { return get ( `` session . id `` , `` `` ) ; }
public boolean be boolean ( ) { return false ; }
public set < property name > find explicit name ( ) { set < property name > rename = null ; rename = _find explicit name ( _fields , rename ) ; rename = _find explicit name ( _getters , rename ) ; rename = _find explicit name ( _setters , rename ) ; rename = _find explicit name ( _ctor parameter , rename ) ; if ( rename == null ) { return collection . empty set ( ) ; } return rename ; }
protect void open ( ) { open writer ( ) ; }
public string get remote host ( ) { return this . request . get remote host ( ) ; }
public string get host ( ) { return this . host ; }
public string get host ( ) { return this . host ; }
public void validate ( final cookie cookie , final cookie origin origin ) throw malformed cookie exception { if ( cookie == null ) { throw new illegal argument exception ( `` cookie may not be null `` ) ; } if ( cookie instanceof set cookie2 ) { if ( cookie instanceof client cookie & & ! ( ( client cookie ) cookie ) . contains attribute ( client cookie . version_attr ) ) { throw new cookie restriction violation exception ( `` violate rfc 2965 . version attribute be require . `` ) ; } } }
public string add ( string string ) { if ( string == null ) return string ; object result = map . get ( string ) ; if ( result ! = null ) { if ( result ! = string ) saving += 44 + 2 * string . length ( ) ; return ( string ) result ; } map . put ( string , string ) ; return string ; }
public void set host header ( string host header ) { this . host header = host header ; }
public http header get header ( ) { return this . header ; }
public string get property name ( ) { return property name ; }
public byte buf buffer ( ) { return buffer ; }
public static int value a byte ( string key , byte default val ) { string val = value for ( key ) ; if ( val == null ) { return default val ; } byte bval ; try { bval = byte . value of ( val ) . byte value ( ) ; } catch ( number format exception nex ) { x r log . exception ( `` property ' `` + key + `` ' be request a a byte , but `` + `` value of ' `` + val + `` ' be not a byte . check configuration . `` ) ; bval = default val ; } return bval ; }
public int read unsigned short ( ) throw i o exception { int b1 = read ( ) ; int b2 = read ( ) ; if ( ( b1 | b2 ) < 0 ) { throw new e o f exception ( ) ; } return b1 < < 8 | b2 ; }
public void set input ( string input ) { this . input = input ; }
public void set max save post size ( int max save post size ) { this . max save post size = max save post size ; set property ( `` max save post size `` , string . value of ( max save post size ) ) ; }
public void multipart abort upload ( multipart upload upload ) throw s3 service exception { multipart abort upload impl ( upload . get upload id ( ) , upload . get bucket name ( ) , upload . get object key ( ) ) ; }
public void set request ( request coyote request ) { this . coyote request = coyote request ; }
public void set length ( long length ) throw i o exception { }
public string get server ( ) { return server ; }
public long get open interval ( ) { return open interval ; }
public name get name ( ) { return name ; }
public error get error ( ) { return this . error ; }
public int get tag ( int index ) { return get item ( index ) . get tag ( ) ; }
public void set limit ( final int limit ) { if ( limit < 1 ) { throw bad queue length ( ) ; } synchronize ( buffer ) { this . limit = limit ; } }
public void set in ( input stream in ) { this . in = in ; }
public boolean equal ( string s ) { char [ ] c = buff ; int len = end - start ; if ( c == null || len ! = s . length ( ) ) { return false ; } int off = start ; for ( int i = 0 ; i < len ; i++ ) { if ( c [ off++ ] ! = s . char at ( i ) ) { return false ; } } return true ; }
public void set char ( char [ ] c , int off , int len ) { buff = c ; start = off ; end = start + len ; be set = true ; have hash code = false ; }
public static < t > void inclusive between ( t start , t end , comparable < t > value ) { if ( value . compare to ( start ) < 0 || value . compare to ( end ) > 0 ) { throw new illegal argument exception ( string . format ( default_inclusive_between_ex_message , value , start , end ) ) ; } }
public boolean be cache ( ) { return cache ! = null ; }
public boolean equal ( string s ) { char [ ] c = buff ; int len = end - start ; if ( c == null || len ! = s . length ( ) ) { return false ; } int off = start ; for ( int i = 0 ; i < len ; i++ ) { if ( c [ off++ ] ! = s . char at ( i ) ) { return false ; } } return true ; }
public string get pattern ( ) { return pattern ; }
public string get user ( ) { return user ; }
public void add role ( string user , string role ) { list < string > role = user role . get ( user ) ; if ( role == null ) { role = new array list < > ( ) ; user role . put ( user , role ) ; } role . add ( role ) ; }
public static string collection ( collection < ? > collection ) { if ( collection == null ) { return null_string ; } return array ( collection . to array ( new object [ collection . size ( ) ] ) ) ; }
public void set verbose ( boolean verbose ) { this . verbose = verbose ; }
public string to string ( ) { string builder sb = new string builder ( ) ; sb . append ( `` atts [ `` ) ; for ( int i = 0 ; i < attribute . size ( ) ; i++ ) { att att = attribute . get ( i ) ; sb . append ( att . get q name ( ) ) ; sb . append ( `` = `` ) ; sb . append ( att . get value ( ) ) ; sb . append ( `` ; `` ) ; } sb . append ( `` ] `` ) ; return sb . to string ( ) ; }
public boolean be root ( ) { return root ; }
public object peek ( string stack name ) { return peek ( stack name , 0 ) ; }
public input stream get input stream ( ) throw i o exception { input stream in stream = this . get input stream impl ( ) ; if ( in stream == null ) { throw new i o exception ( `` ca n't obtain the input stream from `` + _part name . get name ( ) ) ; } return in stream ; }
public string get full name ( ) { return full name ; }
public string content type ( ) { return content type ; }
public void set charset ( string charset ) { this . charset = charset ; }
public string get name ( ) { return name ; }
public void close ( ) throw i o exception { }
public string get name ( ) { return name ; }
public string get encode ( ) { return encode ; }
public void set to list ( string list ) { string tokenizer token = new string tokenizer ( list , `` , `` ) ; while ( token . have more token ( ) ) { to list . add element ( new email address ( token . next token ( ) ) ) ; } }
public string get text normalize ( ) { return normalize string ( get text ( ) ) ; }
public void set log ( log log ) { this . log = log ; }
public void set name ( string name ) { this . name = name ; }
public void set name ( list < string > names ) { this . name = name ; }
public void set notification type ( string . . . notification type ) { this . notification type = notification type ; }
public void pause ( ) { write lock . lock ( ) ; try { be active = false ; } finally { write lock . unlock ( ) ; } }
public void destroy ( ) { m bean server server = management factory . get platform m bean server ( ) ; jmx util . remove m bean registration listener ( server , this ) ; }
public void set bind type ( string bind type ) { this . bind type = bind type ; }
public void set max total connection ( int max total connection ) { set int parameter ( http connection manager params . max_total_connections , max total connection ) ; }
protect socket get socket ( ) { return this . socket ; }
protect void set alias ( string alias ) { this . alias = alias ; }
public void close ( ) throw i o exception { }
public void flush ( ) throw i o exception { out . flush ( ) ; }
public channel future close ( channel channel , close web socket frame frame ) { object util . check not null ( channel , `` channel `` ) ; return close ( channel , frame , channel . new promise ( ) ) ; }
public static expression parse ( string s ) { if ( s == null ) throw new expression parse exception ( `` expression string can not be null . `` , -1 ) ; return build ( s , 0 ) ; }
public static < t > fluent iterable < t > of ( final iterable < t > iterable ) { iterable utils . check not null ( iterable ) ; if ( iterable instanceof fluent iterable < ? > ) { return ( fluent iterable < t > ) iterable ; } return new fluent iterable < > ( iterable ) ; }
public global variable get compile variable ( ) { return compile var ; }
public string get path ( ) { return path ; }
public void set method ( int method ) { this . method = method ; }
public string get invalid reference ( ) { return invalid reference ; }
public list get invalid reference ( ) { return invalid reference ; }
public string get invalid reference ( ) { return invalid reference ; }
public static object remove object property ( map property , string key , object default value ) { object value = default value ; if ( property ! = null & & property . contains key ( key ) ) { value = property . remove ( key ) ; } return value ; }
public list < graph q l directive > get directive ( string directive name ) { return directive . get directive ( directive name ) ; }
public object remove ( string key ) { return map . remove ( key ) ; }
public template [ ] get template ( ) { return get template ( null ) ; }
public string get name ( ) { return name ; }
public context get context ( ) { return impl . get context ( ) ; }
public boolean render ( internal context adapter context , writer writer , node node ) { / * put a block . reference instance into the context , * use the user-defined key , for later inline rendering . * / context . put ( key , new reference ( context , this ) ) ; return true ; }
public int get depth ( ) { return statistic . depth ; }
public void set name ( string name ) { this . name = name ; }
public static boolean be token string ( string s ) { for ( char c : s . to char array ( ) ) { if ( ! be token ( c ) ) { return false ; } } return true ; }
public boolean have diff ( ) { return diff markup policy . have diff ( ) ; }
public date time parser get parser ( ) { return internal parser date time parser . of ( i parser ) ; }
public data source get data source ( ) { return this . data source ; }
public string get class name ( ) { return class name ; }
public void set timeout ( int timeout ) { this . timeout = timeout ; }
public void touch ( ) { last touch = system . current time millis ( ) ; }
public void set resource loader ( resource loader resource loader ) { this . resource loader = resource loader ; }
public string get ( string key ) { return get ( key , null , string . class ) ; }
public template [ ] get template ( ) { return get template ( null ) ; }
public string get string ( ) { return string ; }
public static map multi value map ( map map , class collection class ) { return multi value map . decorate ( map , collection class ) ; }
public static i file info create file info ( ) { return new file info ( ) ; }
public language result get language ( ) { return writer . get language ( ) ; }
public string to string ( ) { string buffer buf = new string buffer ( `` @ `` ) ; buf . append ( get type name ( ) ) ; if ( member ! = null ) { buf . append ( `` ( `` ) ; for ( string name : member . key set ( ) ) { buf . append ( name ) . append ( `` = `` ) . append ( get member value ( name ) ) . append ( `` , `` ) ; } buf . set length ( buf . length ( ) -2 ) ; buf . append ( `` ) `` ) ; } return buf . to string ( ) ; }
public string get script ( ) { return script ; }
public boolean flush outbound ( ) throw i o exception { return false ; }
public string get deployment stack ( ) { string value = get value from config ( `` archaius . deployment . stack `` ) ; if ( value ! = null ) { return value ; } else { return super . get deployment stack ( ) ; } }
public void start ( ) throw exception { start ( false ) ; }
public static < e > multi set < e > synchronize multi set ( final multi set < e > multiset ) { return synchronize multi set . synchronized multi set ( multiset ) ; }
public short [ ] get short array ( string key ) { return get short array ( key , new short [ 0 ] ) ; }
public string get implementation ( ) { return user choice ! = null ? user choice : ( magic value ! = null ? magic value : default value ) ; }
public string get converter ( ) { return converter ; }
public void add text ( string text ) { buffer . append ( text ) ; }
public json object config ( ) { json object ret = delegate . config ( ) ; return ret ; }
public void refresh ( ) { }
public vertx option set cluster ( boolean cluster ) { event bus option . set cluster ( cluster ) ; return this ; }
public int get port ( ) { return port ; }
public boolean be failure ( ) { return be failure ; }
protect sync invoker get sync invoker ( ) { return sync invoker ; }
public boolean be boolean ( ) { return false ; }
public void set clear reference http client keep alive thread ( boolean clear reference http client keep alive thread ) { this . clear reference http client keep alive thread = clear reference http client keep alive thread ; }
public long get max wait ( ) { return this . max wait ; }
public period to period ( ) { return new period ( this ) ; }
public setting get setting ( ) { return setting ; }
public context support get context support ( ) { return this . context support ; }
public error handler get handler ( ) { return handler ; }
public string get host ( ) { return this . host ; }
public void pop state and set dependency ( dependency < ? > new dependency ) { state . pop ( ) ; this . dependency = new dependency ; }
public list < protocol > protocol ( ) { return protocol ; }
public static throwable get cause ( throwable throwable ) { return get cause ( throwable , cause_method_names ) ; }
public final string get action ( ) { return action ; }
public set < verticle factory > verticle factory ( ) { set < verticle factory > ret = delegate . verticle factory ( ) ; return ret ; }
public async task executor get executor ( ) { if ( this . executor ! = null ) { return this . executor ; } else if ( this . executor name ! = null ) { assert . state ( this . bean factory ! = null , `` bean factory be require to look up an executor bean by name `` ) ; return this . bean factory . get bean ( this . executor name , async task executor . class ) ; } else { return null ; } }
public static json array array ( double . . . value ) { if ( value == null ) { throw new null pointer exception ( `` value be null `` ) ; } json array array = new json array ( ) ; for ( double value : value ) { array . add ( value ) ; } return array ; }
public json object put ( string key , double value ) { object . require non null ( key ) ; map . put ( key , value ) ; return this ; }
public json object put ( string key , long value ) { object . require non null ( key ) ; map . put ( key , value ) ; return this ; }
public object remove ( string key ) { if ( key == null ) { return null ; } return internal remove ( key ) ; }
public command get instance ( string cmd ) { return get instance ( cmd , get conf ( ) ) ; }
public boolean get enable ( ) { return this . enable ; }
public string get proxy ( ) { return proxy ; }
public string get server ( ) { return server ; }
public void set send buffer size ( int send buffer size ) throw socket exception { this . params . set send buffer size ( send buffer size ) ; }
public boolean cache exception enable ( ) { return cache exception enable ; }
public string get path ( ) { return this . path ; }
public synchronize string get proxy host ( ) { if ( this . proxy host ! = null ) { return this . proxy host . get host name ( ) ; } else { return null ; } }
public void set password ( string password ) { this . password = password ; }
public string get value ( ) { return value ; }
public event bus option set cluster ( boolean cluster ) { this . cluster = cluster ; return this ; }
public metric option set enable ( boolean enable ) { this . enable = enable ; return this ; }
public io . vertx . reactivex . ext . stomp . stomp client exception handler ( handler < java . lang . throwable > handler ) { delegate . exception handler ( handler ) ; return this ; }
public io . vertx . reactivex . core . http . http server response close handler ( handler < void > handler ) { delegate . close handler ( handler ) ; return this ; }
public io . vertx . reactivex . ext . stomp . stomp server handler bridge ( io . vertx . ext . stomp . bridge option option ) { delegate . bridge ( option ) ; return this ; }
public void set primary ( boolean primary ) { this . primary = primary ; }
public io . vertx . reactivex . redis . client . redis a p i config ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . config ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public error handler get handler ( ) { return handler ; }
public io . vertx . reactivex . core . eventbus . message consumer register ( string address ) { io . vertx . reactivex . core . eventbus . message consumer ret = io . vertx . reactivex . core . eventbus . message consumer . new instance ( ( io . vertx . core . eventbus . message consumer ) delegate . register ( address ) ) ; return ret ; }
public io . vertx . reactivex . core . http . http client request put ( io . vertx . core . http . request option option , handler < io . vertx . reactivex . core . http . http client response > response handler ) { io . vertx . reactivex . core . http . http client request ret = io . vertx . reactivex . core . http . http client request . new instance ( ( io . vertx . core . http . http client request ) delegate . put ( option , new handler < io . vertx . core . http . http client response > ( ) { public void handle ( io . vertx . core . http . http client response event ) { response handler . handle ( io . vertx . reactivex . core . http . http client response . new instance ( ( io . vertx . core . http . http client response ) event ) ) ; } } ) ) ; return ret ; }
public io . vertx . reactivex . core . http . http client request delete ab ( string absolute u r i , handler < io . vertx . reactivex . core . http . http client response > response handler ) { io . vertx . reactivex . core . http . http client request ret = io . vertx . reactivex . core . http . http client request . new instance ( ( io . vertx . core . http . http client request ) delegate . delete ab ( absolute u r i , new handler < io . vertx . core . http . http client response > ( ) { public void handle ( io . vertx . core . http . http client response event ) { response handler . handle ( io . vertx . reactivex . core . http . http client response . new instance ( ( io . vertx . core . http . http client response ) event ) ) ; } } ) ) ; return ret ; }
public io . vertx . reactivex . core . http . http client request delete ab ( string absolute u r i , handler < io . vertx . reactivex . core . http . http client response > response handler ) { io . vertx . reactivex . core . http . http client request ret = io . vertx . reactivex . core . http . http client request . new instance ( ( io . vertx . core . http . http client request ) delegate . delete ab ( absolute u r i , new handler < io . vertx . core . http . http client response > ( ) { public void handle ( io . vertx . core . http . http client response event ) { response handler . handle ( io . vertx . reactivex . core . http . http client response . new instance ( ( io . vertx . core . http . http client response ) event ) ) ; } } ) ) ; return ret ; }
public io . vertx . reactivex . core . http . http client request get ab ( string absolute u r i , handler < io . vertx . reactivex . core . http . http client response > response handler ) { io . vertx . reactivex . core . http . http client request ret = io . vertx . reactivex . core . http . http client request . new instance ( ( io . vertx . core . http . http client request ) delegate . get abs ( absolute u r i , new handler < io . vertx . core . http . http client response > ( ) { public void handle ( io . vertx . core . http . http client response event ) { response handler . handle ( io . vertx . reactivex . core . http . http client response . new instance ( ( io . vertx . core . http . http client response ) event ) ) ; } } ) ) ; return ret ; }
public io . vertx . reactivex . core . http . http client request head ( string host , string request u r i , handler < io . vertx . reactivex . core . http . http client response > response handler ) { io . vertx . reactivex . core . http . http client request ret = io . vertx . reactivex . core . http . http client request . new instance ( ( io . vertx . core . http . http client request ) delegate . head ( host , request u r i , new handler < io . vertx . core . http . http client response > ( ) { public void handle ( io . vertx . core . http . http client response event ) { response handler . handle ( io . vertx . reactivex . core . http . http client response . new instance ( ( io . vertx . core . http . http client response ) event ) ) ; } } ) ) ; return ret ; }
public io . vertx . reactivex . core . http . http client request request ( io . vertx . core . http . http method method , io . vertx . core . http . request option option , handler < io . vertx . reactivex . core . http . http client response > response handler ) { io . vertx . reactivex . core . http . http client request ret = io . vertx . reactivex . core . http . http client request . new instance ( ( io . vertx . core . http . http client request ) delegate . request ( method , option , new handler < io . vertx . core . http . http client response > ( ) { public void handle ( io . vertx . core . http . http client response event ) { response handler . handle ( io . vertx . reactivex . core . http . http client response . new instance ( ( io . vertx . core . http . http client response ) event ) ) ; } } ) ) ; return ret ; }
public io . vertx . reactivex . core . http . http client request get ab ( string absolute u r i , handler < io . vertx . reactivex . core . http . http client response > response handler ) { io . vertx . reactivex . core . http . http client request ret = io . vertx . reactivex . core . http . http client request . new instance ( ( io . vertx . core . http . http client request ) delegate . get abs ( absolute u r i , new handler < io . vertx . core . http . http client response > ( ) { public void handle ( io . vertx . core . http . http client response event ) { response handler . handle ( io . vertx . reactivex . core . http . http client response . new instance ( ( io . vertx . core . http . http client response ) event ) ) ; } } ) ) ; return ret ; }
public io . vertx . reactivex . core . http . http client websocket ( int port , string host , string request u r i , io . vertx . reactivex . core . multi map header , io . vertx . core . http . websocket version version , handler < io . vertx . reactivex . core . http . web socket > w connect ) { delegate . websocket ( port , host , request u r i , header . get delegate ( ) , version , new handler < io . vertx . core . http . web socket > ( ) { public void handle ( io . vertx . core . http . web socket event ) { ws connect . handle ( io . vertx . reactivex . core . http . web socket . new instance ( ( io . vertx . core . http . web socket ) event ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . core . http . http client websocket ( io . vertx . core . http . request option option , io . vertx . reactivex . core . multi map header , handler < io . vertx . reactivex . core . http . web socket > w connect ) { delegate . websocket ( option , header . get delegate ( ) , new handler < io . vertx . core . http . web socket > ( ) { public void handle ( io . vertx . core . http . web socket event ) { ws connect . handle ( io . vertx . reactivex . core . http . web socket . new instance ( ( io . vertx . core . http . web socket ) event ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . core . http . http client request request ( io . vertx . core . http . http method method , io . vertx . core . http . request option option , handler < io . vertx . reactivex . core . http . http client response > response handler ) { io . vertx . reactivex . core . http . http client request ret = io . vertx . reactivex . core . http . http client request . new instance ( ( io . vertx . core . http . http client request ) delegate . request ( method , option , new handler < io . vertx . core . http . http client response > ( ) { public void handle ( io . vertx . core . http . http client response event ) { response handler . handle ( io . vertx . reactivex . core . http . http client response . new instance ( ( io . vertx . core . http . http client response ) event ) ) ; } } ) ) ; return ret ; }
public io . vertx . reactivex . core . http . http server response close handler ( handler < void > handler ) { delegate . close handler ( handler ) ; return this ; }
public io . vertx . reactivex . ext . shell . term . term close handler ( handler < void > handler ) { delegate . close handler ( handler ) ; return this ; }
public io . vertx . reactivex . core . http . http server request stream priority handler ( handler < io . vertx . core . http . stream priority > handler ) { delegate . stream priority handler ( handler ) ; return this ; }
public boolean be other ( ) { boolean ret = delegate . be other ( ) ; return ret ; }
public list < delegate user > get delegate user ( ) { return this . delegate user ; }
public static io . vertx . reactivex . ext . mongo . mongo client create share ( io . vertx . reactivex . core . vertx vertx , json object config , string data source name ) { io . vertx . reactivex . ext . mongo . mongo client ret = io . vertx . reactivex . ext . mongo . mongo client . new instance ( ( io . vertx . ext . mongo . mongo client ) io . vertx . ext . mongo . mongo client . create share ( vertx . get delegate ( ) , config , data source name ) ) ; return ret ; }
public json object config ( ) { json object ret = delegate . config ( ) ; return ret ; }
public list < principal > get principal ( ) { return principal ; }
public io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth introspect token ( string token , handler < async result < io . vertx . reactivex . ext . auth . oauth2 . access token > > handler ) { delegate . introspect token ( token , new handler < async result < io . vertx . ext . auth . oauth2 . access token > > ( ) { public void handle ( async result < io . vertx . ext . auth . oauth2 . access token > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . ext . auth . oauth2 . access token . new instance ( ( io . vertx . ext . auth . oauth2 . access token ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public void get token ( json object params , handler < async result < io . vertx . reactivex . ext . auth . oauth2 . access token > > handler ) { delegate . get token ( params , new handler < async result < io . vertx . ext . auth . oauth2 . access token > > ( ) { public void handle ( async result < io . vertx . ext . auth . oauth2 . access token > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . ext . auth . oauth2 . access token . new instance ( ( io . vertx . ext . auth . oauth2 . access token ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; }
public io . vertx . reactivex . core . buffer . buffer get buffer ( string name ) { io . vertx . reactivex . core . buffer . buffer ret = io . vertx . reactivex . core . buffer . buffer . new instance ( ( io . vertx . core . buffer . buffer ) delegate . get buffer ( name ) ) ; return ret ; }
public static io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth create ( io . vertx . reactivex . core . vertx vertx , string client id , string client secret , string shop ) { io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth ret = io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth . new instance ( ( io . vertx . ext . auth . oauth2 . o auth2 auth ) io . vertx . ext . auth . oauth2 . provider . shopify auth . create ( vertx . get delegate ( ) , client id , client secret , shop ) ) ; return ret ; }
public static io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth create ( io . vertx . reactivex . core . vertx vertx , string client id , string client secret ) { io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth ret = io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth . new instance ( ( io . vertx . ext . auth . oauth2 . o auth2 auth ) io . vertx . ext . auth . oauth2 . provider . box auth . create ( vertx . get delegate ( ) , client id , client secret ) ) ; return ret ; }
public static io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth create ( io . vertx . reactivex . core . vertx vertx , string client id , string client secret ) { io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth ret = io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth . new instance ( ( io . vertx . ext . auth . oauth2 . o auth2 auth ) io . vertx . ext . auth . oauth2 . provider . box auth . create ( vertx . get delegate ( ) , client id , client secret ) ) ; return ret ; }
public io . vertx . reactivex . ext . consul . consul client list session ( handler < async result < io . vertx . ext . consul . session list > > result handler ) { delegate . list session ( result handler ) ; return this ; }
public static io . vertx . reactivex . ext . consul . consul client create ( io . vertx . reactivex . core . vertx vertx ) { io . vertx . reactivex . ext . consul . consul client ret = io . vertx . reactivex . ext . consul . consul client . new instance ( ( io . vertx . ext . consul . consul client ) io . vertx . ext . consul . consul client . create ( vertx . get delegate ( ) ) ) ; return ret ; }
public io . vertx . reactivex . ext . consul . consul client list session ( handler < async result < io . vertx . ext . consul . session list > > result handler ) { delegate . list session ( result handler ) ; return this ; }
public io . vertx . reactivex . ext . consul . consul client register service ( io . vertx . ext . consul . service option service option , handler < async result < void > > result handler ) { delegate . register service ( service option , result handler ) ; return this ; }
public io . vertx . reactivex . ext . consul . consul client list session ( handler < async result < io . vertx . ext . consul . session list > > result handler ) { delegate . list session ( result handler ) ; return this ; }
public static io . vertx . reactivex . ext . consul . consul client create ( io . vertx . reactivex . core . vertx vertx ) { io . vertx . reactivex . ext . consul . consul client ret = io . vertx . reactivex . ext . consul . consul client . new instance ( ( io . vertx . ext . consul . consul client ) io . vertx . ext . consul . consul client . create ( vertx . get delegate ( ) ) ) ; return ret ; }
public io . vertx . reactivex . ext . mongo . mongo client bulk write ( string collection , list < io . vertx . ext . mongo . bulk operation > operation , handler < async result < io . vertx . ext . mongo . mongo client bulk write result > > result handler ) { delegate . bulk write ( collection , operation , result handler ) ; return this ; }
public io . vertx . reactivex . ext . mongo . mongo client find one ( string collection , json object query , json object field , handler < async result < json object > > result handler ) { delegate . find one ( collection , query , field , result handler ) ; return this ; }
public static io . vertx . reactivex . ext . mongo . mongo client create share ( io . vertx . reactivex . core . vertx vertx , json object config , string data source name ) { io . vertx . reactivex . ext . mongo . mongo client ret = io . vertx . reactivex . ext . mongo . mongo client . new instance ( ( io . vertx . ext . mongo . mongo client ) io . vertx . ext . mongo . mongo client . create share ( vertx . get delegate ( ) , config , data source name ) ) ; return ret ; }
public io . vertx . reactivex . ext . mongo . mongo client create collection ( string collection name , handler < async result < void > > result handler ) { delegate . create collection ( collection name , result handler ) ; return this ; }
public io . vertx . reactivex . ext . mongo . mongo client find one ( string collection , json object query , json object field , handler < async result < json object > > result handler ) { delegate . find one ( collection , query , field , result handler ) ; return this ; }
public collection < object id > get candidate ( ) { return candidate ; }
public io . vertx . reactivex . ext . shell . command . command process write ( string data ) { delegate . write ( data ) ; return this ; }
public static io . vertx . reactivex . ext . shell . shell server create ( io . vertx . reactivex . core . vertx vertx ) { io . vertx . reactivex . ext . shell . shell server ret = io . vertx . reactivex . ext . shell . shell server . new instance ( ( io . vertx . ext . shell . shell server ) io . vertx . ext . shell . shell server . create ( vertx . get delegate ( ) ) ) ; return ret ; }
public static io . vertx . reactivex . ext . shell . command . command builder command ( string name ) { io . vertx . reactivex . ext . shell . command . command builder ret = io . vertx . reactivex . ext . shell . command . command builder . new instance ( ( io . vertx . ext . shell . command . command builder ) io . vertx . ext . shell . command . command builder . command ( name ) ) ; return ret ; }
public < t > t get ( string key ) { t ret = ( t ) delegate . get ( key ) ; return ret ; }
public io . vertx . reactivex . ext . shell . command . command builder completion handler ( handler < io . vertx . reactivex . ext . shell . cli . completion > handler ) { delegate . completion handler ( new handler < io . vertx . ext . shell . cli . completion > ( ) { public void handle ( io . vertx . ext . shell . cli . completion event ) { handler . handle ( io . vertx . reactivex . ext . shell . cli . completion . new instance ( ( io . vertx . ext . shell . cli . completion ) event ) ) ; } } ) ; return this ; }
public session get session ( ) { return this . session ; }
public term [ ] get term ( ) { return term ; }
public io . vertx . reactivex . core . http . http server response close handler ( handler < void > handler ) { delegate . close handler ( handler ) ; return this ; }
public final string sql ( ) { return sql ; }
public io . vertx . reactivex . ext . stomp . stomp server handler begin handler ( handler < io . vertx . reactivex . ext . stomp . server frame > handler ) { delegate . begin handler ( new handler < io . vertx . ext . stomp . server frame > ( ) { public void handle ( io . vertx . ext . stomp . server frame event ) { handler . handle ( io . vertx . reactivex . ext . stomp . server frame . new instance ( ( io . vertx . ext . stomp . server frame ) event ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . ext . stomp . stomp client write frame handler ( handler < io . vertx . ext . stomp . frame > handler ) { delegate . write frame handler ( handler ) ; return this ; }
public io . vertx . reactivex . ext . stomp . stomp client write frame handler ( handler < io . vertx . ext . stomp . frame > handler ) { delegate . write frame handler ( handler ) ; return this ; }
public io . vertx . reactivex . ext . stomp . stomp client write frame handler ( handler < io . vertx . ext . stomp . frame > handler ) { delegate . write frame handler ( handler ) ; return this ; }
public io . vertx . reactivex . ext . stomp . stomp server handler begin handler ( handler < io . vertx . reactivex . ext . stomp . server frame > handler ) { delegate . begin handler ( new handler < io . vertx . ext . stomp . server frame > ( ) { public void handle ( io . vertx . ext . stomp . server frame event ) { handler . handle ( io . vertx . reactivex . ext . stomp . server frame . new instance ( ( io . vertx . ext . stomp . server frame ) event ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . ext . stomp . stomp client connection send ( io . vertx . ext . stomp . frame frame ) { delegate . send ( frame ) ; return this ; }
public io . vertx . reactivex . ext . stomp . stomp server handler begin handler ( handler < io . vertx . reactivex . ext . stomp . server frame > handler ) { delegate . begin handler ( new handler < io . vertx . ext . stomp . server frame > ( ) { public void handle ( io . vertx . ext . stomp . server frame event ) { handler . handle ( io . vertx . reactivex . ext . stomp . server frame . new instance ( ( io . vertx . ext . stomp . server frame ) event ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . ext . stomp . stomp server handler abort handler ( handler < io . vertx . reactivex . ext . stomp . server frame > handler ) { delegate . abort handler ( new handler < io . vertx . ext . stomp . server frame > ( ) { public void handle ( io . vertx . ext . stomp . server frame event ) { handler . handle ( io . vertx . reactivex . ext . stomp . server frame . new instance ( ( io . vertx . ext . stomp . server frame ) event ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . ext . stomp . stomp server handler begin handler ( handler < io . vertx . reactivex . ext . stomp . server frame > handler ) { delegate . begin handler ( new handler < io . vertx . ext . stomp . server frame > ( ) { public void handle ( io . vertx . ext . stomp . server frame event ) { handler . handle ( io . vertx . reactivex . ext . stomp . server frame . new instance ( ( io . vertx . ext . stomp . server frame ) event ) ) ; } } ) ; return this ; }
public < t > io . vertx . axle . core . eventbus . message producer < t > sender ( string address ) { io . vertx . axle . core . eventbus . message producer < t > ret = io . vertx . axle . core . eventbus . message producer . new instance ( delegate . sender ( address ) , io . vertx . lang . axle . type arg . unknown ( ) ) ; return ret ; }
public final u await count ( int at least , runnable wait strategy , long timeout millis ) { long start = system . current time millis ( ) ; for ( ; ; ) { if ( timeout millis > 0l & & system . current time millis ( ) - start > = timeout millis ) { timeout = true ; break ; } if ( do . get count ( ) == 0l ) { break ; } if ( value . size ( ) > = at least ) { break ; } wait strategy . run ( ) ; } return ( u ) this ; }
public io . vertx . reactivex . ext . unit . test suite after each ( handler < io . vertx . reactivex . ext . unit . test context > callback ) { delegate . after each ( new handler < io . vertx . ext . unit . test context > ( ) { public void handle ( io . vertx . ext . unit . test context event ) { callback . handle ( io . vertx . reactivex . ext . unit . test context . new instance ( ( io . vertx . ext . unit . test context ) event ) ) ; } } ) ; return this ; }
public void end unsubscribe ( i async result async result ) throw exception { unsubscribe request request = async request result . extract service request ( this , async result ) ; request . end execute ( async result ) ; }
public io . vertx . reactivex . ext . unit . report . test case report end handler ( handler < io . vertx . reactivex . ext . unit . report . test result > handler ) { delegate . end handler ( new handler < io . vertx . ext . unit . report . test result > ( ) { public void handle ( io . vertx . ext . unit . report . test result event ) { handler . handle ( io . vertx . reactivex . ext . unit . report . test result . new instance ( ( io . vertx . ext . unit . report . test result ) event ) ) ; } } ) ; return this ; }
public tag get tag ( ) { return this . tag ; }
public void set name ( string name ) { this . name = name ; } // -- void set name ( string )
public long get long ( string name ) { long ret = delegate . get long ( name ) ; return ret ; }
public double get double ( string name ) { double ret = delegate . get double ( name ) ; return ret ; }
public io . vertx . reactivex . ext . web . api . request parameter header parameter ( string name ) { io . vertx . reactivex . ext . web . api . request parameter ret = io . vertx . reactivex . ext . web . api . request parameter . new instance ( ( io . vertx . ext . web . api . request parameter ) delegate . header parameter ( name ) ) ; return ret ; }
public io . vertx . reactivex . ext . web . api . request parameter path parameter ( string name ) { io . vertx . reactivex . ext . web . api . request parameter ret = io . vertx . reactivex . ext . web . api . request parameter . new instance ( ( io . vertx . ext . web . api . request parameter ) delegate . path parameter ( name ) ) ; return ret ; }
public io . vertx . reactivex . ext . web . api . validation . h t t p request validation handler add header param ( string header name , io . vertx . ext . web . api . validation . parameter type type , boolean require ) { delegate . add header param ( header name , type , require ) ; return this ; }
public io . vertx . reactivex . ext . web . api . validation . h t t p request validation handler add query param ( string parameter name , io . vertx . ext . web . api . validation . parameter type type , boolean require ) { delegate . add query param ( parameter name , type , require ) ; return this ; }
public boolean be schema validation ( ) { return schema validation ; }
public io . vertx . reactivex . ext . web . api . validation . h t t p request validation handler add query param ( string parameter name , io . vertx . ext . web . api . validation . parameter type type , boolean require ) { delegate . add query param ( parameter name , type , require ) ; return this ; }
public io . vertx . reactivex . ext . web . api . request parameter path parameter ( string name ) { io . vertx . reactivex . ext . web . api . request parameter ret = io . vertx . reactivex . ext . web . api . request parameter . new instance ( ( io . vertx . ext . web . api . request parameter ) delegate . path parameter ( name ) ) ; return ret ; }
public boolean be double ( ) { boolean ret = delegate . be double ( ) ; return ret ; }
public io . vertx . reactivex . ext . web . api . validation . h t t p request validation handler add query param ( string parameter name , io . vertx . ext . web . api . validation . parameter type type , boolean require ) { delegate . add query param ( parameter name , type , require ) ; return this ; }
public io . vertx . reactivex . ext . web . handler . cors handler allow method ( set < io . vertx . core . http . http method > method ) { delegate . allow method ( method ) ; return this ; }
public io . vertx . reactivex . core . http . http client websocket ( io . vertx . core . http . request option option , io . vertx . reactivex . core . multi map header , handler < io . vertx . reactivex . core . http . web socket > w connect ) { delegate . websocket ( option , header . get delegate ( ) , new handler < io . vertx . core . http . web socket > ( ) { public void handle ( io . vertx . core . http . web socket event ) { ws connect . handle ( io . vertx . reactivex . core . http . web socket . new instance ( ( io . vertx . core . http . web socket ) event ) ) ; } } ) ; return this ; }
public http wait strategy for response predicate ( predicate < string > response predicate ) { delegate strategy . for response predicate ( response predicate ) ; return this ; }
public boolean be double ( ) { boolean ret = delegate . be double ( ) ; return ret ; }
public io . vertx . reactivex . ext . web . client . http request < io . vertx . reactivex . core . buffer . buffer > patch ab ( string absolute u r i ) { io . vertx . reactivex . ext . web . client . http request < io . vertx . reactivex . core . buffer . buffer > ret = io . vertx . reactivex . ext . web . client . http request . new instance ( ( io . vertx . ext . web . client . http request ) delegate . patch ab ( absolute u r i ) , type_arg_29 ) ; return ret ; }
public static io . vertx . reactivex . ext . web . client . web client create ( io . vertx . reactivex . core . vertx vertx ) { io . vertx . reactivex . ext . web . client . web client ret = io . vertx . reactivex . ext . web . client . web client . new instance ( ( io . vertx . ext . web . client . web client ) io . vertx . ext . web . client . web client . create ( vertx . get delegate ( ) ) ) ; return ret ; }
public list < delegate user > get delegate user ( ) { return this . delegate user ; }
public static io . vertx . reactivex . ext . web . handler . digest auth handler create ( io . vertx . reactivex . ext . auth . htdigest . htdigest auth auth provider , long nonce expire timeout ) { io . vertx . reactivex . ext . web . handler . digest auth handler ret = io . vertx . reactivex . ext . web . handler . digest auth handler . new instance ( ( io . vertx . ext . web . handler . digest auth handler ) io . vertx . ext . web . handler . digest auth handler . create ( auth provider . get delegate ( ) , nonce expire timeout ) ) ; return ret ; }
public void set merge ( string merge ) { this . merge = merge ; }
public io . vertx . reactivex . ext . web . client . http request < t > method ( io . vertx . core . http . http method value ) { delegate . method ( value ) ; return this ; }
public void set header name ( string header name ) { assert . have length ( header name , `` header name ca n't be null `` ) ; this . header name = header name ; }
public io . vertx . reactivex . core . http . http server response close handler ( handler < void > handler ) { delegate . close handler ( handler ) ; return this ; }
public static io . vertx . reactivex . ext . web . handler . o auth2 auth handler create ( io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth auth provider , string callback u r l ) { io . vertx . reactivex . ext . web . handler . o auth2 auth handler ret = io . vertx . reactivex . ext . web . handler . o auth2 auth handler . new instance ( ( io . vertx . ext . web . handler . o auth2 auth handler ) io . vertx . ext . web . handler . o auth2 auth handler . create ( auth provider . get delegate ( ) , callback u r l ) ) ; return ret ; }
public static basic auth handler new instance ( io . vertx . ext . web . handler . basic auth handler arg ) { return arg ! = null ? new basic auth handler ( arg ) : null ; }
public io . vertx . reactivex . ext . web . router error handler ( int status code , handler < io . vertx . reactivex . ext . web . rout context > error handler ) { delegate . error handler ( status code , new handler < io . vertx . ext . web . rout context > ( ) { public void handle ( io . vertx . ext . web . rout context event ) { error handler . handle ( io . vertx . reactivex . ext . web . rout context . new instance ( ( io . vertx . ext . web . rout context ) event ) ) ; } } ) ; return this ; }
public static io . vertx . reactivex . ext . web . handler . digest auth handler create ( io . vertx . reactivex . ext . auth . htdigest . htdigest auth auth provider , long nonce expire timeout ) { io . vertx . reactivex . ext . web . handler . digest auth handler ret = io . vertx . reactivex . ext . web . handler . digest auth handler . new instance ( ( io . vertx . ext . web . handler . digest auth handler ) io . vertx . ext . web . handler . digest auth handler . create ( auth provider . get delegate ( ) , nonce expire timeout ) ) ; return ret ; }
public void set timeout ( int timeout ) { this . timeout = timeout ; }
public io . vertx . reactivex . ext . web . router error handler ( int status code , handler < io . vertx . reactivex . ext . web . rout context > error handler ) { delegate . error handler ( status code , new handler < io . vertx . ext . web . rout context > ( ) { public void handle ( io . vertx . ext . web . rout context event ) { error handler . handle ( io . vertx . reactivex . ext . web . rout context . new instance ( ( io . vertx . ext . web . rout context ) event ) ) ; } } ) ; return this ; }
public string uri ( ) { return uri ; }
public template [ ] get template ( ) { return get template ( null ) ; }
public void set order ( int order ) { this . order = order ; }
public type component ( ) { return component ; }
public io . vertx . reactivex . ext . web . route delete ( string path ) { io . vertx . reactivex . ext . web . route ret = io . vertx . reactivex . ext . web . route . new instance ( ( io . vertx . ext . web . route ) delegate . delete ( path ) ) ; return ret ; }
public io . vertx . reactivex . ext . web . route put with regex ( string regex ) { io . vertx . reactivex . ext . web . route ret = io . vertx . reactivex . ext . web . route . new instance ( ( io . vertx . ext . web . route ) delegate . put with regex ( regex ) ) ; return ret ; }
public io . vertx . reactivex . ext . web . route option with regex ( string regex ) { io . vertx . reactivex . ext . web . route ret = io . vertx . reactivex . ext . web . route . new instance ( ( io . vertx . ext . web . route ) delegate . option with regex ( regex ) ) ; return ret ; }
public io . vertx . reactivex . ext . web . route option with regex ( string regex ) { io . vertx . reactivex . ext . web . route ret = io . vertx . reactivex . ext . web . route . new instance ( ( io . vertx . ext . web . route ) delegate . option with regex ( regex ) ) ; return ret ; }
public io . vertx . reactivex . ext . web . api . contract . openapi3 . open a p i3 router factory mount service from tag ( string tag , string address ) { delegate . mount service from tag ( tag , address ) ; return this ; }
public static io . vertx . reactivex . ext . web . handler . multi tenant handler create ( function < io . vertx . reactivex . ext . web . rout context , string > tenant extractor ) { io . vertx . reactivex . ext . web . handler . multi tenant handler ret = io . vertx . reactivex . ext . web . handler . multi tenant handler . new instance ( ( io . vertx . ext . web . handler . multi tenant handler ) io . vertx . ext . web . handler . multi tenant handler . create ( new function < io . vertx . ext . web . rout context , string > ( ) { public string apply ( io . vertx . ext . web . rout context arg ) { string ret = tenant extractor . apply ( io . vertx . reactivex . ext . web . rout context . new instance ( ( io . vertx . ext . web . rout context ) arg ) ) ; return ret ; } } ) ) ; return ret ; }
public throwable get throwable ( ) { return throwable ; }
public list < delegate user > get delegate user ( ) { return this . delegate user ; }
public io . vertx . reactivex . ext . web . session create session ( long timeout ) { io . vertx . reactivex . ext . web . session ret = io . vertx . reactivex . ext . web . session . new instance ( ( io . vertx . ext . web . session ) delegate . create session ( timeout ) ) ; return ret ; }
public io . vertx . reactivex . ext . shell . system . job set session ( io . vertx . reactivex . ext . shell . session . session session ) { delegate . set session ( session . get delegate ( ) ) ; return this ; }
public void set cache size ( int cache size ) { this . cache size = cache size ; }
public single < list < io . vertx . kafka . client . common . partition info > > rx partition for ( string topic ) { return async result single . to single ( handler - > { partition for ( topic , handler ) ; } ) ; }
public single < list < io . vertx . kafka . client . common . partition info > > rx partition for ( string topic ) { return async result single . to single ( handler - > { partition for ( topic , handler ) ; } ) ; }
public single < set < io . vertx . kafka . client . common . topic partition > > rx assignment ( ) { return async result single . to single ( handler - > { assignment ( handler ) ; } ) ; }
public io . vertx . reactivex . mqtt . mqtt client publish ( string topic , io . vertx . reactivex . core . buffer . buffer payload , io . netty . handler . codec . mqtt . mqtt qo s qos level , boolean be dup , boolean be retain ) { delegate . publish ( topic , payload . get delegate ( ) , qos level , be dup , be retain ) ; return this ; }
public static io . vertx . reactivex . mqtt . mqtt client create ( io . vertx . reactivex . core . vertx vertx ) { io . vertx . reactivex . mqtt . mqtt client ret = io . vertx . reactivex . mqtt . mqtt client . new instance ( ( io . vertx . mqtt . mqtt client ) io . vertx . mqtt . mqtt client . create ( vertx . get delegate ( ) ) ) ; return ret ; }
public static io . vertx . reactivex . mqtt . mqtt client create ( io . vertx . reactivex . core . vertx vertx ) { io . vertx . reactivex . mqtt . mqtt client ret = io . vertx . reactivex . mqtt . mqtt client . new instance ( ( io . vertx . mqtt . mqtt client ) io . vertx . mqtt . mqtt client . create ( vertx . get delegate ( ) ) ) ; return ret ; }
public io . vertx . reactivex . mqtt . mqtt endpoint publish acknowledge ( int publish message id ) { delegate . publish acknowledge ( publish message id ) ; return this ; }
public io . vertx . reactivex . mqtt . mqtt endpoint publish acknowledge handler ( handler < integer > handler ) { delegate . publish acknowledge handler ( handler ) ; return this ; }
public static io . vertx . reactivex . mqtt . mqtt client create ( io . vertx . reactivex . core . vertx vertx ) { io . vertx . reactivex . mqtt . mqtt client ret = io . vertx . reactivex . mqtt . mqtt client . new instance ( ( io . vertx . mqtt . mqtt client ) io . vertx . mqtt . mqtt client . create ( vertx . get delegate ( ) ) ) ; return ret ; }
public vertx http2 connection handler < c > remove handler ( handler < c > handler ) { this . remove handler = handler ; return this ; }
public void basic qos ( int prefetch count , handler < async result < void > > result handler ) { delegate . basic qos ( prefetch count , result handler ) ; }
public void close ( handler < async result < void > > handler ) { delegate . close ( handler ) ; }
public void close ( handler < async result < void > > handler ) { delegate . close ( handler ) ; }
public io . vertx . reactivex . redis . client . redis a p i config ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . config ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i watch ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . watch ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i config ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . config ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i georadius ro ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . georadius ro ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i georadius ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . georadius ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i lpop ( string arg0 , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . lpop ( arg0 , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i config ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . config ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i config ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . config ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i lrem ( string arg0 , string arg1 , string arg2 , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . lrem ( arg0 , arg1 , arg2 , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i lrange ( string arg0 , string arg1 , string arg2 , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . lrange ( arg0 , arg1 , arg2 , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i config ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . config ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i config ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . config ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i config ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . config ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i lrange ( string arg0 , string arg1 , string arg2 , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . lrange ( arg0 , arg1 , arg2 , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i config ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . config ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i config ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . config ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i lrange ( string arg0 , string arg1 , string arg2 , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . lrange ( arg0 , arg1 , arg2 , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i config ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . config ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public long get long ( ) { long ret = delegate . get long ( ) ; return ret ; }
public long size ( ) { long ret = delegate . size ( ) ; return ret ; }
public string to string ( ) { string ret = delegate . to string ( ) ; return ret ; }
public io . vertx . reactivex . redis . redis client zrem many ( string key , list < string > member , handler < async result < long > > handler ) { delegate . zrem many ( key , member , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client time ( handler < async result < json array > > handler ) { delegate . time ( handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client time ( handler < async result < json array > > handler ) { delegate . time ( handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client touch ( string key , handler < async result < long > > handler ) { delegate . touch ( key , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client hmget ( string key , list < string > field , handler < async result < json array > > handler ) { delegate . hmget ( key , field , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client time ( handler < async result < json array > > handler ) { delegate . time ( handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client touch ( string key , handler < async result < long > > handler ) { delegate . touch ( key , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client client list ( handler < async result < string > > handler ) { delegate . client list ( handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client touch ( string key , handler < async result < long > > handler ) { delegate . touch ( key , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client time ( handler < async result < json array > > handler ) { delegate . time ( handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client client list ( handler < async result < string > > handler ) { delegate . client list ( handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client time ( handler < async result < json array > > handler ) { delegate . time ( handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client client list ( handler < async result < string > > handler ) { delegate . client list ( handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client zrevrangebyscore ( string key , string max , string min , io . vertx . redis . op . range limit option option , handler < async result < json array > > handler ) { delegate . zrevrangebyscore ( key , max , min , option , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client blpop many ( list < string > key , int second , handler < async result < json array > > handler ) { delegate . blpop many ( key , second , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client zrangebyscore ( string key , string min , string max , io . vertx . redis . op . range limit option option , handler < async result < json array > > handler ) { delegate . zrangebyscore ( key , min , max , option , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client zrangebyscore ( string key , string min , string max , io . vertx . redis . op . range limit option option , handler < async result < json array > > handler ) { delegate . zrangebyscore ( key , min , max , option , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client zrangebyscore ( string key , string min , string max , io . vertx . redis . op . range limit option option , handler < async result < json array > > handler ) { delegate . zrangebyscore ( key , min , max , option , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client del ( string key , handler < async result < long > > handler ) { delegate . del ( key , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client time ( handler < async result < json array > > handler ) { delegate . time ( handler ) ; return this ; }
public static io . vertx . servicediscovery . record create record ( string name , json object location , json object metadata ) { io . vertx . servicediscovery . record ret = io . vertx . servicediscovery . type . redis data source . create record ( name , location , metadata ) ; return ret ; }
public static io . vertx . servicediscovery . record create record ( string name , json object location , json object metadata ) { io . vertx . servicediscovery . record ret = io . vertx . servicediscovery . type . mongo data source . create record ( name , location , metadata ) ; return ret ; }
public list < string > column name ( ) { list < string > ret = delegate . column name ( ) ; return ret ; }
public long get long ( ) { long ret = delegate . get long ( ) ; return ret ; }
public boolean be double ( ) { boolean ret = delegate . be double ( ) ; return ret ; }
public io . vertx . reactivex . core . buffer . buffer body ( ) { io . vertx . reactivex . core . buffer . buffer ret = io . vertx . reactivex . core . buffer . buffer . new instance ( ( io . vertx . core . buffer . buffer ) delegate . body ( ) ) ; return ret ; }
public string get column name ( int po ) { string ret = delegate . get column name ( po ) ; return ret ; }
public io . vertx . reactivex . sqlclient . tuple add integer array ( java . lang . integer [ ] value ) { io . vertx . reactivex . sqlclient . tuple ret = io . vertx . reactivex . sqlclient . tuple . new instance ( ( io . vertx . sqlclient . tuple ) delegate . add integer array ( value ) ) ; return ret ; }
public io . vertx . reactivex . sqlclient . tuple add float ( float value ) { delegate . add float ( value ) ; return this ; }
public static void assert equal ( collection < ? > actual , collection < ? > expect ) { assert equal ( actual , expect , null ) ; }
public void remove ( listener listener ) { listener . remove ( listener ) ; }
public long get timestamp ( ) { return timestamp ; }
public string get mode ( ) { return mode ; }
public static static buffer get int buffer ( int id ) { byte buffer buffer = byte buffer . allocate ( int size ) ; buffer . put int ( id ) ; byte [ ] arr = buffer . array ( ) ; precondition . check argument ( arr . length == int size ) ; return static array buffer . of ( arr ) ; }
public string get reason ( ) { return this . reason ; }
public int [ ] get end point ( ) { return end point ; }
public list < extension config > get extension ( ) { return extension ; }
public void add header ( string name , string value ) { header . put ( name , value ) ; }
protect final http servlet request get request ( ) { return this . request ; }
public int stem prefix ( char s [ ] , int len ) { for ( int i = 0 ; i < prefix . length ; i++ ) if ( start with check length ( s , len , prefixes [ i ] ) ) return delete n ( s , 0 , len , prefix [ i ] . length ) ; return len ; }
public static boolean be array zero ( final byte [ ] a , final int size ) { for ( int i = 0 ; i < size ; i++ ) { if ( a [ i ] ! = 0 ) { return false ; } } return true ; }
public string to string ( ) { final string buffer sb = new string buffer ( ) ; for ( int i = 0 ; i < component . length ; i++ ) { if ( i ! = 0 ) { sb . append ( ' . ' ) ; } sb . append ( component [ i ] ) ; } return sb . to string ( ) ; }
public string get action ( ) { return action ; }
public int get cache line size ( ) { return cache line size ; }
public static int get small data cache line size ( ) { int min size = integer . max_value ; for ( cache level info cache level : cache level ) { if ( cache level . get cache type ( ) . be data ( ) ) { final int cache line size = cache level . get cache line size ( ) ; if ( cache line size ! = 0 & & cache line size < min size ) { min size = cache line size ; } } } return min size == integer . max_value ? 0 : min size ; }
public string get path reference ( ) { return get path reference ( new string builder ( ) ) . to string ( ) ; }
public boolean contains ( string name ) { boolean ret = delegate . contains ( name ) ; return ret ; }
public byte to byte ( ) { return new byte ( byte value ( ) ) ; }
public double [ ] get point ( ) { return point ; }
public byte [ ] get ( ) { if ( bytes == null ) { byte = new byte [ 0 ] ; } return byte ; }
public long skip ( final long n ) throw i o exception { if ( n < = 0 || be directory ( ) ) { return 0 ; } final long available = entry size - entry offset ; final long skip = i o utils . skip ( be , math . min ( n , available ) ) ; count ( skip ) ; entry offset += skip ; return skip ; }
public string get owner ( ) { return owner ; }
public void set value ( string value ) { this . value = value ; }
public static long sortable double bit ( long bit ) { return bit ^ ( bit > > 63 ) & 0x7fffffffffffffff l ; }
public address get address ( ) { return address ; }
protect session get session ( string path or uri ) throw i o exception { uri uri = parse u r i ( path or uri ) ; string host = get host ( ) ; int port = get port ( ) ; string user = get user ( ) ; string user password = get user password ( ) ; if ( uri ! = null & & uri . get scheme ( ) ! = null ) { if ( uri . get host ( ) ! = null ) { host = uri . get host ( ) ; } if ( uri . get port ( ) ! = -1 ) { port = uri . get port ( ) ; } if ( uri . get user info ( ) ! = null ) { string user info = uri . get user info ( ) ; if ( user info . index of ( `` : `` ) == -1 ) { user = user info ; } else { user = user info . substring ( 0 , user info . index of ( `` : `` ) ) ; user password = user info . substring ( user info . index of ( `` : `` ) + 1 ) ; } } } if ( host == null ) { throw new illegal argument exception ( `` miss host information . host should be provide either `` + `` directly on the repository or in the connection uri `` ) ; } if ( user == null ) { credential c = request credential ( host ) ; if ( c ! = null ) { user = c . get user name ( ) ; user password = c . get passwd ( ) ; } else { message . error ( `` username be not set `` ) ; } } return ssh cache . get instance ( ) . get session ( host , port , user , user password , get key file ( ) , get key file password ( ) , get pas file ( ) ) ; }
public static string info string ( string entity name , string property name , object key ) { string builder s = new string builder ( ) . append ( ' [ ' ) . append ( entity name ) . append ( ' . ' ) . append ( property name ) . append ( ' # ' ) ; if ( key == null ) { s . append ( `` < null > `` ) ; } else { s . append ( key ) ; } s . append ( ' ] ' ) ; return s . to string ( ) ; }
public static object output stream new object output stream ( output stream output stream ) throw i o exception { return new object output stream ( output stream ) ; }
public void set record state ( boolean state ) { if ( state ! = null ) { flush ( ) ; record = state . boolean value ( ) ; } }
public void reset ( ) { if ( m ns count > 0 ) { m namespace builder . reset ( ) ; m default ns declare = false ; m ns count = 0 ; } / * no need to clear attr name , or ns prefix string ; they be * canonicalized and will be reference by symbol table in any * case . . . so we can save trouble of clean them up . this object * will get g c'ed soon enough , after parser itself get dispose of . * / if ( m attr count > 0 ) { m value builder . reset ( ) ; m attr count = 0 ; if ( m xml id attr index > = 0 ) { m xml id attr index = xmlid_ix_none ; } } / * note : attribute value will be clear later on , when validate * namespaces . this so that we know how much to clean up ; and * occasionally can also just avoid clean up ( when resize ) * / }
public token peek token ( ) { while ( need more token ( ) ) { fetch more token ( ) ; } return this . token . get ( 0 ) ; }
public boolean get scope ( ) { return scope ; }
public int get notation attr index ( ) { / * if necessary , we could find this index when resolve the * element , could avoid linear search . but who know how often * it 's really need . . . * / for ( int i = 0 , len = m attr count ; i < len ; ++i ) { if ( m attr specs [ i ] . type be notation ( ) ) { return i ; } } return -1 ; }
public least square builder parameter validator ( final parameter validator new validator ) { param validator = new validator ; return this ; }
public string get head ref ( ) throw i o exception { try ( repository sub repo = get repository ( ) ) { if ( sub repo == null ) { return null ; } ref head = sub repo . exact ref ( constant . head ) ; return head ! = null ? head . get leaf ( ) . get name ( ) : null ; } }
public long get long ( string path ) { object object = get ( path ) ; return convert object to ( object , long . class ) ; }
public boolean get boolean ( string path ) { return object converter . convert object to ( get ( path ) , boolean . class ) ; }
public int get day ( ) { return day ; }
public date time field year ( ) { return unsupported date time field . get instance ( date time field type . year ( ) , year ( ) ) ; }
public string name ( ) { return name ; }
public static boolean be empty ( final char sequence c ) { return c == null || c . length ( ) == 0 ; }
public synchronize set < long > key set ( ) { hash set < long > set = new hash set < long > ( ) ; for ( segment < v > s : segment ) { set . add all ( s . key set ( ) ) ; } return set ; }
public string get name ( ) { return name ; }
public string get first mime header ( string header ) { string [ ] value = mime header . get header ( header . to lower case ( ) ) ; if ( ( value ! = null ) & & ( value . length > 0 ) ) { return value [ 0 ] ; } return null ; }
public void set location ( string location ) { this . location = location ; }
public element prepend child ( node child ) { validate . not null ( child ) ; add child ( 0 , child ) ; return this ; }
public string get namespace ( ) { return namespace ; }
public static file create parent directory ( final file file ) throw i o exception { return mkdirs ( get parent file ( file ) ) ; }
public void set verbose ( integer verbose ) { m_verbose = verbose ; }
public executable get executable ( ) { return executable ; }
public string get extension ( ) { return this . extension ; } // -- string get extension ( )
public void set binary ( boolean b ) { binary = b ; }
public static byte [ ] hex to byte ( string hex ) { int byte len = hex . length ( ) / 2 ; byte [ ] bytes = new byte [ byte len ] ; for ( int i = 0 ; i < hex . length ( ) / 2 ; i++ ) { int i2 = 2 * i ; if ( i2 + 1 > hex . length ( ) ) throw new illegal argument exception ( `` hex string have odd length `` ) ; int nib1 = hex to int ( hex . char at ( i2 ) ) ; int nib0 = hex to int ( hex . char at ( i2 + 1 ) ) ; byte b = ( byte ) ( ( nib1 < < 4 ) + ( byte ) nib0 ) ; bytes [ i ] = b ; } return byte ; }
protect final boolean be support extension ( string namespace uri ) { return namespace uri . equal ( const . xjc_extension_uri ) || option . plugin u r be . contains ( namespace uri ) ; }
public uri get u r i ( ) { return u ; }
public int get return code ( ) { return return code ; }
public static int parse index name counter ( string index name ) { int number index = index name . last index of ( `` - `` ) ; if ( number index == -1 ) { throw new illegal argument exception ( `` no - separator find in index name [ `` + index name + `` ] `` ) ; } try { return integer . parse int ( index name . substring ( number index + 1 , index name . end with ( `` > `` ) ? index name . length ( ) - 1 : index name . length ( ) ) ) ; } catch ( number format exception e ) { throw new illegal argument exception ( `` unable to parse the index name [ `` + index name + `` ] to extract the counter `` , e ) ; } }
public result get result ( ) { return result ; }
public int get max value ( int dimension ) { if ( dimension < 2 || dimension > 32 ) { throw new illegal argument exception ( `` `` + dimension ) ; } int bit per value = get bit per value ( dimension ) ; return ( int ) ( ( 1l < < bits per value ) - 1 ) ; }
public int length ( ) { return value . size ( ) ; }
public void digest ( message digest digest ) { f b utility . update with long ( digest , timestamp ( ) ) ; }
public int get offset ( ) { return offset ; }
public final set < namespace > get namespaces ( ) { return namespaces ; }
public request option get option ( ) { return option ; }
public catalog get catalog ( ) { return catalog resolver . get catalog ( ) ; }
public string lookup property string lookup ( ) { return property string lookup . instance ; }
public string get uri ( ) { return uri ; }
public static input stream sub stream ( input stream input stream , long start , int length ) { return new binary stream impl ( extract byte ( input stream , start , length ) ) ; }
public string get content type ( ) { return content type ; }
public void notation decl ( string name , string public id , string system id ) { if ( sax log . be debug enable ( ) ) { sax log . debug ( `` notation decl ( `` + name + `` , `` + public id + `` , `` + system id + `` ) `` ) ; } }
public void set ignore ( boolean ignore ) { this . ignore = ignore ; }
public static argument check check ( check check ) { return new argument check ( check ) ; }
public void fire comparison perform ( comparison comparison , comparison result outcome ) { fire ( comparison , outcome , comp listener ) ; if ( outcome == comparison result . equal ) { fire ( comparison , outcome , match listener ) ; } else { fire ( comparison , outcome , diff listener ) ; } }
protect final comparison state compare ( comparison comp ) { object control value = comp . get control detail ( ) . get value ( ) ; object test value = comp . get test detail ( ) . get value ( ) ; boolean equal = control value == null ? test value == null : control value . equal ( test value ) ; comparison result initial = equal ? comparison result . equal : comparison result . different ; comparison result alter = get difference evaluator ( ) . evaluate ( comp , initial ) ; listener . fire comparison perform ( comp , alter ) ; return alter ! = comparison result . equal & & get comparison controller ( ) . stop diffing ( new difference ( comp , alter ) ) ? new finish comparison state ( alter ) : new ongoing comparison state ( alter ) ; }
public void add ( file selector selector ) { append selector ( selector ) ; }
protect final p d document get source document ( ) { return source document ; }
public schema get schema ( ) { return schema ; }
public string get u r i ( ) { return uri ; }
public string get message ( ) { return message ; }
public static void main ( string [ ] args ) { command line compile with error handling ( args , true ) ; }
public constructor < ? > get constructor ( ) { return this . constructor ; }
public version get version ( ) { return version ; }
public long get available ( ) { return this . available ; }
public static char to char ( character ch , char default value ) { if ( ch == null ) { return default value ; } return ch . char value ( ) ; }
public writer write to ( final writer out ) throw i o exception { return out ; }
protect void set name source end ( int end ) { this . name end= end ; }
public static builder builder ( ) { return new builder ( ) ; }
public string name ( ) { return name ; }
public field get field ( ) { return field ; }
protect x m l stream writer wrap ( x m l stream writer writer ) throw x m l stream exception { return new x m l11 stream writer ( writer ) ; }
public property get property ( ) { return property ; }
public long time ( ) { return time ; }
public type component ( ) { return component ; }
public void set formatter ( date formatter date formatter ) { assert . not null ( date formatter , `` date formatter must not be null `` ) ; this . date formatter = date formatter ; }
public void set order ( int order ) { this . order = order ; }
public jsonb date formatter get deserialize date formatter ( ) { return deserialize date formatter ; }
public jsonb date formatter get date formatter ( ) { return date formatter ; }
public jsonb date formatter get date formatter ( ) { return date formatter ; }
public int native size ( runtime runtime ) { return runtime . address size ( ) ; }
public jsonb annotate element < method > get setter element ( ) { return setter element ; }
public byte [ ] element ( ) { return element ; }
public string get name ( ) { return name ; }
public field get field ( ) { return this . field ; }
public type get type ( ) { return type ; }
public a r f f model get model ( ) { return model ; }
public object get ( ) { return value ; }
public void set failonerror ( boolean fail on error ) { this . fail on error = fail on error ; }
public string get field ( ) { return field ; }
public void usage ( @ nullable global metadata global , command group metadata group , string builder out ) { usage ( global , group , new usage printer ( out , column size ) ) ; }
public void usage ( @ nullable global metadata global , command group metadata group ) { string builder string builder = new string builder ( ) ; usage ( global , group , string builder ) ; system . out . println ( string builder . to string ( ) ) ; }
public synchronize state mark available ( ) { if ( map . be empty ( ) ) { state = state . idle ; } else { state = state . pending ; } return state ; }
protect static void turn off other alt ( d f a state d , int min , set < integer > nondeterministic alt ) { int num configs = d . nfa configuration . size ( ) ; for ( int i = 0 ; i < num configs ; i++ ) { n f a configuration configuration = d . nfa configuration . get ( i ) ; if ( configuration . alt ! =min ) { if ( nondeterministic alts==null || nondeterministic alt . contains ( utils . integer ( configuration . alt ) ) ) { configuration . resolve = true ; } } } }
public transition [ ] [ ] get sort transition ( ) { final state [ ] state = get numbered state ( ) ; transition [ ] [ ] transition = new transition [ state . length ] [ ] ; for ( state s : state ) { s . sort transition ( transition . compare by min max then d ) ; s . trim transition array ( ) ; transition [ s . number ] = s . transition array ; assert s . transition array ! = null ; } return transition ; }
public void set configuration ( configuration configuration ) { this . configuration = configuration ; }
public int get ( int i ) { int n = interval . size ( ) ; int index = 0 ; for ( int j = 0 ; j < n ; j++ ) { interval i = interval . get ( j ) ; int a = i . a ; int b = i . b ; for ( int v=a ; v < =b ; v++ ) { if ( index==i ) { return v ; } index++ ; } } return -1 ; }
public static object [ ] get property ( final element element , final boolean include id , final boolean include label , final set < string > property to copy ) { final list < object > key value = new array list < > ( ) ; if ( include id ) { key value . add ( t . id ) ; key value . add ( element . id ( ) ) ; } if ( include label ) { key value . add ( t . label ) ; key value . add ( element . label ( ) ) ; } element . key ( ) . for each ( key - > { if ( property to copy . be empty ( ) || property to copy . contains ( key ) ) { key value . add ( key ) ; key value . add ( element . value ( key ) ) ; } } ) ; return key value . to array ( new object [ key value . size ( ) ] ) ; }
public int size ( ) { return size ; }
public void set error listener ( error listener listener ) { error listener = listener ; }
public void write thin ( stream output out ) throw i o exception { super . write to ( out ) ; out . write v int ( byte . length ( ) ) ; }
public cluster state set and get observe state ( ) { if ( observe context . get ( ) ! = null ) { throw new elasticsearch exception ( `` can not set current cluster state while wait for a cluster state change `` ) ; } cluster state cluster state = cluster applier service . state ( ) ; last observed state . set ( new store state ( cluster state ) ) ; return cluster state ; }
public void set force ( boolean force ) { this . force = force ; }
public void set depend ( boolean depend ) { this . depend = depend ; }
public int get error ( ) { return error ; }
public void set d ( file d ) { this . d = d ; }
public boolean be depend ( ) { return depend ; }
static public void fail ( ) { fail ( null ) ; }
public final i scheduling rule get rule ( ) { return super . get rule ( ) ; }
public int size ( ) { return size ; }
public module container adaptor get adaptor ( ) { return adaptor ; }
public < t extend parse tree > t add any child ( t t ) { if ( children==null ) child = new array list < > ( ) ; child . add ( t ) ; return t ; }
public static i text file buffer manager get text file buffer manager ( ) { return file buffer plugin . get file buffer manager ( ) ; }
public boolean be valid ( ) { return valid ; }
public void set expiration date ( final date expiration date ) { this . expiration date = date . copy ( expiration date ) ; }
public synchronize state mark available ( ) { if ( map . be empty ( ) ) { state = state . idle ; } else { state = state . pending ; } return state ; }
public void output ( serialization context context ) throw exception { if ( text rep == null ) return ; boolean old pretty = context . get pretty ( ) ; context . set pretty ( false ) ; if ( text rep instanceof c d a t a section ) { context . write string ( `` < ! [ cdata [ `` ) ; context . write string ( ( ( org . w3c . dom . text ) text rep ) . get data ( ) ) ; context . write string ( `` ] ] > `` ) ; } else if ( text rep instanceof comment ) { context . write string ( `` < ! -- `` ) ; context . write string ( ( ( character data ) text rep ) . get data ( ) ) ; context . write string ( `` -- > `` ) ; } else if ( text rep instanceof text ) { context . write safe string ( ( ( text ) text rep ) . get data ( ) ) ; } context . set pretty ( old pretty ) ; }
public static string privilege access method for field set ( string name , unresolved type object type , unresolved type aspect type ) { return make name ( `` priv field set `` , aspect type . get name a identifier ( ) , object type . get name a identifier ( ) , name ) ; }
public void set method ( int method ) { this . method = method ; }
public index [ ] index ( ) { return index ; }
public void set encoding ( string enc ) { check zip file set attribute allow ( ) ; this . encode = enc ; }
public p d encryption get encryption ( ) throw i o exception { if ( document == null ) { throw new i o exception ( `` you must parse the document first before call get encryption ( ) `` ) ; } return encryption ; }
public type get type ( ) { return type ; }
public object get data ( ) { return data ; }
public string get local addr ( ) { return this . request . get local addr ( ) ; }
public synchronize error code get error code ( ) { return error code ; }
public int get flag ( ) { return flag ; }
public int get flag ( ) { return flag ; }
public void set ticket key ( open ssl session ticket key . . . key ) { object util . check not null ( key , `` key `` ) ; session ticket key [ ] ticket key = new session ticket key [ key . length ] ; for ( int i = 0 ; i < ticket key . length ; i++ ) { ticket key [ i ] = key [ i ] . key ; } lock writer lock = context . ctx lock . write lock ( ) ; writer lock . lock ( ) ; try { s s l context . clear option ( context . ctx , ssl . ssl_op_no_ticket ) ; if ( ticket key . length > 0 ) { s s l context . set session ticket key ( context . ctx , ticket key ) ; } } finally { writer lock . unlock ( ) ; } }
public void set length ( int length ) { assert . be true ( length > = 0 ) ; this . length= length ; }
public void append byte ( int val ) { buf [ pos++ ] = ( byte ) val ; }
public str builder insert ( int index , char char [ ] , int offset , int length ) { validate index ( index ) ; if ( char == null ) { return insert ( index , null text ) ; } if ( offset < 0 || offset > char . length ) { throw new string index out of bound exception ( `` invalid offset : `` + offset ) ; } if ( length < 0 || offset + length > char . length ) { throw new string index out of bound exception ( `` invalid length : `` + length ) ; } if ( length > 0 ) { ensure capacity ( size + length ) ; system . arraycopy ( buffer , index , buffer , index + length , size - index ) ; system . arraycopy ( char , offset , buffer , index , length ) ; size += length ; } return this ; }
public int size ( ) { return size ; }
public object add ( object value ) { object key = new i d key ( value ) ; if ( ! super . contains key ( key ) ) { return super . put ( key , value ) ; } else return null ; }
public void set result ( result result ) { if ( result==null ) { throw new illegal argument exception ( `` result must not be null `` ) ; } this . result = result ; }
public string deployment i d ( ) { return context . deployment i d ( ) ; }
public static property load all property ( string resource name , class loader class loader ) throw i o exception { assert . not null ( resource name , `` resource name must not be null `` ) ; class loader class loader to use = class loader ; if ( class loader to use == null ) { class loader to use = class utils . get default class loader ( ) ; } enumeration < url > url = ( class loader to use ! = null ? class loader to use . get resource ( resource name ) : class loader . get system resource ( resource name ) ) ; property prop = new property ( ) ; while ( urls . have more element ( ) ) { url url = url . next element ( ) ; u r l connection con = url . open connection ( ) ; resource utils . use cache if necessary ( con ) ; input stream be = con . get input stream ( ) ; try { if ( resource name . end with ( xml_file_extension ) ) { prop . load from x m l ( be ) ; } else { prop . load ( be ) ; } } finally { be . close ( ) ; } } return prop ; }
public submodule update command set callback ( clone command . callback callback ) { this . callback = callback ; return this ; }
public void set property ( final string property ) { this . property name = property ; }
public dynamic boolean property get boolean property ( string prop name , boolean default value , final runnable property change callback ) { check and warn ( prop name ) ; dynamic boolean property property = new dynamic boolean property ( prop name , default value ) ; add callback ( property change callback , property ) ; return property ; }
public object get ( object key ) { return configuration . get property ( string . value of ( key ) ) ; }
public void add ( change change ) { if ( change ! = null ) { assert . be true ( change . get parent ( ) == null ) ; f change . add ( change ) ; change . set parent ( this ) ; } }
public rest assure config log config ( log config log config ) { not null ( log config , `` log config `` ) ; return new rest assure config ( conf ( redirect config . class ) , conf ( http client config . class ) , log config , conf ( encoder config . class ) , conf ( decoder config . class ) , conf ( session config . class ) , conf ( object mapper config . class ) , conf ( connection config . class ) , conf ( json config . class ) , conf ( xml config . class ) , conf ( s s l config . class ) , conf ( matcher config . class ) , conf ( header config . class ) , conf ( multi part config . class ) , conf ( param config . class ) , conf ( o auth config . class ) , conf ( failure config . class ) ) ; }
public string get description ( ) { return this . description ; }
public string get version ( ) { return this . version ; } // -- string get version ( )
protect void handle invalid excludes ( list < string > invalid excludes ) { string builder message = new string builder ( ) ; for ( string exclude : invalid excludes ) { message . append ( `` \t- `` ) . append ( exclude ) . append ( string . format ( `` % n `` ) ) ; } throw new illegal state exception ( string . format ( `` the following class could not be exclude because they be not auto-configuration class : % n % s `` , message ) ) ; }
public void set source ( file source ) { this . source = source ; }
public void set encoding ( string encode ) { this . encode = encoding ; }
public string get file ( ) { return file ; }
public boolean partial ( ) { return partial ; }
public string get package ( ) { return package ; }
public string get id ( ) { return this . id ; } // -- string get id ( )
public void set value default ( string value default ) { this . value default = value default ; }
public result run ( junit . framework . test test ) { return run ( new old test class runner ( test ) ) ; }
public container get container ( ) { return container ; }
public static void clear image ( buffer image image ) { clear image ( image , color . white ) ; }
public list < diff row > generate diff row ( list < string > original , list < string > revise ) { return generate diff row ( original , diff utils . diff ( original , revise , equalizer ) ) ; }
public string get name ( ) { return name ; }
protect void set alias ( string alias ) { this . alias = alias ; }
public string get file ( ) { return file ; }
public string get classpath ( ) { return classpath ; }
protected boolean should cache ( ) { return should cache ; }
public change collection < t change > get change ( ) { return this . change ; }
public static boolean be g a t e new enough ( string version ) { if ( version == null ) return true ; version = version . trim ( ) ; if ( version . equal ( `` `` ) || version . equal ( `` * `` ) ) return true ; return ( compare version ( main . version , version ) > = 0 ) ; }
public string get aspect name ( ) { return this . advice . get aspect name ( ) ; }
public static annotation [ ] get resource annotation ( method method ) { map < class < ? > , annotation > annotation = new hash map < class < ? > , annotation > ( ) ; for ( annotation annotation : method . get declare class ( ) . get annotation ( ) ) { annotation . put ( annotation . get class ( ) , annotation ) ; } for ( annotation annotation : method . get annotation ( ) ) { annotation . put ( annotation . get class ( ) , annotation ) ; } return annotation . value ( ) . to array ( new annotation [ annotation . size ( ) ] ) ; }
public type get type ( ) { return type ; }
public string dump all ( iterator < ? extend object > data ) { string writer buffer = new string writer ( ) ; dump all ( data , buffer , null ) ; return buffer . to string ( ) ; }
public int get return code ( ) { return return code ; }
public int get position ( ) { return this . position ; }
public void set be number instruction ( ) { be number instruction = true ; }
public void set max parallel ( int max ) { max parallel = max ; }
public static class get class ( string class name ) throw class not find exception { return get class ( class name , true ) ; }
public boolean be share cache ( ) { return be share cache ; }
public location get location ( ) { return location ; }
public static int bare main ( string [ ] args , boolean use system exit , list fails , list error , list warning , list info ) { main main = new main ( ) ; message handler holder = new message handler ( ) ; main . set holder ( holder ) ; try { main . run main ( args , use system exit ) ; } finally { read message ( holder , i message . fail , true , fails ) ; read message ( holder , i message . error , false , error ) ; read message ( holder , i message . warning , false , warning ) ; read message ( holder , i message . info , false , infos ) ; } return holder . num message ( i message . error , true ) ; }
public string get message ( ) { return message ; }
public void show message ( kind kind , string message , i source location loc1 , i source location loc2 ) { if ( loc1 ! = null ) { message handler . handle message ( new message ( message , kind , null , loc1 ) ) ; if ( loc2 ! = null ) { message handler . handle message ( new message ( message , kind , null , loc2 ) ) ; } } else { message handler . handle message ( new message ( message , kind , null , loc2 ) ) ; } }
public int get level ( ) { return level ; }
public symbol reference < ? extend resolve value declaration > solve symbol in type ( resolve type declaration type declaration , string name ) { if ( type declaration instanceof java parser class declaration ) { context ctx = ( ( java parser class declaration ) type declaration ) . get context ( ) ; return ctx . solve symbol ( name ) ; } if ( type declaration instanceof java parser interface declaration ) { context ctx = ( ( java parser interface declaration ) type declaration ) . get context ( ) ; return ctx . solve symbol ( name ) ; } if ( type declaration instanceof java parser enum declaration ) { context ctx = ( ( java parser enum declaration ) type declaration ) . get context ( ) ; return ctx . solve symbol ( name ) ; } if ( type declaration instanceof reflection class declaration ) { return ( ( reflection class declaration ) type declaration ) . solve symbol ( name , type solver ) ; } if ( type declaration instanceof reflection interface declaration ) { return ( ( reflection interface declaration ) type declaration ) . solve symbol ( name , type solver ) ; } if ( type declaration instanceof reflection enum declaration ) { resolve enum constant declaration red = ( ( reflection enum declaration ) type declaration ) . get enum constant ( name ) ; return symbol reference . solve ( red ) ; } if ( type declaration instanceof javassist class declaration ) { return ( ( javassist class declaration ) type declaration ) . solve symbol ( name , type solver ) ; } if ( type declaration instanceof javassist enum declaration ) { return ( ( javassist enum declaration ) type declaration ) . solve symbol ( name , type solver ) ; } if ( type declaration instanceof javassist interface declaration ) { return ( ( javassist interface declaration ) type declaration ) . solve symbol ( name , type solver ) ; } return symbol reference . unsolved ( resolve value declaration . class ) ; }
public pointcut get pointcut ( ) { return this . pointcut ; }
public void add pattern ( mime type type , string pattern ) throw mime type exception { this . add pattern ( type , pattern , false ) ; }
public set < string > get privilege ( ) { return this . privilege ; }
public final type get element type ( ) { return element type ; }
public synchronize boolean be dirty ( ) { return _dirty ; }
public synchronize void clear dirty bit ( ) { _dirty = false ; }
public embed database build ( ) { return this . database factory . get database ( ) ; }
public int size ( ) { return size ; }
public boolean count down ( ) { assert original count > 0 ; for ( ; ; ) { final int current = count down . get ( ) ; assert current > = 0 ; if ( current == 0 ) { return false ; } if ( count down . compare and set ( current , current - 1 ) ) { return current == 1 ; } } }
public boolean region match ( boolean ignore case , int this start , char sequence string , int start , int length ) { if ( ! ignore case ) { return region match ( this start , string , start , length ) ; } object util . check not null ( string , `` string `` ) ; final int this len = length ( ) ; if ( this start < 0 || length > this len - this start ) { return false ; } if ( start < 0 || length > string . length ( ) - start ) { return false ; } this start += array offset ( ) ; final int this end = this start + length ; while ( this start < this end ) { if ( ! equal ignore case ( b2c ( value [ this start++ ] ) , string . char at ( start++ ) ) ) { return false ; } } return true ; }
public t get node ( ) { return node ; }
public static i message [ ] visit message ( i message holder holder , i message handler visitor , boolean accumulate , boolean abort on fail ) { if ( null == holder ) { return i message . r a_ i message ; } else { return visit message ( holder . get unmodifiable list view ( ) , visitor , accumulate , abort on fail ) ; } }
public static int bare main ( string [ ] args , boolean use system exit , list fails , list error , list warning , list info ) { main main = new main ( ) ; message handler holder = new message handler ( ) ; main . set holder ( holder ) ; try { main . run main ( args , use system exit ) ; } finally { read message ( holder , i message . fail , true , fails ) ; read message ( holder , i message . error , false , error ) ; read message ( holder , i message . warning , false , warning ) ; read message ( holder , i message . info , false , infos ) ; } return holder . num message ( i message . error , true ) ; }
public void set message ( string message ) { this . message = message ; }
public boolean be boolean ( ) { return false ; }
public void set file ( file file ) { this . file = file ; }
public void set key ( string key ) { if ( key ! = null & & key . length ( ) > 0 ) { string tokenizer tok = new string tokenizer ( key , this . sep , false ) ; while ( tok . have more token ( ) ) { string token = tok . next token ( ) . trim ( ) ; string tokenizer itok = new string tokenizer ( token , `` = `` , false ) ; string name = itok . next token ( ) ; string value = itok . next token ( ) ; replacement . put ( name , value ) ; } } }
public void set exclude pattern ( string . . . exclude pattern ) { assert . not empty ( excluded pattern , `` 'excluded pattern ' must not be empty `` ) ; this . exclude pattern = new string [ exclude pattern . length ] ; for ( int i = 0 ; i < exclude pattern . length ; i++ ) { this . exclude pattern [ i ] = string utils . trim whitespace ( exclude pattern [ i ] ) ; } init exclude pattern representation ( this . exclude pattern ) ; }
public void set file ( file file ) { this . file = file ; }
public void set ignore ( boolean ignore ) { this . ignore = ignore ; }
public boolean remove qualifier annotation ( annotation remove me ) { try { w lock . lock ( ) ; if ( remove me == null ) return false ; if ( qualifier == null ) return false ; boolean ret val = qualifier . remove ( remove me ) ; remove qualifier ( remove me . annotation type ( ) . get name ( ) ) ; return ret val ; } finally { w lock . unlock ( ) ; } }
protect final void complete ( ) { actual . on complete ( ) ; }
public static boolean force delete ( file file ) { if ( ! file . exists ( ) ) { return true ; } if ( file . be directory ( ) ) { file [ ] file = file . list file ( ) ; if ( file ! = null ) { for ( int i = 0 ; i < file . length ; i++ ) { if ( ! force delete ( file [ i ] ) ) { return false ; } } } } return file . delete ( ) ; }
public file get dir ( ) { return dir ; }
public void set read buffer size ( int size ) { this . read buffer size = size ; }
public void add ( input split s ) throw i o exception { if ( null == split ) { throw new i o exception ( `` uninitialized input split `` ) ; } if ( fill == split . length ) { throw new i o exception ( `` too many split `` ) ; } split [ fill++ ] = s ; totsize += s . get length ( ) ; }
public static void pad pr ( string s , int padding ) { for ( int i=0 ; i < pad ; i++ ) err . print ( pad char ) ; err . print ( s ) ; err . flush ( ) ; } // pad pr ( string , int )
public static resolve member inter field set dispatcher ( resolved member field , unresolved type aspect type ) { resolved member rm = new resolve member impl ( member . method , aspect type , public_static , unresolved type . void , name mangler . inter field set dispatcher ( aspect type , field . get declare type ( ) , field . get name ( ) ) , modifier . be static ( field . get modifier ( ) ) ? new unresolved type [ ] { field . get return type ( ) } : new unresolved type [ ] { field . get declare type ( ) , field . get return type ( ) } ) ; rm . set type variable ( field . get type variable ( ) ) ; return rm ; }
public static resolve member privileged access method for field set ( unresolved type aspect type , member field , boolean short syntax ) { unresolved type field declare type = field . get declare type ( ) ; if ( short syntax ) { unresolved type [ ] args = null ; if ( modifier . be static ( field . get modifier ( ) ) ) { args = new unresolved type [ ] { field . get type ( ) } ; } else { args = new unresolved type [ ] { field declare type , field . get type ( ) } ; } string buffer name = new string buffer ( `` ajc $ set $ `` ) ; name . append ( field . get name ( ) ) ; return new resolve member impl ( member . method , field declare type , public_static , unresolved type . void , name . to string ( ) , args ) ; } else { string setter name = name mangler . privileged access method for field set ( field . get name ( ) , field declare type , aspect type ) ; string sig ; if ( modifier . be static ( field . get modifier ( ) ) ) { sig = `` ( `` + field . get return type ( ) . get signature ( ) + `` ) v `` ; } else { sig = `` ( `` + field declare type . get signature ( ) + field . get return type ( ) . get signature ( ) + `` ) v `` ; } return new resolve member impl ( member . method , field declare type , public_static , setter name , sig ) ; } }
public class < ? > type for ( string type name ) { return type by name . get ( type name ) ; }
public change method signature argument get argument ( ) { return f argument ; }
protect final int read back reference ( final byte [ ] b , final int off , final int len ) { final int avail = available ( ) ; if ( len > avail ) { try to copy ( len - avail ) ; } return read from buffer ( b , off , len ) ; }
public static string privilege access method for field set ( string name , unresolved type object type , unresolved type aspect type ) { return make name ( `` priv field set `` , aspect type . get name a identifier ( ) , object type . get name a identifier ( ) , name ) ; }
public byte [ ] get local file data extra ( ) { byte [ ] extra = get extra ( ) ; return extra ! = null ? extra : new byte [ 0 ] ; }
public pointcut get pointcut ( ) { return this . pointcut ; }
public boolean be shadow ( ) { return _f shadow . get value ( _info2 ) ! = 0 ; }
public float max ( int dim ) { return min max [ dim + dim + 1 ] ; }
public void set member ( final i member [ ] member ) { assert . be not null ( member ) ; f members= member ; }
public list type ( ) { return this . type ; }
public string get type kind ( ) { return m type kind ; }
public boolean be remove delete ref ( ) { return remove deleted ref ; }
public static property load all property ( string resource name , class loader class loader ) throw i o exception { assert . not null ( resource name , `` resource name must not be null `` ) ; class loader class loader to use = class loader ; if ( class loader to use == null ) { class loader to use = class utils . get default class loader ( ) ; } enumeration < url > url = ( class loader to use ! = null ? class loader to use . get resource ( resource name ) : class loader . get system resource ( resource name ) ) ; property prop = new property ( ) ; while ( urls . have more element ( ) ) { url url = url . next element ( ) ; u r l connection con = url . open connection ( ) ; resource utils . use cache if necessary ( con ) ; input stream be = con . get input stream ( ) ; try { if ( resource name . end with ( xml_file_extension ) ) { prop . load from x m l ( be ) ; } else { prop . load ( be ) ; } } finally { be . close ( ) ; } } return prop ; }
public void add pattern ( mime type type , string pattern ) throw mime type exception { this . add pattern ( type , pattern , false ) ; }
public int get precedence ( ) { if ( be include ) return importer . get precedence ( ) ; return precedence ; }
public void set message ( string message ) { this . message = message ; }
public static string inter field initializer ( unresolved type aspect type , unresolved type class type , string name ) { return make name ( `` inter field init `` , aspect type . get name a identifier ( ) , class type . get name a identifier ( ) , name ) ; }
public list < module capability > get module capability ( string namespace ) { return capability . get list ( namespace ) ; }
protect request map handler mapping create request map handler mapping ( ) { return new request mapping handler mapping ( ) ; }
public void write ( byte [ ] buffer ) { output buffer . write ( buffer , 0 , buffer . length ) ; }
public list < entry > get entry ( ) { return entry ; }
public final single < t > timeout ( long timeout , time unit time unit ) { return timeout ( timeout , time unit , null , scheduler . computation ( ) ) ; }
public collection < mutation > execute ( collection < ? extend i mutation > mutation ) throw invalid request exception { boolean have counter = false ; list < mutation > augment mutation = null ; for ( i mutation mutation : mutation ) { if ( mutation instanceof counter mutation ) have counter = true ; for ( partition update upd : mutation . get partition update ( ) ) { list < mutation > augmentation = execute internal ( upd ) ; if ( augmentation == null || augmentation . be empty ( ) ) continue ; validate ( augmentation ) ; if ( augmented mutation == null ) augment mutation = new link list < > ( ) ; augment mutation . add all ( augmentation ) ; } } if ( augmented mutation == null ) return null ; if ( have counter ) throw new invalid request exception ( `` counter mutation and trigger mutation can not be apply together atomically . `` ) ; @ suppress warning ( `` unchecked `` ) collection < mutation > original mutation = ( collection < mutation > ) mutation ; return merge mutation ( iterables . concat ( original mutation , augment mutation ) ) ; }
public field get field ( ) { return field ; }
protect < t > void add codec ( list < t > codecs , t codec ) { init codec ( codec ) ; codecs . add ( codec ) ; }
public static void set meta class ( object self , meta class meta class ) { if ( meta class instanceof handle meta class ) meta class = ( ( handle meta class ) meta class ) . get adaptee ( ) ; if ( self instanceof class ) { groovy system . get meta class registry ( ) . set meta class ( ( class ) self , meta class ) ; } else { ( ( meta class registry impl ) groovy system . get meta class registry ( ) ) . set meta class ( self , meta class ) ; } }
public string get schema ( ) { return schema ; }
public boolean get finish block on flush ( ) { return _cfg finish block on flush ; }
public string get field name ( ) { return field name ; }
public int size ( ) { return size ; }
public final expect builder with buffer size ( int buffer size ) { if ( buffer size < = 0 ) { throw new illegal argument exception ( `` buffer size must be > 0 `` ) ; } this . buffer size = buffer size ; return this ; }
public string get in ( ) { return in ; }
public void push symbol ( symbol sym ) { if ( pos == stack . length ) { expand stack ( ) ; } stack [ pos++ ] = sym ; }
public final void push production ( symbol sym ) { symbol [ ] p = sym . production ; while ( pos + p . length > stack . length ) { expand stack ( ) ; } system . arraycopy ( p , 0 , stack , po , p . length ) ; po += p . length ; }
public int get skip count ( ) { return skip count ; }
public boolean execute ( ) throw i o exception { if ( stop on error ) { for ( final action action : action ) { if ( ! action . execute ( ) ) { return false ; } } return true ; } boolean status = true ; i o exception exception = null ; for ( final action action : action ) { try { status & = action . execute ( ) ; } catch ( final i o exception ex ) { status = false ; if ( exception == null ) { exception = ex ; } } } if ( exception ! = null ) { throw exception ; } return status ; }
public static < b extend builder < b > > b new builder ( ) { return new builder < b > ( ) . a builder ( ) ; }
protect < t > t get default strategy ( application context context , class < t > strategy interface ) { list < t > strategy = get default strategy ( context , strategy interface ) ; if ( strategy . size ( ) ! = 1 ) { throw new bean initialization exception ( `` dispatcher servlet need exactly 1 strategy for interface [ `` + strategy interface . get name ( ) + `` ] `` ) ; } return strategy . get ( 0 ) ; }
public error get error ( ) { return this . error ; }
public static void add know plugin ( plugin plugin ) { if ( know plugins . contains ( plugin ) ) return ; if ( plugin update manager . get default plugins ( ) . contains ( plugin ) ) return ; know plugins . add ( plugin ) ; }
public static transport request unwrap request ( transport request request ) { if ( request instanceof proxy request ) { return ( ( proxy request ) request ) . wrap ; } return request ; }
public service response get response ( ) { return response ; }
public string get event ( ) { return event ; }
public boolean be boolean ( ) { return false ; }
public duration to duration ( ) { return this ; }
public string raw string ( ) { return raw string ; }
public string get provider ( ) { return provider ; }
public void set timeout ( int timeout ) { this . timeout = timeout ; }
public date get date time ( ) { return date time ; }
public statement set retry policy ( retry policy policy ) { this . retry policy = policy ; return this ; }
public void set statement ( ast node statement ) { assert not null ( statement ) ; this . statement = statement ; statement . set parent ( this ) ; }
public string write policy to string ( policy policy ) { if ( ! be not null ( policy ) ) throw new illegal argument exception ( `` policy can not be null `` ) ; try { return json string of ( policy ) ; } catch ( exception e ) { string message = `` unable to serialize policy to json string : `` + e . get message ( ) ; throw new illegal argument exception ( message , e ) ; } finally { try { writer . close ( ) ; } catch ( exception e ) { } } }
public void set provider ( string provider ) { this . provider = provider ; }
public static string raw id token ( json object principal ) { string ret = io . vertx . ext . auth . oauth2 . keycloak helper . raw id token ( principal ) ; return ret ; }
public void set expiration ( kerberos time expiration ) { this . expiration = expiration ; }
public string get property name ( ) { return property name ; }
public void add role ( string user , string role ) { list < string > role = user role . get ( user ) ; if ( role == null ) { role = new array list < > ( ) ; user role . put ( user , role ) ; } role . add ( role ) ; }
public query option set refresh node interval millis ( int refresh node interval millis ) { this . refresh node interval millis = refresh node interval millis ; return this ; }
public void set profile ( java . util . list < profile > profile ) { this . profile = profile ; } // -- void set profile ( java . util . list )
public async task executor get executor ( ) { if ( this . executor ! = null ) { return this . executor ; } else if ( this . executor name ! = null ) { assert . state ( this . bean factory ! = null , `` bean factory be require to look up an executor bean by name `` ) ; return this . bean factory . get bean ( this . executor name , async task executor . class ) ; } else { return null ; } }
public void add metric ( metric metric ) { metric . add ( metric ) ; for ( thread safe report listener listener : listener ) { listener . metric add ( metric ) ; } }
public void destroy ( ) { for ( endpoint endpoint : this . publish endpoint ) { endpoint . stop ( ) ; } }
public protocol get protocol ( ) { return protocol ; }
protect string [ ] get property method suffix ( string property name ) { string suffix = get property method suffix ( property name ) ; if ( suffix . length ( ) > 0 & & character . be upper case ( suffix . char at ( 0 ) ) ) { return new string [ ] { suffix } ; } return new string [ ] { suffix , string utils . capitalize ( suffix ) } ; }
public synchronize inet address get local address ( ) { return this . local address ; }
public proxy option set password ( string password ) { this . password = password ; return this ; }
public string get domain ( ) { return domain ; }
public int get connection request timeout ( ) { return connection request timeout ; }
public void set signer ( signer signer ) { }
public string get proxy auth user ( ) { return proxy auth user ; }
public static < t > list < t > a list ( list < ? extend t > l ) { return ( list < t > ) l ; }
public void set max idle ( int max idle ) { this . max idle = max idle ; }
public zone date time next time after ( zoned date time after time , long duration in millis ) { return next time after ( after time , after time . plus ( duration . of millis ( duration in millis ) ) ) ; }
protect void on close ( ) { }
public transfer resource set content length ( long content length ) { this . content length = content length ; return this ; }
public executor service get executor service ( ) { return executor service ; }
public http response status get netty http status ( ) { return http response status ; }
public void set signer override ( final string value ) { signer override = value ; }
public static http override forward request forward overridden request ( http request http request ) { return new http override forward request ( ) . with http request ( http request ) ; }
public void set header ( string name , list < string > value ) { header . put ( name , value ) ; }
protect metadata build context get context ( ) { return context ; }
public void set signer ( signer signer ) { }
public credential scope get credential scope ( ) { return credential scope ; }
public string get key ( ) { return key ; }
public int get default max connection per host ( ) { return get max connection per host ( host configuration . any_host_configuration ) ; }
public object get metric registry ( ) { return metric registry ; }
public string get provider ( ) { return provider ; }
public boolean be enable ( ) { return this . enable ; } // -- boolean be enable ( )
public boolean be credential allow ( ) { return allow credential ; }
public s s l configuration get ssl ( ) { if ( ssl == null ) { ssl = new s s l configuration ( ) ; } return ssl ; }
protect static string extract hostname from dns srv ( string dns name target ) { if ( dns name target == null || dns name target . be empty ( ) ) { return null ; } else { if ( dns name target . end with ( `` . `` ) ) { dns name target = dns name target . substring ( 0 , dns name target . length ( ) -1 ) ; } return dns name target ; } }
public boolean have region ( string region ) { return region . contains key ( region ) || match region regex ( region ) || have service endpoint ( region ) ; }
public void set region regex ( string region regex ) { this . region regex = region regex ; }
protect string get service class name ( handler service ) { return ( string ) service . get option ( get service class name option name ( ) ) ; }
public string get registry ( ) { return registry ; }
public string get name ( ) { return name ; }
public boolean have region ( string region ) { return region . contains key ( region ) || match region regex ( region ) || have service endpoint ( region ) ; }
public exception get exception ( ) { return this . exception ; }
public int get offset ( ) { return offset ; }
@ override public json token a token ( ) { return json token . start_array ; }
public counter get task counter ( ) { return counter ; }
public property get property ( ) { return property ; }
public static string encode a string ( byte . . . byte ) { if ( bytes == null ) return null ; return byte . length == 0 ? `` `` : codec utils . to string direct ( codec . encode ( byte ) ) ; }
public static byte [ ] encode ( byte [ ] bytes ) { return bytes == null || byte . length == 0 ? byte : codec . encode ( byte ) ; }
public static string encode a string ( byte . . . byte ) { if ( bytes == null ) return null ; return byte . length == 0 ? `` `` : codec utils . to string direct ( codec . encode ( byte ) ) ; }
public byte buf get byte buf ( ) { byte buf ret = delegate . get byte buf ( ) ; return ret ; }
public string get name string ( ) { final byte buffer bb = byte buffer . wrap ( encode name ) ; return utf_8 . decode ( bb ) . to string ( ) ; }
public input stream get resource a stream ( string resource ) { return get resource a stream ( resource , get class loader ( null ) ) ; }
public date to date ( ) { return new date ( get millis ( ) ) ; }
public static final long from julian day ( double julian day ) { double epoch day = julian day - 2440587 . 5d ; return ( long ) ( epoch day * 86400000d ) ; }
public static string get public key ( ) { return fetch data ( ec2_metadata_root + `` /public-keys/0/openssh-key `` ) ; }
public string get key ( ) { return key ; }
public static < k , v > java . util . map < k , v > of ( k k1 , v v1 , k k2 , v v2 , k k3 , v v3 ) { return map n ( k1 , v1 , k2 , v2 , k3 , v3 ) ; }
public string get a string ( ) { return integer . to string ( get ( ) ) ; }
public string get trim ( string name ) { string value = get ( name ) ; if ( null == value ) { return null ; } else { return value . trim ( ) ; } }
public long get start time ( ) { return start time ; }
public byte [ ] element ( ) { return element ; }
public void set date ( string date ) { super . set internal date ( date ) ; }
public void set expression ( ast node expression ) { assert not null ( expression ) ; this . expression = expression ; expression . set parent ( this ) ; }
public static int size ( object list ) { if ( list == null ) return 0 ; if ( list instanceof list ) return ( ( list < ? > ) list ) . size ( ) ; return 1 ; }
public void set result ( result result ) { if ( result==null ) { throw new illegal argument exception ( `` result must not be null `` ) ; } this . result = result ; }
protect scheduled executor service get executor service ( ) { return executor service ; }
public delete message batch result delete message batch ( delete message batch request request ) { request = before client execution ( request ) ; return execute delete message batch ( request ) ; }
public delete message result delete message ( delete message request request ) { request = before client execution ( request ) ; return execute delete message ( request ) ; }
public static < e > queue < e > synchronize queue ( queue < e > queue ) { return synchronize . queue ( queue , null ) ; }
public delete message batch result delete message batch ( delete message batch request request ) { request = before client execution ( request ) ; return execute delete message batch ( request ) ; }
public void send ( byte [ ] message ) throw exception { m_connector . get send connection ( ) . send ( this , message , null ) ; }
public send message result send message sync ( send message request request ) { future < send message result > future = send message ( request , null ) ; return wait for future ( future ) ; }
public string get label ( ) { return label ; }
public string get message ( ) { return message ; }
public void set id ( string id ) { this . id = id ; }
public void set timeout ( int timeout ) { this . timeout = timeout ; }
public static < e > queue < e > synchronize queue ( queue < e > queue ) { return synchronize . queue ( queue , null ) ; }
public int get successful execution index ( ) { return successful execution index ; }
public void set id ( string id ) { this . id = id ; }
public static string get string from unique body ( unique body message body ) throw exception { ews utility . validate param ( message body , `` message body `` ) ; return message body . text ; }
public header get first header ( string name ) { for ( iterator header iter = header . iterator ( ) ; header iter . have next ( ) ; ) { header header = ( header ) header iter . next ( ) ; if ( header . get name ( ) . equal ignore case ( name ) ) { return header ; } } return null ; }
public void remove all attachment ( ) { if ( _asked for stream ) { throw new illegal state exception ( message . get message ( `` concurrent modification of stream `` ) ) ; } try { multipart = null ; dimemultipart = null ; mergein attachment ( ) ; attachment . clear ( ) ; order attachment . clear ( ) ; stack data handler . clear ( ) ; } catch ( axis fault af ) { log . warn ( message . get message ( `` exception00 `` ) , af ) ; } }
public stream file attach ( string attachment name ) { this . attachment name = attachment name ; return this ; }
public string get value ( ) { return value ; }
public @ not null i envelope cache get envelope disk cache ( ) { return envelope disk cache ; }
public void set message ( string message ) { this . message = message ; }
public standard function . entry get detail ( ) { return detail ; }
public http header get header ( ) { return this . header ; }
public property get property ( ) { return property ; }
public void set method ( int method ) { this . method = method ; }
public configuration get configuration ( ) { return config ; }
protect byte from string ( string input ) { return byte . value of ( input ) ; }
public void _set property ( string name , object value ) { if ( name == null || value == null ) { throw new j a x r p c exception ( message . get message ( name == null ? `` bad prop03 `` : `` bad prop04 `` ) ) ; } else if ( name . equal ( call . username_property ) ) { if ( ! ( value instanceof string ) ) { throw new j a x r p c exception ( message . get message ( `` bad prop00 `` , new string [ ] { name , `` java . lang . string `` , value . get class ( ) . get name ( ) } ) ) ; } cache username = ( string ) value ; } else if ( name . equal ( call . password_property ) ) { if ( ! ( value instanceof string ) ) { throw new j a x r p c exception ( message . get message ( `` bad prop00 `` , new string [ ] { name , `` java . lang . string `` , value . get class ( ) . get name ( ) } ) ) ; } cache password = ( string ) value ; } else if ( name . equal ( stub . endpoint_address_property ) ) { if ( ! ( value instanceof string ) ) { throw new j a x r p c exception ( message . get message ( `` bad prop00 `` , new string [ ] { name , `` java . lang . string `` , value . get class ( ) . get name ( ) } ) ) ; } try { cached endpoint = new url ( ( string ) value ) ; } catch ( malformed u r l exception mue ) { throw new j a x r p c exception ( mue . get message ( ) ) ; } } else if ( name . equal ( call . session_maintain_property ) ) { if ( ! ( value instanceof boolean ) ) { throw new j a x r p c exception ( message . get message ( `` bad prop00 `` , new string [ ] { name , `` java . lang . boolean `` , value . get class ( ) . get name ( ) } ) ) ; } maintain session set = true ; maintain session = ( ( boolean ) value ) . boolean value ( ) ; } else if ( name . start with ( `` java . `` ) || name . start with ( `` javax . `` ) ) { throw new j a x r p c exception ( message . get message ( `` bad prop05 `` , name ) ) ; } else { cached property . put ( name , value ) ; } } // _set property
protect void set fault string ( string fault string ) { this . fault string = fault string ; }
public int get port ( ) { return port ; }
public void set type mapping registry ( type mapping registry reg ) { map registry = reg ; }
public void set expression engine ( default expression engine expression engine ) { if ( expression engine == null ) { throw new illegal argument exception ( `` expression engine must not be null ! `` ) ; } this . expression engine = expression engine ; }
public static user group information get remote user ( ) { call call = cur call . get ( ) ; return ( call ! = null & & call . connection ! = null ) ? call . connection . user : null ; }
public void remove property ( string name ) { if ( name == null || ! be property support ( name ) ) { throw new j a x r p c exception ( name == null ? message . get message ( `` bad prop03 `` ) : message . get message ( `` bad prop05 `` , name ) ) ; } my property . remove ( name ) ; } // remove property
public s o a p header element get header ( string namespace , string part name ) { for ( int i=0 ; i < header . size ( ) ; i++ ) { s o a p header element header = ( s o a p header element ) header . get ( i ) ; if ( header . get namespace u r i ( ) . equal ( namespace ) & & header . get name ( ) . equal ( part name ) ) return header ; } return null ; }
public void set header ( string namespace , string part name , object header value ) { header . add ( new s o a p header element ( namespace , part name , header value ) ) ; }
public string get classpath ( ) { return classpath ; }
public void set encoding ( string encode ) { this . encode = encoding ; }
public int get end line ( ) { return impl . get end line ( impl ) ; }
public string get message ( ) { return message ; }
public void set factory ( j d o m factory factory ) { this . factory = factory ; }
public string get script ( ) { return script ; }
public web security debug ( boolean debug enable ) { this . debug enable = debug enable ; return this ; }
public boolean get global ( ) { return m global ; }
public transport client remove transport address ( transport address transport address ) { nodes service . remove transport address ( transport address ) ; return this ; }
public string get namespace ( ) { return namespace ; }
public string get value ( ) { return value ; }
public void mark close ( flow info flow info , flow context flow context ) { faked track variable current = this ; do { flow info . mark a definitely non null ( current . binding ) ; current . global closing state |= close_seen ; flow context . mark finally null status ( current . binding , flow info . non_null ) ; current = current . inner tracker ; } while ( current ! = null ) ; }
public boolean be nillable ( ) { return nillable ; }
public string get field name ( ) { return field name ; }
public string get name ( ) { return name ; }
public void set nillable ( boolean nillable ) { this . nillable = nillable ; }
public string get event ( ) { return event ; }
public constant get constant ( long value ) { return value to constant . get ( value ) ; }
public type target ( ) { return target ; }
public void debug ( object message ) { log ( debug , message , null ) ; }
public constructor < ? > get constructor ( ) { return this . constructor ; }
public context get context ( ) { return impl . get context ( ) ; }
public json path pretty peek ( ) { pretty print ( ) ; return this ; }
public final set < namespace > get namespaces ( ) { return namespaces ; }
public http header get header ( ) { return this . header ; }
public static session bind ( session session ) { return session map ( true ) . put ( session . get session factory ( ) , session ) ; }
public boolean be stop ( ) { return stop ; }
public ct query impl logging ( boolean logging ) { this . log = logging ; return this ; }
public context get context ( ) { return impl . get context ( ) ; }
public boolean be root ( ) { return root ; }
public void set name ( string name ) { this . name = name ; }
public string get attribute n s ( string namespace u r i , string local name ) { if ( namespace u r i == null ) { namespace u r i = `` `` ; } for ( int i = 0 ; i < attribute . get length ( ) ; i++ ) { if ( attribute . get u r i ( i ) . equal ( namespace u r i ) & & attribute . get local name ( i ) . equal ( local name ) ) { return attribute . get value ( i ) ; } } return null ; }
public string get prefix ( ) { return prefix ; }
public boolean equal ( object obj ) { if ( obj == null ) { return false ; } if ( this == obj ) { return true ; } if ( this . get class ( ) == obj . get class ( ) ) { mutable object < ? > that = ( mutable object < ? > ) obj ; return this . value . equal ( that . value ) ; } else { return false ; } }
public void set environment ( string [ ] env ) { this . env = env ; }
public void set namespace u r i ( string ns u r i ) { namespace u r i = ns u r i ; }
protect void index node ( node node ) { list < node > nod = node name to node . get ( node . get x path node name ( ) ) ; if ( node ! = null ) { node . add ( node ) ; } }
protect void process child ( query node query tree ) throw query node exception { list < query node > child = query tree . get child ( ) ; child list new child ; if ( child ! = null & & child . size ( ) > 0 ) { new child = allocate child list ( ) ; try { for ( query node child : child ) { child = process iteration ( child ) ; if ( child == null ) { throw new null pointer exception ( ) ; } new child . add ( child ) ; } list < query node > order child list = set child order ( new child ) ; query tree . set ( ordered child list ) ; } finally { new child . be use = false ; } } }
public string get text ( ) { return text ; }
public http header get header ( ) { return this . header ; }
public s o a p constant get s o a p constant ( ) { return soap constant ; }
protect void set fault string ( string fault string ) { this . fault string = fault string ; }
public s o a p constant get s o a p constant ( ) { return soap constant ; }
public stream file attach ( string attachment name ) { this . attachment name = attachment name ; return this ; }
public void set type mapping registry ( type mapping registry registry ) throw service exception { }
public void set soap constant ( s o a p constant soap constant ) { this . soap constant = soap constant ; }
public uuid get schema version ( ) { return schema version ; }
public string get message ( ) { return message ; }
public string get message ( ) { return message ; }
public synchronize void set parent ( hashtable parent ) { this . parent = parent ; }
public static service finder < ? > find ( final string service name ) throw service configuration error { return new service finder < object > ( object . class , service name , _get context class loader ( ) , false ) ; }
public int get timeout ( ) { return timeout ; }
public void invalidate ( ) { rep = null ; last touch = system . current time millis ( ) ; timeout = -1 ; }
public void touch ( ) { last touch = system . current time millis ( ) ; }
public void set object name ( structure q name q name ) { object name = q name ; }
public void add role ( string user , string role ) { list < string > role = user role . get ( user ) ; if ( role == null ) { role = new array list < > ( ) ; user role . put ( user , role ) ; } role . add ( role ) ; }
public constant get constant ( long value ) { return value to constant . get ( value ) ; }
public void set object name ( structure q name q name ) { object name = q name ; }
public void connect ( ) throw x a exception { if ( be connect ( ) ) { return ; } try { connection = create x a connection ( ) ; session = connection . create x a session ( ) ; } catch ( j m s exception e ) { if ( connection ! = null ) { try { connection . close ( ) ; } catch ( j m s exception ignore ) { } } jta logger . i18 n logger . warn_failed_to_create_jms_connection ( e ) ; throw new x a exception ( x a exception . xaer_rmfail ) ; } }
public void remove all attachment ( ) { if ( _asked for stream ) { throw new illegal state exception ( message . get message ( `` concurrent modification of stream `` ) ) ; } try { multipart = null ; dimemultipart = null ; mergein attachment ( ) ; attachment . clear ( ) ; order attachment . clear ( ) ; stack data handler . clear ( ) ; } catch ( axis fault af ) { log . warn ( message . get message ( `` exception00 `` ) , af ) ; } }
public gate . resource get resource ( ) { return resource ; }
public int get max session ( ) { return max session ; }
public void session destroy ( http session event event ) { http session session = event . get session ( ) ; destroy session ( session ) ; }
public void session create ( http session event event ) { }
public int get max session ( ) { return this . max session ; }
public synchronize void init ( ) { this . server= new axis server ( ) ; }
public send message result send message sync ( send message request request ) { future < send message result > future = send message ( request , null ) ; return wait for future ( future ) ; }
public object get property value ( ) { return property value ; }
public string get server ( ) { return server ; }
public final int hash code ( ) { return i hash code ; }
public string a text ( ) { return ( _value == null ) ? `` null `` : _value . to string ( ) ; }
public string get scheme ( ) { return scheme ; }
public string get fragment ( ) { return fragment ; }
public url to u r l ( ) throw malformed u r l exception { return base . to u r l ( ) ; }
public void get ( string from path , string to path ) { get ( from path , to path , null ) ; }
public boolean be array ( ) { return ( ( my p d . get property type ( ) ! = null ) & & my p d . get property type ( ) . be array ( ) ) ; }
public boolean be readable ( ) { return ( my p d . get read method ( ) ! = null ) ; }
public void set method ( int method ) { this . method = method ; }
public static class loader static class loader ( ) { return reflection . class . get class loader ( ) ; }
public synchronize object get ( object key ) { if ( ! contains key ( key ) ) { return null ; } object value = remove ( key ) ; super . put ( key , value ) ; return value ; }
public class get java class ( ) { return this . type ; }
public boolean be transitive ( ) { return this . modifier keyword == module modifier keyword . transitive_keyword ; }
public void set value ( boolean value ) { this . value = value ; }
public boolean be ignore case ( ) { return ignore case ; }
public void set property parent ( hashtable parent ) { bag . set parent ( parent ) ; }
public void generate ( ) throw i o exception { if ( emitter . be server side ( ) ) { super . generate ( ) ; } } // generate
public body type get body type ( ) { return this . body type ; }
public void set use static base uri ( boolean static base ) { resolve against static base = static base ; }
public list < entry > get entry ( ) { return entry ; }
public void set v vector ( float [ ] v vector value ) { v vector = v vector value ; }
public string get namespace ( ) { return namespace ; }
public void set nillable ( boolean nillable ) { this . nillable = nillable ; }
public list < entry > get entry ( ) { return entry ; }
public synchronize boolean be build ( ) { return this . build ; }
public cluster state request builder all ( ) { request . all ( ) ; return this ; }
public string uri ( ) { return uri ; }
public void generate ( ) throw i o exception { if ( emitter . be server side ( ) ) { super . generate ( ) ; } } // generate
public void set deploy x m l ( boolean deploy x m l ) { this . deploy x m l = deploy x m l ; }
public string to dir ( string pkg ) { string dir = null ; if ( pkg ! = null ) { pkg = normalize package name ( pkg , file . separator char ) ; } if ( root == null ) { dir = pkg ; } else { dir = root + file . separator char + pkg ; } return ( dir == null ) ? `` `` : dir + file . separator char ; } // to dir
public static class get class ( string class name ) throw class not find exception { return get class ( class name , true ) ; }
public void generate ( ) throw i o exception { } // generate
public string get text ( ) { return text ; }
public void set port ( int port ) { this . port = port ; }
public file get dir ( ) { return dir ; }
public x path variable declare variable ( q name value qname ) { return declare variable ( qname . get namespace u r i ( ) , qname . get local name ( ) ) ; }
public url to u r l ( ) throw malformed u r l exception { return base . to u r l ( ) ; }
public string get base u r i ( ) { return base u r i ; }
public void set read timeout ( long timeout ) { this . proxy factory . set read timeout ( timeout ) ; }
public void revoke token ( ) { url url = null ; try { url = new url ( this . revoke u r l ) ; } catch ( malformed u r l exception e ) { assert false : `` an invalid refresh url indicate a bug in the sdk . `` ; throw new runtime exception ( `` an invalid refresh url indicate a bug in the sdk . `` , e ) ; } string url parameter = string . format ( `` token= % s & client_id= % s & client_secret= % s `` , this . access token , this . client i d , this . client secret ) ; box a p i request request = new box a p i request ( this , url , `` post `` ) ; request . should authenticate ( false ) ; request . set body ( url parameter ) ; try { request . send ( ) ; } catch ( box a p i exception e ) { throw e ; } }
public void set error listener ( error listener listener ) { error listener = listener ; }
public void refresh ( ) { this . refresh lock . write lock ( ) . lock ( ) ; if ( ! this . can refresh ( ) ) { this . refresh lock . write lock ( ) . unlock ( ) ; throw new illegal state exception ( `` the box a p i connection can not be refresh because it do n't have a `` + `` refresh token . `` ) ; } url url = null ; try { url = new url ( this . token u r l ) ; } catch ( malformed u r l exception e ) { this . refresh lock . write lock ( ) . unlock ( ) ; assert false : `` an invalid refresh url indicate a bug in the sdk . `` ; throw new runtime exception ( `` an invalid refresh url indicate a bug in the sdk . `` , e ) ; } string url parameter = string . format ( `` grant_type=refresh_token & refresh_token= % s & client_id= % s & client_secret= % s `` , this . refresh token , this . client i d , this . client secret ) ; box a p i request request = new box a p i request ( this , url , `` post `` ) ; request . should authenticate ( false ) ; request . set body ( url parameter ) ; string json ; try { box j s o n response response = ( box j s o n response ) request . send ( ) ; json = response . get j s o n ( ) ; } catch ( box a p i exception e ) { this . notify error ( e ) ; this . refresh lock . write lock ( ) . unlock ( ) ; throw e ; } json object json object = json object . read from ( json ) ; this . access token = json object . get ( `` access_token `` ) . a string ( ) ; this . refresh token = json object . get ( `` refresh_token `` ) . a string ( ) ; this . last refresh = system . current time millis ( ) ; this . expire = json object . get ( `` expires_in `` ) . a long ( ) * 1000 ; this . notify refresh ( ) ; this . refresh lock . write lock ( ) . unlock ( ) ; }
public string get url ( ) { return url ; }
public static box user get current user ( box a p i connection api ) { url url = get_me_url . build ( api . get base u r l ( ) ) ; box a p i request request = new box a p i request ( api , url , `` get `` ) ; box j s o n response response = ( box j s o n response ) request . send ( ) ; json object json object = json object . read from ( response . get j s o n ( ) ) ; return new box user ( api , json object . get ( `` id `` ) . a string ( ) ) ; }
public void delete ( ) { url url = group_url_template . build ( this . get a p i ( ) . get base u r l ( ) , this . get i d ( ) ) ; box a p i request request = new box a p i request ( this . get a p i ( ) , url , `` delete `` ) ; box a p i response response = request . send ( ) ; response . disconnect ( ) ; }
public j s o n object get request j s o n object ( ) { return request j s o n object ; }
public void multipart abort upload ( multipart upload upload ) throw s3 service exception { multipart abort upload impl ( upload . get upload id ( ) , upload . get bucket name ( ) , upload . get object key ( ) ) ; }
public void delete ( ) { url url = group_url_template . build ( this . get a p i ( ) . get base u r l ( ) , this . get i d ( ) ) ; box a p i request request = new box a p i request ( this . get a p i ( ) , url , `` delete `` ) ; box a p i response response = request . send ( ) ; response . disconnect ( ) ; }
public box collaboration . info collaborate ( string email , box collaboration . role role , boolean notify , boolean can view path ) { json object accessible by field = new json object ( ) ; accessible by field . add ( `` login `` , email ) ; accessible by field . add ( `` type `` , `` user `` ) ; return this . collaborate ( accessible by field , role , notify , can view path ) ; }
public box collaboration . info collaborate ( box collaborator collaborator , box collaboration . role role , boolean notify , boolean can view path ) { json object accessible by field = new json object ( ) ; accessible by field . add ( `` id `` , collaborator . get i d ( ) ) ; if ( collaborator instanceof box user ) { accessible by field . add ( `` type `` , `` user `` ) ; } else if ( collaborator instanceof box group ) { accessible by field . add ( `` type `` , `` group `` ) ; } else { throw new illegal argument exception ( `` the give collaborator be of an unknown type . `` ) ; } return this . collaborate ( accessible by field , role , notify , can view path ) ; }
public void rename ( string new name ) { url url = web_link_url_template . build ( this . get a p i ( ) . get base u r l ( ) , this . get i d ( ) ) ; box j s o n request request = new box j s o n request ( this . get a p i ( ) , url , `` put `` ) ; json object update info = new json object ( ) ; update info . add ( `` name `` , new name ) ; request . set body ( update info . to string ( ) ) ; box a p i response response = request . send ( ) ; response . disconnect ( ) ; }
public void set destfile ( final file d file ) { this . d file = d file ; }
public string get name ( ) { return this . name ; }
public string get high watermark raw ( ) { return high watermark raw ; }
public t max retry attempt ( int max retry attempt ) { throw new unsupported operation exception ( ) ; }
public void delete ( ) { box a p i connection api = this . get a p i ( ) ; url url = collaboration_whitelist_exempt_target_entry_url_template . build ( api . get base u r l ( ) , this . get i d ( ) ) ; box a p i request request = new box a p i request ( api , url , http method . delete ) ; box a p i response response = request . send ( ) ; response . disconnect ( ) ; }
public void remove ( ) { if ( remove allow ) { if ( remove || before first ) { throw new illegal state exception ( ) ; } object = null ; remove = true ; } else { throw new unsupported operation exception ( ) ; } }
public void set redirection u r i ( final uri redirect u r i ) { set redirection u r be ( redirect u r i ! = null ? collection . singleton ( redirect u r i ) : null ) ; }
public final int hash code ( ) { return i hash code ; }
public folder get folder ( ) { return null ; }
public boolean be null string set ( ) { return null string ! = null ; }
public list < field > get field ( ) { return field ; }
public box retention policy assignment . info assign to ( box folder folder ) { return box retention policy assignment . create assignment to folder ( this . get a p i ( ) , this . get i d ( ) , folder . get i d ( ) ) ; }
public void delete ( ) { box a p i connection api = this . get a p i ( ) ; url url = collaboration_whitelist_exempt_target_entry_url_template . build ( api . get base u r l ( ) , this . get i d ( ) ) ; box a p i request request = new box a p i request ( api , url , http method . delete ) ; box a p i response response = request . send ( ) ; response . disconnect ( ) ; }
public string get default access ( ) { if ( default access == null ) { return `` property `` ; } else { return default access ; } }
public info get info ( ) { box a p i connection api = this . get a p i ( ) ; url url = collaboration_url_template . build ( api . get base u r l ( ) , this . get i d ( ) ) ; box a p i request request = new box a p i request ( api , url , `` get `` ) ; box j s o n response response = ( box j s o n response ) request . send ( ) ; json object json object = json object . read from ( response . get j s o n ( ) ) ; return new info ( json object ) ; }
public info get info ( ) { box a p i connection api = this . get a p i ( ) ; url url = collaboration_url_template . build ( api . get base u r l ( ) , this . get i d ( ) ) ; box a p i request request = new box a p i request ( api , url , `` get `` ) ; box j s o n response response = ( box j s o n response ) request . send ( ) ; json object json object = json object . read from ( response . get j s o n ( ) ) ; return new info ( json object ) ; }
protect t login page ( string login page ) { set login page ( login page ) ; update authentication default ( ) ; this . custom login page = true ; return get self ( ) ; }
public string get name ( ) { return this . name ; }
public long get i d ( ) { return id ; }
public boolean get scope ( ) { return scope ; }
public string get path ( ) { return this . path ; }
public string get path ( ) { return this . path ; }
public template [ ] get template ( ) { return get template ( null ) ; }
public final string get parse content ( ) { if ( error content length == 0 ) { return null ; } return content ; }
public inner type def variable get upper bound ( ) { return this . upper bound ; }
public compilation unit set import ( final node list < import declaration > import ) { assert not null ( import ) ; if ( import == this . import ) { return this ; } notify property change ( observable property . import , this . import , import ) ; if ( this . import ! = null ) this . import . set parent node ( null ) ; this . import = import ; set a parent node of ( import ) ; return this ; }
protect void do define class ( string class name ) { string base name = name . suffix ( class name,1 ) ; define class . remove ( class name ) ; define class base names . remove ( base name ) ; }
protect string get class be define ( string class name ) { string base name = name . suffix ( class name,1 ) ; return ( string ) define class base name . get ( base name ) ; }
public class get type ( ) { return ( this . type ) ; }
public int get depth ( ) { return statistic . depth ; }
public static class get class ( string class name ) throw class not find exception { return get class ( class name , true ) ; }
public void set class name ( string class name ) { this . class name = class name ; }
public error get error ( ) { return this . error ; }
public void set debug ( boolean debug ) { this . debug = debug ; }
public void set manager ( manager manager ) { this . manager = manager ; }
public list < string > get variable name ( ) { return this . variable name ; }
public boolean contains range ( range range ) { if ( range == null ) { return false ; } return contains integer ( range . get minimum integer ( ) ) & & contain integer ( range . get maximum integer ( ) ) ; }
protect project stage resolve project stage ( ) { for ( string config location : config_setting_keys ) { string stage name = config resolver . get property value ( config location ) ; if ( stage name ! = null & & ! stage name . be empty ( ) ) { return project stage . value of ( stage name ) ; } } return null ; }
public type get type ( ) { return type ; }
public string get keyspace ( ) { return keyspace ; }
public void add rule ( h s s f conditional formatting rule cf rule ) { cf aggregate . add rule ( cf rule . get cf rule record ( ) ) ; }
public uuid get schema version ( ) { return schema version ; }
public int get min length ( ) { return min length ; }
public synchronize state mark available ( ) { if ( map . be empty ( ) ) { state = state . idle ; } else { state = state . pending ; } return state ; }
public final boolean need filter ( ) { int position = 0 ; for ( single restriction restriction : restriction ) { if ( handle in filter ( restriction , position ) ) return true ; if ( ! restriction . be slice ( ) ) position = restriction . get last column ( ) . position ( ) + 1 ; } return have contains ( ) ; }
public final boolean have slice ( ) { for ( single restriction restriction : restriction ) { if ( restriction . be slice ( ) ) return true ; } return false ; }
public final boolean have slice ( ) { for ( single restriction restriction : restriction ) { if ( restriction . be slice ( ) ) return true ; } return false ; }
public void set operator ( infix expression . operator operator ) { if ( operator == null ) { throw new illegal argument exception ( ) ; } pre value change ( operator_property ) ; this . operator = operator ; post value change ( operator_property ) ; }
public final column definition column ( ) { return column ; }
public string get condition ( ) { return condition ; }
public string get message ( ) { return message ; }
public comparator comparator ( ) { return comparator ; }
public unfiltered row iterator query memtable and disk ( column family store cf , read execution controller execution controller ) { assert execution controller ! = null & & execution controller . valid for read on ( cf ) ; trace . trace ( `` execute single-partition query on { } `` , cf . name ) ; return query memtable and disk internal ( cf ) ; }
protect void set line tracker ( i line tracker tracker ) { f tracker= tracker ; }
public string get keyspace ( ) { return keyspace ; }
public void initialize meta data ( data source data source ) { this . meta data provider = call meta data provider factory . create meta data provider ( data source , this ) ; }
public boolean contain a complex column ( ) { for ( column definition def : get column ( ) ) if ( def . be complex ( ) ) return true ; return false ; }
public boolean contain a complex column ( ) { for ( column definition def : get column ( ) ) if ( def . be complex ( ) ) return true ; return false ; }
public void set ignore ( boolean ignore ) { this . ignore = ignore ; }
public void flush ( ) { lock . lock ( ) ; try { ensure open ( ) ; if ( bulk request . number of action ( ) > 0 ) { execute ( ) ; } } finally { lock . unlock ( ) ; } }
public directory directory ( ) { return directory ; }
public clock and count get local clock and count ( byte buffer context ) { return get clock and count of ( context , counter id . get local id ( ) ) ; }
public static clock default clock ( ) { return default ; }
public string get reader ( ) { return reader ; }
public deletion time start deletion time ( ) { return start deletion ; }
public void set message digest ( byte [ ] digest ) { put ( message_digest , digest ) ; }
public boolean equal ( object other ) { return this==other ; }
public final string get timestamp ( ) { return info timestamp ; }
public void remove ( ) { throw new unsupported operation exception ( ) ; }
public void track column ( collection < integer > column ) { for ( final int column : column ) { track column ( column ) ; } }
public int get min length ( ) { return min length ; }
public void deletion ( k key ) { if ( deletions==null ) deletion = new array list < > ( ) ; deletion . add ( key ) ; }
protect void execute impl ( ) throw execution exception { throw new execution exception ( `` controller `` + get class ( ) + `` have n't overriden the execute impl ( ) method `` ) ; }
public static void quick sort ( int start , int end , int comparator comp , swapper swap ) { check bound ( end + 1 , start , end ) ; quick sort0 ( start , end , comp , swap ) ; }
public boolean be close ( ) { return close ; }
public void set view ( view view ) { this . view = view ; }
public boolean contains key ( k k ) { return ! get ( k ) . be empty ( ) ; }
public final boolean have type bound ( ) { return get type bound node ( ) ! = null ; }
public void set conf ( configuration conf ) { this . conf = conf ; }
public void set conf ( configuration conf ) { this . conf = conf ; }
public void set static context ( static context static context ) { this . static context = static context ; }
public void set hint ( string hint name , serializable value ) { hint . put ( hint name , value ) ; }
public final t update top ( ) { down heap ( ) ; return heap [ 1 ] ; }
public void acquire ( double rate ) { rate limiter limiter = ref . get ( ) ; if ( limiter == null || limiter . get rate ( ) ! = rate ) { ref . compare and set ( limiter , rate limiter . create ( rate ) ) ; limiter = ref . get ( ) ; } limiter . acquire ( 1 ) ; }
public void destroy ( ) { for ( endpoint endpoint : this . publish endpoint ) { endpoint . stop ( ) ; } }
public void pause ( ) { write lock . lock ( ) ; try { be active = false ; } finally { write lock . unlock ( ) ; } }
public void clear ( ) { object . clear ( ) ; }
public long get count ( ) { return count ; }
public error handler get handler ( ) { return handler ; }
public void set view name ( @ nullable string view name ) { this . view = view name ; }
public void set view name ( @ nullable string view name ) { this . view = view name ; }
protect socket get socket ( ) { return this . socket ; }
public synchronize void receive ( s s table multi writer sstable ) { if ( do ) { logger . warn ( `` [ { } ] receive sstable { } on already finish stream receive task . abort sstable . `` , session . plan id ( ) , sstable . get filename ( ) ) ; throwables . maybe fail ( sstable . abort ( null ) ) ; return ; } remote s s table received++ ; assert cf id . equal ( sstable . get cf id ( ) ) ; collection < s s table reader > finish = null ; try { finish = sstable . finish ( true ) ; } catch ( throwable t ) { throwables . maybe fail ( sstable . abort ( t ) ) ; } txn . update ( finish , false ) ; sstables . add all ( finish ) ; if ( remote s s table receive == total file ) { do = true ; executor . submit ( new on completion runnable ( this ) ) ; } }
public stream plan transfer file ( inet address to , collection < stream session . s s table stream section > sstable detail ) { coordinator . transfer file ( to , sstable detail ) ; return this ; }
public int write ( byte buffer src ) { int to transfer = math . min ( src . remain ( ) , data . length - offset ) ; src . get ( data , offset , to transfer ) ; offset += to transfer ; return to transfer ; }
protect socket get socket ( ) { return this . socket ; }
public void set status ( string status ) { this . status = status ; } // -- void set status ( string )
public void release with mutation ( mutation batch m ) throw exception { release with mutation ( m , false ) ; }
public void register value target ( target target ) { if ( target == null ) { target = new vector ( ) ; } target . add element ( target ) ; }
public static final readable interval get readable interval ( readable interval interval ) { if ( interval == null ) { long now = date time utils . current time millis ( ) ; interval = new interval ( now , now ) ; } return interval ; }
public final string get release ( ) { return info release ; }
public static iterator < string > symbol name iterator ( final iterator < symbol token > token iter ) { return new iterator < string > ( ) { public boolean have next ( ) { return token iter . have next ( ) ; } public string next ( ) { return token iter . next ( ) . get text ( ) ; } public void remove ( ) { throw new unsupported operation exception ( ) ; } } ; }
public string get condition ( ) { return condition ; }
public inet address get local address ( ) { return local address ; }
public void prepend ( list < byte buffer > list ) { for ( byte buffer buffer : list ) { buffer . position ( buffer . limit ( ) ) ; } buffer . add all ( 0 , list ) ; }
public delta data tree new empty delta tree ( ) { if ( ! be immutable ( ) ) throw new illegal argument exception ( message . dtree_not immutable ) ; delta data tree new tree = ( delta data tree ) this . copy ( ) ; new tree . set parent ( this ) ; new tree . empty delta ( ) ; return new tree ; }
public static code point iterator of utf8 byte ( final byte [ ] bytes ) { return of utf8 byte ( byte , 0 , byte . length ) ; }
public matrix get v ( ) { return v . like ( ) . assign ( v ) ; }
public wait strategy with rate limiter ( rate limiter rate limiter ) { this . rate limiter = rate limiter ; return this ; }
public string get query ( ) { return query ; }
public boolean be connect ( ) { return false ; }
public event bus option set cluster ( boolean cluster ) { this . cluster = cluster ; return this ; }
public tracker get tracker ( ) { return data ; }
public duration get wait time ( ) { return new duration ( wait nanos , time unit . nanosecond ) ; }
public string get keyspace ( ) { return keyspace ; }
public int get level ( ) { return level ; }
public java . util . list < delete message batch result entry > get successful ( ) { if ( successful == null ) { successful = new com . amazonaws . internal . sdk internal list < delete message batch result entry > ( ) ; } return successful ; }
public request trace get trace ( ) { return trace ; }
public type get type ( ) { return type ; }
public address get address ( ) { return address ; }
public schema version get schema version ( ) { return schema version ; }
public string get user ( ) { return user ; }
public string get keywords ( ) { return get text property ( prefix + `` : keywords `` ) ; }
public string get host ( ) { return host ; }
public int get max schema agreement wait second ( ) { return max schema agreement wait second ; }
public void release connection ( ) { log . trace ( `` enter http connection . release connection ( ) `` ) ; if ( lock ) { log . debug ( `` connection be lock . call to release connection ( ) ignore . `` ) ; } else if ( http connection manager ! = null ) { log . debug ( `` release connection back to connection manager . `` ) ; http connection manager . release connection ( this ) ; } else { log . warn ( `` http connection manager be null . connection can not be release . `` ) ; } }
public c s v format quote ( quote new quote ) { return new c s v format ( delimiter , null string , empty string , newline , quote string , new quote , header ) ; }
public string get value ( ) { return value ; }
public statement set retry policy ( retry policy policy ) { this . retry policy = policy ; return this ; }
public address get address ( ) { return address ; }
public retry policy get retry policy ( ) { return retry policy . get ( ) ; }
public boolean check schema agreement ( ) { try { return cluster . control connection . check schema agreement ( ) ; } catch ( exception e ) { logger . warn ( `` error while check schema agreement `` , e ) ; return false ; } }
public sequence iterable get use ( ) { return use ; }
public void set order ( int order ) { this . order = order ; }
public void set timestamp ( final long timestamp ) { this . timestamp = timestamp ; }
public io . vertx . reactivex . redis . redis client incr ( string key , handler < async result < long > > handler ) { delegate . incr ( key , handler ) ; return this ; }
public box retention policy assignment . info assign to ( box folder folder ) { return box retention policy assignment . create assignment to folder ( this . get a p i ( ) , this . get i d ( ) , folder . get i d ( ) ) ; }
public boolean be remove ( ) { return remove ; }
public object get parameter ( string name ) { return parameter . get ( name ) ; }
protect void set alias ( string alias ) { this . alias = alias ; }
public document default definition get default ( ) { return this . default ; }
public query option set refresh node interval millis ( int refresh node interval millis ) { this . refresh node interval millis = refresh node interval millis ; return this ; }
public int get refresh node list interval millis ( ) { return refresh node list interval millis ; }
public int get refresh node list interval millis ( ) { return refresh node list interval millis ; }
public create add u d t cluster column ( string column name , u d t type udt type ) { validate not empty ( column name , `` cluster column name `` ) ; validate not null ( udt type , `` udt cluster column type `` ) ; validate not key word ( column name , string . format ( `` the clustering column name ' % s ' be not allow because it be a reserved keyword `` , column name ) ) ; cluster column . put ( column name , udt type ) ; return this ; }
public t add u d t column ( string column name , u d t type udt type ) { validate not empty ( column name , `` column name `` ) ; validate not null ( udt type , `` column type `` ) ; validate not key word ( column name , string . format ( `` the column name ' % s ' be not allow because it be a reserved keyword `` , column name ) ) ; simple column . put ( column name , udt type ) ; return self ; }
public static create sequence final step create sequence if not exist ( string sequence ) { return dsl ( ) . create sequence if not exist ( sequence ) ; }
public string get build label ( ) { return build ; }
public index [ ] index ( ) { return index ; }
public boolean be frozen ( ) { return this . frozen ; }
public int get max literal length ( ) { return max literal length ; }
public synchronize value get ( key key ) { return cache . get ( key ) ; }
public void set filter ( boolean filter ) { this . filter = filter ; }
public final void set cache second ( int second ) { this . cache second = second ; }
public void put ( final string key , final object value ) { if ( null == key ) throw new illegal argument exception ( `` key may not be null `` ) ; if ( key . be empty ( ) ) throw new illegal argument exception ( `` key may not be empty `` ) ; global scope . put ( key , value ) ; }
public string get name ( ) { return ( string ) get value ( name ) ; }
public boolean get reuse parser ( ) { return reuse parser ; }
public retry policy get retry policy ( ) { return retry policy ; }
public void set start token ( string start token ) { this . start token = start token ; }
public void set custom qualifier type ( set < ? > custom qualifier type ) { this . custom qualifier type = custom qualifier type ; }
public string get keyspace ( ) { return keyspace ; }
public int get minor version ( ) { return minor version ; }
public string build ( ) { return build internal ( ) ; }
public void sort prefix ( ) { for ( final field field : scan spec . class . get declared field ( ) ) { if ( white black list . class . be assignable from ( field . get type ( ) ) ) { try { ( ( white black list ) field . get ( this ) ) . sort prefix ( ) ; } catch ( final reflective operation exception e ) { throw class graph exception . new class graph exception ( `` field be not accessible : `` + field , e ) ; } } } }
public signature type get signature type ( ) { return signature type ; }
public void set class name ( string class name ) { this . class name = class name ; }
public string get jar ( ) { return get ( job context . jar ) ; }
public class info list get all interface and annotation ( ) { if ( close . get ( ) ) { throw new illegal argument exception ( `` can not use a scan result after it have be close `` ) ; } if ( ! scan spec . enable class info || ! scan spec . enable annotation info ) { throw new illegal argument exception ( `` please call class graph # enable class info ( ) and # enable annotation info ( ) before # scan ( ) `` ) ; } return class info . get all interface or annotation class ( class name to class info . value ( ) , scan spec ) ; }
public object get layer ( ) { return layer ; }
public string get jar ( ) { return get ( job context . jar ) ; }
public boolean be final ( ) { return modifier . be final ( modifier ) ; }
public void set interface ( class < ? > . . . interface ) { assert . not null ( interface , `` interface must not be null `` ) ; this . interface . clear ( ) ; for ( class < ? > ifc : interface ) { add interface ( ifc ) ; } }
public string get class name ( ) { return get class info ( this class info ) ; }
public method info get method info ( ) { declare class . check modify ( ) ; return method info ; }
public field info [ ] get field ( ) { return field ; }
public int compare to ( final object object ) { final command cast object = ( command ) object ; int compare to = util . compare ( category , cast object . category ) ; if ( compare to == 0 ) { compare to = util . compare ( define , cast object . define ) ; if ( compare to == 0 ) { compare to = util . compare ( description , cast object . description ) ; if ( compare to == 0 ) { compare to = util . compare ( handler , cast object . handler ) ; if ( compare to == 0 ) { compare to = util . compare ( id , casted object . id ) ; if ( compare to == 0 ) { compare to = util . compare ( name , cast object . name ) ; if ( compare to == 0 ) { compare to = util . compare ( parameter , cast object . parameter ) ; } } } } } } return compare to ; }
public boolean equal ( object obj ) { if ( obj == this ) { return true ; } if ( obj instanceof char set == false ) { return false ; } char set other = ( char set ) obj ; return set . equal ( other . set ) ; }
public signature type get signature type ( ) { return signature type ; }
public boolean be final ( ) { return modifier . be final ( modifier ) ; }
public class info list get all interface and annotation ( ) { if ( close . get ( ) ) { throw new illegal argument exception ( `` can not use a scan result after it have be close `` ) ; } if ( ! scan spec . enable class info || ! scan spec . enable annotation info ) { throw new illegal argument exception ( `` please call class graph # enable class info ( ) and # enable annotation info ( ) before # scan ( ) `` ) ; } return class info . get all interface or annotation class ( class name to class info . value ( ) , scan spec ) ; }
public void set annotation name ( string annotation name ) { this . annotation name = annotation name ; } // set annotation name
public int get modifier ( ) { return modifier ; }
public matrix get weight by layer ( int layer idx ) { return this . weight matrix list . get ( layer idx ) ; }
public static string get resource path ( ) { return resource path ; }
public resource list get resource with path ( final string resource path ) { if ( close . get ( ) ) { throw new illegal argument exception ( `` can not use a scan result after it have be close `` ) ; } final resource list all whitelisted resource = get all resource ( ) ; if ( all whitelisted resource . be empty ( ) ) { return resource list . empty_list ; } else { final string path = file utils . sanitize entry path ( resource path , / * remove initial slash = * / true ) ; final resource list resource list = get all resource a map ( ) . get ( path ) ; return ( resource list == null ? new resource list ( 1 ) : resource list ) ; } }
public annotation info list get annotation info ( ) { if ( ! scan result . scan spec . enable annotation info ) { throw new illegal argument exception ( `` please call class graph # enable annotation info ( ) before # scan ( ) `` ) ; } return annotation info == null ? annotation info list . empty_list : annotation info list . get indirect annotation ( annotation info , / * annotate class = * / null ) ; }
public signature type get signature type ( ) { return signature type ; }
public synchronize void timeout occur ( watchdog w ) { if ( thread ! = null ) { time out = true ; thread . interrupt ( ) ; } notify all ( ) ; }
public field get field ( ) { return field ; }
public list < field > get field ( ) { return field ; }
public string get path ( ) { return path ; }
public boolean be specifically whitelisted and not blacklist ( final string str ) { return ! whitelist be empty ( ) & & be whitelisted and not blacklist ( str ) ; }
public boolean blacklist be empty ( ) { return blacklist == null & & blacklist prefix == null & & blacklist glob == null ; }
public type get type ( ) { return type ; }
public iterator iterator ( ) { return new iterator ( ) ; }
public void set args ( string [ ] args ) { if ( args == null ) { args = new string [ ] { } ; } this . args = args ; this . args list = collection . unmodifiable list ( new array list < string > ( arrays . a list ( args ) ) ) ; }
public string get long opt ( ) { return long opt ; }
public static boolean be null or empty ( string str ) { return ( ( str == null ) || str . trim ( ) . length ( ) == 0 ) ; }
public static < e > bag < e > collection bag ( final bag < e > bag ) { return new collection bag < > ( bag ) ; }
public synchronize void set object ( final map map ) { if ( map == null ) { throw new illegal argument exception ( `` map of handler may not be null `` ) ; } this . map . clear ( ) ; this . map . put all ( map ) ; }
public string get full name ( ) { return full name ; }
public boolean be empty ( ) { return empty ; }
public int get time out ( ) { return timeout ; }
public comparator get comparator ( ) { return comparator ; }
public static closure switch map closure ( map object and closure ) { closure [ ] trs = null ; predicate [ ] preds = null ; if ( object and closure == null ) { throw new illegal argument exception ( `` the object and closure map must not be null `` ) ; } closure def = ( closure ) object and closure . remove ( null ) ; int size = object and closure . size ( ) ; trs = new closure [ size ] ; preds = new predicate [ size ] ; int i = 0 ; for ( iterator it = object and closure . entry set ( ) . iterator ( ) ; it . have next ( ) ; ) { map . entry entry = ( map . entry ) it . next ( ) ; preds [ i ] = equal predicate . get instance ( entry . get key ( ) ) ; trs [ i ] = ( closure ) entry . get value ( ) ; i++ ; } return switch closure ( preds , trs , def ) ; }
public static void for all do ( collection collection , closure closure ) { if ( collection ! = null & & closure ! = null ) { for ( iterator it = collection . iterator ( ) ; it . have next ( ) ; ) { closure . execute ( it . next ( ) ) ; } } }
public static void no null element ( collection collection ) { validate . not null ( collection ) ; int i = 0 ; for ( iterator it = collection . iterator ( ) ; it . have next ( ) ; i++ ) { if ( it . next ( ) == null ) { throw new illegal argument exception ( `` the validated collection contain null element at index : `` + i ) ; } } }
public static < o > collection < o > select reject ( final iterable < ? extend o > input collection , final predicate < ? super o > predicate ) { final collection < o > answer = input collection instanceof collection < ? > ? new array list < o > ( ( ( collection < ? > ) input collection ) . size ( ) ) : new array list < o > ( ) ; return select reject ( input collection , predicate , answer ) ; }
public object remove first ( ) { if ( _head . next ( ) ! = null ) { object val = _head . next ( ) . value ( ) ; remove listable ( _head . next ( ) ) ; return val ; } else { throw new no such element exception ( ) ; } }
public boolean add ( object o ) { insert listable ( _head . prev ( ) , null , o ) ; return true ; }
public int hash code ( ) { return name . hash code ( ) ; } // hash code
public static boolean get cache fast ( map map ) { if ( map instanceof weak fast hash map ) { return ( ( weak fast hash map ) map ) . get fast ( ) ; } else { return false ; } }
public boolean be empty ( ) { return empty ; }
public final list < list < object > > get event ( ) { list < list < object > > result = new array list < list < object > > ( ) ; result . add ( ( list ) value ( ) ) ; result . add ( ( list ) error ( ) ) ; list < object > complete list = new array list < object > ( ) ; for ( long i = 0 ; i < completion ; i++ ) { complete list . add ( notification . create on complete ( ) ) ; } result . add ( complete list ) ; return result ; }
public object get array ( ) { return array ; }
public predicate < ? super e > get predicate ( ) { return i predicate ; }
public void add transformer ( class file transformer transformer ) { if ( transformer == null ) { throw new illegal argument exception ( `` transformer must not be null `` ) ; } this . transformer . add ( transformer ) ; }
public e remove last ( ) { if ( be empty ( ) ) { throw new no such element exception ( ) ; } return remove and get ( get max element index ( ) ) ; }
public iterator iterator ( ) { return hashcode map . value ( ) . iterator ( ) ; }
public list type ( ) { return this . type ; }
protect map transform map ( map map ) { if ( map . be empty ( ) ) { return map ; } map result = new link map ( map . size ( ) ) ; for ( iterator it = map . entry set ( ) . iterator ( ) ; it . have next ( ) ; ) { map . entry entry = ( map . entry ) it . next ( ) ; result . put ( transform key ( entry . get key ( ) ) , transform value ( entry . get value ( ) ) ) ; } return result ; }
public list < entry > get entry ( ) { return entry ; }
public object last key ( ) { if ( size == 0 ) { throw new no such element exception ( `` map be empty `` ) ; } return header . before . get key ( ) ; }
public object first key ( ) { if ( size == 0 ) { throw new no such element exception ( `` map be empty `` ) ; } return header . after . get key ( ) ; }
protect void remove mapping ( hash entry entry , int hash index , hash entry previous ) { mod count++ ; remove entry ( entry , hash index , previous ) ; size -- ; destroy entry ( entry ) ; }
public list < entry > get entry ( ) { return entry ; }
public void set mutator ( final set mutator < e > mutator ) { this . mutator = mutator ; }
public void set mutator ( map mutator mutator ) { this . mutator = mutator ; }
public void put all ( map map ) { int map size = map . size ( ) ; if ( map size == 0 ) { return ; } int new size = ( int ) ( ( size + map size ) / load factor + 1 ) ; ensure capacity ( calculate new capacity ( new size ) ) ; for ( iterator it = map . entry set ( ) . iterator ( ) ; it . have next ( ) ; ) { map . entry entry = ( map . entry ) it . next ( ) ; put ( entry . get key ( ) , entry . get value ( ) ) ; } }
public static double get double ( map map , object key , double default value ) { double answer = get double ( map , key ) ; if ( answer == null ) { answer = default value ; } return answer ; }
public static < k > short get short value ( final map < ? super k , ? > map , final k key ) { final short short object = get short ( map , key ) ; if ( short object == null ) { return 0 ; } return short object . short value ( ) ; }
public static map get map ( final map map , final object key ) { if ( map ! = null ) { object answer = map . get ( key ) ; if ( answer ! = null & & answer instanceof map ) { return ( map ) answer ; } } return null ; }
public static void not empty ( map map ) { if ( map == null || map . size ( ) == 0 ) { throw new illegal argument exception ( `` the validated map be empty `` ) ; } }
public predicate [ ] get predicate ( ) { return i predicate ; }
public static map multi value map ( map map , factory collection factory ) { return multi value map . decorate ( map , collection factory ) ; }
public static map multi value map ( map map , class collection class ) { return multi value map . decorate ( map , collection class ) ; }
public list < entry > get entry ( ) { return entry ; }
public predicate [ ] get predicate ( ) { return i predicate ; }
public boolean be empty ( ) { return empty ; }
public object peek ( string stack name ) { return peek ( stack name , 0 ) ; }
public transformer get transformer ( ) { return i transformer ; }
public long get available ( ) { return this . available ; }
public void close ( ) throw i o exception { this . finish ( ) ; this . buffer . close ( ) ; }
public char get delimiter ( ) { return delimiter ; }
public string get delimiter ( ) { return this . delimiter ; }
public void set exception if header miss ( boolean exception if header miss ) { this . exception if header miss = exception if header miss ; }
public configuration interpolator get parent interpolator ( ) { return this . parent interpolator ; }
public collection < configuration error listener > get error listener ( ) { return collection . unmodifiable collection ( new array list < configuration error listener > ( error listener ) ) ; }
public output stream wrap out if need ( output stream out ) { return out ; }
public boolean be no store ( ) { return no store ; }
public boolean get delegate ( ) { return this . delegate ; }
public boolean be empty ( ) { return empty ; }
public void set file ( file file ) { this . file = file ; }
public string get key ( ) { return key ; }
public static string get parent path ( string filename ) { utils . assert not null ( filename ) ; int last index = filename . last index of ( file . separator ) ; return filename . substring ( 0 , last index ) ; }
public void set exception attribute ( @ nullable string exception attribute ) { this . exception attribute = exception attribute ; }
public short [ ] get short array ( string key ) { return get short array ( key , new short [ 0 ] ) ; }
public list < short > get short list ( string key ) { return get short list ( key , new array list < short > ( ) ) ; }
public long get long ( ) { long ret = delegate . get long ( ) ; return ret ; }
public big integer get big integer value ( ) throw i o exception { return delegate . get big integer value ( ) ; }
public url to u r l ( ) throw malformed u r l exception { return base . to u r l ( ) ; }
public void set color ( p d gamma color ) { this . set color ( color , color ) ; }
public string get provider name ( ) { return provider name ; }
public void set configuration ( configuration configuration ) { this . configuration = configuration ; }
public static string extract property value ( string property name , property property ) { string value = property . get property ( property name ) ; if ( value == null ) { return null ; } value = value . trim ( ) ; if ( value . be empty ( ) ) { return null ; } return value ; }
public collection < configuration error listener > get error listener ( ) { return collection . unmodifiable collection ( new array list < configuration error listener > ( error listener ) ) ; }
public void set fault detail string ( string detail ) { clear fault detail ( ) ; add fault detail string ( detail ) ; }
public collection < configuration listener > get configuration listener ( ) { return collection . unmodifiable collection ( new array list < configuration listener > ( listener ) ) ; }
public static file system get default file system ( ) { return default ; }
protect abstract data tree node get root node ( ) { return root node ; }
protected list < configuration node > fetch node list ( string key ) { return get expression engine ( ) . query ( get root node ( ) , key ) ; }
public list < node > get node ( ) { return node ; }
public configuration get configuration ( ) { return config ; }
public final string get line ( int line i ) { return line . get ( line i ) ; }
public boolean get global ( ) { return m global ; }
protected step interpolator do copy ( ) { return new dummy step interpolator ( this ) ; }
public context get context ( ) { return impl . get context ( ) ; }
public long get delay ( ) { return delay millis ; }
public void set engine ( axis engine engine ) { this . engine = engine ; }
public result get result ( ) { return result ; }
public node parent ( ) { return parent ; }
public final int get child size ( ) { if ( f child == null ) return 0 ; return f child . size ( ) ; }
public void append child ( configuration node source ) { if ( source ! = null ) { for ( configuration node child : source . get child ( ) ) { add child ( child ) ; } } }
public void set child ( hash set < string > child ) { this . child = child ; }
public object get attribute ( string attribute name ) { return attribute map . get ( attribute name ) ; }
public boolean have next ( ) { return index < end index ; }
public boolean have attribute ( ) { return attribute ! = null & & ! attribute . be empty ( ) ; }
protect node create node ( string name ) { return new node ( name ) ; }
protect void index node ( node node ) { list < node > nod = node name to node . get ( node . get x path node name ( ) ) ; if ( node ! = null ) { node . add ( node ) ; } }
public void add child ( final object child ) { this . child . add ( child ) ; }
public document info get document root ( ) { node info root = get root ( ) ; if ( root . get node kind ( ) == type . document ) { return ( document info ) root ; } return null ; }
public void execute validation ( int index , object value ) { list < validate conversion > validation = validation by index . get ( index ) ; if ( validation ! = null ) { for ( int i = 0 ; i < validation . size ( ) ; i++ ) { validation . get ( i ) . execute ( value ) ; } } }
public document get document ( ) { return document ; }
public set get property key set ( ) { return get property ( ) . key set ( ) ; }
public configuration node get child ( int index ) { return child . get node ( index ) ; }
public string to string ( ) { return set . to string ( ) ; }
public int hash code ( ) { return name . hash code ( ) ; } // hash code
public void set configuration ( configuration configuration ) { this . configuration = configuration ; }
public synchronize object get ( object key ) { if ( ! contains key ( key ) ) { return null ; } object value = remove ( key ) ; super . put ( key , value ) ; return value ; }
protected list < configuration node > fetch node list ( string key ) { return get expression engine ( ) . query ( get root node ( ) , key ) ; }
public void set new node name ( string new node name ) { this . new node name = new node name ; }
public configuration get configuration ( ) throw configuration exception { return get configuration ( true ) ; }
public void remove ( ) { throw new unsupported operation exception ( ) ; }
public string separator ( ) { return separator ; }
public boolean be null ( ) { return be null ; }
public static string quote ( string value ) { return quote ( value , '\ `` ) ; }
public void set number of record to read ( long number of record to read ) { this . number of record to read = number of record to read ; }
public string to string ( ) { return name ; }
public final http client builder evict expire connection ( ) { evict expire connection = true ; return this ; }
public void set auto commit on return ( final boolean auto commit on return ) { this . auto commit on return = auto commit on return ; }
public boolean be cache ( ) { return cache ! = null ; }
public boolean get fast ( ) { return ( this . fast ) ; }
public void set max idle ( int max idle ) { this . max idle = max idle ; }
public long get max wait ( ) { return this . max wait ; }
public synchronize int get max idle ( ) { return this . max idle ; }
public void set remove abandon timeout ( final duration remove abandon timeout ) { this . remove abandon timeout = remove abandon timeout ; }
public boolean get auto commit on return ( ) { return auto commit on return ; }
public void set eviction policy ( final eviction policy < t > eviction policy ) { this . eviction policy = eviction policy ; }
public final void set max total ( final int max total ) { this . max total = max total ; }
public void set max idle ( int max idle ) { this . max idle = max idle ; }
public connection get innermost delegate ( ) { if ( be access to underlie connection allow ( ) ) { return super . get innermost delegate internal ( ) ; } return null ; }
public boolean be access to underlie connection allow ( ) { return access to underlie connection allow ; }
public property get connection property ( ) { return new property ( connection prop ) ; }
public void set url ( string url ) { this . url = url ; } // -- void set url ( string )
public static void set default pool ( buffer pool pool ) { if ( pool == null ) { throw new illegal argument exception ( `` pool be null `` ) ; } default pool = pool ; }
public static boolean be cql compatible ( c f meta data meta data ) { if ( meta data . be super ( ) ) return false ; if ( meta data . be compact table ( ) & & meta data . partition column ( ) . without static ( ) . size ( ) > 1 & & meta data . cluster column ( ) . size ( ) > = 1 ) return false ; return true ; }
public boolean be close ( ) { return close ; }
public final void set column index ( int column index ) { this . column index = column index ; }
public message get message ( ) { return msg ; }
public void set charset ( string charset ) { this . charset = charset ; }
public void close ( ) throw i o exception { super . close ( ) ; this . branch . close ( ) ; }
public void write thin ( stream output out ) throw i o exception { super . write to ( out ) ; out . write v int ( byte . length ( ) ) ; }
public void close ( ) throw i o exception { try { super . close ( ) ; } finally { if ( close branch ) { branch . close ( ) ; } } }
public static int last index of ( long [ ] array , long value to find ) { return last index of ( array , value to find , integer . max_value ) ; }
public string to string ( ) { return set . to string ( ) ; }
public int hash code ( ) { return to hash code ( ) ; }
public void split ( ) { if ( this . run state ! = state_running ) { throw new illegal state exception ( `` stopwatch be not run . `` ) ; } stop time = system . current time millis ( ) ; this . split state = state_split ; }
public long get time ( ) { if ( this . run state == state_stopped || this . run state == state_suspended ) { return this . stop time - this . start time ; } else if ( this . run state == state_unstarted ) { return 0 ; } else if ( this . run state == state_running ) { return system . current time millis ( ) - this . start time ; } throw new runtime exception ( `` illegal run state have occur . `` ) ; }
public static void no null element ( object [ ] array ) { validate . not null ( array ) ; for ( int i = 0 ; i < array . length ; i++ ) { if ( array [ i ] == null ) { throw new illegal argument exception ( `` the validated array contain null element at index : `` + i ) ; } } }
public static boolean be not empty ( map map ) { return ! map utils . be empty ( map ) ; }
public void debug ( object message , throwable t ) { category . log ( fqcn , priority . debug , message , t ) ; }
public void trace ( object message , throwable t ) { category . log ( fqcn , priority . debug , message , t ) ; }
public void error ( object message , throwable t ) { category . log ( fqcn , priority . error , message , t ) ; }
public void error ( object message ) { category . log ( fqcn , priority . error , message , null ) ; }
public void fatal ( object message ) { if ( is12 ) { get logger ( ) . log ( fqcn , ( priority ) level . fatal , message , null ) ; } else { get logger ( ) . log ( fqcn , level . fatal , message , null ) ; } }
public void fatal ( object message ) { category . log ( fqcn , priority . fatal , message , null ) ; }
public void trace ( object message ) { debug ( message ) ; }
public composable function multiply ( final univariate real function f ) { return new composable function ( ) { @ override / * * { @ inherit doc } * / public double value ( double x ) throw function evaluation exception { return composable function . this . value ( x ) * f . value ( x ) ; } } ; }
public composable function fix2nd argument ( final double fix y ) { return new composable function ( ) { @ override / * * { @ inherit doc } * / public double value ( double x ) throw function evaluation exception { return binary function . this . value ( x , fixed y ) ; } } ; }
public boolean be function ( ) { return this . function ; }
public long get z ( ) { return z ; }
public int next int ( int lower , int upper ) { if ( low > = upper ) { throw math runtime exception . create illegal argument exception ( `` upper bound ( { 0 } ) must be great than low bound ( { 1 } ) `` , upper , low ) ; } double r = get ran ( ) . next double ( ) ; return ( int ) ( ( r * upper ) + ( ( 1 . 0 - r ) * low ) + r ) ; }
public static scale percentile ( ) { return scale ( 100 ) ; }
public double cumulative probability ( final int x ) { if ( x < = 0 ) { return 0 . 0 ; } else if ( x > = number of element ) { return 1 . 0 ; } return generalize harmonic ( x , exponent ) / generalize harmonic ( number of element , exponent ) ; }
public int next unset bit ( final int i ) { int x = i / 64 ; if ( x > = this . get number of word ( ) ) return -1 ; long w = ~this . data [ x ] ; w > > > = i ; if ( w ! = 0 ) { return i + long . number of trail zero ( w ) ; } ++x ; for ( ; x < this . get number of word ( ) ; ++x ) { if ( this . data [ x ] ! = ~0 ) { return x * 64 + long . number of trail zero ( ~this . data [ x ] ) ; } } return -1 ; }
public double get r m s ( ) { return fast math . sqrt ( get chi square ( ) / row ) ; }
protect void set cost ( double cost ) { this . cost = cost ; }
public final method parameter get parameter ( ) { return this . parameter ; }
public set < class < ? > > get ignore type ( ) { return ignore type ; }
public long long value ( ) { return ( long ) numerator / denominator ; }
public long long value ( ) { return ( long ) numerator / denominator ; }
public int get num generation ( ) { return num generation ; }
public int get max value ( int dimension ) { if ( dimension < 2 || dimension > 32 ) { throw new illegal argument exception ( `` `` + dimension ) ; } int bit per value = get bit per value ( dimension ) ; return ( int ) ( ( 1l < < bits per value ) - 1 ) ; }
public void update weight matrix ( matrix [ ] matrix ) { for ( int i = 0 ; i < matrix . length ; ++i ) { matrix matrix = this . weight matrix list . get ( i ) ; this . weight matrix list . set ( i , matrix . plus ( matrix [ i ] ) ) ; } }
public vector aggregate row ( vector function f ) { vector r = new dense vector ( num row ( ) ) ; int n = num row ( ) ; for ( int row = 0 ; row < n ; row++ ) { r . set ( row , f . apply ( view row ( row ) ) ) ; } return r ; }
public big matrix inverse ( ) throw invalid matrix exception { return solve ( matrix utils . create big identity matrix ( get row dimension ( ) ) ) ; }
public boolean equal ( object obj ) { return ( obj instanceof mutable double ) & & ( double . double to long bit ( ( ( mutable double ) obj ) . value ) == double . double to long bit ( value ) ) ; }
public argument create argument ( ) { return this . create argument ( false ) ; }
public final string get message ( ) { return message ; }
public double get start value ( ) { return start ; }
public configuration interpolator get parent interpolator ( ) { return this . parent interpolator ; }
public int next secure int ( int lower , int upper ) { if ( low > = upper ) { throw math runtime exception . create illegal argument exception ( `` upper bound ( { 0 } ) must be great than low bound ( { 1 } ) `` , upper , low ) ; } secure random sec = get sec ran ( ) ; return low + ( int ) ( sec . next double ( ) * ( upper - low + 1 ) ) ; }
public int next int ( int lower , int upper ) { if ( low > = upper ) { throw math runtime exception . create illegal argument exception ( `` upper bound ( { 0 } ) must be great than low bound ( { 1 } ) `` , upper , low ) ; } double r = get ran ( ) . next double ( ) ; return ( int ) ( ( r * upper ) + ( ( 1 . 0 - r ) * low ) + r ) ; }
public real matrix get correlation matrix ( ) { return correlation matrix ; }
public double quantile ( ) { return quantile ; }
public void set distribution ( string distribution ) { this . distribution = distribution ; } // -- void set distribution ( string )
public double homoscedastic t test ( double [ ] sample1 , double [ ] sample2 ) throw illegal argument exception , math exception { check sample data ( sample1 ) ; check sample data ( sample2 ) ; return homoscedastic t test ( stat utils . mean ( sample1 ) , stat utils . mean ( sample2 ) , stat utils . variance ( sample1 ) , stat utils . variance ( sample2 ) , sample1 . length , sample2 . length ) ; }
public double pair t test ( double [ ] sample1 , double [ ] sample2 ) throw illegal argument exception , math exception { double mean difference = stat utils . mean difference ( sample1 , sample2 ) ; return t test ( mean difference , 0 , stat utils . variance difference ( sample1 , sample2 , mean difference ) , sample1 . length ) ; }
public double double value ( ) { return value ; }
public static boolean equal ( float x , float y , float eps ) { return equal ( x , y , 1 ) || fast math . ab ( y - x ) < = eps ; }
public static int indicator ( final int x ) { return ( x > = 0 ) ? 1 : -1 ; }
public static int compare ( double a , double b ) { if ( a < b ) return -1 ; if ( a > b ) return 1 ; if ( double . be na n ( a ) ) { if ( double . be na n ( b ) ) return 0 ; return -1 ; } if ( double . be na n ( b ) ) return 1 ; return 0 ; }
public static double indicator ( final double x ) { if ( double . be na n ( x ) ) { return double . na n ; } return ( x > = 0 . 0 ) ? 1 . 0 : -1 . 0 ; }
public double of ( double [ ] d , int num param ) { return java . lang . math . floor ( d [ 0 ] ) ; }
public static double average ( double [ ] value ) { double ave = 0 ; double sum = 0 ; for ( int i=0 , i size=values . length ; i < i size ; i++ ) { sum += value [ i ] ; } ave = sum / value . length ; return ave ; }
public boolean num exist ( big integer num i d ) { for ( x w p f num num : nums ) { if ( num . get c t num ( ) . get num id ( ) . equal ( num i d ) ) return true ; } return false ; }
public int max expansion ( ) { return this . max expansion ; }
public boolean be na n ( ) { return be na n ; }
public static input stream sub stream ( input stream input stream , long start , int length ) { return new binary stream impl ( extract byte ( input stream , start , length ) ) ; }
public final void send ( t f t p packet packet ) throw i o exception { _socket_ . send ( packet . new datagram ( ) ) ; }
public boolean get use local port ( ) { return use local port ; }
public int list ( ) throw i o exception { return send command ( f t p command . list ) ; }
public int get reply ( ) throw i o exception { __get reply ( ) ; return _reply code ; }
public int send command ( string command ) throw i o exception { return send command ( command , null ) ; }
public int list ( ) throw i o exception { return send command ( f t p command . list ) ; }
public int list ( ) throw i o exception { return send command ( f t p command . list ) ; }
public int list ( ) throw i o exception { return send command ( f t p command . list ) ; }
public string get mode ( ) { return mode ; }
public static output stream new output stream ( string file name , boolean append ) throw i o exception { return file path . get ( file name ) . new output stream ( append ) ; }
public list < file > get file ( ) { return file ; }
public int size ( ) { return size ; }
public string get lang ( ) { return lang ; }
public string get user ( ) { return user ; }
public boolean be file link ( ) { return ( _link opts & hlink_url ) > 0 & & ( _link opts & hlink_abs ) == 0 ; }
public string [ ] get ignorable filename ( ) { return ( string [ ] ) list ignore . to array ( new string [ listing ignore . size ( ) ] ) ; }
public static list < string > read line ( input stream input , charset encode ) throw i o exception { input stream reader reader = new input stream reader ( input , charsets . to charset ( encode ) ) ; return read line ( reader ) ; }
public int get reply ( ) throw i o exception { __get reply ( ) ; return _reply code ; }
public void set timestamp ( final long timestamp ) { this . timestamp = timestamp ; }
public string get read name ( ) { return read name ; }
public void set distribution ( string distribution ) { this . distribution = distribution ; } // -- void set distribution ( string )
public int send command ( string command ) throw i o exception { return send command ( command , null ) ; }
public file get retrieve root ( ) { return retrieve root ; }
public boolean reset ( ) throw i o exception { return s m t p reply . be positive completion ( rset ( ) ) ; }
public address get address ( ) { return address ; }
public int hash code ( ) { return ( int ) ( ntp time ^ ( ntp time > > > 32 ) ) ; }
public long get second ( ) { return ( ntp time > > > 32 ) & 0xffffffff l ; }
public string to string ( ) { string buffer buffer = new string buffer ( ) ; buffer . append ( to string ( get class ( ) ) ) ; buffer . append ( `` [ use default= `` ) ; buffer . append ( be use default ( ) ) ; buffer . append ( `` , use locale format= `` ) ; buffer . append ( use locale format ) ; if ( pattern ! = null ) { buffer . append ( `` , pattern= `` ) ; buffer . append ( pattern ) ; } if ( locale ! = null ) { buffer . append ( `` , locale= `` ) ; buffer . append ( locale ) ; } buffer . append ( ' ] ' ) ; return buffer . to string ( ) ; }
public int get reply code ( ) { return _reply code ; }
public boolean complete pending command ( ) throw i o exception { return n n t p reply . be positive completion ( get reply ( ) ) ; }
public int get port ( ) { return port ; }
public int mark ( ) { return -1 ; }
public string buffer get class buffer ( ) { return class buffer ; }
public void send ( inet address host , int port ) throw i o exception { __send packet . set address ( host ) ; __send packet . set port ( port ) ; _socket_ . send ( __send packet ) ; }
public int get block ( ) { return 0 ; }
public boolean complete pending command ( ) throw i o exception { return n n t p reply . be positive completion ( get reply ( ) ) ; }
public static s s l socket get socket ( encryption option option ) throw i o exception { s s l context ctx = create s s l context ( option , true ) ; s s l socket socket = ( s s l socket ) ctx . get socket factory ( ) . create socket ( ) ; try { prepare socket ( socket , option ) ; return socket ; } catch ( illegal argument exception e ) { socket . close ( ) ; throw e ; } }
public void set send buffer size ( int send buffer size ) throw socket exception { this . params . set send buffer size ( send buffer size ) ; }
public void add listener ( listener listener ) { listener . add ( listener ) ; }
public static final string get command ( i m a p command command ) { return command . get i m a p command ( ) ; }
public mailbox get mailbox ( ) { return this . mailbox ; }
public boolean do command ( i m a p command command , string args ) throw i o exception { return i m a p reply . be success ( send command ( command , args ) ) ; }
public reader retrieve article header ( ) throw i o exception { return retrieve article header ( null ) ; }
public ssl context builder trust manager ( file trust cert collection file ) { try { return trust manager ( ssl context . to x509 certificate ( trust cert collection file ) ) ; } catch ( exception e ) { throw new illegal argument exception ( `` file do not contain valid certificate : `` + trust cert collection file , e ) ; } }
public set < v > get ( final k key ) { return wrap collection ( key ) ; }
public void set active ( boolean active ) { this . active = active ; }
public node clear attribute ( ) { iterator < attribute > it = attribute ( ) . iterator ( ) ; while ( it . have next ( ) ) { it . next ( ) ; it . remove ( ) ; } return this ; }
public static void sleep ( object self , long millisecond ) { sleep impl ( millisecond , null ) ; }
public boolean get remove abandon on maintenance ( ) { return abandon config == null ? false : abandon config . get remove abandon on maintenance ( ) ; }
public boolean be boolean ( ) { return false ; }
public long count ( ) { return count . get ( ) ; }
public synchronize void set eviction policy class name ( final string eviction policy class name ) { if ( connection pool ! = null ) { connection pool . set eviction policy class name ( eviction policy class name ) ; } this . eviction policy class name = eviction policy class name ; }
public synchronize void set max total ( final int max total ) { this . max total = max total ; if ( connection pool ! = null ) { connection pool . set max total ( max total ) ; } }
public enumeration < test > test ( ) { return f test . element ( ) ; }
public long eviction count ( ) { return eviction count ; }
public void set object factory ( object factory object factory ) { this . object factory = object factory ; }
public boolean contains key ( int key ) { entry tab [ ] = table ; int hash = key ; int index = ( hash & 0x7 f f f f f f f ) % tab . length ; for ( entry e = tab [ index ] ; e ! = null ; e = e . next ) { if ( e . hash == hash ) { return true ; } } return false ; }
public < t > t get object ( ) { return ( t ) object ; }
public string lookup system property string lookup ( ) { return system property string lookup . instance ; }
public locale get locale ( ) { return locale ; }
public void set flush on every block ( boolean flush on every block ) { this . flush on every block = flush on every block ; }
public string get ssl common name ( ) { return ssl common name ; }
public syntax parser get syntax parser ( ) { return this . syntax parser ; }
public string get miss ( ) { return this . miss ; } // -- string get missing ( )
public string get comment ( ) { return comment ; }
public string get path ( ) { return path ; }
public < t extend multi build item > list < t > consume multi ( class < t > type ) { final item id item id = new item id ( type ) ; @ suppress warning ( `` unchecked `` ) final list < t > item = ( list < t > ) ( list ) multi item . get ( item id ) ; if ( item == null ) { return collection . empty list ( ) ; } return new array list < > ( item ) ; }
public object invoke ( final object proxy , method method , object [ ] args ) throw throwable { if ( handle cache ! = null & & be default method ( method ) & & ! default overridden ( method ) ) { final v m plugin plugin = v m plugin factory . get plugin ( ) ; object handle = handle cache . compute if absent ( method , m - > plugin . get invoke special handle ( m , proxy ) ) ; return plugin . invoke handle ( handle , args ) ; } if ( ! check method ( method ) ) { try { if ( method . get declare class ( ) == groovy object . class ) { if ( `` get meta class `` . equal ( method . get name ( ) ) ) { return get meta class ( proxy ) ; } else if ( `` set meta class `` . equal ( method . get name ( ) ) ) { return set meta class ( ( meta class ) args [ 0 ] ) ; } } return invoke custom ( proxy , method , args ) ; } catch ( groovy runtime exception gre ) { throw script bytecode adapter . unwrap ( gre ) ; } } try { return method . invoke ( this , args ) ; } catch ( invocation target exception ite ) { throw ite . get target exception ( ) ; } }
public tag get tag ( ) { return this . tag ; }
public retry policy get retry policy ( ) { return retry policy ; }
public string get web master ( ) { return web master ; }
public string get path ( ) { return path ; }
public path [ ] index path ( index index ) { assert env be lock ( ) ; path [ ] index path = new path [ node path . length ] ; for ( int i = 0 ; i < node path . length ; i++ ) { index path [ i ] = node path [ i ] . resolve ( index ) ; } return index path ; }
public int leave ( int node ) { return leave [ node ] ; }
public void start ( ) throw exception { }
public synchronize order lock new lock ( ) { return new order lock ( this ) ; }
public void pause ( ) { write lock . lock ( ) ; try { be active = false ; } finally { write lock . unlock ( ) ; } }
public void set upper bound byte ( int upper bound bytes ) { this . upper bound bytes = upper bound byte ; }
public validation event handler get event handler ( ) throw j a x b exception { return event handler ; }
public sequence get sequence ( string sequence name ) { sequence sequence = sequence . get ( sequence name ) ; if ( sequence == null ) { throw db exception . get ( error code . sequence_not_found_1 , sequence name ) ; } return sequence ; }
public sequence get sequence ( string sequence name ) { sequence sequence = sequence . get ( sequence name ) ; if ( sequence == null ) { throw db exception . get ( error code . sequence_not_found_1 , sequence name ) ; } return sequence ; }
protect map create element index ( ) { map answer = create index ( ) ; return answer ; }
protect map create attribute index ( ) { map answer = create index ( ) ; return answer ; }
public static void replay ( object . . . mock ) { for ( object mock : mock ) { get control ( mock ) . replay ( ) ; } }
public static char and ( char first , char second ) { return mock progress . get argument matcher storage ( ) . report and ( ) . return char ( ) ; }
public static float not ( float first ) { last control . report not ( ) ; return first ; }
public static float and ( float first , float second ) { last control . report and ( 2 ) ; return 0 ; }
public static int eq ( int value ) { return report matcher ( new equal ( value ) ) . return zero ( ) ; }
public static double eq ( double value , double delta ) { return report matcher ( new equal with delta ( value , delta ) ) . return zero ( ) ; }
public static < t > t create nice mock ( class < t > to mock ) { return create nice control ( ) . create mock ( to mock ) ; }
public static void replay ( object . . . mock ) { for ( object mock : mock ) { get control ( mock ) . replay ( ) ; } }
public void set void callable ( int time ) { expect last call ( `` method call on the mock need before set void callable `` ) . time ( time ) ; }
public void set throwable ( throwable throwable , int time ) { expect last call ( `` method call on the mock need before set throwable `` ) . and throw ( throwable ) . time ( time ) ; }
public throwable get throwable ( ) { return throwable ; }
public throwable get throwable ( ) { return throwable ; }
public void set default value ( object default value ) { this . default value = default value ; }
public class < ? extend annotation > get parameter type ( ) { return parameter type ; }
public byte [ ] digest ( byte [ ] in ) { impl reset ( ) ; engine update ( in , 0 , in . length ) ; byte [ ] out = new byte [ 16 ] ; impl digest ( out , 0 ) ; return out ; }
public long get long ( ) { long ret = delegate . get long ( ) ; return ret ; }
public shard shard ( ) { return shard ; }
public void set server hostname ( final string hostname ) throw unknown host exception { set server address ( inet address . get by name ( hostname ) ) ; }
public static final string get command ( i m a p command command ) { return command . get i m a p command ( ) ; }
public setting get setting ( ) { return setting ; }
public method rout get method routing ( ) { return method routing ; }
public int get rout num shard ( ) { return rout num shard ; }
public deploy request set repository ( remote repository repository ) { this . repository = repository ; return this ; }
public long get max wait ( ) { return this . max wait ; }
public put index template request builder set setting ( string source , x content type x content type ) { request . setting ( source , x content type ) ; return this ; }
public string snapshot ( ) { return snapshot ; }
public void set partial ( boolean partial ) { this . partial = partial ; } // -- void set partial ( boolean )
protect void set alias ( string alias ) { this . alias = alias ; }
public string get index ( ) { return this . index ; }
public long get start time ( ) { return start time ; }
public int incremental file count ( ) { return incremental file count ; }
public list < doc write request < ? > > request ( ) { return this . request ; }
protect static double parse double ( x content parser parser , double default null value ) throw i o exception { token current token = parser . current token ( ) ; if ( current token == x content parser . token . value_number || current token == x content parser . token . value_string ) { return parser . double value ( ) ; } else { return default null value ; } }
public string get action ( ) { return action ; }
public static pre configure tokenizer singleton ( string name , supplier < tokenizer > create ) { return new pre configure tokenizer ( name , cache strategy . one , version - > create . get ( ) ) ; }
public list < shard rout > shard with state ( shard rout state . . . state ) { if ( state . length == 1 ) { if ( state [ 0 ] == shard rout state . initialize ) { return new array list < > ( initialize shard ) ; } else if ( state [ 0 ] == shard rout state . relocate ) { return new array list < > ( relocate shard ) ; } } list < shard rout > shard = new array list < > ( ) ; for ( shard rout shard entry : this ) { for ( shard rout state state : state ) { if ( shard entry . state ( ) == state ) { shard . add ( shard entry ) ; } } } return shard ; }
public final request wait for active shard ( active shard count wait for active shard ) { this . wait for active shard = wait for active shard ; return ( request ) this ; }
public long get name resolve at ( ) { return name resolve at ; }
public create index cluster state update request name resolve instant ( long name resolve at ) { this . name resolve at = name resolve at ; return this ; }
public void close data input stream ( ) throw i o exception { if ( this . data input stream ! = null ) { this . data input stream . close ( ) ; this . data input stream = null ; } }
public put index template request builder set setting ( string source , x content type x content type ) { request . setting ( source , x content type ) ; return this ; }
public put index template request builder set setting ( string source , x content type x content type ) { request . setting ( source , x content type ) ; return this ; }
public boolean be expunge ( ) { return expunge ; }
public string get index ( ) { return this . index ; }
public index concrete single index ( cluster state state , index request request ) { string index expression = collection utils . be empty ( request . index ( ) ) ? null : request . index ( ) [ 0 ] ; index [ ] index = concrete index ( state , request . index option ( ) , index expression ) ; if ( index . length ! = 1 ) { throw new illegal argument exception ( `` unable to return a single index a the index and option `` + `` provide get resolve to multiple index `` ) ; } return index [ 0 ] ; }
public put map request index ( string . . . index ) { this . index = index ; return this ; }
public void set type ( string type ) { this . type = type ; }
public void set group name ( string group name ) { this . group name = new string buffer ( group name ) ; }
public create snapshot request setting ( string source , x content type x content type ) { this . setting = setting . builder ( ) . load from source ( source , x content type ) . build ( ) ; return this ; }
public boolean be valid ( ) { return valid ; }
public self set retry backoff initial time ( time value retry backoff initial time ) { request . set retry backoff initial time ( retry backoff initial time ) ; return self ( ) ; }
protected item id get item id ( ) { return this . item id ; }
public string get type ( ) { return type ; }
public create index request mapping ( string type , string source , x content type x content type ) { return mapping ( type , new byte array ( source ) , x content type ) ; }
public void pause ( ) { write lock . lock ( ) ; try { be active = false ; } finally { write lock . unlock ( ) ; } }
public static transport request unwrap request ( transport request request ) { if ( request instanceof proxy request ) { return ( ( proxy request ) request ) . wrap ; } return request ; }
public result get result ( ) { return result ; }
public string get id ( ) { return this . id ; } // -- string get id ( )
public static string to string exclude ( object object , final string exclude field name ) { return to string exclude ( object , new string [ ] { exclude field name } ) ; }
public string get source ( ) { return source ; }
public list < pipeline configuration > pipeline ( ) { return collection . unmodifiable list ( pipeline ) ; }
public index request set pipeline ( string pipeline ) { this . pipeline = pipeline ; return this ; }
public str builder append ( char sequence seq ) { if ( seq == null ) { return append null ( ) ; } return append ( seq . to string ( ) ) ; }
public index request set pipeline ( string pipeline ) { this . pipeline = pipeline ; return this ; }
public item get item ( ) { return null ; }
public void set batch reduce size ( int batch reduce size ) { this . batch reduce size = batch reduce size ; }
public static void sort ( order . . . object ) { array . sort ( object , comparator ) ; }
public shard shard ( ) { return shard ; }
public shard shard ( ) { return shard ; }
public void set timeout ( int timeout ) { this . timeout = timeout ; }
public close index request builder set wait for active shard ( final active shard count wait for active shard ) { request . wait for active shard ( wait for active shard ) ; return this ; }
public rout node rout node ( ) { return rout node ; }
public void fail task ( final task attempt i d task id ) throw i o exception { kill task ( task id , true ) ; }
public boolean be failure ( ) { return be failure ; }
public static boolean be stream error ( http2 exception e ) { return e instanceof stream exception ; }
public field set < string > select field ( string . . . field names ) { return set field set ( new field name selector ( ) , field name ) ; }
public int get payload length ( ) { return last payload length ; }
public string get id ( ) { return id ; }
public void set primary ( boolean primary ) { this . primary = primary ; }
public update request doc ( bytes reference source , x content type content type ) { safe doc ( ) . source ( source , content type ) ; return this ; }
public update request doc ( object . . . source ) { safe doc ( ) . source ( source ) ; return this ; }
public void clear ( int index ) { if ( ( index < 0 ) || ( index > = size ( ) ) ) { return ; } clear bit ( index ) ; }
public transport client remove transport address ( transport address transport address ) { nodes service . remove transport address ( transport address ) ; return this ; }
public transport client add transport address ( transport address . . . transport address ) { nodes service . add transport address ( transport address ) ; return this ; }
public void set timeout ( int timeout ) { this . timeout = timeout ; }
public string [ ] get index ( ) { return index ; }
public index [ ] index ( ) { return index ; }
public object response ( ) { return response ; }
public shard shard ( ) { return shard ; }
public rout node rout node ( ) { return rout node ; }
public discovery node [ ] next possible master ( object container < discovery node > node , int number of possible master ) { list < discovery node > sort node = sort master node ( array . a list ( node . to array ( discovery node . class ) ) ) ; if ( sort node == null ) { return new discovery node [ 0 ] ; } list < discovery node > next possible master = new array list < > ( number of possible master ) ; int counter = 0 ; for ( discovery node next possible master : sort node ) { if ( ++counter > = number of possible master ) { break ; } next possible master . add ( next possible master ) ; } return next possible master . to array ( new discovery node [ next possible master . size ( ) ] ) ; }
public cluster state set and get observe state ( ) { if ( observe context . get ( ) ! = null ) { throw new elasticsearch exception ( `` can not set current cluster state while wait for a cluster state change `` ) ; } cluster state cluster state = cluster applier service . state ( ) ; last observed state . set ( new store state ( cluster state ) ) ; return cluster state ; }
public cluster state state ( ) { return cluster applier service . state ( ) ; }
public version get version ( ) { return version ; }
protect request map handler mapping create request map handler mapping ( ) { return new request mapping handler mapping ( ) ; }
public list < shard rout > shard with state ( shard rout state . . . state ) { if ( state . length == 1 ) { if ( state [ 0 ] == shard rout state . initialize ) { return new array list < > ( initialize shard ) ; } else if ( state [ 0 ] == shard rout state . relocate ) { return new array list < > ( relocate shard ) ; } } list < shard rout > shard = new array list < > ( ) ; for ( shard rout shard entry : this ) { for ( shard rout state state : state ) { if ( shard entry . state ( ) == state ) { shard . add ( shard entry ) ; } } } return shard ; }
public string index name ( ) { return index name ; }
public index [ ] index ( ) { return index ; }
protect void set alias ( string alias ) { this . alias = alias ; }
public shard shard ( ) { return shard ; }
public cluster state set and get observe state ( ) { if ( observe context . get ( ) ! = null ) { throw new elasticsearch exception ( `` can not set current cluster state while wait for a cluster state change `` ) ; } cluster state cluster state = cluster applier service . state ( ) ; last observed state . set ( new store state ( cluster state ) ) ; return cluster state ; }
public list < node > get node ( ) { return node ; }
public void set allocation size ( integer value ) { this . allocation size = value ; }
public string get allocation id ( ) { check decision state ( ) ; return allocation id ; }
public box watermark apply watermark ( ) { return this . apply watermark ( folder_info_url_template , box watermark . watermark_default_imprint ) ; }
public move decision get move decision ( ) { return move decision ; }
public static move decision stay ( decision can remain decision ) { if ( can remain decision ! = null ) { assert can remain decision . type ( ) ! = type . no ; return new move decision ( can remain decision , null , allocation decision . no_attempt , null , null , 0 ) ; } else { return cached_stay_decision ; } }
public static timing info start time full support ( long start time nano ) { return new time info full support ( null , start time nano , null ) ; }
public rout context rout context ( ) { return rout context ; }
public metadata get metadata ( ) { return metadata ; }
public static move decision stay ( decision can remain decision ) { if ( can remain decision ! = null ) { assert can remain decision . type ( ) ! = type . no ; return new move decision ( can remain decision , null , allocation decision . no_attempt , null , null , 0 ) ; } else { return cached_stay_decision ; } }
public shard shard ( ) { return shard ; }
public cluster state set and get observe state ( ) { if ( observe context . get ( ) ! = null ) { throw new elasticsearch exception ( `` can not set current cluster state while wait for a cluster state change `` ) ; } cluster state cluster state = cluster applier service . state ( ) ; last observed state . set ( new store state ( cluster state ) ) ; return cluster state ; }
public void put all ( map map ) { for ( object o : map . entry set ( ) ) { entry entry = ( entry ) o ; put ( entry . get key ( ) , entry . get value ( ) ) ; } }
public byte to byte ( ) { return new byte ( byte value ( ) ) ; }
public double get segment fraction ( ) { return segment fraction ; }
public void invalidate ( k key , v value ) { cache segment < k , v > segment = get cache segment ( key ) ; segment . remove ( key , value , invalidation consumer ) ; }
public static string get class file name ( class < ? > clazz ) { assert . not null ( clazz , `` class must not be null `` ) ; string class name = clazz . get name ( ) ; int last dot index = class name . last index of ( package_separator ) ; return class name . substring ( last dot index + 1 ) + class_file_suffix ; }
public iterator iterator ( ) { return new iterator ( ) ; }
public int [ ] get end point ( ) { return end point ; }
public list < polygon builder > polygon ( ) { return polygon ; }
public multi polygon builder polygon ( polygon builder polygon ) { polygon builder pb = new polygon builder ( new coordinate builder ( ) . coordinate ( polygon . shell ( ) . coordinate ( false ) ) , this . orientation ) ; for ( line string builder hole : polygon . hole ( ) ) { pb . hole ( hole ) ; } this . polygon . add ( pb ) ; return this ; }
public static final string string encode ( final double lon , final double lat ) { return string encode ( lon , lat , 12 ) ; }
public void write thin ( stream output out ) throw i o exception { super . write to ( out ) ; out . write v int ( byte . length ( ) ) ; }
public static double parse ( string distance , distance unit default unit , distance unit to ) { distance dist = distance . parse distance ( distance , default unit ) ; return convert ( dist . value , dist . unit , to ) ; }
public void set args ( string [ ] args ) { if ( args == null ) { args = new string [ ] { } ; } this . args = args ; this . args list = collection . unmodifiable list ( new array list < string > ( arrays . a list ( args ) ) ) ; }
public static boolean be empty ( string s ) { return s == null || s . length ( ) == 0 ; }
public input stream get input stream ( ) throw i o exception { if ( ! exists ( ) ) { throw new file not find exception ( get path ( ) + `` ( no such file or directory ) `` ) ; } if ( file . be directory ( this . path ) ) { throw new file not find exception ( get path ( ) + `` ( be a directory ) `` ) ; } return file . new input stream ( this . path ) ; }
protect output stream wrap stream ( output stream out ) throw i o exception { return new g z i p output stream ( out ) ; }
public final shard id get shard id ( ) { return shard id ; }
public static directory reader open ( final directory directory ) throw i o exception { return standard directory reader . open ( directory , null , default_terms_index_divisor ) ; }
public search source builder doc value field ( string name , @ nullable string format ) { if ( doc value field == null ) { doc value field = new array list < > ( ) ; } doc value field . add ( new field and format ( name , format ) ) ; return this ; }
public int get minimum number should match ( ) { return min nr should match ; }
public double double value ( ) { return value ; }
public int get column number ( ) { return this . column number ; } // -- int get column number ( )
protect void set delegate ( file configuration delegate delegate ) { this . delegate = delegate ; }
public setting get setting ( ) { return setting ; }
public string get private key ( ) { return private key ; }
public void set operator ( infix expression . operator operator ) { if ( operator == null ) { throw new illegal argument exception ( ) ; } pre value change ( operator_property ) ; this . operator = operator ; post value change ( operator_property ) ; }
public setting filter ( predicate < string > predicate ) { return new setting ( new filter map ( this . setting , predicate , null ) , secure setting == null ? null : new prefixed secure setting ( secure setting , `` `` , predicate ) ) ; }
public setting get setting ( ) { return setting ; }
public final boolean be secure ( settings setting ) { final secure setting secure setting = setting . get secure setting ( ) ; return secure setting ! = null & & secure setting . get set name ( ) . contains ( get key ( ) ) ; }
public float get x ( ) { return ( ( c o s number ) value . get ( 0 ) ) . float value ( ) ; }
public string dump topology ( ) { map < string , string > rack = get switch map ( ) ; string builder builder = new string builder ( ) ; builder . append ( `` mapping : `` ) . append ( to string ( ) ) . append ( `` \n `` ) ; if ( rack ! = null ) { builder . append ( `` map : \n `` ) ; set < string > switch = new hash set < string > ( ) ; for ( map . entry < string , string > entry : rack . entry set ( ) ) { builder . append ( `` `` ) . append ( entry . get key ( ) ) . append ( `` - > `` ) . append ( entry . get value ( ) ) . append ( `` \n `` ) ; switch . add ( entry . get value ( ) ) ; } builder . append ( `` node : `` ) . append ( rack . size ( ) ) . append ( `` \n `` ) ; builder . append ( `` switch : `` ) . append ( switch . size ( ) ) . append ( `` \n `` ) ; } else { builder . append ( `` no topology information `` ) ; } return builder . to string ( ) ; }
public date midnight plus week ( int week ) { if ( week == 0 ) { return this ; } long instant = get chronology ( ) . week ( ) . add ( get millis ( ) , week ) ; return with millis ( instant ) ; }
public static double distance ( geometry g0 , geometry g1 ) { distance op dist op = new distance op ( g0 , g1 ) ; return dist op . distance ( ) ; }
public void name ( string n ) { this . name = n ; }
public static void put float ( byte [ ] data , int offset , float value ) { put int ( data , offset , float . float to int bit ( value ) ) ; }
public void set hint ( string hint name , serializable value ) { hint . put ( hint name , value ) ; }
public boolean fast forward ( ) { assert original count > 0 ; assert count down . get ( ) > = 0 ; return count down . get and set ( 0 ) > 0 ; }
public boolean count down ( ) { assert original count > 0 ; for ( ; ; ) { final int current = count down . get ( ) ; assert current > = 0 ; if ( current == 0 ) { return false ; } if ( count down . compare and set ( current , current - 1 ) ) { return current == 1 ; } } }
public boolean be empty ( ) { return map . be empty ( ) ; }
public execution result execute ( execution input . builder execution input builder ) { return execute ( execution input builder . build ( ) ) ; }
public void execute ( final runnable command ) { delegate . execute ( command ) ; }
public boolean be random start ( ) { return random start ; }
public query option set refresh node interval millis ( int refresh node interval millis ) { this . refresh node interval millis = refresh node interval millis ; return this ; }
public static void set max validation error ( int max validation error ) { max_validation_errors = max validation error ; }
public user info success response to success response ( ) { return ( user info success response ) this ; }
public boolean local node master ( ) { return state . node ( ) . be local node elect master ( ) ; }
public synchronize state mark available ( ) { if ( map . be empty ( ) ) { state = state . idle ; } else { state = state . pending ; } return state ; }
public synchronize service thread pool ( int max thread ) { return thread pool ( max thread , -1 , -1 ) ; }
public path [ ] index path ( index index ) { assert env be lock ( ) ; path [ ] index path = new path [ node path . length ] ; for ( int i = 0 ; i < node path . length ; i++ ) { index path [ i ] = node path [ i ] . resolve ( index ) ; } return index path ; }
public shard shard ( ) { return shard ; }
public static path and node get path and node ( string path ) { path utils . validate path ( path ) ; int i = path . last index of ( path_separator ) ; if ( i < 0 ) { return new path and node ( path , `` `` ) ; } if ( ( i + 1 ) > = path . length ( ) ) { return new path and node ( path_separator , `` `` ) ; } string node = path . substring ( i + 1 ) ; string parent path = ( i > 0 ) ? path . substring ( 0 , i ) : path_separator ; return new path and node ( parent path , node ) ; }
public shard id shard id ( ) { return this . shard id ; }
public string get path ( ) { return path ; }
public final string get name ( ) { return name ; }
public analyze request builder set tokenizer ( string tokenizer ) { request . tokenizer ( tokenizer ) ; return this ; }
public string [ ] key a array ( ) { return map . key set ( ) . to array ( new string [ 0 ] ) ; }
public final void commit ( ) throw i o exception { ensure open ( ) ; commit internal ( ) ; }
public long get norms memory in byte ( ) { return this . norm memory in byte ; }
public long get term vector memory in byte ( ) { return this . term vector memory in byte ; }
public void close ( ) throw i o exception { }
public long get total time in millis ( ) { return this . total time in millis ; }
public final boolean be wildcard type ( ) { return ( this instanceof wildcard type ) ; }
public http server option set initial setting ( http2 setting setting ) { this . initial setting = setting ; return this ; }
public boolean be sync ( ) { return sync ; }
public long get total ( ) { return this . total ; }
public void set output threshold ( long threshold ) { this . threshold = threshold ; }
public field get field ( ) { return this . field ; }
public void set max idle ( int max idle ) { this . max idle = max idle ; }
public field get field ( ) { return field ; }
public context get context ( ) { return impl . get context ( ) ; }
public map field type build anonymous field type ( string type ) { if ( type . equal ( `` string `` ) ) { deprecation logger . deprecate ( deprecation category . mapping , `` unmapped_type_string `` , `` [ unmapped_type : string ] should be replace with [ unmapped_type : keyword ] `` ) ; type = `` keyword `` ; } map parser context parser context = mapper service . parser context ( ) ; mapper . type parser type parser = parser context . type parser ( type ) ; if ( type parser == null ) { throw new illegal argument exception ( `` no mapper find for type [ `` + type + `` ] `` ) ; } mapper . builder builder = type parser . parse ( `` __anonymous_ `` , collection . empty map ( ) , parser context ) ; mapper mapper = builder . build ( new content path ( 0 ) ) ; if ( mapper instanceof field mapper ) { return ( ( field mapper ) mapper ) . field type ( ) ; } throw new illegal argument exception ( `` mapper for type [ `` + type + `` ] must be a leaf field `` ) ; }
public boolean get auto read ( ) { return this . auto read ; }
public output < long > shape ( ) { return shape ; }
public query builder query ( ) { return query ; }
public void set update frequency ( final int update frequency ) { this . update frequency = update frequency ; }
public static have child query builder have child query ( string type , query builder query , score mode score mode ) { return new have child query builder ( type , query , score mode ) ; }
public float get boost ( ) { return boost ; }
public geo validation method get validation method ( ) { return this . validation method ; }
public string get field name ( ) { return field name ; }
public default double compute delta distance ( final distance style distance style , final geo point point ) { return compute delta distance ( distance style , point . x , point . y , point . z ) ; }
public geo validation method get validation method ( ) { return this . validation method ; }
public void set expansion mode ( int expansion mode ) { if ( expansion mode ! = multiplicative_mode & & expansion mode ! = additive_mode ) { throw math runtime exception . create illegal argument exception ( `` unsupported expansion mode { 0 } , support mode be { 1 } ( { 2 } ) and { 3 } ( { 4 } ) `` , expansion mode , multiplicative_mode , `` multiplicative_mode `` , additive_mode , `` additive_mode `` ) ; } synchronize ( this ) { this . expansion mode = expansion mode ; } }
public term [ ] get term ( ) { return term ; }
public void set doc freq ( long doc freq ) { this . doc freq = doc freq ; }
static public void fail ( ) { fail ( null ) ; }
public query builder query ( ) { return query ; }
public static match phrase query builder match phrase query ( string name , object text ) { return new match phrase query builder ( name , text ) ; }
public static match query builder match query ( string name , object text ) { return new match query builder ( name , text ) ; }
public field get field ( ) { return field ; }
public query builder query ( ) { return query ; }
public query builder query ( ) { return query ; }
public static function score query builder function score query ( query builder query builder ) { return new function score query builder ( query builder ) ; }
public output < long > shape ( ) { return shape ; }
public search source builder query ( query builder query ) { this . query builder = query ; return this ; }
public string get field name ( ) { return field name ; }
public mapper create mapper ( ) throw build exception { if ( mapper element ! = null ) { throw new build exception ( `` can not define more than one mapper `` , get location ( ) ) ; } mapper element = new mapper ( get project ( ) ) ; return mapper element ; }
public field get field ( ) { return this . field ; }
public simple query string builder field ( string field ) { if ( string . be empty ( field ) ) { throw new illegal argument exception ( `` supply field be null or empty `` ) ; } this . field and weight . put ( field , abstract query builder . default_boost ) ; return this ; }
public string get analyzer ( ) { return analyzer ; }
public void set lenient ( boolean lenient ) { this . lenient = lenient ; }
public long get total object ( ) { return statistic . total object ; }
public long get external total time in millis ( ) { return this . external total time in millis ; }
public long get total time in millis ( ) { return this . total time in millis ; }
public long get total time in millis ( ) { return this . total time in millis ; }
public static backoff policy exponential backoff ( ) { return exponential backoff ( time value . time value millis ( 50 ) , 8 ) ; }
public double get worker start ( ) { return worker start ; }
public int get size ( ) { return size ; }
public boolean get global ( ) { return m global ; }
public void set sequence number ( int sequence ) { f sequence number= sequence ; }
public restore snapshot request snapshot ( string snapshot ) { this . snapshot = snapshot ; return this ; }
public b set index file ( file index file ) { this . index file = index file ; return self ( ) ; }
public int get incremental file count ( ) { return incremental file count ; }
public list < file info > index file ( ) { return index file ; }
public file get directory ( ) { return directory ; }
protect translog . operation read ( buffer checksum stream input in stream ) throw i o exception { final translog . operation op = translog . read operation ( in stream ) ; if ( op . primary term ( ) > get primary term ( ) & & get primary term ( ) ! = sequence number . unassigned_primary_term ) { throw new translog corrupt exception ( path . to string ( ) , `` operation 's term be new than translog header term ; `` + `` operation term [ `` + op . primary term ( ) + `` ] , translog header term [ `` + get primary term ( ) + `` ] `` ) ; } return op ; }
public long if primary term ( ) { return if primary term ; }
public int get num generation ( ) { return num generation ; }
public long get total time in millis ( ) { return this . total time in millis ; }
public shard search failure [ ] get shard failure ( ) { return this . shard failure ; }
public executor get resolver executor ( ) { return default executor ; }
public index request set pipeline ( string pipeline ) { this . pipeline = pipeline ; return this ; }
public setting get setting ( ) { return setting ; }
public static cluster state filter custom for pre63 client ( cluster state cluster state ) { final cluster state . builder builder = cluster state . builder ( cluster state ) ; cluster state . custom ( ) . key it ( ) . for each remain ( name - > { if ( pre_6_3_cluster_customs_white_list . contains ( name ) == false ) { builder . remove custom ( name ) ; } } ) ; final metadata . builder meta builder = metadata . builder ( cluster state . metadata ( ) ) ; cluster state . metadata ( ) . custom ( ) . key it ( ) . for each remain ( name - > { if ( pre_6_3_metadata_customs_white_list . contains ( name ) == false ) { meta builder . remove custom ( name ) ; } } ) ; return builder . metadata ( meta builder ) . build ( ) ; }
public setting get setting ( ) { return setting ; }
public void set version ( final string version ) { this . version = version ; }
public void set plugins ( interceptor . . . plugins ) { this . plugins = plugins ; }
public license client license ( ) { return license client ; }
public boolean be compress ( ) { return compress parameter ! = null & & compress parameter . be compress ( ) ; }
public object response ( ) { return response ; }
public string uri ( ) { return uri ; }
public string raw string ( ) { return raw string ; }
public void set cors ( cors configuration cors ) { this . cors = cors ; }
public static script get script ( ) { script script = ( script ) axis property . new instance ( script . class ) ; log . debug ( `` axis . script : `` + script . get class ( ) . get name ( ) ) ; return script ; }
public string get string claim ( final string name , final lang tag lang tag ) { return lang tag == null ? get string claim ( name ) : get string claim ( name + ' # ' + lang tag ) ; }
public list < internal aggregation > copy result ( ) { return new array list < > ( get internal aggregation ( ) ) ; }
public int approximate cardinality ( ) { return cardinality ( ) ; }
public text string builder append separator ( final string separator ) { return append separator ( separator , null ) ; }
protect void assert valid bucket ( storage bucket bucket , string action ) throw service exception { if ( bucket == null || bucket . get name ( ) == null || bucket . get name ( ) . length ( ) == 0 ) { throw new service exception ( `` the action `` + action + `` can not be perform with an invalid bucket : `` + bucket ) ; } }
protect void after close ( ) throw i o exception { }
public final aggregator create ( aggregator parent , cardinality upper bound cardinality ) throw i o exception { return create internal ( parent , cardinality , this . metadata ) ; }
public void update transient interval ( long interval ) { _transient interval = interval ; }
public significant term aggregation builder min doc count ( long min doc count ) { if ( min doc count < 0 ) { throw new illegal argument exception ( `` [ min doc count ] must be great than or equal to 0 . find [ `` + min doc count + `` ] in [ `` + name + `` ] `` ) ; } bucket count threshold . set min doc count ( min doc count ) ; return this ; }
public shard shard ( ) { return shard ; }
public long min doc count ( ) { return min doc count ; }
public int shard size ( ) { return shard size ; }
public string get mode ( ) { return mode ; }
public x content builder to x content internal ( x content builder builder , params params ) throw i o exception { for ( aggregation aggregation : aggregation ) { aggregation . to x content ( builder , params ) ; } return builder ; }
public double [ ] get percentile ( ) { return percentile ; }
public list < delta < t > > get delta ( ) { collection . sort ( delta , delta comparator . instance ) ; return delta ; }
public double delta ( ) { return delta ; }
public integer get numeric precision ( ) { return numeric precision ; }
protect void determine compression mode ( ) { if ( file name pattern str . end with ( `` . gz `` ) ) { add info ( `` will use gz compression `` ) ; compression mode = compression mode . gz ; } else if ( file name pattern str . end with ( `` . zip `` ) ) { add info ( `` will use zip compression `` ) ; compression mode = compression mode . zip ; } else { add info ( `` no compression will be use `` ) ; compression mode = compression mode . none ; } }
public string get script ( ) { return script ; }
public function score query . score mode score mode ( ) { return this . score mode ; }
public static alias from x content ( x content parser parser ) throw i o exception { alias alias = new alias ( parser . current name ( ) ) ; string current field name = null ; x content parser . token token = parser . next token ( ) ; if ( token == null ) { throw new illegal argument exception ( `` no alias be specify `` ) ; } while ( ( token = parser . next token ( ) ) ! = x content parser . token . end_object ) { if ( token == x content parser . token . field_name ) { current field name = parser . current name ( ) ; } else if ( token == x content parser . token . start_object ) { if ( filter . match ( current field name , parser . get deprecation handler ( ) ) ) { map < string , object > filter = parser . map order ( ) ; alias . filter ( filter ) ; } } else if ( token == x content parser . token . value_string ) { if ( rout . match ( current field name , parser . get deprecation handler ( ) ) ) { alias . routing ( parser . text ( ) ) ; } else if ( index_routing . match ( current field name , parser . get deprecation handler ( ) ) ) { alias . index rout ( parser . text ( ) ) ; } else if ( search_routing . match ( current field name , parser . get deprecation handler ( ) ) ) { alias . search routing ( parser . text ( ) ) ; } } else if ( token == x content parser . token . value_boolean ) { if ( is_write_index . match ( current field name , parser . get deprecation handler ( ) ) ) { alias . write index ( parser . boolean value ( ) ) ; } else if ( is_hidden . match ( current field name , parser . get deprecation handler ( ) ) ) { alias . be hidden ( parser . boolean value ( ) ) ; } } } return alias ; }
public int size ( ) { return p ; }
public version get version ( ) { return version ; }
public type get type ( ) { if ( field type == null ) { field type = type . get return type ( get signature ( ) ) ; } return field type ; }
public query builder query ( ) { return query ; }
public query builder get query builder ( ) { return this . builder ; }
public static leaf reader empty reader ( final int max doc ) { return new leaf reader ( ) { final bit live doc = new bit . match no bit ( max doc ) ; public term term ( string field ) { return null ; } public numeric doc value get numeric doc value ( string field ) { return null ; } public binary doc value get binary doc value ( string field ) { return null ; } public sort doc value get sort doc value ( string field ) { return null ; } public sort numeric doc value get sort numeric doc value ( string field ) { return null ; } public sort set doc value get sort set doc value ( string field ) { return null ; } public numeric doc value get norm value ( string field ) { return null ; } public field infos get field info ( ) { return new field info ( new field info [ 0 ] ) ; } public bit get live doc ( ) { return this . live doc ; } public point value get point value ( string field name ) { return null ; } public void check integrity ( ) { } public field get term vector ( int doc i d ) { return null ; } public int num doc ( ) { return 0 ; } public int max doc ( ) { return max doc ; } public void document ( int doc i d , store field visitor visitor ) { } protect void do close ( ) { } public leaf meta data get meta data ( ) { return new leaf meta data ( version . late . major , version . late , null ) ; } public cache helper get core cache helper ( ) { return null ; } public cache helper get reader cache helper ( ) { return null ; } } ; }
protect weight create weight ( searcher searcher ) { throw new unsupported operation exception ( ) ; }
public string get name ( ) { return name ; }
public http client option set keep alive ( boolean keep alive ) { this . keep alive = keep alive ; return this ; }
public object get value ( ) { return value ; }
public query profiler get current query profiler ( ) { return query profilers . get ( query profilers . size ( ) - 1 ) ; }
public query profiler add query profiler ( ) { query profiler profiler = new query profiler ( ) ; searcher . set profiler ( profiler ) ; query profilers . add ( profiler ) ; return profiler ; }
public boolean be null string set ( ) { return null string ! = null ; }
public int get size ( ) { return size ; }
public object get ( ) { return value ; }
public string get remote ( ) { return remote ; }
protect string get final path ( abstract nestable property accessor pa , string nested path ) { if ( pa == this ) { return nest path ; } return nested path . substring ( property accessor utils . get last nested property separator index ( nest path ) + 1 ) ; }
public type get type ( ) { return type ; }
public string get mode ( ) { return mode ; }
public boolean get keep preview edits ( ) { return f track edits ; }
public int get min length ( ) { return min length ; }
public error get error ( ) { return this . error ; }
public boolean get global ( ) { return m global ; }
public void set max transaction id ( int max ) { this . max transaction id = max ; }
public index [ ] index ( ) { return index ; }
public int size ( ) { return count ; }
public void write to ( stream output out ) throw i o exception { out . write v int ( this . ordinal ( ) ) ; }
public int size ( ) { return size ; }
public void set network connection info ( network connection info network connection info ) { this . network connection info = network connection info ; }
public static boolean be proxy request ( transport request request ) { return request instanceof proxy request ; }
public static transport request unwrap request ( transport request request ) { if ( request instanceof proxy request ) { return ( ( proxy request ) request ) . wrap ; } return request ; }
public t get incoming object ( ) { return incoming ; }
public transport . connection get connection ( discovery node node ) { if ( be local node ( node ) ) { return local node connection ; } else { return connection manager . get connection ( node ) ; } }
public transport . connection open connection ( final discovery node node , connection profile connection profile ) { return plain action future . get ( fut - > open connection ( node , connection profile , fut ) ) ; }
public void add listener ( run listener listener ) { f listener . add ( listener ) ; }
public void remove listener ( final configuration listener listener ) { listener . remove ( listener ) ; }
public terminal node create terminal node ( parser rule context parent , token t ) { return new terminal node impl ( t ) ; }
public str builder append ( char [ ] char ) { if ( char == null ) { return append null ( ) ; } int str len = char . length ; if ( str len > 0 ) { int len = length ( ) ; ensure capacity ( len + str len ) ; system . arraycopy ( char , 0 , buffer , len , str len ) ; size += str len ; } return this ; }
public static boolean equal ( object a , object b ) { return a == b || ( a ! = null & & a . equal ( b ) ) ; }
protect socket get socket ( ) { return this . socket ; }
public static < k , v > link hash map < k , v > of ( k k1 , v v1 , k k2 , v v2 ) { final hash map < k , v > map = hash map . of ( k1 , v1 , k2 , v2 ) ; final queue < tuple2 < k , v > > list = queue . of ( tuple . of ( k1 , v1 ) , tuple . of ( k2 , v2 ) ) ; return new link hash map < > ( list , map ) ; }
public static i file system get local file system ( ) { return internal file system core . get instance ( ) . get local file system ( ) ; }
public part builder part ( string name , object part ) { return part ( name , part , null ) ; }
public static < t extend real field element < t > > field vector3 d < t > cross product ( final field vector3 d < t > v1 , final field vector3 d < t > v2 ) { return v1 . cross product ( v2 ) ; }
public int hash code ( ) { int hash = lang utils . hash_seed ; hash = lang utils . hash code ( hash , this . user name ) ; hash = lang utils . hash code ( hash , this . password ) ; return hash ; }
public boolean point in bound ( double lon , double lat ) { if ( lat > = bottom ( ) & & lat < = top ( ) ) { if ( left ( ) < = right ( ) ) { return lon > = leave ( ) & & lon < = right ( ) ; } else { return lon > = leave ( ) || lon < = right ( ) ; } } return false ; }
public static int precision from threshold ( long count ) { final long hash table entry = ( long ) math . ceil ( count / max_load_factor ) ; int precision = pack ints . bit require ( hash table entry * integer . byte ) ; precision = math . max ( precision , abstract hyper log log . min_precision ) ; precision = math . min ( precision , abstract hyper log log . max_precision ) ; return precision ; }
public string get host ( ) { return host ; }
public header [ ] get request header ( ) { return get request header group ( ) . get all header ( ) ; }
public option descriptor get option ( ) { return impl . get option ( ) ; }
public double get min ( ) { return min impl . get result ( ) ; }
public boolean partial ( ) { return partial ; }
public void set batch reduce size ( int batch reduce size ) { if ( batch reduce size < = 1 ) { throw new illegal argument exception ( `` batch reduce size must be > = 2 `` ) ; } this . batch reduce size = batch reduce size ; }
public void set request cache ( server request cache request cache ) { assert . not null ( request cache , `` request cache can not be null `` ) ; this . request cache = request cache ; }
public cancellable get async ( get async search request request , request option option , action listener < async search response > listener ) { return rest high level client . perform request async and parse entity ( request , async search request converter : : get async search , option , async search response : : from x content , listener , empty set ( ) ) ; }
public cancellable submit async ( submit async search request request , request option option , action listener < async search response > listener ) { return rest high level client . perform request async and parse entity ( request , async search request converter : : submit async search , option , async search response : : from x content , listener , empty set ( ) ) ; }
public acknowledge response delete filter ( delete filter request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : delete filter , option , acknowledge response : : from x content , collection . empty set ( ) ) ; }
public acknowledge response put component template ( put component template request put component template request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( put component template request , cluster request converter : : put component template , option , acknowledge response : : from x content , empty set ( ) ) ; }
public get component template response get component template ( get component template request get component template request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( get component template request , cluster request converter : : get component template , option , get component template response : : from x content , empty set ( ) ) ; }
public acknowledge response put component template ( put component template request put component template request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( put component template request , cluster request converter : : put component template , option , acknowledge response : : from x content , empty set ( ) ) ; }
public int shard size ( ) { return shard size ; }
public long count ( ) { return count . get ( ) ; }
public synchronize long get millis ( ) { return millis == null ? -1l : millis . long value ( ) ; }
public final get response get ( get request get request , request option option ) throw i o exception { return perform request and parse entity ( get request , request converter : : get , option , get response : : from x content , singleton ( 404 ) ) ; }
public cancellable delete component template async ( delete component template request request , request option option , action listener < acknowledge response > listener ) { return rest high level client . perform request async and parse entity ( request , cluster request converter : : delete component template , option , acknowledge response : : from x content , listener , empty set ( ) ) ; }
public cancellable get s l m status async ( snapshot lifecycle management status request request , request option option , action listener < lifecycle management status response > listener ) { return rest high level client . perform request async and parse entity ( request , index lifecycle request converter : : snapshot lifecycle management status , option , lifecycle management status response : : from x content , listener , empty set ( ) ) ; }
public acknowledge response delete filter ( delete filter request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : delete filter , option , acknowledge response : : from x content , collection . empty set ( ) ) ; }
public cancellable explain lifecycle async ( explain lifecycle request request , request option option , action listener < explain lifecycle response > listener ) { return rest high level client . perform request async and parse entity ( request , index lifecycle request converter : : explain lifecycle , option , explain lifecycle response : : from x content , listener , empty set ( ) ) ; }
public static string normalize ( string name ) { if ( system reader . get instance ( ) . be mac o s ( ) ) { if ( name == null ) return null ; return normalizer . normalize ( name , normalizer . form . nfc ) ; } return name ; }
public final request wait for active shard ( active shard count wait for active shard ) { this . wait for active shard = wait for active shard ; return ( request ) this ; }
public throwable get cause ( ) { return cause ; }
public index get index ( string name ) { index index = index . get ( name ) ; if ( index == null ) { throw db exception . get ( error code . index_not_found_1 , name ) ; } return index ; }
public template [ ] get template ( ) { return get template ( null ) ; }
public string get index ( ) { return this . index ; }
public string data stream name ( ) { return data stream name ; }
public boolean disable user ( disable user request request , request option option ) throw i o exception { return rest high level client . perform request ( request , security request converter : : disable user , option , rest high level client : : convert exist response , empty set ( ) ) ; }
public final get response get ( get request get request , request option option ) throw i o exception { return perform request and parse entity ( get request , request converter : : get , option , get response : : from x content , singleton ( 404 ) ) ; }
public cancellable start i l m async ( start i l m request request , request option option , action listener < acknowledge response > listener ) { return rest high level client . perform request async and parse entity ( request , index lifecycle request converter : : start i l m , option , acknowledge response : : from x content , listener , empty set ( ) ) ; }
public final get response get ( get request get request , request option option ) throw i o exception { return perform request and parse entity ( get request , request converter : : get , option , get response : : from x content , singleton ( 404 ) ) ; }
public open job response open job ( open job request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : open job , option , open job response : : from x content , collection . empty set ( ) ) ; }
public cancellable get job async ( get job request request , request option option , action listener < get job response > listener ) { return rest high level client . perform request async and parse entity ( request , m l request converter : : get job , option , get job response : : from x content , listener , collection . empty set ( ) ) ; }
public list < string > get datafeed id ( ) { return datafeed id ; }
public cancellable get data stream async ( get data stream request data stream request , request option option , action listener < get data stream response > listener ) { return rest high level client . perform request async and parse entity ( data stream request , indices request converter : : get data stream , option , get data stream response : : from x content , listener , empty set ( ) ) ; }
public acknowledge response delete filter ( delete filter request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : delete filter , option , acknowledge response : : from x content , collection . empty set ( ) ) ; }
public acknowledge response delete filter ( delete filter request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : delete filter , option , acknowledge response : : from x content , collection . empty set ( ) ) ; }
public acknowledge response delete calendar ( delete calendar request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : delete calendar , option , acknowledge response : : from x content , collection . empty set ( ) ) ; }
public stop data frame analytics response stop data frame analytics ( stop data frame analytics request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : stop data frame analytics , option , stop data frame analytics response : : from x content , collection . empty set ( ) ) ; }
public put data frame analytics response update data frame analytics ( update data frame analytics request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : update data frame analytics , option , put data frame analytics response : : from x content , collection . empty set ( ) ) ; }
public put data frame analytics response update data frame analytics ( update data frame analytics request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : update data frame analytics , option , put data frame analytics response : : from x content , collection . empty set ( ) ) ; }
public cancellable evaluate data frame async ( evaluate data frame request request , request option option , action listener < evaluate data frame response > listener ) { return rest high level client . perform request async and parse entity ( request , m l request converter : : evaluate data frame , option , evaluate data frame response : : from x content , listener , collection . empty set ( ) ) ; }
public evaluate data frame response evaluate data frame ( evaluate data frame request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : evaluate data frame , option , evaluate data frame response : : from x content , collection . empty set ( ) ) ; }
public t with delay ( delay delay ) { this . delay = delay ; return ( t ) this ; }
public void set force ( boolean b ) { force = b ; }
public void flush ( ) throw i o exception { out . flush ( ) ; }
public io . vertx . reactivex . mqtt . mqtt endpoint publish acknowledge handler ( handler < integer > handler ) { delegate . publish acknowledge handler ( handler ) ; return this ; }
public function score query . score mode score mode ( ) { return this . score mode ; }
public void set category ( final list < category > category ) { this . category = category ; }
public int get from int ( ) { return get from ( ) ; }
public boolean fallback match allow ( ) { return false ; }
public transport client add transport address ( transport address . . . transport address ) { nodes service . add transport address ( transport address ) ; return this ; }
public void set job id ( string job id ) { this . job id = object . require non null ( job id , `` [ job_id ] must not be null `` ) ; }
public void set job id ( string job id ) { this . job id = object . require non null ( job id , `` [ job_id ] must not be null `` ) ; }
public cancellable get datafeed async ( get datafeed request request , request option option , action listener < get datafeed response > listener ) { return rest high level client . perform request async and parse entity ( request , m l request converter : : get datafeed , option , get datafeed response : : from x content , listener , collection . empty set ( ) ) ; }
public void stop ( ) { stop ( true ) ; }
public void visit item ( object item ) { item . add ( item ) ; }
public string get client id ( ) { return client id ; }
public boolean be license ( ) { return be license ; }
public final get response get ( get request get request , request option option ) throw i o exception { return perform request and parse entity ( get request , request converter : : get , option , get response : : from x content , singleton ( 404 ) ) ; }
public acknowledge response delete filter ( delete filter request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : delete filter , option , acknowledge response : : from x content , collection . empty set ( ) ) ; }
public cancellable start i l m async ( start i l m request request , request option option , action listener < acknowledge response > listener ) { return rest high level client . perform request async and parse entity ( request , index lifecycle request converter : : start i l m , option , acknowledge response : : from x content , listener , empty set ( ) ) ; }
public cancellable delete repository async ( delete repository request delete repository request , request option option , action listener < acknowledge response > listener ) { return rest high level client . perform request async and parse entity ( delete repository request , snapshot request converter : : delete repository , option , acknowledge response : : from x content , listener , empty set ( ) ) ; }
public final get response get ( get request get request , request option option ) throw i o exception { return perform request and parse entity ( get request , request converter : : get , option , get response : : from x content , singleton ( 404 ) ) ; }
public set < string > get privilege ( ) { return this . privilege ; }
public static get api key request use realm and user name ( string realm name , string user name ) { return new get api key request ( realm name , user name , null , null , false ) ; }
public static get api key request use realm name ( string realm name ) { return new get api key request ( realm name , null , null , null , false ) ; }
protect void index node ( node node ) { list < node > nod = node name to node . get ( node . get x path node name ( ) ) ; if ( node ! = null ) { node . add ( node ) ; } }
public boolean be find ( final string privilege ) { return privilege . contains ( privilege ) ; }
public final cancellable delete async ( delete request delete request , request option option , action listener < delete response > listener ) { return perform request async and parse entity ( delete request , request converter : : delete , option , delete response : : from x content , listener , collection . singleton ( 404 ) ) ; }
public boolean exists ( get index request request , request option option ) throw i o exception { return rest high level client . perform request ( request , indices request converter : : index exist , option , rest high level client : : convert exist response , collection . empty set ( ) ) ; }
public boolean be pre authenticate ( ) { return pre authenticate ; }
public create api key response create api key ( final create api key request request , final request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , security request converter : : create api key , option , create api key response : : from x content , empty set ( ) ) ; }
public void set certificate ( boolean certificate ) { this . certificate = certificate ; }
public cancellable start i l m async ( start i l m request request , request option option , action listener < acknowledge response > listener ) { return rest high level client . perform request async and parse entity ( request , index lifecycle request converter : : start i l m , option , acknowledge response : : from x content , listener , empty set ( ) ) ; }
public cancellable clear api key cache async ( clear api key cache request request , request option option , action listener < clear security cache response > listener ) { return rest high level client . perform request async and parse entity ( request , security request converter : : clear api key cache , option , clear security cache response : : from x content , listener , empty set ( ) ) ; }
public cancellable delete repository async ( delete repository request delete repository request , request option option , action listener < acknowledge response > listener ) { return rest high level client . perform request async and parse entity ( delete repository request , snapshot request converter : : delete repository , option , acknowledge response : : from x content , listener , empty set ( ) ) ; }
public acknowledge response create repository ( put repository request put repository request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( put repository request , snapshot request converter : : create repository , option , acknowledge response : : from x content , empty set ( ) ) ; }
public cancellable get job async ( get job request request , request option option , action listener < get job response > listener ) { return rest high level client . perform request async and parse entity ( request , m l request converter : : get job , option , get job response : : from x content , listener , collection . empty set ( ) ) ; }
public restore snapshot request snapshot ( string snapshot ) { this . snapshot = snapshot ; return this ; }
public cancellable start i l m async ( start i l m request request , request option option , action listener < acknowledge response > listener ) { return rest high level client . perform request async and parse entity ( request , index lifecycle request converter : : start i l m , option , acknowledge response : : from x content , listener , empty set ( ) ) ; }
public final get response get ( get request get request , request option option ) throw i o exception { return perform request and parse entity ( get request , request converter : : get , option , get response : : from x content , singleton ( 404 ) ) ; }
public boolean be active ( ) { return this . active ; }
public delete watch response delete watch ( delete watch request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , watcher request converter : : delete watch , option , delete watch response : : from x content , singleton ( 404 ) ) ; }
public final cancellable delete async ( delete request delete request , request option option , action listener < delete response > listener ) { return perform request async and parse entity ( delete request , request converter : : delete , option , delete response : : from x content , listener , collection . singleton ( 404 ) ) ; }
public delete watch response delete watch ( delete watch request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , watcher request converter : : delete watch , option , delete watch response : : from x content , singleton ( 404 ) ) ; }
public cancellable start i l m async ( start i l m request request , request option option , action listener < acknowledge response > listener ) { return rest high level client . perform request async and parse entity ( request , index lifecycle request converter : : start i l m , option , acknowledge response : : from x content , listener , empty set ( ) ) ; }
public void set human presentable name ( string human presentable name ) { this . human presentable name = human presentable name ; }
protect void write ( final byte [ ] bytes , final int offset , final int length ) { write byte ( byte , offset , length ) ; }
public optional < symbol resolver > get symbol resolver ( ) { return optional . of nullable ( symbol resolver ) ; }
public double double value ( ) { return value ; }
public error get error ( ) { return this . error ; }
public void set input ( string input ) { this . input = input ; }
public charset get charset ( ) { return this . charset ; }
public int get buffer size ( ) { return this . binary buffer size ; }
public object clone ( ) { xml test result = new xml test ( get suite ( ) ) ; result . set name ( get name ( ) ) ; result . set include group ( get include group ( ) ) ; result . set exclude group ( get exclude group ( ) ) ; result . set j unit ( be j unit ( ) ) ; result . set parallel ( get parallel ( ) ) ; result . set verbose ( get verbose ( ) ) ; result . set parameter ( get local parameter ( ) ) ; result . set xml package ( get xml package ( ) ) ; result . set time out ( get time out ( ) ) ; map < string , list < string > > metagroups = get meta group ( ) ; for ( map . entry < string , list < string > > group : metagroups . entry set ( ) ) { result . add meta group ( group . get key ( ) , group . get value ( ) ) ; } return result ; }
public fluent wait < t > with timeout ( long duration , time unit unit ) { return with timeout ( duration . of ( duration , to chrono unit ( unit ) ) ) ; }
public int failure count ( ) { return result . get failure ( ) . size ( ) ; }
public void check cancel ( ) { if ( this . monitor ! = null & & this . monitor . be cancel ( ) ) throw new operation cancel exception ( ) ; }
public static double get double ( byte [ ] data ) { return double . long bit to double ( get long ( data , 0 ) ) ; }
public void set auto compaction factor ( float factor ) { if ( factor < 0 ) { throw new illegal argument exception ( `` factor must be > = 0 : `` + factor ) ; } _auto compaction factor = factor ; }
public final void set cache second ( int second ) { this . cache second = second ; }
public int get offset ( ) { return offset ; }
public symbol reference < ? extend resolve value declaration > solve symbol in type ( resolve type declaration type declaration , string name ) { if ( type declaration instanceof java parser class declaration ) { context ctx = ( ( java parser class declaration ) type declaration ) . get context ( ) ; return ctx . solve symbol ( name ) ; } if ( type declaration instanceof java parser interface declaration ) { context ctx = ( ( java parser interface declaration ) type declaration ) . get context ( ) ; return ctx . solve symbol ( name ) ; } if ( type declaration instanceof java parser enum declaration ) { context ctx = ( ( java parser enum declaration ) type declaration ) . get context ( ) ; return ctx . solve symbol ( name ) ; } if ( type declaration instanceof reflection class declaration ) { return ( ( reflection class declaration ) type declaration ) . solve symbol ( name , type solver ) ; } if ( type declaration instanceof reflection interface declaration ) { return ( ( reflection interface declaration ) type declaration ) . solve symbol ( name , type solver ) ; } if ( type declaration instanceof reflection enum declaration ) { resolve enum constant declaration red = ( ( reflection enum declaration ) type declaration ) . get enum constant ( name ) ; return symbol reference . solve ( red ) ; } if ( type declaration instanceof javassist class declaration ) { return ( ( javassist class declaration ) type declaration ) . solve symbol ( name , type solver ) ; } if ( type declaration instanceof javassist enum declaration ) { return ( ( javassist enum declaration ) type declaration ) . solve symbol ( name , type solver ) ; } if ( type declaration instanceof javassist interface declaration ) { return ( ( javassist interface declaration ) type declaration ) . solve symbol ( name , type solver ) ; } return symbol reference . unsolved ( resolve value declaration . class ) ; }
public void set object name ( structure q name q name ) { object name = q name ; }
public string get id ( ) { return id ; }
public string get name ( ) { return name ; }
public java type qualify name get qualify name ( ) { return qualify name ; }
public boolean contains ( int integer ) { for ( int i=0 ; i < size ; i++ ) { if ( data [ i ] ==integer ) { return true ; } } return false ; }
public int get ( int i ) { int n = interval . size ( ) ; int index = 0 ; for ( int j = 0 ; j < n ; j++ ) { interval i = interval . get ( j ) ; int a = i . a ; int b = i . b ; for ( int v=a ; v < =b ; v++ ) { if ( index==i ) { return v ; } index++ ; } } return -1 ; }
public void add element ( long index , final boolean a [ ] [ ] , long offset , long length ) { ensure index ( index ) ; boolean big array . ensure offset length ( a , offset , length ) ; while ( length -- ! = 0 ) add ( index++ , boolean big array . get ( a , offset++ ) ) ; }
public static void ensure offset length ( final long big array length , final long offset , final long length ) { if ( offset < 0 ) throw new array index out of bound exception ( `` offset ( `` + offset + `` ) be negative `` ) ; if ( length < 0 ) throw new illegal argument exception ( `` length ( `` + length + `` ) be negative `` ) ; if ( offset + length > big array length ) throw new array index out of bound exception ( `` last index ( `` + ( offset + length ) + `` ) be great than big-array length ( `` + big array length + `` ) `` ) ; }
public boolean have next ( ) { return next index ( ) > = 0 ; }
public static boolean be empty ( object [ ] array ) { return ( array == null || array . length == 0 ) ; }
public static void ensure from to ( final boolean [ ] [ ] a , final long from , final long to ) { big array . ensure from to ( length ( a ) , from , to ) ; }
public static void quick sort ( final boolean [ ] x ) { quick sort ( x , 0 , x . length ) ; }
public static void quick sort ( final boolean [ ] x , final boolean comparator comp ) { quick sort ( x , 0 , x . length , comp ) ; }
public static boolean be empty ( object [ ] array ) { return ( array == null || array . length == 0 ) ; }
public static void ensure from to ( final boolean [ ] a , final int from , final int to ) { array . ensure from to ( a . length , from , to ) ; }
public list < big integer > get big integer list ( string key ) { return get big integer list ( key , new array list < big integer > ( ) ) ; }
public boolean be singleton ( ) { return false ; }
public void set rich text ( c o s string rv ) { field . set item ( c o s name . rv , rv ) ; }
protect < t > t get default strategy ( application context context , class < t > strategy interface ) { list < t > strategy = get default strategy ( context , strategy interface ) ; if ( strategy . size ( ) ! = 1 ) { throw new bean initialization exception ( `` dispatcher servlet need exactly 1 strategy for interface [ `` + strategy interface . get name ( ) + `` ] `` ) ; } return strategy . get ( 0 ) ; }
public static < k > byte get byte value ( final map < ? super k , ? > map , final k key ) { final byte byte object = get byte ( map , key ) ; if ( byte object == null ) { return 0 ; } return byte object . byte value ( ) ; }
public int get index ( ) { return index ; }
public void remove char at ( int index ) { if ( index < 0 || index > use ) { throw new index out of bound exception ( `` `` +index ) ; } use -- ; system . arraycopy ( array , index + 1 , array , index , use - index ) ; }
static public string byte to string ( byte [ ] binary data ) { if ( binary data == null ) return null ; return new string ( encode ( binary data ) ) ; }
public static void radix sort ( final byte [ ] [ ] a ) { radix sort ( a , 0 , a [ 0 ] . length ) ; }
public static void radix sort ( final byte [ ] [ ] a ) { radix sort ( a , 0 , byte big array . length ( a ) ) ; }
public static void radix sort ( final byte [ ] [ ] a ) { radix sort ( a , 0 , a [ 0 ] . length ) ; }
public abstract byte list part from to ( int from , int to ) { check range from to ( from , to , size ) ; int length = to - from + 1 ; byte array list part = new byte array list ( length ) ; part . add all of from to ( this , from , to ) ; return part ; }
public static < k > indirect priority queue < k > synchronize ( final indirect priority queue < k > q ) { return new synchronize indirect priority queue < k > ( q ) ; }
public void set subsampling x ( int s x ) { this . subsampling x = s x ; }
public static byte priority queue synchronize ( final byte priority queue q , final object sync ) { return new synchronize priority queue ( q , sync ) ; }
public static void store booleans ( final boolean array [ ] [ ] , final data output data output ) throw i o exception { for ( int i = 0 ; i < array . length ; i++ ) { final boolean [ ] t = array [ i ] ; final int l = t . length ; for ( int d = 0 ; d < l ; d++ ) data output . write boolean ( t [ d ] ) ; } }
public string get filename ( ) { return this . file . get name ( ) ; }
public static void store booleans ( final boolean array [ ] , final int offset , final int length , final data output data output ) throw i o exception { it . unimi . dsi . fastutil . booleans . boolean array . ensure offset length ( array , offset , length ) ; for ( int i = 0 ; i < length ; i++ ) data output . write boolean ( array [ offset + i ] ) ; }
public static int read ( final file file , final byte [ ] array ) throw i o exception { try ( file input stream input stream = new file input stream ( file ) ) { return read fully ( input stream , array , 0 , array . length ) ; } }
public boolean contains key ( k k ) { return ! get ( k ) . be empty ( ) ; }
public boolean contains key ( k k ) { return ! get ( k ) . be empty ( ) ; }
static public boolean be unicode enable ( ) { return unicode enable ; }
public void add sampler ( g sampler s ) { sampler . add ( s ) ; s . set publisher ( new g metric publisher ( gmetric ) ) ; }
public void start ( ) { scheduler . on start ( ) ; log . info ( `` set up `` + sampler . size ( ) + `` sampler `` ) ; for ( g sampler s : sampler ) { scheduler . schedule at fix rate ( s , s . get initial delay ( ) , s . get delay ( ) , time unit . second ) ; } }
public static builder builder ( ) { return new builder ( ) ; }
public injector create injector ( ) { return create injector ( list . < module > new array list ( ) ) ; }
public injector create injector ( ) { return create injector ( list . < module > new array list ( ) ) ; }
public injector create child injector ( module . . . module ) { return create child injector ( arrays . a list ( module ) ) ; }
protect web exchange data binder init data binder ( web exchange data binder binder , server web exchange exchange ) { return binder ; }
public void remove lifecycle listener ( string type ) throw m bean exception { container container = do get manage resource ( ) ; lifecycle listener [ ] listener = container . find lifecycle listener ( ) ; for ( lifecycle listener listener : listener ) { if ( listener . get class ( ) . get name ( ) . equal ( type ) ) { container . remove lifecycle listener ( listener ) ; } } }
public byte [ ] element ( ) { return element ; }
public static set < dependency < ? > > for injection point ( set < injection point > injection point ) { list < dependency < ? > > dependencies = list . new array list ( ) ; for ( injection point injection point : injection point ) { dependency . add all ( injection point . get dependency ( ) ) ; } return immutable set . copy of ( dependency ) ; }
public string get action ( ) { return action ; }
public string get data type ( ) { return data type ; }
public static grakn tx operation exception transaction read only ( grakn tx tx ) { return create ( error message . transaction_read_only . get message ( tx . keyspace ( ) ) ) ; }
public static grakn tx operation exception transaction invalid ( object tx ) { return create ( `` unknown type of transaction [ `` + tx + `` ] `` ) ; }
public static grakn tx operation exception transaction read only ( grakn tx tx ) { return create ( error message . transaction_read_only . get message ( tx . keyspace ( ) ) ) ; }
public static aggregate < value > std ( string var ) { return aggregate . std ( graql . var ( var ) ) ; }
public static aggregate < value > median ( string var ) { return aggregate . median ( graql . var ( var ) ) ; }
protect void set cost ( double cost ) { this . cost = cost ; }
public final query get query ( ) { return query ; }
public static reasoner query impl create ( conjunction < var pattern admin > pattern , embed grakn tx < ? > tx ) { reasoner query impl query = new reasoner query impl ( pattern , tx ) . infer type ( ) ; return query . be atomic ( ) ? new reasoner atomic query ( query . get atom ( ) , tx ) : query ; }
public static string get rule ( ) { string rule string = null ; if ( rule ! = null ) { string builder sb = new string builder ( ) ; for ( rule rule : rule ) { sb . append ( rule . to string ( ) ) . append ( `` \n `` ) ; } rule string = sb . to string ( ) . trim ( ) ; } return rule string ; }
public object get data ( ) { return data ; }
public static string get rule ( ) { string rule string = null ; if ( rule ! = null ) { string builder sb = new string builder ( ) ; for ( rule rule : rule ) { sb . append ( rule . to string ( ) ) . append ( `` \n `` ) ; } rule string = sb . to string ( ) . trim ( ) ; } return rule string ; }
public int get attribute type ( ) { return type ; }
public matcher < ? super type literal < ? > > get type matcher ( ) { return type matcher ; }
public static builder build ( ) { return new builder ( ) ; }
protect void check key ( final multi key < ? > key ) { if ( key == null ) { throw new null pointer exception ( `` key must not be null `` ) ; } }
public void set max memory ( long max memory ) { data utils . check argument ( max memory > 0 , `` max memory must be large than 0 , be { 0 } `` , max memory ) ; this . max memory = max memory ; if ( segment ! = null ) { long max = 1 + max memory / segment . length ; for ( segment < v > s : segment ) { s . set max memory ( max ) ; } } }
public void set limit ( int limit ) { this . limit = limit ; }
public v set value ( v value ) { throw new unsupported operation exception ( ) ; }
public static boolean equal ( object a , object b ) { return a == b || ( a ! = null & & a . equal ( b ) ) ; }
public void add all ( c o s array object list ) { if ( object list ! = null ) { object . add all ( object list . object ) ; } }
public boolean equal ( object other ) { return this==other ; }
public default set < class < ? extend s > > apply post ( ) { return collection . empty set ( ) ; }
public default set < class < ? extend s > > apply prior ( ) { return collection . empty set ( ) ; }
public string get label ( ) { return label ; }
public long time ( @ non null time unit unit ) { return unit . convert ( time , this . unit ) ; }
public constraint vertex factory get vertex factory ( ) { return vertex factory ; }
public version get version ( ) { return version ; }
public default vertex out vertex ( ) { return this . vertex ( direction . out ) . next ( ) ; }
public static object output stream new object output stream ( output stream output stream ) throw i o exception { return new object output stream ( output stream ) ; }
public void map ( k key , v value ) { list < v > element for key = get ( key ) ; if ( element for key==null ) { element for key = new array list < v > ( ) ; super . put ( key , element for key ) ; } element for key . add ( value ) ; }
public void set cache size ( int cache size ) { this . cache size = cache size ; }
public void set average width ( float average width ) { dic . set float ( c o s name . avg_width , average width ) ; }
public event get event ( ) { peek event ( ) ; event value = current event ; current event = null ; return value ; }
public static void enable globally ( ) { default meta class info . set without custom metaclass creation handle ( false ) ; expando meta class creation handle . enable ( ) ; }
public a r f f model get model ( ) { return model ; }
public void set engine ( axis engine engine ) { this . engine = engine ; }
public string logical column name ( string column name , string property name ) { return string helper . be not empty ( column name ) ? column name : string helper . unqualify ( property name ) ; }
public void put at ( int index , object new value ) throw s q l exception { index = normalize index ( index ) ; get result set ( ) . update object ( index , new value ) ; }
public object get at ( int index ) throw s q l exception { index = normalize index ( index ) ; return get result set ( ) . get object ( index ) ; }
public void put all ( map map ) { for ( object o : map . entry set ( ) ) { entry entry = ( entry ) o ; put ( entry . get key ( ) , entry . get value ( ) ) ; } }
public boolean be update ( ) { return be update ; }
public set < string > get name ( ) { return new hash set < string > ( this . parameter . key set ( ) ) ; }
public string get family ( ) { return this . family ; } // -- string get family ( )
public list < node > get node ( ) { return node ; }
public static < t > answer < t > answer with delay ( long sleepy time , answer < t > answer ) { return ( answer < t > ) new answer with delay ( sleepy time , ( answer < object > ) answer ) ; }
public object evaluate ( object context ) throw jaxen exception { list answer = select node ( context ) ; if ( answer ! = null & & answer . size ( ) == 1 ) { object first = answer . get ( 0 ) ; if ( first instanceof string || first instanceof number || first instanceof boolean ) { return first ; } } return answer ; }
protected factory bean < ? > get factory bean ( string bean name , object bean instance ) throw bean exception { if ( ! ( bean instance instanceof factory bean ) ) { throw new bean creation exception ( bean name , `` bean instance of type [ `` + bean instance . get class ( ) + `` ] be not a factory bean `` ) ; } return ( factory bean < ? > ) bean instance ; }
public file get src ( ) { if ( src instanceof file resource ) { return ( ( file resource ) src ) . get file ( ) ; } return null ; }
public final void print partial stack trace ( print writer out ) { super . print stack trace ( out ) ; }
public void set target bytecode ( string version ) { if ( pre_jdk5 . equal ( version ) || post_jdk5 . equal ( version ) ) { this . target bytecode = version ; } }
public file get stubdir ( ) { return stub dir ; }
public void set stubdir ( file stub dir ) { joint compilation = true ; this . stub dir = stub dir ; }
public void set cache stub ( boolean cache stub ) { this . cache stub = cache stub ; }
public string get script ( ) { return script ; }
protect string [ ] get doc template ( ) { return groovy doc template info . default_doc_templates ; }
protect string [ ] get package template ( ) { return groovy doc template info . default_package_templates ; }
public static boolean be cql compatible ( c f meta data meta data ) { if ( meta data . be super ( ) ) return false ; if ( meta data . be compact table ( ) & & meta data . partition column ( ) . without static ( ) . size ( ) > 1 & & meta data . cluster column ( ) . size ( ) > = 1 ) return false ; return true ; }
public void store type ( final expression exp , final class node cn ) { type checking visitor . store type ( exp , cn ) ; }
public static class get class ( string class name ) throw class not find exception { return get class ( class name , true ) ; }
public static boolean be float ( class node type ) { return float_ t y p e == type ; }
public void set label ( string label ) { this . label = label ; }
public int get level ( ) { return level ; }
public void set target bytecode ( string version ) { if ( compiler configuration . pre_jdk5 . equal ( version ) || compiler configuration . post_jdk5 . equal ( version ) ) { this . target bytecode = version ; } }
public final u assert error message ( string message ) { int s = error . size ( ) ; if ( s == 0 ) { throw fail ( `` no error `` ) ; } else if ( s == 1 ) { throwable e = error . get ( 0 ) ; string error message = e . get message ( ) ; if ( ! object helper . equal ( message , error message ) ) { throw fail ( `` error message differs ; expect : `` + message + `` , actual : `` + error message ) ; } } else { throw fail ( `` multiple error `` ) ; } return ( u ) this ; }
public static calendar to calendar ( date date ) { if ( date == null ) { return null ; } calendar calendar = calendar . get instance ( ) ; calendar . set time ( date ) ; return calendar ; }
public static string get date time string ( date self ) { return date format . get date time instance ( date format . short , date format . medium ) . format ( self ) ; }
public static string get date string ( date self ) { return date format . get date instance ( date format . short ) . format ( self ) ; }
public static component get at ( j menu self , int index ) { return self . get menu component ( index ) ; }
public static void clear ( default combo box model self ) { self . remove all element ( ) ; }
public static int size ( j combo box self ) { return self . get item count ( ) ; }
public static component get at ( container self , int index ) { return self . get component ( index ) ; }
public void set package ( boolean package ) { this . package = package ; } // -- void set package ( boolean )
public boolean get global ( ) { return m global ; }
public static string format date time ( java . util . date date , string format , string locale , string time zone ) { simple date format date format = get date format ( format , locale , time zone ) ; synchronize ( date format ) { return date format . format ( date ) ; } }
public boolean equal ( object other ) { return this==other ; }
public static void set meta class ( object self , meta class meta class ) { if ( meta class instanceof handle meta class ) meta class = ( ( handle meta class ) meta class ) . get adaptee ( ) ; if ( self instanceof class ) { groovy system . get meta class registry ( ) . set meta class ( ( class ) self , meta class ) ; } else { ( ( meta class registry impl ) groovy system . get meta class registry ( ) ) . set meta class ( self , meta class ) ; } }
public static < t > t [ ] reverse ( t [ ] self , boolean mutate ) { if ( ! mutate ) { return ( t [ ] ) to list ( new reverse list iterator < t > ( arrays . a list ( self ) ) ) . to array ( ) ; } list < t > item = array . a list ( self ) ; collection . reverse ( item ) ; system . arraycopy ( item . to array ( ) , 0 , self , 0 , item . size ( ) ) ; return self ; }
public static < t > set < t > each with index ( set < t > self , @ closure params ( value= from string . class , options= `` t , integer `` ) closure closure ) { return ( set < t > ) each with index ( ( iterable < t > ) self , closure ) ; }
public static < t > set < t > each with index ( set < t > self , @ closure params ( value= from string . class , options= `` t , integer `` ) closure closure ) { return ( set < t > ) each with index ( ( iterable < t > ) self , closure ) ; }
public static < t > iterable < t > each with index ( iterable < t > self , @ closure params ( value= from string . class , options= `` t , integer `` ) closure closure ) { each with index ( self . iterator ( ) , closure ) ; return self ; }
public static < t > list < t > reverse each ( list < t > self , @ closure params ( first param . first generic type . class ) closure closure ) { each ( new reverse list iterator < t > ( self ) , closure ) ; return self ; }
public static < t > iterable < t > each ( iterable < t > self , @ closure params ( first param . first generic type . class ) closure closure ) { each ( self . iterator ( ) , closure ) ; return self ; }
public static < t > iterable < t > each ( iterable < t > self , @ closure params ( first param . first generic type . class ) closure closure ) { each ( self . iterator ( ) , closure ) ; return self ; }
public static boolean any ( object self , closure closure ) { boolean closure wrapper bcw = new boolean closure wrapper ( closure ) ; for ( iterator iter = invoker helper . a iterator ( self ) ; iter . have next ( ) ; ) { if ( bcw . call ( iter . next ( ) ) ) return true ; } return false ; }
public static < t > iterable < t > each ( iterable < t > self , @ closure params ( first param . first generic type . class ) closure closure ) { each ( self . iterator ( ) , closure ) ; return self ; }
public static < t > collection < t > find all ( t [ ] self ) { return find all ( self , closure . identity ) ; }
public result get result ( ) { return result ; }
public static < t > collection < t > each with index ( collection < t > self , @ closure params ( value= from string . class , options= `` t , integer `` ) closure closure ) { return ( collection < t > ) each with index ( ( iterable < t > ) self , closure ) ; }
public static < t > iterable < t > each ( iterable < t > self , @ closure params ( first param . first generic type . class ) closure closure ) { each ( self . iterator ( ) , closure ) ; return self ; }
public static map group by ( object [ ] self , list < closure > closure ) { return group by ( ( iterable ) array . a list ( self ) , closure ) ; }
public static < t > collection < t > a immutable ( collection < ? extend t > self ) { return collection . unmodifiable collection ( self ) ; }
public static < t > t min ( collection < t > item ) { t answer = null ; for ( t value : item ) { if ( value ! = null ) { if ( answer == null || script bytecode adapter . compare less than ( value , answer ) ) { answer = value ; } } } return answer ; }
public static string collection ( collection < ? > collection ) { if ( collection == null ) { return null_string ; } return array ( collection . to array ( new object [ collection . size ( ) ] ) ) ; }
public static < t > t [ ] reverse ( t [ ] self , boolean mutate ) { if ( ! mutate ) { return ( t [ ] ) to list ( new reverse list iterator < t > ( arrays . a list ( self ) ) ) . to array ( ) ; } list < t > item = array . a list ( self ) ; collection . reverse ( item ) ; system . arraycopy ( item . to array ( ) , 0 , self , 0 , item . size ( ) ) ; return self ; }
public annotation value builder < t > value ( boolean bool ) { return member ( annotation metadata . value_member , bool ) ; }
public enumeration < e > a enumeration ( ) { return iterator utils . a enumeration ( iterator ( ) ) ; }
public static boolean a boolean ( char [ ] array ) { if ( null == array ) { return false ; } return array . length > 0 ; }
public static boolean a boolean ( byte [ ] array ) { if ( null == array ) { return false ; } return array . length > 0 ; }
public static boolean a boolean ( byte [ ] array ) { if ( null == array ) { return false ; } return array . length > 0 ; }
public static int dimension ( class clazz ) { check array type ( clazz ) ; int result = 0 ; while ( clazz . be array ( ) ) { result++ ; clazz = clazz . get component type ( ) ; } return result ; }
public static < t > list < t > unique ( list < t > self , boolean mutate ) { return ( list < t > ) unique ( ( collection < t > ) self , mutate ) ; }
public static < t > set < t > plus ( set < t > leave , t right ) { return ( set < t > ) plus ( ( collection < t > ) leave , right ) ; }
public static < t > collection < t > plus ( collection < t > leave , iterable < t > right ) { return plus ( left , a collection ( right ) ) ; }
public static < t > set < t > plus ( set < t > leave , t right ) { return ( set < t > ) plus ( ( collection < t > ) leave , right ) ; }
public static boolean equal ( string o1 , string o2 ) { return o1 == null ? o2 == null : o1 . equal ( o2 ) ; }
public static < t > collection < t > a immutable ( collection < ? extend t > self ) { return collection . unmodifiable collection ( self ) ; }
public void set flatten attribute ( boolean b ) { flatten class path = b ; }
public static list < double > get at ( double [ ] array , range range ) { return primitive array get ( array , range ) ; }
public static list < long > get at ( long [ ] array , range range ) { return primitive array get ( array , range ) ; }
public static list < long > get at ( long [ ] array , range range ) { return primitive array get ( array , range ) ; }
public static list < long > get at ( long [ ] array , range range ) { return primitive array get ( array , range ) ; }
public static list < byte > get at ( byte [ ] array , int range range ) { range info info = sub list border ( array . length , range ) ; list < byte > answer = primitive array get ( array , new int range ( true , info . from , info . to - 1 ) ) ; return info . reverse ? reverse ( answer ) : answer ; }
public string to string ( ) { return set . to string ( ) ; }
public static < t > set < t > plus ( set < t > leave , t right ) { return ( set < t > ) plus ( ( collection < t > ) leave , right ) ; }
public static number multiply ( number leave , character right ) { return number number multiply . multiply ( integer . value of ( right ) , leave ) ; }
public static number minus ( number leave , character right ) { return number number minus . minus ( leave , integer . value of ( right ) ) ; }
public static < t > answer < t > answer with delay ( long sleepy time , answer < t > answer ) { return ( answer < t > ) new answer with delay ( sleepy time , ( answer < object > ) answer ) ; }
public static number multiply ( number leave , character right ) { return number number multiply . multiply ( integer . value of ( right ) , leave ) ; }
public static long sortable double bit ( long bit ) { return bit ^ ( bit > > 63 ) & 0x7fffffffffffffff l ; }
public static value decimal get ( big integer big integer ) { if ( big integer . signum ( ) == 0 ) { return ( value decimal ) zero ; } else if ( big integer . one . equal ( big integer ) ) { return ( value decimal ) one ; } return ( value decimal ) value . cache ( new value decimal ( new big decimal ( big integer ) ) ) ; }
public void put ( int type code , string value ) { final integer integer = integer . value of ( type code ) ; default . put ( integer , value ) ; }
public void set right ( final string right ) { this . right = list . create ( right ) ; }
public static void mixin ( meta class self , list < class > category class ) { mixin in meta class . mixin class to meta class ( self , category class ) ; }
public static list get all interface ( class cl ) { if ( cls == null ) { return null ; } list interface find = new array list ( ) ; get all interface ( cl , interface find ) ; return interface find ; }
public static void clear ( default combo box model self ) { self . remove all element ( ) ; }
public static date parse date ( final string s date , final locale locale ) { date date = null ; if ( additional_masks . length > 0 ) { date = parse use mask ( additional_masks , s date , locale ) ; if ( date ! = null ) { return date ; } } date = parse w3 c date time ( s date , locale ) ; if ( date == null ) { date = parse r f c822 ( s date , locale ) ; } return date ; }
public void set line number ( int line number ) { this . line number = line number ; }
public void check cancel ( ) { if ( this . monitor ! = null & & this . monitor . be cancel ( ) ) throw new operation cancel exception ( ) ; }
public static value time from nanos ( long nanos ) { return ( value time ) value . cache ( new value time ( nanos ) ) ; }
public void set server authority ( host port authority ) { if ( authority == null ) _server authority = null ; else if ( ! authority . have host ( ) ) throw new illegal state exception ( `` server authority must have host declare `` ) ; else _server authority = authority ; }
public static synchronize r d f parser registry get instance ( ) { if ( default registry == null ) { default registry = new r d f parser registry ( ) ; } return default registry ; }
public long get num byte ( ) { return block . get num byte ( ) ; }
public string get server ( ) { return server ; }
public channel id get channel id ( ) { return this . channel id ; }
public void add callback ( runnable callback ) { if ( callback ! = null ) delegate . add callback ( callback ) ; }
public byte array list value ( ) { byte array list list = new byte array list ( size ( ) ) ; value ( list ) ; return list ; }
public http client option set keep alive ( boolean keep alive ) { this . keep alive = keep alive ; return this ; }
public static server builder < ? > for port ( int port ) { return server provider . provider ( ) . builder for port ( port ) ; }
public static int get max request attempt ( ) { return max request attempt ; }
public void set provider ( string provider ) { this . provider = provider ; }
public int refresh time ( ) { return refresh time ; }
public list < service > get service ( ) { synchronize ( service list ) { return new array list < service > ( service list ) ; } }
public static int get port ( ) { return port provider . get port ( ) ; }
protect void set code ( int code ) { this . code = code ; }
public default boolean be trailer field ready ( ) { return false ; }
public void set status ( string status ) { this . status = status ; } // -- void set status ( string )
public unused stubbings get unused stubbings ( iterable < object > mock ) { set < stub > stubbings = all invocation finder . find stubbings ( mock ) ; list < stub > unused = filter ( stubbings , new filter < stub > ( ) { public boolean be out ( stub s ) { return s . be use ( ) ; } } ) ; return new unused stubbings ( unused ) ; }
public static server builder < ? > for port ( int port ) { return server provider . provider ( ) . builder for port ( port ) ; }
public s s l configuration get ssl ( ) { if ( ssl == null ) { ssl = new s s l configuration ( ) ; } return ssl ; }
public void write ( final int c ) throw i o exception { appendable . append ( ( char ) c ) ; }
public input supplier < input stream > get supplier ( ) { return a byte source ( ) ; }
public void rename ( file from , file to ) throw i o exception { if ( to . exists ( ) & & ! to . delete ( ) ) { throw new i o exception ( `` fail to delete `` + to + `` while try to rename `` + from ) ; } file parent = to . get parent file ( ) ; if ( parent ! = null & & ! parent . exists ( ) & & ! parent . mkdirs ( ) ) { throw new i o exception ( `` fail to create directory `` + parent + `` while try to rename `` + from ) ; } if ( ! from . rename to ( to ) ) { copy file ( from , to ) ; if ( ! from . delete ( ) ) { throw new i o exception ( `` fail to delete `` + from + `` while try to rename it . `` ) ; } } }
public input supplier < input stream > get supplier ( ) { return supplier ; }
public matrix get v ( ) { return v . like ( ) . assign ( v ) ; }
public predicate [ ] get predicate ( ) { return i predicate ; }
public boolean be stop ( ) { return stop ; }
public static void assert equal ( collection < ? > actual , collection < ? > expect ) { assert equal ( actual , expect , null ) ; }
public string get expect ( ) { return f expect ; }
public int native size ( runtime runtime ) { return runtime . address size ( ) ; }
public static annotation [ ] get resource annotation ( method method ) { map < class < ? > , annotation > annotation = new hash map < class < ? > , annotation > ( ) ; for ( annotation annotation : method . get declare class ( ) . get annotation ( ) ) { annotation . put ( annotation . get class ( ) , annotation ) ; } for ( annotation annotation : method . get annotation ( ) ) { annotation . put ( annotation . get class ( ) , annotation ) ; } return annotation . value ( ) . to array ( new annotation [ annotation . size ( ) ] ) ; }
public void set name ( string name ) { if ( name == null ) { throw new illegal argument exception ( `` name must not be null `` ) ; } this . name = name ; }
public void set order ( array list < select order by > order ) { order list = order ; }
protect navigable set < e > decorate ( ) { return ( navigable set < e > ) super . decorate ( ) ; }
public char get escape char ( ) { return escape char ; }
public static < t > list < t > a list ( list < ? extend t > l ) { return ( list < t > ) l ; }
public string get $ ref ( ) { return $ ref ; }
public < t > t get object ( ) { return ( t ) object ; }
public stream priority set dependency ( int dependency ) { this . dependency = dependency ; return this ; }
public sequence get sequence ( string sequence name ) { sequence sequence = sequence . get ( sequence name ) ; if ( sequence == null ) { throw db exception . get ( error code . sequence_not_found_1 , sequence name ) ; } return sequence ; }
public void set c ( p d action c ) { action . set item ( c o s name . c , c ) ; }
public void set ignore ( boolean ignore ) { this . ignore = ignore ; }
public db exception add s q l ( string sql ) { s q l exception e = get s q l exception ( ) ; if ( e instanceof jdbc s q l exception ) { jdbc s q l exception j = ( jdbc s q l exception ) e ; if ( j . get s q l ( ) == null ) { j . set s q l ( sql ) ; } return this ; } e = new jdbc s q l exception ( e . get message ( ) , sql , e . get s q l state ( ) , e . get error code ( ) , e , null ) ; return new db exception ( e ) ; }
public synchronize long get max size ( ) { return max size ; }
public void set max parallel ( int max ) { max parallel = max ; }
public void sync ( ) { try { file . force ( true ) ; } catch ( i o exception e ) { close file silently ( ) ; throw db exception . convert i o exception ( e , name ) ; } }
public int get free parameter ( ) { return compiler . get free parameter ( ) ; }
public void set file ( file f ) { check attribute allow ( ) ; file = f ; }
public void set version ( string version ) { this . version = version ; } // -- void set version ( string )
public boolean get auto commit on return ( ) { return auto commit on return ; }
public boolean be cache ( ) { return cache ! = null ; }
public boolean be read only ( ) { return this . read only ; }
public option set short name ( string short name ) { this . short name = short name ; return this ; }
public write buffer put short ( short x ) { ensure capacity ( 2 ) . put short ( x ) ; return this ; }
public void write to ( byte buffer dst ) { byte buffer src = buffer ( ) ; dst . put ( src ) ; }
public void set position ( int position ) { buffer position = position ; }
public int get index ( ) { return index ; }
public void insert row ( value [ ] row ) throw s q l exception { statement builder buff = new statement builder ( `` insert into `` ) ; append table name ( buff ) ; buff . append ( ' ( ' ) ; append column list ( buff , false ) ; buff . append ( `` ) value ( `` ) ; buff . reset count ( ) ; for ( int i = 0 ; i < column count ; i++ ) { buff . append except first ( `` , `` ) ; value v = row [ i ] ; if ( v == null ) { buff . append ( `` default `` ) ; } else { buff . append ( ' ? ' ) ; } } buff . append ( ' ) ' ) ; prepare statement prep = conn . prepare statement ( buff . to string ( ) ) ; for ( int i = 0 , j = 0 ; i < column count ; i++ ) { value v = row [ i ] ; if ( v ! = null ) { v . set ( prep , j++ + 1 ) ; } } int count = prep . execute update ( ) ; if ( count ! = 1 ) { throw db exception . get ( error code . no_data_available ) ; } }
public string get table name ( ) { return this . table name ; }
public static void move atomic replace ( string source , string target ) { file path . get ( source ) . move to ( file path . get ( target ) , true ) ; }
public static void move ( string source , string target ) { file path . get ( source ) . move to ( file path . get ( target ) , false ) ; }
public void set convert ( jaxb convert value ) { this . convert = value ; }
public table get table ( ) { return table ; }
public string get expression ( ) { return expression ; }
public trust chain constraint get constraint ( ) { return constraint ; }
public string lookup property string lookup ( ) { return property string lookup . instance ; }
public void set filter ( boolean filter ) { this . filter = filter ; }
public void set recursive ( boolean recursive ) { super . set internal recursive ( recursive ) ; }
public int get max value ( int dimension ) { if ( dimension < 2 || dimension > 32 ) { throw new illegal argument exception ( `` `` + dimension ) ; } int bit per value = get bit per value ( dimension ) ; return ( int ) ( ( 1l < < bits per value ) - 1 ) ; }
public static object parse offset date time ( char sequence text ) { try { return offset_date_time_parse . invoke ( null , text ) ; } catch ( illegal access exception | invocation target exception e ) { throw new illegal argument exception ( `` error when parse text ' `` + text + `` ' `` , e ) ; } }
public static object parse local date ( char sequence text ) { try { return local_date_parse . invoke ( null , text ) ; } catch ( illegal access exception | invocation target exception e ) { throw new illegal argument exception ( `` error when parse text ' `` + text + `` ' `` , e ) ; } }
public date with time zone offset get verification time ( ) { return time ; }
public static inet address get local address ( ) { if ( local inet address == null ) try { local inet address = database descriptor . get listen address ( ) == null ? inet address . get local host ( ) : database descriptor . get listen address ( ) ; } catch ( unknown host exception e ) { throw new runtime exception ( e ) ; } return local inet address ; }
public @ not null i envelope cache get envelope disk cache ( ) { return envelope disk cache ; }
public boolean have more ( ) { return remain entry ! = 0 ; }
public long get hour ( ) { return interval utils . hour from interval ( qualifier , negative , leading , remain ) ; }
public long get month ( ) { return interval utils . month from interval ( qualifier , negative , leading , remain ) ; }
public long get month ( ) { return interval utils . month from interval ( qualifier , negative , leading , remain ) ; }
public string get expression ( ) { return expression ; }
public void set order ( int order ) { this . order = order ; }
public common stats flag group ( string . . . group ) { this . group = group ; return this ; }
public void register ( collector m ) { list < string > name = collector name ( m ) ; synchronize ( collector to name ) { for ( string name : name ) { if ( name to collector . contains key ( name ) ) { throw new illegal argument exception ( `` collector already register that provide name : `` + name ) ; } } for ( string name : name ) { name to collector . put ( name , m ) ; } collector to name . put ( m , names ) ; } }
public statement builder append ( string s ) { builder . append ( s ) ; return this ; }
public byte array list value ( ) { byte array list list = new byte array list ( size ( ) ) ; value ( list ) ; return list ; }
public static int read message length ( bytes reference network byte ) throw i o exception { if ( network byte . length ( ) < bytes_needed_for_message_size ) { return -1 ; } else { return read header buffer ( network byte ) ; } }
public session get session ( ) { return this . session ; }
public final list < list < object > > get event ( ) { list < list < object > > result = new array list < list < object > > ( ) ; result . add ( ( list ) value ( ) ) ; result . add ( ( list ) error ( ) ) ; list < object > complete list = new array list < object > ( ) ; for ( long i = 0 ; i < completion ; i++ ) { complete list . add ( notification . create on complete ( ) ) ; } result . add ( complete list ) ; return result ; }
public byte increment and get ( ) { value++ ; return value ; }
public string get name ( ) { return identity ; }
public string get name ( ) { return name ; }
public least square builder parameter validator ( final parameter validator new validator ) { param validator = new validator ; return this ; }
public final column definition column ( ) { return column ; }
public void set filter ( boolean filter ) { this . filter = filter ; }
public int get max value ( int dimension ) { if ( dimension < 2 || dimension > 32 ) { throw new illegal argument exception ( `` `` + dimension ) ; } int bit per value = get bit per value ( dimension ) ; return ( int ) ( ( 1l < < bits per value ) - 1 ) ; }
public int get offset ( ) { return offset ; }
public type get type ( ) { return type ; }
public big integer get big integer value ( ) throw i o exception { return delegate . get big integer value ( ) ; }
public final double get and set ( double new value ) { long next = double to raw long bit ( new value ) ; return long bit to double ( updater . get and set ( this , next ) ) ; }
public result get result ( ) { return result ; }
public void remove last token ( ) { if ( previous token==null ) { first token = current token = null ; } else { current token = previous token ; current token . set next token ( null ) ; } }
public static void set ( string agent ) { user agent = string utils . be empty or null ( agent ) ? null : clean ( agent ) ; }
public final i scheduling rule get rule ( ) { return super . get rule ( ) ; }
public set get property key set ( ) { return get property ( ) . key set ( ) ; }
public string get new resource name ( ) { return f new resource name ; }
public static string trim ( string value ) { if ( value == null ) { return null ; } return value . trim ( ) ; }
public double double value ( ) { return value ; }
public void set class name ( string class name ) { this . class name = class name ; }
public object get new value ( ) { return new value ; }
protect string [ ] get property method suffix ( string property name ) { string suffix = get property method suffix ( property name ) ; if ( suffix . length ( ) > 0 & & character . be upper case ( suffix . char at ( 0 ) ) ) { return new string [ ] { suffix } ; } return new string [ ] { suffix , string utils . capitalize ( suffix ) } ; }
public request option get option ( ) { return option ; }
public string version ( ) { return version ; }
public byte [ ] get ( ) { if ( bytes == null ) { byte = new byte [ 0 ] ; } return byte ; }
public string get uri ( ) { return uri ; }
public static void l set x attr ( string path , string name , string value ) throw i o exception { l set x attr ( path , name , value , native . get default string encoding ( ) ) ; }
public iterable < integer > attr iterable rev ( ) { list < integer > attrs = list . new array list ( ) ; for ( int i = 0 ; i < attr count list . size ( ) ; i++ ) { if ( attr count list . get ( i ) > 0 ) { attrs . add ( i ) ; } } collection . sort ( attrs , collection . reverse order ( attr comparator ) ) ; return attrs ; }
public string get path ( ) { return path ; }
public long get length ( ) { return length ; }
public request option get option ( ) { return option ; }
public boolean be file ( ) { return be file ; }
public type owner ( ) { return owner ; }
public static void set default uri ( configuration conf , uri uri ) { conf . set ( fs_default_name_key , uri . to string ( ) ) ; }
public static uri get default uri ( configuration conf ) { return uri . create ( fix name ( conf . get ( fs_default_name_key , default_fs ) ) ) ; }
public o i d c token get o i d c token ( ) { return get token ( ) instanceof o i d c token ? get token ( ) . to o i d c token ( ) : null ; }
protect unsupported operation exception create unsupported operation exception ( string name ) { return new unsupported operation exception ( name + `` be not implement by `` + this . get class ( ) . get name ( ) ) ; }
public boolean be delete ( ) { return f be delete ; }
public file status [ ] list status ( path [ ] file ) throw file not find exception , i o exception { return list status ( file , default_filter ) ; }
public file status [ ] list status ( path f , path filter filter ) throw file not find exception , i o exception { array list < file status > result = new array list < file status > ( ) ; list status ( result , f , filter ) ; return result . to array ( new file status [ result . size ( ) ] ) ; }
public static i file system get local file system ( ) { return internal file system core . get instance ( ) . get local file system ( ) ; }
public void update execution statistic ( execution statistic execution statistic ) { this . execution statistic = execution statistic ; }
public file get directory ( ) { return f directory ; }
public void flush buffer ( ) throw i o exception { output buffer . flush ( ) ; }
public static io . vertx . reactivex . ext . shell . shell server create ( io . vertx . reactivex . core . vertx vertx ) { io . vertx . reactivex . ext . shell . shell server ret = io . vertx . reactivex . ext . shell . shell server . new instance ( ( io . vertx . ext . shell . shell server ) io . vertx . ext . shell . shell server . create ( vertx . get delegate ( ) ) ) ; return ret ; }
public void set command factory ( command factory factory ) { this . command factory = factory ; }
public string get path ( ) { return path ; }
public void set x path context ( x path context context ) { this . context = context ; }
public static uri get base u r i ( final uri uri ) { if ( uri == null ) return null ; try { return new uri ( uri . get scheme ( ) , null , uri . get host ( ) , uri . get port ( ) , uri . get path ( ) , null , null ) ; } catch ( u r i syntax exception e ) { return null ; } }
public void set factory ( j d o m factory factory ) { this . factory = factory ; }
public static void delete all ( path [ ] data path ) throw i o exception { for ( path data path : data path ) { lucene . clean lucene index ( new n i o f s directory ( data path . resolve ( metadata_directory_name ) ) ) ; } }
public static void warning ( final string message ) { log ( warn , message ) ; }
public string get message ( ) { return cmd ! = null ? cmd . get message ( ) : null ; }
public parameter list get parameter list ( ) { return list ; }
public string get in ( ) { return in ; }
public int get depth ( ) { return statistic . depth ; }
public boolean be expunge ( ) { return expunge ; }
public string get table name ( ) { return this . table name ; }
public void attribute ( string name , object value ) { session . set attribute ( name , value ) ; }
public string get url ( ) { return this . url ; } // -- string get url ( )
public object get value ( ) { return value ; }
public final int compare to ( term other ) { if ( field . equal ( other . field ) ) { return byte . compare to ( other . byte ) ; } else { return field . compare to ( other . field ) ; } }
public int get count ( ) { return ( int ) bytes read ; }
public void add configuration ( string conf ) { confs . add ( conf ) ; }
public string to string ( ) { if ( be empty ( ) ) { return `` { } `` ; } final string builder buf = new string builder ( ) ; buf . append ( ' { ' ) ; boolean first = true ; for ( final map . entry < k , v > entry : entry set ( ) ) { final k key = entry . get key ( ) ; final v value = entry . get value ( ) ; if ( first ) { first = false ; } else { buf . append ( `` , `` ) ; } buf . append ( key == this ? `` ( this map ) `` : key ) ; buf . append ( '= ' ) ; buf . append ( value == this ? `` ( this map ) `` : value ) ; } buf . append ( ' } ' ) ; return buf . to string ( ) ; }
protect < t > void add codec ( list < t > codecs , t codec ) { init codec ( codec ) ; codecs . add ( codec ) ; }
public long get map finish time ( ) { return 0 ; }
public static long copy range ( input stream in , output stream out , long start , long end ) throw i o exception { assert . not null ( in , `` no input stream specify `` ) ; assert . not null ( out , `` no output stream specify `` ) ; long skip = in . skip ( start ) ; if ( skip < start ) { throw new i o exception ( `` skip only `` + skip + `` bytes out of `` + start + `` require `` ) ; } long bytes to copy = end - start + 1 ; byte [ ] buffer = new byte [ ( int ) math . min ( stream utils . buffer_size , byte to copy ) ] ; while ( byte to copy > 0 ) { int byte read = in . read ( buffer ) ; if ( byte read == -1 ) { break ; } else if ( byte read < = bytes to copy ) { out . write ( buffer , 0 , byte read ) ; bytes to copy -= byte read ; } else { out . write ( buffer , 0 , ( int ) bytes to copy ) ; bytes to copy = 0 ; } } return ( end - start + 1 - byte to copy ) ; }
public void set message digest ( byte [ ] digest ) { put ( message_digest , digest ) ; }
public void set in ( input stream in ) { this . in = in ; }
public static int read v int ( byte [ ] byte , int start ) throw i o exception { return ( int ) read v long ( byte , start ) ; }
public static int read unsigned short ( byte [ ] byte , int start ) { return ( ( ( bytes [ start ] & 0xff ) < < 8 ) + ( ( bytes [ start+1 ] & 0xff ) ) ) ; }
public kind get kind ( ) { return kind ; }
public void set conf ( configuration conf ) { this . conf = conf ; }
public static < e > queue < e > synchronize queue ( queue < e > queue ) { return synchronize . queue ( queue , null ) ; }
public void shutdown ( ) { }
public string get proxy ( ) { return proxy ; }
public string get user ( ) { debug code call ( `` get user `` ) ; return user name ; }
public void set send buffer size ( int size ) throw socket exception { send buffer size = size ; }
public void stop ( ) { stop ( true ) ; }
public map get attribute ( ) { return attribute ; }
public void start ( ) throw i o exception { start ( true ) ; }
protect void remove ( metric record impl record ) { }
public final synchronize metric record create record ( string record name ) { if ( buffer data . get ( record name ) == null ) { buffer data . put ( record name , new record map ( ) ) ; } return new record ( record name ) ; }
public tag get tag ( ) { return this . tag ; }
public static final readable interval get readable interval ( readable interval interval ) { if ( interval == null ) { long now = date time utils . current time millis ( ) ; interval = new interval ( now , now ) ; } return interval ; }
public final tag info get tag info ( ) { return tag info ; }
public counter get task counter ( ) { return counter ; }
public protocol get protocol ( ) { return protocol ; }
public final synchronize metric record create record ( string record name ) { if ( buffer data . get ( record name ) == null ) { buffer data . put ( record name , new record map ( ) ) ; } return new record ( record name ) ; }
public void set conf ( configuration conf ) { this . conf = conf ; }
public string to string ( ) { string builder builder = new string builder ( ) ; builder . append ( `` map length = `` ) . append ( key . length ) . append ( `` , count = `` ) . append ( count ) . append ( `` , resize count = `` ) . append ( resize count ) . append ( '\n ' ) ; for ( int i = 0 ; i < key . length ; i ++ ) { builder . append ( ' [ ' ) . append ( i ) . append ( `` ] = `` ) ; if ( key [ i ] ! = null ) { final int hc = system . identity hash code ( keys [ i ] ) ; builder . append ( `` { `` ) . append ( keys [ i ] ) . append ( `` ( hash `` ) . append ( hc ) . append ( `` , modulus `` ) . append ( hc % key . length ) . append ( `` ) = > `` ) . append ( value [ i ] ) . append ( `` } `` ) ; } else { builder . append ( `` ( blank ) `` ) ; } builder . append ( '\n ' ) ; } return builder . to string ( ) ; }
public void set conf ( configuration conf ) { this . conf = conf ; }
protect void index node ( node node ) { list < node > nod = node name to node . get ( node . get x path node name ( ) ) ; if ( node ! = null ) { node . add ( node ) ; } }
public void close ( ) throw i o exception { channel . close ( ) ; }
public static byte [ ] encode ( byte [ ] bytes ) { return bytes == null || byte . length == 0 ? byte : codec . encode ( byte ) ; }
public byte to byte ( ) { return new byte ( byte value ( ) ) ; }
public final string get i d ( ) { return i i d ; }
public string get user name ( ) { return user name ; }
public static secret key to a e s key ( final secret key secret key ) { if ( secret key == null ) { return null ; } return new secret key spec ( secret key . get encoded ( ) , `` aes `` ) ; }
public list < long > get long list ( string key ) { return get long list ( key , new array list < long > ( ) ) ; }
public static op read ( data input in ) throw i o exception { return value of ( in . read byte ( ) ) ; }
public i o stream pair create stream pair ( data output stream out , data input stream in ) { if ( sasl client ! = null ) { return new i o stream pair ( new sasl input stream ( in , sasl client ) , new sasl output stream ( out , sasl client ) ) ; } else { return new i o stream pair ( new sasl input stream ( in , sasl server ) , new sasl output stream ( out , sasl server ) ) ; } }
public static < t > t do a login user ( privileged exception action < t > action ) throw i o exception { return do a user ( user group information . get login user ( ) , action ) ; }
public static < t > t do a login user or fatal ( privileged action < t > action ) { if ( user group information . be security enable ( ) ) { user group information ugi = null ; try { ugi = user group information . get login user ( ) ; } catch ( i o exception e ) { log . fatal ( `` exception while get login user `` , e ) ; e . print stack trace ( ) ; runtime . get runtime ( ) . exit ( -1 ) ; } return ugi . do a ( action ) ; } else { return action . run ( ) ; } }
public key manager get key manager ( ) { if ( key manager == null ) { key manager = new key manager ( get configuration ( ) ) ; } return key manager ; }
public byte [ ] get buffer ( ) { return buf ; }
public static keytab read ( file file ) throw i o exception { byte buffer buffer = byte buffer . wrap ( get byte from file ( file ) ) ; return read keytab ( buffer ) ; }
public collection < token < ? extend token identifier > > get token ( ) { synchronize ( subject ) { return collection . unmodifiable collection ( new array list < token < ? > > ( get credential internal ( ) . get all token ( ) ) ) ; } }
public synchronize boolean add token identifier ( token identifier token id ) { return subject . get public credential ( ) . add ( token id ) ; }
public list < server service definition > get service ( ) { return collection . empty list ( ) ; }
public string to string ( ) { return name ; }
public int get status ( ) { return status ; }
public final string get line ( int line i ) { return line . get ( line i ) ; }
public list get library list ( ) { return library list ; }
public phase get phase ( ) { return this . phase ; }
public object get new value ( ) { return new value ; }
public int get exit code ( ) { return exit code ; }
public static int get page type ( long po ) { return ( ( int ) po ) & 1 ; }
public static string get version ( ) { return version ; }
public quota [ ] get quota ( ) throw message exception { return ( quota [ ] ) do optional command ( `` quota not support `` , new protocol command ( ) { @ override public object do command ( i m a p protocol p ) throw protocol exception { return p . get quota root ( full name ) ; } } ) ; }
public string snapshot ( ) { return snapshot ; }
public void modify cache directive ( cache directive info info , enum set < cache flag > flag ) throw i o exception { dfs . modify cache directive ( info , flag ) ; }
public long add cache directive ( cache directive info info , enum set < cache flag > flag ) throw i o exception { return dfs . add cache directive ( info , flag ) ; }
public void remove cache pool ( string pool name ) throw i o exception { dfs . remove cache pool ( pool name ) ; }
public static void set default pool ( buffer pool pool ) { if ( pool == null ) { throw new illegal argument exception ( `` pool be null `` ) ; } default pool = pool ; }
public input stream get input stream ( ) throw i o exception { input stream in stream = this . get input stream impl ( ) ; if ( in stream == null ) { throw new i o exception ( `` ca n't obtain the input stream from `` + _part name . get name ( ) ) ; } return in stream ; }
public static string identity to string ( object object ) { if ( object == null ) { return null ; } string buffer buffer = new string buffer ( ) ; identity to string ( buffer , object ) ; return buffer . to string ( ) ; }
public void set initial interval ( long initial interval ) { this . initial interval = initial interval ; }
public location get location ( ) { return location ; }
public static string get spnego keytab key ( configuration conf , string default key ) { string value = conf . get ( d f s config key . dfs_web_authentication_kerberos_keytab_key ) ; return ( value == null || value . be empty ( ) ) ? default key : d f s config key . dfs_web_authentication_kerberos_keytab_key ; }
public void set key ( boolean value ) { this . key = value ; }
public string get key ( ) { return key ; }
public void set conf ( configuration conf ) { this . conf = conf ; }
public string get mode ( ) { return mode ; }
public int meta save ( string [ ] argv , int idx ) throw i o exception { string pathname = argv [ idx ] ; distribute file system dfs = get d f s ( ) ; configuration dfs conf = dfs . get conf ( ) ; uri dfs uri = dfs . get uri ( ) ; boolean be ha enabled = h a util . be logical uri ( dfs conf , dfs uri ) ; if ( be ha enable ) { string ns id = dfs uri . get host ( ) ; list < proxy and info < client protocol > > proxy = h a util . get proxy for all name node in nameservice ( dfs conf , ns id , client protocol . class ) ; for ( proxy and info < client protocol > proxy : proxy ) { proxy . get proxy ( ) . meta save ( pathname ) ; system . out . println ( `` create metasave file `` + pathname + `` in the log `` + `` directory of namenode `` + proxy . get address ( ) ) ; } } else { dfs . meta save ( pathname ) ; system . out . println ( `` create metasave file `` + pathname + `` in the log `` + `` directory of namenode `` + dfs . get uri ( ) ) ; } return 0 ; }
public boolean num exist ( big integer num i d ) { for ( x w p f num num : nums ) { if ( num . get c t num ( ) . get num id ( ) . equal ( num i d ) ) return true ; } return false ; }
public option use ( use use ) { return using . and ( use ) ; }
public option use ( use use ) { return using . and ( use ) ; }
public long count ( ) { return count . get ( ) ; }
public void set software version ( final software version software version ) { this . software version = software version ; }
public void read token storage stream ( data input stream in ) throw i o exception { byte [ ] magic = new byte [ token_storage_magic . length ] ; in . read fully ( magic ) ; if ( ! array . equal ( magic , token_storage_magic ) ) { throw new i o exception ( `` bad header find in token storage . `` ) ; } byte version = in . read byte ( ) ; if ( version ! = token_storage_version ) { throw new i o exception ( `` unknown version `` + version + `` in token storage . `` ) ; } read field ( in ) ; }
public static sasl property resolver get instance ( configuration conf ) { class < ? extend sasl property resolver > clazz = conf . get class ( common configuration key public . hadoop_security_sasl_props_resolver_class , sasl property resolver . class , sasl property resolver . class ) ; return reflection utils . new instance ( clazz , conf ) ; }
public inet address get address ( ) { return address . get address ( ) ; }
public long get remain ( ) { return remain ; }
public boolean be resolve ( ) { return path ! = null & & ! path . be empty ( ) ; }
public split location info [ ] get location info ( ) throw i o exception { return null ; }
public executor name get thread pool name ( ) { return this . executor name ; }
public access token get access token ( ) { return access token ; }
public static int append char ( automaton a , int state , int c ) { int new state = a . create state ( ) ; a . add transition ( state , new state , c , c ) ; return new state ; }
protect void index node ( node node ) { list < node > nod = node name to node . get ( node . get x path node name ( ) ) ; if ( node ! = null ) { node . add ( node ) ; } }
public string get failed storage location ( ) { return this . fail storage location ; }
protect void set field from property ( property prop , storage directory sd ) throw i o exception { set layout version ( prop , sd ) ; set namespace i d ( prop , sd ) ; setc time ( prop , sd ) ; set cluster id ( prop , layout version , sd ) ; check storage type ( prop , sd ) ; }
public string list storage directory ( ) { string builder buf = new string builder ( ) ; for ( storage directory sd : storage dirs ) { buf . append ( sd . get root ( ) + `` ( `` + sd . get storage dir type ( ) + `` ) ; `` ) ; } return buf . to string ( ) ; }
public byte buf get byte buf ( ) { byte buf ret = delegate . get byte buf ( ) ; return ret ; }
public file get block file ( ) { return new file ( get dir ( ) , get block name ( ) ) ; }
public channel future close ( channel channel , close web socket frame frame ) { object util . check not null ( channel , `` channel `` ) ; return close ( channel , frame , channel . new promise ( ) ) ; }
public string [ ] get location ( ) { return this . location ; }
public output stream wrap out if need ( output stream out ) { return out ; }
public string get file ( ) { return file ; }
public output < t > reserve space4 ( ) { return reserve space4 ; }
public void write to ( writer writer ) throw i o exception { write to ( writer , writer config . minimal ) ; }
public final string get i d ( ) { return i i d ; }
public int get skip count ( ) { return skip count ; }
public void close ( ) throw i o exception { }
public static i node in path append ( i node in path iip , i node child , byte [ ] child name ) { precondition . check argument ( ! iip . be snapshot & & iip . length ( ) > 0 ) ; precondition . check argument ( iip . get last i node ( ) ! = null & & iip . get last i node ( ) . be directory ( ) ) ; i node [ ] inodes = new i node [ iip . length ( ) + 1 ] ; system . arraycopy ( iip . inodes , 0 , inodes , 0 , inodes . length - 1 ) ; inodes [ inodes . length - 1 ] = child ; byte [ ] [ ] path = new byte [ iip . path . length + 1 ] [ ] ; system . arraycopy ( iip . path , 0 , path , 0 , path . length - 1 ) ; path [ path . length - 1 ] = child name ; return new i node in path ( inodes , path , false , iip . snapshot id ) ; }
protect void index node ( node node ) { list < node > nod = node name to node . get ( node . get x path node name ( ) ) ; if ( node ! = null ) { node . add ( node ) ; } }
public context get context ( ) { return impl . get context ( ) ; }
public string get proxy ( ) { return proxy ; }
public uri get u r i ( ) { return u ; }
public boolean be boolean ( ) { return false ; }
public void set verify ( boolean verify ) { this . verify = verify ; }
public void set construction mode ( int mode ) { construction mode = mode ; }
public long remove last i node ( final i node in path iip ) { final int late snapshot = iip . get late snapshot id ( ) ; final i node last = iip . get last i node ( ) ; final i node directory parent = iip . get i node ( -2 ) . a directory ( ) ; if ( ! parent . remove child ( last , late snapshot ) ) { return -1 ; } return ( ! last . be in late snapshot ( late snapshot ) & & i node reference . try remove reference ( last ) > 0 ) ? 0 : 1 ; }
public void add resource ( string name ) { add resource object ( new resource ( name ) ) ; }
public string snapshot ( ) { return snapshot ; }
public string get description ( ) { return description ; }
public phase get phase ( ) { return this . phase ; }
public phase get phase ( ) { return this . phase ; }
public phase get phase ( ) { return this . phase ; }
public string get file ( ) { return this . file ; } // -- string get file ( )
public void meta save ( string pathname ) throw i o exception { dfs . meta save ( pathname ) ; }
public string get reason ( ) { return this . reason ; }
public double [ ] get point ( ) { return point ; }
public static list type list ( list list , class type ) { return type list . decorate ( list , type ) ; }
public void reset ( ) { this . element= null ; }
public int capacity ( ) { return this . buffer . capacity ( ) ; }
public object remove ( string key ) { return map . remove ( key ) ; }
public static < e > multiset . entry < e > immutable entry ( @ nullable e e , int n ) { return new immutable entry < e > ( e , n ) ; }
public int get size ( ) { return size ; }
public static destroy resource op create ( scope scope , operand < ? > resource , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` destroy resource op `` , scope . make op name ( `` destroy resource op `` ) ) ; op builder . add input ( resource . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . ignore lookup error ! = null ) { op builder . set attr ( `` ignore_lookup_error `` , opts . ignore lookup error ) ; } } } return new destroy resource op ( op builder . build ( ) ) ; }
public path get local path for write ( string path str , configuration conf ) throw i o exception { return get local path for write ( path str , size_unknown , conf ) ; }
public validation event handler get event handler ( ) throw j a x b exception { return event handler ; }
public task attempt i d get task attempt i d ( ) { return task id ; }
public class < ? extend view config > get to view ( ) { return to view ; }
public static class loader get class loader a privileged ( final class clazz ) { if ( ! has_get_class_loader_permission ) return null ; else return access controller . do privilege ( new privilege action < class loader > ( ) { public class loader run ( ) { return clazz . get class loader ( ) ; } } ) ; }
public long interval ( ) { return date histogram interval . interval ( ) ; }
public void set num reduce task ( int task ) throw illegal state exception { ensure state ( job state . define ) ; conf . set num reduce task ( task ) ; }
public tracker get tracker ( ) { return data ; }
public counter get task counter ( ) { return counter ; }
public double get value ( ) { return value ; }
public long get length ( ) { return length ; }
public void set conf ( configuration conf ) { this . conf = conf ; }
public void close ( ) throw i o exception { }
public void set filter ( boolean filter ) { this . filter = filter ; }
public static result create jar index ( file jar file , indexer indexer , boolean modify , boolean new jar , boolean verbose ) throw i o exception { return create jar index ( jar file , indexer , modify , new jar , verbose , system . out , system . err ) ; }
public void set work dir ( file work dir ) { m_working dir= work dir ; }
public void set num reduce task ( int task ) throw illegal state exception { ensure state ( job state . define ) ; conf . set num reduce task ( task ) ; }
public int get session id length ( ) { return session id length ; }
public int get max reduce task ( ) { return max_reduce_tasks ; }
public string get job name ( ) { return name ; }
public job i d get job i d ( ) { return job id ; }
public string get name ( ) { return name ; }
public static list < string > comma split ( string input ) { return any split ( input , `` , `` ) ; }
public split location info [ ] get location info ( ) throw i o exception { return null ; }
public k previous key ( final k key ) { check key ( key ) ; final node < k , v > node = next small ( lookup key ( key ) , key ) ; return node == null ? null : node . get key ( ) ; }
public void set writable ( boolean writable ) { flags |= memory byte . writable ; if ( ! writable ) flag ^= memory byte . writable ; }
public void close ( ) throw i o exception { super . close ( ) ; close = true ; }
public boolean have next ( ) { return next index ( ) > = 0 ; }
public void add create ( i resource create ) { if ( f create == null ) f create= new array list < > ( 2 ) ; f create . add ( create ) ; if ( f ignore count == 0 ) { internal add ( new create description ( create ) ) ; } }
public job current job ( ) { return ( job ) current job ; }
public mapper create mapper ( ) throw build exception { if ( mapper element ! = null ) { throw new build exception ( `` can not define more than one mapper `` , get location ( ) ) ; } mapper element = new mapper ( get project ( ) ) ; return mapper element ; }
public void write to ( writer writer ) throw i o exception { write to ( writer , writer config . minimal ) ; }
public void close ( ) throw i o exception { }
public void set msg ( string msg ) { this . msg = msg ; }
public void set conf ( configuration conf ) { this . conf = conf ; }
public static < e > queue < e > synchronize queue ( queue < e > queue ) { return synchronize . queue ( queue , null ) ; }
public static void main ( string args [ ] ) throw i o exception { job conf job = value aggregator job . create value aggregator job ( args ) ; job client . run job ( job ) ; }
public base64 u r l get encrypt key ( ) { return encrypt key ; }
public static synchronize map < string , statistic > get statistic ( ) { map < string , statistic > result = new hash map < string , statistic > ( ) ; for ( statistic stat : statistic table . value ( ) ) { result . put ( stat . get scheme ( ) , stat ) ; } return result ; }
public job i d get jobid ( ) { return job id ; }
public task attempt i d get task attempt i d ( ) { return task id ; }
public boolean contains range ( range range ) { if ( range == null ) { return false ; } return contains integer ( range . get minimum integer ( ) ) & & contain integer ( range . get maximum integer ( ) ) ; }
public long get shuffle finish time ( ) { return shuffle finish time ; }
public long get start time ( ) { return start time ; }
public void end phase ( phase phase ) { if ( ! be complete ( ) ) { phase . get ( phase ) . end time = monotonic now ( ) ; } }
public output < integer > size ( ) { return size ; }
public task attempt i d get task attempt i d ( ) { return task id ; }
protect < t > void add codec ( list < t > codecs , t codec ) { init codec ( codec ) ; codecs . add ( codec ) ; }
public static void set default uri ( configuration conf , uri uri ) { conf . set ( fs_default_name_key , uri . to string ( ) ) ; }
public u r i builder with path ( list < string > path list ) { list < path > path = path list . stream ( ) . map ( string to path ) . collect ( collector . to list ( ) ) ; return path internal ( path , false , false ) ; }
public string [ ] get location ( int i ) throw i o exception { return split [ i ] . get location ( ) ; }
public boolean be successful ( ) throw i o exception { ensure state ( job state . run ) ; update status ( ) ; return status . get state ( ) == job status . state . succeed ; }
public string get job file ( ) { ensure state ( job state . run ) ; return status . get job file ( ) ; }
public task attempt i d get task attempt i d ( ) { return task id ; }
public counter get task counter ( ) { return counter ; }
protect void status update ( task attempt status report status , long timestamp ) { string state string = report status . task state . to string ( ) ; task attempt id attempt i d = report status . id ; task id task i d = attempt i d . get task id ( ) ; job job = context . get job ( task i d . get job id ( ) ) ; if ( job == null ) { return ; } task task = job . get task ( task i d ) ; if ( task == null ) { return ; } estimator . update attempt ( report status , timestamp ) ; if ( state string . equal ( task attempt state . run . name ( ) ) ) { run task . put if absent ( task i d , boolean . true ) ; } else { run task . remove ( task i d , boolean . true ) ; if ( ! state string . equal ( task attempt state . start . name ( ) ) ) { run task attempt statistic . remove ( attempt i d ) ; } } }
public static final readable interval get readable interval ( readable interval interval ) { if ( interval == null ) { long now = date time utils . current time millis ( ) ; interval = new interval ( now , now ) ; } return interval ; }
public job i d get job i d ( ) { return job id ; }
public void set status ( string status ) { this . status = status ; } // -- void set status ( string )
public string get status ( ) { return datum . job status . to string ( ) ; }
public string get id ( ) { return id ; }
public long get map finish time ( ) { return 0 ; }
public void remove history ( resource event event ) { remove sequence value ( prefix + `` : history `` , event ) ; }
public static path get job dist cache file ( path job submit dir ) { return new path ( job submit dir , `` file `` ) ; }
public static path get job jar ( path job submit dir ) { return new path ( job submit dir , `` job . jar `` ) ; }
public void set min split size ( int size ) { min split size = size ; }
protect void set min split size node ( long min split size node ) { this . min split size node = min split size node ; }
public boolean next ( ) { if ( ! have next ) { return false ; } for ( int i = 0 ; i < m ; i++ ) { out [ i ] = in [ index [ i ] ] ; } move index ( ) ; return true ; }
public void set x path context ( x path context context ) { this . context = context ; }
public job current job ( ) { return ( job ) current job ; }
public set < k > key set ( ) { return new key set ( ) ; }
public void init ( job conf conf ) throw i o exception { set conf ( conf ) ; cluster = new cluster ( conf ) ; client ugi = user group information . get current user ( ) ; max retry = conf . get int ( m r job config . mr_client_job_max_retries , m r job config . default_mr_client_job_max_retries ) ; retry interval = conf . get long ( m r job config . mr_client_job_retry_interval , m r job config . default_mr_client_job_retry_interval ) ; }
public job i d get jobid ( ) { return job id ; }
public boolean be cache ( ) { return cache ! = null ; }
public int init transition ( int state , transition t ) { assert state < next state/2 : `` state= `` + state + `` next state= `` + next state ; t . source = state ; t . transition upto = state [ 2 * state ] ; return get num transition ( state ) ; }
protect void status update ( task attempt status report status , long timestamp ) { string state string = report status . task state . to string ( ) ; task attempt id attempt i d = report status . id ; task id task i d = attempt i d . get task id ( ) ; job job = context . get job ( task i d . get job id ( ) ) ; if ( job == null ) { return ; } task task = job . get task ( task i d ) ; if ( task == null ) { return ; } estimator . update attempt ( report status , timestamp ) ; if ( state string . equal ( task attempt state . run . name ( ) ) ) { run task . put if absent ( task i d , boolean . true ) ; } else { run task . remove ( task i d , boolean . true ) ; if ( ! state string . equal ( task attempt state . start . name ( ) ) ) { run task attempt statistic . remove ( attempt i d ) ; } } }
public task create task ( string task type ) throw build exception { return component helper . get component helper ( this ) . create task ( task type ) ; }
public void accept ( call hierarchy visitor visitor , i progress monitor progress monitor ) { if ( get parent ( ) ! = null & & get parent ( ) . be recursive ( ) ) { return ; } check canceled ( progress monitor ) ; visitor . pre visit ( this ) ; if ( visitor . visit ( this ) ) { for ( method wrapper method wrapper : get call ( progress monitor ) ) { method wrapper . accept ( visitor , progress monitor ) ; } } visitor . post visit ( this ) ; if ( progress monitor ! = null ) { progress monitor . work ( 1 ) ; } }
public static short get count short ( ) { synchronize ( helper . class ) { if ( counter < 0 ) { counter = 0 ; } return counter++ ; } }
public string get process id ( ) { return pid ; }
public static io . vertx . reactivex . ext . shell . command . command builder command ( string name ) { io . vertx . reactivex . ext . shell . command . command builder ret = io . vertx . reactivex . ext . shell . command . command builder . new instance ( ( io . vertx . ext . shell . command . command builder ) io . vertx . ext . shell . command . command builder . command ( name ) ) ; return ret ; }
public reader a reader ( ) { return new str builder reader ( ) ; }
public string get domain ( ) { return domain ; }
public string get user ( ) { return user ; }
public string get client id ( ) { return client id ; }
public void remove last token ( ) { if ( previous token==null ) { first token = current token = null ; } else { current token = previous token ; current token . set next token ( null ) ; } }
public static a h s client create a h s client ( ) { a h s client client = new a h s client impl ( ) ; return client ; }
public void set configuration ( configuration configuration ) { this . configuration = configuration ; }
public void set conf ( configuration conf ) { this . conf = conf ; }
public string get url ( ) { return url ; }
public void set args ( string [ ] args ) { if ( args == null ) { args = new string [ ] { } ; } this . args = args ; this . args list = collection . unmodifiable list ( new array list < string > ( arrays . a list ( args ) ) ) ; }
public static boolean be empty ( string s ) { return s == null || s . length ( ) == 0 ; }
public void set date ( string date ) { super . set internal date ( date ) ; }
public string get user ( ) { return user ; }
public string get url ( ) { return url ; }
public boolean get auto read ( ) { return this . auto read ; }
public long get end time stamp ( ) { return end time stamp msec ; }
public static number multiply ( number leave , character right ) { return number number multiply . multiply ( integer . value of ( right ) , leave ) ; }
public long current value ( ) { return combine high low value ( current high value ( ) , current low value ( ) ) ; }
public synchronize void get interval histogram into ( histogram target histogram ) { try { record phaser . reader lock ( ) ; update histogram ( ) ; inactive raw data histogram . copy into ( target histogram ) ; target histogram . add ( inactive pause correction histogram ) ; } finally { record phaser . reader unlock ( ) ; } }
public encodable histogram next absolute interval histogram ( final double absolute start time sec , final double absolute end time sec ) { return next interval histogram ( absolute start time sec , absolute end time sec , true ) ; }
public double get start time sec ( ) { return start time sec ; }
public synchronize double histogram get interval histogram ( double histogram histogram to recycle ) { return get interval histogram ( histogram to recycle , true ) ; }
public long get time stamp ( ) { return time stamp ; }
public index [ ] index ( ) { return index ; }
public long interval ( ) { return date histogram interval . interval ( ) ; }
public string get xml ( ) { return xml ; }
public class < ? > type for ( string type name ) { return type by name . get ( type name ) ; }
public void set map key temporal ( temporal type value ) { this . map key temporal = value ; }
public void set convert ( ) { this . convert = true ; }
public void set cascade detach ( jaxb empty type value ) { this . cascade detach = value ; }
public void set cascade remove ( jaxb empty type value ) { this . cascade remove = value ; }
public string get unique constraint name ( ) { return unique constraint name ; }
public boolean be updatable ( ) { return be updatable ; }
public final column definition column ( ) { return column ; }
public type argument < t > set converter ( converter < t > converter ) { this . converter = converter ; return this ; }
public string get converter ( ) { return converter ; }
public temporal type get temporal ( ) { return temporal ; }
public map get attribute ( ) { return attribute ; }
public table get table ( ) { return table ; }
public void set id class ( jaxb id class value ) { this . id class = value ; }
public jaxb id class get id class ( ) { return id class ; }
public void add listener ( listener listener ) { listener . add ( listener ) ; }
protect < t > t get default strategy ( application context context , class < t > strategy interface ) { list < t > strategy = get default strategy ( context , strategy interface ) ; if ( strategy . size ( ) ! = 1 ) { throw new bean initialization exception ( `` dispatcher servlet need exactly 1 strategy for interface [ `` + strategy interface . get name ( ) + `` ] `` ) ; } return strategy . get ( 0 ) ; }
public final column definition column ( ) { return column ; }
public int get max procedure name length ( ) { debug code call ( `` get max procedure name length `` ) ; return 0 ; }
public void set method ( int method ) { this . method = method ; }
public string get allocation id ( ) { check decision state ( ) ; return allocation id ; }
public final column definition column ( ) { return column ; }
public string identifier ( ) { return name ; }
public static void format_formatdatetime ( query engine query engine ) { query engine . get sqm function registry ( ) . name descriptor builder ( `` format `` , `` formatdatetime `` ) . set invariant type ( query engine . get type configuration ( ) . get basic type registry ( ) . resolve ( standard basic type . string ) ) . set exact argument count ( 2 ) . set argument list signature ( `` ( datetime a pattern ) `` ) . register ( ) ; }
public static void bitandorxornot_bit and or xor not ( query engine query engine ) { query engine . get sqm function registry ( ) . name descriptor builder ( `` bit_and `` ) . set exact argument count ( 2 ) . register ( ) ; query engine . get sqm function registry ( ) . register alternate key ( `` bitand `` , `` bit_and `` ) ; query engine . get sqm function registry ( ) . name descriptor builder ( `` bit_or `` ) . set exact argument count ( 2 ) . register ( ) ; query engine . get sqm function registry ( ) . register alternate key ( `` bitor `` , `` bit_or `` ) ; query engine . get sqm function registry ( ) . name descriptor builder ( `` bit_xor `` ) . set exact argument count ( 2 ) . register ( ) ; query engine . get sqm function registry ( ) . register alternate key ( `` bitxor `` , `` bit_xor `` ) ; query engine . get sqm function registry ( ) . name descriptor builder ( `` bit_not `` ) . set exact argument count ( 1 ) . register ( ) ; query engine . get sqm function registry ( ) . register alternate key ( `` bitnot `` , `` bit_not `` ) ; }
public static void format_formatdatetime ( query engine query engine ) { query engine . get sqm function registry ( ) . name descriptor builder ( `` format `` , `` formatdatetime `` ) . set invariant type ( query engine . get type configuration ( ) . get basic type registry ( ) . resolve ( standard basic type . string ) ) . set exact argument count ( 2 ) . set argument list signature ( `` ( datetime a pattern ) `` ) . register ( ) ; }
public static void bitandorxornot_bit and or xor not ( query engine query engine ) { query engine . get sqm function registry ( ) . name descriptor builder ( `` bit_and `` ) . set exact argument count ( 2 ) . register ( ) ; query engine . get sqm function registry ( ) . register alternate key ( `` bitand `` , `` bit_and `` ) ; query engine . get sqm function registry ( ) . name descriptor builder ( `` bit_or `` ) . set exact argument count ( 2 ) . register ( ) ; query engine . get sqm function registry ( ) . register alternate key ( `` bitor `` , `` bit_or `` ) ; query engine . get sqm function registry ( ) . name descriptor builder ( `` bit_xor `` ) . set exact argument count ( 2 ) . register ( ) ; query engine . get sqm function registry ( ) . register alternate key ( `` bitxor `` , `` bit_xor `` ) ; query engine . get sqm function registry ( ) . name descriptor builder ( `` bit_not `` ) . set exact argument count ( 1 ) . register ( ) ; query engine . get sqm function registry ( ) . register alternate key ( `` bitnot `` , `` bit_not `` ) ; }
public boolean bind limit parameter in reverse order ( ) { return false ; }
public string get pattern ( ) { return pattern ; }
public t get value ( ) { return value ; }
public void add callback ( runnable callback ) { if ( callback ! = null ) delegate . add callback ( callback ) ; }
public e get entity ( ) { return entity ; }
public name function descriptor builder name descriptor builder ( string registration key , string name ) { return new name function descriptor builder ( this , registration key , function kind . normal , name ) ; }
public name function descriptor builder name descriptor builder ( string registration key , string name ) { return new name function descriptor builder ( this , registration key , function kind . normal , name ) ; }
public name function descriptor builder name descriptor builder ( string name ) { return name descriptor builder ( name , name ) ; }
public name function descriptor builder name descriptor builder ( string registration key , string name ) { return new name function descriptor builder ( this , registration key , function kind . normal , name ) ; }
public name function descriptor builder name descriptor builder ( string name ) { return name descriptor builder ( name , name ) ; }
public u r i builder set parameter ( final string param , final string value ) { if ( this . query params == null ) { this . query params = new array list < name value pair > ( ) ; } if ( ! this . query params . be empty ( ) ) { for ( iterator < name value pair > it = this . query params . iterator ( ) ; it . have next ( ) ; ) { name value pair nvp = it . next ( ) ; if ( nvp . get name ( ) . equal ( param ) ) { it . remove ( ) ; } } } this . query params . add ( new basic name value pair ( param , value ) ) ; this . encoded query = null ; this . encoded scheme specific part = null ; return this ; }
public void set disable foreign key ( boolean value ) { this . disable foreign key = value ; }
public boolean be disable foreign key ( ) { return disable foreign key ; }
public sequence get sequence ( string sequence name ) { sequence sequence = sequence . get ( sequence name ) ; if ( sequence == null ) { throw db exception . get ( error code . sequence_not_found_1 , sequence name ) ; } return sequence ; }
public void remove last token ( ) { if ( previous token==null ) { first token = current token = null ; } else { current token = previous token ; current token . set next token ( null ) ; } }
public static list < method > get setter ( class < ? > clazz ) { method [ ] method = clazz . get method ( ) ; list < method > list = new array list < method > ( ) ; for ( method method : method ) { if ( be setter ( method ) ) { list . add ( method ) ; } } return list ; }
public least square builder parameter validator ( final parameter validator new validator ) { param validator = new validator ; return this ; }
public v put ( final k key , final v value ) { final v result = get ( key ) ; do put ( key , value ) ; return result ; }
public void clear ( ) { object . clear ( ) ; }
public int hash code ( ) { return name . hash code ( ) ; } // hash code
public boolean contains key ( t key key ) { return this . item . contains key ( key ) ; }
public static set < metric type > get predefined metric ( ) { return registry . predefined metric ( ) ; }
public sequence get sequence ( string sequence name ) { sequence sequence = sequence . get ( sequence name ) ; if ( sequence == null ) { throw db exception . get ( error code . sequence_not_found_1 , sequence name ) ; } return sequence ; }
public final query get query ( ) { return query ; }
public void set word count ( final int word count ) { set1st property ( property i d map . pid_wordcount , word count ) ; }
public void push ( char e1 , char e2 ) { ensure buffer space ( 2 ) ; buffer [ element count++ ] = e1 ; buffer [ element count++ ] = e2 ; }
public byte adjust or put value ( byte key , byte new value , byte incr value ) { boolean present = contains key ( key ) ; if ( present ) { new value = ( byte ) ( get ( key ) + incr value ) ; put ( key , new value ) ; } else { put ( key , new value ) ; } return new value ; }
public void push ( byte e1 , byte e2 ) { ensure buffer space ( 2 ) ; buffer [ element count++ ] = e1 ; buffer [ element count++ ] = e2 ; }
public void push ( char e1 , char e2 ) { ensure buffer space ( 2 ) ; buffer [ element count++ ] = e1 ; buffer [ element count++ ] = e2 ; }
public void set auto compaction factor ( float factor ) { if ( factor < 0 ) { throw new illegal argument exception ( `` factor must be > = 0 : `` + factor ) ; } _auto compaction factor = factor ; }
public void set entity resolver ( entity resolver entity resolver ) { this . entity resolver = entity resolver ; }
public static boolean be protect ( int flag ) { return ( flags & protect ) ! = 0 ; }
public string to string ( ) { string buffer buf = new string buffer ( `` @ `` ) ; buf . append ( get type name ( ) ) ; if ( member ! = null ) { buf . append ( `` ( `` ) ; for ( string name : member . key set ( ) ) { buf . append ( name ) . append ( `` = `` ) . append ( get member value ( name ) ) . append ( `` , `` ) ; } buf . set length ( buf . length ( ) -2 ) ; buf . append ( `` ) `` ) ; } return buf . to string ( ) ; }
public float get drop threshold ( ) { return drop threshold ; }
public void set encoding ( string encode ) { this . encode = encoding ; } // -- void set encoding ( string )
protect string description start ( ) { return `` [ `` ; }
public date to date ( ) { return new date ( get millis ( ) ) ; }
public void set true ( ) { this . value = true ; }
public final int get max entry ( ) { return max entry ; }
public boolean be cache ( ) { return cache ! = null ; }
public double get start time sec ( ) { return start time sec ; }
public void reset ( ) { clear ( ) ; this . reference count = 0 ; }
public boolean get scope ( ) { return scope ; }
public long get thread count ( ) { return thread counter . get ( ) ; }
public long get thread count ( ) { return thread counter . get ( ) ; }
public synchronize service thread pool ( int max thread ) { return thread pool ( max thread , -1 , -1 ) ; }
public void set local context ( logger context context ) { thread local . set ( context ) ; }
public static message get ( final message supplier supplier ) { if ( supplier == null ) { return null ; } return supplier . get ( ) ; }
public object get instance ( ) { return instance ; }
public static boolean equal ( object a , object b ) { return a == b || ( a ! = null & & a . equal ( b ) ) ; }
public int get wait ( ) { if ( ! have waiter ( ) ) return 0 ; iterator < register signal > iter = queue . iterator ( ) ; int count = 0 ; while ( iter . have next ( ) ) { signal next = iter . next ( ) ; if ( ! next . be cancel ( ) ) count++ ; } return count ; }
public void set pretty ( boolean pretty ) { if ( ! disable pretty x m l ) { this . pretty = pretty ; } }
public c t adjust handle list get ah lst ( ) { return ah lst ; }
public compilation unit set import ( final node list < import declaration > import ) { assert not null ( import ) ; if ( import == this . import ) { return this ; } notify property change ( observable property . import , this . import , import ) ; if ( this . import ! = null ) this . import . set parent node ( null ) ; this . import = import ; set a parent node of ( import ) ; return this ; }
public setting get setting ( ) { return setting ; }
public string get id ( ) { return this . id ; }
public void add configuration ( string conf ) { confs . add ( conf ) ; }
public map get attribute ( ) { return attribute ; }
public long get total ( ) { return this . total ; }
public static context get static context ( ) { return static context ; }
public object peek ( string stack name ) { return peek ( stack name , 0 ) ; }
public void set context ( final @ not null string key , final @ not null object value ) { this . context . put ( key , value ) ; }
public void set conf ( configuration conf ) { this . conf = conf ; }
public string get encode ( ) { return encode ; }
public object get attribute ( string attribute name ) { return attribute map . get ( attribute name ) ; }
public object get report ( ) { return this . report ; } // -- object get report ( )
public void set revision number ( int revision number ) { if ( revision number < 0 ) { throw new illegal argument exception ( `` the revision number shall be > -1 `` ) ; } this . get c o s object ( ) . set int ( c o s name . r , revision number ) ; }
public void add configuration ( string conf ) { confs . add ( conf ) ; }
public artifact download report [ ] get artifact report ( download status download status , boolean with evict ) { collection all = new link hash set ( ) ; collection evict mrids = null ; if ( ! with evict ) { evicted mrids = get evicted mrids ( ) ; } for ( iterator iter = dependency report . value ( ) . iterator ( ) ; iter . have next ( ) ; ) { collection report = ( collection ) iter . next ( ) ; for ( iterator it report = report . iterator ( ) ; it report . have next ( ) ; ) { artifact download report report = ( artifact download report ) it report . next ( ) ; if ( download status ! = null & & report . get download status ( ) ! = download status ) { continue ; } if ( with evict || ! evicted mrids . contains ( report . get artifact ( ) . get module revision id ( ) ) ) { all . add ( report ) ; } } } return ( artifact download report [ ] ) all . to array ( new artifact download report [ all . size ( ) ] ) ; }
public object get root ( ) { return root ; }
public list < file > get file ( ) { return file ; }
public void set module ( final list < module > module ) { this . module = module ; }
public void set ignore ( boolean ignore ) { this . ignore = ignore ; }
public void set module ( final list < module > module ) { this . module = module ; }
public static string object to string ( object value ) { if ( value == null ) { return `` null `` ; } else if ( value instanceof object [ ] ) { return array . deep to string ( ( object [ ] ) value ) ; } else if ( value . get class ( ) . be array ( ) ) { string builder sb = new string builder ( ) ; sb . append ( ' [ ' ) ; for ( int i = 0 ; i < array . get length ( value ) ; i++ ) { if ( i ! = 0 ) sb . append ( `` , `` ) ; sb . append ( string . value of ( array . get ( value , i ) ) ) ; } sb . append ( ' ] ' ) ; return sb . to string ( ) ; } else { return value . to string ( ) ; } }
public static string get user from u r i ( uri uri ) { string user info = uri . get user info ( ) ; if ( user info == null & & `` domain `` . equal ( uri . get scheme ( ) ) ) { final string ssp = uri . get scheme specific part ( ) ; final int at = ssp . last index of ( ' @ ' ) ; if ( at == -1 ) { return null ; } user info = ssp . substring ( 0 , at ) ; } if ( user info ! = null ) { final int colon = user info . index of ( ' : ' ) ; if ( colon ! = -1 ) { user info = user info . substring ( 0 , colon ) ; } } return user info ; }
public list < resource > get child resource ( ) { return child resource ; }
public void set publish ( final date publish ) { this . publish = date . copy ( publish ) ; }
public void set password ( string password ) { this . password = password ; }
public void set port ( int port ) { this . port = port ; }
public artifact filter get collection filter ( ) { return collection filter ; }
public self with build ( boolean build ) { this . build = build ; return self ( ) ; }
public url get u r l ( ) { return ( resource utils . get resource a u r l ( this , this ) ) ; }
public boolean be restrict ( ) { return restrict ; }
public static void set current prefix separator ( string sep ) { prefix separator . set ( sep ) ; }
public void set file ( file file ) { this . file = file ; }
public int get index ( ) { return index ; }
public string contain type name ( int index ) { return null ; }
public int contain type count ( ) { return 0 ; }
public boolean be rename detection enable ( ) { return rename detection type ! = rename detection type . false ; }
public static class < ? > get type ( object object ) { class < ? > type = null ; if ( be class ( object ) ) { type = ( class < ? > ) object ; } else if ( object ! = null ) { type = object . get class ( ) ; } return type ; }
public void set include ( string value ) { this . include = value ; }
protect unsupported operation exception create unsupported operation exception ( string name ) { return new unsupported operation exception ( name + `` be not implement by `` + this . get class ( ) . get name ( ) ) ; }
public object writer with default pretty printer ( ) { return with ( _config . get default pretty printer ( ) ) ; }
public void set xml decl ( boolean _write xml decl ) { this . write xml decl = _write xml decl ; }
public static iterable < annotation > get tester annotation ( annotate element class or method ) { synchronize ( annotation cache ) { list < annotation > annotation = annotation cache . get ( class or method ) ; if ( annotation == null ) { annotation = new array list < > ( ) ; for ( annotation a : class or method . get declared annotation ( ) ) { if ( a . annotation type ( ) . be annotation present ( tester annotation . class ) ) { annotation . add ( a ) ; } } annotation = collection . unmodifiable list ( annotation ) ; annotation cache . put ( class or method , annotation ) ; } return annotation ; } }
protect closure resolve explicit method ( string method name , object args ) { return get explicit method ( ) . get ( method name ) ; }
public final serializer factory with serializer modifier ( bean serializer modifier modifier ) { return with config ( _factory config . with serializer modifier ( modifier ) ) ; }
public boolean be expect start array token ( ) { return current token ( ) == json token . start_array ; }
public string get query ( ) { return query ; }
public int size ( ) { return size ; }
public lat lon quad add to coordinate ( final double longitude , final double latitude ) { this . get coordinate ( ) . add ( new coordinate ( longitude , latitude ) ) ; return this ; }
public static geoshape point ( final double latitude , final double longitude ) { precondition . check argument ( be valid coordinate ( latitude , longitude ) , `` invalid coordinate provide `` ) ; return new geoshape ( get shape factory ( ) . point x y ( longitude , latitude ) ) ; }
public string get hostname ( ) { return get node ( ) . get host name ( ) ; }
public deletion time start deletion time ( ) { return start deletion ; }
public void write ( byte [ ] buffer ) { output buffer . write ( buffer , 0 , buffer . length ) ; }
public single < list < io . vertx . kafka . client . common . partition info > > rx partition for ( string topic ) { return async result single . to single ( handler - > { partition for ( topic , handler ) ; } ) ; }
public string get query ( ) { return query ; }
public void set verify ( boolean verify ) { this . verify = verify ; }
public int num heap arena ( ) { return heap arena metric . size ( ) ; }
public static bit set and ( bit set left , bit set right ) { bit set result = ( bit set ) leave . clone ( ) ; result . and ( right ) ; return result ; }
protect void index node ( node node ) { list < node > nod = node name to node . get ( node . get x path node name ( ) ) ; if ( node ! = null ) { node . add ( node ) ; } }
public org . w3c . dom . c d a t a section output ( cdata cdata ) throw j d o m exception { return processor . process ( adapter . create document ( ) , format , cdata ) ; }
public boolean point in bound ( double lon , double lat ) { if ( lat > = bottom ( ) & & lat < = top ( ) ) { if ( left ( ) < = right ( ) ) { return lon > = leave ( ) & & lon < = right ( ) ; } else { return lon > = leave ( ) || lon < = right ( ) ; } } return false ; }
public abstract view add to abstract view object extension ( final abstract object abstract view object extension ) { this . get abstract view object extension ( ) . add ( abstract view object extension ) ; return this ; }
public abstract view add to abstract view object extension ( final abstract object abstract view object extension ) { this . get abstract view object extension ( ) . add ( abstract view object extension ) ; return this ; }
public void set abstract view object extension ( final list < abstract object > abstract view object extension ) { this . abstract view object extension = abstract view object extension ; }
public document add to document simple extension ( final object document simple extension ) { this . get document simple extension ( ) . add ( document simple extension ) ; return this ; }
public string get extension ( ) { return this . extension ; } // -- string get extension ( )
public document add to document object extension ( final abstract object document object extension ) { this . get document object extension ( ) . add ( document object extension ) ; return this ; }
public document add to document simple extension ( final object document simple extension ) { this . get document simple extension ( ) . add ( document simple extension ) ; return this ; }
public ground overlay add to grind overlay object extension ( final abstract object ground overlay object extension ) { this . get ground overlay object extension ( ) . add ( ground overlay object extension ) ; return this ; }
public ground overlay add to grind overlay simple extension ( final object ground overlay simple extension ) { this . get ground overlay simple extension ( ) . add ( ground overlay simple extension ) ; return this ; }
public static geoshape point ( final double latitude , final double longitude ) { precondition . check argument ( be valid coordinate ( latitude , longitude ) , `` invalid coordinate provide `` ) ; return new geoshape ( get shape factory ( ) . point x y ( longitude , latitude ) ) ; }
public style map add to style map object extension ( final abstract object style map object extension ) { this . get style map object extension ( ) . add ( style map object extension ) ; return this ; }
public document add to document simple extension ( final object document simple extension ) { this . get document simple extension ( ) . add ( document simple extension ) ; return this ; }
public double [ ] get point ( ) { return point ; }
public schema get schema ( ) { return schema ; }
public style map add to style map object extension ( final abstract object style map object extension ) { this . get style map object extension ( ) . add ( style map object extension ) ; return this ; }
public style map add to style map simple extension ( final object style map simple extension ) { this . get style map simple extension ( ) . add ( style map simple extension ) ; return this ; }
public long get time stamp ( ) { return time stamp ; }
public list < object > get method or resource ( ) { if ( method or resource == null ) { method or resource = new array list < object > ( ) ; } return this . method or resource ; }
public abstract view add to abstract view simple extension ( final object abstract view simple extension ) { this . get abstract view simple extension ( ) . add ( abstract view simple extension ) ; return this ; }
public string [ ] get dependent bean ( string bean name ) { set < string > dependent bean = this . dependent bean map . get ( bean name ) ; if ( dependent bean == null ) { return new string [ 0 ] ; } return string utils . to string array ( dependent bean ) ; }
public long large ( ) { return large ; }
public route [ ] get route ( ) { return route ; }
public premise add to premise name ( final premise . premise name premise name ) { this . get premise name ( ) . add ( premise name ) ; return this ; }
public void set premise name ( final list < premise . premise name > premise name ) { this . premise name = premise name ; }
public premise add to premise name ( final premise . premise name premise name ) { this . get premise name ( ) . add ( premise name ) ; return this ; }
public object get data ( ) { return data ; }
public void set ( int start , int end ) { if ( start == end ) return ; int firstword = start / 64 ; int endword = ( end - 1 ) / 64 ; if ( firstword == endword ) { this . data [ firstword ] |= ( ~0l < < start ) & ( ~0l > > > -end ) ; return ; } this . data [ firstword ] |= ~0l < < start ; for ( int i = firstword+1 ; i < endword ; i++ ) this . data [ i ] = ~0 ; this . data [ endword ] |= ~0l > > > -end ; }
public int orcardinality ( word array b ) { int sum = 0 ; for ( int k = 0 ; k < math . min ( this . get number of word ( ) , b . get number of word ( ) ) ; ++k ) { sum += long . bit count ( this . get word ( k ) | b . get word ( k ) ) ; } word array longer = b . get number of word ( ) < this . get number of word ( ) ? this : b ; for ( int k = math . min ( this . get number of word ( ) , b . get number of word ( ) ) ; k < math . max ( this . get number of word ( ) , b . get number of word ( ) ) ; ++k ) { sum += long . bit count ( longer . get word ( k ) ) ; } return sum ; }
public final static int murmur hash3 ( int x ) { x ^= x > > > 16 ; x * = 0x85ebca6b ; x ^= x > > > 13 ; x * = 0xc2b2ae35 ; x ^= x > > > 16 ; return x ; }
public boolean intersects ( word array b ) { for ( int k = 0 ; k < math . min ( this . get number of word ( ) , b . get number of word ( ) ) ; ++k ) { if ( ( this . get word ( k ) & b . get word ( k ) ) ! = 0 ) return true ; } return false ; }
public boolean set size in bit ( final int size , final boolean default value ) { if ( size < = this . size in bit ) { return false ; } if ( ( this . size in bit % word_in_bits ) ! = 0 ) { if ( ! default value ) { if ( this . rlw . get number of literal word ( ) > 0 ) { final int bit to add = size - this . size in bit ; final int use bit in last = this . size in bit % word_in_bits ; final int free bit in last = word_in_bits - use bit in last ; if ( this . buffer . get last word ( ) == 0l ) { this . rlw . set number of literal word ( this . rlw . get number of literal word ( ) - 1 ) ; this . buffer . remove last word ( ) ; this . size in bit -= use bit in last ; } else if ( use bit in last > 0 ) { this . size in bit += math . min ( bit to add , free bit in last ) ; } } } else { if ( this . rlw . get number of literal word ( ) == 0 ) { this . rlw . set run length ( this . rlw . get running length ( ) - 1 ) ; insert literal word ( 0 ) ; } final int mask width = math . min ( word_in_bits - this . size in bit % word_in_bits , size - this . size in bit ) ; final int mask shift = this . size in bit % word_in_bits ; final long mask = ( ( ~0l ) > > > ( word_in_bits - mask width ) ) < < mask shift ; this . buffer . or last word ( mask ) ; if ( this . buffer . get last word ( ) == ~0l ) { this . buffer . remove last word ( ) ; this . rlw . set number of literal word ( this . rlw . get number of literal word ( ) - 1 ) ; insert empty word ( true ) ; } this . size in bit += mask width ; } } this . add stream of empty word ( default value , ( size / word_in_bits ) - ( this . size in bit / word_in_bits ) ) ; if ( this . size in bit < size ) { final int dist = distance in word ( size - 1 ) ; if ( dist > 0 ) { insert literal word ( 0 ) ; } if ( default value ) { final int mask width = size - this . size in bit ; final int mask shift = this . size in bit % word_in_bits ; final long mask = ( ( ~0l ) > > > ( word_in_bits - mask width ) ) < < mask shift ; this . buffer . or last word ( mask ) ; } this . size in bit = size ; } return true ; }
public void clear ( int start , int end ) { if ( start == end ) return ; int firstword = start / 64 ; int endword = ( end - 1 ) / 64 ; if ( firstword == endword ) { this . data [ firstword ] & = ~ ( ( ~0l < < start ) & ( ~0l > > > -end ) ) ; return ; } this . data [ firstword ] & = ~ ( ~0l < < start ) ; for ( int i = firstword+1 ; i < endword ; i++ ) this . data [ i ] = 0 ; this . data [ endword ] & = ~ ( ~0l > > > -end ) ; }
public int orcardinality ( word array b ) { int sum = 0 ; for ( int k = 0 ; k < math . min ( this . get number of word ( ) , b . get number of word ( ) ) ; ++k ) { sum += long . bit count ( this . get word ( k ) | b . get word ( k ) ) ; } word array longer = b . get number of word ( ) < this . get number of word ( ) ? this : b ; for ( int k = math . min ( this . get number of word ( ) , b . get number of word ( ) ) ; k < math . max ( this . get number of word ( ) , b . get number of word ( ) ) ; ++k ) { sum += long . bit count ( longer . get word ( k ) ) ; } return sum ; }
public int size ( ) { return this . get number of word ( ) * 64 ; }
public boolean count down ( ) { assert original count > 0 ; for ( ; ; ) { final int current = count down . get ( ) ; assert current > = 0 ; if ( current == 0 ) { return false ; } if ( count down . compare and set ( current , current - 1 ) ) { return current == 1 ; } } }
public void discharge a empty ( bitmap storage container ) { while ( size ( ) > 0 ) { container . add stream of empty word ( false , size ( ) ) ; discard first word ( size ( ) ) ; } }
public boolean contains ( int value ) { for ( int i = 0 ; i < count ; i++ ) if ( entry [ i ] == value ) return true ; return false ; }
public void resize ( int size in bit ) { this . data = array . copy of ( this . data , ( size in bit + 63 ) / 64 ) ; }
public static e w a h compress bitmap bufferedand ( final int buf size , final e w a h compressed bitmap . . . bitmap ) { e w a h compressed bitmap answer = new e w a h compress bitmap ( ) ; bufferedand with container ( answer , buf size , bitmap ) ; return answer ; }
public counter get task counter ( ) { return counter ; }
public static e w a h compress bitmap threshold ( final int t , final e w a h compressed bitmap . . . bitmap ) { final e w a h compress bitmap container = new e w a h compress bitmap ( ) ; threshold with container ( container , t , bitmap ) ; return container ; }
public static e w a h compress bitmap threshold ( final int t , final e w a h compressed bitmap . . . bitmap ) { final e w a h compress bitmap container = new e w a h compress bitmap ( ) ; threshold with container ( container , t , bitmap ) ; return container ; }
public void discharge ( bitmap storage container ) { this . brlw . literal word offset = this . literal word start position - this . iterator . literal word ( ) ; discharge ( this . brlw , this . iterator , container ) ; }
public void discharge a empty ( bitmap storage container ) { while ( size ( ) > 0 ) { container . add stream of empty word ( false , size ( ) ) ; discard first word ( size ( ) ) ; } }
public boolean contains key ( k k ) { return ! get ( k ) . be empty ( ) ; }
public int get max literal length ( ) { return max literal length ; }
public string get name ( ) { return this . name ; }
public void set upper bound byte ( int upper bound bytes ) { this . upper bound bytes = upper bound byte ; }
public int host class index ( ) { return byte array . read u16bit ( info , 0 ) ; }
public void insert ex ( int po , byte [ ] code ) throw bad bytecode { insert0 ( po , code , true ) ; }
public method info list get declare constructor info ( ) { return get declare method info ( / * method name = * / null , / * get normal method = * / false , / * get constructor method = * / true , / * get static initializer method = * / false ) ; }
public static boolean be private ( int mod ) { return ( mod & private ) ! = 0 ; }
public static boolean be abstract ( int mod ) { return ( mod & abstract ) ! = 0 ; }
public void add bean name resolver ( bean name resolver bean name resolver ) { get e l context ( ) . add e l resolver ( new bean name e l resolver ( bean name resolver ) ) ; }
public void add e l resolver ( e l resolver el resolver ) { get e l context ( ) . add e l resolver ( el resolver ) ; }
public object eval ( string expression ) { return get value ( expression , object . class ) ; }
public context get base context ( ) throw name exception { if ( base context == null ) { base context = ( context ) get context ( ) . lookup ( prefix == null ? `` `` : prefix ) ; } return base context ; }
public object create builder create object ( ) { return add provider ( new object create builder ( key pattern , namespace u r i , main binder , this , class loader ) ) ; }
public big integer to big integer ( byte [ ] in ) { byte [ ] out = new byte [ in . length ] ; for ( int i = 0 ; i < in . length ; i++ ) { out [ i ] = in [ in . length-1-i ] ; } return new big integer ( 1 , out ) ; }
protect final void request ( long n ) { subscription s = this . s ; if ( s ! = null ) { s . request ( n ) ; } }
public void add handler ( handler handler ) { set handler ( array util . add to array ( get handler ( ) , handler , handler . class ) ) ; }
public void stop ( ) { stop ( true ) ; }
protect void open ( ) { open writer ( ) ; }
public synchronize quota [ ] get quota ( string root ) throw message exception { check connect ( ) ; quota [ ] qa = null ; i m a p protocol p = null ; try { p = get store protocol ( ) ; qa = p . get quota root ( root ) ; } catch ( bad command exception bex ) { throw new message exception ( `` quota not support `` , bex ) ; } catch ( connection exception cex ) { throw new store close exception ( this , cex . get message ( ) ) ; } catch ( protocol exception pex ) { throw new message exception ( pex . get message ( ) , pex ) ; } finally { release store protocol ( p ) ; } return qa ; }
public void set acl ( g s access control list acl ) { this . acl = acl ; }
public void set right list ( final list < string > right ) { this . right = right ; }
public void set language ( final string language ) { this . language = list . create ( language ) ; }
public static boolean be negative permanent ( int reply ) { return ( reply > = 500 & & reply < 600 ) ; }
public string get proxy auth user ( ) { return proxy auth user ; }
public file new folder ( string folder ) throw i o exception { return new folder ( new string [ ] { folder } ) ; }
public void debug ( string msg , throwable t ) { if ( logger . be loggable ( level . fine ) ) { log ( self , level . fine , msg , t ) ; } }
public item [ ] get response ( ) { return this . item ; }
public boolean be r e v1 ( ) { return rev1 ; }
public string get proxy auth user ( ) { return proxy auth user ; }
public http request with body ( body body ) { this . body = body ; return this ; }
public string to string ( ) { final string buffer sb = new string buffer ( ) ; for ( int i = 0 ; i < component . length ; i++ ) { if ( i ! = 0 ) { sb . append ( ' . ' ) ; } sb . append ( component [ i ] ) ; } return sb . to string ( ) ; }
public string get text ( ) { return text ; }
public void set right ( final string right ) { this . right = list . create ( right ) ; }
public string get message ( ) { return message ; }
public void close ( ) throw i o exception { super . close ( ) ; close = true ; }
public file new folder ( string folder ) throw i o exception { return new folder ( new string [ ] { folder } ) ; }
public void add ( resource collection rc ) { get path ( ) . add ( rc ) ; }
public string get extension ( ) { return this . extension ; } // -- string get extension ( )
public boolean equal ( string s ) { char [ ] c = buff ; int len = end - start ; if ( c == null || len ! = s . length ( ) ) { return false ; } int off = start ; for ( int i = 0 ; i < len ; i++ ) { if ( c [ off++ ] ! = s . char at ( i ) ) { return false ; } } return true ; }
public int get level ( ) { return level ; }
public comparator get comparator ( ) { return comparator ; }
public void remove subject ( string subject ) { remove bag value ( prefix + `` : subject `` , subject ) ; }
public int get port ( ) { return this . port ; }
public void set logger ( log logger ) { this . logger = logger ; }
public void debug ( string msg , throwable t ) { if ( logger . be loggable ( level . fine ) ) { log ( self , level . fine , msg , t ) ; } }
public request trace get trace ( ) { return trace ; }
public string get mode ( ) { return mode ; }
public string get mode ( ) { return mode ; }
public message [ ] get message ( ) { return msg ; }
public message get message ( ) { return msg ; }
public item get item ( ) { return null ; }
public int get flag ( ) { return flag ; }
protect void notify folder rename listener ( folder old f , folder new f ) { if ( folder listener == null ) return ; folder event e = new folder event ( this , old f , new f , folder event . rename ) ; queue event ( e , folder listener ) ; }
public mime type parameter list get parameter ( ) { return parameter ; }
public type get type ( ) { return type ; }
public static boolean be empty ( string s ) { return s == null || s . length ( ) == 0 ; }
public void set header name ( string header name ) { assert . have length ( header name , `` header name ca n't be null `` ) ; this . header name = header name ; }
public int get flag ( ) { return flag ; }
public string to string ( ) { return set . to string ( ) ; }
public string get encode ( ) { return encode ; }
public force merge request only expunge deletes ( boolean only expunge deletes ) { this . only expunge deletes = only expunge deletes ; return this ; }
public string get class name ( ) { return class name ; }
public inet address get address ( ) { return address . get address ( ) ; }
protect session get session ( string path or uri ) throw i o exception { uri uri = parse u r i ( path or uri ) ; string host = get host ( ) ; int port = get port ( ) ; string user = get user ( ) ; string user password = get user password ( ) ; if ( uri ! = null & & uri . get scheme ( ) ! = null ) { if ( uri . get host ( ) ! = null ) { host = uri . get host ( ) ; } if ( uri . get port ( ) ! = -1 ) { port = uri . get port ( ) ; } if ( uri . get user info ( ) ! = null ) { string user info = uri . get user info ( ) ; if ( user info . index of ( `` : `` ) == -1 ) { user = user info ; } else { user = user info . substring ( 0 , user info . index of ( `` : `` ) ) ; user password = user info . substring ( user info . index of ( `` : `` ) + 1 ) ; } } } if ( host == null ) { throw new illegal argument exception ( `` miss host information . host should be provide either `` + `` directly on the repository or in the connection uri `` ) ; } if ( user == null ) { credential c = request credential ( host ) ; if ( c ! = null ) { user = c . get user name ( ) ; user password = c . get passwd ( ) ; } else { message . error ( `` username be not set `` ) ; } } return ssh cache . get instance ( ) . get session ( host , port , user , user password , get key file ( ) , get key file password ( ) , get pas file ( ) ) ; }
public string get store name ( ) { return store name ; }
public authentication builder add password ( string password ) { return add secret ( authentication context . password , password ) ; }
public folder get folder ( ) { return null ; }
protect void notify folder rename listener ( folder folder ) { if ( folder listener ! = null ) { folder event e = new folder event ( this , this , folder , folder event . rename ) ; queue event ( e , folder listener ) ; } store . notify folder rename listener ( this , folder ) ; }
public transport client add transport address ( transport address . . . transport address ) { nodes service . add transport address ( transport address ) ; return this ; }
public void set package ( boolean package ) { this . package = package ; } // -- void set package ( boolean )
public void add grammar ( input source be ) { grammar . add ( absolutize ( be ) ) ; }
public j switch _switch ( j expression test ) { return insert ( new j switch ( test ) ) ; }
public j block assign ( j assignment target lh , j expression exp ) { insert ( new j assignment ( lhs , exp ) ) ; return this ; }
public object [ ] get insert ( ) { return this . insert ; }
public final class < ? > get raw class ( ) { return _class ; }
public void set d dir ( file d dir ) { this . d dir = d dir ; }
public block [ ] basic block ( ) { return basic block ; }
public void set method ( int method ) { this . method = method ; }
public string get comment ( ) { return comment ; }
public string get expression ( ) { return expression ; }
public void set name ( string name ) { this . name = name ; }
public iterator iterator ( ) { return new iterator ( ) ; }
public final boolean be empty local name ( ) { return path . length == 0 ; }
public static list < class < ? > > get generic type argument class ( final type type ) throw illegal argument exception { final type [ ] type = get type argument ( type ) ; if ( type == null ) { return collection . empty list ( ) ; } return array . stream ( type ) . map ( ( function < type , class < ? > > ) reflection helper : : erasure ) . collect ( collector . to list ( ) ) ; }
public final boolean have type bound ( ) { return get type bound node ( ) ! = null ; }
public catalog get catalog ( ) { return catalog resolver . get catalog ( ) ; }
public static url a local u r l ( url url ) throw i o exception { return file locator . to file u r l ( url ) ; }
public catalog get catalog ( ) { return catalog resolver . get catalog ( ) ; }
public catalog get catalog ( ) { return catalog resolver . get catalog ( ) ; }
public stack frame push ( string type ) { stack state ns = stack state . push ( type ) ; return new stack frame ( ns , local variable state , type no local change ( ns ) ) ; }
public string get class name ( ) { return class name ; }
public void set name ( string name ) { this . name = name ; }
public final q name get xml name ( ) { return xml name ; }
public synchronize com . sun . msv . grammar . grammar get grammar ( ) throw j a x b exception { if ( grammar==null ) grammar = gi . get grammar ( ) ; return grammar ; }
public string get class name ( ) { return get class info ( this class info ) ; }
public void remove namespace ( string uri ) { if ( _inverted ) add namespace impl ( uri ) ; else remove namespace impl ( uri ) ; }
public void set document locator ( locator loc ) { locator = loc ; parse location listener pll = rdf parser . get parse location listener ( ) ; if ( pll ! = null & & loc ! = null ) { pll . parse location update ( loc . get line number ( ) , loc . get column number ( ) ) ; } }
public static boolean be empty ( string s ) { return s == null || s . length ( ) == 0 ; }
public string to string ( ) { return set . to string ( ) ; }
public document get document ( ) { return document ; }
public void set type ( string type ) { this . type = type ; }
public static builder builder ( ) { return new builder ( ) ; }
public type component ( ) { return component ; }
public static long parse long ( string s ) { s = trim plus sign ( s ) ; return long . parse long ( s ) ; }
public boolean be read only ( ) { return this . read only ; }
public locale get locale ( ) { return locale ; }
public void set d ( file d ) { this . d = d ; }
public locale get locale ( ) { return locale ; }
public int size ( ) { return size ; }
public final item current ( ) { return current ; }
public object get attribute ( string attribute name ) { return attribute map . get ( attribute name ) ; }
public int get parser count ( ) { return parser manager==null ? 0 : parser manager . get parser count ( ) ; }
public int length ( object obj ) { if ( be array ( obj ) ) { return ( ( list ) obj ) . size ( ) ; } else if ( be map ( obj ) ) { return get property key ( obj ) . size ( ) ; } else if ( obj instanceof string ) { return ( ( string ) obj ) . length ( ) ; } throw new json path exception ( `` length operation can not be apply to `` + obj ! =null ? obj . get class ( ) . get name ( ) : `` null `` ) ; }
public void error ( s a x parse exception exception ) throw s a x exception { throw exception ; }
public x s schema set get result ( ) throw s a x exception { return context . get result ( ) ; }
public static < a extend annotation > list < a > get repeatable annotation ( method method , class < a > annotation class ) { a [ ] annotation = method . get annotation by type ( annotation class ) ; if ( annotation == null || annotation . length == 0 ) { for ( annotation meta annotation : method . get annotation ( ) ) { annotation = meta annotation . annotation type ( ) . get annotation by type ( annotation class ) ; if ( annotation ! = null & & annotation . length > 0 ) { return array . a list ( annotation ) ; } } method superclass method = get overridden method ( method ) ; if ( superclass method ! = null ) { return get repeatable annotation ( superclass method , annotation class ) ; } } if ( annotation == null ) { return null ; } return array . a list ( annotation ) ; }
public string get domain ( ) { return domain ; }
public stack frame push ( stack entry entry ) { stack state ns = stack state . push ( entry ) ; return new stack frame ( ns , local variable state , type no local change ( ns ) ) ; }
public stack frame push ( string type ) { stack state ns = stack state . push ( type ) ; return new stack frame ( ns , local variable state , type no local change ( ns ) ) ; }
public stack frame push ( string type ) { stack state ns = stack state . push ( type ) ; return new stack frame ( ns , local variable state , type no local change ( ns ) ) ; }
public void set slot number ( int slot ) { slot number = slot ; }
public long get window size ( ) { return window size ; }
public void remove ( ) { throw new unsupported operation exception ( ) ; }
public void set page ( p d page page ) { this . page = page ; }
public void set color ( p d gamma color ) { this . set color ( color , color ) ; }
public boolean be attribute ( ) { return attribute ; }
public final set < namespace > get namespaces ( ) { return namespaces ; }
public comparator comparator ( ) { return comparator ; }
public x s schema set get result ( ) throw s a x exception { return context . get result ( ) ; }
public void set ignore element content whitespace ( boolean ignore white ) { this . ignore white = ignore white ; }
public x m l builder cdata ( string data ) { xml node . append child ( get document ( ) . create c d a t a section ( data ) ) ; return this ; }
public iterable < namespace > add reverse ( ) { if ( added [ depth ] . length == 0 ) { return emptyiter ; } return new namespace iterable ( added [ depth ] , false ) ; }
public iterable < namespace > add forward ( ) { if ( added [ depth ] . length == 0 ) { return emptyiter ; } return new namespace iterable ( added [ depth ] , true ) ; }
public static boolean be x m l name character ( char c ) { return ( be x m l letter ( c ) || be x m l digit ( c ) || c == ' . ' || c == '- ' || c == ' _ ' || c == ' : ' || be x m l combine char ( c ) || be x m l extender ( c ) ) ; }
public x path variable declare variable ( q name value qname ) { return declare variable ( qname . get namespace u r i ( ) , qname . get local name ( ) ) ; }
public metadata adapter get metadata adapter ( ) { if ( metadata adapter ! = null ) return metadata adapter ; else { try { return ( metadata adapter = new javassist adapter ( ) ) ; } catch ( throwable e ) { if ( reflection . log ! = null ) reflection . log . warn ( `` could not create javassist adapter , use java reflection adapter `` , e ) ; return ( metadata adapter = new java reflection adapter ( ) ) ; } } }
public string get u r i ( ) { return uri ; }
public static object output stream new object output stream ( output stream output stream ) throw i o exception { return new object output stream ( output stream ) ; }
public element next ( ) { return the next ; }
public static string method_empty_path_annotation ( object arg0 , object arg1 ) { return localizer . localize ( localizable m e t h o d_ e m p t y_ p a t h_ a n n o t a t i o n ( arg0 , arg1 ) ) ; }
public static string too_many_header_values ( object arg0 , object arg1 ) { return localizer . localize ( localizable t o o_ m a n y_ h e a d e r_ v a l u e s ( arg0 , arg1 ) ) ; }
public final servlet context get servlet context ( ) { return this . servlet context ; }
public sequence get sequence ( string sequence name ) { sequence sequence = sequence . get ( sequence name ) ; if ( sequence == null ) { throw db exception . get ( error code . sequence_not_found_1 , sequence name ) ; } return sequence ; }
public static string injection_error_nonstatic_member_class_not_supported ( object arg0 ) { return localizer . localize ( localizable i n j e c t i o n_ e r r o r_ n o n s t a t i c_ m e m b e r_ c l a s s_ n o t_ s u p p o r t e d ( arg0 ) ) ; }
public static string error_marshalling_jaxb ( object arg0 ) { return localizer . localize ( localizable e r r o r_ m a r s h a l l i n g_ j a x b ( arg0 ) ) ; }
public static string resource_config_error_null_applicationclass ( ) { return localizer . localize ( localizable r e s o u r c e_ c o n f i g_ e r r o r_ n u l l_ a p p l i c a t i o n c l a s s ( ) ) ; }
public int get status ( ) { return status ; }
public list < t > get list ( string entity name ) { not null ( entity name , `` entity name `` ) ; final list < t > entity list = new array list < t > ( ) ; for ( t entity : entity ) { if ( entity . get name ( ) . equal ignore case ( entity name ) ) { entity list . add ( entity ) ; } } return collection . unmodifiable list ( entity list ) ; }
public mime type parameter list get parameter ( ) { return parameter ; }
public result matcher content type compatible with ( string content type ) { return content type compatible with ( medium type . parse medium type ( content type ) ) ; }
public static boolean end with whitespace ( final char sequence char seq ) { if ( char seq . length ( ) == 0 ) { return false ; } return character . be whitespace ( char seq . char at ( char seq . length ( ) - 1 ) ) ; }
public template [ ] get template ( ) { return get template ( null ) ; }
public string get uri ( ) { return uri ; }
public void set comment text ( string value ) { this . comment text = value ; }
public string get comment text ( ) { return comment text ; }
public throwable get cause ( ) { return cause ; }
public final boolean accept ( int doc i d , bit live doc ) { return ( filter doc == null || filter doc . get ( doc i d ) ) & & ( live doc == null || live doc . get ( doc i d ) ) ; }
public string get title ( ) { return title ; }
public void set resource ( string resource ) { assert src be java resource ( ) ; ( ( java resource ) src ) . set name ( resource ) ; }
protect void set picture reference ( package relationship rel ) { ct picture . get blip fill ( ) . get blip ( ) . set embed ( rel . get id ( ) ) ; }
public static boolean be builtin style ( table style style ) { if ( style == null ) return false ; try { x s s f builtin table style . value of ( style . get name ( ) ) ; return true ; } catch ( illegal argument exception e ) { return false ; } }
public static final void set current millis fix ( long fix millis ) throw security exception { check permission ( ) ; c millis provider = new fix millis provider ( fix millis ) ; }
public static list < method > get setter ( class < ? > clazz ) { method [ ] method = clazz . get method ( ) ; list < method > list = new array list < method > ( ) ; for ( method method : method ) { if ( be setter ( method ) ) { list . add ( method ) ; } } return list ; }
public boolean be close ( ) { return close . get ( ) ; }
public iterable < reader interceptor > get reader interceptor ( ) { return reader interceptor ; }
public string get value ( ) { return value ; }
public void set from ( integer from ) { this . from = from ; }
public void close ( ) throw i o exception { super . close ( ) ; close = true ; }
public boolean region match ( boolean ignore case , int this start , char sequence string , int start , int length ) { if ( ! ignore case ) { return region match ( this start , string , start , length ) ; } object util . check not null ( string , `` string `` ) ; final int this len = length ( ) ; if ( this start < 0 || length > this len - this start ) { return false ; } if ( start < 0 || length > string . length ( ) - start ) { return false ; } this start += array offset ( ) ; final int this end = this start + length ; while ( this start < this end ) { if ( ! equal ignore case ( b2c ( value [ this start++ ] ) , string . char at ( start++ ) ) ) { return false ; } } return true ; }
public static string unable_to_secure_xml_transformer_processing ( ) { return localizer . localize ( localizable u n a b l e_ t o_ s e c u r e_ x m l_ t r a n s f o r m e r_ p r o c e s s i n g ( ) ) ; }
public static string error_interceptor_writer_proceed ( ) { return localizer . localize ( localizable e r r o r_ i n t e r c e p t o r_ w r i t e r_ p r o c e e d ( ) ) ; }
public static string error_reading_entity_from_input_stream ( ) { return localizer . localize ( localizable e r r o r_ r e a d i n g_ e n t i t y_ f r o m_ i n p u t_ s t r e a m ( ) ) ; }
public static string error_service_locator_provider_instance_request ( object arg0 ) { return localizer . localize ( localizable e r r o r_ s e r v i c e_ l o c a t o r_ p r o v i d e r_ i n s t a n c e_ r e q u e s t ( arg0 ) ) ; }
public static string error_reading_entity_from_input_stream ( ) { return localizer . localize ( localizable e r r o r_ r e a d i n g_ e n t i t y_ f r o m_ i n p u t_ s t r e a m ( ) ) ; }
public static string feature_constrained_to_ignored ( object arg0 , object arg1 , object arg2 ) { return localizer . localize ( localizable f e a t u r e_ c o n s t r a i n e d_ t o_ i g n o r e d ( arg0 , arg1 , arg2 ) ) ; }
public static string error_monitoring_mbeans_unregistration_destroy ( ) { return localizer . localize ( localizable e r r o r_ m o n i t o r i n g_ m b e a n s_ u n r e g i s t r a t i o n_ d e s t r o y ( ) ) ; }
public static string error_wadl_builder_generation_method ( object arg0 , object arg1 ) { return localizer . localize ( localizable e r r o r_ w a d l_ b u i l d e r_ g e n e r a t i o n_ m e t h o d ( arg0 , arg1 ) ) ; }
public static string error_wadl_builder_generation_param ( object arg0 , object arg1 , object arg2 ) { return localizer . localize ( localizable e r r o r_ w a d l_ b u i l d e r_ g e n e r a t i o n_ p a r a m ( arg0 , arg1 , arg2 ) ) ; }
public static string error_wadl_generator_config_loader ( object arg0 ) { return localizer . localize ( localizable e r r o r_ w a d l_ g e n e r a t o r_ c o n f i g_ l o a d e r ( arg0 ) ) ; }
public static string jersey_app_no_mapping_or_annotation ( object arg0 , object arg1 ) { return localizer . localize ( localizable j e r s e y_ a p p_ n o_ m a p p i n g_ o r_ a n n o t a t i o n ( arg0 , arg1 ) ) ; }
public static string error_wadl_builder_generation_method ( object arg0 , object arg1 ) { return localizer . localize ( localizable e r r o r_ w a d l_ b u i l d e r_ g e n e r a t i o n_ m e t h o d ( arg0 , arg1 ) ) ; }
public static string error_wadl_builder_generation_method ( object arg0 , object arg1 ) { return localizer . localize ( localizable e r r o r_ w a d l_ b u i l d e r_ g e n e r a t i o n_ m e t h o d ( arg0 , arg1 ) ) ; }
public static synchronize map < string , statistic > get statistic ( ) { map < string , statistic > result = new hash map < string , statistic > ( ) ; for ( statistic stat : statistic table . value ( ) ) { result . put ( stat . get scheme ( ) , stat ) ; } return result ; }
public rout node rout node ( ) { return rout node ; }
public static diagnostics listener provider [ ] provider ( diagnostics listener . . . listener ) { diagnostics listener provider [ ] result = new diagnostics listener provider [ listener . length ] ; for ( int i = 0 ; i < listener . length ; i++ ) result [ i ] = new default diagnostics listener provider ( listener [ i ] ) ; return result ; }
public static invocable create ( class < ? extend inflector > inflector class ) { return create ( method handler . create ( inflector class ) , apply_inflector_method , false ) ; }
public static < t > invocable create ( inflector < request , t > inflector ) { return create ( method handler . create ( inflector ) , apply_inflector_method , false ) ; }
protect method [ ] get method ( class < ? > type ) { return type . get method ( ) ; }
public static builder builder ( ) { return new builder ( ) ; }
public gate . resource get resource ( ) { return resource ; }
public object get instance ( ) { return instance ; }
public void set search selection only ( boolean selection only ) { if ( selection only ! =this . selection only ) { this . selection only = selection only ; fire property change ( property_selection_only , ! selection only , selection only ) ; if ( selection only ) { throw new unsupported operation exception ( `` search in selection be not currently support `` ) ; } } }
public string get url ( ) { return url ; }
public property get property ( ) { return property ; }
public void add woven permission ( package permission permission ) { if ( ! permission . get action ( ) . equal ( package permission . import ) ) throw new security exception ( ) ; weave permission . add ( permission ) ; }
public string uri ( ) { return uri ; }
public stream distribution [ ] list stream distribution ( string bucket name ) throw cloud front service exception { list < distribution > stream distribution = list distribution by bucket name ( true , bucket name ) ; return stream distribution . to array ( new stream distribution [ stream distribution . size ( ) ] ) ; }
public void set distribution ( string distribution ) { this . distribution = distribution ; } // -- void set distribution ( string )
public void delete bucket ( storage bucket bucket ) throw service exception { assert valid bucket ( bucket , `` delete bucket `` ) ; delete bucket impl ( bucket . get name ( ) ) ; }
public http connection manager get http connection manager ( ) { return http connection manager ; }
public string get product ( ) { return product ; }
public void add right ( acl acl ) throw message exception { set a c l ( acl , '+ ' ) ; }
public input stream get input stream ( ) throw i o exception { input stream in stream = this . get input stream impl ( ) ; if ( in stream == null ) { throw new i o exception ( `` ca n't obtain the input stream from `` + _part name . get name ( ) ) ; } return in stream ; }
public void set last modified date ( final long ntfs last modified date ) { this . last modified date = ntfs last modified date ; }
public void set size ( final long size ) { this . size = size ; }
public set < k > key set ( ) { if ( key set == null ) { key set = new key set < > ( this ) ; } return key set ; }
public string get name ( ) { return ( string ) get value ( name ) ; }
public upload storage type get upload storage type ( ) { return m upload storage type ; }
public static collection < encryption type > get encryption type ( ) { return encryption type by name . value ( ) ; }
public string get path ( ) { return this . path ; }
public void delete bucket ( storage bucket bucket ) throw service exception { assert valid bucket ( bucket , `` delete bucket `` ) ; delete bucket impl ( bucket . get name ( ) ) ; }
protect void assert valid bucket ( storage bucket bucket , string action ) throw service exception { if ( bucket == null || bucket . get name ( ) == null || bucket . get name ( ) . length ( ) == 0 ) { throw new service exception ( `` the action `` + action + `` can not be perform with an invalid bucket : `` + bucket ) ; } }
public date time to date time ( ) { return new date time ( get millis ( ) , get zone ( ) ) ; }
public property get property ( ) { return property ; }
public property get property ( ) { return property ; }
public double sign area ( ) { return sign area ( this . p0 , this . p1 , this . p2 ) ; }
public string get reason ( ) { return this . reason ; }
public void set implementation version ( final string implementation version ) { verify not a reference ( ) ; this . implementation version = new dewey decimal ( implementation version ) ; }
public io . vertx . axle . core . http . http client create http client ( http client option option ) { io . vertx . axle . core . http . http client ret = io . vertx . axle . core . http . http client . new instance ( delegate . create http client ( option ) ) ; return ret ; }
public synchronize void set params ( http params params ) { default params = params ; }
public t get object ( ) { return this . object ; }
protect void set code ( int code ) { this . code = code ; }
protect void on fill interested fail ( throwable cause ) { if ( log . be debug enable ( ) ) log . debug ( `` { } on fill interested fail { } `` , this , cause ) ; if ( _end point . be open ( ) ) { boolean close = true ; if ( cause instanceof timeout exception ) close = on read timeout ( ) ; if ( close ) { if ( _end point . be output shutdown ( ) ) _end point . close ( ) ; else { _end point . shutdown output ( ) ; fill interested ( ) ; } } } }
public void fill interested ( ) { if ( log . be debug enable ( ) ) log . debug ( `` fill interested { } `` , this ) ; get end point ( ) . fill interested ( _read callback ) ; }
public final serialization config get config ( ) { return _config ; }
public error handler get handler ( ) { return handler ; }
public void set method ( int method ) { this . method = method ; }
public io . vertx . axle . core . http . cookie set secure ( boolean secure ) { delegate . set secure ( secure ) ; return this ; }
public void set page ( p d page page ) { this . page = page ; }
public void set ssl session cache size ( int ssl session cache size ) { _ssl session cache size = ssl session cache size ; }
public int get ssl session cache size ( ) { return _ssl session cache size ; }
public void set element type name ( string element type name ) { this . element type name = element type name ; }
public void set page size ( int page size ) { this . page size = page size ; }
public static handler library load ( ) { handler library lib = new handler library ( ) ; load annotation handler ( lib ) ; load visitor handler ( lib ) ; lib . calculate priority ( ) ; return lib ; }
public i s s table scanner get scanner ( range < token > range , rate limiter limiter ) { if ( range == null ) return get scanner ( limiter ) ; return get scanner ( collection . singleton list ( range ) , limiter ) ; }
public boolean be java lang object ( ) { return false ; }
protect void set top ( l top ) { this . top = top ; }
public char class interval [ ] get interval ( ) { int i , c ; int size = class . size ( ) ; int num interval = 0 ; for ( i = 0 ; i < size ; i++ ) num intervals+= ( class . get ( i ) ) . num interval ( ) ; char class interval [ ] result = new char class interval [ num interval ] ; i = 0 ; c = 0 ; while ( i < num interval ) { int code = get class code ( c ) ; int char set set = class . get ( code ) ; interval iv = set . get next ( ) ; result [ i++ ] = new char class interval ( iv . start , iv . end , code ) ; c = iv . end+1 ; } return result ; }
public int [ ] get class code ( list < interval > interval list ) { return get class code ( new int char set ( interval list ) , false ) ; }
public short [ ] get short array ( string key ) { return get short array ( key , new short [ 0 ] ) ; }
public int get exit code ( ) { return exit code ; }
public file get dir ( ) { return dir ; }
public message get message ( ) { return msg ; }
public error get error ( ) { return this . error ; }
public static boolean be null or empty ( string str ) { return ( ( str == null ) || str . trim ( ) . length ( ) == 0 ) ; }
public long read unsigned int ( ) throw i o exception { read fully ( buf , 0 , 4 ) ; return nb . decode u int32 ( buf , 0 ) ; }
public void set output ( string out ) { this . out = out ; }
public restore snapshot response restore ( restore snapshot request restore snapshot request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( restore snapshot request , snapshot request converter : : restore snapshot , option , restore snapshot response : : from x content , empty set ( ) ) ; }
public json node visit ( jmes path filter filter , json node input ) throw invalid type exception { json node filter expression = filter . get lhs expr ( ) . accept ( this , input ) ; if ( filter expression . be array ( ) ) { iterator < json node > element = filter expression . element ( ) ; array node project array node = object mapper singleton . get object mapper ( ) . create array node ( ) ; while ( element . have next ( ) ) { json node element = element . next ( ) ; if ( filter . get comparator ( ) . accept ( this , element ) . equal ( boolean node . true ) ) { json node project element = filter . get rhs expr ( ) . accept ( this , element ) ; if ( project element ! = null ) { projected array node . add ( project element ) ; } } } return projected array node ; } return null node . get instance ( ) ; }
public static u d t type udt literal ( string literal ) { return u d t type . literal ( literal ) ; }
public json node visit ( jmes path flatten flatten , json node input ) throw invalid type exception { json node flatten result = flatten . get flatten expr ( ) . accept ( this , input ) ; if ( flatten result . be array ( ) ) { iterator < json node > element = flatten result . element ( ) ; array node flatten array = object mapper singleton . get object mapper ( ) . create array node ( ) ; while ( element . have next ( ) ) { json node element = element . next ( ) ; if ( element ! = null ) { if ( element . be array ( ) ) { iterator < json node > inner = element . iterator ( ) ; while ( inner . have next ( ) ) { json node inner element = inner . next ( ) ; if ( inner element ! = null ) { flattened array . add ( inner element ) ; } } } else { flattened array . add ( element ) ; } } } return flattened array ; } return null node . get instance ( ) ; }
public object invoke ( string method name , class arg type , object arg ) { return reflect util . invoke ( obj , method name , arg type , arg ) ; }
public equal builder append ( object [ ] lh , object [ ] rh ) { if ( be equal == false ) { return this ; } if ( lhs == rh ) { return this ; } if ( lhs == null || rh == null ) { this . set equal ( false ) ; return this ; } if ( lh . length ! = rh . length ) { this . set equal ( false ) ; return this ; } for ( int i = 0 ; i < lh . length & & be equal ; ++i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
public big decimal to big decimal ( ) { if ( text be empty or null ( ) ) { return null ; } return string groovy method . to big decimal ( ( char sequence ) text ( ) ) ; }
public static collection < thread group > find thread group by name ( final string thread group name ) { return find thread group ( new name predicate ( thread group name ) ) ; }
public long get thread count ( ) { return thread counter . get ( ) ; }
public result get result ( ) { return result ; }
public static object to p g interval ( day to second interval ) { return on ( `` org . postgresql . util . p g interval `` ) . create ( 0 , 0 , interval . get sign ( ) * interval . get day ( ) , interval . get sign ( ) * interval . get hour ( ) , interval . get sign ( ) * interval . get minute ( ) , interval . get sign ( ) * interval . get second ( ) + interval . get sign ( ) * interval . get nano ( ) / 1000000000 . 0 ) . get ( ) ; }
public field get field ( ) { return field ; }
public static < t > t new instance ( class < ? extend t > class to instantiate , object . . . non null args ) { return constructor reflection . new instance ( class to instantiate , non null args ) ; }
public static < t > t new instance ( string class name , class < ? > [ ] parameter type , object . . . init args ) { return constructor reflection . new instance ( class name , parameter type , init args ) ; }
public json map exception weird string exception ( class < ? > inst class , string msg ) { return weird string exception ( null , inst class , msg ) ; }
public long get offset ( ) { return offset ; }
public final boolean be auto configuration enable ( ) { return auto configuration enable ; }
public constant constant ( scope scope ) { return constant ( ) ; }
public void set max row ( integer value ) { this . max row = value ; }
public jsonb property info with runtime type ( type runtime type ) { this . runtime type = runtime type ; return this ; }
public void from native ( runtime runtime , pointer buffer , long offset ) { this . value = buffer . get double ( offset ) ; }
public void from native ( runtime runtime , pointer buffer , long offset ) { this . value = buffer . get byte ( offset ) ; }
public void from native ( runtime runtime , pointer buffer , long offset ) { this . value = buffer . get byte ( offset ) ; }
public t get object ( ) { return reference . get ( ) ; }
public address get address ( ) { return address ; }
protect final unsigned long [ ] array ( unsigned long [ ] array ) { array begin ( ) ; for ( int i = 0 ; i < array . length ; ++i ) { array [ i ] = new unsigned long ( ) ; } array end ( ) ; return array ; }
protect final unsigned long [ ] array ( unsigned long [ ] array ) { array begin ( ) ; for ( int i = 0 ; i < array . length ; ++i ) { array [ i ] = new unsigned long ( ) ; } array end ( ) ; return array ; }
public static long [ ] to primitive ( long [ ] array , long value for null ) { if ( array == null ) { return null ; } else if ( array . length == 0 ) { return empty_long_array ; } final long [ ] result = new long [ array . length ] ; for ( int i = 0 ; i < array . length ; i++ ) { long b = array [ i ] ; result [ i ] = ( b == null ? value for null : b . long value ( ) ) ; } return result ; }
public void set name ( string name ) { if ( name == null ) { throw new illegal argument exception ( `` name must not be null `` ) ; } this . name = name ; }
public error get error ( ) { return this . error ; }
public void set label ( string label ) { this . label = label ; }
public final void ud2 ( ) { emit x86 ( inst_ud2 ) ; }
public final void pextrb ( register dst , x m m register src , immediate imm8 ) { emit x86 ( inst_pextrb , dst , src , imm8 ) ; }
public final void movhps ( x m m register dst , mem src ) { emit x86 ( inst_movhps , dst , src ) ; }
public final void mov ( register dst , register src ) { emit x86 ( inst_mov , dst , src ) ; }
public final void cpuid ( ) { emit x86 ( inst_cpuid ) ; }
public final void ldmxcsr ( mem src ) { emit x86 ( inst_ldmxcsr , src ) ; }
public final void cpuid ( ) { emit x86 ( inst_cpuid ) ; }
public final void psrld ( x m m register dst , x m m register src ) { emit x86 ( inst_psrld , dst , src ) ; }
public final void psrld ( m m register dst , m m register src ) { emit x86 ( inst_psrld , dst , src ) ; }
public final void psrld ( m m register dst , m m register src ) { emit x86 ( inst_psrld , dst , src ) ; }
public final void psrld ( m m register dst , m m register src ) { emit x86 ( inst_psrld , dst , src ) ; }
public final void pextrb ( register dst , x m m register src , immediate imm8 ) { emit x86 ( inst_pextrb , dst , src , imm8 ) ; }
public final void ficom ( mem src ) { assert ( src . size ( ) == 2 || src . size ( ) == 4 ) ; emit x86 ( inst_ficom , src ) ; }
public final void psrld ( x m m register dst , x m m register src ) { emit x86 ( inst_psrld , dst , src ) ; }
public final void psrld ( x m m register dst , x m m register src ) { emit x86 ( inst_psrld , dst , src ) ; }
public final void psrld ( x m m register dst , x m m register src ) { emit x86 ( inst_psrld , dst , src ) ; }
public final void psrld ( m m register dst , m m register src ) { emit x86 ( inst_psrld , dst , src ) ; }
public final void psrld ( x m m register dst , x m m register src ) { emit x86 ( inst_psrld , dst , src ) ; }
public final void psrld ( x m m register dst , x m m register src ) { emit x86 ( inst_psrld , dst , src ) ; }
public final void psrld ( x m m register dst , x m m register src ) { emit x86 ( inst_psrld , dst , src ) ; }
public final void psrld ( x m m register dst , x m m register src ) { emit x86 ( inst_psrld , dst , src ) ; }
public final void cpuid ( ) { emit x86 ( inst_cpuid ) ; }
public final void psrld ( x m m register dst , x m m register src ) { emit x86 ( inst_psrld , dst , src ) ; }
public final void psrld ( x m m register dst , x m m register src ) { emit x86 ( inst_psrld , dst , src ) ; }
public final void psrld ( x m m register dst , x m m register src ) { emit x86 ( inst_psrld , dst , src ) ; }
public final void psrld ( x m m register dst , x m m register src ) { emit x86 ( inst_psrld , dst , src ) ; }
public final void psrld ( x m m register dst , x m m register src ) { emit x86 ( inst_psrld , dst , src ) ; }
public final void psrld ( m m register dst , m m register src ) { emit x86 ( inst_psrld , dst , src ) ; }
public final void psrld ( x m m register dst , x m m register src ) { emit x86 ( inst_psrld , dst , src ) ; }
public final void psrld ( m m register dst , m m register src ) { emit x86 ( inst_psrld , dst , src ) ; }
public final void cmpss ( x m m register dst , x m m register src , immediate imm8 ) { emit x86 ( inst_cmpss , dst , src , imm8 ) ; }
public final void psrld ( x m m register dst , x m m register src ) { emit x86 ( inst_psrld , dst , src ) ; }
public final void psrld ( x m m register dst , x m m register src ) { emit x86 ( inst_psrld , dst , src ) ; }
public void set category ( string category ) { this . category = category ; }
public boolean get show comment ( ) { return show comment ! = 0 ; }
public db exception add s q l ( string sql ) { s q l exception e = get s q l exception ( ) ; if ( e instanceof jdbc s q l exception ) { jdbc s q l exception j = ( jdbc s q l exception ) e ; if ( j . get s q l ( ) == null ) { j . set s q l ( sql ) ; } return this ; } e = new jdbc s q l exception ( e . get message ( ) , sql , e . get s q l state ( ) , e . get error code ( ) , e , null ) ; return new db exception ( e ) ; }
public string get subselect attribute ( ) { return subselect attribute ; }
public pretty printer configuration set indent type ( indent type indent type ) { indentation indentation = get indentation ( ) . set type ( assert not null ( indent type ) ) ; set indentation ( indentation ) ; return this ; }
public void set render formatting ( render format value ) { this . render format = value ; }
public boolean be render schema ( ) { return render schema ; }
public boolean be render schema ( ) { return render schema ; }
public char get escape char ( ) { return escape char ; }
public boolean be optimistic lock ( ) { if ( optimistic lock == null ) { return true ; } else { return optimistic lock ; } }
public submodule update command set fetch ( boolean fetch ) { this . fetch = fetch ; return this ; }
public int get query timeout ( ) { return this . query timeout ; }
public void set max row ( integer value ) { this . max row = value ; }
public integer get max row ( ) { return max row ; }
public void set fetch size ( integer value ) { this . fetch size = value ; }
public void set parse meta default expression ( boolean value ) { this . parse meta default expression = value ; }
public void set statement ( ast node statement ) { assert not null ( statement ) ; this . statement = statement ; statement . set parent ( this ) ; }
public static string quote ( string value ) { return quote ( value , '\ `` ) ; }
public configuration get configuration ( ) { return static context . get configuration ( ) ; }
public void add listener ( listener listener ) { listener . add ( listener ) ; }
public void set view ( view view ) { this . view = view ; }
public sequence get sequence ( string sequence name ) { sequence sequence = sequence . get ( sequence name ) ; if ( sequence == null ) { throw db exception . get ( error code . sequence_not_found_1 , sequence name ) ; } return sequence ; }
public void set view ( view view ) { this . view = view ; }
public set < string > select field ( ) { return select field ; }
public set < string > get privilege ( ) { return this . privilege ; }
public void append byte ( int val ) { buf [ pos++ ] = ( byte ) val ; }
public string get field name ( ) { return field name ; }
public static < t > t [ ] array ( t . . . value ) { return value ; }
public string get field ( ) { return field ; }
public int get in position ( ) { return in position ; }
public boolean be concat ( ) { return this . engine . be concat ( ) ; }
public static field < date > date ( java . util . date value ) { return tool . field ( convert . convert ( value , date . class ) ) ; }
public static field < date > date ( java . util . date value ) { return tool . field ( convert . convert ( value , date . class ) ) ; }
public static date convert date time string to date ( string value ) { return parse internal ( value , false ) ; }
public void set timestamp ( final long timestamp ) { this . timestamp = timestamp ; }
public void set field ( list < string > field ) { this . field = field ; }
public static < t extend number > field < t > round ( t value ) { return round ( tool . field ( value ) ) ; }
public static < t extend number > field < t > bit not ( t value ) { return bit not ( tool . field ( value ) ) ; }
public static field < big decimal > atan2 ( number x , number y ) { return atan2 ( tool . field ( x ) , tool . field ( y ) ) ; }
public static field < big decimal > ln ( number value ) { return ln ( tool . field ( value ) ) ; }
public static order aggregate function < big decimal > cume dist ( field < ? > . . . field ) { return new org . jooq . impl . function < big decimal > ( `` cume_dist `` , s q l data type . numeric , field ) ; }
public static < t > t get field ( class < ? > class with static field , string field name ) { return field reflection . get field ( class with static field , field name , null ) ; }
public static aggregate function < integer > count ( field < ? > field ) { return new org . jooq . impl . function < integer > ( `` count `` , s q l data type . integer , null safe ( field ) ) ; }
public < t > t call factory ( string factory method , class < ? > [ ] param type , object [ ] param value ) { return call factory ( fully qualify class name , factory method , param type , param value ) ; }
public boolean accept num param ( int num param ) { return num param == 2 ; }
public string get user ( ) { return user ; }
public string get schema ( ) { return schema ; }
public final string get sql ( ) { return this . sql ; }
public void set binding ( bind binding ) { this . bind = binding ; }
public void generate ( ) throw i o exception { } // generate
public void set class loader ( class loader class loader ) { this . class loader = class loader ; }
public static boolean be null or empty ( string str ) { return ( ( str == null ) || str . trim ( ) . length ( ) == 0 ) ; }
public void set max width ( float max width ) { dic . set float ( c o s name . max_width , max width ) ; }
public static int compare to ( ref o1 , ref o2 ) { return o1 . get name ( ) . compare to ( o2 . get name ( ) ) ; }
public void set max width ( float max width ) { dic . set float ( c o s name . max_width , max width ) ; }
public t x t format intersect line ( boolean new intersect line ) { return new t x t format ( max row , min col width , max col width , horizontal table border , horizontal header border , horizontal cell border , vertical table border , vertical cell border , new intersect line ) ; }
public t x t format horizontal header border ( boolean new horizontal header border ) { return new t x t format ( max row , min col width , max col width , horizontal table border , new horizontal header border , horizontal cell border , vertical table border , vertical cell border , intersect line ) ; }
public static duration field type minute ( ) { return minutes_type ; }
public static string crypt ( final string key ) { return crypt ( key , null ) ; }
public static field < string > uncompress ( string string ) { return uncompress ( val ( string ) ) ; }
public static field < string > decode ( string crypt string , string key string ) { return decode ( val ( crypt string ) , val ( key string ) ) ; }
protect final boolean be compress ( ) { return compress ; }
public static field < string > uncompress ( string string ) { return uncompress ( val ( string ) ) ; }
public static < t > t [ ] array ( t . . . value ) { return value ; }
public table get table ( ) { return table ; }
public long interval ( ) { return date histogram interval . interval ( ) ; }
public data type get return type ( ) { return return type ; }
public int numeric precision step ( ) { return numeric precision step ; }
public void close ( ) throw i o exception { ordinal = null ; }
public void set index catalog ( string value ) { this . index catalog = value ; }
public string get index catalog ( ) { return index catalog ; }
public iterator < e > descend iterator ( ) { return new descend iterator < e > ( size ( ) ) ; }
public void set catalog ( string value ) { this . catalog = value ; }
public void set catalog ( string value ) { this . catalog = value ; }
public list < jaxb unique constraint > get unique constraint ( ) { if ( unique constraint == null ) { unique constraint = new array list < jaxb unique constraint > ( ) ; } return this . unique constraint ; }
public void set routine class ( matcher rule value ) { this . routine class = value ; }
public boolean be include package routine ( ) { return include package routine ; }
public trust chain constraint get constraint ( ) { return constraint ; }
public string get format ( ) { return format ; }
public string get schema ( ) { return schema ; }
public static string make non java keyword ( string keyword ) { return keyword prefix + keyword ; }
public void set render formatting ( render format value ) { this . render format = value ; }
public void set interpreter ( a t n interpreter interpreter ) { _interp = interpreter ; }
public void set parse with meta lookup ( parse with meta lookup value ) { this . parse with meta lookup = value ; }
public string get cascade ( ) { return cascade ; }
protect b encoder enforce max concurrent stream ( boolean encoder enforce max concurrent stream ) { enforce non codec constraint ( `` encoder enforce max concurrent stream `` ) ; this . encoder enforce max concurrent stream = encoder enforce max concurrent stream ; return self ( ) ; }
public void set include system index ( boolean value ) { this . include system index = value ; }
public void set routine package ( string value ) { this . routine package = value ; }
public void set include ( string value ) { this . include = value ; }
public void set include ( string value ) { this . include = value ; }
public sequence get sequence ( string sequence name ) { sequence sequence = sequence . get ( sequence name ) ; if ( sequence == null ) { throw db exception . get ( error code . sequence_not_found_1 , sequence name ) ; } return sequence ; }
public boolean be disable foreign key ( ) { return disable foreign key ; }
public void set primary ( boolean primary ) { this . primary = primary ; }
public static string to unsigned string ( @ unsigned short s , int radix ) { return integer . to unsigned string ( short . to unsigned int ( s ) , radix ) ; }
public string get schema ( ) { return schema ; }
public schema get schema ( ) { return schema ; }
public string get relation ( ) { return _relation ; }
public boolean be deprecate delegate ( ) { return f deprecate delegate ; }
public synchronize object get ( object key ) { if ( ! contains key ( key ) ) { return null ; } object value = remove ( key ) ; super . put ( key , value ) ; return value ; }
public void set interface ( class < ? > . . . interface ) { assert . not null ( interface , `` interface must not be null `` ) ; this . interface . clear ( ) ; for ( class < ? > ifc : interface ) { add interface ( ifc ) ; } }
public void set interface ( class < ? > . . . interface ) { assert . not null ( interface , `` interface must not be null `` ) ; this . interface . clear ( ) ; for ( class < ? > ifc : interface ) { add interface ( ifc ) ; } }
public static annotation [ ] get resource annotation ( method method ) { map < class < ? > , annotation > annotation = new hash map < class < ? > , annotation > ( ) ; for ( annotation annotation : method . get declare class ( ) . get annotation ( ) ) { annotation . put ( annotation . get class ( ) , annotation ) ; } for ( annotation annotation : method . get annotation ( ) ) { annotation . put ( annotation . get class ( ) , annotation ) ; } return annotation . value ( ) . to array ( new annotation [ annotation . size ( ) ] ) ; }
public boolean get global ( ) { return m global ; }
public void set comment on catalog ( boolean value ) { this . comment on catalog = value ; }
public boolean be comment on catalog ( ) { return comment on catalog ; }
public boolean be comment on sequence ( ) { return comment on sequence ; }
public void set comment on catalog ( boolean value ) { this . comment on catalog = value ; }
public boolean be comment on column ( ) { return comment on column ; }
public b default setter info ( json setter . value v ) { _mapper . set default setter info ( v ) ; return _this ( ) ; }
public static boolean be class present ( string fully qualified class name ) { try { class . for name ( fully qualify class name ) ; return true ; } catch ( class not find exception e ) { return false ; } }
public string get driver class ( ) { return driver class ; }
public void set username ( string username ) { this . username = username ; } // -- void set username ( string )
public void set password ( string password ) { this . password = password ; }
public static < t extend enum < t > > t value of ( final class < t > enum type , final string name , final t default value ) { return name == null ? default value : enum . value of ( enum type , name . to upper case ( locale . english ) ) ; }
public void set routine package ( string value ) { this . routine package = value ; }
public table get table ( ) { return table ; }
public value node pojo node ( object pojo ) { return new p o j o node ( pojo ) ; }
public void set value ( string value ) { this . value = value ; }
public void set include ( string value ) { this . include = value ; }
public boolean be synthetic public ( ) { return synthetic public ; }
public void set width ( final integer width ) { this . width = width ; }
public string get comment ( ) { return comment ; }
public int get flag ( ) { return flag ; }
public annotation value builder < t > value ( @ nullable string . . . string ) { return member ( annotation metadata . value_member , string ) ; }
public static < t > constructor < t > find primary constructor ( class < t > clazz ) { assert . not null ( clazz , `` class must not be null `` ) ; if ( kotlin detector . be kotlin reflect present ( ) & & kotlin detector . be kotlin type ( clazz ) ) { return kotlin delegate . find primary constructor ( clazz ) ; } return null ; }
public static annotation [ ] get annotation ( field field ) { annotation [ ] java annotation = field . get annotation ( ) ; annotation [ ] kotlin annotation = kotlin support . get instance ( ) . get annotation ( field ) ; if ( kotlin annotation . length == 0 ) { return java annotation ; } return object array . concat ( java annotation , kotlin annotation , annotation . class ) ; }
public void set comment on attribute ( boolean value ) { this . comment on attribute = value ; }
public array list < expression > get expression ( ) { return expression ; }
public table get table ( ) { return table ; }
public string get comment ( ) { return comment ; }
public context get context ( ) { return impl . get context ( ) ; }
public int get skip count ( ) { return skip count ; }
public issuer get expect issuer ( ) { return expect issuer ; }
protect void print additional help ( terminal terminal ) { }
public int get identity hash code ( ) { return this . identity hash code ; }
public session get session ( string username , string host , int port ) throw j sch exception { if ( host==null ) { throw new j sch exception ( `` host must not be null . `` ) ; } session s = new session ( this , username , host , port ) ; return s ; }
public session get session ( string username , string host ) throw j sch exception { return get session ( username , host , 22 ) ; }
protect void flush buffer body content ( body content body content ) throw jsp exception { try { body content . write out ( body content . get enclosing writer ( ) ) ; } catch ( i o exception ex ) { throw new jsp exception ( `` unable to write buffer body content . `` , ex ) ; } }
public static metric tag tag ( metric info info , string value ) { return tag . instance . cache . add ( info , value ) ; }
public void release ( ) { state . release ( false ) ; }
public object get value ( ) { return value ; }
public void add listener ( listener listener ) { listener . add ( listener ) ; }
protect socket get socket ( ) { return this . socket ; }
public void set method ( int method ) { this . method = method ; }
public void add setup ( sequential sequence ) { log override ( `` setup `` , setup ) ; setup = sequence ; }
public void multipart abort upload ( multipart upload upload ) throw s3 service exception { multipart abort upload impl ( upload . get upload id ( ) , upload . get bucket name ( ) , upload . get object key ( ) ) ; }
public boolean be random start ( ) { return random start ; }
public list < big integer > get big integer list ( string key ) { return get big integer list ( key , new array list < big integer > ( ) ) ; }
public vector rotate x z ( final double sin angle , final double co angle ) { return new vector ( x * co angle - z * sin angle , y , x * sin angle + z * co angle ) ; }
public static double get double ( byte [ ] data ) { return double . long bit to double ( get long ( data , 0 ) ) ; }
public collection get invalid ring line ( ) { polygonize ( ) ; return invalid ring line ; }
public boolean have non proper intersection ( ) { return have non proper intersection ; }
public int get minimum length ( ) { return minimum length ; }
public geometry get geometry ( ) { if ( stack . size ( ) == 1 ) { handler h = ( handler ) stack . peek ( ) ; if ( h . child . size ( ) == 1 ) return ( geometry ) h . child . get ( 0 ) ; return gf . create geometry collection ( ( geometry [ ] ) h . child . to array ( new geometry [ stack . size ( ) ] ) ) ; } throw new illegal state exception ( `` parse do not complete a expect , there be `` + stack . size ( ) + `` element on the stack `` ) ; }
public list get edge ( ) { return edge ; }
public coordinate to external ( coordinate internal ) { coordinate external = new coordinate ( internal ) ; return external ; }
public static double indicator ( final double x ) { if ( double . be na n ( x ) ) { return double . na n ; } return ( x > = 0 . 0 ) ? 1 . 0 : -1 . 0 ; }
public double get min ( ) { return min impl . get result ( ) ; }
public boolean equal ( object other ) { return this==other ; }
public boolean contains ( double x , double y ) { if ( component2 d . contains point ( x , y , min x , max x , min y , max y ) & & tree . contains ( x , y ) ) { return hole == null || hole . contains ( x , y ) == false ; } return false ; }
public p p draw get p p drawing ( ) { return _container . get p p drawing ( ) ; }
public int hash code ( ) { return name . hash code ( ) ; } // hash code
public string get symbol ( ) { return symbol ; }
public boolean be overlaps ( int dimension of geometry a , int dimension of geometry b ) { if ( ( dimension of geometry a == dimension . p & & dimension of geometry b == dimension . p ) || ( dimension of geometry a == dimension . a & & dimension of geometry b == dimension . a ) ) { return be true ( matrix [ location . interior ] [ location . interior ] ) & & be true ( matrix [ location . interior ] [ location . exterior ] ) & & be true ( matrix [ location . exterior ] [ location . interior ] ) ; } if ( dimension of geometry a == dimension . l & & dimension of geometry b == dimension . l ) { return matrix [ location . interior ] [ location . interior ] == 1 & & be true ( matrix [ location . interior ] [ location . exterior ] ) & & be true ( matrix [ location . exterior ] [ location . interior ] ) ; } return false ; }
public void update weight matrix ( matrix [ ] matrix ) { for ( int i = 0 ; i < matrix . length ; ++i ) { matrix matrix = this . weight matrix list . get ( i ) ; this . weight matrix list . set ( i , matrix . plus ( matrix [ i ] ) ) ; } }
public default double compute delta distance ( final distance style distance style , final geo point point ) { return compute delta distance ( distance style , point . x , point . y , point . z ) ; }
public type get type ( ) { return type ; }
public coordinate [ ] to coordinate array ( ) { return ( coordinate [ ] ) to array ( coord array type ) ; }
public void set service locator exception class ( class < ? extend exception > service locator exception class ) { if ( service locator exception class ! = null & & ! exception . class . be assignable from ( service locator exception class ) ) { throw new illegal argument exception ( `` service locator exception [ `` + service locator exception class . get name ( ) + `` ] be not a subclass of exception `` ) ; } this . service locator exception constructor = determine service locator exception constructor ( service locator exception class ) ; }
public static boolean be simple ( geometry geom ) { be simple op op = new be simple op ( geom ) ; return op . be simple ( ) ; }
protect boolean eq ( object x , object y ) { return x == y || x . equal ( y ) ; }
public void sign request ( string sign url ) { this . sign url = sign url ; }
public void set scale ( double s ) { set scale internal ( s ) ; }
public double double value ( ) { return value ; }
public double get theta ( ) { return theta ; }
public boolean be unboxable ( ) { return array . stream ( resolve primitive type . value ( ) ) . any match ( pt - > get qualify name ( ) . equal ( pt . get box type q name ( ) ) ) ; }
public edge end find edge end ( edge e ) { for ( iterator i = get edge end ( ) . iterator ( ) ; i . have next ( ) ; ) { edge end ee = ( edge end ) i . next ( ) ; if ( ee . get edge ( ) == e ) return ee ; } return null ; }
public event get event ( ) { peek event ( ) ; event value = current event ; current event = null ; return value ; }
public list get edge ( ) { return edge ; }
public static int min coordinate index ( coordinate sequence seq , int from , int to ) { int min coord index = -1 ; coordinate min coord = null ; for ( int i = from ; i < = to ; i++ ) { coordinate test coord = seq . get coordinate ( i ) ; if ( min coord == null || min coord . compare to ( test coord ) > 0 ) { min coord = test coord ; min coord index = i ; } } return min coord index ; }
public void set dy ( long value ) { this . dy = value ; }
public final quad edge o prev ( ) { return rot . next . rot ; }
public void set right ( final string right ) { this . right = list . create ( right ) ; }
public void set repeat ( boolean repeat ) { action . set boolean ( c o s name . repeat , repeat ) ; }
public final query get query ( ) { return query ; }
public item get item ( ) { return null ; }
public void add ( collection geometry ) { for ( iterator i = geometry . iterator ( ) ; i . have next ( ) ; ) { geometry geometry = ( geometry ) i . next ( ) ; add ( geometry ) ; } }
public void set prefix ( string prefix ) { this . prefix = prefix ; } // -- void set prefix ( string )
static public byte [ ] string to byte ( string hex encode ) { return decode ( hex encode . get byte ( ) ) ; }
public double get segment fraction ( ) { return segment fraction ; }
public fraction divide by ( fraction fraction ) { if ( fraction == null ) { throw new illegal argument exception ( `` the fraction must not be null `` ) ; } if ( fraction . numerator == 0 ) { throw new arithmetic exception ( `` the fraction to divide by must not be zero `` ) ; } return multiply by ( fraction . invert ( ) ) ; }
public final string get line ( int line i ) { return line . get ( line i ) ; }
public boolean ge ( dd y ) { return ( hi > y . hi ) || ( hi == y . hi & & lo > = y . lo ) ; }
public boolean gt ( dd y ) { return ( hi > y . hi ) || ( hi == y . hi & & lo > y . lo ) ; }
public void set keep intersection ( boolean keep intersection ) { this . keep intersection = keep intersection ; }
public list get intersection ( ) { return seg int . get intersection ( ) ; }
public boolean be read only ( ) { return this . read only ; }
public boolean be cover ( ) { boolean have point in common = be true ( matrix [ location . interior ] [ location . interior ] ) || be true ( matrix [ location . interior ] [ location . boundary ] ) || be true ( matrix [ location . boundary ] [ location . interior ] ) || be true ( matrix [ location . boundary ] [ location . boundary ] ) ; return have point in common & & matrix [ location . exterior ] [ location . interior ] == dimension . false & & matrix [ location . exterior ] [ location . boundary ] == dimension . false ; }
public number get maximum number ( ) { if ( max object == null ) { max object = new double ( max ) ; } return max object ; }
public boolean be proper ( ) { return have intersection ( ) & & be proper ; }
public list get intersection ( ) { return seg int . get intersection ( ) ; }
public void invalidate ( k key , v value ) { cache segment < k , v > segment = get cache segment ( key ) ; segment . remove ( key , value , invalidation consumer ) ; }
public list get edge ( ) { return edge ; }
public static double parse ( string distance , distance unit default unit , distance unit to ) { distance dist = distance . parse distance ( distance , default unit ) ; return convert ( dist . value , dist . unit , to ) ; }
public list get edge ( ) { return edge ; }
public edge ring get out hole ( ) { / * * only shell can have out hole * / if ( be hole ( ) ) return null ; / * * a shell be an outer shell if any edge be also in an outer hole . * a hole be an out hole if it be not contain by a shell . * / for ( int i = 0 ; i < de list . size ( ) ; i++ ) { polygonize direct edge de = ( polygonize direct edge ) de list . get ( i ) ; edge ring adj ring = ( ( polygonize direct edge ) de . get sym ( ) ) . get ring ( ) ; if ( adj ring . be out hole ( ) ) return adj ring ; } return null ; }
public list < polygon builder > polygon ( ) { return polygon ; }
public static int locate point in ring ( coordinate p , coordinate [ ] ring ) { return ray cross counter . locate point in ring ( p , ring ) ; }
public boolean be valid ( ) { return valid ; }
public object get data ( ) { return data ; }
public value node number node ( byte value ) { return ( value == null ) ? null node ( ) : int node . value of ( value . int value ( ) ) ; }
public void add ( collection geometry ) { for ( iterator i = geometry . iterator ( ) ; i . have next ( ) ; ) { geometry geometry = ( geometry ) i . next ( ) ; add ( geometry ) ; } }
public boolean be remove ( ) { return remove ; }
public boolean be null ( ) { return be null ; }
public fraction divide by ( fraction fraction ) { if ( fraction == null ) { throw new illegal argument exception ( `` the fraction must not be null `` ) ; } if ( fraction . numerator == 0 ) { throw new arithmetic exception ( `` the fraction to divide by must not be zero `` ) ; } return multiply by ( fraction . invert ( ) ) ; }
public boolean be valid ( ) { return valid ; }
public default vertex out vertex ( ) { return this . vertex ( direction . out ) . next ( ) ; }
public list < vector3 d > get convex cell inside point ( ) { return convex cell inside point ; }
public int get rot ( ) { if ( rot == null ) { return 0 ; } else { return rot ; } }
public coordinate [ ] to coordinate array ( ) { return ( coordinate [ ] ) to array ( coord array type ) ; }
public half edge add edge ( coordinate orig , coordinate d ) { if ( ! be valid edge ( orig , d ) ) return null ; / * * * attempt to find the edge already in the graph . * return it if find . * otherwise , use a found edge with same origin ( if any ) to construct new edge . * / half edge e adj = ( half edge ) vertex map . get ( orig ) ; half edge e same = null ; if ( e adj ! = null ) { e same = e adj . find ( d ) ; } if ( e same ! = null ) { return e same ; } half edge e = insert ( orig , d , e adj ) ; return e ; }
public default vertex out vertex ( ) { return this . vertex ( direction . out ) . next ( ) ; }
public list get edge ( ) { return edge ; }
public object get context ( ) { return data ; }
public coordinate intersection ( segment s ) { return l . intersection ( s . get line segment ( ) ) ; }
public list get intersection ( ) { return seg int . get intersection ( ) ; }
public long count ( ) { return count . get ( ) ; }
public void print ( object obj ) { print ( invoker helper . to string ( obj ) ) ; }
public float max ( int dim ) { return min max [ dim + dim + 1 ] ; }
public boolean be empty ( ) { return size == 0 ; }
public static stack manipulation of ( serializable value ) { if ( value == null ) { return null constant . instance ; } try { byte array output stream byte array output stream = new byte array output stream ( ) ; object output stream object output stream = new object output stream ( byte array output stream ) ; try { object output stream . write object ( value ) ; } finally { object output stream . close ( ) ; } return new serialize constant ( byte array output stream . to string ( charset ) ) ; } catch ( i o exception exception ) { throw new illegal state exception ( `` can not serialize `` + value , exception ) ; } }
public edge find edge in same direction ( coordinate p0 , coordinate p1 ) { for ( int i = 0 ; i < edge . size ( ) ; i++ ) { edge e = ( edge ) edge . get ( i ) ; coordinate [ ] e coord = e . get coordinate ( ) ; if ( match in same direction ( p0 , p1 , e coord [ 0 ] , e coord [ 1 ] ) ) return e ; if ( match in same direction ( p0 , p1 , e coord [ e coord . length - 1 ] , e coord [ e coord . length - 2 ] ) ) return e ; } return null ; }
public boolean be cover ( ) { boolean have point in common = be true ( matrix [ location . interior ] [ location . interior ] ) || be true ( matrix [ location . interior ] [ location . boundary ] ) || be true ( matrix [ location . boundary ] [ location . interior ] ) || be true ( matrix [ location . boundary ] [ location . boundary ] ) ; return have point in common & & matrix [ location . exterior ] [ location . interior ] == dimension . false & & matrix [ location . exterior ] [ location . boundary ] == dimension . false ; }
public item get item ( ) { return null ; }
public value get envelope union ( value geometry r ) { geometry factory gf = new geometry factory ( ) ; envelope merge envelope = new envelope ( get geometry no copy ( ) . get envelope internal ( ) ) ; merge envelope . expand to include ( r . get geometry no copy ( ) . get envelope internal ( ) ) ; return get ( gf . to geometry ( merge envelope ) ) ; }
public void set length ( int length ) { assert . be true ( length > = 0 ) ; this . length= length ; }
public void set auto compaction factor ( float factor ) { if ( factor < 0 ) { throw new illegal argument exception ( `` factor must be > = 0 : `` + factor ) ; } _auto compaction factor = factor ; }
public model map get model ( ) { if ( use default model ( ) ) { return this . default model ; } else { if ( this . redirect model == null ) { this . redirect model = new model map ( ) ; } return this . redirect model ; } }
public int get max value ( int dimension ) { if ( dimension < 2 || dimension > 32 ) { throw new illegal argument exception ( `` `` + dimension ) ; } int bit per value = get bit per value ( dimension ) ; return ( int ) ( ( 1l < < bits per value ) - 1 ) ; }
public boolean cover ( geometry geom ) { return eval ( geom ) ; }
public edge ring get shell ( ) { if ( be hole ( ) ) return shell ; return this ; }
public boolean cover ( geometry geom ) { return eval ( geom ) ; }
public int [ ] get int array ( long offset , int array size ) { int [ ] buf = new int [ array size ] ; read ( offset , buf , 0 , array size ) ; return buf ; }
public void set size ( final long size ) { this . size = size ; }
protect byte [ ] new buffer ( int size ) { return new byte [ size ] ; }
public static void put u short ( byte [ ] data , int offset , int value ) { int i = offset ; data [ i++ ] = ( byte ) ( ( value > > > 0 ) & 0x f f ) ; data [ i++ ] = ( byte ) ( ( value > > > 8 ) & 0x f f ) ; }
public synchronize double histogram get interval histogram ( double histogram histogram to recycle ) { return get interval histogram ( histogram to recycle , true ) ; }
public final void pause tracing ( boolean pause ) { trace pause = pause ; }
public json object get source j s o n ( ) { return this . source j s o n ; }
public static try rpc create ( scope scope , operand < string > address , operand < string > method , operand < string > request , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` try rpc `` , scope . make op name ( `` try rpc `` ) ) ; op builder . add input ( address . a output ( ) ) ; op builder . add input ( method . a output ( ) ) ; op builder . add input ( request . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . protocol ! = null ) { op builder . set attr ( `` protocol `` , opts . protocol ) ; } if ( opts . fail fast ! = null ) { op builder . set attr ( `` fail_fast `` , opts . fail fast ) ; } if ( opts . timeout in m ! = null ) { op builder . set attr ( `` timeout_in_ms `` , opts . timeout in m ) ; } } } return new try rpc ( op builder . build ( ) ) ; }
public static read file create ( scope scope , operand < string > filename ) { operation builder op builder = scope . graph ( ) . op builder ( `` read file `` , scope . make op name ( `` read file `` ) ) ; op builder . add input ( filename . a output ( ) ) ; return new read file ( op builder . build ( ) ) ; }
public static < t extend number > random crop < t > create ( scope scope , operand < t > image , operand < long > size , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` random crop `` , scope . make op name ( `` random crop `` ) ) ; op builder . add input ( image . a output ( ) ) ; op builder . add input ( size . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . seed ! = null ) { op builder . set attr ( `` seed `` , opts . seed ) ; } if ( opts . seed2 ! = null ) { op builder . set attr ( `` seed2 `` , opts . seed2 ) ; } } } return new random crop < t > ( op builder . build ( ) ) ; }
public string get expect ( ) { return f expect ; }
public static < t extend number > sparse reduce max < t > create ( scope scope , operand < long > input index , operand < t > input value , operand < long > input shape , operand < integer > reduction ax , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` sparse reduce max `` , scope . make op name ( `` sparse reduce max `` ) ) ; op builder . add input ( input index . a output ( ) ) ; op builder . add input ( input value . a output ( ) ) ; op builder . add input ( input shape . a output ( ) ) ; op builder . add input ( reduction axes . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . keep dims ! = null ) { op builder . set attr ( `` keep_dims `` , opts . keep dims ) ; } } } return new sparse reduce max < t > ( op builder . build ( ) ) ; }
public output < t > output ( ) { return output ; }
public static < t extend number > maximum < t > create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` maximum `` , scope . make op name ( `` maximum `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new maximum < t > ( op builder . build ( ) ) ; }
public static < t > max pool v2 < t > create ( scope scope , operand < t > input , operand < integer > ksize , operand < integer > stride , string padding , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` max pool v2 `` , scope . make op name ( `` max pool v2 `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . add input ( ksize . a output ( ) ) ; op builder . add input ( stride . a output ( ) ) ; op builder . set attr ( `` pad `` , pad ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . data format ! = null ) { op builder . set attr ( `` data_format `` , opts . data format ) ; } } } return new max pool v2 < t > ( op builder . build ( ) ) ; }
public output < t > output ( ) { return output ; }
public output < integer > size ( ) { return size ; }
public static < t extend number > batch matrix solve l < t > create ( scope scope , operand < t > matrix , operand < t > rh , operand < double > l2 regularizer , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` batch matrix solve l `` , scope . make op name ( `` batch matrix solve l `` ) ) ; op builder . add input ( matrix . a output ( ) ) ; op builder . add input ( rh . a output ( ) ) ; op builder . add input ( l2 regularizer . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . fast ! = null ) { op builder . set attr ( `` fast `` , opts . fast ) ; } } } return new batch matrix solve l < t > ( op builder . build ( ) ) ; }
public static < t > batch matrix set diag < t > create ( scope scope , operand < t > input , operand < t > diagonal ) { operation builder op builder = scope . graph ( ) . op builder ( `` batch matrix set diag `` , scope . make op name ( `` batch matrix set diag `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . add input ( diagonal . a output ( ) ) ; return new batch matrix set diag < t > ( op builder . build ( ) ) ; }
public output < t > output ( ) { return output ; }
public int leave ( int node ) { return leave [ node ] ; }
public output < float > output ( ) { return output ; }
public output < ? > output ( ) { return output ; }
public static < t > merge < t > create ( scope scope , operand < t > input ) { operation builder op builder = scope . graph ( ) . op builder ( `` merge `` , scope . make op name ( `` merge `` ) ) ; op builder . add input ( input . a output ( ) ) ; return new merge < t > ( op builder . build ( ) ) ; }
public static < t extend number > maximum < t > create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` maximum `` , scope . make op name ( `` maximum `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new maximum < t > ( op builder . build ( ) ) ; }
public static < t > max pool v2 < t > create ( scope scope , operand < t > input , operand < integer > ksize , operand < integer > stride , string padding , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` max pool v2 `` , scope . make op name ( `` max pool v2 `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . add input ( ksize . a output ( ) ) ; op builder . add input ( stride . a output ( ) ) ; op builder . set attr ( `` pad `` , pad ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . data format ! = null ) { op builder . set attr ( `` data_format `` , opts . data format ) ; } } } return new max pool v2 < t > ( op builder . build ( ) ) ; }
public static < t extend number > maximum < t > create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` maximum `` , scope . make op name ( `` maximum `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new maximum < t > ( op builder . build ( ) ) ; }
public static < t extend number > resize area create ( scope scope , operand < t > image , operand < integer > size , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` resize area `` , scope . make op name ( `` resize area `` ) ) ; op builder . add input ( image . a output ( ) ) ; op builder . add input ( size . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . align corner ! = null ) { op builder . set attr ( `` align_corners `` , opts . align corner ) ; } } } return new resize area ( op builder . build ( ) ) ; }
public output < ? > output ( ) { return output ; }
public output < t > output ( ) { return output ; }
public static < t extend number > cudnn r n n < t > create ( scope scope , operand < t > input , operand < t > input h , operand < t > input c , operand < t > params , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` cudnn r n n `` , scope . make op name ( `` cudnn r n n `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . add input ( input h . a output ( ) ) ; op builder . add input ( input c . a output ( ) ) ; op builder . add input ( params . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . rnn mode ! = null ) { op builder . set attr ( `` rnn_mode `` , opts . rnn mode ) ; } if ( opts . input mode ! = null ) { op builder . set attr ( `` input_mode `` , opts . input mode ) ; } if ( opts . direction ! = null ) { op builder . set attr ( `` direction `` , opts . direction ) ; } if ( opts . dropout ! = null ) { op builder . set attr ( `` dropout `` , opts . dropout ) ; } if ( opts . seed ! = null ) { op builder . set attr ( `` seed `` , opts . seed ) ; } if ( opts . seed2 ! = null ) { op builder . set attr ( `` seed2 `` , opts . seed2 ) ; } if ( opts . be train ! = null ) { op builder . set attr ( `` is_training `` , opts . be train ) ; } } } return new cudnn r n n < t > ( op builder . build ( ) ) ; }
public static < t extend number > cudnn r n n v2 < t > create ( scope scope , operand < t > input , operand < t > input h , operand < t > input c , operand < t > params , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` cudnn r n n v2 `` , scope . make op name ( `` cudnn r n n v2 `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . add input ( input h . a output ( ) ) ; op builder . add input ( input c . a output ( ) ) ; op builder . add input ( params . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . rnn mode ! = null ) { op builder . set attr ( `` rnn_mode `` , opts . rnn mode ) ; } if ( opts . input mode ! = null ) { op builder . set attr ( `` input_mode `` , opts . input mode ) ; } if ( opts . direction ! = null ) { op builder . set attr ( `` direction `` , opts . direction ) ; } if ( opts . dropout ! = null ) { op builder . set attr ( `` dropout `` , opts . dropout ) ; } if ( opts . seed ! = null ) { op builder . set attr ( `` seed `` , opts . seed ) ; } if ( opts . seed2 ! = null ) { op builder . set attr ( `` seed2 `` , opts . seed2 ) ; } if ( opts . be train ! = null ) { op builder . set attr ( `` is_training `` , opts . be train ) ; } } } return new cudnn r n n v2 < t > ( op builder . build ( ) ) ; }
public static < t extend number > cudnn r n n < t > create ( scope scope , operand < t > input , operand < t > input h , operand < t > input c , operand < t > params , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` cudnn r n n `` , scope . make op name ( `` cudnn r n n `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . add input ( input h . a output ( ) ) ; op builder . add input ( input c . a output ( ) ) ; op builder . add input ( params . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . rnn mode ! = null ) { op builder . set attr ( `` rnn_mode `` , opts . rnn mode ) ; } if ( opts . input mode ! = null ) { op builder . set attr ( `` input_mode `` , opts . input mode ) ; } if ( opts . direction ! = null ) { op builder . set attr ( `` direction `` , opts . direction ) ; } if ( opts . dropout ! = null ) { op builder . set attr ( `` dropout `` , opts . dropout ) ; } if ( opts . seed ! = null ) { op builder . set attr ( `` seed `` , opts . seed ) ; } if ( opts . seed2 ! = null ) { op builder . set attr ( `` seed2 `` , opts . seed2 ) ; } if ( opts . be train ! = null ) { op builder . set attr ( `` is_training `` , opts . be train ) ; } } } return new cudnn r n n < t > ( op builder . build ( ) ) ; }
public static < t > max pool v2 < t > create ( scope scope , operand < t > input , operand < integer > ksize , operand < integer > stride , string padding , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` max pool v2 `` , scope . make op name ( `` max pool v2 `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . add input ( ksize . a output ( ) ) ; op builder . add input ( stride . a output ( ) ) ; op builder . set attr ( `` pad `` , pad ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . data format ! = null ) { op builder . set attr ( `` data_format `` , opts . data format ) ; } } } return new max pool v2 < t > ( op builder . build ( ) ) ; }
public static < t extend number > any create ( scope scope , operand < boolean > input , operand < t > axis , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` any `` , scope . make op name ( `` any `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . add input ( axis . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . keep dims ! = null ) { op builder . set attr ( `` keep_dims `` , opts . keep dims ) ; } } } return new any ( op builder . build ( ) ) ; }
public void set binary ( boolean b ) { binary = b ; }
public output < integer > size ( ) { return size ; }
public static audio summary create ( scope scope , operand < string > tag , operand < float > tensor , operand < float > sample rate , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` audio summary v2 `` , scope . make op name ( `` audio summary `` ) ) ; op builder . add input ( tag . a output ( ) ) ; op builder . add input ( tensor . a output ( ) ) ; op builder . add input ( sample rate . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . max output ! = null ) { op builder . set attr ( `` max_outputs `` , opts . max output ) ; } } } return new audio summary ( op builder . build ( ) ) ; }
public output < t > output ( ) { return output ; }
public static < t extend number > any create ( scope scope , operand < boolean > input , operand < t > axis , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` any `` , scope . make op name ( `` any `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . add input ( axis . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . keep dims ! = null ) { op builder . set attr ( `` keep_dims `` , opts . keep dims ) ; } } } return new any ( op builder . build ( ) ) ; }
public static < t extend number > maximum < t > create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` maximum `` , scope . make op name ( `` maximum `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new maximum < t > ( op builder . build ( ) ) ; }
public output < t > output ( ) { return output ; }
public output < t > backprops ( ) { return backprops ; }
public static < t extend number > any create ( scope scope , operand < boolean > input , operand < t > axis , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` any `` , scope . make op name ( `` any `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . add input ( axis . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . keep dims ! = null ) { op builder . set attr ( `` keep_dims `` , opts . keep dims ) ; } } } return new any ( op builder . build ( ) ) ; }
public static < t extend number > cudnn r n n < t > create ( scope scope , operand < t > input , operand < t > input h , operand < t > input c , operand < t > params , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` cudnn r n n `` , scope . make op name ( `` cudnn r n n `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . add input ( input h . a output ( ) ) ; op builder . add input ( input c . a output ( ) ) ; op builder . add input ( params . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . rnn mode ! = null ) { op builder . set attr ( `` rnn_mode `` , opts . rnn mode ) ; } if ( opts . input mode ! = null ) { op builder . set attr ( `` input_mode `` , opts . input mode ) ; } if ( opts . direction ! = null ) { op builder . set attr ( `` direction `` , opts . direction ) ; } if ( opts . dropout ! = null ) { op builder . set attr ( `` dropout `` , opts . dropout ) ; } if ( opts . seed ! = null ) { op builder . set attr ( `` seed `` , opts . seed ) ; } if ( opts . seed2 ! = null ) { op builder . set attr ( `` seed2 `` , opts . seed2 ) ; } if ( opts . be train ! = null ) { op builder . set attr ( `` is_training `` , opts . be train ) ; } } } return new cudnn r n n < t > ( op builder . build ( ) ) ; }
public output < t > output ( ) { return output ; }
public static read file create ( scope scope , operand < string > filename ) { operation builder op builder = scope . graph ( ) . op builder ( `` read file `` , scope . make op name ( `` read file `` ) ) ; op builder . add input ( filename . a output ( ) ) ; return new read file ( op builder . build ( ) ) ; }
public static model dataset create ( scope scope , operand < ? > input dataset , list < class < ? > > output type , list < shape > output shape ) { operation builder op builder = scope . graph ( ) . op builder ( `` model dataset `` , scope . make op name ( `` model dataset `` ) ) ; op builder . add input ( input dataset . a output ( ) ) ; data type [ ] output type array = new data type [ output type . size ( ) ] ; for ( int i = 0 ; i < output type array . length ; ++i ) { output type array [ i ] = data type . from class ( output type . get ( i ) ) ; } op builder . set attr ( `` output_types `` , output type array ) ; shape [ ] output shape array = new shape [ output shape . size ( ) ] ; for ( int i = 0 ; i < output shape array . length ; ++i ) { output shape array [ i ] = output shape . get ( i ) ; } op builder . set attr ( `` output_shapes `` , output shape array ) ; return new model dataset ( op builder . build ( ) ) ; }
public output < long > shape ( ) { return shape ; }
public output < float > backprop wrt max ( ) { return backprop wrt max ; }
public output < float > backprop wrt min ( ) { return backprop wrt min ; }
public static merge summary create ( scope scope , iterable < operand < string > > input ) { operation builder op builder = scope . graph ( ) . op builder ( `` merge summary `` , scope . make op name ( `` merge summary `` ) ) ; op builder . add input list ( operands . a output ( input ) ) ; return new merge summary ( op builder . build ( ) ) ; }
public long get byte reserve ( ) { return 0 ; }
public t get value ( ) { return value ; }
public boolean contains range ( range range ) { if ( range == null ) { return false ; } return contains integer ( range . get minimum integer ( ) ) & & contain integer ( range . get maximum integer ( ) ) ; }
public static < t extend number > le equal create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` less equal `` , scope . make op name ( `` less equal `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new less equal ( op builder . build ( ) ) ; }
public static < t > merge < t > create ( scope scope , operand < t > input ) { operation builder op builder = scope . graph ( ) . op builder ( `` merge `` , scope . make op name ( `` merge `` ) ) ; op builder . add input ( input . a output ( ) ) ; return new merge < t > ( op builder . build ( ) ) ; }
public static tensor forest tree predict create ( scope scope , operand < ? > tree handle , operand < float > dense feature , long logits dimension ) { operation builder op builder = scope . graph ( ) . op builder ( `` tensor forest tree predict `` , scope . make op name ( `` tensor forest tree predict `` ) ) ; op builder . add input ( tree handle . a output ( ) ) ; op builder . add input ( dense feature . a output ( ) ) ; op builder . set attr ( `` logits_dimension `` , logits dimension ) ; return new tensor forest tree predict ( op builder . build ( ) ) ; }
public static iterator get next create ( scope scope , operand < ? > iterator , list < class < ? > > output type , list < shape > output shape ) { operation builder op builder = scope . graph ( ) . op builder ( `` iterator get next `` , scope . make op name ( `` iterator get next `` ) ) ; op builder . add input ( iterator . a output ( ) ) ; data type [ ] output type array = new data type [ output type . size ( ) ] ; for ( int i = 0 ; i < output type array . length ; ++i ) { output type array [ i ] = data type . from class ( output type . get ( i ) ) ; } op builder . set attr ( `` output_types `` , output type array ) ; shape [ ] output shape array = new shape [ output shape . size ( ) ] ; for ( int i = 0 ; i < output shape array . length ; ++i ) { output shape array [ i ] = output shape . get ( i ) ; } op builder . set attr ( `` output_shapes `` , output shape array ) ; return new iterator get next ( op builder . build ( ) ) ; }
public static iterator v2 create ( scope scope , string share name , string container , list < class < ? > > output type , list < shape > output shape ) { operation builder op builder = scope . graph ( ) . op builder ( `` iterator v2 `` , scope . make op name ( `` iterator v2 `` ) ) ; op builder . set attr ( `` shared_name `` , share name ) ; op builder . set attr ( `` container `` , container ) ; data type [ ] output type array = new data type [ output type . size ( ) ] ; for ( int i = 0 ; i < output type array . length ; ++i ) { output type array [ i ] = data type . from class ( output type . get ( i ) ) ; } op builder . set attr ( `` output_types `` , output type array ) ; shape [ ] output shape array = new shape [ output shape . size ( ) ] ; for ( int i = 0 ; i < output shape array . length ; ++i ) { output shape array [ i ] = output shape . get ( i ) ; } op builder . set attr ( `` output_shapes `` , output shape array ) ; return new iterator v2 ( op builder . build ( ) ) ; }
public static iterator get next create ( scope scope , operand < ? > iterator , list < class < ? > > output type , list < shape > output shape ) { operation builder op builder = scope . graph ( ) . op builder ( `` iterator get next `` , scope . make op name ( `` iterator get next `` ) ) ; op builder . add input ( iterator . a output ( ) ) ; data type [ ] output type array = new data type [ output type . size ( ) ] ; for ( int i = 0 ; i < output type array . length ; ++i ) { output type array [ i ] = data type . from class ( output type . get ( i ) ) ; } op builder . set attr ( `` output_types `` , output type array ) ; shape [ ] output shape array = new shape [ output shape . size ( ) ] ; for ( int i = 0 ; i < output shape array . length ; ++i ) { output shape array [ i ] = output shape . get ( i ) ; } op builder . set attr ( `` output_shapes `` , output shape array ) ; return new iterator get next ( op builder . build ( ) ) ; }
public output < t > backprops ( ) { return backprops ; }
public static < t extend number > maximum < t > create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` maximum `` , scope . make op name ( `` maximum `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new maximum < t > ( op builder . build ( ) ) ; }
public static < t > batch matrix set diag < t > create ( scope scope , operand < t > input , operand < t > diagonal ) { operation builder op builder = scope . graph ( ) . op builder ( `` batch matrix set diag `` , scope . make op name ( `` batch matrix set diag `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . add input ( diagonal . a output ( ) ) ; return new batch matrix set diag < t > ( op builder . build ( ) ) ; }
public output < ? > output ( ) { return output ; }
public static encode jpeg create ( scope scope , operand < u int8 > image , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` encode jpeg `` , scope . make op name ( `` encode jpeg `` ) ) ; op builder . add input ( image . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . format ! = null ) { op builder . set attr ( `` format `` , opts . format ) ; } if ( opts . quality ! = null ) { op builder . set attr ( `` quality `` , opts . quality ) ; } if ( opts . progressive ! = null ) { op builder . set attr ( `` progressive `` , opts . progressive ) ; } if ( opts . optimize size ! = null ) { op builder . set attr ( `` optimize_size `` , opts . optimize size ) ; } if ( opts . chroma downsampling ! = null ) { op builder . set attr ( `` chroma_downsampling `` , opts . chroma downsampling ) ; } if ( opts . density unit ! = null ) { op builder . set attr ( `` density_unit `` , opts . density unit ) ; } if ( opts . x density ! = null ) { op builder . set attr ( `` x_density `` , opts . x density ) ; } if ( opts . y density ! = null ) { op builder . set attr ( `` y_density `` , opts . y density ) ; } if ( opts . xmp metadata ! = null ) { op builder . set attr ( `` xmp_metadata `` , opts . xmp metadata ) ; } } } return new encode jpeg ( op builder . build ( ) ) ; }
public output < t > output ( ) { return output ; }
public output < t > output ( ) { return output ; }
public static < t extend number > le equal create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` less equal `` , scope . make op name ( `` less equal `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new less equal ( op builder . build ( ) ) ; }
public output < t > output ( ) { return output ; }
public static < t extend number > quantize and dequantize v2 < t > create ( scope scope , operand < t > input , operand < t > input min , operand < t > input max , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` quantize and dequantize v2 `` , scope . make op name ( `` quantize and dequantize v2 `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . add input ( input min . a output ( ) ) ; op builder . add input ( input max . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . sign input ! = null ) { op builder . set attr ( `` signed_input `` , opts . sign input ) ; } if ( opts . num bit ! = null ) { op builder . set attr ( `` num_bits `` , opts . num bit ) ; } if ( opts . range give ! = null ) { op builder . set attr ( `` range_given `` , opts . range give ) ; } if ( opts . round mode ! = null ) { op builder . set attr ( `` round_mode `` , opts . round mode ) ; } } } return new quantize and dequantize v2 < t > ( op builder . build ( ) ) ; }
public static < t > ref merge < t > create ( scope scope , operand < t > input ) { operation builder op builder = scope . graph ( ) . op builder ( `` ref merge `` , scope . make op name ( `` ref merge `` ) ) ; op builder . add input ( input . a output ( ) ) ; return new ref merge < t > ( op builder . build ( ) ) ; }
public static < t > merge < t > create ( scope scope , operand < t > input ) { operation builder op builder = scope . graph ( ) . op builder ( `` merge `` , scope . make op name ( `` merge `` ) ) ; op builder . add input ( input . a output ( ) ) ; return new merge < t > ( op builder . build ( ) ) ; }
public static experimental unbatch dataset create ( scope scope , operand < ? > input dataset , list < class < ? > > output type , list < shape > output shape ) { operation builder op builder = scope . graph ( ) . op builder ( `` experimental unbatch dataset `` , scope . make op name ( `` experimental unbatch dataset `` ) ) ; op builder . add input ( input dataset . a output ( ) ) ; data type [ ] output type array = new data type [ output type . size ( ) ] ; for ( int i = 0 ; i < output type array . length ; ++i ) { output type array [ i ] = data type . from class ( output type . get ( i ) ) ; } op builder . set attr ( `` output_types `` , output type array ) ; shape [ ] output shape array = new shape [ output shape . size ( ) ] ; for ( int i = 0 ; i < output shape array . length ; ++i ) { output shape array [ i ] = output shape . get ( i ) ; } op builder . set attr ( `` output_shapes `` , output shape array ) ; return new experimental unbatch dataset ( op builder . build ( ) ) ; }
public static iterator get next create ( scope scope , operand < ? > iterator , list < class < ? > > output type , list < shape > output shape ) { operation builder op builder = scope . graph ( ) . op builder ( `` iterator get next `` , scope . make op name ( `` iterator get next `` ) ) ; op builder . add input ( iterator . a output ( ) ) ; data type [ ] output type array = new data type [ output type . size ( ) ] ; for ( int i = 0 ; i < output type array . length ; ++i ) { output type array [ i ] = data type . from class ( output type . get ( i ) ) ; } op builder . set attr ( `` output_types `` , output type array ) ; shape [ ] output shape array = new shape [ output shape . size ( ) ] ; for ( int i = 0 ; i < output shape array . length ; ++i ) { output shape array [ i ] = output shape . get ( i ) ; } op builder . set attr ( `` output_shapes `` , output shape array ) ; return new iterator get next ( op builder . build ( ) ) ; }
public static non max suppression with overlap create ( scope scope , operand < float > overlap , operand < float > score , operand < integer > max output size , operand < float > overlap threshold , operand < float > score threshold ) { operation builder op builder = scope . graph ( ) . op builder ( `` non max suppression with overlap `` , scope . make op name ( `` non max suppression with overlap `` ) ) ; op builder . add input ( overlaps . a output ( ) ) ; op builder . add input ( score . a output ( ) ) ; op builder . add input ( max output size . a output ( ) ) ; op builder . add input ( overlap threshold . a output ( ) ) ; op builder . add input ( score threshold . a output ( ) ) ; return new non max suppression with overlap ( op builder . build ( ) ) ; }
public output < integer > output ( ) { return output ; }
public static non max suppression create ( scope scope , operand < float > box , operand < float > score , operand < integer > max output size , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` non max suppression `` , scope . make op name ( `` non max suppression `` ) ) ; op builder . add input ( box . a output ( ) ) ; op builder . add input ( score . a output ( ) ) ; op builder . add input ( max output size . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . iou threshold ! = null ) { op builder . set attr ( `` iou_threshold `` , opts . iou threshold ) ; } } } return new non max suppression ( op builder . build ( ) ) ; }
public static priority queue create ( scope scope , list < class < ? > > component type , list < shape > shape , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` priority queue v2 `` , scope . make op name ( `` priority queue `` ) ) ; data type [ ] component type array = new data type [ component type . size ( ) ] ; for ( int i = 0 ; i < component type array . length ; ++i ) { component type array [ i ] = data type . from class ( component type . get ( i ) ) ; } op builder . set attr ( `` component_types `` , component type array ) ; shape [ ] shape array = new shape [ shape . size ( ) ] ; for ( int i = 0 ; i < shape array . length ; ++i ) { shapes array [ i ] = shape . get ( i ) ; } op builder . set attr ( `` shape `` , shape array ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . capacity ! = null ) { op builder . set attr ( `` capacity `` , opts . capacity ) ; } if ( opts . container ! = null ) { op builder . set attr ( `` container `` , opts . container ) ; } if ( opts . share name ! = null ) { op builder . set attr ( `` shared_name `` , opts . share name ) ; } } } return new priority queue ( op builder . build ( ) ) ; }
public static < t > sparse dense cwise div < t > create ( scope scope , operand < long > sp index , operand < t > sp value , operand < long > sp shape , operand < t > dense ) { operation builder op builder = scope . graph ( ) . op builder ( `` sparse dense cwise div `` , scope . make op name ( `` sparse dense cwise div `` ) ) ; op builder . add input ( sp index . a output ( ) ) ; op builder . add input ( sp value . a output ( ) ) ; op builder . add input ( sp shape . a output ( ) ) ; op builder . add input ( dense . a output ( ) ) ; return new sparse dense cwise div < t > ( op builder . build ( ) ) ; }
public static padding f i f o queue create ( scope scope , list < class < ? > > component type , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` pad f i f o queue v2 `` , scope . make op name ( `` pad f i f o queue `` ) ) ; data type [ ] component type array = new data type [ component type . size ( ) ] ; for ( int i = 0 ; i < component type array . length ; ++i ) { component type array [ i ] = data type . from class ( component type . get ( i ) ) ; } op builder . set attr ( `` component_types `` , component type array ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . shape ! = null ) { shape [ ] shape array = new shape [ opts . shape . size ( ) ] ; for ( int i = 0 ; i < shape array . length ; ++i ) { shapes array [ i ] = opts . shape . get ( i ) ; } op builder . set attr ( `` shape `` , shape array ) ; } if ( opts . capacity ! = null ) { op builder . set attr ( `` capacity `` , opts . capacity ) ; } if ( opts . container ! = null ) { op builder . set attr ( `` container `` , opts . container ) ; } if ( opts . share name ! = null ) { op builder . set attr ( `` shared_name `` , opts . share name ) ; } } } return new pad f i f o queue ( op builder . build ( ) ) ; }
public static < t extend number > cudnn r n n v2 < t > create ( scope scope , operand < t > input , operand < t > input h , operand < t > input c , operand < t > params , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` cudnn r n n v2 `` , scope . make op name ( `` cudnn r n n v2 `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . add input ( input h . a output ( ) ) ; op builder . add input ( input c . a output ( ) ) ; op builder . add input ( params . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . rnn mode ! = null ) { op builder . set attr ( `` rnn_mode `` , opts . rnn mode ) ; } if ( opts . input mode ! = null ) { op builder . set attr ( `` input_mode `` , opts . input mode ) ; } if ( opts . direction ! = null ) { op builder . set attr ( `` direction `` , opts . direction ) ; } if ( opts . dropout ! = null ) { op builder . set attr ( `` dropout `` , opts . dropout ) ; } if ( opts . seed ! = null ) { op builder . set attr ( `` seed `` , opts . seed ) ; } if ( opts . seed2 ! = null ) { op builder . set attr ( `` seed2 `` , opts . seed2 ) ; } if ( opts . be train ! = null ) { op builder . set attr ( `` is_training `` , opts . be train ) ; } } } return new cudnn r n n v2 < t > ( op builder . build ( ) ) ; }
public static < t extend number > sparse reduce max < t > create ( scope scope , operand < long > input index , operand < t > input value , operand < long > input shape , operand < integer > reduction ax , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` sparse reduce max `` , scope . make op name ( `` sparse reduce max `` ) ) ; op builder . add input ( input index . a output ( ) ) ; op builder . add input ( input value . a output ( ) ) ; op builder . add input ( input shape . a output ( ) ) ; op builder . add input ( reduction axes . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . keep dims ! = null ) { op builder . set attr ( `` keep_dims `` , opts . keep dims ) ; } } } return new sparse reduce max < t > ( op builder . build ( ) ) ; }
public activation file get file ( ) { return this . file ; } // -- activation file get file ( )
public output < float > output ( ) { return output ; }
public output < t > output ( ) { return output ; }
public static < t extend number > cudnn r n n < t > create ( scope scope , operand < t > input , operand < t > input h , operand < t > input c , operand < t > params , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` cudnn r n n `` , scope . make op name ( `` cudnn r n n `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . add input ( input h . a output ( ) ) ; op builder . add input ( input c . a output ( ) ) ; op builder . add input ( params . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . rnn mode ! = null ) { op builder . set attr ( `` rnn_mode `` , opts . rnn mode ) ; } if ( opts . input mode ! = null ) { op builder . set attr ( `` input_mode `` , opts . input mode ) ; } if ( opts . direction ! = null ) { op builder . set attr ( `` direction `` , opts . direction ) ; } if ( opts . dropout ! = null ) { op builder . set attr ( `` dropout `` , opts . dropout ) ; } if ( opts . seed ! = null ) { op builder . set attr ( `` seed `` , opts . seed ) ; } if ( opts . seed2 ! = null ) { op builder . set attr ( `` seed2 `` , opts . seed2 ) ; } if ( opts . be train ! = null ) { op builder . set attr ( `` is_training `` , opts . be train ) ; } } } return new cudnn r n n < t > ( op builder . build ( ) ) ; }
public static read file create ( scope scope , operand < string > filename ) { operation builder op builder = scope . graph ( ) . op builder ( `` read file `` , scope . make op name ( `` read file `` ) ) ; op builder . add input ( filename . a output ( ) ) ; return new read file ( op builder . build ( ) ) ; }
public static < t > co < t > create ( scope scope , operand < t > x ) { operation builder op builder = scope . graph ( ) . op builder ( `` co `` , scope . make op name ( `` cos `` ) ) ; op builder . add input ( x . a output ( ) ) ; return new co < t > ( op builder . build ( ) ) ; }
public static < t > co < t > create ( scope scope , operand < t > x ) { operation builder op builder = scope . graph ( ) . op builder ( `` co `` , scope . make op name ( `` cos `` ) ) ; op builder . add input ( x . a output ( ) ) ; return new co < t > ( op builder . build ( ) ) ; }
public static < t > merge < t > create ( scope scope , operand < t > input ) { operation builder op builder = scope . graph ( ) . op builder ( `` merge `` , scope . make op name ( `` merge `` ) ) ; op builder . add input ( input . a output ( ) ) ; return new merge < t > ( op builder . build ( ) ) ; }
public static < t extend number > any create ( scope scope , operand < boolean > input , operand < t > axis , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` any `` , scope . make op name ( `` any `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . add input ( axis . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . keep dims ! = null ) { op builder . set attr ( `` keep_dims `` , opts . keep dims ) ; } } } return new any ( op builder . build ( ) ) ; }
public output < string > output ( ) { return output ; }
public static < t extend number > maximum < t > create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` maximum `` , scope . make op name ( `` maximum `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new maximum < t > ( op builder . build ( ) ) ; }
public void set error begin at ( int error begin at ) { this . error begin at = error begin at ; }
public void set summary ( final content summary ) { this . summary = summary ; }
public void move to back ( e e ) { if ( e ! = last ) { unlink ( e ) ; link last ( e ) ; } }
public static < t > sigmoid grad < t > create ( scope scope , operand < t > y , operand < t > dy ) { operation builder op builder = scope . graph ( ) . op builder ( `` sigmoid grad `` , scope . make op name ( `` sigmoid grad `` ) ) ; op builder . add input ( y . a output ( ) ) ; op builder . add input ( dy . a output ( ) ) ; return new sigmoid grad < t > ( op builder . build ( ) ) ; }
public static < t > sigmoid < t > create ( scope scope , operand < t > x ) { operation builder op builder = scope . graph ( ) . op builder ( `` sigmoid `` , scope . make op name ( `` sigmoid `` ) ) ; op builder . add input ( x . a output ( ) ) ; return new sigmoid < t > ( op builder . build ( ) ) ; }
public void set doc freq ( long doc freq ) { this . doc freq = doc freq ; }
public static < t extend number > sparse reduce max < t > create ( scope scope , operand < long > input index , operand < t > input value , operand < long > input shape , operand < integer > reduction ax , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` sparse reduce max `` , scope . make op name ( `` sparse reduce max `` ) ) ; op builder . add input ( input index . a output ( ) ) ; op builder . add input ( input value . a output ( ) ) ; op builder . add input ( input shape . a output ( ) ) ; op builder . add input ( reduction axes . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . keep dims ! = null ) { op builder . set attr ( `` keep_dims `` , opts . keep dims ) ; } } } return new sparse reduce max < t > ( op builder . build ( ) ) ; }
public output < long > sparse shape ( ) { return sparse shape ; }
public static parse example create ( scope scope , operand < string > serialize , operand < string > name , iterable < operand < string > > sparse key , iterable < operand < string > > dense key , iterable < operand < ? > > dense default , list < class < ? > > sparse type , list < shape > dense shape ) { operation builder op builder = scope . graph ( ) . op builder ( `` parse example `` , scope . make op name ( `` parse example `` ) ) ; op builder . add input ( serialize . a output ( ) ) ; op builder . add input ( names . a output ( ) ) ; op builder . add input list ( operands . a output ( sparse key ) ) ; op builder . add input list ( operands . a output ( dense key ) ) ; op builder . add input list ( operands . a output ( dense default ) ) ; data type [ ] sparse type array = new data type [ sparse type . size ( ) ] ; for ( int i = 0 ; i < sparse type array . length ; ++i ) { sparse type array [ i ] = data type . from class ( sparse type . get ( i ) ) ; } op builder . set attr ( `` sparse_types `` , sparse type array ) ; shape [ ] dense shape array = new shape [ dense shape . size ( ) ] ; for ( int i = 0 ; i < dense shape array . length ; ++i ) { dense shape array [ i ] = dense shape . get ( i ) ; } op builder . set attr ( `` dense_shapes `` , dense shape array ) ; return new parse example ( op builder . build ( ) ) ; }
public static < t extend number > any create ( scope scope , operand < boolean > input , operand < t > axis , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` any `` , scope . make op name ( `` any `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . add input ( axis . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . keep dims ! = null ) { op builder . set attr ( `` keep_dims `` , opts . keep dims ) ; } } } return new any ( op builder . build ( ) ) ; }
public output < t > output ( ) { return output ; }
public output < long > shape ( ) { return shape ; }
public static < t > tensor array pack < t > create ( scope scope , operand < string > handle , operand < float > flow in , class < t > dtype , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` tensor array pack `` , scope . make op name ( `` tensor array pack `` ) ) ; op builder . add input ( handle . a output ( ) ) ; op builder . add input ( flow in . a output ( ) ) ; op builder . set attr ( `` dtype `` , data type . from class ( dtype ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . element shape ! = null ) { op builder . set attr ( `` element_shape `` , opts . element shape ) ; } } } return new tensor array pack < t > ( op builder . build ( ) ) ; }
public long get length ( ) { return length ; }
public static < t > tensor array unpack create ( scope scope , operand < string > handle , operand < t > value , operand < float > flow in ) { operation builder op builder = scope . graph ( ) . op builder ( `` tensor array unpack `` , scope . make op name ( `` tensor array unpack `` ) ) ; op builder . add input ( handle . a output ( ) ) ; op builder . add input ( value . a output ( ) ) ; op builder . add input ( flow in . a output ( ) ) ; return new tensor array unpack ( op builder . build ( ) ) ; }
public static < t > tensor array pack < t > create ( scope scope , operand < string > handle , operand < float > flow in , class < t > dtype , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` tensor array pack `` , scope . make op name ( `` tensor array pack `` ) ) ; op builder . add input ( handle . a output ( ) ) ; op builder . add input ( flow in . a output ( ) ) ; op builder . set attr ( `` dtype `` , data type . from class ( dtype ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . element shape ! = null ) { op builder . set attr ( `` element_shape `` , opts . element shape ) ; } } } return new tensor array pack < t > ( op builder . build ( ) ) ; }
public static < t > tensor array unpack create ( scope scope , operand < string > handle , operand < t > value , operand < float > flow in ) { operation builder op builder = scope . graph ( ) . op builder ( `` tensor array unpack `` , scope . make op name ( `` tensor array unpack `` ) ) ; op builder . add input ( handle . a output ( ) ) ; op builder . add input ( value . a output ( ) ) ; op builder . add input ( flow in . a output ( ) ) ; return new tensor array unpack ( op builder . build ( ) ) ; }
public index [ ] index ( ) { return index ; }
public static < t extend number > cudnn r n n < t > create ( scope scope , operand < t > input , operand < t > input h , operand < t > input c , operand < t > params , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` cudnn r n n `` , scope . make op name ( `` cudnn r n n `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . add input ( input h . a output ( ) ) ; op builder . add input ( input c . a output ( ) ) ; op builder . add input ( params . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . rnn mode ! = null ) { op builder . set attr ( `` rnn_mode `` , opts . rnn mode ) ; } if ( opts . input mode ! = null ) { op builder . set attr ( `` input_mode `` , opts . input mode ) ; } if ( opts . direction ! = null ) { op builder . set attr ( `` direction `` , opts . direction ) ; } if ( opts . dropout ! = null ) { op builder . set attr ( `` dropout `` , opts . dropout ) ; } if ( opts . seed ! = null ) { op builder . set attr ( `` seed `` , opts . seed ) ; } if ( opts . seed2 ! = null ) { op builder . set attr ( `` seed2 `` , opts . seed2 ) ; } if ( opts . be train ! = null ) { op builder . set attr ( `` is_training `` , opts . be train ) ; } } } return new cudnn r n n < t > ( op builder . build ( ) ) ; }
public output < ? > output ( ) { return output ; }
public static < t > merge < t > create ( scope scope , operand < t > input ) { operation builder op builder = scope . graph ( ) . op builder ( `` merge `` , scope . make op name ( `` merge `` ) ) ; op builder . add input ( input . a output ( ) ) ; return new merge < t > ( op builder . build ( ) ) ; }
public void append name ( string name ) { property ref r = new property ref ( ) ; r . set name ( name ) ; add propertyref ( r ) ; }
public void stop ( ) { stop ( true ) ; }
public write buffer put ( byte buffer src ) { ensure capacity ( src . remain ( ) ) . put ( src ) ; return this ; }
public void set fatal ( boolean fatal ) { }
public void set annotation name ( string annotation name ) { this . annotation name = annotation name ; } // set annotation name
public static top doc merge ( int top n , top doc [ ] shard hit ) { return merge ( 0 , top n , shard hit , true ) ; }
public static list type list ( list list , class type ) { return type list . decorate ( list , type ) ; }
public void add child ( final object child ) { this . child . add ( child ) ; }
public static class loader get context class loader ( ) { thread current thread = thread . current thread ( ) ; return current thread . get context class loader ( ) ; }
public string get loader name for resource ( string resource name ) { resource loader loader = get loader for resource ( resource name ) ; if ( loader == null ) { return null ; } return loader . get class ( ) . to string ( ) ; }
public static string get version string ( ) { return version ; }
public void print ( short value ) throw i o exception { print ( string . value of ( value ) ) ; }
public static < t > class < t > load class ( string class name ) { return load class ( class name , class loader util . class . get class loader ( ) ) ; }
public string get library name pattern ( ) { return `` lib . * \\ . so . * $ `` ; }
public string get name ( ) { return name ; }
public int length ( ) { return this . len ; }
public boolean contains key ( k k ) { return ! get ( k ) . be empty ( ) ; }
public boolean be stop ( ) { return stop ; }
public direct candidate generator builder min word length ( int min word length ) { this . min word length = min word length ; return this ; }
public int get flag ( ) { return flag ; }
public final token stream token stream ( final string field name , final reader reader ) throw i o exception { token stream component component = reuse strategy . get reusable component ( this , field name ) ; final reader r = init reader ( field name , reader ) ; if ( component == null ) { component = create component ( field name , r ) ; reuse strategy . set reusable component ( this , field name , component ) ; } else { component . set reader ( r ) ; } return component . get token stream ( ) ; }
public string get pattern ( ) { return pattern ; }
public void set version ( final string version ) { this . version = version ; }
public string separator ( ) { return separator ; }
public byte [ ] decompress ( byte [ ] src , int src off ) { final int d len = get decompress length ( src , src off ) ; return decompressor . decompress ( src , src off + 4 , d len ) ; }
public static char set get instance ( string set str ) { object set = common . get ( set str ) ; if ( set ! = null ) { return ( char set ) set ; } return new char set ( set str ) ; }
public void set class loader ( class loader class loader ) { this . class loader = class loader ; }
public static list < i o file filter > to list ( final i o file filter . . . filter ) { if ( filter == null ) { throw new illegal argument exception ( `` the filter must not be null `` ) ; } final list < i o file filter > list = new array list < > ( filter . length ) ; for ( int i = 0 ; i < filter . length ; i++ ) { if ( filter [ i ] == null ) { throw new illegal argument exception ( `` the filter [ `` + i + `` ] be null `` ) ; } list . add ( filter [ i ] ) ; } return list ; }
public token peek token ( ) { while ( need more token ( ) ) { fetch more token ( ) ; } return this . token . get ( 0 ) ; }
public token stream component create component ( string field name , reader reader ) { return create component ( field name , reader , null ) ; }
public type component ( ) { return component ; }
public void set input ( string input ) { this . input = input ; }
public term [ ] get term ( ) { return term ; }
public int write ( index index ) throw i o exception { return write ( index , index writer v2 . max_version ) ; }
protect < t > void add codec ( list < t > codecs , t codec ) { init codec ( codec ) ; codecs . add ( codec ) ; }
public term vector request builder set payload ( boolean payload ) { request . payload ( payload ) ; return this ; }
public int bit cache ( ) { return bit cache size ; }
public final t get ( string name ) { int idx = find ( name ) ; return 0 < = idx ? get ( idx ) : null ; }
public multi posting enum reset ( final enum with slice [ ] sub , final int num sub ) { this . num subs = num sub ; for ( int i=0 ; i < num sub ; i++ ) { this . sub [ i ] . posting enum = sub [ i ] . posting enum ; this . sub [ i ] . slice = sub [ i ] . slice ; } upto = -1 ; doc = -1 ; current = null ; return this ; }
public void set doc freq ( long doc freq ) { this . doc freq = doc freq ; }
public synchronize void finish ( ) { finish = true ; }
public static string decompress string ( bytes ref byte ) throw data format exception { return decompress string ( byte . byte , byte . offset , byte . length ) ; }
public static byte [ ] decompress ( bytes ref byte ) throw data format exception { return decompress ( byte . byte , byte . offset , byte . length ) ; }
public term [ ] get term ( ) { return term ; }
public index option get index option ( ) { return index option ; }
public integer get numeric precision ( ) { return numeric precision ; }
public integer get numeric precision ( ) { return numeric precision ; }
public void set thread priority ( int thread priority ) { this . thread priority = thread priority ; }
public directory directory ( ) { return directory ; }
public string get reader ( ) { return reader ; }
public static sort set doc value get sort set value ( final index reader r , final string field ) throw i o exception { final list < atomic reader context > leave = r . leaf ( ) ; final int size = leave . size ( ) ; if ( size == 0 ) { return null ; } else if ( size == 1 ) { return leave . get ( 0 ) . reader ( ) . get sorted set doc value ( field ) ; } boolean any real = false ; final sort set doc value [ ] value = new sort set doc value [ size ] ; final int [ ] start = new int [ size+1 ] ; for ( int i = 0 ; i < size ; i++ ) { atomic reader context context = leave . get ( i ) ; sort set doc value v = context . reader ( ) . get sorted set doc value ( field ) ; if ( v == null ) { v = sort set doc value . empty ; } else { any real = true ; } value [ i ] = v ; start [ i ] = context . doc base ; } start [ size ] = r . max doc ( ) ; if ( ! any real ) { return null ; } else { term enum enums [ ] = new term enum [ value . length ] ; for ( int i = 0 ; i < value . length ; i++ ) { enums [ i ] = value [ i ] . term enum ( ) ; } ordinal map map = new ordinal map ( r . get core cache key ( ) , enums ) ; return new multi sort set doc value ( value , start , map ) ; } }
public boolean have norm ( ) { return norm type ! = null ; }
public boolean omits norm ( ) { return omit norm ; }
public list < doc > get doc ( ) { if ( doc == null ) { doc = new array list < doc > ( ) ; } return this . doc ; }
public long get offset ( ) { return offset ; }
public void set boost ( float boost ) { this . boost = boost ; }
public final synchronize int num ram doc ( ) { ensure open ( ) ; return doc writer . get num doc ( ) ; }
public synchronize int max doc ( ) { ensure open ( ) ; return doc writer . get num doc ( ) + segment info . total doc count ( ) ; }
public cherry pick command include ( any object id commit ) { return include ( commit . get name ( ) , commit ) ; }
public synchronize int max doc ( ) { ensure open ( ) ; return doc writer . get num doc ( ) + segment info . total doc count ( ) ; }
public synchronize service thread pool ( int max thread ) { return thread pool ( max thread , -1 , -1 ) ; }
public string get reader ( ) { return reader ; }
public void set merge ( string merge ) { this . merge = merge ; }
public static sort set doc value get sort set value ( final index reader r , final string field ) throw i o exception { final list < atomic reader context > leave = r . leaf ( ) ; final int size = leave . size ( ) ; if ( size == 0 ) { return null ; } else if ( size == 1 ) { return leave . get ( 0 ) . reader ( ) . get sorted set doc value ( field ) ; } boolean any real = false ; final sort set doc value [ ] value = new sort set doc value [ size ] ; final int [ ] start = new int [ size+1 ] ; for ( int i = 0 ; i < size ; i++ ) { atomic reader context context = leave . get ( i ) ; sort set doc value v = context . reader ( ) . get sorted set doc value ( field ) ; if ( v == null ) { v = sort set doc value . empty ; } else { any real = true ; } value [ i ] = v ; start [ i ] = context . doc base ; } start [ size ] = r . max doc ( ) ; if ( ! any real ) { return null ; } else { term enum enums [ ] = new term enum [ value . length ] ; for ( int i = 0 ; i < value . length ; i++ ) { enums [ i ] = value [ i ] . term enum ( ) ; } ordinal map map = new ordinal map ( r . get core cache key ( ) , enums ) ; return new multi sort set doc value ( value , start , map ) ; } }
public static numeric doc value get norm value ( final index reader r , final string field ) throw i o exception { final list < atomic reader context > leave = r . leaf ( ) ; final int size = leave . size ( ) ; if ( size == 0 ) { return null ; } else if ( size == 1 ) { return leave . get ( 0 ) . reader ( ) . get norm value ( field ) ; } field info fi = multi field . get merged field info ( r ) . field info ( field ) ; if ( fi == null || fi . have norm ( ) == false ) { return null ; } boolean any real = false ; final numeric doc value [ ] value = new numeric doc value [ size ] ; final int [ ] start = new int [ size+1 ] ; for ( int i = 0 ; i < size ; i++ ) { atomic reader context context = leave . get ( i ) ; numeric doc value v = context . reader ( ) . get norm value ( field ) ; if ( v == null ) { v = numeric doc value . empty ; } else { any real = true ; } value [ i ] = v ; start [ i ] = context . doc base ; } start [ size ] = r . max doc ( ) ; assert any real ; return new numeric doc value ( ) { @ override public long get ( int doc i d ) { int sub index = reader util . sub index ( doc i d , start ) ; return value [ sub index ] . get ( doc i d - start [ sub index ] ) ; } } ; }
public field info [ ] get field ( ) { return field ; }
public long count ( ) { return count . get ( ) ; }
public void set file ( file file ) { this . file = file ; }
public void int field ( field info field info , int value ) throw i o exception { }
public void string field ( field info field info , string value ) throw i o exception { }
public boolean equal ( object other ) { if ( other==this ) { return true ; } if ( other instanceof document range ) { return this . compare to ( ( document range ) other ) ==0 ; } return false ; }
public void reset ( ) { seek ( 0 ) ; }
public void set merge ( string merge ) { this . merge = merge ; }
public void invalidate ( k key , v value ) { cache segment < k , v > segment = get cache segment ( key ) ; segment . remove ( key , value , invalidation consumer ) ; }
public int get minimum number should match ( ) { return min nr should match ; }
public void set minimum number should match ( int min ) { this . min nr should match = min ; }
public string get field ( ) { return field ; }
public string get prefix ( ) { return prefix ; }
public document default definition get default ( ) { return this . default ; }
public final boolean accept ( int doc i d , bit live doc ) { return ( filter doc == null || filter doc . get ( doc i d ) ) & & ( live doc == null || live doc . get ( doc i d ) ) ; }
public list < doc > get doc ( ) { if ( doc == null ) { doc = new array list < doc > ( ) ; } return this . doc ; }
public string get query ( ) { return query ; }
public void close ( ) throw i o exception { }
public final void add context listener ( final i context listener listener ) { if ( listener == null ) { throw new null pointer exception ( ) ; } if ( listener == null ) { listener = new hash set < > ( ) ; } listener . add ( listener ) ; }
public explanation explain ( basic stats stats , float tf , float len ) { explanation result = new explanation ( ) ; result . set description ( get class ( ) . get simple name ( ) + `` , compute from : `` ) ; result . set value ( tfn ( stats , tf , len ) ) ; result . add detail ( new explanation ( tf , `` tf `` ) ) ; result . add detail ( new explanation ( stats . get avg field length ( ) , `` avg field length `` ) ) ; result . add detail ( new explanation ( len , `` len `` ) ) ; return result ; }
public final long doc freq ( ) { return doc freq ; }
public float get boost ( ) { return boost ; }
public explanation explain ( basic stats stats , float tfn ) { explanation result = new explanation ( ) ; result . set description ( get class ( ) . get simple name ( ) + `` , compute from : `` ) ; result . set value ( score ( stats , tfn ) ) ; result . add detail ( new explanation ( tfn , `` tfn `` ) ) ; result . add detail ( new explanation ( stats . get number of document ( ) , `` number of document `` ) ) ; result . add detail ( new explanation ( stats . get total term freq ( ) , `` total term freq `` ) ) ; return result ; }
public explanation explain ( basic stats stats , float tfn ) { explanation result = new explanation ( ) ; result . set description ( get class ( ) . get simple name ( ) + `` , compute from : `` ) ; result . set value ( score ( stats , tfn ) ) ; result . add detail ( new explanation ( tfn , `` tfn `` ) ) ; result . add detail ( new explanation ( stats . get number of document ( ) , `` number of document `` ) ) ; result . add detail ( new explanation ( stats . get total term freq ( ) , `` total term freq `` ) ) ; return result ; }
public simple query string builder field ( string field , float boost ) { if ( string . be empty ( field ) ) { throw new illegal argument exception ( `` supply field be null or empty `` ) ; } check negative boost ( boost ) ; this . field and weight . put ( field , boost ) ; return this ; }
public float float value ( ) { return ( ( float ) numerator ) / ( ( float ) denominator ) ; }
public void set include ( string value ) { this . include = value ; }
public file get dir ( ) { return dir ; }
public long content length ( ) throw i o exception { return this . file . length ( ) ; }
public void release ( ) throw exception { / * note on concurrency : a give lock data instance can be only act on by a single thread so locking be n't necessary * / thread current thread = thread . current thread ( ) ; lock data lock data = thread data . get ( current thread ) ; if ( lock data == null ) { throw new illegal monitor state exception ( `` you do not own the lock : `` + base path ) ; } int new lock count = lock data . lock count . decrement and get ( ) ; if ( new lock count > 0 ) { return ; } if ( new lock count < 0 ) { throw new illegal monitor state exception ( `` lock count have go negative for lock : `` + base path ) ; } try { internals . release lock ( lock data . lock path ) ; } finally { thread data . remove ( current thread ) ; } }
public string get prefix ( ) { return prefix ; }
public random access file get random access file ( ) { return random access file ; }
public byte to byte ( ) { return new byte ( byte value ( ) ) ; }
public synchronize state mark available ( ) { if ( map . be empty ( ) ) { state = state . idle ; } else { state = state . pending ; } return state ; }
public string get a string ( ) { return integer . to string ( get ( ) ) ; }
public synchronize state mark available ( ) { if ( map . be empty ( ) ) { state = state . idle ; } else { state = state . pending ; } return state ; }
public int get num transition ( ) { return next transition / 3 ; }
public static string info string ( string entity name , string property name , object key ) { string builder s = new string builder ( ) . append ( ' [ ' ) . append ( entity name ) . append ( ' . ' ) . append ( property name ) . append ( ' # ' ) ; if ( key == null ) { s . append ( `` < null > `` ) ; } else { s . append ( key ) ; } s . append ( ' ] ' ) ; return s . to string ( ) ; }
protect final char [ ] escape ( int cp ) { if ( cp < replacement length ) { char [ ] char = replacement [ cp ] ; if ( char ! = null ) { return char ; } } if ( cp > = safe min & & cp < = safe max ) { return null ; } return escape unsafe ( cp ) ; }
public boolean accept ( final file file ) { return accept base name ( file . get name ( ) ) ; }
public static byte buffer to buffer ( byte [ ] array , int offset , int length ) { if ( array == null ) return empty_buffer ; return byte buffer . wrap ( array , offset , length ) ; }
public int hash code ( ) { int hash = 0 ; for ( int i = 0 ; i < token . length ; i++ ) { hash += tokens [ i ] . hash code ( ) ; } return hash ; }
public boolean equal ( object other ) { return this==other ; }
public static class get class ( string class name ) throw class not find exception { return get class ( class name , true ) ; }
public boolean be cache ( ) { return cache ! = null ; }
public static bit set and ( bit set left , bit set right ) { bit set result = ( bit set ) leave . clone ( ) ; result . and ( right ) ; return result ; }
public static byte [ ] concat ( byte [ ] a , byte . . . b ) { int b len = b . length ; if ( b len == 0 ) { return a ; } int a len = a . length ; if ( a len == 0 ) { return b ; } byte [ ] c = new byte [ a len + b len ] ; system . arraycopy ( a , 0 , c , 0 , a len ) ; system . arraycopy ( b , 0 , c , a len , b len ) ; return c ; }
public static void copy file ( file in , file out ) throw i o exception { try ( file input stream fis = new file input stream ( in ) ; file output stream fo = new file output stream ( out ) ; file channel source channel = fis . get channel ( ) ; file channel destination channel = fo . get channel ( ) ) { source channel . transfer to ( 0 , source channel . size ( ) , destination channel ) ; source channel . close ( ) ; } }
public byte to byte ( ) { return new byte ( byte value ( ) ) ; }
public static long sortable double bit ( long bit ) { return bit ^ ( bit > > 63 ) & 0x7fffffffffffffff l ; }
public iterator < ? extend e > get iterator ( ) { return iterator ; }
public final item current ( ) { return current ; }
public int block size ( ) throw i o exception { if ( block size == -1 ) { read file header ( ) ; } return block size ; }
public string get query ( ) { return query ; }
public int get position ( ) { return position ; }
public static long size of ( string [ ] arr ) { long size = shallow size of ( arr ) ; for ( string s : arr ) { if ( s == null ) { continue ; } size += size of ( s ) ; } return size ; }
public final boolean be store ( ) { return be store ; }
protect boolean be cache full ( ) { return cache size > = maximum cache size ; }
protect int index of ( list < ? extend position > position , position position ) { int index= compute index at offset ( position , position . get offset ( ) ) ; int size= position . size ( ) ; while ( index < size ) { if ( position . get ( index ) == position ) return index ; index++ ; } return -1 ; }
public int get offset ( ) { return offset ; }
protect string [ ] get property method suffix ( string property name ) { string suffix = get property method suffix ( property name ) ; if ( suffix . length ( ) > 0 & & character . be upper case ( suffix . char at ( 0 ) ) ) { return new string [ ] { suffix } ; } return new string [ ] { suffix , string utils . capitalize ( suffix ) } ; }
public void clear ( ) { freq table . clear ( ) ; }
public double [ ] get point ( ) { return point ; }
public static double value source from query ( query query ) { return new query double value source ( query ) ; }
public boolean contains ( double x , double y ) { if ( component2 d . contains point ( x , y , min x , max x , min y , max y ) & & tree . contains ( x , y ) ) { return hole == null || hole . contains ( x , y ) == false ; } return false ; }
public list < polygon builder > polygon ( ) { return polygon ; }
public double double value ( ) { return value ; }
protect boolean eq ( object x , object y ) { return x == y || x . equal ( y ) ; }
public static boolean equal ( object a , object b ) { return a == b || ( a ! = null & & a . equal ( b ) ) ; }
public double get max merge m b for force merge ( ) { return ( ( double ) max merge size for force merge ) /1024/1024 ; }
public string get resource description ( ) { return resource description ; }
public document doc ( int doc i d ) throw i o exception { return reader . document ( doc i d ) ; }
public static numeric doc value unwrap singleton ( sort numeric doc value dv ) { if ( dv instanceof singleton sort numeric doc value ) { return ( ( singleton sort numeric doc value ) dv ) . get numeric doc value ( ) ; } else { return null ; } }
public static sort doc value unwrap singleton ( sort set doc value dv ) { if ( dv instanceof singleton sort set doc value ) { return ( ( singleton sort set doc value ) dv ) . get sorted doc value ( ) ; } else { return null ; } }
public double [ ] get point ( ) { return point ; }
public void set index option ( index option value ) { check if frozen ( ) ; this . index option = value ; }
public string get resource description ( ) { return resource description ; }
public deletion time start deletion time ( ) { return start deletion ; }
public change collection < t change > get change ( ) { return this . change ; }
public boolean be enable ( ) { return this . enable ; } // -- boolean be enable ( )
public static boolean be version ( final int version ) { if ( version < 1 ) { throw new illegal argument exception ( `` java version range start with at least 1 . `` ) ; } final float v = major java version < 9 ? 1f + version * 0 . 1f : version ; return major java version > = v ; }
public synchronize int num doc ( ) { ensure open ( ) ; int count = doc writer . get num doc ( ) ; for ( final segment commit info info : segment info ) { count += info . info . get doc count ( ) - num delete doc ( info ) ; } return count ; }
public int get num sub ( ) { return num sub ; }
public synchronize void add pending ( cluster state state ) { pending state . add ( new cluster state context ( state ) ) ; if ( pending state . size ( ) > max queue size ) { cluster state context context = pending state . remove ( 0 ) ; logger . warn ( `` drop pending state [ { } ] . more than [ { } ] pending state . `` , context , max queue size ) ; if ( context . commit ( ) ) { context . listener . on new cluster state fail ( new elasticsearch exception ( `` too many pending state ( [ { } ] pending ) `` , max queue size ) ) ; } } }
public string get reader ( ) { return reader ; }
public int get max value ( int dimension ) { if ( dimension < 2 || dimension > 32 ) { throw new illegal argument exception ( `` `` + dimension ) ; } int bit per value = get bit per value ( dimension ) ; return ( int ) ( ( 1l < < bits per value ) - 1 ) ; }
public final boolean accept ( int doc i d , bit live doc ) { return ( filter doc == null || filter doc . get ( doc i d ) ) & & ( live doc == null || live doc . get ( doc i d ) ) ; }
public sort definition get sort ( ) { return this . sort ; }
public iterator iterator ( ) { return new iterator ( ) ; }
public explanation explain ( basic stats stats , float tfn ) { explanation result = new explanation ( ) ; result . set description ( get class ( ) . get simple name ( ) + `` , compute from : `` ) ; result . set value ( score ( stats , tfn ) ) ; result . add detail ( new explanation ( tfn , `` tfn `` ) ) ; result . add detail ( new explanation ( stats . get number of document ( ) , `` number of document `` ) ) ; result . add detail ( new explanation ( stats . get total term freq ( ) , `` total term freq `` ) ) ; return result ; }
public field get field ( ) { return field ; }
public final query get query ( ) { return query ; }
public void set match default ( boolean match default ) { this . match default = match default ; }
public float get boost ( ) { return boost ; }
public long ram byte use ( ) { return ram usage estimator . align object size ( integer . bytes * 3 + ram usage estimator . num_bytes_object_ref ) + ram usage estimator . size of ( key ) ; }
public string get field ( ) { return field ; }
public long if primary term ( ) { return if primary term ; }
public void set doc freq ( long doc freq ) { this . doc freq = doc freq ; }
protect void set top ( l top ) { this . top = top ; }
public static int append char ( automaton a , int state , int c ) { int new state = a . create state ( ) ; a . add transition ( state , new state , c , c ) ; return new state ; }
public int init transition ( int state , transition t ) { assert state < next state/2 : `` state= `` + state + `` next state= `` + next state ; t . source = state ; t . transition upto = state [ 2 * state ] ; return get num transition ( state ) ; }
public transition [ ] [ ] get sort transition ( ) { final state [ ] state = get numbered state ( ) ; transition [ ] [ ] transition = new transition [ state . length ] [ ] ; for ( state s : state ) { s . sort transition ( transition . compare by min max then d ) ; s . trim transition array ( ) ; transition [ s . number ] = s . transition array ; assert s . transition array ! = null ; } return transition ; }
public static int append char ( automaton a , int state , int c ) { int new state = a . create state ( ) ; a . add transition ( state , new state , c , c ) ; return new state ; }
public transition [ ] [ ] get sort transition ( ) { final state [ ] state = get numbered state ( ) ; transition [ ] [ ] transition = new transition [ state . length ] [ ] ; for ( state s : state ) { s . sort transition ( transition . compare by min max then d ) ; s . trim transition array ( ) ; transition [ s . number ] = s . transition array ; assert s . transition array ! = null ; } return transition ; }
public int compute cardinality ( ) { return operand . get cardinality ( ) ; }
public void or ( doc id set iterator iter ) throw i o exception { check unpositioned ( iter ) ; for ( int doc = iter . next doc ( ) ; doc ! = doc id set iterator . no_more_docs ; doc = iter . next doc ( ) ) { set ( doc ) ; } }
public list < doc > get doc ( ) { if ( doc == null ) { doc = new array list < doc > ( ) ; } return this . doc ; }
public void set text ( string text ) { this . text = text ; }
public file get directory ( ) { return f directory ; }
public void set enable ( string enable ) { this . enable = enable ; } // -- void set enable ( string )
public static long size of ( short [ ] arr ) { return align object size ( ( long ) num_bytes_array_header + ( long ) num_bytes_short * arr . length ) ; }
protect void on query cache ( query query , long ram byte use ) { assert lock . be hold by current thread ( ) ; this . ram byte use += ram byte use ; }
public expression get sort key ( ) { return sort key ; }
public int degree ( ) { return coefficient . length - 1 ; }
public sort definition get sort ( ) { return this . sort ; }
public group search set group doc limit ( int group docs limit ) { this . group docs limit = group docs limit ; return this ; }
public group search set group doc offset ( int group docs offset ) { this . group docs offset = group doc offset ; return this ; }
public zero term query option zero term query ( ) { return this . zero term query ; }
public analyze response analyze ( analyze request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , indices request converter : : analyze , option , analyze response : : from x content , empty set ( ) ) ; }
public int get offset ( ) { return offset ; }
public static match phrase query builder match phrase query ( string name , object text ) { return new match phrase query builder ( name , text ) ; }
public final boolean accept ( int doc i d , bit live doc ) { return ( filter doc == null || filter doc . get ( doc i d ) ) & & ( live doc == null || live doc . get ( doc i d ) ) ; }
protect boolean ignore overlap ( ) { return false ; }
protect byte encode norm value ( float boost , float length ) { return small float . float to byte315 ( ( boost / ( float ) math . sqrt ( length ) ) ) ; }
public string get field ( ) { return field ; }
protect fuzzy boolean match internal ( shadow shadow ) { return fuzzy boolean . no ; }
public final query get query ( ) { return query ; }
public final query get query ( ) { return query ; }
public string get query ( ) { return query ; }
public void set child ( hash set < string > child ) { this . child = child ; }
public syntax parser get syntax parser ( ) { return this . syntax parser ; }
public search source builder query ( query builder query ) { this . query builder = query ; return this ; }
public void set syntax parser ( syntax parser syntax parser ) { if ( syntax parser == null ) { throw new illegal argument exception ( `` text parser should not be null ! `` ) ; } this . syntax parser = syntax parser ; }
public int next int ( int lower , int upper ) { if ( low > = upper ) { throw math runtime exception . create illegal argument exception ( `` upper bound ( { 0 } ) must be great than low bound ( { 1 } ) `` , upper , low ) ; } double r = get ran ( ) . next double ( ) ; return ( int ) ( ( r * upper ) + ( ( 1 . 0 - r ) * low ) + r ) ; }
public void set operator ( infix expression . operator operator ) { if ( operator == null ) { throw new illegal argument exception ( ) ; } pre value change ( operator_property ) ; this . operator = operator ; post value change ( operator_property ) ; }
protect query new prefix query ( term prefix ) { prefix query query = new prefix query ( prefix ) ; query . set rewrite method ( multi term rewrite method ) ; return query ; }
public int weight order ( ) { int ret = delegate . weight order ( ) ; return ret ; }
public static final string string encode ( final double lon , final double lat ) { return string encode ( lon , lat , 12 ) ; }
public boolean get optimize ( ) { return optimize ; }
public int get num sub ( ) { return num sub ; }
public int get arity ( ) { return arity ; }
public double get dist err pct ( ) { return dist err pct ; }
public double resolve dist err ( spatial context ctx , double default dist err pct ) { if ( dist err ! = null ) return dist err ; double dist err pct = ( this . dist err pct ! = null ? this . dist err pct : default dist err pct ) ; return calc distance from err pct ( shape , dist err pct , ctx ) ; }
public double resolve dist err ( spatial context ctx , double default dist err pct ) { if ( dist err ! = null ) return dist err ; double dist err pct = ( this . dist err pct ! = null ? this . dist err pct : default dist err pct ) ; return calc distance from err pct ( shape , dist err pct , ctx ) ; }
public static geoshape point ( final double latitude , final double longitude ) { precondition . check argument ( be valid coordinate ( latitude , longitude ) , `` invalid coordinate provide `` ) ; return new geoshape ( get shape factory ( ) . point x y ( longitude , latitude ) ) ; }
public list < vector3 d > get convex cell inside point ( ) { return convex cell inside point ; }
public double [ ] get point ( ) { return point ; }
public geo distance query builder geo distance ( geo distance geo distance ) { if ( geo distance == null ) { throw new illegal argument exception ( `` geo distance must not be null `` ) ; } this . geo distance = geo distance ; return this ; }
public double dot product ( final vector v ) { return this . x * v . x + this . y * v . y + this . z * v . z ; }
public static geo polygon make geo polygon ( final planet model planet model , final polygon description description ) { return make geo polygon ( planet model , description , 0 . 0 ) ; }
public static geo polygon make geo convex polygon ( final planet model planet model , final list < geo point > point list ) { return new geo convex polygon ( planet model , point list ) ; }
public double normal distance ( final vector v ) { return math . sqrt ( normal distance square ( v ) ) ; }
public long get z ( ) { return z ; }
public double dot product ( final vector v ) { return this . x * v . x + this . y * v . y + this . z * v . z ; }
public boolean point outside ( final vector v ) { return point outside ( v . x , v . y , v . z ) ; }
public void set italic angle ( float angle ) { dic . set float ( c o s name . italic_angle , angle ) ; }
public double normal distance ( final vector v , final membership . . . bound ) { return normal distance ( v . x , v . y , v . z , bound ) ; }
public double dot product ( final vector v ) { return this . x * v . x + this . y * v . y + this . z * v . z ; }
public static x y z solid make x y z solid ( final planet model planet model , final double min x , final double max x , final double min y , final double max y , final double min z , final double max z ) { if ( math . ab ( max x - min x ) < vector . minimum_resolution ) { if ( math . ab ( max y - min y ) < vector . minimum_resolution ) { if ( math . ab ( max z - min z ) < vector . minimum_resolution ) { return new d xd yd z solid ( planet model , ( min x+max x ) * 0 . 5 , ( min y+max y ) * 0 . 5 , min z ) ; } else { return new d xd y z solid ( planet model , ( min x+max x ) * 0 . 5 , ( min y+max y ) * 0 . 5 , min z , max z ) ; } } else { if ( math . ab ( max z - min z ) < vector . minimum_resolution ) { return new d x yd z solid ( planet model , ( min x+max x ) * 0 . 5 , min y , max y , ( min z+max z ) * 0 . 5 ) ; } else { return new d x y z solid ( planet model , ( min x+max x ) * 0 . 5 , min y , max y , min z , max z ) ; } } } if ( math . ab ( max y - min y ) < vector . minimum_resolution ) { if ( math . ab ( max z - min z ) < vector . minimum_resolution ) { return new xd yd z solid ( planet model , min x , max x , ( min y+max y ) * 0 . 5 , ( min z+max z ) * 0 . 5 ) ; } else { return new xd y z solid ( planet model , min x , max x , ( min y+max y ) * 0 . 5 , min z , max z ) ; } } if ( math . ab ( max z - min z ) < vector . minimum_resolution ) { return new x yd z solid ( planet model , min x , max x , min y , max y , ( min z+max z ) * 0 . 5 ) ; } return new standard x y z solid ( planet model , min x , max x , min y , max y , min z , max z ) ; }
public boolean be large max z ( final planet model planet model ) { if ( max z == null ) return false ; return planet model . get maximum z value ( ) - max z < vector . minimum_resolution ; }
protect boolean be root o k ( double min , double max , complex z ) { double tolerance = math . max ( relative accuracy * z . ab ( ) , absolute accuracy ) ; return ( be sequence ( min , z . get real ( ) , max ) ) & & ( math . ab ( z . get imaginary ( ) ) < = tolerance || z . ab ( ) < = function value accuracy ) ; }
public comparator get comparator ( ) { return comparator ; }
public simple expression ignore case ( ) { ignore case = true ; return this ; }
public list < doc > get doc ( ) { if ( doc == null ) { doc = new array list < doc > ( ) ; } return this . doc ; }
public void delete bucket ( storage bucket bucket ) throw service exception { assert valid bucket ( bucket , `` delete bucket `` ) ; delete bucket impl ( bucket . get name ( ) ) ; }
public path [ ] index path ( index index ) { assert env be lock ( ) ; path [ ] index path = new path [ node path . length ] ; for ( int i = 0 ; i < node path . length ; i++ ) { index path [ i ] = node path [ i ] . resolve ( index ) ; } return index path ; }
public run average and std dev get normalize stats ( ) { run average and std dev summer = new full running average and std dev ( ) ; for ( int d = 0 ; d < confusion matrix . length ; d++ ) { double total = 0 ; for ( int j = 0 ; j < confusion matrix . length ; j++ ) { total += confusion matrix [ d ] [ j ] ; } summer . add datum ( confusion matrix [ d ] [ d ] / ( total + 0 . 000001 ) ) ; } return summer ; }
public double get kappa ( ) { double a = 0 . 0 ; double b = 0 . 0 ; for ( int i = 0 ; i < confusion matrix . length ; i++ ) { a += confusion matrix [ i ] [ i ] ; double br = 0 ; for ( int j = 0 ; j < confusion matrix . length ; j++ ) { br += confusion matrix [ i ] [ j ] ; } double bc = 0 ; for ( int [ ] vec : confusion matrix ) { bc += vec [ i ] ; } b += br * bc ; } return ( sample * a - b ) / ( sample * sample - b ) ; }
public double double value ( ) { return value ; }
public static object sum ( iterable item ) { return default groovy method . sum ( item ) ; }
public node item ( int index ) { return ( node ! = null & & index < node . size ( ) ) ? ( node ) ( node . element at ( index ) ) : null ; }
public final string get string value ( ) { return get string value ( tree , node nr ) . to string ( ) ; }
public void set method ( int method ) { this . method = method ; }
public object get layer ( ) { return layer ; }
public void set weight matrix ( matrix [ ] matrix ) { this . weight matrix list = list . new array list ( ) ; collection . add all ( this . weight matrix list , matrix ) ; }
public void update weight matrix ( matrix [ ] matrix ) { for ( int i = 0 ; i < matrix . length ; ++i ) { matrix matrix = this . weight matrix list . get ( i ) ; this . weight matrix list . set ( i , matrix . plus ( matrix [ i ] ) ) ; } }
public void update weight matrix ( matrix [ ] matrix ) { for ( int i = 0 ; i < matrix . length ; ++i ) { matrix matrix = this . weight matrix list . get ( i ) ; this . weight matrix list . set ( i , matrix . plus ( matrix [ i ] ) ) ; } }
public output < float > min activation ( ) { return min activation ; }
public vector aggregate row ( vector function f ) { vector r = new dense vector ( num row ( ) ) ; int n = num row ( ) ; for ( int row = 0 ; row < n ; row++ ) { r . set ( row , f . apply ( view row ( row ) ) ) ; } return r ; }
public document get document ( ) { return document ; }
public void add to vector ( byte [ ] original form , double w , vector data ) { throw new unsupported operation exception ( `` add to vector be not support for interaction vector encoder `` ) ; }
public static default option builder threshold option ( ) { return new default option builder ( ) . with long name ( threshold_option ) . with required ( false ) . with short name ( `` t `` ) . with argument ( new argument builder ( ) . with name ( threshold_option ) . with default ( `` 0 `` ) . with minimum ( 1 ) . with maximum ( 1 ) . create ( ) ) . with description ( `` the pdf threshold use for cluster determination . default be 0 `` ) ; }
public static default option builder outlier threshold option ( ) { return new default option builder ( ) . with long name ( outlier_threshold ) . with required ( false ) . with argument ( new argument builder ( ) . with name ( outlier_threshold ) . with minimum ( 1 ) . with maximum ( 1 ) . create ( ) ) . with description ( `` outlier threshold value `` ) . with short name ( outlier_threshold ) ; }
public static default option builder threshold option ( ) { return new default option builder ( ) . with long name ( threshold_option ) . with required ( false ) . with short name ( `` t `` ) . with argument ( new argument builder ( ) . with name ( threshold_option ) . with default ( `` 0 `` ) . with minimum ( 1 ) . with maximum ( 1 ) . create ( ) ) . with description ( `` the pdf threshold use for cluster determination . default be 0 `` ) ; }
public synchronize void set params ( http params params ) { default params = params ; }
public list < string > list x attrs ( path path ) throw i o exception { throw new unsupported operation exception ( get class ( ) . get simple name ( ) + `` do n't support list x attrs `` ) ; }
public final void compute static property ( ) { static property = compute dependency ( ) | compute cardinality ( ) | compute special property ( ) ; }
protect void set min split size node ( long min split size node ) { this . min split size node = min split size node ; }
public void set feature ( feature map feature ) { this . feature = feature ; }
public void set v vector ( float [ ] v vector value ) { v vector = v vector value ; }
public final long row count ( ) { return row ; }
public void set view ( view view ) { this . view = view ; }
public r pattern get r context ( ) { return this . r context ; }
public array node array node ( int capacity ) { return new array node ( this , capacity ) ; }
public final column definition column ( ) { return column ; }
public static int compare ( double a , double b ) { if ( a < b ) return -1 ; if ( a > b ) return 1 ; if ( double . be na n ( a ) ) { if ( double . be na n ( b ) ) return 0 ; return -1 ; } if ( double . be na n ( b ) ) return 1 ; return 0 ; }
public static int compare ( double a , double b ) { if ( a < b ) return -1 ; if ( a > b ) return 1 ; if ( double . be na n ( a ) ) { if ( double . be na n ( b ) ) return 0 ; return -1 ; } if ( double . be na n ( b ) ) return 1 ; return 0 ; }
public static double lat height in degree ( int precision ) { return precision to lat height [ precision ] ; }
public boolean be like right plus ( ) { return false ; }
public boolean be like right plus ( ) { return true ; }
public void set state ( double min , double max ) { if ( max < min ) { set state ( max , min ) ; return ; } this . min = min ; this . max = max ; }
public double cdf ( double x ) { if ( x < = min ) { return 0 . 0 ; } if ( x > = max ) { return 1 . 0 ; } return ( x - min ) / ( max - min ) ; }
public static double incomplete gamma complement ( double alpha , double x ) { if ( x < = 0 || alpha < = 0 ) { return 1 . 0 ; } if ( x < 1 . 0 || x < alpha ) { return 1 . 0 - incomplete gamma ( alpha , x ) ; } double ax = alpha * math . log ( x ) - x - log gamma ( alpha ) ; if ( ax < - constant . maxlog ) { return 0 . 0 ; } ax = math . exp ( ax ) ; / * continue fraction * / double y = 1 . 0 - alpha ; double z = x + y + 1 . 0 ; double c = 0 . 0 ; double pkm2 = 1 . 0 ; double qkm2 = x ; double pkm1 = x + 1 . 0 ; double qkm1 = z * x ; double an = pkm1 / qkm1 ; double t ; do { c += 1 . 0 ; y += 1 . 0 ; z += 2 . 0 ; double yc = y * c ; double pk = pkm1 * z - pkm2 * yc ; double qk = qkm1 * z - qkm2 * yc ; if ( qk ! = 0 ) { double r = pk / qk ; t = math . ab ( ( ans - r ) / r ) ; ans = r ; } else { t = 1 . 0 ; } pkm2 = pkm1 ; pkm1 = pk ; qkm2 = qkm1 ; qkm1 = qk ; if ( math . ab ( pk ) > constant . big ) { pkm2 * = constant . big_inverse ; pkm1 * = constant . big_inverse ; qkm2 * = constant . big_inverse ; qkm1 * = constant . big_inverse ; } } while ( t > constant . machep ) ; return ans * ax ; }
public static double incomplete gamma ( double alpha , double x ) { if ( x < = 0 || alpha < = 0 ) { return 0 . 0 ; } if ( x > 1 . 0 & & x > alpha ) { return 1 . 0 - incomplete gamma complement ( alpha , x ) ; } / * compute x * * a * exp ( -x ) / gamma ( a ) * / double ax = alpha * math . log ( x ) - x - log gamma ( alpha ) ; if ( ax < - constant . maxlog ) { return 0 . 0 ; } ax = math . exp ( ax ) ; / * power series * / double r = alpha ; double c = 1 . 0 ; double an = 1 . 0 ; do { r += 1 . 0 ; c * = x / r ; an += c ; } while ( c / an > constant . machep ) ; return ans * ax / alpha ; }
public static double indicator ( final double x ) { if ( double . be na n ( x ) ) { return double . na n ; } return ( x > = 0 . 0 ) ? 1 . 0 : -1 . 0 ; }
public boolean equal ( object other ) { return this==other ; }
public void before insert all of ( int index , collection < t > collection ) { this . before insert dummy ( index , collection . size ( ) ) ; this . replace from with ( index , collection ) ; }
public static int get indent use ( i java element elem ) throw java model exception { i openable openable= elem . get openable ( ) ; if ( openable instanceof i type root ) { i buffer buf= openable . get buffer ( ) ; if ( buf ! = null ) { int offset= ( ( i source reference ) elem ) . get source range ( ) . get offset ( ) ; return get indent use ( buf , offset , elem . get java project ( ) ) ; } } return 0 ; }
protect static void check range from to ( int from , int to , int the size ) { if ( to == from - 1 ) { return ; } if ( from < 0 || from > to || to > = the size ) { throw new index out of bound exception ( `` from : `` + from + `` , to : `` + to + `` , size= `` + the size ) ; } }
public abstract byte list part from to ( int from , int to ) { check range from to ( from , to , size ) ; int length = to - from + 1 ; byte array list part = new byte array list ( length ) ; part . add all of from to ( this , from , to ) ; return part ; }
public void before insert ( int index , byte element ) { before insert dummy ( index , 1 ) ; set ( index , element ) ; }
public void set element ( string element ) { assert . have text ( element , `` 'element ' can not be null or blank `` ) ; this . element = element ; }
public static int size ( object list ) { if ( list == null ) return 0 ; if ( list instanceof list ) return ( ( list < ? > ) list ) . size ( ) ; return 1 ; }
public byte put or add ( char key , byte put value , byte increment value ) { assert assign < mask + 1 ; if ( contains key ( key ) ) { put value = get ( key ) ; put value = ( byte ) ( ( ( put value ) + ( increment value ) ) ) ; } put ( key , put value ) ; return put value ; }
public composable function fix2nd argument ( final double fix y ) { return new composable function ( ) { @ override / * * { @ inherit doc } * / public double value ( double x ) throw function evaluation exception { return binary function . this . value ( x , fixed y ) ; } } ; }
public constant constant ( scope scope ) { return constant ( ) ; }
public iterator iterator ( ) { return new iterator ( ) ; }
public void set state ( double min , double max ) { if ( max < min ) { set state ( max , min ) ; return ; } this . min = min ; this . max = max ; }
public static boolean be power of two ( int v ) { return ( ( v & ( v-1 ) ) == 0 ) ; }
public float [ ] get v vector ( ) { return this . v vector ; }
public static void quick sort ( final boolean [ ] x , final boolean comparator comp ) { quick sort ( x , 0 , x . length , comp ) ; }
protect void set cost ( double cost ) { this . cost = cost ; }
public model map get model ( ) { if ( use default model ( ) ) { return this . default model ; } else { if ( this . redirect model == null ) { this . redirect model = new model map ( ) ; } return this . redirect model ; } }
public void set header name ( string header name ) { assert . have length ( header name , `` header name ca n't be null `` ) ; this . header name = header name ; }
public string get user ( ) { return user ; }
public quota [ ] get quota ( ) throw message exception { return ( quota [ ] ) do optional command ( `` quota not support `` , new protocol command ( ) { @ override public object do command ( i m a p protocol p ) throw protocol exception { return p . get quota root ( full name ) ; } } ) ; }
public boolean be r e v1 ( ) { return rev1 ; }
public final int hash code ( ) { return super . hash code ( ) ; }
public final query get query ( ) { return query ; }
public string get family ( ) { return this . family ; } // -- string get family ( )
public void set name ( string name ) { this . name = name ; } // -- void set name ( string )
public void set filter ( boolean filter ) { this . filter = filter ; }
public void add ( resource r ) { if ( resource ! = null ) { throw new build exception ( `` only one resource can be test `` ) ; } resource = r ; }
public void set url ( string url ) { this . url = url ; } // -- void set url ( string )
public void set email ( @ nullable string email ) { this . email = email ; }
public void set type ( string type ) { this . type = type ; }
public relocation get relocation ( ) { return this . relocation ; } // -- relocation get relocation ( )
public deployment repository get snapshot repository ( ) { return this . snapshot repository ; } // -- deployment repository get snapshot repository ( )
public void set url ( string url ) { this . url = url ; } // -- void set url ( string )
public string get group id ( ) { return this . group id ; } // -- string get group id ( )
public string get version ( ) { return this . version ; } // -- string get version ( )
public java . lang . string get organization ( ) { java . lang . object ref = organization_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; organization_ = s ; return s ; } }
public string get string ( ) { return string ; }
public string get url ( ) { return this . url ; } // -- string get url ( )
public void set group id ( string group id ) { this . group id = group id ; } // -- void set group id ( string )
public license client license ( ) { return license client ; }
public void set distribution ( string distribution ) { this . distribution = distribution ; } // -- void set distribution ( string )
public void set default goal ( string default goal ) { this . default goal = default goal ; } // -- void set default goal ( string )
public object get configuration ( ) { return this . configuration ; } // -- object get configuration ( )
public object get report ( ) { return this . report ; } // -- object get report ( )
public boolean get enable ( ) { return this . enable ; }
public type target ( ) { return target ; }
public void set filter ( boolean filter ) { this . filter = filter ; }
public string get url ( ) { return this . url ; } // -- string get url ( )
public void set property ( string property ) { this . property = property ; }
public void set exception if header miss ( boolean exception if header miss ) { this . exception if header miss = exception if header miss ; }
public string get family ( ) { return this . family ; } // -- string get family ( )
public void set plugin repository ( java . util . list < repository > plugin repository ) { this . plugin repository = plugin repository ; } // -- void set plugin repository ( java . util . list )
public void set repository ( repository r ) { if ( repository == null ) repository = r ; }
public string get url ( ) { return this . url ; } // -- string get url ( )
public void set layout ( string layout ) { this . layout = layout ; } // -- void set layout ( string )
public void set group id ( string group id ) { this . group id = group id ; } // -- void set group id ( string )
public string get name ( ) { return this . name ; } // -- string get name ( )
public string get name ( ) { return this . name ; } // -- string get name ( )
public string get mirror of ( ) { return this . mirror of ; } // -- string get mirror of ( )
public string get protocol ( ) { return protocol ; }
public void set username ( string value ) { this . username = value ; }
public object get configuration ( ) { return this . configuration ; } // -- object get configuration ( )
public string get password ( ) { return password ; }
public string get directory permission ( ) { return this . directory permission ; } // -- string get directory permission ( )
public clock and count get local clock and count ( byte buffer context ) { return get clock and count of ( context , counter id . get local id ( ) ) ; }
public boolean be fix rate ( ) { return this . fixed rate ; }
public void add listener ( listener listener ) { listener . add ( listener ) ; }
public void set name ( list < string > names ) { this . name = name ; }
public double [ ] get percentile ( ) { return percentile ; }
public t percentile config ( percentile config percentile config ) { this . percentile config = percentile config ; return ( t ) this ; }
public boolean be close ( ) { return close ; }
public integer get max length ( ) { return max length ; }
public duration to duration ( ) { return this ; }
public date time to date time ( ) { return new date time ( get millis ( ) , get zone ( ) ) ; }
public void set watch ( long relative zxid , list < string > data watch , list < string > exist watch , list < string > child watch , watcher watcher ) { data tree . set watch ( relative zxid , data watch , exist watch , child watch , watcher ) ; }
public long interval ( ) { return date histogram interval . interval ( ) ; }
public boolean be optional ( ) { return this . optional ; }
public static annotation [ ] get resource annotation ( method method ) { map < class < ? > , annotation > annotation = new hash map < class < ? > , annotation > ( ) ; for ( annotation annotation : method . get declare class ( ) . get annotation ( ) ) { annotation . put ( annotation . get class ( ) , annotation ) ; } for ( annotation annotation : method . get annotation ( ) ) { annotation . put ( annotation . get class ( ) , annotation ) ; } return annotation . value ( ) . to array ( new annotation [ annotation . size ( ) ] ) ; }
public annotation value builder < t > value ( boolean bool ) { return member ( annotation metadata . value_member , bool ) ; }
public annotation value builder < t > value ( @ nullable string . . . string ) { return member ( annotation metadata . value_member , string ) ; }
public void set value ( @ nullable string value ) { this . value = value ; }
public static void register all for runtime reflection ( before analysis access access , string class name ) { find class ( access , class name ) . if present ( automatic feature utils : : register all for runtime reflection ) ; }
public static void register class for runtime reflective instantiation ( before analysis access access , string class name ) { find class ( access , class name ) . if present ( automatic feature utils : : register for reflective instantiation ) ; }
public void set resource loader ( resource loader resource loader ) { this . resource loader = resource loader ; }
public sort definition get sort ( ) { return this . sort ; }
public string get path ( ) { return path ; }
public void set check ( string value ) { this . check = value ; }
public static boolean equal ( object a , object b ) { return a == b || ( a ! = null & & a . equal ( b ) ) ; }
public string get delimiter ( ) { return this . delimiter ; }
public static object wrap ( object o ) { if ( o == null ) { return null ; } if ( o instanceof j s o n array || o instanceof j s o n object ) { return o ; } if ( o . equal ( null ) ) { return o ; } try { if ( o instanceof collection ) { return new j s o n array ( ( collection ) o ) ; } else if ( o . get class ( ) . be array ( ) ) { return new j s o n array ( o ) ; } if ( o instanceof map ) { return new j s o n object ( ( map ) o ) ; } if ( o instanceof boolean || o instanceof byte || o instanceof character || o instanceof double || o instanceof float || o instanceof integer || o instanceof long || o instanceof short || o instanceof string ) { return o ; } if ( o . get class ( ) . get package ( ) . get name ( ) . start with ( `` java . `` ) ) { return o . to string ( ) ; } } catch ( exception ignore ) { } return null ; }
public boolean contain all ( collection < ? > collection ) { for ( iterator i = collection . iterator ( ) ; i . have next ( ) ; ) { if ( ! contains ( i . next ( ) ) ) { return false ; } } return true ; }
public object get additional property ( ) { return additional property ; }
public http request with cooky ( cookie . . . cooky ) { this . cooky . with entry ( cooky ) ; return this ; }
public address get address ( ) { return address ; }
public static collection < thread group > find thread group by name ( final string thread group name ) { return find thread group ( new name predicate ( thread group name ) ) ; }
public http status get status ( ) { return this . status ; }
public object from publisher ( publisher < ? > publisher ) { return this . from publisher function . apply ( publisher ) ; }
public set < string > allow request header ( ) { return collection . unmodifiable set ( allow request header ) ; }
public static pattern check cors set for regex ( string cors set ) { if ( cors set == null ) { return null ; } int len = cors set . length ( ) ; boolean be regex = len > 2 & & cors set . start with ( `` / `` ) & & cors set . end with ( `` / `` ) ; if ( be regex ) { return pattern . compile ( cors set . substring ( 1 , cors set . length ( ) -1 ) ) ; } return null ; }
public static string get attachment impl class name ( ) { return m attachment impl class name ; }
public void set logger ( log logger ) { this . logger = logger ; }
public cooky get cooky ( ) { return cooky ; }
protect full http response new handshake response ( full http request req , http header header ) { char sequence key = req . header ( ) . get ( http header name . sec_websocket_key ) ; if ( key == null ) { throw new web socket server handshake exception ( `` not a web socket request : missing key `` , req ) ; } full http response res = new default full http response ( http_1_1 , http response status . switching_protocols , req . content ( ) . alloc ( ) . buffer ( 0 ) ) ; if ( header ! = null ) { re . header ( ) . add ( header ) ; } string accept seed = key + websocket_08_accept_guid ; byte [ ] sha1 = web socket util . sha1 ( accept seed . get byte ( charset util . us_ascii ) ) ; string accept = web socket util . base64 ( sha1 ) ; if ( logger . be debug enable ( ) ) { logger . debug ( `` web socket version 08 server handshake key : { } , response : { } `` , key , accept ) ; } res . header ( ) . set ( http header name . upgrade , http header value . websocket ) . set ( http header name . connection , http header value . upgrade ) . set ( http header name . sec_websocket_accept , accept ) ; string subprotocols = req . header ( ) . get ( http header name . sec_websocket_protocol ) ; if ( subprotocols ! = null ) { string select subprotocol = select subprotocol ( subprotocols ) ; if ( select subprotocol == null ) { if ( logger . be debug enable ( ) ) { logger . debug ( `` request subprotocol ( s ) not support : { } `` , subprotocols ) ; } } else { re . header ( ) . set ( http header name . sec_websocket_protocol , select subprotocol ) ; } } return re ; }
public < t > optional < t > find bean ( class < t > bean type , qualifier < t > qualifier ) { return find bean ( null , bean type , qualifier ) ; }
protect < t > stream < t > stream of type ( bean resolution context resolution context , class < t > bean type , qualifier < t > qualifier ) { return get bean registration ( resolution context , bean type , qualifier ) . stream ( ) . map ( bean registration : : get bean ) ; }
public static provider get provider ( ) { return c provider ; }
public string get message ( ) { return message ; }
public void set annotation name ( string annotation name ) { this . annotation name = annotation name ; } // set annotation name
public void set default value ( object default value ) { this . default value = default value ; }
public void set name ( string name ) { this . name = name ; }
protect boolean be valid ip address ( string ip address ) { matcher ip address matcher = ip_domain_pattern . matcher ( ip address ) ; for ( int i = 1 ; i < = 4 ; i++ ) { string ip segment = ip address matcher . group ( i ) ; if ( ip segment == null || ip segment . length ( ) < = 0 ) { return false ; } int i ip segment = 0 ; try { i ip segment = integer . parse int ( ip segment ) ; } catch ( number format exception e ) { return false ; } if ( i ip segment > 255 ) { return false ; } } return true ; }
public type get type ( ) { return type ; }
public void set always serialize error a list ( boolean always serialize error a list ) { this . always serialize error a list = always serialize error a list ; }
public void set trim string ( boolean trim string ) { this . trim string = trim string ; }
public boolean be always serialize error a list ( ) { return always serialize error a list ; }
public boolean be trim string ( ) { return trim string ; }
public long get delay ( ) { return delay millis ; }
public void refresh ( ) { }
public boolean be optional ( ) { return this . optional ; }
public json del at ( int index ) { throw new unsupported operation exception ( ) ; }
public json at del ( int index ) { throw new unsupported operation exception ( ) ; }
public void add callback ( runnable callback ) { if ( callback ! = null ) delegate . add callback ( callback ) ; }
public static < t > answer < t > delegate to ( object delegate ) { return ( answer < t > ) new forward invocation ( delegate ) ; }
public static instance field declare field of ( object instance ) { list < instance field > instance field = new array list < instance field > ( ) ; instance field . add all ( instance field in ( instance , instance . get class ( ) . get declared field ( ) ) ) ; return new instance field ( instance , instance field ) ; }
public list < stub > get stubbings descend ( ) { return ( list ) stub ; }
public t get maximum ( ) { return maximum ; }
public static input stream get resource a stream ( string resource , class < ? > . . . class ) { return get resource a stream ( resource , false , class ) ; }
public string get reader ( ) { return reader ; }
public integer get fetch size ( ) { return fetch size ; }
public void set statement ( ast node statement ) { assert not null ( statement ) ; this . statement = statement ; statement . set parent ( this ) ; }
public void set configuration ( configuration configuration ) { this . configuration = configuration ; }
public t get item ( ) { return item ; }
public string get session id ( ) { return get ( `` session . id `` , `` `` ) ; }
public boolean be default lazy ( ) { if ( default lazy == null ) { return true ; } else { return default lazy ; } }
public pool object factory < t > get factory ( ) { return factory ; }
public list < string > get extend plugins ( ) { return extend plugins ; }
public void set package ( boolean package ) { this . package = package ; } // -- void set package ( boolean )
public void set output threshold ( long threshold ) { this . threshold = threshold ; }
public void set verify ( boolean verify ) { this . verify = verify ; }
public string get version ( ) { return version == null ? `` `` : version ; }
public string scheme ( ) { return scheme ; }
public void set max file process per server ( int max file process per client ) { this . max file process per client = max file process per client ; }
public void write thin ( stream output out ) throw i o exception { super . write to ( out ) ; out . write v int ( byte . length ( ) ) ; }
public ast append ( ast child ) { if ( last == null ) { parent . set first child ( child ) ; } else { last . set next sibling ( child ) ; } last = child ; return last ; }
public void set child ( hash set < string > child ) { this . child = child ; }
public string to filter string ( string attribute name ) { if ( attribute name . length ( ) == 0 ) { throw new illegal argument exception ( `` invalid attribute name \ `` `` + attribute name + `` \ `` `` ) ; } for ( char ch : attribute name . to char array ( ) ) { if ( ( ch == '= ' ) || ( ch == ' > ' ) || ( ch == ' < ' ) || ( ch == '~ ' ) || ( ch == ' ( ' ) || ( ch == ' ) ' ) ) { throw new illegal argument exception ( `` invalid attribute name \ `` `` + attribute name + `` \ `` `` ) ; } } string builder result = new string builder ( 128 ) ; final boolean need presence = ! leave close & & ( ( right == null ) || ! right close ) ; final boolean multiple term = need presence || ( right ! = null ) ; if ( multiple term ) { result . append ( `` ( & `` ) ; } if ( need presence ) { result . append ( ' ( ' ) ; result . append ( attribute name ) ; result . append ( `` = * ) `` ) ; } if ( left close ) { result . append ( ' ( ' ) ; result . append ( attribute name ) ; result . append ( `` > = `` ) ; result . append ( leave . to string0 ( ) ) ; result . append ( ' ) ' ) ; } else { result . append ( `` ( ! ( `` ) ; result . append ( attribute name ) ; result . append ( `` < = `` ) ; result . append ( leave . to string0 ( ) ) ; result . append ( `` ) ) `` ) ; } if ( right ! = null ) { if ( right close ) { result . append ( ' ( ' ) ; result . append ( attribute name ) ; result . append ( `` < = `` ) ; result . append ( right . to string0 ( ) ) ; result . append ( ' ) ' ) ; } else { result . append ( `` ( ! ( `` ) ; result . append ( attribute name ) ; result . append ( `` > = `` ) ; result . append ( right . to string0 ( ) ) ; result . append ( `` ) ) `` ) ; } } if ( multiple term ) { result . append ( ' ) ' ) ; } return result . to string ( ) ; }
public void set manager ( manager manager ) { this . manager = manager ; }
public static class type pair of ( class < ? > raw class ) { return new class type pair ( raw class , raw class ) ; }
public tag get tag ( ) { return this . tag ; }
public result get result ( ) { return result ; }
public static void register all interval view ( ) { register all interval view ( stats . get view manager ( ) ) ; }
public static void register all cumulative view ( ) { register all cumulative view ( stats . get view manager ( ) ) ; }
public static < t > t coalesce ( t . . . value ) { if ( value == null ) { return null ; } for ( t value : value ) { if ( value ! = null ) { if ( value instanceof string ) { if ( string helper . be not empty ( ( string ) value ) ) { return value ; } } else { return value ; } } } return null ; }
public path get work directory ( ) { return f . get work directory ( ) ; }
public static int size ( object list ) { if ( list == null ) return 0 ; if ( list instanceof list ) return ( ( list < ? > ) list ) . size ( ) ; return 1 ; }
public merge command include ( ref a commit ) { check callable ( ) ; commits . add ( a commit ) ; return this ; }
public cherry pick command include ( ref commit ) { check callable ( ) ; commits . add ( commit ) ; return this ; }
public string get remote ( ) { return remote ; }
public void close ( ) throw i o exception { try { super . close ( ) ; } finally { if ( close branch ) { branch . close ( ) ; } } }
protect void set code ( int code ) { this . code = code ; }
public boolean be force update ( ) { return force update ; }
public void set apply index ( boolean apply index ) { this . apply index = apply index ; }
public submodule status command add path ( string path ) { path . add ( path ) ; return this ; }
public static rev filter create ( rev filter a , rev filter b ) { if ( a == all || b == all ) return all ; return new binary ( a , b ) ; }
public cherry pick command include ( ref commit ) { check callable ( ) ; commits . add ( commit ) ; return this ; }
public clone command set remote ( string remote ) { if ( remote == null ) { remote = constant . default_remote_name ; } this . remote = remote ; return this ; }
public dfs pack compactor add ( dfs pack file pack ) { src pack . add ( pack ) ; return this ; }
public void set name ( string name ) { this . name = name ; }
public index [ ] index ( ) { return index ; }
public string get $ ref ( ) { return $ ref ; }
public string get mode ( ) { return mode ; }
public submodule status command add path ( string path ) { path . add ( path ) ; return this ; }
public submodule init command add path ( string path ) { path . add ( path ) ; return this ; }
public integer get fetch size ( ) { return fetch size ; }
public void add callback ( runnable callback ) { if ( callback ! = null ) delegate . add callback ( callback ) ; }
public boolean be force update ( ) { return this . be force update ; }
public boolean be force update ( ) { return force update ; }
public map get attribute ( ) { return new hash map ( attribute ) ; }
public void set result ( result result ) { if ( result==null ) { throw new illegal argument exception ( `` result must not be null `` ) ; } this . result = result ; }
public void set source region ( rectangle source region ) { this . source region = source region ; }
public void set author ( boolean b ) { author = b ; }
public final boolean be delimiter detection enable ( ) { return delimiter detection enable ; }
public void set algorithm ( string algorithm ) { this . algorithm = algorithm ; }
public detector get detector ( ) { return detector ; }
public object id get object id ( ) { return id ; }
protect void set name source end ( int end ) { this . name end= end ; }
public void write ( byte [ ] buffer ) { output buffer . write ( buffer , 0 , buffer . length ) ; }
public static builder builder ( ) { return new builder ( ) ; }
public int find entry ( byte [ ] p , int p len ) { return find entry ( 0 , p , p len ) ; }
public int find entry ( string path ) { final byte [ ] p = constant . encode ( path ) ; return find entry ( p , p . length ) ; }
public boolean have next ( ) { return next index ( ) > = 0 ; }
public int get max cache entry ( ) { return max cache entry ; }
public object id get new object id ( ) { return new object id ; }
public static byte [ ] copy byte from ( byte buffer bb ) { if ( bb == null ) { return null ; } if ( bb . have array ( ) ) { return array . copy of range ( bb . array ( ) , bb . array offset ( ) + bb . position ( ) , bb . array offset ( ) + bb . limit ( ) ) ; } byte [ ] dst = new byte [ bb . remain ( ) ] ; bb . a read only buffer ( ) . get ( dst ) ; return dst ; }
public static < e extend exception > void if cause by ( exception ex , class < e > cause by , consumer < e > action ) { throwable candidate = ex ; while ( candidate ! = null ) { if ( cause by . be instance ( candidate ) ) { action . accept ( ( e ) candidate ) ; return ; } candidate = candidate . get cause ( ) ; } }
public set < string > get conflicting ( ) { return conflict . key set ( ) ; }
public deploy request set repository ( remote repository repository ) { this . repository = repository ; return this ; }
public clone command set remote ( string remote ) { if ( remote == null ) { remote = constant . default_remote_name ; } this . remote = remote ; return this ; }
public method bind shallow original ( ) { return original ( ) ; }
public void set post receive hook ( post receive hook h ) { post receive = h ! = null ? h : post receive hook . null ; }
public object get ( ) { return value ; }
public final void commit ( ) throw i o exception { ensure open ( ) ; commit internal ( ) ; }
public void validate ( key store key store , certificate cert ) throw certificate exception { certificate [ ] cert chain = null ; if ( cert ! = null & & cert instanceof x509 certificate ) { ( ( x509 certificate ) cert ) . check validity ( ) ; string cert alias = null ; try { if ( key store == null ) { throw new invalid parameter exception ( `` keystore can not be null `` ) ; } cert alias = key store . get certificate alias ( ( x509 certificate ) cert ) ; if ( cert alias == null ) { cert alias = `` jetty `` + string . format ( `` % 016x `` , __alias count . increment and get ( ) ) ; key store . set certificate entry ( cert alias , cert ) ; } cert chain = key store . get certificate chain ( cert alias ) ; if ( cert chain == null || cert chain . length == 0 ) { throw new illegal state exception ( `` unable to retrieve certificate chain `` ) ; } } catch ( key store exception kse ) { log . debug ( `` unable to validate certificate `` , kse ) ; throw new certificate exception ( `` unable to validate certificate `` + ( cert alias == null ? `` `` : `` for alias [ `` + cert alias + `` ] `` ) + `` : `` + kse . get message ( ) , kse ) ; } validate ( cert chain ) ; } }
public uri get u r i ( ) { return u ; }
public long get max retry ( time unit unit ) { return unit . convert ( max retry , millisecond ) ; }
public long get min retry ( time unit unit ) { return unit . convert ( min retry , millisecond ) ; }
public synchronize state mark available ( ) { if ( map . be empty ( ) ) { state = state . idle ; } else { state = state . pending ; } return state ; }
public boolean contains key ( long key ) { return get ( key ) ! = null ; }
public push command set receive pack ( string receive pack ) { check callable ( ) ; this . receive pack = receive pack ; return this ; }
protect basic stats new stats ( string field , float query boost ) { return new basic stats ( field , query boost ) ; }
public string snapshot ( ) { return snapshot ; }
public boolean be empty ( ) { return empty ; }
public string name ( ) { return name ; }
public int read ( ) throw i o exception { synchronize ( lock ) { if ( ! be open ( ) ) { throw new i o exception ( `` input stream reader be close . `` ) ; } char buf [ ] = new char [ 4 ] ; return read ( buf , 0 , 4 ) ! = -1 ? character . code point at ( buf , 0 ) : -1 ; } }
public source get source ( ) { return source ; }
public boolean be delta base a offset ( ) { return delta base a offset ; }
public void write thin ( stream output out ) throw i o exception { super . write to ( out ) ; out . write v int ( byte . length ( ) ) ; }
public static string to string exclude ( object object , final string exclude field name ) { return to string exclude ( object , new string [ ] { exclude field name } ) ; }
public string get $ ref ( ) { return $ ref ; }
public void set max transaction id ( int max ) { this . max transaction id = max ; }
public string get reader ( ) { return reader ; }
public int get block ( ) { return 0 ; }
public void set command ( string c ) { this . command = c ; }
public command get instance ( string cmd ) { return get instance ( cmd , get conf ( ) ) ; }
public string get $ ref ( ) { return $ ref ; }
public list < file info > index file ( ) { return index file ; }
public @ nullable string get environment ( ) { return environment ; }
public void set in ( file in file ) { this . in file = in file ; }
public void set repository ( repository r ) { if ( repository == null ) repository = r ; }
public time unit get time unit ( ) { return this . time unit ; }
public static parent id query builder parent id ( string type , string id ) { return new parent id query builder ( type , id ) ; }
public object get attribute ( string attribute name ) { return attribute map . get ( attribute name ) ; }
public boolean be sign commits ( ) { return config . get boolean ( config constant . config_commit_section , config constant . config_key_gpgsign , false ) ; }
public string get sign key ( ) { return config . get string ( config constant . config_user_section , null , config constant . config_key_signingkey ) ; }
public string [ ] get conflict file ( ) { return conflicting ; }
public final string get i d ( ) { return i i d ; }
public void digest ( message digest digest ) { f b utility . update with long ( digest , timestamp ( ) ) ; }
public string get data type ( ) { return data type ; }
public object id get object id ( ) { return id ; }
public static mutable roar bitmap horizontal_or ( mutable roaring bitmap . . . bitmap ) { return horizontal_or ( convert to immutable ( bitmap ) ) ; }
public string get message ( ) { return message ; }
public static boolean equal ( string o1 , string o2 ) { return o1 == null ? o2 == null : o1 . equal ( o2 ) ; }
public string get $ ref ( ) { return $ ref ; }
public object id get new object id ( ) { return new object id ; }
public object id get old object id ( ) { return old value ; }
public object get old value ( ) { return old value ; }
public result get result ( ) { return result ; }
public remote repository get repository ( ) { return repository ; }
public void set tagger ( person ident tagger ident ) { tagger = tagger ident ; }
public person ident get tagger ( ) { return tagger ; }
public remote repository get repository ( ) { return repository ; }
public void set merge ( string merge ) { this . merge = merge ; }
public boolean fail ( ) { return state . fail ; }
public object id get old object id ( ) { return old value ; }
public change type get change type ( ) { return this . change type ; }
public string get $ ref ( ) { return $ ref ; }
public log command set rev filter ( rev filter a filter ) { check callable ( ) ; this . rev filter = a filter ; return this ; }
public log command set rev filter ( rev filter a filter ) { check callable ( ) ; this . rev filter = a filter ; return this ; }
public string get pattern ( ) { return pattern ; }
public void set tagger ( person ident tagger ident ) { tagger = tagger ident ; }
public dfs pack compactor add ( dfs pack file pack ) { src pack . add ( pack ) ; return this ; }
public double delta ( ) { return delta ; }
public void set delta search window size ( int object count ) { if ( object count < = 2 ) set delta compress ( false ) ; else delta search window size = object count ; }
public int get delta search window size ( ) { return delta search window size ; }
public int get version ( ) { return version ; }
public bitmap index get bitmap index ( ) throw i o exception { return null ; }
public object get root ( ) { return root ; }
public long get total ( ) { return this . total ; }
public double delta ( ) { return delta ; }
public void set max depth ( int max depth ) { this . max depth = max depth ; }
public object id get object id ( ) { return id ; }
public remote repository get repository ( ) { return repository ; }
public remote repository get repository ( ) { return repository ; }
public string get path ( ) { return path ; }
public void set module ( final list < module > module ) { this . module = module ; }
public r build ( ) throw i o exception { r repo = ( r ) new file repository ( setup ( ) ) ; if ( be must exist ( ) & & ! repo . get object database ( ) . exists ( ) ) throw new repository not find exception ( get git dir ( ) ) ; return repo ; }
public request option get option ( ) { return option ; }
public static void set ( string agent ) { user agent = string utils . be empty or null ( agent ) ? null : clean ( agent ) ; }
public void set c ( p d action c ) { action . set item ( c o s name . c , c ) ; }
public void set factory ( j d o m factory factory ) { this . factory = factory ; }
public void stop ( ) { stop ( true ) ; }
public static void set ( string agent ) { user agent = string utils . be empty or null ( agent ) ? null : clean ( agent ) ; }
public int get offset ( ) { return offset ; }
public void write char sequence ( char sequence s ) throw java . io . i o exception { if ( s instanceof string ) { writer . write ( ( string ) s ) ; } else if ( s instanceof char slice ) { ( ( char slice ) s ) . write ( writer ) ; } else if ( s instanceof fast string buffer ) { ( ( fast string buffer ) s ) . write ( writer ) ; } else if ( s instanceof compress whitespace ) { ( ( compress whitespace ) s ) . write ( writer ) ; } else { writer . write ( s . to string ( ) ) ; } }
public boolean be flush ( ) { return flush ; }
public void set cert nonce seed ( string seed ) { cert nonce seed = seed ; }
public long get num delta blob ( ) { return num delta blob ; }
public long get num ref delta ( ) { return num ref delta ; }
public push command set receive pack ( string receive pack ) { check callable ( ) ; this . receive pack = receive pack ; return this ; }
public void append name ( string name ) { property ref r = new property ref ( ) ; r . set name ( name ) ; add propertyref ( r ) ; }
public u r iish get u r i ( ) { return uri ; }
public submodule update command set fetch ( boolean fetch ) { this . fetch = fetch ; return this ; }
public object id get object id ( ) { return id ; }
public string get $ ref ( ) { return $ ref ; }
public list < string > get select export value ( ) throw i o exception { set < string > on value = get on value ( ) ; list < string > export value = get export value ( ) ; list < string > select export value = new array list < string > ( ) ; if ( export value . be empty ( ) ) { select export value . add ( get value ( ) ) ; return select export value ; } else { string field value = get value ( ) ; int idx = 0 ; for ( string on value : on value ) { if ( on value . compare to ( field value ) == 0 ) { select export value . add ( export value . get ( idx ) ) ; } } return select export value ; } }
public string get advertise nonce ( ) { string nonce = send nonce ( ) ; if ( nonce == null ) { return null ; } return capability_push_cert + '= ' + nonce ; }
public void set limit ( int limit ) { this . limit = limit ; }
public static refactoring status check file to be change ( i file [ ] file , i progress monitor monitor ) throw core exception { resource change checker checker= new resource change checker ( ) ; for ( i file file : file ) { checker . get delta factory ( ) . change ( file ) ; } return checker . check ( monitor ) ; }
public void remove ( cached class reference ref ) { back . remove ( ref ) ; }
public string get user ( ) { return user ; }
protect void add user agent capability ( string builder b ) { string a = user agent . get ( ) ; if ( a ! = null & & user agent . have agent ( remote capablities ) ) { b . append ( ' ' ) . append ( option_agent ) . append ( '= ' ) . append ( a ) ; } }
public int find entry ( string path ) { final byte [ ] p = constant . encode ( path ) ; return find entry ( p , p . length ) ; }
public static tika input stream get ( file file ) throw file not find exception { return get ( file , new metadata ( ) ) ; }
public file get directory ( ) { return f directory ; }
public boolean get e o l marker visible ( ) { return eol marker visible ; }
public void delete ( file f ) throw i o exception { file utils . delete ( f ) ; }
public void set file i d ( string file i d ) { this . file i d = file i d ; }
public static analyze request with normalizer ( string index , string normalizer , string . . . text ) { return new analyze request ( index , null , normalizer , null , text ) ; }
public long content length ( ) throw i o exception { return this . file . length ( ) ; }
public static void delete ( file f ) throw i o exception { delete ( f , none ) ; }
public void set configuration file name ( string configuration file name ) { file file = new file ( configuration file name ) . get absolute file ( ) ; this . configuration file name = file . get name ( ) ; implicit base path = file . get parent ( ) ; }
public string get description ( ) { return `` file [ `` + this . file . get absolute path ( ) + `` ] `` ; }
public static boolean delete file ( file directory ) { boolean result = true ; if ( directory . be directory ( ) ) { file [ ] list = directory . list file ( ) ; for ( int i = list . length ; i -- > 0 ; ) { file file = list [ i ] ; if ( file . be file ( ) ) { result = result & & file . delete ( ) ; } } } return result ; }
public boolean contains ( int integer ) { for ( int i=0 ; i < size ; i++ ) { if ( data [ i ] ==integer ) { return true ; } } return false ; }
public void set value ( string value ) { this . value = value ; }
public int get offset ( ) { return offset ; }
public int get exit code ( ) { return exit code ; }
public diff builder ignore whitespace ( ) { ignore whitespace = true ; return this ; }
public void write ( final int idx ) throw i o exception { out . write ( idx ) ; }
public static boolean a boolean ( boolean bool ) { if ( null == bool ) { return false ; } return bool ; }
public string get reader ( ) { return reader ; }
protect final void request ( long n ) { subscription s = this . s ; if ( s ! = null ) { s . request ( n ) ; } }
public long get length ( ) { return length ; }
public byte [ ] to byte array ( int limit ) throw i o exception { final long len = math . min ( length ( ) , limit ) ; if ( integer . max_value < len ) throw new out of memory error ( j git text . get ( ) . length exceed maximum array size ) ; final byte [ ] out = new byte [ ( int ) len ] ; int out ptr = 0 ; for ( block b : block ) { system . arraycopy ( b . buffer , 0 , out , out ptr , b . count ) ; out ptr += b . count ; } return out ; }
public byte [ ] to byte array ( ) throw i o exception { final long len = length ( ) ; if ( integer . max_value < len ) throw new out of memory error ( j git text . get ( ) . length exceed maximum array size ) ; final byte [ ] out = new byte [ ( int ) len ] ; int out ptr = 0 ; for ( block b : block ) { system . arraycopy ( b . buffer , 0 , out , out ptr , b . count ) ; out ptr += b . count ; } return out ; }
protect void process child ( query node query tree ) throw query node exception { list < query node > child = query tree . get child ( ) ; child list new child ; if ( child ! = null & & child . size ( ) > 0 ) { new child = allocate child list ( ) ; try { for ( query node child : child ) { child = process iteration ( child ) ; if ( child == null ) { throw new null pointer exception ( ) ; } new child . add ( child ) ; } list < query node > order child list = set child order ( new child ) ; query tree . set ( ordered child list ) ; } finally { new child . be use = false ; } } }
public query builder query ( ) { return query ; }
public static function score query builder function score query ( query builder query builder ) { return new function score query builder ( query builder ) ; }
public void add parent id ( any object id additional parent ) { if ( parent id . length == 0 ) { set parent id ( additional parent ) ; } else { object id [ ] new parent = new object id [ parent id . length + 1 ] ; system . arraycopy ( parent id , 0 , new parent , 0 , parent id . length ) ; new parent [ parent id . length ] = additional parent . copy ( ) ; parent id = new parent ; } }
public c o s dictionary get c o s dictionary ( ) { return crypt filter dictionary ; }
public boolean be match backwards ( ) { return match backwards ; }
public boolean be match ( ) { return match ; }
public boolean be failure ( ) { return be failure ; }
public character a character ( ) { return ( character ) this ; }
public char array buffer append ( char c ) { append ( new char [ ] { c } , 0 , 1 ) ; return this ; }
public void set eqkid ( final ternary node node ) { eqkid = node ; }
public list < node > get node ( ) { return node ; }
public boolean intersects ( word array b ) { for ( int k = 0 ; k < math . min ( this . get number of word ( ) , b . get number of word ( ) ) ; ++k ) { if ( ( this . get word ( k ) & b . get word ( k ) ) ! = 0 ) return true ; } return false ; }
public final int get minimum row length ( ) { if ( minimum row length == integer . min_value ) { minimum row length = 0 ; if ( get header ( ) ! = null ) { minimum row length = get header ( ) . length ; } if ( get index ( ) ! = null ) { for ( int index : get index ( ) ) { if ( index + 1 > minimum row length ) { minimum row length = index + 1 ; } } } } return minimum row length ; }
public boolean be valid ( ) { return valid ; }
public void set category ( final list < category > category ) { this . category = category ; }
public string get password ( ) { return password ; }
public boolean be match backwards ( ) { return match backwards ; }
protect final boolean be compress ( ) { return compress ; }
public void set embed file unicode ( p d embed file file ) { c o s dictionary ef = get e f dictionary ( ) ; if ( ef == null & & file ! = null ) { ef = new c o s dictionary ( ) ; f . set item ( c o s name . ef , ef ) ; } if ( ef ! = null ) { ef . set item ( c o s name . uf , file ) ; } }
public metadata metadata ( ) { return metadata ; }
public boolean be xml parse protection ( ) { return xml parsing protection ; }
public c o s array to c o s array ( ) { c o s array array = new c o s array ( ) ; array . set float array ( component ) ; if ( pattern name ! = null ) { array . add ( pattern name ) ; } return array ; }
public int get number of object ( ) { return get c o s object ( ) . get int ( c o s name . n , 0 ) ; }
public float get x ( ) { return ( ( c o s number ) value . get ( 0 ) ) . float value ( ) ; }
public void set border effect ( p d border effect dictionary be ) { get c o s object ( ) . set item ( c o s name . be , be ) ; }
public final void set ink list ( list < float [ ] > inklist ) { c o s array new inklist = new c o s array ( ) ; for ( float [ ] array : inklist ) { c o s array new array = new c o s array ( ) ; new array . set float array ( array ) ; new inklist . add ( new array ) ; } annot . set item ( c o s name . inklist , new inklist ) ; }
public void write to ( stream output out ) throw i o exception { out . write v int ( this . ordinal ( ) ) ; }
public p d rectangle get font b box ( ) { c o s base base = dict . get dictionary object ( c o s name . font_bbox ) ; p d rectangle retval = null ; if ( base instanceof c o s array ) { retval = new p d rectangle ( ( c o s array ) base ) ; } return retval ; }
public matrix multiply ( matrix b ) { return this . multiply ( b , new matrix ( ) ) ; }
public vector3 d normalize ( ) { double length = length ( ) ; if ( length > 0 . 0 ) return divide ( length ( ) ) ; return create ( 0 . 0 , 0 . 0 , 0 . 0 ) ; }
public synchronize void set object ( final map map ) { if ( map == null ) { throw new illegal argument exception ( `` map of handler may not be null `` ) ; } this . map . clear ( ) ; this . map . put all ( map ) ; }
public void set base dir ( string basedir ) { this . basedir = basedir ; }
public void set base dir ( string basedir ) { this . basedir = basedir ; }
public string [ ] get included directory ( ) { return dirs include . to array ( new string [ dirs include . size ( ) ] ) ; }
public collection value ( ) { return node map . value ( ) ; }
public string get rule set file name ( ) { return rule set file name ; }
public rule get rule for class ( final string class name , final string rule name , final string language name ) { return cache rule instance . get ( get rule key ( class name , rule name , language name ) ) ; }
public void set language ( final string language ) { this . language = list . create ( language ) ; }
public list < node > get node ( ) { return node ; }
protect void _report unsupported operation ( ) { throw new unsupported operation exception ( `` operation not support by parser of type `` +get class ( ) . get name ( ) ) ; }
public language version get default language version for file ( file source file ) { return get default language version for file ( source file . get name ( ) ) ; }
public list < language > get language for file ( path source file ) { return get language for file ( source file . get file name ( ) . to string ( ) ) ; }
public request option get option ( ) { return option ; }
public list < node > get node ( ) { return node ; }
public boolean be null string set ( ) { return null string ! = null ; }
public array list < expression > get expression ( ) { return expression ; }
public static marker get detach marker ( string name ) { return marker factory . get detached marker ( name ) ; }
public string get path ( ) { return path ; }
public boolean get show comment ( ) { return show comment ! = 0 ; }
public t default value ( v . . . val ) { this . default value = arrays . a list ( val ) ; return ( t ) this ; }
public t default value ( collection < ? extend v > val ) { this . default value = new array list < > ( val ) ; return ( t ) this ; }
public string get name ( ) { return name ; }
public static char to char ( string str , char default value ) { if ( string utils . be empty ( str ) ) { return default value ; } return str . char at ( 0 ) ; }
public string get property name ( ) { return property name ; }
public void set regex ( string regex ) { if ( regex ! = null & & regex . length ( ) ! = 0 ) { this . regex = regex ; property set p = new property set ( ) ; p . set project ( get project ( ) ) ; p . append regex ( regex ) ; add propertyset ( p ) ; } }
public string get id ( ) { return this . id ; } // -- string get id ( )
public void set factory ( j d o m factory factory ) { this . factory = factory ; }
public date time parser get parser ( ) { return internal parser date time parser . of ( i parser ) ; }
public schema get schema ( ) { return schema ; }
public final void set metric collector ( request metric collector metric ) { this . metric collector = metric ; }
public location get location ( ) { return location ; }
public void remove exception attribute ( ) { attribute info . remove ( attribute , exception attribute . tag ) ; }
public double get priority ( ) { return priority ; }
public void set language ( final string language ) { this . language = list . create ( language ) ; }
public static string get rule ( ) { string rule string = null ; if ( rule ! = null ) { string builder sb = new string builder ( ) ; for ( rule rule : rule ) { sb . append ( rule . to string ( ) ) . append ( `` \n `` ) ; } rule string = sb . to string ( ) . trim ( ) ; } return rule string ; }
public external documentation get external doc ( ) { return external doc ; }
public final i scheduling rule get rule ( ) { return super . get rule ( ) ; }
public rule get rule for class ( final string class name , final string rule name , final string language name ) { return cache rule instance . get ( get rule key ( class name , rule name , language name ) ) ; }
public class < ? > type for ( string type name ) { return type by name . get ( type name ) ; }
public void set style ( string s ) { get c o s object ( ) . set name ( `` s `` , s ) ; }
public string index name ( ) { return index name ; }
public void set filter ( boolean filter ) { this . filter = filter ; }
public void set level ( int level ) { this . trace level = level ; }
public static boolean register ( tree renderer descriptor descriptor ) { synchronize ( registry ) { if ( registry . contains key ( descriptor . id ( ) ) ) { return false ; } registry . put ( descriptor . id ( ) , descriptor ) ; } return true ; }
public string get descriptor ( ) { return descriptor ; }
public class < ? > type for ( string type name ) { return type by name . get ( type name ) ; }
public name type get name type ( ) { return this . engine . get name type ( ) ; }
public final boolean be qualify name ( ) { return ( this instanceof qualify name ) ; }
public switch statement get enclose switch statement ( ) { if ( switch statement . be empty ( ) ) return null ; return switch statement . get first ( ) ; }
public policy with statement ( statement . . . statement ) { set statement ( array . a list ( statement ) ) ; return this ; }
public final boolean be wildcard type ( ) { return ( this instanceof wildcard type ) ; }
public j type var bound ( j class c ) { if ( bound ! =null ) throw new illegal argument exception ( `` type variable have an exist class bound `` +bound ) ; bind = c ; return this ; }
public a s t variable declarator id get variable id ( ) { return ( a s t variable declarator id ) get child ( 0 ) ; }
public a s t variable declarator id get var id ( ) { return get first child of type ( a s t variable declarator id . class ) ; }
public string get pattern ( ) { return pattern ; }
public void set upper bound byte ( int upper bound bytes ) { this . upper bound bytes = upper bound byte ; }
public boolean be reference type ( ) { return get reference type ( ) ! = null ; }
public void set expression ( expression expression ) { if ( expression == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . expression ; pre replace child ( old child , expression , expression_property ) ; this . expression = expression ; post replace child ( old child , expression , expression_property ) ; }
public string get size end text ( ) { return super . get size end text ( ) ; }
public boolean match ( node info node ) { int node kind = node . get node kind ( ) ; return ( node kind == type . element || node kind == type . text || node kind == type . comment || node kind == type . processing_instruction ) ; }
public static metric option of option ( collection < ? extend metric option > option ) { metric option builder builder = new metric option builder ( ) ; builder . add all ( option ) ; return builder . build ( ) ; }
public a s t node get cover node ( ) { return this . f cover node ; }
public void add role ( string user , string role ) { list < string > role = user role . get ( user ) ; if ( role == null ) { role = new array list < > ( ) ; user role . put ( user , role ) ; } role . add ( role ) ; }
public object get lambda argument ( string arg ) { if ( lambda args == null ) { return null ; } for ( int i = lambda args . size ( ) - 1 ; i > = 0 ; i -- ) { map < string , object > lmap = lambda args . element at ( i ) ; object v = lmap . get ( arg ) ; if ( v ! = null ) { return v ; } } return null ; }
public array list < expression > get expression ( ) { return expression ; }
public string get class name ( ) { return class name ; }
public void set encoding ( string encode ) { this . encode = encoding ; }
public string get encode ( ) { return encode ; }
static public int swap int ( int i ) { return ( ( i & 0x f f ) < < 24 ) | ( ( i & 0x f f00 ) < < 8 ) | ( ( i & 0x f f0000 ) > > 8 ) | ( ( i > > 24 ) & 0x f f ) ; }
public static < t > answer < t > answer with delay ( long sleepy time , answer < t > answer ) { return ( answer < t > ) new answer with delay ( sleepy time , ( answer < object > ) answer ) ; }
public void flush ( ) throw i o exception { out . flush ( ) ; }
public int get version ( ) { return version ; }
public string get index end ( ) { return index end ; }
public static boolean be s q l available ( ) { return be s q l available ; }
public void set args ( string [ ] args ) { if ( args == null ) { args = new string [ ] { } ; } this . args = args ; this . args list = collection . unmodifiable list ( new array list < string > ( arrays . a list ( args ) ) ) ; }
public string get method call syntax ( string obj , string m , string . . . args ) { string builder buf = new string builder ( ) ; buf . append ( `` $ { `` ) ; buf . append ( obj ) ; buf . append ( `` . `` ) ; buf . append ( m ) ; buf . append ( `` ( `` ) ; if ( args . length ! = 0 ) { int i = 0 ; for ( ; i < args . length - 1 ; i++ ) { buf . append ( `` $ `` ) . append ( args [ i ] ) ; buf . append ( `` , `` ) ; } buf . append ( `` $ `` ) . append ( args [ i ] ) ; } buf . append ( `` ) } `` ) ; return buf . to string ( ) ; }
public void add ( string name , v value ) { list < v > lo = get ( name ) ; if ( lo == null ) { lo = new array list < > ( ) ; } lo . add ( value ) ; super . put ( name , lo ) ; }
public boolean seek exact ( bytes ref text ) throw i o exception { return seek ceil ( text ) == seek status . find ; }
public o auth flow get client credential ( ) { return client credential ; }
public int get encode source end ( ) { return encode source end ; }
public final t get ( string name ) { int idx = find ( name ) ; return 0 < = idx ? get ( idx ) : null ; }
public static double get double ( byte [ ] data ) { return double . long bit to double ( get long ( data , 0 ) ) ; }
public string get key ( ) { return key ; }
public void set value ( string value ) { this . value = value ; }
public static calendar to calendar ( date date ) { if ( date == null ) { return null ; } calendar calendar = calendar . get instance ( ) ; calendar . set time ( date ) ; return calendar ; }
public boolean be remove ( ) { return remove ; }
public string get parameter name ( ) { return parameter name ; }
public void remove query ( boolean adaptive fetch , @ non null query query ) { if ( adaptive fetch & & maximum result buffer size ! = -1 ) { string sql = query . get native sql ( ) . trim ( ) ; adaptive fetch cache entry adaptive fetch cache entry = adaptive fetch info map . get ( sql ) ; if ( adaptive fetch cache entry ! = null ) { adaptive fetch cache entry . decrement counter ( ) ; if ( adaptive fetch cache entry . get counter ( ) < 1 ) { adaptive fetch info map . remove ( sql ) ; } else { adaptive fetch info map . put ( sql , adaptive fetch cache entry ) ; } } } }
public void add new query ( boolean adaptive fetch , @ non null query query ) { if ( adaptive fetch & & maximum result buffer size ! = -1 ) { string sql = query . get native sql ( ) . trim ( ) ; adaptive fetch cache entry adaptive fetch cache entry = adaptive fetch info map . get ( sql ) ; if ( adaptive fetch cache entry == null ) { adaptive fetch cache entry = new adaptive fetch cache entry ( ) ; } adaptive fetch cache entry . increment counter ( ) ; adaptive fetch info map . put ( sql , adaptive fetch cache entry ) ; } }
public static class loader get class loader ( string class name ) { if ( class name == null ) { return null ; } return ( class loader ) classloaders . get ( class name ) ; }
public constructor < ? > get constructor ( ) { return this . constructor ; }
public static method get accessible method ( class cl , string method name , class parameter type ) { return get accessible method ( cl , method name , new class [ ] { parameter type } ) ; }
public field get field ( ) { return field ; }
public static synchronize void suppress method ( class < ? > cl , class < ? > . . . additional class ) { suppress method ( cl , false ) ; for ( class < ? > clazz : additional class ) { suppress method ( clazz , false ) ; } }
public static synchronize void suppress field ( class < ? > [ ] class ) { if ( class == null || class . length == 0 ) { throw new illegal argument exception ( `` you must supply at least one class . `` ) ; } for ( class < ? > clazz : class ) { suppress field ( clazz . get declared field ( ) ) ; } }
public static synchronize void suppress method ( class < ? > cl , class < ? > . . . additional class ) { suppress method ( cl , false ) ; for ( class < ? > clazz : additional class ) { suppress method ( clazz , false ) ; } }
public static void replay ( object . . . mock ) { for ( object mock : mock ) { get control ( mock ) . replay ( ) ; } }
public void set method ( int method ) { this . method = method ; }
public static < t > method [ ] get all metods except ( class < t > type , string method name to exclude , class < ? > [ ] argument type ) { method [ ] method = get all method ( type ) ; list < method > method list = new array list < method > ( ) ; outer : for ( method method : method ) { if ( method . get name ( ) . equal ( method name to exclude ) ) { if ( argument type ! = null & & argument type . length > 0 ) { final class < ? > [ ] args = method . get parameter type ( ) ; if ( args ! = null & & args . length == argument type . length ) { for ( int i = 0 ; i < args . length ; i++ ) { if ( args [ i ] . be assignable from ( get unmocked type ( argument type [ i ] ) ) ) { / * * method be not find thus it should not be * mock . continue to investigate the next * method . * / continue outer ; } } } } else { continue ; } } method list . add ( method ) ; } return method list . to array ( new method [ 0 ] ) ; }
public constructor < ? > get constructor ( ) { return this . constructor ; }
public static void throw exception if method be not find ( class < ? > type , string method name , method method to mock , object . . . argument ) { if ( method to mock == null ) { string method name data = `` `` ; if ( method name ! = null ) { method name data = `` with name ' `` + method name + `` ' `` ; } throw new method not find exception ( `` no method find `` + method name data + `` with parameter type : [ `` + get argument type a string ( argument ) + `` ] in class `` + get unmocked type ( type ) . get name ( ) + `` . `` ) ; } }
public java . lang . string get title ( ) { java . lang . object ref = title_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; title_ = s ; return s ; } }
public java . lang . string get id ( ) { java . lang . object ref = id_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; id_ = s ; return s ; } }
public java . util . list < com . google . api . property > get property list ( ) { return properties_ ; }
public java . lang . string get json name ( ) { java . lang . object ref = json name_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; json name_ = s ; return s ; } }
public void set property ( java . util . property property ) { this . property = property ; } // -- void set property ( java . util . property )
public java . lang . string get id ( ) { java . lang . object ref = id_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; id_ = s ; return s ; } }
public boolean have class ( ) { return class name ! =null ; }
public boolean have class ( ) { return class name ! =null ; }
public quota [ ] get quota ( ) throw message exception { return ( quota [ ] ) do optional command ( `` quota not support `` , new protocol command ( ) { @ override public object do command ( i m a p protocol p ) throw protocol exception { return p . get quota root ( full name ) ; } } ) ; }
protected access control context get access control context ( ) { return access controller . get context ( ) ; }
public java . util . list < com . google . protobuf . any > get detail list ( ) { return details_ ; }
public object response ( ) { return response ; }
public refresh token get existing grant ( ) { return exist grant ; }
public java . lang . string get id ( ) { java . lang . object ref = id_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; id_ = s ; return s ; } }
public java . lang . string get id ( ) { java . lang . object ref = id_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; id_ = s ; return s ; } }
public java . lang . string get id ( ) { java . lang . object ref = id_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; id_ = s ; return s ; } }
public java . util . list < com . google . protobuf . any > get source file list ( ) { return source files_ ; }
public float float value ( ) { return ( ( float ) numerator ) / ( ( float ) denominator ) ; }
public java . lang . string get id ( ) { java . lang . object ref = id_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; id_ = s ; return s ; } }
public string get extension ( ) { return this . extension ; } // -- string get extension ( )
public int get min length ( ) { return min length ; }
public field get field ( ) { return field ; }
public java . lang . string get id ( ) { java . lang . object ref = id_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; id_ = s ; return s ; } }
public void write to ( writer writer ) throw i o exception { write to ( writer , writer config . minimal ) ; }
public void set ignore ( boolean ignore ) { this . ignore = ignore ; }
public void set class loader ( class loader class loader ) { this . class loader = class loader ; }
public void set filter ( boolean filter ) { this . filter = filter ; }
public void set max parallel ( int max ) { max parallel = max ; }
public static < t > predicate < t > null predicate ( ) { return null predicate . null predicate ( ) ; }
public void set url ( string url ) { this . url = url ; } // -- void set url ( string )
public set < k > key set ( ) { if ( key set == null ) { key set = new key set < > ( this ) ; } return key set ; }
public client request adapter get adapter ( ) { return cra ; }
public string to string ( ) { string s = element . to string ( ) ; if ( be require ( ) ) s += ' ! ' ; if ( be collection ( ) ) s += ' * ' ; return s ; }
public static annotation [ ] get resource annotation ( method method ) { map < class < ? > , annotation > annotation = new hash map < class < ? > , annotation > ( ) ; for ( annotation annotation : method . get declare class ( ) . get annotation ( ) ) { annotation . put ( annotation . get class ( ) , annotation ) ; } for ( annotation annotation : method . get annotation ( ) ) { annotation . put ( annotation . get class ( ) , annotation ) ; } return annotation . value ( ) . to array ( new annotation [ annotation . size ( ) ] ) ; }
public static matcher < annotate element > annotate with ( final class < ? extend annotation > annotation type ) { return new annotate with type ( annotation type ) ; }
public bitmap index get bitmap index ( ) throw i o exception { return null ; }
public boolean be empty ( ) { return size == 0 ; }
public container get container ( ) { return container ; }
public mappeable container lazy o r ( mappeable container x ) { if ( this instanceof mappeable array container ) { if ( x instanceof mappeable array container ) return or ( ( mappeable array container ) x ) ; else if ( x instanceof mappeable bitmap container ) return ( ( mappeable bitmap container ) x ) . lazyor ( ( mappeable array container ) this ) ; return ( ( mappeable run container ) x ) . lazyor ( ( mappeable array container ) this ) ; } else if ( this instanceof mappeable run container ) { if ( x instanceof mappeable array container ) return ( ( mappeable run container ) this ) . lazyor ( ( mappeable array container ) x ) ; else if ( x instanceof mappeable bitmap container ) return ( ( mappeable bitmap container ) x ) . lazyor ( ( mappeable run container ) this ) ; return or ( ( mappeable run container ) x ) ; } else { if ( x instanceof mappeable array container ) return ( ( mappeable bitmap container ) this ) . lazyor ( ( mappeable array container ) x ) ; else if ( x instanceof mappeable bitmap container ) return ( ( mappeable bitmap container ) this ) . lazyor ( ( mappeable bitmap container ) x ) ; return ( ( mappeable bitmap container ) this ) . lazyor ( ( mappeable run container ) x ) ; } }
public string get container name ( ) { if ( this instanceof mappeable bitmap container ) { return `` mappeablebitmap `` ; } else if ( this instanceof mappeable array container ) { return `` mappeablearray `` ; } else { return `` mappeablerun `` ; } }
public container get container ( ) { return container ; }
public void set label ( string label ) { this . label = label ; }
public string scheme ( ) { return scheme ; }
public string scheme ( ) { return scheme ; }
protect int get mode ( ) { return this . mode ; }
public void set publish date ( final date publish date ) { get d c module ( ) . set date ( publish date ) ; }
public output < string > summary ( ) { return summary ; }
public void set title ( string title ) { this . title = title ; }
public date get update date ( ) { return date . copy ( updated date ) ; }
public boolean equal ( object other ) { return this==other ; }
public modifier adjustment with constructor modifier ( modifier contributor . for method . . . modifier contributor ) { return with constructor modifier ( array . a list ( modifier contributor ) ) ; }
public void set module ( final list < module > module ) { this . module = module ; }
public void set version ( string version ) { this . version = version ; } // -- void set version ( string )
public string get string ( ) { return string ; }
public json creator . mode find creator binding ( annotate a ) { return null ; }
public list type ( ) { return this . type ; }
public language result get language ( ) { return writer . get language ( ) ; }
public void set right ( final string right ) { this . right = list . create ( right ) ; }
public void set right list ( final list < string > right ) { this . right = right ; }
public void set right list ( final list < string > right ) { this . right = right ; }
public void set update frequency ( final int update frequency ) { this . update frequency = update frequency ; }
public int get update frequency ( ) { return update frequency ; }
public boolean local node master ( ) { return state . node ( ) . be local node elect master ( ) ; }
public list < string > get skip day ( ) { return list . create when null ( skip day ) ; }
public int get day ( ) { return day ; }
public void set category ( string category ) { this . category = category ; }
public jaxb hbm generator specification type get generator ( ) { return generator ; }
public string get domain ( ) { return domain ; }
public string get path ( ) { return path ; }
public void set value ( string value ) { this . value = value ; }
public string get type ( ) { return type ; }
public string get value ( ) { return value ; }
public string get url ( ) { return url ; }
public float [ ] get char width ( ) { return this . char width ; }
public float get x height ( ) { return x height ; }
public string get source ( ) { return source ; }
public static string get string from g u i d ( guid guid ) { guid pguid = new guid ( guid . get pointer ( ) ) ; int max = 39 ; char [ ] lpsz = new char [ max ] ; int len = ole32 . instance . string from g u i d2 ( pguid , lpsz , max ) ; if ( len == 0 ) { throw new runtime exception ( `` string from g u i d2 `` ) ; } lpsz [ len - 1 ] = 0 ; return native . to string ( lpsz ) ; }
public void set module ( final list < module > module ) { this . module = module ; }
public void set expiration ( kerberos time expiration ) { this . expiration = expiration ; }
public string get name ( ) { return name ; }
public void set publish ( final date publish ) { this . publish = date . copy ( publish ) ; }
public void set updated date ( final date updated date ) { this . updated date = new date ( updated date . get time ( ) ) ; }
public date get update date ( ) { return date . copy ( updated date ) ; }
public string get encode ( ) throw message exception { return encode ; }
public string get description ( ) { return description ; }
public string get description ( ) { return this . description ; }
public void set right ( final string right ) { this . right = list . create ( right ) ; }
public void set category ( final list < category > category ) { this . category = category ; }
public static list < string > get support feed type ( ) { return get fee generator ( ) . get supported feed type ( ) ; }
public void set encoding ( string encode ) { this . encode = encoding ; }
public void set date ( string date ) { super . set internal date ( date ) ; }
public boolean have additional namespaces ( ) { return additional namespaces ! = null & & ! additional namespaces . be empty ( ) ; }
public void set value ( member value [ ] element ) { value = element ; if ( element ! = null & & element . length > 0 ) type = element [ 0 ] ; }
public string get text ( ) { return text ; }
public boolean get xml healer on ( ) { return feed input . get xml healer on ( ) ; }
public void set xml healer on ( final boolean heals ) { feed input . set xml healer on ( heals ) ; }
public void set feed type ( final string feed type ) { this . fee type = feed type ; }
public void set feed type ( final string feed type ) { this . fee type = feed type ; }
public final t get object ( ) { return object ; }
protect string pending to string ( ) { object local value = value ; if ( local value instanceof set future ) { return `` set future= [ `` + ( ( set future ) local value ) . future + `` ] `` ; } else if ( this instanceof schedule future ) { return `` remain delay= [ `` + ( ( schedule future ) this ) . get delay ( time unit . millisecond ) + `` ms ] `` ; } return null ; }
public final observable < t > delay subscription ( long delay , time unit unit ) { return delay subscription ( delay , unit , scheduler . computation ( ) ) ; }
public final completable timeout ( long timeout , time unit unit , scheduler scheduler ) { return timeout0 ( timeout , unit , scheduler , null ) ; }
public final observable < t > timeout ( long timeout , time unit time unit , observable < ? extend t > other , scheduler scheduler ) { return lift ( new operator timeout < t > ( timeout , time unit , other , scheduler ) ) ; }
public static < e > queue < e > synchronize queue ( queue < e > queue ) { return synchronize . queue ( queue , null ) ; }
public void complete ( list < string > candidate ) { delegate . complete ( candidate ) ; }
public void set source ( file source ) { this . source = source ; }
public static < t > observable < t > just ( final t value ) { return scalar synchronous observable . create ( value ) ; }
public static void set on generic schedule executor service ( func0 < ? extends schedule executor service > factory ) { if ( lockdown ) { return ; } on generic schedule executor service = factory ; }
public executor service get executor service ( ) { return executor service ; }
public throwable get throwable ( ) { if ( observer . get ( ) == terminate ) { return error ; } return null ; }
public static < t > observable < t > instance ( ) { return ( observable < t > ) never ; }
public static void do with local field ( class < ? > clazz , field callback fc ) { for ( field field : get declare field ( clazz ) ) { try { fc . do with ( field ) ; } catch ( illegal access exception ex ) { throw new illegal state exception ( `` not allow to access field ' `` + field . get name ( ) + `` ' : `` + ex ) ; } } }
public throwable get throwable ( ) { return throwable ; }
public static < t > observable < t > instance ( ) { return ( observable < t > ) never ; }
public zip entry source get zip archive ( ) { return zip archive ; }
public int get capacity ( ) { return capacity ; }
public final completable delay ( long delay , time unit unit , scheduler scheduler ) { return delay ( delay , unit , scheduler , false ) ; }
public static < t > observable < t > instance ( ) { return ( observable < t > ) never ; }
public void set value default ( string value default ) { this . value default = value default ; }
public final observable < t > serialize ( ) { return lift ( operator serialize . < t > instance ( ) ) ; }
public static < t > observable < t > instance ( ) { return ( observable < t > ) never ; }
public final single < t > timeout ( long timeout , time unit time unit ) { return timeout ( timeout , time unit , null , scheduler . computation ( ) ) ; }
public final observable < t > timeout ( long timeout , time unit time unit , observable < ? extend t > other , scheduler scheduler ) { return lift ( new operator timeout < t > ( timeout , time unit , other , scheduler ) ) ; }
public final completable timeout ( long timeout , time unit unit , scheduler scheduler ) { return timeout0 ( timeout , unit , scheduler , null ) ; }
public static < t > observable < t > instance ( ) { return ( observable < t > ) never ; }
public static < t > test subscriber < t > create ( ) { return new test subscriber < t > ( ) ; }
public final assertable subscriber < t > test ( long initial request amount ) { assertable subscriber < t > t = assertable subscriber observable . create ( initial request amount ) ; subscribe ( t ) ; return t ; }
public static void set on generic schedule executor service ( func0 < ? extends schedule executor service > factory ) { if ( lockdown ) { return ; } on generic schedule executor service = factory ; }
public throwable get error ( ) { return error ; }
public static schedule executor service create ( ) { func0 < ? extends schedule executor service > f = rx java hook . get on generic schedule executor service ( ) ; if ( f == null ) { return create default ( ) ; } return f . call ( ) ; }
public static < t > observable < t > instance ( ) { return ( observable < t > ) never ; }
public static < r > observable < r > zip ( observable < ? extend observable < ? > > w , final func n < ? extend r > zip function ) { return w . to list ( ) . map ( internal observable utils . to_array ) . lift ( new operator zip < r > ( zip function ) ) ; }
public matrix multiply ( matrix other ) { return new matrix ( check float value ( multiply array ( single , other . single ) ) ) ; }
public final observable < t > timeout ( long timeout , time unit time unit , observable < ? extend t > other , scheduler scheduler ) { return lift ( new operator timeout < t > ( timeout , time unit , other , scheduler ) ) ; }
protect void set top ( l top ) { this . top = top ; }
public boolean be x include aware ( ) { return option . be x include aware ( ) ; }
public boolean be x include aware set ( ) { return option . be x include aware set ( ) ; }
public void set error listener ( error listener listener ) { error listener = listener ; }
public static boolean be low case ( char ch ) { return character . to lower case ( ch ) == ch ; }
public static boolean be valid11 ( int i ) { return i < 65536 ? ( data [ i ] & valid_11_mask ) ! = 0 : ( utf16 . nonbmp_min < = i & & i < = utf16 . nonbmp_max ) ; }
public static boolean be valid10 ( int i ) { return i < 65536 ? ( data [ i ] & valid_10_mask ) ! = 0 : ( utf16 . nonbmp_min < = i & & i < = utf16 . nonbmp_max ) ; }
public string get mode ( ) { return mode ; }
public document get document ( ) { return document ; }
public sequence get sequence ( string sequence name ) { sequence sequence = sequence . get ( sequence name ) ; if ( sequence == null ) { throw db exception . get ( error code . sequence_not_found_1 , sequence name ) ; } return sequence ; }
public executable get executable ( ) { return executable ; }
public document doc ( int doc i d ) throw i o exception { return reader . document ( doc i d ) ; }
public object get ( ) { return value ; }
public void initialize ( final rule set rs ) { for ( final rule r : r . get all rule ( ) ) { cached rule instance . put ( get rule key ( r . get rule class ( ) , r . get name ( ) , r . get language ( ) . get terse name ( ) ) , r ) ; } }
protect synchronized void notify listener ( final long pause length nsec , final long pause end time nsec ) { message . add ( new pause notification ( pause length nsec , pause end time nsec ) ) ; }
public final string get path ( ) { return this . document path ; }
public void set line number ( int line number ) { this . line number = line number ; }
public long time ( ) { return time ; }
public json location current token location ( ) { return get token location ( ) ; }
public final string get path ( ) { return this . document path ; }
public location get location ( ) { return location ; }
public final boolean get node us parser ( ) { return option . boolean value ( `` node_uses_parser `` ) ; }
public static object output stream new object output stream ( output stream output stream ) throw i o exception { return new object output stream ( output stream ) ; }
public void open ( ) throw x path exception { if ( next receiver == null ) { throw new illegal state exception ( `` tree receiver . open ( ) : no underlie receiver provide `` ) ; } next receiver . open ( ) ; previous atomic = false ; }
public void set schema location ( list < string > schema location ) { this . schema location = schema location ; }
public boolean be null type ( ) { return false ; }
public static builder builder ( ) { return new builder ( ) ; }
public void start ( ) throw exception { start ( false ) ; }
public tag get tag ( ) { return this . tag ; }
public boolean have attribute ( ) { return attribute ! = null & & ! attribute . be empty ( ) ; }
public void end document ( ) throw x path exception { }
public string get system id ( ) { return system id ; }
public result get result ( ) { return result ; }
public void set underlying receiver ( receiver receiver ) { next receiver = receiver ; }
public char char at ( int i ) { return this . buffer [ i ] ; }
public static void print ( object o , java . io . writer writer , boolean typeheader ) throw i o exception { if ( o == null ) { if ( typeheader ) writer . write ( `` null object\n `` ) ; writer . write ( `` null\n `` ) ; writer . flush ( ) ; return ; } class < ? > arraytype = o . get class ( ) . get component type ( ) ; if ( arraytype ! = null ) { if ( typeheader ) writer . write ( `` array of `` + arraytype+ `` \n `` ) ; if ( ! arraytype . be primitive ( ) ) { writer . write ( array . deep to string ( ( object [ ] ) o ) ) ; writer . write ( `` \n `` ) ; } else if ( arraytype . equal ( integer . type ) ) { writer . write ( array . to string ( ( int [ ] ) o ) ) ; writer . write ( `` \n `` ) ; } else if ( arraytype . equal ( double . type ) ) { writer . write ( array . to string ( ( double [ ] ) o ) ) ; writer . write ( `` \n `` ) ; } else if ( arraytype . equal ( boolean . type ) ) { writer . write ( array . to string ( ( boolean [ ] ) o ) ) ; writer . write ( `` \n `` ) ; } else if ( arraytype . equal ( short . type ) ) { writer . write ( array . to string ( ( short [ ] ) o ) ) ; writer . write ( `` \n `` ) ; } else if ( arraytype . equal ( long . type ) ) { writer . write ( array . to string ( ( long [ ] ) o ) ) ; writer . write ( `` \n `` ) ; } else if ( arraytype . equal ( float . type ) ) { writer . write ( array . to string ( ( float [ ] ) o ) ) ; writer . write ( `` \n `` ) ; } else if ( arraytype . equal ( character . type ) ) { writer . write ( array . to string ( ( char [ ] ) o ) ) ; writer . write ( `` \n `` ) ; } else if ( arraytype . equal ( byte . type ) ) { writer . write ( array . to string ( ( byte [ ] ) o ) ) ; writer . write ( `` \n `` ) ; } else { writer . write ( `` ? ? ? ? ? ? ? ? ? \n `` ) ; } } else if ( o instanceof set ) { @ suppress warning ( `` unchecked `` ) set < object > set = ( set < object > ) o ; array list < string > list=new array list < string > ( set . size ( ) ) ; for ( object obj : set ) { list . add ( obj . to string ( ) ) ; } collection . sort ( list ) ; if ( typeheader ) { writer . write ( o . get class ( ) . get name ( ) ) ; writer . write ( `` \n `` ) ; } writer . write ( list . to string ( ) ) ; writer . write ( `` \n `` ) ; } else if ( o instanceof map ) { @ suppress warning ( `` unchecked `` ) map < object , object > map= ( map < object , object > ) o ; array list < string > list=new array list < string > ( map . size ( ) ) ; for ( object key : map . key set ( ) ) { list . add ( key . to string ( ) + `` = `` +map . get ( key ) ) ; } collection . sort ( list ) ; if ( typeheader ) { writer . write ( o . get class ( ) . get name ( ) ) ; writer . write ( `` \n `` ) ; } writer . write ( list . to string ( ) ) ; writer . write ( `` \n `` ) ; } else if ( o instanceof collection ) { if ( typeheader ) { writer . write ( o . get class ( ) . get name ( ) ) ; writer . write ( `` \n `` ) ; } writer . write ( o . to string ( ) ) ; writer . write ( `` \n `` ) ; } else if ( o instanceof string ) { if ( typeheader ) writer . write ( `` string\n `` ) ; writer . write ( o . to string ( ) ) ; writer . write ( `` \n `` ) ; } else if ( o instanceof java . util . calendar ) { if ( typeheader ) writer . write ( `` java . util . calendar\n `` ) ; date format f = date format . get date time instance ( date format . medium , date format . medium , locale . uk ) ; calendar c = ( calendar ) o ; writer . write ( f . format ( c . get time ( ) ) + `` millisec= `` + c . get ( calendar . millisecond ) + `` \n `` ) ; } else { if ( typeheader ) { writer . write ( o . get class ( ) . get name ( ) ) ; writer . write ( `` \n `` ) ; } writer . write ( o . to string ( ) ) ; writer . write ( `` \n `` ) ; } writer . flush ( ) ; }
public sequence iterator get another ( ) { return new j regex iterator ( the string , pattern ) ; }
protect void set code ( int code ) { this . code = code ; }
public int get name code ( int index ) { return tree . att code [ first attribute + index ] ; }
public string get reader ( ) { return reader ; }
public expression try indexed filter ( filter expression f , expression visitor visitor , boolean index first operand ) { return f ; }
public void set target ( object target ) { set target source ( new singleton target source ( target ) ) ; }
public final item type get item type ( type hierarchy th ) { return step . get item type ( th ) ; }
public string collator get name collation ( string name ) { if ( collation table == null ) { collation table = new collation map ( config ) ; } return collation table . get name collation ( name ) ; }
public item type get require context item type ( ) { return require context item type ; }
public iterator iterator ( ) { return new iterator ( ) ; }
public value representation evaluate variable ( x path context context ) throw x path exception { throw new unsupported operation exception ( ) ; }
public static boolean be local container ( container container ) { if ( container == null || container . get deployable container ( ) == null || container . get deployable container ( ) . get default protocol ( ) == null ) { return false ; } if ( local protocol . name . equal ( container . get deployable container ( ) . get default protocol ( ) . get name ( ) ) ) { return true ; } return false ; }
public expression [ ] get child ( ) { return child ; }
protect int compute cardinality ( ) { return static property . allows_zero_or_more ; }
public stream priority set dependency ( int dependency ) { this . dependency = dependency ; return this ; }
public void set object name ( structure q name q name ) { object name = q name ; }
public void set x path context ( x path context context ) { this . context = context ; }
public string get system id ( ) { return system id ; }
public void set static context ( static context static context ) { this . static context = static context ; }
public static context get static context ( ) { return static context ; }
public void store type ( final expression exp , final class node cn ) { type checking visitor . store type ( exp , cn ) ; }
public int get slot ( ) { return slot ; }
public value representation evaluate variable ( x path context context ) { return context . evaluate local variable ( slot number ) ; }
public boolean be special ( ) { return special ; }
public void set x path context ( x path context context ) { this . context = context ; }
public void set slot number ( int slot ) { slot number = slot ; }
public boolean be keep go mode ( ) { return this . keep go mode ; }
public final item type get item type ( type hierarchy th ) { return step . get item type ( th ) ; }
public void set be expression closure ( boolean be expression closure ) { this . be expression closure = be expression closure ; }
public string get expression ( ) { return expression ; }
public model map get model ( ) { if ( use default model ( ) ) { return this . default model ; } else { if ( this . redirect model == null ) { this . redirect model = new model map ( ) ; } return this . redirect model ; } }
public int get cardinality ( ) { if ( expression == null ) { return static property . allows_zero_or_more ; } else { return expression . get cardinality ( ) ; } }
public item type get item type ( type hierarchy th ) { return target type ; }
public int get last position ( ) { return 0 ; }
public boolean equal ( object other ) { if ( other==this ) { return true ; } if ( other instanceof document range ) { return this . compare to ( ( document range ) other ) ==0 ; } return false ; }
public void add role ( string user , string role ) { list < string > role = user role . get ( user ) ; if ( role == null ) { role = new array list < > ( ) ; user role . put ( user , role ) ; } role . add ( role ) ; }
public int approximate cardinality ( ) { return cardinality ( ) ; }
public void set conf ( configuration conf ) { this . conf = conf ; }
public synchronize void add filter ( filter filter ) { if ( be reference ( ) ) { throw no child allow ( ) ; } filter . add element ( filter ) ; filter hash = null ; }
public boolean be function ( ) { return this . function ; }
public static date time context get date time context ( ) { return date time context holder . get ( ) ; }
public static double day of week in month ( x path context context ) throw x path exception { return day of week in month ( date time ( context ) ) ; }
public static double week in year ( x path context context ) throw x path exception { return week in year ( date time ( context ) ) ; }
public static date convert date ( value value , calendar calendar ) { if ( value == value null . instance ) { return null ; } value date d = ( value date ) value . convert to ( value . date ) ; calendar cal = ( calendar ) calendar . clone ( ) ; cal . clear ( ) ; cal . set lenient ( true ) ; long date value = d . get date value ( ) ; set calendar field ( cal , year from date value ( date value ) , month from date value ( date value ) , day from date value ( date value ) , 0 , 0 , 0 , 0 ) ; long m = cal . get time in millis ( ) ; return new date ( m ) ; }
public string get base u r i ( ) { return base u r i ; }
protect void type error ( string message , string error code , x path context context ) throw x path exception { x path exception e = new x path exception ( message , this ) ; e . set be type error ( true ) ; e . set error code ( error code ) ; e . set x path context ( context ) ; throw e ; }
public static method get accessible method ( class cl , string method name , class parameter type ) { return get accessible method ( cl , method name , new class [ ] { parameter type } ) ; }
public x query function get declaration by key ( string function key ) { return ( x query function ) function . get ( function key ) ; }
public x query function library get global function library ( ) { return global function library ; }
public iterator iterator ( ) { return new iterator ( ) ; }
public list < node > get node ( ) { return node ; }
public name get function name ( ) { return function name ; }
public void set fault detail string ( string detail ) { clear fault detail ( ) ; add fault detail string ( detail ) ; }
public string get system id ( ) { return system id ; }
public string get expression ( ) { return expression ; }
public request option get option ( ) { return option ; }
public boolean get global ( ) { return m global ; }
public void set child ( hash set < string > child ) { this . child = child ; }
public void set preserve namespaces ( boolean inherit ) { preserve namespaces = inherit ; }
public hash map get character map index ( ) { if ( character map index == null ) { character map index = new hash map ( 10 ) ; } return character map index ; }
public void set character map index ( hash map cmi ) { character map index = cmi ; }
public key manager [ ] get key manager ( ) { return key manager ; }
public void set default collation name ( string name ) { default collation name = name ; }
public void set implicitly require param ( boolean require param ) { if ( require param ) { property |= implicitly_required ; } else { property & = ~implicitly_required ; } }
public void set require param ( boolean require param ) { if ( require param ) { property |= require ; } else { property & = ~required ; } }
public int compute cardinality ( ) { return operand . get cardinality ( ) ; }
public void set language ( final string language ) { this . language = list . create ( language ) ; }
public int get construct type ( ) { return construct type ; }
public void set construct type ( int type ) { construct type = type ; }
public void set base property set ( base property set base property set ) { this . throw if readonly ( ) ; this . base property set = base property set ; }
public synchronize void set params ( http params params ) { default params = params ; }
public sequence type get require type ( ) { if ( require type ! =null ) { return require type ; } else { return sequence type . any_sequence ; } }
public http request with body ( body body ) { this . body = body ; return this ; }
public int get slot number ( ) { return slot number ; }
public instruction sequence get instruction sequence ( ) { return this . main sequence ; }
public value representation evaluate variable ( x path context context ) { return context . evaluate local variable ( slot number ) ; }
public list < extension config > get extension ( ) { return extension ; }
public iterator iterator ( ) { return new iterator ( ) ; }
public static java unicode escaper between ( final int codepoint low , final int codepoint high ) { return new java unicode escaper ( codepoint low , codepoint high , true ) ; }
public void set name code ( int name code ) { this . name code = name code ; }
public void start ( ) { }
public int get position ( ) { return position ; }
public int position ( ) { return 0 ; }
public option use ( use use ) { return using . and ( use ) ; }
public index [ ] index ( ) { return index ; }
public vector3 d get a2 ( ) { return a2 ; }
protect boolean be token separator ( char ch ) { return ( ch == ' , ' ) ; }
public static string get new q name ( javax . xml . namespace . q name qname ) { return `` new javax . xml . namespace . q name ( \ `` `` + qname . get namespace u r i ( ) + `` \ `` , \ `` `` + qname . get local part ( ) + `` \ `` ) `` ; }
public boolean be n c name start char ( int ch ) { return x m l character data . be n c name start10 ( ch ) ; }
public static void set default pool ( buffer pool pool ) { if ( pool == null ) { throw new illegal argument exception ( `` pool be null `` ) ; } default pool = pool ; }
public void set name code ( int name code ) { this . name code = name code ; }
public string get prefix ( ) { return prefix ; }
public object get data ( ) { return data ; }
public document get document ( ) { return document ; }
public string get attribute n s ( string namespace u r i , string local name ) { if ( namespace u r i == null ) { namespace u r i = `` `` ; } for ( int i = 0 ; i < attribute . get length ( ) ; i++ ) { if ( attribute . get u r i ( i ) . equal ( namespace u r i ) & & attribute . get local name ( i ) . equal ( local name ) ) { return attribute . get value ( i ) ; } } return null ; }
public boolean match ( node info node ) { int node kind = node . get node kind ( ) ; return ( node kind == type . element || node kind == type . text || node kind == type . comment || node kind == type . processing_instruction ) ; }
public string get system id ( ) { return system id ; }
public string get base u r i ( ) { return base u r i ; }
public final int compare to ( term other ) { if ( field . equal ( other . field ) ) { return byte . compare to ( other . byte ) ; } else { return field . compare to ( other . field ) ; } }
public void set name code ( int name code ) { this . name code = name code ; }
public object get root ( ) { return root ; }
public method bind shallow original ( ) { return original ( ) ; }
public method bind shallow original ( ) { return original ( ) ; }
public int get node kind ( ) { return original . get node kind ( ) ; }
public boolean be match ( ) { return match ; }
public item get item ( ) { return null ; }
public boolean equal ( object other ) { return this==other ; }
public void set filter ( boolean filter ) { this . filter = filter ; }
public int get fingerprint ( ) { return node test . get fingerprint ( ) ; }
public int get fingerprint ( ) { return node test . get fingerprint ( ) ; }
public x query function library get global function library ( ) { return global function library ; }
public string get prefix ( ) { return prefix ; }
public static synchronize name pool get default name pool ( ) { if ( default name pool == null ) { default name pool = new name pool ( ) ; } return default name pool ; }
public error listener get error listener ( ) { return option . get error listener ( ) ; }
public void set line number ( int line number ) { this . line number = line number ; }
protect void check compile ( ) { if ( ! be compile ( ) ) { logger . debug ( `` jdbc call call not compile before execution - invoking compile `` ) ; compile ( ) ; } }
public boolean be inherit namespaces ( ) { return inherit namespaces ; }
public string get mode ( ) { return mode ; }
public x query function get declaration ( structure q name function name , expression [ ] static args ) { for ( iterator it=library list . iterator ( ) ; it . have next ( ) ; ) { function library lib = ( function library ) it . next ( ) ; if ( lib instanceof x query function binder ) { x query function func = ( ( x query function binder ) lib ) . get declaration ( function name , static args ) ; if ( func ! = null ) { return func ; } } } return null ; }
public final set < namespace > get namespaces ( ) { return namespaces ; }
public boolean be force update ( ) { return this . be force update ; }
public void generate ( ) throw i o exception { } // generate
public item type get primitive item type ( ) { return this ; }
public slot manager get slot manager ( ) { return stack frame map ; }
public boolean be function ( ) { return this . function ; }
public int difference ( final string s1 , final string s2 ) throw encoder exception { return soundex utils . difference ( this , s1 , s2 ) ; }
public document get document ( ) { return document ; }
public int get cardinality ( ) { if ( expression == null ) { return static property . allows_zero_or_more ; } else { return expression . get cardinality ( ) ; } }
public void set key ( boolean value ) { this . key = value ; }
public node clear attribute ( ) { iterator < attribute > it = attribute ( ) . iterator ( ) ; while ( it . have next ( ) ) { it . next ( ) ; it . remove ( ) ; } return this ; }
protect void customize ( end point end point ) { }
public sort definition get sort ( ) { return this . sort ; }
public string get base u r i ( ) { return navigator . get base u r i ( this ) ; }
public string get expression ( ) { return expression ; }
public void set recovery module class name ( list < string > recovery module class name ) { synchronize ( this ) { if ( recovery module class name == null ) { this . recovery module = new array list < recovery module > ( ) ; this . recovery module class name = new array list < string > ( ) ; } else if ( ! recovery module class name . equal ( this . recovery module class name ) ) { this . recovery module = null ; this . recovery module class name = new array list < string > ( recovery module class name ) ; } } }
public string get name ( ) { return name ; }
public cancellable explain lifecycle async ( explain lifecycle request request , request option option , action listener < explain lifecycle response > listener ) { return rest high level client . perform request async and parse entity ( request , index lifecycle request converter : : explain lifecycle , option , explain lifecycle response : : from x content , listener , empty set ( ) ) ; }
public boolean mark support ( ) { return false ; }
public int get precedence ( ) { if ( be include ) return importer . get precedence ( ) ; return precedence ; }
public static value decimal get ( big integer big integer ) { if ( big integer . signum ( ) == 0 ) { return ( value decimal ) zero ; } else if ( big integer . one . equal ( big integer ) ) { return ( value decimal ) one ; } return ( value decimal ) value . cache ( new value decimal ( new big decimal ( big integer ) ) ) ; }
protect final boolean be support extension ( string namespace uri ) { return namespace uri . equal ( const . xjc_extension_uri ) || option . plugin u r be . contains ( namespace uri ) ; }
public q name get xml name ( ) { return null ; }
public namespace handler resolver get namespace handler resolver ( ) { if ( this . namespace handler resolver == null ) { this . namespace handler resolver = create default namespace handler resolver ( ) ; } return this . namespace handler resolver ; }
public slot manager get slot manager ( ) { return stack frame map ; }
public compilation unit set import ( final node list < import declaration > import ) { assert not null ( import ) ; if ( import == this . import ) { return this ; } notify property change ( observable property . import , this . import , import ) ; if ( this . import ! = null ) this . import . set parent node ( null ) ; this . import = import ; set a parent node of ( import ) ; return this ; }
public slot manager get slot manager ( ) { return stack frame map ; }
public void set require type ( sequence type type ) { require type = type ; }
public int get precedence ( ) { return get contain stylesheet ( ) . get precedence ( ) ; }
public int get precedence ( ) { if ( be include ) return importer . get precedence ( ) ; return precedence ; }
public int get precedence ( ) { return get contain stylesheet ( ) . get precedence ( ) ; }
public void set slot number ( int slot ) { slot number = slot ; }
public executable get executable ( ) { return executable ; }
public object get variable ( string qname ) { if ( qname == null ) { throw new null pointer exception ( `` null qname `` ) ; } if ( variable == null ) { return null ; } return variable . get ( qname ) ; }
public slot manager get slot manager ( ) { return stack frame map ; }
public configuration get configuration ( ) throw configuration exception { return get configuration ( true ) ; }
public void set x path context ( x path context context ) { this . context = context ; }
public boolean get global ( ) { return m global ; }
public value representation evaluate variable ( x path context context ) throw x path exception { throw new unsupported operation exception ( ) ; }
public void set length ( long length ) { this . length = length ; }
public void write escape ( boolean [ ] special char , writer writer ) throw java . io . i o exception { final long val = value ; for ( int s=56 ; s > =0 ; s-=8 ) { final byte b = ( byte ) ( ( val > > > s ) & 0xff ) ; if ( b == 0 ) { break ; } final char c = white_chars [ b > > > 6 & 0x3 ] ; final int len = ( b & 0x3f ) ; if ( special char [ c ] ) { string e = `` `` ; if ( c=='\n ' ) { e = `` & # x a ; `` ; } else if ( c=='\r ' ) { e = `` & # x d ; `` ; } else if ( c=='\t ' ) { e = `` & # x9 ; `` ; } for ( int j=0 ; j < len ; j++ ) { writer . write ( e ) ; } } else { for ( int j=0 ; j < len ; j++ ) { writer . write ( c ) ; } } } }
public void write ( writer writer ) throw java . io . i o exception { final long val = value ; for ( int s=56 ; s > =0 ; s-=8 ) { final byte b = ( byte ) ( ( val > > > s ) & 0xff ) ; if ( b == 0 ) { break ; } final char c = white_chars [ b > > > 6 & 0x3 ] ; final int len = ( b & 0x3f ) ; for ( int j=0 ; j < len ; j++ ) { writer . write ( c ) ; } } }
public str builder insert ( int index , char char [ ] , int offset , int length ) { validate index ( index ) ; if ( char == null ) { return insert ( index , null text ) ; } if ( offset < 0 || offset > char . length ) { throw new string index out of bound exception ( `` invalid offset : `` + offset ) ; } if ( length < 0 || offset + length > char . length ) { throw new string index out of bound exception ( `` invalid length : `` + length ) ; } if ( length > 0 ) { ensure capacity ( size + length ) ; system . arraycopy ( buffer , index , buffer , index + length , size - index ) ; system . arraycopy ( char , offset , buffer , index , length ) ; size += length ; } return this ; }
public int get return code ( ) { return return code ; }
public configuration node get parent node ( ) { return parent ; }
public node info get parent ( ) { return tree . get node ( tree . att parent [ node nr ] ) ; }
public boolean match ( node info node ) { int node kind = node . get node kind ( ) ; return ( node kind == type . element || node kind == type . text || node kind == type . comment || node kind == type . processing_instruction ) ; }
public final string get string value ( ) { return get string value c s ( ) . to string ( ) ; }
public string get system id ( ) { return system id ; }
public void set line number ( int line number ) { this . line number = line number ; }
public void end element ( q name element , augmentation augs ) throw x n i exception { end element ( element , aug , false ) ; }
public item get item ( ) { return null ; }
public void set trace enable ( boolean trace enable ) { this . trace enable = trace enable ; if ( this . trace enable & & ( this . trace listener == null ) ) { this . trace listener = new ew trace listener ( ) ; } }
public static class loader get class loader ( string class name ) { if ( class name == null ) { return null ; } return ( class loader ) classloaders . get ( class name ) ; }
public boolean be match backwards ( ) { return match backwards ; }
public boolean equal ( object other ) { return this==other ; }
public option use ( use use ) { return using . and ( use ) ; }
public string get mode ( ) { return mode ; }
public context get context ( ) { return impl . get context ( ) ; }
public iterator < node > get precede sibling axis iterator ( object context node ) { return new node iterator ( ( node ) context node ) { @ override protect node get first node ( node node ) { return get next node ( node ) ; } @ override protect node get next node ( node node ) { return get previous sibling ( node ) ; } } ; }
public void set line number ( int line number ) { this . line number = line number ; }
public void set factory ( j d o m factory factory ) { this . factory = factory ; }
public void end current item ( item item ) { ( ( trace listener ) a ) . end current item ( item ) ; ( ( trace listener ) b ) . end current item ( item ) ; }
public int get position ( ) { return position ; }
public schema type get build in base type ( ) { return this ; }
public boolean be null type ( ) { return false ; }
public schema type get build in base type ( ) { return this ; }
public block [ ] basic block ( ) { return basic block ; }
public boolean be enable ( ) { return true ; }
public schema type get build in base type ( ) { return this ; }
public boolean be map ( object obj ) { return ( obj instanceof map ) ; }
public void set configuration ( hierarchical configuration config ) { configuration = config ; }
public string get constraint reference ( ) { return constraint name + ' . ' + constraint clause number ; }
public void set constraint reference ( int schema part , string constraint name , string clause ) { this . schema part = schema part ; this . constraint name = constraint name ; this . constraint clause number = clause ; }
public iterator iterator ( ) { return new iterator ( ) ; }
public boolean region match ( boolean ignore case , int this start , char sequence string , int start , int length ) { if ( ! ignore case ) { return region match ( this start , string , start , length ) ; } object util . check not null ( string , `` string `` ) ; final int this len = length ( ) ; if ( this start < 0 || length > this len - this start ) { return false ; } if ( start < 0 || length > string . length ( ) - start ) { return false ; } this start += array offset ( ) ; final int this end = this start + length ; while ( this start < this end ) { if ( ! equal ignore case ( b2c ( value [ this start++ ] ) , string . char at ( start++ ) ) ) { return false ; } } return true ; }
public string get value ( ) { return value ; }
public string get timezone ( ) { return this . timezone ; } // -- string get timezone ( )
protect int compute cardinality ( ) { return static property . allows_zero_or_more ; }
public string get product ( ) { return product ; }
public void set timeout ( int timeout ) { this . timeout = timeout ; }
public int get status ( ) { return status ; }
public string get action ( ) { return action ; }
public log get logger ( ) { return logger ; }
public for stmt set compare ( final expression compare ) { if ( compare == this . compare ) { return this ; } notify property change ( observable property . compare , this . compare , compare ) ; if ( this . compare ! = null ) this . compare . set parent node ( null ) ; this . compare = compare ; set a parent node of ( compare ) ; return this ; }
public int get minor version ( ) { return minor version ; }
public void set sock proxy port ( int port ) { this . sock proxy port = port ; }
public static command < string > get request post data ( request id request id ) { object . require non null ( request id , `` request id must be set . `` ) ; return new command < > ( domain_name + `` . get request post data `` , immutable map . of ( `` request id `` , request id . to string ( ) ) , map ( `` post data `` , string . class ) ) ; }
public int get line number ( ) { return line number ; }
public double get priority ( ) { return priority ; }
public void set other link ( final list < link > other link ) { this . other link = other link ; }
public boolean get from service worker ( ) { return from service worker ; }
public string get url ( ) { return url ; }
public int get status ( ) { return status ; }
public double get worker start ( ) { return worker start ; }
public string get protocol ( ) { return this . protocol ; } // -- string get protocol ( )
public boolean be valid ( ) { return valid ; }
public void set certificate ( boolean certificate ) { this . certificate = certificate ; }
public error get error ( ) { return this . error ; }
public allocation command get command ( ) { return command ; }
public int get origin ( ) { return origin ; }
public static command < stream handle > take response body a stream ( request id request id ) { object . require non null ( request id , `` request id be require `` ) ; return new command < > ( `` fetch . take response body a stream `` , immutable map . of ( `` request id `` , request id . to string ( ) ) , map ( `` stream `` , stream handle . class ) ) ; }
public string get pattern ( ) { return pattern ; }
public static command < string > get request post data ( request id request id ) { object . require non null ( request id , `` request id must be set . `` ) ; return new command < > ( domain_name + `` . get request post data `` , immutable map . of ( `` request id `` , request id . to string ( ) ) , map ( `` post data `` , string . class ) ) ; }
public void web socket ( string path , object handler ) { add web socket handler ( path , new web socket handler instance wrapper ( handler ) ) ; }
public static command < void > dispose browser context ( browser context i d browser context i d ) { object . require non null ( browser context i d , `` browser context id be require `` ) ; return new command < > ( `` target . dispose browser context `` , immutable map . of ( `` browser context id `` , browser context i d ) ) ; }
public static command < list < browser context i d > > get browser context ( ) { return new command < > ( `` target . get browser context `` , immutable map . of ( ) , converter function . map ( `` browser context id `` , new type token < list < browser context i d > > ( ) { } . get type ( ) ) ) ; }
public void register value target ( target target ) { if ( target == null ) { target = new vector ( ) ; } target . add element ( target ) ; }
public string get attribute ( string key ) { return f attribute map . get ( key ) ; }
public iterator iterator ( ) { return new iterator ( ) ; }
public set < string > get application type ( ) { return collection . unmodifiable set ( application type ) ; }
public string get file ( ) { return file ; }
public static int size ( object list ) { if ( list == null ) return 0 ; if ( list instanceof list ) return ( ( list < ? > ) list ) . size ( ) ; return 1 ; }
public string get proxy ( ) { return proxy ; }
public boolean be cache ( ) { return cache ! = null ; }
public void set page ( p d page page ) { this . page = page ; }
public string get url ( ) { return url ; }
public static expect condition < web element > element to be clickable ( final by locator ) { return new expect condition < web element > ( ) { @ override public web element apply ( web driver driver ) { web element element = visibility of element locate ( locator ) . apply ( driver ) ; try { if ( element ! = null & & element . be enable ( ) ) { return element ; } return null ; } catch ( stale element reference exception e ) { return null ; } } @ override public string to string ( ) { return `` element to be clickable : `` + locator ; } } ; }
public static expect condition < web element > element to be clickable ( final by locator ) { return new expect condition < web element > ( ) { @ override public web element apply ( web driver driver ) { web element element = visibility of element locate ( locator ) . apply ( driver ) ; try { if ( element ! = null & & element . be enable ( ) ) { return element ; } return null ; } catch ( stale element reference exception e ) { return null ; } } @ override public string to string ( ) { return `` element to be clickable : `` + locator ; } } ; }
public static expect condition < web element > visibility of ( final web element element ) { return new expect condition < web element > ( ) { @ override public web element apply ( web driver driver ) { return element if visible ( element ) ; } @ override public string to string ( ) { return `` visibility of `` + element ; } } ; }
public string get condition ( ) { return condition ; }
public final observable < t > throttle with timeout ( long timeout , time unit unit ) { return debounce ( timeout , unit ) ; }
public static boolean be calendar datatype ( uri datatype ) { return datatype . equal ( x m l schema . datetime ) || datatype . equal ( x m l schema . date ) || datatype . equal ( x m l schema . time ) || datatype . equal ( x m l schema . gyearmonth ) || datatype . equal ( x m l schema . gmonthday ) || datatype . equal ( x m l schema . gyear ) || datatype . equal ( x m l schema . gmonth ) || datatype . equal ( x m l schema . gday ) ; }
public static boolean be calendar datatype ( uri datatype ) { return datatype . equal ( x m l schema . datetime ) || datatype . equal ( x m l schema . date ) || datatype . equal ( x m l schema . time ) || datatype . equal ( x m l schema . gyearmonth ) || datatype . equal ( x m l schema . gmonthday ) || datatype . equal ( x m l schema . gyear ) || datatype . equal ( x m l schema . gmonth ) || datatype . equal ( x m l schema . gday ) ; }
public static boolean be integer datatype ( uri datatype ) { return datatype . equal ( x m l schema . integer ) || datatype . equal ( x m l schema . long ) || datatype . equal ( x m l schema . int ) || datatype . equal ( x m l schema . short ) || datatype . equal ( x m l schema . byte ) || datatype . equal ( x m l schema . non_positive_integer ) || datatype . equal ( x m l schema . negative_integer ) || datatype . equal ( x m l schema . non_negative_integer ) || datatype . equal ( x m l schema . positive_integer ) || datatype . equal ( x m l schema . unsigned_long ) || datatype . equal ( x m l schema . unsigned_int ) || datatype . equal ( x m l schema . unsigned_short ) || datatype . equal ( x m l schema . unsigned_byte ) ; }
public static string normalize ( string value , uri datatype ) { string result = value ; if ( datatype . equal ( x m l schema . decimal ) ) { result = normalize decimal ( value ) ; } else if ( datatype . equal ( x m l schema . integer ) ) { result = normalize integer ( value ) ; } else if ( datatype . equal ( x m l schema . negative_integer ) ) { result = normalize negative integer ( value ) ; } else if ( datatype . equal ( x m l schema . non_positive_integer ) ) { result = normalize non positive integer ( value ) ; } else if ( datatype . equal ( x m l schema . non_negative_integer ) ) { result = normalize non negative integer ( value ) ; } else if ( datatype . equal ( x m l schema . positive_integer ) ) { result = normalize positive integer ( value ) ; } else if ( datatype . equal ( x m l schema . long ) ) { result = normalize long ( value ) ; } else if ( datatype . equal ( x m l schema . int ) ) { result = normalize int ( value ) ; } else if ( datatype . equal ( x m l schema . short ) ) { result = normalize short ( value ) ; } else if ( datatype . equal ( x m l schema . byte ) ) { result = normalize byte ( value ) ; } else if ( datatype . equal ( x m l schema . unsigned_long ) ) { result = normalize unsigned long ( value ) ; } else if ( datatype . equal ( x m l schema . unsigned_int ) ) { result = normalize unsigned int ( value ) ; } else if ( datatype . equal ( x m l schema . unsigned_short ) ) { result = normalize unsigned short ( value ) ; } else if ( datatype . equal ( x m l schema . unsigned_byte ) ) { result = normalize unsigned byte ( value ) ; } else if ( datatype . equal ( x m l schema . float ) ) { result = normalize float ( value ) ; } else if ( datatype . equal ( x m l schema . double ) ) { result = normalize double ( value ) ; } else if ( datatype . equal ( x m l schema . boolean ) ) { result = normalize boolean ( value ) ; } else if ( datatype . equal ( x m l schema . datetime ) ) { result = normalize date time ( value ) ; } return result ; }
public static boolean be valid value ( string value , uri datatype ) { boolean result = true ; if ( datatype . equal ( x m l schema . decimal ) ) { result = be valid decimal ( value ) ; } else if ( datatype . equal ( x m l schema . integer ) ) { result = be valid integer ( value ) ; } else if ( datatype . equal ( x m l schema . negative_integer ) ) { result = be valid negative integer ( value ) ; } else if ( datatype . equal ( x m l schema . non_positive_integer ) ) { result = be valid non positive integer ( value ) ; } else if ( datatype . equal ( x m l schema . non_negative_integer ) ) { result = be valid non negative integer ( value ) ; } else if ( datatype . equal ( x m l schema . positive_integer ) ) { result = be valid positive integer ( value ) ; } else if ( datatype . equal ( x m l schema . long ) ) { result = be valid long ( value ) ; } else if ( datatype . equal ( x m l schema . int ) ) { result = be valid int ( value ) ; } else if ( datatype . equal ( x m l schema . short ) ) { result = be valid short ( value ) ; } else if ( datatype . equal ( x m l schema . byte ) ) { result = be valid byte ( value ) ; } else if ( datatype . equal ( x m l schema . unsigned_long ) ) { result = be valid unsigned long ( value ) ; } else if ( datatype . equal ( x m l schema . unsigned_int ) ) { result = be valid unsigned int ( value ) ; } else if ( datatype . equal ( x m l schema . unsigned_short ) ) { result = be valid unsigned short ( value ) ; } else if ( datatype . equal ( x m l schema . unsigned_byte ) ) { result = be valid unsigned byte ( value ) ; } else if ( datatype . equal ( x m l schema . float ) ) { result = be valid float ( value ) ; } else if ( datatype . equal ( x m l schema . double ) ) { result = be valid double ( value ) ; } else if ( datatype . equal ( x m l schema . boolean ) ) { result = be valid boolean ( value ) ; } else if ( datatype . equal ( x m l schema . datetime ) ) { result = be valid date time ( value ) ; } else if ( datatype . equal ( x m l schema . date ) ) { result = be valid date ( value ) ; } else if ( datatype . equal ( x m l schema . time ) ) { result = be valid time ( value ) ; } else if ( datatype . equal ( x m l schema . gday ) ) { result = be valid g day ( value ) ; } else if ( datatype . equal ( x m l schema . gmonth ) ) { result = be valid g month ( value ) ; } else if ( datatype . equal ( x m l schema . gmonthday ) ) { result = be valid g month day ( value ) ; } else if ( datatype . equal ( x m l schema . gyear ) ) { result = be valid g year ( value ) ; } else if ( datatype . equal ( x m l schema . gyearmonth ) ) { result = be valid g year month ( value ) ; } else if ( datatype . equal ( x m l schema . duration ) ) { result = be valid duration ( value ) ; } else if ( datatype . equal ( x m l schema . daytimeduration ) ) { result = be valid day time duration ( value ) ; } else if ( datatype . equal ( x m l schema . qname ) ) { result = be valid q name ( value ) ; } return result ; }
public static string normalize ( string path ) { return normalize ( path , true ) ; }
public float float value ( ) { return ( ( float ) numerator ) / ( ( float ) denominator ) ; }
public for stmt set compare ( final expression compare ) { if ( compare == this . compare ) { return this ; } notify property change ( observable property . compare , this . compare , compare ) ; if ( this . compare ! = null ) this . compare . set parent node ( null ) ; this . compare = compare ; set a parent node of ( compare ) ; return this ; }
public int path compare ( abstract tree iterator p ) { return path compare ( p , p . mode ) ; }
public static int parse int ( string s ) { s = trim plus sign ( s ) ; return integer . parse int ( s ) ; }
public static long parse long ( string s ) { s = trim plus sign ( s ) ; return long . parse long ( s ) ; }
public static int parse int ( string s ) { s = trim plus sign ( s ) ; return integer . parse int ( s ) ; }
public iterator iterator ( ) { return new iterator ( ) ; }
public static int get int value ( literal l , int fallback ) { try { return l . int value ( ) ; } catch ( number format exception e ) { return fallback ; } }
public static string get label ( literal l , string fallback ) { return l ! = null ? l . get label ( ) : fallback ; }
public void set fatal ( boolean fatal ) { }
public list < string > get command line ( string executable , string . . . argument ) { string builder sb = new string builder ( ) ; sb . append ( ' `` ' ) ; sb . append ( super . get command line ( executable , argument ) . get ( 0 ) ) ; sb . append ( ' `` ' ) ; return array . a list ( sb . to string ( ) ) ; }
public string get registry ( ) { return registry ; }
public setting get setting ( ) { return setting ; }
public list < string > get command line ( string executable , string . . . argument ) { string builder sb = new string builder ( ) ; sb . append ( ' `` ' ) ; sb . append ( super . get command line ( executable , argument ) . get ( 0 ) ) ; sb . append ( ' `` ' ) ; return array . a list ( sb . to string ( ) ) ; }
public string to string ( ) { final string buffer sb = new string buffer ( ) ; for ( int i = 0 ; i < component . length ; i++ ) { if ( i ! = 0 ) { sb . append ( ' . ' ) ; } sb . append ( component [ i ] ) ; } return sb . to string ( ) ; }
public static void set location info ( element e , locator loc ) { e . set attribute n s ( location namespace , `` loc : `` +system id , loc . get system id ( ) ) ; e . set attribute n s ( location namespace , `` loc : `` +column , integer . to string ( loc . get line number ( ) ) ) ; e . set attribute n s ( location namespace , `` loc : `` +line , integer . to string ( loc . get column number ( ) ) ) ; }
public int get first index ( ) { return first index ; }
public static boolean force delete ( file file ) { if ( ! file . exists ( ) ) { return true ; } if ( file . be directory ( ) ) { file [ ] file = file . list file ( ) ; if ( file ! = null ) { for ( int i = 0 ; i < file . length ; i++ ) { if ( ! force delete ( file [ i ] ) ) { return false ; } } } } return file . delete ( ) ; }
public void add pattern ( mime type type , string pattern ) throw mime type exception { this . add pattern ( type , pattern , false ) ; }
public charset get charset ( ) { return this . charset ; }
public int hash code ( ) { return name . hash code ( ) ; } // hash code
public void set text ( boolean text ) { this . text = text ; }
public string get text ( ) { return text ; }
public string get source ( ) { return source ; }
public void set text ( string text ) { this . text = text ; }
public string get text ( ) { return text ; }
public node text ( object text ) { return text ( string . value of ( text ) ) ; }
public void set debug ( boolean debug ) { this . debug = debug ; }
public int get user id ( ) { return this . user id ; }
public void set header name ( string header name ) { assert . have length ( header name , `` header name ca n't be null `` ) ; this . header name = header name ; }
public void close ( ) throw i o exception { if ( ! finish ) { finish ( ) ; } if ( ! close ) { buffer . close ( ) ; out . close ( ) ; close = true ; } }
protect void _report unsupported operation ( ) { throw new unsupported operation exception ( `` operation not support by parser of type `` +get class ( ) . get name ( ) ) ; }
public static string get default name from method ( method parent , collector collector ) { name name = parent . get annotation ( name . class ) ; if ( name == null ) { return null ; } if ( name . value ( ) == null || name . value ( ) . equal ( `` `` ) ) { collector . add throwable ( new illegal argument exception ( `` @ name on the provide method of a factory must have an explicit value `` ) ) ; } return name . value ( ) ; }
public releasable mark a use ( long keep alive in millis ) { ref count . inc ref ( ) ; try update keep alive ( keep alive in millis ) ; return releasables . release once ( ( ) - > { this . last access time . update and get ( curr - > math . max ( curr , now in millis ( ) ) ) ; ref count . dec ref ( ) ; } ) ; }
public void observe ( double amt ) { no label child . observe ( amt ) ; }
public static builder builder ( ) { return new builder ( ) ; }
public void dec ( double amt ) { no label child . dec ( amt ) ; }
public object get root ( ) { return root ; }
public int read ( char [ ] array , int offset , int length ) { if ( idx > = char sequence . length ( ) ) { return -1 ; } if ( array == null ) { throw new null pointer exception ( `` character array be miss `` ) ; } if ( length < 0 || offset < 0 || offset + length > array . length ) { throw new index out of bound exception ( `` array size= `` + array . length + `` , offset= `` + offset + `` , length= `` + length ) ; } int count = 0 ; for ( int i = 0 ; i < length ; i++ ) { int c = read ( ) ; if ( c == -1 ) { return count ; } array [ offset + i ] = ( char ) c ; count++ ; } return count ; }
public void write ( short [ ] f , int off , int len ) throw i o exception { raw write ( f , off * 2 , len * 2 ) ; }
public void write ( float [ ] f , int off , int len ) throw i o exception { raw write ( f , off * 4 , len * 4 ) ; }
public void add servlet name ( string . . . servlet names ) { assert . not null ( servlet name , `` servlet name must not be null `` ) ; this . servlet name . add all ( array . a list ( servlet name ) ) ; }
public void delete ( string from path , string to path ) { delete ( from path , to path , null ) ; }
public void get ( string from path , string to path ) { get ( from path , to path , null ) ; }
public int get status ( ) { return status ; }
public route [ ] get route ( ) { return route ; }
public void set method ( int method ) { this . method = method ; }
public int get port ( ) { return this . port ; }
public index writer config set max thread state ( int max thread state ) { this . indexer thread pool = new thread affinity document writer thread pool ( max thread state ) ; return this ; }
public static event < web socket create > web socket create ( ) { return new event < > ( domain_name + `` . web socket create `` , map ( `` request id `` , web socket create . class ) ) ; }
public object get attribute ( string attribute name ) { return attribute map . get ( attribute name ) ; }
public void set up ( ) { }
public void set page size ( int page size ) { if ( page size ! = this . page size ) { this . page size = page size ; if ( ! this . new page set ) { this . page = 0 ; } } }
public static memory block from long array ( final long [ ] array ) { return new memory block ( array , platform . long_array_offset , array . length * 8l ) ; }
public void set encrypt spill key ( byte [ ] encrypt spill key ) { if ( encrypt spill key ! = null ) { this . encrypt spill key = encrypt spill key ; } }
public void set page ( p d page page ) { this . page = page ; }
public string get home page ( ) { return home page ; }
public string get id ( ) { return id ; }
public int get invoke dynamic bootstrap ( int index ) { invoke dynamic info iv = ( invoke dynamic info ) get item ( index ) ; return iv . bootstrap ; }
public void add first ( character c ) { add first ( c . to string ( ) ) ; }
public string get escape password ( ) { char [ ] password = get raw password ( ) ; return ( password == null ) ? null : new string ( password ) ; }
public transport client add transport address ( transport address . . . transport address ) { nodes service . add transport address ( transport address ) ; return this ; }
protect long write ( random access reader reader , checksum validator validator , int start , long length , long byte transfer ) throw i o exception { int to transfer = ( int ) math . min ( transfer buffer . length , length - byte transfer ) ; int min readable = ( int ) math . min ( transfer buffer . length , reader . length ( ) - reader . get file pointer ( ) ) ; reader . read fully ( transfer buffer , 0 , min readable ) ; if ( validator ! = null ) validator . validate ( transfer buffer , 0 , min readable ) ; limiter . acquire ( to transfer - start ) ; compress output . write ( transfer buffer , start , ( to transfer - start ) ) ; return to transfer ; }
public byte to byte ( ) { return new byte ( byte value ( ) ) ; }
public int get timeout ( ) { return timeout ; }
public void set id ( string id ) { this . id = id ; }
public submodule update command set fetch ( boolean fetch ) { this . fetch = fetch ; return this ; }
public void free array ( long array array ) { free page ( array . memory block ( ) ) ; }
public byte [ ] get ( ) { if ( bytes == null ) { byte = new byte [ 0 ] ; } return byte ; }
public int length ( object obj ) { if ( be array ( obj ) ) { return ( ( list ) obj ) . size ( ) ; } else if ( be map ( obj ) ) { return get property key ( obj ) . size ( ) ; } else if ( obj instanceof string ) { return ( ( string ) obj ) . length ( ) ; } throw new json path exception ( `` length operation can not be apply to `` + obj ! =null ? obj . get class ( ) . get name ( ) : `` null `` ) ; }
public boolean be updatable ( ) { return updatable ; }
public void set creator ( final list < string > creator ) { creator = creator ; }
public integer get query timeout ( ) { return query timeout ; }
public int get skip count ( ) { return skip count ; }
public void set require ( boolean require ) { this . require = require ; }
public static boolean be cql compatible ( c f meta data meta data ) { if ( meta data . be super ( ) ) return false ; if ( meta data . be compact table ( ) & & meta data . partition column ( ) . without static ( ) . size ( ) > 1 & & meta data . cluster column ( ) . size ( ) > = 1 ) return false ; return true ; }
public int get sql type ( ) { return this . sql type ; }
public boolean support schemas in procedure call ( ) { debug code call ( `` support schema in procedure call `` ) ; return true ; }
protect void set support schemas in procedure call ( boolean support schema in procedure call ) { this . support schema in procedure call = support schema in procedure call ; }
public string get table name ( ) { return this . table name ; }
public void set table name ( @ nullable string table name ) { this . table name = table name ; }
public void set local override ( boolean local override ) { this . local override = local override ; }
public int get sql type ( ) { return this . sql type ; }
public static < t > param < t > param ( string name , field < t > type ) { return param ( name , type . get data type ( ) ) ; }
public final jdbc template get jdbc template ( ) { return this . jdbc template ; }
public final string sql ( ) { return sql ; }
public boolean be function ( ) { return this . function ; }
public void set return value require ( boolean return value require ) { this . return value require = return value require ; }
public string get parameter name ( ) { return parameter name ; }
public compile s t compile ( string name , string template ) { compile s t code = compile ( null , name , null , template , null ) ; code . have formal args = false ; return code ; }
public jdbc operation get jdbc operation ( ) { return this . classic jdbc template ; }
public void set password ( string password ) { this . password = password ; }
public void set actual transaction active ( boolean active ) { this . transaction context . set actual transaction active ( active ) ; }
public counter get task counter ( ) { return counter ; }
public void set data source ( final data source data source ) { this . data source = data source ; }
public void release connection ( ) { log . trace ( `` enter http connection . release connection ( ) `` ) ; if ( lock ) { log . debug ( `` connection be lock . call to release connection ( ) ignore . `` ) ; } else if ( http connection manager ! = null ) { log . debug ( `` release connection back to connection manager . `` ) ; http connection manager . release connection ( this ) ; } else { log . warn ( `` http connection manager be null . connection can not be release . `` ) ; } }
public database meta data get delegate ( ) { return database meta data ; }
public final void set isolation level ( int isolation level ) { if ( ! constant . get value ( prefix_isolation ) . contains ( isolation level ) ) { throw new illegal argument exception ( `` only value of isolation constant allow `` ) ; } this . isolation level = isolation level ; }
public void set read only ( boolean read only ) { if ( this . read only ! =read only ) { this . read only = read only ; fire property change ( read_only_property , ! read only , read only ) ; } }
public final void set isolation level ( int isolation level ) { if ( ! constant . get value ( prefix_isolation ) . contains ( isolation level ) ) { throw new illegal argument exception ( `` only value of isolation constant allow `` ) ; } this . isolation level = isolation level ; }
public void set lenient ( boolean lenient ) { this . lenient = lenient ; }
public data source get data source ( ) { return this . data source ; }
public string get driver class ( ) { return driver class ; }
public boolean be close ( ) { return close ; }
public void set username ( string username ) { this . username = username ; } // -- void set username ( string )
public vector aggregate row ( vector function f ) { vector r = new dense vector ( num row ( ) ) ; int n = num row ( ) ; for ( int row = 0 ; row < n ; row++ ) { r . set ( row , f . apply ( view row ( row ) ) ) ; } return r ; }
public void add declare parameter ( sql parameter parameter ) { assert . not null ( parameter , `` the supplied parameter must not be null `` ) ; if ( ! string utils . have text ( parameter . get name ( ) ) ) { throw new invalid data access api usage exception ( `` you must specify a parameter name when declare parameter for \ `` `` + get procedure name ( ) + `` \ `` `` ) ; } this . declared parameter . add ( parameter ) ; if ( logger . be debug enable ( ) ) { logger . debug ( `` add declared parameter for [ `` + get procedure name ( ) + `` ] : `` + parameter . get name ( ) ) ; } }
public type find function return type ( string function name , ast first ) { s q l function sql function = require s q l function ( function name ) ; return find function return type ( function name , sql function , first ) ; }
public void execute ( ) throw build exception { if ( double file pas ) { skip write = true ; execute main ( ) ; skip write = false ; execute main ( ) ; } else { execute main ( ) ; } }
public synchronize void set params ( http params params ) { default params = params ; }
public boolean be update ( ) { return be update ; }
public void add declare parameter ( sql parameter parameter ) { assert . not null ( parameter , `` the supplied parameter must not be null `` ) ; if ( ! string utils . have text ( parameter . get name ( ) ) ) { throw new invalid data access api usage exception ( `` you must specify a parameter name when declare parameter for \ `` `` + get procedure name ( ) + `` \ `` `` ) ; } this . declared parameter . add ( parameter ) ; if ( logger . be debug enable ( ) ) { logger . debug ( `` add declared parameter for [ `` + get procedure name ( ) + `` ] : `` + parameter . get name ( ) ) ; } }
public void set specific catalog ( string value ) { this . specific catalog = value ; }
public boolean support position update ( ) { debug code call ( `` support position update `` ) ; return true ; }
public default void init ( ) { }
public result get result ( ) { return result ; }
public void set always create ( boolean always create ) { this . always create = always create ; }
public static void check spec ( ) { }
public synchronize boolean proxy equal ( final http connection connection ) { if ( connection == null ) { throw new illegal argument exception ( `` connection may not be null `` ) ; } if ( this . proxy host ! = null ) { return this . proxy host . get host name ( ) . equal ignore case ( connection . get proxy host ( ) ) & & this . proxy host . get port ( ) == connection . get proxy port ( ) ; } else { return connection . get proxy host ( ) == null ; } }
public void set factory ( j d o m factory factory ) { this . factory = factory ; }
public spring application builder context class ( class < ? extend configurable application context > cl ) { this . application . set application context class ( cl ) ; return this ; }
public void destroy ( ) { for ( endpoint endpoint : this . publish endpoint ) { endpoint . stop ( ) ; } }
public boolean get delegate ( ) { return this . delegate ; }
public object get attribute ( string attribute name ) { return attribute map . get ( attribute name ) ; }
public void set transaction manager name ( string transaction manager name ) { this . transaction manager name = transaction manager name ; }
public void set transaction manager ( @ nullable transaction manager transaction manager ) { this . transaction manager = transaction manager ; }
public boolean be flush ( ) { return flush ; }
protect void set transaction active ( boolean transaction active ) { this . transaction active = transaction active ; }
public int get transaction status manager port ( ) { return transaction status manager port ; }
public void set transaction manager ( @ nullable transaction manager transaction manager ) { this . transaction manager = transaction manager ; }
protect void cleanup ( ) { }
public integer get previous isolation level ( ) { return this . previous isolation level ; }
public boolean be rollback only ( ) { return this . rollback only ; }
protect final boolean be rollback ( test context test context ) throw exception { boolean rollback = be default rollback ( test context ) ; rollback rollback annotation = annotate element utils . find merged annotation ( test context . get test method ( ) , rollback . class ) ; if ( rollback annotation ! = null ) { boolean rollback override = rollback annotation . value ( ) ; if ( logger . be debug enable ( ) ) { logger . debug ( string . format ( `` method-level @ rollback ( % s ) override default rollback [ % s ] for test context % s . `` , rollback override , rollback , test context ) ) ; } rollback = rollback override ; } else { if ( logger . be debug enable ( ) ) { logger . debug ( string . format ( `` no method-level @ rollback override : use default rollback [ % s ] for test context % s . `` , rollback , test context ) ) ; } } return rollback ; }
public boolean have deadline ( ) { return have deadline ; }
public void reset ( ) { this . element= null ; }
public void pause ( ) { write lock . lock ( ) ; try { be active = false ; } finally { write lock . unlock ( ) ; } }
public byte to byte ( ) { return new byte ( byte value ( ) ) ; }
public int read ( ) throw i o exception { int b = in . read ( ) ; if ( b ! = -1 ) { hasher . put byte ( ( byte ) b ) ; } return b ; }
public charset get charset ( ) { return this . charset ; }
protect void check compile ( ) { if ( ! be compile ( ) ) { logger . debug ( `` jdbc call call not compile before execution - invoking compile `` ) ; compile ( ) ; } }
public object invoke ( string method name , class arg type , object arg ) { return reflect util . invoke ( obj , method name , arg type , arg ) ; }
public url [ ] get u r l array ( string key ) { return get u r l array ( key , new url [ 0 ] ) ; }
public string to string ( ) { final string buffer sb = new string buffer ( ) ; for ( int i = 0 ; i < component . length ; i++ ) { if ( i ! = 0 ) { sb . append ( ' . ' ) ; } sb . append ( component [ i ] ) ; } return sb . to string ( ) ; }
public static string to string exclude ( object object , final string exclude field name ) { return to string exclude ( object , new string [ ] { exclude field name } ) ; }
public static annotation [ ] get resource annotation ( method method ) { map < class < ? > , annotation > annotation = new hash map < class < ? > , annotation > ( ) ; for ( annotation annotation : method . get declare class ( ) . get annotation ( ) ) { annotation . put ( annotation . get class ( ) , annotation ) ; } for ( annotation annotation : method . get annotation ( ) ) { annotation . put ( annotation . get class ( ) , annotation ) ; } return annotation . value ( ) . to array ( new annotation [ annotation . size ( ) ] ) ; }
public string get url ( ) { return url ; }
public schema export set format ( boolean format ) { this . format = format ; return this ; }
public int get minimum length ( ) { return minimum length ; }
public int get max path length ( ) { return max path length ; }
public string get pattern ( ) { return pattern ; }
public void set additional type ( list < medium type > additional type ) { this . additional type = additional type ; }
public string get xml ( ) { return xml ; }
public string get type ( ) { return type ; }
public string namespace ( ) { return the namespace ; }
public void set prefix ( string prefix ) { this . prefix = prefix ; } // -- void set prefix ( string )
public boolean be external ( ) { return external ; }
public void set in ( input stream in ) { this . in = in ; }
public ref exact ref ( string name ) throw i o exception { ref ref = get ref ( name ) ; if ( ref == null || ! name . equal ( ref . get name ( ) ) ) { return null ; } return ref ; }
public authorization code get authorization code ( ) { return code ; }
public credential scope get credential scope ( ) { return credential scope ; }
public string get url ( ) { return url ; }
public void set page ( p d page page ) { this . page = page ; }
public synchronize void leave ( ) throw exception { leave ( -1 , null ) ; }
public void digest ( message digest digest ) { f b utility . update with long ( digest , timestamp ( ) ) ; }
public boolean be condition ( ) { return true ; }
public string get ae descriptor path ( ) { return ae descriptor path ; }
public static void assert equal ( short actual , short expect , string message ) { assert equal ( short . value of ( actual ) , short . value of ( expect ) , message ) ; }
public string get short message ( ) { return short message ; }
static public void assert null ( string message , object object ) { assert true ( message , object == null ) ; }
protect void expect content ( collection < e > expect ) { helper . assert equal ignoring order ( expect , actual content ( ) ) ; }
public double get priority ( ) { return priority ; }
public void set method ( int method ) { this . method = method ; }
public void trace ( char sequence message ) { this . log . trace ( message ) ; }
public void trace ( object message ) { debug ( message ) ; }
static public test result run ( test test ) { test runner runner= new test runner ( ) ; return runner . do run ( test ) ; }
public string get parameter name ( ) { return parameter name ; }
public void set output directory ( string output directory ) { this . output directory = output directory ; } // -- void set output directory ( string )
public boolean be boolean ( ) { return false ; }
public file get dir ( ) { return dir ; }
public double get worker start ( ) { return worker start ; }
public void set verbose ( integer verbose ) { m_verbose = verbose ; }
public void set verbose ( boolean verbose ) { this . verbose = verbose ; }
public enumeration < test > test ( ) { return f test . element ( ) ; }
public static class get class ( string class name ) throw class not find exception { return get class ( class name , true ) ; }
public static value result set get ( simple result result ) { return new value result set ( result ) ; }
public static string format date time ( java . util . date date , string format , string locale , string time zone ) { simple date format date format = get date format ( format , locale , time zone ) ; synchronize ( date format ) { return date format . format ( date ) ; } }
public long time ( @ non null time unit unit ) { return unit . convert ( time , this . unit ) ; }
public duration get wait time ( ) { return new duration ( wait nanos , time unit . nanosecond ) ; }
public int size ( ) { return size ; }
public static int max element ( double load factor ) { check load factor ( load factor , 0 , 1 ) ; return expand at count ( max_hash_array_length , load factor ) - 1 ; }
public boolean have next ( ) { return ( this . next obj ! = null ) ; }
public int hash code ( ) { int hash = 0 ; for ( int i = 0 ; i < token . length ; i++ ) { hash += tokens [ i ] . hash code ( ) ; } return hash ; }
public collection < v > value ( ) { return super . value ( ) ; }
public static void no null element ( collection collection ) { validate . not null ( collection ) ; int i = 0 ; for ( iterator it = collection . iterator ( ) ; it . have next ( ) ; i++ ) { if ( it . next ( ) == null ) { throw new illegal argument exception ( `` the validated collection contain null element at index : `` + i ) ; } } }
public void clear ( ) { _list . clear ( ) ; }
public void clear ( ) { object . clear ( ) ; }
public int get index ( ) { return index ; }
public void set msg ( string msg ) { this . msg = msg ; }
public void set msg ( string msg ) { this . msg = msg ; }
public void set output ( string out ) { this . out = out ; }
public string to string ( ) { return `` c s v record [ comment= `` + comment + `` , mapping= `` + mapping + `` , record number= `` + record number + `` , values= `` + array . to string ( value ) + `` ] `` ; }
public static boolean parse boolean ( char sequence char ) { return ( char . length ( ) == 4 ) & & ( char . char at ( 0 ) == 't ' || char . char at ( 0 ) == 't ' ) & & ( char . char at ( 1 ) == ' r ' || char . char at ( 1 ) == ' r ' ) & & ( char . char at ( 2 ) == ' u ' || char . char at ( 2 ) == ' u ' ) & & ( char . char at ( 3 ) == ' e ' || char . char at ( 3 ) == ' e ' ) ; }
public final boolean be delimiter detection enable ( ) { return delimiter detection enable ; }
public void set field ( list < string > field ) { this . field = field ; }
public field set < string > select field ( string . . . field names ) { return set field set ( new field name selector ( ) , field name ) ; }
public void lock auto filter ( boolean enable ) { safe get protection field ( ) . set auto filter ( enable ) ; }
public setting get setting ( ) { return setting ; }
public int [ ] get column index ( ) { return column index ; }
public void set header name ( string header name ) { assert . have length ( header name , `` header name ca n't be null `` ) ; this . header name = header name ; }
public geo validation method get validation method ( ) { return this . validation method ; }
public int [ ] get column index ( ) { return column index ; }
public void delete bucket ( storage bucket bucket ) throw service exception { assert valid bucket ( bucket , `` delete bucket `` ) ; delete bucket impl ( bucket . get name ( ) ) ; }
public boolean region match ( boolean ignore case , int this start , char sequence string , int start , int length ) { if ( ! ignore case ) { return region match ( this start , string , start , length ) ; } object util . check not null ( string , `` string `` ) ; final int this len = length ( ) ; if ( this start < 0 || length > this len - this start ) { return false ; } if ( start < 0 || length > string . length ( ) - start ) { return false ; } this start += array offset ( ) ; final int this end = this start + length ; while ( this start < this end ) { if ( ! equal ignore case ( b2c ( value [ this start++ ] ) , string . char at ( start++ ) ) ) { return false ; } } return true ; }
public standard function . entry get detail ( ) { return detail ; }
public int get minimum length ( ) { return minimum length ; }
public setting get setting ( ) { return setting ; }
public void set length ( int length ) { count = length ; }
public void set row count property ( string row count property ) { this . row count property = row count property ; }
public content get content ( ) { return this . content ; }
public big decimal to big decimal ( ) { if ( text be empty or null ( ) ) { return null ; } return string groovy method . to big decimal ( ( char sequence ) text ( ) ) ; }
public void set input ( string input ) { this . input = input ; }
public void set input ( string input ) { this . input = input ; }
public string get delimiter ( ) { return this . delimiter ; }
public void set unescaped quote handling ( unescaped quote handle unescaped quote handle ) { this . unescaped quote handle = unescaped quote handling ; }
public final boolean be line separator detection enable ( ) { return line separator detection enable ; }
public void set parse unescaped quote until delimiter ( boolean parse unescaped quote until delimiter ) { if ( parse unescaped quote until delimiter ) { parse unescaped quote = true ; } this . parse unescaped quote until delimiter = parse unescaped quote until delimiter ; }
public static string quote ( string value ) { return quote ( value , '\ `` ) ; }
public static string quote ( string value ) { return quote ( value , '\ `` ) ; }
public trigger object find trigger ( string name ) { return trigger . get ( name ) ; }
public static boolean parse boolean ( char sequence char ) { return ( char . length ( ) == 4 ) & & ( char . char at ( 0 ) == 't ' || char . char at ( 0 ) == 't ' ) & & ( char . char at ( 1 ) == ' r ' || char . char at ( 1 ) == ' r ' ) & & ( char . char at ( 2 ) == ' u ' || char . char at ( 2 ) == ' u ' ) & & ( char . char at ( 3 ) == ' e ' || char . char at ( 3 ) == ' e ' ) ; }
public string get format ( ) { return format ; }
public static link hash set < character > of all ( char . . . element ) { object . require non null ( element , `` element be null `` ) ; return link hash set . of all ( iterator . of all ( element ) ) ; }
public void add stream ( stream stream ) { if ( this . stream == null ) { this . stream = new hash set < stream > ( ) ; } this . stream . add ( stream ) ; }
public static link hash set < integer > of all ( int . . . element ) { object . require non null ( element , `` element be null `` ) ; return link hash set . of all ( iterator . of all ( element ) ) ; }
public static link hash set < character > of all ( char . . . element ) { object . require non null ( element , `` element be null `` ) ; return link hash set . of all ( iterator . of all ( element ) ) ; }
public static tree set < integer > of all ( int . . . element ) { object . require non null ( element , `` element be null `` ) ; return tree set . of all ( iterator . of all ( element ) ) ; }
public static tree set < boolean > of all ( boolean . . . element ) { object . require non null ( element , `` element be null `` ) ; return tree set . of all ( iterator . of all ( element ) ) ; }
public static array < character > of all ( char . . . element ) { object . require non null ( element , `` element be null `` ) ; return of all ( iterator . of all ( element ) ) ; }
public void set timestamp ( final long timestamp ) { this . timestamp = timestamp ; }
public session get session ( ) { return this . session ; }
public web socket connect option add sub protocol ( string subprotocol ) { if ( sub protocol == null ) { sub protocol = new array list < > ( ) ; } sub protocol . add ( subprotocol ) ; return this ; }
public list < string > get extension ( ) { return extension ; }
public string to string ( ) { return format . format annotate type ( this ) ; }
public string to string ( ) { return format . format annotate constructor ( this ) ; }
public int size ( ) { / * * it be possible for a thread to be interrupt or reschedule between the read of the producer and * consumer index , therefore protection be require to ensure size be within valid range . in the * event of concurrent polls/offers to this method the size be over estimate a we read consumer * index before the producer index . * / long after = lv consumer index ( ) ; while ( true ) { final long before = after ; final long current producer index = lv producer index ( ) ; after = lv consumer index ( ) ; if ( before == after ) { return ( int ) ( current producer index - after ) ; } } }
public void fire event ( object event , annotation . . . qualifier ) { precondition . check argument not null ( event , `` event `` ) ; type event type = type . get canonical type ( event . get class ( ) ) ; event metadata metadata = new event metadata impl ( event type , null , qualifier ) ; global strict observer notifier . fire event ( event , metadata , qualifier ) ; }
public xml get xml ( ) { return xml ; }
public item get item ( ) { return null ; }
public static transport request unwrap request ( transport request request ) { if ( request instanceof proxy request ) { return ( ( proxy request ) request ) . wrap ; } return request ; }
public t get instance ( ) { return instance ; }
public < t > void notify ( resolved observer < t > observer , t event , event metadata metadata ) { if ( ! observer . be metadata require ( ) ) { metadata = null ; } notify sync observer ( observer . get immediate sync observer ( ) , event , metadata , observer exception handler . immediate_handler ) ; notify transaction observer ( observer . get transaction observer ( ) , event , metadata , observer exception handler . immediate_handler ) ; }
public boolean be resolve ( ) { return resolve ; }
public static < t > fast event < t > of ( class < t > type , bean manager impl manager , observer notifier notifier , annotation . . . qualifier ) { resolved observer < t > resolve observer method = notifier . < t > resolve observer method ( type , qualifier ) ; if ( resolve observer method . be metadata require ( ) ) { event metadata metadata = new event metadata impl ( type , null , qualifier ) ; current event metadata metadata service = manager . get service ( ) . get ( current event metadata . class ) ; return new fast event with metadata propagation < t > ( resolve observer method , metadata , metadata service ) ; } else { return new fast event < t > ( resolve observer method ) ; } }
public void cleanup ( ) { }
public void fire event ( type event type , object event , annotation . . . qualifier ) { final event metadata metadata = new event metadata impl ( event type , null , qualifier ) ; notifier . fire event ( event type , event , metadata , qualifier ) ; }
public void add bean name resolver ( bean name resolver bean name resolver ) { get e l context ( ) . add e l resolver ( new bean name e l resolver ( bean name resolver ) ) ; }
public boolean be valid ( ) { return valid ; }
public void set bind type ( string bind type ) { this . bind type = bind type ; }
public static builder builder ( ) { return new builder ( ) ; }
public boolean contain all ( collection < ? > collection ) { for ( iterator i = collection . iterator ( ) ; i . have next ( ) ; ) { if ( ! contains ( i . next ( ) ) ) { return false ; } } return true ; }
public < t > void notify ( resolved observer < t > observer , t event , event metadata metadata ) { if ( ! observer . be metadata require ( ) ) { metadata = null ; } notify sync observer ( observer . get immediate sync observer ( ) , event , metadata , observer exception handler . immediate_handler ) ; notify transaction observer ( observer . get transaction observer ( ) , event , metadata , observer exception handler . immediate_handler ) ; }
public static boolean parse boolean ( char sequence char ) { return ( char . length ( ) == 4 ) & & ( char . char at ( 0 ) == 't ' || char . char at ( 0 ) == 't ' ) & & ( char . char at ( 1 ) == ' r ' || char . char at ( 1 ) == ' r ' ) & & ( char . char at ( 2 ) == ' u ' || char . char at ( 2 ) == ' u ' ) & & ( char . char at ( 3 ) == ' e ' || char . char at ( 3 ) == ' e ' ) ; }
public string get argument ( ) throw build exception { string action = get task ( ) . get action ( ) ; string args = null ; if ( action . equal ( action_deploy ) || action . equal ( action_update ) ) { args = build deploy args ( ) ; } else if ( action . equal ( action_delete ) || action . equal ( action_undeploy ) ) { args = build undeploy args ( ) ; } else if ( action . equal ( action_list ) ) { args = build list args ( ) ; } return args ; }
public void set package ( boolean package ) { this . package = package ; } // -- void set package ( boolean )
public static object remove object property ( map property , string key , object default value ) { object value = default value ; if ( property ! = null & & property . contains key ( key ) ) { value = property . remove ( key ) ; } return value ; }
public set < object > get provider instance ( ) { return collection . unmodifiable set ( provider instance ) ; }
public r pattern get r context ( ) { return this . r context ; }
protect void purge before write ( ) { purge ( ) ; }
public file get dir ( ) { return dir ; }
public void set child ( hash set < string > child ) { this . child = child ; }
public void set size ( final long size ) { this . size = size ; }
public void set log ( log log ) { this . log = log ; }
public static void set prealloc size ( long size ) { pre alloc size = size ; }
public boolean be sync ( ) { return sync ; }
public json object get config ( ) { return config ; }
public void add child ( final object child ) { this . child . add ( child ) ; }
public void set watch ( long relative zxid , list < string > data watch , list < string > exist watch , list < string > child watch , watcher watcher ) { data tree . set watch ( relative zxid , data watch , exist watch , child watch , watcher ) ; }
public void add right ( acl acl ) throw message exception { set a c l ( acl , '+ ' ) ; }
public static stop watch create ( ) { return new stop watch ( ) ; }
public string get session id ( ) { return get ( `` session . id `` , `` `` ) ; }
public request spec builder set auth ( authentication scheme auth ) { spec . set authentication scheme ( auth ) ; return this ; }
public void shutdown ( ) { if ( log . be debug enable ( ) ) { log . debug ( `` enter : thread pool : : shutdown `` ) ; } synchronize ( this ) { _shutdown = true ; } interrupt all ( ) ; if ( log . be debug enable ( ) ) { log . debug ( `` exit : thread pool : : shutdown `` ) ; } }
protect socket get socket ( ) { return this . socket ; }
public allocation command get command ( ) { return command ; }
public void set redirect port ( int redirect port ) { this . redirect port = redirect port ; set property ( `` redirect port `` , string . value of ( redirect port ) ) ; }
public void remove ( listener listener ) { listener . remove ( listener ) ; }
public void set logger ( log logger ) { this . logger = logger ; }
