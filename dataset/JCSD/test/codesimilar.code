public string get human presentable name ( ) { return human presentable name ; }
public synchronize data handler get data handler ( ) throw message exception { if ( dh == null ) dh = new mime body part . mime part data handler ( new mime part data source ( this ) ) ; return dh ; }
public command info [ ] get preferred command ( ) { if ( data source ! = null ) return get command map ( ) . get preferred command ( get base type ( ) , data source ) ; else return get command map ( ) . get preferred command ( get base type ( ) ) ; }
public object get property ( string name ) { if ( `` name `` . equal ( name ) ) { return function name . get display name ( ) ; } else if ( `` a `` . equal ( name ) ) { return result type . to string ( ) ; } else { return null ; } }
public list < type parameter > get type parameter ( ) { return type parameter ; }
public int length ( ) { return name value pair . size ( ) ; }
public string to string ( int indent space ) throw j s o n exception { j s o n stringer stringer = new j s o n stringer ( indent space ) ; write to ( stringer ) ; return stringer . to string ( ) ; }
public static j s o n compare result compare j s o n ( string expect str , string actual str , j s o n comparator comparator ) throw j s o n exception { object expect = j s o n parser . parse j s o n ( expect str ) ; object actual = j s o n parser . parse j s o n ( actual str ) ; if ( ( expect instanceof j s o n object ) & & ( actual instanceof j s o n object ) ) { return compare j s o n ( ( j s o n object ) expect , ( j s o n object ) actual , comparator ) ; } else if ( ( expect instanceof j s o n array ) & & ( actual instanceof j s o n array ) ) { return compare j s o n ( ( j s o n array ) expect , ( j s o n array ) actual , comparator ) ; } else if ( expect instanceof j s o n string & & actual instanceof j s o n string ) { return compare json ( ( j s o n string ) expect , ( j s o n string ) actual ) ; } else if ( expect instanceof j s o n object ) { return new j s o n compare result ( ) . fail ( `` `` , expect , actual ) ; } else { return new j s o n compare result ( ) . fail ( `` `` , expect , actual ) ; } }
public void set thread context loader ( ) { if ( be context loader save ) { throw new build exception ( `` context loader have not be reset `` ) ; } if ( loader utils . be context loader available ( ) ) { save context loader = loader utils . get context class loader ( ) ; class loader loader = this ; if ( project ! = null & & `` only `` . equal ( project . get property ( `` build . sysclasspath `` ) ) ) { loader = this . get class ( ) . get class loader ( ) ; } loader utils . set context class loader ( loader ) ; be context loader save = true ; } }
public ct package get or create ( string qualify name , ct module root module ) { if ( qualified name . be empty ( ) ) { return root module . get root package ( ) ; } string tokenizer token = new string tokenizer ( qualified name , ct package . package_separator ) ; ct package last = root module . get root package ( ) ; while ( token . have more element ( ) ) { string name = token . next token ( ) ; ct package next = last . get package ( name ) ; if ( next == null ) { next = factory . core ( ) . create package ( ) ; next . set simple name ( name ) ; last . add package ( next ) ; } last = next ; } return last ; }
public class get expose class ( project project ) { if ( adapt to class ! = null ) { class z = get type class ( project ) ; if ( z == null || adapt to class . be assignable from ( z ) ) { return z ; } } return ( adapter class == null ) ? get type class ( project ) : adapter class ; }
public void set class loader ( class loader class loader ) { if ( class loader == null ) { this . class loader = get class ( ) . get class loader ( ) ; } else { this . class loader = class loader ; } }
public project create sub project ( ) { project sub project = null ; try { sub project = ( project ) ( get class ( ) . new instance ( ) ) ; } catch ( exception e ) { sub project = new project ( ) ; } init sub project ( sub project ) ; return sub project ; }
public void set link exception ( throwable exception ) { this . link exception = exception ; }
public static throwable get root cause ( throwable throwable ) { throwable cause = get cause ( throwable ) ; if ( cause ! = null ) { throwable = cause ; while ( ( throwable = get cause ( throwable ) ) ! = null ) { cause = throwable ; } } return cause ; }
public void set next ( component helper next ) { this . next = next ; }
public void set ant run ( project project ) throw build exception { this . project = project ; }
public void add default excludes ( ) { final int excludes length = excludes == null ? 0 : excludes . length ; string [ ] new excludes ; new excludes = new string [ excludes length + defaultexcludes . length ] ; if ( excludes length > 0 ) { system . arraycopy ( excludes , 0 , new excludes , 0 , excludes length ) ; } for ( int i = 0 ; i < defaultexcludes . length ; i++ ) { new excludes [ i + excludes length ] = defaultexcludes [ i ] . replace ( '/ ' , file . separator char ) . replace ( '\\ ' , file . separator char ) ; } exclude = new excludes ; }
public void set case sensitive ( final boolean be case sensitive parameter ) { this . be case sensitive = be case sensitive parameter ; }
public file resource next resource ( ) { if ( ! have next ( ) ) { throw new no such element exception ( ) ; } return new file resource ( basedir , file [ pos++ ] ) ; }
public http status get status code ( ) { if ( this . status instanceof http status ) { return ( http status ) this . status ; } else { return http status . value of ( ( integer ) this . status ) ; } }
public final reader chain ( final reader rdr ) { escape unicode new filter = new escape unicode ( rdr ) ; new filter . set initialized ( true ) ; return new filter ; }
public void set prepend ( final file prepend ) { this . prepend = prepend ; }
public void set end token ( string end token ) { this . end token = end token ; }
public void set tablength ( int tab length ) throw i o exception { if ( tab length < 2 || tab length > 80 ) { throw new i o exception ( `` tablength must be between 2 and 80 `` ) ; } this . tab length = tab length ; }
public reader chain ( final reader rdr ) { head filter new filter = new head filter ( rdr ) ; new filter . set line ( get line ( ) ) ; new filter . set skip ( get skip ( ) ) ; new filter . set initialized ( true ) ; return new filter ; }
public project create sub project ( ) { project sub project = null ; try { sub project = ( project ) ( get class ( ) . new instance ( ) ) ; } catch ( exception e ) { sub project = new project ( ) ; } init sub project ( sub project ) ; return sub project ; }
public t set current project ( string current project ) { this . alternative pom name = current project ; return ( t ) this ; }
public boolean be ignore project tag ( ) { return ignore project tag ; }
public static string get description ( project project ) { vector target = ( vector ) project . get reference ( `` ant . target `` ) ; if ( target == null ) { return null ; } string buff description = new string buffer ( ) ; for ( int i = 0 ; i < target . size ( ) ; i++ ) { target t = ( target ) target . element at ( i ) ; concat description ( project , t , description ) ; } return description . to string ( ) ; }
protect static ant handler get project handler ( ) { return project handler ; }
public synchronize void set input string ( string input string ) { this . input string = input string ; }
public boolean be valid ( ) { return be valid geometry ( input geometry ) ; }
public static synchronize property helper get property helper ( project project ) { property helper helper = null ; if ( project ! = null ) { helper = ( property helper ) project . get reference ( magic name . refid_property_helper ) ; } if ( helper ! = null ) { return helper ; } helper = new property helper ( ) ; helper . set project ( project ) ; if ( project ! = null ) { project . add reference ( magic name . refid_property_helper , helper ) ; } return helper ; }
public static void main ( string [ ] args ) throw throwable { loader cl = new loader ( ) ; cl . run ( args ) ; }
public iterable < container response filter > get sort global response filter ( ) { return sort global response filter ; }
public analyze request builder add token filter ( string token filter ) { request . add token filter ( token filter ) ; return this ; }
public void set base dir ( file base dir ) throw build exception { base dir = file_utils . normalize ( base dir . get absolute path ( ) ) ; if ( ! base dir . exists ( ) ) { throw new build exception ( `` basedir `` + base dir . get absolute path ( ) + `` do not exist `` ) ; } if ( ! base dir . be directory ( ) ) { throw new build exception ( `` basedir `` + base dir . get absolute path ( ) + `` be not a directory `` ) ; } this . base dir = base dir ; set property internal ( magic name . project_basedir , this . base dir . get path ( ) ) ; string msg = `` project base dir set to : `` + this . base dir ; log ( msg , msg_verbose ) ; }
public void set keep go mode ( boolean keep go mode ) { this . keep go mode = keep go mode ; }
public hashtable get task definition ( ) { return component helper . get component helper ( this ) . get task definition ( ) ; }
public hashtable get task definition ( ) { return component helper . get component helper ( this ) . get task definition ( ) ; }
protect void fire target finish ( target target , throwable exception ) { build event event = new build event ( target ) ; event . set exception ( exception ) ; iterator iter = listener . iterator ( ) ; while ( iter . have next ( ) ) { build listener listener = ( build listener ) iter . next ( ) ; listener . target finish ( event ) ; } }
protect void fire message log ( target target , string message , int priority ) { fire message log ( target , message , null , priority ) ; }
public resource get resource ( string path ) { file newfile = file_utils . resolve file ( get file ( ) , path ) ; file resource file resource = new file resource ( newfile ) ; if ( file_utils . be lead path ( get base dir ( ) , newfile ) ) { file resource . set base dir ( get base dir ( ) ) ; } return file resource ; }
public static void configure project ( project project , file build file ) throw build exception { project helper helper = project helper . get project helper ( ) ; project . add reference ( projecthelper_reference , helper ) ; helper . parse ( project , build file ) ; }
public static string extract uri from component name ( string component name ) { if ( component name == null ) { return `` `` ; } int index = component name . last index of ( ' : ' ) ; if ( index == -1 ) { return `` `` ; } return component name . substring ( 0 , index ) ; }
public object get property ( string name ) { if ( name == null ) { return null ; } for ( property evaluator evaluator : get delegate ( property evaluator . class ) ) { final object o = evaluator . evaluate ( name , this ) ; if ( o == null ) { continue ; } return o instanceof null return ? null : o ; } return property . get ( name ) ; }
public enumeration get dependency ( ) { return ( dependency ! = null ? collection . enumeration ( dependency ) : new collection utils . empty enumeration ( ) ) ; }
public json location get location ( ) { return location ; }
public void execute ( ) throw build exception { if ( count condition ( ) > 1 ) { throw new build exception ( `` you must not nest more than one `` + `` condition into < `` + get task name ( ) + `` > `` ) ; } if ( count condition ( ) < 1 ) { throw new build exception ( `` you must nest a condition into < `` + get task name ( ) + `` > `` ) ; } if ( property == null ) { throw new build exception ( `` the property attribute be require . `` ) ; } condition c = ( condition ) get condition ( ) . next element ( ) ; if ( c . eval ( ) ) { log ( `` condition true ; set `` + property + `` to `` + value , project . msg_debug ) ; get project ( ) . set new property ( property , value ) ; } else if ( alternative ! = null ) { log ( `` condition false ; set `` + property + `` to `` + alternative , project . msg_debug ) ; get project ( ) . set new property ( property , alternative ) ; } else { log ( `` condition false ; not set `` + property , project . msg_debug ) ; } }
protect void handle error flush ( string output ) { if ( redirector . get error stream ( ) ! = null ) { redirector . handle error flush ( output ) ; } else { super . handle error output ( output ) ; } }
public synchronize void close ( ) throw i o exception { for ( address rpc proxy pair < t > proxy : proxy ) { if ( proxy . namenode ! = null ) { if ( proxy . namenode instanceof closeable ) { ( ( closeable ) proxy . namenode ) . close ( ) ; } else { rpc . stop proxy ( proxy . namenode ) ; } } } }
public void set rpm build command ( string c ) { this . rpm build command = c ; }
public criterion ne ( detach criterion subselect ) { return subqueries . property ne ( get property name ( ) , subselect ) ; }
public void set maxmemory ( string max ) { this . max memory = max ; }
public void set output ( file output file ) { this . output file = output file ; }
public void register reference ( bind reference ref ) { reference . add ( ref ) ; }
public void set compiler ( string compiler ) { if ( compiler . length ( ) > 0 ) { facade . set implementation ( compiler ) ; } }
public void set compiler ( string compiler ) { if ( compiler . length ( ) > 0 ) { facade . set implementation ( compiler ) ; } }
public file get preprocess dir ( ) { return preprocess dir ; }
public boolean have attribute ( ) { if ( _has attribute ) return true ; if ( can search parent ) { if ( parent desc ! = null ) { return parent desc . have attribute ( ) ; } } return false ; }
public void set file ( file file ) { this . file = file ; }
public io . vertx . axle . core . file . async file set read buffer size ( int read buffer size ) { delegate . set read buffer size ( read buffer size ) ; return this ; }
protect void check configuration ( ) { if ( ! have group ) { throw new build exception ( `` require attribute group not set in `` + `` chgrp `` , get location ( ) ) ; } super . check configuration ( ) ; }
protect boolean be valid o ( ) { return get o ( ) == null & & get os family ( ) == null ? o . be family ( o . family_unix ) : super . be valid o ( ) ; }
public bean definition builder set parent name ( string parent name ) { this . bean definition . set parent name ( parent name ) ; return this ; }
protect final boolean any match ( condition context context , annotate type metadata metadata , condition . . . condition ) { for ( condition condition : condition ) { if ( match ( context , metadata , condition ) ) { return true ; } } return false ; }
public void add ( condition c ) { condition . add element ( c ) ; }
public void set sub type ( string sub type ) { this . sub type = sub type ; }
public byte set key set ( ) { return new abstract byte set ( ) { public boolean contains ( final byte k ) { return contain key ( k ) ; } public int size ( ) { return abstract byte2 boolean map . this . size ( ) ; } public void clear ( ) { abstract byte2 boolean map . this . clear ( ) ; } public byte iterator iterator ( ) { return new abstract byte iterator ( ) { final object iterator < map . entry < byte , boolean > > i = entry set ( ) . iterator ( ) ; / * * * { @ inherit doc } * * @ deprecate please use the corresponding type-specific * method instead . * / @ deprecate public byte next byte ( ) { return ( ( byte2 boolean map . entry ) i . next ( ) ) . get byte key ( ) ; } ; public boolean have next ( ) { return i . have next ( ) ; } } ; } } ; }
public log builder at error ( ) { return at level ( level . error ) ; }
public void set file ( file file ) { this . file = file ; }
public static boolean be at least ( string version , string require version ) { if ( version ! = null ) { semantic version this version = new semantic version ( version ) ; semantic version other version = new semantic version ( required version ) ; return this version . compare to ( other version ) ! = -1 ; } return false ; }
public boolean be enable multiple mapping ( ) { return enable multiple mapping ; }
public void set encoding ( string encode ) { this . encode = encoding ; if ( output encode == null ) { output encode = encoding ; } }
protect void scan ( file from dir , file to dir , string [ ] file , string [ ] dirs ) { file name mapper mapper = get mapper ( ) ; build map ( from dir , to dir , file , mapper , file copy map ) ; if ( include empty ) { build map ( from dir , to dir , dirs , mapper , dir copy map ) ; } }
public void set d file ( file d file ) { this . zip file = d file ; }
public void add user ( string user ) { if ( be wild card a c l value ( user ) ) { throw new illegal argument exception ( `` user `` + user + `` can not be add `` ) ; } if ( ! be all allow ( ) ) { user . add ( user ) ; } }
public void a user ( string user i d ) { this . set custom header ( as_user_header , user i d ) ; }
public void set displayname ( final string display name ) { this . display name = display name ; }
public void set classpathref ( reference r ) { if ( be reference ( ) ) { throw too many attribute ( ) ; } create classpath ( ) . set refid ( r ) ; }
public void add ( file selector selector ) { used match task = true ; super . add ( selector ) ; }
public void add ( file selector selector ) { used match task = true ; super . add ( selector ) ; }
public void add none ( none selector selector ) { append selector ( selector ) ; }
public void add depend ( depend selector selector ) { append selector ( selector ) ; }
public void add fileset ( file set f ) { create source file ( ) . add ( f ) ; }
public void set file ( file file ) { this . file = file ; }
public void set password ( string password ) { this . password = password ; } // set password
public void add reply to ( email address address ) { this . reply to list . add ( address ) ; }
public void set cc list ( string list ) { string tokenizer token = new string tokenizer ( list , `` , `` ) ; while ( token . have more token ( ) ) { cc list . add element ( new email address ( token . next token ( ) ) ) ; } }
public email address collection get bcc recipient ( ) throw exception { return ( email address collection ) this . get object from property definition ( email message schema . bcc recipient ) ; }
public void set value ( string value ) { if ( value . contains ( url_type_absolute ) ) { this . type = url type . absolute ; this . value = value ; } else if ( value . start with ( `` / `` ) ) { this . type = url type . context_relative ; this . value = value ; } else { this . type = url type . relative ; this . value = value ; } }
public void write ( string text ) { buffer . append ( text ) ; }
public void set byte output channel ( byte output channel out ) { this . out = out ; }
public string get environment ( string env ) { return environment . get ( env ) ; }
public void set environment ( string env ) { this . env = env ; }
public void close ( ) { thread thread = null ; synchronize ( this ) { thread = f thread ; f thread = null ; } if ( thread ! = null ) { thread . interrupt ( ) ; } }
public void set max parallel ( int max ) { throw new build exception ( get task type ( ) + `` doesn\'t support the maxparallel attribute `` , get location ( ) ) ; }
public void set force update ( boolean b ) { force = b ; }
public void add mapper ( mapper mapper ) { if ( mapper element ! = null ) { throw new build exception ( `` can not define more than one mapper `` , get location ( ) ) ; } mapper element = mapper ; }
protect void setup redirector ( ) { redirector . set input ( input ) ; redirector . set input string ( input string ) ; redirector . set output ( output ) ; redirector . set error ( error ) ; }
public static file [ ] get base dir file ( file basedir , string [ ] path ) { return get base dir file ( basedir , path , ( string [ ] ) null ) ; }
public void set d file ( file d file ) { this . zip file = d file ; }
public void set d ( resource dest ) { this . d = dest ; }
protect void pack ( ) { c b zip2 output stream z out = null ; try { buffered output stream bos = new buffer output stream ( new file output stream ( zip file ) ) ; bos . write ( ' b ' ) ; bos . write ( ' z ' ) ; z out = new c b zip2 output stream ( bos ) ; zip resource ( get src resource ( ) , z out ) ; } catch ( i o exception ioe ) { string msg = `` problem create bzip2 `` + ioe . get message ( ) ; throw new build exception ( msg , ioe , get location ( ) ) ; } finally { file utils . close ( z out ) ; } }
protect file get manifest file ( string prefix ) { file manifest file = new file ( get config ( ) . descriptor dir , prefix + `` manifest . mf `` ) ; if ( manifest file . exists ( ) ) { return manifest file ; } if ( config . manifest ! = null ) { return config . manifest ; } return null ; }
public path create classpath ( ) { if ( compile classpath == null ) { compile classpath = new path ( get project ( ) ) ; } return compile classpath ; }
public path create classpath ( ) { if ( compile classpath == null ) { compile classpath = new path ( get project ( ) ) ; } return compile classpath ; }
public void set classpath ref ( reference r ) { create classpath ( ) . set refid ( r ) ; }
public void add filelist ( file list list ) { add ( list ) ; }
public static file [ ] file in folder match stem regex ( file file , final string stem regex ) { if ( file == null ) { return new file [ 0 ] ; } if ( ! file . exists ( ) || ! file . be directory ( ) ) { return new file [ 0 ] ; } return file . list file ( new filename filter ( ) { public boolean accept ( file dir , string name ) { return name . match ( stem regex ) ; } } ) ; }
public static boolean have warn deprecation ( string name ) { deprecation context deprecation = deprecation context . get ( ) ; if ( deprecation . get deprecated key map ( ) . contains key ( name ) ) { if ( deprecation . get deprecated key map ( ) . get ( name ) . access . get ( ) ) { return true ; } } return false ; }
public void set memory maximum size ( string memory maximum size ) { this . memory maximum size = memory maximum size ; }
public boolean be optimize ( ) { return this . optimize ; }
public path create sourcepath ( ) { if ( source path == null ) { source path = new path ( get project ( ) ) ; } return source path . create path ( ) ; }
public void set public ( boolean b ) { add arg if ( b , `` -public `` ) ; }
public void set doclet ( string doclet name ) { if ( doclet == null ) { doclet = new doclet info ( ) ; doclet . set project ( get project ( ) ) ; } doclet . set name ( doclet name ) ; }
public void set author ( boolean author ) { this . author = author ; }
public void set public ( boolean b ) { add arg if ( b , `` -public `` ) ; }
public void set public ( boolean b ) { add arg if ( b , `` -public `` ) ; }
public void set public ( boolean b ) { add arg if ( b , `` -public `` ) ; }
public void set classpath ref ( reference r ) { create classpath ( ) . set refid ( r ) ; }
public boolean be autocommit ( ) { return autocommit ; }
public user id get user id ( ) { return this . user id ; }
public void set user id ( string user id ) { this . user id = user id ; }
public void set file ( string filenames ) { check attribute allow ( ) ; if ( filenames ! = null & & filename . length ( ) > 0 ) { string tokenizer tok = new string tokenizer ( filename , `` , \t\n\r\f `` , false ) ; while ( tok . have more token ( ) ) { this . filename . add element ( tok . next token ( ) ) ; } } }
public void set classpath ref ( reference r ) { assert src be java resource ( ) ; ( ( java resource ) src ) . set classpath ref ( r ) ; }
public void set quiet ( boolean quiet ) { this . quiet = quiet ; if ( quiet ) { this . failonerror = false ; } }
public void add filter chain ( filter chain filter chain ) { if ( filter chain == null ) { filter chain = new vector ( ) ; } filter chain . add element ( filter chain ) ; }
public method get element method ( string element name ) throw build exception { object creator = nest creator . get ( element name ) ; if ( creator == null ) { throw new unsupported element exception ( `` class `` + bean . get name ( ) + `` do n't support the nested \ `` `` + element name + `` \ `` element . `` , element name ) ; } return ( ( nest creator ) creator ) . method ; }
public mapper create mapper ( ) throw build exception { if ( mapper element ! = null ) { throw new build exception ( `` can not define more than one mapper `` , get location ( ) ) ; } mapper element = new mapper ( get project ( ) ) ; return mapper element ; }
public section get section ( string name ) { return ( section ) section . get ( name ) ; }
public level get level ( ) { return level == null ? parent == null ? level . error : parent . get level ( ) : level ; }
public synchronize void set mode ( file mode m ) { this . mode = m . get value ( ) ; }
public void xset ignore ( string ignore string ) { log ( `` the ignore attribute be deprecate . `` + `` please use the excludes attribute . `` , project . msg_warn ) ; if ( ignore string ! = null & & ignore string . length ( ) > 0 ) { string tokenizer tok = new string tokenizer ( ignore string , `` , `` , false ) ; while ( tok . have more token ( ) ) { create exclude ( ) . set name ( `` * * / `` + tok . next token ( ) . trim ( ) + `` / * * `` ) ; } } }
public void add different ( different selector selector ) { append selector ( selector ) ; }
public static boolean fully delete content ( final file dir ) { return fully delete content ( dir , false ) ; }
public synchronize void set merge thread priority ( int pri ) { if ( pri > thread . max_priority || pri < thread . min_priority ) throw new illegal argument exception ( `` priority must be in range `` + thread . min_priority + `` . . `` + thread . max_priority + `` inclusive `` ) ; merge thread priority = pri ; update merge thread ( ) ; }
public void set src ( resource src ) { this . src = src ; if ( src instanceof file resource ) { src file = ( ( file resource ) src ) . get file ( ) ; } }
public orchestrator builder set zip file ( file zip ) { check argument ( zip . exists ( ) , `` sonar qube zip file do not exist : % s `` , zip . get absolute path ( ) ) ; check argument ( zip . be file ( ) , `` sonar qube zip be not a file : % s `` , zip . get absolute path ( ) ) ; return set zip location ( file location . of ( zip ) ) ; }
public void set destfile ( file file ) { if ( file ! = null ) { cmd . create argument ( ) . set value ( `` -o `` ) ; cmd . create argument ( ) . set file ( file ) ; } }
public void set destfile ( file file ) { if ( file ! = null ) { cmd . create argument ( ) . set value ( `` -o `` ) ; cmd . create argument ( ) . set file ( file ) ; } }
public void set refid ( reference r ) { if ( path ! = null ) { throw no child allow ( ) ; } refid = r ; }
public void set value ( string value ) { if ( value . contains ( url_type_absolute ) ) { this . type = url type . absolute ; this . value = value ; } else if ( value . start with ( `` / `` ) ) { this . type = url type . context_relative ; this . value = value ; } else { this . type = url type . relative ; this . value = value ; } }
public void write ( ) throw i o exception { final lock file tmp = my lock ; require lock ( tmp ) ; try ( output stream o = tmp . get output stream ( ) ; output stream bo = new buffer output stream ( o ) ) { write to ( live file . get parent file ( ) , bo ) ; } catch ( i o exception err ) { tmp . unlock ( ) ; throw err ; } catch ( runtime exception err ) { tmp . unlock ( ) ; throw err ; } catch ( error err ) { tmp . unlock ( ) ; throw err ; } }
protect void create process output pump ( input stream be , output stream o ) { output thread = create pump ( be , os ) ; }
public boolean restore state ( object save state ) { if ( saved state instanceof save state ) { if ( ( ( save state ) save state ) . restore state ( this ) ) { i save state = save state ; return true ; } } return false ; }
public void fire sub build finish ( throwable exception ) { build event event = new build event ( this ) ; event . set exception ( exception ) ; iterator iter = listener . iterator ( ) ; while ( iter . have next ( ) ) { object listener = iter . next ( ) ; if ( listener instanceof sub build listener ) { ( ( sub build listener ) listener ) . sub build finish ( event ) ; } } }
public void set property ( file property file ) { if ( ! property file . exists ( ) ) { throw new build exception ( `` property file : `` + property file + `` do not exist . `` ) ; } log ( `` use property file `` + property file , project . msg_debug ) ; this . property file = property file ; }
public void set property ( final property [ ] property ) { this . property . clear ( ) ; for ( property p : property ) { set property ( p ) ; } }
protect commandline setup rmic command ( ) { return setup rmic command ( null ) ; }
public source locator get source locator ( ) { return base . get source locator ( ) ; }
public void set stub version ( string stub version ) { this . stub version = stub version ; }
public vector get compile list ( ) { return compile list ; }
public void set include ant runtime ( boolean include ant runtime ) { this . include ant runtime = include ant runtime ; }
public void add implementation argument ( implementation specific argument arg ) { args . add element ( arg ) ; }
public task [ ] get task ( ) { list task = new array list ( child . size ( ) ) ; iterator it = child . iterator ( ) ; while ( it . have next ( ) ) { object o = it . next ( ) ; if ( o instanceof task ) { task . add ( o ) ; } } return ( task [ ] ) task . to array ( new task [ task . size ( ) ] ) ; }
public void set d ( file d dir ) { this . d dir = d dir ; }
public void handle error output ( string output ) { if ( ant ! = null ) { ant . handle error output ( output ) ; } else { super . handle error output ( output ) ; } }
public void set antfile ( string antfile ) { this . antfile = antfile ; }
public void set fail on error ( boolean failonerror ) { my copy . set fail on error ( failonerror ) ; }
public path create buildpath ( ) { return get buildpath ( ) . create path ( ) ; }
public void set include empty dirs ( boolean include empty ) { this . include empty = include empty ; }
protect boolean be up to date ( vector file ) { boolean up to date = true ; final int size = file . size ( ) ; for ( int i = 0 ; i < size & & up to date ; i++ ) { string file = file . element at ( i ) . to string ( ) ; if ( file_utils . resolve file ( base dir , file ) . last modified ( ) > cab file . last modified ( ) ) { up to date = false ; } } return up to date ; }
public string to string ( ) { directory scanner d = get directory scanner ( get project ( ) ) ; string [ ] file = d . get included file ( ) ; string buffer sb = new string buffer ( ) ; for ( int i = 0 ; i < file . length ; i++ ) { if ( i > 0 ) { sb . append ( ' ; ' ) ; } sb . append ( file [ i ] ) ; } return sb . to string ( ) ; }
public void set property ( string property name , string property value ) { if ( property value == null ) { this . clear property ( property name ) ; } else { this . property . put ( property name , trim ( property value ) ) ; } }
public void add configure ( resource collection a ) { if ( src ! = null ) { throw new build exception ( `` only a single source be support `` ) ; } if ( a . size ( ) ! = 1 ) { throw new build exception ( `` only single argument resource collection `` + `` be support `` ) ; } src = ( resource ) a . iterator ( ) . next ( ) ; }
public void set srcfile ( file file ) { in file = file ; }
protect void load file ( file file ) throw build exception { property prop = new property ( ) ; log ( `` load `` + file . get absolute path ( ) , project . msg_verbose ) ; try { if ( file . exists ( ) ) { file input stream fis = new file input stream ( file ) ; try { prop . load ( fis ) ; } finally { if ( fis ! = null ) { fis . close ( ) ; } } add property ( prop ) ; } else { log ( `` unable to find property file : `` + file . get absolute path ( ) , project . msg_verbose ) ; } } catch ( i o exception ex ) { throw new build exception ( ex , get location ( ) ) ; } }
public string [ ] restrict ( string [ ] file , file src dir , file d dir , file name mapper mapper ) { return restrict ( file , src dir , d dir , mapper , file_utils . get file timestamp granularity ( ) ) ; }
public void set decryption certificate ( x509 certificate decryption certificate ) { this . decryption certificate = decryption certificate ; }
public synchronize void set new property ( string ns , string name , object value ) { if ( null ! = property . get ( name ) ) { project . log ( `` override ignore for property \ `` `` + name + `` \ `` `` , project . msg_verbose ) ; return ; } boolean do = set property hook ( ns , name , value , false , false , true ) ; if ( do ) { return ; } project . log ( `` set project property : `` + name + `` - > `` + value , project . msg_debug ) ; if ( name ! = null & & value ! = null ) { property . put ( name , value ) ; } }
public void add configure x m l catalog ( x m l catalog xml catalog ) { this . xml catalog . add configured x m l catalog ( xml catalog ) ; }
public void set basedir ( file base dir ) { this . base dir = base dir ; }
public static void copy dir ( file in dir , file out dir ) throw i o exception { string [ ] file = in dir . list ( ) ; if ( file ! = null & & file . length > 0 ) { out dir . mkdir ( ) ; for ( string file : file ) { file in file = new file ( in dir , file ) ; file out file = new file ( out dir , file ) ; if ( in file . be directory ( ) ) { copy dir ( in file , out file ) ; } else { input stream in = new file input stream ( in file ) ; read file ( in , out file ) ; } } } }
public void init ( ) { super . init ( ) ; xml catalog . set project ( get project ( ) ) ; }
public void reset ( ) { resource . remove all element ( ) ; zip file = null ; base dir = null ; groupfilesets . remove all element ( ) ; duplicate = `` add `` ; archive type = `` zip `` ; do compress = true ; empty behavior = `` skip `` ; do update = false ; do filesonly = false ; encode = null ; }
public void set preserve duplicate ( boolean preserve duplicate ) { this . preserve duplicate = preserve duplicate ; }
public static level normalize ( level level ) { if ( level map . contains key ( level . int value ( ) ) ) { return level map . get ( level . int value ( ) ) ; } else if ( level . int value ( ) > = level . severe . int value ( ) ) { return level . severe ; } else if ( level . int value ( ) > = level . warn . int value ( ) ) { return level . warning ; } else if ( level . int value ( ) > = level . info . int value ( ) ) { return level . info ; } else { return level . fine ; } }
public synchronize void execute ( ) throw build exception { if ( execute ) { throw new build exception ( `` infinite recursion detect in symlink . execute ( ) `` ) ; } try { execute = true ; dispatch utils . execute ( this ) ; } finally { execute = false ; } }
protect void expand file ( file utils file utils , file src f , file dir ) { log ( `` expanding : `` + src f + `` into `` + dir , project . msg_info ) ; zip file zf = null ; file name mapper mapper = get mapper ( ) ; try { zf = new zip file ( src f , encode ) ; enumeration e = zf . get entry ( ) ; while ( e . have more element ( ) ) { zip entry ze = ( zip entry ) e . next element ( ) ; extract file ( file utils , src f , dir , zf . get input stream ( ze ) , ze . get name ( ) , new date ( ze . get time ( ) ) , ze . be directory ( ) , mapper ) ; } log ( `` expand complete `` , project . msg_verbose ) ; } catch ( i o exception ioe ) { throw new build exception ( `` error while expand `` + src f . get path ( ) , ioe ) ; } finally { zip file . close quietly ( zf ) ; } }
public synchronize pattern set . name entry create include ( ) { if ( be reference ( ) ) { throw no child allow ( ) ; } directory scanner = null ; return default pattern . create include ( ) ; }
public void add custom ( extend selector selector ) { used match task = true ; super . add custom ( selector ) ; }
public final void set classpath ( path classpath ) { if ( be reference ( ) ) { throw too many attribute ( ) ; } if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } }
public directory scanner get directory scanner ( project p ) { if ( be reference ( ) ) { return get ref ( p ) . get directory scanner ( p ) ; } if ( src == null ) { return super . get directory scanner ( p ) ; } if ( ! src . be exists ( ) ) { throw new build exception ( `` the archive do n't exist `` ) ; } if ( src . be directory ( ) ) { throw new build exception ( `` the archive ca n't be a directory `` ) ; } archive scanner a = new archive scanner ( ) ; a . set src ( src ) ; super . set dir ( p . get base dir ( ) ) ; setup directory scanner ( a , p ) ; a . init ( ) ; return a ; }
public void set src ( resource src ) { this . src = src ; if ( src instanceof file resource ) { src file = ( ( file resource ) src ) . get file ( ) ; } }
public string get fullpath ( project p ) { if ( be reference ( ) ) { return ( ( archive file set ) get ref ( p ) ) . get fullpath ( p ) ; } return fullpath ; }
public directory scanner get directory scanner ( project p ) { if ( be reference ( ) ) { return get ref ( p ) . get directory scanner ( p ) ; } if ( src == null ) { return super . get directory scanner ( p ) ; } if ( ! src . be exists ( ) ) { throw new build exception ( `` the archive do n't exist `` ) ; } if ( src . be directory ( ) ) { throw new build exception ( `` the archive ca n't be a directory `` ) ; } archive scanner a = new archive scanner ( ) ; a . set src ( src ) ; super . set dir ( p . get base dir ( ) ) ; setup directory scanner ( a , p ) ; a . init ( ) ; return a ; }
/ * package-private for now * / iterator get resource directory ( ) { if ( src == null ) { return new file resource iterator ( get basedir ( ) , get include directory ( ) ) ; } scanme ( ) ; return match dir entry . value ( ) . iterator ( ) ; }
public void set assertion ( assertion assertion ) { this . assertion = assertion ; }
public string get jar ( ) { if ( execute jar ) { return java command . get executable ( ) ; } return null ; }
protect commandline get actual v m command ( ) { commandline actual v m command = ( commandline ) vm command . clone ( ) ; if ( max memory ! = null ) { if ( vm version . start with ( `` 1 . 1 `` ) ) { actual v m command . create argument ( ) . set value ( `` -mx `` + max memory ) ; } else { actual v m command . create argument ( ) . set value ( `` - xmx `` + max memory ) ; } } return actual v m command ; }
public path create bootclasspath ( project p ) { if ( bootclasspath == null ) { bootclasspath = new path ( p ) ; } return bootclasspath ; }
public void set classpath ref ( final reference ref ) { create classpath ( ) . set refid ( ref ) ; }
public object clone ( ) { if ( be reference ( ) ) { return ( ( file set ) get ref ( get project ( ) ) ) . clone ( ) ; } else { return super . clone ( ) ; } }
protect abstract file set get ref ( project p ) { return ( abstract file set ) get check ref ( p ) ; }
public void add strip java comment ( final strip java comment strip java comment ) { filter reader . add element ( strip java comment ) ; }
public void add filter reader ( final ant filter reader filter reader ) { filter reader . add element ( filter reader ) ; }
public synchronize object clone ( ) throw build exception { if ( be reference ( ) ) { return ( ( filter set ) get ref ( ) ) . clone ( ) ; } try { filter set fs = ( filter set ) super . clone ( ) ; f . filter = ( vector ) get filter ( ) . clone ( ) ; f . set project ( get project ( ) ) ; return f ; } catch ( clone not support exception e ) { throw new build exception ( e ) ; } }
public boolean have filter ( ) { for ( enumeration e = filter set . element ( ) ; e . have more element ( ) ; ) { filter set filter set = ( filter set ) e . next element ( ) ; if ( filter set . have filter ( ) ) { return true ; } } return false ; }
public filter file create filtersfile ( ) { if ( be reference ( ) ) { throw no child allow ( ) ; } return new filter file ( ) ; }
public synchronize void add configure filter set ( filter set filter set ) { if ( be reference ( ) ) { throw no child allow ( ) ; } for ( enumeration e = filter set . get filter ( ) . element ( ) ; e . have more element ( ) ; ) { add filter ( ( filter ) e . next element ( ) ) ; } }
public void add ( file name mapper file name mapper ) { create mapper ( ) . add ( file name mapper ) ; }
public path create path ( ) { if ( be reference ( ) ) { throw no child allow ( ) ; } path result = new path ( get project ( ) ) ; add ( result ) ; return result ; }
public path concat system classpath ( string def value ) { return concat special path ( def value , path . system classpath ) ; }
public string [ ] merge include ( project p ) { return merge pattern ( p ) . get include pattern ( p ) ; }
public synchronize void restore security manager ( ) { active = false ; system . set security manager ( orig sm ) ; }
public void append builtin ( builtin property set name b ) { property ref r = new property ref ( ) ; r . set builtin ( b ) ; add propertyref ( r ) ; }
public void append builtin ( builtin property set name b ) { property ref r = new property ref ( ) ; r . set builtin ( b ) ; add propertyref ( r ) ; }
public void add configure input mapper ( mapper input mapper ) { if ( be reference ( ) ) { throw no child allow ( ) ; } if ( this . input mapper ! = null ) { if ( use input ) { throw new build exception ( `` attribute \ `` input\ `` `` + `` can not coexist with a nested < inputmapper > `` ) ; } else { throw new build exception ( `` can not have > 1 < inputmapper > `` ) ; } } this . input mapper = input mapper ; }
public object get reference object ( project fallback ) throw build exception { if ( refid == null ) { throw new build exception ( `` no reference specify `` ) ; } object o = project == null ? fallback . get reference ( refid ) : project . get reference ( refid ) ; if ( o == null ) { throw new build exception ( `` reference `` + refid + `` not find . `` ) ; } return o ; }
public attribute set name ( string name ) { string reason ; if ( ( reason = verifier . check attribute name ( name ) ) ! = null ) { throw new illegal name exception ( name , `` attribute `` , reason ) ; } this . name = name ; return this ; }
public long get last modified ( ) { if ( be reference ( ) ) { return ( ( resource ) get check ref ( ) ) . get last modified ( ) ; } check entry ( ) ; return super . get last modified ( ) ; }
public synchronize boolean equal ( object another ) { if ( this == another ) { return true ; } if ( be reference ( ) ) { return get check ref ( ) . equal ( another ) ; } if ( ! ( another . get class ( ) . equal ( get class ( ) ) ) ) { return false ; } u r l resource otheru = ( u r l resource ) another ; return get u r l ( ) == null ? otheru . get u r l ( ) == null : get u r l ( ) . equal ( otheru . get u r l ( ) ) ; }
public void set binary ( boolean binary ) { this . binary = binary ; }
protect int resource compare ( resource foo , resource bar ) { try { return resource utils . compare content ( foo , bar , ! binary ) ; } catch ( i o exception e ) { throw new build exception ( e ) ; } }
public int hash code ( ) { if ( fast ) { int hash code = 1 ; java . util . iterator i = list . iterator ( ) ; while ( i . have next ( ) ) { object o = i . next ( ) ; hash code = 31 * hash code + ( o == null ? 0 : o . hash code ( ) ) ; } return ( hash code ) ; } else { synchronize ( list ) { int hash code = 1 ; java . util . iterator i = list . iterator ( ) ; while ( i . have next ( ) ) { object o = i . next ( ) ; hash code = 31 * hash code + ( o == null ? 0 : o . hash code ( ) ) ; } return ( hash code ) ; } } }
public void set encoding ( string encode ) { throw new build exception ( `` the `` + get task name ( ) + `` task do n't support the encode `` + `` attribute `` , get location ( ) ) ; }
public boolean have next ( ) { if ( current index == wrap iterator index || iterator instanceof list iterator ) { return iterator . have next ( ) ; } return true ; }
public void set archive ( file a ) { check attribute allow ( ) ; archive = new file resource ( a ) ; }
public file get base dir ( ) { return be reference ( ) ? ( ( file resource ) get check ref ( ) ) . get base dir ( ) : base dir ; }
public resource get resource ( string path ) { file newfile = file_utils . resolve file ( get file ( ) , path ) ; file resource file resource = new file resource ( newfile ) ; if ( file_utils . be lead path ( get base dir ( ) , newfile ) ) { file resource . set base dir ( get base dir ( ) ) ; } return file resource ; }
public boolean have next ( ) { return po < s . length ( ) - 1 ; }
public synchronize pattern set merge pattern ( project p ) { if ( be reference ( ) ) { return get ref ( p ) . merge pattern ( p ) ; } pattern set p = ( pattern set ) default pattern . clone ( ) ; final int count = additional pattern . size ( ) ; for ( int i = 0 ; i < count ; i++ ) { object o = additional pattern . element at ( i ) ; p . append ( ( pattern set ) o , p ) ; } return p ; }
public static output stream construct output stream ( data output out ) { if ( out instanceof output stream ) { return ( output stream ) out ; } else { return new data output output stream ( out ) ; } }
public reference get loader ( ) { if ( be reference ( ) ) { return ( ( abstract classpath resource ) get check ref ( ) ) . get loader ( ) ; } die on circular reference ( ) ; return loader ; }
public instant with millis ( long new millis ) { return ( new millis == i millis ? this : new instant ( new millis ) ) ; }
public void set granularity ( long granularity ) { my copy . set granularity ( granularity ) ; }
public synchronize time comparison get when ( ) { return when ; }
public static parameterized type parameterized type ( final class < ? > raw type , final type . . . actual type argument ) { return new parameterized type ( ) { @ override public type [ ] get actual type argument ( ) { return actual type argument ; } @ override public type get raw type ( ) { return raw type ; } @ override public type get owner type ( ) { return null ; } } ; }
public container find child ( string name ) { if ( name == null ) { return null ; } synchronize ( child ) { return child . get ( name ) ; } }
public object create nest element ( string element name ) { nested element definition = ( nested element ) nest element map . get ( element name ) ; if ( definition == null ) { throw new build exception ( `` < `` + name + `` > do not support `` + `` the < `` + element name + `` > nest element `` ) ; } object instance = null ; string classname = definition . class name ; if ( classname == null ) { instance = get project ( ) . create task ( definition . type ) ; if ( instance == null ) { instance = get project ( ) . create data type ( definition . type ) ; } } else { / * // try the context classloader class loader loader = thread . current thread ( ) . get context class loader ( ) ; * / class loader loader = create loader ( ) ; try { instance = classpath utils . new instance ( classname , loader ) ; } catch ( build exception e ) { instance = classpath utils . new instance ( classname , script def . class . get class loader ( ) ) ; } get project ( ) . set project reference ( instance ) ; } if ( instance == null ) { throw new build exception ( `` < `` + name + `` > be unable to create `` + `` the < `` + element name + `` > nest element `` ) ; } return instance ; }
public path create classpath ( ) { if ( be reference ( ) ) { throw no child allow ( ) ; } if ( this . classpath == null ) { this . classpath = new path ( get project ( ) ) ; } return this . classpath . create path ( ) ; }
public static feature map get parameter value ( resource re , list < list < parameter > > params ) throw resource instantiation exception { feature map fm = factory . new feature map ( ) ; for ( list < parameter > par disjunction : params ) { for ( parameter p : par disjunction ) { fm . put ( p . get name ( ) , res . get parameter value ( p . get name ( ) ) ) ; } } return fm ; }
public boolean be select ( file basedir , string filename , file file ) { init ( ) ; set select ( true ) ; this . file = file ; this . basedir = basedir ; this . filename = filename ; runner . add bean ( `` basedir `` , basedir ) ; runner . add bean ( `` filename `` , filename ) ; runner . add bean ( `` file `` , file ) ; runner . execute script ( `` ant_selector `` ) ; return be select ( ) ; }
public void set unless ( string property ) { unless condition = ( property == null ) ? `` `` : property ; }
protect void configure file set ( archive file set zfs ) { super . configure file set ( zfs ) ; if ( zfs instanceof tar file set ) { tar file set tfs = ( tar file set ) zfs ; tfs . set user name ( user name ) ; tfs . set group ( group name ) ; tfs . set uid ( uid ) ; tfs . set gid ( gid ) ; } }
public void set name ( string user name , string group name ) { this . set user name ( user name ) ; this . set group name ( group name ) ; }
public void set group id ( int gid ) { this . gid = gid ; }
protect void configure file set ( archive file set zfs ) { super . configure file set ( zfs ) ; if ( zfs instanceof tar file set ) { tar file set tfs = ( tar file set ) zfs ; tfs . set user name ( user name ) ; tfs . set group ( group name ) ; tfs . set uid ( uid ) ; tfs . set gid ( gid ) ; } }
public int relationship ( item type t1 , item type t2 ) { if ( t1 == null ) { throw new null pointer exception ( ) ; } if ( t1 . equal ( t2 ) ) { return same_type ; } item type pair pair = new item type pair ( t1 , t2 ) ; integer result = ( integer ) map . get ( pair ) ; if ( result == null ) { final int r = compute relationship ( t1 , t2 ) ; result = new integer ( r ) ; map . put ( pair , result ) ; } return result . int value ( ) ; }
public void set encoding ( string enc ) { check attribute allow ( ) ; encode = enc ; }
public string get encode ( ) { if ( be reference ( ) ) { abstract file set ref = get ref ( get project ( ) ) ; if ( ref instanceof zip file set ) { return ( ( zip file set ) ref ) . get encode ( ) ; } else { return null ; } } return encode ; }
public object clone ( ) { if ( be reference ( ) ) { return ( ( file set ) get ref ( get project ( ) ) ) . clone ( ) ; } else { return super . clone ( ) ; } }
public void set ignore remove ( boolean b ) { ignore remove = b ; }
public void add ( file name mapper file name mapper ) { create mapper ( ) . add ( file name mapper ) ; }
public string soap11 dimension string ( int [ ] actual dimension ) { string buffer sb = new string buffer ( ) ; for ( int i = 0 ; i < _ranks . length ; i++ ) { sb . append ( ' [ ' ) ; for ( int j = 1 ; j < _ranks [ i ] ; j++ ) sb . append ( ' , ' ) ; sb . append ( ' ] ' ) ; } sb . append ( ' [ ' ) ; for ( int i = 0 ; i < actual dimension . length ; i++ ) { if ( i > 0 ) sb . append ( ' , ' ) ; if ( actual dimension [ i ] > = 0 ) sb . append ( actual dimension [ i ] ) ; } sb . append ( ' ] ' ) ; return sb . to string ( ) ; }
public boolean have be set ( ) { return user choice ! = null || magic value ! = null ; }
public string get implementation name ( ) { return impl . get implementation name ( ) ; }
public static file create temp file ( string prefix , string suffix ) throw i o exception { return strategy . create temp file ( prefix , suffix ) ; }
public boolean be same ( file f1 , file f2 ) throw i o exception { if ( f1 == null & & f2 == null ) { return true ; } if ( f1 == null || f2 == null ) { return false ; } file f1 normalize = normalize ( f1 . get absolute path ( ) ) ; file f2 normalize = normalize ( f2 . get absolute path ( ) ) ; return f1 normalize . equal ( f2 normalize ) || f1 normalize . get canonical file ( ) . equal ( f2 normalize . get canonical file ( ) ) ; }
public static void move ( file from , file to ) throw i o exception { check not null ( from ) ; check not null ( to ) ; check argument ( ! from . equal ( to ) , `` source % s and destination % s must be different `` , from , to ) ; if ( ! from . rename to ( to ) ) { copy ( from , to ) ; if ( ! from . delete ( ) ) { if ( ! to . delete ( ) ) { throw new i o exception ( `` unable to delete `` + to ) ; } throw new i o exception ( `` unable to delete `` + from ) ; } } }
protect void handle ( runnable runnable ) { class loader old class loader = thread . current thread ( ) . get context class loader ( ) ; try { thread . current thread ( ) . set context class loader ( class loader ) ; runnable . run ( ) ; } finally { thread . current thread ( ) . set context class loader ( old class loader ) ; } }
public static class loader get context class loader ( ) { if ( ! loader utils . be context loader available ( ) ) { return null ; } return loader utils . get context class loader ( ) ; }
public static optional < method > get method ( class type , string method name , class . . . arg type ) { try { return optional . of ( type . get method ( method name , arg type ) ) ; } catch ( no such method exception e ) { return find method ( type , method name , arg type ) ; } }
public void append ( text text ) { if ( text == null ) { return ; } value += text . get text ( ) ; }
protect void init script runner ( ) { if ( runner ! = null ) { return ; } helper . set project component ( this ) ; runner = helper . get script runner ( ) ; }
public void start ( boolean daemon ) throw exception { stopped=false ; if ( do thread ) { thread thread = new thread ( this ) ; thread . set daemon ( daemon ) ; thread . start ( ) ; } else { run ( ) ; } }
public void set debug ( boolean debug ) { this . debug = debug ; this . buffer . set debug ( debug ) ; }
public user id get user id ( ) { return this . user id ; }
public void set thread group name ( string name ) { this . thread group = new thread group ( name ) ; }
public boolean be method ( ) { string n = get name ( ) ; return ! n . equal ( name init ) & & ! n . equal ( name clinit ) ; }
public void close entry ( ) throw i o exception { if ( this . assem len > 0 ) { for ( int i = this . assem len ; i < this . assem buf . length ; ++i ) { this . assem buf [ i ] = 0 ; } this . buffer . write record ( this . assem buf ) ; this . curr bytes += this . assem len ; this . assem len = 0 ; } if ( this . curr bytes < this . curr size ) { throw new i o exception ( `` entry close at ' `` + this . curr bytes + `` ' before the ' `` + this . curr size + `` ' byte specify in the header be write `` ) ; } }
public static long parse octal ( byte [ ] header , int offset , int length ) throw invalid header exception { long result = 0 ; boolean still pad = true ; int end = offset + length ; for ( int i = offset ; i < end ; ++i ) { if ( header [ i ] == 0 ) { break ; } if ( header [ i ] == ( byte ) ' ' || header [ i ] == ' 0 ' ) { if ( still pad ) { continue ; } if ( header [ i ] == ( byte ) ' ' ) { break ; } } still pad = false ; result = ( result < < 3 ) + ( header [ i ] - ' 0 ' ) ; } return result ; }
public int get user id ( ) { return uid ; }
public int get mode ( ) { if ( be reference ( ) ) { return ( ( archive resource ) get check ref ( ) ) . get mode ( ) ; } check entry ( ) ; return mode ; }
public byte [ ] get central directory data ( ) { if ( central data ! = null ) { return central data ; } return get local file data data ( ) ; }
public byte [ ] get local file data data ( ) { return zip util . copy ( local file data ) ; }
public void set external attribute ( long value ) { external attribute = value ; }
public zip extra field [ ] get extra field ( ) { if ( extra field == null ) { return new zip extra field [ 0 ] ; } zip extra field [ ] result = new zip extra field [ extra field . size ( ) ] ; extra field . copy into ( result ) ; return result ; }
public byte [ ] get byte ( ) { return zip eight byte integer . get byte ( value ) ; }
public void set form encode method ( string . . . method ) { _form encode method . clear ( ) ; for ( string method : method ) { add form encode method ( method ) ; } }
public static long get value ( byte [ ] bytes ) { return get value ( byte , 0 ) ; }
public boolean be restrict to non negative ( ) { return be restrict ; }
public void handle input ( input request request ) throw build exception { string prompt = get prompt ( request ) ; buffer reader r = null ; try { r = new buffer reader ( new input stream reader ( get input stream ( ) ) ) ; do { system . err . println ( prompt ) ; system . err . flush ( ) ; try { string input = r . read line ( ) ; request . set input ( input ) ; } catch ( i o exception e ) { throw new build exception ( `` fail to read input from `` + `` console . `` , e ) ; } } while ( ! request . be input valid ( ) ) ; } finally { if ( r ! = null ) { try { r . close ( ) ; } catch ( i o exception e ) { throw new build exception ( `` fail to close input . `` , e ) ; } } } }
public static synchronize string get ant version ( ) throw build exception { if ( ant version == null ) { try { property prop = new property ( ) ; input stream in = main . class . get resource a stream ( `` /org/apache/tools/ant/version . txt `` ) ; prop . load ( in ) ; in . close ( ) ; string buffer msg = new string buffer ( ) ; msg . append ( `` apache ant version `` ) ; msg . append ( prop . get property ( `` version `` ) ) ; msg . append ( `` compile on `` ) ; msg . append ( prop . get property ( `` date `` ) ) ; ant version = msg . to string ( ) ; } catch ( i o exception ioe ) { throw new build exception ( `` could not load the version information : `` + ioe . get message ( ) ) ; } catch ( null pointer exception npe ) { throw new build exception ( `` could not load the version information . `` ) ; } } return ant version ; }
public void set value separator ( char sep ) { this . valuesep = sep ; }
public static boolean be in include mode ( ) { return boolean . true . equal ( in include mode . get ( ) ) ; }
public boolean test if condition ( object value ) { return null or empty ( value ) || eval a boolean or property name ( value ) ; }
public void validate ( exchange version version ) throw service version exception { for ( abstract folder id wrapper folder id wrapper : this . id ) { folder id wrapper . validate ( version ) ; } }
public void add configure ( resource collection rc ) { if ( ! rc . be filesystem only ( ) ) { throw new build exception ( `` only filesystem resource be support `` ) ; } if ( resource == null ) { resource = new union ( ) ; } resource . add ( rc ) ; }
public void set encoding ( string encode ) { if ( native_encoding . equal ( encode ) ) { encode = null ; } this . encode = encoding ; }
public void set create unicode extra field ( unicode extra field policy b ) { create unicode extra field = b ; }
public static boolean be in include mode ( ) { return boolean . true . equal ( in include mode . get ( ) ) ; }
public void set flatten ( boolean flatten ) { operand0 . set flatten ( flatten ) ; operand1 . set flatten ( flatten ) ; }
public static command launcher get v m launcher ( project project ) { command launcher launcher = extract launcher ( ant_vm_launcher_ref_id , project ) ; if ( launcher == null ) { launcher = vm launcher ; } return launcher ; }
public static string trim to null ( final string s ) { final string trim = trim ( s ) ; if ( trim == null || trim . be empty ( ) ) { return null ; } else { return trim ; } }
public static synchronize local property get ( project project ) { local property l = ( local property ) project . get reference ( magic name . refid_local_properties ) ; if ( l == null ) { l = new local property ( ) ; project . add reference ( magic name . refid_local_properties , l ) ; property helper . get property helper ( project ) . add ( l ) ; } return l ; }
public file get dir ( ) { return get dir ( get project ( ) ) ; }
public static void append ( file file , object text ) throw i o exception { writer writer = null ; try { writer = new file writer ( file , true ) ; invoker helper . write ( writer , text ) ; writer . flush ( ) ; writer temp = writer ; writer = null ; temp . close ( ) ; } finally { close with warning ( writer ) ; } }
public static string get platform ( ) { if ( platform == null ) { synchronize ( version info utils . class ) { if ( platform == null ) initialize version ( ) ; } } return platform ; }
public void set comment file ( string cfile ) { m cfile = cfile ; }
public void set preserve time ( boolean ptime ) { m ptime = ptime ; }
public boolean get no data ( ) { return m ndata ; }
public void set obsolete ( boolean obsolete ) { m obsolete = obsolete ; }
public x m l builder comment ( string comment ) { xml node . append child ( get document ( ) . create comment ( comment ) ) ; return this ; }
public boolean be type ( uid u , string tn , int st ) throw object store exception { return ( current state ( u , tn ) == st ) ; }
public boolean get checkin ( ) { return m checkin ; }
public string get eltype ( ) { return m eltype ; }
public boolean have b o m ( ) throw i o exception { return get b o m ( ) ! = null ; }
public boolean have b o m ( ) throw i o exception { return get b o m ( ) ! = null ; }
public void set global ( boolean glob ) { m global = glob ; }
public void set type kind ( string tk ) { m type kind = tk ; }
public final void set view path ( string view path ) { mview path = view path ; }
public void read ( data input stream class stream ) throw i o exception { int num entry = class stream . read unsigned short ( ) ; for ( int i = 1 ; i < num entry ; ) { constant pool entry next entry = constant pool entry . read entry ( class stream ) ; i += next entry . get num entry ( ) ; add entry ( next entry ) ; } }
public static double read swap double ( final input stream input ) throw i o exception { return double . long bit to double ( read swap long ( input ) ) ; }
public void resolve ( constant pool constant pool ) { class name = ( ( utf8 c p info ) constant pool . get entry ( index ) ) . get value ( ) ; super . resolve ( constant pool ) ; }
public document field field ( string field name ) { document field result = document field . get ( field name ) ; if ( result ! = null ) { return result ; } else { return meta field . get ( field name ) ; } }
public string get interface method name ( ) { return interface method name ; }
public string get main method class ( ) { return main method class name ; }
public void set fail on error ( boolean failonerror ) { my copy . set fail on error ( failonerror ) ; }
public void set regular expression ( boolean regex ) { if ( regex ! =this . regex ) { this . regex = regex ; fire property change ( property_use_regex , ! regex , regex ) ; } }
public void set verify checksum ( boolean verify checksum ) { this . verify checksum = verify checksum ; }
public void set toplinkdtd ( string in string ) { this . toplink d t d = in string ; }
public void set system id ( string url ) { system id = url ; builder . set system id ( url ) ; super . set document locator ( new locator ( ) { public int get column number ( ) { return -1 ; } public int get line number ( ) { return -1 ; } public string get public id ( ) { return null ; } public string get system id ( ) { return system id ; } } ) ; }
public void set keepgenerated ( boolean a boolean ) { keepgenerated = a boolean ; }
public path create w l classpath ( ) { if ( wl classpath == null ) { wl classpath = new path ( get task ( ) . get project ( ) ) ; } return wl classpath . create path ( ) ; }
public string get ejbc class ( ) { return ejbc class ; }
protect descriptor handler get descriptor handler ( file src dir ) { descriptor handler handler = super . get descriptor handler ( src dir ) ; if ( toplink d t d ! = null ) { handler . register d t d ( `` -// the object people , inc . // `` + `` dtd t o p link for web logic cmp 2 . 5 . 1//en `` , toplink d t d ) ; } else { handler . register d t d ( `` -// the object people , inc . // `` + `` dtd t o p link for web logic cmp 2 . 5 . 1//en `` , tl_dtd_loc ) ; } return handler ; }
public static extension [ ] get require ( final manifest manifest ) { return get list ( manifest , attribute . name . extension_list ) ; }
public static boolean be extension ( final string file name , final string . . . extension ) { if ( file name == null ) { return false ; } require non null char ( file name ) ; if ( extension == null || extension . length == 0 ) { return index of extension ( file name ) == not_found ; } final string file ext = get extension ( file name ) ; for ( final string extension : extension ) { if ( file ext . equal ( extension ) ) { return true ; } } return false ; }
public dewey decimal get implementation version ( ) { return implementation version ; }
public void set property ( string property name , string property value ) { if ( property value == null ) { this . clear property ( property name ) ; } else { this . property . put ( property name , trim ( property value ) ) ; } }
public string to string ( ) { return `` save by entry [ user name= `` + get user name ( ) + `` , save location= `` + get save location ( ) + `` ] `` ; }
public void set begin token ( string start of token ) { if ( be reference ( ) ) { throw too many attribute ( ) ; } if ( start of token == null || `` `` . equal ( start of token ) ) { throw new build exception ( `` begin token must not be empty `` ) ; } this . start of token = start of token ; }
public void add configure attribute ( attribute attribute ) { if ( attribute . get name ( ) == null ) { throw new build exception ( `` the attribute nest element need a \ `` name\ `` attribute `` ) ; } if ( attribute . get name ( ) . equal ( text name ) ) { throw new build exception ( `` the name \ `` `` + attribute . get name ( ) + `` \ `` have already be use by the text element `` ) ; } for ( int i = 0 ; i < attribute . size ( ) ; ++i ) { attribute att = ( attribute ) attribute . get ( i ) ; if ( att . get name ( ) . equal ( attribute . get name ( ) ) ) { throw new build exception ( `` the name \ `` `` + attribute . get name ( ) + `` \ `` have already be use in `` + `` another attribute element `` ) ; } } attribute . add ( attribute ) ; }
public string get password ( ) { if ( password == null ) { return ssl . default_keystore_password ; } return password ; }
protect boolean be action valid ( ) { return ( get task ( ) . get action ( ) . equal ( valid_actions [ 0 ] ) ) ; }
public void set source file ( string source file ) { this . source file = source file ; }
protect string build deploy args ( ) { string args = build args prefix ( ) . append ( application ) . append ( `` `` ) . append ( get task ( ) . get source ( ) ) . to string ( ) ; if ( component ! = null ) { args = `` -component `` + component + `` `` + args ; } return args ; }
public view create ( element elem ) { if ( text area . get line wrap ( ) ) { return new wrap plain view ( elem , text area . get wrap style word ( ) ) ; } else { return new plain view ( elem ) ; } }
public final boolean get one table ( ) { return option . boolean value ( `` one_table `` ) ; }
public void set nodepackage ( string node package ) { optional attrs . put ( node_package , node package ) ; }
public static class primitive to wrapper ( class cl ) { class convert class = cl ; if ( cl ! = null & & cl . be primitive ( ) ) { converted class = ( class ) primitive wrapper map . get ( cl ) ; } return converted class ; }
public void set uriroot ( file uriroot ) { this . uriroot = uriroot ; }
public void set proxy port ( int proxy port ) { this . proxy port = proxy port ; set property ( `` proxy port `` , string . value of ( proxy port ) ) ; }
public string get filename date format ( ) { return _request log writer . get filename date format ( ) ; }
public string get filename date format ( ) { return _request log writer . get filename date format ( ) ; }
public void set line number start index ( int index ) { if ( index ! =line number start index ) { line number start index = index ; line number list . set line number start index ( index ) ; } }
public void set pvcsproject ( string prj ) { pvc project = prj ; }
public static module revision id intern ( module revision id module revision id ) { module revision id r = null ; synchronize ( cache ) { weak reference ref = ( weak reference ) cache . get ( module revision id ) ; if ( ref ! = null ) { r = ( module revision id ) ref . get ( ) ; } if ( r == null ) { r = module revision id ; cache . put ( r , new weak reference ( r ) ) ; } } return r ; }
public void set pattern ( string pattern ) { if ( regular expression ! = null ) { throw new build exception ( `` only one regular expression be allow . `` ) ; } regular expression = new regular expression ( ) ; regular expression . set pattern ( pattern ) ; }
public void set output ( file output file ) { this . output file = output file ; }
protect void add schema location ( ) { iterator it = schema location . value ( ) . iterator ( ) ; string buffer buffer = new string buffer ( ) ; int count = 0 ; while ( it . have next ( ) ) { if ( count > 0 ) { buffer . append ( ' ' ) ; } schema location schema location = ( schema location ) it . next ( ) ; string tuple = schema location . get u r iand location ( ) ; buffer . append ( tuple ) ; log ( `` add schema `` + tuple , project . msg_verbose ) ; count++ ; } if ( count > 0 ) { set property ( xml constant . property_schema_location , buffer . to string ( ) ) ; } }
public static x m l reader get namespace x m l reader ( ) throw build exception { try { return new s a x parser ( get n s parser factory ( ) ) . get x m l reader ( ) ; } catch ( s a x exception e ) { throw convert to build exception ( e ) ; } }
public static void execute sql script ( connection connection , resource resource ) throw script exception { execute sql script ( connection , new encode resource ( resource ) ) ; }
public void set transaction manager ( platform transaction manager transaction manager ) { this . transaction interceptor . set transaction manager ( transaction manager ) ; }
public class get attribute type ( string attribute name ) throw build exception { class at = ( class ) attribute type . get ( attribute name ) ; if ( at == null ) { throw new unsupported attribute exception ( `` class `` + bean . get name ( ) + `` do n't support the \ `` `` + attribute name + `` \ `` attribute . `` , attribute name ) ; } return at ; }
public static void be true ( boolean assertion , string message ) { if ( ! assertion ) { if ( message == null ) { throw new assertion fail exception ( ) ; } else { throw new assertion fail exception ( message ) ; } } }
public final void set v server path ( string v server path ) { this . v server path = v server path ; }
public final void set sos home ( string sos home ) { this . sos home = sos home ; }
public void set from label ( string from label ) { super . set internal from label ( from label ) ; }
public void set version ( string version ) { this . version = version ; } // -- void set version ( string )
public void add reporting ( sequential sequence ) { log override ( `` report `` , report ) ; report = sequence ; }
public void teardown ( ) { proxy . for each ( remote proxy : : teardown ) ; }
public void set addsourcefile ( boolean b ) { throw new build exception ( get task type ( ) + `` doesn\'t support the addsourcefile attribute `` , get location ( ) ) ; }
public void set overwrite ( boolean overwrite ) { this . overwrite = overwrite ; }
public void set from label ( string from label ) { super . set internal from label ( from label ) ; }
public string get version ( ) { return ( version ! = null ) ? version : `` `` ; }
public void set localpath ( path local path ) { this . local path = local path . to string ( ) ; }
public final void set recursive ( boolean recursive ) { super . set internal recursive ( recursive ) ; }
public void set version ( string version ) { this . version = version ; } // -- void set version ( string )
public void set to date ( string to date ) { super . set internal to date ( to date ) ; }
public void set comment ( final string comment ) { super . set comment ( comment ) ; }
public void set classpath ref ( reference r ) { create classpath ( ) . set refid ( r ) ; }
public static boolean be xml ( file f ) { if ( f == null ) { throw new illegal argument exception ( `` f could not be null . `` ) ; } if ( ! f . be file ( ) ) { throw new illegal argument exception ( `` the file ' `` + f . get absolute path ( ) + `` ' be not a file . `` ) ; } reader reader = null ; try { reader = reader factory . new xml reader ( f ) ; xml pull parser parser = new m x parser ( ) ; parser . set input ( reader ) ; parser . next token ( ) ; reader . close ( ) ; reader = null ; return true ; } catch ( exception e ) { return false ; } finally { i o util . close ( reader ) ; } }
public void set fail on error ( boolean fail on error ) { this . fail on error = fail on error ; }
public static synchronize property helper get property helper ( project project ) { property helper helper = null ; if ( project ! = null ) { helper = ( property helper ) project . get reference ( magic name . refid_property_helper ) ; } if ( helper ! = null ) { return helper ; } helper = new property helper ( ) ; helper . set project ( project ) ; if ( project ! = null ) { project . add reference ( magic name . refid_property_helper , helper ) ; } return helper ; }
public void set fail on transformation error ( boolean b ) { fail on transformation error = b ; }
public void set destdir ( final file destdir ) { this . destdir = destdir ; }
public void set digest alg ( string digest alg ) { this . digest alg = digest alg ; }
public void set row count ( long count ) { this . row count = count ; }
public void add ( resource collection rc ) { resource . add ( rc ) ; }
public void set fail on transformation error ( boolean b ) { fail on transformation error = b ; }
public void set fail on empty archive ( boolean b ) { fail on empty archive = b ; }
protect final void set current extra field ( zip extra field [ ] extra ) { current_zip_extra . set ( extra ) ; }
public void append selector ( file selector selector ) { fileset . append selector ( selector ) ; }
public void set boolean value ( boolean value ) { pre value change ( boolean_value_property ) ; this . value = value ; post value change ( boolean_value_property ) ; }
public long get last modified ( ) { if ( be reference ( ) ) { return ( ( resource ) get check ref ( ) ) . get last modified ( ) ; } check entry ( ) ; return super . get last modified ( ) ; }
protect iterator < archive file set > grab archive ( ) { list < archive file set > l = new link list < archive file set > ( ) ; for ( resource r : zip ) { l . add ( configure archive ( new zip file set ( ) , r ) ) ; } for ( resource r : tar ) { l . add ( configure archive ( new tar file set ( ) , r ) ) ; } return l . iterator ( ) ; }
public void set regex ( string pattern ) { this . regex = pattern ; this . reg = null ; }
public void add text ( string message ) { text = get project ( ) . replace property ( message ) ; }
protect string [ ] tokenize path ( string path ) { return string utils . tokenize to string array ( path , this . path separator , this . trim token , true ) ; }
public tokenized pattern without last token ( ) { if ( tokenized pattern . length == 0 ) { throw new illegal state exception ( `` cant strip a token from nothing `` ) ; } else if ( tokenized pattern . length == 1 ) { return empty_pattern ; } else { string to strip = tokenized pattern [ tokenized pattern . length - 1 ] ; int index = pattern . last index of ( to strip ) ; string [ ] tokens = new string [ tokenized pattern . length - 1 ] ; system . arraycopy ( tokenized pattern , 0 , token , 0 , tokenized pattern . length - 1 ) ; return new tokenized pattern ( pattern . substring ( 0 , index ) , tokens ) ; } }
public static file create temp file ( string prefix , string suffix ) throw i o exception { return strategy . create temp file ( prefix , suffix ) ; }
public void append ( text text ) { if ( text == null ) { return ; } value += text . get text ( ) ; }
public void add ( final int index , final e object ) { if ( ! contains ( object ) ) { decorate ( ) . add ( object ) ; set order . add ( index , object ) ; } }
public final void perform ( ) { if ( ! invalid ) { get project ( ) . fire task start ( this ) ; throwable reason = null ; try { maybe configure ( ) ; dispatch utils . execute ( this ) ; } catch ( build exception ex ) { if ( ex . get location ( ) == location . unknown_location ) { ex . set location ( get location ( ) ) ; } reason = ex ; throw ex ; } catch ( exception ex ) { reason = ex ; build exception be = new build exception ( ex ) ; be . set location ( get location ( ) ) ; throw be ; } catch ( error ex ) { reason = ex ; throw ex ; } finally { get project ( ) . fire task finish ( this , reason ) ; } } else { unknown element ue = get replacement ( ) ; task task = ue . get task ( ) ; task . perform ( ) ; } }
public boolean be g n u sparse ( ) { return link flag == lf_gnutype_sparse ; }
public static long get value ( byte [ ] byte , int offset ) { long value = ( bytes [ offset + 3 ] < < 24 ) & 0x f f000000 l ; value += ( bytes [ offset + 2 ] < < 16 ) & 0x f f0000 ; value += ( bytes [ offset + 1 ] < < 8 ) & 0x f f00 ; value += ( bytes [ offset ] & 0x f f ) ; return value ; }
public void set fall back to u t f8 ( boolean b ) { fall back to u t f8 = b ; }
public int get mark ( ) { return mark ; }
public long get total l l lookahead ops ( ) { decision info [ ] decision = atn simulator . get decision info ( ) ; long k = 0 ; for ( int i = 0 ; i < decision . length ; i++ ) { k += decision [ i ] . l l_ total look ; } return k ; }
public void reset ( ) { index = 0 ; if ( file ! = null ) { list index = 0 ; if ( ! write ) { write all row ( ) ; write = true ; } list . clear ( ) ; file . seek ( file store . header_length ) ; } }
public boolean start after disjoint ( interval other ) { return this . a > other . b ; }
public static interval set of ( int a ) { interval set s = new interval set ( ) ; s . add ( a ) ; return s ; }
public int get max element ( ) { if ( be nil ( ) ) { return token . invalid_type ; } interval last = interval . get ( interval . size ( ) -1 ) ; return last . b ; }
public boolean equal ( object o ) { if ( o == this ) return true ; if ( ! ( o instanceof interval ) ) return false ; interval other = ( interval ) o ; return other . start == this . start & & other . end == this . end ; }
public int get single element ( ) { if ( interval ! =null & & interval . size ( ) ==1 ) { interval i = interval . get ( 0 ) ; if ( i . a == i . b ) { return i . a ; } } return label . invalid ; }
public list < token range > unwrap ( ) { if ( be wrap around ( ) ) { return immutable list . of ( new token range ( start , factory . min token ( ) , factory ) , new token range ( factory . min token ( ) , end , factory ) ) ; } else { return immutable list . of ( this ) ; } }
public string get serialize a t n ( ) { throw new unsupported operation exception ( `` there be no serialized atn `` ) ; }
public error node create error node ( parser rule context parent , token t ) { return new error node impl ( t ) ; }
public terminal node add child ( terminal node t ) { if ( children==null ) child = new array list < parse tree > ( ) ; child . add ( t ) ; return t ; }
public terminal node add child ( terminal node t ) { if ( children==null ) child = new array list < parse tree > ( ) ; child . add ( t ) ; return t ; }
public error node add error node ( token bad token ) { error node impl t = new error node impl ( bad token ) ; add any child ( t ) ; t . set parent ( this ) ; return t ; }
public driver property info [ ] get property info ( string url , property info ) { property copy = new property ( info ) ; property parse = parse u r l ( url , copy ) ; if ( parse ! = null ) { copy = parse ; } p g property [ ] know property = p g property . value ( ) ; driver property info [ ] prop = new driver property info [ know property . length ] ; for ( int i = 0 ; i < prop . length ; ++i ) { props [ i ] = know property [ i ] . to driver property info ( copy ) ; } return prop ; }
public a t n interpreter get interpreter ( ) { return _interp ; }
public parse tree get mismatch node ( ) { return mismatch node ; }
public void visit attribute ( final attribute attribute ) { if ( mv ! = null ) { mv . visit attribute ( attribute ) ; } }
public void visit nest host ( final string nest host ) { if ( api < opcodes . asm7 ) { throw new unsupported operation exception ( `` this feature require asm7 `` ) ; } if ( cv ! = null ) { cv . visit nest host ( nest host ) ; } }
public class graph blacklist module ( final string . . . module names ) { for ( final string module name : module name ) { scan spec . module white black list . add to blacklist ( white black list . normalize package or class name ( module name ) ) ; } return this ; }
public object [ ] get bootstrap method argument ( ) { return bootstrap method argument ; }
public object [ ] get bootstrap method argument ( ) { return bootstrap method argument ; }
public void visit attribute ( final attribute attribute ) { if ( mv ! = null ) { mv . visit attribute ( attribute ) ; } }
public int get tag no ( ) { return tag . get tag ( ) ; }
public annotation visitor visit insn annotation ( int type ref , type path type path , string desc , boolean visible ) { if ( api < opcodes . asm5 ) { throw new runtime exception ( ) ; } if ( mv ! = null ) { return mv . visit insn annotation ( type ref , type path , desc , visible ) ; } return null ; }
public void visit insn ( final int opcode ) { if ( mv ! = null ) { mv . visit insn ( opcode ) ; } }
public void visit label ( final label label ) { if ( mv ! = null ) { mv . visit label ( label ) ; } }
public signature visitor visit interface bound ( ) { return this ; }
protect annotation visitor create annotation remapper ( final annotation visitor annotation visitor ) { return new annotation remapper ( api , annotation visitor , remapper ) ; }
public static indexed filter create descriptor filter ( descriptor descriptor impl , boolean deep copy ) { final descriptor filter descriptor = ( deep copy ) ? new descriptor impl ( descriptor impl ) : descriptor impl ; return new indexed filter ( ) { @ override public boolean match ( descriptor d ) { return descriptor impl . descriptor equal ( filter descriptor , d ) ; } @ override public string get advertise contract ( ) { set < string > contract = filter descriptor . get advertised contract ( ) ; if ( contract == null || contract . be empty ( ) ) return null ; return contract . iterator ( ) . next ( ) ; } @ override public string get name ( ) { return filter descriptor . get name ( ) ; } } ; }
public string map method desc ( final string method descriptor ) { if ( `` ( ) v `` . equal ( method descriptor ) ) { return method descriptor ; } string builder string builder = new string builder ( `` ( `` ) ; for ( type argument type : type . get argument type ( method descriptor ) ) { string builder . append ( map type ( argument type ) . get descriptor ( ) ) ; } type return type = type . get return type ( method descriptor ) ; if ( return type == type . void_type ) { string builder . append ( `` ) v `` ) ; } else { string builder . append ( ' ) ' ) . append ( map type ( return type ) . get descriptor ( ) ) ; } return string builder . to string ( ) ; }
public void insert ( final abstract insn node previous insn , final insn list insn list ) { if ( insn list . size == 0 ) { return ; } size += insn list . size ; abstract insn node first insn list element = insn list . first insn ; abstract insn node last insn list element = insn list . last insn ; abstract insn node next insn = previous insn . next insn ; if ( next insn == null ) { last insn = last insn list element ; } else { next insn . previous insn = last insn list element ; } previous insn . next insn = first insn list element ; last insn list element . next insn = next insn ; first insn list element . previous insn = previous insn ; cache = null ; insn list . remove all ( false ) ; }
public void reset label ( ) { abstract insn node current insn = first insn ; while ( current insn ! = null ) { if ( current insn instanceof label node ) { ( ( label node ) current insn ) . reset label ( ) ; } current insn = current insn . next insn ; } }
public void clear ( ) { remove all ( check ) ; }
public void accept ( final module visitor module visitor ) { module visitor . visit export ( packaze , access , module == null ? null : module . to array ( new string [ 0 ] ) ) ; }
public string result ( ) { try { this . indent ( ) ; } catch ( runtime exception re ) { throw new runtime exception ( `` problem here : `` + this , re ) ; } if ( this . json == null ) { return null ; } string result string = this . result . to string ( ) ; return result string == null ? null : result string . trim ( ) ; }
public self be close to ( big decimal expect , percentage percentage ) { big decimal . assert be close to percentage ( info , actual , expect , percentage ) ; return myself ; }
public boolean be less than or equal ( final dewey decimal other ) { return ! be great than ( other ) ; }
public boolean be less than ( final dewey decimal other ) { return ! be great than or equal ( other ) ; }
public self contains sequence ( @ suppress warning ( `` unchecked `` ) element . . . sequence ) { array . assert contain sequence ( info , actual , sequence ) ; return myself ; }
public self do not contain key ( k key ) { return do not contain key ( key ) ; }
public self contain only key ( @ suppress warning ( `` unchecked `` ) k . . . key ) { map . assert contain only key ( info , actual , key ) ; return myself ; }
public self contain only ( boolean . . . value ) { array . assert contain only ( info , actual , value ) ; return myself ; }
public atomic reference array assert < t > do not contain sequence ( @ suppress warning ( `` unchecked `` ) t . . . sequence ) { array . assert do not contain sequence ( info , array , sequence ) ; return myself ; }
public self be equal to ignore give field ( object other , string . . . property or field to ignore ) { object . assert be equal to ignore give field ( info , actual , other , comparator by property or field , comparator by type , property or field to ignore ) ; return myself ; }
public self have no null field or property ( ) { object . assert have no null field or property except ( info , actual ) ; return myself ; }
public < t > self use comparator for type ( comparator < t > comparator , class < t > type ) { if ( iterables . get comparator ( ) == null ) { use element comparator ( new extend by type comparator ( get comparators by type ( ) ) ) ; } get comparators for element property or field type ( ) . put ( type , comparator ) ; get comparators by type ( ) . put ( type , comparator ) ; return myself ; }
public self be not equal to ( object expect ) { if ( actual == null || expect == null ) { super . be not equal to ( expect ) ; } else { comparables . assert not equal ( info , actual , expect ) ; } return myself ; }
public static list < string > line of ( url url ) { return u r l . line of ( url , charset . default charset ( ) ) ; }
public atomic reference array assert < t > contain only ( @ suppress warning ( `` unchecked `` ) t . . . value ) { array . assert contain only ( info , array , value ) ; return myself ; }
public atomic reference array assert < t > be at most ( int time , condition < ? super t > condition ) { array . assert be at most ( info , array , time , condition ) ; return myself ; }
public self be exactly ( int time , condition < ? super element > condition ) { array . assert be exactly ( info , actual , time , condition ) ; return myself ; }
public boolean evaluate ( final t object ) { boolean match = false ; for ( final predicate < ? super t > i predicate : i predicate ) { if ( i predicate . evaluate ( object ) ) { if ( match ) { return false ; } match = true ; } } return match ; }
public void override error message ( supplier < string > supplier ) { check state ( override error message == null , `` an error message have already be set with override error message ( string new error message ) `` ) ; override error message supplier = supplier ; }
protect duration get absolute duration ( temporal temporal1 , temporal temporal2 ) { return duration . between ( temporal1 , temporal2 ) . ab ( ) ; }
public void assert start with ( assertion info info , boolean [ ] actual , boolean [ ] sequence ) { array . assert start with ( info , failure , actual , sequence ) ; }
public static void set remove assert j related element from stack trace ( boolean remove assert j related element from stack trace ) { fail . set remove assert j related element from stack trace ( remove assert j related element from stack trace ) ; }
public void assert have content ( assertion info info , input stream actual , string expect ) { check not null ( expect , `` the string to compare to should not be null `` ) ; assert not null ( info , actual ) ; try { list < delta < string > > diffs = diff . diff ( actual , expect ) ; if ( diffs . be empty ( ) ) return ; throw failure . failure ( info , should have same content ( actual , expect , diffs ) ) ; } catch ( i o exception e ) { string msg = format ( `` unable to compare content of input stream : % n < % s > % nand string : % n < % s > `` , actual , expect ) ; throw new input stream exception ( msg , e ) ; } }
public void assert be in ( assertion info info , object actual , iterable < ? > value ) { check be not null and not empty ( value ) ; if ( ! be actual in ( actual , value ) ) throw failure . failure ( info , should be in ( actual , value , comparison strategy ) ) ; }
public void assert be zero ( assertion info info , number actual ) { assert equal by comparison ( info , actual , zero ( ) ) ; }
public void assert be positive ( assertion info info , number actual ) { assert great than ( info , actual , zero ( ) ) ; }
public void assert be positive ( assertion info info , number actual ) { assert great than ( info , actual , zero ( ) ) ; }
public void assert contain only ( assertion info info , boolean [ ] actual , boolean [ ] value ) { array . assert contain only ( info , failure , actual , value ) ; }
public void assert be exactly instance of ( assertion info info , object actual , class < ? > type ) { if ( ! actual be exactly instance of type ( actual , type , info ) ) throw failure . failure ( info , should be exactly instance ( actual , type ) ) ; }
public void assert be not in ( assertion info info , object actual , object [ ] value ) { check be not null and not empty ( value ) ; assert be not in ( info , actual , a list ( value ) ) ; }
public static string format date ( long value , date format thread localformat ) { string cache date = null ; long long value = value ; try { cached date = format cache . get ( long value ) ; } catch ( exception ex ) { } if ( cached date ! = null ) { return cache date ; } string new date ; date date value = new date ( value ) ; if ( thread localformat ! = null ) { new date = thread localformat . format ( date value ) ; synchronize ( format cache ) { update cache ( format cache , long value , new date ) ; } } else { synchronize ( format cache ) { new date = format . format ( date value ) ; update cache ( format cache , long value , new date ) ; } } return new date ; }
public static string format date ( date date ) { calendar calendar = gregorian calendar . get instance ( utc , locale . u ) ; calendar . set time ( date ) ; return do format date ( calendar ) ; }
public static date truncate time ( date date ) { if ( date == null ) return null ; calendar cal = to calendar ( date ) ; cal . set ( calendar . hour_of_day , 0 ) ; cal . set ( calendar . minute , 0 ) ; cal . set ( calendar . second , 0 ) ; cal . set ( calendar . millisecond , 0 ) ; return cal . get time ( ) ; }
public void add delta ( delta < t > delta ) { delta . add ( delta ) ; }
public static void set allow compare private field ( boolean allow compare private field ) { field support . comparison ( ) . set allow use private field ( allow compare private field ) ; }
public < t > boolean try get value ( class < t > cl , extend property definition property definition , out param < t > property value out ) throw argument exception { extended property extend property = null ; out param < extend property > extend property out = new out param < extend property > ( ) ; if ( this . try get property ( property definition , extend property out ) ) { extended property = extend property out . get param ( ) ; if ( ! cl . be assignable from ( property definition . get type ( ) ) ) { string error message = string . format ( `` property definition type ' % s ' and type parameter ' % s ' be n't compatible . `` , property definition . get type ( ) . get simple name ( ) , cl . get simple name ( ) ) ; throw new argument exception ( error message , `` property definition `` ) ; } property value out . set param ( ( t ) extend property . get value ( ) ) ; return true ; } else { property value out . set param ( null ) ; return false ; } }
public self have size great than ( int boundary ) { iterables . assert have size great than ( info , actual , boundary ) ; return myself ; }
public self have size less than or equal to ( int boundary ) { iterables . assert have size less than or equal to ( info , actual , boundary ) ; return myself ; }
public self contain only once ( @ suppress warning ( `` unchecked `` ) element . . . value ) { array . assert contain only once ( info , actual , value ) ; return myself ; }
public self have all null field or property ( ) { object . assert have all null field or property except ( info , actual ) ; return myself ; }
public static abstract short array assert < ? > give ( short [ ] actual ) { return assume that ( actual ) ; }
public static abstract long array assert < ? > give ( long [ ] actual ) { return assume that ( actual ) ; }
public static abstract float assert < ? > give ( float actual ) { return assume that ( actual ) ; }
public static abstract boolean assert < ? > give ( boolean actual ) { return assume that ( actual ) ; }
public static generic context resolve ( final class < ? > type , final class < ? > . . . ignore class ) { return new type generic context ( generic info factory . create ( type , ignore class ) , type ) ; }
public self ignore field match regexes ( string . . . regexes ) { recursive comparison configuration . ignore field match regexes ( regexes ) ; return myself ; }
public self ignore field match regexes ( string . . . regexes ) { recursive comparison configuration . ignore field match regexes ( regexes ) ; return myself ; }
protect assertion error failure with actual expect ( object actual , object expect , string error message format , object . . . argument ) { string error message = optional . of nullable ( info . override error message ( ) ) . or else ( format ( error message format , argument ) ) ; string description = message formatter . instance ( ) . format ( info . description ( ) , info . representation ( ) , error message ) ; assertion error assertion error = assertion error creator . assertion error ( description , actual , expect , info . representation ( ) ) ; failure . instance ( ) . remove assert j related element from stack trace if need ( assertion error ) ; remove custom assert related element from stack trace if need ( assertion error ) ; return assertion error ; }
public void assert have size ( assertion info info , boolean [ ] actual , int expect size ) { array . assert have size ( info , failure , actual , expect size ) ; }
public static < t > field < t [ ] > array ( t . . . value ) { return array ( tool . field ( value ) ) ; }
protect assertion error failure with actual expect ( object actual , object expect , string error message format , object . . . argument ) { string error message = optional . of nullable ( info . override error message ( ) ) . or else ( format ( error message format , argument ) ) ; string description = message formatter . instance ( ) . format ( info . description ( ) , info . representation ( ) , error message ) ; assertion error assertion error = assertion error creator . assertion error ( description , actual , expect , info . representation ( ) ) ; failure . instance ( ) . remove assert j related element from stack trace if need ( assertion error ) ; remove custom assert related element from stack trace if need ( assertion error ) ; return assertion error ; }
public self have field or property with value ( string name , object value ) { object . assert have field or property with value ( info , actual , name , value ) ; return myself ; }
public atomic integer assert do not have value ( int expect value ) { be not null ( ) ; int actual value = actual . get ( ) ; if ( object . get comparison strategy ( ) . be equal ( actual value , expect value ) ) { throw assertion error ( should not contain value ( actual , expect value ) ) ; } return myself ; }
public static boolean2 d array assert give ( boolean [ ] [ ] actual ) { return assume that ( actual ) ; }
public self be equal to compare field by field ( object other ) { object . assert be equal to ignore give field ( info , actual , other , comparator by property or field , comparator by type ) ; return myself ; }
public self have no null field or property ( ) { object . assert have no null field or property except ( info , actual ) ; return myself ; }
public self have field or property with value ( string name , object value ) { object . assert have field or property with value ( info , actual , name , value ) ; return myself ; }
public self be equal to compare field by field recursively ( object other ) { object . assert be equal to compare field by field recursively ( info , actual , other , comparator by property or field , get comparators by type ( ) ) ; return myself ; }
public self be close to ( int expect , offset < integer > offset ) { integer . assert be close to ( info , actual , expect , offset ) ; return myself ; }
public atomic reference array assert < t > be at most ( int time , condition < ? super t > condition ) { array . assert be at most ( info , array , time , condition ) ; return myself ; }
public v put ( final k key , final v value ) { if ( this . mutator == null ) { throw new unsupported operation exception ( `` no mutator specify `` ) ; } return this . mutator . put ( this , this . composite , key , value ) ; }
public void remove datanode ( final datanode i d node ) throw unregistered node exception { namesystem . write lock ( ) ; try { final datanode descriptor descriptor = get datanode ( node ) ; if ( descriptor ! = null ) { remove datanode ( descriptor ) ; } else { name node . state change log . warn ( `` block * remove datanode : `` + node + `` do not exist `` ) ; } } finally { namesystem . write unlock ( ) ; } }
public static < t > supplier < queue < t > > unbounded multiproducer ( ) { return ( ) - > hook . wrap queue ( new mpsc link queue < t > ( ) ) ; }
public static < t > replay subject < t > create with size ( int max size ) { return new replay subject < t > ( new size bound replay buffer < t > ( max size ) ) ; }
public static void catch uncaught exception by default ( ) { default catch uncaught exception = true ; }
public condition factory catch uncaught exception ( ) { return new condition factory ( alias , timeout , poll interval , poll delay , true , condition evaluation listener ) ; }
public < t > ct field reference < t > create reference ( field field ) { ct field reference < t > field ref = factory . core ( ) . create field reference ( ) ; field ref . set simple name ( field . get name ( ) ) ; field ref . set declare type ( factory . type ( ) . create reference ( field . get declare class ( ) ) ) ; ct type reference < t > t = factory . type ( ) . create reference ( ( class < t > ) field . get type ( ) ) ; field ref . set type ( t ) ; return field ref ; }
public static < t > t get internal state ( object object , string field name ) { field find field = find field in hierarchy ( object , field name ) ; try { return ( t ) find field . get ( object ) ; } catch ( illegal access exception e ) { throw new runtime exception ( `` internal error : fail to get field in method get internal state . `` , e ) ; } }
public static object find value of type ( collection < ? > collection , class < ? > [ ] type ) { if ( be empty ( collection ) || object . be empty ( type ) ) { return null ; } for ( class < ? > type : type ) { object value = find value of type ( collection , type ) ; if ( value ! = null ) { return value ; } } return null ; }
public static void ignore exception by default ( ) { default exception ignorer = new predicate exception ignorer ( e - > true ) ; }
public condition factory during ( duration timeout ) { return new condition factory ( alias , timeout constraint . with hold predicate time ( timeout ) , poll interval , poll delay , catch uncaught exception , exception ignorer , condition evaluation listener , executor lifecycle ) ; }
public asm visitor wrapper . for declared method on ( element matcher < ? super method description > matcher ) { return new asm visitor wrapper . for declared method ( ) . method ( matcher , this ) ; }
public modifier adjustment with constructor modifier ( element matcher < ? super method description > matcher , modifier contributor . for method . . . modifier contributor ) { return with constructor modifier ( matcher , arrays . a list ( modifier contributor ) ) ; }
public modifier adjustment with method modifier ( modifier contributor . for method . . . modifier contributor ) { return with method modifier ( array . a list ( modifier contributor ) ) ; }
public static type reference adjustment relaxed ( ) { return new type reference adjustment ( false , none ( ) ) ; }
public static with implicit invocation target type invoke ( method description method description ) { method description . in defined shape declare method = method description . a defined ( ) ; return declare method . get return type ( ) . a erasure ( ) . equal ( method description . get return type ( ) . a erasure ( ) ) ? invoke ( declared method ) : of generic method . of ( method description , invoke ( declared method ) ) ; }
public < t > dynamic type . builder < t > redefine ( class < t > type ) { return redefine ( type , class file locator . for class loader . of ( type . get class loader ( ) ) ) ; }
public static byte [ ] serialize ( object object ) { if ( object == null ) { return null ; } byte array output stream baos = new byte array output stream ( 1024 ) ; try { object output stream oos = new object output stream ( baos ) ; oos . write object ( object ) ; oos . flush ( ) ; } catch ( i o exception ex ) { throw new illegal argument exception ( `` fail to serialize object of type : `` + object . get class ( ) , ex ) ; } return baos . to byte array ( ) ; }
public static primitive unboxing delegate for primitive ( type definition type definition ) { if ( type definition . represent ( boolean . class ) ) { return boolean ; } else if ( type definition . represent ( byte . class ) ) { return byte ; } else if ( type definition . represent ( short . class ) ) { return short ; } else if ( type definition . represent ( char . class ) ) { return character ; } else if ( type definition . represent ( int . class ) ) { return integer ; } else if ( type definition . represent ( long . class ) ) { return long ; } else if ( type definition . represent ( float . class ) ) { return float ; } else if ( type definition . represent ( double . class ) ) { return double ; } else { throw new illegal argument exception ( `` expect non-void primitive type instead of `` + type definition ) ; } }
public equal method with primitive wrapper type field first ( ) { return with field order ( type property comparator . for_primitive_wrapper_types ) ; }
public static without specify target invoke ( method description method description ) { return invoke ( new method locator . for explicit method ( method description ) ) ; }
public method call with argument array ( ) { return with ( argument loader . for method parameter array . for instrumented method . instance ) ; }
public static < t extend type definition > element matcher . junction < t > be array ( ) { return new array type matcher < t > ( ) ; }
public void visit var insn ( int opcode , int var ) { if ( mv ! = null ) { mv . visit var insn ( opcode , var ) ; } }
public void visit table switch insn ( final int min , final int max , final label dflt , final label . . . label ) { if ( mv ! = null ) { mv . visit table switch insn ( min , max , dflt , label ) ; } }
public double miss rate ( ) { long request count = request count ( ) ; return ( request count == 0 ) ? 0 . 0 : ( double ) miss count / request count ; }
public long get class cache eviction count ( ) { return class map . stats ( ) . eviction count ( ) ; }
public boolean enter ( long time , time unit unit ) { final long timeout nanos = to safe nanos ( time , unit ) ; final reentrant lock lock = this . lock ; if ( ! fair & & lock . try lock ( ) ) { return true ; } boolean interrupted = thread . interrupt ( ) ; try { final long start time = system . nano time ( ) ; for ( long remain nanos = timeout nanos ; ; ) { try { return lock . try lock ( remain nanos , time unit . nanosecond ) ; } catch ( interrupted exception interrupt ) { interrupted = true ; remain nanos = remain nanos ( start time , timeout nanos ) ; } } } finally { if ( interrupt ) { thread . current thread ( ) . interrupt ( ) ; } } }
public path create src ( ) { if ( src == null ) { src = new path ( get project ( ) ) ; } return src . create path ( ) ; }
public static i18n conversion category string to i18n conversion category ( string string ) { string = string . to lower case ( ) ; for ( i18n conversion category v : new i18n conversion category [ ] { date , number } ) { for ( string s : v . string ) { if ( s . equal ( string ) ) { return v ; } } } throw new illegal argument exception ( `` invalid format type . `` ) ; }
public static @ unsigned short to unsigned short ( @ unsigned char c ) { return ( short ) ( ( ( int ) c ) & 0xff ) ; }
public static string to unsigned string ( @ unsigned byte b , int radix ) { return integer . to unsigned string ( byte . to unsigned int ( b ) , radix ) ; }
public resolve method [ ] get static method ( ) { if ( _static method == null ) { _static method = resolve static method ( ) ; } return _static method ; }
public static fast hash map copy fast hash map ( fast hash map map ) { fast hash map result = new fast hash map ( ) ; iterator i = map . entry set ( ) . iterator ( ) ; while ( i . have next ( ) ) { entry entry = ( entry ) i . next ( ) ; string key = ( string ) entry . get key ( ) ; object value = entry . get value ( ) ; if ( value instanceof msg ) { result . put ( key , ( ( msg ) value ) . clone ( ) ) ; } else if ( value instanceof arg ) { result . put ( key , ( ( arg ) value ) . clone ( ) ) ; } else if ( value instanceof var ) { result . put ( key , ( ( var ) value ) . clone ( ) ) ; } else { result . put ( key , value ) ; } } result . set fast ( true ) ; return result ; }
public void null instead of clone ( final class < ? > . . . c ) { for ( final class < ? > cl : c ) { null instead . add ( cl ) ; } }
public void set u r l ( url _url ) { this . url = _url ; }
public void remove comet listener ( comet listener listener ) { _comet listener . remove ( listener ) ; }
public void set update interval ( string update interval ) { this . update interval = update interval ; } // -- void set update interval ( string )
public static string retrieve child ( string parent id ) { return `` select * from `` + streams_table_name + `` where `` + streams_parent_id_key + `` = `` + format text value ( parent id ) + `` ; `` ; }
public void add child stream ( stream child stream ) { if ( child map == null || child == null ) { child = new hash set < stream > ( ) ; child map = new hash map < string , stream > ( ) ; } if ( ! child stream . have child ( this . id ) ) { child stream . set parent id ( this . id ) ; child . add ( child stream ) ; child map . put ( child stream . get id ( ) , child stream ) ; } else { system . out . println ( `` error : stream . add child stream ( ) - no cycle allow `` ) ; } }
public void add tag ( string p tag ) { if ( tags == null ) { tags = new hash set < string > ( ) ; } tag . add ( p tag ) ; }
public static void activate online ( ) { online activate = true ; }
public synchronize static void print thread info ( print stream stream , string title ) { final int stack_depth = 20 ; boolean contention = thread bean . be thread contention monitoring enable ( ) ; long [ ] thread id = thread bean . get all thread id ( ) ; stream . println ( `` process thread dump : `` + title ) ; stream . println ( thread id . length + `` active thread `` ) ; for ( long tid : thread id ) { thread info info = thread bean . get thread info ( tid , stack_depth ) ; if ( info == null ) { stream . println ( `` inactive `` ) ; continue ; } stream . println ( `` thread `` + get task name ( info . get thread id ( ) , info . get thread name ( ) ) + `` : `` ) ; thread . state state = info . get thread state ( ) ; stream . println ( `` state : `` + state ) ; stream . println ( `` block count : `` + info . get blocked count ( ) ) ; stream . println ( `` wait count : `` + info . get waited count ( ) ) ; if ( contention ) { stream . println ( `` block time : `` + info . get blocked time ( ) ) ; stream . println ( `` wait time : `` + info . get waited time ( ) ) ; } if ( state == thread . state . wait ) { stream . println ( `` wait on `` + info . get lock name ( ) ) ; } else if ( state == thread . state . block ) { stream . println ( `` block on `` + info . get lock name ( ) ) ; stream . println ( `` block by `` + get task name ( info . get lock owner id ( ) , info . get lock owner name ( ) ) ) ; } stream . println ( `` stack : `` ) ; for ( stack trace element frame : info . get stack trace ( ) ) { stream . println ( `` `` + frame . to string ( ) ) ; } } stream . flush ( ) ; }
public object get ( string name , string key ) { object value = value . get ( name ) ; if ( value == null ) { throw new null pointer exception ( `` no mapped value for ' `` + name + `` ( `` + key + `` ) ' `` ) ; } else if ( value instanceof map ) { return ( ( ( map ) value ) . get ( key ) ) ; } else { throw new illegal argument exception ( `` non-mapped property for ' `` + name + `` ( `` + key + `` ) ' `` ) ; } }
public dyna property get dyna property ( string name ) { if ( name == null ) { throw new illegal argument exception ( `` no property name specify `` ) ; } return ( ( dyna property ) property map . get ( name ) ) ; }
public static comparator transform comparator ( comparator comparator , transformer transformer ) { if ( comparator == null ) { comparator = natural_comparator ; } return new transform comparator ( transformer , comparator ) ; }
public < t > list < t > get bean ( class < t > bean type ) { int index = argument utils . index of ( bean type , bean type ) ; if ( index == -1 ) { throw new illegal argument exception ( `` unknown bean type ' `` + bean type . get simple name ( ) + `` ' . available type be : `` + array . to string ( bean type ) ) ; } return bean [ index ] ; }
public throwable init cause ( throwable cause ) { return super . init cause ( cause ) ; }
public static void set cache fast ( map map , boolean fast ) { if ( map instanceof weak fast hash map ) { ( ( weak fast hash map ) map ) . set fast ( fast ) ; } }
public locale convert utils bean get locale convert utils ( ) { return locale convert utils ; }
public synchronize object get initial value ( ) { return get initial value ( null ) ; }
public string to string ( ) { return `` converter manager [ `` + i instant converter . size ( ) + `` instant , `` + i partial converter . size ( ) + `` partial , `` + i duration converter . size ( ) + `` duration , `` + i period converter . size ( ) + `` period , `` + i interval converter . size ( ) + `` interval ] `` ; }
public void set time zone ( date time zone time zone ) { this . time zone = time zone ; }
public boolean find pattern ( string pattern ) { for ( string s : pattern ) { if ( s . equal ( pattern ) ) return true ; } return false ; }
protect format get format ( string pattern , locale locale ) { date format formatter = null ; boolean use pattern = ( pattern ! = null & & pattern . length ( ) > 0 ) ; if ( ! use pattern ) { formatter = ( date format ) get format ( locale ) ; } else if ( locale == null ) { formatter = new simple date format ( pattern ) ; } else { date format symbols symbol = new date format symbol ( locale ) ; formatter = new simple date format ( pattern , symbol ) ; } formatter . set lenient ( false ) ; return formatter ; }
public string to string ( ) { string buffer buffer = new string buffer ( ) ; buffer . append ( to string ( get class ( ) ) ) ; buffer . append ( `` [ use default= `` ) ; buffer . append ( be use default ( ) ) ; buffer . append ( `` , use locale format= `` ) ; buffer . append ( use locale format ) ; if ( display pattern ! = null ) { buffer . append ( `` , patterns= { `` ) ; buffer . append ( display pattern ) ; buffer . append ( ' } ' ) ; } if ( locale ! = null ) { buffer . append ( `` , locale= `` ) ; buffer . append ( locale ) ; } if ( time zone ! = null ) { buffer . append ( `` , time zone= `` ) ; buffer . append ( time zone ) ; } buffer . append ( ' ] ' ) ; return buffer . to string ( ) ; }
public static long get default long ( ) { return ( convert utils bean . get instance ( ) . get default long ( ) ) ; }
public static void set default short ( short new default short ) { convert utils bean . get instance ( ) . set default short ( new default short ) ; }
public static class < ? > primitive type ( class < ? > type ) { if ( type . be primitive ( ) ) { return type ; } if ( type == integer . class ) { return integer . type ; } if ( type == long . class ) { return long . type ; } if ( type == boolean . class ) { return boolean . type ; } if ( type == double . class ) { return double . type ; } if ( type == float . class ) { return float . type ; } if ( type == byte . class ) { return byte . type ; } if ( type == short . class ) { return short . type ; } if ( type == character . class ) { return character . type ; } return null ; }
public boolean be indexed ( ) { if ( type == null ) { return ( false ) ; } else if ( type . be array ( ) ) { return ( true ) ; } else if ( list . class . be assignable from ( type ) ) { return ( true ) ; } else { return ( false ) ; } }
public boolean be map ( string expression ) { if ( expression == null || expression . length ( ) == 0 ) { return false ; } for ( int i = 0 ; i < expression . length ( ) ; i++ ) { char c = expression . char at ( i ) ; if ( c == nest || c == indexed_start ) { return false ; } else if ( c == mapped_start ) { return true ; } } return false ; }
public string get property ( string expression ) { if ( expression == null || expression . length ( ) == 0 ) { return expression ; } for ( int i = 0 ; i < expression . length ( ) ; i++ ) { char c = expression . char at ( i ) ; if ( c == nest ) { return expression . substring ( 0 , i ) ; } else if ( c == mapped_start || c == indexed_start ) { return expression . substring ( 0 , i ) ; } } return expression ; }
public boolean be restrict to non negative ( ) { return be restrict ; }
public static wrap dyna class create dyna class ( class bean class ) { wrap dyna class dyna class = ( wrap dyna class ) get dyna class map ( ) . get ( bean class ) ; if ( dyna class == null ) { dyna class = new wrap dyna class ( bean class ) ; get dyna class map ( ) . put ( bean class , dyna class ) ; } return ( dyna class ) ; }
public object convert ( string [ ] value , class clazz , string pattern ) { return convert ( value , clazz , get default locale ( ) , pattern ) ; }
public method get map read method ( ) { return map read method ref . get ( ) ; }
public void set map read method ( method map getter ) throw introspection exception { map read method ref = new map method reference ( mapped getter ) ; find mapped property type ( ) ; }
protect static convert utils bean get instance ( ) { return bean utils bean . get instance ( ) . get convert utils ( ) ; }
public int read ( ) throw i o exception { int result = read current ( ) ; if ( result == eof & & ! eof ) { open file ( ++current index ) ; result = read current ( ) ; } return result ; }
public int hash code ( ) { int h = 0 ; iterator < map . entry < object , object > > i = entry set ( ) . iterator ( ) ; while ( i . have next ( ) ) h += i . next ( ) . hash code ( ) ; return h ; } // hash code
public instance < object > instance ( ) { check state ( ) ; return get instance ( ) ; }
public int get desc padding ( ) { return default desc pad ; }
public static < e > comparator < e > null low comparator ( comparator < e > comparator ) { if ( comparator == null ) { comparator = natural_comparator ; } return new null comparator < > ( comparator , false ) ; }
public void set comparator ( comparator < suggest word > comparator ) { this . comparator = comparator ; }
public string get long opt separator ( ) { return long opt separator ; }
public option set require ( boolean require ) { this . require = require ; return this ; }
public byte [ ] encode ( final byte [ ] raw ) { return to ascii byte ( raw ) ; }
public static string crypt ( final byte [ ] key byte ) { return crypt ( key byte , null ) ; }
public static message digest get sha512_256 digest ( ) { return get digest ( message digest algorithms . sha_512_256 ) ; }
public byte [ ] hmac ( final input stream value to digest ) throw i o exception { final byte [ ] buffer = new byte [ stream_buffer_length ] ; int read ; while ( ( read = value to digest . read ( buffer , 0 , stream_buffer_length ) ) > -1 ) { mac . update ( buffer , 0 , read ) ; } return mac . do final ( ) ; }
public static mac get hmac sha384 ( final byte [ ] key ) { return get initialize mac ( hmac algorithm . hmac_sha_384 , key ) ; }
public static string hmac sha256 hex ( final byte [ ] key , final byte [ ] value to digest ) { return hex . encode hex string ( hmac sha256 ( key , value to digest ) ) ; }
public static string hmac sha1 hex ( final byte [ ] key , final byte [ ] value to digest ) { return hex . encode hex string ( hmac sha1 ( key , value to digest ) ) ; }
public static string sha512 crypt ( final byte [ ] key byte , string salt ) { if ( salt == null ) { salt = sha512_prefix + b64 . get random salt ( 8 ) ; } return sha2 crypt ( key byte , salt , sha512_prefix , sha512_blocksize , message digest algorithm . sha_512 ) ; }
public void set rule type ( final rule type rule type ) { this . engine = new phonetic engine ( this . engine . get name type ( ) , rule type , this . engine . be concat ( ) , this . engine . get max phoneme ( ) ) ; }
public void set concat ( final boolean concat ) { this . engine = new phonetic engine ( this . engine . get name type ( ) , this . engine . get rule type ( ) , concat , this . engine . get max phoneme ( ) ) ; }
public object get property ( string name ) { if ( `` name `` . equal ( name ) ) { return function name . get display name ( ) ; } else if ( `` a `` . equal ( name ) ) { return result type . to string ( ) ; } else { return null ; } }
public r pattern get l context ( ) { return this . l context ; }
public static final int string difference ( string s1 , string s2 ) { int len1 = s1 . length ( ) ; int len2 = s2 . length ( ) ; int len = len1 < len2 ? len1 : len2 ; for ( int i = 0 ; i < len ; i++ ) { if ( s1 . char at ( i ) ! = s2 . char at ( i ) ) { return i ; } } return len ; }
public charset charset ( ) { string charset = auth params . get ( `` charset `` ) ; if ( charset ! = null ) { try { return charset . for name ( charset ) ; } catch ( exception ignore ) { } } return iso_8859_1 ; }
public object encode ( final object obj ) throw encoder exception { if ( obj == null ) { return null ; } else if ( obj instanceof byte [ ] ) { return encode ( ( byte [ ] ) obj ) ; } else if ( obj instanceof string ) { return encode ( ( string ) obj ) ; } else { throw new encoder exception ( `` object of type `` + obj . get class ( ) . get name ( ) + `` can not be url encode `` ) ; } }
public static message digest get digest ( final string algorithm ) { try { return message digest . get instance ( algorithm ) ; } catch ( final no such algorithm exception e ) { throw new illegal argument exception ( e ) ; } }
public static message digest get sha384 digest ( ) { return get digest ( message digest algorithms . sha_384 ) ; }
public static message digest get sha384 digest ( ) { return get digest ( message digest algorithms . sha_384 ) ; }
public static string sha512_256 hex ( final byte [ ] data ) { return hex . encode hex string ( sha512_256 ( data ) ) ; }
public boolean be encode blank ( ) { return this . encode blank ; }
public boolean be empty ( ) { if ( fast ) { return ( map . be empty ( ) ) ; } else { synchronize ( map ) { return ( map . be empty ( ) ) ; } } }
public iterator < e > iterator ( ) { if ( all . be empty ( ) ) { return empty iterator . < e > empty iterator ( ) ; } final iterator chain < e > chain = new iterator chain < > ( ) ; for ( final set < e > item : all ) { chain . add iterator ( item . iterator ( ) ) ; } return chain ; }
public set < e > unique set ( ) { if ( unique set == null ) { unique set = create unique set ( ) ; } return unique set ; }
public static < e > bag < e > collection bag ( final bag < e > bag ) { return collection bag . collection bag ( bag ) ; }
public v put ( final multi key < ? extend k > key , final v value ) { check key ( key ) ; return super . put ( key , value ) ; }
public v get ( final object key ) { check key ( key ) ; final node < k , v > node = lookup key ( key ) ; return node == null ? null : node . get value ( ) ; }
public k next key ( final k key ) { check key ( key ) ; final node < k , v > node = next great ( lookup key ( key ) , key ) ; return node == null ? null : node . get key ( ) ; }
public string to string ( ) { return key buffer . to string ( ) ; }
public collection < v > value ( ) { final composite collection < v > value = new composite collection < > ( ) ; for ( int i = composite . length - 1 ; i > = 0 ; -- i ) { value . add composited ( composite [ i ] . value ( ) ) ; } return value ; }
public list < set < e > > get set ( ) { return unmodifiable list . unmodifiable list ( all ) ; }
public boolean add all ( final int index , final collection < ? extend e > coll ) { final list < e > temp = new array list < > ( ) ; for ( final e e : coll ) { if ( set . add ( e ) ) { temp . add ( e ) ; } } return super . add all ( index , temp ) ; }
public static < c > int count match ( final iterable < c > input , final predicate < ? super c > predicate ) { return predicate == null ? 0 : ( int ) iterable utils . count match ( input , predicate ) ; }
public static < o > collection < o > select ( final iterable < ? extend o > input collection , final predicate < ? super o > predicate ) { final collection < o > answer = input collection instanceof collection < ? > ? new array list < o > ( ( ( collection < ? > ) input collection ) . size ( ) ) : new array list < o > ( ) ; return select ( input collection , predicate , answer ) ; }
public static < t > factory < t > constant factory ( final t constant to return ) { if ( constant to return == null ) { return null_instance ; } return new constant factory < > ( constant to return ) ; }
public static < t > iterable < t > consume iterable ( final iterable < t > iterable ) { if ( iterable instanceof queue ) { return new fluent iterable < t > ( ) { @ override public iterator < t > iterator ( ) { return new consume queue iterator < t > ( ( queue < t > ) iterable ) ; } @ override public string to string ( ) { return `` iterables . consume iterable ( . . . ) '' ; } } ; } check not null ( iterable ) ; return new fluent iterable < t > ( ) { @ override public iterator < t > iterator ( ) { return iterators . consume iterator ( iterable . iterator ( ) ) ; } @ override public string to string ( ) { return `` iterables . consume iterable ( . . . ) '' ; } } ; }
public static < e > iterator < e > a iterator ( final enumeration < ? extend e > enumeration ) { if ( enumeration == null ) { throw new null pointer exception ( `` enumeration must not be null `` ) ; } return new enumeration iterator < > ( enumeration ) ; }
public static < e > void for each ( final iterable < e > iterable , final closure < ? super e > closure ) { iterator utils . for each ( empty iterator if null ( iterable ) , closure ) ; }
public boolean evaluate ( final t object ) { return i predicate1 . evaluate ( object ) || i predicate2 . evaluate ( object ) ; }
public static < t > predicate < t > equal predicate ( final t object , final equator < t > equator ) { if ( object == null ) { return null predicate . null predicate ( ) ; } return new equal predicate < > ( object , equator ) ; }
public boolean evaluate ( final t object ) { for ( final predicate < ? super t > i predicate : i predicate ) { if ( i predicate . evaluate ( object ) ) { return true ; } } return false ; }
public void execute ( final e input ) { if ( i predicate . evaluate ( input ) ) { i true closure . execute ( input ) ; } else { i false closure . execute ( input ) ; } }
public boolean evaluate ( final t object ) { final t result = i transformer . transform ( object ) ; return i predicate . evaluate ( result ) ; }
public static < e > bag < e > predicate bag ( final bag < e > bag , final predicate < ? super e > predicate ) { return predicate bag . predicate bag ( bag , predicate ) ; }
public static < e > iterable < e > loop iterable ( final iterable < e > iterable ) { check not null ( iterable ) ; return new fluent iterable < e > ( ) { @ override public iterator < e > iterator ( ) { return new lazy iterator chain < e > ( ) { @ override protect iterator < ? extend e > next iterator ( final int count ) { if ( iterable utils . be empty ( iterable ) ) { return null ; } return iterable . iterator ( ) ; } } ; } } ; }
public static < e > iterable < e > filter iterable ( final iterable < e > iterable , final predicate < ? super e > predicate ) { check not null ( iterable ) ; if ( predicate == null ) { throw new null pointer exception ( `` predicate must not be null . `` ) ; } return new fluent iterable < e > ( ) { @ override public iterator < e > iterator ( ) { return iterator utils . filter iterator ( empty iterator if null ( iterable ) , predicate ) ; } } ; }
public static < e > iterable < e > filter iterable ( final iterable < e > iterable , final predicate < ? super e > predicate ) { check not null ( iterable ) ; if ( predicate == null ) { throw new null pointer exception ( `` predicate must not be null . `` ) ; } return new fluent iterable < e > ( ) { @ override public iterator < e > iterator ( ) { return iterator utils . filter iterator ( empty iterator if null ( iterable ) , predicate ) ; } } ; }
public static boolean be empty ( iterable < ? > iterable ) { if ( iterable instanceof collection ) { return ( ( collection < ? > ) iterable ) . be empty ( ) ; } return ! iterable . iterator ( ) . have next ( ) ; }
public boolean have next ( ) { return index < end ; }
public static int get length ( object array ) { if ( array == null ) { return 0 ; } return array . get length ( array ) ; }
public void remove ( ) { if ( last use iterator == null ) { throw new illegal state exception ( `` iterator remove ( ) can not be call at this time `` ) ; } last used iterator . remove ( ) ; last used iterator = null ; }
public static < e > iterator < e > peeking iterator ( final iterator < ? extend e > iterator ) { return peek iterator . peek iterator ( iterator ) ; }
public predicate < ? super e > get predicate ( ) { return i predicate ; }
public static < e > resettable iterator < e > empty iterator ( ) { return empty iterator . < e > resettable empty iterator ( ) ; }
public void reset ( ) { if ( iterator instanceof list iterator ) { final list iterator < ? > li = ( list iterator < ? > ) iterator ; while ( li . previous index ( ) > = 0 ) { li . previous ( ) ; } return ; } current index = 0 ; }
public e next ( ) { if ( list . be empty ( ) ) { throw new no such element exception ( `` there be no element for this iterator to loop on `` ) ; } if ( iterator . have next ( ) == false ) { reset ( ) ; } return iterator . next ( ) ; }
public void remove ( ) { get iterator ( ) . remove ( ) ; }
public e next ( ) { final e obj = iterator . previous ( ) ; valid for update = true ; return obj ; }
public boolean have next ( ) { update current iterator ( ) ; last used iterator = current iterator ; return current iterator . have next ( ) ; }
public boolean have previous ( ) { return ! before first & & ! remove ; }
public e previous ( ) { if ( before first || remove ) { throw new no such element exception ( ) ; } before first = true ; return object ; }
protect void set maximum cache size ( final int maximum cache size ) { this . maximum cache size = maximum cache size ; shrink cache to maximum size ( ) ; }
protect void remove node ( final node < e > node ) { super . remove node ( node ) ; add node to cache ( node ) ; }
public void clear ( ) { mod count++ ; size = 0 ; root = null ; }
public int hash code ( ) { if ( fast ) { int hash code = 1 ; java . util . iterator i = list . iterator ( ) ; while ( i . have next ( ) ) { object o = i . next ( ) ; hash code = 31 * hash code + ( o == null ? 0 : o . hash code ( ) ) ; } return ( hash code ) ; } else { synchronize ( list ) { int hash code = 1 ; java . util . iterator i = list . iterator ( ) ; while ( i . have next ( ) ) { object o = i . next ( ) ; hash code = 31 * hash code + ( o == null ? 0 : o . hash code ( ) ) ; } return ( hash code ) ; } } }
public static < e > list < e > retain all ( final collection < e > collection , final collection < ? > retain ) { final list < e > list = new array list < > ( math . min ( collection . size ( ) , retain . size ( ) ) ) ; for ( final e obj : collection ) { if ( retain . contains ( obj ) ) { list . add ( obj ) ; } } return list ; }
public set < k > key set ( ) { if ( key set == null ) { key set = new reference key set < > ( this ) ; } return key set ; }
public void clear ( ) { final iterator < entry < e > > it = entry set ( ) . iterator ( ) ; while ( it . have next ( ) ) { it . next ( ) ; it . remove ( ) ; } }
protect boolean be set value check ( ) { return value predicate ! = null ; }
protect void add entry ( hash entry entry , int hash index ) { link entry link = ( link entry ) entry ; link . after = header ; link . before = header . before ; header . before . after = link ; header . before = link ; data [ hash index ] = entry ; }
protect void purge before read ( ) { purge ( ) ; }
public v remove ( final object key ) { for ( int i = this . composite . length - 1 ; i > = 0 ; -- i ) { if ( this . composite [ i ] . contains key ( key ) ) { return this . composite [ i ] . remove ( key ) ; } } return null ; }
public k last key ( ) { if ( size == 0 ) { throw new no such element exception ( `` map be empty `` ) ; } return header . before . get key ( ) ; }
public set < k > key set ( ) { return new key view ( ) ; }
public string to string ( ) { if ( size ( ) == 0 ) { return `` { } `` ; } final string builder buf = new string builder ( 32 * size ( ) ) ; buf . append ( ' { ' ) ; final map iterator < k , v > it = map iterator ( ) ; boolean have next = it . have next ( ) ; while ( have next ) { final k key = it . next ( ) ; final v value = it . get value ( ) ; buf . append ( key == this ? `` ( this map ) `` : key ) . append ( '= ' ) . append ( value == this ? `` ( this map ) `` : value ) ; have next = it . have next ( ) ; if ( have next ) { buf . append ( ' , ' ) . append ( ' ' ) ; } } buf . append ( ' } ' ) ; return buf . to string ( ) ; }
public boolean be scan ( ) { return scan ; }
public int hash code ( ) { int h = 0x8004a00b ; h ^= prefix start ; h ^= local name start ; for ( int i=prefix start-1 ; i > =0 ; i -- ) { h ^= ( content [ i ] < < ( i & 0x1f ) ) ; } return h ; }
public void add ( collection < key > key ) { if ( key == null ) { throw new illegal argument exception ( `` collection < key > may not be null `` ) ; } for ( key key : key ) { add ( key ) ; } } //end add ( )
protect v check set value ( final v value ) { if ( value predicate . evaluate ( value ) == false ) { throw new illegal argument exception ( `` can not set value - predicate reject it `` ) ; } return value ; }
public set < k > key set ( ) { final set < k > key = new open hash set < > ( ) ; for each key ( new object procedure < k > ( ) { @ override public boolean apply ( k element ) { key . add ( element ) ; return true ; } } ) ; return key ; }
public static < k > byte get byte ( final map < ? super k , ? > map , final k key ) { final number answer = get number ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof byte ) { return ( byte ) answer ; } return byte . value of ( answer . byte value ( ) ) ; }
public static < k > short get short ( final map < ? super k , ? > map , final k key ) { final number answer = get number ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof short ) { return ( short ) answer ; } return short . value of ( answer . short value ( ) ) ; }
public static < k > integer get integer ( final map < ? super k , ? > map , final k key ) { final number answer = get number ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof integer ) { return ( integer ) answer ; } return integer . value of ( answer . int value ( ) ) ; }
public boolean put all ( final map < ? extend k , ? extend v > map ) { if ( map == null ) { throw new null pointer exception ( `` map must not be null . `` ) ; } boolean change = false ; for ( final map . entry < ? extend k , ? extend v > entry : map . entry set ( ) ) { change |= put ( entry . get key ( ) , entry . get value ( ) ) ; } return change ; }
public collection < v > get ( final k key ) { return wrap collection ( key ) ; }
public static < e > string to string ( final iterator < e > iterator ) { return to string ( iterator , transformer utils . string value transformer ( ) , default_tostring_delimiter , default_tostring_prefix , default_tostring_suffix ) ; }
public static < e > synchronize multi set < e > synchronize multi set ( final multi set < e > multiset ) { return new synchronize multi set < > ( multiset ) ; }
public static < t > predicate < t > not null predicate ( ) { return not null predicate . not null predicate ( ) ; }
public static < t > predicate < t > equal predicate ( final t object , final equator < t > equator ) { if ( object == null ) { return null predicate . null predicate ( ) ; } return new equal predicate < > ( object , equator ) ; }
public static < t > predicate < t > all predicate ( final predicate < ? super t > . . . predicate ) { return all predicate . all predicate ( predicate ) ; }
protect queue < e > get queue ( ) { return ( queue < e > ) decorate ( ) ; }
public t change get change at index ( int index ) { if ( index < 0 || index > = this . get count ( ) ) { throw new index out of bound exception ( string . format ( `` index % d be out of range [ 0 . . % d [ . `` , index , this . get count ( ) ) ) ; } return this . change . get ( index ) ; }
public void accept ( final command visitor < t > visitor ) { visitor . visit delete command ( get object ( ) ) ; }
public static < e > navigable set < e > synchronize navigable set ( navigable set < e > navigable set ) { return synchronize . navigable set ( navigable set ) ; }
public boolean add ( final e obj ) { if ( mutator == null ) { throw new unsupported operation exception ( `` add ( ) be not support on composite collection without a collection mutator strategy `` ) ; } return mutator . add ( this , all , obj ) ; }
public void set mutator ( final collection mutator < e > mutator ) { this . mutator = mutator ; }
public synchronize void add composited ( collection c ) { if ( ! ( c instanceof set ) ) { throw new illegal argument exception ( `` collection add must implement java . util . set `` ) ; } for ( iterator i = this . get collection ( ) . iterator ( ) ; i . have next ( ) ; ) { set set = ( set ) i . next ( ) ; collection intersect = collection utils . intersection ( set , c ) ; if ( intersects . size ( ) > 0 ) { if ( this . mutator == null ) { throw new unsupported operation exception ( `` collision add composited collection with no set mutator set `` ) ; } else if ( ! ( this . mutator instanceof set mutator ) ) { throw new unsupported operation exception ( `` collision add composited collection to a composite set with a collection mutator instead of a set mutator `` ) ; } ( ( set mutator ) this . mutator ) . resolve collision ( this , set , ( set ) c , intersects ) ; if ( collection utils . intersection ( set , c ) . size ( ) > 0 ) { throw new illegal argument exception ( `` attempt to add illegal entry unresolved by set mutator . resolve collision ( ) `` ) ; } } } super . add composited ( new collection [ ] { c } ) ; }
public void add composited ( final set < e > set1 , final set < e > set2 ) { add composited ( set1 ) ; add composited ( set2 ) ; }
public static < t > transformer < class < ? extend t > , t > instantiate transformer ( ) { return no_arg_instance ; }
public static < t > tensor list push back create ( scope scope , operand < ? > input handle , operand < t > tensor ) { operation builder op builder = scope . graph ( ) . op builder ( `` tensor list push back `` , scope . make op name ( `` tensor list push back `` ) ) ; op builder . add input ( input handle . a output ( ) ) ; op builder . add input ( tensor . a output ( ) ) ; return new tensor list push back ( op builder . build ( ) ) ; }
public int get count ( ) { return ( int ) bytes write ; }
protect void set byte count ( final long count ) { this . write = count ; }
public boolean be delete ( ) { return this == delete ; }
public static parameterized type parameterized type ( final class < ? > raw type , final type . . . actual type argument ) { return new parameterized type ( ) { @ override public type [ ] get actual type argument ( ) { return actual type argument ; } @ override public type get raw type ( ) { return raw type ; } @ override public type get owner type ( ) { return null ; } } ; }
public void set size ( long size ) { this . size = size ; }
public void set access time ( final date atime ) { this . atime = atime . get time ( ) ; }
public static level normalize ( level level ) { if ( level map . contains key ( level . int value ( ) ) ) { return level map . get ( level . int value ( ) ) ; } else if ( level . int value ( ) > = level . severe . int value ( ) ) { return level . severe ; } else if ( level . int value ( ) > = level . warn . int value ( ) ) { return level . warning ; } else if ( level . int value ( ) > = level . info . int value ( ) ) { return level . info ; } else { return level . fine ; } }
public boolean be anti item ( ) { return be anti item ; }
public void set last modified date ( final date last modified date ) { have last modified date = last modified date ! = null ; if ( have last modified date ) { this . last modified date = java time to ntfs time ( last modify date ) ; } }
protect void close new channel ( ) throw i o reactor exception { channel entry entry ; while ( ( entry = this . new channel . poll ( ) ) ! = null ) { final session request impl session request = entry . get session request ( ) ; if ( session request ! = null ) { session request . cancel ( ) ; } final socket channel channel = entry . get channel ( ) ; try { channel . close ( ) ; } catch ( final i o exception ignore ) { } } }
public seven z archive entry create archive entry ( final file input file , final string entry name ) throw i o exception { final seven z archive entry entry = new seven z archive entry ( ) ; entry . set directory ( input file . be directory ( ) ) ; entry . set name ( entry name ) ; entry . set last modified date ( new date ( input file . last modified ( ) ) ) ; return entry ; }
public void write ( byte [ ] b ) throw i o exception { write ( b , 0 , b . length ) ; }
public long skip ( final long n ) throw i o exception { if ( n < = avail ) { final int m = ( int ) n ; po += m ; avail -= m ; read byte += n ; return n ; } long to skip = n - avail , result = 0 ; avail = 0 ; while ( to skip ! = 0 & & ( result = be == system . in ? skip by read ( to skip ) : be . skip ( to skip ) ) < to skip ) { if ( result == 0 ) { if ( be . read ( ) == -1 ) break ; to skip -- ; } else to skip -= result ; } final long t = n - ( to skip - result ) ; read byte += t ; return t ; }
public short get vertical alignment ( ) { return ( short ) get text object record ( ) . get vertical text alignment ( ) ; }
public void set access java time ( final date d ) { set access time ( date to zip ( d ) ) ; }
public date get create java time ( ) { return zip long to date ( create time ) ; }
public void set flag ( final byte flag ) { this . flag = flag ; this . bit0_modify time present = ( flags & modify_time_bit ) == modify_time_bit ; this . bit1_access time present = ( flags & access_time_bit ) == access_time_bit ; this . bit2_create time present = ( flags & create_time_bit ) == create_time_bit ; }
public void set flag ( final byte flag ) { this . flag = flag ; this . bit0_modify time present = ( flags & modify_time_bit ) == modify_time_bit ; this . bit1_access time present = ( flags & access_time_bit ) == access_time_bit ; this . bit2_create time present = ( flags & create_time_bit ) == create_time_bit ; }
public void set create time ( final zip long l ) { bit2_create time present = l ! = null ; flag = ( byte ) ( l ! = null ? ( flags | create_time_bit ) : ( flag & ~create_time_bit ) ) ; this . create time = l ; }
public void set g i d ( final long l ) { this . gid = zip util . long to big ( l ) ; }
public zip short get central directory length ( ) { return central directory data == null ? get local file data length ( ) : new zip short ( central directory data . length ) ; }
public int get raw flag ( ) { return raw flag ; }
protect string calculate content hash ( signable request < ? > request ) { input stream payload stream = get binary request payload stream ( request ) ; read limit info info = request . get read limit info ( ) ; payload stream . mark ( info == null ? -1 : info . get read limit ( ) ) ; string content sha256 = binary utils . to hex ( hash ( payload stream ) ) ; try { payload stream . reset ( ) ; } catch ( i o exception e ) { throw new sdk client exception ( `` unable to reset stream after calculate aws4 signature `` , e ) ; } return content sha256 ; }
public static void delete recursive on exit ( file dir ) { if ( dir . be directory ( ) ) { string [ ] child = dir . list ( ) ; for ( string child : child ) delete recursive on exit ( new file ( dir , child ) ) ; } logger . trace ( `` scheduling deferred deletion of file : { } `` , dir ) ; dir . delete on exit ( ) ; }
public bytes ref get ( long id , bytes ref dest ) { final long start offset = start offset . get ( id ) ; final int length = ( int ) ( start offset . get ( id + 1 ) - start offset ) ; byte . get ( start offset , length , dest ) ; return d ; }
protect final int read literal ( final byte [ ] b , final int off , final int len ) throw i o exception { final int avail = available ( ) ; if ( len > avail ) { try to read literal ( len - avail ) ; } return read from buffer ( b , off , len ) ; }
public int get max char literal length ( ) { debug code call ( `` get max char literal length `` ) ; return 0 ; }
public static boolean be equal ( final byte [ ] buffer1 , final byte [ ] buffer2 , final boolean ignore trail null ) { return be equal ( buffer1 , 0 , buffer1 . length , buffer2 , 0 , buffer2 . length , ignore trail null ) ; }
public static boolean match ( final byte [ ] signature , final int length ) { if ( length < sig_length ) { return false ; } for ( int i = 0 ; i < sig_length ; i++ ) { if ( signature [ i ] ! = cafe_dood [ i ] ) { return false ; } } return true ; }
public long read bit ( final int count ) throw i o exception { if ( count < 0 || count > maximum_cache_size ) { throw new illegal argument exception ( `` count must not be negative or great than `` + maximum_cache_size ) ; } if ( ensure cache ( count ) ) { return -1 ; } if ( bit cache size < count ) { return process bit greater57 ( count ) ; } return read cache bit ( count ) ; }
public static builder builder ( ) { return new builder ( ) ; }
public list < tar archive struct sparse > get sparse header ( ) { return sparse header ; }
public void set use language encode flag ( boolean b ) { use u t f8 flag = b & & zip encoding helper . be u t f8 ( encode ) ; }
public void delete ( final string filename ) { add deletion ( new change ( filename , change . type_delete ) ) ; }
public list < string > get add from change set ( ) { return add from change set ; }
public static string get compress filename ( final string filename ) { return file name util . get compressed filename ( filename ) ; }
public static byte [ ] read byte ( file file ) throw i o exception { byte [ ] bytes = new byte [ ( int ) file . length ( ) ] ; file input stream file input stream = new file input stream ( file ) ; data input stream dis = new data input stream ( file input stream ) ; try { dis . read fully ( byte ) ; input stream temp = dis ; dis = null ; temp . close ( ) ; } finally { close with warning ( dis ) ; } return byte ; }
public string get large icon ( ) { return large icon ; }
public string get small icon ( ) { return small icon ; }
public boolean have content ( ) { c o s base content = page . get dictionary object ( c o s name . content ) ; if ( content instanceof c o s stream ) { return ( ( c o s stream ) content ) . size ( ) > 0 ; } else if ( content instanceof c o s array ) { return ( ( c o s array ) content ) . size ( ) > 0 ; } return false ; }
public string get source file ( ) { source file attribute sf = ( source file attribute ) get attribute ( source file attribute . tag ) ; if ( sf == null ) return null ; return sf . get file name ( ) ; }
public k get key ( long index ) { check open ( ) ; if ( index < 0 || index > = size ( ) ) { return null ; } page p = root ; long offset = 0 ; while ( true ) { if ( p . be leaf ( ) ) { if ( index > = offset + p . get key count ( ) ) { return null ; } return ( k ) p . get key ( ( int ) ( index - offset ) ) ; } int i = 0 , size = p . get child page count ( ) ; for ( ; i < size ; i++ ) { long c = p . get count ( i ) ; if ( index < c + offset ) { break ; } offset += c ; } if ( i == size ) { return null ; } p = p . get child page ( i ) ; } }
public int invoke interface count ( ) { return 1 + segment utils . count invoke interface args ( descriptor . underlie string ( ) ) ; }
public string outer class ( int nth ) { int i = outer class index ( nth ) ; if ( i == 0 ) return null ; return const pool . get class info ( i ) ; }
public void set s a x logger ( log sax log ) { this . sax log = sax log ; }
public void register ( string public id , url entity u r l ) { if ( log . be debug enable ( ) ) { log . debug ( `` register ( ' `` + public id + `` ' , ' `` + entity u r l + `` ' `` ) ; } entity validator . put ( public id , entity u r l ) ; }
public digester loader set entity resolver ( entity resolver entity resolver ) { this . entity resolver = entity resolver ; return this ; }
public void add call method ( string pattern , string method name , int param count ) { add rule ( pattern , new call method rule ( method name , param count ) ) ; }
public void add bean property setter ( string pattern ) { add rule ( pattern , new bean property setter rule ( ) ) ; }
public < t > t peek ( string stack name ) { return this . < t > npe safe cast ( peek ( stack name , 0 ) ) ; }
public void set system id ( string url ) { system id = url ; builder . set system id ( url ) ; super . set document locator ( new locator ( ) { public int get column number ( ) { return -1 ; } public int get line number ( ) { return -1 ; } public string get public id ( ) { return null ; } public string get system id ( ) { return system id ; } } ) ; }
public declaration get declaration by class ( string class name ) { declaration decl = ( declaration ) declaration by class . get ( class name ) ; if ( ( decl == null ) & & ( parent ! = null ) ) { decl = parent . get declaration by class ( class name ) ; } return decl ; }
public parser rule context get parent ( ) { return ( parser rule context ) super . get parent ( ) ; }
public static i undo manager get undo manager ( ) { return refactoring core plugin . get undo manager ( ) ; }
public void set rule factory ( rule factory factory ) { rule factory = factory ; }
public void set digester ( digester digester ) { super . set digester ( digester ) ; log = digester . get logger ( ) ; }
public add alias builder < nest property builder > add alias ( string element name ) { if ( element name == null ) { report error ( `` set property ( ) . add alias ( string ) `` , `` empty 'element name ' not allow `` ) ; } return new add alias builder < nest property builder > ( this , element name , element name ) ; }
public void set log ( logger log ) { this . log = log ; }
public static digester create digester ( input source rule source ) { rule set rule set = new from xml rule set ( rule source ) ; digester digester = new digester ( ) ; digester . add rule set ( rule set ) ; return digester ; }
public call method builder use exact match ( boolean use exact match ) { this . use exact match = use exact match ; return this ; }
public void add message ( localizable pattern , object . . . argument ) { msg pattern . add ( pattern ) ; msg argument . add ( arg utils . flatten ( argument ) ) ; }
public node create rule provider create node ( ) { return add provider ( new node create rule provider ( key pattern , namespace u r i , main binder , this ) ) ; }
public plugin declaration rule builder declare plugin ( ) { return add provider ( new plugin declaration rule builder ( key pattern , namespace u r i , main binder , this ) ) ; }
public object create builder use default constructor argument ( object . . . default constructor argument ) { if ( default constructor argument == null ) { report error ( `` create object ( ) . use default constructor argument ( object [ ] ) `` , `` null default constructor argument not allow `` ) ; return this ; } this . default constructor argument = default constructor argument ; return this ; }
public void set s a x logger ( log sax log ) { this . sax log = sax log ; }
public boolean be use context class loader ( ) { return use context class loader ; }
public void set custom content handler ( content handler handler ) { custom content handler = handler ; }
public void register ( string public id , string entity u r l ) { if ( log . be debug enable ( ) ) { log . debug ( `` register ( ' `` + public id + `` ' , ' `` + entity u r l + `` ' `` ) ; } try { entity validator . put ( public id , new url ( entity u r l ) ) ; } catch ( malformed u r l exception e ) { throw new illegal argument exception ( `` malformed url ' `` + entity u r l + `` ' : `` + e . get message ( ) ) ; } }
public void add set property ( string pattern , string attribute name , string property name ) { add rule ( pattern , new set property rule ( attribute name , property name ) ) ; }
public set property builder ignore miss property ( boolean ignore miss property ) { this . ignore miss property = ignore miss property ; return this ; }
public static boolean can execute ( file file ) { if ( ! be file ( file ) ) { return false ; } return file . be executable ( file . to path ( ) ) ; }
public void flush ( ) throw i o exception { buffer info buffer info = get buffer info ( ) ; if ( buffer info . buffer . size ( ) > 0 ) { process flush ( buffer info . buffer ) ; } }
public static boolean be lenient enable ( ) { final string lenient = system . get property ( commons_exec_lenient , boolean . true . to string ( ) ) ; return boolean . true . to string ( ) . equal ignore case ( lenient ) ; }
public static string encode basic auth ( string username , string password , @ nullable charset charset ) { assert . not null ( username , `` username must not be null `` ) ; assert . do not contain ( username , `` : `` , `` username must not contain a colon `` ) ; assert . not null ( password , `` password must not be null `` ) ; if ( charset == null ) { charset = standard charsets . iso_8859_1 ; } charset encoder encoder = charset . new encoder ( ) ; if ( ! encoder . can encode ( username ) || ! encoder . can encode ( password ) ) { throw new illegal argument exception ( `` username or password contain character that can not be encode to `` + charset . display name ( ) ) ; } string credential string = username + `` : `` + password ; byte [ ] encode byte = base64 . get encoder ( ) . encode ( credential string . get byte ( charset ) ) ; return new string ( encoded byte , charset ) ; }
public entity i d get trust anchor i d ( ) { string value = get string claim ( trust_anchor_id_claim_name ) ; try { return entity i d . parse ( value ) ; } catch ( parse exception e ) { return null ; } }
public string get parameter ( final string name ) { args . not empty ( name , `` parameter name `` ) ; if ( this . params == null ) { return null ; } for ( final name value pair param : this . params ) { if ( param . get name ( ) . equal ignore case ( name ) ) { return param . get value ( ) ; } } return null ; }
public int read ( ) throw i o exception { if ( close ) { throw new i o exception ( `` attempt read from closed stream . `` ) ; } if ( pos > = content length ) { return -1 ; } pos++ ; return this . wrap stream . read ( ) ; }
protect void flush cache with append ( byte buffer to append [ ] , int off , int len ) throw i o exception { byte chunk header [ ] = encode util . get ascii byte ( integer . to hex string ( cache position + len ) + `` \r\n `` ) ; stream . write ( chunk header , 0 , chunk header . length ) ; stream . write ( cache , 0 , cache position ) ; stream . write ( buffer to append , off , len ) ; stream . write ( endchunk , 0 , endchunk . length ) ; cache position = 0 ; }
public string get cookie path ( ) { return this . cookie path ; }
public detail cookie matcher version ( int expect version value ) { return version ( equal to ( expect version value ) ) ; }
public name value pair [ ] get parameter ( ) { log . trace ( `` enter post method . get parameter ( ) `` ) ; int num pair = this . params . size ( ) ; object [ ] object arr = this . params . to array ( ) ; name value pair [ ] nv pair arr = new name value pair [ num pair ] ; for ( int i = 0 ; i < num pair ; i++ ) { nv pair arr [ i ] = ( name value pair ) object arr [ i ] ; } return nv pair arr ; }
public void set header ( string name , string value ) { boolean flag = false ; if ( ( name == null ) || name . equal ( `` `` ) ) { throw new illegal argument exception ( `` illegal mime header name `` ) ; } for ( int i = 0 ; i < header . size ( ) ; i++ ) { mime header mimeheader = ( mime header ) header . element at ( i ) ; if ( mimeheader . get name ( ) . equal ignore case ( name ) ) { if ( ! flag ) { header . set element at ( new mime header ( mimeheader . get name ( ) , value ) , i ) ; flag = true ; } else { header . remove element at ( i -- ) ; } } } if ( ! flag ) { add header ( name , value ) ; } }
public void remove request header ( string header name ) { header [ ] header = get request header group ( ) . get header ( header name ) ; for ( int i = 0 ; i < header . length ; i++ ) { get request header group ( ) . remove header ( header [ i ] ) ; } }
public boolean contains header ( string name ) { for ( iterator header iter = header . iterator ( ) ; header iter . have next ( ) ; ) { header header = ( header ) header iter . next ( ) ; if ( header . get name ( ) . equal ignore case ( name ) ) { return true ; } } return false ; }
protect http u r l connection create connection ( final client invocation request ) throw i o exception { proxy proxy = null ; if ( this . proxy host ! = null & & this . proxy port ! = null ) { proxy = new proxy ( proxy . type . http , new inet socket address ( this . proxy host , this . proxy port ) ) ; } else { proxy = proxy . no_proxy ; } http u r l connection connection = ( http u r l connection ) request . get uri ( ) . to u r l ( ) . open connection ( proxy ) ; connection . set request method ( request . get method ( ) ) ; if ( this . connect timeout ! = null ) { connection . set connect timeout ( this . connect timeout ) ; } if ( this . read timeout ! = null ) { connection . set read timeout ( this . read timeout ) ; } return connection ; }
public synchronize string get host ( ) { if ( this . host ! = null ) { return this . host . get host name ( ) ; } else { return null ; } }
public synchronize int get proxy port ( ) { if ( this . proxy host ! = null ) { return this . proxy host . get port ( ) ; } else { return -1 ; } }
public synchronize int get proxy port ( ) { if ( this . proxy host ! = null ) { return this . proxy host . get port ( ) ; } else { return -1 ; } }
public synchronize void set local address ( inet address local address ) { this . local address = local address ; }
public void set strict ( strict mode strict ) { this . strict = strict ; }
public final socket factory get socket factory ( ) { if ( this . socket factory instanceof scheme socket factory adaptor ) { return ( ( scheme socket factory adaptor ) this . socket factory ) . get factory ( ) ; } else { if ( this . layer ) { return new layer socket factory adaptor ( ( layer scheme socket factory ) this . socket factory ) ; } else { return new socket factory adaptor ( this . socket factory ) ; } } }
public client configuration with proxy host ( string proxy host ) { set proxy host ( proxy host ) ; return this ; }
public boolean be secure ( ) { return this . request . be secure ( ) ; }
public long get sum ( long time ) { long sum = 0 ; for ( bucket bucket : bucket ) { boolean stale = bucket . be stale now ( time ) ; if ( ! stale ) { sum += bucket . value . get ( ) ; } if ( log . be debug enable ( ) ) { long bucket time = bucket . update time . get ( ) ; string time str = new date ( bucket time ) . to string ( ) ; log . debug ( `` sum : + `` + sum + `` bucket : update time : `` + time str + `` ( `` + bucket time + `` ) be stale `` + stale + `` at `` + time ) ; } } return sum ; }
public response builder set body ( input stream input stream ) { not null ( input stream , `` response body `` ) ; rest assure response . set content ( input stream ) ; return this ; }
public void set http connection manager ( http connection manager http connection manager ) { this . http connection manager = http connection manager ; }
public void release ( ) { super . release ( ) ; if ( ! be open ( ) & & this . current connection ! = null ) { if ( this . connection handle ! = null ) { this . connection handle . release connection ( this . current connection ) ; } this . current connection = null ; } }
public socket option set send buffer size ( int send buffer size ) { this . send buffer size = send buffer size ; return this ; }
public static string get ascii string ( final byte [ ] data , int offset , int length ) { if ( data == null ) { throw new illegal argument exception ( `` parameter may not be null `` ) ; } try { return new string ( data , offset , length , `` us-ascii `` ) ; } catch ( unsupported encode exception e ) { throw new runtime exception ( `` http client require ascii support `` ) ; } }
public boolean get do authentication ( ) { return do authentication ; }
public void remove request header ( string header name ) { header [ ] header = get request header group ( ) . get header ( header name ) ; for ( int i = 0 ; i < header . length ; i++ ) { get request header group ( ) . remove header ( header [ i ] ) ; } }
public boolean validate object ( t obj ) { return true ; }
public void set escape password ( string escape password ) throw u r i exception { set raw password ( ( escape password == null ) ? null : escaped password . to char array ( ) ) ; }
public boolean get follow redirects ( ) { return follow redirects ; }
protect boolean have request content ( ) { log . trace ( `` enter entity enclose method . have request content ( ) `` ) ; return ( this . request entity ! = null ) || ( this . request stream ! = null ) || ( this . request string ! = null ) ; }
protect void send disposition header ( output stream out ) throw i o exception { log . trace ( `` enter send disposition header ( output stream out ) `` ) ; out . write ( content_disposition_bytes ) ; out . write ( quote_bytes ) ; out . write ( encode util . get ascii byte ( get name ( ) ) ) ; out . write ( quote_bytes ) ; }
public static boolean be hide ( path path ) { path file name = path . get file name ( ) ; if ( file name == null ) { return false ; } return file name . to string ( ) . start with ( `` . `` ) ; }
protect void send end of header ( output stream out ) throw i o exception { log . trace ( `` enter send end of header ( output stream out ) `` ) ; out . write ( crlf_bytes ) ; out . write ( crlf_bytes ) ; }
public void add output property ( string name , string value ) { if ( name == null ) { throw new illegal argument exception ( `` name must not be null `` ) ; } if ( value == null ) { throw new illegal argument exception ( `` value must not be null `` ) ; } output . set property ( name , value ) ; }
public void set request content length ( int length ) { log . trace ( `` enter entity enclose method . set request content length ( int ) `` ) ; this . request content length = length ; }
public boolean remove parameter ( string param name ) throw illegal argument exception { log . trace ( `` enter post method . remove parameter ( string ) `` ) ; if ( param name == null ) { throw new illegal argument exception ( `` argument pass to remove parameter ( string ) can not be null `` ) ; } boolean removed = false ; iterator iter = this . params . iterator ( ) ; while ( iter . have next ( ) ) { name value pair pair = ( name value pair ) iter . next ( ) ; if ( param name . equal ( pair . get name ( ) ) ) { iter . remove ( ) ; remove = true ; } } return remove ; }
public void set connection stale checking enable ( boolean connection stale check enable ) { this . params . set stale checking enable ( connection stale check enable ) ; }
public int get connection in pool ( ) { synchronize ( connection pool ) { return connection pool . num connection ; } }
public void set authentication preemptive ( boolean value ) { this . preemptive = value ; }
public void set default max connection per host ( int max host connection ) { set max connection per host ( host configuration . any_host_configuration , max host connection ) ; }
public int get max total connection ( ) { return get int parameter ( http connection manager params . max_total_connections , multi thread http connection manager . default_max_total_connections ) ; }
public int get so timeout ( ) { return get int parameter ( so_timeout , 0 ) ; }
public void set receive buffer size ( int size ) { set int parameter ( so_rcvbuf , size ) ; }
public int get linger ( ) { return get int parameter ( so_linger , -1 ) ; }
public boolean be opaque ( ) { return this . opaque ; }
public boolean be net path ( ) { return _is_net_path || ( _authority ! = null ) ; }
public static string get default document charset by platform ( ) { return default document charset by platform ; }
public static string get default document charset by platform ( ) { return default document charset by platform ; }
public string get escape userinfo ( ) { return ( _userinfo == null ) ? null : new string ( _userinfo ) ; }
public char [ ] get raw above hier path ( ) throw u r i exception { char [ ] path = get raw current hier path ( ) ; return ( path == null || path . length == 0 ) ? root path : get raw current hier path ( path ) ; }
public string get escape fragment ( ) { return ( _fragment == null ) ? null : new string ( _fragment ) ; }
public string find user ( string username ) { user database database = ( user database ) this . resource ; user user = database . find user ( username ) ; if ( user == null ) { return null ; } try { object name oname = m bean utils . create object name ( manage user . get domain ( ) , user ) ; return oname . to string ( ) ; } catch ( malformed object name exception e ) { illegal argument exception iae = new illegal argument exception ( sm . get string ( `` user m bean . create error . user `` , username ) ) ; iae . init cause ( e ) ; throw iae ; } }
public int hash code ( ) { int hash = lang utils . hash_seed ; hash = lang utils . hash code ( hash , this . get name ( ) ) ; hash = lang utils . hash code ( hash , this . cookie domain ) ; hash = lang utils . hash code ( hash , this . cookie path ) ; return hash ; }
public input stream get error stream ( ) { log . trace ( `` enter http u r l connection . get error stream ( ) `` ) ; throw new runtime exception ( `` not implement yet `` ) ; }
public boolean be always use quote ( ) { return always use quote ; }
public static string encode path query ( string unescaped ) throw u r i exception { return encode path query ( unescaped , uri . get default protocol charset ( ) ) ; }
public int byte length ( ) { return raw byte . length ; }
public list < file > sort ( final list < file > file ) { if ( file ! = null ) { file . sort ( this ) ; } return file ; }
public string to string ( ) { if ( _reason == null ) return super . to string ( ) ; return super . to string ( ) + `` [ `` + _reason + `` ] `` ; }
public static void write swap double ( final byte [ ] data , final int offset , final double value ) { write swap long ( data , offset , double . double to long bit ( value ) ) ; }
public static long read swap unsigned integer ( final input stream input ) throw i o exception { final int value1 = read ( input ) ; final int value2 = read ( input ) ; final int value3 = read ( input ) ; final int value4 = read ( input ) ; final long low = ( ( ( value1 & 0xff ) < < 0 ) + ( ( value2 & 0xff ) < < 8 ) + ( ( value3 & 0xff ) < < 16 ) ) ; final long high = value4 & 0xff ; return ( high < < 24 ) + ( 0xffffffff l & low ) ; }
public list < file > sort ( final list < file > file ) { if ( file ! = null ) { file . sort ( this ) ; } return file ; }
public static path counter delete directory ( final path directory ) throw i o exception { return delete directory ( directory , empty_delete_option_array ) ; }
public static path counter copy directory ( final path source directory , final path target directory , final copy option . . . copy option ) throw i o exception { final path absolute source = source directory . to absolute path ( ) ; return visit file tree ( new copy directory visitor ( counter . long path counter ( ) , absolute source , target directory , copy option ) , absolute source ) . get path counter ( ) ; }
public static boolean file content equal ( final path path1 , final path path2 ) throw i o exception { return file content equal ( path1 , path2 , empty_link_option_array , empty_open_option_array ) ; }
public string to string ( ) { return `` property [ `` + get name ( ) + `` ] `` ; }
public boolean accept ( final file file ) { return file . can write ( ) ; }
public boolean accept ( final file file ) { if ( file filter ! = null ) { return file filter . accept ( file ) ; } return super . accept ( file ) ; }
public static i o file filter prefix file filter ( string prefix ) { return new prefix file filter ( prefix ) ; }
public static i o file filter suffix file filter ( string suffix ) { return new suffix file filter ( suffix ) ; }
public file status [ ] list status ( path [ ] file , path filter filter ) throw file not find exception , i o exception { array list < file status > result = new array list < file status > ( ) ; for ( int i = 0 ; i < file . length ; i++ ) { list status ( result , file [ i ] , filter ) ; } return result . to array ( new file status [ result . size ( ) ] ) ; }
public boolean accept ( final file file ) { return accept ( file . get name ( ) ) ; }
public boolean accept ( final file file ) { if ( file filter ! = null ) { return file filter . accept ( file ) ; } return super . accept ( file ) ; }
public static string normalize no end separator ( final string file name ) { return do normalize ( file name , system_separator , false ) ; }
public static string separator to window ( final string path ) { if ( path == null || path . index of ( unix_separator ) == not_found ) { return path ; } return path . replace ( unix_separator , windows_separator ) ; }
public string [ ] get reserve file name ( ) { return reserve file name . clone ( ) ; }
public boolean create new file ( file f , boolean mkdirs ) throw i o exception { file parent = f . get parent file ( ) ; if ( mkdirs & & ! ( parent . exists ( ) ) ) { parent . mkdirs ( ) ; } return f . create new file ( ) ; }
public path get home directory ( ) { return this . make qualified ( new path ( `` /user/ `` + system . get property ( `` user . name `` ) ) ) ; }
public static void clean directory ( final file directory ) throw i o exception { final file [ ] file = list file ( directory , null ) ; final list < exception > cause list = new array list < > ( ) ; for ( final file file : file ) { try { force delete ( file ) ; } catch ( final i o exception ioe ) { cause list . add ( ioe ) ; } } if ( ! cause list . be empty ( ) ) { throw new i o exception list ( directory . to string ( ) , cause list ) ; } }
public static list < string > read line ( final file file , final string charset name ) throw i o exception { return read line ( file , charsets . to charset ( charset name ) ) ; }
public static void touch ( file file ) throw i o exception { check not null ( file ) ; if ( ! file . create new file ( ) & & ! file . set last modify ( system . current time millis ( ) ) ) { throw new i o exception ( `` unable to update modification time of `` + file ) ; } }
public void mark ( final int read ahead limit ) throw i o exception { this . read ahead limit = read ahead limit - char read ; mark at = char read ; target . mark ( read ahead limit ) ; }
public static ints ref to u t f32 ( char [ ] s , int offset , int length , ints ref scratch ) { int char idx = offset ; int int idx = 0 ; final int char limit = offset + length ; while ( char idx < char limit ) { scratch . grow ( int idx+1 ) ; final int utf32 = character . code point at ( s , char idx , char limit ) ; scratch . ints [ int idx ] = utf32 ; char idx += character . char count ( utf32 ) ; int idx++ ; } scratch . length = int idx ; return scratch ; }
public long skip ( final long number of char ) throw i o exception { if ( eof ) { throw new i o exception ( `` skip after end of file `` ) ; } if ( position == size ) { return do end of file ( ) ; } position += number of char ; long return length = number of char ; if ( position > size ) { return length = number of char - ( position - size ) ; position = size ; } return return length ; }
public long position ( ) { return global position ; }
public synchronize void reset ( ) throw i o exception { if ( ! mark support ) { throw unsupported operation exception . reset ( ) ; } if ( mark < 0 ) { throw new i o exception ( `` no position have be mark `` ) ; } if ( position > mark + readlimit ) { throw new i o exception ( `` mark position [ `` + mark + `` ] be no longer valid - pass the read limit [ `` + readlimit + `` ] `` ) ; } position = mark ; eof = false ; }
public static void put int little endian ( byte buffer buffer , int value ) { int p = flip to fill ( buffer ) ; buffer . put ( ( byte ) ( value & 0x f f ) ) ; buffer . put ( ( byte ) ( ( value > > > 8 ) & 0x f f ) ) ; buffer . put ( ( byte ) ( ( value > > > 16 ) & 0x f f ) ) ; buffer . put ( ( byte ) ( ( value > > > 24 ) & 0x f f ) ) ; flip to flush ( buffer , p ) ; }
public random access file generate random file ( final int length ) throw i o exception { m file = file . create temp file ( speed test const . upload_temp_file_name , speed test const . upload_temp_file_extension ) ; final random access file random file = new random access file ( m file . get absolute path ( ) , `` rw `` ) ; random file . set length ( length ) ; final int iter = length / speed test const . upload_file_write_chunk ; final int remain = length % speed test const . upload_file_write_chunk ; for ( int i = 0 ; i < iter ; i++ ) { final byte [ ] random = new byte [ speed test const . upload_file_write_chunk ] ; m random . next byte ( random ) ; random file . write ( random ) ; } if ( remain > 0 ) { final byte [ ] random = new byte [ remain ] ; m random . next byte ( random ) ; random file . write ( random ) ; } return random file ; }
public random access file get writable file ( ) { return raf ; }
public synchronize void close ( ) throw i o exception { / * close the channel since socket . get input stream ( ) . close ( ) * close the socket . * / reader . channel . close ( ) ; reader . close ( ) ; }
public void throw if cause of ( final throwable throwable ) throw i o exception { tag i o exception . throw cause if tag with ( throwable , tag ) ; }
public long get configured delay in millis ( ) { check decision state ( ) ; return configure delay in millis ; }
public static input stream to input stream ( string input ) { return to input stream ( input , charset . default charset ( ) ) ; }
public static input stream to input stream ( final char sequence input , final charset charset ) { return to input stream ( input . to string ( ) , charset ) ; }
public static filter < file > to file filter ( final filename filter filter ) { return new filter < file > ( ) { @ override public boolean filter ( file file ) { return filter . accept ( file . get parent file ( ) , file . get name ( ) ) ; } @ override public string to string ( ) { return filter . to string ( ) ; } } ; }
public void remove listener ( final file alteration listener listener ) { if ( listener ! = null ) { while ( listener . remove ( listener ) ) { } } }
public long length ( ) { return length ; }
public void set exists ( string exists ) { this . exist = exists ; } // -- void set exists ( string )
public void append to ( final appendable appendable ) throw i o exception { if ( appendable instanceof writer ) { ( ( writer ) appendable ) . write ( buffer , 0 , size ) ; } else if ( appendable instanceof string builder ) { ( ( string builder ) appendable ) . append ( buffer , 0 , size ) ; } else if ( appendable instanceof string buffer ) { ( ( string buffer ) appendable ) . append ( buffer , 0 , size ) ; } else if ( appendable instanceof char buffer ) { ( ( char buffer ) appendable ) . put ( buffer , 0 , size ) ; } else { appendable . append ( this ) ; } }
public void write ( final char [ ] cbuf , final int off , final int len ) throw i o exception { if ( xml prolog writer ! = null ) { detect encoding ( cbuf , off , len ) ; } else { writer . write ( cbuf , off , len ) ; } }
public writer append ( final char c ) throw i o exception { appendable . append ( c ) ; return this ; }
public void close ( ) throw i o exception { super . close ( ) ; target . close ( ) ; }
public void write ( int idx ) throw i o exception { out . write ( idx ) ; }
public void write ( final int c ) throw i o exception { list < exception > cause list = null ; int i = 0 ; for ( final writer w : writer ) { if ( w ! = null ) { try { w . write ( c ) ; } catch ( final i o exception e ) { cause list = add ( cause list , i , e ) ; } } i++ ; } if ( not empty ( cause list ) ) { throw new i o exception list ( `` write `` , cause list ) ; } }
public static void copy then close ( input stream input , output stream output ) throw i o exception { copy ( input , output ) ; input . close ( ) ; output . close ( ) ; }
public static encode default encode ( ) { return default_encoding ; }
public validate object input stream reject ( final pattern pattern ) { reject matcher . add ( new regexp class name matcher ( pattern ) ) ; return this ; }
public boolean be cause of ( final throwable exception ) { return tag i o exception . be tag with ( exception , tag ) ; }
public int compare ( final file file1 , final file file2 ) { final long result = file utils . last modified unchecked ( file1 ) - file utils . last modified unchecked ( file2 ) ; if ( result < 0 ) { return -1 ; } if ( result > 0 ) { return 1 ; } return 0 ; }
public static i o file filter age file filter ( final file cutoff reference ) { return new age file filter ( cutoff reference ) ; }
public static string get full path ( string filename ) { return do get full path ( filename , true ) ; }
public static boolean equal on system ( string filename1 , string filename2 ) { return equal ( filename1 , filename2 , false , i o case . system ) ; }
public synchronize void mark ( int readlimit ) { mark fb index = fb index ; mark at start = first bytes == null ; in . mark ( readlimit ) ; }
public text string builder insert ( final int index , final char [ ] char , final int offset , final int length ) { validate index ( index ) ; if ( char == null ) { return insert ( index , null text ) ; } if ( offset < 0 || offset > char . length ) { throw new string index out of bound exception ( `` invalid offset : `` + offset ) ; } if ( length < 0 || offset + length > char . length ) { throw new string index out of bound exception ( `` invalid length : `` + length ) ; } if ( length > 0 ) { ensure capacity ( size + length ) ; system . arraycopy ( buffer , index , buffer , index + length , size - index ) ; system . arraycopy ( char , offset , buffer , index , length ) ; size += length ; } return this ; }
public void add ( geometry geometry ) { geometry . apply ( new geometry component filter ( ) { public void filter ( geometry component ) { if ( component instanceof line string ) { add ( ( line string ) component ) ; } } } ) ; }
public static char [ ] to char array ( final reader input ) throw i o exception { final char array writer sw = new char array writer ( ) ; copy ( input , sw ) ; return sw . to char array ( ) ; }
public static list < string > read line ( final input stream input ) throw i o exception { return read line ( input , charset . default charset ( ) ) ; }
public static list < string > read line ( final input stream input , final charset encode ) throw i o exception { final input stream reader reader = new input stream reader ( input , charsets . to charset ( encode ) ) ; return read line ( reader ) ; }
public static input stream to input stream ( char sequence input ) { return to input stream ( input , charset . default charset ( ) ) ; }
public static void write ( string buffer data , writer output ) throw i o exception { if ( data ! = null ) { output . write ( data . to string ( ) ) ; } }
public static void write ( string data , output stream output , charset encode ) throw i o exception { if ( data ! = null ) { output . write ( data . get byte ( charsets . to charset ( encode ) ) ) ; } }
public static void copy ( reader input , output stream output ) throw i o exception { copy ( input , output , charset . default charset ( ) ) ; }
public static list < string > read line ( final input stream input , final charset encode ) throw i o exception { final input stream reader reader = new input stream reader ( input , charsets . to charset ( encode ) ) ; return read line ( reader ) ; }
public static boolean content equal ( reader input1 , reader input2 ) throw i o exception { if ( ! ( input1 instanceof buffer reader ) ) { input1 = new buffer reader ( input1 ) ; } if ( ! ( input2 instanceof buffer reader ) ) { input2 = new buffer reader ( input2 ) ; } int ch = input1 . read ( ) ; while ( -1 ! = ch ) { int ch2 = input2 . read ( ) ; if ( ch ! = ch2 ) { return false ; } ch = input1 . read ( ) ; } int ch2 = input2 . read ( ) ; return ( ch2 == -1 ) ; }
public void on stop ( final file alteration observer observer ) { }
public byte [ ] get data ( ) { return memory output stream ! = null ? memory output stream . to byte array ( ) : null ; }
public static closeable a closeable ( final socket socket ) { if ( closeable . class . be assignable from ( socket . get class ( ) ) ) { return closeable . class . cast ( socket ) ; } else { return new closeable ( ) { @ override public void close ( ) throw i o exception { socket . close ( ) ; } } ; } }
public static char [ ] to char array ( input stream be ) throw i o exception { return to char array ( be , charset . default charset ( ) ) ; }
public static string to string ( byte [ ] input , string encode ) throw i o exception { return new string ( input , charsets . to charset ( encode ) ) ; }
public static boolean content equal ( reader input1 , reader input2 ) throw i o exception { if ( ! ( input1 instanceof buffer reader ) ) { input1 = new buffer reader ( input1 ) ; } if ( ! ( input2 instanceof buffer reader ) ) { input2 = new buffer reader ( input2 ) ; } int ch = input1 . read ( ) ; while ( -1 ! = ch ) { int ch2 = input2 . read ( ) ; if ( ch ! = ch2 ) { return false ; } ch = input1 . read ( ) ; } int ch2 = input2 . read ( ) ; return ( ch2 == -1 ) ; }
public static boolean be empty ( final path path ) throw i o exception { return file . be directory ( path ) ? be empty directory ( path ) : be empty file ( path ) ; }
public static long copy large ( final reader input , final writer output ) throw i o exception { return copy large ( input , output , new char [ default_buffer_size ] ) ; }
public static boolean be same type ( object array1 , object array2 ) { if ( array1 == null || array2 == null ) { throw new illegal argument exception ( `` the array must not be null `` ) ; } return array1 . get class ( ) . get name ( ) . equal ( array2 . get class ( ) . get name ( ) ) ; }
public static boolean be empty ( object [ ] array ) { if ( array == null || array . length == 0 ) { return true ; } return false ; }
public static int [ ] subarray ( int [ ] array , int start index inclusive , int end index exclusive ) { if ( array == null ) { return null ; } if ( start index inclusive < 0 ) { start index inclusive = 0 ; } if ( end index exclusive > array . length ) { end index exclusive = array . length ; } int new size = end index exclusive - start index inclusive ; if ( new size < = 0 ) { return empty_int_array ; } int [ ] subarray = new int [ new size ] ; system . arraycopy ( array , start index inclusive , subarray , 0 , new size ) ; return subarray ; }
public static int last index of ( final object [ ] array , final object object to find , int start index ) { if ( array == null ) { return index_not_found ; } if ( start index < 0 ) { return index_not_found ; } else if ( start index > = array . length ) { start index = array . length - 1 ; } if ( object to find == null ) { for ( int i = start index ; i > = 0 ; i -- ) { if ( array [ i ] == null ) { return i ; } } } else if ( array . get class ( ) . get component type ( ) . be instance ( object to find ) ) { for ( int i = start index ; i > = 0 ; i -- ) { if ( object to find . equal ( array [ i ] ) ) { return i ; } } } return index_not_found ; }
public static int last index of ( char [ ] array , char value to find ) { return last index of ( array , value to find , integer . max_value ) ; }
public static int last index of ( double [ ] array , double value to find , int start index , double tolerance ) { if ( array utils . be empty ( array ) ) { return index_not_found ; } if ( start index < 0 ) { return index_not_found ; } else if ( start index > = array . length ) { start index = array . length - 1 ; } double min = value to find - tolerance ; double max = value to find + tolerance ; for ( int i = start index ; i > = 0 ; i -- ) { if ( array [ i ] > = min & & array [ i ] < = max ) { return i ; } } return index_not_found ; }
public static long [ ] to primitive ( long [ ] array ) { if ( array == null ) { return null ; } else if ( array . length == 0 ) { return empty_long_array ; } final long [ ] result = new long [ array . length ] ; for ( int i = 0 ; i < array . length ; i++ ) { result [ i ] = array [ i ] . long value ( ) ; } return result ; }
public static short [ ] to primitive ( short [ ] array , short value for null ) { if ( array == null ) { return null ; } else if ( array . length == 0 ) { return empty_short_array ; } final short [ ] result = new short [ array . length ] ; for ( int i = 0 ; i < array . length ; i++ ) { short b = array [ i ] ; result [ i ] = ( b == null ? value for null : b . short value ( ) ) ; } return result ; }
public static float [ ] to primitive ( float [ ] array ) { if ( array == null ) { return null ; } else if ( array . length == 0 ) { return empty_float_array ; } final float [ ] result = new float [ array . length ] ; for ( int i = 0 ; i < array . length ; i++ ) { result [ i ] = array [ i ] . float value ( ) ; } return result ; }
public static boolean be not empty ( boolean [ ] array ) { return ( array ! = null & & array . length ! = 0 ) ; }
public equal builder append ( byte lh , byte rh ) { if ( be equal == false ) { return this ; } be equals = ( lhs == rh ) ; return this ; }
public equal builder append ( int [ ] lh , int [ ] rh ) { if ( be equal == false ) { return this ; } if ( lhs == rh ) { return this ; } if ( lhs == null || rh == null ) { this . set equal ( false ) ; return this ; } if ( lh . length ! = rh . length ) { this . set equal ( false ) ; return this ; } for ( int i = 0 ; i < lh . length & & be equal ; ++i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
public void reset ( ) { this . reset ( true , true ) ; }
public hash code builder append ( int value ) { i total = i total * i constant + value ; return this ; }
public int hash code ( ) { int hash code = get class ( ) . hash code ( ) ; for ( int b : byte ) { hash code += b ; } return hash code ; }
public field set < string > exclude field ( string . . . field names ) { return set field set ( new exclude field name selector ( ) , field name ) ; }
public field set < string > exclude field ( string . . . field names ) { return set field set ( new exclude field name selector ( ) , field name ) ; }
public field set < string > exclude field ( string . . . field names ) { return set field set ( new exclude field name selector ( ) , field name ) ; }
public void set use identity hash code ( boolean use identity hash code ) { super . set use identity hash code ( use identity hash code ) ; }
public void set array start ( string array start ) { super . set array start ( array start ) ; }
public string get array separator ( ) { return super . get array separator ( ) ; }
public void set field name value separator ( string field name value separator ) { super . set field name value separator ( field name value separator ) ; }
public void set size end text ( string size end text ) { super . set size end text ( size end text ) ; }
public to string builder append ( boolean value ) { style . append ( buffer , null , value ) ; return this ; }
public to string builder append ( short value ) { style . append ( buffer , null , value ) ; return this ; }
public to string builder append ( boolean value ) { style . append ( buffer , null , value ) ; return this ; }
public to string builder append ( float [ ] array ) { style . append ( buffer , null , array , null ) ; return this ; }
public to string builder append ( string field name , byte value ) { style . append ( buffer , field name , value ) ; return this ; }
protect void append detail ( string buffer buffer , string field name , object value ) { buffer . append ( value ) ; }
protect void reflection append array detail ( string buffer buffer , string field name , object array ) { buffer . append ( array start ) ; int length = array . get length ( array ) ; for ( int i = 0 ; i < length ; i++ ) { object item = array . get ( array , i ) ; if ( i > 0 ) { buffer . append ( array separator ) ; } if ( item == null ) { append null text ( buffer , field name ) ; } else { append internal ( buffer , field name , item , array content detail ) ; } } buffer . append ( array end ) ; }
protect void append summary ( string buffer buffer , string field name , object [ ] array ) { append summary size ( buffer , field name , array . length ) ; }
protect void append summary ( string buffer buffer , string field name , byte [ ] array ) { append summary size ( buffer , field name , array . length ) ; }
protect void append summary ( string buffer buffer , string field name , object [ ] array ) { append summary size ( buffer , field name , array . length ) ; }
public boolean end with ( char seq suffix ) { return back . end with ( suffix . back ) ; }
public static boolean contain any ( final string str , final string . . . set ) { if ( string utils . be empty ( str ) || deep empty ( set ) ) { return false ; } final char set char = char set . get instance ( set ) ; for ( final char c : str . to char array ( ) ) { if ( char . contains ( c ) ) { return true ; } } return false ; }
public boolean equal ( object obj ) { if ( obj == this ) { return true ; } if ( obj instanceof char range == false ) { return false ; } char range other = ( char range ) obj ; return start == other . start & & end == other . end & & negate == other . negate ; }
public string to string ( ) { if ( to string ! = null ) { return to string ; } else { return to string = get u r i ( ) . to string ( ) ; } }
public static char to char ( character ch ) { if ( ch == null ) { throw new illegal argument exception ( `` the character must not be null `` ) ; } return ch . char value ( ) ; }
public static char to char ( string str ) { if ( string utils . be empty ( str ) ) { throw new illegal argument exception ( `` the string must not be empty `` ) ; } return str . char at ( 0 ) ; }
public static string aws v4 encode u r i ( char sequence input , boolean encode slash ) { string builder result = new string builder ( ) ; for ( int i = 0 ; i < input . length ( ) ; i++ ) { char ch = input . char at ( i ) ; if ( ( ch > = ' a ' & & ch < = ' z ' ) || ( ch > = ' a ' & & ch < = ' z ' ) || ( ch > = ' 0 ' & & ch < = ' 9 ' ) || ch == ' _ ' || ch == '- ' || ch == '~ ' || ch == ' . ' ) { result . append ( ch ) ; } else if ( ch == '/ ' ) { result . append ( encode slash ? `` % 2f `` : ch ) ; } else { string hex = rest utils . encode url string ( string . value of ( ch ) ) ; result . append ( hex ) ; } } return result . to string ( ) ; }
public static list < class < ? > > get all interface ( class < ? > cl ) { if ( cls == null ) return null ; link hash set < class < ? > > interface find = new link hash set < > ( ) ; get all interface ( cl , interface find ) ; return new array list < > ( interface find ) ; }
public static list convert class to class name ( list class ) { if ( class == null ) { return null ; } list class name = new array list ( class . size ( ) ) ; for ( iterator it = class . iterator ( ) ; it . have next ( ) ; ) { class cl = ( class ) it . next ( ) ; if ( cls == null ) { class name . add ( null ) ; } else { class name . add ( cl . get name ( ) ) ; } } return class name ; }
public static class get class ( class loader class loader , string class name ) throw class not find exception { return get class ( class loader , class name , true ) ; }
public static class [ ] to class ( object [ ] array ) { if ( array == null ) { return null ; } else if ( array . length == 0 ) { return array utils . empty_class_array ; } class [ ] class = new class [ array . length ] ; for ( int i = 0 ; i < array . length ; i++ ) { class [ i ] = array [ i ] . get class ( ) ; } return class ; }
public static string get short canonical name ( object object , string value if null ) { if ( object == null ) { return value if null ; } return get short canonical name ( object . get class ( ) . get name ( ) ) ; }
protect static enum get enum ( class enum class , string name ) { entry entry = get entry ( enum class ) ; if ( entry == null ) { return null ; } return ( enum ) entry . map . get ( name ) ; }
protect static enum get enum ( class enum class , string name ) { entry entry = get entry ( enum class ) ; if ( entry == null ) { return null ; } return ( enum ) entry . map . get ( name ) ; }
public int hash code ( ) { int hash code = get class ( ) . hash code ( ) ; for ( final int b : byte ) { hash code += b ; } return hash code ; }
public static throwable [ ] get throwables ( throwable throwable ) { list < throwable > list = new array list < throwable > ( ) ; while ( throwable ! = null ) { list . add ( throwable ) ; throwable = get cause ( throwable ) ; } return list . to array ( new throwable [ list . size ( ) ] ) ; }
public static string [ ] get root cause stack trace ( throwable t ) { throwable throwables [ ] = get throwables ( t ) ; int count = throwables . length ; array list frame = new array list ( ) ; list next trace = get stack frame list ( throwables [ count - 1 ] ) ; for ( int i = count ; -- i > = 0 ; ) { list trace = next trace ; if ( i ! = 0 ) { next trace = get stack frame list ( throwables [ i - 1 ] ) ; remove common frame ( trace , next trace ) ; } if ( i == count - 1 ) { frame . add ( throwables [ i ] . to string ( ) ) ; } else { frame . add ( wrapped_marker + throwables [ i ] . to string ( ) ) ; } for ( int j = 0 ; j < trace . size ( ) ; j++ ) { frame . add ( trace . get ( j ) ) ; } } return ( string [ ] ) frames . to array ( new string [ 0 ] ) ; }
public object get ( string key ) { entry tab [ ] = table ; int hash = key . hash code ( ) ; int index = ( hash & 0x7 f f f f f f f ) % tab . length ; for ( entry e = tab [ index ] ; e ! = null ; e = e . next ) { if ( ( e . hash == hash ) & & ( e . key == key ) ) return e . value ; } return null ; }
public int get maximum text length ( locale locale ) { int max = get maximum value ( ) ; if ( max > = 0 ) { if ( max < 10 ) { return 1 ; } else if ( max < 100 ) { return 2 ; } else if ( max < 1000 ) { return 3 ; } } return integer . to string ( max ) . length ( ) ; }
public int get maximum text length ( locale locale ) { int max = get maximum value ( ) ; if ( max > = 0 ) { if ( max < 10 ) { return 1 ; } else if ( max < 100 ) { return 2 ; } else if ( max < 1000 ) { return 3 ; } } return integer . to string ( max ) . length ( ) ; }
public double ratio ( long numerator , long denominator ) { return denominator == 0 ? 0f : ( ( double ) numerator ) / ( ( double ) denominator ) ; }
public float float value ( ) { return numerator . float value ( ) / denominator . float value ( ) ; }
public big fraction divide ( final big fraction fraction ) { if ( fraction == null ) { throw new null argument exception ( localized format . fraction ) ; } if ( fraction . numerator . signum ( ) == 0 ) { throw new math arithmetic exception ( localized format . zero_denominator ) ; } if ( numerator . signum ( ) == 0 ) { return zero ; } return multiply ( fraction . reciprocal ( ) ) ; }
public boolean overlap range ( range range ) { if ( range == null ) { return false ; } return range . contains integer ( min ) || range . contains integer ( max ) || contains integer ( range . get minimum integer ( ) ) ; }
public int compare to ( time stamp another time stamp ) { long this val = this . ntp time ; long another val = another time stamp . ntp time ; return ( this val < another val ? -1 : ( this val == another val ? 0 : 1 ) ) ; }
public static byte to byte ( object value ) throw conversion exception { number n = to number ( value , byte . class ) ; if ( n instanceof byte ) { return ( byte ) n ; } else { return new byte ( n . byte value ( ) ) ; } }
public boolean equal ( object obj ) { if ( obj == this ) { return true ; } if ( obj instanceof double range == false ) { return false ; } double range range = ( double range ) obj ; return ( double . double to long bit ( min ) == double . double to long bit ( range . min ) & & double . double to long bit ( max ) == double . double to long bit ( range . max ) ) ; }
public boolean contains double ( number value ) { if ( value == null ) { return false ; } return contains double ( value . double value ( ) ) ; }
public boolean contains double ( number value ) { if ( value == null ) { return false ; } return contains double ( value . double value ( ) ) ; }
public void print stack trace ( print writer out ) { delegate . print stack trace ( out ) ; }
public void append start ( string buffer buffer , object object ) { if ( object ! = null ) { append class name ( buffer , object ) ; append identity hash code ( buffer , object ) ; append content start ( buffer ) ; if ( field separator at start ) { append field separator ( buffer ) ; } } }
public static field get declared field ( class cl , string field name ) { return get declare field ( cls , field name , false ) ; }
public static object read static field ( class cl , string field name ) throw illegal access exception { return read static field ( cls , field name , false ) ; }
public static void write declare static field ( class < ? > cl , string field name , object value ) throw illegal access exception { write declare static field ( cls , field name , value , false ) ; }
public static constructor get accessible constructor ( class cl , class parameter type ) { return get accessible constructor ( cl , new class [ ] { parameter type } ) ; }
public static file get user dir ( ) { return new file ( system . get property ( user_dir_key ) ) ; }
public boolean be empty ( ) { return size ( ) == 0 ; }
public str builder append ( string buffer str ) { if ( str == null ) { return append null ( ) ; } int str len = str . length ( ) ; if ( str len > 0 ) { int len = length ( ) ; ensure capacity ( len + str len ) ; str . get char ( 0 , str len , buffer , len ) ; size += str len ; } return this ; }
public str builder appendln ( boolean value ) { return append ( value ) . append new line ( ) ; }
public text string builder insert ( final int index , final char [ ] char , final int offset , final int length ) { validate index ( index ) ; if ( char == null ) { return insert ( index , null text ) ; } if ( offset < 0 || offset > char . length ) { throw new string index out of bound exception ( `` invalid offset : `` + offset ) ; } if ( length < 0 || offset + length > char . length ) { throw new string index out of bound exception ( `` invalid length : `` + length ) ; } if ( length > 0 ) { ensure capacity ( size + length ) ; system . arraycopy ( buffer , index , buffer , index + length , size - index ) ; system . arraycopy ( char , offset , buffer , index , length ) ; size += length ; } return this ; }
public static string translate ( string str , string search char , string replace char ) { if ( string utils . be empty ( str ) ) { return str ; } string buffer buffer = new string buffer ( str . length ( ) ) ; char [ ] chrs = str . to char array ( ) ; char [ ] with chrs = replace char . to char array ( ) ; int sz = chrs . length ; int with max = replace char . length ( ) - 1 ; for ( int i=0 ; i < sz ; i++ ) { int idx = search char . index of ( chrs [ i ] ) ; if ( idx ! = -1 ) { if ( idx > with max ) { idx = with max ; } buffer . append ( with chrs [ idx ] ) ; } else { buffer . append ( chrs [ i ] ) ; } } return buffer . to string ( ) ; }
public str builder replace first ( string search str , string replace str ) { int search len = ( search str == null ? 0 : search str . length ( ) ) ; if ( search len > 0 ) { int index = index of ( search str , 0 ) ; if ( index > = 0 ) { int replace len = ( replace str == null ? 0 : replace str . length ( ) ) ; replace impl ( index , index + search len , search len , replace str , replace len ) ; } } return this ; }
public boolean end with ( string str ) { if ( str == null ) { return false ; } int len = str . length ( ) ; if ( len == 0 ) { return true ; } if ( len > size ) { return false ; } int pos = size - len ; for ( int i = 0 ; i < len ; i++ , pos++ ) { if ( buffer [ pos ] ! = str . char at ( i ) ) { return false ; } } return true ; }
public string leave string ( int length ) { if ( length < = 0 ) { return `` `` ; } else if ( length > = size ) { return new string ( buffer , 0 , size ) ; } else { return new string ( buffer , 0 , length ) ; } }
public int index of ( str matcher matcher ) { return index of ( matcher , 0 ) ; }
public int last index of ( string str , int start index ) { start index = ( start index > = size ? size - 1 : start index ) ; if ( str == null || start index < 0 ) { return -1 ; } int str len = str . length ( ) ; if ( str len > 0 & & str len < = size ) { if ( str len == 1 ) { return last index of ( str . char at ( 0 ) , start index ) ; } outer : for ( int i = start index - str len + 1 ; i > = 0 ; i -- ) { for ( int j = 0 ; j < str len ; j++ ) { if ( str . char at ( j ) ! = buffer [ i + j ] ) { continue outer ; } } return i ; } } else if ( str len == 0 ) { return start index ; } return -1 ; }
public static reader get resource a reader ( string resource ) throw i o exception { reader reader ; if ( charset == null ) { reader = new input stream reader ( get resource a stream ( resource ) ) ; } else { reader = new input stream reader ( get resource a stream ( resource ) , charset ) ; } return reader ; }
public static str matcher tab matcher ( ) { return tab_matcher ; }
public str substitutor set variable suffix matcher ( str matcher suffix matcher ) { if ( suffix matcher == null ) { throw new illegal argument exception ( `` variable suffix matcher must not be null ! `` ) ; } this . suffix matcher = suffix matcher ; return this ; }
public boolean have next ( ) { check tokenized ( ) ; return token po < token . length ; }
public str tokenizer set ignore char ( char ignore ) { return set ignore matcher ( str matcher . char matcher ( ignore ) ) ; }
public static string format ( calendar calendar , string pattern , locale locale ) { return format ( calendar , pattern , null , locale ) ; }
public static void no null element ( object [ ] array , string message ) { if ( array ! = null ) { for ( int i = 0 ; i < array . length ; i++ ) { if ( array [ i ] == null ) { throw new illegal argument exception ( message ) ; } } } }
public static void no null element ( object [ ] array , string message ) { if ( array ! = null ) { for ( int i = 0 ; i < array . length ; i++ ) { if ( array [ i ] == null ) { throw new illegal argument exception ( message ) ; } } } }
public static void all element of type ( collection collection , class clazz ) { validate . not null ( collection ) ; validate . not null ( clazz ) ; int i = 0 ; for ( iterator it = collection . iterator ( ) ; it . have next ( ) ; i++ ) { if ( clazz . be instance ( it . next ( ) ) == false ) { throw new illegal argument exception ( `` the validated collection contain an element not of type `` + clazz . get name ( ) + `` at index : `` + i ) ; } } }
public static string capitalize fully ( string str , char [ ] delimiters ) { int delim len = ( delimiters == null ? -1 : delimiters . length ) ; if ( str == null || str . length ( ) == 0 || delim len == 0 ) { return str ; } str = str . to lower case ( ) ; return capitalize ( str , delimiters ) ; }
public static file get user dir ( ) { return new file ( system . get property ( user_dir_key ) ) ; }
public string substitutor set enable substitution in variable ( final boolean enable substitution in variable ) { this . enable substitution in variable = enable substitution in variable ; return this ; }
public integer get priority ( ) { return priority ; }
public long get roll count thread execute ( ) { return roll counter stream . get late count ( hystrix event type . thread pool . execute ) ; }
public < t > listenable future < t > submit ( final callable < t > callable , executor executor ) { check not null ( callable ) ; return submit async ( new async callable < t > ( ) { @ override public listenable future < t > call ( ) throw exception { return immediate future ( callable . call ( ) ) ; } } , executor ) ; }
public boolean evaluate ( final t object ) { for ( final predicate < ? super t > i predicate : i predicate ) { if ( i predicate . evaluate ( object ) ) { return true ; } } return false ; }
public schedule executor service get schedule executor service ( ) { return state . get scheduled executor service ( ) ; }
public string [ ] find lifecycle listener name ( ) throw m bean exception { container container = do get manage resource ( ) ; list < string > result = new array list < > ( ) ; lifecycle listener [ ] listener = container . find lifecycle listener ( ) ; for ( lifecycle listener listener : listener ) { result . add ( listener . get class ( ) . get name ( ) ) ; } return result . to array ( new string [ 0 ] ) ; }
public static filename filter to filename filter ( final filter < file > filter ) { return new filename filter ( ) { @ override public boolean accept ( file dir , string name ) { return filter . filter ( new file ( dir , name ) ) ; } @ override public string to string ( ) { return filter . to string ( ) ; } } ; }
public static boolean equal ( object this obj , object that obj ) { if ( this obj == null ) { return that obj == null ; } else if ( that obj == null ) { return false ; } final class < ? > clazz = this obj . get class ( ) ; if ( ! clazz . equal ( that obj . get class ( ) ) ) { return false ; } if ( ! clazz . be array ( ) ) { return this obj . equal ( that obj ) ; } final class < ? > component type = clazz . get component type ( ) ; if ( long . class . equal ( component type ) ) { return array . equal ( ( long [ ] ) this obj , ( long [ ] ) that obj ) ; } else if ( int . class . equal ( component type ) ) { return array . equal ( ( int [ ] ) this obj , ( int [ ] ) that obj ) ; } else if ( short . class . equal ( component type ) ) { return array . equal ( ( short [ ] ) this obj , ( short [ ] ) that obj ) ; } else if ( char . class . equal ( component type ) ) { return array . equal ( ( char [ ] ) this obj , ( char [ ] ) that obj ) ; } else if ( byte . class . equal ( component type ) ) { return array . equal ( ( byte [ ] ) this obj , ( byte [ ] ) that obj ) ; } else if ( boolean . class . equal ( component type ) ) { return array . equal ( ( boolean [ ] ) this obj , ( boolean [ ] ) that obj ) ; } else if ( float . class . equal ( component type ) ) { return array . equal ( ( float [ ] ) this obj , ( float [ ] ) that obj ) ; } else if ( double . class . equal ( component type ) ) { return array . equal ( ( double [ ] ) this obj , ( double [ ] ) that obj ) ; } else { return array . equal ( ( object [ ] ) this obj , ( object [ ] ) that obj ) ; } }
public integer actual maximum size ( ) { final int core size = core size ( ) . get ( ) ; final int maximum size = maximum size ( ) . get ( ) ; if ( get allow maximum size to diverge from core size ( ) . get ( ) ) { if ( core size > maximum size ) { return core size ; } else { return maximum size ; } } else { return core size ; } }
public static void write static field ( field field , object value , boolean force access ) throw illegal access exception { if ( field == null ) { throw new illegal argument exception ( `` the field must not be null `` ) ; } if ( ! modifier . be static ( field . get modifier ( ) ) ) { throw new illegal argument exception ( `` the field ' `` + field . get name ( ) + `` ' be not static `` ) ; } write field ( field , ( object ) null , value , force access ) ; }
public static boolean be assignable ( final type type , final type to type ) { return be assignable ( type , to type , null ) ; }
public static final string unescape html4 ( string input ) { return unescape_html4 . translate ( input ) ; }
public static final string unescape html4 ( string input ) { return unescape_html4 . translate ( input ) ; }
public str builder append ( char sequence seq , int start index , int length ) { if ( seq == null ) { return append null ( ) ; } return append ( seq . to string ( ) , start index , length ) ; }
public static < t extend collection < ? > > t valid index ( t collection , int index , string message , object . . . value ) { validate . not null ( collection ) ; if ( index < 0 || index > = collection . size ( ) ) { throw new index out of bound exception ( string . format ( message , value ) ) ; } return collection ; }
public static < t extend collection < ? > > t valid index ( t collection , int index , string message , object . . . value ) { validate . not null ( collection ) ; if ( index < 0 || index > = collection . size ( ) ) { throw new index out of bound exception ( string . format ( message , value ) ) ; } return collection ; }
public static < t > void exclusive between ( t start , t end , comparable < t > value ) { if ( value . compare to ( start ) < = 0 || value . compare to ( end ) > = 0 ) { throw new illegal argument exception ( string . format ( default_exclusive_between_ex_message , value , start , end ) ) ; } }
public static < t > void exclusive between ( t start , t end , comparable < t > value , string message , object . . . value ) { if ( value . compare to ( start ) < = 0 || value . compare to ( end ) > = 0 ) { throw new illegal argument exception ( string . format ( message , value ) ) ; } }
public static void be assignable from ( class < ? > super type , class < ? > type ) { if ( super type . be assignable from ( type ) == false ) { throw new illegal argument exception ( string . format ( default_is_assignable_ex_message , type == null ? `` null `` : type . get name ( ) , super type . get name ( ) ) ) ; } }
public static boolean [ ] add ( final boolean [ ] array , final boolean element ) { final boolean [ ] new array = ( boolean [ ] ) copy array grow1 ( array , boolean . type ) ; new array [ new array . length - 1 ] = element ; return new array ; }
public static boolean [ ] insert ( final int index , final boolean [ ] array , final boolean . . . value ) { if ( array == null ) { return null ; } if ( array utils . be empty ( value ) ) { return clone ( array ) ; } if ( index < 0 || index > array . length ) { throw new index out of bound exception ( `` index : `` + index + `` , length : `` + array . length ) ; } final boolean [ ] result = new boolean [ array . length + value . length ] ; system . arraycopy ( value , 0 , result , index , value . length ) ; if ( index > 0 ) { system . arraycopy ( array , 0 , result , 0 , index ) ; } if ( index < array . length ) { system . arraycopy ( array , index , result , index + value . length , array . length - index ) ; } return result ; }
public static void shift ( final double [ ] array , final int offset ) { if ( array == null ) { return ; } shift ( array , 0 , array . length , offset ) ; }
public static void swap ( final int [ ] array , final int offset1 , final int offset2 ) { if ( be empty ( array ) ) { return ; } swap ( array , offset1 , offset2 , 1 ) ; }
public static void swap ( final short [ ] array , int offset1 , int offset2 , int len ) { if ( be empty ( array ) || offset1 > = array . length || offset2 > = array . length ) { return ; } if ( offset1 < 0 ) { offset1 = 0 ; } if ( offset2 < 0 ) { offset2 = 0 ; } if ( offset1 == offset2 ) { return ; } len = math . min ( math . min ( len , array . length - offset1 ) , array . length - offset2 ) ; for ( int i = 0 ; i < len ; i++ , offset1++ , offset2++ ) { final short aux = array [ offset1 ] ; array [ offset1 ] = array [ offset2 ] ; array [ offset2 ] = aux ; } }
public field find field ( final string name ) { return ( field ) field cache . get ( name ) ; }
public long get interval ( ) { return interval ; }
public long get closing interval ( ) { return closing interval ; }
public synchronize void acquire ( ) throw interrupted exception { if ( be shutdown ( ) ) { throw new illegal state exception ( `` time semaphore be shut down ! `` ) ; } if ( task == null ) { task = start timer ( ) ; } boolean can pass = false ; do { can pass = get limit ( ) < = no_limit || acquire count < get limit ( ) ; if ( ! can pass ) { wait ( ) ; } else { acquire count++ ; } } while ( ! can pass ) ; }
public string [ ] find lifecycle listener name ( ) throw m bean exception { container container = do get manage resource ( ) ; list < string > result = new array list < > ( ) ; lifecycle listener [ ] listener = container . find lifecycle listener ( ) ; for ( lifecycle listener listener : listener ) { result . add ( listener . get class ( ) . get name ( ) ) ; } return result . to array ( new string [ 0 ] ) ; }
public void set value ( string value ) { this . value = value ; this . value set = true ; }
public byte get and increment ( ) { final byte last = value ; value++ ; return last ; }
public float next float ( ) { return shared_random . next float ( ) ; }
public static string get system property ( final string name ) { return access controller . do privilege ( new privilege action < string > ( ) { public string run ( ) { return system . get property ( name ) ; } } ) ; }
public static object [ ] clone ( object [ ] array ) { if ( array == null ) { return null ; } return ( object [ ] ) array . clone ( ) ; }
public static collection < thread > find thread by name ( final string thread name , final thread group thread group ) { return find thread ( thread group , false , new name predicate ( thread name ) ) ; }
public static int day of month of ( date date ) { return to calendar ( date ) . get ( calendar . day_of_month ) ; }
public string month name ( int month , int min width , int max width ) { string name = english month [ month-1 ] ; if ( max width < 3 ) { max width = 3 ; } if ( name . length ( ) > max width ) { name = name . substring ( 0 , max width ) ; } while ( name . length ( ) < min width ) { name = name + ' ' ; } return name ; }
public static stop watch create start ( ) { stop watch sw = new stop watch ( ) ; sw . start ( ) ; return sw ; }
public boolean equal ( object obj ) { if ( obj == this ) { return true ; } if ( obj instanceof map . entry < ? , ? > ) { map . entry < ? , ? > other = ( map . entry < ? , ? > ) obj ; return object utils . equal ( get key ( ) , other . get key ( ) ) & & object utils . equal ( get value ( ) , other . get value ( ) ) ; } return false ; }
public boolean be not empty ( ) { return size ! = 0 ; }
public string month name ( int month , int min width , int max width ) { string name = english month [ month-1 ] ; if ( max width < 3 ) { max width = 3 ; } if ( name . length ( ) > max width ) { name = name . substring ( 0 , max width ) ; } while ( name . length ( ) < min width ) { name = name + ' ' ; } return name ; }
public static java unicode escaper outside of ( final int codepoint low , final int codepoint high ) { return new java unicode escaper ( codepoint low , codepoint high , false ) ; }
public long get duration ( time unit time unit ) { return time unit . convert ( nanos , time unit . nanosecond ) ; }
public static string get simple name ( class < ? > cl ) { if ( cls == null ) { return string utils . empty ; } return cl . get simple name ( ) ; }
public string get value type desc ( ) { class < ? > cl = get value class ( ) ; if ( cls == null ) { return `` unknown `` ; } return cl . get name ( ) ; }
public logger get logger ( ) { logger result = logger ; if ( result == null ) { synchronize ( this ) { result = logger ; if ( result == null ) { logger = result = hierarchy . get default hierarchy ( ) . get logger for ( name ) ; } } } return result ; }
public void trace ( object message , throwable t ) { debug ( message , t ) ; }
public boolean be fatal enabled ( ) { return get logger ( ) . be fatal error enable ( ) ; }
static public log get instance ( string name ) { log log = ( log ) ( log . get ( name ) ) ; if ( null == log ) { log = make new log instance ( name ) ; log . put ( name , log ) ; } return log ; }
public int hash code ( ) { return 227 + 229 * get free parameter ( ) + 233 * get order ( ) + 239 * math utils . hash ( data ) ; }
public estimate parameter [ ] get all parameter ( ) { return parameter . to array ( new estimate parameter [ parameter . size ( ) ] ) ; }
public double value ( double z ) { return evaluate internal ( x , y , z ) ; }
public int get degree ( ) { return degree - 1 ; }
public boolean be imaginary ( ) { return imaginary ; }
public boolean be na n ( ) { return double . be na n ( value ) ; }
public complex sinh ( ) { if ( be na n ) { return na n ; } return create complex ( fast math . sinh ( real ) * fast math . co ( imaginary ) , fast math . cosh ( real ) * fast math . sin ( imaginary ) ) ; }
public complex tan ( ) { if ( be na n || double . be infinite ( real ) ) { return na n ; } if ( imaginary > 20 . 0 ) { return create complex ( 0 . 0 , 1 . 0 ) ; } if ( imaginary < -20 . 0 ) { return create complex ( 0 . 0 , -1 . 0 ) ; } double real2 = 2 . 0 * real ; double imaginary2 = 2 . 0 * imaginary ; double d = fast math . co ( real2 ) + fast math . cosh ( imaginary2 ) ; return create complex ( fast math . sin ( real2 ) / d , fast math . sinh ( imaginary2 ) / d ) ; }
public double get argument ( ) { return math . atan2 ( get imaginary ( ) , get real ( ) ) ; }
public static complex value of ( double real part ) { if ( double . be na n ( real part ) ) { return na n ; } return new complex ( real part ) ; }
public boolean be unit quaternion ( double eps ) { return precision . equal ( get norm ( ) , 1d , eps ) ; }
public static double dot product ( final quaternion q1 , final quaternion q2 ) { return q1 . get q0 ( ) * q2 . get q0 ( ) + q1 . get q1 ( ) * q2 . get q1 ( ) + q1 . get q2 ( ) * q2 . get q2 ( ) + q1 . get q3 ( ) * q2 . get q3 ( ) ; }
public round mode get rounding mode ( ) { return round mode ; }
public static dfp sin ( final dfp a ) { final dfp pi = a . get field ( ) . get pi ( ) ; final dfp zero = a . get field ( ) . get zero ( ) ; boolean neg = false ; / * first reduce the argument to the range of +/- pi * / dfp x = a . remainder ( pi . multiply ( 2 ) ) ; / * if x < 0 then apply identity sin ( -x ) = -sin ( x ) * / / * this put x in the range 0 < x < pi * / if ( x . less than ( zero ) ) { x = x . negate ( ) ; neg = true ; } / * since sine ( x ) = sine ( pi - x ) we can reduce the range to * 0 < x < pi/2 * / if ( x . great than ( pi . divide ( 2 ) ) ) { x = pi . subtract ( x ) ; } dfp y ; if ( x . less than ( pi . divide ( 4 ) ) ) { y = sin internal ( split ( x ) ) ; } else { final dfp c [ ] = new dfp [ 2 ] ; final dfp [ ] pi split = a . get field ( ) . get pi split ( ) ; c [ 0 ] = pi split [ 0 ] . divide ( 2 ) . subtract ( x ) ; c [ 1 ] = pi split [ 1 ] . divide ( 2 ) ; y = cos internal ( c ) ; } if ( neg ) { y = y . negate ( ) ; } return a . new instance ( y ) ; }
protect static dfp atan internal ( final dfp a ) { dfp y = new dfp ( a ) ; dfp x = new dfp ( y ) ; dfp py = new dfp ( y ) ; for ( int i = 3 ; i < 90 ; i += 2 ) { x = x . multiply ( a ) ; x = x . multiply ( a ) ; x = x . negate ( ) ; y = y . add ( x . divide ( i ) ) ; if ( y . equal ( py ) ) { break ; } py = new dfp ( y ) ; } return y ; }
public float get mu ( ) { return mu ; }
public float [ ] [ ] get ink list ( ) { c o s array array = get c o s object ( ) . get c o s array ( c o s name . inklist ) ; if ( array ! = null ) { float [ ] [ ] ink list = new float [ array . size ( ) ] [ ] ; for ( int i = 0 ; i < array . size ( ) ; ++i ) { c o s base base2 = array . get object ( i ) ; if ( base2 instanceof c o s array ) { ink list [ i ] = ( ( c o s array ) array . get object ( i ) ) . to float array ( ) ; } else { ink list [ i ] = new float [ 0 ] ; } } return ink list ; } return new float [ 0 ] [ 0 ] ; }
public levenberg marquardt optimizer with ortho tolerance ( double new ortho tolerance ) { return new levenberg marquardt optimizer ( initial step bound factor , cost relative tolerance , par relative tolerance , new ortho tolerance , qr rank threshold ) ; }
public void clear observation ( ) { observation . clear ( ) ; }
public big fraction multiply ( final big fraction fraction ) { if ( fraction == null ) { throw new null argument exception ( localized format . fraction ) ; } if ( numerator . signum ( ) == 0 || fraction . numerator . signum ( ) == 0 ) { return zero ; } return new big fraction ( numerator . multiply ( fraction . numerator ) , denominator . multiply ( fraction . denominator ) ) ; }
public big fraction multiply ( final big fraction fraction ) { if ( fraction == null ) { throw new null argument exception ( localized format . fraction ) ; } if ( numerator . signum ( ) == 0 || fraction . numerator . signum ( ) == 0 ) { return zero ; } return new big fraction ( numerator . multiply ( fraction . numerator ) , denominator . multiply ( fraction . denominator ) ) ; }
public static fraction get fraction ( int numerator , int denominator ) { if ( denominator == 0 ) { throw new arithmetic exception ( `` the denominator must not be zero `` ) ; } if ( denominator < 0 ) { if ( numerator== integer . min_value || denominator== integer . min_value ) { throw new arithmetic exception ( `` overflow : ca n't negate `` ) ; } numerator = -numerator ; denominator = -denominator ; } return new fraction ( numerator , denominator ) ; }
public chromosome pair crossover ( chromosome first , chromosome second ) { if ( ! ( first instanceof abstract list chromosome < ? > & & second instanceof abstract list chromosome < ? > ) ) { throw new illegal argument exception ( `` one point crossover work on fixed length chromosomes only . `` ) ; } return crossover ( ( abstract list chromosome < t > ) first , ( abstract list chromosome < t > ) second ) ; }
public static string random ( int count , int start , int end , boolean letter , boolean number , char [ ] char ) { return random ( count , start , end , letter , number , char , random ) ; }
public void set elitism rate ( double elitism rate ) { if ( elitism rate < 0 || elitism rate > 1 ) throw new illegal argument exception ( `` elitism rate have to be in [ 0,1 ] `` ) ; this . elitism rate = elitism rate ; }
public boolean be satisfied ( final population population ) { if ( this . num generation < this . max generation ) { num generations++ ; return false ; } return true ; }
public static synchronize void set random generator ( final random generator random ) { random generator = random ; }
public double get crossover rate ( ) { return crossover rate ; }
public void set arity ( final int arity ) { this . arity = arity ; }
public boolean contains ( final p point ) { return point . distance ( center ) < = radius ; }
public void apply to ( final t [ ] in , final t [ ] out ) { final t x = in [ 0 ] ; final t y = in [ 1 ] ; final t z = in [ 2 ] ; final t s = q1 . multiply ( x ) . add ( q2 . multiply ( y ) ) . add ( q3 . multiply ( z ) ) ; out [ 0 ] = q0 . multiply ( x . multiply ( q0 ) . subtract ( q2 . multiply ( z ) . subtract ( q3 . multiply ( y ) ) ) ) . add ( s . multiply ( q1 ) ) . multiply ( 2 ) . subtract ( x ) ; out [ 1 ] = q0 . multiply ( y . multiply ( q0 ) . subtract ( q3 . multiply ( x ) . subtract ( q1 . multiply ( z ) ) ) ) . add ( s . multiply ( q2 ) ) . multiply ( 2 ) . subtract ( y ) ; out [ 2 ] = q0 . multiply ( z . multiply ( q0 ) . subtract ( q1 . multiply ( y ) . subtract ( q2 . multiply ( x ) ) ) ) . add ( s . multiply ( q3 ) ) . multiply ( 2 ) . subtract ( z ) ; }
public t [ ] get value ( t [ ] array ) { t v = get value ( ) ; if ( v == null ) { if ( array . length ! = 0 ) { array [ 0 ] = null ; } return array ; } if ( array . length == 0 ) { array = array . copy of ( array , 1 ) ; } array [ 0 ] = v ; if ( array . length ! = 1 ) { array [ 1 ] = null ; } return array ; }
public vector2 d to sub space ( final point < euclidean3 d > point ) { final vector3 d p3 d = ( vector3 d ) point ; return new vector2 d ( p3 d . dot product ( u ) , p3 d . dot product ( v ) ) ; }
public expression copy ( ) { arithmetic expression10 a2 = new arithmetic expression10 ( operand0 . copy ( ) , operator , operand1 . copy ( ) ) ; a2 . calculator = calculator ; return a2 ; }
public static vector2 d format get instance ( final locale locale ) { return new vector2 d format ( composite format . get default number format ( locale ) ) ; }
public void set tolerance ( double tolerance ) { this . tolerance = tolerance ; }
public s2 point get barycenter ( ) { if ( summed barycenter . get norm sq ( ) == 0 ) { return s2 point . na n ; } else { return new s2 point ( summed barycenter ) ; } }
public sub hyperplane < s > get plus outside ( ) { return plus outside ; }
public boolean touch inside ( ) { return inside touch ! = null & & ! inside touch . be empty ( ) ; }
public vector3 d get point at ( final double alpha ) { return new vector3 d ( fast math . co ( alpha ) , x , fast math . sin ( alpha ) , y ) ; }
public geometry convex hull ( ) { return ( new convex hull ( this ) ) . get convex hull ( ) ; }
public affine transformation rotate ( double sin theta , double co theta ) { compose ( rotation instance ( sin theta , cos theta ) ) ; return this ; }
public double get phase ( ) { return phi ; }
public boolean equal ( final object object ) { if ( object == this ) { return true ; } if ( object instanceof real matrix == false ) { return false ; } real matrix m = ( real matrix ) object ; final int n row = get row dimension ( ) ; final int n col = get column dimension ( ) ; if ( m . get column dimension ( ) ! = n col || m . get row dimension ( ) ! = n row ) { return false ; } for ( int row = 0 ; row < n row ; ++row ) { for ( int col = 0 ; col < n col ; ++col ) { if ( get entry ( row , col ) ! = m . get entry ( row , col ) ) { return false ; } } } return true ; }
protect void check sub matrix index ( final int [ ] select row , final int [ ] select column ) throw no data exception , null argument exception , out of range exception { if ( select row == null || select column == null ) { throw new null argument exception ( ) ; } if ( select row . length == 0 || select column . length == 0 ) { throw new no data exception ( ) ; } for ( final int row : select row ) { check row index ( row ) ; } for ( final int column : select column ) { check column index ( column ) ; } }
public int hash code ( ) { int h = get function name ( ) . hash code ( ) ; for ( int i=0 ; i < get number of argument ( ) ; i++ ) { h ^= argument [ i ] . hash code ( ) ; } return h ; }
public static set available locale set ( ) { if ( c available locale set == null ) { init available locale set ( ) ; } return c available locale set ; }
public void unitize ( ) throw math arithmetic exception { final double norm = get norm ( ) ; if ( norm == 0 ) { throw new math arithmetic exception ( localized format . zero_norm ) ; } map divide to self ( get norm ( ) ) ; }
public real vector map to self ( univariate function function ) { iterator < entry > it = iterator ( ) ; while ( it . have next ( ) ) { final entry e = it . next ( ) ; e . set value ( function . value ( e . get value ( ) ) ) ; } return this ; }
public sparse field vector < t > subtract ( sparse field vector < t > v ) throw illegal argument exception { check vector dimension ( v . get dimension ( ) ) ; sparse field vector < t > res = ( sparse field vector < t > ) copy ( ) ; open int to field hash map < t > . iterator iter = v . get entry ( ) . iterator ( ) ; while ( iter . have next ( ) ) { iter . advance ( ) ; int key = iter . key ( ) ; if ( entry . contains key ( key ) ) { re . set entry ( key , entry . get ( key ) . subtract ( iter . value ( ) ) ) ; } else { re . set entry ( key , field . get zero ( ) . subtract ( iter . value ( ) ) ) ; } } return re ; }
public integer actual maximum size ( ) { final int core size = core size ( ) . get ( ) ; final int maximum size = maximum size ( ) . get ( ) ; if ( get allow maximum size to diverge from core size ( ) . get ( ) ) { if ( core size > maximum size ) { return core size ; } else { return maximum size ; } } else { return core size ; } }
protect void set equation ( final expandable stateful o d e equation ) { this . expandable = equation ; }
public void set first index ( int idx ) { first index = idx ; }
public double [ ] get primary state ( ) { return primary state . clone ( ) ; }
public t [ ] get secondary state ( final int index ) { return index == 0 ? state . clone ( ) : secondary state [ index - 1 ] . clone ( ) ; }
public double [ ] guess parameter error ( ) { if ( row < = col ) { throw new number be too small exception ( localized format . no_degrees_of_freedom , row , col , false ) ; } double [ ] error = new double [ col ] ; final double c = fast math . sqrt ( get chi square ( ) / ( row - col ) ) ; double [ ] [ ] covar = compute covariance ( point , 1e-14 ) ; for ( int i = 0 ; i < error . length ; ++i ) { error [ i ] = fast math . sqrt ( covar [ i ] [ i ] ) * c ; } return error ; }
public double get h p ( ) { return h p ; }
public package relationship collection get relationship ( ) { return get relationship helper ( null ) ; }
protect final double [ ] get row ( int row ) { return tableau . get data ref ( ) [ row ] ; }
public double get complexity ( ) { double total cost = 0 ; for ( list < fragment > list : fragment ( ) ) { total cost += fragment list cost ( list ) ; } return total cost ; }
public neural network set cost function ( string cost function ) { this . cost function name = cost function ; return this ; }
public class < ? > [ ] get target implement ( ) { return target implement == null ? null : ( class [ ] ) target implement . clone ( ) ; }
public double [ ] get upper ( ) { return upper . clone ( ) ; }
public double get proxy start ( ) { return proxy start ; }
public double get r ( ) { double b1 = get slope ( ) ; double result = fast math . sqrt ( get r square ( ) ) ; if ( b1 < 0 ) { result = -result ; } return result ; }
public double [ ] [ ] get error covariance ( ) { return error covariance . get data ( ) ; }
public double orient distance ( coordinate p ) { vector3 d pb = new vector3 d ( p , base pt ) ; double pbd dot normal = pb . dot ( normal ) ; if ( double . be na n ( pbd dot normal ) ) throw new illegal argument exception ( `` 3d coordinate have na n ordinate `` ) ; double d = pbd dot normal / normal . length ( ) ; return d ; }
public static double regularize gamma p ( double a , double x ) { return regularize gamma p ( a , x , default_epsilon , integer . max_value ) ; }
public double [ ] get point ref ( ) { return point ; }
public real matrix get correlation matrix ( ) { return rank correlation . get correlation matrix ( ) ; }
public real matrix compute correlation matrix ( real matrix matrix ) { int n vars = matrix . get column dimension ( ) ; real matrix out matrix = new block real matrix ( n var , n var ) ; for ( int i = 0 ; i < n var ; i++ ) { for ( int j = 0 ; j < i ; j++ ) { double corr = correlation ( matrix . get column ( i ) , matrix . get column ( j ) ) ; out matrix . set entry ( i , j , corr ) ; out matrix . set entry ( j , i , corr ) ; } out matrix . set entry ( i , i , 1d ) ; } return out matrix ; }
public double get sumsq ( ) { return sumsq impl . get result ( ) ; }
public storeless univariate statistic [ ] get min impl ( ) { return min impl . clone ( ) ; }
public void set min impl ( storeless univariate statistic min impl ) throw math illegal state exception { check empty ( ) ; this . min impl = min impl ; }
public double evaluate ( final double [ ] value , final double [ ] weight , final int begin , final int length ) throw math illegal argument exception { double sum = double . na n ; if ( test ( value , weight , begin , length , true ) ) { sum = 0 . 0 ; for ( int i = begin ; i < begin + length ; i++ ) { sum += value [ i ] * weight [ i ] ; } } return sum ; }
public void set bias correct ( boolean bias correct ) { this . bias correct = bias correct ; }
public double evaluate ( final double [ ] value , final double mean , final int begin , final int length ) throw math illegal argument exception { return fast math . sqrt ( variance . evaluate ( value , mean , begin , length ) ) ; }
public double evaluate ( final double [ ] value , final double [ ] weight ) throw math illegal argument exception { return evaluate ( value , weight , 0 , value . length ) ; }
public void add value ( double [ ] value ) throw dimension mismatch exception { check dimension ( value . length ) ; for ( int i = 0 ; i < k ; ++i ) { double v = value [ i ] ; sum impl [ i ] . increment ( v ) ; sum sq impl [ i ] . increment ( v ) ; min impl [ i ] . increment ( v ) ; max impl [ i ] . increment ( v ) ; sum log impl [ i ] . increment ( v ) ; geo mean impl [ i ] . increment ( v ) ; mean impl [ i ] . increment ( v ) ; } covariance impl . increment ( value ) ; n++ ; }
public double get quantile ( ) { return quantile ; }
public double [ ] get standard deviation ( ) { double [ ] std dev = new double [ k ] ; if ( get n ( ) < 1 ) { array . fill ( std dev , double . na n ) ; } else if ( get n ( ) < 2 ) { array . fill ( std dev , 0 . 0 ) ; } else { real matrix matrix = covariance impl . get result ( ) ; for ( int i = 0 ; i < k ; ++i ) { std dev [ i ] = fast math . sqrt ( matrix . get entry ( i , i ) ) ; } } return std dev ; }
public double [ ] get min ( ) { return get result ( min impl ) ; }
public string to string ( ) { string buffer out buffer = new string buffer ( ) ; string endl = `` \n `` ; out buffer . append ( `` statistical summary value : `` ) . append ( endl ) ; out buffer . append ( `` n : `` ) . append ( get n ( ) ) . append ( endl ) ; out buffer . append ( `` min : `` ) . append ( get min ( ) ) . append ( endl ) ; out buffer . append ( `` max : `` ) . append ( get max ( ) ) . append ( endl ) ; out buffer . append ( `` mean : `` ) . append ( get mean ( ) ) . append ( endl ) ; out buffer . append ( `` std dev : `` ) . append ( get standard deviation ( ) ) . append ( endl ) ; out buffer . append ( `` variance : `` ) . append ( get variance ( ) ) . append ( endl ) ; out buffer . append ( `` sum : `` ) . append ( get sum ( ) ) . append ( endl ) ; return out buffer . to string ( ) ; }
public static void clear ( ) { class_to_elected_fields . clear ( ) ; dictionary_fields . clear ( ) ; field_to_cache_hit . clear ( ) ; field_to_nb_reset . clear ( ) ; dictionary_array . clear ( ) ; class_to_cache_hit . clear ( ) ; }
public double kolmogorov smirnov test ( real distribution distribution , double [ ] data , boolean exact ) { return 1d - cdf ( kolmogorov smirnov statistic ( distribution , data ) , data . length , exact ) ; }
public double kolmogorov smirnov test ( double [ ] x , double [ ] y , boolean strict ) { final long length product = ( long ) x . length * y . length ; double [ ] xa = null ; double [ ] ya = null ; if ( length product < large_sample_product & & have tie ( x , y ) ) { xa = math array . copy of ( x ) ; ya = math array . copy of ( y ) ; fix tie ( xa , ya ) ; } else { xa = x ; ya = y ; } if ( length product < large_sample_product ) { return exact p ( kolmogorov smirnov statistic ( xa , ya ) , x . length , y . length , strict ) ; } return approximate p ( kolmogorov smirnov statistic ( x , y ) , x . length , y . length ) ; }
public static confidence interval get normal approximation interval ( int number of trial , int number of success , double confidence level ) { return normal_approximation . create interval ( number of trial , number of success , confidence level ) ; }
protect void new y sample data ( double [ ] y ) { this . y = new array real vector ( y ) ; }
protect double calculate y variance ( ) { real vector residual = calculate residual ( ) ; return residual . dot product ( residual ) / ( x . get row dimension ( ) - x . get column dimension ( ) ) ; }
public double calculate adjust r square ( ) { final double n = get x ( ) . get row dimension ( ) ; if ( be no intercept ( ) ) { return 1 - ( 1 - calculate r square ( ) ) * ( n / ( n - get x ( ) . get column dimension ( ) ) ) ; } else { return 1 - ( calculate residual sum of square ( ) * ( n - 1 ) ) / ( calculate total sum of square ( ) * ( n - get x ( ) . get column dimension ( ) ) ) ; } }
public static long to long ( object value ) throw conversion exception { number n = to number ( value , long . class ) ; if ( n instanceof long ) { return ( long ) n ; } else { return new long ( n . long value ( ) ) ; } }
public void append ( simple regression reg ) { if ( n == 0 ) { xbar = reg . xbar ; ybar = reg . ybar ; sum x x = reg . sum x x ; sum y y = reg . sum y y ; sum x y = reg . sum x y ; } else { if ( have intercept ) { final double fact1 = reg . n / ( double ) ( reg . n + n ) ; final double fact2 = n * reg . n / ( double ) ( reg . n + n ) ; final double dx = reg . xbar - xbar ; final double dy = reg . ybar - ybar ; sum x x += reg . sum x x + dx * dx * fact2 ; sum y y += reg . sum y y + dy * dy * fact2 ; sum x y += reg . sum x y + dx * dy * fact2 ; xbar += dx * fact1 ; ybar += dy * fact1 ; } else { sum x x += reg . sum x x ; sum y y += reg . sum y y ; sum x y += reg . sum x y ; } } sum x += reg . sum x ; sum y += reg . sum y ; n += reg . n ; }
public double get intercept ( ) { return get intercept ( get slope ( ) ) ; }
public static double sum sq ( final double [ ] value , final int begin , final int length ) throw math illegal argument exception { return sum_of_squares . evaluate ( value , begin , length ) ; }
public double evaluate ( final double [ ] value , final double mean , final int begin , final int length ) throw math illegal argument exception { return fast math . sqrt ( variance . evaluate ( value , mean , begin , length ) ) ; }
public static double regularize gamma q ( double a , double x ) { return regularize gamma q ( a , x , default_epsilon , integer . max_value ) ; }
public int [ ] get order of regressors ( ) { return math array . copy of ( vorder ) ; }
public int compare value ( t first , t second ) { if ( first == null ) { if ( second == null ) { return 0 ; } else { return -1 ; } } else if ( second == null ) { return 1 ; } else { return ( ( comparable < t > ) first ) . compare to ( second ) ; } }
public boolean equal ( object o ) { if ( o == this ) { return true ; } if ( o instanceof pointer type ) { pointer p = ( ( pointer type ) o ) . get pointer ( ) ; if ( pointer == null ) { return p == null ; } return pointer . equal ( p ) ; } return false ; }
public static boolean equal include na n ( float x , float y , float eps ) { return equal include na n ( x , y ) || ( fast math . ab ( y - x ) < = eps ) ; }
public number transformer put transformer ( class < ? > key , number transformer transformer ) { return map . put ( key , transformer ) ; }
public static string replace system property ( object source ) { return new str substitutor ( str lookup . system property lookup ( ) ) . replace ( source ) ; }
public char sequence logest common subsequence ( final char sequence leave , final char sequence right ) { return long common subsequence ( leave , right ) ; }
public str tokenizer set ignore empty token ( boolean ignore empty token ) { this . ignore empty token = ignore empty token ; return this ; }
public static str matcher char set matcher ( final char . . . char ) { if ( char == null || char . length == 0 ) { return none_matcher ; } if ( char . length == 1 ) { return new char matcher ( char [ 0 ] ) ; } return new char set matcher ( char ) ; }
public text string builder appendln ( final text string builder str ) { return append ( str ) . append new line ( ) ; }
public str builder appendln ( char [ ] char ) { return append ( char ) . append new line ( ) ; }
public str builder append separator ( string separator ) { return append separator ( separator , null ) ; }
public object get ( final object key ) { if ( key instanceof string ) { return this . get property ( ( string ) key ) ; } else { return super . get ( key ) ; } }
public int size ( ) { return b tree . size ( column ) ; }
public static byte [ ] copy ( byte [ ] source , byte [ ] target ) { int len = source . length ; if ( len > target . length ) { target = new byte [ len ] ; } system . arraycopy ( source , 0 , target , 0 , len ) ; return target ; }
public static resource change validator get validator ( ) { if ( instance == null ) instance = new resource change validator ( ) ; return instance ; }
public boolean have ip address ( string ip address ) { ip address matcher matcher = new ip address matcher ( ip address ) ; return matcher . match ( this . request ) ; }
protect void register indexed property ( indexed property definition indexed property ) { this . indexed property . add ( indexed property ) ; }
public void set depends on ( string . . . depend on ) { this . depend on = depends on ; }
public collect request set dependency ( list < dependency > dependency ) { if ( dependency == null ) { this . dependency = collection . empty list ( ) ; } else { this . dependency = dependency ; } return this ; }
protect void register indexed property ( indexed property definition indexed property ) { this . indexed property . add ( indexed property ) ; }
protect locale find locale for language ( string language ) { locale [ ] locales = locale . get available locale ( ) ; for ( int i = 0 , size = locale . length ; i < size ; i++ ) { locale locale = locales [ i ] ; if ( language . equal ( locale . get language ( ) ) ) { string country = locale . get country ( ) ; if ( country == null || country . length ( ) == 0 ) { string variant = locale . get variant ( ) ; if ( variant == null || variant . length ( ) == 0 ) { return locale ; } } } } return null ; }
public static boolean be valid ( final issuer value ) { if ( value == null ) return false ; try { return be valid ( new uri ( value . get value ( ) ) ) ; } catch ( u r i syntax exception e ) { return false ; } }
public boolean be valid ( string email ) { return org . apache . common . validator . routine . email validator . get instance ( ) . be valid ( email ) ; }
public string format ( object value , locale locale , time zone time zone ) { return format ( value , ( string ) null , locale , time zone ) ; }
public boolean contains property ( string value ) { if ( value == null ) { return false ; } final int len = value . length ( ) ; for ( parse position po = new parse position ( 0 ) ; po . get index ( ) < len ; ) { if ( parse property name ( value , po ) ! = null ) { return true ; } po . set index ( po . get index ( ) + 1 ) ; } return false ; }
public big integer validate ( string value , string pattern , locale locale ) { return ( big integer ) parse ( value , pattern , locale ) ; }
public calendar validate ( string value , string pattern , locale locale , time zone time zone ) { return ( calendar ) parse ( value , pattern , locale , time zone ) ; }
public calendar validate ( string value , string pattern , time zone time zone ) { return ( calendar ) parse ( value , pattern , ( locale ) null , time zone ) ; }
public string calculate ( string code ) throw check digit exception { if ( code == null || code . length ( ) == 0 ) { throw new check digit exception ( `` code be miss `` ) ; } int modulus result = calculate modulus ( code , false ) ; int char value = ( modulus - modulus result ) % modulus ; return to check digit ( char value ) ; }
protect string to check digit ( int char value ) throw check digit exception { if ( char value == 10 ) { return `` x `` ; } else { return super . to check digit ( char value ) ; } }
public string calculate ( string code ) throw check digit exception { if ( code == null || code . length ( ) == 0 ) { throw new check digit exception ( `` code be miss `` ) ; } int modulus result = calculate modulus ( code , false ) ; int char value = ( modulus - modulus result ) % modulus ; return to check digit ( char value ) ; }
public date validate ( string value , string pattern , locale locale , time zone time zone ) { return ( date ) parse ( value , pattern , locale , time zone ) ; }
public static domain validator get instance ( boolean allow local ) { if ( allow local ) { return domain_validator_with_local ; } return domain_validator ; }
public boolean be valid generic tld ( string g tld ) { return generic_tld_list . contains ( chomp lead dot ( g tld . to lower case ( ) ) ) ; }
public boolean be valid generic tld ( string g tld ) { return generic_tld_list . contains ( chomp lead dot ( g tld . to lower case ( ) ) ) ; }
public float validate ( string value , string pattern , locale locale ) { return ( float ) parse ( value , pattern , locale ) ; }
public static resource change validator get validator ( ) { if ( instance == null ) instance = new resource change validator ( ) ; return instance ; }
public calendar validate ( string value , string pattern , time zone time zone ) { return ( calendar ) parse ( value , pattern , ( locale ) null , time zone ) ; }
public void set parameter ( string parameter class name , object parameter value ) { this . parameter . put ( parameter class name , parameter value ) ; }
public void add msg ( msg msg ) { h msg . put ( msg . get name ( ) , msg ) ; }
public void set javascript ( string javascript ) { if ( js function ! = null ) { throw new illegal state exception ( `` can not call set javascript ( ) after call set j function ( ) `` ) ; } this . javascript = javascript ; }
public validator action get validator action ( string key ) { return ( validator action ) h action . get ( key ) ; }
public map get validator action ( ) { return collection . unmodifiable map ( h action ) ; }
public validator result get validator result ( string key ) { return ( validator result ) this . h result . get ( key ) ; }
public string get ( string path ) { final json value value = this . value . get ( this . path to property ( path ) ) ; if ( value == null ) { return null ; } if ( ! value . be string ( ) ) { return value . to string ( ) ; } return value . a string ( ) ; }
public static int main program ( string args [ ] ) throw exception { j j doc context context = new j j doc context ( ) ; java c c globals . banner line ( `` documentation generator `` , `` 0 . 1 . 4 `` ) ; java c c parser parser = null ; if ( args . length == 0 ) { j j doc main . help_message ( context ) ; return 1 ; } else { j j doc globals . info ( context , `` ( type \ `` jjdoc\ `` with no argument for help ) `` ) ; } if ( option . be option ( args [ args . length - 1 ] ) ) { j j doc globals . error ( context , `` last argument \ `` `` + args [ args . length - 1 ] + `` \ `` be not a filename or \ `` -\ `` . `` ) ; return 1 ; } for ( int arg = 0 ; arg < ( args . length - 1 ) ; arg++ ) { if ( ! option . be option ( args [ arg ] ) ) { j j doc globals . error ( context , `` argument \ `` `` + args [ arg ] + `` \ `` must be an option setting . `` ) ; return 1 ; } option . set cmd line option ( args [ arg ] ) ; } if ( args [ args . length - 1 ] . equal ( `` - `` ) ) { j j doc globals . info ( context , `` reading from standard input . . . `` ) ; parser = new java c c parser ( new java . io . data input stream ( system . in ) ) ; j j doc globals . input_file = `` standard input `` ; j j doc globals . output_file = `` standard output `` ; } else { j j doc globals . info ( context , `` reading from file `` + args [ args . length - 1 ] + `` . . . `` ) ; try { java . io . file fp = new java . io . file ( args [ args . length - 1 ] ) ; if ( ! fp . exists ( ) ) { j j doc globals . error ( context , `` file `` + args [ args . length - 1 ] + `` not find . `` ) ; return 1 ; } if ( fp . be directory ( ) ) { j j doc globals . error ( context , args [ args . length - 1 ] + `` be a directory . please use a valid file name . `` ) ; return 1 ; } j j doc globals . input_file = fp . get name ( ) ; parser = new java c c parser ( new java . io . buffer reader ( new java . io . input stream reader ( new java . io . file input stream ( args [ args . length - 1 ] ) , option . get grammar encoding ( ) ) ) ) ; } catch ( security exception se ) { j j doc globals . error ( context , `` security violation while try to open `` + args [ args . length - 1 ] ) ; return 1 ; } catch ( java . io . file not find exception e ) { j j doc globals . error ( context , `` file `` + args [ args . length - 1 ] + `` not find . `` ) ; return 1 ; } } try { parser . javacc_input ( context ) ; j j doc . start ( context ) ; if ( context . error ( ) . get_error_count ( ) == 0 ) { if ( context . error ( ) . get_warning_count ( ) == 0 ) { j j doc globals . info ( context , `` grammar documentation generate successfully in `` + j j doc globals . output_file ) ; } else { j j doc globals . info ( context , `` grammar documentation generate with 0 error and `` + context . error ( ) . get_warning_count ( ) + `` warning . `` ) ; } return 0 ; } else { j j doc globals . error ( context , `` detect `` + context . error ( ) . get_error_count ( ) + `` error and `` + context . error ( ) . get_warning_count ( ) + `` warning . `` ) ; return context . error ( ) . get_error_count ( ) == 0 ? 0 : 1 ; } } catch ( org . javacc . parser . meta parse exception e ) { j j doc globals . error ( context , e . to string ( ) ) ; j j doc globals . error ( context , `` detect `` + context . error ( ) . get_error_count ( ) + `` error and `` + context . error ( ) . get_warning_count ( ) + `` warning . `` ) ; return 1 ; } catch ( org . javacc . parser . parse exception e ) { j j doc globals . error ( context , e . to string ( ) ) ; j j doc globals . error ( context , `` detect `` + ( context . error ( ) . get_error_count ( ) + 1 ) + `` error and `` + context . error ( ) . get_warning_count ( ) + `` warning . `` ) ; return 1 ; } }
public void set nodeusesparser ( boolean node use parser ) { optional attrs . put ( node_uses_parser , node us parser ? boolean . true : boolean . false ) ; }
public final boolean get text ( ) { return option . boolean value ( `` text `` ) ; }
public final string get node extends ( ) { return option . string value ( `` node_extends `` ) ; }
public void set nodepackage ( string node package ) { optional attrs . put ( node_package , node package ) ; }
public static string string value ( final string option ) { return ( string ) option . option value . get ( option ) ; }
public static boolean get build token manager ( ) { return option . boolean value ( option . useroption__build_token_manager ) ; }
public static boolean get user token manager ( ) { return option . boolean value ( option . useroption__user_token_manager ) ; }
public static int compare java version ( string first , string second ) { return long . compare ( compiler option . version to jdk level ( first ) , compiler option . version to jdk level ( second ) ) ; }
public static boolean get generate annotation ( ) { return option . boolean value ( option . useroption__generate_annotations ) ; }
public void append to ( multi path mp ) { if ( ! gi . be in range ( 0 , cp . num point ( ) ) ) throw new illegal argument exception ( `` group iterator not in range `` ) ; ; int n = mp . get dimension ( ) ; double [ ] d = new double [ n + 1 ] ; d [ n ] = t_min ; eval ( d ) ; if ( connect ) mp . line to ( d ) ; else mp . move to ( d ) ; binary curve approximation algorithm . gen pt ( this , t_min , t_max , mp ) ; }
public void set use default interval ( boolean b ) { use default interval = b ; }
public curve get curve ( int index ) { return ( curve ) curve bag . get ( index ) ; }
public point get point ( int index ) { return ( point ) point bag . get ( index ) ; }
public list sub list ( int from index , int to index ) { if ( fast ) { return new sub list ( from index , to index ) ; } else { return list . sub list ( from index , to index ) ; } }
public final int get number of regex group ( ) { if ( group count . be empty ( ) ) { return 0 ; } else { int [ ] group index = get group index ( ) ; return group index [ group index . length - 1 ] + skip group ; } }
protect void set connection close force ( boolean b ) { if ( log . be debug enable ( ) ) { log . debug ( `` force-close connection : `` + b ) ; } this . connection close force = b ; }
public void ensure capacity ( int capacity ) { if ( point . length < capacity ) { int x = 2 * point . length ; if ( x < capacity ) x = capacity ; double [ ] [ ] p2 = new double [ x ] [ ] ; for ( int i = 0 ; i < size ; i++ ) p2 [ i ] = point [ i ] ; object [ ] t2 = new object [ x ] ; for ( int i = 0 ; i < size ; i++ ) t2 [ i ] = type [ i ] ; point = p2 ; type = t2 ; } }
public int get index ( string expression ) { if ( expression == null || expression . length ( ) == 0 ) { return -1 ; } for ( int i = 0 ; i < expression . length ( ) ; i++ ) { char c = expression . char at ( i ) ; if ( c == nest || c == mapped_start ) { return -1 ; } else if ( c == indexed_start ) { int end = expression . index of ( indexed_end , i ) ; if ( end < 0 ) { throw new illegal argument exception ( `` miss end delimiter `` ) ; } string value = expression . substring ( i + 1 , end ) ; if ( value . length ( ) == 0 ) { throw new illegal argument exception ( `` no index value `` ) ; } int index = 0 ; try { index = integer . parse int ( value , 10 ) ; } catch ( exception e ) { throw new illegal argument exception ( `` invalid index value ' `` + value + `` ' `` ) ; } return index ; } } return -1 ; }
public double of ( double [ ] d , int num param ) { return math . exp ( d [ 0 ] ) ; }
public double of ( double [ ] d , int num param ) { double a = math . sqrt ( ( d [ 0 ] + 1 ) / 2 ) ; double b = math . sqrt ( ( d [ 0 ] - 1 ) / 2 ) ; return 2 * math . log ( a + b ) ; }
public double of ( double [ ] d , int num param ) { if ( num param == 1 ) { return java . lang . math . log ( d [ 0 ] ) / java . lang . math . log ( 10 ) ; } return java . lang . math . log ( d [ 0 ] ) / java . lang . math . log ( d [ 1 ] ) ; }
public boolean accept num param ( int num param ) { return num param == 1 || num param == 2 ; }
public double of ( double [ ] d , int num param ) { return ( math . pow ( math . e , d [ 0 ] ) - math . pow ( math . e , -d [ 0 ] ) ) / 2 ; }
public double of ( double [ ] d , int num param ) { if ( num param == 1 ) { return java . lang . math . log ( d [ 0 ] ) / java . lang . math . log ( 10 ) ; } return java . lang . math . log ( d [ 0 ] ) / java . lang . math . log ( d [ 1 ] ) ; }
public double of ( double [ ] d , int num param ) { if ( num param == 1 ) { return java . lang . math . log ( d [ 0 ] ) / java . lang . math . log ( 10 ) ; } return java . lang . math . log ( d [ 0 ] ) / java . lang . math . log ( d [ 1 ] ) ; }
public string [ ] get variable name ( ) { string [ ] arr = new string [ num var ] ; for ( int i = 0 ; i < arr . length ; i++ ) arr [ i ] = name [ i ] ; return arr ; }
public string [ ] get variable name ( ) { string [ ] arr = new string [ num var ] ; for ( int i = 0 ; i < arr . length ; i++ ) arr [ i ] = name [ i ] ; return arr ; }
public void reset memory ( ) { if ( share data . a . length > 0 ) { share data . a = new int [ 0 ] ; share data . c = new int [ 0 ] ; } if ( share data . knot . length > 0 ) share data . knot = new double [ 0 ] ; }
public void trim array ( ) { if ( size < value . length ) { double [ ] arr = new double [ size ] ; for ( int i = 0 ; i < size ; i++ ) arr [ i ] = value [ i ] ; value = arr ; } }
public void navigate to ( class < ? extend view config > to view ) { this . to view = to view ; }
public boolean be passivation capable ( ) { return passivation capable ; }
public static class loader get context class loader ( ) { return access controller . do privilege ( new privilege action < class loader > ( ) { public class loader run ( ) { class loader cl = null ; try { cl = thread . current thread ( ) . get context class loader ( ) ; } catch ( security exception ex ) { } return cl ; } } ) ; }
public static project stage producer get instance ( ) { if ( project stage producer == null ) { lazy init ( ) ; } if ( project stage == null ) { project stage producer . init project stage ( ) ; } return project stage producer ; }
public static boolean be private ( member member ) { return modifier . be private ( member . get modifier ( ) ) ; }
public static boolean be all method static ( method . . . method ) { for ( method method : method ) { if ( ! modifier . be static ( method . get modifier ( ) ) ) { return false ; } } return true ; }
public collection list attribute description ( ) { list < string > list = new array list < string > ( ) ; try { m bean attribute info [ ] attrs = bean info . get attribute ( ) ; for ( m bean attribute info attr : attrs ) { list . add ( describe attribute ( attr ) ) ; } } catch ( exception e ) { throw exception ( `` could not list attribute description . reason : `` , e ) ; } return list ; }
public class parse class ( groovy code source code source , boolean should cache source ) throw compilation fail exception { class answer ; synchronize ( source cache ) { answer = source cache . get ( code source . get name ( ) ) ; if ( answer ! = null ) return answer ; if ( should cache source ) { answer = do parse class ( code source ) ; source cache . put ( code source . get name ( ) , answer ) ; } } if ( ! should cache source ) answer = do parse class ( code source ) ; return answer ; }
public void start element ( string uri , string local name , string q name , attribute atts ) throw s a x exception { process x m l catalog p i = false ; super . start element ( uri , local name , q name , atts ) ; }
public short compare document position ( node other ) throw d o m exception { d o m exception ex = new d o m exception ( d o m exception . not_supported_err , `` dom level 3 interface be not fully implement in jaxen 's namespace node class `` ) ; throw ex ; }
public string get element name ( object element ) { return get element name ( element , false ) ; }
public option set default value ( string default value ) { this . default value = default value ; if ( this . default value ! = null ) { set require ( false ) ; } return this ; }
public void set name ( string name ) { if ( this . can set field value ( this . name , name ) ) { this . name = name ; this . change ( ) ; } }
public void clear ( ) { match = `` `` ; body text . clear ( ) ; params . clear ( ) ; public id = null ; stack . clear ( ) ; stack by name . clear ( ) ; custom content handler = null ; }
public static document from string ( string name ) { document document = builder ( ) . new document ( ) ; document fragment fragment = create content ( document , name ) ; if ( fragment ! = null ) { document . append child ( fragment ) ; } else { document . append child ( document . create element ( name ) ) ; } return document ; }
public s a x parser factory get factory ( ) { if ( factory == null ) { factory = s a x parser factory . new instance ( ) ; factory . set namespace aware ( namespace aware ) ; factory . set validating ( validate ) ; } return ( factory ) ; }
public void internal entity decl ( string name , string value ) throw s a x exception { if ( internal d t dsubset ) { if ( include internal d t d declaration ) { add d t d declaration ( new internal entity decl ( name , value ) ) ; } } else { if ( include external d t d declaration ) { add external d t d declaration ( new internal entity decl ( name , value ) ) ; } } }
protect void add d t d declaration ( decl declaration ) { if ( internal d t d declaration == null ) { internal d t d declaration = new array list < decl > ( ) ; } internal d t d declaration . add ( declaration ) ; }
public document read ( reader reader ) throw document exception { input source source = new input source ( reader ) ; if ( this . encode ! = null ) { source . set encoding ( this . encode ) ; } return read ( source ) ; }
public void set encoding ( string encode ) { this . encode = encoding ; if ( output encode == null ) { output encode = encoding ; } }
protect s a x handler create content handler ( ) { s a x handler content handler = new s a x handler ( factory ) ; return content handler ; }
public void set priority ( double priority ) { this . priority = priority ; }
public x m l table definition get definition ( ) { return definition ; }
protect q name push q name ( string local name , string qualify name , namespace namespace , string prefix ) { if ( ( prefix == null ) || ( prefix . length ( ) == 0 ) ) { this . default namespace = null ; } return create q name ( local name , qualify name , namespace ) ; }
public static boolean start with whitespace ( final char sequence char seq ) { if ( char seq . length ( ) == 0 ) { return false ; } return character . be whitespace ( char seq . char at ( 0 ) ) ; }
public static void sort ( list < ? > list ) { if ( list . size ( ) > 1 ) { collection . sort ( list , instance ) ; } }
public static < t > factory < t > instantiate factory ( final class < t > class to instantiate , final class < ? > [ ] param type , final object [ ] args ) { return instantiate factory . instantiate factory ( class to instantiate , param type , args ) ; }
public class < t > [ ] to class array ( ) throw service configuration error { final list < class < t > > result = new array list < class < t > > ( ) ; final service iterator provider iterator provider = service iterator provider . get instance ( ) ; final iterator < class < t > > i = iterator provider . create class iterator ( service class , service name , class loader , ignore on class not find ) ; while ( i . have next ( ) ) { result . add ( i . next ( ) ) ; } return result . to array ( ( class < t > [ ] ) array . new instance ( class . class , result . size ( ) ) ) ; }
public address resolver option add server ( string server ) { if ( server == null ) { server = new array list < > ( ) ; } server . add ( server ) ; return this ; }
public ok http client set dns ( dns dns ) { this . dns = dns ; return this ; }
public autodiscover error code get error code ( ) { return this . error code ; }
public synchronize service port ( int port ) { if ( initialize ) { throw before route mapping exception ( ) ; } this . port = port ; return this ; }
protect get domain setting response create response instance ( ) { return new get domain setting response ( ) ; }
public void read to descendant ( xml namespace xml namespace , string local name ) throw x m l stream exception { read to descendant ( local name , ews utility . get namespace uri ( xml namespace ) ) ; }
protect void verify ( full http response response ) { final http response status status = http response status . switching_protocols ; final http header header = response . header ( ) ; if ( ! response . status ( ) . equal ( status ) ) { throw new web socket handshake exception ( `` invalid handshake response get status : `` + response . status ( ) ) ; } char sequence upgrade = header . get ( http header name . upgrade ) ; if ( ! http header value . websocket . content equal ignore case ( upgrade ) ) { throw new web socket handshake exception ( `` invalid handshake response upgrade : `` + upgrade ) ; } if ( ! header . contains value ( http header name . connection , http header value . upgrade , true ) ) { throw new web socket handshake exception ( `` invalid handshake response connection : `` + header . get ( http header name . connection ) ) ; } char sequence accept = header . get ( http header name . sec_websocket_accept ) ; if ( accept == null || ! accept . equal ( expect challenge response string ) ) { throw new web socket handshake exception ( string . format ( `` invalid challenge . actual : % s . expect : % s `` , accept , expect challenge response string ) ) ; } }
protect static enum get enum ( class enum class , int value ) { if ( enum class == null ) { throw new illegal argument exception ( `` the enum class must not be null `` ) ; } list list = enum . get enum list ( enum class ) ; for ( iterator it = list . iterator ( ) ; it . have next ( ) ; ) { value enum enumeration = ( value enum ) it . next ( ) ; if ( enumeration . get value ( ) == value ) { return enumeration ; } } return null ; }
public string read element value ( string namespace prefix , string local name ) throw exception { if ( ! this . be start element ( namespace prefix , local name ) ) { this . read start element ( namespace prefix , local name ) ; } string value = null ; if ( ! this . be empty element ( ) ) { value = this . read value ( ) ; } return value ; }
public void read start element ( string namespace prefix , string local name ) throw exception { this . internal read element ( namespace prefix , local name , new xml node type ( xml node type . start_element ) ) ; }
public void skip element ( string namespace prefix , string local name ) throw exception { if ( ! this . be end element ( namespace prefix , local name ) ) { if ( ! this . be start element ( namespace prefix , local name ) ) { this . read start element ( namespace prefix , local name ) ; } if ( ! this . be empty element ( ) ) { do { this . read ( ) ; } while ( ! this . be end element ( namespace prefix , local name ) ) ; } } }
public boolean be end element ( string namespace prefix , string local name ) { boolean be end element = false ; if ( this . present event . be end element ( ) ) { end element end element = this . present event . a end element ( ) ; q name q name = end element . get name ( ) ; be end element = q name . get local part ( ) . equal ( local name ) & & q name . get prefix ( ) . equal ( namespace prefix ) ; } return be end element ; }
public t response execute ( ) throw exception { t response service response = internal execute ( ) ; service response . throw if necessary ( ) ; return service response ; }
public int get minor version ( ) { return minor ; }
public static boolean be at least major minor ( string version , int major version , int minor version ) { semantic version semantic version = new semantic version ( version ) ; return be at least major minor impl ( semantic version , major version , minor version ) ; }
public int get major build number ( ) { return major build number ; }
public get event result end get event ( i async result async result ) throw exception { get event request request = async request result . extract service request ( this , async result ) ; return request . end execute ( async result ) . get response at index ( 0 ) . get result ( ) ; }
public email address collection get room list ( ) throw exception { get room list request request = new get room list request ( this ) ; return request . execute ( ) . get room list ( ) ; }
public boolean be trace enable for ( trace flag trace flag ) { return this . be trace enable ( ) & & this . trace flag . contains ( trace flag ) ; }
public web proxy get web proxy ( ) { return this . web proxy ; }
public void validate ( ) throw exception { for ( property definition property definition : this . added property ) { this . validate property value ( property definition ) ; } for ( property definition property definition : this . modified property ) { this . validate property value ( property definition ) ; } }
public void clear change log ( ) { this . deleted property . clear ( ) ; this . modified property . clear ( ) ; this . added property . clear ( ) ; iterator < entry < property definition , object > > it = this . property . entry set ( ) . iterator ( ) ; while ( it . have next ( ) ) { entry < property definition , object > key value pair = it . next ( ) ; if ( key value pair . get value ( ) instanceof complex property ) { complex property complex property = ( complex property ) key value pair . get value ( ) ; complex property . clear change log ( ) ; } } this . be dirty = false ; }
public base property set get base property set ( ) { return this . base property set ; }
public delegate user get delegate user ( ) { return this . delegate user ; }
protect string get collection item xml element name ( folder id complex property ) { return complex property . get xml element name ( ) ; }
public folder id get parent folder id ( ) { return parent folder id ; }
protect void set parent folder id ( folder id parent folder id ) { this . parent folder id = parent folder id ; }
public void set identifier ( string email address ) { this . email address = email address ; }
public folder id get parent folder id ( ) { return this . parent folder id ; }
public final query exception wrap with query string ( string query string ) { if ( this . get query string ( ) ! = null ) { return this ; } return generate query exception ( query string ) ; }
public boolean get include permission ( ) { return this . include permission ; }
public property set get property set or default ( ) { if ( this . get property set ( ) == null ) { return property set . get first class property ( ) ; } else { return this . get property set ( ) ; } }
protect boolean be exclude ( string class name ) { synchronize ( this . exclusion monitor ) { if ( this . excluded class . contains ( class name ) ) { return true ; } for ( string package name : this . exclude package ) { if ( class name . start with ( package name ) ) { return true ; } } } return false ; }
public void buffer entity ( ) throw client handler exception { if ( be entity buffer ) return ; byte array output stream baos = new byte array output stream ( ) ; try { reader writer . write to ( entity , baos ) ; } catch ( i o exception ex ) { throw new client handler exception ( ex ) ; } finally { close ( ) ; } entity = new byte array input stream ( baos . to byte array ( ) ) ; be entity buffered = true ; }
public string get response text ( ) throw e w s http exception { throw if response be null ( ) ; return response . get status line ( ) . get reason phrase ( ) ; }
public void set pre authenticate ( boolean pre authenticate ) { this . pre authenticate = pre authenticate ; }
public static response request ( method method ) { return give ( ) . request ( method ) ; }
protect void add ( item id item id ) { this . item id . add ( new item id wrapper ( item id ) ) ; }
public name resolution collection resolve name ( string name to resolve ) throw exception { return this . resolve name ( name to resolve , resolve name search location . contact then directory , false ) ; }
public void set oof setting ( oof setting oof setting ) { this . oof setting = oof setting ; }
public folder id get sync folder id ( ) { return this . sync folder id ; }
protect string getmailbox smtp address ( ) { return this . mailbox smtp address ; }
public conflict resolution mode get conflict resolution mode ( ) { return this . conflict resolution mode ; }
public void set oof setting ( oof setting oof setting ) { this . oof setting = oof setting ; }
public void throw if necessary ( ) throw service response exception { this . internal throw if necessary ( ) ; }
public void throw if necessary ( ) throw service response exception { this . internal throw if necessary ( ) ; }
public set < change file > get change set ( ) { return this . change set ; }
public void update ( ) throw exception { if ( this . be new ) { throw new invalid operation exception ( `` this user configuration ca n't be update because it 's never be save . `` ) ; } if ( this . be property updated ( user configuration property . binary data ) || this . be property updated ( user configuration property . dictionary ) || this . be property updated ( user configuration property . xml data ) ) { this . service . update user configuration ( this ) ; } this . reset be dirty ( ) ; }
public folder id get parent folder id ( ) throw service local exception { return get property bag ( ) . get object from property definition ( item schema . parent folder id ) ; }
protect send invitation mode get default send invitation mode ( ) { return send invitation mode . send to all and save copy ; }
public calendar action result accept ( boolean send response ) throw exception { return this . internal accept ( false , send response ) ; }
public time zone definition get end time zone ( ) throw service local exception { return get property bag ( ) . get object from property definition ( appointment schema . end time zone ) ; }
public boolean get be meet ( ) throw service local exception { return get property bag ( ) . get object from property definition ( appointment schema . be meet ) ; }
public email address get from ( ) throw service local exception { return get property bag ( ) . get object from property definition ( email message schema . from ) ; }
public attendee collection get require attendee ( ) throw service local exception { return get property bag ( ) . get object from property definition ( appointment schema . require attendee ) ; }
public void set start time zone ( time zone definition value ) throw exception { this . get property bag ( ) . set object from property definition ( appointment schema . start time zone , value ) ; }
public file attachment get contact picture attachment ( ) throw service local exception { ews utility . validate method version ( this . get service ( ) , exchange version . exchange2010 , `` get contact picture attachment `` ) ; if ( ! this . get property bag ( ) . be property loaded ( contact schema . attachment ) ) { throw new property exception ( `` the attachment collection must be load . `` ) ; } for ( attachment file attachment : this . get attachment ( ) ) { if ( file attachment instanceof file attachment ) { if ( ( ( file attachment ) file attachment ) . be contact photo ( ) ) { return ( file attachment ) file attachment ; } } } return null ; }
public string get display name ( ) throw service local exception { return get property bag ( ) . get object from property definition ( folder schema . display name ) ; }
public string get company name ( ) throw service local exception { return get property bag ( ) . get object from property definition ( contact schema . company name ) ; }
public email address get from ( ) throw service local exception { return get property bag ( ) . get object from property definition ( email message schema . from ) ; }
public void set contact ( string list value ) throw exception { this . get property bag ( ) . set object from property definition ( task schema . contact , value ) ; }
public void set job title ( string value ) throw exception { this . get property bag ( ) . set object from property definition ( contact schema . job title , value ) ; }
public void set contact ( string list value ) throw exception { this . get property bag ( ) . set object from property definition ( task schema . contact , value ) ; }
public string get spouse name ( ) throw service local exception { return get property bag ( ) . get object from property definition ( contact schema . spouse name ) ; }
public string list get contact ( ) throw service local exception { return get property bag ( ) . get object from property definition ( task schema . contact ) ; }
public string list get contact ( ) throw service local exception { return get property bag ( ) . get object from property definition ( task schema . contact ) ; }
public string list get global unique recipient ( ) throw exception { return get property bag ( ) . get object from property definition ( conversation schema . global unique recipient ) ; }
public boolean get have attachment ( ) throw service local exception { return get property bag ( ) . < boolean > get object from property definition ( conversation schema . have attachment ) ; }
public email address collection get cc recipient ( ) throw exception { return ( email address collection ) this . get object from property definition ( email message schema . cc recipient ) ; }
public string get conversation topic ( ) throw service local exception { return get property bag ( ) . get object from property definition ( email message schema . conversation topic ) ; }
public void set sender ( email address value ) throw exception { this . get property bag ( ) . set object from property definition ( email message schema . sender , value ) ; }
public void set be delivery receipt request ( boolean value ) throw exception { this . get property bag ( ) . set object from property definition ( email message schema . be delivery receipt request , value ) ; }
public boolean get be from me ( ) throw service local exception { return get property bag ( ) . < boolean > get object from property definition ( item schema . be from me ) ; }
public string get item class ( ) throw service local exception { return get property bag ( ) . get object from property definition ( item schema . item class ) ; }
public date get start ( ) throw service local exception { return get property bag ( ) . get object from property definition ( appointment schema . start ) ; }
public date get date time create ( ) throw service local exception { return get property bag ( ) . get object from property definition ( item schema . date time create ) ; }
public integer get total work ( ) throw service local exception { return get property bag ( ) . get object from property definition ( task schema . total work ) ; }
protect calendar action result internal accept ( boolean tentative , boolean send response ) throw exception { accept meeting invitation message accept = this . create accept message ( tentative ) ; if ( send response ) { return accept . calendar send and save copy ( ) ; } else { return accept . calendar save ( ) ; } }
public message body get body prefix ( ) throw exception { return ( message body ) this . get object from property definition ( response object schema . body prefix ) ; }
public static email message schema get instance ( ) { return instance ; }
protect void register internal property ( property definition property ) { this . register property ( property , true ) ; }
protect void add on change event ( i create service object with attachment param change ) { on change list . add ( change ) ; }
protected list < t complex property > get added item ( ) { return this . added item ; }
public boolean contains ( t key key ) { return this . entry . contains key ( key ) ; }
public boolean try get value ( object key , out param < object > value ) { if ( this . dictionary . contains key ( key ) ) { value . set param ( this . dictionary . get ( key ) ) ; return true ; } else { value . set param ( null ) ; return false ; } }
public synchronize string get host ( ) { if ( this . host ! = null ) { return this . host . get host name ( ) ; } else { return null ; } }
protect void set ew url ( uri value ) { ews url = value ; }
public void set bcc list ( string list ) { string tokenizer token = new string tokenizer ( list , `` , `` ) ; while ( token . have more token ( ) ) { bcc list . add element ( new email address ( token . next token ( ) ) ) ; } }
public folder get folder ( ) { return folder ; }
public item type get item type ( type hierarchy th ) { if ( item type == null ) { return super . get item type ( th ) ; } return item type ; }
public iterable < attendee info > get attendee ( ) { return attendee ; }
public void set attendee type ( meet attendee type attendee type ) { this . attendee type = attendee type ; }
public void set maximum suggestion per day ( int value ) { if ( value < 0 || value > 48 ) { throw new illegal argument exception ( string . format ( `` % s , % s , % s , % s `` , `` % s must be between % d and % d . `` , `` maximum suggestion per day `` , 0 , 48 ) ) ; } this . maximum suggestion per day = value ; }
public void set maximum non work hour suggestion per day ( int value ) { if ( value < 0 || value > 48 ) { throw new illegal argument exception ( string . format ( `` % s must be between % d and % d . `` , `` maximum non work hour suggestion per day `` , 0 , 48 ) ) ; } this . maximum non work hour suggestion per day = value ; }
public void set merge free busy interval ( int value ) { if ( value < 5 || value > 1440 ) { throw new illegal argument exception ( string . format ( `` % s , % s , % s , % s `` , `` % s must be between % d and % d . `` , `` merge free busy interval `` , 5 , 1440 ) ) ; } this . merge free busy interval = value ; }
public time window get detailed suggestion window ( ) { return this . detailed suggestion window ; }
public suggestion response get suggestion response ( ) { return this . suggestion response ; }
protect void set delta ( time span delta ) { this . delta = delta ; }
protect void set month ( int month ) { this . month = month ; }
public oof reply get external reply ( ) { return external reply ; }
public date time get end ( ) { return new date time ( get end millis ( ) , get chronology ( ) ) ; }
public static meeting cancellation bind ( exchange service service , item id id ) { return meeting cancellation . bind ( service , id , property set . get first class property ( ) ) ; }
public void set action ( conversation action type value ) { this . action = value ; }
public void set category property ( string category ) { this . category = set string value ( category ) ; }
public void set unique id ( string unique id ) { this . unique id = unique id ; }
public string get phone number ( phone number key key ) { phone number entry phone number entry = this . get entry ( ) . get ( key ) ; if ( phone number entry == null ) { return null ; } return phone number entry . get phone number ( ) ; }
public email address get manager mailbox ( ) throw service local exception { return get property bag ( ) . get object from property definition ( contact schema . manager mailbox ) ; }
public contact get contact ( ) { return contact ; }
protect void init fault sub code ( ) { if ( fault sub code == null ) { fault sub code = new vector ( ) ; } }
public void set fault code ( string fault code ) throw s o a p exception { fault . set fault code a string ( fault code ) ; }
protect void set fault actor ( string fault actor ) { this . fault actor = fault actor ; }
public int line number ( int position ) { int line number = get line number ( position ) ; return line number < 1 ? 1 : line number ; }
public object get property ( string name ) { if ( `` name `` . equal ( name ) ) { return function name . get display name ( ) ; } else if ( `` a `` . equal ( name ) ) { return result type . to string ( ) ; } else { return null ; } }
public void unsubscribe ( ) throw exception { get service ( ) . unsubscribe ( get id ( ) ) ; }
public throwable get exception ( ) { if ( this . nest core exception == null ) { return get status ( ) . get exception ( ) ; } else { return this . nest core exception ; } }
public request spec builder set content type ( string content type ) { spec . content type ( content type ) ; return this ; }
public boolean get be inline ( ) throw service version exception { ews utility . validate property version ( this . get owner ( ) . get service ( ) , exchange version . exchange2010 , `` be inline `` ) ; return this . be inline ; }
public void clear ( ) { relationship by i d . clear ( ) ; relationship by type . clear ( ) ; internal relationship by target name . clear ( ) ; }
public void clear ( ) { relationship by i d . clear ( ) ; relationship by type . clear ( ) ; internal relationship by target name . clear ( ) ; }
public day of the week get day of the week ( ) { return day of the week ; }
public long start time ( ) { return start time ; }
protected list < t complex property > get added item ( ) { return this . added item ; }
protect void remove from change log ( t complex property complex property ) { this . remove item . remove ( complex property ) ; this . modified item . remove ( complex property ) ; this . added item . remove ( complex property ) ; }
public void set inbox folder permission level ( delegate folder permission level value ) { this . delegate folder permission . get ( xml element name . inbox folder permission level ) . set permission level ( value ) ; }
public boolean get receive copy of meeting message ( ) { return this . receive copy of meeting message ; }
public static string clean ( string charset name ) { try { return for name ( charset name ) . name ( ) ; } catch ( exception e ) { return null ; } }
public void set primary smtp address ( string primary smtp address ) { if ( this . can set field value ( this . primary smtp address , primary smtp address ) ) { this . primary smtp address = primary smtp address ; this . change ( ) ; } }
public mailbox type get mailbox type ( ) { return mailbox type ; }
public address resolver option add search domain ( string search domain ) { if ( search domains == null ) { search domains = new array list < > ( ) ; } search domain . add ( search domain ) ; return this ; }
public boolean remove extend property ( extended property definition property definition ) throw exception { ews utility . validate param ( property definition , `` property definition `` ) ; extend property extend property = null ; out param < extend property > extend property out = new out param < extend property > ( ) ; if ( this . try get property ( property definition , extend property out ) ) { extended property = extend property out . get param ( ) ; return this . internal remove ( extended property ) ; } else { return false ; } }
protect void set content stream ( input stream content stream ) { this . throw if this be not new ( ) ; this . content stream = content stream ; this . content = null ; this . file name = null ; }
public void set mailbox ( mailbox mailbox ) { this . mailbox = mailbox ; }
public void set be folder owner ( boolean value ) { if ( this . can set field value ( this . be folder owner , value ) ) { this . be folder owner = value ; this . change ( ) ; } this . adjust permission level ( ) ; }
public void change ( ) { for ( i service object change delegate change : this . on change ) { change . service object change ( this ) ; } }
public string get business home page ( ) throw service local exception { return get property bag ( ) . get object from property definition ( contact schema . business home page ) ; }
public object get property ( string name ) { if ( `` name `` . equal ( name ) ) { return function name . get display name ( ) ; } else if ( `` a `` . equal ( name ) ) { return result type . to string ( ) ; } else { return null ; } }
public void set daylight ( time change value ) { if ( this . can set field value ( this . daylight , value ) ) { this . daylight = value ; this . change ( ) ; } }
public string get state ( ) throw exception { return ( string ) this . property bag . get simple property bag ( physical address schema . state ) ; }
public string get country or region ( ) throw exception { return ( string ) this . property bag . get simple property bag ( physical address schema . country or region ) ; }
public < t folder extend folder > t folder bind to folder ( class < t folder > cl , folder id folder id , property set property set ) throw exception { folder result = this . bind to folder ( folder id , property set ) ; if ( cl . be assignable from ( result . get class ( ) ) ) { return ( t folder ) result ; } else { throw new service local exception ( string . format ( `` the folder type return by the service ( % s ) be n't compatible with the request folder type ( % s ) . `` , result . get class ( ) . get name ( ) , cl . get name ( ) ) ) ; } }
public void set end date ( date value ) { if ( this . can set field value ( this . end date , value ) ) { this . end date = value ; this . change ( ) ; } this . number of occurrence = null ; }
public void set end date ( date value ) { if ( this . can set field value ( this . end date , value ) ) { this . end date = value ; this . change ( ) ; } this . number of occurrence = null ; }
public boolean be support ( ) { return i field . be support ( ) ; }
public boolean get permanent delete ( ) { return this . permanent delete ; }
public response message create reply ( boolean reply all ) throw exception { this . throw if this be new ( ) ; return new response message ( this , reply all ? response message type . reply all : response message type . reply ) ; }
protect iterable < rule operation > get inbox rule operation ( ) { return this . inbox rule operation ; }
public date time value get current date time ( ) { if ( current date time==null ) { current date time = new date time value ( new gregorian calendar ( ) , true ) ; } return current date time ; }
public static void set date time context ( date time context date time context ) { if ( date time context == null ) { reset date time context ( ) ; } else { date time context holder . set ( date time context ) ; } }
protect boolean be standard period ( ) { return this . name . equal ( time zone period . standard period name ) ; }
public date get absolute date ( ) { return absolute date ; }
public static string get string from message body ( message body message body ) throw exception { ews utility . validate param ( message body , `` message body `` ) ; return message body . text ; }
public void set body type ( body type body type ) { if ( this . can set field value ( this . body type , body type ) ) { this . body type = body type ; this . change ( ) ; } }
public node stats request index ( boolean index ) { if ( index ) { this . index . all ( ) ; } else { this . index . clear ( ) ; } return this ; }
public static boolean be nullable ( class type ) { if ( type . be primitive ( ) ) { return false ; } else { return true ; } }
public uri uri ( ) { return uri ; }
public void set more change available ( boolean more change available ) { this . more change available = more change available ; }
public void set change type ( change type change type ) { this . change type = change type ; }
public void set service object ( service object service object ) { this . service object = service object ; }
@ override public service id create id ( ) { return new item id ( ) ; }
public date read element value a date time ( ) throw exception { return date time utils . convert date time string to date ( read element value ( ) ) ; }
public cascade style get pseudo element style ( node node , string pseudo element ) { element e = null ; if ( node . get node type ( ) == node . element_node ) { e = ( element ) node ; } else { e = ( element ) node . get parent node ( ) ; } return _matcher . get p e cascade style ( e , pseudo element ) ; }
public static list < medium type > a medium type ( list < mime type > mime type ) { list < medium type > medium type = new array list < > ( mime type . size ( ) ) ; for ( mime type mime type : mime type ) { medium type . add ( medium type . a medium type ( mime type ) ) ; } return medium type ; }
public int get origin y ( int gid ) { if ( origin . contains key ( gid ) ) { return origin . get ( gid ) ; } else { return default vert origin y ; } }
public string get title ( ) { if ( title ! = null ) { return title . get value ( ) ; } return null ; }
public share context get share context ( ) { return panel . get share context ( ) ; }
public void add option panel ( option panel panel ) { main_tabbed pane . add ( panel , main_tabbed pane . get component count ( ) -1 ) ; try { panel . load option ( ) ; } catch ( i o exception e ) { message msg = new message ( `` could not load option . `` , i message . error , e , null ) ; ajde . get default ( ) . get message handler ( ) . handle message ( msg ) ; } }
public void clear image cache ( ) { _image resource loader . clear ( ) ; }
public boolean be hover ( object e ) { return ui . be hover ( ( element ) e ) ; }
public synchronize image load item get task ( ) throw interrupted exception { while ( _load queue . be empty ( ) ) { wait ( ) ; } if ( _load queue . get last ( ) == kill_switch ) { x r log . general ( level . fine , `` thread `` + thread . current thread ( ) . get name ( ) + `` requested item , but queue be shut down ; return kill switch . `` ) ; return kill_switch ; } else { image load item item = ( image load item ) _load queue . remove last ( ) ; x r log . general ( level . fine , `` thread `` + thread . current thread ( ) . get name ( ) + `` pulled item `` + item . _uri + `` from queue , `` + ( _load queue . size ( ) - 1 ) + `` remain `` ) ; return item ; } }
public void add listener ( f s mouse listener l ) { if ( l == null ) { return ; } if ( ! _handlers . contains key ( l ) ) { _handlers . put ( l , l ) ; } if ( ! _enabled & & _handlers . size ( ) > 0 ) { _panel . add mouse listener ( this ) ; _panel . add mouse motion listener ( this ) ; _enabled = true ; } }
public void scroll to ( point pt ) { if ( this . enclose scroll pane ! = null ) { this . enclose scroll pane . get vertical scroll bar ( ) . set value ( pt . y ) ; } }
public static int value a short ( string key , short default val ) { string val = value for ( key ) ; if ( val == null ) { return default val ; } short sval ; try { sval = short . value of ( val ) . short value ( ) ; } catch ( number format exception nex ) { x r log . exception ( `` property ' `` + key + `` ' be request a a short , but `` + `` value of ' `` + val + `` ' be not a short . check configuration . `` ) ; sval = default val ; } return sval ; }
public void print annotation ( ) { system . out . println ( `` annotation : `` ) ; for ( map . entry < dot name , list < annotation instance > > e : annotation . entry set ( ) ) { system . out . println ( e . get key ( ) + `` : `` ) ; for ( annotation instance instance : e . get value ( ) ) { annotation target target = instance . target ( ) ; if ( target instanceof class info ) { system . out . println ( `` class : `` + target ) ; } else if ( target instanceof field info ) { system . out . println ( `` field : `` + target ) ; } else if ( target instanceof method info ) { system . out . println ( `` method : `` + target ) ; } else if ( target instanceof method parameter info ) { system . out . println ( `` parameter : `` + target ) ; } list < annotation value > value = instance . value ( ) ; if ( value . size ( ) < 1 ) continue ; string builder builder = new string builder ( `` ( `` ) ; for ( int i = 0 ; i < value . size ( ) ; i ++ ) { builder . append ( value . get ( i ) ) ; if ( i < value . size ( ) - 1 ) builder . append ( `` , `` ) ; } builder . append ( ' ) ' ) ; system . out . println ( builder . to string ( ) ) ; } } }
public static image writer get image writer by medium type ( medium type medium type ) { iterator < image writer > writer = image i o . get image writer by m i m e type ( medium type . to string ( ) ) ; image writer writer = writer . next ( ) ; if ( writer == null ) { response response = response . server error ( ) . entity ( `` `` ) . build ( ) ; throw new web application exception ( response ) ; } return writer ; }
public static void clear image ( buffer image image , color bg color ) { graphics2 d g2d = ( graphics2 d ) image . get graphic ( ) ; g2d . set color ( bg color ) ; g2d . fill rect ( 0 , 0 , image . get width ( ) , image . get height ( ) ) ; g2d . dispose ( ) ; }
public static buffer image render to image ( string url , int width , int height , int buffer image type ) { graphics2 d renderer g2r = new graphics2 d renderer ( ) ; g2r . set document ( url ) ; dimension dim = new dimension ( width , height ) ; buffer image buff = new buffer image ( ( int ) dim . get width ( ) , ( int ) dim . get height ( ) , buffer image type ) ; graphics2 d g = ( graphics2 d ) buff . get graphic ( ) ; g2r . layout ( g , dim ) ; g2r . render ( g ) ; g . dispose ( ) ; return buff ; }
public string format error ( final log record record ) { return format message ( record . get thrown ( ) ) ; }
public string get head ( handler h ) { return super . get head ( h ) ; }
public node info request add metric ( string . . . metric ) { sort set < string > metric set = new tree set < > ( arrays . a list ( metric ) ) ; if ( metric . all metric ( ) . contain all ( metric set ) == false ) { metric set . remove all ( metric . all metric ( ) ) ; string plural = metric set . size ( ) == 1 ? `` `` : `` s `` ; throw new illegal state exception ( `` use illegal metric `` + plural + `` : `` + metric set ) ; } request metric . add all ( metric set ) ; return this ; }
public true type font get font by name ( string name ) throw i o exception { for ( int i = 0 ; i < num font ; i++ ) { true type font font = get font at index ( i ) ; if ( font . get name ( ) . equal ( name ) ) { return font ; } } return null ; }
public string get full method name ( ) { return full method name ; }
public void set mapping scheme ( int mapping scheme value ) { map scheme = mapping scheme value ; }
public string get character set ( ) { return this . character set ; }
public iterator iterator ( ) { vector v = new java . util . vector ( ) ; enumeration en = cache . property name ( ) ; while ( en . have more element ( ) ) { v . add ( en . next element ( ) ) ; } return v . iterator ( ) ; }
public void set knot vector ( value vector v ) { if ( v == null ) throw new illegal argument exception ( `` knot-vector can not be null . `` ) ; knot vector = v ; }
public void set x height ( float x height value ) { x height = x height value ; }
public void set italic angle ( float italic angle value ) { italic angle = italic angle value ; }
public void set char width ( float [ ] char width value ) { char width = char width value ; }
public list < track kern > get track kern ( ) { return collection . unmodifiable list ( track kern ) ; }
public list < track kern > get track kern ( ) { return collection . unmodifiable list ( track kern ) ; }
public void set composite ( list < composite > composite list ) { composite = composite list ; }
public float get standard horizontal width ( ) { return standard horizontal width ; }
public void set max kern ( float max kern value ) { max kern = max kern value ; }
public void set max point size ( float max point size value ) { max point size = max point size value ; }
public static synchronize registry get registry ( object key , object guard ) { if ( registry == null ) { if ( jre compat . be graal available ( ) ) { disable registry ( ) ; } else { registry = new registry ( ) ; } } if ( registry . guard ! = null & & registry . guard ! = guard ) { return null ; } return registry ; }
public static string get operator ( int b0 ) { return key map . get ( calculate key ( b0 ) ) ; }
public static void update checksum ( crc32 checksum , byte buffer buffer ) { int position = buffer . position ( ) ; checksum . update ( buffer ) ; buffer . position ( position ) ; }
public int peek unsigned byte ( int offset ) throw i o exception { int b = peek ( offset ) ; if ( b < 0 ) { throw new e o f exception ( ) ; } return b ; }
public int read int ( ) throw i o exception { int b1 = read ( ) ; int b2 = read ( ) ; int b3 = read ( ) ; int b4 = read ( ) ; if ( ( b1 | b2 | b3 | b4 ) < 0 ) { throw new e o f exception ( ) ; } return b1 < < 24 | b2 < < 16 | b3 < < 8 | b4 ; }
public void write ( byte [ ] buffer , int offset , int length ) { output buffer . write ( buffer , offset , length ) ; }
public list < object > get type1 sequence ( ) { return type1 sequence ; }
public string get name ( ) { return cmap name ; }
public void set system id ( string url ) { system id = url ; builder . set system id ( url ) ; super . set document locator ( new locator ( ) { public int get column number ( ) { return -1 ; } public int get line number ( ) { return -1 ; } public string get public id ( ) { return null ; } public string get system id ( ) { return system id ; } } ) ; }
public string get name ( int code ) { string name = code to name . get ( code ) ; if ( name ! = null ) { return name ; } return `` . notdef `` ; }
public int scale x ( int x , int y ) { return math . round ( ( float ) ( x * xscale + y * scale10 ) ) ; }
public int scale x ( int x , int y ) { return math . round ( ( float ) ( x * xscale + y * scale10 ) ) ; }
public str builder append separator ( char standard , char default if empty ) { if ( size ( ) > 0 ) { append ( standard ) ; } else { append ( default if empty ) ; } return this ; }
public boolean be post script ( ) { return table . contains key ( c f f table . tag ) ; }
public header table get header ( ) throw i o exception { return ( header table ) get table ( header table . tag ) ; }
public vertical metric table get vertical metric ( ) throw i o exception { return ( vertical metric table ) get table ( vertical metric table . tag ) ; }
public string read tag ( ) throw i o exception { return new string ( read ( 4 ) , charsets . us_ascii ) ; }
public int read sign int ( ) throw i o exception { int ch1 = read ( ) ; int ch2 = read ( ) ; int ch3 = read ( ) ; int ch4 = read ( ) ; if ( ( ch1 | ch2 | ch3 | ch4 ) < 0 ) { throw new e o f exception ( ) ; } return ( ( ch1 < < 24 ) + ( ch2 < < 16 ) + ( ch3 < < 8 ) + ( ch4 < < 0 ) ) ; }
public list < parser notice > get parser notice ( ) { list < parser notice > notice = new array list < parser notice > ( ) ; if ( notice highlight pair ! =null ) { for ( notice highlight pair pair : notice highlight pair ) { notice . add ( pair . notice ) ; } } return notice ; }
public void set family name ( string family name value ) { family name = family name value ; }
public static type1 font create with segment ( byte [ ] segment1 , byte [ ] segment2 ) throw i o exception { type1 parser parser = new type1 parser ( ) ; return parser . parse ( segment1 , segment2 ) ; }
public static boolean be mandatory ( final interface itf ) { if ( itf instanceof type interface ) { type interface t itf = ( type interface ) itf ; return t itf . get contingency ( ) == null || type interface . mandatory_contingency . equal ( t itf . get contingency ( ) ) ; } return false ; }
public static boolean be singleton ( final interface itf ) { if ( itf instanceof type interface ) { type interface t itf = ( type interface ) itf ; return t itf . get cardinality ( ) == null || type interface . singleton_cardinality . equal ( t itf . get cardinality ( ) ) ; } return false ; }
public void warn ( object message ) { log ( level . warning , string . value of ( message ) , null ) ; }
public boolean be warn enabled ( ) { return logger . be enable for ( level . warn ) ; }
protect void index by type ( ) { if ( annots by type ! = null ) return ; annots by type = new hash map < string , annotation set > ( gate . hash_sth_size ) ; iterator < annotation > annot iter = annots by id . value ( ) . iterator ( ) ; while ( annot iter . have next ( ) ) add to type index ( annot iter . next ( ) ) ; } // index by type ( )
public void add annotation ( int start offset , int end offset , string type , feature map feature ) { stack row . get ( stack row . size ( ) -1 ) . add annotation ( stack annotation . create annotation ( start offset , end offset , type , feature ) ) ; }
public void fatal error ( s a x parse exception ex ) throw s a x exception { _seh . fatal error ( ex ) ; } // fatal error
public void unload document ( int index ) { unload document ( index , true ) ; }
public boolean be persistent document ( int index ) { if ( document == null || document . be empty ( ) ) return false ; return ( doc data list . get ( index ) . get persistent i d ( ) ! = null ) ; }
public void remove annotation set ( string name ) { if ( name annot set ! = null ) { annotation set remove = name annot set . remove ( name ) ; if ( remove ! = null ) { fire annotation set remove ( new document event ( this , document event . annotation_set_removed , name ) ) ; } } }
public static annotation set get coextensive annotation ( annotation set source , annotation set coext set ) { return get coextensive annotation worker ( source , null , start ( coext set ) , end ( coext set ) ) ; }
public void set rout type ( string rout type ) { if ( this . can set field value ( this . rout type , rout type ) ) { this . rout type = rout type ; this . change ( ) ; } }
public string subtype ( ) { return subtype ; }
public boolean have parameter annotation ( final string annotation name ) { for ( final method parameter info method parameter info : get parameter info ( ) ) { if ( method parameter info . have annotation ( annotation name ) ) { return true ; } } return false ; }
public void set document persistent i d ( int index , object pers i d ) { if ( index > = doc data list . size ( ) ) return ; doc data list . get ( index ) . set persistent i d ( pers i d ) ; if ( debug ) out . prln ( `` i d be now : `` + doc data list ) ; }
static public document format get document format ( gate . document a gate document , url url ) { return get document format ( a gate document , get mime type ( url ) ) ; } // get document format ( url )
public void execute ( ) throw build exception { log ( `` deprecate - the `` + get task name ( ) + `` task be deprecate . `` + `` use the mail task instead . `` ) ; super . execute ( ) ; }
public void set l r persistence id ( object lr i d ) { this . lr persistent id = lr i d ; }
public void cleanup ( ) { f document scanner . cleanup ( f close stream ) ; } // cleanup ( )
public feature map get feature ( ) { if ( feature == null ) { feature = new simple feature map impl ( ) ; } return feature ; }
public void set feature ( feature map feature ) { this . feature = feature ; }
protect void assert target bean ( method method , object target bean , object [ ] args ) { class < ? > method declare class = method . get declare class ( ) ; class < ? > target bean class = target bean . get class ( ) ; if ( ! method declare class . be assignable from ( target bean class ) ) { string text = `` the mapped handler method class ' `` + method declare class . get name ( ) + `` ' be not an instance of the actual controller bean class ' `` + target bean class . get name ( ) + `` ' . if the controller require proxying `` + `` ( e . g . due to @ transactional ) , please use class-based proxying . `` ; throw new illegal state exception ( format invoke error ( text , args ) ) ; } }
public void set receipt handle ( string receipt handle ) { this . receipt handle = receipt handle ; }
public void set max non competitive boost ( float boost ) { this . max boost att . set max non competitive boost ( boost ) ; }
public boolean be store ( ) { return be store ; }
public directory get directory ( ) { return directory ; }
public string get description ( ) { if ( description == null ) { description = description . get description ( this ) ; } return description ; }
public static list < integer > convert integer c o s array to list ( c o s array int array ) { list < integer > retval = null ; if ( int array ! = null ) { list < integer > number = new array list < integer > ( ) ; for ( int i = 0 ; i < int array . size ( ) ; i++ ) { c o s number num ; if ( int array . get ( i ) instanceof c o s object ) { num = ( c o s number ) ( ( c o s object ) int array . get ( i ) ) . get object ( ) ; } else { num = ( c o s number ) int array . get ( i ) ; } number . add ( num . int value ( ) ) ; } retval = new c o s array list < integer > ( number , int array ) ; } return retval ; }
public weight create weight ( index searcher searcher ) throw i o exception { return new disjunction max weight ( searcher ) ; }
public final query rewrite ( index reader reader ) throw i o exception { return rewrite method . rewrite ( reader , this ) ; }
public final synchronize void close ( ) throw i o exception { commit ( ) ; do close ( ) ; if ( close directory ) directory . close ( ) ; }
public index output create output ( string name , i o context context ) throw i o exception { ensure open ( ) ; r a m file file = new r a m file ( ) ; r a m file exist = file map . remove ( name ) ; if ( exist ! = null ) { size in byte . add and get ( -existing . size in byte ) ; exist . directory = null ; } file map . put ( name , file ) ; return new r a m output stream ( file ) ; }
public void insert ( final t element ) { if ( element ! = null ) { if ( top == null ) { top = new node ( element , null ) ; } else { top . insert ( element ) ; } } }
public integer actual maximum size ( ) { final int core size = core size ( ) . get ( ) ; final int maximum size = maximum size ( ) . get ( ) ; if ( get allow maximum size to diverge from core size ( ) . get ( ) ) { if ( core size > maximum size ) { return core size ; } else { return maximum size ; } } else { return core size ; } }
public gate . annotation get annotation ( ) { return annotation ; }
public void replace ( string statement ) throw can not compile exception { throw new runtime exception ( `` not implement yet `` ) ; }
public final query exception wrap with query string ( string query string ) { if ( this . get query string ( ) ! = null ) { return this ; } return generate query exception ( query string ) ; }
public void set rout type ( string rout type ) { if ( this . can set field value ( this . rout type , rout type ) ) { this . rout type = rout type ; this . change ( ) ; } }
public void set text ( string text ) { if ( this . can set field value ( this . text , text ) ) { this . text = text ; this . change ( ) ; } }
public boolean have feature ( string feature ) throw i o exception { if ( ! init feature map ( ) ) { return false ; } return __features map . contains key ( feature . to upper case ( locale . english ) ) ; }
public static final int opposite ( int position ) { if ( position == leave ) return right ; if ( position == right ) return leave ; return position ; }
public string get annotation name ( ) { return annotation name ; } // get annotation name
protect void write j s o n object ( j s o n object root ) throw x m l stream exception { try { if ( root == null ) writer . write ( `` null `` ) ; else root . write ( writer ) ; } catch ( j s o n exception e ) { throw new x m l stream exception ( e ) ; } catch ( i o exception e ) { throw new x m l stream exception ( e ) ; } }
public static corpus new corpus ( string name ) throw resource instantiation exception { return ( corpus ) create resource ( `` gate . corpus . corpus impl `` , new feature map ( ) , new feature map ( ) , name ) ; } // new corpus
public void cleanup ( ) { manager . clear ( ) ; for ( bean manager impl bean manager : bean deployment archive . value ( ) ) { bean manager . cleanup ( ) ; } bean deployment archive . clear ( ) ; deployment service . cleanup ( ) ; deployment manager . cleanup ( ) ; instance . clear ( context id ) ; }
public spring application builder web ( web application type web application type ) { this . application . set web application type ( web application type ) ; return this ; }
public list < string > get small v r for resource ( string resource class name ) { return get v r for resource ( resource class name , resource data . small_gui ) ; } // get small v r for resource
public final term term ( string field ) throw i o exception { final field field = field ( ) ; if ( field == null ) { return null ; } return field . term ( field ) ; }
public string get help u r l ( ) { return help u r l ; }
public feature map get runtime default ( ) throw parameter exception { return get default ( runtime parameter ) ; } // get runtime default ( )
public boolean add ( list < parameter > disjunction ) { boolean status = false ; iterator < parameter > iter = disjunction . iterator ( ) ; parameter param = iter . next ( ) ; if ( param . be runtime ( ) ) { status = runtime parameter . add ( disjunction ) ; } else { status = initime parameter . add ( disjunction ) ; } return status ; } // add ( param )
public string get version ( ) { return ( version ! = null ) ? version : `` `` ; }
public int hash code ( ) { return get class ( ) . hash code ( ) ^ storage dir . hash code ( ) ; } // hash code
public optional < instantiation > be an instantiation ( ) { return optional . empty ( ) ; }
public void re init ( ) throw resource instantiation exception { init ( ) ; } // re init ( )
public void set class name ( final string class name ) { this . class name = class name ; }
public void set jar file url ( url jar file url ) { this . jar file url = jar file url ; }
public void set xml file url ( url xml file url ) { this . xml file url = xml file url ; }
public void set resource displayed ( string a resource displayed ) { resource display = a resource displayed ; } // set resource displayed
public synchronize boolean put ( object o ) { if ( object . size ( ) > 30 ) return false ; object . add element ( o ) ; return true ; } // put
public static filter < file > get file extension filter ( string . . . extension ) { return new file extension filter ( extension ) ; }
public document transform to document ( ) { d o m result r = new d o m result ( ) ; transform to ( r ) ; return ( document ) r . get node ( ) ; }
public static string get gate resource a string ( string resource name ) throw i o exception { input stream resource stream = get gate resource a stream ( resource name ) ; if ( resource stream == null ) throw new i o exception ( `` no such resource on classpath : `` + resource name ) ; try { return i o utils . to string ( resource stream ) ; } finally { resource stream . close ( ) ; } } // get gate resource a string ( string )
public static feature map get runtime parameter value ( resource re ) throw resource instantiation exception { resource data r data = gate . get creole register ( ) . get ( re . get class ( ) . get name ( ) ) ; if ( r data == null ) throw new resource instantiation exception ( `` could not find creole data for `` + re . get class ( ) . get name ( ) ) ; parameter list params = r data . get parameter list ( ) ; return abstract resource . get parameter value ( re , params . get runtime parameter ( ) ) ; }
public static feature map feature map ( object . . . value ) { feature map fm = factory . new feature map ( ) ; if ( value ! = null ) { for ( int i = 0 ; i < value . length ; i++ ) { fm . put ( value [ i ] , value [ ++i ] ) ; } } return fm ; }
public static boolean unregister i r engine ( string class name ) { return register i r engine . remove ( class name ) ; }
public static set < plugin > get know plugins ( ) { set < plugin > plugins = new hash set < plugin > ( ) ; plugins . add all ( know plugins ) ; plugins . add all ( plugin update manager . get default plugins ( ) ) ; return plugins ; }
public static file get user session file ( ) { return user session file ; }
public list < string > get extension ( ) { if ( extension ! = null ) { return collection . unmodifiable list ( extension ) ; } else { return collection . empty list ( ) ; } }
public document get document ( ) { return document ; } // get document ( )
public void remove line highlight ( object tag ) { if ( tag instanceof line highlight info ) { line highlight . remove ( tag ) ; repaint line ( ( line highlight info ) tag ) ; } }
public static set < string > get output annotation set ( controller c ) { object set name obj = c . get feature ( ) . get ( output_annotation_sets_feature ) ; if ( set names obj ! = null & & set name obj instanceof set ) { return ( set < string > ) set name obj ; } else { set < string > set name = new hash set < string > ( ) ; c . get feature ( ) . put ( output_annotation_sets_feature , set name ) ; populate output set name for controller ( set names , c , true ) ; return set name ; } }
public void end general entity ( string name , augmentation augs ) throw x n i exception { if ( f document handler ! = null ) { f document handler . end general entity ( name , aug ) ; } } // end general entity ( string , augmentation )
public string get comment ( ) { return `` gate serial datastore `` ; }
public collection < relation > get relation ( string type ) { list < relation > res = new array list < relation > ( ) ; bit set rels = index by type . get ( type ) ; if ( rels ! = null ) { for ( int rel po = 0 ; rel po < = max i d ; rel pos++ ) { if ( rels . get ( rel po ) ) res . add ( index by id . get ( rel po ) ) ; } } return re ; }
public void remove layout component ( component comp ) { }
public graphic configuration get device configuration ( ) { return graphic environment . get local graphic environment ( ) . get default screen device ( ) . get default configuration ( ) ; }
public synchronize void show dialog ( component [ ] component ) { center box . remove all ( ) ; for ( int i =0 ; i < component . length ; i++ ) { center box . add ( component [ i ] ) ; } center box . validate ( ) ; pack ( ) ; / * point loc = frame . get location ( ) ; set location ( loc . x + ( frame . get size ( ) . width - get size ( ) . width ) / 2 , loc . y + ( frame . get size ( ) . height - get size ( ) . height ) /2 ) ; * / stop = false ; thread thread = new thread ( thread . current thread ( ) . get thread group ( ) , this , `` wait dialog2 `` ) ; thread . set priority ( thread . max_priority ) ; thread . start ( ) ; set visible ( true ) ; }
public static boolean be file ( file f ) { return f . be file ( ) & & ! be archive ( f ) ; }
public boolean be enable hide column ( ) { return this . enable hiding column ; }
public comparator < ? super c > column comparator ( ) { return column comparator ; }
public feature map get feature ( ) { if ( feature == null ) { feature = new simple feature map impl ( ) ; } return feature ; }
public static void set benchmarking enable ( boolean benchmarking enable ) { benchmark . benchmarking enable = benchmarking enable ; }
public void pad ( int factor ) throw i o exception { int pad = factor - ( int ) ( nr bit % factor ) ; int excess = padding & 7 ; if ( excess > 0 ) { this . write ( 0 , excess ) ; pad -= excess ; } while ( pad > 0 ) { this . write ( 0 , 8 ) ; pad -= 8 ; } this . out . flush ( ) ; }
public static resource new resource ( path path ) { return new path resource ( path ) ; }
public class loader get class loader ( ) { return classloader ! = null ? classloader : ( classloader = loader . get class loader ( resolver util . class , null ) ) ; }
public static corpus new corpus ( string name ) throw resource instantiation exception { return ( corpus ) create resource ( `` gate . corpus . corpus impl `` , new feature map ( ) , new feature map ( ) , name ) ; } // new corpus
public static boolean remove cache directory ( file dir ) { return extra cache directory . remove ( dir ) ; }
public v get ( object key ) { require non null ( key ) ; for ( entry < k , v > entry : entry ( ) ) { if ( entry . key == key ) { return entry . value ; } } return null ; }
static public void set unicode enable ( boolean value ) { unicode enable = value ; }
public static boolean be g a t e old enough ( string version ) { if ( version == null ) return true ; version = version . trim ( ) ; if ( version . equal ( `` `` ) || version . equal ( `` * `` ) ) return true ; return ( compare version ( main . version , version ) < = 0 ) ; }
public x m l stream writer create x m l stream writer ( writer writer ) throw x m l stream exception { throw new java . lang . unsupported operation exception ( ) ; }
public void write start document ( ) throw x m l stream exception { this . xml writer . write start document ( `` utf-8 `` , `` 1 . 0 `` ) ; }
public static string clean string for ( document doc , annotation set anns ) { return clean string ( string for ( doc , anns ) ) ; }
public static annotation set get coextensive annotation ( annotation set source , annotation set coext set ) { return get coextensive annotation worker ( source , null , start ( coext set ) , end ( coext set ) ) ; }
public static annotation set get coextensive annotation ( annotation set source , annotation set coext set , string type ) { return get coextensive annotation worker ( source , type , start ( coext set ) , end ( coext set ) ) ; }
public static void load plugin ( string dir name ) { file gatehome = gate . get gate home ( ) ; if ( gatehome == null ) { throw new gate runtime exception ( `` can not load plugin , gate home location not know `` ) ; } file plugin dir = new file ( new file ( gatehome , `` plugins `` ) , dir name ) ; load plugin ( plugin dir ) ; }
public int read ( ) throw i o exception { if ( ! get initialized ( ) ) { initialize ( ) ; set initialize ( true ) ; } while ( line == null || line . length ( ) == 0 ) { line = line tokenizer . get token ( in ) ; line = tail filter ( line ) ; if ( line == null ) { return -1 ; } line pos = 0 ; } int ch = line . char at ( line po ) ; line pos++ ; if ( line po == line . length ( ) ) { line = null ; } return ch ; }
public string get text ( ) { if ( text ! = null ) { return text . trim ( ) ; } return text ; }
public static int compare java version ( string first , string second ) { return long . compare ( compiler option . version to jdk level ( first ) , compiler option . version to jdk level ( second ) ) ; }
public static c char pointer pointer holder to c string ( char sequence [ ] java string ) { return new c char pointer pointer holder ( java string ) ; }
public boolean equal ( object o ) { if ( o == this ) { return true ; } if ( o instanceof pointer type ) { pointer p = ( ( pointer type ) o ) . get pointer ( ) ; if ( pointer == null ) { return p == null ; } return pointer . equal ( p ) ; } return false ; }
public static void initialize at build time ( string . . . package ) { stack trace element [ ] stacktrace = thread . current thread ( ) . get stack trace ( ) ; for ( string a package : package ) { image singleton . lookup ( runtime class initialization support . class ) . initialize at build time ( a package , message + get caller ( stacktrace ) ) ; } }
public static < t > t instantiate class ( class < t > clazz ) throw bean instantiation exception { assert . not null ( clazz , `` class must not be null `` ) ; if ( clazz . be interface ( ) ) { throw new bean instantiation exception ( clazz , `` specified class be an interface `` ) ; } try { return instantiate class ( clazz . get declared constructor ( ) ) ; } catch ( no such method exception ex ) { throw new bean instantiation exception ( clazz , `` no default constructor find `` , ex ) ; } }
public static boolean in image code ( ) { return system . get property ( property_image_code_key ) ! = null ; }
public static void report class initialize ( class < ? > c ) { if ( image singleton support . be instal ( ) & & image singleton . contains ( runtime class initialization support . class ) ) { runtime class initialization support runtime class initialization = image singleton . lookup ( runtime class initialization support . class ) ; runtime class initialization . report class initialize ( c ) ; } }
public static long get process i d ( ) { return image singleton . lookup ( process property support . class ) . get process i d ( ) ; }
public static string get argument vector program name ( ) { return image singleton . lookup ( process property support . class ) . get argument vector program name ( ) ; }
public string get deprecation ( ) { return this . deprecation ; } // -- string get deprecation ( )
public value get binding ( string language id ) { return impl . get binding ( language id ) ; }
public static context create ( string . . . permitted language ) { return new builder ( permitted language ) . build ( ) ; }
public boolean await close ( long timeout , time unit unit ) throw interrupted exception { lock . lock ( ) ; try { if ( close ) { return true ; } close = true ; this . cancellable flush task . cancel ( ) ; if ( bulk request . number of action ( ) > 0 ) { execute ( ) ; } try { return this . bulk request handler . await close ( timeout , unit ) ; } finally { on close . run ( ) ; } } finally { lock . unlock ( ) ; } }
public value get binding ( string language id ) { return impl . get binding ( language id ) ; }
public static < t > t lookup ( class < t > key ) { return image singleton support . get ( ) . lookup ( key ) ; }
public boolean be interactive ( ) { return get impl ( ) . be interactive ( impl ) ; }
public static option descriptor get option ( ) { return get option ( enum set . all of ( option class . class ) ) ; }
public string get root name ( ) { return impl . get execution event root name ( impl ) ; }
public void close ( boolean cancel if execute ) { impl . close ( this , cancel if execute ) ; }
public boolean be internal ( ) { return get impl ( ) . be internal ( impl ) ; }
public int get char length ( ) { return impl . get char length ( impl ) ; }
public boolean have line ( ) { return impl . have line ( impl ) ; }
public int get line start offset ( int line number ) throw illegal argument exception { return get impl ( ) . get line start offset ( impl , line number ) ; }
public static builder new builder ( string language , url url ) { return empty . new builder ( language , url ) ; }
public static string find mime type ( file file ) throw i o exception { return get impl ( ) . find mime type ( file ) ; }
public int get start line ( ) { return impl . get start line ( impl ) ; }
public int get char index ( ) { return impl . get char index ( impl ) ; }
public value get array element ( long index ) { return impl . get array element ( receiver , index ) ; }
public boolean be boolean ( ) { return impl . be boolean ( receiver ) ; }
public context get context ( ) { return engine . get impl ( ) . get limit event context ( impl ) ; }
public void visit post order ( query visitor visitor ) { visit impl ( visitor , false ) ; }
protect completable future < field value info > resolve field with info ( execution context execution context , execution strategy parameter parameter ) { graph q l field definition field def = get field def ( execution context , parameter , parameter . get field ( ) . get single field ( ) ) ; supplier < execution step info > execution step info = fp kit . intra thread memoize ( ( ) - > create execution step info ( execution context , parameter , field def , null ) ) ; instrumentation instrumentation = execution context . get instrumentation ( ) ; instrumentation context < execution result > field ctx = instrumentation . begin field ( new instrumentation field parameter ( execution context , execution step info ) ) ; completable future < fetch value > fetch field future = fetch field ( execution context , parameter ) ; completable future < field value info > result = fetch field future . then apply ( ( fetch value ) - > complete field ( execution context , parameter , fetch value ) ) ; completable future < execution result > execution result future = result . then compose ( field value info : : get field value ) ; field ctx . on dispatched ( execution result future ) ; execution result future . when complete ( field ctx : : on complete ) ; return result ; }
public static list < field > get declare field include inherit ( class < ? > clazz ) { list < field > field = new array list < field > ( ) ; while ( clazz ! = null ) { for ( field field : clazz . get declared field ( ) ) { field . add ( field ) ; } clazz = clazz . get superclass ( ) ; } return field ; }
public static locale get locale ( ) { locale context locale context = get locale context ( ) ; if ( locale context ! = null ) { locale locale = locale context . get locale ( ) ; if ( locale ! = null ) { return locale ; } } return locale . get default ( ) ; }
public execution result execute ( unary operator < execution input . builder > builder function ) { return execute ( builder function . apply ( execution input . new execution input ( ) ) . build ( ) ) ; }
public execution result execute ( unary operator < execution input . builder > builder function ) { return execute ( builder function . apply ( execution input . new execution input ( ) ) . build ( ) ) ; }
public static execution context builder new execution context builder ( execution context other ) { return new execution context builder ( other ) ; }
public object get ( char sequence key ) { t s t node node = get node ( key ) ; if ( node == null ) { return null ; } return node . data ; }
public response spec builder set default parser ( parser parser ) { spec . default parser ( parser ) ; return this ; }
public string get field value ( string field name ) { assert . check not null param ( `` field name `` , field name ) ; return field . get ( field name ) ; }
public data fetcher < ? > get data fetcher ( field coordinate coordinate , graph q l field definition field definition ) { return get data fetcher impl ( coordinate , field definition , data fetcher map , system data fetcher map , default data fetcher factory ) ; }
public graph q l enum value definition transform ( consumer < builder > builder consumer ) { builder builder = new enum value definition ( this ) ; builder consumer . accept ( builder ) ; return builder . build ( ) ; }
public graph q l input object field transform ( consumer < builder > builder consumer ) { builder builder = new input object field ( this ) ; builder consumer . accept ( builder ) ; return builder . build ( ) ; }
public graph q l directive get directive ( string directive name ) { return directive . get directive ( directive name ) ; }
public list < graph q l directive > get directive ( ) { return directive . get directive ( ) ; }
public graph q l schema transform without type ( consumer < builder without type > builder consumer ) { builder without type builder = new builder without type ( this ) ; builder consumer . accept ( builder ) ; return builder . build ( ) ; }
public static graph q l schema create mocked schema ( string sdl ) { type definition registry type definition registry = new schema parser ( ) . parse ( sdl ) ; graph q l schema graph q l schema = new schema generator ( ) . make executable schema ( type definition registry , runtime wiring . mocked_wiring ) ; return graph q l schema ; }
public < t > t get ( ) { return ( t ) object ; }
public validation error get validation error ( ) { return this . validation error ; }
public static boolean get disable checksum ( ) { return disable checksum ; }
public static void print ( print stream self , object value ) { self . print ( invoker helper . to string ( value ) ) ; }
protect final string read line ( ) throw i o exception { int ch = in . read ( ) ; if ( ch == -1 ) { return null ; } string buff line = new string buffer ( ) ; while ( ch ! = -1 ) { line . append ( ( char ) ch ) ; if ( ch == '\n ' ) { break ; } ch = in . read ( ) ; } return line . to string ( ) ; }
public static void enable ( ) { final meta class registry meta class registry = groovy system . get meta class registry ( ) ; synchronize ( meta class registry ) { if ( meta class registry . get meta class creation handler ( ) ! = instance ) { class info . clear modify expandos ( ) ; meta class registry . set meta class creation handle ( instance ) ; } } }
public object invoke ( object proxy , method method , object [ ] args ) throw throwable { string name = method . get name ( ) ; if ( method . get declare class ( ) == groovy object . class ) { if ( name . equal ( `` get meta class `` ) ) { return get meta class ( ) ; } else if ( name . equal ( `` set meta class `` ) ) { return set meta class ( ( meta class ) args [ 0 ] ) ; } } return invoker helper . invoke method ( extension , method . get name ( ) , args ) ; }
public int next int from to ( int from , int to ) { return ( int ) ( from + ( long ) ( ( 1l + to - from ) * random double ( ) ) ) ; }
public object invoke static method ( object object , string method name , object [ ] argument ) { if ( invoke static method method ! = null ) { meta class helper . unwrap ( argument ) ; return invoke static method method . invoke ( object , new object [ ] { method name , argument } ) ; } return super . invoke static method ( object , method name , argument ) ; }
public object invoke constructor ( final object [ ] argument ) { if ( intercept construction & & null == interceptor ) throw new runtime exception ( `` can not invoke constructor without interceptor `` ) ; if ( intercept construction ) { groovy object new instance = ( groovy object ) interceptor . before invoke ( null , get the class ( ) . get simple name ( ) , argument ) ; new instance . set meta class ( this ) ; return new instance ; } return adaptee . invoke constructor ( argument ) ; }
public object get property ( final class a class , final object object , final string property , final boolean use super , final boolean from inside class ) { if ( null == interceptor ) { return super . get property ( a class , object , property , use super , from inside class ) ; } if ( interceptor instanceof property access interceptor ) { property access interceptor pae = ( property access interceptor ) interceptor ; object result = pae . before get ( object , property ) ; if ( interceptor . do invoke ( ) ) { result = super . get property ( a class , object , property , use super , from inside class ) ; } return result ; } return super . get property ( a class , object , property , use super , from inside class ) ; }
public static boolean contains instance ( collection collection , object element ) { if ( collection ! = null ) { for ( object candidate : collection ) { if ( candidate == element ) { return true ; } } } return false ; }
public static < t1 , t2 , t3 , t4 > tuple4 < t1 , t2 , t3 , t4 > tuple ( t1 v1 , t2 v2 , t3 v3 , t4 v4 ) { return new tuple4 < > ( v1 , v2 , v3 , v4 ) ; }
public string get local part ( ) { return original . get local part ( ) ; }
public string to string ( ) { return ( ( namespace u r i . equal ( empty_string ) ) ? local part : ' { ' + namespace u r i + ' } ' + local part ) ; }
public int get index ( string expression ) { if ( expression == null || expression . length ( ) == 0 ) { return -1 ; } for ( int i = 0 ; i < expression . length ( ) ; i++ ) { char c = expression . char at ( i ) ; if ( c == nest || c == mapped_start ) { return -1 ; } else if ( c == indexed_start ) { int end = expression . index of ( indexed_end , i ) ; if ( end < 0 ) { throw new illegal argument exception ( `` miss end delimiter `` ) ; } string value = expression . substring ( i + 1 , end ) ; if ( value . length ( ) == 0 ) { throw new illegal argument exception ( `` no index value `` ) ; } int index = 0 ; try { index = integer . parse int ( value , 10 ) ; } catch ( exception e ) { throw new illegal argument exception ( `` invalid index value ' `` + value + `` ' `` ) ; } return index ; } } return -1 ; }
public static date clear time ( final date self ) { calendar calendar = calendar . get instance ( ) ; calendar . set time ( self ) ; clear time common ( calendar ) ; self . set time ( calendar . get time ( ) . get time ( ) ) ; return self ; }
public static duration get relative daylight saving offset ( date self , date other ) { duration d1 = get daylight saving offset ( self ) ; duration d2 = get daylight saving offset ( other ) ; return new time duration ( 0 , 0 , 0 , ( int ) ( d2 . to millisecond ( ) - d1 . to millisecond ( ) ) ) ; }
public static class node pick generic type ( class node type , int gt index ) { final generic type [ ] generic type = type . get generic type ( ) ; if ( generic types==null || generic type . length < gt index ) { return class helper . object_type ; } return generic type [ gt index ] . get type ( ) ; }
public void set default charset ( charset default charset ) { this . default charset = default charset ; }
public object get name ( string method name ) { if ( get proxy builder ( ) . name mapping closure ! = null ) { return get proxy builder ( ) . name mapping closure . call ( method name ) ; } return method name ; }
protected factory resolve factory ( object name , map attribute , object value ) { get proxy builder ( ) . get context ( ) . put ( child_builder , get proxy builder ( ) ) ; return get proxy builder ( ) . get factory ( ) . get ( name ) ; }
protect void set parent ( object parent , object child ) { get proxy builder ( ) . get current factory ( ) . set parent ( get proxy builder ( ) . get child builder ( ) , parent , child ) ; factory parent factory = get proxy builder ( ) . get parent factory ( ) ; if ( parent factory ! = null ) { parent factory . set child ( get proxy builder ( ) . get current builder ( ) , parent , child ) ; } }
public void remove post instantiate delegate ( closure delegate ) { get proxy builder ( ) . post instantiate delegate . remove ( delegate ) ; }
public static object sum ( collection item ) { return default groovy method . sum ( item ) ; }
public object get property ( string key ) { list < configuration node > nod = fetch node list ( key ) ; if ( node . size ( ) == 0 ) { return null ; } else { list < object > list = new array list < object > ( ) ; for ( configuration node node : node ) { if ( node . get value ( ) ! = null ) { list . add ( node . get value ( ) ) ; } } if ( list . size ( ) < 1 ) { return null ; } else { return ( list . size ( ) == 1 ) ? list . get ( 0 ) : list ; } } }
public boolean append ( node child ) { child . set parent ( this ) ; return get parent list ( this ) . add ( child ) ; }
public final int prev ( int node ) { final int leave = left ( node ) ; if ( left ! = nil ) { return last ( leave ) ; } else { int parent = parent ( node ) ; while ( parent ! = nil & & node == leave ( parent ) ) { node = parent ; parent = parent ( parent ) ; } return parent ; } }
public big integer to big integer ( ) { if ( text be empty or null ( ) ) { return null ; } return string groovy method . to big integer ( ( char sequence ) text ( ) ) ; }
public string text ( ) { if ( value instanceof string ) { return ( string ) value ; } if ( value instanceof node list ) { return ( ( node list ) value ) . text ( ) ; } if ( value instanceof collection ) { collection coll = ( collection ) value ; string previous text = null ; string builder sb = null ; for ( object child : coll ) { string child text = null ; if ( child instanceof string ) { child text = ( string ) child ; } else if ( child instanceof node ) { child text = ( ( node ) child ) . text ( ) ; } if ( child text ! = null ) { if ( previous text == null ) { previous text = child text ; } else { if ( sb == null ) { sb = new string builder ( ) ; sb . append ( previous text ) ; } sb . append ( child text ) ; } } } if ( sb ! = null ) { return sb . to string ( ) ; } else { if ( previous text ! = null ) { return previous text ; } return `` `` ; } } return `` `` + value ; }
public static field node get field ( class node class node , string field name ) { class node node = class node ; set < string > visit = new hash set < > ( ) ; while ( node ! = null ) { field node fn = node . get declared field ( field name ) ; if ( fn ! = null ) return fn ; class node [ ] interface = node . get interface ( ) ; for ( class node i node : interface ) { if ( visit . contains ( i node . get name ( ) ) ) continue ; field node ifn = get field ( i node , field name ) ; visit . add ( i node . get name ( ) ) ; if ( ifn ! = null ) return ifn ; } node = node . get super class ( ) ; } return null ; }
public boolean be indexed ( string expression ) { if ( expression == null || expression . length ( ) == 0 ) { return false ; } for ( int i = 0 ; i < expression . length ( ) ; i++ ) { char c = expression . char at ( i ) ; if ( c == nest || c == mapped_start ) { return false ; } else if ( c == indexed_start ) { return true ; } } return false ; }
public byte size value calculate value ( byte size value total , byte size value max headroom ) { if ( ratio ! = null ) { long ratio byte = ( long ) math . ceil ( ratio . get a ratio ( ) * total . get byte ( ) ) ; if ( max headroom ! = null & & max headroom . get byte ( ) ! = -1 ) { return byte size value . of byte ( math . max ( ratio byte , total . get byte ( ) - max headroom . get byte ( ) ) ) ; } else { return byte size value . of byte ( ratio byte ) ; } } else { return absolute ; } }
public void move to front ( e e ) { if ( e ! = first ) { unlink ( e ) ; link first ( e ) ; } }
public void set round up ( boolean r ) { round up = r ; }
public boolean be synthetic ( ) { return synthetic ; }
public method node get method ( string name , parameter [ ] parameter ) { for ( method node method : get method ( name ) ) { if ( parameter equal ( method . get parameter ( ) , parameter ) ) { return method ; } } return null ; }
public object invoke static method ( object object , string method name , object [ ] argument ) { if ( invoke static method method ! = null ) { meta class helper . unwrap ( argument ) ; return invoke static method method . invoke ( object , new object [ ] { method name , argument } ) ; } return super . invoke static method ( object , method name , argument ) ; }
public j annotation use annotate ( class < ? extend annotation > clazz ) { j annotation use annotation use = new j annotation use ( owner ( ) . ref ( clazz ) ) ; return annotation use ; }
public static boolean be float category ( class node type ) { return type==float_ t y p e || type==double_ t y p e ; }
public static boolean be big int category ( class node type ) { return type== big integer_ t y p e || be long category ( type ) ; }
public void cast to non primitive if necessary ( final class node source type , final class node target type ) { operand stack o = controller . get operand stack ( ) ; class node box type = o . box ( ) ; if ( widen category . implement interface or subclass of ( boxed type , target type ) ) return ; method visitor mv = controller . get method visitor ( ) ; if ( class helper . c l a s s_ type . equal ( target type ) ) { cast to class method . call ( mv ) ; } else if ( class helper . string_type . equal ( target type ) ) { cast to string method . call ( mv ) ; } else if ( target type . be derive from ( class helper . enum_ type ) ) { ( new class expression ( target type ) ) . visit ( controller . get acg ( ) ) ; o . remove ( 1 ) ; cast to enum method . call ( mv ) ; bytecode helper . do cast ( mv , target type ) ; } else { ( new class expression ( target type ) ) . visit ( controller . get acg ( ) ) ; o . remove ( 1 ) ; cast to type method . call ( mv ) ; } }
public bytecode variable get variable ( final string variable name , final boolean must exist ) { if ( variable name . equal ( `` this `` ) ) return bytecode variable . this_variable ; if ( variable name . equal ( `` super `` ) ) return bytecode variable . super_variable ; bytecode variable v = stack variable . get ( variable name ) ; if ( v == null & & must exist ) throw new groovy bug error ( `` try to get a variable with the name `` + variable name + `` a stack variable , but a variable with this name be not create `` ) ; return v ; }
public int size ( ) { int size = 0 ; for ( int i = this . composite . length - 1 ; i > = 0 ; -- i ) { size += this . composite [ i ] . size ( ) ; } return size ; }
protect void mark ( ) throw compilation fail exception { i source unit operation mark = ( final source unit source ) - > { if ( source . phase < phase ) { source . goto phase ( phase ) ; } if ( source . phase == phase & & phase complete & & ! source . phase complete ) { source . complete phase ( ) ; } } ; mark . do phase operation ( this ) ; }
public print writer get reporter ( ) throw i o exception { if ( output buffer . be new ( ) ) { output buffer . check converter ( ) ; if ( writer == null ) { writer = new coyote writer ( output buffer ) ; } return writer ; } else { return null ; } }
public void add error ( final message message , final boolean fatal ) throw compilation fail exception { if ( fatal ) { add fatal error ( message ) ; } else { add error ( message ) ; } }
public void set token blacklist ( final list < integer > token blacklist ) { if ( tokens whitelist ! = null ) { throw new illegal argument exception ( `` you be not allow to set both whitelist and blacklist `` ) ; } this . token blacklist = token blacklist ; }
public void set receiver black list ( final list < string > receiver black list ) { if ( receiver white list ! = null ) { throw new illegal argument exception ( `` you be not allow to set both whitelist and blacklist `` ) ; } this . receiver black list = receiver black list ; }
public final int error count ( ) { return error . size ( ) ; }
public void write ( final print writer output , final janitor janitor ) { string description = `` general error during `` + owner . get phase description ( ) + `` : `` ; string message = cause . get message ( ) ; if ( message ! = null ) { output . println ( description + message ) ; } else { output . println ( description + cause ) ; } output . println ( ) ; / * if ( debug ) * / cause . print stack trace ( output ) ; }
public void set compiler configuration ( @ nullable compiler configuration compiler configuration ) { this . compiler configuration = ( compiler configuration ! = null ? compiler configuration : new compiler configuration ( ) ) ; }
public static class get call class ( int match level , collection < string > extra ignore package ) { class [ ] class context = helper . get class context ( ) ; int depth = 0 ; try { class c ; do { do { c = class context [ depth++ ] ; } while ( class should be ignore ( c , extra ignore package ) ) ; } while ( c ! = null & & match level -- > 0 & & depth < class context . length ) ; return c ; } catch ( throwable t ) { return null ; } }
public static class element type ( class clazz ) { check array type ( clazz ) ; while ( clazz . be array ( ) ) { clazz = clazz . get component type ( ) ; } return clazz ; }
public static void c array set ( char [ ] a , int i , char v ) { try { a [ i ] =v ; } catch ( throwable t ) { a [ default groovy method support . normalise index ( i , a . length ) ] =v ; } }
public static int int array get ( int [ ] a , int i ) { try { return a [ i ] ; } catch ( throwable t ) { return a [ default groovy method support . normalise index ( i , a . length ) ] ; } }
public static void int array set ( int [ ] a , int i , int v ) { try { a [ i ] =v ; } catch ( throwable t ) { a [ default groovy method support . normalise index ( i , a . length ) ] =v ; } }
public object invoke ( object proxy , method method , object [ ] args ) throw throwable { string name = method . get name ( ) ; if ( method . get declare class ( ) == groovy object . class ) { if ( name . equal ( `` get meta class `` ) ) { return get meta class ( ) ; } else if ( name . equal ( `` set meta class `` ) ) { return set meta class ( ( meta class ) args [ 0 ] ) ; } } return invoker helper . invoke method ( extension , method . get name ( ) , args ) ; }
public string to string ( ) { return delegate ( ) . to string ( ) ; }
public static void sleep ( object self , long millisecond , closure on interrupt ) { sleep impl ( millisecond , on interrupt ) ; }
public static string to type string ( object [ ] argument ) { return to type string ( argument , -1 ) ; }
public byte [ ] get byte to end of stream ( data input stream in ) throw i o exception { final int chunk size = ( in . available ( ) > 0 ) ? in . available ( ) : 2048 ; byte [ ] buf = new byte [ chunk size ] ; byte array output stream byte stream = new byte array output stream ( chunk size ) ; int count ; while ( ( count=in . read ( buf ) ) ! = -1 ) { byte stream . write ( buf , 0 , count ) ; } return byte stream . to byte array ( ) ; }
public static object output stream new object output stream ( file file ) throw i o exception { return new object output stream ( new file output stream ( file ) ) ; }
public static void append ( file file , byte [ ] bytes ) throw i o exception { output stream stream = null ; try { stream = new file output stream ( file , true ) ; stream . write ( byte , 0 , byte . length ) ; stream . flush ( ) ; output stream temp = stream ; stream = null ; temp . close ( ) ; } finally { close with warning ( stream ) ; } }
public static iterator < string > iterator ( reader self ) { final buffer reader buffer reader ; if ( self instanceof buffer reader ) buffer reader = ( buffered reader ) self ; else buffer reader = new buffer reader ( self ) ; return new iterator < string > ( ) { string next val / * = null * / ; boolean next must read = true ; boolean have next = true ; public boolean have next ( ) { if ( next must read & & have next ) { try { next val = read next ( ) ; next must read = false ; } catch ( i o exception e ) { have next = false ; } } return have next ; } public string next ( ) { string retval = null ; if ( next must read ) { try { retval = read next ( ) ; } catch ( i o exception e ) { have next = false ; } } else retval = next val ; next must read = true ; return retval ; } private string read next ( ) throw i o exception { string nv = buffer reader . read line ( ) ; if ( nv == null ) have next = false ; return nv ; } public void remove ( ) { throw new unsupported operation exception ( `` can not remove ( ) from a reader iterator `` ) ; } } ; }
public static buffer reader new reader ( input stream self , string charset ) throw unsupported encode exception { return new buffer reader ( new input stream reader ( self , charset ) ) ; }
public static < t > t with object input stream ( input stream input stream , @ closure params ( value= simple type . class , options= `` java . io . object input stream `` ) closure < t > closure ) throw i o exception { return with stream ( new object input stream ( input stream ) , closure ) ; }
public synchronize object get ( final object key ) { final object value = remove ( key ) ; if ( value ! = null ) put ( key , value ) ; return value ; }
protect int add entry ( final int previous code , final byte character , final int max table size ) { if ( table size < max table size ) { prefixes [ table size ] = previous code ; character [ table size ] = character ; return table size++ ; } return -1 ; }
public static boolean reference equal ( object x , object y ) { return x == y ; }
public set < entry < e > > entry set ( ) { if ( entry set == null ) { entry set = create entry set ( ) ; } return entry set ; }
public static void set orig bool ( boolean v ) { orig boolean = v ; orig boolean re = without custom handle & & orig boolean ; }
public static void set orig bool ( boolean v ) { orig boolean = v ; orig boolean re = without custom handle & & orig boolean ; }
public static void set orig bool ( boolean v ) { orig boolean = v ; orig boolean re = without custom handle & & orig boolean ; }
public static void enable ( ) { final meta class registry meta class registry = groovy system . get meta class registry ( ) ; synchronize ( meta class registry ) { if ( meta class registry . get meta class creation handler ( ) ! = instance ) { class info . clear modify expandos ( ) ; meta class registry . set meta class creation handle ( instance ) ; } } }
protected class define class ( string name , byte [ ] bytecode , protection domain domain ) { throw new deprecation exception ( `` the method groovy . lang . groovy class loader # define class ( string , byte [ ] , protection domain ) be no longer use internally and remove `` ) ; }
public static string get method suggestion string ( string method name , class type , object [ ] argument ) { class info ci = class info . get class info ( type ) ; list < meta method > method = new array list < meta method > ( ci . get meta class ( ) . get method ( ) ) ; method . add all ( ci . get meta class ( ) . get meta method ( ) ) ; list < meta method > sugg = rank method ( method name , argument , method ) ; string builder sb = new string builder ( ) ; if ( ! sugg . be empty ( ) ) { sb . append ( `` \n possible solution : `` ) ; for ( int i = 0 ; i < sugg . size ( ) ; i++ ) { if ( i ! = 0 ) sb . append ( `` , `` ) ; sb . append ( sugg . get ( i ) . get name ( ) ) . append ( `` ( `` ) ; sb . append ( list parameter name ( sugg . get ( i ) . get parameter type ( ) ) ) ; sb . append ( `` ) `` ) ; } } class [ ] argument class = get argument class ( argument ) ; list < pair < class , class > > conflict class = get conflict class ( sugg , argument class ) ; if ( ! conflict class . be empty ( ) ) { sb . append ( `` \n the following class appear a argument class and a parameter class , `` ) ; sb . append ( `` but be define by different class loader : \n `` ) ; boolean first = true ; for ( pair < class , class > pair : conflict class ) { if ( ! first ) { sb . append ( `` , `` ) ; } else { first = false ; } sb . append ( pair . u . get name ( ) ) . append ( `` ( define by ' `` ) ; sb . append ( pair . u . get class loader ( ) ) ; sb . append ( `` ' and ' `` ) ; sb . append ( pair . v . get class loader ( ) ) ; sb . append ( `` ' ) `` ) ; } sb . append ( `` \n if one of the method suggestion match the method you want to call , `` ) ; sb . append ( `` \nthen check your class loader setup . `` ) ; } return sb . to string ( ) ; }
public static < t > t with object input stream ( file file , class loader class loader , @ closure params ( value = simple type . class , option = `` java . io . object input stream `` ) closure < t > closure ) throw i o exception { return i o groovy method . with stream ( new object input stream ( file , class loader ) , closure ) ; }
public static void append ( file file , reader reader , boolean write bom ) throw i o exception { append ( file , reader , charset . default charset ( ) . name ( ) , write bom ) ; }
public void set writable file ( writable file file ) { super . set internal writable file ( file ) ; }
public static void append ( file file , object text , string charset , boolean write bom ) throw i o exception { writer writer = null ; try { boolean should write bom = write bom & & ! file . exists ( ) ; file output stream out = new file output stream ( file , true ) ; if ( should write bom ) { write u t f16 bom if require ( out , charset ) ; } writer = new output stream writer ( out , charset ) ; invoker helper . write ( writer , text ) ; writer . flush ( ) ; writer temp = writer ; writer = null ; temp . close ( ) ; } finally { close with warning ( writer ) ; } }
public static void each byte ( file self , int buffer len , @ closure params ( value = from string . class , option = `` byte [ ] , integer `` ) closure closure ) throw i o exception { buffered input stream be = new input stream ( self ) ; i o groovy method . each byte ( be , buffer len , closure ) ; }
public static void each byte ( url url , @ closure params ( value = simple type . class , option = `` byte `` ) closure closure ) throw i o exception { input stream be = url . open connection ( ) . get input stream ( ) ; i o groovy method . each byte ( be , closure ) ; }
public static socket accept ( server socket server socket , @ closure params ( value= simple type . class , options= `` java . net . socket `` ) final closure closure ) throw i o exception { return accept ( server socket , true , closure ) ; }
public void write ( int c ) { if ( c ! = -1 ) { current . append ( ( char ) c ) ; } if ( c == '\n ' ) { current = new string buffer ( ) ; line . add ( current ) ; } }
public object get ( ) { int size = size ( ) ; if ( size == 0 ) { throw new buffer underflow exception ( ) ; } return get ( size - 1 ) ; }
public c s t node add ( c s t node element ) { return set ( size ( ) , element ) ; }
public static void command line compile ( string [ ] args ) throw exception { command line compile ( args , true ) ; }
public static response delete ( uri uri ) { return give ( ) . delete ( uri ) ; }
public void set method target ( method node mn ) { this . target = mn ; if ( mn ! = null ) { set type ( target . get return type ( ) ) ; } else { set type ( class helper . object_type ) ; } }
public binary expression get enclose binary expression ( ) { if ( enclose binary expression . be empty ( ) ) return null ; return enclose binary expression . get first ( ) ; }
public binary expression get enclose binary expression ( ) { if ( enclose binary expression . be empty ( ) ) return null ; return enclose binary expression . get first ( ) ; }
public switch statement pop enclose switch statement ( ) { return switch statement . remove first ( ) ; }
public void push enclose switch statement ( switch statement switch statement ) { switch statement . add first ( switch statement ) ; }
public class node get enclose class node ( ) { if ( enclose class node . be empty ( ) ) return null ; return enclose class node . get first ( ) ; }
public class node get enclose class node ( ) { if ( enclose class node . be empty ( ) ) return null ; return enclose class node . get first ( ) ; }
public expression get enclose method call ( ) { if ( enclose method call . be empty ( ) ) return null ; return enclose method call . get first ( ) ; }
public list < method node > handle miss method ( class node receiver , string name , argument list expression argument list , class node [ ] argument type , method call call ) { return collection . empty list ( ) ; }
public class node get type ( final a s t node exp ) { return type check visitor . get type ( exp ) ; }
public class node build list type ( class node component type ) { return parameterized type ( class helper . list_type , component type ) ; }
public static string get variable name for parameter ( method parameter parameter ) { assert . not null ( parameter , `` method parameter must not be null `` ) ; class < ? > value class ; boolean pluralize = false ; if ( parameter . get parameter type ( ) . be array ( ) ) { value class = parameter . get parameter type ( ) . get component type ( ) ; pluralize = true ; } else if ( collection . class . be assignable from ( parameter . get parameter type ( ) ) ) { value class = generic collection type resolver . get collection parameter type ( parameter ) ; if ( value class == null ) { throw new illegal argument exception ( `` can not generate variable name for non-typed collection parameter type `` ) ; } pluralize = true ; } else { value class = parameter . get parameter type ( ) ; } string name = class utils . get short name a property ( value class ) ; return ( pluralize ? pluralize ( name ) : name ) ; }
protect static method handle add transformer ( method handle handle , int po , object arg , class < ? > parameter ) { method handle transformer = null ; if ( arg instanceof g string ) { transformer = to_string ; } else if ( arg instanceof closure ) { transformer = create s a m transform ( arg , parameter ) ; } else if ( number . class . be assignable from ( parameter ) ) { transformer = select number transformer ( parameter , arg ) ; } else if ( parameter . be array ( ) ) { transformer = method handle . insert argument ( as_array , 1 , parameter ) ; } if ( transformer == null ) throw new groovy bug error ( `` unknown transformation for argument `` + arg + `` at position `` + po + `` with `` + arg . get class ( ) + `` for parameter of type `` + parameter ) ; return apply unsharp filter ( handle , po , transformer ) ; }
public < t extend type definition > list < t > get type ( class < t > target class ) { return type . value ( ) . stream ( ) . filter ( target class : : be instance ) . map ( target class : : cast ) . collect ( collector . to list ( ) ) ; }
public static < t > list < t > to list ( final stream < t > self ) { return self . collect ( collector . to list ( ) ) ; }
public static package part name create part name ( uri part name , package part relative part ) throw invalid format exception { uri new part name u r i = resolve part uri ( relative part . get part name ( ) . get u r i ( ) , part name ) ; return create part name ( new part name u r i ) ; }
protect void write raw ( char sequence seq , char buf buffer ) { if ( seq ! = null ) { buffer . add ( seq . to string ( ) ) ; } }
public void set file date format ( string file date format ) { string new format ; if ( file date format == null ) { new format = `` `` ; } else { new format = file date format ; } this . file date format = new format ; synchronize ( this ) { file date formatter = new simple date format ( new format , locale . u ) ; file date formatter . set time zone ( time zone . get default ( ) ) ; } }
public boolean composite handle throwable ( composite converter < i log event > composite converter ) { converter < i log event > child converter = composite converter . get child converter ( ) ; for ( converter < i log event > c = child converter ; c ! = null ; c = c . get next ( ) ) { if ( c instanceof throwable handle converter ) { return true ; } else if ( c instanceof composite converter ) { boolean r = composite handle throwable ( ( composite converter < i log event > ) c ) ; if ( r ) return true ; } } return false ; }
public static boolean be single ( class < ? > type ) { for ( class < ? > reactive type : single_types ) { if ( reactive type . be assignable from ( type ) ) { return true ; } } return false ; }
public object call ( iterable coll , closure c ) { list < object > list content = new array list < object > ( ) ; if ( coll ! = null ) { for ( object it : coll ) { list content . add ( json delegate . curry delegate and get content ( c , it ) ) ; } } content = list content ; return content ; }
public boolean be lazy chop ( ) { return lazy chop ; }
public final void chop map ( ) { / * if it have be chop then you have to return . * / if ( map chop ) { return ; } map chopped = true ; / * if the internal map be not create yet , do n't . we can chop the value w/o create the internal map . * / if ( this . map == null ) { for ( int index = 0 ; index < len ; index++ ) { map item value entry = ( map item value ) item [ index ] ; value value = entry . get value ( ) ; if ( value == null ) continue ; if ( value . be container ( ) ) { chop container ( value ) ; } else { value . chop ( ) ; } } } else { / * iterate through the map and do the same thing . make sure child and child of child be chop . * / for ( map . entry < string , object > entry : map . entry set ( ) ) { object object = entry . get value ( ) ; if ( object instanceof value ) { value value = ( value ) object ; if ( value . be container ( ) ) { chop container ( value ) ; } else { value . chop ( ) ; } } else if ( object instanceof lazy value map ) { lazy value map m = ( lazy value map ) object ; m . chop map ( ) ; } else if ( object instanceof value list ) { value list list = ( value list ) object ; list . chop list ( ) ; } } } }
public closure get body ( ) { return new closure ( this . parent , this ) { public void do call ( object [ ] args ) { final groovy object delegate = ( groovy object ) get delegate ( ) ; final g path result this object = ( g path result ) get this object ( ) ; node node = ( node ) this object . get at ( 0 ) ; list child = node . child ( ) ; for ( object child : child ) { delegate . get property ( `` mkp `` ) ; if ( child instanceof node ) { delegate . invoke method ( `` yield `` , new object [ ] { new node child ( ( node ) child , this object , `` * `` , null ) } ) ; } else { delegate . invoke method ( `` yield `` , new object [ ] { child } ) ; } } } } ; }
public long to long ( ) { if ( text be empty or null ( ) ) { return null ; } return string groovy method . to long ( ( char sequence ) text ( ) ) ; }
public writer write to ( writer out ) throw i o exception { return out . append ( to string ( ) ) ; }
public void add child ( configuration node child ) { child . add node ( child ) ; child . set attribute ( false ) ; child . set parent node ( this ) ; }
public enumeration < string > get logger name ( ) { final array deque < iterator < logger node > > node stack = new array deque < > ( ) ; node stack . add ( collection . singleton ( root logger ) . iterator ( ) ) ; return new enumeration < string > ( ) { logger node next ; @ override public boolean have more element ( ) { if ( next ! = null ) return true ; while ( ! node stack . be empty ( ) ) { final iterator < logger node > itr = node stack . peek first ( ) ; if ( ! itr . have next ( ) ) { node stack . poll first ( ) ; } else { final logger node node = itr . next ( ) ; node stack . add last ( node . get child ( ) . iterator ( ) ) ; if ( node . have logger ( ) ) { next = node ; return true ; } } } return false ; } @ override public string next element ( ) { if ( ! have more element ( ) ) { throw new no such element exception ( ) ; } try { return next . get full name ( ) ; } finally { next = null ; } } } ; }
public void set keep ignorable whitespace ( boolean keep ignorable whitespace ) { this . keep ignorable whitespace = keep ignorable whitespace ; }
public void set keep ignorable whitespace ( boolean keep ignorable whitespace ) { this . keep ignorable whitespace = keep ignorable whitespace ; }
protect s a x reader create reader ( ) throw document exception { final s a x reader reader = new s a x reader ( ) ; try { reader . set feature ( `` http : //apache . org/xml/features/disallow-doctype-decl `` , true ) ; } catch ( s a x exception e ) { throw new document exception ( `` can not disable doctype processing `` , e ) ; } return reader ; }
public boolean be omit empty attribute ( ) { return omit empty attribute ; }
public q name get name ( string uri , string local name , string prefix ) { / * return new q name ( uri , local name , prefix ) ; * / assert local name ! = null ; if ( uri == null ) uri = `` `` ; if ( prefix == null ) prefix = `` `` ; int index = hash ( uri , local name , prefix ) & hashmask ; while ( true ) { q name q = table [ index ] ; if ( q == null ) { num entries++ ; if ( num entry > = threshold ) rehash ( ) ; return table [ index ] = new q name ( uri , local name , prefix ) ; } else if ( equal ( q , uri , local name , prefix ) ) return q ; else index = ( index-1 ) & hashmask ; } }
public static s a x parser new s a x parser ( string schema language , url schema ) throw s a x exception , parser configuration exception { return new s a x parser ( schema language , true , false , schema ) ; }
public string to json ( object src ) { if ( src == null ) { return to json ( json null . instance ) ; } return to json ( src , src . get class ( ) ) ; }
public json writer new json writer ( writer writer ) throw i o exception { if ( generate non executable json ) { writer . write ( json_non_executable_prefix ) ; } json writer json writer = new json writer ( writer ) ; if ( pretty printing ) { json writer . set indent ( `` `` ) ; } json writer . set serialize null ( serialize null ) ; return json writer ; }
public gson builder exclude field with modifier ( int . . . modifier ) { excluder = excluder . with modifier ( modifier ) ; return this ; }
public void set naming policy ( naming policy naming policy ) { if ( name policy == null ) naming policy = default naming policy . instance ; this . naming policy = naming policy ; }
public void add ( string string ) { element . add ( string == null ? json null . instance : new json primitive ( string ) ) ; }
public long get a long ( ) { if ( element . size ( ) == 1 ) { return element . get ( 0 ) . get a long ( ) ; } throw new illegal state exception ( ) ; }
public int get a int ( ) { throw new unsupported operation exception ( get class ( ) . get simple name ( ) ) ; }
public json primitive get a json primitive ( string member name ) { return ( json primitive ) member . get ( member name ) ; }
public static boolean be void ( type type ) { final class < ? > cl = type factory . default instance ( ) . construct type ( type ) . get raw class ( ) ; return void . class . be assignable from ( cl ) || void . type . be assignable from ( cl ) ; }
public boolean be empty ( ) { if ( fast ) { return ( map . be empty ( ) ) ; } else { synchronize ( map ) { return ( map . be empty ( ) ) ; } } }
public static boolean safe equal ( object a , object b ) { if ( a == b ) return true ; if ( a == null ) return false ; if ( b == null ) return false ; return a . equal ( b ) ; }
public string get a string ( ) { if ( be number ( ) ) { return get a number ( ) . to string ( ) ; } else if ( be boolean ( ) ) { return get a boolean wrapper ( ) . to string ( ) ; } else { return ( string ) value ; } }
public static < v > option key < option map < v > > map of ( class < v > value class ) { option type < option map < v > > type = option type . map of ( value class ) ; if ( type == null ) { throw new illegal argument exception ( `` no default type specify for type `` + value class . get name ( ) ) ; } return new option key < > ( option map . empty ( ) , type ) ; }
public static < e > immutable multiset < e > of ( ) { return ( immutable multiset < e > ) regular immutable multiset . empty ; }
public immutable set < k > key set ( ) { return map . key set ( ) ; }
public static < e > immutable sort set < e > copy of sort ( sort set < e > sort set ) { comparator < ? super e > comparator = sort iterables . comparator ( sort set ) ; immutable list < e > list = immutable list . copy of ( sorted set ) ; if ( list . be empty ( ) ) { return empty set ( comparator ) ; } else { return new regular immutable sort set < e > ( list , comparator ) ; } }
public static < e extend comparable < ? super e > > immutable sort multiset < e > of ( e e1 , e e2 ) { return copy of ( order . natural ( ) , arrays . a list ( e1 , e2 ) ) ; }
public static < e > immutable sort set < e > of ( e element ) { throw new unsupported operation exception ( ) ; }
public static < b > set < list < b > > cartesian product ( list < ? extend set < ? extend b > > set ) { return cartesian set . create ( set ) ; }
public e next ( ) throw no such element exception { if ( have next ( ) == false ) { throw new no such element exception ( ) ; } final int least index = least ( ) ; if ( least index == -1 ) { throw new no such element exception ( ) ; } final e val = value . get ( least index ) ; clear ( least index ) ; last return = least index ; return val ; }
public element last ( ) { return be empty ( ) ? null : get ( size ( ) - 1 ) ; }
public static < t > order < t > explicit ( list < t > value in order ) { return new explicit order < t > ( value in order ) ; }
public static < e > queue < e > synchronize queue ( final queue < e > queue ) { return synchronize queue . synchronize queue ( queue ) ; }
public static < e extend comparable > tree multiset < e > create ( iterable < ? extend e > element ) { tree multiset < e > multiset = create ( ) ; iterables . add all ( multiset , element ) ; return multiset ; }
protect int next escape index ( char sequence csq , int index , int end ) { check not null ( csq ) ; for ( ; index < end ; index++ ) { char c = csq . char at ( index ) ; if ( c > = safe octet . length || ! safe octet [ c ] ) { break ; } } return index ; }
protect final char [ ] escape ( char c ) { if ( c < replacement length ) { char [ ] char = replacement [ c ] ; if ( char ! = null ) { return char ; } } if ( c > = safe min & & c < = safe max ) { return null ; } return escape unsafe ( c ) ; }
public char escaper builder add escape ( char [ ] c , string r ) { check not null ( r ) ; for ( char c : c ) { add escape ( c , r ) ; } return this ; }
public static object get singleton target ( object candidate ) { if ( candidate instanceof advise ) { target source target source = ( ( advise ) candidate ) . get target source ( ) ; if ( target source instanceof singleton target source ) { return ( ( singleton target source ) target source ) . get target ( ) ; } } return null ; }
public void set md5 hash ( byte [ ] md5 hash ) { add metadata ( metadata_header_hash_md5 , service utils . to hex ( md5 hash ) ) ; add metadata ( metadata_header_content_md5 , service utils . to base64 ( md5 hash ) ) ; }
public static hash code combine order ( iterable < hash code > hash code ) { iterator < hash code > iterator = hash code . iterator ( ) ; check argument ( iterator . have next ( ) , `` must be at least 1 hash code to combine . `` ) ; int bit = iterator . next ( ) . bit ( ) ; byte [ ] result byte = new byte [ bit / 8 ] ; for ( hash code hash code : hash code ) { byte [ ] next byte = hash code . a byte ( ) ; check argument ( next byte . length == result byte . length , `` all hashcodes must have the same bit length . `` ) ; for ( int i = 0 ; i < next byte . length ; i++ ) { result bytes [ i ] = ( byte ) ( result bytes [ i ] * 37 ^ next byte [ i ] ) ; } } return hash code . from bytes no copy ( result byte ) ; }
public int read ( ) throw i o exception { int b = in . read ( ) ; if ( trace & & b ! = -1 ) { if ( quote ) write byte ( b ) ; else trace out . write ( b ) ; } return b ; }
public static string to hex ( byte [ ] data ) { return base16 lower . encode a string ( data ) ; }
public static void skip fully ( data input in , int len ) throw i o exception { int total = 0 ; int cur = 0 ; while ( ( total < len ) & & ( ( cur = in . skip byte ( len-total ) ) > 0 ) ) { total += cur ; } if ( total < len ) { throw new i o exception ( `` not able to skip `` + len + `` byte , possibly `` + `` due to end of input . `` ) ; } }
public < t > t read line ( line processor < t > processor ) throw i o exception { check not null ( processor ) ; close closer = closer . create ( ) ; try { reader reader = closer . register ( open stream ( ) ) ; return char stream . read line ( reader , processor ) ; } catch ( throwable e ) { throw close . rethrow ( e ) ; } finally { closer . close ( ) ; } }
public static buffer reader new reader ( file file , string charset ) throw file not find exception , unsupported encode exception { return new buffer reader ( new input stream reader ( new file input stream ( file ) , charset ) ) ; }
protect final file create temp dir ( string prefix ) { try { file temp dir = file . create temp file ( prefix + `` . `` , `` . `` + get port ( ) ) ; temp dir . delete ( ) ; temp dir . mkdir ( ) ; temp dir . delete on exit ( ) ; return temp dir ; } catch ( i o exception ex ) { throw new web server exception ( `` unable to create temp dir . java . io . tmpdir be set to `` + system . get property ( `` java . io . tmpdir `` ) , ex ) ; } }
public static byte [ ] to byte array ( url url ) throw i o exception { u r l connection conn = url . open connection ( ) ; try { return i o utils . to byte array ( conn ) ; } finally { close ( conn ) ; } }
public static host and port from host ( string host ) { host and port parse host = from string ( host ) ; check argument ( ! parse host . have port ( ) , `` host have a port : % s `` , host ) ; return parse host ; }
public static inet address decrement ( inet address address ) { byte [ ] addr = address . get address ( ) ; int i = addr . length - 1 ; while ( i > = 0 & & addr [ i ] == ( byte ) 0x00 ) { addr [ i ] = ( byte ) 0xff ; i -- ; } check argument ( i > = 0 , `` decrementing % s would wrap . `` , address ) ; addr [ i ] -- ; return byte to inet address ( addr ) ; }
public list < composite part > get part ( ) { return part ; }
public boolean be public suffix ( ) { return public suffix index == 0 ; }
public static boolean be valid expression ( @ nullable string expression ) { if ( expression == null ) { return false ; } try { parse ( expression ) ; return true ; } catch ( illegal argument exception ex ) { return false ; } }
public immutable set < class info > get top level class ( ) { return fluent iterable . from ( resource ) . filter ( class info . class ) . filter ( new predicate < class info > ( ) { @ override public boolean apply ( class info info ) { return info . be top level ( ) ; } } ) . to set ( ) ; }
public static type set union ( final type set a , final type set b ) { return new type set ( ) { public boolean contains ( x s type type ) { return a . contains ( type ) || b . contains ( type ) ; } } ; }
public final double get and add ( double delta ) { while ( true ) { long current = value ; double current val = long bits to double ( current ) ; double next val = current val + delta ; long next = double to raw long bit ( next val ) ; if ( updater . compare and set ( this , current , next ) ) { return current val ; } } }
public boolean enter if ( guard guard ) { if ( guard . monitor ! = this ) { throw new illegal monitor state exception ( ) ; } final reentrant lock lock = this . lock ; lock . lock ( ) ; boolean satisfy = false ; try { return satisfied = guard . be satisfied ( ) ; } finally { if ( ! satisfy ) { lock . unlock ( ) ; } } }
public void wait for ( guard guard ) throw interrupted exception { if ( ! ( ( guard . monitor == this ) & lock . be hold by current thread ( ) ) ) { throw new illegal monitor state exception ( ) ; } if ( ! guard . be satisfied ( ) ) { await ( guard , true ) ; } }
public static < e > fluent iterable < e > of ( @ nullable e element , e . . . element ) { return from ( list . a list ( element , element ) ) ; }
public void put all ( bloom filter < t > that ) { check not null ( that ) ; check argument ( this ! = that , `` can not combine a bloom filter with itself . `` ) ; check argument ( this . num hash function == that . num hash function , `` bloom filter must have the same number of hash function ( % s ! = % s ) `` , this . num hash function , that . num hash function ) ; check argument ( this . bit size ( ) == that . bit size ( ) , `` bloom filter must have the same size underlie bit array ( % s ! = % s ) `` , this . bit size ( ) , that . bit size ( ) ) ; check argument ( this . strategy . equal ( that . strategy ) , `` bloom filter must have equal strategy ( % s ! = % s ) `` , this . strategy , that . strategy ) ; check argument ( this . funnel . equal ( that . funnel ) , `` bloom filter must have equal funnel ( % s ! = % s ) `` , this . funnel , that . funnel ) ; this . bit . put all ( that . bit ) ; }
public static hash function hmac sha1 ( key key ) { return new mac hash function ( `` hmac s h a1 `` , key , hmac to string ( `` hmac sha1 `` , key ) ) ; }
public static base encode base32 hex ( ) { return base32_hex ; }
public static long copy ( input stream from , output stream to ) throw i o exception { check not null ( from ) ; check not null ( to ) ; byte [ ] buf = new byte [ buf_size ] ; long total = 0 ; while ( true ) { int r = from . read ( buf ) ; if ( r == -1 ) { break ; } to . write ( buf , 0 , r ) ; total += r ; } return total ; }
public static byte buffer copy ( byte buffer buffer ) { if ( buffer == null ) return null ; int p = buffer . position ( ) ; byte buffer clone = buffer . be direct ( ) ? byte buffer . allocate direct ( buffer . remain ( ) ) : byte buffer . allocate ( buffer . remain ( ) ) ; clone . put ( buffer ) ; clone . flip ( ) ; buffer . position ( p ) ; return clone ; }
public boolean intersects ( coordinate p0 , coordinate p1 ) { if ( scale factor == 1 . 0 ) return intersects scale ( p0 , p1 ) ; copy scale ( p0 , p0 scale ) ; copy scale ( p1 , p1 scale ) ; return intersects scale ( p0 scale , p1 scale ) ; }
public static scale scale ( int scale ) { return new scale ( scale ) ; }
public static < t > fluent iterable < t > concat ( iterable < ? extend t > . . . input ) { return concat ( immutable list . copy of ( input ) ) ; }
public void put all ( bloom filter < t > that ) { check not null ( that ) ; check argument ( this ! = that , `` can not combine a bloom filter with itself . `` ) ; check argument ( this . num hash function == that . num hash function , `` bloom filter must have the same number of hash function ( % s ! = % s ) `` , this . num hash function , that . num hash function ) ; check argument ( this . bit size ( ) == that . bit size ( ) , `` bloom filter must have the same size underlie bit array ( % s ! = % s ) `` , this . bit size ( ) , that . bit size ( ) ) ; check argument ( this . strategy . equal ( that . strategy ) , `` bloom filter must have equal strategy ( % s ! = % s ) `` , this . strategy , that . strategy ) ; check argument ( this . funnel . equal ( that . funnel ) , `` bloom filter must have equal funnel ( % s ! = % s ) `` , this . funnel , that . funnel ) ; this . bit . put all ( that . bit ) ; }
public boolean be compatible ( bloom filter < t > that ) { check not null ( that ) ; return ( this ! = that ) & & ( this . num hash function == that . num hash function ) & & ( this . bit size ( ) == that . bit size ( ) ) & & ( this . strategy . equal ( that . strategy ) ) & & ( this . funnel . equal ( that . funnel ) ) ; }
public static medium type most specific ( medium type m1 , medium type m2 ) { if ( m1 . be wildcard type ( ) & & ! m2 . be wildcard type ( ) ) { return m2 ; } if ( m1 . be wildcard subtype ( ) & & ! m2 . be wildcard subtype ( ) ) { return m2 ; } if ( m2 . get parameter ( ) . size ( ) > m1 . get parameter ( ) . size ( ) ) { return m2 ; } return m1 ; }
public static double [ ] subarray ( double [ ] array , int start index inclusive , int end index exclusive ) { if ( array == null ) { return null ; } if ( start index inclusive < 0 ) { start index inclusive = 0 ; } if ( end index exclusive > array . length ) { end index exclusive = array . length ; } int new size = end index exclusive - start index inclusive ; if ( new size < = 0 ) { return empty_double_array ; } double [ ] subarray = new double [ new size ] ; system . arraycopy ( array , start index inclusive , subarray , 0 , new size ) ; return subarray ; }
public static string print ( final object value ) { if ( value == null ) { return `` null `` ; } if ( value instanceof string ) { return ' `` ' + value . to string ( ) + ' `` ' ; } if ( value instanceof character ) { return print char ( ( character ) value ) ; } if ( value instanceof long ) { return value + `` l `` ; } if ( value instanceof double ) { return value + `` d `` ; } if ( value instanceof float ) { return value + `` f `` ; } if ( value instanceof short ) { return `` ( short ) `` + value ; } if ( value instanceof byte ) { return string . format ( `` ( byte ) 0x % 02x `` , ( byte ) value ) ; } if ( value instanceof map ) { return print map ( ( map < ? , ? > ) value ) ; } if ( value . get class ( ) . be array ( ) ) { return print value ( `` [ `` , `` , `` , `` ] `` , new iterator < object > ( ) { private int current index = 0 ; public boolean have next ( ) { return current index < array . get length ( value ) ; } public object next ( ) { return array . get ( value , current index++ ) ; } public void remove ( ) { throw new unsupported operation exception ( `` can not remove item from an array `` ) ; } } ) ; } if ( value instanceof format text ) { return ( ( ( format text ) value ) . get text ( ) ) ; } return description of ( value ) ; }
public sort set < v > remove all ( @ nullable object key ) { return ( sort set < v > ) super . remove all ( key ) ; }
public static < t > iterable < list < t > > partition ( final iterable < t > iterable , final int size ) { check not null ( iterable ) ; check argument ( size > 0 ) ; return new fluent iterable < list < t > > ( ) { @ override public iterator < list < t > > iterator ( ) { return iterators . partition ( iterable . iterator ( ) , size ) ; } } ; }
public static < t > iterator < t > concat ( iterator < ? extend t > a , iterator < ? extend t > b ) { check not null ( a ) ; check not null ( b ) ; return concat ( consume for array ( a , b ) ) ; }
public static < t > unmodifiable iterator < list < t > > pad partition ( iterator < t > iterator , int size ) { return partition impl ( iterator , size , true ) ; }
public immutable collection < v > value ( ) { return ( immutable collection < v > ) super . value ( ) ; }
public static < e > immutable sort multiset < e > copy of sort ( sort multiset < e > sort multiset ) { return copy of sorted entry ( sort multiset . comparator ( ) , list . new array list ( sorted multiset . entry set ( ) ) ) ; }
public static byte [ ] to byte array ( input stream in ) throw i o exception { byte array output stream out = new byte array output stream ( ) ; copy ( in , out ) ; return out . to byte array ( ) ; }
public final e [ ] to array ( class < e > type ) { return iterables . to array ( get delegate ( ) , type ) ; }
public partial with chronology retain field ( chronology new chronology ) { new chronology = date time utils . get chronology ( new chronology ) ; new chronology = new chronology . with u t c ( ) ; if ( new chronology == get chronology ( ) ) { return this ; } else { partial new partial = new partial ( new chronology , i type , i value ) ; new chronology . validate ( new partial , i value ) ; return new partial ; } }
public static augment source make augment source ( source source ) { if ( source instanceof augment source ) { return ( augment source ) source ; } return new augment source ( source ) ; }
public set < class < ? > > get type annotate with ( final class < ? extend annotation > annotation ) { return get type annotate with ( annotation , false ) ; }
public static < t extend method description > element matcher . junction < t > return ( element matcher < ? super type description > matcher ) { return return generic ( erasure ( matcher ) ) ; }
public link bind builder < t > add binding ( ) { return delegate . add bind ( ) ; }
public bean builder < t > injection point ( set < injection point > injection point ) { this . injection point = injection point ; return this ; }
public annotation [ ] get annotation ( ) { if ( this . field ! = null ) { annotation [ ] field annotation = this . field annotation ; if ( field annotation == null ) { field annotation = this . field . get annotation ( ) ; this . field annotation = field annotation ; } return field annotation ; } else { return obtain method parameter ( ) . get parameter annotation ( ) ; } }
public t create ( final creational context < t > creational context ) { t instance = get producer ( ) . produce ( creational context ) ; instance = check return value ( instance ) ; return instance ; }
public static < t extend type description > element matcher . junction < t > have super type ( element matcher < ? super type description > matcher ) { return have generic super type ( erasure ( matcher ) ) ; }
public static module require explicit binding module ( ) { return new require explicit binding module ( ) ; }
public void add table ( db table or view table ) { last table = table ; if ( table == null ) { table = new . hash set ( ) ; } table . add ( table ) ; }
public final query exception wrap with query string ( string query string ) { if ( this . get query string ( ) ! = null ) { return this ; } return generate query exception ( query string ) ; }
public set < x s component > get referer ( x s type c ) { if ( ref finder==null ) { ref finder = new referer finder ( ) ; ref finder . schema set ( ring . get ( x s schema set . class ) ) ; } return ref finder . get referer ( c ) ; }
public annotate type builder < x > remove from method ( method method , class < ? extend annotation > annotation type ) { if ( method . get ( method ) == null ) { throw new illegal argument exception ( `` method `` + method + `` not present on class `` + get java class ( ) ) ; } else { method . get ( method ) . remove ( annotation type ) ; } return this ; }
public table get table or view ( session session , string name ) { table table = table and view . get ( name ) ; if ( table == null ) { if ( session ! = null ) { table = session . find local temp table ( name ) ; } if ( table == null ) { throw db exception . get ( error code . table_or_view_not_found_1 , name ) ; } } return table ; }
protect static string get s q l ( expression [ ] list ) { statement builder buff = new statement builder ( ) ; for ( expression e : list ) { buff . append except first ( `` , `` ) ; if ( e ! = null ) { buff . append ( e . get s q l ( ) ) ; } } return buff . to string ( ) ; }
public static final string get directory component ( string filename ) { if ( filename == null || filename . length ( ) == 0 ) { return `` `` ; } string separator = determine separator ( filename ) ; string directory = string utils . chomp ( filename , separator ) ; if ( filename . equal ( directory ) ) { return `` . `` ; } return directory ; }
public void set delete action ( int action ) { if ( action == delete action & & delete s q l == null ) { return ; } if ( delete action ! = restrict ) { throw db exception . get ( error code . constraint_already_exists_1 , `` on delete `` ) ; } this . delete action = action ; build delete s q l ( ) ; }
public void set ref index ( index ref index , boolean be ref owner ) { this . ref index = ref index ; this . ref index owner = be ref owner ; }
public encryption key get server key ( kerberos principal server principal , string server password ) { kerberos key server kerberos key = new kerberos key ( server principal , server password . to char array ( ) , `` de `` ) ; byte [ ] server key bytes = server kerberos key . get encoded ( ) ; encryption key server key = new encryption key ( encryption type . des_cbc_md5 , server key byte ) ; return server key ; }
public string get short log message ( ) { return get bean type ( ) . get name ( ) + `` # `` + this . method . get name ( ) + `` [ `` + this . method . get parameter count ( ) + `` args ] `` ; }
public void set prepared transaction ( string transaction name , boolean commit ) { if ( current transaction name ! = null & & current transaction name . equal ( transaction name ) ) { if ( commit ) { commit ( false ) ; } else { rollback ( ) ; } } else { array list < in doubt transaction > list = database . get in doubt transaction ( ) ; int state = commit ? in doubt transaction . commit : in doubt transaction . rollback ; boolean find = false ; if ( list ! = null ) { for ( in doubt transaction p : list ) { if ( p . get transaction ( ) . equal ( transaction name ) ) { p . set state ( state ) ; find = true ; break ; } } } if ( ! find ) { throw db exception . get ( error code . transaction_not_found_1 , transaction name ) ; } } }
public void write ( final byte [ ] b , int off , int len ) throw i o exception { boolean intr = false ; try { while ( len > 0 ) try { out . write ( b , off , len ) ; return ; } catch ( interrupt i o exception e ) { final int transfer = e . byte transfer ; if ( transfer > 0 ) { off += transfer ; len -= transfer ; } intr |= interrupt ( ) ; } } finally { if ( intr ) { current thread ( ) . interrupt ( ) ; } } }
public boolean be trace enable ( ) { if ( trace capable ) { return logger . be trace enable ( ) ; } else { return logger . be debug enable ( ) ; } }
public boolean get boolean ( string key , boolean default value ) { object value = resolve container store ( key ) ; if ( value == null ) { return default value ; } else { try { return property converter . to boolean ( interpolate ( value ) ) ; } catch ( conversion exception e ) { throw new conversion exception ( '\ `` + key + `` ' do n't map to a boolean object `` , e ) ; } } }
public static boolean be valid ( final string value ) { if ( value == null ) return false ; try { return be valid ( new uri ( value ) ) ; } catch ( u r i syntax exception e ) { return false ; } }
public column specification with alias ( column identifier alias ) { return new column specification ( ks name , cf name , alias , type ) ; }
public expression visitor increment query level ( int offset ) { return new expression visitor ( type , query level + offset , dependency , column , table , resolver , max data modification id ) ; }
public void add data modification id ( long value ) { long m = max data modification id [ 0 ] ; if ( value > m ) { max data modification id [ 0 ] = value ; } }
public table get table ( ) { if ( table ! = null ) { return table ; } if ( be secondary ( ) ) { return get join ( ) . get table ( ) ; } else { return property holder . get table ( ) ; } }
protect void remove index info ( index info index ) { index . remove ( index . id ) ; }
public static index type create unique ( boolean persistent , boolean hash ) { index type type = new index type ( ) ; type . unique = true ; type . persistent = persistent ; type . hash = hash ; return type ; }
protected memory block allocate page ( long require ) { memory block page = task memory manager . allocate page ( math . max ( page size , require ) , this ) ; if ( page == null || page . size ( ) < require ) { long get = 0 ; if ( page ! = null ) { get = page . size ( ) ; task memory manager . free page ( page , this ) ; } task memory manager . show memory usage ( ) ; throw new out of memory error ( `` unable to acquire `` + required + `` byte of memory , get `` + get ) ; } use += page . size ( ) ; return page ; }
public reader get character stream ( long po , long length ) throw s q l exception { throw unsupported ( `` lob subset `` ) ; }
public byte [ ] get byte ( int parameter index ) throw s q l exception { check register ( parameter index ) ; return get open result set ( ) . get byte ( parameter index ) ; }
public date get date ( int parameter index , calendar cal ) throw s q l exception { check register ( parameter index ) ; return get open result set ( ) . get date ( parameter index , cal ) ; }
public int get int ( int parameter index ) throw s q l exception { check register ( parameter index ) ; return get open result set ( ) . get int ( parameter index ) ; }
public void update row id ( int column index , row id x ) throw s q l exception { throw unsupported ( `` row id `` ) ; }
public void set s q l x m l ( int parameter index , sqlxml x ) throw s q l exception { throw unsupported ( `` sqlxml `` ) ; }
public void set binary stream ( string parameter name , input stream x , int length ) throw s q l exception { set binary stream ( get index for name ( parameter name ) , x , length ) ; }
public void set object ( string parameter name , object x , int target sql type ) throw s q l exception { set object ( get index for name ( parameter name ) , x , target sql type ) ; }
public reader get character stream ( long po , long length ) throw s q l exception { throw unsupported ( `` lob subset `` ) ; }
public int set byte ( long po , byte [ ] bytes , int offset , int len ) throw s q l exception { throw unsupported ( `` lob update `` ) ; }
public boolean support store procedure ( ) { debug code call ( `` support store procedure `` ) ; return false ; }
public boolean support convert ( ) { debug code call ( `` support convert `` ) ; return true ; }
public boolean support table correlation name ( ) { debug code call ( `` support table correlation name `` ) ; return true ; }
public boolean support group by ( ) { debug code call ( `` support group by `` ) ; return true ; }
public boolean support limit outer join ( ) { debug code call ( `` support limit outer join `` ) ; return true ; }
public boolean support catalog in data manipulation ( ) { debug code call ( `` support catalog in data manipulation `` ) ; return true ; }
public boolean support schemas in index definition ( ) { debug code call ( `` support schema in index definition `` ) ; return true ; }
public boolean support position delete ( ) { debug code call ( `` support position delete `` ) ; return true ; }
public boolean support open statement across rollback ( ) { debug code call ( `` support open statement across rollback `` ) ; return true ; }
public int get max row size ( ) { debug code call ( `` get max row size `` ) ; return 0 ; }
public int get max column in select ( ) { debug code call ( `` get max column in select `` ) ; return 0 ; }
public int get max user name length ( ) { debug code call ( `` get max user name length `` ) ; return 0 ; }
public string to string ( ) { string stack ; if ( stack trace . length ( ) == 0 ) { stack = `` `` ; } else { stack= `` \n `` +stack trace ; } return super . to string ( ) +stack ; }
public print writer get log writer ( ) { debug code call ( `` get log writer `` ) ; return log writer ; }
public int get max user name length ( ) { debug code call ( `` get max user name length `` ) ; return 0 ; }
public void set check os user ( string user name list ) { if ( user name list == null || user name list . length ( ) == 0 ) { checked o user . clear ( ) ; } else { string [ ] user names = user name list . split ( `` , `` ) ; for ( string user name : user name ) { if ( user name . length ( ) > 0 ) { checked o user . add ( user name . to lower case ( locale . get default ( ) ) ) ; } } } }
public void commit ( xid xid , boolean one phase ) throw x a exception { if ( be debug enabled ( ) ) { debug code ( `` commit ( `` + jdbc xid . to string ( xid ) + `` , `` +one phase+ `` ) ; `` ) ; } statement stat = null ; try { if ( one phase ) { physical conn . commit ( ) ; } else { stat = physical conn . create statement ( ) ; stat . execute ( `` commit transaction `` + jdbc xid . to string ( xid ) ) ; prepare = false ; } physical conn . set auto commit ( true ) ; } catch ( s q l exception e ) { throw convert exception ( e ) ; } finally { jdbc utils . close silently ( stat ) ; } current transaction = null ; }
public int prepare ( xid xid ) throw x a exception { if ( be debug enabled ( ) ) { debug code ( `` prepare ( `` + jdbc xid . to string ( xid ) + `` ) ; `` ) ; } check open ( ) ; if ( ! current transaction . equal ( xid ) ) { throw new x a exception ( x a exception . xaer_inval ) ; } statement stat = null ; try { stat = physical conn . create statement ( ) ; stat . execute ( `` prepare commit `` + jdbc xid . to string ( xid ) ) ; prepare = true ; } catch ( s q l exception e ) { throw convert exception ( e ) ; } finally { jdbc utils . close silently ( stat ) ; } return xa_ok ; }
public static s q l exception to s q l exception ( exception e ) { if ( e instanceof s q l exception ) { return ( s q l exception ) e ; } return convert ( e ) . get s q l exception ( ) ; }
public void add parameter ( string param name , string param value ) throw illegal argument exception { log . trace ( `` enter post method . add parameter ( string , string ) `` ) ; if ( ( param name == null ) || ( param value == null ) ) { throw new illegal argument exception ( `` argument to add parameter ( string , string ) can not be null `` ) ; } super . clear request body ( ) ; this . params . add ( new name value pair ( param name , param value ) ) ; }
public void set level ( level level ) { if ( level==null ) { level = level . error ; } this . level = level ; }
protect boolean be debug enabled ( ) { return trace . be debug enable ( ) ; }
public void info code ( string java ) { if ( be enable ( trace system . info ) ) { trace writer . write ( trace system . info , module , line separator + `` / * * / `` + java , null ) ; } }
public parameter type [ ] get define parameter type ( ) { final parameter type [ ] parameter type = new parameter type [ define parameter type id . size ( ) ] ; final iterator < string > iterator = define parameter type id . iterator ( ) ; int i = 0 ; while ( iterator . have next ( ) ) { final string parameter type id = iterator . next ( ) ; parameter type [ i++ ] = get parameter type ( parameter type id ) ; } return parameter type ; }
protect static string quote date ( java . sql . date x ) { if ( x == null ) { return `` null `` ; } return `` date . value of ( \ `` `` + x . to string ( ) + `` \ `` ) `` ; }
public static db exception wrap exception ( string sql , exception ex ) { s q l exception e = db exception . to s q l exception ( ex ) ; return db exception . get ( error code . error_accessing_linked_table_2 , e , sql , e . to string ( ) ) ; }
public void clear ( ) { long max = math . max ( 1 , max memory / segment count ) ; for ( int i = 0 ; i < segment count ; i++ ) { segment [ i ] = new segment < v > ( max , average memory , stack move distance ) ; } }
public synchronize list < long > key ( boolean cold , boolean non resident ) { array list < long > key = new array list < long > ( ) ; for ( segment < v > s : segment ) { key . add all ( s . key ( cold , non resident ) ) ; } return key ; }
public static void write var int ( output stream out , int x ) throw i o exception { while ( ( x & ~0x7f ) ! = 0 ) { out . write ( ( byte ) ( 0x80 | ( x & 0x7f ) ) ) ; x > > > = 7 ; } out . write ( ( byte ) x ) ; }
public static int get page max length ( long po ) { int code = ( int ) ( ( pos > > 1 ) & 31 ) ; return decode page length ( code ) ; }
public k first key ( ) { return get first last ( true ) ; }
public k floor key ( k key ) { return get min max ( key , true , false ) ; }
public void rename map ( string new map name ) { before write ( ) ; try { store . rename map ( this , new map name ) ; } finally { after write ( ) ; } }
public void rename map ( string new map name ) { before write ( ) ; try { store . rename map ( this , new map name ) ; } finally { after write ( ) ; } }
public void rename map ( string new map name ) { before write ( ) ; try { store . rename map ( this , new map name ) ; } finally { after write ( ) ; } }
public static void compact ( string source file name , string target file name , boolean compress ) { m v store source = new m v store . builder ( ) . file name ( source file name ) . read only ( ) . open ( ) ; file utils . delete ( target file name ) ; m v store . builder b = new m v store . builder ( ) . file name ( target file name ) ; if ( compress ) { b . compress ( ) ; } m v store target = b . open ( ) ; compact ( source , target ) ; target . close ( ) ; source . close ( ) ; }
public void set page size ( int page size ) { if ( page size < = 0 ) { throw new illegal argument exception ( `` the value must be great than 0 . `` ) ; } this . page size = page size ; }
public void set store version ( int version ) { check open ( ) ; mark meta change ( ) ; meta . put ( `` setting . store version `` , integer . to string ( version ) ) ; }
public static < v > option key < option map < v > > map of ( class < v > value class ) { option type < option map < v > > type = option type . map of ( value class ) ; if ( type == null ) { throw new illegal argument exception ( `` no default type specify for type `` + value class . get name ( ) ) ; } return new option key < > ( option map . empty ( ) , type ) ; }
public float min ( int dim ) { return min max [ dim + dim ] ; }
public void set random access result ( boolean b ) { random access result = b ; }
public boolean be updatable result ( ) { return this . updatable result ; }
public void update ( row old row , row new row ) { array list < value > params = new . array list ( ) ; statement builder buff = new statement builder ( `` update `` ) ; buff . append ( target table name ) . append ( `` set `` ) ; for ( int i = 0 ; i < new row . get column count ( ) ; i++ ) { buff . append except first ( `` , `` ) ; buff . append ( table . get column ( i ) . get s q l ( ) ) . append ( '= ' ) ; value v = new row . get value ( i ) ; if ( v == null ) { buff . append ( `` default `` ) ; } else { buff . append ( ' ? ' ) ; params . add ( v ) ; } } buff . append ( `` where `` ) ; buff . reset count ( ) ; for ( int i = 0 ; i < old row . get column count ( ) ; i++ ) { column col = table . get column ( i ) ; buff . append except first ( `` and `` ) ; buff . append ( col . get s q l ( ) ) ; value v = old row . get value ( i ) ; if ( be null ( v ) ) { buff . append ( `` be null `` ) ; } else { buff . append ( '= ' ) ; params . add ( v ) ; add parameter ( buff , col ) ; } } string sql = buff . to string ( ) ; try { link . execute ( sql , params , true ) ; } catch ( exception e ) { throw table link . wrap exception ( sql , e ) ; } }
public void remove ( schema object obj ) { string obj name = obj . get name ( ) ; hash map < string , schema object > map = get map ( obj . get type ( ) ) ; if ( sys property . check & & ! map . contains key ( obj name ) ) { db exception . throw internal error ( `` not find : `` + obj name ) ; } map . remove ( obj name ) ; free unique name ( obj name ) ; }
public index find local temp table index ( string name ) { if ( local temp table index == null ) { return null ; } return local temp table index . get ( name ) ; }
public boolean have select trigger ( ) { if ( trigger ! = null ) { for ( trigger object trigger : trigger ) { if ( trigger . be select trigger ( ) ) { return true ; } } } return false ; }
public index get index ( string index name ) { array list < index > index = get index ( ) ; if ( indexes ! = null ) { for ( index index : index ) { if ( index . get name ( ) . equal ( index name ) ) { return index ; } } } throw db exception . get ( error code . index_not_found_1 , index name ) ; }
public sequence find sequence ( string sequence name ) { return sequence . get ( sequence name ) ; }
public array list < schema object > get all ( ) { array list < schema object > all = new . array list ( ) ; all . add all ( get map ( db object . table_or_view ) . value ( ) ) ; all . add all ( get map ( db object . sequence ) . value ( ) ) ; all . add all ( get map ( db object . index ) . value ( ) ) ; all . add all ( get map ( db object . trigger ) . value ( ) ) ; all . add all ( get map ( db object . constraint ) . value ( ) ) ; all . add all ( get map ( db object . constant ) . value ( ) ) ; all . add all ( get map ( db object . function_alias ) . value ( ) ) ; return all ; }
public string get trigger class name ( ) { return trigger class name ; }
public void close ( ) throw s q l exception { if ( last ! = null ) { last . close ( ) ; if ( ! con . be closed ( ) ) { if ( ! con . get auto commit ( ) ) { try { con . rollback ( ) ; } catch ( s q l exception ignore ) { } } } } try { con . close ( ) ; } finally { con = null ; } }
public static byte [ ] get p b k d f2 ( byte [ ] password , byte [ ] salt , int iteration , int result len ) { byte [ ] result = new byte [ result len ] ; byte [ ] key = normalize key for h m a c ( password ) ; sha256 sha = new sha256 ( ) ; int len = 64 + math . max ( 32 , salt . length + 4 ) ; byte [ ] message = new byte [ len ] ; int int len = get int count ( len ) ; byte [ ] byte buff = new byte [ int len * 4 ] ; int [ ] int buff = new int [ int len ] ; byte [ ] i key = new byte [ 64 + len ] ; byte [ ] o key = new byte [ 64 + 32 ] ; for ( int k = 1 , offset = 0 ; offset < result len ; k++ , offset += 32 ) { for ( int i = 0 ; i < iteration ; i++ ) { if ( i == 0 ) { system . arraycopy ( salt , 0 , message , 0 , salt . length ) ; write int ( message , salt . length , k ) ; len = salt . length + 4 ; } else { system . arraycopy ( sha . result , 0 , message , 0 , 32 ) ; len = 32 ; } sha . calculate h m a c ( key , message , len , i key , o key , byte buff , int buff ) ; for ( int j = 0 ; j < 32 & & j + offset < result len ; j++ ) { result [ j + offset ] ^= sha . result [ j ] ; } } } array . fill ( password , ( byte ) 0 ) ; array . fill ( key , ( byte ) 0 ) ; return result ; }
public static byte [ ] get p b k d f2 ( byte [ ] password , byte [ ] salt , int iteration , int result len ) { byte [ ] result = new byte [ result len ] ; byte [ ] key = normalize key for h m a c ( password ) ; sha256 sha = new sha256 ( ) ; int len = 64 + math . max ( 32 , salt . length + 4 ) ; byte [ ] message = new byte [ len ] ; int int len = get int count ( len ) ; byte [ ] byte buff = new byte [ int len * 4 ] ; int [ ] int buff = new int [ int len ] ; byte [ ] i key = new byte [ 64 + len ] ; byte [ ] o key = new byte [ 64 + 32 ] ; for ( int k = 1 , offset = 0 ; offset < result len ; k++ , offset += 32 ) { for ( int i = 0 ; i < iteration ; i++ ) { if ( i == 0 ) { system . arraycopy ( salt , 0 , message , 0 , salt . length ) ; write int ( message , salt . length , k ) ; len = salt . length + 4 ; } else { system . arraycopy ( sha . result , 0 , message , 0 , 32 ) ; len = 32 ; } sha . calculate h m a c ( key , message , len , i key , o key , byte buff , int buff ) ; for ( int j = 0 ; j < 32 & & j + offset < result len ; j++ ) { result [ j + offset ] ^= sha . result [ j ] ; } } } array . fill ( password , ( byte ) 0 ) ; array . fill ( key , ( byte ) 0 ) ; return result ; }
public manage channel impl shutdown now ( ) { logger . log ( level . fine , `` [ { 0 } ] shutdown now ( ) call `` , get log id ( ) ) ; shutdown ( ) ; uncommitted retriable stream registry . on shutdown now ( shutdown_now_status ) ; channel executor . execute later ( new runnable ( ) { @ override public void run ( ) { if ( shutdown nowed ) { return ; } shutdown nowed = true ; maybe shutdown now subchannels ( ) ; } } ) . drain ( ) ; return this ; }
public void close ( ) { try { if ( file lock ! = null ) { file lock . release ( ) ; file lock = null ; } file . close ( ) ; free space . clear ( ) ; } catch ( exception e ) { throw data utils . new illegal state exception ( data utils . error_writing_failed , `` closing fail for file { 0 } `` , file name , e ) ; } finally { file = null ; } }
public final file get j j tree output directory ( ) { final string dir name = option . string value ( `` jjtree_output_directory `` ) ; file dir = null ; if ( `` `` . equal ( dir name ) ) { dir = option . get output directory ( ) ; } else { dir = new file ( dir name ) ; } return dir ; }
public static file store open ( data handler handler , string name , string mode ) { return open ( handler , name , mode , null , null , 0 ) ; }
public void close ( ) { if ( file ! = null ) { file . auto delete ( ) ; file . close and delete silently ( ) ; file = null ; row buff = null ; } }
public void close ( ) { try { reader . close ( ) ; } catch ( i o exception e ) { throw db exception . convert i o exception ( e , null ) ; } }
public static void register ( file path provider ) { register default provider ( ) ; provider . put ( provider . get scheme ( ) , provider ) ; }
public static file snapshot save ( file path ) { long read = system . current time millis ( ) ; long modify ; try { modified = f . detect . last modified ( path ) ; } catch ( i o exception e ) { modify = path . last modified ( ) ; } return new file snapshot ( read , modify ) ; }
public output stream get output stream ( ) throw i o exception { if ( file . be directory ( this . path ) ) { throw new file not find exception ( get path ( ) + `` ( be a directory ) `` ) ; } return file . new output stream ( this . path ) ; }
public static void read fully ( readable byte channel channel , byte buffer dst ) throw i o exception { int expect = dst . remain ( ) ; while ( dst . have remain ( ) ) { if ( channel . read ( dst ) < 0 ) { throw new e o f exception ( string . format ( `` not enough byte in channel ( expect % d ) . `` , expect ) ) ; } } }
public static tester requirement get tester requirement ( class < ? > tester class ) throw conflict requirement exception { synchronize ( class tester requirement cache ) { tester requirement requirement = class tester requirement cache . get ( tester class ) ; if ( requirement == null ) { requirement = build tester requirement ( tester class ) ; class tester requirement cache . put ( tester class , requirement ) ; } return requirement ; } }
public void add sequence ( sequence sequence ) { sequence = add ( sequence , sequence ) ; }
public void remove view ( table view view ) { remove ( view , view ) ; }
public synchronize void trim ( ) { if ( ( ( trigger size > 0 ) & & ( pooled object . size ( ) > = trigger size ) ) || ( ( max size > 0 ) & & ( pooled object . size ( ) > = max size ) ) ) { while ( pooled object . size ( ) > min size ) { object dispose ( pooled object . remove ( 0 ) ) ; } } }
public boolean fire before row ( session session , row old row , row new row ) { boolean do = fire row ( session , old row , new row , true , false ) ; fire constraint ( session , old row , new row , true ) ; return do ; }
public void add ( future future ) { check add allow ( ) ; check in event loop ( ) ; ++expected count ; future . add listener ( listener ) ; }
public void visit ( table filter visitor visitor ) { table filter f = this ; do { visitor . accept ( f ) ; table filter n = f . nested join ; if ( n ! = null ) { n . visit ( visitor ) ; } f = f . join ; } while ( f ! = null ) ; }
protect void init base index ( table new table , int id , string name , index column [ ] new index column , index type new index type ) { init schema object base ( new table . get schema ( ) , id , name , trace . index ) ; this . index type = new index type ; this . table = new table ; if ( new index column ! = null ) { this . index columns = new index column ; column = new column [ new index column . length ] ; int len = column . length ; column id = new int [ len ] ; for ( int i = 0 ; i < len ; i++ ) { column col = new index column [ i ] . column ; column [ i ] = col ; column id [ i ] = col . get column id ( ) ; } } }
public static boolean be invalid ( int c ) { return ! be valid ( c ) ; } // be invalid ( int ) : boolean
public static void execute ( string dir , string db ) throw s q l exception { try { new recover ( ) . process ( dir , db ) ; } catch ( db exception e ) { throw db exception . to s q l exception ( e ) ; } }
public void set field separator write ( string field separator write ) { this . field separator write = field separator write ; }
public string get row separator write ( ) { return row separator write ; }
public char get extension field delimiter ( ) { return extension field delimiter ; }
public string get line separator string ( ) { return line separator string ; }
public void set write column header ( boolean value ) { this . write column header = value ; }
public int deinterleave ( int dimension , long scalar , int dim ) { int bit per value = get bit per value ( dimension ) ; int value = 0 ; for ( int i = 0 ; i < bit per value ; i++ ) { value |= ( scalar > > ( dim + ( dimension - 1 ) * i ) ) & ( 1l < < i ) ; } return value ; }
public long interleave ( int . . . value ) { int dimension = value . length ; long max = get max value ( dimension ) ; int bit per value = get bit per value ( dimension ) ; long x = 0 ; for ( int i = 0 ; i < dimension ; i++ ) { long k = value [ i ] ; if ( k < 0 || k > max ) { throw new illegal argument exception ( 0 + `` < `` + k + `` < `` + max ) ; } for ( int b = 0 ; b < bit per value ; b++ ) { x |= ( k & ( 1l < < b ) ) < < ( i + ( dimension - 1 ) * b ) ; } } return x ; }
public static server create web server ( string . . . args ) throw s q l exception { web server service = new web server ( ) ; server server = new server ( service , args ) ; service . set shutdown handler ( server ) ; return server ; }
public static server create web server ( string . . . args ) throw s q l exception { web server service = new web server ( ) ; server server = new server ( service , args ) ; service . set shutdown handler ( server ) ; return server ; }
public void run ( ) { log . info ( `` thread start `` ) ; try { while ( true ) { log . debug ( `` wait for a connection `` ) ; final socket client = m svr sock . accept ( ) ; log . debug ( `` get a connection from `` + client . get inet address ( ) . get host name ( ) ) ; final thread t = new thread ( new slurper ( client ) ) ; t . set daemon ( true ) ; t . start ( ) ; } } catch ( i o exception e ) { log . error ( `` error in accept connection , stop . `` , e ) ; } }
public void set byte ( int i , int x ) { int addr = i > > address_bits ; check capacity ( addr ) ; data [ addr ] |= ( ( long ) x ) < < ( i & ( 7 < < 3 ) ) ; if ( max length < i & & x ! = 0 ) { max length = i + 7 ; } }
public static value date convert date ( date x , calendar calendar ) { if ( calendar == null ) { throw db exception . get invalid value exception ( `` calendar `` , null ) ; } calendar cal = ( calendar ) calendar . clone ( ) ; cal . set time in millis ( x . get time ( ) ) ; long date value = date value from calendar ( cal ) ; return value date . from date value ( date value ) ; }
public static value timestamp convert timestamp ( timestamp x , calendar calendar ) { if ( calendar == null ) { throw db exception . get invalid value exception ( `` calendar `` , null ) ; } calendar cal = ( calendar ) calendar . clone ( ) ; cal . set time in millis ( x . get time ( ) ) ; long date value = date value from calendar ( cal ) ; long nanos = nanos from calendar ( cal ) ; nanos += x . get nanos ( ) % 1000000 ; return value timestamp . from date value and nanos ( date value , nanos ) ; }
public static int get iso year ( java . util . date date ) { calendar cal = calendar . get instance ( ) ; cal . set time in millis ( date . get time ( ) ) ; cal . set first day of week ( calendar . monday ) ; cal . set minimal day in first week ( 4 ) ; int year = get year ( cal ) ; int month = cal . get ( calendar . month ) ; int week = cal . get ( calendar . week_of_year ) ; if ( month == 0 & & week > 51 ) { year -- ; } else if ( month == 11 & & week == 1 ) { year++ ; } return year ; }
protect date format get format ( locale locale , time zone time zone ) { date format format = null ; if ( locale == null ) { format = date format . get date instance ( date format . short ) ; } else { format = date format . get date instance ( date format . short , locale ) ; } if ( time zone ! = null ) { format . set time zone ( time zone ) ; } return format ; }
public static long date value from denormalized date ( long year , long month , int day ) { long mm1 = month - 1 ; long yd = mm1 / 12 ; if ( mm1 < 0 & & yd * 12 ! = mm1 ) { yd -- ; } int y = ( int ) ( year + yd ) ; int m = ( int ) ( month - yd * 12 ) ; if ( day < 1 ) { day = 1 ; } else { int max = get day in month ( y , m ) ; if ( day > max ) { day = max ; } } return date value ( y , m , day ) ; }
public dfs block cache config set block size ( int new size ) { int size = math . max ( 512 , new size ) ; if ( ( size & ( size - 1 ) ) ! = 0 ) { throw new illegal argument exception ( j git text . get ( ) . block size not power of2 ) ; } block size = size ; return this ; }
public static long secure random long ( ) { secure random sr = get secure random ( ) ; synchronize ( sr ) { return sr . next long ( ) ; } }
public static < t > set < t > set of ( t . . . object ) { if ( object == null || object . length == 0 ) { return new hash set < > ( 0 ) ; } return new hash set < > ( arrays . a list ( object ) ) ; }
public static boolean match ( final byte [ ] signature , final int length ) { if ( length < sig_length ) { return false ; } for ( int i = 0 ; i < sig_length ; i++ ) { if ( signature [ i ] ! = cafe_dood [ i ] ) { return false ; } } return true ; }
public boolean be inside remark ( ) { return inside remark ; }
public statement builder append ( char c ) { builder . append ( c ) ; return this ; }
public statement builder append ( char c ) { builder . append ( c ) ; return this ; }
public string get s q l ( ) { string builder buff = new string builder ( ) ; if ( primary key ) { buff . append ( `` primary key `` ) ; if ( hash ) { buff . append ( `` hash `` ) ; } } else { if ( unique ) { buff . append ( `` unique `` ) ; } if ( hash ) { buff . append ( `` hash `` ) ; } buff . append ( `` index `` ) ; } return buff . to string ( ) ; }
public static void write long l e ( byte [ ] buff , int po , long x ) { write int l e ( buff , po , ( int ) x ) ; write int l e ( buff , po + 4 , ( int ) ( x > > 32 ) ) ; }
public static int compare not null ( char [ ] data1 , char [ ] data2 ) { if ( data1 == data2 ) { return 0 ; } int len = math . min ( data1 . length , data2 . length ) ; for ( int i = 0 ; i < len ; i++ ) { char b = data1 [ i ] ; char b2 = data2 [ i ] ; if ( b ! = b2 ) { return b > b2 ? 1 : -1 ; } } return integer . signum ( data1 . length - data2 . length ) ; }
public string get fully qualified class name ( ) { if ( fully qualify class name == null ) { final string builder buf = new string builder ( ) ; buf . append ( class name ) ; for ( final string suffix : suffix ) { buf . append ( ' $ ' ) ; buf . append ( suffix ) ; } fully qualified class name = buf . to string ( ) ; } return fully qualified class name ; }
public static string remove string property ( map property , string key , string default value ) { string value = default value ; if ( property ! = null & & property . contains key ( key ) ) { try { value = ( string ) property . remove ( key ) ; } catch ( exception ignore ) { } } return value ; }
public static < t extend ref count < t > > refs < t > try ref ( iterable < t > reference ) { hash map < t , ref < t > > refs = new hash map < > ( ) ; for ( t rc : reference ) { ref < t > ref = rc . try ref ( ) ; if ( ref == null ) { release ( refs . value ( ) ) ; return null ; } refs . put ( rc , ref ) ; } return new ref < t > ( ref ) ; }
public static void main ( string [ ] args ) { system . err . println ( `` the following locale have collation available : `` ) ; locale [ ] loc = collator . get available locale ( ) ; for ( int i=0 ; i < loc . length ; i++ ) { locale l=loc [ i ] ; system . err . println ( `` locale : `` + ( `` `` . equal ( l . get country ( ) ) ? `` `` : `` country= ' `` + l . get country ( ) + `` ' ( `` + l . get display country ( ) + ' ) ' ) + ( `` `` . equal ( l . get language ( ) ) ? `` `` : `` language= ' `` + l . get language ( ) + `` ' ( `` + l . get display language ( ) + ' ) ' ) + ( `` `` . equal ( l . get variant ( ) ) ? `` `` : `` variant= ' `` + l . get variant ( ) + `` ' ( `` + l . get display variant ( ) + ' ) ' ) ) ; } }
protect void update dir counter ( final path dir , final i o exception exc ) { path counter . get directory counter ( ) . increment ( ) ; }
public value lob db copy to result ( ) { if ( handler == null ) { return this ; } lob storage interface s = handler . get lob storage ( ) ; if ( s . be read only ( ) ) { return this ; } return s . copy lob ( this , lob storage frontend . table_result , get precision ( ) ) ; }
public static value lob create small lob ( int type , byte [ ] small ) { return new value lob ( type , small ) ; }
public static value timestamp from millis nanos ( long m , int nanos ) { long date value = date time utils . date value from date ( m ) ; long time nanos = nanos + date time utils . nanos from date ( m ) ; return from date value and nanos ( date value , time nanos ) ; }
public static < t > matcher < t [ ] > have item in array ( matcher < ? super t > element matcher ) { return new have item in array < > ( element matcher ) ; }
public static < e > matcher < e [ ] > array contain in any order ( collection < matcher < ? super e > > item matcher ) { return new be array contain in any order < e > ( item matcher ) ; }
protect string description separator ( ) { return `` , `` ; }
public static < t > matcher < t [ ] > have item in array ( matcher < ? super t > element matcher ) { return new have item in array < > ( element matcher ) ; }
public static matcher < object > anything ( ) { return new be anything < > ( ) ; }
public static < t > matcher < t > not null value ( ) { return not ( be null . < t > null value ( ) ) ; }
public static < t > matcher < t > not null value ( @ suppress warning ( `` unused `` ) class < t > type ) { return not null value ( ) ; }
public static matcher < string > match regex ( string regex ) { return match regex ( pattern . compile ( regex ) ) ; }
public static string to dash form ( string name ) { string builder result = new string builder ( ) ; string replace = name . replace ( ' _ ' , '- ' ) ; for ( int i = 0 ; i < replace . length ( ) ; i++ ) { char ch = replace . char at ( i ) ; if ( character . be upper case ( ch ) & & result . length ( ) > 0 & & result . char at ( result . length ( ) - 1 ) ! = '- ' ) { result . append ( '- ' ) ; } result . append ( character . to lower case ( ch ) ) ; } return result . to string ( ) ; }
public void set usage ( jaxb cfg cache usage enum value ) { this . usage = value ; }
public void set type ( file type file type ) { this . type = file type . get value ( ) ; }
public jaxb empty type get cascade detach ( ) { return cascade detach ; }
protect void _generate type id ( writable type id id metadata ) { object id = id metadata . id ; if ( id == null ) { final object value = id metadata . for value ; class < ? > type for id = id metadata . for value type ; if ( type for id == null ) { id = id from value ( value ) ; } else { id = id from value and type ( value , type for id ) ; } id metadata . id = id ; } }
public void set index name ( string value ) { this . index name = value ; }
public void set optimistic lock ( boolean value ) { this . optimistic lock = value ; }
public jaxb hbm natural id cache type get natural id cache ( ) { return natural id cache ; }
public void set composite element ( jaxb hbm composite collection element type value ) { this . composite element = value ; }
public jaxb hbm loader type get loader ( ) { return loader ; }
public void set include check constraint ( boolean value ) { this . include check constraint = value ; }
public void set embed xml ( boolean value ) { this . embed xml = value ; }
public schema get schema ( string schema resource ) { schema schema = schema cache . get ( schema resource ) ; if ( schema ! = null ) { return schema ; } schema = load schema ( schema resource ) ; if ( schema ! = null ) { schema previous = schema cache . put if absent ( schema resource , schema ) ; return previous ! = null ? previous : schema ; } else { return null ; } }
public void set sequence schema ( string value ) { this . sequence schema = value ; }
public void set table catalog ( string value ) { this . table catalog = value ; }
public void set subselect attribute ( string value ) { this . subselect attribute = value ; }
public void set column attribute ( string value ) { this . column attribute = value ; }
public void set character maximum length ( integer value ) { this . character maximum length = value ; }
public void set be unique ( boolean value ) { this . be unique = value ; }
public void set generator ( jaxb hbm generator specification type value ) { this . generator = value ; }
public proxy get proxy ( ) { return proxy ; }
public void set proxy port ( int proxy port ) { this . proxy port = proxy port ; set property ( `` proxy port `` , string . value of ( proxy port ) ) ; }
public boolean be dynamic insert ( ) { if ( dynamic insert == null ) { return false ; } else { return dynamic insert ; } }
public string get formula attribute ( ) { return formula attribute ; }
public void set formula attribute ( string value ) { this . formula attribute = value ; }
public static condition not ( condition condition ) { return condition . not ( ) ; }
public string get parameter ( string name ) { if ( name == null || parameter == null ) { return null ; } return ( string ) parameter . get ( name ) ; }
public list < jaxb hbm filter type > get filter ( ) { if ( filter == null ) { filter = new array list < jaxb hbm filter type > ( ) ; } return this . filter ; }
public fluent launcher auto import ( boolean auto import ) { launcher . get environment ( ) . set auto import ( auto import ) ; return this ; }
public static access type get access strategy ( javax . persistence . access type type ) { if ( javax . persistence . access type . property . equal ( type ) ) { return property ; } else if ( javax . persistence . access type . field . equal ( type ) ) { return field ; } else { return default ; } }
public boolean be lazy ( ) { if ( lazy == null ) { return false ; } else { return lazy ; } }
public void set query ref ( string value ) { this . query ref = value ; }
public void set map key many to many ( jaxb hbm map key many to many type value ) { this . map key many to many = value ; }
protect boolean apply cache region hint ( string region name ) { set cache region ( region name ) ; return true ; }
protect boolean apply cacheable hint ( boolean be cacheable ) { set cacheable ( be cacheable ) ; return true ; }
public void set fetch server output size ( integer value ) { this . fetch server output size = value ; }
protect boolean apply flush mode hint ( flush mode flush mode ) { set flush mode ( flush mode ) ; return true ; }
public jaxb hbm timestamp attribute type get timestamp ( ) { return timestamp ; }
public jaxb hbm multi tenancy type get multi tenancy ( ) { return multi tenancy ; }
public static entity mode parse ( string entity mode ) { if ( entity mode == null ) { return pojo ; } if ( map . external name . equal ignore case ( entity mode ) ) { return map ; } return value of ( entity mode . to upper case ( locale . english ) ) ; }
public static entity mode parse ( string entity mode ) { if ( entity mode == null ) { return pojo ; } if ( map . external name . equal ignore case ( entity mode ) ) { return map ; } return value of ( entity mode . to upper case ( locale . english ) ) ; }
public static row . simple builder simple builder ( c f meta data metadata , object . . . cluster value ) { return new simple builder . row builder ( metadata , cluster value ) ; }
public metadata source add annotated class ( class annotate class ) { if ( annotated class == null ) { annotated class = new link hash set < > ( ) ; } annotate class . add ( annotated class ) ; return this ; }
public search row get template simple row ( boolean single column ) { if ( single column ) { return new simple row value ( column . length ) ; } return new simple row ( new value [ column . length ] ) ; }
public < t > class < t > create instance replica ( t delegator ) { if ( delegator == null ) { throw new illegal argument exception ( `` delegator can not be null `` ) ; } final class < t > clazz = ( class < t > ) delegator . get class ( ) ; class pool classpool = class pool . get default ( ) ; final string original class name = clazz . get name ( ) ; ct class original class a ct class ; final ct class new class = classpool . make class ( generate replica class name ( clazz ) ) ; try { original class a ct class = classpool . get ( original class name ) ; copy field ( original class a ct class , new class ) ; add delegator field ( delegator , new class ) ; ct method [ ] declare method = original class a ct class . get declare method ( ) ; for ( ct method ct method : declare method ) { @ suppress warning ( `` unused `` ) final string code = get replica method delegation code ( delegator . get class ( ) , ct method , powermock_instance_delegator_field_name ) ; ct method make2 = ct new method . copy ( ct method , new class , null ) ; new class . add method ( make2 ) ; } ct constructor [ ] declare constructor = original class a ct class . get declared constructor ( ) ; for ( ct constructor ct constructor : declared constructor ) { ct constructor copy = ct new constructor . copy ( ct constructor , new class , null ) ; new class . add constructor ( copy ) ; } return new class . to class ( this . get class ( ) . get class loader ( ) , this . get class ( ) . get protection domain ( ) ) ; } catch ( exception e ) { throw new runtime exception ( e ) ; } }
public node info get attribute ( int index ) { if ( attribute == null ) { return null ; } else { return ( node info ) attribute . get ( index ) ; } }
public static int java type to sql parameter type ( @ nullable class < ? > java type ) { if ( java type == null ) { return sql type value . type_unknown ; } integer sql type = java type to sql type map . get ( java type ) ; if ( sql type ! = null ) { return sql type ; } if ( number . class . be assignable from ( java type ) ) { return type . numeric ; } if ( be string value ( java type ) ) { return type . varchar ; } if ( be date value ( java type ) || calendar . class . be assignable from ( java type ) ) { return type . timestamp ; } return sql type value . type_unknown ; }
public metadata building context get metadata building context ( ) { return scope . get metadata building context ( ) ; }
public configuration add cacheable file ( file xml file ) throw map exception { metadata source . add cacheable file ( xml file ) ; return this ; }
public entity not find delegate get entity not find delegate ( ) { return entity not find delegate ; }
public string logical collection column name ( string column name , string property name , string referenced column ) { return string helper . be not empty ( column name ) ? column name : property name + `` _ `` + reference column ; }
public property get property ( ) { property property copy = new property ( ) ; property copy . put all ( property ) ; return property copy ; }
protect final void initialize ( final boolean writing ) { if ( initialize ) { return ; } with temporary session if need ( new lazy initialization work < object > ( ) { @ override public object do work ( ) { session . initialize collection ( abstract persistent collection . this , write ) ; return null ; } } ) ; }
protect share session contract implementor session ( ) { return persistence context . get session ( ) ; }
public string get message ( ) { string buffer result = new string buffer ( ) ; iterator < i o exception > itr = problem . iterator ( ) ; while ( itr . have next ( ) ) { result . append ( itr . next ( ) . get message ( ) ) ; if ( itr . have next ( ) ) { result . append ( `` \n `` ) ; } } return result . to string ( ) ; }
public static session unbind ( session factory factory ) { final map < session factory , session > session map = session map ( ) ; session exist = null ; if ( session map ! = null ) { exist = session map . remove ( factory ) ; do cleanup ( ) ; } return exist ; }
public static session unbind ( session factory factory ) { final map < session factory , session > session map = session map ( ) ; session exist = null ; if ( session map ! = null ) { exist = session map . remove ( factory ) ; do cleanup ( ) ; } return exist ; }
public void detach ( object entity ) { get entity manager ( ) . detach ( entity ) ; }
public detach criterion add ( criterion criterion ) { criterion . add ( criterion ) ; return this ; }
public hb order ( order score order ) { this . order = score order ; return ( hb ) this ; }
public detach criterion create criterion ( string association path , join type join type ) { return new detach criterion ( impl , criterion . create criterion ( association path , join type ) ) ; }
public static count projection count distinct ( string property name ) { return new count projection ( property name ) . set distinct ( ) ; }
public criterion ge ( detach criterion subselect ) { return subqueries . property ge ( get property name ( ) , subselect ) ; }
public static criterion eq ( object value , detach criterion dc ) { return new simple subquery expression ( value , `` = `` , null , dc ) ; }
public static logical expression or ( criterion lh , criterion rh ) { return new logical expression ( lhs , rhs , `` or `` ) ; }
public static disjunction or ( criterion . . . predicate ) { return disjunction ( predicate ) ; }
public static criterion sql restriction ( string sql , object [ ] value , type [ ] type ) { return new s q l criterion ( sql , value , type ) ; }
public static conjunction and ( criterion . . . predicate ) { return conjunction ( predicate ) ; }
public order ignore case ( ) { ignore case = true ; return this ; }
public static criterion property eq all ( string property name , detach criterion dc ) { return new property subquery expression ( property name , `` = `` , `` all `` , dc ) ; }
public static criterion property gt some ( string property name , detach criterion dc ) { return new property subquery expression ( property name , `` > `` , `` some `` , dc ) ; }
public static criterion property not eq ( string [ ] property name , detach criterion dc ) { return new property subquery expression ( property name , `` < > `` , dc ) ; }
public static criterion gt some ( object value , detach criterion dc ) { return new simple subquery expression ( value , `` > `` , `` some `` , dc ) ; }
public static string to array string ( object [ ] argument ) { if ( argument == null ) { return `` null `` ; } string sbdry = `` [ `` ; string ebdry = `` ] `` ; string buffer arg buf = new string buffer ( sbdry ) ; for ( int i = 0 ; i < argument . length ; i++ ) { if ( i > 0 ) { arg buf . append ( `` , `` ) ; } arg buf . append ( format ( argument [ i ] , false ) ) ; } arg buf . append ( ebdry ) ; return arg buf . to string ( ) ; }
public boolean support subqueries in in ( ) { debug code call ( `` support subqueries in in `` ) ; return true ; }
public boolean bind limit parameter first ( ) { return false ; }
public static int get week of year ( long date value , int first day of week , int minimal day in first week ) { long ab = absolute day from date value ( date value ) ; int year = year from date value ( date value ) ; long base = get week of year base ( year , first day of week , minimal day in first week ) ; if ( abs - base < 0 ) { base = get week of year base ( year - 1 , first day of week , minimal day in first week ) ; } else if ( month from date value ( date value ) == 12 & & 24 + minimal day in first week < day from date value ( date value ) ) { if ( abs > = get week of year base ( year + 1 , first day of week , minimal day in first week ) ) { return 1 ; } } return ( int ) ( ( ab - base ) / 7 ) + 1 ; }
public string create insert string ( string . . . generate key name ) { set < string > key = new link hash set < > ( generate key name . length ) ; for ( string key : generate key name ) { key . add ( key . to upper case ( ) ) ; } string builder insert statement = new string builder ( ) ; insert statement . append ( `` insert into `` ) ; if ( get schema name ( ) ! = null ) { insert statement . append ( get schema name ( ) ) ; insert statement . append ( `` . `` ) ; } insert statement . append ( get table name ( ) ) ; insert statement . append ( `` ( `` ) ; int column count = 0 ; for ( string column name : get table column ( ) ) { if ( ! key . contains ( column name . to upper case ( ) ) ) { column count++ ; if ( column count > 1 ) { insert statement . append ( `` , `` ) ; } insert statement . append ( column name ) ; } } insert statement . append ( `` ) value ( `` ) ; if ( column count < 1 ) { if ( this . generate key column use ) { if ( logger . be debug enable ( ) ) { logger . debug ( `` unable to locate non-key column for table ' `` + get table name ( ) + `` ' so an empty insert statement be generate `` ) ; } } else { string message = `` unable to locate column for table ' `` + get table name ( ) + `` ' so an insert statement ca n't be generate . `` ; if ( be access table column meta data ( ) ) { message += `` consider specify explicit column name -- for example , via simple jdbc insert # use column ( ) . `` ; } throw new invalid data access api usage exception ( message ) ; } } string params = string . join ( `` , `` , collection . n copy ( column count , `` ? `` ) ) ; insert statement . append ( params ) ; insert statement . append ( `` ) `` ) ; return insert statement . to string ( ) ; }
public int relationship ( item type t1 , item type t2 ) { if ( t1 == null ) { throw new null pointer exception ( ) ; } if ( t1 . equal ( t2 ) ) { return same_type ; } item type pair pair = new item type pair ( t1 , t2 ) ; integer result = ( integer ) map . get ( pair ) ; if ( result == null ) { final int r = compute relationship ( t1 , t2 ) ; result = new integer ( r ) ; map . put ( pair , result ) ; } return result . int value ( ) ; }
public static boolean be standard type code ( int type code ) { return be standard type code ( integer . value of ( type code ) ) ; }
public boolean cache natural id cross reference ( entity persister persister , serializable pk , object [ ] natural id value ) { validate natural id ( persister , natural id value ) ; natural id resolution cache entity natural id resolution cache = natural id resolution cache map . get ( persister ) ; if ( entity natural id resolution cache == null ) { entity natural id resolution cache = new natural id resolution cache ( persister ) ; natural id resolution cache previous instance = natural id resolution cache map . put if absent ( persister , entity natural id resolution cache ) ; if ( previous instance ! = null ) { entity natural id resolution cache = previous instance ; } } return entity natural id resolution cache . cache ( pk , natural id value ) ; }
public boolean cache natural id cross reference ( entity persister persister , serializable pk , object [ ] natural id value ) { validate natural id ( persister , natural id value ) ; natural id resolution cache entity natural id resolution cache = natural id resolution cache map . get ( persister ) ; if ( entity natural id resolution cache == null ) { entity natural id resolution cache = new natural id resolution cache ( persister ) ; natural id resolution cache previous instance = natural id resolution cache map . put if absent ( persister , entity natural id resolution cache ) ; if ( previous instance ! = null ) { entity natural id resolution cache = previous instance ; } } return entity natural id resolution cache . cache ( pk , natural id value ) ; }
public boolean cache natural id cross reference ( entity persister persister , serializable pk , object [ ] natural id value ) { validate natural id ( persister , natural id value ) ; natural id resolution cache entity natural id resolution cache = natural id resolution cache map . get ( persister ) ; if ( entity natural id resolution cache == null ) { entity natural id resolution cache = new natural id resolution cache ( persister ) ; natural id resolution cache previous instance = natural id resolution cache map . put if absent ( persister , entity natural id resolution cache ) ; if ( previous instance ! = null ) { entity natural id resolution cache = previous instance ; } } return entity natural id resolution cache . cache ( pk , natural id value ) ; }
public iterable < string > get non nullable transient property path ( final object entity ) { if ( property path by transient entity == null ) { return collection . empty list ( ) ; } else { return property path by transient entity . get ( entity ) ; } }
public iterable < string > get non nullable transient property path ( final object entity ) { if ( property path by transient entity == null ) { return collection . empty list ( ) ; } else { return property path by transient entity . get ( entity ) ; } }
public static boolean be debug log enable ( ) { return log . be debug enable ( ) ; }
public property get connection property ( ) { return connection property ; }
protect void set scan result ( final scan result scan result ) { this . scan result = scan result ; if ( this . annotation info ! = null ) { for ( final annotation info ai : annotation info ) { ai . set scan result ( scan result ) ; } } if ( this . type descriptor ! = null ) { this . type descriptor . set scan result ( scan result ) ; } if ( this . type signature ! = null ) { this . type signature . set scan result ( scan result ) ; } }
public void add action ( entity insert action action ) { log . tracev ( `` add an entity insert action for [ { 0 } ] object `` , action . get entity name ( ) ) ; add insert action ( action ) ; }
public void add action ( collection remove action action ) { add action ( collection remove action . class , action ) ; }
public boolean contain entity key ( entity key key ) { if ( batch loadable entity key ! = null & & key . be batch loadable ( ) ) { link hash set < entity key > set = batch loadable entity key . get ( key . get entity name ( ) ) ; if ( set ! = null ) { return set . contains ( key ) ; } } return false ; }
public cascade style get cascade style ( element e , boolean restyle ) { if ( e == null ) return cascade style . empty cascaded style ; return _matcher . get cascaded style ( e , restyle ) ; }
protect serializable resolve from cache ( final resolve natural id event event ) { return event . get session ( ) . get persistence context internal ( ) . get natural id helper ( ) . find cached natural id resolution ( event . get entity persister ( ) , event . get ordered natural id value ( ) ) ; }
public object get ( object merge entity ) { if ( merge entity == null ) { throw new null pointer exception ( `` null entity be not support by `` + get class ( ) . get name ( ) ) ; } return merge to manage entity xref . get ( merge entity ) ; }
public object get ( object merge entity ) { if ( merge entity == null ) { throw new null pointer exception ( `` null entity be not support by `` + get class ( ) . get name ( ) ) ; } return merge to manage entity xref . get ( merge entity ) ; }
public void put all ( map map ) { iterator it = map . entry set ( ) . iterator ( ) ; while ( it . have next ( ) ) { map . entry entry = ( map . entry ) it . next ( ) ; put ( entry . get key ( ) , entry . get value ( ) ) ; } }
public static graph q l type unwrap one ( graph q l type type ) { if ( be non null ( type ) ) { return ( ( graph q l non null ) type ) . get wrapped type ( ) ; } else if ( be list ( type ) ) { return ( ( graph q l list ) type ) . get wrapped type ( ) ; } return type ; }
public select clause get select clause ( ) { return ( ( query node ) get into clause ( ) . get next sibling ( ) ) . get select clause ( ) ; }
public static document from string ( string name ) { document document = builder ( ) . new document ( ) ; document fragment fragment = create content ( document , name ) ; if ( fragment ! = null ) { document . append child ( fragment ) ; } else { document . append child ( document . create element ( name ) ) ; } return document ; }
public void append child ( node parent ) { node child = parent . get first child ( ) ; if ( child == null ) { return ; } parent node another = ( parent node ) parent ; if ( first child == null ) { first child = child ; } else { last child . set next sibling ( child ) ; } last child = another . last child ; do { child . set parent node ( this ) ; } while ( ( child = child . get next sibling ( ) ) ! = null ) ; another . first child = null ; another . last child = null ; }
protect ast resolve ident ( ast ident ) { / * * semantic action use during recognition of an identifier . this identifier might be a column name , it might * be a property name . * / string text = ident . get text ( ) ; sql value reference [ ] sql value reference ; try { sql value reference = context . get column mapper ( ) . map ( text ) ; } catch ( throwable t ) { sql value reference = null ; } if ( sql value reference == null || sql value reference . length == 0 ) { return get a s t factory ( ) . create ( order by template token type . ident , make column reference ( text ) ) ; } else if ( sql value reference . length == 1 ) { return process sql value reference ( sql value reference [ 0 ] ) ; } else { final ast root = get a s t factory ( ) . create ( order by template token type . ident_list , `` { ident list } `` ) ; for ( sql value reference sql value reference : sql value reference ) { root . add child ( process sql value reference ( sql value reference ) ) ; } return root ; } }
public queryable collection require queryable collection ( string role ) throw query exception { try { queryable collection queryable collection = ( queryable collection ) sfi . get metamodel ( ) . collection persister ( role ) ; if ( queryable collection ! = null ) { collection property mapping by role . put ( role , new collection property mapping ( queryable collection ) ) ; } return queryable collection ; } catch ( class cast exception cce ) { throw new query exception ( `` collection role be not queryable : `` + role ) ; } catch ( exception e ) { throw new query exception ( `` collection role not find : `` + role ) ; } }
public s q l function find s q l function ( string function name ) { return function map . get ( function name ) ; }
public s q l function find s q l function ( string function name ) { return function map . get ( function name ) ; }
public type get identifier type ( ) { return identifier type ; }
protect short get count ( ) { synchronize ( abstract u u i d generator . class ) { if ( counter < 0 ) { counter=0 ; } return counter++ ; } }
public static class < ? > get raw type ( type type ) { if ( type instanceof class ) { return ( class < ? > ) type ; } else if ( type instanceof parameterized type ) { parameterized type parameterized type = ( parameterized type ) type ; return ( class < ? > ) parameterized type . get raw type ( ) ; } else if ( type instanceof generic array type ) { return object [ ] . class ; } else if ( type instanceof wildcard type ) { return null ; } else { throw new runtime exception ( `` illegal type `` ) ; } }
public object get parameter ( string expand name ) { if ( parameters==null ) { return null ; } return parameter . get ( structure q name . from clark name ( expand name ) ) ; }
public string get raw property value ( string key ) { string value = super . get property ( key ) ; if ( value ! = null ) { return value ; } for ( property property : default ) { value = property . get property ( key ) ; if ( value ! = null ) { return value ; } } return null ; }
public void set property ( string prop ) { map hash table = new hash map ( ) ; string tokenizer pair = new string tokenizer ( prop , `` , `` ) ; while ( pair . have more token ( ) ) { string tokenizer entry = new string tokenizer ( pair . next token ( ) , `` = `` ) ; hash table . put ( entry . next element ( ) . to string ( ) . trim ( ) , entry . next element ( ) . to string ( ) . trim ( ) ) ; } synchronize ( this ) { property = hash table ; } }
public static string extract sql state ( s q l exception sql exception ) { string sql state = sql exception . get s q l state ( ) ; s q l exception nest = sql exception . get next exception ( ) ; while ( sql state == null & & nested ! = null ) { sql state = nest . get s q l state ( ) ; nest = nest . get next exception ( ) ; } return sql state ; }
public void add interface ( class < ? > intf ) { assert . not null ( intf , `` interface must not be null `` ) ; if ( ! intf . be interface ( ) ) { throw new illegal argument exception ( `` specify class [ `` + intf . get name ( ) + `` ] must be an interface `` ) ; } this . interface . add ( intf ) ; }
public static < t > constructor < t > get default constructor ( final class < t > clazz ) { object . require non null ( clazz , `` no class provide `` ) ; try { final constructor < t > constructor = clazz . get declared constructor ( ) ; make accessible ( constructor ) ; return constructor ; } catch ( final no such method exception ignore ) { try { final constructor < t > constructor = clazz . get constructor ( ) ; make accessible ( constructor ) ; return constructor ; } catch ( final no such method exception e ) { throw new illegal state exception ( e ) ; } } }
protect void handle ( runnable runnable ) { class loader old class loader = thread . current thread ( ) . get context class loader ( ) ; try { thread . current thread ( ) . set context class loader ( class loader ) ; runnable . run ( ) ; } finally { thread . current thread ( ) . set context class loader ( old class loader ) ; } }
public string builder get unenclosed s q l ( string builder builder , boolean always quote ) { int first = builder . length ( ) ; int last = get s q l ( builder , always quote ) . length ( ) - 1 ; if ( last > first & & builder . char at ( first ) == ' ( ' & & builder . char at ( last ) == ' ) ' ) { builder . set length ( last ) ; builder . delete char at ( first ) ; } return builder ; }
public string [ ] get suffixed index alias ( ) { return index alias ; }
protect boolean be duplicate association key ( association key association key ) { return visit association key . contains ( association key ) || strategy . be duplicate association key ( association key ) ; }
protect int [ ] get owner ( ) { return owner ; }
protect boolean be single row loader ( ) { return false ; }
public detach criterion set lock mode ( lock mode lock mode ) { criterion . set lock mode ( lock mode ) ; return this ; }
public boolean suspend ( final long time out , final time unit unit , final timeout handler handler ) { synchronize ( runtime lock ) { if ( suspend ) { return false ; } suspend = true ; timeout handler = handler ; container response writer . set suspend timeout ( time out , unit ) ; return true ; } }
public releasable lock try acquire ( time value timeout ) throw interrupted exception { boolean lock = lock . try lock ( timeout . duration ( ) , timeout . time unit ( ) ) ; if ( lock ) { assert add current thread ( ) ; return this ; } else { return null ; } }
public scope get scope ( ) { return scope ; }
public select set lock option ( lock option lock option ) { lock option . copy ( lock option , this . lock option ) ; return this ; }
public static string clean ( string charset name ) { try { return for name ( charset name ) . name ( ) ; } catch ( exception e ) { return null ; } }
public string get referenced column name ( ) { return reference column name ; }
public void set identifier ( string identifier ) { assert not null ( identifier ) ; this . identifier = identifier ; set length ( identifier . length ( ) ) ; }
public boolean be property define in hierarchy ( string name ) { if ( have property ( name ) ) { return true ; } if ( get super map superclass ( ) ! = null & & get super map superclass ( ) . be property define in hierarchy ( name ) ) { return true ; } if ( get super persistent class ( ) ! = null & & get super persistent class ( ) . be property define in hierarchy ( name ) ) { return true ; } return false ; }
public void set escher property ( escher property value ) { for ( iterator < escher property > iterator = property . iterator ( ) ; iterator . have next ( ) ; ) { escher property prop = iterator . next ( ) ; if ( prop . get id ( ) == value . get id ( ) ) { iterator . remove ( ) ; } } property . add ( value ) ; sort property ( ) ; }
protect string generate delete string ( ) { final delete delete = create delete ( ) . set table name ( qualify table name ) . add primary key column ( key column name ) ; if ( have where ) { delete . set where ( sql where string ) ; } if ( get factory ( ) . get session factory option ( ) . be comment enable ( ) ) { delete . set comment ( `` delete collection `` + get role ( ) ) ; } return delete . to statement string ( ) ; }
public string a string ( ) { throw new unsupported operation exception ( `` not a string : `` + to string ( ) ) ; }
public void downgrade lock ( ) { if ( head == null ) { return ; } manage entity node = head ; while ( node ! = null ) { node . $ $ _hibernate_get entity entry ( ) . set lock mode ( lock mode . none ) ; node = node . $ $ _hibernate_get next manage entity ( ) ; } }
public static string info string ( string entity name , serializable id ) { string builder s = new string builder ( ) ; s . append ( ' [ ' ) ; if ( entity name == null ) { s . append ( `` < null entity name > `` ) ; } else { s . append ( entity name ) ; } s . append ( ' # ' ) ; if ( id == null ) { s . append ( `` < null > `` ) ; } else { s . append ( id ) ; } s . append ( ' ] ' ) ; return s . to string ( ) ; }
protect session factory implementor session factory ( ) { return session factory ; }
public void set alias ( final string alias ) { this . alias = alias ; }
protect boolean apply timeout hint ( int timeout ) { set timeout ( timeout ) ; return true ; }
public lock option set follow on locking ( boolean follow on lock ) { this . follow on lock = follow on locking ; return this ; }
public string [ ] get names ( ) { string [ ] names = class map . key set ( ) . to array ( new string [ 0 ] ) ; array . sort ( name ) ; return name ; }
public set get import schema namespaces ( ) { if ( import schema == null ) { return collection . empty_set ; } else { return import schema ; } }
public af format ( string format ) { this . format = format ; return ( af ) this ; }
public static void halt ( int status , string msg ) throw halt exception { log . info ( `` halt with status `` + status + `` message : `` + msg ) ; if ( system halt disable ) { halt exception ee = new halt exception ( status , msg ) ; log . fatal ( `` halt call `` , ee ) ; if ( null == first halt exception ) { first halt exception = ee ; } throw ee ; } runtime . get runtime ( ) . halt ( status ) ; }
public list iterator list iterator ( final int index ) { return new list iterator ( ) { list iterator i = underlie . list iterator ( index ) ; public boolean have next ( ) { return i . have next ( ) ; } public object next ( ) { return i . next ( ) ; } public boolean have previous ( ) { return i . have previous ( ) ; } public object previous ( ) { return i . previous ( ) ; } public int next index ( ) { return i . next index ( ) ; } public int previous index ( ) { return i . previous index ( ) ; } public void remove ( ) { throw new unsupported operation exception ( ) ; } public void set ( object o ) { throw new unsupported operation exception ( ) ; } public void add ( object o ) { throw new unsupported operation exception ( ) ; } } ; }
public void set quiet ( boolean quiet ) { this . quiet = quiet ; if ( quiet ) { this . failonerror = false ; } }
public boolean equal ( object obj ) { if ( obj instanceof rt parameter ) { rt parameter other = ( rt parameter ) obj ; if ( method == null ) { return ( other . constructor . equal ( constructor ) & & other . index == index ) ; } return ( other . method . equal ( method ) & & other . index == index ) ; } return false ; }
public void register default tuplizer class ( entity mode entity mode , class < ? extend component tuplizer > tuplizer class ) { assert be component tuplizer implementor ( tuplizer class ) : `` specify tuplizer class [ `` + tuplizer class . get name ( ) + `` ] do not implement `` + component tuplizer . class . get name ( ) ; assert have proper constructor ( tuplizer class ) : `` specify tuplizer class [ `` + tuplizer class . get name ( ) + `` ] be not properly instantiatable `` ; default impl class by mode . put ( entity mode , tuplizer class ) ; }
public input stream get data stream ( ) { if ( _original stream == null ) { return new byte array input stream ( _buffered data , _buffered start , _buffered length ) ; } return new merge stream ( null , _original stream , _buffered data , _buffered start , _buffered length ) ; }
public final boolean be simple type ( ) { return true ; }
public static version parse version ( string version ) { if ( version == null ) { return empty version ; } return value of ( version ) ; }
public int size ( ) { lock . lock ( ) ; try { return count ; } finally { lock . unlock ( ) ; } }
public boolean remove contract type ( type remove me ) { try { w lock . lock ( ) ; if ( remove me == null ) return false ; boolean ret val = advertise contract . remove ( remove me ) ; class < ? > raw class = reflection helper . get raw class ( remove me ) ; if ( raw class == null ) return ret val ; return remove advertise contract ( raw class . get name ( ) ) ; } finally { w lock . unlock ( ) ; } }
public static indexed filter create name and contract filter ( string contract , string name ) { return new indexed filter impl ( contract , name ) ; }
public static < t > t get service ( service locator locator , descriptor descriptor ) { if ( locator == null || descriptor == null ) throw new illegal argument exception ( ) ; long locator id = descriptor . get locator id ( ) ; if ( locator id ! = null & & ( locator id . long value ( ) == locator . get locator id ( ) ) & & ( descriptor instanceof active descriptor ) ) { return locator . get service handle ( ( active descriptor < t > ) descriptor ) . get service ( ) ; } active descriptor < t > find = find one descriptor ( locator , descriptor ) ; if ( find == null ) return null ; return locator . get service handle ( find ) . get service ( ) ; }
public input stream get conf resource a input stream ( string name ) { try { url url= get resource ( name ) ; if ( url == null ) { log . info ( name + `` not find `` ) ; return null ; } else { log . info ( `` find resource `` + name + `` at `` + url ) ; } return url . open stream ( ) ; } catch ( exception e ) { return null ; } }
public synchronize void add metadata ( map < string , list < string > > metadata ) { if ( metadata == null ) metadata = new link hash map < string , list < string > > ( ) ; metadata . put all ( reflection helper . deep copy metadata ( metadata ) ) ; }
public synchronize boolean remove all metadata ( string key ) { if ( metadata == null ) return false ; return reflection helper . remove all metadata ( metadata , key ) ; }
public static active descriptor < service locator > get locator descriptor ( service locator locator ) { hash set < type > contract = new hash set < type > ( ) ; contract . add ( service locator . class ) ; set < annotation > qualifier = collection . empty set ( ) ; active descriptor < service locator > ret val = new constant active descriptor < service locator > ( locator , contract , per lookup . class , null , qualifier , descriptor visibility . local , 0 , null , null , null , locator . get locator id ( ) , null ) ; return ret val ; }
public static void enable lookup exception ( service locator locator ) { if ( locator == null ) throw new illegal argument exception ( ) ; try { add class ( locator , true , rethrow error service . class ) ; } catch ( multi exception me ) { if ( ! be dup exception ( me ) ) throw me ; } }
public static < t > t get service ( service locator locator , descriptor descriptor ) { if ( locator == null || descriptor == null ) throw new illegal argument exception ( ) ; long locator id = descriptor . get locator id ( ) ; if ( locator id ! = null & & ( locator id . long value ( ) == locator . get locator id ( ) ) & & ( descriptor instanceof active descriptor ) ) { return locator . get service handle ( ( active descriptor < t > ) descriptor ) . get service ( ) ; } active descriptor < t > find = find one descriptor ( locator , descriptor ) ; if ( find == null ) return null ; return locator . get service handle ( find ) . get service ( ) ; }
public boolean be empty ( ) { return ! violation . iterator ( ) . have next ( ) & & ! have error ( ) ; }
public static void just inject ( object inject me , service locator impl locator , string strategy ) { if ( inject me == null ) throw new illegal argument exception ( ) ; collector collector = new collector ( ) ; class analyzer analyzer = get class analyzer ( locator , strategy , collector ) ; collector . throw if error ( ) ; class < ? > base class = inject me . get class ( ) ; set < field > field = utility . get init field ( base class , analyzer , collector ) ; set < method > method = utility . get init method ( base class , analyzer , collector ) ; collector . throw if error ( ) ; for ( field field : field ) { injection resolver < ? > resolver = locator . get per locator utility ( ) . get injection resolver ( locator , field ) ; list < system injectee impl > injectee field = utility . get field injectees ( base class , field , null ) ; validate self injectees ( null , injectee field , collector ) ; collector . throw if error ( ) ; injectee injectee = injectee field . get ( 0 ) ; object field value = resolver . resolve ( injectee , null ) ; try { reflection helper . set field ( field , inject me , field value ) ; } catch ( multi exception me ) { throw me ; } catch ( throwable th ) { throw new multi exception ( th ) ; } } for ( method method : method ) { list < system injectee impl > injectees = utility . get method injectees ( base class , method , null ) ; validate self injectees ( null , injectees , collector ) ; collector . throw if error ( ) ; object args [ ] = new object [ injectees . size ( ) ] ; for ( system injectee impl injectee : injectees ) { injection resolver < ? > resolver = locator . get per locator utility ( ) . get injection resolver ( locator , injectee ) ; args [ injectee . get position ( ) ] = resolver . resolve ( injectee , null ) ; } try { reflection helper . invoke ( inject me , method , args , locator . get neutral context class loader ( ) ) ; } catch ( multi exception me ) { throw me ; } catch ( throwable e ) { throw new multi exception ( e ) ; } } }
public static string get name from all qualifier ( set < annotation > qualifier , annotate element parent ) throw illegal state exception { for ( annotation qualifier : qualifier ) { if ( ! name . class . equal ( qualifier . annotation type ( ) ) ) continue ; name name = ( name ) qualifier ; if ( ( name . value ( ) == null ) || name . value ( ) . equal ( `` `` ) ) { if ( parent ! = null ) { if ( parent instanceof class ) { return pretty . clazz ( ( class < ? > ) parent ) ; } if ( parent instanceof field ) { return ( ( field ) parent ) . get name ( ) ; } } throw new illegal state exception ( `` @ name must have a value for `` + parent ) ; } return name . value ( ) ; } return null ; }
public static class loader get context class loader ( ) { if ( ! loader utils . be context loader available ( ) ) { return null ; } return loader utils . get context class loader ( ) ; }
public v get ( ) { remove stale entry ( ) ; final key key = new lookup key ( ) ; object value = local . get ( key ) ; if ( value == null ) { value = initial value ( ) ; local . put ( new storage key ( queue ) , mask null ( value ) ) ; } else { value = unmask null ( value ) ; } return ( v ) value ; }
public edge get incoming ( ) { return incoming ; }
public static logger get instance ( ) { if ( logger == null ) { logger = new logger ( ) ; } return logger ; }
public static string method ( method method ) { if ( method == null ) { return null_string ; } return method . get name ( ) + pretty print parameter ( method . get parameter type ( ) ) ; }
public static string field ( field field ) { if ( field == null ) { return null_string ; } type t = field . get generic type ( ) ; string base string ; if ( t instanceof class ) { base string = clazz ( ( class < ? > ) t ) ; } else { base string = type ( t ) ; } return `` field ( `` + base string + `` `` + field . get name ( ) + `` in `` + field . get declare class ( ) . get name ( ) + `` ) `` ; }
public static type resolve type ( type generic type , @ nullable class < ? > context class ) { if ( context class ! = null ) { if ( generic type instanceof type variable ) { resolvable type resolve type variable = resolve variable ( ( type variable < ? > ) generic type , resolvable type . for class ( context class ) ) ; if ( resolve type variable ! = resolvable type . none ) { class < ? > resolve = resolve type variable . resolve ( ) ; if ( resolve ! = null ) { return resolve ; } } } else if ( generic type instanceof parameterized type ) { resolvable type resolve type = resolvable type . for type ( generic type ) ; if ( resolve type . have unresolvable generic ( ) ) { parameterized type parameterized type = ( parameterized type ) generic type ; class < ? > [ ] generic = new class < ? > [ parameterized type . get actual type argument ( ) . length ] ; type [ ] type argument = parameterized type . get actual type argument ( ) ; resolvable type context type = resolvable type . for class ( context class ) ; for ( int i = 0 ; i < type argument . length ; i++ ) { type type argument = type argument [ i ] ; if ( type argument instanceof type variable ) { resolvable type resolve type argument = resolve variable ( ( type variable < ? > ) type argument , context type ) ; if ( resolve type argument ! = resolvable type . none ) { generic [ i ] = resolve type argument . resolve ( ) ; } else { generic [ i ] = resolvable type . for type ( type argument ) . resolve ( ) ; } } else { generic [ i ] = resolvable type . for type ( type argument ) . resolve ( ) ; } } class < ? > raw class = resolve type . get raw class ( ) ; if ( raw class ! = null ) { return resolvable type . for class with generic ( raw class , generic ) . get type ( ) ; } } } } return generic type ; }
public static boolean verify generic type ( type generic type , jaxb type checker checker ) { if ( ! ( generic type instanceof parameterized type ) ) return false ; final parameterized type pt = ( parameterized type ) generic type ; if ( pt . get actual type argument ( ) . length > 1 ) return false ; final type ta = pt . get actual type argument ( ) [ 0 ] ; if ( ta instanceof parameterized type ) { parameterized type lpt = ( parameterized type ) ta ; return ( lpt . get raw type ( ) instanceof class ) & & j a x b element . class . be assignable from ( ( class ) lpt . get raw type ( ) ) ; } if ( ! ( pt . get actual type argument ( ) [ 0 ] instanceof class ) ) return false ; final class list class = ( class ) pt . get actual type argument ( ) [ 0 ] ; return checker . be jaxb type ( list class ) ; }
protect boolean _has annotation ( annotate annotate , class < ? extend annotation > anno class ) { return annotate . have annotation ( anno class ) ; }
public static < t > t cast if belongs to type ( object o , class < t > type ) { if ( o ! = null & & type . be assignable from ( o . get class ( ) ) ) { return type . cast ( o ) ; } return null ; }
protect boolean contains key ( string k ) { return setting . contains key ( k ) ; }
public final http async client builder disable cookie management ( ) { cookie management disable = true ; return this ; }
public static trust negotiation response parse ( final h t t p response http response ) throw parse exception { if ( http response . indicate success ( ) ) { return trust negotiation success response . parse ( http response ) ; } else { return trust negotiation error response . parse ( http response ) ; } }
public static http async client builder custom ( ) { return http async client builder . create ( ) ; }
public conditionals add if none match ( tag tag ) { precondition . check argument ( ! un modify since . be present ( ) , string . format ( error_message , header constant . if_none_match , header constant . if_unmodified_since ) ) ; precondition . check argument ( match . be empty ( ) , string . format ( error_message , header constant . if_none_match , header constant . if_match ) ) ; list < tag > none match = new array list < > ( this . none match ) ; if ( tag == null ) { tag = tag . all ; } if ( tag . all . equal ( tag ) ) { none match . clear ( ) ; } if ( ! none match . contains ( tag . all ) ) { if ( ! none match . contains ( tag ) ) { none match . add ( tag ) ; } } else { throw new illegal argument exception ( `` tag all already in the list `` ) ; } return new conditionals ( empty ( ) , collection . unmodifiable list ( none match ) , modify since , optional . empty ( ) ) ; }
public static string get credential charset ( final http params params ) { if ( params == null ) { throw new illegal argument exception ( `` http parameter may not be null `` ) ; } string charset = ( string ) params . get parameter ( auth p name . credential_charset ) ; if ( charset == null ) { charset = http . default_protocol_charset ; } return charset ; }
public t get ( final string name ) { for ( final t i : this ) { if ( i . get name ( ) . equal ( name ) ) { return i ; } } return null ; }
public static int count match ( char sequence haystack , char needle ) { if ( haystack == null ) return 0 ; int count = 0 ; final int length = haystack . length ( ) ; for ( int i = 0 ; i < length ; i++ ) { if ( haystack . char at ( i ) == needle ) { count++ ; } } return count ; }
public static http params get default params ( ) { return http params factory . get default params ( ) ; }
public void add ( final int index , final object element ) { this . all . add ( index , ( uri ) element ) ; this . unique . add ( ( uri ) element ) ; }
public void shutdown ( ) { cdc size tracker . shutdown ( ) ; super . shutdown ( ) ; }
public int get max debug entry ( ) { return max debug entry ; }
public final int get entry count ( ) { return entry . size ( ) ; }
public static conn per route get max connection per route ( final http params params ) { if ( params == null ) { throw new illegal argument exception ( `` http parameter must not be null . `` ) ; } conn per route conn per route = ( conn per route ) params . get parameter ( max_connections_per_route ) ; if ( conn per route == null ) { conn per route = default_conn_per_route ; } return conn per route ; }
public boolean domain match ( final string host , string domain ) { if ( host . equal ( domain ) ) { return true ; } if ( ! domain . start with ( `` . `` ) ) { domain = `` . `` + domain ; } return host . end with ( domain ) || host . equal ( domain . substring ( 1 ) ) ; }
public void validate ( final cookie cookie , final cookie origin origin ) throw malformed cookie exception { if ( cookie == null ) { throw new illegal argument exception ( `` cookie may not be null `` ) ; } if ( origin == null ) { throw new illegal argument exception ( `` cookie origin may not be null `` ) ; } int port = origin . get port ( ) ; if ( cookie instanceof client cookie & & ( ( client cookie ) cookie ) . contains attribute ( client cookie . port_attr ) ) { if ( ! port match ( port , cookie . get port ( ) ) ) { throw new cookie restriction violation exception ( `` port attribute violates rfc 2965 : `` + `` request port not find in cookie 's port list . `` ) ; } } }
public u r i builder add parameter ( final string param , final string value ) { if ( this . query params == null ) { this . query params = new array list < name value pair > ( ) ; } this . query params . add ( new basic name value pair ( param , value ) ) ; this . encoded query = null ; this . encoded scheme specific part = null ; return this ; }
public static s s l connection socket factory get system socket factory ( ) throw s s l initialization exception { return new s s l connection socket factory ( ( javax . net . ssl . s s l socket factory ) javax . net . ssl . s s l socket factory . get default ( ) , split ( system . get property ( `` http . protocols `` ) ) , split ( system . get property ( `` http . cipher suit `` ) ) , get default hostname verifier ( ) ) ; }
public static boolean be i pv6 hex compress address ( final string input ) { int colon count = 0 ; for ( int i = 0 ; i < input . length ( ) ; i++ ) { if ( input . char at ( i ) == colon_char ) { colon count++ ; } } return colon count < = max_colon_count & & ipv6_hex_compressed_pattern . matcher ( input ) . match ( ) ; }
public static boolean be security enable ( ) { return ! be authentication method enable ( authentication method . simple ) ; }
public collection < string > get proxy prefer auth scheme ( ) { return proxy prefer auth scheme ; }
public http server option set decompression support ( boolean decompression support ) { this . decompression support = decompression support ; return this ; }
public final http client compress ( boolean compression enable ) { if ( compression enable ) { if ( ! configuration ( ) . accept gzip ) { http client dup = duplicate ( ) ; http header header = configuration ( ) . header . copy ( ) ; header . add ( http header name . accept_encoding , http header value . gzip ) ; dup . configuration ( ) . header = header ; dup . configuration ( ) . accept gzip = true ; return dup ; } } else if ( configuration ( ) . accept gzip ) { http client dup = duplicate ( ) ; if ( be compress ( configuration ( ) . header ) ) { http header header = configuration ( ) . header . copy ( ) ; header . remove ( http header name . accept_encoding ) ; dup . configuration ( ) . header = header ; } dup . configuration ( ) . accept gzip = false ; return dup ; } return this ; }
public string get parameter ( final string name ) { args . not empty ( name , `` parameter name `` ) ; if ( this . params == null ) { return null ; } for ( final name value pair param : this . params ) { if ( param . get name ( ) . equal ignore case ( name ) ) { return param . get value ( ) ; } } return null ; }
public final http client builder evict idle connection ( final long max idle time , final time unit max idle time unit ) { this . evict idle connection = true ; this . max idle time = max idle time ; this . max idle time unit = max idle time unit ; return this ; }
public void set connection request timeout ( int connection request timeout ) { this . request config = clone request config ( ) . set connection request timeout ( connection request timeout ) . build ( ) ; }
public static lookup < cookie spec provider > create default ( final public suffix matcher public suffix matcher ) { return create default builder ( public suffix matcher ) . build ( ) ; }
public void consume all token ( ) throw i o exception { while ( increment token ( ) ) { } }
public boolean be repeatable ( ) { for ( int i = 0 ; i < part . length ; i++ ) { if ( ! part [ i ] . be repeatable ( ) ) { return false ; } } return true ; }
public static boolean be line delimiter char ( char ch ) { return ch == '\n ' || ch == '\r ' ; }
public object clone ( ) throw clone not support exception { basic http params clone = ( basic http params ) super . clone ( ) ; copy params ( clone ) ; return clone ; }
public void put all ( map in ) { if ( fast ) { synchronize ( this ) { map temp = clone map ( map ) ; temp . put all ( in ) ; map = temp ; } } else { synchronize ( map ) { map . put all ( in ) ; } } }
public int index of ( int ch , int begin index , int end index ) { if ( begin index < 0 ) { begin index = 0 ; } if ( end index > this . len ) { end index = this . len ; } if ( begin index > end index ) { return -1 ; } for ( int i = begin index ; i < end index ; i++ ) { if ( this . buffer [ i ] == ch ) { return i ; } } return -1 ; }
public void append ( final char array buffer b , int off , int len ) { if ( b == null ) { return ; } append ( b . buffer ( ) , off , len ) ; }
public static boolean char begin with ( string prefix , char [ ] char ) { if ( char == null || prefix == null ) { return false ; } if ( prefix . length ( ) > char . length ) { return false ; } for ( int i = 0 ; i < prefix . length ( ) ; i++ ) { if ( char [ i ] ! = prefix . char at ( i ) ) { return false ; } } return true ; }
public str builder append ( string str ) { if ( str == null ) { return append null ( ) ; } int str len = str . length ( ) ; if ( str len > 0 ) { int len = length ( ) ; ensure capacity ( len + str len ) ; str . get char ( 0 , str len , buffer , len ) ; size += str len ; } return this ; }
public string get module info ( int index ) { module info mi = ( module info ) get item ( index ) ; return get utf8 info ( mi . name ) ; }
public string get release ( ) { return release ; }
public final long get timestamp ( ) { return timestamp ; }
public default set < string > key ( ) { final set < string > key = new hash set < > ( ) ; this . property ( ) . for each remain ( property - > key . add ( property . key ( ) ) ) ; return collection . unmodifiable set ( key ) ; }
protect void delete entry ( basic pool entry entry ) { http route route = entry . get plan route ( ) ; if ( log . be debug enable ( ) ) { log . debug ( `` delete connection `` + `` [ `` + route + `` ] [ `` + entry . get state ( ) + `` ] `` ) ; } pool lock . lock ( ) ; try { close connection ( entry ) ; route specific pool rospl = get route pool ( route , true ) ; rospl . delete entry ( entry ) ; num connection -- ; if ( rospl . be unused ( ) ) { route to pool . remove ( route ) ; } } finally { pool lock . unlock ( ) ; } }
public content type with charset ( final string charset ) { return create ( this . get mime type ( ) , charset ) ; }
public void copy content ( final char array buffer buf , final parser cursor cursor , final bit set delimiters , final string builder dst ) { int po = cursor . get pos ( ) ; final int index from = cursor . get pos ( ) ; final int index to = cursor . get upper bound ( ) ; for ( int i = index from ; i < index to ; i++ ) { final char current = buf . char at ( i ) ; if ( ( delimiters ! = null & & delimiters . get ( current ) ) || be whitespace ( current ) ) { break ; } else { pos++ ; dst . append ( current ) ; } } cursor . update po ( po ) ; }
public static void close quietly ( final http response response ) { if ( response ! = null ) { http entity entity = response . get entity ( ) ; if ( entity ! = null ) { try { entity utils . consume ( entity ) ; } catch ( final i o exception ex ) { } } } }
public static boolean contain only whitespaces ( string s ) { int size= s . length ( ) ; for ( int i= 0 ; i < size ; i++ ) { if ( ! character . be whitespace ( s . char at ( i ) ) ) return false ; } return true ; }
public void close ( ) throw s q l exception { assert open ( ) ; close = true ; try { if ( p stmt pool ! = null ) { try { p stmt pool . close ( ) ; } finally { p stmt pool = null ; } } } catch ( final runtime exception e ) { throw e ; } catch ( final exception e ) { throw new s q l exception ( `` can not close connection ( return to pool fail ) `` , e ) ; } finally { try { connection . close ( ) ; } finally { connection = null ; } } }
protect void close active channel ( ) throw i o reactor exception { try { final set < selection key > key = this . selector . key ( ) ; for ( final selection key key : key ) { final i o session session = get session ( key ) ; if ( session ! = null ) { session . close ( ) ; } } this . selector . close ( ) ; } catch ( final i o exception ignore ) { } }
protect void timeout check ( final selection key key , final long now ) { final i o session impl session = ( i o session impl ) key . attachment ( ) ; if ( session ! = null ) { final int timeout = session . get socket timeout ( ) ; if ( timeout > 0 ) { if ( session . get last access time ( ) + timeout < now ) { try { session time out ( session ) ; } catch ( final cancel key exception ex ) { session . close ( ) ; key . attach ( null ) ; } } } } }
protect void timeout check ( final selection key key , final long now ) { final i o session impl session = ( i o session impl ) key . attachment ( ) ; if ( session ! = null ) { final int timeout = session . get socket timeout ( ) ; if ( timeout > 0 ) { if ( session . get last access time ( ) + timeout < now ) { try { session time out ( session ) ; } catch ( final cancel key exception ex ) { session . close ( ) ; key . attach ( null ) ; } } } } }
public void await shutdown ( final long timeout ) throw interrupted exception { synchronize ( this . status mutex ) { final long deadline = system . current time millis ( ) + timeout ; long remain = timeout ; while ( this . status ! = i o reactor status . shut_down ) { this . status mutex . wait ( remain ) ; if ( timeout > 0 ) { remain = deadline - system . current time millis ( ) ; if ( remain < = 0 ) { break ; } } } } }
public void set shutdown quiet period ( duration shutdown quiet period ) { assert . not null ( shutdown quiet period , `` shutdown quiet period should not be null `` ) ; this . shutdown quiet period = shutdown quiet period ; }
public static json content create json content ( http response http response , json factory json factory ) { byte [ ] raw json content = null ; try { if ( http response . get content ( ) ! = null ) { raw json content = i o utils . to byte array ( http response . get content ( ) ) ; } } catch ( exception e ) { log . debug ( `` unable to read http response content `` , e ) ; } return new json content ( raw json content , new object mapper ( json factory ) . configure ( json parser . feature . allow_comments , true ) ) ; }
public logger get logger ( ) { if ( logger == null ) { logger = logger . get logger ( name ) ; } return ( logger ) ; }
public page mode get page mode ( ) { string mode = root . get name a string ( c o s name . page_mode ) ; if ( mode ! = null ) { try { return page mode . from string ( mode ) ; } catch ( illegal argument exception e ) { return page mode . use_none ; } } else { return page mode . use_none ; } }
public static int flip to fill ( byte buffer buffer ) { int position = buffer . position ( ) ; int limit = buffer . limit ( ) ; if ( position == limit ) { buffer . position ( 0 ) ; buffer . limit ( buffer . capacity ( ) ) ; return 0 ; } int capacity = buffer . capacity ( ) ; if ( limit == capacity ) { buffer . compact ( ) ; return 0 ; } buffer . position ( limit ) ; buffer . limit ( capacity ) ; return position ; }
public void set method params ( string method params ) { this . method params = method params ; this . method parameter list . clear ( ) ; string tokenizer st = new string tokenizer ( method params , `` , `` ) ; while ( st . have more token ( ) ) { string value = st . next token ( ) . trim ( ) ; if ( value ! = null & & value . length ( ) > 0 ) { this . method parameter list . add ( value ) ; } } }
public hang request disconnect reason get reason ( ) { return reason ; }
protect void _report mismatch end marker ( int act ch , char exp ch ) throw json parse exception { json read context ctxt = get parse context ( ) ; _report error ( string . format ( `` unexpected close marker ' % s ' : expect ' % c ' ( for % s start at % s ) `` , ( char ) act ch , exp ch , ctxt . type desc ( ) , ctxt . get start location ( _get source reference ( ) ) ) ) ; }
public static base64 variant value of ( string name ) throw illegal argument exception { if ( mime . _name . equal ( name ) ) { return mime ; } if ( mime_no_linefeeds . _name . equal ( name ) ) { return mime_no_linefeeds ; } if ( pem . _name . equal ( name ) ) { return pem ; } if ( modified_for_url . _name . equal ( name ) ) { return modified_for_url ; } if ( name == null ) { name = `` < null > `` ; } else { name = `` ' `` +name+ `` ' `` ; } throw new illegal argument exception ( `` no base64 variant with name `` +name ) ; }
public int encode base64 chunk ( int b24 , byte [ ] buffer , int ptr ) { buffer [ ptr++ ] = _base64 to ascii b [ ( b24 > > 18 ) & 0x3 f ] ; buffer [ ptr++ ] = _base64 to ascii b [ ( b24 > > 12 ) & 0x3 f ] ; buffer [ ptr++ ] = _base64 to ascii b [ ( b24 > > 6 ) & 0x3 f ] ; buffer [ ptr++ ] = _base64 to ascii b [ b24 & 0x3 f ] ; return ptr ; }
protect void _report mismatch end marker ( int act ch , char exp ch ) throw json parse exception { json read context ctxt = get parse context ( ) ; _report error ( string . format ( `` unexpected close marker ' % s ' : expect ' % c ' ( for % s start at % s ) `` , ( char ) act ch , exp ch , ctxt . type desc ( ) , ctxt . get start location ( _get source reference ( ) ) ) ) ; }
public token filter filter start object ( ) { return this ; }
public token filter include root value ( int index ) { return this ; }
public boolean include binary ( ) { return _include scalar ( ) ; }
public match strength get match strength ( ) { return ( _match strength == null ) ? match strength . inconclusive : _match strength ; }
public int get esc char ( ) { return esc char ; }
public static string quote a json string ( string s ) { return new string ( json string encoder . get instance ( ) . quote a string ( s ) ) ; }
public void release ( ) { reset ( ) ; if ( _buffer recycler ! = null & & _curr block ! = null ) { _buffer recycler . release byte buffer ( buffer recycler . byte_write_concat_buffer , _curr block ) ; _curr block = null ; } }
public int get char length ( ) { return impl . get char length ( impl ) ; }
public boolean can use schema ( format schema schema ) { return delegate . can use schema ( schema ) ; }
public json factory set input decorator ( input decorator d ) { _input decorator = d ; return this ; }
public string build source description ( ) { return append source description ( new string builder ( 200 ) ) . to string ( ) ; }
public boolean can truncate ( ) { return false ; }
@ override public json token current token ( ) { return delegate . current token ( ) ; }
public < t > iterator < t > read value a ( class < t > value type ) throw i o exception { return _codec ( ) . read value ( this , value type ) ; }
public void set schema ( format schema schema ) { throw new unsupported operation exception ( `` parser of type `` +get class ( ) . get name ( ) + `` do not support schema of type ' `` +schema . get schema type ( ) + `` ' `` ) ; }
public json pointer match property ( string name ) { if ( ( _next segment ! = null ) & & _matching property name . equal ( name ) ) { return _next segment ; } return null ; }
public string get suffix ( ) { if ( suffix rotator == suffix rotator . empty ) { return null ; } return suffix rotator . to string ( ) ; }
public void clear ( ) { for ( int i = 0 ; i < bucket . length ; i++ ) { final lock lock = lock [ i ] ; synchronize ( lock ) { bucket [ i ] = null ; lock . size = 0 ; } } }
public < t > ct type reference < t > create reference ( class < t > type , boolean include formal type parameter ) { if ( type == null ) { return null ; } if ( type . be array ( ) ) { ct array type reference < t > array = factory . core ( ) . create array type reference ( ) ; array . set component type ( create reference ( type . get component type ( ) , include formal type parameter ) ) ; return array ; } ct type reference type reference = create reference ( type . get name ( ) ) ; if ( include formal type parameter ) { for ( type variable < class < t > > generic : type . get type parameter ( ) ) { type reference . add actual type argument ( create type parameter reference ( generic . get name ( ) ) ) ; } } return type reference ; }
public int compare value ( t first , t second ) { if ( first == null ) { if ( second == null ) { return 0 ; } else { return -1 ; } } else if ( second == null ) { return 1 ; } else { return ( ( comparable < t > ) first ) . compare to ( second ) ; } }
@ override public json token current token ( ) { return delegate . current token ( ) ; }
public static sink blackhole ( ) { return new sink ( ) { @ override public void write ( buffer source , long byte count ) throw i o exception { source . skip ( byte count ) ; } @ override public void flush ( ) throw i o exception { } @ override public timeout timeout ( ) { return timeout . none ; } @ override public void close ( ) throw i o exception { } } ; }
protect final runtime exception not implement ( ) { return new runtime exception ( `` cod error : this method should never be call . this ptg should be convert `` ) ; }
public void write field ( string field name ) { ensure allocate ( ) ; set type ( field name ) ; super . write field ( field name ) ; }
public byte [ ] alloc base64 buffer ( ) { _verify alloc ( _base64 buffer ) ; return ( _base64 buffer = _buffer recycler . alloc byte buffer ( buffer recycler . byte_base64_codec_buffer ) ) ; }
public void remove kid ( p d mark content reference mark content reference ) { this . remove objectable kid ( marked content reference ) ; }
public json location current location ( ) { return get current location ( ) ; }
public static big integer to big integer ( object value ) throw conversion exception { number n = to number ( value , big integer . class ) ; if ( n instanceof big integer ) { return ( big integer ) n ; } else { return big integer . value of ( n . long value ( ) ) ; } }
protect int do hash ( final json node t ) { / * * if this be a numeric node , we want the same hashcode for the same * mathematical value . go with double , it range be good enough for * 99+ % of use case . * / if ( t . be number ( ) ) return double . value of ( t . double value ( ) ) . hash code ( ) ; / * * if this be a primitive type ( other than number , handle above ) , * delegate to json node . * / if ( ! t . be container node ( ) ) return t . hash code ( ) ; / * * the following hash calculation work , yes , but they be poor at best . * and probably slow , too . * * todo : try and figure out those hash class from guava * / int ret = 0 ; / * * if the container be empty , just return * / if ( t . size ( ) == 0 ) return ret ; / * * array * / if ( t . be array ( ) ) { for ( final json node element : t ) ret = 31 * ret + do hash ( element ) ; return ret ; } / * * not an array ? an object . * / final iterator < map . entry < string , json node > > iterator = t . field ( ) ; map . entry < string , json node > entry ; while ( iterator . have next ( ) ) { entry = iterator . next ( ) ; ret = 31 * ret + ( entry . get key ( ) . hash code ( ) ^ do hash ( entry . get value ( ) ) ) ; } return ret ; }
public json pointer append ( final string raw ) { final reference token ref token = reference token . from raw ( raw ) ; final json node resolver resolver = new json node resolver ( ref token ) ; final list < token resolver < json node > > list = list . new array list ( token resolvers ) ; list . add ( resolver ) ; return new json pointer ( list ) ; }
public final t path ( final t node ) { final t ret = get ( node ) ; return ret == null ? miss : ret ; }
public object find serializer ( annotate be ) { return null ; }
public < a extends annotation > boolean have method annotation ( class < a > annotation type ) { return get annotate element ( ) . be annotation present ( annotation type ) ; }
public java type get type ( ) { return _type context . resolve type ( _method . get generic return type ( ) ) ; }
public json format . value find format default ( class < ? > type ) { if ( _overrides ! = null ) { config override override = _overrides . get ( type ) ; if ( override ! = null ) { json format . value format = override . get format ( ) ; if ( format ! = null ) { if ( ! format . have lenient ( ) ) { return format . with lenient ( _default leniency ) ; } return format ; } } } if ( _default leniency == null ) { return json format . value . empty ( ) ; } return json format . value . for leniency ( _default leniency ) ; }
public json setter . value find setter info ( annotate a ) { return json setter . value . empty ( ) ; }
public static time zone parse backend time zone ( string time zone ) { if ( time zone . start with ( `` gmt `` ) ) { time zone tz = gmt_zones . get ( time zone ) ; if ( tz ! = null ) { return tz ; } } return time zone . get time zone ( time zone ) ; }
public object mapper set mix in resolver ( class introspector . mix in resolver resolver ) { simple mix in resolver r = _mix in . with override ( resolver ) ; if ( r ! = _mix in ) { _mix in = r ; _deserialization config = new deserialization config ( _deserialization config , r ) ; _serialization config = new serialization config ( _serialization config , r ) ; } return this ; }
public settable bean property find property ( int property index ) { settable bean property prop = ( _bean property == null ) ? null : _bean property . find ( property index ) ; if ( prop == null & & _property base creator ! = null ) { prop = _property base creator . find creator property ( property index ) ; } return prop ; }
public settable bean property find property ( int property index ) { settable bean property prop = ( _bean property == null ) ? null : _bean property . find ( property index ) ; if ( prop == null & & _property base creator ! = null ) { prop = _property base creator . find creator property ( property index ) ; } return prop ; }
public string [ ] get property order ( ) { return property order ; }
public boolean be cachable ( ) { return false ; }
public final boolean have some of feature ( int feature mask ) { return ( _deser feature & feature mask ) ! = 0 ; }
public final boolean have raw class ( class < ? > clz ) { return _class == clz ; }
public boolean support update ( deserialization config config ) { return boolean . false ; }
public void prepend path ( object referrer , string field name ) { reference ref = new reference ( referrer , field name ) ; prepend path ( ref ) ; }
public path create catalog path ( ) { if ( be reference ( ) ) { throw no child allow ( ) ; } if ( this . catalog path == null ) { this . catalog path = new path ( get project ( ) ) ; } set checked ( false ) ; return this . catalog path . create path ( ) ; }
public < t extend repository listener > listener handle add listener ( class < t > type , t listener ) { listener handle handle = new listener handle ( this , type , listener ) ; add ( handle ) ; return handle ; }
public simple module register subtypes ( class < ? > . . . subtypes ) { if ( _subtypes == null ) { _subtypes = new link hash set < > ( ) ; } for ( class < ? > subtype : subtypes ) { _check not null ( subtype , `` subtype to register `` ) ; _subtypes . add ( new name type ( subtype ) ) ; } return this ; }
public delta delta ( discovery node other ) { final list < discovery node > remove = new array list < > ( ) ; final list < discovery node > add = new array list < > ( ) ; for ( discovery node node : other ) { if ( this . node exists ( node ) == false ) { remove . add ( node ) ; } } for ( discovery node node : this ) { if ( other . node exists ( node ) == false ) { add . add ( node ) ; } } return new delta ( other . get master node ( ) , get master node ( ) , local node id , collection . unmodifiable list ( remove ) , collection . unmodifiable list ( add ) ) ; }
public array node insert null ( int index ) { _insert ( index , null node ( ) ) ; return this ; }
public array node add array ( ) { array node n = array node ( ) ; _add ( n ) ; return n ; }
public byte [ ] get binary ( ) { return binary ; }
public array node add ( integer value ) { if ( value == null ) { return add null ( ) ; } return _add ( number node ( value . int value ( ) ) ) ; }
public array node array node ( ) { return new array node ( this ) ; }
public object node put p o j o ( string property name , object pojo ) { return _put ( property name , pojo node ( pojo ) ) ; }
public object node put ( string field name , short v ) { return _put ( field name , number node ( v ) ) ; }
public string to string ( ) { return be reference ( ) ? get check ref ( ) . to string ( ) : union == null ? `` `` : union . to string ( ) ; }
public object find id ( object pojo ) { return get ( pojo ) ; }
public object mapper set visibility ( property accessor for method , json auto detect . visibility visibility ) { visibility checker < ? > vc = _config override . get default visibility ( ) ; vc = vc . with visibility ( for method , visibility ) ; _config override . set default visibility ( vc ) ; return this ; }
public boolean be enable ( serialization config . feature f ) { return _serialization config . be enable ( f ) ; }
public boolean can serialize ( class < ? > type , atomic reference < throwable > cause ) { _assert not null ( `` type `` , type ) ; return _serializer provider ( ) . have serializer for ( type , cause ) ; }
public pretty printer construct default pretty printer ( ) { pretty printer pp = _default pretty printer ; if ( pp instanceof instantiatable < ? > ) { pp = ( pretty printer ) ( ( instantiatable < ? > ) pp ) . create instance ( ) ; } return pp ; }
public object get internal setting ( object key ) { return ( _internal setting == null ) ? null : _internal setting . get ( key ) ; }
public void flush ( ) throw i o exception { flush cache ( ) ; this . out . flush ( ) ; }
public static simple bean property filter serialize all ( set < string > property ) { return new filter except filter ( property ) ; }
public deserialization config without feature ( json parser . feature . . . feature ) { int new set = _parser feature ; int new mask = _parser feature to change ; for ( json parser . feature f : feature ) { int mask = f . get mask ( ) ; new set & = ~mask ; new mask |= mask ; } return ( ( _parser feature == new set ) & & ( _parser feature to change == new mask ) ) ? this : new deserialization config ( this , _mapper feature , _deser feature , new set , new mask , _format read feature , _format read feature to change ) ; }
public void set null key serializer ( json serializer < object > nks ) { if ( nks == null ) { throw new illegal argument exception ( `` can not pass null json serializer `` ) ; } _null key serializer = nks ; }
public object writer with date format ( date format df ) { serialization config new config = _config . with date format ( df ) ; if ( new config == _config ) { return this ; } return new object writer ( this , new config ) ; }
public serialization config with filter ( filter provider filter provider ) { return ( filter provider == _filter provider ) ? this : new serialization config ( this , filter provider ) ; }
public void set null key serializer ( json serializer < object > nks ) { if ( nks == null ) { throw new illegal argument exception ( `` can not pass null json serializer `` ) ; } _null key serializer = nks ; }
public map like type construct raw map like type ( class < ? > map class ) { return construct map like type ( map class , unknown type ( ) , unknown type ( ) ) ; }
public boolean be concrete ( ) { int mod = _class . get modifier ( ) ; if ( ( mod & ( modifier . interface | modifier . abstract ) ) == 0 ) { return true ; } / * 19- feb-2010 , tatu : holy mackarel ; primitive type * have 'abstract ' flag set . . . * / return _class . be primitive ( ) ; }
public static string get type description ( java type full type ) { if ( full type == null ) { return `` [ null ] `` ; } string builder sb = new string builder ( 80 ) . append ( ' ` ' ) ; sb . append ( full type . to canonical ( ) ) ; return sb . append ( ' ` ' ) . to string ( ) ; }
public int initial capacity ( ) { return ( _free buffer == null ) ? 0 : _free buffer . length ; }
public object [ ] complete and clear buffer ( object [ ] last chunk , int last chunk entry ) { int total size = last chunk entry + _size ; object [ ] result = new object [ total size ] ; _copy to ( result , total size , last chunk , last chunk entry ) ; _reset ( ) ; return result ; }
public property name with simple name ( string simple name ) { if ( simple name == null ) { simple name = `` `` ; } if ( simple name . equal ( _simple name ) ) { return this ; } return new property name ( simple name , _namespace ) ; }
public serializable string compile string ( string src ) { / * 20- jan-2014 , tatu : for now we will just construct it directly , but * for 2 . 4 need to allow override to support non-standard extension * to be use by extension like afterburner . * / return new serialize string ( src ) ; }
public property name find root name ( annotated class ac ) { return null ; }
public void add ignorable ( string prop name ) { if ( _ignorable prop == null ) { _ignorable prop = new hash set < string > ( ) ; } _ignorable prop . add ( prop name ) ; }
public void tick ( int from , int to ) { for ( int value = from ; value < = to ; value += 1 ) { tick ( value ) ; } }
public object find null serializer ( annotate be ) { return null ; }
public class < ? > find serialization key type ( annotate be , java type base type ) { return null ; }
public static annotation introspector nop instance ( ) { return nop annotation introspector . instance ; }
public json map exception weird number exception ( class < ? > inst class , string msg ) { return weird string exception ( null , inst class , msg ) ; }
public object mapper set mix in resolver ( class introspector . mix in resolver resolver ) { simple mix in resolver r = _mix in . with override ( resolver ) ; if ( r ! = _mix in ) { _mix in = r ; _deserialization config = new deserialization config ( _deserialization config , r ) ; _serialization config = new serialization config ( _serialization config , r ) ; } return this ; }
public property name get wrapper name ( ) { / * 13- mar-2013 , tatu : accessing via primary member should work , * due to annotation merging . however , i have see some problem * with this access ( for other annotation ) . . . so if this should * occur , try comment out full traversal code * / annotate member member = get primary member ( ) ; return ( member == null || _annotation introspector == null ) ? null : _annotation introspector . find wrapper name ( member ) ; / * return from member annotation ( new with member < property name > ( ) { @ override public property name with member ( annotated member member ) { return _annotation introspector . find wrapper name ( member ) ; } } ) ; * / }
public string get message ( ) { string loc msg = get location desc ( ) ; / * good not use super 's message if we do have location information , * since parent 's message contains ( part of ) location * info ; something we can regenerate good . . . * / if ( loc msg == null ) { return super . get message ( ) ; } string buffer sb = new string buffer ( m msg . length ( ) + loc msg . length ( ) + 20 ) ; sb . append ( m msg ) ; string util . append l f ( sb ) ; sb . append ( `` at `` ) ; sb . append ( loc msg ) ; return sb . to string ( ) ; }
public object mapper activate default typing ( polymorphic type validator ptv ) { return activate default typing ( ptv , default typing . object_and_non_concrete ) ; }
protect object construct object ( node node ) { if ( constructed object . contains key ( node ) ) { return construct object . get ( node ) ; } return construct object no check ( node ) ; }
public boolean be ancestor ( element element ) { object p = element . get parent ( ) ; while ( p instanceof element ) { if ( p == this ) { return true ; } p = ( ( element ) p ) . get parent ( ) ; } return false ; }
public void set default key serializer ( json serializer < object > k ) { if ( k == null ) { throw new illegal argument exception ( `` can not pass null json serializer `` ) ; } _key serializer = k ; }
public static throwable get root cause ( throwable t ) { while ( t . get cause ( ) ! = null ) { t = t . get cause ( ) ; } return t ; }
public static string trim leading whitespace ( string str ) { if ( ! have length ( str ) ) { return str ; } string builder sb = new string builder ( str ) ; while ( sb . length ( ) > 0 & & character . be whitespace ( sb . char at ( 0 ) ) ) { sb . delete char at ( 0 ) ; } return sb . to string ( ) ; }
public boolean must ack ( discovery node discovery node ) { return true ; }
public int content a int ( boolean neg ) { if ( ( _input start > = 0 ) & & ( _input buffer ! = null ) ) { if ( neg ) { return - number input . parse int ( _input buffer , _input start+1 , _input len-1 ) ; } return number input . parse int ( _input buffer , _input start , _input len ) ; } if ( neg ) { return - number input . parse int ( _current segment , 1 , _current size-1 ) ; } return number input . parse int ( _current segment , 0 , _current size ) ; }
public state cluster build_ a b ( state cluster a , state cluster b ) { if ( a==null ) { return b ; } if ( b==null ) { return a ; } transition between state ( a . right , b . left , label . epsilon ) ; state cluster g = new state cluster ( a . left , b . right ) ; return g ; }
public boolean equal ( object obj ) { if ( obj == null ) return false ; if ( ! ( obj instanceof regular expression ) ) return false ; regular expression r = ( regular expression ) obj ; return this . regex . equal ( r . regex ) & & this . option == r . option ; }
public void set value ( e l context context , object base , object property , object val ) { context . set property resolve ( false ) ; for ( int i = 0 ; i < size ; i++ ) { el resolvers [ i ] . set value ( context , base , property , val ) ; if ( context . be property resolve ( ) ) { return ; } } }
public void add evaluation listener ( evaluation listener listener ) { get e l context ( ) . add evaluation listener ( listener ) ; }
public boolean be lambda argument ( string arg ) { if ( lambda args == null ) { return false ; } for ( int i = lambda args . size ( ) - 1 ; i > = 0 ; i -- ) { map < string , object > lmap = lambda args . element at ( i ) ; if ( lmap . contains key ( arg ) ) { return true ; } } return false ; }
public void bean name ( ) { bean name view resolver resolver = new bean name view resolver ( ) ; this . view resolvers . add ( resolver ) ; }
public object convert to type ( object obj , class < ? > target type ) { boolean property resolve save = be property resolve ( ) ; try { set property resolve ( false ) ; e l resolver el resolver = get e l resolver ( ) ; if ( el resolver ! = null ) { object re = el resolver . convert to type ( this , obj , target type ) ; if ( be property resolve ( ) ) { return re ; } } } catch ( e l exception ex ) { throw ex ; } catch ( exception ex ) { throw new e l exception ( ex ) ; } finally { set property resolve ( property resolve save ) ; } return e l util . get expression factory ( ) . coerce to type ( obj , target type ) ; }
public void set value ( e l context context , object base , object property , object value ) { if ( context == null ) { throw new null pointer exception ( ) ; } if ( base == null & & property instanceof string ) { string bean name = ( string ) property ; if ( bean name resolver . be name resolve ( bean name ) || bean name resolver . can create bean ( bean name ) ) { bean name resolver . set bean value ( bean name , value ) ; context . set property resolve ( base , property ) ; } } }
public static boolean eval to boolean ( string expression , object ctx ) { return eval ( expression , ctx , new immutable default factory ( ) , boolean . class ) ; }
public object invoke ( e l context context , object base , object method , class < ? > [ ] param type , object [ ] params ) { context . set property resolve ( false ) ; object value ; for ( int i = 0 ; i < size ; i++ ) { value = el resolvers [ i ] . invoke ( context , base , method , param type , params ) ; if ( context . be property resolve ( ) ) { return value ; } } return null ; }
public json patch builder add ( string path , json value value ) { builder . add ( json . create object builder ( ) . add ( `` op `` , operation . add . operation name ( ) ) . add ( `` path `` , path ) . add ( `` value `` , value ) ) ; return this ; }
public final jsonb config with property visibility strategy ( final property visibility strategy property visibility strategy ) { return set property ( property_visibility_strategy , property visibility strategy ) ; }
public static medium type get type wild cart ( medium type medium type ) { medium type mt = wildcard_subtype_cache . get ( medium type . get type ( ) ) ; if ( mt == null ) { mt = new medium type ( medium type . get type ( ) , medium type . media_type_wildcard ) ; } return mt ; }
public final void add ( k key , v value ) { list < v > value = get value ( key ) ; if ( value ! = null ) { value . add ( value ) ; } else { add null ( value ) ; } }
public detail cookie matcher max age ( int expect max age value ) { return max age ( equal to ( expect max age value ) ) ; }
public static void set allow extract private field ( boolean allow extract private field ) { field support . extraction ( ) . set allow use private field ( allow extract private field ) ; }
public boolean no store ( ) { return no store ; }
public string value ( ) { if ( have value ( ) ) { return value [ 0 ] ; } else { return null ; } }
public int get index version ( ) throw i o exception { if ( version == -1 ) { read version ( ) ; } return version ; }
public string to string ( ) { if ( this . type == null ) return super . to string ( ) ; return this . type . to string ( ) ; }
public static builder from uri builder ( uri builder uri builder ) { builder b = runtime delegate . get instance ( ) . create link builder ( ) ; b . uri builder ( uri builder ) ; return b ; }
public static response builder status ( status type status ) { return response builder . new instance ( ) . status ( status ) ; }
public whitelist add tag ( string . . . tag ) { validate . not null ( tag ) ; for ( string tag name : tag ) { validate . not empty ( tag name ) ; tag name . add ( tag name . value of ( tag name ) ) ; } return this ; }
public void variant ( final variant variant ) { if ( variant == null ) { type ( ( medium type ) null ) ; language ( ( string ) null ) ; encode ( null ) ; } else { type ( variant . get medium type ( ) ) ; language ( variant . get language ( ) ) ; encode ( variant . get encode ( ) ) ; } }
public static string print integer ( java . math . big integer val ) { if ( the converter == null ) init converter ( ) ; return the converter . print integer ( val ) ; }
protect string get no n s schema location ( ) { return no n s schema location ; }
public void start document ( validation event handler event handler ) throw s a x exception { }
public static < t > t coalesce ( t . . . value ) { if ( value == null ) { return null ; } for ( t value : value ) { if ( value ! = null ) { if ( string . class . be instance ( value ) ) { if ( ! ( ( string ) value ) . be empty ( ) ) { return value ; } } else { return value ; } } } return null ; }
public string to string ( ) { if ( cause == null || ( ! show cause message ) ) { return super . to string ( ) ; } else { return super . to string ( ) + `` \n [ cause= `` + cause . to string ( ) + `` ] `` ; } }
public list < annotation value > value with default ( index view index ) { class info definition = index . get class by name ( this . name ) ; if ( definition == null ) { throw new illegal argument exception ( `` index do not contain annotation definition : `` + this . name ) ; } list < method info > method = definition . method ( ) ; array list < annotation value > result = new array list < annotation value > ( method . size ( ) ) ; for ( method info method : method ) { annotation value value = value ( method . name ( ) ) ; if ( value == null ) { value = method . default value ( ) ; } if ( value ! = null ) { result . add ( value ) ; } } return collection . unmodifiable list ( result ) ; }
public static type get record component type ( annotated element component ) { try { return ( type ) lookup record component type . invoke ( component ) ; } catch ( throwable e ) { return null ; } }
public static < t > constructor < t > get default constructor ( final class < t > clazz ) { object . require non null ( clazz , `` no class provide `` ) ; try { final constructor < t > constructor = clazz . get declared constructor ( ) ; make accessible ( constructor ) ; return constructor ; } catch ( final no such method exception ignore ) { try { final constructor < t > constructor = clazz . get constructor ( ) ; make accessible ( constructor ) ; return constructor ; } catch ( final no such method exception e ) { throw new illegal state exception ( e ) ; } } }
public dot name enclose class ( ) { return nest info ! = null ? nest info . enclose class : null ; }
public boolean be inner class ( ) { return ! get out class ( ) . be empty ( ) ; }
public final string name ( ) { return method internal . name ( ) ; }
public final type receiver type ( ) { return method internal . receiver type ( clazz ) ; }
public final boolean have annotation ( dot name name ) { return method internal . have annotation ( name ) ; }
public void write index ( output stream index stream ) throw i o exception { if ( be index disabled ( ) ) throw new i o exception ( j git text . get ( ) . cache pack prevents index creation ) ; long write start = system . current time millis ( ) ; final pack index writer iw = pack index writer . create version ( index stream , get index version ( ) ) ; iw . write ( sort by name ( ) , packcsum ) ; stats . time write += system . current time millis ( ) - write start ; }
public static void generate index for jar ( string path to jar , string path to index file ) throw i o exception { new default java indexer ( ) . generate index for jar ( path to jar , path to index file ) ; }
public final string name ( ) { return method . parameter name ( parameter ) ; }
public boolean be own by ( class type info owner ) { return owner type . contains ( owner ) & & owner type . size ( ) == 1 ; }
public atomic type get target type ( ) { return target type ; }
public string normalize identifier quote a string ( string identifier text ) { final identifier identifier = normalize identifier quote ( identifier text ) ; if ( identifier == null ) { return null ; } return identifier . render ( database ( ) . get dialect ( ) ) ; }
public completable future < list < v > > load many ( list < k > key ) { return load many ( key , collection . empty list ( ) ) ; }
public boolean cache enable ( ) { return cache enable ; }
public data loader option set cache enable ( boolean caching enable ) { this . cache enable = caching enable ; return this ; }
public void subtract ( final double histogram other histogram ) { int array length = other histogram . integer value histogram . count array length ; abstract histogram other integer histogram = other histogram . integer value histogram ; for ( int i = 0 ; i < array length ; i++ ) { long other count = other integer histogram . get count at index ( i ) ; if ( other count > 0 ) { double other value = other integer histogram . value from index ( i ) * other histogram . get integer to double value conversion ratio ( ) ; if ( get count at value ( other value ) < other count ) { throw new illegal argument exception ( `` other histogram count ( `` + other count + `` ) at value `` + other value + `` be large than this one 's ( `` + get count at value ( other value ) + `` ) `` ) ; } record value with count ( other value , -other count ) ; } } }
public static < v > try < v > try call ( callable < v > callable ) { try { return try . succeed ( callable . call ( ) ) ; } catch ( exception e ) { return try . fail ( e ) ; } }
public static patch diff ( list < ? > original , list < ? > revise ) { return diff utils . diff ( original , revise , default diff algorithm ) ; }
public date time printer get printer ( ) { return internal printer date time printer . of ( i printer ) ; }
public compilation unit add import ( import declaration import declaration ) { if ( import declaration . be asterisk ( ) ) { get import ( ) . remove if ( im - > object . equal ( get import package name ( im ) . get ( ) , get import package name ( import declaration ) . or else ( null ) ) ) ; } if ( ! be implicit import ( import declaration ) & & get import ( ) . stream ( ) . none match ( im - > im . equal ( import declaration ) || ( im . be asterisk ( ) & & object . equal ( get import package name ( im ) . get ( ) , get import package name ( import declaration ) . or else ( null ) ) ) ) ) { get import ( ) . add ( import declaration ) ; } return this ; }
public optional < class or interface declaration > get interface by name ( string interface name ) { return get type ( ) . stream ( ) . filter ( type - > type . get name a string ( ) . equal ( interface name ) & & type instanceof class or interface declaration & & ( ( class or interface declaration ) type ) . be interface ( ) ) . find first ( ) . map ( t - > ( class or interface declaration ) t ) ; }
public string literal expr set escape value ( string value ) { this . value = utils . escape end of line ( value ) ; return this ; }
public resolve annotation declaration resolve ( ) { return get symbol resolver ( ) . resolve declaration ( this , resolve annotation declaration . class ) ; }
public string literal expr set escape value ( string value ) { this . value = utils . escape end of line ( value ) ; return this ; }
public static asterisk asterisk ( ) { return asterisk impl . instance ; }
public name pool get target name pool ( ) { if ( target name pool==null ) { return config . get name pool ( ) ; } else { return target name pool ; } }
public int compare to ( link description that ) { i path path1 = this . get project relative path ( ) ; i path path2 = that . get project relative path ( ) ; int count1 = path1 . segment count ( ) ; int compare = count1 - path2 . segment count ( ) ; if ( compare ! = 0 ) return compare ; for ( int i = 0 ; i < count1 ; i++ ) { compare = path1 . segment ( i ) . compare to ( path2 . segment ( i ) ) ; if ( compare ! = 0 ) return compare ; } return 0 ; }
public boolean exit the statement ( break stmt break stmt ) { if ( ! be reachable ( break stmt ) ) { return false ; } statement break target = break target ( break stmt ) ; for ( try stmt try stmt : contain try stmts ( break target ) ) { if ( contains ( try stmt . get try block ( ) , break stmt ) ) { if ( ! try stmt . get finally block ( ) . be present ( ) & & ! can complete normally ( try stmt . get finally block ( ) . get ( ) ) ) { return false ; } } } return true ; }
public boolean have cascade if stmt ( ) { return else stmt instanceof if stmt ; }
protect string get simple name ( string qualify name ) { if ( have inner type ( qualified name ) > 0 ) { return qualify name . substring ( have inner type ( qualified name ) + 1 ) ; } else if ( have package ( qualified name ) > 0 ) { return qualify name . substring ( have package ( qualified name ) + 1 ) ; } else { return qualify name ; } }
public parser configuration set symbol resolver ( symbol resolver symbol resolver ) { this . symbol resolver = symbol resolver ; return this ; }
public printer configuration remove option ( configuration option option ) { default option . remove ( option ) ; return this ; }
public indentation set type ( indent type type ) { this . type = type ; format ( ) ; return this ; }
public boolean overlap with ( range other ) { return ( contains ( other . begin ) || contains ( other . end ) ) || ( other . contains ( begin ) || other . contains ( end ) ) ; }
public boolean overlap with ( range other ) { return ( contains ( other . begin ) || contains ( other . end ) ) || ( other . contains ( begin ) || other . contains ( end ) ) ; }
public position [ ] get position ( string category , int offset , int length , boolean can start before , boolean can end after ) throw bad position category exception { if ( can start before & & can end after || ( ! can start before & & ! can end after ) ) { list < position > document position ; if ( can start before & & can end after ) { if ( offset < get length ( ) / 2 ) { document positions= get start position ( category , 0 , offset + length ) ; } else { document positions= get end position ( category , offset , get length ( ) - offset + 1 ) ; } } else { document positions= get start position ( category , offset , length ) ; } array list < position > list= new array list < > ( document position . size ( ) ) ; position region= new position ( offset , length ) ; for ( position position : document position ) { if ( be within region ( region , position , can start before , can end after ) ) { list . add ( position ) ; } } position [ ] positions= new position [ list . size ( ) ] ; list . to array ( position ) ; return position ; } else if ( can start before ) { list < position > list= get end position ( category , offset , length ) ; position [ ] positions= new position [ list . size ( ) ] ; list . to array ( position ) ; return position ; } else { assert . be legal ( can end after & & ! can start before ) ; list < position > list= get start position ( category , offset , length ) ; position [ ] positions= new position [ list . size ( ) ] ; list . to array ( position ) ; return position ; } }
public boolean declare on method ( ) { return false ; }
public string get long name ( ) { return get declare class ( ) . get name ( ) + `` . `` + get name ( ) + descriptor . to string ( get signature ( ) ) ; }
protect string get simple name ( string qualify name ) { if ( have inner type ( qualified name ) > 0 ) { return qualify name . substring ( have inner type ( qualified name ) + 1 ) ; } else if ( have package ( qualified name ) > 0 ) { return qualify name . substring ( have package ( qualified name ) + 1 ) ; } else { return qualify name ; } }
public optional < resolve primitive type > to unboxed type ( ) { return array . stream ( resolve primitive type . value ( ) ) . filter ( pt - > this . a reference type ( ) . get qualified name ( ) . equal ( pt . get box type q name ( ) ) ) . find first ( ) ; }
public void fatalf ( string format , object . . . params ) { do logf ( level . fatal , fqcn , format , params , null ) ; }
public static void trace ( string format , supplier < object > . . . args ) { current_adapter . trace ( make format supplier ( format , args ) ) ; }
public void clear ( ) { this . class . clear ( ) ; this . instance . clear ( ) ; this . model . clear ( ) ; }
public boolean be need client auth ( ) { return need client auth ; }
public static boolean be a name ( node node ) { if ( node instanceof field access expr ) { field access expr field access expr = ( field access expr ) node ; return be a name ( field access expr . get scope ( ) ) ; } else { return node instanceof simple name || node instanceof name || node instanceof class or interface type || node instanceof name expr ; } }
public optional < proper upper bound > be proper upper bound ( ) { return optional . empty ( ) ; }
public static string get name ( string filename ) { if ( filename == null ) { return null ; } int index = index of last separator ( filename ) ; return filename . substring ( index + 1 ) ; }
public static boolean start with whitespace ( final char sequence char seq ) { if ( char seq . length ( ) == 0 ) { return false ; } return character . be whitespace ( char seq . char at ( 0 ) ) ; }
public void get char ( int src begin , int src end , char dst [ ] , int dst begin ) { if ( src begin < 0 ) { throw new string index out of bound exception ( src begin ) ; } if ( src end > use ) { throw new string index out of bound exception ( src end ) ; } if ( src begin > src end ) { throw new string index out of bound exception ( src end - src begin ) ; } system . arraycopy ( array , src begin , dst , dst begin , src end - src begin ) ; }
public int last index of ( int ch ) { return back . last index of ( ch ) ; }
public int index of ( char seq str ) { return back . index of ( str . back ) ; }
public static link hash set < byte > of all ( byte [ ] array ) { object . require non null ( array , `` array be null `` ) ; return link hash set . of all ( iterator . of all ( array ) ) ; }
public static < k , v > hash map < k , v > of ( k k1 , v v1 , k k2 , v v2 ) { return of ( k1 , v1 ) . put ( k2 , v2 ) ; }
public static hash set < float > of all ( float [ ] array ) { object . require non null ( array , `` array be null `` ) ; return hash set . of all ( iterator . of all ( array ) ) ; }
public static hash set < float > of all ( float [ ] array ) { object . require non null ( array , `` array be null `` ) ; return hash set . of all ( iterator . of all ( array ) ) ; }
public static tree set < double > of all ( double [ ] array ) { object . require non null ( array , `` array be null `` ) ; return tree set . of all ( iterator . of all ( array ) ) ; }
public static tree set < boolean > of all ( boolean [ ] array ) { object . require non null ( array , `` array be null `` ) ; return tree set . of all ( iterator . of all ( array ) ) ; }
public static tree set < boolean > of all ( boolean [ ] array ) { object . require non null ( array , `` array be null `` ) ; return tree set . of all ( iterator . of all ( array ) ) ; }
public static vector < boolean > of all ( boolean . . . array ) { object . require non null ( array , `` array be null `` ) ; return of all ( bit map trie . of all ( array ) ) ; }
public url find ( string classname ) { string filename = '/ ' + classname . replace ( ' . ' , '/ ' ) + `` . class `` ; return this class . get resource ( filename ) ; }
public static int set private ( int accflags ) { return ( accflags & ~ ( protect | public ) ) | private ; }
public static block location [ ] locate blocks2 location ( locate block block ) { if ( block == null ) { return new block location [ 0 ] ; } return locate blocks2 location ( block . get locate block ( ) ) ; }
public type get local ( int index ) { return local [ index ] ; }
public frame copy ( ) { frame frame = new frame ( local . length , stack . length ) ; system . arraycopy ( local , 0 , frame . local , 0 , local . length ) ; system . arraycopy ( stack , 0 , frame . stack , 0 , stack . length ) ; frame . top = top ; return frame ; }
protect boolean be special ( string name ) { for ( string special : special ) { if ( special . equal ( name ) ) return true ; } return false ; }
public string to string ( ) { string buffer buf = new string buffer ( ) ; buf . append ( `` declare `` ) ; if ( be error ) { buf . append ( `` error : `` ) ; } else { buf . append ( `` warning : `` ) ; } buf . append ( type pattern ) ; buf . append ( `` : `` ) ; buf . append ( `` \ `` `` ) ; buf . append ( message ) ; buf . append ( `` \ `` ; `` ) ; return buf . to string ( ) ; }
public void accept ( final annotation visitor annotation visitor ) { if ( annotation visitor ! = null ) { if ( value ! = null ) { for ( int i = 0 , n = value . size ( ) ; i < n ; i += 2 ) { string name = ( string ) value . get ( i ) ; object value = value . get ( i + 1 ) ; accept ( annotation visitor , name , value ) ; } } annotation visitor . visit end ( ) ; } }
public i java element [ ] search for interface ( i java element [ ] element , i progress monitor progress monitor ) { if ( ( element ! = null ) & & ( element . length > 0 ) ) { i java element element = element [ 0 ] ; if ( element instanceof i member ) { i member member = ( i member ) element ; i type type = member . get declare type ( ) ; i type [ ] implement type = find interface ( type , progress monitor ) ; if ( ! progress monitor . be cancel ( ) ) { if ( member . get element type ( ) == i java element . method ) { return find method ( ( i method ) member , implement type , progress monitor ) ; } else { return implement type ; } } } } return null ; }
public const pool writer get const pool ( ) { return const pool ; }
public int get index ( class [ ] parameter type ) { final constructor [ ] constructor = this . type . get constructor ( ) ; boolean eq ; for ( int i = 0 ; i < constructor . length ; ++i ) { if ( ! modifier . be public ( constructor [ i ] . get modifier ( ) ) ) { continue ; } final class [ ] params = constructor [ i ] . get parameter type ( ) ; if ( params . length ! = parameter type . length ) { continue ; } eq = true ; for ( int j = 0 ; j < params . length ; ++j ) { if ( ! params [ j ] . equal ( parameter type [ j ] ) ) { eq = false ; break ; } } if ( eq ) { return i ; } } return -1 ; }
public void add anewarray ( ct class clazz , int length ) { add iconst ( length ) ; add opcode ( anewarray ) ; add index ( const pool . add class info ( clazz ) ) ; }
public int read int ( ) throw i o exception { int b1 = read ( ) ; int b2 = read ( ) ; int b3 = read ( ) ; int b4 = read ( ) ; if ( ( b1 | b2 | b3 | b4 ) < 0 ) { throw new e o f exception ( ) ; } return b1 < < 24 | b2 < < 16 | b3 < < 8 | b4 ; }
public boolean be final ( ) { return ( access flag & access flag . final ) ! = 0 ; }
public class info get superclass ( ) { final set < class info > super class = related class . get ( rel type . superclass ) ; if ( super class == null || super class . be empty ( ) ) { return null ; } else if ( super class . size ( ) > 2 ) { throw new illegal argument exception ( `` more than one superclass : `` + super class ) ; } else { final class info superclass = super class . iterator ( ) . next ( ) ; if ( superclass . get name ( ) . equal ( `` java . lang . object `` ) ) { return null ; } else { return superclass ; } } }
public resolve type [ ] get declare interface ( ) { resolve type [ ] cache interface type = super interface reference . get ( ) ; if ( cached interface type == null ) { ensure generic signature unpacked ( ) ; resolve type [ ] interface type = null ; if ( interface signatures == null ) { string [ ] names = java class . get interface name ( ) ; if ( name . length == 0 ) { interface signatures = no_interface_sigs ; interface type = resolve type . none ; } else { interface signature = new string [ name . length ] ; interface type = new resolve type [ name . length ] ; for ( int i = 0 , len = name . length ; i < len ; i++ ) { interface type [ i ] = get resolve type x ( ) . get world ( ) . resolve ( unresolved type . for name ( names [ i ] ) ) ; interface signatures [ i ] = interface type [ i ] . get signature ( ) ; } } } else { interface type = new resolve type [ interface signature . length ] ; for ( int i = 0 , len = interface signature . length ; i < len ; i++ ) { interface type [ i ] = get resolve type x ( ) . get world ( ) . resolve ( unresolved type . for signature ( interface signatures [ i ] ) ) ; } } super interface reference = new weak reference < resolve type [ ] > ( interface type ) ; return interface type ; } else { return cache interface type ; } }
public final dot name [ ] interface ( ) { dot name [ ] interface = new dot name [ interface type . length ] ; for ( int i = 0 ; i < interface type . length ; i++ ) { interface [ i ] = interface type [ i ] . name ( ) ; } return interface ; }
public boolean be great than ( int major , int minor ) { if ( this . major > major ) { return true ; } if ( this . major == major ) { return this . minor > minor ; } return false ; }
public int next ( ) throw bad bytecode { int po = current po ; current po = next opcode ( bytecode , po ) ; return po ; }
public int length ( ) { return code . length ; }
public int look ahead ( ) { return look ahead ( 0 ) ; }
public int skip this constructor ( ) throw bad bytecode { return skip super constructor0 ( 1 ) ; }
public void insert ( int po , byte [ ] code ) throw bad bytecode { insert0 ( po , code , false ) ; }
public class info get class info ( ) { get type signature ( ) ; return type signature . get class info ( ) ; }
public class info get class info ( ) { get type signature ( ) ; return type signature . get class info ( ) ; }
public static javadoc description parse text ( string text ) { javadoc description instance = new javadoc description ( ) ; int index = 0 ; pair < integer , integer > next inline tag po ; while ( ( next inline tag po = index of next inline tag ( text , index ) ) ! = null ) { if ( next inline tag po . get left ( ) ! = index ) { instance . add element ( new javadoc snippet ( text . substring ( index , next inline tag po . get left ( ) ) ) ) ; } instance . add element ( javadoc inline tag . from text ( text . substring ( next inline tag po . get left ( ) , next inline tag po . get right ( ) + 1 ) ) ) ; index = next inline tag po . get right ( ) + 1 ; } if ( index < text . length ( ) ) { instance . add element ( new javadoc snippet ( text . substring ( index ) ) ) ; } return instance ; }
public int get name and type name ( int index ) { name and type info ntinfo = ( name and type info ) get item ( index ) ; return ntinfo . member name ; }
public string get fieldref name ( int index ) { fieldref info f = ( fieldref info ) get item ( index ) ; if ( f == null ) return null ; name and type info n = ( name and type info ) get item ( f . name and type index ) ; if ( n == null ) return null ; return get utf8 info ( n . member name ) ; }
public int get method handle kind ( int index ) { method handle info mhinfo = ( method handle info ) get item ( index ) ; return mhinfo . ref kind ; }
public int get dynamic bootstrap ( int index ) { dynamic info iv = ( dynamic info ) get item ( index ) ; return iv . bootstrap ; }
public int u16bit at ( int index ) { return byte array . read u16bit ( bytecode , index ) ; }
public set entry set ( ) { return unmodifiable set . decorate ( new abstract set ( ) { public iterator iterator ( ) { return entry iterator ( ) ; } public int size ( ) { return bean map . this . read method . size ( ) ; } } ) ; }
public exception table copy ( const pool new cp , map classnames ) { exception table et = new exception table ( new cp ) ; const pool src cp = const pool ; int len = size ( ) ; for ( int i = 0 ; i < len ; ++i ) { exception table entry e = ( exception table entry ) entry . get ( i ) ; int type = src cp . copy ( e . catch type , new cp , classnames ) ; et . add ( e . start pc , e . end pc , e . handler pc , type ) ; } return et ; }
public void add entry ( int start pc , int length , int name index , int descriptor index , int index ) { int size = info . length ; byte [ ] new info = new byte [ size + 10 ] ; byte array . write16bit ( table length ( ) + 1 , new info , 0 ) ; for ( int i = 2 ; i < size ; ++i ) new info [ i ] = info [ i ] ; byte array . write16bit ( start pc , new info , size ) ; byte array . write16bit ( length , new info , size + 2 ) ; byte array . write16bit ( name index , new info , size + 4 ) ; byte array . write16bit ( descriptor index , new info , size + 6 ) ; byte array . write16bit ( index , new info , size + 8 ) ; info = new info ; }
public const pool writer get const pool ( ) { return const pool ; }
public void remove code attribute ( ) { attribute info . remove ( attribute , code attribute . tag ) ; }
public final line number table get line number table ( ) { code code = get code ( ) ; if ( code ! = null ) return code . get line number table ( ) ; return null ; }
public int class index ( ) { return byte array . read u16bit ( get ( ) , 0 ) ; }
public static method signature to method signature ( string sig ) throw bad bytecode { try { return parse method sig ( sig ) ; } catch ( index out of bound exception e ) { throw error ( sig ) ; } }
public boolean be indexed ( ) { if ( type == null ) { return ( false ) ; } else if ( type . be array ( ) ) { return ( true ) ; } else if ( list . class . be assignable from ( type ) ) { return ( true ) ; } else { return ( false ) ; } }
public string get message ( ) { if ( super . get message ( ) ! = null ) { return super . get message ( ) ; } else if ( cause ! = null ) { return cause . to string ( ) ; } else { return null ; } }
protected class find class ( string name ) throw class not find exception { if ( ( context ! = null ) & & ( context . get class resolver ( ) ! = null ) ) { return context . get class resolver ( ) . class for name ( name , context ) ; } return super . find class ( name ) ; }
public string get bind source ( ) { if ( source instanceof class ) { return stack trace element . for type ( ( class ) source ) . to string ( ) ; } else if ( source instanceof member ) { return stack trace element . for member ( ( member ) source ) . to string ( ) ; } else { return source . to string ( ) ; } }
public void replace field write ( ct field field , ct class call class , string call method ) { transformer = new transform write field ( transformer , field , call class . get name ( ) , call method ) ; }
public static a s t list concat ( a s t list a , a s t list b ) { if ( a == null ) return b ; a s t list list = a ; while ( list . right ! = null ) list = list . right ; list . right = b ; return a ; }
protect void at return stmnt ( stmnt st ) throw compile error { a s tree result = st . get left ( ) ; if ( result ! = null & & return type == ct class . void type ) { compile expr ( result ) ; if ( is2word ( expr type , array dim ) ) bytecode . add opcode ( pop2 ) ; else if ( expr type ! = void ) bytecode . add opcode ( pop ) ; result = null ; } at return stmnt2 ( result ) ; }
public class node extract static receiver ( method call call ) { if ( call instanceof static method call expression ) { return ( ( static method call expression ) call ) . get owner type ( ) ; } else if ( call instanceof method call expression ) { expression object expr = ( ( method call expression ) call ) . get object expression ( ) ; if ( object expr instanceof class expression & & class helper . c l a s s_ type . equal ( object expr . get type ( ) ) ) { generic type [ ] generic type = object expr . get type ( ) . get generic type ( ) ; if ( generic type ! =null & & generic type . length==1 ) { return generic type [ 0 ] . get type ( ) ; } } if ( object expr instanceof class expression ) { return object expr . get type ( ) ; } } return null ; }
public a s t list parse member1 ( symbol table tbl ) throw compile error { a s t list mod = parse member mod ( ) ; declarator d ; boolean be constructor = false ; if ( lex . look ahead ( ) == identifier & & lex . look ahead ( 1 ) == ' ( ' ) { d = new declarator ( void , 0 ) ; be constructor = true ; } else d = parse formal type ( tbl ) ; if ( lex . get ( ) ! = identifier ) throw new syntax error ( lex ) ; string name ; if ( be constructor ) name = method decl . init name ; else name = lex . get string ( ) ; d . set variable ( new symbol ( name ) ) ; if ( be constructor || lex . look ahead ( ) == ' ( ' ) return parse method1 ( tbl , be constructor , mod , d ) ; return parse field ( tbl , mod , d ) ; }
public void set insert before ( boolean insert before ) { f insert before= insert before ; }
public string get file name ( ) { class file cf = this class . get class file2 ( ) ; if ( cf == null ) return null ; return cf . get source file ( ) ; }
public static matcher < class > subclass of ( final class < ? > superclass ) { return new subclass of ( superclass ) ; }
public ct class get return type ( ) throw not find exception { return get return type0 ( ) ; }
public ct class [ ] get declare class ( ) throw not find exception { return get nested class ( ) ; }
public ct field [ ] get declare field ( ) { return new ct field [ 0 ] ; }
public ct field get declared field ( string name ) throw not find exception { throw new not find exception ( name ) ; }
public ct method [ ] get declare method ( ) { return new ct method [ 0 ] ; }
public void set prune element ( boolean prune element ) { this . prune element = prune element ; if ( prune element ) { get reader ( ) . set default handler ( new prune element handler ( ) ) ; } }
public ct class get type ( ) throw not find exception { const pool cp = get const pool ( ) ; int pos = current po ; int index = iterator . u16bit at ( pos + 1 ) ; string name = cp . get class info ( index ) ; return this class . get class pool ( ) . get ct class ( name ) ; }
public string get name ( ) { if ( method info . be static initializer ( ) ) return method info . name clinit ; return declare class . get simple name ( ) ; }
public method info list get ( final string method name ) { boolean have method with name = false ; for ( final method info mi : this ) { if ( mi . get name ( ) . equal ( method name ) ) { have method with name = true ; break ; } } if ( ! have method with name ) { return empty_list ; } else { final method info list match method = new method info list ( 2 ) ; for ( final method info mi : this ) { if ( mi . get name ( ) . equal ( method name ) ) { match method . add ( mi ) ; } } return match method ; } }
public static ct method copy ( ct method src , ct class declaring , class map map ) throw can not compile exception { return new ct method ( src , declare , map ) ; }
public exception table copy ( const pool new cp , map classnames ) { exception table et = new exception table ( new cp ) ; const pool src cp = const pool ; int len = size ( ) ; for ( int i = 0 ; i < len ; ++i ) { exception table entry e = ( exception table entry ) entry . get ( i ) ; int type = src cp . copy ( e . catch type , new cp , classnames ) ; et . add ( e . start pc , e . end pc , e . handler pc , type ) ; } return et ; }
public void edit ( method call m ) throw can not compile exception { }
public void edit ( handler h ) throw can not compile exception { }
public ct class get type ( ) throw not find exception { const pool cp = get const pool ( ) ; int pos = current po ; int index = iterator . u16bit at ( pos + 1 ) ; string name = cp . get class info ( index ) ; return this class . get class pool ( ) . get ct class ( name ) ; }
public final ct method get enclose method ( ) throw not find exception { ct behavior b = get enclose behavior ( ) ; if ( b == null ) return null ; else if ( b instanceof ct method ) return ( ct method ) b ; else throw new not find exception ( b . get long name ( ) + `` be enclose `` + get name ( ) ) ; }
public static boolean be package ( int mod ) { return ( mod & ( public | private | protect ) ) == 0 ; }
public static boolean be public ( int mod ) { return ( mod & public ) ! = 0 ; }
public static void set use context class loader locally ( ) { use_context_class_loader_locally . set ( true ) ; }
public static class < ? > [ ] to primitive type ( class < ? > [ ] type ) { if ( type == null ) { throw new illegal argument exception ( `` type can not be null `` ) ; } class < ? > [ ] convert type = new class < ? > [ type . length ] ; for ( int i = 0 ; i < type . length ; i++ ) { final class < ? > original type = type [ i ] ; class < ? > primitive type = primitive wrapper . get ( original type ) ; if ( primitive type == null ) { convert type [ i ] = original type ; } else { converted type [ i ] = primitive type ; } } return converted type ; }
public boolean be use cache ( ) { return _use cache ; }
public void set use write replace ( boolean use write replace ) { factory write replace = use write replace ; }
public void on frame ( frame frame ) { / * ignore , not support by jsr-356 * / }
public void on input stream ( input stream stream ) { / * not support in listener mode ( yet ) * / }
public long get date header ( string name ) { return this . _get http servlet request ( ) . get date header ( name ) ; }
public string get servlet path ( ) { return this . _get http servlet request ( ) . get servlet path ( ) ; }
public string get servlet path ( ) { return this . _get http servlet request ( ) . get servlet path ( ) ; }
public boolean be request session id valid ( ) { return this . _get http servlet request ( ) . be request session id valid ( ) ; }
public void set status ( int sc , string sm ) { this . _get http servlet response ( ) . set status ( sc , sm ) ; }
public void println ( int i ) throw i o exception { print ( i ) ; println ( ) ; }
public void println ( int i ) throw i o exception { print ( i ) ; println ( ) ; }
public void add request content length ( long content length ) { if ( content length < 0 ) throw new illegal argument exception ( ) ; synchronize ( lock ) { if ( this . request content length == -1 ) this . request content length = content length ; else this . request content length += content length ; } }
public string get remote addr forward ( ) { string remote addr proxy = ( string ) req . get attribute ( constant . remote_addr_attribute ) ; if ( remote addr proxy == null ) { return get remote addr ( ) ; } return remote addr proxy ; }
public void set remote host ( string remote host ) { this . remote host = remote host ; }
public string get local hostname ( ) { try { inet address addr = inet address . get local host ( ) ; return addr . get host name ( ) ; } catch ( unknown host exception uhe ) { add error ( `` could not determine local host name `` , uhe ) ; return `` unknown_localhost `` ; } }
public boolean be wrapper for ( class < ? > wrap type ) { if ( ! servlet response . class . be assignable from ( wrapped type ) ) { throw new illegal argument exception ( `` give class `` + wrap type . get name ( ) + `` not a subinterface of `` + servlet response . class . get name ( ) ) ; } if ( wrapped type . be assignable from ( response . get class ( ) ) ) { return true ; } else if ( response instanceof servlet response wrapper ) { return ( ( servlet response wrapper ) response ) . be wrapper for ( wrapped type ) ; } else { return false ; } }
public void type ( string content type ) { response . set content type ( content type ) ; }
public int get buffer size ( ) { return get manager ( ) . get buff size ( ) ; }
public set < string > subprotocols ( ) { set < string > ret = new link hash set < string > ( ) ; collection . add all ( ret , subprotocols ) ; return ret ; }
public void remove session ( session session ) { single sign on session key key = new single sign on session key ( session ) ; session key . remove ( key ) ; }
public session session ( ) { if ( session == null || ! valid session ) { valid session ( true ) ; session = new session ( servlet request . get session ( ) , this ) ; } return session ; }
public void set decl handler ( decl handler decl handler ) { this . decl handler = decl handler ; }
public static j a x b context new instance ( string context path , class loader class loader ) throw j a x b exception { return new instance ( context path , class loader , collection . < string , object > empty map ( ) ) ; }
public q name get xml name ( ) { return xml name ; }
public final boolean be element ( ) { return ( flag & flag_is_element ) ! =0 ; }
public void write external ( object output out ) throw i o exception { out . write u t f ( to string ( ) ) ; out . flush ( ) ; }
public void finish ( ) throw i o exception { if ( ! deflater . finish ( ) ) { deflater . finish ( ) ; while ( ! deflater . finish ( ) ) { deflate ( ) ; } write trailer ( ) ; } }
public static string get prefix ( string qname ) { int colon = qname . index of ( ' : ' ) ; if ( colon < 0 ) { return `` `` ; } return qname . substring ( 0 , colon ) ; }
public static log _new log ( class clazz ) { class registry . put ( clazz , clazz ) ; return ( log factory == null ) ? new simple log ( clazz . get name ( ) ) : log factory . get instance ( clazz . get name ( ) ) ; }
public object get inner peer ( ) { if ( assoc ! =null & & be inplace mode ) return assoc . get inner peer ( current element ) ; else return null ; }
public void check output spec ( job context context ) { check output spec ( hadoop compat . get configuration ( context ) ) ; }
public e peek first ( ) { return peek ( ) ; }
public static schema factory create schema factory ( final string language , boolean disable secure processing ) throw illegal state exception { try { schema factory factory = schema factory . new instance ( language ) ; if ( logger . be loggable ( level . fine ) ) { logger . log ( level . fine , `` schema factory instance : { 0 } `` , factory ) ; } factory . set feature ( x m l constant . feature_secure_processing , ! be x m l security disable ( disable secure processing ) ) ; return factory ; } catch ( s a x not recognize exception ex ) { logger . log ( level . severe , null , ex ) ; throw new illegal state exception ( ex ) ; } catch ( s a x not support exception ex ) { logger . log ( level . severe , null , ex ) ; throw new illegal state exception ( ex ) ; } catch ( abstract method error er ) { logger . log ( level . severe , null , er ) ; throw new illegal state exception ( message . invalid_jaxp_implementation . format ( ) , er ) ; } }
public list depth first ( ) { list answer = new node list ( ) ; answer . add ( this ) ; answer . add all ( depth first rest ( ) ) ; return answer ; }
public void set context support ( context support context support ) { this . context support = context support ; }
public feature map get feature ( ) { if ( feature == null ) { feature = new simple feature map impl ( ) ; } return feature ; }
public object get user data ( string key ) { return user data . get ( key ) ; }
public boolean any match ( final predicate < ? super e > predicate ) { return iterable utils . match any ( iterable , predicate ) ; }
public string to string ( ) { final string builder buf = new string builder ( 1024 ) ; if ( ! module path . be empty ( ) ) { buf . append ( `` -- module-path= `` ) ; buf . append ( join . join ( file . path separator , module path ) ) ; } if ( ! add module . be empty ( ) ) { if ( buf . length ( ) > 0 ) { buf . append ( ' ' ) ; } buf . append ( `` -- add-modules= `` ) ; buf . append ( join . join ( `` , `` , add module ) ) ; } for ( final string patch module entry : patch module ) { if ( buf . length ( ) > 0 ) { buf . append ( ' ' ) ; } buf . append ( `` -- patch-module= `` ) ; buf . append ( patch module entry ) ; } for ( final string add export entry : add export ) { if ( buf . length ( ) > 0 ) { buf . append ( ' ' ) ; } buf . append ( `` -- add-exports= `` ) ; buf . append ( add export entry ) ; } for ( final string add open entry : add open ) { if ( buf . length ( ) > 0 ) { buf . append ( ' ' ) ; } buf . append ( `` -- add-opens= `` ) ; buf . append ( add open entry ) ; } for ( final string add read entry : add read ) { if ( buf . length ( ) > 0 ) { buf . append ( ' ' ) ; } buf . append ( `` -- add-reads= `` ) ; buf . append ( add read entry ) ; } return buf . to string ( ) ; }
public string text ( ) { if ( value instanceof string ) { return ( string ) value ; } if ( value instanceof node list ) { return ( ( node list ) value ) . text ( ) ; } if ( value instanceof collection ) { collection coll = ( collection ) value ; string previous text = null ; string builder sb = null ; for ( object child : coll ) { string child text = null ; if ( child instanceof string ) { child text = ( string ) child ; } else if ( child instanceof node ) { child text = ( ( node ) child ) . text ( ) ; } if ( child text ! = null ) { if ( previous text == null ) { previous text = child text ; } else { if ( sb == null ) { sb = new string builder ( ) ; sb . append ( previous text ) ; } sb . append ( child text ) ; } } } if ( sb ! = null ) { return sb . to string ( ) ; } else { if ( previous text ! = null ) { return previous text ; } return `` `` ; } } return `` `` + value ; }
protect locale find locale for language ( string language ) { locale [ ] locales = locale . get available locale ( ) ; for ( int i = 0 , size = locale . length ; i < size ; i++ ) { locale locale = locales [ i ] ; if ( language . equal ( locale . get language ( ) ) ) { string country = locale . get country ( ) ; if ( country == null || country . length ( ) == 0 ) { string variant = locale . get variant ( ) ; if ( variant == null || variant . length ( ) == 0 ) { return locale ; } } } } return null ; }
public static boolean evaluate ( object obj , navigator nav ) { return ( ( boolean function . evaluate ( obj , nav ) . boolean value ( ) ) ? boolean . false : boolean . true ) ; }
public string translate namespace prefix to uri ( string prefix ) { return get context support ( ) . translate namespace prefix to uri ( prefix ) ; }
public x path create x path ( string xpath expression ) throw invalid x path exception { default x path xpath = new default x path ( xpath expression ) ; if ( xpath namespace u r be ! = null ) { xpath . set namespace u r be ( xpath namespace u r be ) ; } return xpath ; }
public iterator iterator ( ) { return new iterator ( ) { iterator i = underlie . iterator ( ) ; public boolean have next ( ) { return i . have next ( ) ; } public object next ( ) { return i . next ( ) ; } public void remove ( ) { throw new unsupported operation exception ( ) ; } } ; }
public final int get position ( ) { return this . position ; }
public ex hyperlink atom get ex hyperlink atom ( ) { return link atom ; }
public void set render hint ( render hint . key hint key , object hint value ) { _hints . put ( hint key , hint value ) ; }
public void work start ( work event e ) { }
public void log ( level level , object message , object [ ] params , throwable t ) { do log ( level , fqcn , message , params , t ) ; }
public void warn ( string logger fqcn , object message , throwable t ) { do log ( level . warn , logger fqcn , message , null , t ) ; }
protect object write replace ( ) throw object stream exception { return new generate message lite . serialize form ( this ) ; }
public void set auto flush ( final boolean auto flush ) throw security exception { this . auto flush = auto flush ; if ( auto flush ) { flush ( ) ; } }
public static format step text format step ( final string string ) { return new format step ( ) { public void render ( final string builder builder , final ext log record record ) { builder . append ( string ) ; } public int estimate length ( ) { return string . length ( ) ; } public item type get item type ( ) { return item type . text ; } } ; }
public static format step message format step ( final boolean leave justify , final int minimum width , final int maximum width ) { return message format step ( left justify , minimum width , default_truncate_beginning , maximum width ) ; }
public static format step level format step ( final boolean leave justify , final int minimum width , final int maximum width ) { return level format step ( left justify , minimum width , default_truncate_beginning , maximum width ) ; }
public void set step ( final format step [ ] step ) { this . step = step == null || step . length == 0 ? empty_steps : step . clone ( ) ; calculate builder length ( ) ; }
public static closeable a closeable ( final socket socket ) { if ( closeable . class . be assignable from ( socket . get class ( ) ) ) { return closeable . class . cast ( socket ) ; } else { return new closeable ( ) { @ override public void close ( ) throw i o exception { socket . close ( ) ; } } ; } }
public synchronize void set output encode ( string output encode ) { if ( output encode == null ) { throw new illegal argument exception ( `` output encode must not be null `` ) ; } else { this . output encode = output encode ; } }
public void set limit ( int limit ) { if ( buffer == null ) { buffer = byte buffer . allocate ( limit ) ; buffer . flip ( ) ; } }
public string get suffix ( ) { if ( suffix rotator == suffix rotator . empty ) { return null ; } return suffix rotator . to string ( ) ; }
public protocol protocol ( ) { return protocol ; }
public facility get facility ( ) { synchronize ( output lock ) { return facility ; } }
public void set hostname ( final string hostname ) throw unknown host exception { set address ( inet address . get by name ( hostname ) ) ; }
public < v > v get attachment ( string logger name , logger . attachment key < v > key ) { final logger node node = root logger . get if exists ( logger name ) ; if ( node == null ) return null ; return node . get attachment ( key ) ; }
public log get instance ( string name ) throw log configuration exception { log instance = ( log ) instance . get ( name ) ; if ( instance == null ) { instance = new instance ( name ) ; instance . put ( name , instance ) ; } return ( instance ) ; }
public static void clear ( ) { logger provider . provider . clear mdc ( ) ; }
public static void clear ( ) { ndc . get ( ) . trim to ( 0 ) ; }
public static executor context class loader executor ( final executor delegate , final class loader task class loader ) { return new delegate executor ( delegate ) { public void execute ( final runnable command ) { super . execute ( new context class loader save runnable ( task class loader , command ) ) ; } } ; }
public final boolean await terminal event ( ) { try { await ( ) ; return true ; } catch ( interrupted exception ex ) { thread . current thread ( ) . interrupt ( ) ; return false ; } }
public void set uncaught exception handler ( thread . uncaught exception handler uncaught exception handler ) { this . uncaught exception handler = uncaught exception handler ; }
public task executor builder await termination ( boolean await termination ) { return new task executor builder ( this . queue capacity , this . core pool size , this . max pool size , this . allow core thread time out , this . keep alive , await termination , this . await termination period , this . thread name prefix , this . task decorator , this . customizers ) ; }
public int get queue size ( ) { return no_queue_limit ? -1 : current queue size of ( queue size ) ; }
public void start ( boolean daemon ) throw exception { stopped=false ; if ( do thread ) { thread thread = new thread ( this ) ; thread . set daemon ( daemon ) ; thread . start ( ) ; } else { run ( ) ; } }
public static executor reject executor ( final string message ) { return new reject executor ( message ) ; }
public string get jar file name ( ) { return jar file name ; }
protect user transaction build user transaction ( transaction manager transaction manager ) { if ( transaction manager instanceof user transaction ) { return ( user transaction ) transaction manager ; } else { return new user transaction adapter ( transaction manager ) ; } }
public static transaction suspend any transaction ( ) { transaction manager tm = transaction manager locator . locate transaction manager ( ) ; try { return tm . suspend ( ) ; } catch ( system exception e ) { throw new runtime exception ( `` unable to suspend transaction `` , e ) ; } }
public void remove connection event listener ( connection event listener listener ) { debug code ( `` remove connection event listener ( listener ) ; `` ) ; listener . remove ( listener ) ; }
public static void kill container ( string jdbc url ) { synchronize ( jdbc url container cache ) { jdbc database container container = jdbc url container cache . get ( jdbc url ) ; if ( container ! = null ) { container . stop ( ) ; jdbc url container cache . remove ( jdbc url ) ; container connection . remove ( container . get container id ( ) ) ; initialize container . remove ( container . get container id ( ) ) ; } } }
public attribute type get attribute type ( ) { return type ; }
public int hash code ( ) { if ( hash code cache == null ) { hash code cache = super . hash code ( ) ; } return hash code cache ; }
public string to string ( ) { return new string buffer ( 64 ) . append ( `` [ text : `` ) . append ( get text ( ) ) . append ( `` ] `` ) . to string ( ) ; }
public void set property ( string id , object value ) { if ( property map == null ) { property map = new hash map ( ) ; } property map . put ( id , value ) ; }
public element get root element ( ) { int index = content . index of first element ( ) ; if ( index < 0 ) { throw new illegal state exception ( `` root element not set `` ) ; } return ( element ) content . get ( index ) ; }
public document add content ( int index , collection c ) { content . add all ( index , c ) ; return this ; }
public element set text ( string text ) { content . clear ( ) ; if ( text ! = null ) { add content ( new text ( text ) ) ; } return this ; }
public void set default mask ( ) { filter mask = element | cdata | text | comment | pi | entityref | document | doctype ; }
public void set text visible ( boolean visible ) { if ( visible ) { filter mask |= text ; } else { filter mask & = ~text ; } }
public document build ( org . w3c . dom . document dom document ) { document doc = factory . document ( null ) ; build tree ( dom document , doc , null , true ) ; return doc ; }
public void set factory ( final j d o m factory factory ) { set j d o m factory ( factory ) ; }
public document build ( url url ) throw j d o m exception , i o exception { string system i d = url . to external form ( ) ; return build ( new input source ( system i d ) ) ; }
public string get driver class name ( ) { return this . driver class ; }
public void set reuse parser ( final boolean reuse parser ) { this . reuse parser = reuse parser ; if ( ! reuse parser ) { engine = null ; } }
public void set ignore element content whitespace ( final boolean ignore white ) { this . ignore white = ignore white ; }
public static throwable get root cause ( throwable throwable ) { throwable cause = get cause ( throwable ) ; if ( cause ! = null ) { throwable = cause ; while ( ( throwable = get cause ( throwable ) ) ! = null ) { cause = throwable ; } } return cause ; }
public uri get u r i ( ) throw i o exception { if ( this . uri ! = null ) { return this . uri ; } else { return super . get u r i ( ) ; } }
public static format get compact format ( ) { format f = new format ( ) ; f . set text mode ( text mode . normalize ) ; return f ; }
public format set omit encode ( boolean omit encode ) { this . omit encode = omit encode ; return this ; }
public ivy node get real node ( ) { ivy node node = this . node . get real node ( ) ; if ( node ! = null ) { return node ; } else { return this . node ; } }
public void set decl handler ( decl handler decl handler ) { this . decl handler = decl handler ; }
public boolean get report d t d event ( ) { return report dtd event ; }
public processing instruction set pseudo attribute ( string name , string value ) { string reason = verifier . check process instruction data ( name ) ; if ( reason ! = null ) { throw new illegal data exception ( name , reason ) ; } reason = verifier . check process instruction data ( value ) ; if ( reason ! = null ) { throw new illegal data exception ( value , reason ) ; } this . map data . put ( name , value ) ; this . raw data = to string ( map data ) ; return this ; }
public string to string ( ) { return new string buffer ( ) . append ( `` [ comment : `` ) . append ( new org . jdom . output . x m l outputter ( ) . output string ( this ) ) . append ( `` ] `` ) . to string ( ) ; }
public string get text normalize ( ) { return text . normalize string ( get text ( ) ) ; }
public j d o m factory get factory ( ) { return factory ; }
public document get document ( ) { object src = ( ( j d o m input source ) get input source ( ) ) . get source ( ) ; document doc = null ; if ( src instanceof document ) { doc = ( document ) src ; } return doc ; }
public void set input source ( input source input source ) { throw new unsupported operation exception ( ) ; }
public string a string ( document doc ) { try { d o m source dom source = new d o m source ( doc ) ; string writer writer = new string writer ( ) ; stream result result = new stream result ( writer ) ; transformer factory tf = transformer factory . new instance ( ) ; transformer transformer = tf . new transformer ( ) ; transformer . transform ( dom source , result ) ; return writer . to string ( ) ; } catch ( transformer exception e ) { throw new illegal state exception ( e ) ; } }
public string a string ( document doc ) { try { d o m source dom source = new d o m source ( doc ) ; string writer writer = new string writer ( ) ; stream result result = new stream result ( writer ) ; transformer factory tf = transformer factory . new instance ( ) ; transformer transformer = tf . new transformer ( ) ; transformer . transform ( dom source , result ) ; return writer . to string ( ) ; } catch ( transformer exception e ) { throw new illegal state exception ( e ) ; } }
public static boolean be x m l name start character ( char c ) { return ( be x m l letter ( c ) || c == ' _ ' || c == ' : ' ) ; }
public string value of ( object context ) throw j d o m exception { try { current context = context ; return x path . string value of ( context ) ; } catch ( jaxen exception ex1 ) { throw new j d o m exception ( `` x path error while evaluate \ `` `` + x path . to string ( ) + `` \ `` : `` + ex1 . get message ( ) , ex1 ) ; } finally { current context = null ; } }
public void set variable ( x path variable variable , value representation value ) throw x path exception { sequence type require type = variable . get require type ( ) ; if ( require type ! = sequence type . any_sequence ) { x path exception err = type checker . test conformance ( value , require type , context object ) ; if ( err ! = null ) { throw err ; } } sequence iterator iter = value . a iterator ( value ) ; while ( true ) { item item = iter . next ( ) ; if ( item == null ) { break ; } if ( item instanceof node info ) { if ( ! ( ( node info ) item ) . get configuration ( ) . be compatible ( context object . get configuration ( ) ) ) { throw new x path exception ( `` supply node must be build use the same or a compatible configuration `` , saxon error code . sxxp0004 ) ; } } } int slot = variable . get local slot number ( ) ; structure q name expect name = ( slot > = stack frame map . get number of variable ( ) ? null : ( structure q name ) stack frame map . get variable map ( ) . get ( slot ) ) ; if ( ! variable . get variable q name ( ) . equal ( expect name ) ) { throw new x path exception ( `` supply x path variable be bind to the wrong slot : perhaps it be create use a different static context `` ) ; } context object . set local variable ( slot , value ) ; }
public element set attribute ( list new attribute ) { attribute . clear and set ( new attribute ) ; return this ; }
public string get amd ( ) { return get text property ( prefix+ `` : amd `` ) ; }
public void set instance i d ( string id ) { x m l util . set string value ( parent , `` st evt : instance i d `` , id ) ; }
public void set mangager variant ( string manager variant ) { x m l util . set string value ( parent , `` st ref : manager variant `` , manager variant ) ; }
public void set document i d ( string id ) { x m l util . set string value ( parent , `` st ref : document i d `` , id ) ; }
public string get image ( ) { return x m l util . get string value ( parent , `` xap g img : image `` ) ; }
public x m p schema dynamic medium add dynamic medium schema ( ) { x m p schema dynamic medium schema = new x m p schema dynamic medium ( this ) ; return ( x m p schema dynamic medium ) basic add schema ( schema ) ; }
public void merge ( x m p metadata metadata ) throw i o exception { list < x m p schema > schemas2 = metadata . get schemas ( ) ; for ( iterator < x m p schema > iterator = schemas2 . iterator ( ) ; iterator . have next ( ) ; ) { x m p schema schema2 = iterator . next ( ) ; x m p schema schema1 = get schema by class ( schema2 . get class ( ) ) ; if ( schema1 == null ) { element rdf = get r d f element ( ) ; rdf . append child ( xmp document . import node ( schema2 . get element ( ) , true ) ) ; } else { schema1 . merge ( schema2 ) ; } } }
public x m l document source get document source ( ) { return f document source ; } // get document source ( ) : x m l document source
public void merge ( x m p metadata metadata ) throw i o exception { list < x m p schema > schemas2 = metadata . get schemas ( ) ; for ( iterator < x m p schema > iterator = schemas2 . iterator ( ) ; iterator . have next ( ) ; ) { x m p schema schema2 = iterator . next ( ) ; x m p schema schema1 = get schema by class ( schema2 . get class ( ) ) ; if ( schema1 == null ) { element rdf = get r d f element ( ) ; rdf . append child ( xmp document . import node ( schema2 . get element ( ) , true ) ) ; } else { schema1 . merge ( schema2 ) ; } } }
public x m p schema basic job ticket add basic job ticket schema ( ) { x m p schema basic job ticket schema = new x m p schema basic job ticket ( this ) ; return ( x m p schema basic job ticket ) basic add schema ( schema ) ; }
public static x m p metadata load ( input source be ) throw i o exception { return new x m p metadata p d f a ( x m l util . parse ( be ) ) ; }
public list < string > get bag list ( string bag name ) { list < string > retval = null ; node list node = schema . get element by tag name ( bag name ) ; if ( node . get length ( ) > 0 ) { element contributor = ( element ) node . item ( 0 ) ; node list bag list = contributor . get element by tag name ( `` rdf : bag `` ) ; if ( bag list . get length ( ) > 0 ) { element bag = ( element ) bag list . item ( 0 ) ; retval = new array list < string > ( ) ; node list item = bag . get element by tag name ( `` rdf : li `` ) ; for ( int i = 0 ; i < item . get length ( ) ; i++ ) { element li = ( element ) item . item ( i ) ; retval . add ( x m l util . get string value ( li ) ) ; } retval = collection . unmodifiable list ( retval ) ; } } return retval ; }
public void add advisory ( string advisory ) { add bag value ( prefix + `` : advisory `` , advisory ) ; }
public void add advisory ( string advisory ) { add bag value ( prefix + `` : advisory `` , advisory ) ; }
public calendar get metadata date ( ) throw i o exception { return get date property ( prefix + `` : metadata date `` ) ; }
public void set modify date ( calendar date ) { set date property ( prefix + `` : modify date `` , date ) ; }
public void set thumbnail ( thumbnail thumbnail ) { set thumbnail property ( prefix + `` : thumbnail `` , null , thumbnail ) ; }
public thumbnail get thumbnail ( string language ) { return get thumbnail property ( prefix + `` : thumbnail `` , language ) ; }
public void set description ( string language , string description ) { set language property ( prefix + `` : description `` , language , description ) ; }
public void add language ( string language ) { add bag value ( prefix + `` : language `` , language ) ; }
public list < string > get owner ( ) { return get bag list ( prefix + `` : owner `` ) ; }
public string get right ( string language ) { return get language property ( prefix + `` : right `` , language ) ; }
public void add subject ( string subject ) { add bag value ( prefix + `` : subject `` , subject ) ; }
public list < string > get subject code ( ) { return get bag list ( prefix + `` : subject code `` ) ; }
public void set title ( string language , string title ) { set language property ( prefix + `` : title `` , language , title ) ; }
public string get title ( string language ) { return get language property ( prefix + `` : title `` , language ) ; }
public void set ci adr ctry ( string country ) { set text property ( prefix + `` : ci adr ctry `` , country ) ; }
public void set document i d ( string id ) { x m l util . set string value ( parent , `` st ref : document i d `` , id ) ; }
public void add history ( resource event event ) { add sequence value ( prefix + `` : history `` , event ) ; }
public void set keywords ( final string keywords ) { set1st property ( property i d map . pid_keywords , keywords ) ; }
public list < string > get supplemental category ( ) { return get bag list ( prefix + `` : supplemental category `` ) ; }
public list < string > get owner ( ) { return get bag list ( prefix + `` : owner `` ) ; }
public string get usage term ( string language ) { return get language property ( prefix + `` : usage term `` , language ) ; }
protect object invoke operation ( cache operation invoker invoker ) { return invoker . invoke ( ) ; }
public iterable < reader interceptor > get sort global reader interceptor ( ) { return sort global reader interceptor ; }
public static string persistence_unit_not_configured ( object arg0 ) { return localizer . localize ( localizable p e r s i s t e n c e_ u n i t_ n o t_ c o n f i g u r e d ( arg0 ) ) ; }
public static string closed_by_client_while_receiving ( ) { return localizer . localize ( localizable c l o s e d_ b y_ c l i e n t_ w h i l e_ r e c e i v i n g ( ) ) ; }
public static string sax_cannot_disable_general_entity_processing_feature ( object arg0 ) { return localizer . localize ( localizable s a x_ c a n n o t_ d i s a b l e_ g e n e r a l_ e n t i t y_ p r o c e s s i n g_ f e a t u r e ( arg0 ) ) ; }
public static string http_trailer_header_overflow ( ) { return localizer . localize ( localizable h t t p_ t r a i l e r_ h e a d e r_ o v e r f l o w ( ) ) ; }
public static string param_creation_factory_not_found ( object arg0 ) { return localizer . localize ( localizable p a r a m_ c r e a t i o n_ f a c t o r y_ n o t_ f o u n d ( arg0 ) ) ; }
public static string suspend_handler_execution_failed ( ) { return localizer . localize ( localizable s u s p e n d_ h a n d l e r_ e x e c u t i o n_ f a i l e d ( ) ) ; }
public static string error_listener_close ( object arg0 ) { return localizer . localize ( localizable e r r o r_ l i s t e n e r_ c l o s e ( arg0 ) ) ; }
public static string error_service_locator_provider_instance_feature_reader_interceptor_context ( object arg0 ) { return localizer . localize ( localizable e r r o r_ s e r v i c e_ l o c a t o r_ p r o v i d e r_ i n s t a n c e_ f e a t u r e_ r e a d e r_ i n t e r c e p t o r_ c o n t e x t ( arg0 ) ) ; }
public static string null_keystore ( ) { return localizer . localize ( localizable n u l l_ k e y s t o r e ( ) ) ; }
public static string client_uri_builder_null ( ) { return localizer . localize ( localizable c l i e n t_ u r i_ b u i l d e r_ n u l l ( ) ) ; }
public http header get response header ( ) { if ( collection utils . be empty ( this . supported medium type ) ) { return http header . empty ; } http header header = new http header ( ) ; header . set accept ( this . supported medium type ) ; return header ; }
public static void warning ( final object source , final string message ) { error ( source , message , severity . warn ) ; }
public boolean fatal issue find ( ) { for ( resource model issue issue : get issue list ( ) ) { if ( issue . get severity ( ) == severity . fatal ) { return true ; } } return false ; }
protect runnable wrap task ( runnable command ) { final callable < object > wrap = wrap task ( executor . callable ( command , null ) ) ; return new runnable ( ) { @ override public void run ( ) { try { wrapped . call ( ) ; } catch ( exception e ) { throwables . propagate ( e ) ; } } } ; }
public throwable get throwable ( ) { if ( throwable == null ) { if ( exception proxy ! = null ) { throwable = exception proxy . create exception ( ) ; } } return throwable ; }
public static boolean be bind ( ) { create modeler binding ( ) ; return modeler binding . can bind ( ) ; }
public a s t node find declare node ( i bind binding ) { return this . ast . get binding resolver ( ) . find declaring node ( bind ) ; }
public t analyzer ( string analyzer ) { this . analyzer = analyzer ; return ( t ) this ; }
public alias binding rank ( int rank ) { this . rank = optional int . of ( rank ) ; return this ; }
public void set injectee descriptor ( active descriptor < ? > injectee descriptor ) { this . injectee descriptor = injectee descriptor ; }
public static list < string > get name for class ( list < ? extend object > instance ) { list < string > name = new array list < string > ( ) ; if ( instance ! = null ) { for ( object instance : instance ) { string name = get name for class ( instance ) ; if ( name ! = null ) { name . add ( name ) ; } } } return name ; }
public static string warnings_detected ( object arg0 ) { return localizer . localize ( localizable w a r n i n g s_ d e t e c t e d ( arg0 ) ) ; }
public static string uri_component_encoded_octet_invalid_digit ( object arg0 , object arg1 ) { return localizer . localize ( localizable u r i_ c o m p o n e n t_ e n c o d e d_ o c t e t_ i n v a l i d_ d i g i t ( arg0 , arg1 ) ) ; }
public static string error_template_parser_illegal_char_part_of_name ( object arg0 , object arg1 , object arg2 ) { return localizer . localize ( localizable e r r o r_ t e m p l a t e_ p a r s e r_ i l l e g a l_ c h a r_ p a r t_ o f_ n a m e ( arg0 , arg1 , arg2 ) ) ; }
public static string error_processing_response_from_already_mapped_exception ( ) { return localizer . localize ( localizable e r r o r_ p r o c e s s i n g_ r e s p o n s e_ f r o m_ a l r e a d y_ m a p p e d_ e x c e p t i o n ( ) ) ; }
public static string error_notfound_messagebodywriter ( object arg0 , object arg1 , object arg2 ) { return localizer . localize ( localizable e r r o r_ n o t f o u n d_ m e s s a g e b o d y w r i t e r ( arg0 , arg1 , arg2 ) ) ; }
public static string injection_error_local_class_not_supported ( object arg0 ) { return localizer . localize ( localizable i n j e c t i o n_ e r r o r_ l o c a l_ c l a s s_ n o t_ s u p p o r t e d ( arg0 ) ) ; }
public static string unable_to_parse_header_value ( object arg0 , object arg1 ) { return localizer . localize ( localizable u n a b l e_ t o_ p a r s e_ h e a d e r_ v a l u e ( arg0 , arg1 ) ) ; }
public static string error_interceptor_reader_proceed ( ) { return localizer . localize ( localizable e r r o r_ i n t e r c e p t o r_ r e a d e r_ p r o c e e d ( ) ) ; }
public static string http_header_no_end_separator ( object arg0 ) { return localizer . localize ( localizable h t t p_ h e a d e r_ n o_ e n d_ s e p a r a t o r ( arg0 ) ) ; }
public static string mbw_trying_to_close_stream ( object arg0 ) { return localizer . localize ( localizable m b w_ t r y i n g_ t o_ c l o s e_ s t r e a m ( arg0 ) ) ; }
public static string error_service_locator_provider_instance_feature_context ( object arg0 ) { return localizer . localize ( localizable e r r o r_ s e r v i c e_ l o c a t o r_ p r o v i d e r_ i n s t a n c e_ f e a t u r e_ c o n t e x t ( arg0 ) ) ; }
public alias routing ( string rout ) { this . index rout = routing ; this . search rout = routing ; return this ; }
public static < t > service finder < t > find ( final class < t > service ) throw service configuration error { return find ( service , _get context class loader ( ) , false ) ; }
public static < t > service finder < t > find ( final class < t > service ) throw service configuration error { return find ( service , _get context class loader ( ) , false ) ; }
public string integration test jvm ( ) { return common ( ) + `` test jvm `` ; }
public static class type pair of ( class < ? > raw class , type type ) { return new class type pair ( raw class , type ) ; }
public static < e > set < e > set union view ( final set < ? extend e > set1 , final set < ? extend e > set2 ) { check not null ( set1 , `` set1 `` ) ; check not null ( set2 , `` set2 `` ) ; return new abstract set < e > ( ) { @ override public iterator < e > iterator ( ) { return get union ( set1 , set2 ) . iterator ( ) ; } @ override public int size ( ) { return get union ( set1 , set2 ) . size ( ) ; } private set < e > get union ( set < ? extend e > set1 , set < ? extend e > set2 ) { hash set < e > hash set = new hash set < > ( set1 ) ; hash set . add all ( set2 ) ; return hash set ; } } ; }
public static string collection ( collection < ? > collection ) { if ( collection == null ) return null_string ; return array ( collection . to array ( new object [ collection . size ( ) ] ) ) ; }
public static < t > t get value ( map < string , ? > property , string key , t default value , map < string , string > legacy map ) { return get value ( property , null , key , default value , legacy map ) ; }
public static list < class type pair > get type argument and class ( final type type ) throw illegal argument exception { final type [ ] type = get type argument ( type ) ; if ( type == null ) { return collection . empty list ( ) ; } return array . stream ( type ) . map ( type1 - > class type pair . of ( erasure ( type1 ) , type1 ) ) . collect ( collector . to list ( ) ) ; }
public static class < ? > get m x bean interface ( class < ? > clazz ) { if ( clazz == null || clazz . get superclass ( ) == null ) { return null ; } class < ? > [ ] implement interface = clazz . get interface ( ) ; for ( class < ? > iface : implemented interface ) { if ( jmx . be m x bean interface ( iface ) ) { return iface ; } } return get m x bean interface ( clazz . get superclass ( ) ) ; }
public static string [ ] tokenize ( final string [ ] entry , final string delimiters ) { final list < string > token = new link list < string > ( ) ; for ( string entry : entry ) { if ( entry == null || entry . be empty ( ) ) { continue ; } entry = entry . trim ( ) ; if ( entry . be empty ( ) ) { continue ; } tokenize ( entry , delimiters , token ) ; } return token . to array ( new string [ token . size ( ) ] ) ; }
public static mime type create ( input stream . . . input stream ) throw i o exception , mime type exception { mime type mime type = new mime type ( ) ; mime type reader reader = new mime type reader ( mime type ) ; for ( input stream input stream : input stream ) { reader . read ( input stream ) ; } mime type . init ( ) ; return mime type ; }
public uri get location ( ) { return single header ( http header . location , new function < string , uri > ( ) { @ override public uri apply ( string value ) { try { return uri . create ( value ) ; } catch ( illegal argument exception ex ) { throw new process exception ( ex ) ; } } } , false ) ; }
public void close ( ) throw i o exception { if ( ! close ) { this . finish ( ) ; this . buffer . close ( ) ; out . close ( ) ; close = true ; } }
public set < match entity tag > get if match ( ) { final string if match = get header string ( http header . if_match ) ; if ( if match == null || if match . be empty ( ) ) { return null ; } try { return http header reader . read match entity tag ( if match ) ; } catch ( java . text . parse exception e ) { throw exception ( http header . if_match , if match , e ) ; } }
public annotation [ ] get entity annotation ( ) { return entity annotation . clone ( ) ; }
public static int get quality ( medium type mt ) { final string q param = mt . get parameter ( ) . get ( quality . quality_parameter_name ) ; return read quality factor ( q param ) ; }
public static component bag new instance ( predicate < contract provider > registration strategy ) { return new component bag ( registration strategy ) ; }
public instance reference current ( ) throw illegal state exception { return current ( ) . get reference ( ) ; }
public static < data > stage . builder < data > chain ( chainable stage < data > root stage ) { return new stage chain builder < data > ( root stage ) ; }
public static char to char ( string str ) { if ( string utils . be empty ( str ) ) { throw new illegal argument exception ( `` the string must not be empty `` ) ; } return str . char at ( 0 ) ; }
public final boolean be template variable present ( string name ) { for ( string s : template variable ) { if ( s . equal ( name ) ) { return true ; } } return false ; }
protect uri pattern create uri pattern ( uri template parser template parser ) { return new uri pattern ( template parser . get pattern ( ) , template parser . get group index ( ) ) ; }
public date read element value a unspecified date ( ) throw exception { return date time utils . convert date string to date ( read element value ( ) ) ; }
public static boolean contain white space ( string s ) { for ( char c : s . to char array ( ) ) { if ( be white space ( c ) ) { return true ; } } return false ; }
public static list < medium type > create from ( string [ ] medium type ) { list < medium type > result = new array list < medium type > ( ) ; try { for ( string medium type : medium type ) { http header reader . read medium type ( result , medium type ) ; } } catch ( parse exception ex ) { throw new illegal argument exception ( ex ) ; } collection . sort ( result , partial_order_comparator ) ; return collection . unmodifiable list ( result ) ; }
public static privilege action set accessible method p a ( final method m ) { if ( modifier . be public ( m . get modifier ( ) ) ) { return no op privilege a c t i o n ; } return new privilege action < object > ( ) { @ override public object run ( ) { if ( ! m . be accessible ( ) ) { m . set accessible ( true ) ; } return m ; } } ; }
public static class [ ] get parameterized class argument ( declare class interface pair p ) { if ( p . generic interface instanceof parameterized type ) { parameterized type pt = ( parameterized type ) p . generic interface ; type [ ] a = pt . get actual type argument ( ) ; class [ ] ca = new class [ a . length ] ; for ( int i = 0 ; i < a . length ; i++ ) { type a = a [ i ] ; if ( a instanceof class ) { cas [ i ] = ( class ) a ; } else if ( a instanceof parameterized type ) { pt = ( parameterized type ) a ; ca [ i ] = ( class ) pt . get raw type ( ) ; } else if ( a instanceof type variable ) { class type pair ctp = resolve type variable ( p . concrete class , p . declare class , ( type variable ) a ) ; cas [ i ] = ( ctp ! = null ) ? ctp . c : object . class ; } } return ca ; } else { return null ; } }
public static string error_provider_and_resource_constrained_to_ignored ( object arg0 ) { return localizer . localize ( localizable e r r o r_ p r o v i d e r_ a n d_ r e s o u r c e_ c o n s t r a i n e d_ t o_ i g n o r e d ( arg0 ) ) ; }
public static string exception_sending_error_response ( object arg0 , object arg1 ) { return localizer . localize ( localizable e x c e p t i o n_ s e n d i n g_ e r r o r_ r e s p o n s e ( arg0 , arg1 ) ) ; }
public static string error_unmarshalling_jaxb ( object arg0 ) { return localizer . localize ( localizable e r r o r_ u n m a r s h a l l i n g_ j a x b ( arg0 ) ) ; }
public final string get domain ( ) { if ( domain == null ) { domain = get domain internal ( ) ; } if ( domain == null ) { domain = globals . default_mbean_domain ; } return domain ; }
public final parse context override path ( final content path path ) { return new filter parse context ( this ) { @ override public content path path ( ) { return path ; } } ; }
public int hash code ( ) { int hash = 7 ; hash = 29 * hash + ( this . language ! = null ? this . language . hash code ( ) : 0 ) ; hash = 29 * hash + ( this . medium type ! = null ? this . medium type . hash code ( ) : 0 ) ; hash = 29 * hash + ( this . encode ! = null ? this . encode . hash code ( ) : 0 ) ; return hash ; }
public string value ( ) { if ( have value ( ) ) { return value [ 0 ] ; } else { return null ; } }
public int hash code ( ) { if ( address == null ) return 0 ; else return address . to lower case ( locale . english ) . hash code ( ) ; }
public static string field ( field field ) { if ( field == null ) { return null_string ; } type t = field . get generic type ( ) ; string base string ; if ( t instanceof class ) { base string = clazz ( ( class < ? > ) t ) ; } else { base string = type ( t ) ; } return `` field ( `` + base string + `` `` + field . get name ( ) + `` in `` + field . get declare class ( ) . get name ( ) + `` ) `` ; }
public boolean have unresolvable generic ( ) { if ( this == none ) { return false ; } resolvable type [ ] generic = get generic ( ) ; for ( resolvable type generic : generic ) { if ( generic . be unresolvable type variable ( ) || generic . be wildcard without bound ( ) ) { return true ; } } class < ? > resolve = resolve ( ) ; if ( resolve ! = null ) { for ( type generic interface : resolve . get generic interface ( ) ) { if ( generic interface instanceof class ) { if ( for class ( ( class < ? > ) generic interface ) . have generic ( ) ) { return true ; } } } return get super type ( ) . have unresolvable generic ( ) ; } return false ; }
protect set < string > return filter scope ( final set < string > filter scope , final boolean return default fallback ) { return return default fallback & & filter scope . be empty ( ) ? filter helper . get default filter scope ( ) : filtering scope ; }
protect boolean have match medium type for writing ( medium type medium type ) { return have match medium type ( medium type ) ; }
protect void introspect ( object o ) { _introspector . introspect ( o . get class ( ) ) ; }
public static boolean be simple type ( class < ? > clazz ) { return simple_type_set . contains ( clazz ) ; }
public list < string > get c s v ( http header header , boolean keep quote ) { quote c s v value = null ; for ( http field f : this ) { if ( f . get header ( ) == header ) { if ( value == null ) value = new quote c s v ( keep quote ) ; value . add value ( f . get value ( ) ) ; } } return value == null ? collection . empty list ( ) : value . get value ( ) ; }
public void add ( http field field ) { if ( field == null ) return ; enumeration < string > e = field . get field name ( ) ; while ( e . have more element ( ) ) { string name = e . next element ( ) ; enumeration < string > value = field . get value ( name ) ; while ( value . have more element ( ) ) add ( name , value . next element ( ) ) ; } }
public void set sent date ( date d ) throw message exception { if ( d == null ) remove header ( `` date `` ) ; else { synchronize ( mail date format ) { set header ( `` date `` , mail date format . format ( d ) ) ; } } }
public byte buffer to byte buffer ( ) { byte buffer combine buffer = take byte buffer ( ) ; _buffers . add ( combine buffer ) ; return combine buffer ; }
public network option set reuse port ( boolean reuse port ) { this . reuse port = reuse port ; return this ; }
public void generate payload ( frame frame , byte buffer buffer ) { byte buffer payload = frame . get payload ( ) ; if ( ! buffer util . have content ( payload ) ) return ; int po = buffer util . flip to fill ( buffer ) ; if ( frame . be mask ( ) ) mask payload ( buffer , frame ) ; else buffer . put ( payload . slice ( ) ) ; buffer util . flip to flush ( buffer , po ) ; }
public void init default definition ( ) { init task ( ) ; init type ( ) ; }
public void init ( filter config config ) throw servlet exception { for ( filter filter : this . filter ) { filter . init ( config ) ; } }
public void log ( string msg ) { get servlet context ( ) . log ( get servlet name ( ) + `` : `` + msg ) ; }
public authenticate user authenticate ( message context msg context ) { http servlet request req = ( http servlet request ) msg context . get property ( h t t p constant . mc_http_servletrequest ) ; if ( req == null ) return null ; log . debug ( message . get message ( `` got00 `` , `` http servlet request `` ) ) ; principal principal = req . get user principal ( ) ; if ( principal == null ) { log . debug ( message . get message ( `` no principal00 `` ) ) ; return null ; } log . debug ( message . get message ( `` get principal00 `` , principal . get name ( ) ) ) ; return new servlet authenticate user ( req ) ; }
default public http servlet map get http servlet mapping ( ) { return new http servlet mapping ( ) { @ override public string get match value ( ) { return `` `` ; } @ override public string get pattern ( ) { return `` `` ; } @ override public string get servlet name ( ) { return `` `` ; } @ override public mapping match get mapping match ( ) { return null ; } @ override public string to string ( ) { return `` map impl { `` + `` match value= `` + get match value ( ) + `` , pattern= `` + get pattern ( ) + `` , servlet name= `` + get servlet name ( ) + `` , map match= `` + get mapping match ( ) + `` } http servlet request { `` + http servlet request . this . to string ( ) + ' } ' ; } } ; }
public default void session create ( http session event se ) { }
public default void attribute remove ( servlet request attribute event srae ) { }
public string to string ( ) { return ( code + `` `` + reason phrase ) ; }
public list < class < ? extend decoder > > get decoder ( ) { return this . decoder ; }
public long get max output buffer size ( ) { return max output buffer size ; }
public collection < event handler with jacobians > get event handler ( ) { final collection < event handler with jacobians > handler = new array list < event handler with jacobians > ( ) ; for ( final event handler handler : integrator . get event handler ( ) ) { if ( handler instanceof event handler wrapper ) { handler . add ( ( ( event handler wrapper ) handler ) . get handler ( ) ) ; } } return handler ; }
public void apply to ( configurable application context context ) { apply to ( context . get environment ( ) ) ; }
public void exclude ( string connector name , string address pattern , path spec path spec ) { _set . exclude ( new pattern tuple ( connector name , inet address pattern . from ( address pattern ) , path spec ) ) ; }
protect string get webapp base ( http servlet request request ) { string buffer base u r l=new string buffer ( 128 ) ; base u r l . append ( request . get scheme ( ) ) ; base u r l . append ( `` : // `` ) ; base u r l . append ( request . get server name ( ) ) ; if ( request . get server port ( ) ! =80 ) { base u r l . append ( `` : `` ) ; base u r l . append ( request . get server port ( ) ) ; } base u r l . append ( request . get context path ( ) ) ; return base u r l . to string ( ) ; }
public set < granted authority > map authority ( collection < ? extends grant authority > authority ) { hash set < granted authority > map = new hash set < > ( authority . size ( ) ) ; for ( grant authority authority : authority ) { map . add ( map authority ( authority . get authority ( ) ) ) ; } if ( this . default authority ! = null ) { map . add ( this . default authority ) ; } return map ; }
protect void next protocol ( connector connector , end point end point , byte buffer buffer ) throw illegal state exception { string next protocol = find next protocol ( connector ) ; if ( log . be debug enable ( ) ) log . debug ( `` detector { } detection unsuccessful , find ' { } ' a the next protocol to upgrade to `` , get protocol ( ) , next protocol ) ; if ( next protocol == null ) throw new illegal state exception ( `` can not find protocol follow ' `` + get protocol ( ) + `` ' in connector 's protocol list `` + connector . get protocol ( ) + `` for `` + end point ) ; upgrade to connection factory ( connector . get connection factory ( next protocol ) , connector , end point ) ; }
public long get start time ( ) { if ( this . run state == state_unstarted ) { throw new illegal state exception ( `` stopwatch have not be start `` ) ; } return this . start time ; }
public string determine driver class name ( ) { if ( string utils . have text ( this . driver class name ) ) { assert . state ( driver class be loadable ( ) , ( ) - > `` can not load driver class : `` + this . driver class name ) ; return this . driver class name ; } string driver class name = null ; if ( string utils . have text ( this . url ) ) { driver class name = database driver . from jdbc url ( this . url ) . get driver class name ( ) ; } if ( ! string utils . have text ( driver class name ) ) { driver class name = this . embedded database connection . get driver class name ( ) ; } if ( ! string utils . have text ( driver class name ) ) { throw new data source bean creation exception ( `` fail to determine a suitable driver class `` , this , this . embedded database connection ) ; } return driver class name ; }
public void reseed random generator ( long seed ) { }
public void set prefer proxied for address ( boolean prefer proxied for address ) { _prefer proxied for address = prefer proxied for address ; }
public void add include method ( string . . . method ) { for ( string m : method ) { _methods . include ( m ) ; } }
public void add include path ( string . . . pathspecs ) { for ( string p : pathspecs ) _paths . include ( string util . csv split ( p ) ) ; }
public void set include method list ( string csv method ) { set include method ( string util . csv split ( csv method ) ) ; }
protect void set ( string [ ] entry , path map < i p address map < boolean > > pattern map ) { pattern map . clear ( ) ; if ( entry ! = null & & entry . length > 0 ) { for ( string addr path : entry ) { add ( addr path , pattern map ) ; } } }
public void set request header ( map request header ) { this . _request header = request header ; }
public object get factory ( ) { return factory ; }
public cache chain new cache chain ( list < filter holder > filter , servlet holder servlet holder ) { return new cache chain ( filter , servlet holder ) ; }
public boolean compare and set ( int expect hi , int hi , int expect lo , int lo ) { long encode = encode ( expect hi , expect lo ) ; long update = encode ( hi , lo ) ; return compare and set ( encoded , update ) ; }
public static string byte to string ( byte buffer b ) { return unpooled . wrap buffer ( b ) . to string ( standard charsets . utf_8 ) ; }
public static byte buffer to buffer ( byte [ ] array ) { if ( array == null ) return empty_buffer ; return to buffer ( array , 0 , array . length ) ; }
public static string to hex summary ( byte buffer buffer ) { if ( buffer == null ) return `` null `` ; string builder buf = new string builder ( ) ; buf . append ( `` b [ `` ) . append ( buffer . remain ( ) ) . append ( `` ] = `` ) ; for ( int i = buffer . position ( ) ; i < buffer . limit ( ) ; i++ ) { type util . to hex ( buffer . get ( i ) , buf ) ; if ( i == buffer . position ( ) + 24 & & buffer . limit ( ) > buffer . position ( ) + 32 ) { buf . append ( `` . . . `` ) ; i = buffer . limit ( ) - 8 ; } } return buf . to string ( ) ; }
public object get property ( string key ) { list < configuration node > nod = fetch node list ( key ) ; if ( node . size ( ) == 0 ) { return null ; } else { list < object > list = new array list < object > ( ) ; for ( configuration node node : node ) { if ( node . get value ( ) ! = null ) { list . add ( node . get value ( ) ) ; } } if ( list . size ( ) < 1 ) { return null ; } else { return ( list . size ( ) == 1 ) ? list . get ( 0 ) : list ; } } }
public string to string ( ) { return string . format ( fmt_to_string , integer . value of ( system . identity hash code ( this ) ) , string . value of ( get object ( ) ) ) ; }
public void add value ( string name , list < v > value ) { list < v > lo = get ( name ) ; if ( lo == null ) { lo = new array list < > ( ) ; } lo . add all ( value ) ; put ( name , lo ) ; }
public detach criterion create alias ( string association path , string alias ) { criterion . create alias ( association path , alias ) ; return this ; }
public string validate ( key store key store , string key alias ) throw certificate exception { string result = null ; if ( key alias ! = null ) { try { validate ( key store , key store . get certificate ( key alias ) ) ; } catch ( key store exception kse ) { log . debug ( `` unable to validate alias : { } `` , key alias , kse ) ; throw new certificate exception ( `` unable to validate certificate `` + `` for alias [ `` + key alias + `` ] : `` + kse . get message ( ) , kse ) ; } result = key alias ; } return result ; }
public static x509 certificate [ ] get cert chain ( s s l session ssl session ) { return get x509 cert chain ( null , ssl session ) ; }
public void set idle timeout ( int idle timeout ) { _executor . set keep alive time ( idle timeout , time unit . millisecond ) ; }
public void set thread description ( string thread description ) { _thread = thread description ; }
public void set max disk usage per part ( long max disk usage per part ) { this . max disk usage per part = max disk usage per part ; }
public collection < url > get tlds ( uri uri ) throw i o exception { hash set < url > tlds = new hash set < url > ( ) ; string jar uri = uri jar prefix ( uri , `` ! / `` ) ; url url = new url ( jar uri ) ; jar u r l connection jar conn = ( jar u r l connection ) url . open connection ( ) ; jar conn . set use cache ( resource . get default use cache ( ) ) ; jar file jar file = jar conn . get jar file ( ) ; enumeration < jar entry > entries = jar file . entry ( ) ; while ( entry . have more element ( ) ) { jar entry e = entry . next element ( ) ; string name = e . get name ( ) ; if ( name . start with ( `` meta-inf `` ) & & name . end with ( `` . tld `` ) ) { tlds . add ( new url ( jar uri + name ) ) ; } } if ( ! resource . get default use cache ( ) ) jar file . close ( ) ; return tlds ; }
public static void check argument ( boolean expression , object error message ) { if ( ! expression ) { throw new illegal argument exception ( string . value of ( error message ) ) ; } }
public static void have text ( string text , string message ) { if ( ! string utils . have text ( text ) ) { throw new illegal argument exception ( message ) ; } }
public static void not empty ( collection < ? > collection , string message ) { if ( collection utils . be empty ( collection ) ) { throw new illegal argument exception ( message ) ; } }
public static boolean be empty ( object [ ] array ) { if ( array == null || array . length == 0 ) { return true ; } return false ; }
protect static final boolean equal ( final object [ ] leave array , final object [ ] right array ) { if ( left array == right array ) { return true ; } if ( left array == null ) { return ( right array == null ) ; } else if ( right array == null ) { return false ; } if ( left array . length ! = right array . length ) { return false ; } for ( int i= 0 ; i < left array . length ; i++ ) { final object left= leave array [ i ] ; final object right= right array [ i ] ; final boolean equal= ( left == null ) ? ( right == null ) : ( left . equal ( right ) ) ; if ( ! equal ) { return false ; } } return true ; }
public static char [ ] to char array ( final char sequence source ) { final int len = string utils . length ( source ) ; if ( len == 0 ) { return array utils . empty_char_array ; } if ( source instanceof string ) { return ( ( string ) source ) . to char array ( ) ; } final char [ ] array = new char [ len ] ; for ( int i = 0 ; i < len ; i++ ) { array [ i ] = source . char at ( i ) ; } return array ; }
public static string null safe to string ( object obj ) { if ( obj == null ) { return null_string ; } if ( obj instanceof string ) { return ( string ) obj ; } if ( obj instanceof object [ ] ) { return null safe to string ( ( object [ ] ) obj ) ; } if ( obj instanceof boolean [ ] ) { return null safe to string ( ( boolean [ ] ) obj ) ; } if ( obj instanceof byte [ ] ) { return null safe to string ( ( byte [ ] ) obj ) ; } if ( obj instanceof char [ ] ) { return null safe to string ( ( char [ ] ) obj ) ; } if ( obj instanceof double [ ] ) { return null safe to string ( ( double [ ] ) obj ) ; } if ( obj instanceof float [ ] ) { return null safe to string ( ( float [ ] ) obj ) ; } if ( obj instanceof int [ ] ) { return null safe to string ( ( int [ ] ) obj ) ; } if ( obj instanceof long [ ] ) { return null safe to string ( ( long [ ] ) obj ) ; } if ( obj instanceof short [ ] ) { return null safe to string ( ( short [ ] ) obj ) ; } string str = obj . to string ( ) ; return ( str ! = null ? str : empty_string ) ; }
public static string null safe to string ( object obj ) { if ( obj == null ) { return null_string ; } if ( obj instanceof string ) { return ( string ) obj ; } if ( obj instanceof object [ ] ) { return null safe to string ( ( object [ ] ) obj ) ; } if ( obj instanceof boolean [ ] ) { return null safe to string ( ( boolean [ ] ) obj ) ; } if ( obj instanceof byte [ ] ) { return null safe to string ( ( byte [ ] ) obj ) ; } if ( obj instanceof char [ ] ) { return null safe to string ( ( char [ ] ) obj ) ; } if ( obj instanceof double [ ] ) { return null safe to string ( ( double [ ] ) obj ) ; } if ( obj instanceof float [ ] ) { return null safe to string ( ( float [ ] ) obj ) ; } if ( obj instanceof int [ ] ) { return null safe to string ( ( int [ ] ) obj ) ; } if ( obj instanceof long [ ] ) { return null safe to string ( ( long [ ] ) obj ) ; } if ( obj instanceof short [ ] ) { return null safe to string ( ( short [ ] ) obj ) ; } string str = obj . to string ( ) ; return ( str ! = null ? str : empty_string ) ; }
public static boolean start with ignore case ( string str , string prefix ) { if ( str == null || prefix == null ) { return false ; } if ( str . start with ( prefix ) ) { return true ; } if ( str . length ( ) < prefix . length ( ) ) { return false ; } string lc str = str . substring ( 0 , prefix . length ( ) ) . to lower case ( ) ; string lc prefix = prefix . to lower case ( ) ; return lc str . equal ( lc prefix ) ; }
protect string get simple name ( string qualify name ) { if ( have inner type ( qualified name ) > 0 ) { return qualify name . substring ( have inner type ( qualified name ) + 1 ) ; } else if ( have package ( qualified name ) > 0 ) { return qualify name . substring ( have package ( qualified name ) + 1 ) ; } else { return qualify name ; } }
public static < e > list < e > to list ( final enumeration < ? extend e > enumeration ) { return iterator utils . to list ( new enumeration iterator < > ( enumeration ) ) ; }
public string value ( ) { if ( have value ( ) ) { return value [ 0 ] ; } else { return null ; } }
public int get parameter index ( ) { return this . parameter index ; }
public long get long ( long offset ) { bound check ( offset , 8 ) ; return super . get long ( offset ) ; }
public short get short ( long offset ) { bound check ( offset , 2 ) ; return super . get short ( offset ) ; }
public float get float ( long offset ) { bound check ( offset , 4 ) ; return super . get float ( offset ) ; }
public float get float ( long offset ) { bound check ( offset , 4 ) ; return super . get float ( offset ) ; }
public long [ ] get long array ( long offset , int array size ) { long [ ] buf = new long [ array size ] ; read ( offset , buf , 0 , array size ) ; return buf ; }
public long [ ] get long array ( long offset , int array size ) { long [ ] buf = new long [ array size ] ; read ( offset , buf , 0 , array size ) ; return buf ; }
public static list < field > get all declare field ( class < ? > cl ) { final list < field > field = new array list < > ( ) ; while ( cl ! = null ) { for ( final field field : cl . get declared field ( ) ) { field . add ( field ) ; } cls = cl . get superclass ( ) ; } return field ; }
public boolean data equal ( structure s , boolean clear ) { if ( clear ) { s . get pointer ( ) . clear ( s . size ( ) ) ; s . write ( ) ; get pointer ( ) . clear ( size ( ) ) ; write ( ) ; } byte [ ] data = s . get pointer ( ) . get byte array ( 0 , s . size ( ) ) ; byte [ ] ref = get pointer ( ) . get byte array ( 0 , size ( ) ) ; if ( data . length == ref . length ) { for ( int i=0 ; i < data . length ; i++ ) { if ( data [ i ] ! = ref [ i ] ) { return false ; } } return true ; } return false ; }
public < t > list < t > load static service provider ( class < t > iface ) { list < t > provider = new array list < t > ( ) ; if ( loader ! = null ) { list < string > name = identify static service provider ( iface ) ; for ( string name : name ) { try { class < ? > klass = loader . load class ( name ) ; if ( iface . be assignable from ( klass ) ) { t instance = ( t ) klass . new instance ( ) ; if ( instance instanceof initializable ) { ( ( initializable ) instance ) . check initialization ( initializable problem handler ) ; } provider . add ( instance ) ; } } catch ( throwable t ) { handler . handle load error ( name , t ) ; } } } return provider ; }
protected list < field > get field ( boolean force ) { list < field > flist = get field list ( ) ; set < string > name = new hash set < string > ( ) ; for ( field f : flist ) { name . add ( f . get name ( ) ) ; } list < string > field order = field order ( ) ; if ( field order . size ( ) ! = flist . size ( ) & & flist . size ( ) > 1 ) { if ( force ) { throw new error ( `` structure . get field order ( ) on `` + get class ( ) + ( field order . size ( ) < flist . size ( ) ? `` do not provide enough `` : `` provide too many `` ) + `` names [ `` + field order . size ( ) + `` ] ( `` + sort ( field order ) + `` ) to match declare field [ `` + flist . size ( ) + `` ] ( `` + sort ( name ) + `` ) `` ) ; } return null ; } set < string > order name = new hash set < string > ( field order ) ; if ( ! order name . equal ( name ) ) { throw new error ( `` structure . get field order ( ) on `` + get class ( ) + `` return names ( `` + sort ( field order ) + `` ) which do not match declared field name ( `` + sort ( name ) + `` ) `` ) ; } sort field ( flist , field order ) ; return flist ; }
public void set alpha ( float alpha ) { window utils . set window alpha ( drag image , alpha ) ; }
public static void set x attr ( string path , string name , string value ) throw i o exception { set x attr ( path , name , value , native . get default string encoding ( ) ) ; }
public static i o service get matching service ( c f dictionary ref match dictionary ) { int master port = get master port ( ) ; i o service service = io . i o service get matching service ( master port , match dictionary ) ; sys . mach_port_deallocate ( sys . mach_task_self ( ) , master port ) ; return service ; }
public static i o service get matching service ( c f dictionary ref match dictionary ) { int master port = get master port ( ) ; i o service service = io . i o service get matching service ( master port , match dictionary ) ; sys . mach_port_deallocate ( sys . mach_task_self ( ) , master port ) ; return service ; }
public pointer by reference get i dispatch pointer ( ) { return p dispatch ; }
public static error handler new instance ( io . vertx . ext . web . handler . error handler arg ) { return arg ! = null ? new error handler ( arg ) : null ; }
public static buffer type buffer ( buffer buffer , class type ) { return type buffer . decorate ( buffer , type ) ; }
public hreftype get ref type of impl type ( int index ) { h r e f t y p e by reference pp t info = new h r e f t y p e by reference ( ) ; hresult hr = this . type info . get ref type of impl type ( new uint ( index ) , pp t info ) ; c o m utils . check r c ( hr ) ; return pp t info . get value ( ) ; }
public hreftype get ref type of impl type ( int index ) { h r e f t y p e by reference pp t info = new h r e f t y p e by reference ( ) ; hresult hr = this . type info . get ref type of impl type ( new uint ( index ) , pp t info ) ; c o m utils . check r c ( hr ) ; return pp t info . get value ( ) ; }
public void set l c i d ( lcid value ) { lcid = value ; }
public static byte [ ] crypt protect data ( byte [ ] data ) { return crypt protect data ( data , 0 ) ; }
public static group [ ] get user local group ( string user name ) { return get user local group ( user name , null ) ; }
public static guid generate g u i d ( ) { guid pguid = new guid ( ) ; hresult hr = ole32 . instance . co create guid ( pguid ) ; if ( ! hr . equal ( w32 error . s_ok ) ) { throw new runtime exception ( hr . to string ( ) ) ; } return pguid ; }
public static void hangup ras connection ( string conn name ) throw ras32 exception { handle hras conn = get ras connection ( conn name ) ; if ( hras conn == null ) return ; int err = rasapi32 . instance . ra hang up ( hras conn ) ; if ( err ! = win error . error_success ) throw new ras32 exception ( err ) ; }
public static string get folder path ( hwnd hwnd , int n folder , dword dw flag ) { char [ ] psz path = new char [ win def . max_path ] ; hresult hr = shell32 . instance . s h get folder path ( hwnd , n folder , null , dw flag , psz path ) ; if ( ! hr . equal ( w32 error . s_ok ) ) { throw new win32 exception ( hr ) ; } return native . to string ( psz path ) ; }
public void open ( int permission ) { close ( ) ; _handle = advapi32 . instance . open s c manager ( _machine name , _database name , permission ) ; if ( _handle == null ) { throw new win32 exception ( kernel32 . instance . get last error ( ) ) ; } }
public enum_service_status_process [ ] enum service status ex process ( int dw service type , int dw service state , string group name ) { int by reference pcb byte need = new int by reference ( 0 ) ; int by reference lp service return = new int by reference ( 0 ) ; int by reference lp resume handle = new int by reference ( 0 ) ; advapi32 . instance . enum service status ex ( _handle , winsvc . sc_enum_process_info , dw service type , dw service state , pointer . null , 0 , pcb byte need , lp service return , lp resume handle , group name ) ; int last error = kernel32 . instance . get last error ( ) ; if ( last error ! = win error . error_more_data ) { throw new win32 exception ( last error ) ; } memory buffer = new memory ( pcb byte need . get value ( ) ) ; boolean result = advapi32 . instance . enum service status ex ( _handle , winsvc . sc_enum_process_info , dw service type , dw service state , buffer , ( int ) buffer . size ( ) , pcb byte need , lp service return , lp resume handle , group name ) ; if ( ! result ) { throw new win32 exception ( kernel32 . instance . get last error ( ) ) ; } if ( lp service return . get value ( ) == 0 ) { return new winsvc . enum_service_status_process [ 0 ] ; } enum_service_status_process status = structure . new instance ( enum_service_status_process . class , buffer ) ; status . read ( ) ; return ( enum_service_status_process [ ] ) status . to array ( lp service return . get value ( ) ) ; }
public static memory evt get publisher metadata property ( evt_handle publisher metadata , int property id , int flag ) { int by reference publisher metadata property buffer use = new int by reference ( ) ; boolean result = wevtapi . instance . evt get publisher metadata property ( publisher metadata , property id , flag , 0 , null , publisher metadata property buffer use ) ; int error code = kernel32 . instance . get last error ( ) ; if ( ( ! result ) & & error code ! = kernel32 . error_insufficient_buffer ) { throw new win32 exception ( error code ) ; } memory publisher metadata property buffer = new memory ( publisher metadata property buffer use . get value ( ) ) ; result = wevtapi . instance . evt get publisher metadata property ( publisher metadata , property id , flag , ( int ) publisher metadata property buffer . size ( ) , publisher metadata property buffer , publisher metadata property buffer use ) ; if ( ! result ) { throw new win32 exception ( kernel32 . instance . get last error ( ) ) ; } return publisher metadata property buffer ; }
public calendar to calendar ( locale locale ) { if ( locale == null ) { locale = locale . get default ( ) ; } date time zone zone = get zone ( ) ; calendar cal = calendar . get instance ( zone . to time zone ( ) , locale ) ; cal . set time ( to date ( ) ) ; return cal ; }
public mutable date time to mutable date time ( ) { return new mutable date time ( get millis ( ) , get zone ( ) ) ; }
public date time to date time ( chronology chronology ) { return new date time ( get millis ( ) , chronology ) ; }
public boolean be after ( readable instant instant ) { long instant millis = date time utils . get instant millis ( instant ) ; return be after ( instant millis ) ; }
public interval gap ( readable interval interval ) { interval = date time utils . get readable interval ( interval ) ; long other start = interval . get start millis ( ) ; long other end = interval . get end millis ( ) ; long this start = get start millis ( ) ; long this end = get end millis ( ) ; if ( this start > other end ) { return new interval ( other end , this start , get chronology ( ) ) ; } else if ( other start > this end ) { return new interval ( this end , other start , get chronology ( ) ) ; } else { return null ; } }
public duration field type [ ] get field type ( ) { duration field type [ ] result = new duration field type [ size ( ) ] ; for ( int i = 0 ; i < result . length ; i++ ) { result [ i ] = get field type ( i ) ; } return result ; }
public duration field type [ ] get field type ( ) { duration field type [ ] result = new duration field type [ size ( ) ] ; for ( int i = 0 ; i < result . length ; i++ ) { result [ i ] = get field type ( i ) ; } return result ; }
public boolean be support ( date time field type type ) { if ( type == null ) { return false ; } return type . get field ( get chronology ( ) ) . be support ( ) ; }
protect int index of ( duration field type type ) { for ( int i = 0 , isize = size ( ) ; i < isize ; i++ ) { if ( get field type ( i ) . get duration type ( ) == type ) { return i ; } } return -1 ; }
public period to period ( ) { return new period ( get millis ( ) ) ; }
public period to period ( period type type ) { return new period ( get start millis ( ) , get end millis ( ) , type , get chronology ( ) ) ; }
public static final period type get period type ( period type type ) { if ( type == null ) { return period type . standard ( ) ; } return type ; }
protect void set period ( readable period period ) { if ( period == null ) { set value ( new int [ size ( ) ] ) ; } else { set period internal ( period ) ; } }
public date time field year of era ( ) { return unsupported date time field . get instance ( date time field type . year of era ( ) , year ( ) ) ; }
public date time field year of era ( ) { return unsupported date time field . get instance ( date time field type . year of era ( ) , year ( ) ) ; }
public boolean equal ( object obj ) { if ( this == obj ) { return true ; } if ( obj instanceof zone chronology == false ) { return false ; } zone chronology chrono = ( zone chronology ) obj ; return get base ( ) . equal ( chrono . get base ( ) ) & & get zone ( ) . equal ( chrono . get zone ( ) ) ; }
public static buddhist chronology get instance u t c ( ) { return instance_utc ; }
public static coptic chronology get instance ( date time zone zone ) { return get instance ( zone , 4 ) ; }
public int get ( long instant ) { return i chronology . get week of weekyear ( instant ) ; }
public string get a text ( int field value , locale locale ) { return g j locale symbol . for locale ( locale ) . day of week value to text ( field value ) ; }
public static ethiopic chronology get instance ( date time zone zone ) { return get instance ( zone , 4 ) ; }
public static islamic chronology get instance ( date time zone zone ) { return get instance ( zone , leap_year_16_based ) ; }
public duration converter [ ] get duration converter ( ) { converter set set = i duration converter ; duration converter [ ] converter = new duration converter [ set . size ( ) ] ; set . copy into ( converter ) ; return converter ; }
public static i s o chronology get instance ( date time zone zone ) { if ( zone == null ) { zone = date time zone . get default ( ) ; } i s o chronology chrono = c cache . get ( zone ) ; if ( chrono == null ) { chrono = new i s o chronology ( zone chronology . get instance ( instance_utc , zone ) ) ; i s o chronology old chrono = c cache . put if absent ( zone , chrono ) ; if ( old chrono ! = null ) { chrono = old chrono ; } } return chrono ; }
protect long check instant ( long instant , chronology chronology ) { return instant ; }
public date time plus week ( int week ) { if ( week == 0 ) { return this ; } long instant = get chronology ( ) . week ( ) . add ( get millis ( ) , week ) ; return with millis ( instant ) ; }
public date time minus day ( int day ) { if ( day == 0 ) { return this ; } long instant = get chronology ( ) . day ( ) . subtract ( get millis ( ) , day ) ; return with millis ( instant ) ; }
public interval with duration after start ( readable duration duration ) { long duration millis = date time utils . get duration millis ( duration ) ; if ( duration millis == to duration millis ( ) ) { return this ; } chronology chrono = get chronology ( ) ; long start millis = get start millis ( ) ; long end millis = chrono . add ( start millis , duration millis , 1 ) ; return new interval ( start millis , end millis , chrono ) ; }
public date time with weekyear ( int weekyear ) { return with millis ( get chronology ( ) . weekyear ( ) . set ( get millis ( ) , weekyear ) ) ; }
public date time with month of year ( int month of year ) { return with millis ( get chronology ( ) . month of year ( ) . set ( get millis ( ) , month of year ) ) ; }
public date time with day of month ( int day of month ) { return with millis ( get chronology ( ) . day of month ( ) . set ( get millis ( ) , day of month ) ) ; }
public date time to date time ( date time zone zone ) { zone = date time utils . get zone ( zone ) ; if ( get zone ( ) == zone ) { return this ; } return super . to date time ( zone ) ; }
public date time with late offset at overlap ( ) { long new millis = get zone ( ) . adjust offset ( get millis ( ) , true ) ; return with millis ( new millis ) ; }
public date time with time ( int hour of day , int minute of hour , int second of minute , int millis of second ) { chronology chrono = get chronology ( ) ; long instant = get millis ( ) ; instant = chrono . hour of day ( ) . set ( instant , hour of day ) ; instant = chrono . minute of hour ( ) . set ( instant , minute of hour ) ; instant = chrono . second of minute ( ) . set ( instant , second of minute ) ; instant = chrono . millis of second ( ) . set ( instant , millis of second ) ; return with millis ( instant ) ; }
public date midnight plus month ( int month ) { if ( month == 0 ) { return this ; } long instant = get chronology ( ) . month ( ) . add ( get millis ( ) , month ) ; return with millis ( instant ) ; }
public date midnight minus week ( int week ) { if ( week == 0 ) { return this ; } long instant = get chronology ( ) . week ( ) . subtract ( get millis ( ) , week ) ; return with millis ( instant ) ; }
public date midnight with week of weekyear ( int week of weekyear ) { return with millis ( get chronology ( ) . week of weekyear ( ) . set ( get millis ( ) , week of weekyear ) ) ; }
public string to string ( ) { if ( i low limit == i upper limit ) { return `` date time comparator [ `` + ( i low limit == null ? `` `` : i low limit . get name ( ) ) + `` ] `` ; } else { return `` date time comparator [ `` + ( i low limit == null ? `` `` : i low limit . get name ( ) ) + `` - `` + ( i upper limit == null ? `` `` : i upper limit . get name ( ) ) + `` ] `` ; } }
public date time field weekyear ( ) { return unsupported date time field . get instance ( date time field type . weekyear ( ) , weekyears ( ) ) ; }
public static final void set current millis offset ( long offset millis ) throw security exception { check permission ( ) ; if ( offset millis == 0 ) { c millis provider = system_millis_provider ; } else { c millis provider = new offset millis provider ( offset millis ) ; } }
public boolean abuts ( readable interval interval ) { if ( interval == null ) { long now = date time utils . current time millis ( ) ; return ( get start millis ( ) == now || get end millis ( ) == now ) ; } else { return ( interval . get end millis ( ) == get start millis ( ) || get end millis ( ) == interval . get start millis ( ) ) ; } }
public date time to date time ( date time zone zone ) { zone = date time utils . get zone ( zone ) ; if ( get zone ( ) == zone ) { return this ; } return super . to date time ( zone ) ; }
public static final long to julian day number ( long epoch millis ) { return ( long ) math . floor ( to julian day ( epoch millis ) + 0 . 5d ) ; }
public static final void set current millis offset ( long offset millis ) throw security exception { check permission ( ) ; if ( offset millis == 0 ) { c millis provider = system_millis_provider ; } else { c millis provider = new offset millis provider ( offset millis ) ; } }
public set < string > get available i d ( ) { return i zone info key ; }
public static name provider get name provider ( ) { return c name provider ; }
public string get public i d ( ) { return public i d ; }
public duration with millis ( long duration ) { if ( duration == get millis ( ) ) { return this ; } return new duration ( duration ) ; }
public duration field minute ( ) { return unsupported duration field . get instance ( duration field type . minute ( ) ) ; }
public string get a string ( ) { if ( be number ( ) ) { return get a number ( ) . to string ( ) ; } else if ( be boolean ( ) ) { return get a boolean wrapper ( ) . to string ( ) ; } else { return ( string ) value ; } }
public string get a short text ( locale locale ) { return get field ( ) . get a short text ( get readable partial ( ) , get ( ) , locale ) ; }
public int get maximum value ( ) { return get field ( ) . get maximum value ( get millis ( ) ) ; }
public int get maximum value ( readable partial instant , int [ ] value ) { return get maximum value ( instant ) ; }
public string get a short text ( readable partial partial , int field value , locale locale ) { return get a short text ( field value , locale ) ; }
public int get difference ( readable instant instant ) { if ( instant == null ) { return get field ( ) . get difference ( get millis ( ) , date time utils . current time millis ( ) ) ; } return get field ( ) . get difference ( get millis ( ) , instant . get millis ( ) ) ; }
protect int get maximum value for set ( long instant , int value ) { return get maximum value ( instant ) ; }
public long remainder ( long instant ) { return instant - round floor ( instant ) ; }
public int get maximum text length ( locale locale ) { int max = get maximum value ( ) ; if ( max > = 0 ) { if ( max < 10 ) { return 1 ; } else if ( max < 100 ) { return 2 ; } else if ( max < 1000 ) { return 3 ; } } return integer . to string ( max ) . length ( ) ; }
public static date time field get instance ( date time field field ) { if ( field == null ) { return null ; } if ( field instanceof lenient date time field ) { field = ( ( lenient date time field ) field ) . get wrapped field ( ) ; } if ( ! field . be lenient ( ) ) { return field ; } return new strict date time field ( field ) ; }
public long add wrap field ( long instant , int amount ) { return set ( instant , field utils . get wrapped value ( get ( instant ) , amount , i min , i max ) ) ; }
public static date time formatter short date ( ) { return create formatter for style index ( short , none ) ; }
public static date parse time field ( x content parser parser , string field name ) throw i o exception { if ( parser . current token ( ) == x content parser . token . value_number ) { return new date ( parser . long value ( ) ) ; } else if ( parser . current token ( ) == x content parser . token . value_string ) { return new date ( date formatters . from ( date time formatter . iso_instant . parse ( parser . text ( ) ) ) . to instant ( ) . to epoch milli ( ) ) ; } throw new illegal argument exception ( `` unexpected token [ `` + parser . current token ( ) + `` ] for [ `` + field name + `` ] `` ) ; }
public chronology with u t c ( ) { return with zone ( date time zone . utc ) ; }
public date time parse date time ( string text ) { internal parser parser = require parser ( ) ; chronology chrono = select chronology ( null ) ; date time parser bucket bucket = new date time parser bucket ( 0 , chrono , i locale , i pivot year , i default year ) ; int new po = parser . parse into ( bucket , text , 0 ) ; if ( new po > = 0 ) { if ( new po > = text . length ( ) ) { long millis = bucket . compute millis ( true , text ) ; if ( i offset parse & & bucket . get offset integer ( ) ! = null ) { int parse offset = bucket . get offset integer ( ) ; date time zone parse zone = date time zone . for offset millis ( parsed offset ) ; chrono = chrono . with zone ( parsed zone ) ; } else if ( bucket . get zone ( ) ! = null ) { chrono = chrono . with zone ( bucket . get zone ( ) ) ; } date time dt = new date time ( millis , chrono ) ; if ( i zone ! = null ) { dt = dt . with zone ( i zone ) ; } return dt ; } } else { new po = ~new po ; } throw new illegal argument exception ( format utils . create error message ( text , new po ) ) ; }
public static date time formatter date time parser ( ) { return constant . dtp ; }
public static date time formatter year month day ( ) { return constant . ymd ; }
public static date time formatter basic date time no millis ( ) { return constant . bdtx ; }
public static date time formatter hour minute second millis ( ) { return constant . hmsl ; }
public static period formatter get default ( ) { return word base ( locale . english ) ; }
public void print to ( string buffer buf , readable period period ) { check printer ( ) ; check period ( period ) ; get printer ( ) . print to ( buf , period , i locale ) ; }
public period formatter builder append ( period formatter formatter ) { if ( formatter == null ) { throw new illegal argument exception ( `` no formatter supply `` ) ; } clear prefix ( ) ; append0 ( formatter . get printer ( ) , formatter . get parser ( ) ) ; return this ; }
public field element add ( field element val ) { int [ ] g = ( ( ed25519 field element ) val ) . t ; int [ ] h = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i++ ) { h [ i ] = t [ i ] + g [ i ] ; } return new ed25519 field element ( f , h ) ; }
public period formatter builder append minute ( ) { append field ( minute ) ; return this ; }
public static synchronize unsupported duration field get instance ( duration field type type ) { unsupported duration field field ; if ( c cache == null ) { c cache = new hash map < duration field type , unsupported duration field > ( 7 ) ; field = null ; } else { field = c cache . get ( type ) ; } if ( field == null ) { field = new unsupported duration field ( type ) ; c cache . put ( type , field ) ; } return field ; }
public interval with duration after start ( readable duration duration ) { long duration millis = date time utils . get duration millis ( duration ) ; if ( duration millis == to duration millis ( ) ) { return this ; } chronology chrono = get chronology ( ) ; long start millis = get start millis ( ) ; long end millis = chrono . add ( start millis , duration millis , 1 ) ; return new interval ( start millis , end millis , chrono ) ; }
public void set start ( readable instant start ) { long start millis = date time utils . get instant millis ( start ) ; super . set interval ( start millis , get end millis ( ) , get chronology ( ) ) ; }
public interval with period before end ( readable period period ) { if ( period == null ) { return with duration before end ( null ) ; } chronology chrono = get chronology ( ) ; long end millis = get end millis ( ) ; long start millis = chrono . add ( period , end millis , -1 ) ; return new interval ( start millis , end millis , chrono ) ; }
public void set week ( int week ) { super . set field ( duration field type . week ( ) , week ) ; }
public partial with period add ( readable period period , int scalar ) { if ( period == null || scalar == 0 ) { return this ; } int [ ] new value = get value ( ) ; for ( int i = 0 ; i < period . size ( ) ; i++ ) { duration field type field type = period . get field type ( i ) ; int index = index of ( field type ) ; if ( index > = 0 ) { new value = get field ( index ) . add ( this , index , new value , field utils . safe multiply ( period . get value ( i ) , scalar ) ) ; } } return new partial ( this , new value ) ; }
public static period millis ( int millis ) { return new period ( new int [ ] { 0 , 0 , 0 , 0 , 0 , 0 , 0 , millis } , period type . standard ( ) ) ; }
public static date minus ( date self , int day ) { return plus ( self , -days ) ; }
public static period type day time ( ) { period type type = c d time ; if ( type == null ) { type = new period type ( `` day time `` , new duration field type [ ] { duration field type . day ( ) , duration field type . hour ( ) , duration field type . minute ( ) , duration field type . second ( ) , duration field type . millis ( ) , } , new int [ ] { -1 , -1 , -1 , 0 , 1 , 2 , 3 , 4 , } ) ; c d time = type ; } return type ; }
public date time to date time ( date time zone zone ) { zone = date time utils . get zone ( zone ) ; if ( get zone ( ) == zone ) { return this ; } return super . to date time ( zone ) ; }
public void check access ( string p host , string p address , string p origin ) { if ( ! backend manager . be remote access allow ( p host , p address ) ) { throw new security exception ( `` no access from client `` + p address + `` allow `` ) ; } if ( p origin ! = null & & ! backend manager . be origin allow ( p origin , true ) ) { throw new security exception ( `` origin `` + p origin + `` be not allow to call this agent `` ) ; } }
public m bean server connection get jolokia m bean server ( ) { return jolokia m bean server ; }
public static m bean server get m bean server ( ) { list < m bean server > server = m bean server factory . find m bean server ( null ) ; m bean server server = server . size ( ) > 0 ? server . get ( 0 ) : management factory . get platform m bean server ( ) ; return server ; }
public request config get request config ( ) { return request config ; }
public static i product get product ( ) { return internal platform . get default ( ) . get product ( ) ; }
public static x509 certificate confirmation parse ( final j s o n object json object ) { if ( ! json object . contains key ( `` cnf `` ) ) { return null ; } try { return parse from confirmation j s o n object ( j s o n object utils . get j s o n object ( json object , `` cnf `` ) ) ; } catch ( parse exception e ) { return null ; } }
public object convert to json ( object p value , list < string > p path part , json convert option p option ) throw attribute not find exception { stack < string > extra stack = p path part ! = null ? escape util . reverse path ( p path part ) : new stack < string > ( ) ; return extract object with context ( p value , extra stack , p option , true ) ; }
public boolean use return value with path ( ) { return true ; }
public void set max entry ( int p max entry ) { set limit ( new history limit ( p max entry , limit . get max duration ( ) ) ) ; }
public j s o n object get error j s o n ( int p error code , throwable p exp , jmx request p jmx req ) { j s o n object json object = new j s o n object ( ) ; json object . put ( `` status `` , p error code ) ; json object . put ( `` error `` , get exception message ( p exp ) ) ; json object . put ( `` error_type `` , p exp . get class ( ) . get name ( ) ) ; add error info ( json object , p exp , p jmx req ) ; if ( backend manager . be debug ( ) ) { backend manager . error ( `` error `` + p error code , p exp ) ; } if ( p jmx req ! = null ) { json object . put ( `` request `` , p jmx req . to j s o n ( ) ) ; } return json object ; }
public value fault handler get value fault handler ( ) { return fault handler ; }
public j s o n object to j s o n ( ) { j s o n object ret = super . to j s o n ( ) ; if ( argument ! = null & & argument . size ( ) > 0 ) { ret . put ( `` argument `` , argument ) ; } ret . put ( `` operation `` , operation ) ; return ret ; }
public string to string ( ) { if ( size ( ) == 0 ) { return `` { } `` ; } final string builder buf = new string builder ( 32 * size ( ) ) ; buf . append ( ' { ' ) ; final map iterator < k , v > it = map iterator ( ) ; boolean have next = it . have next ( ) ; while ( have next ) { final k key = it . next ( ) ; final v value = it . get value ( ) ; buf . append ( key == this ? `` ( this map ) `` : key ) . append ( '= ' ) . append ( value == this ? `` ( this map ) `` : value ) ; have next = it . have next ( ) ; if ( have next ) { buf . append ( ' , ' ) . append ( ' ' ) ; } } buf . append ( ' } ' ) ; return buf . to string ( ) ; }
public v get or default ( object key , v default value ) { v ret = ( v ) __type arg_1 . wrap ( delegate . get or default ( key , __type arg_1 . < v > unwrap ( default value ) ) ) ; return ret ; }
public static string get class base name ( class c ) { string s = c . get name ( ) ; return s . substring ( s . last index of ( ' . ' ) + 1 ) ; }
public static j s o n array to j s o n array ( string string ) throw j s o n exception { return to j s o n array ( new j s o n tokener ( string ) ) ; }
public static string to string ( j s o n array ja ) throw j s o n exception { j s o n object jo = ja . opt j s o n object ( 0 ) ; if ( jo ! = null ) { j s o n array name = jo . name ( ) ; if ( names ! = null ) { return row to string ( name ) + to string ( name , ja ) ; } } return null ; }
public string get ooxml name ( ) { if ( this == seal ) return star_16 . get ooxml name ( ) ; if ( ooxml id == -1 ) { return ( name ( ) . start with ( `` text `` ) ) ? rect . get ooxml name ( ) : null ; } string builder sb = new string builder ( ) ; boolean to lower = true ; for ( char ch : name ( ) . to char array ( ) ) { if ( ch == ' _ ' ) { to lower = false ; continue ; } sb . append ( to lower ? string util . to lower case ( ch ) : string util . to upper case ( ch ) ) ; to lower = true ; } return sb . to string ( ) ; }
public j s o n writer array ( ) throw j s o n exception { if ( this . mode == ' i ' || this . mode == ' o ' || this . mode == ' a ' ) { this . push ( null ) ; this . append ( `` [ `` ) ; this . comma = false ; return this ; } throw new j s o n exception ( `` misplace array . `` ) ; }
public whitelist add tag ( string . . . tag ) { validate . not null ( tag ) ; for ( string tag name : tag ) { validate . not empty ( tag name ) ; tag name . add ( tag name . value of ( tag name ) ) ; } return this ; }
public criterion gte ( object o ) { this . criterion type = relational operator . gte ; this . right = value node . to value node ( o ) ; return this ; }
public boolean be definite ( ) { return path . be definite ( ) ; }
public static object index ( object obj , object index ) { if ( obj instanceof map ) { map map = ( map ) obj ; if ( map . contains key ( index ) ) { return map . get ( index ) ; } } int idx = -1 ; if ( index instanceof integer ) { idx = ( ( integer ) index ) . int value ( ) ; } if ( idx < 0 ) { return obj ; } else if ( obj instanceof map ) { map map = ( map ) obj ; iterator iterator = map . key set ( ) . iterator ( ) ; return index ( iterator , idx ) ; } else if ( obj instanceof list ) { return ( ( list ) obj ) . get ( idx ) ; } else if ( obj instanceof object [ ] ) { return ( ( object [ ] ) obj ) [ idx ] ; } else if ( obj instanceof enumeration ) { enumeration it = ( enumeration ) obj ; while ( it . have more element ( ) ) { idx -- ; if ( idx == -1 ) { return it . next element ( ) ; } else { it . next element ( ) ; } } } else if ( obj instanceof iterator ) { return index ( ( iterator ) obj , idx ) ; } else if ( obj instanceof collection ) { iterator iterator = ( ( collection ) obj ) . iterator ( ) ; return index ( iterator , idx ) ; } return obj ; }
public void set property ( object obj , object key , object value ) { if ( be map ( obj ) ) ( ( map ) obj ) . put ( key . to string ( ) , value ) ; else { throw new json path exception ( `` set property operation can not be use with `` + obj ! =null ? obj . get class ( ) . get name ( ) : `` null `` ) ; } }
public boolean get boolean ( string path ) { object object = get ( path ) ; return convert object to ( object , boolean . class ) ; }
public char get char ( string path ) { object object = get ( path ) ; return convert object to ( object , character . class ) ; }
public xml path peek ( ) { final g path result result = lazy xml parser . invoke ( ) ; final string render = xml renderer . render ( result ) ; system . out . println ( render ) ; return this ; }
public void set pretty print ( boolean pretty print ) { this . pretty print = pretty print ; configure pretty print ( ) ; }
public static response get ( url url ) { return give ( ) . get ( url ) ; }
public static void reset ( ) { xml path . config = null ; }
public static boolean reg match ( final string regex , final string input ) { if ( primary_script_engine ! = null ) { return invoke script engine ( reg_match_function_name , regex , input ) ; } return invoke fallback engine ( reg_match , regex , input ) ; }
public t get ( final string name ) { for ( final t i : this ) { if ( i . get name ( ) . equal ( name ) ) { return i ; } } return null ; }
public static loading configuration by default ( ) { return new load configuration builder ( ) . freeze ( ) ; }
public digester get digester ( ) { return digester ; }
public static void write j s o n k v ( string key , object value , appendable out , j s o n style compression ) throw i o exception { if ( key == null ) out . append ( `` null `` ) ; else if ( ! compression . must protect key ( key ) ) out . append ( key ) ; else { out . append ( ' `` ' ) ; j s o n value . escape ( key , out , compression ) ; out . append ( ' `` ' ) ; } out . append ( ' : ' ) ; if ( value instanceof string ) compression . write string ( out , ( string ) value ) ; else j s o n value . write j s o n string ( value , out , compression ) ; }
public string to string ( ) { if ( failure ) return j s o n value . to j s o n string ( failure message , error_compress ) ; return j s o n value . to j s o n string ( root ) ; }
@ override public string to string ( ) { try { j s o n stringer stringer = new j s o n stringer ( ) ; write to ( stringer ) ; return stringer . to string ( ) ; } catch ( j s o n exception e ) { return null ; } }
public long a long obj ( ) { if ( current == null ) return null ; if ( current instanceof number ) { if ( current instanceof long ) return ( long ) current ; if ( current instanceof integer ) return long . value of ( ( ( number ) current ) . long value ( ) ) ; return null ; } return null ; }
public j s o n navi < ? > at ( int index ) { if ( failure ) return this ; if ( ! ( current instanceof list ) ) return failure ( `` current node be not an array `` , index ) ; @ suppress warning ( `` unchecked `` ) list < object > lst = ( ( list < object > ) current ) ; if ( index < 0 ) { index = lst . size ( ) + index ; if ( index < 0 ) index = 0 ; } if ( index > = lst . size ( ) ) if ( readonly ) return failure ( `` out of bound exception for index `` , index ) ; else { stack . add ( current ) ; path . add ( index ) ; current = null ; miss key = index ; return this ; } object next = lst . get ( index ) ; stack . add ( current ) ; path . add ( index ) ; current = next ; return this ; }
public j s o n navi < ? > at ( int index ) { if ( failure ) return this ; if ( ! ( current instanceof list ) ) return failure ( `` current node be not an array `` , index ) ; @ suppress warning ( `` unchecked `` ) list < object > lst = ( ( list < object > ) current ) ; if ( index < 0 ) { index = lst . size ( ) + index ; if ( index < 0 ) index = 0 ; } if ( index > = lst . size ( ) ) if ( readonly ) return failure ( `` out of bound exception for index `` , index ) ; else { stack . add ( current ) ; path . add ( index ) ; current = null ; miss key = index ; return this ; } object next = lst . get ( index ) ; stack . add ( current ) ; path . add ( index ) ; current = next ; return this ; }
public void add interface writer first ( class < ? > inter face , json writer i < ? > writer ) { register writer interface first ( inter face , writer ) ; }
public static < t > void register writer ( class < ? > cl , json writer i < t > writer ) { default writer . register writer ( writer , cl ) ; }
public static void assert not equal ( string expect str , j s o n object actual , boolean strict ) throw j s o n exception { assert not equal ( expect str , actual , strict ? j s o n compare mode . strict : j s o n compare mode . lenient ) ; }
public static void assert equal ( string expect str , string actual str , j s o n comparator comparator ) throw j s o n exception { assert equal ( `` `` , expect str , actual str , comparator ) ; }
public j s o n compare result fail ( string field , object expect , object actual ) { _field failure . add ( new field comparison failure ( field , expect , actual ) ) ; this . _field = field ; this . _expected = expect ; this . _actual = actual ; fail ( format failure message ( field , expect , actual ) ) ; return this ; }
public static document load ( input stream in , string charset name , string base uri ) throw i o exception { byte buffer byte data = read to byte buffer ( in ) ; return parse byte data ( byte data , charset name , base uri , parser . html parser ( ) ) ; }
public iterator < e > iterator ( ) { if ( all . be empty ( ) ) { return empty iterator . < e > empty iterator ( ) ; } final iterator chain < e > chain = new iterator chain < > ( ) ; for ( final set < e > item : all ) { chain . add iterator ( item . iterator ( ) ) ; } return chain ; }
public static string join ( string sep , object . . . args ) { return joiner . on ( sep ) . join ( args ) ; }
public static document parse ( string html , string base uri ) { return parser . parse ( html , base uri ) ; }
public static document parse ( input stream in , string charset name , string base uri , parser parser ) throw i o exception { return data util . load ( in , charset name , base uri , parser ) ; }
public boolean put if absent ( char key , byte value ) { if ( ! contains key ( key ) ) { put ( key , value ) ; return true ; } else { return false ; } }
public static string clean ( string body html , string base uri , whitelist whitelist ) { document dirty = parse body fragment ( body html , base uri ) ; clean clean = new cleaner ( whitelist ) ; document clean = cleaner . clean ( dirty ) ; return clean . body ( ) . html ( ) ; }
public location get location ( ) { return location ; }
public element prepend element ( string tag name ) { element child = new element ( tag . value of ( tag name ) , base uri ( ) ) ; prepend child ( child ) ; return child ; }
public node unwrap ( ) { validate . not null ( parent node ) ; node first child = child node . size ( ) > 0 ? child node . get ( 0 ) : null ; parent node . add child ( sibling index , this . child node a array ( ) ) ; this . remove ( ) ; return first child ; }
public void set occurrence index ( int occurrence index ) { if ( occurrence index < 1 ) { throw new illegal argument exception ( `` occurrence index must be great than 0 . `` ) ; } this . occurrence index = occurrence index ; }
public string val ( ) { if ( tag name ( ) . equal ( `` textarea `` ) ) return text ( ) ; else return attr ( `` value `` ) ; }
public element html ( string html ) { for ( element element : this ) { element . html ( html ) ; } return this ; }
public node before ( string html ) { add sibling html ( sibling index , html ) ; return this ; }
public node before ( node node ) { validate . not null ( node ) ; validate . not null ( parent node ) ; parent node . add child ( sibling index , node ) ; return this ; }
public node before ( node node ) { validate . not null ( node ) ; validate . not null ( parent node ) ; parent node . add child ( sibling index , node ) ; return this ; }
public boolean can exclude ( ) { return exclude rule ! = null & & ! exclude rule . be empty ( ) ; }
public boolean match whitespace ( ) { return ! be empty ( ) & & string util . be whitespace ( queue . char at ( po ) ) ; }
public final void add first ( byte . . . element ) { ensure buffer space ( element . length ) ; for ( byte k : element ) { add first ( k ) ; } }
public void advance ( ) { pos++ ; }
public string consume word ( ) { int start = po ; while ( match word ( ) ) pos++ ; return queue . substring ( start , po ) ; }
public static whitelist relaxed ( ) { return new whitelist ( ) . add tag ( `` a `` , `` b `` , `` blockquote `` , `` br `` , `` caption `` , `` cite `` , `` code `` , `` col `` , `` colgroup `` , `` dd `` , `` div `` , `` dl `` , `` dt `` , `` em `` , `` h1 `` , `` h2 `` , `` h3 `` , `` h4 `` , `` h5 `` , `` h6 `` , `` i `` , `` img `` , `` li `` , `` ol `` , `` p `` , `` pre `` , `` q `` , `` small `` , `` span `` , `` strike `` , `` strong `` , `` sub `` , `` sup `` , `` table `` , `` tbody `` , `` td `` , `` tfoot `` , `` th `` , `` thead `` , `` tr `` , `` u `` , `` ul `` ) . add attribute ( `` a `` , `` href `` , `` title `` ) . add attribute ( `` blockquote `` , `` cite `` ) . add attribute ( `` col `` , `` span `` , `` width `` ) . add attribute ( `` colgroup `` , `` span `` , `` width `` ) . add attribute ( `` img `` , `` align `` , `` alt `` , `` height `` , `` src `` , `` title `` , `` width `` ) . add attribute ( `` ol `` , `` start `` , `` type `` ) . add attribute ( `` q `` , `` cite `` ) . add attribute ( `` table `` , `` summary `` , `` width `` ) . add attribute ( `` td `` , `` abbr `` , `` axis `` , `` colspan `` , `` rowspan `` , `` width `` ) . add attribute ( `` th `` , `` abbr `` , `` axis `` , `` colspan `` , `` rowspan `` , `` scope `` , `` width `` ) . add attribute ( `` ul `` , `` type `` ) . add protocol ( `` a `` , `` href `` , `` ftp `` , `` http `` , `` http `` , `` mailto `` ) . add protocol ( `` blockquote `` , `` cite `` , `` http `` , `` https `` ) . add protocol ( `` cite `` , `` cite `` , `` http `` , `` https `` ) . add protocol ( `` img `` , `` src `` , `` http `` , `` https `` ) . add protocol ( `` q `` , `` cite `` , `` http `` , `` https `` ) ; }
public element remove attr ( string attribute key ) { for ( element element : this ) { element . remove attr ( attribute key ) ; } return this ; }
public element prev all ( string query ) { return sibling ( query , false , true ) ; }
public string whole text ( ) { final string builder accum = string util . borrow builder ( ) ; node traversor . traverse ( new node visitor ( ) { public void head ( node node , int depth ) { if ( node instanceof text node ) { text node text node = ( text node ) node ; accum . append ( text node . get whole text ( ) ) ; } } public void tail ( node node , int depth ) { } } , this ) ; return string util . release builder ( accum ) ; }
public element select ( string query ) { return selector . select ( query , this ) ; }
public static string join ( string sep , object . . . args ) { return joiner . on ( sep ) . join ( args ) ; }
public xml declaration a xml declaration ( ) { string data = get data ( ) ; document doc = jsoup . parse ( `` < `` + data . substring ( 1 , data . length ( ) -1 ) + `` > `` , base uri ( ) , parser . xml parser ( ) ) ; xml declaration decl = null ; if ( doc . child ( ) . size ( ) > 0 ) { element el = doc . child ( 0 ) ; decl = new xml declaration ( node utils . parser ( doc ) . setting ( ) . normalize tag ( el . tag name ( ) ) , data . start with ( `` ! `` ) ) ; decl . attribute ( ) . add all ( el . attribute ( ) ) ; } return decl ; }
public list get attribute name ( ) { list attribute = new array list ( ) ; iterator it = _parameters . get parameter ( ) . iterator ( ) ; while ( it . have next ( ) ) { attribute . add ( ( ( parameter ) it . next ( ) ) . get key ( ) ) ; } return attribute ; }
public static void uninstall ( ) throw security exception { java . util . log . logger root logger = get root logger ( ) ; handler [ ] handler = root logger . get handler ( ) ; for ( int i = 0 ; i < handler . length ; i++ ) { if ( handler [ i ] instanceof s l f4 j bridge handler ) { root logger . remove handler ( handler [ i ] ) ; } } }
public static void fail ( string message ) { fail ( message , null ) ; }
protect void start up ( ) throw exception { }
public static string get short name ( final step step , final int max length ) { final string name = step . to string ( ) ; if ( name . length ( ) > max length ) return name . substring ( 0 , max length - 3 ) + `` . . . `` ; return name ; }
static public void run and wait ( test suite ) { test runner a test runner= new test runner ( ) ; a test runner . do run ( suite , true ) ; }
protect test result create result ( ) { return new test result ( ) ; }
public void start test ( test test ) { final int count= test . count test case ( ) ; synchronize ( this ) { f run tests+= count ; } for ( enumeration e= clone listener ( ) . element ( ) ; e . have more element ( ) ; ) { ( ( test listener ) e . next element ( ) ) . start test ( test ) ; } }
static public void assert not null ( string message , object object ) { assert true ( message , object ! = null ) ; }
public string get expect ( ) { return expect ; }
public string elapsed time a string ( long run time ) { return number format . get instance ( ) . format ( ( double ) run time/1000 ) ; }
public static request method ( class < ? > clazz , string method name ) { description method= description . create test description ( clazz , method name ) ; return request . a class ( clazz ) . filter with ( method ) ; }
public result run ( class < ? > test class ) { return run ( request . a class ( test class ) ) ; }
static public void run and wait ( test suite ) { test runner a test runner= new test runner ( ) ; a test runner . do run ( suite , true ) ; }
public void add listener ( run listener listener ) { f notifier . add listener ( listener ) ; }
public file new folder ( string . . . folder name ) throw i o exception { file file = get root ( ) ; for ( int i = 0 ; i < folder name . length ; i++ ) { string folder name = folder name [ i ] ; file = new file ( file , folder name ) ; if ( ! file . mkdir ( ) & & be last element in array ( i , folder name ) ) { throw new i o exception ( `` a folder with the name \ ' `` + folder name + `` \ ' already exist `` ) ; } } return file ; }
public int get failure count ( ) { return failure . size ( ) ; }
public file new folder ( string path ) throw i o exception { return new folder ( new string [ ] { path } ) ; }
public statement apply ( final statement base , description description ) { return new statement ( ) { @ override public void evaluate ( ) throw throwable { base . evaluate ( ) ; verify ( ) ; } } ; }
public static result run class ( class . . . class ) { return new j unit core ( ) . run ( class ) ; }
public static throwable on completable error ( throwable error ) { func1 < throwable , throwable > f = on completable subscribe error ; if ( f ! = null ) { return f . call ( error ) ; } return error ; }
static public void assert equal ( string message , string expect , string actual ) { if ( expect == null & & actual == null ) return ; if ( expect ! = null & & expect . equal ( actual ) ) return ; throw new comparison failure ( message , expect , actual ) ; }
public static < t extend class loader > element matcher . junction < t > have child ( element matcher < ? super class loader > matcher ) { return new class loader hierarchy matcher < t > ( matcher ) ; }
public response action expect ( request matcher matcher ) { return expect ( expect count . once ( ) , matcher ) ; }
public static metadata implementor build metadata from main args ( string [ ] args ) throw exception { final command line args command line args = command line args . parse command line args ( args ) ; standard service registry service registry = build standard service registry ( command line args ) ; try { return build metadata ( command line args , service registry ) ; } finally { standard service registry builder . destroy ( service registry ) ; } }
public list < exception > validate annotate method ( framework method method ) { return no_validation_errors ; }
public < a extends annotation > list < constraint validator descriptor < a > > get all validator descriptor ( class < a > annotation type ) { contract . assert not null ( annotation type , message . class can not be null ( ) ) ; return validator descriptor . compute if absent ( annotation type , a - > get default validator descriptor ( a ) ) ; }
public static < t extend type description . generic > element matcher . junction < t > erasure ( element matcher < ? super type description > matcher ) { return new erasure matcher < t > ( matcher ) ; }
public static < t > matcher < t > null value ( class < t > type ) { return new be null < t > ( ) ; }
public static < t > combinable either matcher < t > either ( matcher < ? super t > matcher ) { return core matcher . either ( matcher ) ; }
public void delete ( ) { if ( folder ! = null ) { recursive delete ( folder ) ; } }
public static condition evaluation result enable ( string reason ) { return new condition evaluation result ( true , reason ) ; }
public static boolean be assignable to ( object obj , class < ? > target type ) { precondition . not null ( target type , `` target type must not be null `` ) ; if ( obj == null ) { return ! target type . be primitive ( ) ; } if ( target type . be instance ( obj ) ) { return true ; } if ( target type . be primitive ( ) ) { class < ? > source type = obj . get class ( ) ; return source type == primitive to wrapper map . get ( target type ) || be widen conversion ( source type , target type ) ; } return false ; }
public static class < ? > get primitive from wrapper type ( class < ? > wrapper type ) { return primitive wrapper . get ( wrapper type ) ; }
public int get remember position ( ) { if ( ! able to format ) { return original position ; } int accrue input index = 0 ; int current output index = 0 ; while ( accrue input index < position to remember & & current output index < current output . length ( ) ) { if ( accrue input without format . char at ( accrue input index ) == current output . char at ( current output index ) ) { accrue input index++ ; } current output index++ ; } return current output index ; }
public static string find ( string regex ) { report matcher ( new find ( regex ) ) ; return null ; }
public string get raw ( ) { return raw ; }
public void set follow redirects ( final boolean follow ) { follow redirects = follow ; }
public string get label ( ) { return clean string ( _label ) ; }
public static log monitor adapter new instance ( int loglevels ) { log monitor adapter adapter ; if ( loglevels == jdk14_log_levels ) { adapter = new instance ( log level . get jdk14 level ( ) ) ; adapter . set default level ( log level . fine ) ; adapter . set severe level ( log level . severe ) ; } else { adapter = new instance ( log level . get log4 j level ( ) ) ; adapter . set default level ( log level . debug ) ; adapter . set severe level ( log level . fatal ) ; } return adapter ; }
public static < t > t assert hold lock ( @ not null t monitor ) { assert thread . hold lock ( check not null param ( `` monitor `` , monitor ) ) : message . log . expect lock hold ( monitor ) ; return monitor ; }
public void log ( final string fqcn , final level level , final string message , final string bundle name , final ext log record . format style style , final object [ ] params , final throwable t ) { if ( level == null || fqcn == null || message == null || ! logger node . be loggable level ( level . int value ( ) ) ) { return ; } final ext log record rec = new ext log record ( level , message , style , fqcn ) ; rec . set resource bundle name ( bundle name ) ; rec . set parameter ( params ) ; rec . set thrown ( t ) ; log raw ( rec ) ; }
public static base64 variant value of ( string name ) throw illegal argument exception { if ( mime . _name . equal ( name ) ) { return mime ; } if ( mime_no_linefeeds . _name . equal ( name ) ) { return mime_no_linefeeds ; } if ( pem . _name . equal ( name ) ) { return pem ; } if ( modified_for_url . _name . equal ( name ) ) { return modified_for_url ; } if ( name == null ) { name = `` < null > `` ; } else { name = `` ' `` +name+ `` ' `` ; } throw new illegal argument exception ( `` no base64 variant with name `` +name ) ; }
public url get resource a u r l ( string resource ) { return get resource a u r l ( resource , get class loader ( null ) ) ; }
public enumeration < string > get logger name ( ) { final array deque < iterator < logger node > > node stack = new array deque < > ( ) ; node stack . add ( collection . singleton ( root logger ) . iterator ( ) ) ; return new enumeration < string > ( ) { logger node next ; @ override public boolean have more element ( ) { if ( next ! = null ) return true ; while ( ! node stack . be empty ( ) ) { final iterator < logger node > itr = node stack . peek first ( ) ; if ( ! itr . have next ( ) ) { node stack . poll first ( ) ; } else { final logger node node = itr . next ( ) ; node stack . add last ( node . get child ( ) . iterator ( ) ) ; if ( node . have logger ( ) ) { next = node ; return true ; } } } return false ; } @ override public string next element ( ) { if ( ! have more element ( ) ) { throw new no such element exception ( ) ; } try { return next . get full name ( ) ; } finally { next = null ; } } } ; }
protect void set m r u ( object o ) { int index = _mru file list . index of ( o ) ; if ( index == -1 ) { _mru file list . add ( 0 , o ) ; set max size ( _max size ) ; } else { move to top ( index ) ; } }
protect void delayed fire table data change ( ) { swing utility . invoke later ( new runnable ( ) { public void run ( ) { fire table data change ( ) ; } } ) ; }
protect boolean load log file ( file file ) { boolean ok = false ; try { log file parser lfp = new log file parser ( file ) ; lfp . parse ( this ) ; ok = true ; } catch ( i o exception e ) { log factor5 error dialog error = new log factor5 error dialog ( get base frame ( ) , `` error reading `` + file . get name ( ) ) ; } return ok ; }
public void trace ( object message , throwable t ) { if ( is12 ) { get logger ( ) . log ( fqcn , ( priority ) level . debug , message , t ) ; } else { get logger ( ) . log ( fqcn , level . debug , message , t ) ; } }
public static void error ( final logger logger , final string pattern , final object [ ] argument ) { if ( logger . be enable for ( level . error ) ) { force log ( logger , level . error , format ( pattern , argument ) ) ; } }
public void add cc ( email address address ) { cc list . add element ( address ) ; }
public final void set s m t p protocol ( final string val ) { smtp protocol = val ; }
synchronize public void close ( ) { if ( close ) return ; this . close = true ; if ( advertise via multicast d n s ) { zero conf . unadvertise ( ) ; } clean up ( ) ; }
public void set application ( string application ) { this . application = application ; }
public void format ( final string buffer sbuf , final logging event e ) { for ( int i = 0 ; i < pattern converter . length ; i++ ) { int start field = sbuf . length ( ) ; pattern converter [ i ] . format ( e , sbuf ) ; pattern field [ i ] . format ( start field , sbuf ) ; } }
public boolean be leave truncate ( ) { return leave truncate ; }
public void set output property ( property property ) { if ( property == null ) { local output property = null ; } else { enumeration key = property . property name ( ) ; while ( key . have more element ( ) ) { string key = ( string ) key . next element ( ) ; set output property ( key , property . get property ( key ) ) ; } } }
public static date pattern converter new instance ( final string [ ] option ) { return new date pattern converter ( option ) ; }
public boolean ignores throwable ( ) { return ! handle exception ; }
public http log interceptor set level ( level level ) { if ( level == null ) throw new null pointer exception ( `` level == null . use level . none instead . `` ) ; this . level = level ; return this ; }
public static logger context get context ( ) { try { return factory . get context ( fqcn , null , null , true ) ; } catch ( final illegal state exception ex ) { logger . warn ( ex . get message ( ) + `` use simple logger `` ) ; return new simple logger context factory ( ) . get context ( fqcn , null , null , true ) ; } }
public static resource bundle get resource bundle ( string bundle name , locale locale ) { return resource bundle . get bundle ( bundle name , locale , class utils . get class loader ( null ) ) ; }
public static throwable get root cause ( throwable throwable ) { throwable cause = get cause ( throwable ) ; if ( cause ! = null ) { throwable = cause ; while ( ( throwable = get cause ( throwable ) ) ! = null ) { cause = throwable ; } } return cause ; }
public short get parameter count ( ) { return 0 ; }
public static parameterized type parameterized type ( final class < ? > raw type , final type . . . actual type argument ) { return new parameterized type ( ) { @ override public type [ ] get actual type argument ( ) { return actual type argument ; } @ override public type get raw type ( ) { return raw type ; } @ override public type get owner type ( ) { return null ; } } ; }
public log builder at debug ( ) { return at level ( level . debug ) ; }
public void freeze ( ) { this . frozen = true ; }
public void remove listener ( final status listener listener ) { close silently ( listener ) ; listener lock . write lock ( ) . lock ( ) ; try { listener . remove ( listener ) ; int low = level . to level ( default_status_level , level . warn ) . int level ( ) ; for ( final status listener status listener : listener ) { final int level = status listener . get status level ( ) . int level ( ) ; if ( low < level ) { low = level ; } } listener level = low ; } finally { listener lock . write lock ( ) . unlock ( ) ; } }
public static < t extend enum < t > > t value of ( final class < t > enum type , final string name ) { return enum . value of ( enum type , name ) ; }
public static object get ( final supplier < ? > supplier ) { if ( supplier == null ) { return null ; } final object result = supplier . get ( ) ; return result instanceof message ? ( ( message ) result ) . get formatted message ( ) : result ; }
public double get double property ( final string name , final double default value ) { final string prop = get string property ( name ) ; if ( prop ! = null ) { try { return double . parse double ( prop ) ; } catch ( final exception ignore ) { return default value ; } } return default value ; }
public extend property subset ( string prefix ) { extended property c = new extend property ( ) ; iterator key = get key ( ) ; boolean valid subset = false ; while ( key . have next ( ) ) { object key = key . next ( ) ; if ( key instanceof string & & ( ( string ) key ) . start with ( prefix ) ) { if ( ! valid subset ) { valid subset = true ; } / * * check to make sure that c . subset ( prefix ) do n't * blow up when there be only a single property * with the key prefix . this be not a useful * subset but it be a valid subset . * / string new key = null ; if ( ( ( string ) key ) . length ( ) == prefix . length ( ) ) { new key = prefix ; } else { new key = ( ( string ) key ) . substring ( prefix . length ( ) + 1 ) ; } / * * use add property direct ( ) - this will plug the data a * be into the map , but will also do the right thing * re key accounting * / c . add property direct ( new key , get ( key ) ) ; } } if ( valid subset ) { return c ; } else { return null ; } }
public static boolean contain only whitespaces ( string s ) { int size= s . length ( ) ; for ( int i= 0 ; i < size ; i++ ) { if ( ! character . be whitespace ( s . char at ( i ) ) ) return false ; } return true ; }
public error handler get error handler ( ) { return ( this . error handler ) ; }
public static string clean ( string charset name ) { try { return for name ( charset name ) . name ( ) ; } catch ( exception e ) { return null ; } }
protected boolean should flush ( final logging event event ) { return immediate flush ; }
public static string [ ] to string array ( final object [ ] array ) { if ( array == null ) { return null ; } else if ( array . length == 0 ) { return empty_string_array ; } final string [ ] result = new string [ array . length ] ; for ( int i = 0 ; i < array . length ; i++ ) { result [ i ] = array [ i ] . to string ( ) ; } return result ; }
public void write byte ( byte [ ] bytes ) { write byte ( byte , 0 , byte . length ) ; }
public final void write raw byte ( final byte [ ] value , int offset , int length ) throw i o exception { write ( value , offset , length ) ; }
public static void write chunk ( final byte [ ] data , final output stream output ) throw i o exception { if ( data ! = null ) { int byte = data . length ; int offset = 0 ; while ( byte > 0 ) { final int chunk = math . min ( byte , default_buffer_size ) ; output . write ( data , offset , chunk ) ; bytes -= chunk ; offset += chunk ; } } }
public static < b > builder < b > builder ( ) { return new builder < b > ( ) ; }
public void execute ( lexer lexer , char stream input , int start index ) { boolean require seek = false ; int stop index = input . index ( ) ; try { for ( lexer action lexer action : lexer action ) { if ( lexer action instanceof lexer indexed custom action ) { int offset = ( ( lexer indexed custom action ) lexer action ) . get offset ( ) ; input . seek ( start index + offset ) ; lexer action = ( ( lexer indexed custom action ) lexer action ) . get action ( ) ; require seek = ( start index + offset ) ! = stop index ; } else if ( lexer action . be position dependent ( ) ) { input . seek ( stop index ) ; require seek = false ; } lexer action . execute ( lexer ) ; } } finally { if ( require seek ) { input . seek ( stop index ) ; } } }
public string get destination file name ( ) { return destination file name ; }
public boolean be condition ( ) { final simple binding binding = new simple binding ( ) ; binding . put all ( configuration . get property ( ) ) ; binding . put ( `` substitutor `` , configuration . get str substitutor ( ) ) ; final object object = configuration . get script manager ( ) . execute ( script . get name ( ) , binding ) ; return boolean . parse boolean ( object . to string ( ) ) ; }
public boolean be trigger event ( final log event event ) { for ( final triggering policy trigger policy : triggering policy ) { if ( trigger policy . be trigger event ( event ) ) { return true ; } } return false ; }
public static < b > builder < b > builder ( ) { return new builder < b > ( ) ; }
public final http route get route ( ) { return route ; }
public logger get parent ( ) { final logger config lc = private config . logger config . get name ( ) . equal ( get name ( ) ) ? private config . logger config . get parent ( ) : private config . logger config ; if ( lc == null ) { return null ; } final string lc name = lc . get name ( ) ; final message factory message factory = get message factory ( ) ; if ( context . have logger ( lc name , message factory ) ) { return context . get logger ( lc name , message factory ) ; } return new logger ( context , lc name , message factory ) ; }
public void remove iteration listener ( final iteration listener listener ) { listener . remove ( listener ) ; }
public static logger create logger ( @ plugin element ( `` logger `` ) final logger config [ ] logger ) { final concurrent map < string , logger config > logger map = new concurrent hash map < > ( ) ; logger config root = null ; for ( final logger config logger : logger ) { if ( logger ! = null ) { if ( logger . get name ( ) . be empty ( ) ) { if ( root ! = null ) { throw new illegal state exception ( `` configuration have multiple root logger . there can be only one . `` ) ; } root = logger ; } logger map . put ( logger . get name ( ) , logger ) ; } } return new logger ( logger map , root ) ; }
public synchronize void add logger ( final string logger name , final logger config logger config ) { logger configs . put if absent ( logger name , logger config ) ; set parent ( ) ; }
public static level to level ( final string name , final level default level ) { if ( name == null ) { return default level ; } final level level = level . get ( to upper case ( name ) ) ; return level == null ? default level : level ; }
protect property editor registry get property editor registry ( ) { if ( get target ( ) ! = null ) { return get internal binding result ( ) . get property accessor ( ) ; } else { return get simple type converter ( ) ; } }
public list < uri > get resource ( ) { return resource ; }
protect object convert ( object value , class type ) { converter converter = get convert utils ( ) . lookup ( type ) ; if ( converter ! = null ) { log . trace ( `` use converter `` + converter ) ; return converter . convert ( type , value ) ; } else { return value ; } }
public static boolean shutdown ( final logger context ctx , final long timeout , final time unit time unit ) { if ( ctx ! = null ) { return ctx . stop ( timeout , time unit ) ; } return true ; }
public configuration get configuration ( final logger context logger context , final string name , final uri config location ) { if ( ! be active ( ) ) { return null ; } if ( config location ! = null ) { final configuration source source = configuration source . from uri ( config location ) ; if ( source ! = null ) { return get configuration ( logger context , source ) ; } } return null ; }
protect static byte [ ] to byte array ( final input stream be ) throw i o exception { final byte array output stream buffer = new byte array output stream ( ) ; int n read ; final byte [ ] data = new byte [ buf_size ] ; while ( ( n read = be . read ( data , 0 , data . length ) ) ! = -1 ) { buffer . write ( data , 0 , n read ) ; } return buffer . to byte array ( ) ; }
public level get level ( ) { return private config . logger config level ; }
public void set config location ( string . . . location ) { if ( location ! = null ) { assert . no null element ( location , `` config location must not be null `` ) ; this . config location = new string [ location . length ] ; for ( int i = 0 ; i < location . length ; i++ ) { this . config location [ i ] = resolve path ( location [ i ] ) . trim ( ) ; } } else { this . config location = null ; } }
public static void set root level ( final level level ) { final logger context logger context = logger context . get context ( false ) ; final logger config logger config = logger context . get configuration ( ) . get root logger ( ) ; if ( ! logger config . get level ( ) . equal ( level ) ) { logger config . set level ( level ) ; logger context . update logger ( ) ; } }
public void message log ( build event event ) { if ( event . get priority ( ) > msg output level || null == event . get message ( ) || `` `` . equal ( event . get message ( ) . trim ( ) ) ) { return ; } if ( null ! = target name ) { out . println ( string utils . line_sep + target name + `` : `` ) ; target name = null ; } super . message log ( event ) ; }
public static value function invoke method ( final method method ) { method . set accessible ( true ) ; return new value function ( ) { public double apply ( object obj ) { try { final number n = ( number ) method . invoke ( obj ) ; return n . double value ( ) ; } catch ( exception e ) { logger . warn ( `` exception from method register a a gauge [ `` + method + `` ] `` , e ) ; return double . na n ; } } } ; }
public void clear secret ( ) { if ( this . key store config ! = null ) { this . key store config . clear secret ( ) ; } if ( this . trust store config ! = null ) { this . trust store config . clear secret ( ) ; } }
public static pid process new pid process ( int pid ) { if ( system utils . is_os_windows ) { return new window process ( pid ) ; } return new unix process ( pid ) ; }
public boolean be unmatched argument allow ( ) { return unmatched argument allow ; }
public command line add subcommand ( final string name , final object command ) { final command line command line = to command line ( command ) ; command line . parent = this ; interpreter . command . put ( name , command line ) ; return this ; }
public static long multiply ( long n , long time ) { long u = n * time ; if ( ( ( n | time ) > > > 31 ) ! = 0 ) { if ( u / n ! = time ) { return long . max_value ; } } return u ; }
public static condition new secure transport condition ( ) { return new boolean condition ( secure_transport_condition_key , true ) ; }
public string lookup ( final string key ) { return key ! = null ? key . to lower case ( ) : null ; }
public static void shutdown ( ) { shutdown ( false ) ; }
public void set queue connection factory binding name ( string qcf bind name ) { this . qcf bind name = qcf bind name ; }
public void set queue connection factory binding name ( string qcf bind name ) { this . qcf bind name = qcf bind name ; }
public boolean be system context ( ) { return thread local . get ( ) . be system context ; }
public option set default value ( string default value ) { this . default value = default value ; if ( this . default value ! = null ) { set require ( false ) ; } return this ; }
public option set default value ( string default value ) { this . default value = default value ; if ( this . default value ! = null ) { set require ( false ) ; } return this ; }
public object last key ( ) { if ( fast ) { return ( map . last key ( ) ) ; } else { synchronize ( map ) { return ( map . last key ( ) ) ; } } }
public sort map head map ( object key ) { if ( fast ) { return ( map . head map ( key ) ) ; } else { synchronize ( map ) { return ( map . head map ( key ) ) ; } } }
public map get copy of context map ( ) { hash map hash map = ( hash map ) inheritable thread local . get ( ) ; if ( hash map ! = null ) { return new hash map ( hash map ) ; } else { return null ; } }
public int get backlog size ( ) { return backlog size ; }
public void set ssl ( s s l configuration ssl ) { this . ssl = ssl ; }
public void set log exception stack trace ( boolean log exception stack trace ) { this . log exception stack trace = log exception stack trace ; }
public final long get time stamp ( ) { return time stamp ; }
public string get driver class name ( ) { return this . driver class ; }
public string get conversion pattern ( ) { return conversion pattern ; }
public object get property ( string name ) { if ( name == null ) { return null ; } for ( property evaluator evaluator : get delegate ( property evaluator . class ) ) { final object o = evaluator . evaluate ( name , this ) ; if ( o == null ) { continue ; } return o instanceof null return ? null : o ; } return property . get ( name ) ; }
public void end ( interpretation context ic , string name ) throw action exception { if ( in error ) { return ; } object o = ic . peek object ( ) ; if ( o ! = hook ) { add warn ( `` the object at the of the stack be not the hook push earlier . `` ) ; } else { ic . pop object ( ) ; thread hook thread = new thread ( hook , `` logback shutdown hook [ `` + context . get name ( ) + `` ] `` ) ; context . put object ( core constant . shutdown_hook_thread , hook thread ) ; runtime . get runtime ( ) . add shutdown hook ( hook thread ) ; } }
public void start ( ) { int error = 0 ; if ( get file ( ) ! = null ) { add info ( `` file property be set to [ `` + file name + `` ] `` ) ; if ( prudent ) { if ( be append ( ) == false ) { set append ( true ) ; add warn ( `` set \ `` append\ `` property to true on account of \ `` prudent\ `` mode `` ) ; } } try { open file ( get file ( ) ) ; } catch ( java . io . i o exception e ) { errors++ ; add error ( `` open file ( `` + file name + `` , `` + append + `` ) call fail . `` , e ) ; } } else { errors++ ; add error ( `` \ `` file\ `` property not set for appender name [ `` + name + `` ] . `` ) ; } if ( error == 0 ) { super . start ( ) ; } }
public void set s m t p host ( string smtp host ) { set smtp host ( smtp host ) ; }
public void set port ( int port ) { this . port = port ; } // -- void set port ( int )
public static string escape tag ( final string buffer buf ) { for ( int i = 0 ; i < buf . length ( ) ; i++ ) { char ch = buf . char at ( i ) ; if ( ch == ' < ' ) { buf . replace ( i , i + 1 , `` & lt ; `` ) ; } else if ( ch == ' > ' ) { buf . replace ( i , i + 1 , `` & gt ; `` ) ; } } return buf . to string ( ) ; }
public void set compression ( tar compression method mode ) { this . compression = mode ; }
public boolean be attach ( appender < e > appender ) { if ( appender == null ) { return false ; } boolean attached = false ; r . lock ( ) ; try { for ( appender < e > a : appender list ) { if ( a == appender ) { attached = true ; break ; } } } finally { r . unlock ( ) ; } return attach ; }
public static set < string > get resource ( string p resource ) throw i o exception { list < class loader > clls = find class loader ( ) ; if ( clls . size ( ) ! = 0 ) { set < string > ret = new hash set < string > ( ) ; for ( class loader cll : clls ) { enumeration < url > url enum = cll . get resource ( p resource ) ; ret . add all ( extract url a string from enumeration ( url enum ) ) ; } return ret ; } else { return extract url a string from enumeration ( class loader . get system resource ( p resource ) ) ; } }
public static privilege action < class loader > get class loader p a ( final class < ? > clazz ) { return new privilege action < class loader > ( ) { @ override public class loader run ( ) { return clazz . get class loader ( ) ; } } ; }
public static class loader get class loader of class ( final class < ? > clazz ) { class loader cl = clazz . get class loader ( ) ; if ( cl == null ) { return class loader . get system class loader ( ) ; } else { return cl ; } }
public static void print in case of error or warning ( context context ) { if ( context == null ) { throw new illegal argument exception ( `` context argument can not be null `` ) ; } status manager sm = context . get status manager ( ) ; if ( sm == null ) { p . println ( `` warn : context name \ `` `` + context . get name ( ) + `` \ `` have no status manager `` ) ; } else { status checker sc = new status checker ( context ) ; if ( sc . get high level ( 0 ) > = error status . warn ) { print ( sm ) ; } } }
static public void add on console listener instance ( context context , on console status listener on console status listener ) { on console status listener . set context ( context ) ; boolean effectively add = context . get status manager ( ) . add ( on console status listener ) ; if ( effectively add ) { on console status listener . start ( ) ; } }
public static string local host name ( ) { try { inet address localhost = inet address . get local host ( ) ; return localhost . get host name ( ) ; } catch ( exception e ) { internal log factory . get log ( aws host name utils . class ) . debug ( `` fail to determine the local hostname ; fall back to `` + `` use \ `` localhost\ `` . `` , e ) ; return `` localhost `` ; } }
public void set algorithm ( string algorithm ) { assert . have text ( algorithm , `` algorithm required `` ) ; this . algorithm = algorithm ; }
public void set provider ( string provider ) { this . provider = provider ; }
public void select protocol ( string [ ] enable protocol , string [ ] support protocol ) { list < string > select protocol = process include exclude pattern ( `` protocols `` , enable protocol , support protocol , _include protocol , _exclude protocols ) ; if ( select protocol . be empty ( ) ) log . warn ( `` no select protocols from { } `` , arrays . a list ( supported protocol ) ) ; _selected protocol = select protocol . to array ( new string [ 0 ] ) ; }
public void set need client auth ( boolean be need client auth ) { this . be need client auth = be need client auth ; }
public void set want client auth ( boolean be want client auth ) { this . be want client auth = be want client auth ; }
public void set title ( final string title ) { if ( this . title == null ) { this . title = new content ( ) ; } this . title . set value ( title ) ; }
protect string get description ( object manage bean , string bean key ) { manage resource mr = this . attribute source . get manage resource ( get class to expose ( manage bean ) ) ; return ( mr ! = null ? mr . get description ( ) : `` `` ) ; }
public action get asynchronous ( ) { return asynchronous ; }
public int get origin y ( int gid ) { if ( origin . contains key ( gid ) ) { return origin . get ( gid ) ; } else { return default vert origin y ; } }
public static < e > immutable multiset < e > copy of ( e [ ] element ) { return copy of ( array . a list ( element ) ) ; }
public static boolean be empty ( string str ) { return str == null || str . length ( ) == 0 ; }
public byte [ ] decompress ( byte [ ] src , int src off ) { if ( safe decompressor ! = null ) { return decompress ( src , src off , src . length - src off ) ; } final int d len = get decompress length ( src , src off ) ; return fast decompressor . decompress ( src , src off + 4 , d len ) ; }
public byte [ ] decompress ( byte [ ] src , int src off ) { if ( safe decompressor ! = null ) { return decompress ( src , src off , src . length - src off ) ; } final int d len = get decompress length ( src , src off ) ; return fast decompressor . decompress ( src , src off + 4 , d len ) ; }
public long get expect content size ( ) { if ( ! read single frame ) { throw new unsupported operation exception ( `` operation not permit when multiple frame can be read `` ) ; } return expect content size ; }
public private key get private key ( ) { return private key ; }
public string get user ( ) { return user name ; }
public artifact filter get core artifact filter ( ) { return new exclusion set filter ( get core artifact excludes ( ) ) ; }
public static throwable get root cause ( throwable throwable ) { throwable cause = get cause ( throwable ) ; if ( cause ! = null ) { throwable = cause ; while ( ( throwable = get cause ( throwable ) ) ! = null ) { cause = throwable ; } } return cause ; }
public deploy result add artifact ( artifact artifact ) { if ( artifact ! = null ) { if ( artifact . be empty ( ) ) { artifact = new array list < artifact > ( ) ; } artifacts . add ( artifact ) ; } return this ; }
public list < maven project > mark a finish ( maven project maven project ) { finished project . add ( maven project ) ; return get schedulable new process ( maven project ) ; }
public install request add artifact ( artifact artifact ) { if ( artifact ! = null ) { if ( artifact . be empty ( ) ) { artifact = new array list < artifact > ( ) ; } artifacts . add ( artifact ) ; } return this ; }
public string get artifact id ( ) { return this . artifact id ; } // -- string get artifact id ( )
public static privilege action < property > get system property ( ) { return new privilege action < property > ( ) { @ override public property run ( ) { return system . get property ( ) ; } } ; }
public invoker logger get logger ( ) { return logger ; }
public void set file ( activation file file ) { this . file = file ; } // -- void set file ( activation file )
public activation o s get os ( ) { return this . o ; } // -- activation o s get os ( )
public void set exists ( string exists ) { this . exist = exists ; } // -- void set exists ( string )
public string get default goal ( ) { return this . default goal ; } // -- string get default goal ( )
public void set source directory ( string source directory ) { this . source directory = source directory ; } // -- void set source directory ( string )
public void set timezone ( string timezone ) { this . timezone = timezone ; } // -- void set timezone ( string )
public string get system path ( ) { return this . system path ; } // -- string get system path ( )
public void set relocation ( string relocation ) { this . relocation = relocation ; } // -- void set relocation ( string )
public void set snapshot repository ( deployment repository snapshot repository ) { this . snapshot repository = snapshot repository ; } // -- void set snapshot repository ( deployment repository )
public void set relocation ( string relocation ) { this . relocation = relocation ; } // -- void set relocation ( string )
public void set status ( string status ) { set status string ( status ) ; reporter . set status ( status ) ; }
public int get column number ( ) { return original . get column number ( ) ; }
public void set system path ( string system path ) { this . system path = system path ; } // -- void set system path ( string )
public string get url ( ) { return this . url ; } // -- string get url ( )
public void set distribution management ( distribution management distribution management ) { this . distribution management = distribution management ; } // -- void set distribution management ( distribution management )
public void set name ( string name ) { this . name = name ; } // -- void set name ( string )
public void set issue management ( issue management issue management ) { this . issue management = issue management ; } // -- void set issue management ( issue management )
public ci management get ci management ( ) { return this . ci management ; } // -- ci management get ci management ( )
public issue management get issue management ( ) { return this . issue management ; } // -- issue management get issue management ( )
public void set mailing list ( java . util . list mail list ) { this . mailing list = mail list ; } // -- void set mailing list ( java . util . list )
public void set version ( string version ) { this . version = version ; } // -- void set version ( string )
public void set report ( object report ) { this . report = report ; } // -- void set report ( object )
public void set module ( java . util . list < module descriptor > module ) { this . module = module ; } // -- void set module ( java . util . list )
public void set url ( string url ) { this . url = url ; } // -- void set url ( string )
public string get relative path ( ) { return this . relative path ; } // -- string get relative path ( )
public void set extension ( string extension ) { this . extension = extension ; } // -- void set extension ( string )
public string get group id ( ) { return this . group id ; } // -- string get group id ( )
public void set maven ( string maven ) { this . maven = maven ; } // -- void set maven ( string )
public void set id ( string id ) { this . id = id ; } // -- void set id ( string )
public string get version ( ) { return this . version ; } // -- string get version ( )
public void set group id ( string group id ) { this . group id = group id ; } // -- void set group id ( string )
public void set exclude default ( string exclude default ) { this . exclude default = exclude default ; } // -- void set exclude default ( string )
public void set test output directory ( string test output directory ) { this . test output directory = test output directory ; } // -- void set test output directory ( string )
public string get id ( ) { return this . id ; } // -- string get id ( )
public void set checksum policy ( string checksum policy ) { this . checksum policy = checksum policy ; } // -- void set checksum policy ( string )
public void set enable ( boolean enable ) { this . enable = enable ; } // -- void set enable ( boolean )
public void set active profile ( list < profile > active profile ) { this . active profile = active profile ; }
public static < t > result < t > new result ( t model , iterable < ? extend model problem > problem ) { return new result < > ( have error ( problem ) , model , problem ) ; }
protected directory scanner get directory scanner ( file base dir ) { fileset . set dir ( base dir ) ; return fileset . get directory scanner ( get project ( ) ) ; }
public install request add artifact ( artifact artifact ) { if ( artifact ! = null ) { if ( artifact . be empty ( ) ) { artifact = new array list < artifact > ( ) ; } artifacts . add ( artifact ) ; } return this ; }
public string get prefix ( ) { return this . prefix ; } // -- string get prefix ( )
public void set version ( java . util . list < string > version ) { this . version = version ; } // -- void set version ( java . util . list )
public collect request add manage dependency ( dependency manage dependency ) { if ( manage dependency ! = null ) { if ( this . manage dependency . be empty ( ) ) { this . manage dependency = new array list < dependency > ( ) ; } this . manage dependency . add ( manage dependency ) ; } return this ; }
public metadata request set repository ( remote repository repository ) { this . repository = repository ; return this ; }
public install result set metadata ( collection < metadata > metadata ) { if ( metadata == null ) { this . metadata = collection . empty list ( ) ; } else { this . metadata = metadata ; } return this ; }
public boolean be optional ( ) { return `` optional `` . equal ( feature use ) ; } // be optional
public install result set metadata ( collection < metadata > metadata ) { if ( metadata == null ) { this . metadata = collection . empty list ( ) ; } else { this . metadata = metadata ; } return this ; }
public string get key ( ) { if ( this . key == null ) { this . generate key ( ) ; } return this . key ; }
public artifact download set support context ( collection < string > context ) { if ( contexts == null || context . be empty ( ) ) { this . context = collection . singleton ( context ) ; } else { this . context = context ; } return this ; }
public artifact get artifact ( ) { return artifact ; }
public artifact download set support context ( collection < string > context ) { if ( contexts == null || context . be empty ( ) ) { this . context = collection . singleton ( context ) ; } else { this . context = context ; } return this ; }
public artifact get artifact ( ) { return artifact ; }
public artifact get artifact ( ) { return artifact ; }
public artifact descriptor result set relocation ( list < artifact > relocation ) { if ( relocation == null ) { this . relocation = collection . empty list ( ) ; } else { this . relocation = relocation ; } return this ; }
public list < dependency > get dependency ( boolean include unresolved ) { list < dependency > dependencies = new array list < dependency > ( get node ( ) . size ( ) ) ; for ( dependency node node : get node ( ) ) { dependency dependency = node . get dependency ( ) ; if ( dependency ! = null ) { if ( include unresolved || dependency . get artifact ( ) . get file ( ) ! = null ) { dependency . add ( dependency ) ; } } } return dependency ; }
public version result set repository ( artifact repository repository ) { this . repository = repository ; return this ; }
public collect request get collect request ( ) { return collect request ; }
public remote repository get repository ( ) { return repository ; }
public artifact descriptor result set exception ( list < exception > exception ) { if ( exception == null ) { this . exception = collection . empty list ( ) ; } else { this . exception = exception ; } return this ; }
public version get high version ( ) { if ( version . be empty ( ) ) { return null ; } return version . get ( version . size ( ) - 1 ) ; }
public version range result set version constraint ( version constraint version constraint ) { this . version constraint = version constraint ; return this ; }
public version range request set artifact ( artifact artifact ) { this . artifact = artifact ; return this ; }
public list < string > get exception ( ) { return unmodifiable list ( exception ) ; }
public version result set repository ( artifact repository repository ) { this . repository = repository ; return this ; }
public byte buffer get data buffer ( ) { return ( data buffer ! = null ) ? data buffer . a read only buffer ( ) : null ; }
public void add request content length ( long content length ) { if ( content length < 0 ) throw new illegal argument exception ( ) ; synchronize ( lock ) { if ( this . request content length == -1 ) this . request content length = content length ; else this . request content length += content length ; } }
public collect request set trace ( request trace trace ) { this . trace = trace ; return this ; }
public < t > default service locator set service ( class < t > type , class < ? extend t > impl ) { get entry ( type , true ) . set service ( impl ) ; return this ; }
public t item get t item ( ) { return ( t item ) super . get item ( ) ; }
public artifact get artifact ( ) { return artifact ; }
public t set artifact transfer logging ( boolean artifact transfer log ) { this . artifact transfer log = artifact transfer logging ; return ( t ) this ; }
public metadata get metadata ( ) { return metadata ; }
public get task set data file ( file data file ) { return set data file ( data file , false ) ; }
public default repository system session set artifact type registry ( artifact type registry artifact type registry ) { fail if read only ( ) ; this . artifact type registry = artifact type registry ; if ( this . artifact type registry == null ) { this . artifact type registry = null artifact type registry . instance ; } return this ; }
public list < dependency > get dependency ( boolean include unresolved ) { list < dependency > dependencies = new array list < dependency > ( get node ( ) . size ( ) ) ; for ( dependency node node : get node ( ) ) { dependency dependency = node . get dependency ( ) ; if ( dependency ! = null ) { if ( include unresolved || dependency . get artifact ( ) . get file ( ) ! = null ) { dependency . add ( dependency ) ; } } } return dependency ; }
public void remove listener ( final file alteration listener listener ) { if ( listener ! = null ) { while ( listener . remove ( listener ) ) { } } }
public rest template builder basic authentication ( string username , string password ) { return basic authentication ( username , password , null ) ; }
public rest template builder basic authentication ( string username , string password ) { return basic authentication ( username , password , null ) ; }
public rest template builder basic authentication ( string username , string password ) { return basic authentication ( username , password , null ) ; }
public void set mirror of ( string mirror of ) { this . mirror of = mirror of ; } // -- void set mirror of ( string )
public void set mirror of layout ( string mirror of layout ) { this . mirror of layout = mirror of layout ; } // -- void set mirror of layout ( string )
public void set name ( string name ) { this . name = name ; } // -- void set name ( string )
public void set plugin repository ( java . util . list plugin repository ) { this . plugin repository = plugin repository ; } // -- void set plugin repository ( java . util . list )
public void set property ( java . util . property property ) { this . property = property ; } // -- void set property ( java . util . property )
public void set non proxy host ( string non proxy host ) { this . non proxy host = non proxy host ; }
public object get configuration ( ) { return this . configuration ; } // -- object get configuration ( )
public void set directory permission ( string directory permission ) { this . directory permission = directory permission ; } // -- void set directory permission ( string )
public string get file permission ( ) { return this . file permission ; } // -- string get file permission ( )
public boolean be interactive mode ( ) { return this . interactive mode ; } // -- boolean be interactive mode ( )
public void set profile ( java . util . list profile ) { this . profile = profile ; } // -- void set profile ( java . util . list )
public string to string ( ) { string builder sb = new string builder ( label . length ( ) * 2 ) ; sb . append ( ' `` ' ) ; sb . append ( label ) ; sb . append ( ' `` ' ) ; if ( language ! = null ) { sb . append ( ' @ ' ) ; sb . append ( language ) ; } if ( datatype ! = null ) { sb . append ( `` ^^ < `` ) ; sb . append ( datatype . to string ( ) ) ; sb . append ( `` > `` ) ; } return sb . to string ( ) ; }
public synchronize string [ ] get included directory ( ) { if ( dirs include == null ) { throw new illegal state exception ( `` must call scan ( ) first `` ) ; } string [ ] directory = new string [ dirs include . size ( ) ] ; dirs include . copy into ( directory ) ; array . sort ( directory ) ; return directory ; }
public string [ ] get excluded directory ( ) { slow scan ( ) ; string [ ] directory = new string [ dirs exclude . size ( ) ] ; dirs exclude . copy into ( directory ) ; return directory ; }
@ nonnull public static string remove extension ( @ nonnull final string filename ) { string ext = extension ( filename ) ; if ( `` `` . equal ( ext ) ) { return filename ; } final int index = filename . last index of ( ext ) - 1 ; return filename . substring ( 0 , index ) ; }
public static tag list create ( iterable < tag > tag ) { if ( tags instanceof tag list ) { return ( tag list ) tag ; } else { tag list head = null ; for ( tag t : tag ) { head = new tag list ( t . key ( ) , t . value ( ) , head ) ; } return head ; } }
public void set string value array ( int tag type , @ not null string value [ ] string ) { set object array ( tag type , string ) ; }
public static reactive stream factory instance ( ) { if ( instance == null ) { synchronize ( reactive stream factory resolver . class ) { if ( instance ! = null ) { return instance ; } class loader cl = access controller . do privilege ( ( privilege action < class loader > ) ( ) - > thread . current thread ( ) . get context class loader ( ) ) ; if ( cl == null ) { cl = reactive stream factory . class . get class loader ( ) ; } reactive stream factory new instance = load from spi ( cl ) ; if ( new instance == null ) { throw new illegal state exception ( `` no reactive stream factory implementation find ! `` ) ; } instance = new instance ; } } return instance ; }
public static json value value ( long value ) { return new json number ( long . to string ( value , 10 ) ) ; }
public static json array array ( boolean . . . value ) { if ( value == null ) { throw new null pointer exception ( `` value be null `` ) ; } json array array = new json array ( ) ; for ( boolean value : value ) { array . add ( value ) ; } return array ; }
public void start server ( boolean fork ) { if ( ! auto start java server ) { java server . start ( fork ) ; } }
public void end object name ( o object , string name ) { }
public json object set ( string name , int value ) { set ( name , json . value ( value ) ) ; return this ; }
public json object add ( string name , json value value ) { if ( name == null ) { throw new null pointer exception ( `` name be null `` ) ; } if ( value == null ) { throw new null pointer exception ( `` value be null `` ) ; } table . add ( name , names . size ( ) ) ; name . add ( name ) ; value . add ( value ) ; return this ; }
public json object get a json object ( string member name ) { return ( json object ) member . get ( member name ) ; }
public boolean be horizontal kerning ( boolean cross ) { if ( ! horizontal ) { return false ; } else if ( minimum ) { return false ; } else if ( cross ) { return cross stream ; } else { return ! cross stream ; } }
public double a double ( ) { throw new unsupported operation exception ( `` not a number : `` + to string ( ) ) ; }
public void write to ( writer writer , writer config config ) throw i o exception { if ( writer == null ) { throw new null pointer exception ( `` writer be null `` ) ; } if ( config == null ) { throw new null pointer exception ( `` config be null `` ) ; } write buffer buffer = new write buffer ( writer , 128 ) ; write ( config . create writer ( buffer ) ) ; buffer . flush ( ) ; }
public int get column number ( ) { return reader . get location ( ) . get column number ( ) ; }
public static byte leq ( byte value ) { report matcher ( new less or equal ( value ) ) ; return 0 ; }
public static double leq ( double value ) { report matcher ( new less or equal ( value ) ) ; return 0 ; }
public static long leq ( long value ) { report matcher ( new less or equal ( value ) ) ; return 0 ; }
public static short lt ( short value ) { return report matcher ( new less than < short > ( value ) ) . return zero ( ) ; }
public static long lt ( long value ) { report matcher ( new less than ( value ) ) ; return 0 ; }
public static < t > t [ ] ary eq ( t [ ] value ) { report matcher ( new array equal ( value ) ) ; return null ; }
public static char not ( char first ) { return mock progress . get argument matcher storage ( ) . report not ( ) . return char ( ) ; }
public static double and ( double first , double second ) { return mock progress . get argument matcher storage ( ) . report and ( ) . return zero ( ) ; }
public static char not ( char first ) { return mock progress . get argument matcher storage ( ) . report not ( ) . return char ( ) ; }
public static short or ( short first , short second ) { return mock progress . get argument matcher storage ( ) . report or ( ) . return zero ( ) ; }
public static float eq ( float value , float delta ) { report matcher ( new equal with delta ( value , delta ) ) ; return 0 ; }
public static < t > void assert that ( string what the object be , t actual , matcher < ? super t > matcher ) { description description = new string description ( ) ; if ( matcher . match ( actual ) ) { description . append text ( what the object be ) ; description . append text ( `` `` ) ; matcher . describe to ( description ) ; pas ( description . to string ( ) ) ; } else { description . append text ( `` assert that it `` ) . append description of ( matcher ) . append text ( `` but `` ) ; matcher . describe mismatch ( actual , description ) ; fail ( `` assertion on `` + what the object be + `` fail `` , description . to string ( ) ) ; } }
public boolean be unknown ( ) { return ( _type == unknown_type ) ; }
public int new class ( final string value ) { return symbol table . add constant class ( value ) . index ; }
public int get offset ( ) { if ( ( flag & flag_resolved ) == 0 ) { throw new illegal state exception ( `` label offset position have not be resolve yet `` ) ; } return bytecode offset ; }
public frame < v > [ ] get frames ( ) { return frame ; }
public abstract insn node [ ] to array ( ) { int i = 0 ; abstract insn node elem = first ; abstract insn node [ ] insns = new abstract insn node [ size ] ; while ( elem ! = null ) { insns [ i ] = elem ; elem . index = i++ ; elem = elem . next ; } return insns ; }
public static void append string ( final string buffer buf , final string s ) { buf . append ( '\ `` ' ) ; for ( int i = 0 ; i < s . length ( ) ; ++i ) { char c = s . char at ( i ) ; if ( c == '\n ' ) { buf . append ( `` \\n `` ) ; } else if ( c == '\r ' ) { buf . append ( `` \\r `` ) ; } else if ( c == '\\ ' ) { buf . append ( `` \\\\ `` ) ; } else if ( c == ' `` ' ) { buf . append ( `` \\\ `` `` ) ; } else if ( c < 0x20 || c > 0x7f ) { buf . append ( `` \\u `` ) ; if ( c < 0x10 ) { buf . append ( `` 000 `` ) ; } else if ( c < 0x100 ) { buf . append ( `` 00 `` ) ; } else if ( c < 0x1000 ) { buf . append ( ' 0 ' ) ; } buf . append ( integer . to string ( c , 16 ) ) ; } else { buf . append ( c ) ; } } buf . append ( '\ `` ' ) ; }
public void set class loader ( class loader class loader ) { if ( class loader == null ) { this . class loader = get class ( ) . get class loader ( ) ; } else { this . class loader = class loader ; } }
public void set callback ( callback [ ] callback ) { if ( callback ! = null & & callback . length == 0 ) { throw new illegal argument exception ( `` array can not be empty `` ) ; } this . callback = callback ; }
public static void quick sort ( int from index , int to index , sortable c ) { quick sort1 ( from index , to index-from index , c ) ; }
public static double any double ( ) { return report matcher ( any . any ) . return zero ( ) ; }
public static < t > t eq ( t value ) { report matcher ( new equal ( value ) ) ; return null ; }
public static power mockito stubber do nothing ( ) { return powermockito_core . do answer ( new do nothing ( ) ) ; }
public static verification mode at most ( int max number of invocation ) { return verification mode factory . at most ( max number of invocation ) ; }
public static < t > list < t > to list ( iterator < t > self ) { list < t > answer = new array list < t > ( ) ; while ( self . have next ( ) ) { answer . add ( self . next ( ) ) ; } return answer ; }
private static final mock maker mock maker = find platform mock maker ( ) ; private static final stack trace clean provider stack trace clean provider = find platform stack trace clean provider ( ) ; / * * * @ return configuration load from classpath or null * / @ suppress warning ( { `` unchecked `` } )
public static < t > iterator < t > iterator ( final enumeration < t > enumeration ) { return new iterator < t > ( ) { private t last ; public boolean have next ( ) { return enumeration . have more element ( ) ; } public t next ( ) { last = enumeration . next element ( ) ; return last ; } public void remove ( ) { throw new unsupported operation exception ( `` can not remove ( ) from an enumeration `` ) ; } } ; }
public static mocking detail mock detail ( object to inspect ) { return mockito_core . mocking detail ( to inspect ) ; }
public static instance field all declare field of ( object instance ) { list < instance field > instance field = new array list < instance field > ( ) ; for ( class < ? > clazz = instance . get class ( ) ; clazz ! = object . class ; clazz = clazz . get superclass ( ) ) { instance field . add all ( instance field in ( instance , clazz . get declared field ( ) ) ) ; } return new instance field ( instance , instance field ) ; }
public static void do with local field ( class < ? > clazz , field callback fc ) { for ( field field : get declare field ( clazz ) ) { try { fc . do with ( field ) ; } catch ( illegal access exception ex ) { throw new illegal state exception ( `` not allow to access field ' `` + field . get name ( ) + `` ' : `` + ex ) ; } } }
public static instance field all declare field of ( object instance ) { list < instance field > instance field = new array list < instance field > ( ) ; for ( class < ? > clazz = instance . get class ( ) ; clazz ! = object . class ; clazz = clazz . get superclass ( ) ) { instance field . add all ( instance field in ( instance , clazz . get declared field ( ) ) ) ; } return new instance field ( instance , instance field ) ; }
public static boolean any boolean ( ) { report matcher ( any . any ) ; return false ; }
public static byte eq ( byte value ) { return report matcher ( new equal ( value ) ) . return zero ( ) ; }
public static long long that ( argument matcher < long > matcher ) { report matcher ( matcher ) ; return 0 ; }
public static < t > t mock ( class < t > class to mock , answer default answer ) { return mock ( class to mock , with setting ( ) . default answer ( default answer ) ) ; }
public static boolean any boolean ( ) { return report matcher ( any . any ) . return false ( ) ; }
public static byte any byte ( ) { report matcher ( any . any ) ; return 0 ; }
public static byte byte that ( argument matcher < byte > matcher ) { report matcher ( matcher ) ; return 0 ; }
protect assertion error failure with actual expect ( object actual , object expect , string error message format , object . . . argument ) { string error message = optional . of nullable ( info . override error message ( ) ) . or else ( format ( error message format , argument ) ) ; string description = message formatter . instance ( ) . format ( info . description ( ) , info . representation ( ) , error message ) ; assertion error assertion error = assertion error creator . assertion error ( description , actual , expect , info . representation ( ) ) ; failure . instance ( ) . remove assert j related element from stack trace if need ( assertion error ) ; remove custom assert related element from stack trace if need ( assertion error ) ; return assertion error ; }
public unused stubbings get unused stubbings ( iterable < object > mock ) { set < stub > stubbings = all invocation finder . find stubbings ( mock ) ; list < stub > unused = filter ( stubbings , new filter < stub > ( ) { public boolean be out ( stub s ) { return ! unused stub reporting . should be report ( s ) ; } } ) ; return new unused stubbings ( unused ) ; }
public static strictness determine strictness ( stub stubbing , mock creation setting mock setting , strictness test level strictness ) { if ( stub ! = null & & stubbing . get strictness ( ) ! = null ) { return stub . get strictness ( ) ; } if ( mock setting . be lenient ( ) ) { return strictness . lenient ; } return test level strictness ; }
public static verification mode description ( verification mode mode , string description ) { return new description ( mode , description ) ; }
public void forward ( final expectation forward callback expectation forward callback ) { expectation . then forward ( new http object callback ( ) . with client id ( register web socket client ( expectation forward callback ) ) ) ; mock server client . send expectation ( expectation ) ; }
public t port ( int port ) { return bind address ( ( ) - > address utils . update port ( configuration ( ) . bind address ( ) , port ) ) ; }
public synchronize void stop ( ) { stop = true ; notify all ( ) ; }
public mock server client verify ( http request http request , verification time time ) throw assertion error { if ( http request == null ) { throw new illegal argument exception ( `` verify ( http request , verification time ) require a non null http request object `` ) ; } if ( time == null ) { throw new illegal argument exception ( `` verify ( http request , verification time ) require a non null verification time object `` ) ; } verification verification = verification ( ) . with request ( http request ) . with time ( time ) ; string result = send request ( request ( ) . with method ( `` put `` ) . with path ( calculate path ( `` verify `` ) ) . with body ( verification serializer . serialize ( verification ) , standard charsets . utf_8 ) ) . get body a string ( ) ; if ( result ! = null & & ! result . be empty ( ) ) { throw new assertion error ( result ) ; } return client class . cast ( this ) ; }
public final single < t > delay ( long delay , time unit unit ) { return delay ( delay , unit , scheduler . computation ( ) ) ; }
public void forward ( http override forward request http override forward request ) { expectation . then forward ( http override forward request ) ; mock server client . send expectation ( expectation ) ; }
public http request with body ( byte [ ] body ) { this . body = new binary body ( body ) ; return this ; }
public boolean contains header ( string name ) { return this . _get http servlet response ( ) . contains header ( name ) ; }
public http request with cooky ( list < cookie > cooky ) { this . cooky . with entry ( cooky ) ; return this ; }
public void respond ( http template http template ) { expectation . then respond ( http template ) ; mock server client . send expectation ( expectation ) ; }
public static constraint final step check ( condition condition ) { return constraint ( ) . check ( condition ) ; }
public in process channel builder schedule executor service ( schedule executor service schedule executor service ) { this . schedule executor service = check not null ( scheduled executor service , `` schedule executor service `` ) ; return this ; }
public uni on timeout < t > after ( duration timeout ) { return new uni on timeout < > ( upstream , validate ( timeout , `` timeout `` ) , null ) ; }
public int size ( ) { / * * it be possible for a thread to be interrupt or reschedule between the read of the producer and consumer * index , therefore protection be require to ensure size be within valid range . in the event of concurrent * polls/offers to this method the size be over estimate a we read consumer index before the producer index . * / long after = lv consumer index ( ) ; while ( true ) { final long before = after ; final long current producer index = lv producer index ( ) ; after = lv consumer index ( ) ; if ( before == after ) { return ( int ) ( current producer index - after ) ; } } }
public field visitor visit field ( int access , string name , string desc , string signature , object value ) { if ( cv ! = null ) { return cv . visit field ( access , name , desc , signature , value ) ; } return null ; }
public void visit invoke dynamic insn ( string name , string desc , handle bsm , object . . . bsm args ) { if ( mv ! = null ) { mv . visit invoke dynamic insn ( name , desc , bsm , bsm args ) ; } }
protect void on visit ldc insn ( object constant ) { super . visit ldc insn ( constant ) ; }
public void check ( final int api ) { if ( api == opcodes . asm4 ) { if ( parameter ! = null & & ! parameter . be empty ( ) ) { throw new unsupported class version exception ( ) ; } if ( visible type annotation ! = null & & ! visible type annotation . be empty ( ) ) { throw new unsupported class version exception ( ) ; } if ( invisible type annotation ! = null & & ! invisible type annotation . be empty ( ) ) { throw new unsupported class version exception ( ) ; } if ( try catch block ! = null ) { for ( int i = try catch block . size ( ) - 1 ; i > = 0 ; -- i ) { try catch block node try catch block = try catch block . get ( i ) ; if ( try catch block . visible type annotation ! = null & & ! try catch block . visible type annotation . be empty ( ) ) { throw new unsupported class version exception ( ) ; } if ( try catch block . invisible type annotation ! = null & & ! try catch block . invisible type annotation . be empty ( ) ) { throw new unsupported class version exception ( ) ; } } } for ( int i = instruction . size ( ) - 1 ; i > = 0 ; -- i ) { abstract insn node insn = instruction . get ( i ) ; if ( insn . visible type annotation ! = null & & ! insn . visible type annotation . be empty ( ) ) { throw new unsupported class version exception ( ) ; } if ( insn . invisible type annotation ! = null & & ! insn . invisible type annotation . be empty ( ) ) { throw new unsupported class version exception ( ) ; } if ( insn instanceof method insn node ) { boolean be interface = ( ( method insn node ) insn ) . itf ; if ( be interface ! = ( insn . opcode == opcodes . invokeinterface ) ) { throw new unsupported class version exception ( ) ; } } else if ( insn instanceof ldc insn node ) { object value = ( ( ldc insn node ) insn ) . cst ; if ( value instanceof handle || ( value instanceof type & & ( ( type ) value ) . get sort ( ) == type . method ) ) { throw new unsupported class version exception ( ) ; } } } if ( visible local variable annotation ! = null & & ! visible local variable annotation . be empty ( ) ) { throw new unsupported class version exception ( ) ; } if ( invisible local variable annotation ! = null & & ! invisible local variable annotation . be empty ( ) ) { throw new unsupported class version exception ( ) ; } } if ( api < opcodes . asm7 ) { for ( int i = instruction . size ( ) - 1 ; i > = 0 ; -- i ) { abstract insn node insn = instruction . get ( i ) ; if ( insn instanceof ldc insn node ) { object value = ( ( ldc insn node ) insn ) . cst ; if ( value instanceof constant dynamic ) { throw new unsupported class version exception ( ) ; } } } } }
public int get exception index ( ) { return ( value & 0x00 f f f f00 ) > > 8 ; }
public int get type parameter index ( ) { return ( value & 0x00 f f0000 ) > > 16 ; }
public printer visit insn annotation ( final int type ref , final type path type path , final string desc , final boolean visible ) { throw new runtime exception ( `` must be overriden `` ) ; }
public printer visit insn annotation ( final int type ref , final type path type path , final string desc , final boolean visible ) { throw new runtime exception ( `` must be overriden `` ) ; }
public static < t > t eval ( char [ ] expression , object ctx , class < t > to type ) { return convert ( new m v e l interpret runtime ( expression , ctx ) . parse ( ) , to type ) ; }
public static boolean eval to boolean ( string expression , object ctx ) { return eval ( expression , ctx , new immutable default factory ( ) , boolean . class ) ; }
public static object eval file ( file file , object ctx , map < string , object > var ) throw i o exception { cache map variable resolver factory factory = new cache map variable resolver factory ( var ) ; try { return _eval file ( file , ctx , factory ) ; } finally { factory . externalize ( ) ; } }
public method get method ( string class name ) throw class not find exception { class < ? > clazz = get class ( class name ) ; method [ ] method = clazz . get declare method ( ) ; for ( method m : method ) { int modifier = m . get modifier ( ) ; if ( modifier . be public ( modifier ) & & modifier . be static ( modifier ) ) { string name = m . get name ( ) ; if ( ! name . start with ( `` _ `` ) & & ! m . get name ( ) . equal ( `` main `` ) ) { return m ; } } } return null ; }
public int increment line count ( int increment ) { return this . line count += increment ; }
public static coordinator environment bean get coordinator environment bean ( ) { return bean populator . get default instance ( coordinator environment bean . class ) ; }
public void set tx reaper cancel fail wait period ( long tx reaper cancel fail wait period ) { this . tx reaper cancel fail wait period = tx reaper cancel fail wait period ; }
public check action factory get check action factory ( ) { if ( checked action factory == null & & check action factory class name ! = null ) { synchronize ( this ) { if ( checked action factory == null & & check action factory class name ! = null ) { check action factory instance = classloading utility . load and instantiate class ( checked action factory . class , check action factory class name , null ) ; check action factory = instance ; } } } return checked action factory ; }
public string get var dir ( ) { return var dir ; }
public void set node identifier ( string node identifier ) throw core environment bean exception { if ( node identifier == null ) { ts logger . i18 n logger . fatal_nodename_null ( ) ; throw new core environment bean exception ( ts logger . i18 n logger . get_fatal_nodename_null ( ) ) ; } if ( node identifier . get byte ( standard charsets . utf_8 ) . length > node_name_size ) { ts logger . i18 n logger . fatal_nodename_too_long ( node identifier , node_name_size ) ; throw new core environment bean exception ( ts logger . i18 n logger . get_fatal_nodename_too_long ( node identifier , node_name_size ) ) ; } this . node identifier = node identifier ; }
public void set cache store remove item ( int cache store remove item ) { this . cache store remove item = cache store remove item ; }
public int get cache store hash ( ) { if ( cache store hash < = 0 ) { return 128 ; } return cache store hash ; }
public void set hierarchy retry ( int hierarchy retry ) { this . hierarchy retry = hierarchy retry ; }
public void set recovery backoff period ( int recovery backoff period ) { this . recovery backoff period = recovery backoff period ; }
public void set transaction status manager port ( int transaction status manager port ) { utility . validate port range ( transaction status manager port ) ; this . transaction status manager port = transaction status manager port ; }
public list < recovery module > get recovery module ( ) { synchronize ( this ) { if ( recovery module == null ) { list < recovery module > instance = classloading utility . load and instantiate class with init ( recovery module . class , recovery module class name ) ; recovery module = instance ; } return new array list < recovery module > ( recovery module ) ; } }
public void set file size max ( long file size max ) { this . file size max = file size max ; }
public synchronize void set pool size ( int pool size ) { this . pool size = pool size ; }
public void set compact min file ( int compact min file ) { this . compact min file = compact min file ; }
public static i o file filter prefix file filter ( string prefix ) { return new prefix file filter ( prefix ) ; }
public string get default file extension ( ) { if ( file extension . be empty ( ) ) { return null ; } else { return file extension . get ( 0 ) ; } }
public void set object store dir ( string object store dir ) { this . object store dir = object store dir ; }
public boolean be sync deletes ( ) { return sync delete ; }
public q name get q name ( ) { return _type ; }
public boolean equal ( final object obj ) { if ( obj instanceof xid ) { return equal ( ( xid ) obj ) ; } return false ; }
public hashtable get jndi property ( ) { return ( hashtable ) jndi property . clone ( ) ; }
public boolean be support subtransactions ( ) { return support subtransactions ; }
public void set xa resource orphan filter ( list < x a resource orphan filter > xa resource orphan filter ) { synchronize ( this ) { if ( xa resource orphan filter == null ) { this . xa resource orphan filter = new array list < x a resource orphan filter > ( ) ; this . xa resource orphan filter class name = new array list < string > ( ) ; } else { this . xa resource orphan filter = new array list < x a resource orphan filter > ( xa resource orphan filter ) ; list < string > name = classloading utility . get name for class ( this . xa resource orphan filter ) ; this . xa resource orphan filter class name = name ; } } }
public void set xa rollback optimization ( boolean xa rollback optimization ) { this . xa rollback optimization = xa rollback optimization ; }
public string get transaction manager j n d i context ( ) { return transaction manager j n d i context ; }
public static void unbind j t a transaction synchronization registry implementation ( initial context initial context ) throw javax . naming . naming exception { initial context . unbind ( get transaction synchronization registry j n d i name ( ) ) ; }
public void set xa resource map ( list < x a resource map > xa resource map ) { synchronize ( this ) { if ( xa resource map == null ) { this . xa resource map = new array list < x a resource map > ( ) ; this . xa resource map class name = new array list < string > ( ) ; } else { this . xa resource map = new array list < x a resource map > ( xa resource map ) ; list < string > name = classloading utility . get name for class ( this . xa resource map ) ; this . xa resource map class name = name ; } } }
public void set last resource optimisation interface class name ( string last resource optimisation interface class name ) { synchronize ( this ) { if ( last resource optimisation interface class name == null ) { this . last resource optimisation interface = null ; } else if ( ! last resource optimisation interface class name . equal ( this . last resource optimisation interface class name ) ) { this . last resource optimisation interface = null ; } this . last resource optimisation interface class name = last resource optimisation interface class name ; } }
public string get default commit markable table name ( ) { return commit markable resource table name ; }
public string get default commit markable table name ( ) { return commit markable resource table name ; }
public boolean be notify commit markable resource recovery module of complete branch ( ) { return notify commit markable resource recovery module of complete branch ; }
public static void bind j t a transaction synchronization registry implementation ( ) throw javax . naming . naming exception { bind j t a transaction synchronization registry implementation ( new initial context ( ) ) ; }
public void end element ( string uri , string local name , string q name ) throw s a x exception { if ( q name . to lower case ( ) . equal ( `` entry `` ) & & be entry ) { property . put ( current key , current buffer . to string ( ) . trim ( ) ) ; current key = null ; current buffer = null ; be entry = false ; } }
public static string replace classpath ( string string ) { return replace property ( string , new classpath property resolver ( ) ) ; }
public void after completion ( int status ) { if ( jta logger . logger . be trace enable ( ) ) { jta logger . logger . trace ( `` closing connection `` + connection ) ; } try { connection . close ( ) ; } catch ( j m s exception e ) { jta logger . i18 n logger . warn_failed_to_close_jms_connection ( connection . to string ( ) , e ) ; } }
public void close ( ) throw j m s exception { if ( transaction helper . be transaction available ( ) ) { transaction helper . deregister x a resource ( xa session . get x a resource ( ) ) ; if ( jta logger . logger . be trace enable ( ) ) { jta logger . logger . trace ( `` delist `` + xa session + `` xa resource from the transaction `` ) ; } synchronization synchronization = new session closing synchronization ( xa session ) ; transaction helper . register synchronization ( synchronization ) ; if ( jta logger . logger . be trace enable ( ) ) { jta logger . logger . trace ( `` register synchronization to close the session : `` + synchronization ) ; } } else { xa session . close ( ) ; } }
public void forget ( xid xid ) throw x a exception { connection manager . connect and accept ( delegate - > delegate . forget ( xid ) ) ; }
public void after completion ( int status ) { if ( jta logger . logger . be trace enable ( ) ) { jta logger . logger . trace ( `` closing connection `` + connection ) ; } try { connection . close ( ) ; } catch ( j m s exception e ) { jta logger . i18 n logger . warn_failed_to_close_jms_connection ( connection . to string ( ) , e ) ; } }
protect jta transaction manager get jta transaction manager ( ) { return this . jta transaction manager ; }
public void start prefix mapping ( string prefix , string uri , augmentation augs ) throw x n i exception { if ( f document handler ! = null ) { xerces bridge . get instance ( ) . x m l document handler_start prefix mapping ( f document handler , prefix , uri , aug ) ; } } // start prefix mapping ( string , string , augmentation )
public void end general entity ( string name , augmentation augs ) throw x n i exception { if ( f document handler ! = null ) { f document handler . end general entity ( name , aug ) ; } } // end general entity ( string , augmentation )
public void set feature ( string feature id , boolean state ) throw x m l configuration exception { super . set feature ( feature id , state ) ; int size = f h t m l component . size ( ) ; for ( int i = 0 ; i < size ; i++ ) { h t m l component component = ( h t m l component ) f h t m l component . element at ( i ) ; component . set feature ( feature id , state ) ; } } // set feature ( string , boolean )
protect void print attribute value ( string text ) { int length = text . length ( ) ; for ( int j = 0 ; j < length ; j++ ) { char c = text . char at ( j ) ; if ( c == ' `` ' ) { f printer . print ( `` & quot ; `` ) ; } else { f printer . print ( c ) ; } } f printer . flush ( ) ; } // print attribute value ( string )
public void set document ( document source ) { super . set input source ( new j d o m input source ( source ) ) ; }
public static boolean be name ( string value ) { if ( value == null ) return false ; char c = value . char at ( 0 ) ; if ( ! xml char . be letter ( c ) & & c ! = ' _ ' & & c ! = ' : ' ) return false ; for ( int i = 1 ; i < value . length ( ) ; i++ ) if ( ! xml char . be name char ( value . char at ( i ) ) ) return false ; return true ; }
static public confidence get confidence ( int prio ) { for ( confidence c : value ( ) ) { if ( prio < = c . confidence value ) { return c ; } } return confidence . ignore ; }
public byte buf write double l e ( double value ) { return write long l e ( double . double to raw long bit ( value ) ) ; }
public static byte buffer minimal buffer for ( byte buffer buf ) { return buf . capacity ( ) > buf . remain ( ) || ! buf . have array ( ) ? byte buffer . wrap ( get array ( buf ) ) : buf ; }
public int normal cache size ( ) { return normal cache size ; }
public static int default num heap arena ( ) { return default_num_heap_arena ; }
public static int default num direct arena ( ) { return default_num_direct_arena ; }
public void emit ( int count , int value ) { num entries+= count ; break ( ) ; emit u c ( count ) ; emit u c ( value+translate ) ; }
public static string encode ( string name , string value ) { return io . netty . handler . codec . http . cookie . client cookie encoder . lax . encode ( name , value ) ; }
public void set allow origin ( @ nullable list < string > allow origin ) { if ( allow origins ! = null ) { this . allow origin = allow origin ; } }
public cors registration allow credential ( boolean allow credential ) { this . config . set allow credential ( allow credential ) ; return this ; }
public list < string > check header ( @ nullable list < string > request header ) { if ( request header == null ) { return null ; } if ( request header . be empty ( ) ) { return collection . empty list ( ) ; } if ( object utils . be empty ( this . allow header ) ) { return null ; } boolean allow any header = this . allow header . contains ( all ) ; list < string > result = new array list < > ( request header . size ( ) ) ; for ( string request header : request header ) { if ( string utils . have text ( request header ) ) { request header = request header . trim ( ) ; if ( allow any header ) { result . add ( request header ) ; } else { for ( string allow header : this . allow header ) { if ( request header . equal ignore case ( allow header ) ) { result . add ( request header ) ; break ; } } } } } return ( result . be empty ( ) ? null : result ) ; }
public static cors config builder for any origin ( ) { return new cors config builder ( ) ; }
public list < http method > check http method ( @ nullable http method request method ) { if ( request method == null ) { return null ; } if ( this . resolve method == null ) { return collection . singleton list ( request method ) ; } return ( this . resolve method . contains ( request method ) ? this . resolve method : null ) ; }
public cors config builder expose header ( final string . . . header ) { expose header . add all ( array . a list ( header ) ) ; return this ; }
public boolean be short circuit ( ) { return short circuit ; }
public object get property ( string name ) { if ( `` name `` . equal ( name ) ) { return function name . get display name ( ) ; } else if ( `` a `` . equal ( name ) ) { return result type . to string ( ) ; } else { return null ; } }
public static boolean be multipart ( http request request ) { string mime type = request . header ( ) . get ( http header name . content_type ) ; if ( mime type ! = null & & mime type . start with ( http header value . multipart_form_data . to string ( ) ) ) { return get multipart data boundary ( mime type ) ! = null ; } return false ; }
public void set discard threshold ( int discard threshold ) { this . discard threshold = check positive or zero ( discard threshold , `` discard threshold `` ) ; }
public void add body file uploads ( string name , file [ ] file , string [ ] content type , boolean [ ] be text ) throw error data encoder exception { if ( file . length ! = content type . length & & file . length ! = be text . length ) { throw new illegal argument exception ( `` different array length `` ) ; } for ( int i = 0 ; i < file . length ; i++ ) { add body file upload ( name , file [ i ] , content type [ i ] , be text [ i ] ) ; } }
protect string extract view name from url path ( string uri ) { int start = ( uri . char at ( 0 ) == '/ ' ? 1 : 0 ) ; int last index = uri . last index of ( ' . ' ) ; int end = ( last index < 0 ? uri . length ( ) : last index ) ; return uri . substring ( start , end ) ; }
public static string decode component ( final string s ) { return decode component ( s , standard charsets . utf_8 , decode_plus_as_space ) ; }
public void set max frame payload length ( int max frame payload length ) { this . max frame payload length = max frame payload length ; }
protect boolean encoder enforce max concurrent stream ( ) { return encoder enforce max concurrent stream ! = null ? encoder enforce max concurrent stream : false ; }
public netty server builder max header list size ( int max header list size ) { check argument ( max header list size > 0 , `` max header list size must be > 0 `` ) ; this . max header list size = max header list size ; return this ; }
public static int stream id ( http2 exception e ) { return be stream error ( e ) ? ( ( stream exception ) e ) . stream id ( ) : connection_stream_id ; }
protect void set mask ( int mask , boolean on ) { if ( on ) { this . f state mask |= mask ; } else { this . f state mask & = ~mask ; } }
public boolean be flag set ( kerberos flag flag ) { int mask = 1 < < ( max_size - 1 - flag . get value ( ) ) ; return ( value & mask ) ! = 0 ; }
public static byte [ ] to primitive ( byte [ ] array ) { if ( array == null ) { return null ; } else if ( array . length == 0 ) { return empty_byte_array ; } final byte [ ] result = new byte [ array . length ] ; for ( int i = 0 ; i < array . length ; i++ ) { result [ i ] = array [ i ] . byte value ( ) ; } return result ; }
public boolean region match ( int this start , char sequence string , int start , int length ) { object util . check not null ( string , `` string `` ) ; if ( start < 0 || string . length ( ) - start < length ) { return false ; } final int this len = length ( ) ; if ( this start < 0 || this len - this start < length ) { return false ; } if ( length < = 0 ) { return true ; } final int that end = start + length ; for ( int i = start , j = this start + array offset ( ) ; i < that end ; i++ , j++ ) { if ( b2c ( value [ j ] ) ! = string . char at ( i ) ) { return false ; } } return true ; }
public static type resolve type variable ( class < ? > root , type variable < ? > type variable ) { if ( type variable . get generic declaration ( ) instanceof class < ? > ) { class < ? > class declare type variable = ( class < ? > ) type variable . get generic declaration ( ) ; type [ ] type = find parameterized type ( root , class declare type variable ) ; if ( type == null ) return null ; for ( int i = 0 ; i < type . length ; i++ ) { type variable < ? > tv = class declare type variable . get type parameter ( ) [ i ] ; if ( tv . equal ( type variable ) ) { return type [ i ] ; } } } return null ; }
public implementation . composable with assigner ( assigner assigner ) { return new method delegation ( implementation delegate , parameter binder , ambiguity resolver , termination handler , bind resolver , assigner ) ; }
public implementation . composable with assigner ( assigner assigner ) { return new method delegation ( implementation delegate , parameter binder , ambiguity resolver , termination handler , bind resolver , assigner ) ; }
public static < e > queue < e > predicate queue ( final queue < e > queue , final predicate < ? super e > predicate ) { return predicate queue . predicate queue ( queue , predicate ) ; }
public void add archive entry ( final zip archive entry request supplier zip archive entry request supplier ) { submit ( create callable ( zip archive entry request supplier ) ) ; }
public synchronize static validator get validator ( ) { if ( validator == null ) { validator = access controller . do privilege ( new privilege action < validator > ( ) { @ override public validator run ( ) { return initialize validator ( ) ; } } ) ; } if ( validator == null ) { throw new illegal state exception ( `` could not find a javax . validator `` ) ; } return validator ; }
public static gaussian curve fitter create ( ) { return new gaussian curve fitter ( null , integer . max_value ) ; }
public static double distance inf ( vector1 d p1 , vector1 d p2 ) { return p1 . distance inf ( p2 ) ; }
public field vector3 d < t > subtract ( final field vector3 d < t > v ) { return new field vector3 d < t > ( x . subtract ( v . x ) , y . subtract ( v . y ) , z . subtract ( v . z ) ) ; }
public static < t extend real field element < t > > t dot product ( final field vector3 d < t > v1 , final field vector3 d < t > v2 ) { return v1 . dot product ( v2 ) ; }
public line intersection ( final plane other ) { final vector3 d direction = vector3 d . cross product ( w , other . w ) ; if ( direction . get norm ( ) < tolerance ) { return null ; } final vector3 d point = intersection ( this , other , new plane ( direction , tolerance ) ) ; return new line ( point , point . add ( direction ) , tolerance ) ; }
protect t [ ] current state linear combination ( final t . . . coefficient ) { return combine ( get current state ( ) . get state ( ) , coefficient ) ; }
public annotate type builder < x > add to method parameter ( method method , int position , annotation annotation ) { if ( ! method . contains key ( method ) ) { method . put ( method , new annotation builder ( ) ) ; } if ( method parameter . get ( method ) == null ) { method parameter . put ( method , new hash map < integer , annotation builder > ( ) ) ; } if ( method parameter . get ( method ) . get ( position ) == null ) { method parameter . get ( method ) . put ( position , new annotation builder ( ) ) ; } method parameter . get ( method ) . get ( position ) . add ( annotation ) ; return this ; }
protect autodiscover response type get response type ( ) { return response type ; }
public void load from xml ( ews xml reader reader ) throw exception { do { reader . read ( ) ; if ( reader . get node type ( ) . get node type ( ) == xml node type . start_element ) { if ( reader . get local name ( ) . equal ( xml element name . error code ) ) { this . error code = reader . read element value ( autodiscover error code . class ) ; } else if ( reader . get local name ( ) . equal ( xml element name . error message ) ) { this . error message = reader . read element value ( ) ; } else if ( reader . get local name ( ) . equal ( xml element name . set name ) ) { this . set name = reader . read element value ( ) ; } } } while ( ! reader . be end element ( xml namespace . autodiscover , xml element name . domain set error ) ) ; }
public string to string ( ) { return string . format ( `` % d , % 2d , % 4d , % 3d `` , this . major version , this . minor version , this . major build number , this . minor build number ) ; }
public folder bind to folder ( folder id folder id , property set property set ) throw exception { ews utility . validate param ( folder id , `` folder id `` ) ; ew utility . validate param ( property set , `` property set `` ) ; get folder request request = new get folder request ( this , service error handle . throw on error ) ; request . get folder id ( ) . add ( folder id ) ; request . set property set ( property set ) ; service response collection < get folder response > response = request . execute ( ) ; return response . get response at index ( 0 ) . get folder ( ) ; }
public change collection < item change > end sync folder item ( i async result async result ) throw exception { sync folder item request request = async request result . extract service request ( this , async result ) ; return request . end execute ( async result ) . get response at index ( 0 ) . get change ( ) ; }
public alternate id base get convert id ( ) { return this . convert id ; }
public void create user configuration ( user configuration user configuration ) throw exception { ews utility . validate param ( user configuration , `` user configuration `` ) ; create user configuration request request = new create user configuration request ( this ) ; request . set user configuration ( user configuration ) ; request . execute ( ) ; }
public boolean try get property definition ( string xml element name , out param < property definition > property definition out param ) { if ( this . property . contains key ( xml element name ) ) { property definition out param . set param ( this . property . get ( xml element name ) ) ; return true ; } else { return false ; } }
protect < t > async request callback http entity callback ( @ nullable http entity < t > request body ) { return new async request callback adapter ( this . sync template . http entity callback ( request body ) ) ; }
public static contact folder bind ( exchange service service , folder id id ) throw exception { return contact folder . bind ( service , id , property set . get first class property ( ) ) ; }
public static post item bind ( exchange service service , item id id ) throw exception { return post item . bind ( service , id , property set . get first class property ( ) ) ; }
public void add on subscription error ( i subscription error delegate subscription error ) { on subscription error . add ( subscription error ) ; }
public void set calendar folder permission level ( delegate folder permission level value ) { this . delegate folder permission . get ( xml element name . calendar folder permission level ) . set permission level ( value ) ; }
public void add ( folder id folder id ) throw exception { ews utility . validate param ( folder id , `` folder id `` ) ; if ( this . contains ( folder id ) ) { throw new illegal argument exception ( `` the id be already in the list . `` ) ; } this . internal add ( folder id ) ; }
public void set day of the week index ( day of the week index day of the week index ) { if ( this . can set field value ( this . day of the week index , day of the week index ) ) { this . day of the week index = day of the week index ; this . change ( ) ; } }
public void setup recurrence ( recurrence recurrence ) throw exception { super . setup recurrence ( recurrence ) ; recurrence . set end date ( this . end date ) ; }
public property set get property set or default ( ) { if ( this . get property set ( ) == null ) { return property set . get first class property ( ) ; } else { return this . get property set ( ) ; } }
public static int skip space ( string to parse , int idx ) { while ( be blank ( to parse . char at ( idx ) ) & & idx < to parse . length ( ) ) ++idx ; return idx ; }
public hit search ( query query , filter filter , sort sort ) throw i o exception { return new hit ( this , query , filter , sort ) ; }
public method node get method ( string name , parameter [ ] parameter ) { for ( method node method : get method ( name ) ) { if ( parameter equal ( method . get parameter ( ) , parameter ) ) { return method ; } } return null ; }
public static object from cache ( mutable call site call site , class < ? > sender , string method name , int call i d , boolean safe navigation , boolean this call , boolean spread call , object dummy receiver , object [ ] argument ) throw throwable { method handle wrapper mhw = do with call site ( call site , argument , ( c , receiver ) - > c . get and put ( receiver . get class ( ) . get name ( ) , c - > fallback ( call site , sender , method name , call i d , safe navigation , this call , spread call , dummy receiver , argument ) ) ) ; if ( mhw . be can set target ( ) & & ( call site . get target ( ) ! = mhw . get target method handle ( ) ) & & ( mhw . get late hit count ( ) > indy_optimize_threshold ) ) { call site . set target ( mhw . get target method handle ( ) ) ; if ( log_enabled ) log . info ( `` call site target set , prepare outside invocation `` ) ; mhw . reset late hit count ( ) ; } return mhw . get cached method handle ( ) . invoke exact ( argument ) ; }
public object get current version ( serializable id , share session contract implementor session ) throw hibernate exception { if ( log . be trace enable ( ) ) { log . tracev ( `` get version : { 0 } `` , message helper . info string ( this , id , get factory ( ) ) ) ; } try { prepared statement st = session . get jdbc coordinator ( ) . get statement preparer ( ) . prepare statement ( get version select string ( ) ) ; try { get identifier type ( ) . null safe set ( st , id , 1 , session ) ; result set r = session . get jdbc coordinator ( ) . get result set return ( ) . extract ( st ) ; try { if ( ! r . next ( ) ) { return null ; } if ( ! be versioned ( ) ) { return this ; } return get version type ( ) . null safe get ( r , get version column name ( ) , session , null ) ; } finally { session . get jdbc coordinator ( ) . get logical connection ( ) . get resource registry ( ) . release ( r , st ) ; } } finally { session . get jdbc coordinator ( ) . get logical connection ( ) . get resource registry ( ) . release ( st ) ; session . get jdbc coordinator ( ) . after statement execution ( ) ; } } catch ( s q l exception e ) { throw session . get jdbc service ( ) . get sql exception helper ( ) . convert ( e , `` could not retrieve version : `` + message helper . info string ( this , id , get factory ( ) ) , get version select string ( ) ) ; } }
public static lob creator builder impl make lob creator builder ( ) { log . disable contextual l o b creation since connection null ( ) ; return new lob creator builder impl ( false ) ; }
protect boolean be join fetch enable ( association type type , fetch mode config , cascade style cascade style ) { return be join fetch enable in mapping ( config , type ) ; }
public object get current version ( serializable id , share session contract implementor session ) throw hibernate exception { if ( log . be trace enable ( ) ) { log . tracev ( `` get version : { 0 } `` , message helper . info string ( this , id , get factory ( ) ) ) ; } try { prepared statement st = session . get jdbc coordinator ( ) . get statement preparer ( ) . prepare statement ( get version select string ( ) ) ; try { get identifier type ( ) . null safe set ( st , id , 1 , session ) ; result set r = session . get jdbc coordinator ( ) . get result set return ( ) . extract ( st ) ; try { if ( ! r . next ( ) ) { return null ; } if ( ! be versioned ( ) ) { return this ; } return get version type ( ) . null safe get ( r , get version column name ( ) , session , null ) ; } finally { session . get jdbc coordinator ( ) . get logical connection ( ) . get resource registry ( ) . release ( r , st ) ; } } finally { session . get jdbc coordinator ( ) . get logical connection ( ) . get resource registry ( ) . release ( st ) ; session . get jdbc coordinator ( ) . after statement execution ( ) ; } } catch ( s q l exception e ) { throw session . get jdbc service ( ) . get sql exception helper ( ) . convert ( e , `` could not retrieve version : `` + message helper . info string ( this , id , get factory ( ) ) , get version select string ( ) ) ; } }
public static iterable < attribute definition > get identifier sub attribute ( abstract entity persister entity persister ) { return get singular sub attribute ( entity persister , entity persister , ( composite type ) entity persister . get identifier type ( ) , entity persister . get table name ( ) , entity persister . get root table identifier column name ( ) ) ; }
public string find implicit property name ( annotated member member ) { return null ; }
protect boolean us static typing ( serialization config config , bean description bean desc , type serializer type ser ) { / * 16- aug-2010 , tatu : if there be a ( value ) type serializer , we can not force * static typing ; that would make it impossible to handle expect subtypes * / if ( type ser ! = null ) { return false ; } annotation introspector intr = config . get annotation introspector ( ) ; json serialize . type t = intr . find serialization typing ( bean desc . get class info ( ) ) ; if ( t ! = null & & t ! = json serialize . type . default_typing ) { return ( t == json serialize . type . static ) ; } return config . be enable ( mapper feature . use_static_typing ) ; }
public property name strategy name strategy instance ( mapper config < ? > config , annotate annotate , class < ? > impl class ) { return null ; }
public jsonb creator get creator ( class < ? > clazz ) { jsonb creator jsonb creator = null ; constructor < ? > [ ] declare constructor = access controller . do privilege ( ( privilege action < constructor < ? > [ ] > ) clazz : : get declared constructor ) ; for ( constructor < ? > constructor : declared constructor ) { final javax . json . bind . annotation . jsonb creator annot = find annotation ( constructor . get declared annotation ( ) , javax . json . bind . annotation . jsonb creator . class ) ; if ( annot ! = null ) { jsonb creator = create jsonb creator ( constructor , jsonb creator , clazz ) ; } } method [ ] declare method = access controller . do privilege ( ( privilege action < method [ ] > ) clazz : : get declare method ) ; for ( method method : declare method ) { final javax . json . bind . annotation . jsonb creator annot = find annotation ( method . get declared annotation ( ) , javax . json . bind . annotation . jsonb creator . class ) ; if ( annot ! = null & & modifier . be static ( method . get modifier ( ) ) ) { if ( ! clazz . equal ( method . get return type ( ) ) ) { throw new jsonb exception ( message . get message ( message key . incompatible_factory_creator_return_type , method , clazz ) ) ; } jsonb creator = create jsonb creator ( method , jsonb creator , clazz ) ; } } if ( jsonb creator == null ) { jsonb creator = constructor property introspector . get creator ( declared constructor ) ; } return jsonb creator ; }
public object deserialize type from object ( json parser jp , deserialization context ctxt ) throw i o exception { return _deserialize ( jp , ctxt ) ; }
public object deserialize typed from any ( json parser p , deserialization context ctxt ) throw i o exception { / * sometimes , however , we get an array wrapper ; specifically * when an array or list have be serialize with type information . * / if ( p . have token ( json token . start_array ) ) { return super . deserialize typed from array ( p , ctxt ) ; } return deserialize typed from object ( p , ctxt ) ; }
public static object default value ( class < ? > cl ) { if ( cls == integer . type ) { return integer . value of ( 0 ) ; } if ( cls == long . type ) { return long . value of ( 0l ) ; } if ( cls == boolean . type ) { return boolean . false ; } if ( cls == double . type ) { return double . value of ( 0 . 0 ) ; } if ( cls == float . type ) { return float . value of ( 0 . 0f ) ; } if ( cls == byte . type ) { return byte . value of ( ( byte ) 0 ) ; } if ( cls == short . type ) { return short . value of ( ( short ) 0 ) ; } if ( cls == character . type ) { return '\0 ' ; } throw new illegal argument exception ( `` class `` +cls . get name ( ) + `` be not a primitive type `` ) ; }
protect boolean us static typing ( serialization config config , bean description bean desc , type serializer type ser ) { / * 16- aug-2010 , tatu : if there be a ( value ) type serializer , we can not force * static typing ; that would make it impossible to handle expect subtypes * / if ( type ser ! = null ) { return false ; } annotation introspector intr = config . get annotation introspector ( ) ; json serialize . type t = intr . find serialization typing ( bean desc . get class info ( ) ) ; if ( t ! = null & & t ! = json serialize . type . default_typing ) { return ( t == json serialize . type . static ) ; } return config . be enable ( mapper feature . use_static_typing ) ; }
public container serializer < ? > with value type serializer ( type serializer vt ) { if ( vt == null ) return this ; return _with value type serializer ( vt ) ; }
public void serialize with type ( object value , json generator jgen , serializer provider provider , type serializer type ser ) throw i o exception { / * be this an erroneous call ? for now , let 's assume it be not , and * that type serializer be just overridden if so * / _serializer . serialize with type ( value , jgen , provider , type ser ) ; }
protect boolean parameter match ( type require parameter , type bean parameter ) { if ( type . be actual type ( require parameter ) & & type . be actual type ( bean parameter ) ) { / * * the required type parameter and the bean type parameter be actual type with identical raw * type , and , if the type be parameterized , the bean type parameter be assignable to the required * type parameter accord to these rule , or * / return match ( require parameter , bean parameter ) ; } if ( require parameter instanceof wildcard type & & type . be actual type ( bean parameter ) ) { / * * the required type parameter be a wildcard , the bean type parameter be an actual type and the * actual type be assignable to the upper bound , if any , of the wildcard and assignable from the * low bound , if any , of the wildcard , or * / return parameter match ( ( wildcard type ) require parameter , bean parameter ) ; } if ( require parameter instanceof wildcard type & & bean parameter instanceof type variable < ? > ) { / * * the required type parameter be a wildcard , the bean type parameter be a type variable and the * upper bound of the type variable be assignable to or assignable from the upper bound , if any , of * the wildcard and assignable from the low bound , if any , of the wildcard , or * / return parameter match ( ( wildcard type ) require parameter , ( type variable < ? > ) bean parameter ) ; } if ( type . be actual type ( require parameter ) & & bean parameter instanceof type variable < ? > ) { / * * the required type parameter be an actual type , the bean type parameter be a type variable and * the actual type be assignable to the upper bound , if any , of the type variable , or * / return parameter match ( require parameter , ( type variable < ? > ) bean parameter ) ; } if ( require parameter instanceof type variable < ? > & & bean parameter instanceof type variable < ? > ) { / * * the required type parameter and the bean type parameter be both type variable and the upper * bound of the required type parameter be assignable to the upper bound , if any , of the bean type * parameter * / return parameter match ( ( type variable < ? > ) require parameter , ( type variable < ? > ) bean parameter ) ; } return false ; }
public final serializer factory with additional serializers ( serializers additional ) { return with config ( _factory config . with additional serializers ( additional ) ) ; }
public json node read tree ( json parser jp ) throw i o exception , json processing exception { / * 02- mar-2009 , tatu : one twist ; deserialization provider * will map json null straight into java null . but what * we want to return be the `` null node `` instead . * / / * 05- aug-2011 , tatu : also , must check for eof here before * call read value ( ) , since that 'll choke on it otherwise * / deserialization config cfg = copy deserialization config ( ) ; json token t = jp . get current token ( ) ; if ( t == null ) { t = jp . next token ( ) ; if ( t == null ) { return null ; } } json node n = ( json node ) _read value ( cfg , jp , json_node_type ) ; return ( n == null ) ? get node factory ( ) . null node ( ) : n ; }
public annotation declaration add annotation declaration ( string name ) { return add annotation declaration ( name , modifier . keyword . public ) ; }
public pretty printer configuration set indent size ( int indent size ) { indentation indentation = get indentation ( ) . set size ( assert non negative ( indent size ) ) ; set indentation ( indentation ) ; return this ; }
public groovy field doc [ ] enum constant ( ) { collection . sort ( enum constant ) ; return enum constant . to array ( new groovy field doc [ enum constant . size ( ) ] ) ; }
protect type declaration < ? > find contain type decl ( node node ) { node parent = node ; while ( true ) { parent = demand parent node ( parent ) ; if ( parent instanceof type declaration ) { return ( type declaration < ? > ) parent ; } } }
protect type declaration < ? > find contain type decl ( node node ) { node parent = node ; while ( true ) { parent = demand parent node ( parent ) ; if ( parent instanceof type declaration ) { return ( type declaration < ? > ) parent ; } } }
public symbol reference < resolve type declaration > solve type in type ( resolve type declaration type declaration , string name ) { if ( type declaration instanceof java parser class declaration ) { return ( ( java parser class declaration ) type declaration ) . solve type ( name ) ; } if ( type declaration instanceof java parser interface declaration ) { return ( ( java parser interface declaration ) type declaration ) . solve type ( name ) ; } return symbol reference . unsolved ( resolve reference type declaration . class ) ; }
public void start element ( unmarshalling context . state state , tag name ea ) throw s a x exception { }
public schema tree load ( final json node schema ) { bundle . check not null ( schema , `` load cfg . null schema `` ) ; return dereferencing . new tree ( schema ) ; }
public void set cors configuration source ( cors configuration source cors configuration source ) { assert . not null ( cors configuration source , `` cors configuration source must not be null `` ) ; this . cors configuration source = cors configuration source ; }
public default repository system session set dependency selector ( dependency selector dependency selector ) { fail if read only ( ) ; this . dependency selector = dependency selector ; return this ; }
public static string for proxy ( repository system session session , remote repository repository ) { string digest = `` `` ; proxy proxy = repository . get proxy ( ) ; if ( proxy ! = null ) { authentication auth = proxy . get authentication ( ) ; if ( auth ! = null ) { authentication digest auth digest = new authentication digest ( session , repository , proxy ) ; auth . digest ( auth digest ) ; digest = auth digest . digest ( ) ; } } return digest ; }
public artifact repository get repository ( version version ) { return repository . get ( version ) ; }
public default repository system session set dependency traverser ( dependency traverser dependency traverser ) { fail if read only ( ) ; this . dependency traverser = dependency traverser ; return this ; }
public static reactive stream factory instance ( ) { if ( instance == null ) { synchronize ( reactive stream factory resolver . class ) { if ( instance ! = null ) { return instance ; } class loader cl = access controller . do privilege ( ( privilege action < class loader > ) ( ) - > thread . current thread ( ) . get context class loader ( ) ) ; if ( cl == null ) { cl = reactive stream factory . class . get class loader ( ) ; } reactive stream factory new instance = load from spi ( cl ) ; if ( new instance == null ) { throw new illegal state exception ( `` no reactive stream factory implementation find ! `` ) ; } instance = new instance ; } } return instance ; }
public channel future close ( channel channel , close web socket frame frame , channel promise promise ) { return channel . write and flush ( frame , promise ) ; }
protect full http response new handshake response ( full http request req , http header header ) { char sequence key = req . header ( ) . get ( http header name . sec_websocket_key ) ; if ( key == null ) { throw new web socket handshake exception ( `` not a web socket request : missing key `` ) ; } full http response res = new default full http response ( http_1_1 , http response status . switching_protocols , req . content ( ) . alloc ( ) . buffer ( 0 ) ) ; if ( header ! = null ) { re . header ( ) . add ( header ) ; } string accept seed = key + websocket_08_accept_guid ; byte [ ] sha1 = web socket util . sha1 ( accept seed . get byte ( charset util . us_ascii ) ) ; string accept = web socket util . base64 ( sha1 ) ; if ( logger . be debug enable ( ) ) { logger . debug ( `` web socket version 08 server handshake key : { } , response : { } `` , key , accept ) ; } res . header ( ) . add ( http header name . upgrade , http header value . websocket ) ; re . header ( ) . add ( http header name . connection , http header value . upgrade ) ; re . header ( ) . add ( http header name . sec_websocket_accept , accept ) ; string subprotocols = req . header ( ) . get ( http header name . sec_websocket_protocol ) ; if ( subprotocols ! = null ) { string select subprotocol = select subprotocol ( subprotocols ) ; if ( select subprotocol == null ) { if ( logger . be debug enable ( ) ) { logger . debug ( `` request subprotocol ( s ) not support : { } `` , subprotocols ) ; } } else { re . header ( ) . add ( http header name . sec_websocket_protocol , select subprotocol ) ; } } return re ; }
public final internal thread local map thread local map ( ) { return thread local map ; }
public void debug ( string format , object arg ) { if ( logger . be loggable ( level . fine ) ) { format tuple ft = message formatter . format ( format , arg ) ; log ( self , level . fine , ft . get message ( ) , ft . get throwable ( ) ) ; } }
public void debug ( string msg ) { if ( logger . be loggable ( level . fine ) ) { log ( self , level . fine , msg , null ) ; } }
public void info ( string msg , throwable t ) { if ( logger . be loggable ( level . info ) ) { log ( self , level . info , msg , t ) ; } }
public void trace ( string format , object arg a , object arg b ) { if ( be trace enable ( ) ) { format tuple ft = message formatter . format ( format , arg a , arg b ) ; logger . log ( fqcn , trace capable ? level . trace : level . debug , ft . get message ( ) , ft . get throwable ( ) ) ; } }
public void debug ( string format , object arg ) { if ( logger . be debug enable ( ) ) { format tuple ft = message formatter . format ( format , arg ) ; logger . log ( fqcn , level . debug , ft . get message ( ) , ft . get throwable ( ) ) ; } }
public void error ( string msg ) { if ( logger . be loggable ( level . severe ) ) { log ( self , level . severe , msg , null ) ; } }
public static < t > t [ ] add to array ( t [ ] array , t item , class < ? > type ) { if ( array == null ) { if ( type == null & & item ! = null ) type = item . get class ( ) ; @ suppress warning ( `` unchecked `` ) t [ ] na = ( t [ ] ) array . new instance ( type , 1 ) ; na [ 0 ] = item ; return na ; } else { t [ ] na = array . copy of ( array , array . length + 1 ) ; na [ array . length ] = item ; return na ; } }
public static int int value ( integer wrapper , int default value ) { return wrapper ! = null ? wrapper : default value ; }
public void set alignment ( int alignment ) { if ( ( alignment & ( alignment - 1 ) ) ! = 0 || alignment > 0xffff ) { throw new illegal argument exception ( `` invalid value for alignment , must be power of two and no big than `` + 0xffff + `` but be `` + alignment ) ; } this . alignment = alignment ; }
public e next ( ) throw no such element exception { if ( have next ( ) == false ) { throw new no such element exception ( ) ; } final int least index = least ( ) ; if ( least index == -1 ) { throw new no such element exception ( ) ; } final e val = value . get ( least index ) ; clear ( least index ) ; last return = least index ; return val ; }
public final void remove ( internal thread local map thread local map ) { if ( thread local map == null ) { return ; } object v = thread local map . remove indexed variable ( index ) ; remove from variable to remove ( thread local map , this ) ; if ( v ! = internal thread local map . unset ) { try { on removal ( ( v ) v ) ; } catch ( exception e ) { platform dependent . throw exception ( e ) ; } } }
public long ticket key resume ( ) { lock reader lock = context . ctx lock . read lock ( ) ; reader lock . lock ( ) ; try { return s s l context . session ticket key resume ( context . ctx ) ; } finally { reader lock . unlock ( ) ; } }
public ssl context builder trust manager ( input stream trust cert collection input stream ) { try { return trust manager ( ssl context . to x509 certificate ( trust cert collection input stream ) ) ; } catch ( exception e ) { throw new illegal argument exception ( `` input stream do not contain valid certificate . `` , e ) ; } }
public final void set close notify read timeout ( long close notify read timeout , time unit unit ) { set close notify read timeout millis ( unit . to millis ( close notify read timeout ) ) ; }
public long get current edit offset ( ) { return current edit offset ; }
public void set ticket key ( byte [ ] key ) { if ( key . length % session ticket key . ticket_key_size ! = 0 ) { throw new illegal argument exception ( `` key . length % `` + session ticket key . ticket_key_size + `` ! = 0 `` ) ; } session ticket key [ ] ticket = new session ticket key [ key . length / session ticket key . ticket_key_size ] ; for ( int i = 0 , a = 0 ; i < ticket . length ; i++ ) { byte [ ] name = array . copy of range ( key , a , session ticket key . name_size ) ; a += session ticket key . name_size ; byte [ ] hmac key = array . copy of range ( key , a , session ticket key . hmac_key_size ) ; i += session ticket key . hmac_key_size ; byte [ ] aes key = array . copy of range ( key , a , session ticket key . aes_key_size ) ; a += session ticket key . aes_key_size ; ticket [ i ] = new session ticket key ( name , hmac key , aes key ) ; } lock writer lock = context . ctx lock . write lock ( ) ; writer lock . lock ( ) ; try { s s l context . clear option ( context . ctx , ssl . ssl_op_no_ticket ) ; s s l context . set session ticket key ( context . ctx , ticket ) ; } finally { writer lock . unlock ( ) ; } }
public final void copy to ( abstract coalesce buffer queue dest ) { d . buf and listener pair . add all ( buf and listener pair ) ; d . increment readable byte ( readable byte ) ; }
public static string clean ( string charset name ) { try { return for name ( charset name ) . name ( ) ; } catch ( exception e ) { return null ; } }
public static synchronize boolean be bouncy castle register ( ) { register ( ) ; return bouncy_castle . equal ( security provider ) || spongy_castle . equal ( security provider ) ; }
protect a w s credential sanitize credential ( a w s credential credential ) { string access key id = null ; string secret key = null ; string token = null ; synchronize ( credential ) { access key id = credential . get a w s access key id ( ) ; secret key = credential . get a w s secret key ( ) ; if ( credential instanceof a w s session credential ) { token = ( ( a w s session credential ) credential ) . get session token ( ) ; } } if ( secret key ! = null ) secret key = secret key . trim ( ) ; if ( access key id ! = null ) access key id = access key id . trim ( ) ; if ( token ! = null ) token = token . trim ( ) ; if ( credential instanceof a w s session credential ) { return new basic session credential ( access key id , secret key , token ) ; } return new basic a w s credential ( access key id , secret key ) ; }
public void set authorization j w s algs ( final list < j w s algorithm > authz j w s algs ) { this . authz j w s algs = authz j w s algs ; }
public static boolean be support ( final j w e algorithm alg ) { for ( provider p : security . get provider ( ) ) { if ( be support ( alg , p ) ) { return true ; } } return false ; }
public static boolean be support ( final j w e algorithm alg ) { for ( provider p : security . get provider ( ) ) { if ( be support ( alg , p ) ) { return true ; } } return false ; }
public provider get content encryption provider ( ) { return ce provider ! = null ? ce provider : get provider ( ) ; }
public byte [ ] get encrypt spill key ( ) { return encrypt spill key ; }
public string get t l s client auth san u r i ( ) { return tl client auth san u r i ; }
public base64 u r l get parse base64 u r l ( ) { return parse base64 u r l ; }
public int get min key size ( ) { return min size bit ; }
public list < jwk > get key ( ) { return key ; }
public void set subject j w k ( final jwk sub j w k ) { if ( sub j w k ! = null ) { if ( sub j w k . be private ( ) ) throw new illegal argument exception ( `` the subject 's json web key ( jwk ) must be public `` ) ; set claim ( sub_jwk_claim_name , new j s o n object ( sub j w k . to j s o n object ( ) ) ) ; } else { set claim ( sub_jwk_claim_name , null ) ; } }
public string normalize identifier quote a string ( string identifier text ) { final identifier identifier = normalize identifier quote ( identifier text ) ; if ( identifier == null ) { return null ; } return identifier . render ( database ( ) . get dialect ( ) ) ; }
public base64 u r l get first factor c r t exponent ( ) { return dp ; }
public base64 u r l get first factor c r t exponent ( ) { return dp ; }
public byte [ ] to byte array ( ) { return get key value ( ) . decode ( ) ; }
public static value date time to value ( value original , long date value , long time nanos , boolean force timestamp ) { if ( ! ( original instanceof value timestamp ) ) { if ( ! force timestamp ) { if ( original instanceof value date ) { return value date . from date value ( date value ) ; } if ( original instanceof value time ) { return value time . from nanos ( time nanos ) ; } } if ( original instanceof value timestamp time zone ) { return value timestamp time zone . from date value and nanos ( date value , time nanos , ( ( value timestamp time zone ) original ) . get time zone offset min ( ) ) ; } } return value timestamp . from date value and nanos ( date value , time nanos ) ; }
public static base64 u r l encode ( final string text ) { return encode ( text . get byte ( standard charset . utf_8 ) ) ; }
public static base64 encode ( final big integer big int ) { return encode ( big integer utils . to byte unsigned ( big int ) ) ; }
public secret key get secret key ( ) { return new secret key spec ( secret , `` mac `` ) ; }
static public void append escape c d a t a ( final string buffer buf , final string str ) { if ( str ! = null ) { int end = str . index of ( cdata_end ) ; if ( end < 0 ) { buf . append ( str ) ; } else { int start = 0 ; while ( end > -1 ) { buf . append ( str . substring ( start , end ) ) ; buf . append ( cdata_embeded_end ) ; start = end + cdata_end_len ; if ( start < str . length ( ) ) { end = str . index of ( cdata_end , start ) ; } else { return ; } } buf . append ( str . substring ( start ) ) ; } } }
public static x509 certificate confirmation of ( final x509 certificate x509 cert ) { return new x509 certificate confirmation ( x509 cert utils . compute s h a256 thumbprint ( x509 cert ) ) ; }
public j w t authentication claim set get j w t authentication claim set ( ) { return jwt auth claim set ; }
public void set token endpoint auth method ( final list < client authentication method > auth method ) { this . token endpoint auth method = auth method ; }
public jwtid get j w t i d ( ) { identifier id = get i d ( ) ; return id ! = null ? new jwtid ( id . get value ( ) ) : null ; }
public final void set subject ( final formatter format ) { check access ( ) ; if ( format == null ) { throw new null pointer exception ( ) ; } synchronize ( this ) { if ( be write ) { throw new illegal state exception ( ) ; } this . subject formatter = format ; } }
public string get client x509 certificate subject d n ( ) { return client x509 certificate subject d n ; }
public static < t > iterator < t > array ( final t [ ] o ) { return new iterator < t > ( ) { int i = 0 ; int len = ( o == null ) ? 0 : o . length ; public boolean have next ( ) { return i < len ; } public t next ( ) { if ( i < len ) { return o [ i++ ] ; } else { throw new no such element exception ( ) ; } } public void remove ( ) { throw new unsupported operation exception ( ) ; } } ; }
public j s o n object to j s o n object ( ) { j s o n object json object = new j s o n object ( ) ; map . entry < string , j s o n object > cnf claim = to j w t claim ( ) ; json object . put ( cnf claim . get key ( ) , cnf claim . get value ( ) ) ; return json object ; }
public o auth flow get authorization code ( ) { return authorization code ; }
public static set < bearer token error > get standard error ( ) { set < bearer token error > std error = new hash set < > ( ) ; std error . add ( bearer token error . missing_token ) ; std error . add ( bearer token error . invalid_request ) ; std error . add ( bearer token error . invalid_token ) ; std error . add ( bearer token error . insufficient_scope ) ; return collection . unmodifiable set ( std error ) ; }
public j w t claim set to j w t claim set ( ) { if ( be sign ( ) ) { throw new illegal state exception ( ) ; } return j w t claim set utils . to j w t claim set ( to parameter ( ) ) ; }
public document issuer get issuer ( ) { return issuer ; }
public bearer access token get registration access token ( ) { return access token ; }
public static string bind ( string message ) { return bind ( message , null ) ; }
public c i b a error delivery to error delivery ( ) { return ( c i b a error delivery ) this ; }
public o i d c token to o i d c token ( ) { return ( o i d c token ) this ; }
public client metadata get client metadata ( ) { return metadata ; }
public uri get redirection u r i ( ) { if ( redirect u r be ! = null & & ! redirect u r be . be empty ( ) ) { return redirect u r be . iterator ( ) . next ( ) ; } else { return null ; } }
public void set logo u r i ( final uri logo u r i ) { logo u r i entry . put ( null , logo u r i ) ; }
public void set term of service u r i ( final uri tos u r i ) { u r i utils . ensure scheme be h t t p sor h t t p ( tos u r i ) ; this . tos u r i = tos u r i ; }
public void set request object j w s alg ( final j w s algorithm request object j w s alg ) { this . request object j w s alg = request object j w s alg ; }
public j w e algorithm get request object j w e alg ( ) { return request object j w e alg ; }
public void set software statement ( final sign j w t software statement ) { if ( software statement ! = null & & software statement . get state ( ) . equal ( j w s object . state . unsigned ) ) { throw new illegal argument exception ( `` the software statement must be sign `` ) ; } this . software statement = software statement ; }
public software version get software version ( ) { return software version ; }
public void set authorization j w e alg ( final j w e algorithm authz j w e alg ) { this . authz j w e alg = authz j w e alg ; }
public void set back channel token delivery mode ( final back channel token delivery mode back channel token delivery mode ) { this . back channel token delivery mode = back channel token delivery mode ; }
public void apply default ( ) { if ( rms == null ) { rms = new array list < > ( 2 ) ; rms . add ( response mode . query ) ; rms . add ( response mode . fragment ) ; } if ( gts == null ) { gts = new array list < > ( 2 ) ; gts . add ( grant type . authorization_code ) ; gts . add ( grant type . implicit ) ; } if ( token endpoint auth method == null ) { token endpoint auth method = new array list < > ( ) ; token endpoint auth method . add ( client authentication method . client_secret_basic ) ; } }
public uri get verification u r i complete ( ) { return verification u r i complete ; }
public j s o n object to j s o n object ( ) { j s o n object json object = new j s o n object ( ) ; map . entry < string , j s o n object > cnf claim = to j w t claim ( ) ; json object . put ( cnf claim . get key ( ) , cnf claim . get value ( ) ) ; return json object ; }
public static int get small instruction cache line size ( ) { int min size = integer . max_value ; for ( cache level info cache level : cache level ) { if ( cache level . get cache type ( ) . be instruction ( ) ) { final int cache line size = cache level . get cache line size ( ) ; if ( cache line size ! = 0 & & cache line size < min size ) { min size = cache line size ; } } } return min size == integer . max_value ? 0 : min size ; }
public boolean cancel timer ( long id ) { boolean ret = delegate . cancel timer ( id ) ; return ret ; }
public error object get error object ( ) { return error object ; }
public string get url fragment ( ) { return url fragment ; }
public void add fragment ( xml fragment fragment ) { assert not null ( fragment ) ; fragment . add ( fragment ) ; fragment . set parent ( this ) ; }
public void set client x509 certificate ( final x509 certificate client x509 certificate ) { this . client x509 certificate = client x509 certificate ; }
public static list < string > to string list ( final collection < uri > uri list , final boolean ignore null ) { if ( uri list == null ) { return null ; } if ( uri list . be empty ( ) ) { return collection . empty list ( ) ; } list < string > out = new link list < > ( ) ; for ( uri uri : uri list ) { if ( uri ! = null ) { out . add ( uri . to string ( ) ) ; } else if ( ! ignore null ) { out . add ( null ) ; } } return out ; }
public j s o n object to j s o n object ( ) { return to j s o n object ( false ) ; }
public response mode imply response mode ( ) { return response mode . resolve ( rm , rt ) ; }
public void set refresh token ( string refresh token ) { this . refresh token = refresh token ; }
public class realm get class realm ( ) { return realm ; }
public list < audience > to single audience list ( ) { list < audience > audience list = new array list < > ( 1 ) ; audience list . add ( this ) ; return audience list ; }
public authorization grant get authorization grant ( ) { return authz grant ; }
public token introspection success response to success response ( ) { return ( token introspection success response ) this ; }
public authorization grant get authorization grant ( ) { return authz grant ; }
public day to standard day ( ) { long day = get standard day ( ) ; return day . day ( field utils . safe to int ( day ) ) ; }
public static uri strip query string ( final uri uri ) { if ( uri == null ) return null ; try { return new uri ( uri . get scheme ( ) , null , uri . get host ( ) , uri . get port ( ) , uri . get path ( ) , null , uri . get fragment ( ) ) ; } catch ( u r i syntax exception e ) { return null ; } }
public country code get country ( ) { string code = get string claim ( country_claim_name ) ; if ( code == null ) { return null ; } try { return country code . parse ( code ) ; } catch ( parse exception e ) { return null ; } }
public i s o3166_1 alpha2 country code to i s o3166_1 alpha2 country code ( ) { return ( i s o3166_1 alpha2 country code ) this ; }
public static i s o3166_1 alpha3 country code to alpha3 country code ( final i s o3166_1 alpha2 country code alpha2 code ) { lazy load map_2_3 ( ) ; string alpha3 code = map_2_3 . get property ( alpha2 code . get value ( ) ) ; return alpha3 code ! = null ? new i s o3166_1 alpha3 country code ( alpha3 code ) : null ; }
public @ nullable string get attachment type ( ) { return attachment type ; }
public boolean be embed message ( ) { return ( attachment directory ! = null ) ; }
public static string clean content type ( mime part mp , string content type ) { if ( clean content type ! = null ) { try { return ( string ) clean content type . invoke ( null , new object [ ] { mp , content type } ) ; } catch ( exception ex ) { return content type ; } } else return content type ; }
public vouch evidence to vouch evidence ( ) { return ( vouch evidence ) this ; }
public date with time zone offset get creation time ( ) { return create at ; }
public type signature get type signature ( ) { return type signature ; }
public document issuer get issuer ( ) { return issuer ; }
public j s o n object to j s o n object ( ) { j s o n object o = new j s o n object ( ) ; o . put ( `` type `` , get type ( ) . get value ( ) ) ; if ( get document number ( ) ! = null ) { o . put ( `` document_number `` , get document number ( ) . get value ( ) ) ; } if ( get personal number ( ) ! = null ) { o . put ( `` personal_number `` , get personal number ( ) . get value ( ) ) ; } if ( get serial number ( ) ! = null ) { o . put ( `` serial_number `` , get serial number ( ) . get value ( ) ) ; } if ( get date of issuance ( ) ! = null ) { o . put ( `` date_of_issuance `` , get date of issuance ( ) . to i s o8601 string ( ) ) ; } if ( get date of expiry ( ) ! = null ) { o . put ( `` date_of_expiry `` , get date of expiry ( ) . to i s o8601 string ( ) ) ; } if ( get issuer ( ) ! = null ) { j s o n object issuer object = get issuer ( ) . to j s o n object ( ) ; if ( ! issuer object . be empty ( ) ) { o . put ( `` issuer `` , issuer object ) ; } } return o ; }
public j s o n object to j s o n object ( ) { j s o n object o = new j s o n object ( ) ; if ( get name ( ) ! = null ) { o . put ( `` name `` , get name ( ) . get value ( ) ) ; } if ( get birthdate string ( ) ! = null ) { o . put ( `` birthdate `` , get birthdate string ( ) ) ; } if ( get address ( ) ! = null ) { o . put all ( get address ( ) . to j s o n object ( ) ) ; } if ( get occupation ( ) ! = null ) { o . put ( `` occupation `` , get occupation ( ) . get value ( ) ) ; } if ( get organization ( ) ! = null ) { o . put ( `` organization `` , get organization ( ) . get value ( ) ) ; } return o ; }
public void set identity trust framework ( final list < identity trust framework > trust framework ) { this . trust framework = trust framework ; }
public identity assurance level get assurance level ( ) { return assurance level ; }
public void set u r i claim ( final string name , final uri value ) { if ( value ! = null ) set claim ( name , value . to string ( ) ) ; else claim . remove ( name ) ; }
public void set claim ( final string name , final object value , final lang tag lang tag ) { string key name = lang tag ! = null ? name + `` # `` + lang tag : name ; set claim ( key name , value ) ; }
public void set u r i claim ( final string name , final uri value ) { if ( value ! = null ) set claim ( name , value . to string ( ) ) ; else claim . remove ( name ) ; }
public j s o n object to j s o n object ( ) { j s o n object json object = new j s o n object ( ) ; map . entry < string , j s o n object > cnf claim = to j w t claim ( ) ; json object . put ( cnf claim . get key ( ) , cnf claim . get value ( ) ) ; return json object ; }
public void set authentication time ( final date auth time ) { set date claim ( auth_time_claim_name , auth time ) ; }
public json pointer append ( final string raw ) { final reference token ref token = reference token . from raw ( raw ) ; final json node resolver resolver = new json node resolver ( ref token ) ; final list < token resolver < json node > > list = list . new array list ( token resolvers ) ; list . add ( resolver ) ; return new json pointer ( list ) ; }
public void set verify claim ( final list < verify claim set > verify claim list ) { if ( verified claim list ! = null ) { list < j s o n object > json object = new link list < > ( ) ; for ( verified claim set verified claim : verify claim list ) { if ( verified claim ! = null ) { json object . add ( verified claim . to j s o n object ( ) ) ; } } set claim ( verified_claims_claim_name , json object ) ; } else { set claim ( verified_claims_claim_name , null ) ; } }
public void set birth family name ( final string birth family name ) { set claim ( birth_family_name_claim_name , birth family name ) ; }
public list < country code > get nationality ( ) { list < string > value = get string list claim ( nationalities_claim_name ) ; if ( value == null ) { return null ; } list < country code > cod = new link list < > ( ) ; for ( string v : value ) { if ( v ! = null ) { try { code . add ( country code . parse ( v ) ) ; } catch ( parse exception e ) { return null ; } } } return code ; }
public void set birth middle name ( final string birth middle name ) { set claim ( birth_middle_name_claim_name , birth middle name ) ; }
public entry remove user info claim ( final string claim name , final lang tag lang tag ) { return user info claim . remove ( to key ( claim name , lang tag ) ) ; }
public entry remove verify user info claim ( final string claim name , final lang tag lang tag ) { return verify user info claim . remove ( to key ( claim name , lang tag ) ) ; }
public j s o n object to j s o n object ( ) { j s o n object json object = new j s o n object ( ) ; map . entry < string , j s o n object > cnf claim = to j w t claim ( ) ; json object . put ( cnf claim . get key ( ) , cnf claim . get value ( ) ) ; return json object ; }
public void set subject j w k ( final jwk sub j w k ) { if ( sub j w k ! = null ) { if ( sub j w k . be private ( ) ) throw new illegal argument exception ( `` the subject 's json web key ( jwk ) must be public `` ) ; set claim ( sub_jwk_claim_name , new j s o n object ( sub j w k . to j s o n object ( ) ) ) ; } else { set claim ( sub_jwk_claim_name , null ) ; } }
public void set o auth client metadata ( final client metadata client metadata ) { j s o n object o = client metadata ! = null ? client metadata . to j s o n object ( ) : null ; set metadata ( federation metadata type . oauth_client , o ) ; }
public o i d c client metadata get r p metadata ( ) { j s o n object o = get metadata ( federation metadata type . openid_relying_party ) ; if ( o == null ) { return null ; } try { return o i d c client metadata . parse ( o ) ; } catch ( com . nimbusds . oauth2 . sdk . parse exception e ) { return null ; } }
public void set metadata policy j s o n object ( final j s o n object metadata policy ) { set claim ( metadata_policy_claim_name , metadata policy ) ; }
public void set federation registration endpoint u r i ( final uri federation registration endpoint ) { this . federation registration endpoint = federation registration endpoint ; }
public j s o n object to j s o n object ( ) { j s o n object o = new j s o n object ( ) ; o . put ( `` trust_framework `` , get trust framework ( ) . get value ( ) ) ; if ( get assurance level ( ) ! = null ) { o . put ( `` assurance_level `` , get assurance level ( ) . get value ( ) ) ; } if ( get assurance process ( ) ! = null ) { o . put ( `` assurance_process `` , get assurance process ( ) . to j s o n object ( ) ) ; } if ( get verification time ( ) ! = null ) { o . put ( `` time `` , get verification time ( ) . to i s o8601 string ( ) ) ; } if ( get verification process ( ) ! = null ) { o . put ( `` verification_process `` , get verification process ( ) . get value ( ) ) ; } if ( get evidence ( ) ! = null ) { j s o n array evidence array = new j s o n array ( ) ; for ( identity evidence ev : get evidence ( ) ) { if ( ev ! = null ) { evidence array . add ( ev . to j s o n object ( ) ) ; } } if ( ! evidence array . be empty ( ) ) { o . put ( `` evidence `` , evidence array ) ; } } return o ; }
public metadata policy entry get entry ( final string parameter name ) { list < policy operation > policy operation = entry . get ( parameter name ) ; if ( policy operation == null ) { return null ; } return new metadata policy entry ( parameter name , policy operation ) ; }
public metadata policy entry get entry ( final string parameter name ) { list < policy operation > policy operation = entry . get ( parameter name ) ; if ( policy operation == null ) { return null ; } return new metadata policy entry ( parameter name , policy operation ) ; }
public entity statement retriever get entity statement retriever ( ) { return statement retriever ; }
public int get max length ( ) { return max length ; }
public trust chain set filter ( final trust chain constraint constraint ) { trust chain set permit = new trust chain set ( ) ; for ( trust chain chain : this ) { if ( constraint . get max path length ( ) < 0 || chain . length ( ) -1 < = constraint . get max path length ( ) ) { boolean find non permitted = false ; for ( entity statement stmt : chain . get superior statement ( ) ) { if ( ! constraint . be permit ( stmt . get claim set ( ) . get issuer entity i d ( ) ) ) { find non permitted = true ; break ; } } if ( ! find non permit ) { permit . add ( chain ) ; } } } return permit ; }
public static claim request resolve ( final response type response type , final scope scope ) { return resolve ( response type , scope , collection . < scope . value , set < string > > empty map ( ) ) ; }
public void set authorization j w e encs ( final list < encryption method > authz j w e encs ) { this . authz j w e encs = authz j w e encs ; }
public void set document method ( final list < identity verification method > method ) { this . document method = method ; }
public electronic record evidence to electronic record evidence ( ) { return ( electronic record evidence ) this ; }
public void set default max age ( final int default max age ) { this . default max age = default max age ; }
public uri get back channel logout u r i ( ) { return back channel logout u r i ; }
public entity list success response to success response ( ) { return ( entity list success response ) this ; }
public client i d get client i d ( ) { return expect client i d ; }
public jwt consumer builder set expect issuer ( boolean require issuer , string expect issuer ) { iss validator = new iss validator ( expect issuer , require issuer ) ; return this ; }
public http url base url ( ) { return base url ; }
protect boolean be remote host ( string target url ) { if ( object utils . be empty ( this . host ) ) { return false ; } string target host = uri component builder . from uri string ( target url ) . build ( ) . get host ( ) ; if ( ! string utils . have length ( target host ) ) { return false ; } for ( string host : this . host ) { if ( target host . equal ( host ) ) { return false ; } } return true ; }
public synchronize int get idle connection count ( ) { int total = 0 ; for ( real connection connection : connection ) { if ( connection . allocation . be empty ( ) ) total++ ; } return total ; }
public static string encode basic auth ( string username , string password , @ nullable charset charset ) { assert . not null ( username , `` username must not be null `` ) ; assert . do not contain ( username , `` : `` , `` username must not contain a colon `` ) ; assert . not null ( password , `` password must not be null `` ) ; if ( charset == null ) { charset = standard charsets . iso_8859_1 ; } charset encoder encoder = charset . new encoder ( ) ; if ( ! encoder . can encode ( username ) || ! encoder . can encode ( password ) ) { throw new illegal argument exception ( `` username or password contain character that can not be encode to `` + charset . display name ( ) ) ; } string credential string = username + `` : `` + password ; byte [ ] encode byte = base64 . get encoder ( ) . encode ( credential string . get byte ( charset ) ) ; return new string ( encoded byte , charset ) ; }
public long max size ( ) { return cache . get max size ( ) ; }
public void set max upload size ( long max upload size ) { this . file upload . set size max ( max upload size ) ; }
public rule error code get error code ( ) { return this . error code ; }
public void write request ( header header , string request line ) throw i o exception { if ( state ! = state_idle ) throw new illegal state exception ( `` state : `` + state ) ; sink . write utf8 ( request line ) . write utf8 ( `` \r\n `` ) ; for ( int i = 0 , size = header . size ( ) ; i < size ; i ++ ) { sink . write utf8 ( header . name ( i ) ) . write utf8 ( `` : `` ) . write utf8 ( header . value ( i ) ) . write utf8 ( `` \r\n `` ) ; } sink . write utf8 ( `` \r\n `` ) ; state = state_open_request_body ; }
public static boolean safe equal ( object a , object b ) { if ( a == b ) return true ; if ( a == null ) return false ; if ( b == null ) return false ; return a . equal ( b ) ; }
public void on retry ( r result , throwable failure ) { }
public static byte [ ] get byte unchecked ( final string string , final string charset name ) { if ( string == null ) { return null ; } try { return string . get byte ( charset name ) ; } catch ( final unsupported encode exception e ) { throw string utils . new illegal state exception ( charset name , e ) ; } }
public proxy set ssl proxy ( string ssl proxy ) { verify proxy type compatibility ( proxy type . manual ) ; this . proxy type = proxy type . manual ; this . ssl proxy = ssl proxy ; return this ; }
public list < protocol > get protocol ( ) { return protocol ; }
public static cooky cooky ( cookie cookie , cookie . . . additional cooky ) { assert parameter . not null ( cookie , `` cookie `` ) ; final list < cookie > cookie list = new link list < cookie > ( ) ; cookie list . add ( cookie ) ; collection . add all ( cookie list , additional cooky ) ; return new cooky ( cookie list ) ; }
public int size ( ) { return decode mutation . size ( ) + encode mutation . size ( ) ; }
public void check close ( ) { if ( be close ( ) ) { throw db exception . get ( error code . connection_broken_1 , `` session close `` ) ; } }
public void secure connect end ( call call , @ nullable handshake handshake ) { }
public void response header start ( call call ) { }
protect void start article ( ) throw i o exception { start article ( true ) ; }
public time value get ping interval ( ) { return ping interval ; }
public string get scheme ( ) { return scheme ; }
public string get password ( ) { if ( password == null ) { return ssl . default_keystore_password ; } return password ; }
public int get connect timeout millis ( ) { return connect timeout millis ; }
public time value get ping interval ( ) { return ping interval ; }
public static hash function hmac sha512 ( key key ) { return new mac hash function ( `` hmac s h a512 `` , key , hmac to string ( `` hmac sha512 `` , key ) ) ; }
@ override public object [ ] to array ( ) { return snapshot ( ) . to array ( ) ; }
public byte [ ] get s h a256 ( ) { if ( value == null ) { return null ; } try { message digest sha256 = message digest . get instance ( `` sha-256 `` ) ; return sha256 . digest ( value ) ; } catch ( no such algorithm exception e ) { throw new runtime exception ( e ) ; } }
public static hash function hmac sha512 ( key key ) { return new mac hash function ( `` hmac s h a512 `` , key , hmac to string ( `` hmac sha512 `` , key ) ) ; }
public long get size ( ) { if ( size > = 0 ) { return size ; } else if ( cached content ! = null ) { return cache content . length ; } else if ( dfos . be in memory ( ) ) { return dfos . get data ( ) . length ; } else { return dfos . get file ( ) . length ( ) ; } }
public timeout clear deadline ( ) { this . have deadline = false ; return this ; }
public byte [ ] get m d5 ( ) { if ( md5 == null ) try { md5 = message digest . get instance ( `` md5 `` ) . digest ( this . to string ( ) . get byte ( `` utf-8 `` ) ) ; } catch ( exception e ) { throw new avro runtime exception ( e ) ; } return md5 ; }
public document rewrite session type get session type ( ) { return f session type ; }
public boolean be version2 ( ) { return have parameter ( `` openid . n `` ) & & openid2_ns . equal ( get parameter value ( `` openid . n `` ) ) ; }
public string get public key i d ( ) { return this . public key i d ; }
public d h parameter spec get d h params ( ) { return _dh params ; }
public association session type get min assoc sess enc ( ) { return _min assoc sess enc ; }
public void set pref assoc sess enc ( association session type pref assoc sess enc ) { this . _pref assoc sess enc = pref assoc sess enc ; }
public boolean be immediate auth ( ) { return _immediate auth ; }
public void set content type ( string content type ) { this . _content type = content type ; }
public string encode redirect u r l ( string url ) { if ( be encodeable ( to absolute ( url ) ) ) { return to encode ( url , request . get session internal ( ) . get id internal ( ) ) ; } else { return url ; } }
public string get dh public key ( ) { return get parameter value ( `` openid . dh_consumer_public `` ) ; }
public string get dh public key ( ) { return get parameter value ( `` openid . dh_consumer_public `` ) ; }
public secret key get secret key ( ) { return new secret key spec ( secret , `` mac `` ) ; }
public void set sign extension ( string [ ] extension ) { if ( extension ! = null ) { _sign extension = new array list ( arrays . a list ( extension ) ) ; build sign list ( ) ; } }
public string get update url ( ) { return _parameters . have parameter ( `` policy_url `` ) ? _parameters . get parameter value ( `` policy_url `` ) : null ; }
public message extension get extension ( string type uri ) throw message exception { if ( ! _extesion . contains key ( type uri ) ) { if ( have extension factory ( type uri ) ) { message extension factory extension factory = get extension factory ( type uri ) ; string mode = get parameter value ( `` openid . mode `` ) ; message extension extension = extension factory . get extension ( get extension params ( type uri ) , mode . start with ( `` checkid_ `` ) ) ; if ( this instanceof auth success & & extension . sign require ( ) ) { list sign params = arrays . a list ( ( ( auth success ) this ) . get sign list ( ) . split ( `` , `` ) ) ; string alias = get extension alias ( type uri ) ; if ( have parameter ( `` openid . n `` ) & & ! sign params . contains ( `` ns . `` + alias ) ) throw new message exception ( `` namespace declaration for extension `` + type uri + `` must be sign `` ) ; iterator iter = extension . get parameter ( ) . get parameter ( ) . iterator ( ) ; while ( iter . have next ( ) ) { parameter param = ( parameter ) iter . next ( ) ; if ( ! sign params . contains ( alias + `` . `` + param . get key ( ) ) ) { throw new message exception ( `` extension `` + type uri + `` must be sign ; `` + `` field `` + param . get key ( ) + `` be not sign . `` ) ; } } } _extesion . put ( type uri , extension ) ; } else throw new message exception ( `` can not instantiate extension : `` + type uri ) ; } if ( debug ) _log . debug ( `` extract `` + type uri + `` extension from message . . . `` ) ; return ( message extension ) _extesion . get ( type uri ) ; }
public message extension get extension ( string type uri ) throw message exception { if ( ! _extesion . contains key ( type uri ) ) { if ( have extension factory ( type uri ) ) { message extension factory extension factory = get extension factory ( type uri ) ; string mode = get parameter value ( `` openid . mode `` ) ; message extension extension = extension factory . get extension ( get extension params ( type uri ) , mode . start with ( `` checkid_ `` ) ) ; if ( this instanceof auth success & & extension . sign require ( ) ) { list sign params = arrays . a list ( ( ( auth success ) this ) . get sign list ( ) . split ( `` , `` ) ) ; string alias = get extension alias ( type uri ) ; if ( have parameter ( `` openid . n `` ) & & ! sign params . contains ( `` ns . `` + alias ) ) throw new message exception ( `` namespace declaration for extension `` + type uri + `` must be sign `` ) ; iterator iter = extension . get parameter ( ) . get parameter ( ) . iterator ( ) ; while ( iter . have next ( ) ) { parameter param = ( parameter ) iter . next ( ) ; if ( ! sign params . contains ( alias + `` . `` + param . get key ( ) ) ) { throw new message exception ( `` extension `` + type uri + `` must be sign ; `` + `` field `` + param . get key ( ) + `` be not sign . `` ) ; } } } _extesion . put ( type uri , extension ) ; } else throw new message exception ( `` can not instantiate extension : `` + type uri ) ; } if ( debug ) _log . debug ( `` extract `` + type uri + `` extension from message . . . `` ) ; return ( message extension ) _extesion . get ( type uri ) ; }
public string get update url ( ) { return _parameters . have parameter ( `` policy_url `` ) ? _parameters . get parameter value ( `` policy_url `` ) : null ; }
public boolean be throwable match ( throwable ite ) { string message reg exp = get reg exp ( ) ; if ( default_regexp . equal ( message reg exp ) ) { return true ; } final string message = ite . get message ( ) ; return message ! = null & & pattern . compile ( message reg exp , pattern . dotall ) . matcher ( message ) . match ( ) ; }
public uri uri ( ) { return uri ; }
public void set sign field ( string sign field ) { this . _sign field = sign field ; }
public deployment option set multi thread ( boolean multi thread ) { this . multi thread = multi thread ; return this ; }
public boolean be failure on field ( ) { return ! _field failure . be empty ( ) ; }
public void set use identity hash code ( boolean use identity hash code ) { super . set use identity hash code ( use identity hash code ) ; }
public static name provider get name provider ( ) { return c name provider ; }
public o auth2 login configurer < b > token endpoint ( customizer < token endpoint config > token endpoint customizer ) { token endpoint customizer . customize ( this . token endpoint config ) ; return this ; }
public final void remove category listener ( final i category listener category listener ) { if ( category listener == null ) { throw new null pointer exception ( ) ; } if ( category listener ! = null ) { category listener . remove ( category listener ) ; } }
public final int compare to ( final object object ) { final parameter type cast object = ( parameter type ) object ; int compare to = util . compare ( define , cast object . define ) ; if ( compare to == 0 ) { compare to = util . compare ( id , casted object . id ) ; } return compare to ; }
public category [ ] get define category ( ) { final category [ ] category = new category [ define category id . size ( ) ] ; final iterator < string > category id itr = define category id . iterator ( ) ; int i = 0 ; while ( category id itr . have next ( ) ) { string category id = category id itr . next ( ) ; category [ i++ ] = get category ( category id ) ; } return category ; }
public command [ ] get all command ( ) { return ( command [ ] ) handle object by id . value ( ) . to array ( new command [ handle object by id . size ( ) ] ) ; }
public final boolean be category define ( ) { return ( ( ( change value & changed_category_defined ) ! = 0 ) & & ( category id ! = null ) ) ; }
protect synchronized final void add listener object ( final object listener ) { if ( listener == null ) { throw new illegal argument exception ( ) ; } if ( listener list == null ) { listener list = new listener list < > ( listener list . identity ) ; } listener list . add ( listener ) ; }
public boolean contain value ( object value ) { if ( fast ) { return ( map . contain value ( value ) ) ; } else { synchronize ( map ) { return ( map . contain value ( value ) ) ; } } }
public void set id ( item id id ) { if ( this . can set field value ( this . id , id ) ) { this . id = id ; this . change ( ) ; } }
public static synchronize datatype handler registry get instance ( ) { if ( default registry == null ) { default registry = new datatype handler registry ( ) ; } return default registry ; }
public void add mi behave expression type ( class < ? > clazz ) { if ( f misbehave expression type == null ) { f misbehave expression types= new array list < > ( 2 ) ; f misbehave expression type . add ( clazz ) ; } else if ( ! f misbehave expression type . contains ( clazz ) ) { f misbehave expression type . add ( clazz ) ; } }
public final void internal initialize ( property tester descriptor descriptor ) { f properties= descriptor . get property ( ) ; f namespace= descriptor . get namespace ( ) ; f config element= descriptor . get configuration element ( ) ; }
public static i text file buffer get text file buffer ( final i compilation unit unit ) { assert . be not null ( unit ) ; final i resource resource= unit . get resource ( ) ; if ( resource == null || resource . get type ( ) ! = i resource . file ) return null ; return file buffer . get text file buffer manager ( ) . get text file buffer ( resource . get full path ( ) , location kind . ifile ) ; }
public i document setup participant [ ] get document setup participant ( i path location , location kind location kind ) { set < i document setup participant > participants= new hash set < > ( ) ; list < i document setup participant > p= get document setup participant ( find content type ( location , location kind ) ) ; if ( p ! = null ) participant . add all ( p ) ; p= get document setup participant ( location . last segment ( ) ) ; if ( p ! = null ) participant . add all ( p ) ; p= get document setup participant ( location . get file extension ( ) ) ; if ( p ! = null ) participant . add all ( p ) ; p= get document setup participant ( wildcard ) ; if ( p ! = null ) participant . add all ( p ) ; i document setup participant [ ] result= new i document setup participant [ participant . size ( ) ] ; participant . to array ( result ) ; return result ; }
public i annotation model factory get annotation model factory ( i path location , location kind location kind ) { i annotation model factory factory= get annotation model factory ( find content type ( location , location kind ) ) ; if ( factory == null ) factory= get annotation model factory ( location . last segment ( ) ) ; if ( factory == null ) factory= get annotation model factory ( location . get file extension ( ) ) ; if ( factory == null ) factory= get annotation model factory ( wildcard ) ; return factory ; }
protect i content type [ ] find content type ( i path location , location kind location kind ) { assert . be legal ( location kind ! = location kind . ifile ) ; return f content type manager . find content type for ( location . last segment ( ) ) ; }
public collection < string > file ( directory dir , boolean include segment file ) throw i o exception { hash set < string > file = new hash set < string > ( ) ; if ( include segment file ) { final string segment file name = get segment file name ( ) ; if ( segment file name ! = null ) { file . add ( segment file name ) ; } } final int size = size ( ) ; for ( int i=0 ; i < size ; i++ ) { final segment commit info info = info ( i ) ; assert info . info . dir == dir ; if ( info . info . dir == dir ) { file . add all ( info . file ( ) ) ; } } return file ; }
public static i file system get null file system ( ) { return internal file system core . get instance ( ) . get null file system ( ) ; }
public static i file system get null file system ( ) { return internal file system core . get instance ( ) . get null file system ( ) ; }
public node info get attribute ( int index ) { if ( attribute == null ) { return null ; } else { return ( node info ) attribute . get ( index ) ; } }
public synchronize void reset ( ) { lock order . clear ( ) ; know deadlock . clear ( ) ; }
public void remove token for job ( string job id ) { synchronize ( current job token ) { current job token . remove ( job id ) ; } }
public static job create ( string name , final i core runnable runnable ) { return new job ( name ) { @ override protect i status run ( i progress monitor monitor ) { try { runnable . run ( monitor ) ; } catch ( core exception e ) { i status st = e . get status ( ) ; return new status ( st . get severity ( ) , st . get plugin ( ) , st . get code ( ) , st . get message ( ) , e ) ; } return status . ok_status ; } } ; }
public final void set rule ( i scheduling rule rule ) { super . set rule ( rule ) ; }
public boolean user match ( authenticate user user , string principal ) { if ( user == null ) return principal == null ; if ( user instanceof servlet authenticate user ) { servlet authenticate user servlet user = ( servlet authenticate user ) user ; return servlet user . get request ( ) . be user in role ( principal ) ; } return false ; }
public final job group get job group ( ) { return super . get job group ( ) ; }
public delta data tree assemble with forward delta ( delta data tree delta tree ) { return new delta data tree ( get root node ( ) . assemble with ( delta tree . get root node ( ) ) , this ) ; }
public static abstract data tree node get root node ( abstract data tree tree ) { return tree . get root node ( ) ; }
protect void reroot ( delta data tree source tree ) { if ( ! source tree . be immutable ( ) ) handle immutable tree ( ) ; delta data tree source parent = source tree . get parent ( ) ; if ( source parent == null ) return ; this . reroot ( source parent ) ; delta data tree backward delta = source tree . a backward delta ( ) ; delta data tree complete = source parent . assemble with forward delta ( source tree ) ; source tree . set root node ( complete . get root node ( ) ) ; source tree . set parent ( null ) ; source parent . set root node ( backward delta . get root node ( ) ) ; source parent . set parent ( source tree ) ; }
public int local deletion time ( ) { return local deletion time ; }
public i folder change to folder ( ) throw core exception { get property manager ( ) . delete property ( this , i resource . depth_zero ) ; i folder result = workspace . get root ( ) . get folder ( path ) ; if ( be link ( ) ) { i path location = get raw location ( ) ; delete ( i resource . none , null ) ; result . create link ( location , i resource . allow_missing_local , null ) ; } else { workspace . delete resource ( this ) ; workspace . create resource ( result , false ) ; } return result ; }
public i marker [ ] find marker ( string type , boolean include subtypes , i progress monitor monitor ) throw core exception { final resource traversal [ ] traversal = get traversal ( resource mapping context . local_context , monitor ) ; array list < i marker > result = new array list < > ( ) ; for ( resource traversal traversal : traversal ) traversal . do find marker ( result , type , include subtypes ) ; return result . to array ( new i marker [ result . size ( ) ] ) ; }
public boolean be transient ( ) { return modifier . be transient ( modifier ) ; }
public boolean be persistent ( string type ) { marker type definition def = definition . get ( type ) ; return def ! = null & & def . be persistent ; }
protect void rehash to ( int an index ) { int target = an index ; int index = an index + 1 ; if ( index > = element . length ) index = 0 ; i marker set element element = element [ index ] ; while ( element ! = null ) { int hash index = hash for ( element . get id ( ) ) % element . length ; boolean match ; if ( index < target ) match = ! ( hash index > target || hash index < = index ) ; else match = ! ( hash index > target & & hash index < = index ) ; if ( match ) { element [ target ] = element ; target = index ; } index++ ; if ( index > = element . length ) index = 0 ; element = element [ index ] ; } elements [ target ] = null ; }
public i path location for ( i resource resource ) { if ( resource . get type ( ) == i resource . root ) return meta area location . append ( f_root ) ; return project meta location . append ( resource . get project ( ) . get name ( ) ) ; }
public void write description ( i project description description , int update flag , boolean have public change , boolean have private change ) throw core exception { if ( project description . be read ) return ; project description . be write = true ; try { get local manager ( ) . internal write ( this , description , update flag , have public change , have private change ) ; } finally { project description . be write = false ; } }
public object get property store ( ) { return property store ; }
public void set type ( int value ) { set bit ( m_type , m_type_start , value ) ; }
public flag get flag ( ) { return ( flag ) flag . clone ( ) ; }
public float coord ( int overlap , int max overlap ) { return overlap / ( float ) max overlap ; }
public static boolean be overlap root ( i path root path1 , i path root path2 ) { if ( root path1 == null || root path2 == null ) { return false ; } return root path1 . be prefix of ( root path2 ) || root path2 . be prefix of ( root path1 ) ; }
public string get other message ( boolean flush ) { if ( null == error sink ) { return null ; } string result = error sink . to string ( ) . trim ( ) ; if ( 0 == result . length ( ) ) { result = null ; } if ( flush ) { error sink . set length ( 0 ) ; } return result ; }
public element tree read tree ( data input input , string new project name ) throw i o exception { / * the format version number have already be consume * by element tree reader # read from . * / element tree result = new element tree ( data tree reader . read tree ( null , input , new project name ) ) ; return result ; }
public void write delta ( element tree old tree , element tree new tree , i path path , int depth , final data output output , i element comparator comparator ) throw i o exception { / * write the version number * / write number ( current_format , output ) ; / * * * note that in current element tree usage , the new * tree be the complete tree , and old tree be just * delta on the new tree . * / delta data tree complete tree = new tree . get data tree ( ) ; delta data tree derive tree = old tree . get data tree ( ) ; delta data tree delta to write = null ; delta to write = complete tree . forward delta with ( derive tree , comparator ) ; assert . be true ( delta to write . be immutable ( ) ) ; data tree writer . write tree ( delta to write , path , depth , output ) ; }
public final void remember last built state ( ) { super . remember last built state ( ) ; }
public resource mapping [ ] get mapping ( resource traversal [ ] traversal , resource mapping context context , i progress monitor monitor ) throw core exception { set < resource mapping > result = new hash set < > ( ) ; for ( resource traversal traversal : traversal ) { resource map [ ] mapping = get mapping ( traversal . get resource ( ) , context , monitor ) ; result . add all ( array . a list ( mapping ) ) ; } return result . to array ( new resource mapping [ result . size ( ) ] ) ; }
public i marker [ ] find marker ( string type , boolean include subtypes , i progress monitor monitor ) throw core exception { final resource traversal [ ] traversal = get traversal ( resource mapping context . local_context , monitor ) ; array list < i marker > result = new array list < > ( ) ; for ( resource traversal traversal : traversal ) traversal . do find marker ( result , type , include subtypes ) ; return result . to array ( new i marker [ result . size ( ) ] ) ; }
public i refresh monitor install monitor ( i resource resource , i refresh result result , i progress monitor progress monitor ) { if ( resource . get location ( ) == null || ! resource . exists ( ) || resource . get type ( ) == i resource . file ) return null ; if ( monitor == null ) monitor = new win32 monitor ( result ) ; if ( monitor . monitor ( resource ) ) return monitor ; return null ; }
public boolean be archive ( ) { return ( attribute & efs . attribute_archive ) ! = 0 ; }
public void set value ( string name , long value ) { final long long value = get long ( name ) ; if ( value == long value ) return ; long old value = long . value of ( long value ) ; long new value = long . value of ( value ) ; try { notify = false ; if ( get default long ( name ) == value ) get plugin preference ( true ) . remove ( name ) ; else get plugin preference ( true ) . put long ( name , value ) ; fire property change event ( name , old value , new value ) ; } finally { notify = true ; } }
public boolean get boolean ( string name ) { return get plugin preference ( true ) . get boolean ( name , get default preference ( ) . get boolean ( name , boolean_default_default ) ) ; }
public boolean get boolean ( string name ) { return get plugin preference ( true ) . get boolean ( name , get default preference ( ) . get boolean ( name , boolean_default_default ) ) ; }
public static void remove listener ( performance listener listener ) { if ( enable ) performance stats processor . remove listener ( listener ) ; }
public boolean be failure ( ) { return be failure ( get exit value ( ) ) ; }
public static url to file u r l ( url url ) throw i o exception { u r l converter converter = activator . get u r l converter ( url ) ; return converter == null ? url : converter . to file u r l ( url ) ; }
public final i path get state location ( ) throw illegal state exception { return internal platform . get default ( ) . get state location ( get bundle ( ) , true ) ; }
public string get plugin id attr n ( ) { return plugin id attr n ; }
public static string get n l extension ( ) { return internal platform . get default ( ) . get n l extension ( ) ; }
public static string [ ] know w s value ( ) { return internal platform . get default ( ) . know w s value ( ) ; }
public static bundle [ ] get fragment ( bundle bundle ) { return internal platform . get default ( ) . get fragment ( bundle ) ; }
protect void set attribute ( final map < string , ? extends object > attribute ) throw core exception { i workspace workspace= resource plugin . get workspace ( ) ; i workspace runnable runnable= monitor - > ensure marker ( ) . set attribute ( attribute ) ; workspace . run ( runnable , get marker rule ( ) , i workspace . avoid_update , null ) ; }
public void fire resume event ( int detail ) { fire event ( new debug event ( this , debug event . resume , detail ) ) ; }
public boolean be writable ( ) { return ( ( flag & memory byte . writable ) == memory byte . writable ) ; }
public boolean be readable ( ) { return ( ( flag & memory byte . readable ) == memory byte . readable ) ; }
public static void refresh resource ( i resource [ ] resource , int depth , i progress monitor monitor ) throw core exception { if ( resource == null || resource . length == 0 ) { return ; } sub monitor lmonitor = sub monitor . convert ( monitor , debug core message . refreshing resource , resource . length ) ; if ( lmonitor . be cancel ( ) ) { return ; } multi status status = new multi status ( debug plugin . get unique identifier ( ) , 0 , debug core message . refresh resource error , null ) ; try { for ( i resource resource : resource ) { if ( lmonitor . be cancel ( ) ) { break ; } if ( resource ! = null & & resource . be accessible ( ) ) { try { resource . refresh local ( depth , null ) ; } catch ( core exception e ) { status . merge ( e . get status ( ) ) ; } } lmonitor . work ( 1 ) ; } } finally { lmonitor . do ( ) ; } if ( ! status . be o k ( ) ) { throw new core exception ( status ) ; } }
public void set id ( string id ) { set id ( id , true ) ; }
public reindex request set source query ( query builder query builder ) { if ( query builder ! = null ) { this . get search request ( ) . source ( ) . query ( query builder ) ; } return this ; }
protect void warn ( string message , throwable exception ) throw core exception { i status status = new status ( i status . warning , debug plugin . get unique identifier ( ) , debug plugin . error , message , exception ) ; throw new core exception ( status ) ; }
protect string serialize document ( document document ) throw core exception { return debug plugin . serialize document ( document ) ; }
public static void delete ( file file ) { if ( file . be file ( ) ) { file . delete ( ) ; return ; } if ( ! file . be directory ( ) ) { return ; } file [ ] exist file = file . list file ( ) ; if ( ! be null or empty ( exist file ) ) { for ( file f : existing file ) { delete ( f ) ; } } file . delete ( ) ; }
public static file maybe mark unwritable ( file path ) { file directory = get directory ( path ) ; if ( instance . unwritable directory . add ( directory ) ) { directory version . increment and get ( ) ; logger . warn ( `` blacklist { } for writes `` , directory ) ; return directory ; } return null ; }
public synchronize i breakpoint manager get breakpoint manager ( ) { if ( f breakpoint manager == null ) { f breakpoint manager = new breakpoint manager ( ) ; } return f breakpoint manager ; }
public boolean can terminate ( ) { synchronize ( sub launch ) { if ( sub launch . be empty ( ) ) { return false ; } for ( i launch launch : sub launch . key set ( ) ) { if ( launch . can terminate ( ) ) { return true ; } } return false ; } }
protect i launch configuration type get type ( ) { return f type ; }
protect void set set attribute ( element element ) throw core exception { string set key = element . get attribute ( key ) ; node list node list = element . get child node ( ) ; int entry count = node list . get length ( ) ; set < string > set = new hash set < > ( entry count ) ; node node = null ; element selement = null ; for ( int i = 0 ; i < entry count ; i++ ) { node = node list . item ( i ) ; if ( node . get node type ( ) == node . element_node ) { selement = ( element ) node ; if ( ! selement . get node name ( ) . equal ignore case ( set_entry ) ) { throw get invalid format debug exception ( ) ; } set . add ( get value attribute ( selement ) ) ; } } set attribute ( set key , set ) ; }
protect launch configuration info get copy ( ) { launch configuration info copy = new launch configuration info ( ) ; copy . set type ( get type ( ) ) ; copy . set attribute table ( get attribute ( ) ) ; copy . set be prototype ( be prototype ( ) ) ; copy . set prototype ( get prototype ( ) ) ; copy . set visible attribute ( get visible attribute ( ) ) ; return copy ; }
protect object remove attribute ( string attribute name ) { if ( attribute name ! = null ) { return f attribute . remove ( attribute name ) ; } return null ; }
public void migrate ( i launch configuration candidate ) throw core exception { initialize migration delegate ( ) ; if ( f migration delegate ! = null ) { f migration delegate . migrate ( candidate ) ; } }
public i launch delegate [ ] get launch delegate ( ) { initialize launch delegate ( ) ; collection < launch delegate > col = f launch delegate . value ( ) ; return col . to array ( new i launch delegate [ col . size ( ) ] ) ; }
public boolean can terminate ( ) { synchronize ( sub launch ) { if ( sub launch . be empty ( ) ) { return false ; } for ( i launch launch : sub launch . key set ( ) ) { if ( launch . can terminate ( ) ) { return true ; } } return false ; } }
public void resource change ( i resource change event event ) { i resource delta delta= event . get delta ( ) ; if ( delta ! = null ) { try { if ( fg visitor == null ) { fg visitor= new breakpoint manager visitor ( ) ; } delta . accept ( fg visitor ) ; fg visitor . update ( ) ; } catch ( core exception ce ) { debug plugin . log ( ce ) ; } } }
protect void terminate map configuration ( i resource resource ) { i launch [ ] launch = get launch ( ) ; i launch configuration [ ] configs = get map configuration ( resource ) ; try { for ( i launch launch : launch ) { for ( i launch configuration config : configs ) { if ( config . equal ( launch . get launch configuration ( ) ) & & launch . can terminate ( ) ) { launch . terminate ( ) ; } } } } catch ( core exception e ) { debug plugin . log ( e ) ; } }
public static i launch create advance launch ( i launch configuration configuration , string mode ) throw core exception { return new launch ( configuration , mode , create source locator ( advanced source lookup director . id , configuration ) ) ; }
public static void set use step filter ( boolean use step filter ) { get step filter manager ( ) . set use step filter ( use step filter ) ; }
public static i launch create advance launch ( i launch configuration configuration , string mode ) throw core exception { return new launch ( configuration , mode , create source locator ( advanced source lookup director . id , configuration ) ) ; }
public void start monitoring ( ) { synchronize ( this ) { if ( f thread == null ) { f thread = new thread ( ( runnable ) this : : write , debug core message . input stream monitor_label ) ; f thread . set daemon ( true ) ; f thread . start ( ) ; } } }
public static synchronize void save preference ( string qualifier ) { try { contexts [ default_context ] . get node ( qualifier ) . flush ( ) ; contexts [ instance_context ] . get node ( qualifier ) . flush ( ) ; } catch ( back store exception bse ) { debug plugin . log ( bse ) ; } }
protect d o m output element create and attach child ( element element ) { if ( m root node ! = null ) { m root node . append child ( element ) ; } else { m element . append child ( element ) ; } return create child ( element ) ; }
public string get action ( ) { if ( action == null ) { return `` `` ; } else { return action ; } }
public final void lock ( ) { security manager sm = system . get security manager ( ) ; if ( sm ! = null ) sm . check permission ( new application admin permission ( this , application admin permission . lock_action ) ) ; synchronize ( lock ) { if ( lock [ 0 ] ) return ; lock [ 0 ] = true ; lock specific ( ) ; save lock ( true ) ; } }
public boolean equal ( object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof admin permission ) ) { return false ; } admin permission ap = ( admin permission ) obj ; return ( action_mask == ap . action_mask ) & & ( ( bundle == ap . bundle ) || ( ( bundle ! = null ) & & bundle . equal ( ap . bundle ) ) ) & & ( filter == null ? ap . filter == null : filter . equal ( ap . filter ) ) ; }
public static i path get log file location ( ) { return meta data keeper . get meta area ( ) . get log location ( ) ; }
public void remove log listener ( i log listener listener ) { synchronize ( log listener ) { log listener . remove ( listener ) ; } }
public static boolean be abs url ( char sequence url ) { return abs_url_re . matcher ( url ) . find ( ) ; }
public static url to file u r l ( url url ) throw i o exception { u r l converter converter = activator . get u r l converter ( url ) ; return converter == null ? url : converter . to file u r l ( url ) ; }
public int size ( ) { return listener . size ( ) ; }
public void add all ( i status status ) { assert . be legal ( status ! = null ) ; add all internal ( status . get child ( ) ) ; }
public resolvable builder add qualifier unchecked ( qualifier instance qualifier ) { this . qualifier instance . add ( qualifier ) ; return this ; }
public void shutdown ( ) { if ( listener ! = null ) { listener . clear ( ) ; listener = null ; } if ( memory block ! = null ) { memory block . clear ( ) ; memory block = null ; } }
public static void run ( i safe runnable code ) { assert . be not null ( code ) ; try { code . run ( ) ; } catch ( exception | linkage error | assertion error e ) { handle exception ( code , e ) ; } }
protect void set response code ( int response code ) { this . response code = response code ; }
public void validate ( plugin descriptor plugin descriptor ) { / * * note : for plugins that depend on other plugin artifacts the plugin realm contain more than one plugin * descriptor . however , only the first descriptor be of interest . * / if ( ! first descriptor ) { return ; } first descriptor = false ; if ( ! plugin artifact . get group id ( ) . equal ( plugin descriptor . get group id ( ) ) ) { error . add ( `` plugin 's descriptor contain the wrong group id : `` + plugin descriptor . get group id ( ) ) ; } if ( ! plugin artifact . get artifact id ( ) . equal ( plugin descriptor . get artifact id ( ) ) ) { error . add ( `` plugin 's descriptor contain the wrong artifact id : `` + plugin descriptor . get artifact id ( ) ) ; } if ( ! plugin artifact . get base version ( ) . equal ( plugin descriptor . get version ( ) ) ) { error . add ( `` plugin 's descriptor contain the wrong version : `` + plugin descriptor . get version ( ) ) ; } }
public void stop ( ) { registry . remove listener ( listener ) ; listener . unregister all ( ) ; }
public void resource change ( i resource change event event ) { i resource delta delta= event . get delta ( ) ; if ( delta ! = null ) { try { if ( fg visitor == null ) { fg visitor= new breakpoint manager visitor ( ) ; } delta . accept ( fg visitor ) ; fg visitor . update ( ) ; } catch ( core exception ce ) { debug plugin . log ( ce ) ; } } }
public object remove ( final object key ) { return do remove ( ( comparable ) key , key ) ; }
public void set ( long timestamp ) { aggregate timestamp = timestamp ; modify = false ; }
public boolean be modify ( ) { return false ; }
public static void set default registry provider ( i registry provider provider ) throw core exception { registry provider factory . set default ( provider ) ; }
public object [ ] get extra marker attribute value ( ) { return default problem . empty_values ; }
public static final char [ ] prepend ( char prefix , char [ ] array ) { if ( array == null ) return new char [ ] { prefix } ; int length = array . length ; system . arraycopy ( array , 0 , array = new char [ length + 1 ] , 1 , length ) ; array [ 0 ] = prefix ; return array ; }
public static final char [ ] [ ] array concat ( char [ ] [ ] first , char [ ] [ ] second ) { if ( first == null ) return second ; if ( second == null ) return first ; int length1 = first . length ; int length2 = second . length ; char [ ] [ ] result = new char [ length1 + length2 ] [ ] ; system . arraycopy ( first , 0 , result , 0 , length1 ) ; system . arraycopy ( second , 0 , result , length1 , length2 ) ; return result ; }
public static final char [ ] prepend ( char prefix , char [ ] array ) { if ( array == null ) return new char [ ] { prefix } ; int length = array . length ; system . arraycopy ( array , 0 , array = new char [ length + 1 ] , 1 , length ) ; array [ 0 ] = prefix ; return array ; }
public static boolean be indent char ( char ch ) { return scanner helper . be whitespace ( ch ) & & ! be line delimiter char ( ch ) ; }
public static final int index of ( char [ ] to be find , char [ ] array , boolean be case sensitive ) { return index of ( to be find , array , be case sensitive , 0 ) ; }
public final i bind resolve binding ( ) { return this . ast . get binding resolver ( ) . resolve reference ( this ) ; }
public i java element delta get delta ( ) { return ( i java element delta ) this . source ; }
public void put problem ( string marker type , categorize problem [ ] problem ) { if ( this . operation . problem == null ) this . operation . problem = new hash map ( ) ; this . operation . problem . put ( marker type , problem ) ; }
public final i compilation unit new work copy ( string name , i classpath entry [ ] classpath , i problem requestor problem requestor , i progress monitor monitor ) throw java model exception { external java project project = new external java project ( classpath ) ; i package fragment parent = ( ( package fragment root ) project . get package fragment root ( project . get project ( ) ) ) . get package fragment ( char operation . no_strings ) ; compilation unit result = new compilation unit ( ( package fragment ) parent , name , this ) ; result . become work copy ( problem requestor , monitor ) ; return result ; }
public static string get warn token ( int problem i d ) { int irritant = problem reporter . get irritant ( problem i d ) ; if ( irritant ! = 0 ) { return compiler option . warn token from irritant ( irritant ) ; } return null ; }
public boolean be member type declaration ( ) { a s t node parent = get parent ( ) ; return ( parent instanceof abstract type declaration ) || ( parent instanceof anonymous class declaration ) ; }
public annotation member declaration set default value ( final expression default value ) { if ( default value == this . default value ) { return this ; } notify property change ( observable property . default_value , this . default value , default value ) ; if ( this . default value ! = null ) this . default value . set parent node ( null ) ; this . default value = default value ; set a parent node of ( default value ) ; return this ; }
public i method bind resolve binding ( ) { return this . ast . get binding resolver ( ) . resolve method ( this ) ; }
public void set label ( simple name label ) { a s t node old child = this . optional label ; pre replace child ( old child , label , label_property ) ; this . optional label = label ; post replace child ( old child , label , label_property ) ; }
public void set type ( type type ) { if ( type == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . base type ; pre replace child ( old child , type , type_property ) ; this . base type = type ; post replace child ( old child , type , type_property ) ; }
public a s t node find declare node ( i bind binding ) { return this . ast . get binding resolver ( ) . find declaring node ( bind ) ; }
public void set expression ( expression expression ) { if ( expression == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . expression ; pre replace child ( old child , expression , expression_property ) ; this . expression = expression ; post replace child ( old child , expression , expression_property ) ; }
public void set label ( simple name label ) { a s t node old child = this . optional label ; pre replace child ( old child , label , label_property ) ; this . optional label = label ; post replace child ( old child , label , label_property ) ; }
public void set expression ( expression expression ) { if ( expression == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . expression ; pre replace child ( old child , expression , expression_property ) ; this . expression = expression ; post replace child ( old child , expression , expression_property ) ; }
public final boolean resolve boxing ( ) { return this . ast . get binding resolver ( ) . resolve boxing ( this ) ; }
public void set name ( simple name name ) { if ( name == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . name ; pre replace child ( old child , name , name_property ) ; this . name = name ; post replace child ( old child , name , name_property ) ; }
public statement transform ( try catch statement try catch statement ) { if ( ! a boolean ( try catch statement . get resource statement ( ) ) ) { return try catch statement ; } if ( this . be basic try with resource statement ( try catch statement ) ) { return this . transform basic try with resource statement ( try catch statement ) ; } else { return this . transform extend try with resource statement ( try catch statement ) ; } }
public void set then statement ( statement statement ) { if ( statement == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . then statement ; pre replace child ( old child , statement , then_statement_property ) ; this . then statement = statement ; post replace child ( old child , statement , then_statement_property ) ; }
public i type bind resolve binding ( ) { return this . ast . get binding resolver ( ) . resolve type ( this ) ; }
public void set operator ( prefix expression . operator operator ) { if ( operator == null ) { throw new illegal argument exception ( ) ; } pre value change ( operator_property ) ; this . operator = operator ; post value change ( operator_property ) ; }
public static module bind create ( i module module , lookup environment exist environment ) { if ( module . be automatic ( ) ) return new automatic module binding ( module , exist environment ) ; return new binary module binding ( ( i binary module ) module , exist environment ) ; }
public void set then statement ( statement statement ) { if ( statement == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . then statement ; pre replace child ( old child , statement , then_statement_property ) ; this . then statement = statement ; post replace child ( old child , statement , then_statement_property ) ; }
public void set qualifier ( name name ) { a s t node old child = this . optional qualifier ; pre replace child ( old child , name , qualifier_property ) ; this . optional qualifier = name ; post replace child ( old child , name , qualifier_property ) ; }
public simple name get receiver qualifier ( ) { unsupported in2_3_4 ( ) ; return this . optional receiver qualifier ; }
public i type bind resolve binding ( ) { return this . ast . get binding resolver ( ) . resolve type ( this ) ; }
public static boolean be protect ( int flag ) { return ( flags & acc protect ) ! = 0 ; }
public static boolean be synchronize ( int flag ) { return ( flags & acc synchronize ) ! = 0 ; }
public governator add module ( module . . . module ) { if ( module ! = null ) { this . module . add all ( array . a list ( module ) ) ; } return this ; }
public boolean be static ( ) { return this . modifier keyword == module modifier keyword . static_keyword ; }
public void set name ( simple name name ) { a s t node old child = this . optional parameter name ; pre replace child ( old child , name , name_property ) ; this . optional parameter name = name ; post replace child ( old child , name , name_property ) ; }
public final boolean be qualify type ( ) { return ( this instanceof qualify type ) ; }
public static a s t node perform ( a s t node root , int start , int length ) { node finder finder = new node finder ( root , start , length ) ; a s t node result= finder . get covered node ( ) ; if ( result == null || result . get start position ( ) ! = start || result . get length ( ) ! = length ) { return finder . get cover node ( ) ; } return result ; }
public static a s t node perform ( a s t node root , int start , int length ) { node finder finder = new node finder ( root , start , length ) ; a s t node result= finder . get covered node ( ) ; if ( result == null || result . get start position ( ) ! = start || result . get length ( ) ! = length ) { return finder . get cover node ( ) ; } return result ; }
public void set expression ( expression expression ) { if ( expression == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . expression ; pre replace child ( old child , expression , expression_property ) ; this . expression = expression ; post replace child ( old child , expression , expression_property ) ; }
public void set right operand ( expression expression ) { if ( expression == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . right operand ; pre replace child ( old child , expression , right_operand_property ) ; this . right operand = expression ; post replace child ( old child , expression , right_operand_property ) ; }
public list super interface ( ) { return internal super interface ( ) ; }
public void set expression ( expression expression ) { if ( expression == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . expression ; pre replace child ( old child , expression , expression_property ) ; this . expression = expression ; post replace child ( old child , expression , expression_property ) ; }
public boolean be varargs ( ) { unsupported in2 ( ) ; return this . variable arity ; }
public string get text ( ) { if ( text ! = null ) { return text . trim ( ) ; } return text ; }
public final j class wildcard ( ) { return new j type wildcard ( this ) ; }
public boolean extend superclass ( final string superclass name ) { return get superclass ( ) . contains name ( superclass name ) ; }
public void set type ( type type ) { if ( type == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . base type ; pre replace child ( old child , type , type_property ) ; this . base type = type ; post replace child ( old child , type , type_property ) ; }
public list thrown exception type ( ) { if ( this . thrown exception type == null ) { unsupported in2_3_4 ( ) ; } return this . thrown exception type ; }
public static boolean be static ( int flag ) { return ( flags & acc static ) ! = 0 ; }
public final boolean be synthetic ( ) { return ( this . modifier & class file constant . acc synthetic ) ! = 0 ; }
public final boolean be bridge ( ) { return ( this . modifier & class file constant . acc bridge ) ! = 0 ; }
public static i status validate field name ( string name ) { return validate identifier ( name , compiler option . version_1_3 , compiler option . version_1_3 ) ; }
public static char [ ] suggest getter name ( i java project project , char [ ] field name , int modifier , boolean be boolean , char [ ] [ ] exclude names ) { if ( be boolean ) { char [ ] name = internal naming convention . get base name ( get field variable kind ( modifier ) , project , field name , false ) ; int prefix len = getter_bool_name . length ; if ( char operation . prefix equal ( getter_bool_name , name ) & & name . length > prefix len & & scanner helper . be upper case ( name [ prefix len ] ) ) { return suggest new name ( name , exclude names ) ; } else { return suggest new name ( char operation . concat ( getter_bool_name , suggest accessor name ( project , field name , modifier ) ) , exclude names ) ; } } else { return suggest new name ( char operation . concat ( getter_name , suggest accessor name ( project , field name , modifier ) ) , exclude names ) ; } }
public final string get path ( ) { return this . path ; }
public void search ( i workspace workspace , string pattern string , int search for , int limit to , i java search scope scope , i java search result collector result collector ) throw java model exception { try { int match mode = pattern string . index of ( ' * ' ) ! = -1 || pattern string . index of ( ' ? ' ) ! = -1 ? search pattern . r_pattern_match : search pattern . r_exact_match ; search ( search pattern . create pattern ( pattern string , search for , limit to , match mode | search pattern . r_case_sensitive ) , new search participant [ ] { get default search participant ( ) } , scope , new result collector adapter ( result collector ) , result collector . get progress monitor ( ) ) ; } catch ( core exception e ) { if ( e instanceof java model exception ) throw ( java model exception ) e ; throw new java model exception ( e ) ; } }
public void search declaration of accessed field ( i java element enclose element , search requestor requestor , i progress monitor monitor ) throw java model exception { this . basic engine . search declaration of accessed field ( enclose element , requestor , monitor ) ; }
public static type get type reference ( typed element type ) { class element class element = type . get type ( ) ; if ( type . be primitive ( ) ) { string internal name = name_to_type_map . get ( class element . get name ( ) ) ; if ( type . be array ( ) ) { string builder name = new string builder ( internal name ) ; for ( int i = 0 ; i < type . get array dimension ( ) ; i++ ) { name . insert ( 0 , `` [ `` ) ; } return type . get object type ( name . to string ( ) ) ; } else { return type . get type ( internal name ) ; } } else { object native type = type . get native type ( ) ; if ( native type instanceof class ) { class < ? > t = ( class < ? > ) native type ; return type . get type ( t ) ; } else { string internal name = type . get type ( ) . get name ( ) . replace ( ' . ' , '/ ' ) ; if ( internal name . be empty ( ) ) { return type . get type ( object . class ) ; } if ( type . be array ( ) ) { string builder name = new string builder ( internal name ) ; name . insert ( 0 , `` l `` ) ; for ( int i = 0 ; i < type . get array dimension ( ) ; i++ ) { name . insert ( 0 , `` [ `` ) ; } name . append ( `` ; `` ) ; return type . get object type ( name . to string ( ) ) ; } else { return type . get object type ( internal name ) ; } } } }
public static claim request resolve ( final response type response type , final scope scope ) { return resolve ( response type , scope , collection . < scope . value , set < string > > empty map ( ) ) ; }
public reference bind [ ] get discourage exception ( ) { reference bind [ ] all discourage exception = new reference binding [ this . discouraged exception . element size ] ; this . discouraged exception . a array ( all discourage exception ) ; return all discouraged exception ; }
public int literal index for type ( final type bind bind ) { type binding type bind = binding . leaf component type ( ) ; if ( ( type binding . tag bit & tag bit . contains nest type reference ) ! = 0 ) { util . record nest type ( this . class file , type binding ) ; } return this . literal index for type ( bind . constant pool name ( ) ) ; }
public static void clean up unassigned ( block scope scope , a s t node location , flow info flow info ) { if ( ! scope . have resource tracker ( ) ) return ; location . traverse ( new a s t visitor ( ) { @ override public boolean visit ( message send message send , block scope skope ) { faked track variable close tracker = message send . close tracker ; if ( close tracker ! = null ) { if ( close tracker . original binding == null ) { int null status = flow info . null status ( close tracker . binding ) ; if ( ( null status & ( flow info . potentially_null | flow info . null ) ) ! = 0 ) { close tracker . report error ( skope . problem reporter ( ) , message send , null status ) ; } close tracker . withdraw ( ) ; } } return true ; } } , scope ) ; }
public void mark close effectively final ( ) { this . global closing state |= twr_effectively_final ; }
public boolean continue completes ( ) { return false ; }
public type annotation walker to throw ( int index ) { long new match = this . match ; if ( new match == 0 ) return empty_annotation_walker ; int length = this . type annotation . length ; long mask = 1 ; for ( int i = 0 ; i < length ; i++ , mask = mask < < 1 ) { i binary type annotation candidate = this . type annotation [ i ] ; if ( candidate . get target type ( ) ! = annotation target type constant . throw || candidate . get throws type index ( ) ! = index ) { new match & = ~mask ; } } return restrict ( new match , 0 ) ; }
public void resolve ( constant pool constant pool ) { class name = ( ( utf8 c p info ) constant pool . get entry ( index ) ) . get value ( ) ; super . resolve ( constant pool ) ; }
public compilation unit add import ( import declaration import declaration ) { if ( import declaration . be asterisk ( ) ) { get import ( ) . remove if ( im - > object . equal ( get import package name ( im ) . get ( ) , get import package name ( import declaration ) . or else ( null ) ) ) ; } if ( ! be implicit import ( import declaration ) & & get import ( ) . stream ( ) . none match ( im - > im . equal ( import declaration ) || ( im . be asterisk ( ) & & object . equal ( get import package name ( im ) . get ( ) , get import package name ( import declaration ) . or else ( null ) ) ) ) ) { get import ( ) . add ( import declaration ) ; } return this ; }
public i compilation unit get compilation unit ( ) { return f compilation unit ; }
public final i bind resolve binding ( ) { return this . ast . get binding resolver ( ) . resolve reference ( this ) ; }
public boolean have same irritant ( irritant set irritant set ) { if ( irritant set == null ) return false ; for ( int i = 0 ; i < group_max ; i++ ) { if ( this . bits [ i ] ! = irritant set . bit [ i ] ) return false ; } return true ; }
public final boolean be valid binding ( ) { return problem id ( ) == problem reason . no error ; }
public char [ ] generic type signature ( ) { if ( ! be prototype ( ) ) return this . prototype . generic type signature ( ) ; if ( this . generic reference type signature == null & & this . constant pool name == null ) { if ( be anonymous type ( ) ) set constant pool name ( superclass ( ) . source name ( ) ) ; else set constant pool name ( source name ( ) ) ; } return super . generic type signature ( ) ; }
public final boolean be public ( ) { return ( this . modifier & class file constant . acc public ) ! = 0 ; }
public method bind original ( ) { return this ; }
public static constant set get constant set ( string name ) { constant set constant = constant set . get ( name ) ; if ( constant == null ) { synchronize ( lock ) { if ( ! constant set . contains key ( name ) ) { constant = new constant set ( jnr . constant . constant set . get constant set ( name ) ) ; constant set . put ( name , constant ) ; } } } return constant ; }
public recover element add ( type declaration type declaration , int bracket balance value ) { return this . add ( type declaration , bracket balance value , false ) ; }
public recover type enclose type ( ) { recovered element current = this ; while ( current ! = null ) { if ( current instanceof recover type ) { return ( recovered type ) current ; } current = current . parent ; } return null ; }
protect void set source range end ( int end ) { this . f source range [ 1 ] = end ; }
protect void check cancel ( i progress monitor progress monitor ) { if ( progress monitor ! = null & & progress monitor . be cancel ( ) ) { throw new operation cancel exception ( ) ; } }
protect static int get number of problem ( i problem [ ] problem , int problem id ) { int result= 0 ; for ( i problem problem : problem ) { if ( problem . get i d ( ) == problem id ) result++ ; } return result ; }
public string get field doc ( i field child ) throw java model exception { if ( this . content == null ) return null ; int [ ] range = null ; synchronize ( this ) { if ( this . field doc range == null ) { this . field doc range = new hashtable of object to int array ( ) ; } else { range = this . field doc range . get ( child ) ; } if ( range == null ) { range = compute field range ( child ) ; this . field doc range . put ( child , range ) ; } } if ( range ! = null ) { if ( range == unknown_format ) throw new java model exception ( new java model status ( i java model status constant . unknown_javadoc_format , child ) ) ; return new string ( this . content , range [ 0 ] , range [ 1 ] - range [ 0 ] ) ; } return null ; }
public void put problem ( string marker type , categorize problem [ ] problem ) { if ( this . operation . problem == null ) this . operation . problem = new hash map ( ) ; this . operation . problem . put ( marker type , problem ) ; }
public void exit field ( int body end , int declaration end ) { d o m field field = ( d o m field ) this . f stack . pop ( ) ; if ( field . get end position ( ) < declaration end ) { field . set source range end ( declaration end ) ; int name end = field . f name range [ 1 ] ; if ( name end < body end ) { / * see 1fviiv8 - obtain initializer range * / string initializer = new string ( this . f document , name end + 1 , body end - name end ) ; int index = initializer . index of ( '= ' ) ; if ( index > -1 ) { field . set have initializer ( true ) ; field . set initializer range ( name end + index + 2 , body end ) ; } } } this . f field count++ ; this . f node = field ; if ( this . f build single member ) { this . f finish single member= true ; } }
public void exit class ( int body end , int declaration end ) { exit type ( body end , declaration end ) ; }
protect d o m field get last field declaration ( ) { d o m field field = this ; while ( field . be variable declarator ( ) || field . have multiple variable declarators ( ) ) { if ( field . f next node instanceof d o m field & & ( ( d o m field ) field . f next node ) . be variable declarator ( ) ) { field= ( d o m field ) field . f next node ; } else { break ; } } return field ; }
protect void set type alter ( boolean type alter ) { set mask ( mask_field_type_altered , type alter ) ; }
public enumeration < v > element ( ) { if ( this . entry queue == null ) return new l r u cache enumerator < > ( null ) ; l r u cache enumerator . l r u enumerator element < v > head = new l r u cache enumerator . l r u enumerator element < > ( this . entry queue . value ) ; l r u cache entry < k , v > current entry = this . entry queue . next ; l r u cache enumerator . l r u enumerator element < v > current element = head ; while ( current entry ! = null ) { current element . next = new l r u cache enumerator . l r u enumerator element < > ( current entry . value ) ; current element = current element . next ; current entry = current entry . next ; } return new l r u cache enumerator < > ( head ) ; }
public void add binary ( i file resource , i path container path ) { if ( java core . get plugin ( ) == null ) return ; search participant participant = search engine . get default search participant ( ) ; search document document = participant . get document ( resource . get full path ( ) . to string ( ) ) ; index location index location = compute index location ( container path ) ; schedule document indexing ( document , container path , index location , participant ) ; }
protect int get value hash code ( ) { if ( this . value == null ) { return 0 ; } if ( ! this . type . be array ( ) ) { return this . value . hash code ( ) ; } if ( this . type == byte [ ] . class ) { return array . hash code ( ( byte [ ] ) this . value ) ; } if ( this . type == char [ ] . class ) { return array . hash code ( ( char [ ] ) this . value ) ; } if ( this . type == double [ ] . class ) { return array . hash code ( ( double [ ] ) this . value ) ; } if ( this . type == float [ ] . class ) { return array . hash code ( ( float [ ] ) this . value ) ; } if ( this . type == int [ ] . class ) { return array . hash code ( ( int [ ] ) this . value ) ; } if ( this . type == long [ ] . class ) { return array . hash code ( ( long [ ] ) this . value ) ; } if ( this . type == short [ ] . class ) { return array . hash code ( ( short [ ] ) this . value ) ; } if ( this . type == boolean [ ] . class ) { return array . hash code ( ( boolean [ ] ) this . value ) ; } return array . hash code ( ( object [ ] ) this . value ) ; }
public static string capitalize ( string name ) { if ( name == null || name . length ( ) == 0 ) { return name ; } char char [ ] = name . to char array ( ) ; char [ 0 ] = character . to upper case ( char [ 0 ] ) ; return new string ( char ) ; }
public void reset ( ) { this . response . reset ( ) ; }
public type signature get type signature ( ) { if ( type signature str == null ) { return null ; } if ( type signature == null ) { try { type signature = type signature . parse ( type signature str , declare class name ) ; type signature . set scan result ( scan result ) ; } catch ( final parse exception e ) { throw new illegal argument exception ( e ) ; } } return type signature ; }
public char array buffer append ( char [ ] src ) { if ( src ! = null ) append ( src , 0 , src . length ) ; return this ; }
public create index request builder set index ( string index ) { request . index ( index ) ; return this ; }
public < t > ct field reference < t > create reference ( ct type reference < ? > declare type , ct type reference < t > type , string field name ) { ct field reference < t > field ref = factory . core ( ) . create field reference ( ) ; field ref . set simple name ( field name ) ; field ref . set declare type ( declare type ) ; field ref . set type ( type ) ; return field ref ; }
public reference binding set focus type ( char [ ] [ ] compound name ) { if ( compound name == null || this . lookup environment == null ) return null ; this . focus type = this . lookup environment . get cached type ( compound name ) ; if ( this . focus type == null ) { this . focus type = this . lookup environment . ask for type ( compound name , this . lookup environment . un name module ) ; if ( this . focus type == null ) { int length = compound name . length ; char [ ] type name = compound name [ length-1 ] ; int first dollar = char operation . index of ( ' $ ' , type name ) ; if ( first dollar ! = -1 ) { compound name [ length-1 ] = char operation . subarray ( type name , 0 , first dollar ) ; this . focus type = this . lookup environment . ask for type ( compound name , this . lookup environment . un name module ) ; if ( this . focus type ! = null ) { char [ ] [ ] member type name = char operation . split on ( ' $ ' , type name , first dollar+1 , type name . length ) ; for ( int i = 0 ; i < member type name . length ; i++ ) { this . focus type = this . focus type . get member type ( member type name [ i ] ) ; if ( this . focus type == null ) return null ; } } } } } return this . focus type ; }
public string get name ( ) { if ( f class == null ) { return `` null `` ; } return f class . get name ( ) ; }
public static < t > all group head collector < t > new collector ( group selector < t > selector , sort sort ) { if ( sort . equal ( sort . relevance ) ) return new score group head collector < > ( selector , sort ) ; return new sort group head collector < > ( selector , sort ) ; }
public static string get getter method body content ( i compilation unit cu , string declare type name , string method name , string field name , string line delimiter ) throw core exception { return stub utility . get getter method body content ( cu . get java project ( ) , declare type name , method name , field name , line delimiter ) ; }
public list < parse problem > get error ( ) { return error ; }
public change get change ( ) { if ( f change ! = null ) { final change descriptor descriptor= f change . get descriptor ( ) ; if ( descriptor == null ) { final composite change composite= new composite change ( f change . get name ( ) ) { @ override public final change descriptor get descriptor ( ) { string name= f change . get name ( ) ; if ( name . length ( ) == 0 ) name= refactoring core message . create change operation_unknown_ refactoring ; unknown refactoring descriptor unknown descriptor= new unknown refactoring descriptor ( name ) ; return new refactoring change descriptor ( unknown descriptor ) ; } } ; composite . mark a synthetic ( ) ; composite . add ( f change ) ; f change= composite ; } } return f change ; }
public void set class name ( string class name ) { java refactoring descriptor util . set string ( f argument , class_name , class name ) ; }
public void set delegate ( boolean delegate ) { f delegate= delegate ; }
public void set deprecate delegate ( boolean deprecate delegate ) { f deprecate delegate= deprecate delegate ; }
public void set subtype ( final i type type ) { assert . be not null ( type ) ; f sub type= type ; }
public void set delegate ( boolean delegate ) { f delegate= delegate ; }
public method declaration generate to string method ( ) throw core exception { initialize ( ) ; for ( string element : f context . get template parser ( ) . get begin ( ) ) { add element ( process element ( element , null ) ) ; } object [ ] members= f context . get select member ( ) ; for ( int i= 0 ; i < member . length ; i++ ) { if ( ! f context . be skip null ( ) || get member type ( member [ i ] ) . be primitive ( ) ) add member ( member [ i ] , i ! = member . length - 1 ) ; else add member check null ( member [ i ] , i ! = member . length - 1 ) ; } for ( string element : f context . get template parser ( ) . get end ( ) ) { add element ( process element ( element , null ) ) ; } complete ( ) ; return to string method ; }
public string get new name ( ) { return f name ; }
public move argument get argument ( ) { return f argument ; }
public static expression make lazy expression ( expression operand ) { if ( operand instanceof lazy expression || operand instanceof literal ) { return operand ; } else { return new lazy expression ( operand ) ; } }
protect type entry get element decl ( string element name ) { if ( element ! = null ) { for ( int i = 0 ; i < element . size ( ) ; i++ ) { element decl elem = ( element decl ) element . get ( i ) ; string variable name ; if ( elem . get any element ( ) ) { variable name = constant . anycontent ; } else { variable name = elem . get name ( ) ; } if ( variable name . equal ( element name ) ) return elem . get type ( ) ; } } return null ; }
public static char [ ] suggest getter name ( i java project project , char [ ] field name , int modifier , boolean be boolean , char [ ] [ ] exclude names ) { if ( be boolean ) { char [ ] name = internal naming convention . get base name ( get field variable kind ( modifier ) , project , field name , false ) ; int prefix len = getter_bool_name . length ; if ( char operation . prefix equal ( getter_bool_name , name ) & & name . length > prefix len & & scanner helper . be upper case ( name [ prefix len ] ) ) { return suggest new name ( name , exclude names ) ; } else { return suggest new name ( char operation . concat ( getter_bool_name , suggest accessor name ( project , field name , modifier ) ) , exclude names ) ; } } else { return suggest new name ( char operation . concat ( getter_name , suggest accessor name ( project , field name , modifier ) ) , exclude names ) ; } }
public static string swap case ( string str ) { int str len ; if ( str == null || ( str len = str . length ( ) ) == 0 ) { return str ; } string buffer buffer = new string buffer ( str len ) ; boolean whitespace = true ; char ch = 0 ; char tmp = 0 ; for ( int i = 0 ; i < str len ; i++ ) { ch = str . char at ( i ) ; if ( character . be upper case ( ch ) ) { tmp = character . to lower case ( ch ) ; } else if ( character . be title case ( ch ) ) { tmp = character . to lower case ( ch ) ; } else if ( character . be low case ( ch ) ) { if ( whitespace ) { tmp = character . to title case ( ch ) ; } else { tmp = character . to upper case ( ch ) ; } } else { tmp = ch ; } buffer . append ( tmp ) ; whitespace = character . be whitespace ( ch ) ; } return buffer . to string ( ) ; }
public static int compute indent unit ( string line , i java project project ) { return indent manipulation . measure indent unit ( line , code formatter util . get tab width ( project ) , code formatter util . get indent width ( project ) ) ; }
public boolean get expand with constructor ( ) { return f be expand with constructor set & & f expand with constructor ; }
public string matcher [ ] get ignore filter ( ) { if ( f filter == null ) { string filter string= null ; if ( be filter enable ( ) ) { filter string= get filter ( ) ; if ( filter string . be empty ( ) ) { filter string= default ignore filter ; } } if ( filter string ! = null ) { f filters= parse list ( filter string ) ; } else { f filters= null ; } } return f filter ; }
public boolean replace weak ( subscription next ) { subscription current = get ( ) ; if ( current == unsubscribed . instance ) { if ( next ! = null ) { next . unsubscribe ( ) ; } return false ; } if ( compare and set ( current , next ) ) { return true ; } current = get ( ) ; if ( current == unsubscribed . instance ) { if ( next ! = null ) { next . unsubscribe ( ) ; } return false ; } return true ; }
public method wrapper [ ] get call ( i progress monitor progress monitor ) { method wrapper [ ] result = super . get call ( progress monitor ) ; array . sort ( result , f method wrapper comparator ) ; return result ; }
public void clear ( string cache key ) { value cache key key = get request cache key ( cache key ) ; if ( key ! = null ) { / * remove this cache key * / request variable for cache . get ( concurrency strategy ) . remove ( key ) ; } }
public method declaration [ ] get method ( ) { list bd = body declaration ( ) ; int method count = 0 ; for ( iterator it = bd . list iterator ( ) ; it . have next ( ) ; ) { if ( it . next ( ) instanceof method declaration ) { method count++ ; } } method declaration [ ] method = new method declaration [ method count ] ; int next = 0 ; for ( iterator it = bd . list iterator ( ) ; it . have next ( ) ; ) { object decl = it . next ( ) ; if ( decl instanceof method declaration ) { method [ next++ ] = ( method declaration ) decl ; } } return method ; }
public static selection create from start length ( int s , int l ) { assert . be true ( s > = 0 & & l > = 0 ) ; selection result= new selection ( ) ; result . f start= s ; result . f length= l ; result . f exclusive end= s + l ; return result ; }
public static a s t node perform ( a s t node root , int start , int length ) { node finder finder = new node finder ( root , start , length ) ; a s t node result= finder . get covered node ( ) ; if ( result == null || result . get start position ( ) ! = start || result . get length ( ) ! = length ) { return finder . get cover node ( ) ; } return result ; }
public list < infix expression . operator > get infix out safe operator ( ) { return collection . empty list ( ) ; }
public static string null safe to string ( object obj ) { if ( obj == null ) { return null_string ; } if ( obj instanceof string ) { return ( string ) obj ; } if ( obj instanceof object [ ] ) { return null safe to string ( ( object [ ] ) obj ) ; } if ( obj instanceof boolean [ ] ) { return null safe to string ( ( boolean [ ] ) obj ) ; } if ( obj instanceof byte [ ] ) { return null safe to string ( ( byte [ ] ) obj ) ; } if ( obj instanceof char [ ] ) { return null safe to string ( ( char [ ] ) obj ) ; } if ( obj instanceof double [ ] ) { return null safe to string ( ( double [ ] ) obj ) ; } if ( obj instanceof float [ ] ) { return null safe to string ( ( float [ ] ) obj ) ; } if ( obj instanceof int [ ] ) { return null safe to string ( ( int [ ] ) obj ) ; } if ( obj instanceof long [ ] ) { return null safe to string ( ( long [ ] ) obj ) ; } if ( obj instanceof short [ ] ) { return null safe to string ( ( short [ ] ) obj ) ; } string str = obj . to string ( ) ; return ( str ! = null ? str : empty_string ) ; }
public lookup result find class node ( string name , compilation unit compilation unit ) { return try a loader class or script ( name , compilation unit ) ; }
public void create edit ( ) throw java model exception { try { i document document= new document ( f delegate rewrite . get cu ( ) . get buffer ( ) . get content ( ) ) ; text edit edit= f delegate rewrite . get a s t rewrite ( ) . rewrite a s t ( document , f delegate rewrite . get cu ( ) . get option ( true ) ) ; edit . apply ( document , text edit . update_regions ) ; string new source= string . trim indentation ( document . get ( f track position . get start position ( ) , f tracked position . get length ( ) ) , f preference . tab width , f preference . indent width , false ) ; a s t node placeholder= f original rewrite . get a s t rewrite ( ) . create string placeholder ( new source , f declaration . get node type ( ) ) ; categorize text edit group group description= f original rewrite . create categorized group description ( get text edit group label ( ) , category_delegate ) ; list rewrite body declaration list rewrite= f original rewrite . get a s t rewrite ( ) . get list rewrite ( f declaration . get parent ( ) , get type body declaration property ( ) ) ; if ( f copy ) if ( f insert before ) body declaration list rewrite . insert before ( placeholder , f declaration , group description ) ; else body declaration list rewrite . insert after ( placeholder , f declaration , group description ) ; else body declaration list rewrite . replace ( f declaration , placeholder , group description ) ; } catch ( bad location exception e ) { java manipulation plugin . log ( e ) ; } }
protect i requestor get infrastructure evaluation requestor ( i code snippet requestor requestor ) { return new requestor wrapper ( requestor ) ; }
protect static i variable bind [ ] get argument binding ( final method declaration declaration ) { assert . be not null ( declaration ) ; final list < i variable bind > parameters= new array list < > ( declaration . parameter ( ) . size ( ) ) ; for ( final iterator < single variable declaration > iterator= declaration . parameter ( ) . iterator ( ) ; iterator . have next ( ) ; ) { variable declaration variable= iterator . next ( ) ; i variable binding binding= variable . resolve binding ( ) ; if ( bind == null ) return new i variable bind [ 0 ] ; parameter . add ( bind ) ; } final i variable bind [ ] result= new i variable bind [ parameter . size ( ) ] ; parameter . to array ( result ) ; return result ; }
public boolean be java lang cloneable ( ) { return false ; }
public final boolean be local ( ) { return ( f flag & f_is_local ) ! = 0 ; }
public final boolean be anonymous ( ) { return ( f flag & f_is_anonymous ) ! = 0 ; }
public final boolean be anonymous ( ) { return ( f flag & f_is_anonymous ) ! = 0 ; }
public static boolean be java lang type ( class type ) { string type name = type . get name ( ) ; return be java lang type ( type name ) ; }
public static refactoring status context create ( i type root type root , selection selection ) { i source range range= null ; if ( selection ! = null ) range= new source range ( selection . get offset ( ) , selection . get length ( ) ) ; return create ( type root , range ) ; }
public static boolean overlap ( text edit edit1 , text edit edit2 ) { if ( edit1 instanceof multi text edit & & edit2 instanceof multi text edit ) { multi text edit multi text edit1= ( multi text edit ) edit1 ; if ( ! multi text edit1 . have child ( ) ) return false ; multi text edit multi text edit2= ( multi text edit ) edit2 ; if ( ! multi text edit2 . have child ( ) ) return false ; text edit [ ] children1= multi text edit1 . get child ( ) ; text edit [ ] children2= multi text edit2 . get child ( ) ; int i1= 0 ; int i2= 0 ; while ( i1 < children1 . length & & i2 < children2 . length ) { while ( children1 [ i1 ] . get exclusive end ( ) < children2 [ i2 ] . get offset ( ) ) { i1++ ; if ( i1 > = children1 . length ) return false ; } while ( children2 [ i2 ] . get exclusive end ( ) < children1 [ i1 ] . get offset ( ) ) { i2++ ; if ( i2 > = children2 . length ) return false ; } if ( children1 [ i1 ] . get exclusive end ( ) < children2 [ i2 ] . get offset ( ) ) continue ; if ( overlap ( children1 [ i1 ] , children2 [ i2 ] ) ) return true ; int merge end= math . max ( children1 [ i1 ] . get exclusive end ( ) , children2 [ i2 ] . get exclusive end ( ) ) ; i1++ ; i2++ ; if ( i1 < children1 . length & & children1 [ i1 ] . get offset ( ) < merge end ) { return true ; } if ( i2 < children2 . length & & children2 [ i2 ] . get offset ( ) < merge end ) { return true ; } } return false ; } else if ( edit1 instanceof multi text edit ) { multi text edit multi text edit1= ( multi text edit ) edit1 ; if ( ! multi text edit1 . have child ( ) ) return false ; text edit [ ] children= multi text edit1 . get child ( ) ; int i= 0 ; while ( child [ i ] . get exclusive end ( ) < edit2 . get offset ( ) ) { i++ ; if ( i > = child . length ) return false ; } if ( overlap ( child [ i ] , edit2 ) ) return true ; return false ; } else if ( edit2 instanceof multi text edit ) { multi text edit multi text edit2= ( multi text edit ) edit2 ; if ( ! multi text edit2 . have child ( ) ) return false ; text edit [ ] children= multi text edit2 . get child ( ) ; int i= 0 ; while ( child [ i ] . get exclusive end ( ) < edit1 . get offset ( ) ) { i++ ; if ( i > = child . length ) return false ; } if ( overlap ( child [ i ] , edit1 ) ) return true ; return false ; } else { int start1= edit1 . get offset ( ) ; int end1= start1 + edit1 . get length ( ) ; int start2= edit2 . get offset ( ) ; int end2= start2 + edit2 . get length ( ) ; if ( start1 > end2 ) return false ; if ( start2 > end1 ) return false ; return true ; } }
protect final void reload header ( ) { this . output . initialize header ( ) ; if ( context instanceof default parse context ) { ( ( default parse context ) context ) . reset ( ) ; } }
public static string get upper bound ( string signature ) { return string . value of ( get upper bound ( signature . to char array ( ) ) ) ; }
public i method find overridden method in type ( i type overridden type , i method override ) throw java model exception { int flags= override . get flags ( ) ; if ( flag . be private ( flag ) || flag . be static ( flag ) || override . be constructor ( ) ) return null ; for ( i method overridden : overridden type . get method ( ) ) { flags= overridden . get flags ( ) ; if ( flag . be private ( flag ) || flag . be static ( flag ) || overridden . be constructor ( ) ) continue ; if ( be subsignature ( override , overridden ) ) { return overridden ; } } return null ; }
public static i status check in sync ( i resource [ ] resource ) { i status result= null ; for ( i resource resource : resource ) { if ( ! resource . be synchronize ( i resource . depth_infinite ) ) { result= add out of sync ( result , resource ) ; } } if ( result ! = null ) return result ; return status . ok_status ; }
public static boolean be file u r i ( uri uri ) { return scheme_file . equal ignore case ( uri . get scheme ( ) ) ; }
protect < t > type converter find type converter ( class < ? > source type , class < t > target type , string format annotation ) { type converter type converter = unconvertible ; list < class > source hierarchy = class utils . resolve hierarchy ( source type ) ; list < class > target hierarchy = class utils . resolve hierarchy ( target type ) ; for ( class source super type : source hierarchy ) { for ( class target super type : target hierarchy ) { convertible pair pair = new convertible pair ( source super type , target super type , format annotation ) ; type converter = type converter . get ( pair ) ; if ( type converter ! = null ) { converter cache . put ( pair , type converter ) ; return type converter ; } } } boolean have format = format annotation ! = null ; if ( have formatting ) { for ( class source super type : source hierarchy ) { for ( class target super type : target hierarchy ) { convertible pair pair = new convertible pair ( source super type , target super type ) ; type converter = type converter . get ( pair ) ; if ( type converter ! = null ) { converter cache . put ( pair , type converter ) ; return type converter ; } } } } return type converter ; }
public void set severity ( final int severity ) { assert . be true ( severity == refactoring status . warn || severity == refactoring status . info || severity == refactoring status . fatal || severity == refactoring status . error ) ; f severity= severity ; }
protect int compute index in position list ( list < ? extend position > position , int offset ) { return compute index in position list ( position , offset , true ) ; }
public boolean be leaf ( ) { return ! ( be composite ( boundable1 ) || be composite ( boundable2 ) ) ; }
public void add string pool participant ( i string pool participant participant , i scheduling rule rule ) { participant . put ( participant , rule ) ; if ( get state ( ) == job . sleep ) wake up ( initial_delay ) ; else schedule ( initial_delay ) ; }
public static void log ( string message ) { log ( new status ( i status . error , get unique identifier ( ) , i status . error , message , null ) ) ; }
public static x m l reader get x m l reader ( ) throw build exception { try { return new s a x parser ( get parser factory ( ) ) . get x m l reader ( ) ; } catch ( s a x exception e ) { throw convert to build exception ( e ) ; } }
public annotation [ ] get annotation ( ) { if ( f class == null ) { return new annotation [ 0 ] ; } return f class . get annotation ( ) ; }
public string [ ] get extension dirs ( ) { return f extension dirs ; }
protect void fire terminate event ( ) { debug plugin manager= debug plugin . get default ( ) ; if ( manager ! = null ) { manager . fire debug event set ( new debug event [ ] { new debug event ( this , debug event . terminate ) } ) ; } }
public void add v m ( i v m install vm ) { if ( ! f v m list . contains ( vm ) ) { i v m install type vm install type = vm . get v m install type ( ) ; list < i v m install > vm list = f v m type to v m map . get ( vm install type ) ; if ( vm list == null ) { vm list = new array list < > ( 3 ) ; f v m type to v m map . put ( vm install type , vm list ) ; } vm list . add ( vm ) ; file install location = vm . get install location ( ) ; if ( install location == null || vm install type . validate install location ( install location ) . get severity ( ) == i status . error ) { f invalid v m list . add ( vm ) ; } f v m list . add ( vm ) ; } }
public void set system id ( string url ) { system id = url ; builder . set system id ( url ) ; super . set document locator ( new locator ( ) { public int get column number ( ) { return -1 ; } public int get line number ( ) { return -1 ; } public string get public id ( ) { return null ; } public string get system id ( ) { return system id ; } } ) ; }
public attribute get ( string key ) { return map . get ( key ) ; }
protected process exec ( string [ ] cmd line , file work directory ) throw core exception { cmd line = quote window args ( cmd line ) ; return debug plugin . exec ( cmd line , work directory ) ; }
public url get default javadoc location ( file install location ) { return null ; }
public object leave shift ( final object new value ) { append node ( new value ) ; return this ; }
public t get old value ( ) { return old value ; }
public static zip file get zip file ( string name ) throw i o exception { synchronize ( fg zip file cache ) { if ( fg cleaner == null ) { fg cleaner = new archive cleaner ( ) ; debug plugin . get default ( ) . get launch manager ( ) . add launch listener ( fg cleaner ) ; resource plugin . get workspace ( ) . add resource change listener ( fg cleaner , i resource change event . pre_delete | i resource change event . pre_close ) ; } zip file zip = fg zip file cache . get ( name ) ; if ( zip == null ) { zip = new zip file ( name ) ; fg zip file cache . put ( name , zip ) ; } return zip ; } }
public refactoring status get condition status ( ) { return f precondition status ; }
public boolean remove ( change change ) { assert . be not null ( change ) ; boolean result= f change . remove ( change ) ; if ( result ) { change . set parent ( null ) ; } return result ; }
public change [ ] clear ( ) { change [ ] result= f change . to array ( new change [ f change . size ( ) ] ) ; f change . clear ( ) ; return result ; }
public int get event type ( ) { return f event type ; }
public boolean be update reference ( ) { return f update reference ; }
public refactoring processor get processor ( ) { return f processor ; }
public boolean be process ( object element ) { return f process element . contains ( element ) ; }
public void add listener ( file change listener file change listener ) { assert . not null ( file change listener , `` file change listener must not be null `` ) ; synchronize ( this . monitor ) { check not start ( ) ; this . listener . add ( file change listener ) ; } }
public refactoring status get status ( ) { return f status ; }
protect refactoring tick provider do get refactoring tick provider ( ) { return refactoring tick provider . default ; }
protect refactoring create refactoring ( final refactoring descriptor descriptor , final refactoring status status ) throw core exception { assert . be not null ( descriptor ) ; return descriptor . create refactoring ( status ) ; }
public void set destination ( i container destination ) { assert . be not null ( destination ) ; f destination= destination ; }
public void set keep preview edits ( boolean keep ) { f track edits= keep ; }
public final void set save mode ( final int mode ) { f save mode= mode ; }
public final boolean need save ( ) { return ( f save mode & text file change . force_save ) ! = 0 || ! f dirty & & ( f save mode & text file change . keep_save_state ) ! = 0 ; }
public static string get date for header ( ) { calendar cal = calendar . get instance ( ) ; time zone tz = cal . get time zone ( ) ; int offset = tz . get offset ( cal . get ( calendar . era ) , cal . get ( calendar . year ) , cal . get ( calendar . month ) , cal . get ( calendar . day_of_month ) , cal . get ( calendar . day_of_week ) , cal . get ( calendar . millisecond ) ) ; string buffer tz marker = new string buffer ( offset < 0 ? `` - `` : `` + `` ) ; offset = math . ab ( offset ) ; int hour = offset / ( 60 * 60 * 1000 ) ; int minute = offset / ( 60 * 1000 ) - 60 * hour ; if ( hour < 10 ) { tz marker . append ( `` 0 `` ) ; } tz marker . append ( hour ) ; if ( minute < 10 ) { tz marker . append ( `` 0 `` ) ; } tz marker . append ( minute ) ; return date_header_format . format ( cal . get time ( ) ) + tz marker . to string ( ) ; }
public resource get resource ( string name ) { return new file resource ( d dir , name ) ; }
public void add delete ( i resource delete ) { if ( f delete == null ) f delete= new array list < > ( 2 ) ; f delete . add ( delete ) ; if ( f ignore count == 0 ) { internal add ( new delete description ( delete ) ) ; } }
public string get namespace ( class loader loader ) { class loader weave adaptor weave adaptor = ( class loader weave adaptor ) weaver container . get weaver ( loader , weave context ) ; return weave adaptor . get namespace ( ) ; }
public executor get start level executor ( ) { return default executor ; }
final public long get timestamp ( ) { read lock ( ) ; try { return all time stamp . get ( ) ; } finally { read unlock ( ) ; } }
public list < module capability > find capability ( requirement requirement ) { namespace set namespace set = namespace set . get ( requirement . get namespace ( ) ) ; if ( namespace set == null ) { return collection . empty list ( ) ; } return namespace set . find capability ( requirement ) ; }
public final string get bundle symbolic name ( ) { return bundle symbolic name ; }
public list < v > value ( ) throw interrupted exception { final list < v > entries = new array list < > ( map . size ( ) ) ; for ( final entry < k , singleton holder < v > > ent : map . entry set ( ) ) { final v entry value = ent . get value ( ) . get ( ) ; if ( entry value ! = null ) { entry . add ( entry value ) ; } } return entry ; }
public boolean exists ( final file file ) { if ( system . get security manager ( ) == null ) return file . exists ( ) ; return access controller . do privilege ( new privilege action < boolean > ( ) { @ override public boolean run ( ) { return file . exists ( ) ? boolean . true : boolean . false ; } } , control context ) . boolean value ( ) ; }
public type get component ( ) { if ( this . clazz == null || ! this . clazz . be array ( ) ) return null ; ct class component ; try { component = this . clazz . get component type ( ) ; } catch ( not find exception e ) { throw new runtime exception ( e ) ; } type type = ( type ) prim . get ( component ) ; return ( type ! = null ) ? type : new type ( component ) ; }
public static < t > collection < t > a collection ( final iterator < ? extend t > iter ) { list < t > l = new array list < t > ( ) ; while ( iter . have next ( ) ) { l . add ( iter . next ( ) ) ; } return l ; }
public static message digest get digest ( final string algorithm , final message digest default message digest ) { try { return message digest . get instance ( algorithm ) ; } catch ( final exception e ) { return default message digest ; } }
public static predicate < path > be regular file ( link option . . . option ) { final link option [ ] option copy = option . clone ( ) ; return new predicate < path > ( ) { @ override public boolean apply ( path input ) { return file . be regular file ( input , option copy ) ; } @ override public string to string ( ) { return `` more file . be regular file ( `` + array . to string ( option copy ) + `` ) `` ; } } ; }
public collection < string > get o s name alias ( string osname ) { return get alias ( osname . to lower case ( ) , osname alias table ) ; }
public configuration get container configuration ( ) { return container configuration ; }
public bundle entry find entry ( string path ) { for ( bundle file mr file : mr bundle file ) { bundle entry mr entry = mr file . get entry ( path ) ; if ( mr entry ! = null ) { return mr entry ; } } return bundlefile . get entry ( path ) ; }
public void close ( ) { for ( classpath entry entry : entry ) { try { entry . close ( ) ; } catch ( i o exception e ) { generation . get bundle info ( ) . get storage ( ) . get adaptor ( ) . publish container event ( container event . error , generation . get revision ( ) . get revision ( ) . get module ( ) , e ) ; } } }
public void add permission ( final type permission permission ) { if ( permission . equal ( no type permission . none ) || permission . equal ( any type permission . any ) ) permission . clear ( ) ; permission . add ( 0 , permission ) ; }
public boolean remove ( object key ) { boolean be remove = false ; if ( key ! = null ) { this . dictionary . remove ( key ) ; be remove = true ; } if ( be remove ) { this . change ( ) ; } return be remove ; }
public bundle [ ] get use bundle ( ) { return registration . get use bundle ( ) ; }
public void remove service event listener ( storage service event listener listener ) { if ( listener ! = null ) { service event listener . remove ( listener ) ; } }
public version range result add version ( version version ) { if ( version . be empty ( ) ) { version = new array list < version > ( ) ; } version . add ( version ) ; return this ; }
public final int get micro ( ) { return nano / 1000 ; }
public version get maximum ( ) { version right = get right ( ) ; return right == null ? version max : right ; }
public boolean get include minimum ( ) { return get leave type ( ) == version range . left_closed ; }
public boolean be empty ( ) { if ( fast ) { return ( map . be empty ( ) ) ; } else { synchronize ( map ) { return ( map . be empty ( ) ) ; } } }
public string to string ( ) { string builder result = new string builder ( `` [ `` ) ; if ( be printable ( start ) ) result . append ( `` ' `` ) . append ( ( char ) start ) . append ( `` ' `` ) ; else result . append ( start ) ; if ( start ! = end ) { result . append ( `` - `` ) ; if ( be printable ( end ) ) result . append ( `` ' `` ) . append ( ( char ) end ) . append ( `` ' `` ) ; else result . append ( end ) ; } result . append ( `` ] `` ) ; return result . to string ( ) ; }
public boolean equal ( object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof condition info ) ) { return false ; } condition info other = ( condition info ) obj ; if ( ! type . equal ( other . type ) || args . length ! = other . args . length ) return false ; for ( int i = 0 ; i < args . length ; i++ ) { if ( ! args [ i ] . equal ( other . args [ i ] ) ) return false ; } return true ; }
protect i line tracker get tracker ( ) { assert . be not null ( f tracker ) ; return f tracker ; }
protect void write string ( string text ) throw i o exception { / * * dom store \n at the end of text node that be newlines . this be * significant if we be in a pre section . however , we only want to * output the system line . separator , not \n . this be a little brittle , * but this function appear to be call with these lineseparators a a * separate text_node . if we be in a preformatted section , output the * right line . separator , otherwise ditch . if the single \n character be * not the text , then do the super thing to output the text . * * also , we store the last text that be not a \n since it may be use * by write element in this class to line up preformatted tag . * / if ( text . equal ( `` \n `` ) ) { if ( ! format stack . empty ( ) ) { super . write string ( line separator ) ; } return ; } last text = text ; if ( format stack . empty ( ) ) { super . write string ( text . trim ( ) ) ; } else { super . write string ( text ) ; } }
public static void cancel manager ( i document document ) { link mode manager mgr= fg manager . get ( document ) ; if ( mgr ! = null ) mgr . close all environment ( ) ; }
public void stop listening for preference change ( ) { if ( f property listener ! = null ) { f preference store . remove preference change listener ( f property listener ) ; f property listener= null ; } }
public void set parent ( @ nullable application context parent ) { this . parent = parent ; if ( parent ! = null ) { environment parent environment = parent . get environment ( ) ; if ( parent environment instanceof configurable environment ) { get environment ( ) . merge ( ( configurable environment ) parent environment ) ; } } }
public int [ ] get tab stop position ( ) { return _props . get rgdxa tab ( ) ; }
public link position find position ( link position to find ) { link position position= null ; for ( link position group group : f group ) { position= group . get position ( to find ) ; if ( position ! = null ) break ; } return position ; }
public boolean be contain ( int off , int len ) { synchronize ( f lock ) { return ! be delete ( ) & & off < = get offset ( ) & & off + len > = get offset ( ) + get length ( ) ; } }
public int get sequence number ( ) { return f sequence number ; }
public boolean be valid ( ) { if ( bytes == null ) { throw new illegal state exception ( `` byte be null `` ) ; } if ( length < 0 ) { throw new illegal state exception ( `` length be negative : `` + length ) ; } if ( length > byte . length ) { throw new illegal state exception ( `` length be out of bound : `` + length + `` , bytes . length= `` + byte . length ) ; } if ( offset < 0 ) { throw new illegal state exception ( `` offset be negative : `` + offset ) ; } if ( offset > byte . length ) { throw new illegal state exception ( `` offset out of bound : `` + offset + `` , bytes . length= `` + byte . length ) ; } if ( offset + length < 0 ) { throw new illegal state exception ( `` offset+length be negative : offset= `` + offset + `` , length= `` + length ) ; } if ( offset + length > byte . length ) { throw new illegal state exception ( `` offset+length out of bound : offset= `` + offset + `` , length= `` + length + `` , bytes . length= `` + byte . length ) ; } return true ; }
public i region get region ( ) { int size= f edits . size ( ) ; if ( size == 0 ) { return null ; } else if ( size == 1 ) { return f edits . get ( 0 ) . get region ( ) ; } else { return text edit . get coverage ( f edits . to array ( new text edit [ f edits . size ( ) ] ) ) ; } }
protect void fire document change ( document event event ) { update document structure ( event ) ; if ( f stop listener notification == 0 ) do fire document change ( event ) ; else f deferred document event= event ; }
public member order preference cache common get member order preference cache common ( ) { if ( f member order preference cache common == null ) { f member order preference cache common= new member order preference cache common ( ) ; } return f member order preference cache common ; }
protect void offset ( int offset ) { super . offset ( offset ) ; offset range ( this . f initializer range , offset ) ; offset range ( this . f type range , offset ) ; }
public void add protocol resolver ( protocol resolver resolver ) { assert . not null ( resolver , `` protocol resolver must not be null `` ) ; this . protocol resolvers . add ( resolver ) ; }
public void validate ( string pattern ) throw template exception { template translator translator= new template translator ( ) ; template buffer buffer= translator . translate ( pattern ) ; validate variable ( buffer . get variable ( ) ) ; }
public string get type ( ) { return f type . get name ( ) ; }
public string get name ( ) { if ( f class == null ) { return `` null `` ; } return f class . get name ( ) ; }
public void set target edit ( copy target edit edit ) throw malformed tree exception { assert . be not null ( edit ) ; if ( f target ! = edit ) { f target= edit ; f target . set source edit ( this ) ; } }
public final text edit [ ] get child ( ) { if ( f child == null ) return empty_array ; return f child . to array ( new text edit [ f child . size ( ) ] ) ; }
public text edit get preview edit ( text edit original ) { assert . be true ( get keep preview edits ( ) & & f copier ! = null & & original ! = null ) ; return f copier . get copy ( original ) ; }
public text edit get preview edit ( text edit original ) { assert . be true ( get keep preview edits ( ) & & f copier ! = null & & original ! = null ) ; return f copier . get copy ( original ) ; }
public final text edit get root ( ) { text edit result= this ; while ( result . f parent ! = null ) { result= result . f parent ; } return result ; }
public boolean visit ( move target edit edit ) { return visit node ( edit ) ; }
public boolean visit ( insert edit edit ) { return visit node ( edit ) ; }
public boolean be delete content ( ) { return f delete content ; }
public void stop listening for preference change ( ) { if ( f property listener ! = null ) { f preference store . remove preference change listener ( f property listener ) ; f property listener= null ; } }
public synchronize code template [ ] get template ( ) { code template [ ] temp = new code template [ template . size ( ) ] ; return template . to array ( temp ) ; }
public final dynamic template find dynamic template ( string field name , dynamic template . x content field type match type ) { final string path a string = path ( ) . path a text ( field name ) ; final string match template name = source to parse ( ) . dynamic template ( ) . get ( path a string ) ; for ( dynamic template template : root ( ) . dynamic template ( ) ) { if ( template . match ( match template name , path a string , field name , match type ) ) { return template ; } } if ( match template name ! = null ) { throw new mapper parse exception ( `` ca n't find dynamic template for dynamic template name [ `` + match template name + `` ] of field [ `` + path a string + `` ] `` ) ; } return null ; }
public template find template by id ( string id ) { template persistence data data= get template data ( id ) ; if ( data ! = null & & ! data . be delete ( ) ) return data . get template ( ) ; return null ; }
public string get action ( ) { if ( action == null ) { return `` `` ; } else { return action ; } }
public boolean equal ( object obj ) { if ( obj == this ) { return true ; } else if ( obj instanceof folder id ) { folder id other = ( folder id ) obj ; if ( this . folder name ! = null ) { if ( other . folder name ! = null & & this . folder name . equal ( other . folder name ) ) { if ( this . mailbox ! = null ) { return this . mailbox . equal ( other . mailbox ) ; } else if ( other . mailbox == null ) { return true ; } } } else if ( super . equal ( other ) ) { return true ; } return false ; } else { return false ; } }
public int hash code ( ) { int hash = 0 ; if ( null ! = name ) { hash += name . hash code ( ) ; } if ( null ! = public u r i ) { hash += public u r i . hash code ( ) ; } if ( null ! = system u r i ) { hash += system u r i . hash code ( ) ; } return hash ; }
public void set stroke color ( p d color color ) throw i o exception { if ( stroke color space stack . be empty ( ) || stroke color space stack . peek ( ) ! = color . get color space ( ) ) { write operand ( get name ( color . get color space ( ) ) ) ; write operator ( `` cs `` ) ; set stroke color space stack ( color . get color space ( ) ) ; } for ( float value : color . get component ( ) ) { write operand ( value ) ; } if ( color . get color space ( ) instanceof p d pattern ) { write operand ( color . get pattern name ( ) ) ; } if ( color . get color space ( ) instanceof p d pattern || color . get color space ( ) instanceof p d separation || color . get color space ( ) instanceof p d device n || color . get color space ( ) instanceof p d i c c base ) { write operator ( `` scn `` ) ; } else { write operator ( `` sc `` ) ; } }
public c o s dictionary get image parameter ( ) { return image parameter ; }
protect final stack < p d graphic state > save graphic stack ( ) { stack < p d graphic state > save stack = graphic stack ; graphic stack = new stack < p d graphic state > ( ) ; graphic stack . add ( save stack . peek ( ) . clone ( ) ) ; return save stack ; }
public static void clear ( ) { class_to_elected_fields . clear ( ) ; dictionary_fields . clear ( ) ; field_to_cache_hit . clear ( ) ; field_to_nb_reset . clear ( ) ; dictionary_array . clear ( ) ; class_to_cache_hit . clear ( ) ; }
public list < object > get kid ( ) { list < object > kid object = new array list < object > ( ) ; c o s base k = this . get c o s object ( ) . get dictionary object ( c o s name . k ) ; if ( k instanceof c o s array ) { for ( c o s base kid : ( ( c o s array ) k ) ) { object kid object = this . create object ( kid ) ; if ( kid object ! = null ) { kid object . add ( kid object ) ; } } } else { object kid object = this . create object ( k ) ; if ( kid object ! = null ) { kid object . add ( kid object ) ; } } return kid object ; }
public string get name ( int index , string default value ) { string retval = default value ; if ( index < size ( ) ) { object obj = object . get ( index ) ; if ( obj instanceof c o s name ) { retval = ( ( c o s name ) obj ) . get name ( ) ; } } return retval ; }
public string get set ( string index , string set ) { setting index setting = setting . get ( index ) ; if ( set ! = null ) { if ( index setting ! = null & & index setting . have value ( set ) ) { return index setting . get ( set ) ; } else { setting default index setting = default setting . get ( index ) ; if ( default index setting ! = null ) { return default index setting . get ( set ) ; } else { return null ; } } } else { return null ; } }
public static value boolean get ( boolean b ) { return ( value boolean ) ( b ? true : false ) ; }
public c o s name get c o s name ( c o s name key , c o s name default value ) { c o s base name = get dictionary object ( key ) ; if ( name instanceof c o s name ) { return ( c o s name ) name ; } return default value ; }
public c o s base get item ( c o s name key ) { c o s base retval =null ; if ( base object instanceof c o s dictionary ) { retval = ( ( c o s dictionary ) base object ) . get item ( key ) ; } return retval ; }
public c o s array get document i d ( ) { return ( c o s array ) get trailer ( ) . get dictionary object ( c o s name . id ) ; }
public static byte [ ] serialize ( object obj ) { try { if ( serializer ! = null ) { return serializer . serialize ( obj ) ; } byte array output stream out = new byte array output stream ( ) ; object output stream o = new object output stream ( out ) ; o . write object ( obj ) ; return out . to byte array ( ) ; } catch ( throwable e ) { throw db exception . get ( error code . serialization_failed_1 , e , e . to string ( ) ) ; } }
public rectangle get source region ( ) { return source region ; }
public void set subsampling offset x ( int s offset x ) { this . subsampling offset x = s offset x ; }
public void set process temp file dir ( file process temp file dir ) { this . process temp file dir = process temp file dir ; }
public random access create buffer ( input stream input ) throw i o exception { scratch file buffer buf = new scratch file buffer ( this ) ; byte [ ] byte buffer = new byte [ 8192 ] ; int bytes read = 0 ; while ( ( bytes read = input . read ( byte buffer ) ) > -1 ) { buf . write ( byte buffer , 0 , byte read ) ; } buf . seek ( 0 ) ; return buf ; }
public void set first page overlay p d f ( p d document first page overlay p d f ) { first page overlay = first page overlay p d f ; }
public void set even page overlay p d f ( p d document even page overlay p d f ) { even page overlay = even page overlay p d f ; }
public list < p d document > split ( p d document document ) throw i o exception { destination document = new array list < p d document > ( ) ; source document = document ; process page ( ) ; return destination document ; }
public void add source ( list < input stream > source list ) { source . add all ( source list ) ; }
public void set start ( int start ) { if ( start < = 0 ) { throw new illegal argument exception ( `` the page number start value must be a positive integer `` ) ; } root . set int ( key_start , start ) ; }
protect p d document create document ( ) throw i o exception { return new p d document ( document , source , get access permission ( ) ) ; }
public c o s document get document ( ) throw i o exception { if ( document == null ) { throw new i o exception ( `` you must parse the document first before call get document ( ) `` ) ; } return document ; }
public p d document create p d f from text ( reader text ) throw i o exception { p d document doc = new p d document ( ) ; create p d f from text ( doc , text ) ; return doc ; }
public final c o s dictionary get first trailer ( ) { if ( byte po to xref map . be empty ( ) ) { return null ; } set < long > offset = byte po to xref map . key set ( ) ; sort set < long > sort offset = new tree set < long > ( offset ) ; return byte po to xref map . get ( sort offset . first ( ) ) . trailer ; }
protect void reset ( ) { for ( xref trailer obj trailer obj : byte po to xref map . value ( ) ) { trailer obj . reset ( ) ; } cur xref trailer obj = null ; resolve xref trailer = null ; }
protect void do write header ( c o s document doc ) throw i o exception { if ( be compress ( ) ) { doc . set version ( math . max ( doc . get version ( ) , c o s writer compression pool . minimum_supported_version ) ) ; } string header string ; if ( fdf document ! = null ) { header string = `` % fdf- `` + doc . get version ( ) ; } else { header string = `` % pdf- `` + doc . get version ( ) ; } get standard output ( ) . write ( header string . get byte ( standard charsets . iso_8859_1 ) ) ; get standard output ( ) . write e o l ( ) ; get standard output ( ) . write ( comment ) ; get standard output ( ) . write ( garbage ) ; get standard output ( ) . write e o l ( ) ; }
public string get file unix ( ) { return f . get string ( c o s name . unix ) ; }
public void set embed file ( p d embed file file ) { c o s dictionary ef = get e f dictionary ( ) ; if ( ef == null & & file ! = null ) { ef = new c o s dictionary ( ) ; f . set item ( c o s name . ef , ef ) ; } if ( ef ! = null ) { ef . set item ( c o s name . f , file ) ; } }
public void set subtype ( string sub type ) { get c o s object ( ) . set name ( c o s name . subtype , sub type ) ; }
public calendar get creation date ( ) throw i o exception { return get c o s object ( ) . get embedded date ( `` params `` , `` creation date `` ) ; }
public string get mac subtype ( ) { string retval = null ; c o s dictionary params = ( c o s dictionary ) get c o s object ( ) . get dictionary object ( c o s name . params ) ; if ( params ! = null ) { retval = params . get embedded string ( `` mac `` , `` subtype `` ) ; } return retval ; }
public void set bit per sample ( int bps ) { get c o s object ( ) . set int ( c o s name . bits_per_sample , bps ) ; }
public static object min ( comparable c1 , comparable c2 ) { if ( c1 ! = null & & c2 ! = null ) { return c1 . compare to ( c2 ) < 1 ? c1 : c2 ; } else { return c1 ! = null ? c1 : c2 ; } }
public number pop number ( ) { return ( number ) stack . pop ( ) ; }
public void add real ( float value ) { this . instruction . add ( value ) ; }
public static instruction sequence parse ( char sequence text ) { instruction sequence builder builder = new instruction sequence builder ( ) ; parser . parse ( text , builder ) ; return builder . get instruction sequence ( ) ; }
public void set number of object ( int n ) { get c o s object ( ) . set int ( c o s name . n , n ) ; }
public string [ ] get label by page index ( ) { final string [ ] map = new string [ doc . get number of page ( ) ] ; compute label ( new label handler ( ) { @ override public void new label ( int page index , string label ) { if ( page index < doc . get number of page ( ) ) { map [ page index ] = label ; } } } ) ; return map ; }
public float get low left x ( ) { return ( ( c o s number ) rect array . get ( 0 ) ) . float value ( ) ; }
public float get low left y ( ) { return ( ( c o s number ) rect array . get ( 1 ) ) . float value ( ) ; }
public list < c o s name > get filter ( ) { list < c o s name > retval = null ; c o s base filter = stream . get filter ( ) ; if ( filter instanceof c o s name ) { c o s name name = ( c o s name ) filter ; retval = new c o s array list < c o s name > ( name , name , stream , c o s name . filter ) ; } else if ( filter instanceof c o s array ) { retval = ( list < c o s name > ) ( ( c o s array ) filter ) . to list ( ) ; } return retval ; }
public void set metadata ( p d metadata meta ) { root . set item ( c o s name . metadata , meta ) ; }
public byte [ ] get owner key ( ) throw i o exception { byte [ ] o = null ; c o s string owner = ( c o s string ) dictionary . get dictionary object ( c o s name . o ) ; if ( owner ! = null ) { o = owner . get byte ( ) ; } return o ; }
public void set attribute ( revision < p d attribute object > attribute ) { c o s name key = c o s name . a ; if ( ( attribute . size ( ) == 1 ) & & ( attribute . get revision number ( 0 ) == 0 ) ) { p d attribute object attribute object = attribute . get object ( 0 ) ; attribute object . set structure element ( this ) ; this . get c o s object ( ) . set item ( key , attribute object ) ; return ; } c o s array array = new c o s array ( ) ; for ( int i = 0 ; i < attribute . size ( ) ; i++ ) { p d attribute object attribute object = attribute . get object ( i ) ; attribute object . set structure element ( this ) ; int revision number = attribute . get revision number ( i ) ; if ( revision number < 0 ) { throw new illegal argument exception ( `` the revision number shall be > -1 `` ) ; } array . add ( attribute object ) ; array . add ( c o s integer . get ( revision number ) ) ; } this . get c o s object ( ) . set item ( key , array ) ; }
public p d structure node get parent ( ) { c o s base base = this . get c o s object ( ) . get dictionary object ( c o s name . p ) ; if ( base instanceof c o s dictionary ) { return p d structure node . create ( ( c o s dictionary ) base ) ; } return null ; }
public void set alternate description ( string alternate description ) { this . get c o s object ( ) . set string ( c o s name . alt , alternate description ) ; }
public boolean be top attach ( ) { return this . be attach ( `` top `` ) ; }
public void set after colour ( p d gamma colour ) { this . set colour by index ( 1 , colour ) ; }
public p d gamma get background color ( ) { return this . get color ( background_color ) ; }
public void set background color ( p d gamma background color ) { this . set color ( background_color , background color ) ; }
public float get space before ( ) { return this . get number ( space_before , 0 . f ) ; }
public void set text align ( string text indent ) { this . set name ( text_align , text indent ) ; }
public void set border style ( border side side , border style style ) { get border ( side , true ) . set style ( s t border style . enum . for int ( style . ordinal ( ) + 1 ) ) ; }
public void set border style ( string [ ] border style ) { this . set array of name ( border_style , border style ) ; }
public p d gamma get text decoration color ( ) { return this . get color ( text_decoration_color ) ; }
public void set text decoration thickness ( float text decoration thickness ) { this . set number ( text_decoration_thickness , text decoration thickness ) ; }
public void set no orientation ( boolean orientation ) { if ( orientation ) { set orientation ( print orientation . default ) ; } }
public int get column count ( ) { return this . get integer ( column_count , 1 ) ; }
protect void set integer ( string name , int value ) { c o s base old base = this . get c o s object ( ) . get dictionary object ( name ) ; this . get c o s object ( ) . set int ( name , value ) ; c o s base new base = this . get c o s object ( ) . get dictionary object ( name ) ; this . potentially notify change ( old base , new base ) ; }
protect object get number or array of number ( string name , float default value ) { c o s base v = this . get c o s object ( ) . get dictionary object ( name ) ; if ( v instanceof c o s array ) { c o s array array = ( c o s array ) v ; float [ ] value = new float [ array . size ( ) ] ; for ( int i = 0 ; i < array . size ( ) ; i++ ) { c o s base item = array . get object ( i ) ; if ( item instanceof c o s number ) { value [ i ] = ( ( c o s number ) item ) . float value ( ) ; } } return value ; } if ( v instanceof c o s number ) { return ( ( c o s number ) v ) . float value ( ) ; } if ( default value == unspecified ) { return null ; } return default value ; }
protect void set number ( string name , int value ) { c o s base old base = this . get c o s object ( ) . get dictionary object ( name ) ; this . get c o s object ( ) . set int ( name , value ) ; c o s base new base = this . get c o s object ( ) . get dictionary object ( name ) ; this . potentially notify change ( old base , new base ) ; }
public final void set gamma ( p d gamma gamma ) { c o s array gamma array = null ; if ( gamma ! = null ) { gamma array = gamma . get c o s array ( ) ; } dictionary . set item ( c o s name . gamma , gamma array ) ; }
public boolean be readable ( ) { return ( this . file . can read ( ) & & ! this . file . be directory ( ) ) ; }
public void set can assemble document ( boolean allow assembly ) { if ( ! read only ) { set permission bit ( assemble_document_bit , allow assembly ) ; } }
public p d crypt filter dictionary get crypt filter dictionary ( c o s name crypt filter name ) { c o s dictionary crypt filter dictionary = ( c o s dictionary ) dictionary . get dictionary object ( c o s name . cf ) ; if ( crypt filter dictionary ! = null ) { c o s dictionary std crypt filter dictionary = ( c o s dictionary ) crypt filter dictionary . get dictionary object ( crypt filter name ) ; if ( std crypt filter dictionary ! = null ) { return new p d crypt filter dictionary ( std crypt filter dictionary ) ; } } return null ; }
public string get filter ( ) { return dictionary . get name a string ( c o s name . filter ) ; }
public void set revision ( int revision ) { dictionary . set int ( c o s name . r , revision ) ; }
public p d crypt filter dictionary get crypt filter dictionary ( c o s name crypt filter name ) { c o s dictionary crypt filter dictionary = ( c o s dictionary ) dictionary . get dictionary object ( c o s name . cf ) ; if ( crypt filter dictionary ! = null ) { c o s dictionary std crypt filter dictionary = ( c o s dictionary ) crypt filter dictionary . get dictionary object ( crypt filter name ) ; if ( std crypt filter dictionary ! = null ) { return new p d crypt filter dictionary ( std crypt filter dictionary ) ; } } return null ; }
public void set decryption certificate ( x509 certificate decryption certificate ) { this . decryption certificate = decryption certificate ; }
public void set key ( byte [ ] key ) { b = 0 ; c = 0 ; if ( key . length < 1 || key . length > 32 ) { throw new illegal argument exception ( `` number of byte must be between 1 and 32 `` ) ; } for ( int i = 0 ; i < salt . length ; i++ ) { salt [ i ] = i ; } int key index = 0 ; int salt index = 0 ; for ( int i = 0 ; i < salt . length ; i++ ) { salt index = ( fix byte ( key [ key index ] ) + salt [ i ] + salt index ) % 256 ; swap ( salt , i , salt index ) ; key index = ( key index + 1 ) % key . length ; } }
public boolean be invisible ( ) { return annot . get flag ( c o s name . f , flag_invisible ) ; }
public string get name ( ) { return annot . get string ( c o s name . nm ) ; }
public final void set rich content ( string rc ) { annot . set item ( c o s name . rc , new c o s string ( rc ) ) ; }
public void set border effect ( p d border effect dictionary be ) { get c o s object ( ) . set item ( c o s name . be , be ) ; }
public float [ ] [ ] get ink list ( ) { c o s array array = get c o s object ( ) . get c o s array ( c o s name . inklist ) ; if ( array ! = null ) { float [ ] [ ] ink list = new float [ array . size ( ) ] [ ] ; for ( int i = 0 ; i < array . size ( ) ; ++i ) { c o s base base2 = array . get object ( i ) ; if ( base2 instanceof c o s array ) { ink list [ i ] = ( ( c o s array ) array . get object ( i ) ) . to float array ( ) ; } else { ink list [ i ] = new float [ 0 ] ; } } return ink list ; } return new float [ 0 ] [ 0 ] ; }
public float get leader offset ( ) { return annot . get float ( c o s name . llo ) ; }
public float get caption vertical offset ( ) { float retval = 0 . f ; c o s array array = ( c o s array ) annot . get dictionary object ( c o s name . co ) ; if ( array ! = null ) { retval = array . to float array ( ) [ 1 ] ; } return retval ; }
public f d f dictionary get f d f ( ) { c o s dictionary fdf = ( c o s dictionary ) catalog . get dictionary object ( c o s name . fdf ) ; f d f dictionary retval ; if ( fdf ! = null ) { retval = new f d f dictionary ( fdf ) ; } else { retval = new f d f dictionary ( ) ; set f d f ( retval ) ; } return retval ; }
public string get target ( ) { return fdf . get string ( c o s name . target ) ; }
public list < p d file specification > get embed f d f ( ) throw i o exception { list < p d file specification > retval = null ; c o s array embedded array = ( c o s array ) fdf . get dictionary object ( c o s name . embedded_fdfs ) ; if ( embedded array ! = null ) { list < p d file specification > embed = new array list < p d file specification > ( ) ; for ( int i = 0 ; i < embedded array . size ( ) ; i++ ) { embed . add ( p d file specification . create f s ( embedded array . get ( i ) ) ) ; } retval = new c o s array list < p d file specification > ( embed , embedded array ) ; } return retval ; }
public f d f icon fit get icon fit ( ) { f d f icon fit retval = null ; c o s dictionary dic = ( c o s dictionary ) field . get dictionary object ( c o s name . if ) ; if ( dic ! = null ) { retval = new f d f icon fit ( dic ) ; } return retval ; }
public string get rich text ( ) { c o s base rv = field . get dictionary object ( c o s name . rv ) ; if ( rv == null ) { return null ; } else if ( rv instanceof c o s string ) { return ( ( c o s string ) rv ) . get string ( ) ; } else { return ( ( c o s stream ) rv ) . to text string ( ) ; } }
public void set file ( p d file specification f ) { fdf . set item ( c o s name . f , f ) ; }
public f d f name page reference get template reference ( ) { f d f name page reference retval = null ; c o s dictionary dict = ( c o s dictionary ) template . get dictionary object ( c o s name . tref ) ; if ( dict ! = null ) { retval = new f d f name page reference ( dict ) ; } return retval ; }
public static j w e algorithm parse ( final string s ) { if ( s . equal ( rsa1_5 . get name ( ) ) ) { return rsa1_5 ; } else if ( s . equal ( rsa_oaep . get name ( ) ) ) { return rsa_oaep ; } else if ( s . equal ( rsa_oaep_256 . get name ( ) ) ) { return rsa_oaep_256 ; } else if ( s . equal ( a128kw . get name ( ) ) ) { return a128kw ; } else if ( s . equal ( a192kw . get name ( ) ) ) { return a192kw ; } else if ( s . equal ( a256kw . get name ( ) ) ) { return a256kw ; } else if ( s . equal ( dir . get name ( ) ) ) { return dir ; } else if ( s . equal ( ecdh_es . get name ( ) ) ) { return ecdh_es ; } else if ( s . equal ( ecdh_es_a128kw . get name ( ) ) ) { return ecdh_es_a128kw ; } else if ( s . equal ( ecdh_es_a192kw . get name ( ) ) ) { return ecdh_es_a192kw ; } else if ( s . equal ( ecdh_es_a256kw . get name ( ) ) ) { return ecdh_es_a256kw ; } else if ( s . equal ( a128gcmkw . get name ( ) ) ) { return a128gcmkw ; } else if ( s . equal ( a192gcmkw . get name ( ) ) ) { return a192gcmkw ; } else if ( s . equal ( a256gcmkw . get name ( ) ) ) { return a256gcmkw ; } else if ( s . equal ( pbes2_hs256_a128kw . get name ( ) ) ) { return pbes2_hs256_a128kw ; } else if ( s . equal ( pbes2_hs384_a192kw . get name ( ) ) ) { return pbes2_hs384_a192kw ; } else if ( s . equal ( pbes2_hs512_a256kw . get name ( ) ) ) { return pbes2_hs512_a256kw ; } else { return new j w e algorithm ( s ) ; } }
public string code point to name ( int code point ) { string name = unicode to name . get ( new string ( new int [ ] { code point } , 0 , 1 ) ) ; if ( name == null ) { return `` . notdef `` ; } return name ; }
public void add font ( font info info , font box font font ) { cache . put ( info , new soft reference < font box font > ( font ) ) ; }
public synchronize font provider get provider ( ) { if ( font provider == null ) { set provider ( default font provider . instance ) ; } return font provider ; }
public void set w1y ( float w1y value ) { w1y = w1y value ; }
public c f f font get c f f font ( ) { if ( cid font ! = null ) { return cid font ; } else if ( t1 font instanceof c f f type1 font ) { return ( c f f type1 font ) t1 font ; } else { return null ; } }
public p d font get font ( ) throw i o exception { p d font retval = null ; c o s base font = font set . get object ( 0 ) ; if ( font instanceof c o s dictionary ) { retval = p d font factory . create font ( ( c o s dictionary ) font ) ; } return retval ; }
public string get sub type ( ) { return dict . get name a string ( c o s name . subtype ) ; }
public string get font family ( ) { string retval = null ; c o s string name = ( c o s string ) dic . get dictionary object ( c o s name . font_family ) ; if ( name ! = null ) { retval = name . get string ( ) ; } return retval ; }
public void set flag ( int flag ) { dic . set int ( c o s name . flag , flag ) ; this . flag = flag ; }
public float get italic angle ( ) { return dic . get float ( c o s name . italic_angle , 0 ) ; }
public float get cap height ( ) { return cap height ; }
public float get average width ( ) { return dic . get float ( c o s name . avg_width , 0 ) ; }
public void set guideline width ( float width ) { dictionary . set float ( c o s name . w , width ) ; }
public float get miss width ( ) { return dic . get float ( c o s name . missing_width , 0 ) ; }
public string get font family ( ) { string retval = null ; c o s string name = ( c o s string ) dic . get dictionary object ( c o s name . font_family ) ; if ( name ! = null ) { retval = name . get string ( ) ; } return retval ; }
public p d stream get c i d set ( ) { c o s objectable cid set = dic . get dictionary object ( c o s name . cid_set ) ; if ( cid set instanceof c o s stream ) { return new p d stream ( ( c o s stream ) cid set ) ; } return null ; }
public string get base font ( ) { return dict . get name a string ( c o s name . base_font ) ; }
public static glyph list get adobe glyph list ( ) { return default ; }
public type1 font get type1 font ( ) { return type1font ; }
public p d rectangle get font bounding box ( ) { c o s array rect = ( c o s array ) dic . get dictionary object ( c o s name . font_bbox ) ; p d rectangle retval = null ; if ( rect ! = null ) { retval = new p d rectangle ( rect ) ; } return retval ; }
public p d type3 char proc get char proc ( int code ) { string name = get encode ( ) . get name ( code ) ; c o s base base = get char procs ( ) . get dictionary object ( c o s name . get p d f name ( name ) ) ; if ( base instanceof c o s stream ) { return new p d type3 char proc ( this , ( c o s stream ) base ) ; } return null ; }
public final void set gamma ( p d gamma gamma ) { c o s array gamma array = null ; if ( gamma ! = null ) { gamma array = gamma . get c o s array ( ) ; } dictionary . set item ( c o s name . gamma , gamma array ) ; }
public iterable < c o s name > get pattern name ( ) { return get name ( c o s name . pattern ) ; }
public void add class name ( string class name ) { if ( class name == null ) { return ; } c o s name key = c o s name . c ; c o s base c = this . get c o s object ( ) . get dictionary object ( key ) ; c o s array array ; if ( c instanceof c o s array ) { array = ( c o s array ) c ; } else { array = new c o s array ( ) ; if ( c ! = null ) { array . add ( c ) ; array . add ( c o s integer . get ( 0 ) ) ; } } this . get c o s object ( ) . set item ( key , array ) ; array . add ( c o s name . get p d f name ( class name ) ) ; array . add ( c o s integer . get ( this . get revision number ( ) ) ) ; }
public float get r ( ) { return ( ( c o s number ) value . get ( 0 ) ) . float value ( ) ; }
public float get b ( ) { return ( ( c o s number ) value . get ( 2 ) ) . float value ( ) ; }
public static buffer image get r g b image ( p d image pd image , c o s array color key ) throw i o exception { return get r g b image ( pd image , null , 1 , color key ) ; }
public void set resource ( p d resource resource ) { get c o s object ( ) . set item ( c o s name . resource , resource ) ; }
public void set domain ( c o s array new domain ) { domain = new domain ; get c o s object ( ) . set item ( c o s name . domain , new domain ) ; }
public c o s array get coords ( ) { if ( coords == null ) { coords = ( c o s array ) get c o s object ( ) . get dictionary object ( c o s name . coords ) ; } return coords ; }
public int get bit per flag ( ) { return get c o s object ( ) . get int ( c o s name . bits_per_flag , -1 ) ; }
public void set smoothness tolerance ( float smoothness ) { set float item ( c o s name . sm , smoothness ) ; }
public c o s base get transfer ( ) { c o s base base = dict . get dictionary object ( c o s name . tr ) ; if ( base instanceof c o s array & & ( ( c o s array ) base ) . size ( ) ! = 4 ) { return null ; } return base ; }
public void set transfer ( c o s base transfer ) { dict . set item ( c o s name . tr , transfer ) ; }
public double get non stroke alpha constant ( ) { return non stroke alpha constant ; }
public void set alpha source ( boolean value ) { alpha source = value ; }
public void set non stroke overprint ( boolean value ) { non stroke overprint = value ; }
public double get overprint mode ( ) { return overprint mode ; }
protect final boolean be list state ( ) { return state text type . char at ( state ) == ' l ' ; }
public void replace text ( string p place holder , string p value ) { while ( true ) { string text = text ( ) ; int offset = text . index of ( p place holder ) ; if ( offset > = 0 ) { replace text ( p place holder , p value , offset ) ; } else { break ; } } }
public p d color get non stroke color ( ) { return non stroke color ; }
public void intersect clip path ( general path path ) { intersect clip path ( new area ( path ) ) ; }
public c o s array get function ( ) { if ( function == null ) { function = ( c o s array ) ( get c o s object ( ) . get dictionary object ( c o s name . function ) ) ; } return function ; }
public void set font size ( float font size ) { this . font size = font size ; lead = font size * 1 . 2f ; }
public p d page get page ( ) { p d page retval = null ; if ( array . size ( ) > 0 ) { c o s base page = array . get object ( 0 ) ; if ( page instanceof c o s dictionary ) { retval = new p d page ( ( c o s dictionary ) page ) ; } } return retval ; }
public boolean get repeat ( ) { c o s base base = action . get dictionary object ( c o s name . repeat ) ; if ( base instanceof c o s boolean ) { return ( ( c o s boolean ) base ) . get value ( ) ; } return false ; }
public p d action get d ( ) { c o s dictionary d = ( c o s dictionary ) action . get dictionary object ( c o s name . d ) ; p d action retval = null ; if ( d ! = null ) { retval = p d action factory . create action ( d ) ; } return retval ; }
public void set action ( p d action action ) { this . get c o s object ( ) . set item ( c o s name . a , action ) ; }
public p d color get interior color ( ) { return get color ( c o s name . ic ) ; }
public string get highlight mode ( ) { return get c o s object ( ) . get name a string ( c o s name . h , highlight_mode_invert ) ; }
public void set reply type ( string rt ) { get c o s object ( ) . set name ( `` rt `` , rt ) ; }
public p d border effect dictionary get border effect ( ) { c o s dictionary be = ( c o s dictionary ) get c o s object ( ) . get dictionary object ( c o s name . be ) ; if ( be ! = null ) { return new p d border effect dictionary ( be ) ; } else { return null ; } }
public p d appearance entry get normal appearance ( ) { c o s base entry = dictionary . get dictionary object ( c o s name . n ) ; if ( entry instanceof c o s dictionary ) { return new p d appearance entry ( entry ) ; } return null ; }
public void set action ( p d annotation additional action action ) { this . get c o s object ( ) . set item ( c o s name . aa , action ) ; }
public void set rollover caption ( string caption ) { this . get c o s object ( ) . set string ( c o s name . rc , caption ) ; }
public p d form x object get normal icon ( ) { c o s base i = this . get c o s object ( ) . get dictionary object ( c o s name . i ) ; if ( i instanceof c o s stream ) { return new p d form x object ( ( c o s stream ) i ) ; } return null ; }
public boolean be sub dictionary ( ) { return ! ( this . entry instanceof c o s stream ) ; }
public void set start point end style ( string style ) { if ( style == null ) { style = p d annotation line . le_none ; } c o s array array = ( c o s array ) annot . get dictionary object ( c o s name . le ) ; if ( array == null ) { array = new c o s array ( ) ; array . add ( c o s name . get p d f name ( style ) ) ; array . add ( c o s name . get p d f name ( p d annotation line . le_none ) ) ; annot . set item ( c o s name . le , array ) ; } else { array . set name ( 0 , style ) ; } }
public void set line dash pattern ( c o s array dash array ) { c o s array array = null ; if ( dash array ! = null ) { array = dash array ; } dictionary . set item ( c o s name . d , array ) ; }
public calendar get sign date ( ) { return dictionary . get date ( c o s name . m ) ; }
public void set sub filter require ( boolean flag ) { get c o s object ( ) . set flag ( c o s name . ff , flag_subfilter , flag ) ; }
public void set v require ( boolean flag ) { get c o s object ( ) . set flag ( c o s name . ff , flag_v , flag ) ; }
public void set reason ( string reason ) { dictionary . set string ( c o s name . reason , reason ) ; }
public void set subject d n require ( boolean flag ) { this . get c o s object ( ) . set flag ( c o s name . ff , flag_subject_dn , flag ) ; }
public list < byte [ ] > get issuer ( ) { c o s base base = this . dictionary . get dictionary object ( c o s name . issuer ) ; if ( base instanceof c o s array ) { c o s array array = ( c o s array ) base ; return get list of byte array from c o s array ( array ) ; } return null ; }
public void set timestamp require ( boolean flag ) { dictionary . set int ( c o s name . ft , flag ? 1 : 0 ) ; }
public void set sub filter ( string subfilter ) { dictionary . set name ( c o s name . sub_filter , subfilter ) ; }
public void set byte range ( int [ ] range ) { if ( range . length ! =4 ) { return ; } c o s array ary = new c o s array ( ) ; for ( int i : range ) { ary . add ( c o s integer . get ( i ) ) ; } dictionary . set item ( c o s name . byterange , ary ) ; }
public p d page get current page ( ) { return current page ; }
public void set destination ( p d page page ) { p d page x y z destination d = null ; if ( page ! = null ) { d = new p d page x y z destination ( ) ; d . set page ( page ) ; } set destination ( d ) ; }
public void set image form stream ( p d stream image form stream ) { this . image form stream = image form stream ; }
public boolean equal ( object other ) { if ( other == null ) { return false ; } if ( this . get class ( ) . equal ( other . get class ( ) ) ) { box resource other resource = ( box resource ) other ; return this . get i d ( ) . equal ( other resource . get i d ( ) ) ; } return false ; }
public void set right ( int x ) { array . grow to size ( 6 ) ; if ( x == -1 ) { array . set ( 4 , null ) ; } else { array . set int ( 4 , x ) ; } }
public void set top ( int y ) { array . grow to size ( 6 ) ; if ( y == -1 ) { array . set ( 5 , null ) ; } else { array . set int ( 5 , y ) ; } }
public void set action ( p d action action ) { this . get c o s object ( ) . set item ( c o s name . a , action ) ; }
public p d structure element get structure element ( ) { p d structure element se = null ; c o s dictionary dic = ( c o s dictionary ) get c o s object ( ) . get dictionary object ( c o s name . se ) ; if ( dic ! = null ) { se = new p d structure element ( dic ) ; } return se ; }
public void set default appearance ( string da value ) { dictionary . set string ( c o s name . da , da value ) ; }
public void set need appearance ( boolean value ) { dictionary . set boolean ( c o s name . need_appearances , value ) ; }
public boolean be push button ( ) { return get c o s object ( ) . get flag ( c o s name . ff , flag_pushbutton ) ; }
public void set option ( list < string > display value ) { if ( display value ! = null & & ! display value . be empty ( ) ) { if ( be sort ( ) ) { collection . sort ( display value ) ; } get c o s object ( ) . set item ( c o s name . opt , c o s array list . convert string list to c o s string c o s array ( display value ) ) ; } else { get c o s object ( ) . remove item ( c o s name . opt ) ; } }
public static list < string > string list value ( final string option ) { object object = option . option value . get ( option ) ; if ( object instanceof list < ? > ) { return ( list < string > ) object ; } return null ; }
public p d signature get value ( ) { c o s base value = get c o s object ( ) . get dictionary object ( c o s name . v ) ; if ( value == null ) { return null ; } return new p d signature ( ( c o s dictionary ) value ) ; }
public void set value ( int index ) throw i o exception { if ( get export value ( ) . be empty ( ) || index < 0 || index > = get export value ( ) . size ( ) ) { throw new illegal argument exception ( `` index ' `` + index + `` ' be not a valid index for the field `` + get fully qualify name ( ) + `` , valid index be from 0 to `` + ( get export value ( ) . size ( ) - 1 ) ) ; } update by value ( string . value of ( index ) ) ; apply change ( ) ; }
public void set value ( p d signature value ) throw i o exception { get c o s object ( ) . set item ( c o s name . v , value ) ; apply change ( ) ; }
public void set v require ( boolean flag ) { get c o s object ( ) . set flag ( c o s name . ff , flag_v , flag ) ; }
public void remove class name ( string class name ) { if ( class name == null ) { return ; } c o s name key = c o s name . c ; c o s base c = this . get c o s object ( ) . get dictionary object ( key ) ; c o s name name = c o s name . get p d f name ( class name ) ; if ( c instanceof c o s array ) { c o s array array = ( c o s array ) c ; array . remove ( name ) ; if ( ( array . size ( ) == 2 ) & & ( array . get int ( 1 ) == 0 ) ) { this . get c o s object ( ) . set item ( key , array . get object ( 0 ) ) ; } } else { c o s base direct c = c ; if ( c instanceof c o s object ) { direct c = ( ( c o s object ) c ) . get object ( ) ; } if ( name . equal ( direct c ) ) { this . get c o s object ( ) . set item ( key , null ) ; } } }
public string get default value ( ) { c o s base value = get inheritable attribute ( c o s name . dv ) ; if ( value instanceof c o s name ) { return ( ( c o s name ) value ) . get name ( ) ; } else { return `` `` ; } }
public static parameterized type parameterized type ( final class < ? > raw type , final type . . . actual type argument ) { return new parameterized type ( ) { @ override public type [ ] get actual type argument ( ) { return actual type argument ; } @ override public type get raw type ( ) { return raw type ; } @ override public type get owner type ( ) { return null ; } } ; }
public p d number format dictionary [ ] get distance ( ) { c o s array d = ( c o s array ) this . get c o s object ( ) . get dictionary object ( `` d `` ) ; if ( d ! = null ) { p d number format dictionary [ ] retval = new p d number format dictionary [ d . size ( ) ] ; for ( int i = 0 ; i < d . size ( ) ; i++ ) { c o s dictionary dic = ( c o s dictionary ) d . get ( i ) ; retval [ i ] = new p d number format dictionary ( dic ) ; } return retval ; } return null ; }
public void set name ( string name ) { get c o s object ( ) . set name ( c o s name . name , name ) ; }
public p d rectangle get rectangle ( ) { p d rectangle retval = null ; c o s array rect array = ( c o s array ) annot . get dictionary object ( c o s name . rect ) ; if ( rect array ! = null ) { retval = new p d rectangle ( rect array ) ; } return retval ; }
public final void set rectangle ( p d rectangle rectangle ) { annot . set item ( c o s name . rect , rectangle ) ; }
public boolean hide toolbar ( ) { return prefs . get boolean ( c o s name . hide_toolbar , false ) ; }
public boolean fit window ( ) { return prefs . get boolean ( c o s name . fit_window , false ) ; }
public string get print clip ( ) { return prefs . get name a string ( c o s name . print_clip , boundary . crop box . to string ( ) ) ; }
public void set print area ( boundary value ) { prefs . set name ( c o s name . print_area , value . to string ( ) ) ; }
public void add signature ( p d signature sig object ) throw i o exception { add signature ( sig object , new signature option ( ) ) ; }
public list < p d signature > get signature dictionary ( ) throw i o exception { list < p d signature > signatures = new array list < p d signature > ( ) ; for ( p d signature field field : get signature field ( ) ) { c o s base value = field . get c o s object ( ) . get dictionary object ( c o s name . v ) ; if ( value ! = null ) { signature . add ( new p d signature ( ( c o s dictionary ) value ) ) ; } } return signature ; }
public security handler new security handler for policy ( protection policy policy ) { class < ? extend security handler > handler class = policy to handler . get ( policy . get class ( ) ) ; if ( handler class == null ) { return null ; } class < ? > [ ] args class = { policy . get class ( ) } ; object [ ] args = { policy } ; return new security handler ( handler class , args class , args ) ; }
public resource cache get resource cache ( ) { return resource cache ; }
public void set viewer preference ( p d viewer preference prefs ) { root . set item ( c o s name . viewer_preferences , prefs ) ; }
public void set filter ( string filter ) { dictionary . set item ( c o s name . filter , c o s name . get p d f name ( filter ) ) ; }
public page mode get page mode ( ) { string mode = root . get name a string ( c o s name . page_mode ) ; if ( mode ! = null ) { try { return page mode . from string ( mode ) ; } catch ( illegal argument exception e ) { return page mode . use_none ; } } else { return page mode . use_none ; } }
public p d page label get page label ( ) throw i o exception { c o s dictionary dict = ( c o s dictionary ) root . get dictionary object ( c o s name . page_labels ) ; return dict == null ? null : new p d page label ( document , dict ) ; }
public void set trap ( string value ) { if ( value ! = null & & ! value . equal ( `` true `` ) & & ! value . equal ( `` false `` ) & & ! value . equal ( `` unknown `` ) ) { throw new runtime exception ( `` valid value for trap be `` + `` ' true ' , ' false ' , or ' unknown ' `` ) ; } info . set name ( c o s name . trap , value ) ; }
public p d thread bead get first bead ( ) { p d thread bead retval = null ; c o s dictionary bead = ( c o s dictionary ) thread . get dictionary object ( `` f `` ) ; if ( bead ! = null ) { retval = new p d thread bead ( bead ) ; } return retval ; }
public void save graphic state ( ) throw i o exception { if ( in text mode ) { log . warn ( `` save the graphic state be not allow within text object . `` ) ; } if ( ! font stack . be empty ( ) ) { font stack . push ( font stack . peek ( ) ) ; } if ( ! stroke color space stack . be empty ( ) ) { stroke color space stack . push ( stroke color space stack . peek ( ) ) ; } if ( ! non stroke color space stack . be empty ( ) ) { non stroke color space stack . push ( non stroke color space stack . peek ( ) ) ; } write operator ( `` q `` ) ; }
public void fill and stroke even odd ( ) throw i o exception { if ( in text mode ) { throw new illegal state exception ( `` error : fill and stroke even odd be not allow within a text block . `` ) ; } write operator ( `` b * `` ) ; }
public void fill ( ) throw i o exception { if ( in text mode ) { throw new illegal state exception ( `` error : fill be not allow within a text block . `` ) ; } write operator ( `` f `` ) ; }
public void begin mark content ( c o s name tag , p d property list property list ) throw i o exception { write operand ( tag ) ; write operand ( resource . add ( property list ) ) ; write operator ( `` bdc `` ) ; }
public void set word spacing ( float spacing ) throw i o exception { write operand ( space ) ; write operator ( `` tw `` ) ; }
public void insert after ( p d page new page , p d page prev page ) { c o s dictionary prev page dict = prev page . get c o s object ( ) ; c o s dictionary parent dict = ( c o s dictionary ) prev page dict . get dictionary object ( c o s name . parent ) ; c o s array kid = ( c o s array ) parent dict . get dictionary object ( c o s name . kid ) ; boolean find = false ; for ( int i = 0 ; i < kid . size ( ) ; ++i ) { c o s dictionary page dict = ( c o s dictionary ) kid . get object ( i ) ; if ( page dict . equal ( prev page . get c o s object ( ) ) ) { kid . add ( i + 1 , new page . get c o s object ( ) ) ; new page . get c o s object ( ) . set item ( c o s name . parent , parent dict ) ; find = true ; break ; } } if ( ! find ) { throw new illegal argument exception ( `` attempt to insert before orphan page `` ) ; } increase parent ( parent dict ) ; }
public void set font name ( string font name ) { c o s name name = null ; if ( font name ! = null ) { name = c o s name . get p d f name ( font name ) ; } dic . set item ( c o s name . font_name , name ) ; }
public c o s name add ( p d shade shade ) { return add ( c o s name . shading , `` sh `` , shade ) ; }
public void put ( c o s name name , p d x object xobject ) { put ( c o s name . xobject , name , xobject ) ; }
public c o s name add ( p d font font ) { return add ( c o s name . font , `` f `` , font ) ; }
public c o s name add ( p d shade shade ) { return add ( c o s name . shading , `` sh `` , shade ) ; }
public c o s name add ( p d abstract pattern pattern ) { return add ( c o s name . pattern , `` p `` , pattern ) ; }
public void draw ( graphics2 d graphic ) { visit shape ( new shape renderer ( graphic ) ) ; }
public buffer image render image ( int page index ) throw i o exception { return render image ( page index , 1 ) ; }
public void set should separate by bead ( boolean a should separate by bead ) { should separate by bead = a should separate by bead ; }
public boolean get add more formatting ( ) { return add more formatting ; }
public void set drop threshold ( float drop threshold value ) { drop threshold = drop threshold value ; }
public void set paragraph end ( string s ) { paragraph end = s ; }
public void set start page ( int start page value ) { start page = start page value ; }
public long get text rotation ( ) { return cell alignement . get text rotation ( ) ; }
public float get width ( ) { return get width rot ( rotation ) ; }
public void add path ( t value , byte [ ] . . . part ) { int depth = 0 ; byte trie node < t > node = _root ; for ( byte [ ] part : part ) { for ( byte b : part ) { byte trie node < t > child = node . _children . get ( b ) ; if ( child == null ) { child = new byte trie node < t > ( ) ; node . _children . put ( b , child ) ; } node = child ; depth++ ; } } if ( depth == 0 ) throw new illegal argument exception ( `` part must contain at least one byte . `` ) ; node . set value ( value ) ; _max depth = math . max ( _max depth , depth ) ; }
public static void display byte array ( byte [ ] record ) { int i ; for ( i=0 ; i < record . length -1 ; i++ ) { if ( i % 16 == 0 ) { system . out . println ( ) ; } system . out . print ( integer . to hex string ( record [ i ] > > 4 & 0x0 f ) ) ; system . out . print ( integer . to hex string ( record [ i ] & 0x0 f ) ) ; system . out . print ( `` , `` ) ; } system . out . print ( integer . to hex string ( record [ i ] > > 4 & 0x0 f ) ) ; system . out . print ( integer . to hex string ( record [ i ] & 0x0 f ) ) ; system . out . println ( ) ; }
public void set matrix ( affine transform transform ) { c o s array matrix = new c o s array ( ) ; double [ ] value = new double [ 6 ] ; transform . get matrix ( value ) ; for ( double v : value ) { matrix . add ( new c o s float ( ( float ) v ) ) ; } get c o s object ( ) . set item ( c o s name . matrix , matrix ) ; }
public void concatenate ( matrix matrix ) { matrix . multiply ( this , this ) ; }
public void translate ( float tx , float ty ) { single [ 6 ] += tx * single [ 0 ] + ty * single [ 3 ] ; single [ 7 ] += tx * single [ 1 ] + ty * single [ 4 ] ; single [ 8 ] += tx * single [ 2 ] + ty * single [ 5 ] ; check float value ( single ) ; }
public static matrix get translate instance ( float tx , float ty ) { matrix matrix = new matrix ( ) ; matrix . single [ 6 ] = tx ; matrix . single [ 7 ] = ty ; return matrix ; }
public void set landscape ( boolean landscape ) { this . landscape = landscape ; }
public static final long positive pack ( int i1 , int i2 ) { long packed1 = ( long ) i1 < < shift ; long packed2 = integer . rotate leave ( i2 , 1 ) & mask ; return long . rotate right ( packed1 | packed2 , 1 ) ; }
public iterator < node > get parent axis iterator ( object context node ) { if ( be attribute ( context node ) ) { return new single object iterator ( ( ( attribute ) context node ) . get parent ( ) ) ; } node parent = ( ( node ) context node ) . get parent ( ) ; if ( parent ! = null ) { return new single object iterator ( parent ) ; } else { return empty_iterator ; } }
public static string canonical role hint ( final string role , final string hint ) { return hint . be default hint ( hint ) ? role : role + ' : ' + hint ; }
public void add ( method method ) { string method name = method . get name ( ) ; list < method > l = get ( method name ) ; if ( l == null ) { l = new array list < method > ( ) ; method by name map . put ( method name , l ) ; } l . add ( method ) ; }
public void set name ( string name ) { this . name = name ; } // -- void set name ( string )
public void append ( pattern set other , project p ) { if ( be reference ( ) ) { throw new build exception ( `` can not append to a reference `` ) ; } string [ ] incl = other . get include pattern ( p ) ; if ( incl ! = null ) { for ( int i = 0 ; i < incl . length ; i++ ) { create include ( ) . set name ( incl [ i ] ) ; } } string [ ] excl = other . get exclude pattern ( p ) ; if ( excl ! = null ) { for ( int i = 0 ; i < excl . length ; i++ ) { create exclude ( ) . set name ( excl [ i ] ) ; } } }
public void remove container listener ( container listener listener ) { listener . remove ( listener ) ; }
public static throwable get cause ( throwable throwable ) { synchronize ( cause_method_names_lock ) { return get cause ( throwable , cause_method_names ) ; } }
public static void print root cause stack trace ( throwable throwable ) { print root cause stack trace ( throwable , system . err ) ; }
public static list < method > get annotate method ( class < ? > bean class , method filter filter ) { list < method > out = new array list < method > ( ) ; class clazz = bean class ; do { method [ ] declare = clazz . get declare method ( ) ; outer : for ( method method : declare ) { annotation [ ] annotation = method . get declared annotation ( ) ; for ( annotation annotation : annotation ) { if ( be custom annotation ( annotation ) ) { if ( filter . reject ( method ) ) { continue outer ; } out . add ( method ) ; continue outer ; } } } clazz = clazz . get superclass ( ) ; } while ( clazz ! = null & & clazz ! = object . class ) ; return out ; }
public boolean be double literal ( ) { string image = get image ( ) ; if ( be float & & image ! = null & & image . length ( ) > 0 ) { char last char = image . char at ( image . length ( ) - 1 ) ; if ( last char == 'd ' || last char == 'd ' || character . be digit ( last char ) || last char == ' . ' ) { return true ; } } return false ; }
public static void write line ( collection < ? > line , string line end , writer writer ) throw i o exception { if ( line == null ) { return ; } if ( line end == null ) { line end = line_separator ; } for ( object line : line ) { if ( line ! = null ) { writer . write ( line . to string ( ) ) ; } writer . write ( line end ) ; } }
public string to string ( ) { string builder s = new string builder ( ) ; if ( coefficient [ 0 ] == 0 . 0 ) { if ( coefficient . length == 1 ) { return `` 0 `` ; } } else { s . append ( to string ( coefficient [ 0 ] ) ) ; } for ( int i = 1 ; i < coefficient . length ; ++i ) { if ( coefficient [ i ] ! = 0 ) { if ( s . length ( ) > 0 ) { if ( coefficient [ i ] < 0 ) { s . append ( `` - `` ) ; } else { s . append ( `` + `` ) ; } } else { if ( coefficient [ i ] < 0 ) { s . append ( `` - `` ) ; } } double abs ai = fast math . ab ( coefficient [ i ] ) ; if ( ( abs ai - 1 ) ! = 0 ) { s . append ( to string ( abs ai ) ) ; s . append ( ' ' ) ; } s . append ( `` x `` ) ; if ( i > 1 ) { s . append ( '^ ' ) ; s . append ( integer . to string ( i ) ) ; } } } return s . to string ( ) ; }
public commandline . argument create argument ( ) { return java command . create argument ( ) ; }
public boolean create new file ( file f , boolean mkdirs ) throw i o exception { file parent = f . get parent file ( ) ; if ( mkdirs & & ! ( parent . exists ( ) ) ) { parent . mkdirs ( ) ; } return f . create new file ( ) ; }
public static void set escher property ( abstract escher opt record opt , short prop id , int value ) { java . util . list < escher property > prop = opt . get escher property ( ) ; for ( iterator < escher property > iterator = prop . iterator ( ) ; iterator . have next ( ) ; ) { if ( iterator . next ( ) . get property number ( ) == prop id ) { iterator . remove ( ) ; break ; } } if ( value ! = -1 ) { opt . add escher property ( new escher simple property ( prop id , value ) ) ; opt . sort property ( ) ; } }
public boolean equal ( object o ) { if ( this == o ) { return true ; } if ( o == null || ! ( o instanceof escher complex property ) ) { return false ; } escher complex property escher complex property = ( escher complex property ) o ; return array . equal ( _complex data , escher complex property . _complex data ) ; }
public void set marker ( byte field_2_marker ) { this . field_2_marker = field_2_marker ; }
public x s l f picture data find picture data ( byte [ ] picture data ) { long checksum = i o utils . calculate checksum ( picture data ) ; byte cs [ ] = new byte [ little endian consts . long_size ] ; little endian . put long ( c , 0 , checksum ) ; for ( x s l f picture data pic : get picture data ( ) ) { if ( array . equal ( pic . get checksum ( ) , c ) ) { return pic ; } } return null ; }
public short get row1 ( ) { return field_4_row1 ; }
public void set file id cluster ( file id cluster [ ] file id cluster ) { field_5_file id cluster . clear ( ) ; if ( file id cluster ! = null ) { field_5_file id cluster . add all ( array . a list ( file id cluster ) ) ; } }
public void set drawing save ( int drawing save ) { this . field_4_drawings save = drawing save ; }
public void set compress size ( int compress size ) { field_5_cb save = compress size ; }
public void set instance ( short value ) { _options = f instance . set short value ( _options , value ) ; }
public void set system id ( string url ) { system id = url ; builder . set system id ( url ) ; super . set document locator ( new locator ( ) { public int get column number ( ) { return -1 ; } public int get line number ( ) { return -1 ; } public string get public id ( ) { return null ; } public string get system id ( ) { return system id ; } } ) ; }
public int iterator int iterator ( ) { return new int iterator ( ) { @ override public boolean have next ( ) { return this . i > = 0 ; } @ override public int next ( ) { this . j = this . i ; this . i = bit set . this . next set bit ( this . i + 1 ) ; return this . j ; } private int i = bit set . this . next set bit ( 0 ) ; private int j ; } ; }
public int get color4 ( ) { return field_4_color4 ; }
public void set shape type ( short value ) { set instance ( value ) ; }
public static boolean get prefer event extractor ( ) { if ( all prefer event extractor ! = null ) { return all prefer event extractor ; } return thread prefer event extractor . get ( ) ; }
public document summary information get doc summary information ( ) { return document . get document summary information ( ) ; }
public set < long > id set ( ) { return collection . unmodifiable set ( dictionary . key set ( ) ) ; }
public void remove byte count ( ) { remove1st property ( property i d map . pid_bytecount ) ; }
public void set slide count ( final int slide count ) { set1st property ( property i d map . pid_slidecount , slide count ) ; }
public void remove hidden count ( ) { remove1st property ( property i d map . pid_hiddencount ) ; }
public void remove char count ( ) { remove1st property ( property i d map . pid_charcount ) ; }
public void set application version ( int version ) { set1st property ( property i d map . pid_version , version ) ; }
public void set language ( string language ) { set1st property ( property i d map . pid_language , language ) ; }
public void set document version ( string version ) { set1st property ( property i d map . pid_docversion , version ) ; }
public long get recovery i d ( ) { return recovery id ; }
public groovy field doc [ ] property ( ) { collection . sort ( property ) ; return property . to array ( new groovy field doc [ property . size ( ) ] ) ; }
public void remove comment ( ) { remove1st property ( property i d map . pid_comments ) ; }
public void remove last author ( ) { remove1st property ( property i d map . pid_lastauthor ) ; }
public void remove create date time ( ) { remove1st property ( property i d map . pid_create_dtm ) ; }
public void remove word count ( ) { remove1st property ( property i d map . pid_wordcount ) ; }
public void set source position ( a s t node node ) { this . line number = node . get line number ( ) ; this . column number = node . get column number ( ) ; this . last line number = node . get last line number ( ) ; this . last column number = node . get last column number ( ) ; }
public void process workbook event ( h s s f request req , p o i f s file system f ) throw i o exception { process workbook event ( req , f . get root ( ) ) ; }
public static record listener provider [ ] provider ( record listener . . . listener ) { record listener provider [ ] result = new record listener provider [ listener . length ] ; for ( int i = 0 ; i < listener . length ; i++ ) result [ i ] = new default record listener provider ( listener [ i ] ) ; return result ; }
public h s l f object data [ ] get embedded object ( ) { if ( _objects == null ) { list < h s l f object data > object = new array list < > ( ) ; for ( record r : _records ) { if ( r instanceof ex ole obj stg ) { object . add ( new h s l f object data ( ( ex ole obj stg ) r ) ) ; } } _objects = object . to array ( new h s l f object data [ 0 ] ) ; } return _objects ; }
public void add value record ( int row , cell value record interface col ) { if ( log . check ( p o i logger . debug ) ) { log . log ( p o i logger . debug , `` add value record row `` + row ) ; } dimension record d = _dimensions ; if ( col . get column ( ) > = d . get last col ( ) ) { d . set last col ( ( short ) ( col . get column ( ) + 1 ) ) ; } if ( col . get column ( ) < d . get first col ( ) ) { d . set first col ( col . get column ( ) ) ; } _rows aggregate . insert cell ( col ) ; }
public void set gridset ( boolean gridset ) { if ( gridset ) { field_1_gridset_flag = 1 ; } else { field_1_gridset_flag = 0 ; } }
public column info record find column info ( int column index ) { int n infos = record . size ( ) ; for ( int i=0 ; i < n info ; i++ ) { column info record ci = get col info ( i ) ; if ( ci . contains column ( column index ) ) { return ci ; } } return null ; }
public boolean be display row col heading ( ) { return window two . get display row col heading ( ) ; }
public sheet build ( ) { sheet sheet = ( sheet name == null ) ? workbook . create sheet ( ) : workbook . create sheet ( sheet name ) ; row current row ; cell current cell ; for ( int row index = 0 ; row index < cell . length ; ++row index ) { object [ ] row array = cell [ row index ] ; current row = sheet . create row ( row index ) ; for ( int cell index = 0 ; cell index < row array . length ; ++cell index ) { object cell value = row array [ cell index ] ; if ( cell value ! = null || should create empty cell ) { current cell = current row . create cell ( cell index ) ; set cell value ( current cell , cell value ) ; } } } return sheet ; }
public void set build ( int build ) { field_3_build = build ; }
public int get position of bof ( ) { return field_1_position_of_ b o f ; }
public void set border left ( int border ) { field_13_border_styles1 = bord leave line style . set value ( field_13_border_styles1 , border ) ; }
public int get border diagonal ( ) { return bord diag line style . get value ( field_14_border_styles2 ) ; }
public int get right border color ( ) { return bord right line color . get value ( field_13_border_styles1 ) ; }
public boolean get bold ( ) { return font . get bold weight ( ) == boldweight_bold ; }
public static cell range address [ ] [ ] build merge range map ( sheet sheet ) { cell range address [ ] [ ] merge range = new cell range address [ 1 ] [ ] ; for ( final cell range address cell range address : sheet . get merge region ( ) ) { final int require height = cell range address . get last row ( ) + 1 ; if ( merge range . length < require height ) { cell range address [ ] [ ] new array = new cell range address [ require height ] [ ] ; system . arraycopy ( merge range , 0 , new array , 0 , merge range . length ) ; merge range = new array ; } for ( int r = cell range address . get first row ( ) ; r < = cell range address . get last row ( ) ; r++ ) { final int require width = cell range address . get last column ( ) + 1 ; cell range address [ ] row merge = merge range [ r ] ; if ( row merge == null ) { row merge = new cell range address [ require width ] ; merge range [ r ] = row merge ; } else { final int row merge length = row merge . length ; if ( row merge length < require width ) { final cell range address [ ] new row = new cell range address [ require width ] ; system . arraycopy ( row merge , 0 , new row , 0 , row merge length ) ; merge range [ r ] = new row ; row merge = new row ; } } array . fill ( row merge , cell range address . get first column ( ) , cell range address . get last column ( ) + 1 , cell range address ) ; } } return merged range ; }
public static c f rule12 record create ( h s s f sheet sheet , icon set icon set ) { threshold [ ] t = new threshold [ icon set . num ] ; for ( int i=0 ; i < t . length ; i++ ) { ts [ i ] = new icon multi state threshold ( ) ; } c f rule12 record r = new c f rule12 record ( condition_type_icon_set , comparison operator . no_comparison ) ; icon multi state format imf = r . create multi state formatting ( ) ; imf . set icon set ( icon set ) ; imf . set threshold ( t ) ; return r ; }
public static ptg [ ] parse ( string formula , formula parse workbook workbook , formula type formula type , int sheet index , int row index ) { formula parser fp = new formula parser ( formula , workbook , sheet index , row index ) ; fp . parse ( ) ; return fp . get r p n ptg ( formula type ) ; }
public short get pattern ( ) { return field_3_pattern ; }
public void set maximum category ( short field_2_maximum category ) { this . field_2_maximum category = field_2_maximum category ; }
public short get minor unit ( ) { return field_6_minor unit ; }
public void set default minor unit ( boolean value ) { field_9_options = default minor unit . set short boolean ( field_9_options , value ) ; }
public boolean be default minimum ( ) { return default minimum . be set ( field_9_options ) ; }
public void set default cross ( boolean value ) { field_9_options = default cross . set short boolean ( field_9_options , value ) ; }
public void set bar space ( short field_1_bar space ) { this . field_1_bar space = field_1_bar space ; }
public void set format flag ( short field_3_format flag ) { this . field_3_format flag = field_3_format flag ; }
public short get point number ( ) { return field_1_point number ; }
public void set show series key ( boolean value ) { field_1_options = show series key . set short boolean ( field_1_options , value ) ; }
public void set height basis ( short field_3_height basis ) { this . field_3_height basis = field_3_height basis ; }
public void set auto position ( boolean value ) { field_2_options = auto position . set short boolean ( field_2_options , value ) ; }
public void set vertical ( boolean value ) { field_7_options = vertical . set short boolean ( field_7_options , value ) ; }
public void set data table ( boolean value ) { field_7_options = data table . set short boolean ( field_7_options , value ) ; }
public short get line pattern ( ) { return field_2_line pattern ; }
public void set colour palette index ( short field_5_colour palette index ) { this . field_5_colour palette index = field_5_colour palette index ; }
public void set reference type ( byte field_2_reference type ) { this . field_2_reference type = field_2_reference type ; }
public void set custom number format ( boolean value ) { field_3_options = custom number format . set short boolean ( field_3_options , value ) ; }
public void set custom number format ( boolean value ) { field_3_options = custom number format . set short boolean ( field_3_options , value ) ; }
public short get format index ( ) { return field_1_format index ; }
public void set show actual ( boolean value ) { field_1_format flag = show actual . set short boolean ( field_1_format flag , value ) ; }
public void set category data type ( short field_1_category data type ) { this . field_1_category data type = field_1_category data type ; }
public short get category data type ( ) { return field_1_category data type ; }
public short get num bubble value ( ) { return field_6_num bubble value ; }
public void set ( short value ) { this . value = value ; }
public short get bubble series type ( ) { return field_5_bubble series type ; }
public void set system id ( string url ) { system id = url ; builder . set system id ( url ) ; super . set document locator ( new locator ( ) { public int get column number ( ) { return -1 ; } public int get line number ( ) { return -1 ; } public string get public id ( ) { return null ; } public string get system id ( ) { return system id ; } } ) ; }
public int get empty ( ) { return field_2_empty ; }
public boolean be plot visible only ( ) { return plot visible only . be set ( field_1_flags ) ; }
public short get options1 ( ) { return field_9_options1 ; }
public void set text rotation ( short field_12_text rotation ) { this . field_12_text rotation = field_12_text rotation ; }
public int get zero1 ( ) { return field_6_zero1 ; }
public void set autorotate ( boolean value ) { field_10_options = autorotate . set short boolean ( field_10_options , value ) ; }
public void set automatic category crossing ( boolean value ) { field_6_options = automatic category crossing . set short boolean ( field_6_options , value ) ; }
public void set lock ( boolean value ) { field_3_option = lock . set short boolean ( field_3_option , value ) ; }
public int size ( ) { return _size ; }
public void remove shape to obj record ( escher record rec ) { shape to obj . remove ( rec ) ; }
public void set italic ( boolean italic ) { get c o s object ( ) . set flag ( c o s name . f , italic_flag , italic ) ; }
public void set charset ( byte charset ) { field_8_charset = charset ; }
public void set font name ( string fn ) { field_11_font_name = fn ; }
public double get value ( ) { return field_4_value ; }
public boolean be document link ( ) { return ( _link opts & hlink_place ) > 0 ; }
public boolean be document link ( ) { return ( _link opts & hlink_place ) > 0 ; }
public boolean get iteration ( ) { return iteration on . be set ( _flags ) ; }
public ext s s t record create ext s s t record ( int sst offset ) { if ( bucket absolute offset == null || bucket relative offset == null ) { throw new illegal state exception ( `` sst record have not yet be serialize . `` ) ; } ext s s t record ext s s t = new ext s s t record ( ) ; ext s s t . set num string per bucket ( ( short ) 8 ) ; int [ ] absolute offset = bucket absolute offset . clone ( ) ; int [ ] relative offset = bucket relative offset . clone ( ) ; for ( int i = 0 ; i < absolute offset . length ; i++ ) { absolute offset [ i ] += sst offset ; } ext s s t . set bucket offset ( absolute offset , relative offset ) ; return ext s s t ; }
public double get r k number ( ) { return r k util . decode number ( field_4_rk_number ) ; }
public ptg [ ] get name definition ( ) { return field_13_name_definition . get token ( ) ; }
public double get value ( ) { return field_4_value ; }
public void set protect ( boolean protect ) { _options = protect flag . set boolean ( _options , protect ) ; }
public short read short ( ) { check record position ( little endian consts . short_size ) ; _current data offset += little endian consts . short_size ; return _data input . read short ( ) ; }
public static byte [ ] to primitive ( byte [ ] array ) { if ( array == null ) { return null ; } else if ( array . length == 0 ) { return empty_byte_array ; } final byte [ ] result = new byte [ array . length ] ; for ( int i = 0 ; i < array . length ; i++ ) { result [ i ] = array [ i ] . byte value ( ) ; } return result ; }
public short get outline level ( ) { return ( short ) outline level . get value ( field_7_option_flags ) ; }
public void set last column ( int last col ) { _range . set last column ( last col ) ; }
public int get active cell row ( ) { return field_2_row_active_cell ; }
public void set system id ( string url ) { system id = url ; builder . set system id ( url ) ; super . set document locator ( new locator ( ) { public int get column number ( ) { return -1 ; } public int get line number ( ) { return -1 ; } public string get public id ( ) { return null ; } public string get system id ( ) { return system id ; } } ) ; }
public void fill polygon ( int [ ] x point , int [ ] y point , int n point ) { java . awt . polygon polygon = new java . awt . polygon ( x point , y point , n point ) ; fill ( polygon ) ; }
public string get data format string ( org . apache . poi . hssf . model . internal workbook workbook ) { h s s f data format format = new h s s f data format ( workbook ) ; return format . get format ( get data format ( ) ) ; }
public version resource resolver add fix version strategy ( string version , string . . . path pattern ) { list < string > pattern list = array . a list ( path pattern ) ; list < string > prefixed pattern = new array list < > ( path pattern . length ) ; string version prefix = `` / `` + version ; for ( string pattern : pattern list ) { prefixed pattern . add ( pattern ) ; if ( ! pattern . start with ( version prefix ) & & ! pattern list . contains ( version prefix + pattern ) ) { prefixed pattern . add ( version prefix + pattern ) ; } } return add version strategy ( new fix version strategy ( version ) , string utils . to string array ( prefixed pattern ) ) ; }
public void set reading order ( short order ) { _format . set read order ( order ) ; }
public void set rule ( int idx , h s s f conditional formatting rule cf rule ) { cf aggregate . set rule ( idx , cf rule . get cf rule record ( ) ) ; }
public static int get iso year ( java . util . date date ) { calendar cal = calendar . get instance ( ) ; cal . set time in millis ( date . get time ( ) ) ; cal . set first day of week ( calendar . monday ) ; cal . set minimal day in first week ( 4 ) ; int year = get year ( cal ) ; int month = cal . get ( calendar . month ) ; int week = cal . get ( calendar . week_of_year ) ; if ( month == 0 & & week > 51 ) { year -- ; } else if ( month == 11 & & week == 1 ) { year++ ; } return year ; }
public evaluation name get name ( string name , int sheet index ) { for ( int i=0 ; i < _i book . get num name ( ) ; i++ ) { name record nr = _i book . get name record ( i ) ; if ( nr . get sheet number ( ) == sheet index+1 & & name . equal ignore case ( nr . get name text ( ) ) ) { return new name ( nr , i ) ; } } return sheet index == -1 ? null : get name ( name , -1 ) ; }
public boolean get bold ( ) { return font . get bold weight ( ) == boldweight_bold ; }
public void notify update cell ( h s s f cell cell ) { _book evaluator . notify update cell ( new h s s f evaluation cell ( cell ) ) ; }
public static value eval choose single element from area ( area eval ae , int src cell row , int src cell col ) throw evaluation exception { value eval result = choose single element from area internal ( ae , src cell row , src cell col ) ; if ( result instanceof error eval ) { throw new evaluation exception ( ( error eval ) result ) ; } return result ; }
public void set no orientation ( boolean orientation ) { print setup record . set no orientation ( orientation ) ; }
public short get copy ( ) { return print setup record . get copy ( ) ; }
public void set page start ( short start ) { print setup record . set page start ( start ) ; }
public void set no orientation ( boolean orientation ) { print setup record . set no orientation ( orientation ) ; }
public void set no orientation ( boolean orientation ) { print setup record . set no orientation ( orientation ) ; }
public void set v resolution ( short resolution ) { print setup record . set v resolution ( resolution ) ; }
public void set string ( string s ) { clear formatting ( ) ; st . set t ( s ) ; preserve space ( st . xget t ( ) ) ; }
public int get index of format run ( int index ) { unicode string . format run r = _string . get format run ( index ) ; return r . get character po ( ) ; }
public static custom indexed color map from color ( c t color color ) { if ( color == null || ! color . be set indexed color ( ) ) return null ; list < c t rgb color > rgb color list = color . get indexed color ( ) . get rgb color list ( ) ; byte [ ] [ ] custom color index = new byte [ rgb color list . size ( ) ] [ 3 ] ; for ( int i=0 ; i < rgb color list . size ( ) ; i++ ) { custom color index [ i ] = rgb color list . get ( i ) . get rgb ( ) ; } return new custom indexed color map ( custom color index ) ; }
public static custom indexed color map from color ( c t color color ) { if ( color == null || ! color . be set indexed color ( ) ) return null ; list < c t rgb color > rgb color list = color . get indexed color ( ) . get rgb color list ( ) ; byte [ ] [ ] custom color index = new byte [ rgb color list . size ( ) ] [ 3 ] ; for ( int i=0 ; i < rgb color list . size ( ) ; i++ ) { custom color index [ i ] = rgb color list . get ( i ) . get rgb ( ) ; } return new custom indexed color map ( custom color index ) ; }
public void set margin top ( int margin top ) { set property value ( new escher simple property ( escher property . text__texttop , margin top ) ) ; }
public void set horizontal alignment ( short align ) { get text object record ( ) . set horizontal text alignment ( align ) ; }
public static h s s f workbook create workbook ( final p o i f s file system f ) throw i o exception { return new h s s f workbook ( f ) ; }
public static string unicode escape ( char ch ) { if ( ch < 0x10 ) { return `` \\u000 `` + integer . to hex string ( ch ) ; } else if ( ch < 0x100 ) { return `` \\u00 `` + integer . to hex string ( ch ) ; } else if ( ch < 0x1000 ) { return `` \\u0 `` + integer . to hex string ( ch ) ; } return `` \\u `` + integer . to hex string ( ch ) ; }
public static void set bottom border color ( int color , cell range address region , h s s f sheet sheet , h s s f workbook workbook ) { region util . set bottom border color ( color , region , sheet ) ; }
public static byte [ ] generate iv ( hash algorithm hash algorithm , byte [ ] salt , byte [ ] block key , int block size ) { byte iv [ ] = salt ; if ( block key ! = null ) { message digest hash algo = get message digest ( hash algorithm ) ; hash algo . update ( salt ) ; iv = hash algo . digest ( block key ) ; } return get block36 ( iv , block size ) ; }
public static string xor hash password reverse ( string password ) { int hash password = create xor verifier2 ( password ) ; return string . format ( locale . root , `` % 1 $ 02x % 2 $ 02x % 3 $ 02x % 4 $ 02x `` , ( hash password > > > 0 ) & 0x f f , ( hash password > > > 8 ) & 0x f f , ( hash password > > > 16 ) & 0x f f , ( hash password > > > 24 ) & 0x f f ) ; }
public static void copy node ( p o i f s file system source , p o i f s file system target ) throw i o exception { copy node ( source . get root ( ) , target . get root ( ) ) ; }
public document input stream create document input stream ( final string document name ) throw i o exception { return get root ( ) . create document input stream ( document name ) ; }
public boolean should use small block ( ) { return property . be small ( _size . get ( ) ) ; }
public void set storage clsid ( class i d clsid storage ) { _storage_clsid = clsid storage ; if ( clsid storage == null ) { array . fill ( _raw_data , _storage_clsid_offset , _storage_clsid_offset + class i d . length , ( byte ) 0 ) ; } else { clsid storage . write ( _raw_data , _storage_clsid_offset ) ; } }
public void set size ( long size ) { _size = size ; }
public void set max y ( string value ) { this . max y = value ; }
public c t sc rgb color get scrgb clr ( ) { return scrgb clr ; }
public c t s rgb color get srgb clr ( ) { return srgb clr ; }
public c t preset color get prst clr ( ) { return prst clr ; }
public void set gd lst ( c t geom guide list value ) { this . gd lst = value ; }
public void set ah lst ( c t adjust handle list value ) { this . ah lst = value ; }
public void set cxn lst ( c t connection site list value ) { this . cxn lst = value ; }
public ex embed get ex embed ( ) { return get ex embed ( false ) ; }
public void set ch ext ( c t positive size2 d value ) { this . ch ext = value ; }
public final quad edge rot ( ) { return rot ; }
public boolean be flip v ( ) { if ( flip v == null ) { return false ; } else { return flip v ; } }
public boolean be flip h ( ) { if ( flip h == null ) { return false ; } else { return flip h ; } }
public static long mix64 ( long z ) { z = ( z ^ ( z > > > 32 ) ) * 0x4cd6944c5cc20b6d l ; z = ( z ^ ( z > > > 29 ) ) * 0xfc12c5b19d3259e9 l ; return z ^ ( z > > > 32 ) ; }
public string get min ang ( ) { return min ang ; }
public int get height ( ) { return sx height ; }
public void scale ( double sx , double sy ) { _transform . scale ( sx , sy ) ; }
public long get dy ( ) { return dy ; }
public affine transformation shear ( double x shear , double y shear ) { compose ( shear instance ( x shear , y shear ) ) ; return this ; }
public shape get clip ( ) { if ( log . check ( p o i logger . warn ) ) { log . log ( p o i logger . warn , `` not implement `` ) ; } return null ; }
public object clone ( ) { try { return super . clone ( ) ; } catch ( clone not support exception e ) { throw new runtime exception ( e . get message ( ) ) ; } }
public static collection < string > get support function name ( ) { analysis tool pak inst = ( analysis tool pak ) instance ; collection < string > lst = new tree set < > ( ) ; for ( map . entry < string , free ref function > me : inst . _functions by name . entry set ( ) ) { free ref function func = me . get value ( ) ; if ( func ! = null & & ! ( func instanceof not implement ) ) { lst . add ( me . get key ( ) ) ; } } return collection . unmodifiable collection ( lst ) ; }
public final value eval evaluate ( value eval [ ] args , int src row index , int src column index ) { if ( args . length ! = 3 ) { return error eval . value_invalid ; } return evaluate ( src row index , src column index , args [ 0 ] , args [ 1 ] , args [ 2 ] ) ; }
protect evaluation cell to evaluation cell ( cell cell ) { if ( ! ( cell instanceof x s s f cell ) ) { throw new illegal argument exception ( `` unexpected type of cell : `` + cell . get class ( ) + `` . `` + `` only x s s f cell can be evaluate . `` ) ; } return new x s s f evaluation cell ( ( x s s f cell ) cell ) ; }
protect final void recurse clear cache formula result ( ) { formula cell cache entry [ ] formula cell = get consume cell ( ) ; for ( int i = 0 ; i < formula cell . length ; i++ ) { formula cell cache entry fc = formula cell [ i ] ; fc . clear formula entry ( ) ; fc . recurse clear cache formula result ( ) ; } }
static public double pmt ( double r , int nper , double pv , double fv ) { return pmt ( r , nper , pv , fv , 0 ) ; }
public final value eval evaluate ( value eval [ ] args , int src row index , int src column index ) { if ( args . length ! = 3 ) { return error eval . value_invalid ; } return evaluate ( src row index , src column index , args [ 0 ] , args [ 1 ] , args [ 2 ] ) ; }
public final value eval evaluate ( value eval [ ] args , int src row index , int src column index ) { if ( args . length ! = 3 ) { return error eval . value_invalid ; } return evaluate ( src row index , src column index , args [ 0 ] , args [ 1 ] , args [ 2 ] ) ; }
public static double round up ( double n , int p ) { return round ( n , p , java . math . round mode . up ) ; }
public static double sum ( double [ ] value ) { double sum = 0 ; for ( int i=0 , i size=values . length ; i < i size ; i++ ) { sum += value [ i ] ; } return sum ; }
public static double sum ( double [ ] value ) { double sum = 0 ; for ( int i=0 , i size=values . length ; i < i size ; i++ ) { sum += value [ i ] ; } return sum ; }
public static double sum ( double [ ] value ) { double sum = 0 ; for ( int i=0 , i size=values . length ; i < i size ; i++ ) { sum += value [ i ] ; } return sum ; }
public double of ( double [ ] d , int num param ) { if ( num param == 0 ) return double . min_value ; double min = double . max_value ; for ( int i = 0 ; i < num param ; i++ ) if ( d [ i ] < min ) min = d [ i ] ; return min ; }
public static double asinh ( double d ) { return math . log ( math . sqrt ( d * d + 1 ) + d ) ; }
public static double [ ] to primitive ( double [ ] array ) { if ( array == null ) { return null ; } else if ( array . length == 0 ) { return empty_double_array ; } final double [ ] result = new double [ array . length ] ; for ( int i = 0 ; i < array . length ; i++ ) { result [ i ] = array [ i ] . double value ( ) ; } return result ; }
public static boolean be build in function name ( string name ) { short ix = function metadata registry . lookup index by name ( name . to upper case ( locale . root ) ) ; return ix > = 0 ; }
public static charset get charset ( char sequence content type value ) { if ( content type value ! = null ) { return get charset ( content type value , charset util . iso_8859_1 ) ; } else { return charset util . iso_8859_1 ; } }
public static cell get cell ( row row , int column index ) { cell cell = row . get cell ( column index ) ; if ( cell == null ) { cell = row . create cell ( column index ) ; } return cell ; }
public x s s f cell get reference cell ( ) { x s s f cell cell = null ; cell reference cell reference = new cell reference ( single xml cell . get r ( ) ) ; x s s f row row = parent . get x s s f sheet ( ) . get row ( cell reference . get row ( ) ) ; if ( row==null ) { row = parent . get x s s f sheet ( ) . create row ( cell reference . get row ( ) ) ; } cell = row . get cell ( cell reference . get col ( ) ) ; if ( cell==null ) { cell = row . create cell ( cell reference . get col ( ) ) ; } return cell ; }
public static cell range address [ ] [ ] build merge range map ( sheet sheet ) { cell range address [ ] [ ] merge range = new cell range address [ 1 ] [ ] ; for ( final cell range address cell range address : sheet . get merge region ( ) ) { final int require height = cell range address . get last row ( ) + 1 ; if ( merge range . length < require height ) { cell range address [ ] [ ] new array = new cell range address [ require height ] [ ] ; system . arraycopy ( merge range , 0 , new array , 0 , merge range . length ) ; merge range = new array ; } for ( int r = cell range address . get first row ( ) ; r < = cell range address . get last row ( ) ; r++ ) { final int require width = cell range address . get last column ( ) + 1 ; cell range address [ ] row merge = merge range [ r ] ; if ( row merge == null ) { row merge = new cell range address [ require width ] ; merge range [ r ] = row merge ; } else { final int row merge length = row merge . length ; if ( row merge length < require width ) { final cell range address [ ] new row = new cell range address [ require width ] ; system . arraycopy ( row merge , 0 , new row , 0 , row merge length ) ; merge range [ r ] = new row ; row merge = new row ; } } array . fill ( row merge , cell range address . get first column ( ) , cell range address . get last column ( ) + 1 , cell range address ) ; } } return merged range ; }
public static boolean contains ( cell range address cr a , cell range address cr b ) { return le ( cr a . get first row ( ) , cr b . get first row ( ) ) & & ge ( cr a . get last row ( ) , cr b . get last row ( ) ) & & le ( cr a . get first column ( ) , cr b . get first column ( ) ) & & ge ( cr a . get last column ( ) , cr b . get last column ( ) ) ; }
public void set horizontal ( horizontal alignment align ) { cell alignement . set horizontal ( s t horizontal alignment . enum . for int ( align . ordinal ( ) + 1 ) ) ; }
public void set vertical ( vertical alignment align ) { cell alignement . set vertical ( s t vertical alignment . enum . for int ( align . ordinal ( ) + 1 ) ) ; }
public static void set top border color ( int color , cell range address region , sheet sheet ) { int col start = region . get first column ( ) ; int col end = region . get last column ( ) ; int row index = region . get first row ( ) ; cell property setter cps = new cell property setter ( cell util . top_border_color , color ) ; row row = cell util . get row ( row index , sheet ) ; for ( int i = col start ; i < = col end ; i++ ) { cps . set property ( row , i ) ; } }
public static void read fully ( input stream in , byte [ ] b ) throw i o exception { read fully ( in , b , 0 , b . length ) ; }
public static void update ( url src u r l , file d file , update option option ) throw i o exception , s a x exception { if ( d file . get parent file ( ) ! = null ) { d file . get parent file ( ) . mkdirs ( ) ; } output stream d stream = new file output stream ( d file ) ; try { update ( src u r l , d stream , option ) ; } finally { try { d stream . close ( ) ; } catch ( i o exception e ) { message . warn ( `` fail to close a stream : `` + e . to string ( ) ) ; } } }
public static long calculate checksum ( byte [ ] data ) { checksum sum = new crc32 ( ) ; sum . update ( data , 0 , data . length ) ; return sum . get value ( ) ; }
public static boolean be os ( string family , string name , string arch , string version ) { boolean ret value = false ; if ( family ! = null || name ! = null || arch ! = null || version ! = null ) { boolean be family = true ; boolean be name = true ; boolean be arch = true ; boolean be version = true ; if ( family ! = null ) { if ( family . equal ignore case ( family_windows ) ) { be family = os_name . contains ( family_windows ) ; } else if ( family . equal ignore case ( family_os2 ) ) { be family = os_name . contains ( family_os2 ) ; } else if ( family . equal ignore case ( family_netware ) ) { be family = os_name . contains ( family_netware ) ; } else if ( family . equal ignore case ( family_dos ) ) { be family = path_sep . equal ( `` ; `` ) & & ! be family ( family_netware ) ; } else if ( family . equal ignore case ( family_mac ) ) { be family = os_name . contains ( family_mac ) ; } else if ( family . equal ignore case ( family_tandem ) ) { be family = os_name . contains ( `` nonstop_kernel `` ) ; } else if ( family . equal ignore case ( family_unix ) ) { be family = path_sep . equal ( `` : `` ) & & ! be family ( family_openvms ) & & ( ! be family ( family_mac ) || os_name . end with ( `` x `` ) ) ; } else if ( family . equal ignore case ( family_win9x ) ) { be family = be family ( family_windows ) & & ( os_name . contains ( `` 95 `` ) || os_name . contains ( `` 98 `` ) || os_name . contains ( `` me `` ) || os_name . contains ( `` ce `` ) ) ; } else if ( family . equal ignore case ( family_zos ) ) { be family = os_name . contains ( family_zos ) || os_name . contains ( `` os/390 `` ) ; } else if ( family . equal ignore case ( family_os400 ) ) { be family = os_name . contains ( family_os400 ) ; } else if ( family . equal ignore case ( family_openvms ) ) { be family = os_name . contains ( family_openvms ) ; } else { be family = os_name . contains ( family . to lower case ( locale . u ) ) ; } } if ( name ! = null ) { be name = name . to lower case ( locale . u ) . equal ( os_name ) ; } if ( arch ! = null ) { be arch = arch . to lower case ( locale . u ) . equal ( os_arch ) ; } if ( version ! = null ) { be version = version . to lower case ( locale . u ) . equal ( os_version ) ; } ret value = be family & & be name & & be arch & & be version ; } return ret value ; }
public static void put double ( byte [ ] data , int offset , double value ) { put long ( data , offset , double . double to long bit ( value ) ) ; }
public static void put u byte ( byte [ ] data , int offset , short value ) { data [ offset ] = ( byte ) ( value & 0x f f ) ; }
public static int get u short ( byte [ ] data ) { return get u short ( data , 0 ) ; }
public static void write swap float ( final byte [ ] data , final int offset , final float value ) { write swap integer ( data , offset , float . float to int bit ( value ) ) ; }
public static void put int ( byte [ ] data , int offset , int value ) { int i = offset ; data [ i++ ] = ( byte ) ( ( value > > > 0 ) & 0x f f ) ; data [ i++ ] = ( byte ) ( ( value > > > 8 ) & 0x f f ) ; data [ i++ ] = ( byte ) ( ( value > > > 16 ) & 0x f f ) ; data [ i++ ] = ( byte ) ( ( value > > > 24 ) & 0x f f ) ; }
public static void check ( boolean assert true , string message ) { if ( ! assert true ) { throw new document format exception ( message ) ; } }
public static int double to fix point ( double float point ) { double fractional part = float point % 1d ; double integral part = float point - fractional part ; int i = ( int ) math . floor ( integral part ) ; int f = ( int ) math . rint ( fractional part * 65536d ) ; return ( i < < 16 ) | ( f & 0x f f f f ) ; }
public final p o i x m l document part create relationship ( p o i x m l relation descriptor , p o i x m l factory factory ) { return create relationship ( descriptor , factory , -1 , false ) . get document part ( ) ; }
public java type get type ( ) { return _type ; }
public relation get relation ( ) { return relation ; }
protect package relationship get package relationship ( p o i x m l document part parent , package part part ) { try { string part name = part . get part name ( ) . get name ( ) ; for ( package relationship pr : parent . get package part ( ) . get relationship ( ) ) { string pack name = pr . get target u r i ( ) . to a s c i i string ( ) ; if ( pack name . equal ignore case ( part name ) ) { return pr ; } } } catch ( invalid format exception e ) { throw new p o i x m l exception ( `` error while determine package relation `` , e ) ; } throw new p o i x m l exception ( `` package part be n't a child of the parent document . `` ) ; }
public estimate parameter [ ] get all parameter ( ) { return parameter . to array ( new estimate parameter [ parameter . size ( ) ] ) ; }
public static void copy file unbuffered ( file src , file dst ) throw i o exception { if ( native load & & shell . window ) { copy file unbuffered0 ( src . get absolute path ( ) , dst . get absolute path ( ) ) ; } else { file input stream fis = null ; file output stream fo = null ; file channel input = null ; file channel output = null ; try { fis = new file input stream ( src ) ; fos = new file output stream ( dst ) ; input = fis . get channel ( ) ; output = fo . get channel ( ) ; long remain = input . size ( ) ; long position = 0 ; long transfer = 0 ; while ( remain > 0 ) { transfer = input . transfer to ( position , remain , output ) ; remain -= transfer ; position += transfer ; } } finally { i o utils . cleanup ( log , output ) ; i o utils . cleanup ( log , fo ) ; i o utils . cleanup ( log , input ) ; i o utils . cleanup ( log , fis ) ; } } }
public void set last printed property ( string last printed ) { try { this . last printed = set date value ( last print ) ; } catch ( invalid format exception e ) { throw new illegal argument exception ( `` last printed : `` + e . get localized message ( ) , e ) ; } }
public static o p c package open or create ( file file ) throw invalid format exception { if ( file . exists ( ) ) { return open ( file . get absolute path ( ) ) ; } else { return create ( file ) ; } }
public array list < package part > get part by relationship type ( string relationship type ) { if ( relationship type == null ) { throw new illegal argument exception ( `` relationship type `` ) ; } array list < package part > ret arr = new array list < > ( ) ; for ( package relationship rel : get relationship by type ( relationship type ) ) { package part part = get part ( rel ) ; if ( part ! = null ) { ret arr . add ( part ) ; } } collection . sort ( ret arr ) ; return ret arr ; }
public void remove part ( package part part ) { if ( part ! = null ) { remove part ( part . get part name ( ) ) ; } }
public static boolean can enhance ( executable member ) { return can access ( member , have package access ( ) ) ; }
public package relationship collection get relationship by type ( string relationship type ) throw invalid format exception { _container . throw exception if write only ( ) ; return get relationship core ( relationship type ) ; }
public compressor input stream create compressor input stream ( final string name , final input stream in ) throw compressor exception { if ( name == null || in == null ) { throw new illegal argument exception ( `` compressor name and stream must not be null . `` ) ; } try { if ( gzip . equal ignore case ( name ) ) { return new gzip compressor input stream ( in ) ; } if ( bzip2 . equal ignore case ( name ) ) { return new b zip2 compressor input stream ( in ) ; } if ( xz . equal ignore case ( name ) ) { return new x z compressor input stream ( in ) ; } if ( pack200 . equal ignore case ( name ) ) { return new pack200 compressor input stream ( in ) ; } } catch ( i o exception e ) { throw new compressor exception ( `` could not create compressor input stream . `` , e ) ; } throw new compressor exception ( `` compressor : `` + name + `` not find . `` ) ; }
public static string print hex ( byte [ ] array , int offset , int len ) { string builder sb = new string builder ( ) ; for ( int i = 0 ; i < len ; i++ ) { byte b = array [ offset + i ] ; if ( sb . length ( ) > 0 ) sb . append ( ' ' ) ; sb . append ( digits [ b > > 4 & 0x0 f ] ) ; sb . append ( digits [ b & 0x0 f ] ) ; } return sb . to string ( ) ; }
public zip archive entry get zip archive ( ) { return zip entry ; }
public input stream get input stream ( ) throw i o exception { cipher ci dec = crypto function . get cipher ( skey spec , cipher algorithm , chain mode . cbc , iv byte , cipher . decrypt_mode , pad ) ; return new cipher input stream ( new file input stream ( temp file ) , ci dec ) ; }
public synchronize property configuration layout get layout ( ) { if ( layout == null ) { layout = create layout ( ) ; } return layout ; }
public void set margin right ( double point ) { if ( point ! = null || _p . be set p pr ( ) ) { get or create property ( ) . set margin right ( point ) ; } }
public void set margin right ( double point ) { if ( point ! = null || _p . be set p pr ( ) ) { get or create property ( ) . set margin right ( point ) ; } }
public x d d f space get space after ( ) { return find defined paragraph property ( props - > prop . be set spc aft ( ) , prop - > prop . get spc aft ( ) ) . map ( space - > extract space ( space ) ) . or else ( null ) ; }
public void set bullet color follow text ( ) { get or create bullet property ( ) . set bullet color follow text ( ) ; }
public void set bold ( boolean bold ) { get r pr ( ) . set b ( bold ) ; }
public void set subscript ( double offset ) { set baseline ( offset == null ? null : - math . ab ( offset ) ) ; }
public void set subscript ( double offset ) { set baseline ( offset == null ? null : - math . ab ( offset ) ) ; }
public string get parse string ( ) { if ( parsed part == null ) { return null ; } string builder sb = new string builder ( ) ; for ( base64 u r l part : parsed part ) { if ( sb . length ( ) > 0 ) { sb . append ( ' . ' ) ; } if ( part ! = null ) { sb . append ( part . to string ( ) ) ; } } return sb . to string ( ) ; }
public string get text ( boolean get slide text , boolean get note text ) { return get text ( get slide text , get note text , comment by default , master by default ) ; }
public static x s s f workbook create workbook ( input stream stream ) throw i o exception , invalid format exception { o p c package pkg = o p c package . open ( stream ) ; return create workbook ( pkg ) ; }
public static void marshal ( object jaxb object , file xml ) { _marshal ( jaxb object , xml ) ; }
public void set name ( string name ) { if ( this . can set field value ( this . name , name ) ) { this . name = name ; this . change ( ) ; } }
public c t color get c t color ( ) { return ct color ; }
public reader parse ( path path , metadata metadata ) throw i o exception { input stream stream = tika input stream . get ( path , metadata ) ; return parse ( stream , metadata ) ; }
protect x m l reader create x m l reader ( ) throw s a x exception { return s a x helper . create x m l reader ( be validate ( ) ) ; }
public c t comment new comment ( cell address ref ) { c t comment ct = comment . get comment list ( ) . add new comment ( ) ; ct . set ref ( ref . format a string ( ) ) ; ct . set author id ( default_author_id ) ; if ( comment ref ! = null ) { comment ref . put ( ref , ct ) ; } return ct ; }
public void track all column for auto sizing ( ) { _auto size column tracker . track all column ( ) ; }
public boolean untrack column ( collection < integer > column ) { untracked column . add all ( column ) ; return max column width . key set ( ) . remove all ( column ) ; }
public void track column for auto sizing ( collection < integer > column ) { _auto size column tracker . track column ( column ) ; }
public x s s f picture create picture ( x s s f client anchor anchor , int picture index ) { package relationship rel = add picture reference ( picture index ) ; long shape id = new shape id ( ) ; c t two cell anchor ct anchor = create two cell anchor ( anchor ) ; c t picture ct shape = ct anchor . add new pic ( ) ; ct shape . set ( x s s f picture . prototype ( ) ) ; ct shape . get nv pic pr ( ) . get c nv pr ( ) . set id ( shape id ) ; x s s f picture shape = new x s s f picture ( this , ct shape ) ; shape . anchor = anchor ; shape . set picture reference ( rel ) ; ct shape . get sp pr ( ) . set xfrm ( create xfrm ( anchor ) ) ; return shape ; }
public static int get first row ( row selection selection ) { return ( selection == null || selection . get first row ( ) == null ) ? 0 : selection . get first row ( ) ; }
public boolean track column ( int column ) { untracked column . remove ( column ) ; if ( ! max column width . contains key ( column ) ) { max column width . put ( column , new column width pair ( ) ) ; return true ; } return false ; }
public void lock object ( boolean enable ) { safe get protection field ( ) . set object ( enable ) ; }
public boolean be compress temp file ( ) { return _compress tmp file ; }
public theme table get theme ( ) { return theme ; }
public c t col get column ( long index , boolean split column ) { return get column1 base ( index+1 , split column ) ; }
public boolean style exist ( string style i d ) { for ( x w p f style style : list style ) { if ( style . get style id ( ) . equal ( style i d ) ) return true ; } return false ; }
public void set title formula ( string formula ) { c t title ct title ; if ( chart . be set title ( ) ) { ct title = chart . get title ( ) ; } else { ct title = chart . add new title ( ) ; } c t tx tx ; if ( ct title . be set tx ( ) ) { tx = ct title . get tx ( ) ; } else { tx = ct title . add new tx ( ) ; } if ( tx . be set rich ( ) ) { tx . unset rich ( ) ; } c t str ref str ref ; if ( tx . be set str ref ( ) ) { str ref = tx . get str ref ( ) ; } else { str ref = tx . add new str ref ( ) ; } str ref . set f ( formula ) ; }
public theme get theme ( string theme name ) { if ( theme name == null ) { return null ; } theme theme = this . theme cache . get ( theme name ) ; if ( theme == null ) { synchronize ( this . theme cache ) { theme = this . theme cache . get ( theme name ) ; if ( theme == null ) { string basename = this . basename prefix + theme name ; message source message source = create message source ( basename ) ; theme = new simple theme ( theme name , message source ) ; init parent ( theme ) ; this . theme cache . put ( theme name , theme ) ; if ( logger . be debug enable ( ) ) { logger . debug ( `` theme create : name ' `` + theme name + `` ' , basename [ `` + basename + `` ] `` ) ; } } } } return theme ; }
protect void set id ( long id ) { graphic frame . get nv graphic frame pr ( ) . get c nv pr ( ) . set id ( id ) ; }
public hyperlink type get type ( ) { return _type ; }
public string get cell ref ( ) { return _ct hyperlink . get ref ( ) ; }
public void set line width ( float line width ) throw i o exception { if ( in text mode ) { throw new illegal state exception ( `` error : set line width be not allow within a text block . `` ) ; } write operand ( line width ) ; write operator ( `` w `` ) ; }
public void set comment ( sort set < comment > comment ) { if ( comment == null ) { this . comment = null ; } else { if ( this . comment ! = null ) this . comment . clear ( ) ; for ( comment c : comment ) add comment ( c ) ; } }
public void set picture reference ( package relationship rel ) { ct pic . get blip fill ( ) . get blip ( ) . set embed ( rel . get id ( ) ) ; }
public void add col label ( int column index , string value format ) { check column index ( column index ) ; area reference pivot area = get pivot area ( ) ; final int last row index = pivot area . get last cell ( ) . get row ( ) - pivot area . get first cell ( ) . get row ( ) ; c t pivot field pivot field = pivot table definition . get pivot field ( ) ; c t pivot field pivot field = c t pivot field . factory . new instance ( ) ; c t item item = pivot field . add new item ( ) ; pivot field . set axis ( s t axis . axis_col ) ; pivot field . set show all ( false ) ; if ( value format ! = null & & ! value format . trim ( ) . be empty ( ) ) { data format df = parent sheet . get workbook ( ) . create data format ( ) ; pivot field . set num fmt id ( df . get format ( value format ) ) ; } for ( int i = 0 ; i < = last row index ; i++ ) { item . add new item ( ) . set t ( s t item type . default ) ; } item . set count ( item . size of item array ( ) ) ; pivot field . set pivot field array ( column index , pivot field ) ; c t col field col field ; if ( pivot table definition . get col field ( ) ! = null ) { col field = pivot table definition . get col field ( ) ; } else { col field = pivot table definition . add new col field ( ) ; } col field . add new field ( ) . set x ( column index ) ; col field . set count ( col field . size of field array ( ) ) ; }
public void set page order ( page order page order ) { s t page order . enum v = s t page order . enum . for int ( page order . get value ( ) ) ; page setup . set page order ( v ) ; }
protect static c t graphical object frame prototype ( ) { if ( prototype == null ) { c t graphical object frame graphic frame = c t graphical object frame . factory . new instance ( ) ; c t graphical object frame non visual nv graphic = graphic frame . add new nv graphic frame pr ( ) ; c t non visual drawing prop prop = nv graphic . add new c nv pr ( ) ; prop . set id ( 0 ) ; prop . set name ( `` diagramm 1 `` ) ; nv graphic . add new c nv graphic frame pr ( ) ; c t transform2 d transform = graphic frame . add new xfrm ( ) ; c t positive size2 d ext point = transform . add new ext ( ) ; c t point2 d off point = transform . add new off ( ) ; ext point . set cx ( 0 ) ; ext point . set cy ( 0 ) ; off point . set x ( 0 ) ; off point . set y ( 0 ) ; / * c t graphical object graphic = * / graphic frame . add new graphic ( ) ; prototype = graphic frame ; } return prototype ; }
public h s l f font info get font info ( string typeface ) { return font . get ( typeface ) ; }
public void set decompress concatenate ( final boolean decompress concatenate ) { if ( this . decompress until e o f ! = null ) { throw new illegal state exception ( `` can not override the setting define by the constructor `` ) ; } this . decompress concatenate = decompress concatenate ; }
public x w p f header get header ( int page number ) { if ( page number == 1 & & first page header ! = null ) { return first page header ; } if ( page number % 2 == 0 & & even page header ! = null ) { return even page header ; } return default header ; }
public x w p f header get header ( enum type ) { if ( type == s t hdr ftr . even ) { return even page header ; } else if ( type == s t hdr ftr . first ) { return first page header ; } return default header ; }
public void set chart right margin ( long margin ) { ct inline . set dist r ( margin ) ; }
public int get po of paragraph ( x w p f paragraph p ) { return get po of body element ( p ) ; }
public x w p f table create table ( int row , int col ) { x w p f table table = new x w p f table ( header footer . add new tbl ( ) , this , row , col ) ; table . add ( table ) ; body element . add ( table ) ; return table ; }
public x s l f chart create chart ( x s l f slide slide ) { int chart idx = find next available file name index ( x s l f relation . chart , _charts . size ( ) + 1 ) ; x s l f chart chart = ( x s l f chart ) create relationship ( x s l f relation . chart , x s l f factory . get instance ( ) , chart idx , true ) . get document part ( ) ; slide . add relation ( null , x s l f relation . chart , chart ) ; chart . set chart index ( chart idx ) ; _charts . add ( chart ) ; return chart ; }
public x w p f footnote create footnote ( ) { if ( footnote == null ) { footnote document footnote doc = footnote document . factory . new instance ( ) ; x w p f relation relation = x w p f relation . footnote ; int i = get relation index ( relation ) ; x w p f footnote wrapper = ( x w p f footnote ) create relationship ( relation , x w p f factory . get instance ( ) , i ) ; wrapper . set footnote ( footnote doc . add new footnote ( ) ) ; wrapper . set id manager ( this . footnote id manager ) ; footnote = wrapper ; } return footnote ; }
public list < x w p f picture data > get all picture ( ) { return collection . unmodifiable list ( picture ) ; }
public void remove paragraph ( x w p f paragraph paragraph ) { if ( paragraph . contains ( paragraph ) ) { ctp ct p = paragraph . get c t p ( ) ; xml cursor c = ct p . new cursor ( ) ; c . remove xml ( ) ; c . dispose ( ) ; paragraph . remove ( paragraph ) ; body element . remove ( paragraph ) ; } }
public x w p f hyperlink get hyperlink ( x w p f document document ) { string id = get hyperlink id ( ) ; if ( id == null ) return null ; return document . get hyperlink by i d ( id ) ; }
public x w p f num get num ( big integer num i d ) { for ( x w p f num num : nums ) { if ( num . get c t num ( ) . get num id ( ) . equal ( num i d ) ) return num ; } return null ; }
public string get next style i d ( ) { if ( ct style . get next ( ) ! = null ) return ct style . get next ( ) . get val ( ) ; else return null ; }
public string get color ( ) { string color = null ; c t tc pr tcpr = ct tc . get tc pr ( ) ; if ( tcpr ! = null ) { c t shd ctshd = tcpr . get shd ( ) ; if ( ctshd ! = null ) { color = ctshd . xget fill ( ) . get string value ( ) ; } } return color ; }
public string get color ( ) { string color = null ; c t tc pr tcpr = ct tc . get tc pr ( ) ; if ( tcpr ! = null ) { c t shd ctshd = tcpr . get shd ( ) ; if ( ctshd ! = null ) { color = ctshd . xget fill ( ) . get string value ( ) ; } } return color ; }
public string [ ] get all text ( ) { list < string > text = new array list < > ( ) ; for ( stream stream : hdgf . get top level stream ( ) ) { find text ( stream , text ) ; } return text . to array ( new string [ 0 ] ) ; }
public int size in byte ( ) { return header size in byte ; }
public list < t n e f attribute > get message attribute ( ) { return collection . unmodifiable list ( message attribute ) ; }
public m a p i attribute get m a p i attribute ( m a p i property id ) { for ( m a p i attribute attr : mapi attribute ) { if ( attr . get property ( ) == id ) { return attr ; } } return null ; }
public static byte [ ] decompress ( byte [ ] value ) throw data format exception { return decompress ( value , 0 , value . length ) ; }
public boolean be footer visible ( ) { return be visible ( header footer atom . f have footer , placeholder . footer ) ; }
public static int get octal byte ( long value , byte [ ] buf , int offset , int length ) { int idx = length - 1 ; buf [ offset + idx ] = 0 ; -- idx ; buf [ offset + idx ] = ( byte ) ' ' ; -- idx ; if ( value == 0 ) { buf [ offset + idx ] = ( byte ) ' 0 ' ; -- idx ; } else { for ( long val = value ; idx > = 0 & & val > 0 ; -- idx ) { buf [ offset + idx ] = ( byte ) ( ( byte ) ' 0 ' + ( byte ) ( val & 7 ) ) ; val = val > > 3 ; } } for ( ; idx > = 0 ; -- idx ) { buf [ offset + idx ] = ( byte ) ' ' ; } return offset + length ; }
public long get record type ( ) { return _type ; }
public void set accent and follow hyperlink colour r g b ( int rgb ) { accent and follow hyperlink colour r g b = rgb ; }
public int get color ( int idx ) { int [ ] clr = { background colour r g b , text and line colour r g b , shadow colour r g b , title text colour r g b , fill colour r g b , accent colour r g b , accent and hyperlink colour r g b , accent and follow hyperlink colour r g b } ; return clr [ idx ] ; }
public note atom get note atom ( ) { return note atom ; }
public string get text ( ) { return comment record == null ? null : comment record . get text ( ) ; }
public date get date ( ) { return system time utils . get date ( _data,4 ) ; }
public format set omit encode ( boolean omit encode ) { this . omit encode = omit encode ; return this ; }
public boolean get show result ( ) { return show result ; }
public long get record type ( ) { return record type . ex control . type i d ; }
public boolean get cant lock server b ( ) { return _data [ 4 ] ! = 0 ; }
public string _get detail a ( ) { return link detail a == null ? null : link detail a . get text ( ) ; }
public int get format id ( ) { return little endian . get short ( _recdata , 0 ) ; }
public ex obj list get ex obj list ( boolean create ) { if ( ex obj list == null & & create ) { ex obj list = new ex obj list ( ) ; add child after ( ex obj list , get document atom ( ) ) ; } return ex obj list ; }
public void set sub type ( int type ) { little endian . put int ( _data , 12 , type ) ; }
public int get font type ( ) { return _recdata [ 66 ] ; }
public long get record type ( ) { return _type ; }
public int get placeholder id ( ) { return placeholder id ; }
public int get index ( ) { return _index ; }
public long get record type ( ) { return _type ; }
public escher container record get escher container ( ) { for ( escher record er : escher record ) { if ( er instanceof escher container record ) { return ( escher container record ) er ; } } return null ; }
public static h s l f sound data [ ] find ( document document ) { array list < h s l f sound data > lst = new array list < > ( ) ; record [ ] ch = document . get child record ( ) ; for ( int i = 0 ; i < ch . length ; i++ ) { if ( ch [ i ] . get record type ( ) == record type . sound collection . type i d ) { record container col = ( record container ) ch [ i ] ; record [ ] sr = col . get child record ( ) ; for ( int j = 0 ; j < sr . length ; j++ ) { if ( sr [ j ] instanceof sound ) { lst . add ( new h s l f sound data ( ( sound ) sr [ j ] ) ) ; } } } } return lst . to array ( new h s l f sound data [ lst . size ( ) ] ) ; }
public slide atom get slide atom ( ) { return slide atom ; }
public int get paragraph text length cover ( ) { return get character cover ( paragraph style ) ; }
public h s l f picture data get picture data ( ) { abstract escher opt record opt = shape . get escher opt record ( ) ; escher simple property p = h s l f shape . get escher property ( opt , escher property . fill__patterntexture ) ; if ( p == null ) { return null ; } h s l f slide show ppt = shape . get sheet ( ) . get slide show ( ) ; list < h s l f picture data > pict = ppt . get picture data ( ) ; document doc = ppt . get document record ( ) ; escher container record dgg container = doc . get p p draw group ( ) . get dgg container ( ) ; escher container record bstore = h s l f shape . get escher child ( dgg container , escher container record . bstore_container ) ; java . util . list < escher record > lst = bstore . get child record ( ) ; int idx = p . get property value ( ) ; if ( idx == 0 ) { log . log ( p o i logger . warn , `` no reference to picture data find `` ) ; } else { escher b s e record bse = ( escher b s e record ) lst . get ( idx - 1 ) ; for ( h s l f picture data pd : pict ) { if ( pd . get offset ( ) == bse . get offset ( ) ) { return pd ; } } } return null ; }
public void add shape ( h s l f shape shape ) { p p draw ppdrawing = get p p drawing ( ) ; escher container record dg container = ppdrawing . get dg container ( ) ; escher container record spgr = h s l f shape . get escher child ( dg container , escher container record . spgr_container ) ; spgr . add child record ( shape . get sp container ( ) ) ; shape . set sheet ( this ) ; shape . set shape id ( allocate shape id ( ) ) ; shape . after insert ( this ) ; }
public void set anchor ( rectangle2 d anchor ) { int x = unit . point to master ( anchor . get x ( ) ) ; int y = unit . point to master ( anchor . get y ( ) ) ; int w = unit . point to master ( anchor . get width ( ) + anchor . get x ( ) ) ; int h = unit . point to master ( anchor . get height ( ) + anchor . get y ( ) ) ; escher sp record sp record = get escher child ( escher sp record . record_id ) ; int flag = sp record . get flags ( ) ; if ( ( flag & escher sp record . flag_child ) ! = 0 ) { escher child anchor record rec = get escher child ( escher child anchor record . record_id ) ; rec . set dx1 ( x ) ; rec . set dy1 ( y ) ; rec . set dx2 ( w ) ; rec . set dy2 ( h ) ; } else { escher client anchor record rec = get escher child ( escher client anchor record . record_id ) ; rec . set col1 ( ( short ) x ) ; rec . set flag ( ( short ) y ) ; rec . set dx1 ( ( short ) w ) ; rec . set row1 ( ( short ) h ) ; } }
public final serializable get id ( ) { if ( id instanceof delay post insert identifier ) { final entity entry entry = session . get persistence context internal ( ) . get entry ( instance ) ; final serializable ee id = entry == null ? null : entry . get id ( ) ; return ee id instanceof delay post insert identifier ? null : ee id ; } return id ; }
public void set anchor ( h s s f anchor anchor ) { int i = 0 ; int record id = -1 ; if ( parent == null ) { if ( anchor instanceof h s s f child anchor ) throw new illegal argument exception ( `` must use client anchor for shape directly attach to sheet . `` ) ; escher client anchor record anch = _escher container . get child by id ( escher client anchor record . record_id ) ; if ( null ! = anch ) { for ( i=0 ; i < _escher container . get child record ( ) . size ( ) ; i++ ) { if ( _escher container . get child ( i ) . get record id ( ) == escher client anchor record . record_id ) { if ( i ! = _escher container . get child record ( ) . size ( ) -1 ) { record id = _escher container . get child ( i+1 ) . get record id ( ) ; } } } _escher container . remove child record ( anch ) ; } } else { if ( anchor instanceof h s s f client anchor ) throw new illegal argument exception ( `` must use child anchor for shape attach to group . `` ) ; escher child anchor record anch = _escher container . get child by id ( escher child anchor record . record_id ) ; if ( null ! = anch ) { for ( i=0 ; i < _escher container . get child record ( ) . size ( ) ; i++ ) { if ( _escher container . get child ( i ) . get record id ( ) == escher child anchor record . record_id ) { if ( i ! = _escher container . get child record ( ) . size ( ) -1 ) { record id = _escher container . get child ( i+1 ) . get record id ( ) ; } } } _escher container . remove child record ( anch ) ; } } if ( -1 == record id ) { _escher container . add child record ( anchor . get escher anchor ( ) ) ; } else { _escher container . add child before ( anchor . get escher anchor ( ) , record id ) ; } this . anchor = anchor ; }
public h s l f master sheet get master sheet ( ) { return null ; }
protect escher container record create sp container ( int idx , boolean be child ) { escher container record ecr = super . create sp container ( idx , be child ) ; escher sp record sp record = ecr . get child by id ( escher sp record . record_id ) ; sp record . set flag ( escher sp record . flag_haveanchor | escher sp record . flag_hasshapetype | escher sp record . flag_oleshape ) ; set shape type ( shape type . host_control ) ; set escher property ( escher property . blip__pictureid , idx ) ; set escher property ( escher property . linestyle__color , 0x8000001 ) ; set escher property ( escher property . linestyle__nolinedrawdash , 0x80008 ) ; set escher property ( escher property . shadowstyle__color , 0x8000002 ) ; set escher property ( escher property . protection__lockagainstgrouping , -1 ) ; h s l f escher client data record cldata = get client data ( true ) ; cldata . add child ( new ex obj ref atom ( ) ) ; return ecr ; }
public p p draw get p p drawing ( ) { return pp drawing ; }
public static h s l f slide show impl create ( ) { input stream be = h s l f slide show impl . class . get resource a stream ( `` /org/apache/poi/hslf/data/empty . ppt `` ) ; if ( be == null ) { throw new h s l f exception ( `` miss resource 'empty . ppt ' `` ) ; } try { try { return new h s l f slide show impl ( be ) ; } finally { be . close ( ) ; } } catch ( i o exception e ) { throw new h s l f exception ( e ) ; } }
public byte [ ] get byte ( ) { byte [ ] ret = delegate . get byte ( ) ; return ret ; }
public static date get date ( byte [ ] data ) { return get date ( data,0 ) ; }
public string get string from chunk ( string chunk chunk ) throw chunk not find exception { if ( chunk == null ) { if ( return null on miss chunk ) { return null ; } else { throw new chunk not find exception ( ) ; } } return chunk . get value ( ) ; }
public string get display from ( ) throw chunk not find exception { return get string from chunk ( main chunk . get display from chunk ( ) ) ; }
public boolean get boolean value ( ) throw data conversion exception { string value trim = value . trim ( ) ; if ( ( value trim . equal ignore case ( `` true `` ) ) || ( value trim . equal ignore case ( `` on `` ) ) || ( value trim . equal ignore case ( `` 1 `` ) ) || ( value trim . equal ignore case ( `` yes `` ) ) ) { return true ; } else if ( ( value trim . equal ignore case ( `` false `` ) ) || ( value trim . equal ignore case ( `` off `` ) ) || ( value trim . equal ignore case ( `` 0 `` ) ) || ( value trim . equal ignore case ( `` no `` ) ) ) { return false ; } else { throw new data conversion exception ( name , `` boolean `` ) ; } }
public list < palette entry > get palette ( ) { return palette ; }
public list < picture > get all picture ( ) { array list < picture > picture = new array list < > ( ) ; range range = _document . get overall range ( ) ; for ( int i = 0 ; i < range . num character run ( ) ; i++ ) { character run run = range . get character run ( i ) ; if ( run==null ) { continue ; } picture picture = extract picture ( run , false ) ; if ( picture ! = null ) { picture . add ( picture ) ; } } search for picture ( _dgg . get escher record ( ) , picture ) ; return picture ; }
public void remove auth role ( string auth role ) { if ( auth role == null ) return ; if ( role_all_roles . equal ( auth role ) ) { all role = false ; return ; } if ( role_all_authenticated_users . equal ( auth role ) ) { authenticated user = false ; return ; } int n = -1 ; for ( int i = 0 ; i < auth role . length ; i++ ) { if ( auth role [ i ] . equal ( auth role ) ) { n = i ; break ; } } if ( n > = 0 ) { int j = 0 ; string result [ ] = new string [ auth role . length - 1 ] ; for ( int i = 0 ; i < auth role . length ; i++ ) { if ( i ! = n ) result [ j++ ] = auth role [ i ] ; } auth role = result ; } }
public style get style ( int index ) { return style [ index ] ; }
public ascii string sub sequence ( int start , int end , boolean copy ) { if ( be out of bound ( start , end - start , length ( ) ) ) { throw new index out of bound exception ( `` expect : 0 < = start ( `` + start + `` ) < = end ( `` + end + `` ) < = length ( `` + length ( ) + ' ) ' ) ; } if ( start == 0 & & end == length ( ) ) { return this ; } if ( end == start ) { return empty_string ; } return new ascii string ( value , start + offset , end - start , copy ) ; }
public void set bkf_flags ( short field_2_bkf_flags ) { this . field_2_bkf_flags = field_2_bkf_flags ; }
public boolean be f result dirty ( ) { return f result dirty . be set ( field_2_flt ) ; }
public void set lnc ( byte field_9_lnc ) { this . field_9_lnc = field_9_lnc ; }
public int get dxa lnn ( ) { return field_12_dxa lnn ; }
public void set dm bin other ( int field_18_dm bin other ) { this . field_18_dm bin other = field_18_dm bin other ; }
public int get dxt char space ( ) { return field_27_dxt char space ; }
public static short format short ( string value ) { if ( value == null ) { return null ; } try { return new short ( value ) ; } catch ( number format exception e ) { return null ; } }
public int get xa page n up ( ) { return field_41_xa page n up ; }
public int get xa page n up ( ) { return field_41_xa page n up ; }
public void set unused5 ( byte field_52_unused5 ) { this . field_52_unused5 = field_52_unused5 ; }
public void set olst anm ( byte [ ] field_59_olst anm ) { this . field_59_olst anm = field_59_olst anm ; }
public void set f hdr row ( boolean value ) { field_2_tlp_flags = ( byte ) f hdr row . set boolean ( field_2_tlp_flags , value ) ; }
public boolean be shadow ( ) { return shadow . be set ( field_1_format flag ) ; }
public j frame get frame ( component comp ) { if ( comp instanceof j frame ) { return ( j frame ) comp ; } return get frame ( comp . get parent ( ) ) ; }
public string get text ( ) { return string util . get from compress unicode ( _text,0 , _text . length ) ; }
public table insert table before ( short column , int row ) { paragraph property par prop = new paragraph property ( ) ; par prop . set f in table ( true ) ; par prop . set itap ( 1 ) ; final int old end = this . _end ; for ( int x = 0 ; x < row ; x++ ) { paragraph cell = this . insert before ( par prop , style sheet . nil_style ) ; cell . insert after ( string . value of ( '\u0007 ' ) ) ; for ( int y = 1 ; y < columns ; y++ ) { cell = cell . insert after ( par prop , style sheet . nil_style ) ; cell . insert after ( string . value of ( '\u0007 ' ) ) ; } cell = cell . insert after ( par prop , style sheet . nil_style , string . value of ( '\u0007 ' ) ) ; cell . set table row end ( new table property ( column ) ) ; } final int new end = this . _end ; final int diff = new end - old end ; return new table ( _start , _start + diff , this , 1 ) ; }
public character run get character run ( int index ) { init character run ( ) ; if ( index + _char start > = _char end ) throw new index out of bound exception ( `` chpx # `` + index + `` ( `` + ( index + _char start ) + `` ) not in range [ `` + _char start + `` ; `` + _char end + `` ) `` ) ; chpx chpx = _characters . get ( index + _char start ) ; if ( chpx == null ) { return null ; } short istd ; if ( this instanceof paragraph ) { istd = ( ( paragraph ) this ) . _istd ; } else { int [ ] point = find range ( _paragraphs , math . max ( chpx . get start ( ) , _start ) , math . min ( chpx . get end ( ) , _end ) ) ; init paragraph ( ) ; int par start = math . max ( point [ 0 ] , _par start ) ; if ( par start > = _paragraphs . size ( ) ) { return null ; } papx papx = _paragraphs . get ( point [ 0 ] ) ; istd = papx . get istd ( ) ; } return new character run ( chpx , _doc . get style sheet ( ) , istd , this ) ; }
public static void write operation ( stream output out stream , list < operation > to write ) throw i o exception { final byte stream output out = new byte stream output ( ) ; out stream . write int ( to write . size ( ) ) ; final buffer checksum stream output checksum stream output = new buffer checksum stream output ( out ) ; for ( operation op : to write ) { out . reset ( ) ; write operation no size ( checksum stream output , op ) ; out stream . write int ( math . to int exact ( out . position ( ) ) ) ; out . byte ( ) . write to ( out stream ) ; } }
public static int compute u int32 size ( final int field number , final int value ) { return compute tag size ( field number ) + compute u int32 size no tag ( value ) ; }
public static int compute lazy field size ( final int field number , final lazy field lite value ) { return compute tag size ( field number ) + compute lazy field size no tag ( value ) ; }
public static int compute u int32 size ( final int field number , final int value ) { return compute tag size ( field number ) + compute u int32 size no tag ( value ) ; }
public void set message type ( string message type ) { this . message type = message type ; }
public java . lang . string get name ( ) { java . lang . object ref = name_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; name_ = s ; return s ; } }
public static string new string utf8 ( final byte [ ] bytes ) { return new string ( byte , charsets . utf_8 ) ; }
public boolean get response streaming ( ) { return response streaming_ ; }
public java . util . list < com . google . protobuf . field > get field list ( ) { return fields_ ; }
public syntax exception get syntax error ( final int index ) { syntax exception exception = null ; message message = get error ( index ) ; if ( message instanceof syntax error message ) { exception = ( ( syntax error message ) message ) . get cause ( ) ; } return exception ; }
public b type get builder ( int index ) { ensure builder ( ) ; single field builder < m type , b type , i type > builder = builder . get ( index ) ; if ( builder == null ) { m type message = message . get ( index ) ; builder = new single field builder < m type , b type , i type > ( message , this , be clean ) ; builder . set ( index , builder ) ; } return builder . get builder ( ) ; }
public list < text format parse location > get location ( final field descriptor field descriptor ) { list < text format parse location > result = location from field . get ( field descriptor ) ; return ( result == null ) ? collection . < text format parse location > empty list ( ) : result ; }
public document field field ( string field name ) { document field result = document field . get ( field name ) ; if ( result ! = null ) { return result ; } else { return meta field . get ( field name ) ; } }
public void set path ( path path ) { set path ( paths collection . of ( path ) ) ; }
public void set string path ( string path ) { if ( ! path . be empty ( ) & & ! path . end with ( file . separator ) ) { path += file . separator char ; } this . string path = path ; }
public list < app dependency > get user dependency ( ) { return runtime deps ; }
public t set remote repository manager ( remote repository manager remote repo manager ) { this . remote repo manager = remote repo manager ; return ( t ) this ; }
public < t extend multi build item > list < t > consume multi ( class < t > type , comparator < ? super t > comparator ) { final list < t > result = consume multi ( type ) ; result . sort ( comparator ) ; return result ; }
public object get ( final object key ) { if ( key instanceof string ) { return this . get property ( ( string ) key ) ; } else { return super . get ( key ) ; } }
public string to string ( ) { if ( get file ( ) == null ) { return `` ( unknown file ) `` ; } int ln = get line ( ) ; return ( ln > = 1 ) ? `` ( `` + get file ( ) . get absolute path ( ) . replace ( '\\ ' , '/ ' ) . replace ( `` c : / `` , `` / `` ) + `` : `` + ln + `` ) `` : get file ( ) . get absolute path ( ) . replace ( '\\ ' , '/ ' ) . replace ( `` c : / `` , `` / `` ) ; }
public static < t extend panache entity base > panache query < t > find ( string query , object . . . params ) { throw jpa operation . implementation injection miss ( ) ; }
public static < t extend panache entity base > panache query < t > find ( string query , sort sort , object . . . params ) { throw jpa operation . implementation injection miss ( ) ; }
public static long count ( string query , object . . . params ) { throw jpa operation . implementation injection miss ( ) ; }
public static page of ( int index , int size ) { return new page ( index , size ) ; }
public static sort descending ( string . . . column ) { sort sort = new sort ( ) ; for ( string column : column ) { sort . and ( column , direction . descend ) ; } return sort ; }
public static sort descending ( string . . . column ) { sort sort = new sort ( ) ; for ( string column : column ) { sort . and ( column , direction . descend ) ; } return sort ; }
public static sort descending ( string . . . column ) { sort sort = new sort ( ) ; for ( string column : column ) { sort . and ( column , direction . descend ) ; } return sort ; }
public static uni < security identity > get security identity ( rout context rout context , identity provider manager identity provider manager ) { uni < security identity > defer = rout context . get ( deferred_identity_key ) ; if ( deferred ! = null ) { return defer ; } quarkus http user exist = ( quarkus http user ) rout context . user ( ) ; if ( exist ! = null ) { return uni . create from ( ) . item ( exist . get security identity ( ) ) ; } if ( identity provider manager ! = null ) { return identity provider manager . authenticate ( anonymous authentication request . instance ) ; } return uni . create from ( ) . null item ( ) ; }
public static < t > org . reactivestreams . subscriber < t > to subscriber ( flow . subscriber < t > flow subscriber ) { require non null ( flow subscriber , `` flow subscriber `` ) ; final org . reactivestreams . subscriber < t > subscriber ; if ( flow subscriber instanceof flow to reactive subscriber ) { subscriber = ( org . reactivestreams . subscriber < t > ) ( ( flow to reactive subscriber < t > ) flow subscriber ) . reactive stream ; } else if ( flow subscriber instanceof org . reactivestreams . subscriber ) { subscriber = ( org . reactivestreams . subscriber < t > ) flow subscriber ; } else { subscriber = new reactive to flow subscriber < t > ( flow subscriber ) ; } return subscriber ; }
public final mono < t > metric ( ) { if ( ! metric . be instrumentation available ( ) ) { return this ; } if ( this instanceof fuseable ) { return on assembly ( new mono metric fuseable < > ( this ) ) ; } return on assembly ( new mono metric < > ( this ) ) ; }
public void try terminate consumer ( subscriber < ? > consumer ) { throwable ex = terminate ( ) ; if ( ex == null ) { consumer . on complete ( ) ; } else if ( ex ! = exception helper . terminate ) { consumer . on error ( ex ) ; } }
public static < t > replay processor < t > create timeout ( duration max age ) { return create timeout ( max age , scheduler . parallel ( ) ) ; }
public static < t > subscription scalar subscription ( core subscriber < ? super t > subscriber , t value , string step name ) { return new scalar subscription < > ( subscriber , value , step name ) ; }
public final parallel flux < t > do on subscribe ( consumer < ? super subscription > on subscribe ) { object . require non null ( on subscribe , `` on subscribe `` ) ; return do on signal ( this , null , null , null , null , null , on subscribe , null , null ) ; }
public final flux < t > sequential ( int prefetch ) { return flux . on assembly ( new parallel merge sequential < > ( this , prefetch , queue . get ( prefetch ) ) ) ; }
public static int mul and check ( int x , int y ) throw math arithmetic exception { long m = ( ( long ) x ) * ( ( long ) y ) ; if ( m < integer . min_value || m > integer . max_value ) { throw new math arithmetic exception ( ) ; } return ( int ) m ; }
public static int ceiling next power of two ( final int x ) { return 1 < < ( bits_per_int - integer . number of lead zero ( x - 1 ) ) ; }
public static date create date ( string str ) { throw new unsupported operation exception ( `` not yet implement `` ) ; }
public final byte buf flux retain ( ) { return maybe fuse ( do on next ( byte buf : : retain ) , alloc ) ; }
public final boolean be dispose ( ) { return subscription helper . be cancel ( s . get ( ) ) ; }
public netty server builder ssl context ( ssl context ssl context ) { if ( ssl context ! = null ) { check argument ( ssl context . be server ( ) , `` client ssl context can not be use for server `` ) ; grpc ssl context . ensure alpn and h2 enable ( ssl context . application protocol negotiator ( ) ) ; } this . ssl context = ssl context ; return this ; }
public static inet socket address replace with resolve ( inet socket address inet socket address ) { require non null ( inet socket address , `` inet socket address `` ) ; if ( ! inet socket address . be unresolved ( ) ) { return inet socket address ; } inet socket address = replace unresolved numeric ip ( inet socket address ) ; if ( ! inet socket address . be unresolved ( ) ) { return inet socket address ; } else { return new inet socket address ( inet socket address . get host string ( ) , inet socket address . get port ( ) ) ; } }
public byte [ ] get byte ( ) throw i o exception { byte buf byte buf = file upload . get byte buf ( ) ; if ( byte buf == null ) { throw new i o exception ( `` the byte have already be release `` ) ; } try { return byte buf util . get byte ( byte buf ) ; } finally { if ( control release ) { byte buf . release ( ) ; } } }
public address resolver option set query timeout ( long query timeout ) { if ( query timeout < 1 ) { throw new illegal argument exception ( `` query timeout must be > 0 `` ) ; } this . query timeout = query timeout ; return this ; }
public boolean be accept gzip encode ( ) { return accept gzip encoding ; }
public final http client follow redirect ( boolean follow redirect ) { if ( ! follow redirect & & configuration ( ) . follow redirect predicate == null & & configuration ( ) . redirect request consumer == null & & configuration ( ) . redirect request bi consumer == null ) { return this ; } return follow redirect ( follow redirect , ( consumer < http client request > ) null ) ; }
public static cooky new server request holder ( http header header , server cookie decoder decoder ) { return new cooky ( header , http header name . cookie , false , decoder ) ; }
public final void set read chunk size ( int chunk size ) { if ( chunk size < = 0 ) { throw new illegal argument exception ( `` chunk size must be positive `` ) ; } this . chunk size = chunk size ; }
protect calendar action result internal accept ( boolean tentative , boolean send response ) throw exception { accept meeting invitation message accept = this . create accept message ( tentative ) ; if ( send response ) { return accept . calendar send and save copy ( ) ; } else { return accept . calendar save ( ) ; } }
public final http server idle timeout ( duration idle timeout ) { object . require non null ( idle timeout , `` idle timeout `` ) ; http server dup = duplicate ( ) ; dup . configuration ( ) . idle timeout = idle timeout ; return dup ; }
public form auth config with additional field ( string field name ) { not null ( field name , `` additional field name `` ) ; list < string > list = new array list < string > ( additional input field name ) ; list . add ( field name ) ; return new form auth config ( form action , user input tag name , password input tag name , log detail , log config , csrf field name , auto detect csrf field name , send csrf token a form param , list ) ; }
public request spec builder add multi part ( string control name , file file ) { spec . multi part ( control name , file ) ; return this ; }
public request spec builder add cookie ( cookie cookie ) { spec . cookie ( cookie ) ; return this ; }
public request spec builder add multi part ( string control name , file file ) { spec . multi part ( control name , file ) ; return this ; }
public r socket security simple authentication ( customizer < simple authentication spec > simple ) { if ( this . simple auth spec == null ) { this . simple auth spec = new simple authentication spec ( ) ; } simple . customize ( this . simple auth spec ) ; return this ; }
public request spec builder set proxy ( int port ) { spec . proxy ( port ) ; return this ; }
public response builder set header ( string name , string value ) { not null ( name , `` header name `` ) ; not null ( value , `` header value `` ) ; list < header > new header = new array list < header > ( rest assure response . header ( ) . a list ( ) ) ; new header . add ( new header ( name , value ) ) ; rest assure response . set response header ( new header ( new header ) ) ; if ( trim ( name ) . equal ignore case ( content_type ) ) { rest assure response . set content type ( value ) ; } return this ; }
public response spec builder expect status line ( string expect status line ) { spec . status line ( expect status line ) ; return this ; }
public void status ( int status code ) { response . set status ( status code ) ; }
public response spec builder expect status code ( matcher < integer > expect status code ) { spec . status code ( expect status code ) ; return this ; }
public response spec builder expect header ( string header name , matcher < string > expect value matcher ) { spec . header ( header name , expect value matcher ) ; return this ; }
public encoder config append default content charset to content type if undefined ( boolean should add default content charset to content type if miss ) { return new encoder config ( default content charset , default query parameter charset , should add default content charset to content type if missing , content encoders , content type to default charset , true ) ; }
public encoder config append default content charset to content type if undefined ( boolean should add default content charset to content type if miss ) { return new encoder config ( default content charset , default query parameter charset , should add default content charset to content type if missing , content encoders , content type to default charset , true ) ; }
public encoder config append default content charset to content type if undefined ( boolean should add default content charset to content type if miss ) { return new encoder config ( default content charset , default query parameter charset , should add default content charset to content type if missing , content encoders , content type to default charset , true ) ; }
public json path config default parser type ( json parser type default parser type ) { return new json path config ( number return type , default parser type , gson object mapper factory , jackson1 object mapper factory , jackson2 object mapper factory , johnzon object mapper factory , jsonb object mapper factory , default deserializer , charset ) ; }
public multi part config default boundary ( string default boundary ) { return new multi part config ( default control name , default file name , default subtype , default boundary , default charset , true ) ; }
public rest assure config encoder config ( encoder config encoder config ) { not null ( encoder config , `` encoder config `` ) ; return new rest assure config ( conf ( redirect config . class ) , conf ( http client config . class ) , conf ( log config . class ) , encoder config , conf ( decoder config . class ) , conf ( session config . class ) , conf ( object mapper config . class ) , conf ( connection config . class ) , conf ( json config . class ) , conf ( xml config . class ) , conf ( s s l config . class ) , conf ( matcher config . class ) , conf ( header config . class ) , conf ( multi part config . class ) , conf ( param config . class ) , conf ( o auth config . class ) , conf ( failure config . class ) ) ; }
public static void key store ( string path to jks , string password ) { validate . not empty ( password , `` password can not be empty `` ) ; apply key store ( path to jks , password ) ; }
public object request ( string method , boolean have body , closure config closure ) throw client protocol exception , i o exception { return this . do request ( this . default u r i . to u r i ( ) , method , this . default content type , have body , config closure ) ; }
public void shutdown ( ) { client execution timer . shutdown ( ) ; http request timer . shutdown ( ) ; idle connection reaper . remove connection manager ( http client . get http client connection manager ( ) ) ; http client . get http client connection manager ( ) . shutdown ( ) ; }
public url to u r l ( ) throw malformed u r l exception { return resource groovy method . to u r l ( ( char sequence ) text ( ) ) ; }
public synchronize boolean equal ( object another ) { if ( this == another ) { return true ; } if ( be reference ( ) ) { return get check ref ( ) . equal ( another ) ; } if ( ! ( another . get class ( ) . equal ( get class ( ) ) ) ) { return false ; } u r l resource otheru = ( u r l resource ) another ; return get u r l ( ) == null ? otheru . get u r l ( ) == null : get u r l ( ) . equal ( otheru . get u r l ( ) ) ; }
public t get ( string entity name ) { not null ( entity name , `` entity name `` ) ; list < t > copy of entity = reverse ( ) ; for ( t entity : copy of entity ) { if ( entity . get name ( ) . equal ignore case ( entity name ) ) { return entity ; } } return null ; }
public static uri strip query string ( final uri uri ) { if ( uri == null ) return null ; try { return new uri ( uri . get scheme ( ) , null , uri . get host ( ) , uri . get port ( ) , uri . get path ( ) , null , uri . get fragment ( ) ) ; } catch ( u r i syntax exception e ) { return null ; } }
public detail cookie matcher same site ( matcher < ? super string > same site matcher ) { return new detailed cookie matcher ( and ( matcher . have property ( `` same site `` , same site matcher ) ) ) ; }
public dtd create d t d ( string dtd ) { d t d event dtd event = new d t d event ( dtd ) ; if ( location ! = null ) dtd event . set location ( location ) ; return dtd event ; }
public static request specification give ( request specification request specification ) { return give ( ) . spec ( request specification ) ; }
public inbound message context header ( multivalued map < string , string > new header ) { for ( map . entry < string , list < string > > header : new header . entry set ( ) ) { header . add all ( header . get key ( ) , header . get value ( ) ) ; } return this ; }
public int get port ( ) { return _host port . get port ( ) ; }
public void inject on provider instance ( collection < ? > provider ) { for ( object o : provider ) { inject on provider instance ( o ) ; } }
public validator result validate ( ) throw validator exception { locale locale = ( locale ) this . get parameter value ( locale_param ) ; if ( locale == null ) { locale = locale . get default ( ) ; } this . set parameter ( validator_param , this ) ; form form = this . resource . get form ( locale , this . form name ) ; if ( form ! = null ) { this . set parameter ( form_param , form ) ; return form . validate ( this . parameter , this . resource . get validator action ( ) , this . page , this . field name ) ; } return new validator result ( ) ; }
public static config provider resolver instance ( ) { if ( instance == null ) { synchronize ( config provider resolver . class ) { if ( instance ! = null ) { return instance ; } instance = load spi ( config provider resolver . class . get class loader ( ) ) ; } } return instance ; }
public class method add constructor ( constructor < ? > method ) { class method class method = add method ( method . get modifier ( ) , `` < init > `` , `` v `` , descriptor utils . parameter descriptor ( method . get parameter type ( ) ) ) ; for ( class < ? > e : method . get exception type ( ) ) { class method . add checked exception ( ( class < ? extend exception > ) e ) ; } for ( annotation annotation : method . get declared annotation ( ) ) { class method . get runtime visible annotation attribute ( ) . add annotation ( annotation builder . create annotation ( const pool , annotation ) ) ; } int count = 0 ; for ( annotation [ ] parameter annotation : method . get parameter annotation ( ) ) { for ( annotation annotation : parameter annotation ) { class method . get runtime visible parameter annotation attribute ( ) . add annotation ( count , annotation builder . create annotation ( const pool , annotation ) ) ; } count++ ; } return class method ; }
public list < object property > get element ( ) { return element ! = null ? element : no_elems ; }
public int get destructuring length ( ) { return destructuring length ; }
public final observable < t > skip last ( int count ) { return lift ( new operator skip last < t > ( count ) ) ; }
public token . comment type get comment type ( ) { return comment type ; }
public string value ( ) { if ( have value ( ) ) { return value [ 0 ] ; } else { return null ; } }
public void set target ( loop target ) { assert not null ( target ) ; this . target = target ; set jump statement ( target ) ; }
public void set target ( loop target ) { assert not null ( target ) ; this . target = target ; set jump statement ( target ) ; }
public boolean have side effect ( ) { return type == token . expr_result || expr . have side effect ( ) ; }
public void set iterate object ( ast node object ) { assert not null ( object ) ; this . iterated object = object ; object . set parent ( this ) ; }
public boolean be for each ( ) { return be for each ; }
public void set in position ( int in position ) { this . in position = in position ; }
public function source function source by name ( string function name ) { return function name . get ( function name ) ; }
public package declaration set name ( final name name ) { assert not null ( name ) ; if ( name == this . name ) { return this ; } notify property change ( observable property . name , this . name , name ) ; if ( this . name ! = null ) this . name . set parent node ( null ) ; this . name = name ; set a parent node of ( name ) ; return this ; }
public boolean be expression closure ( ) { return be expression closure ; }
public request condition holder combine ( request condition holder other ) { if ( this . condition == null & & other . condition == null ) { return this ; } else if ( this . condition == null ) { return other ; } else if ( other . condition == null ) { return this ; } else { assert equal condition type ( this . condition , other . condition ) ; request condition < ? > combine = ( request condition < ? > ) this . condition . combine ( other . condition ) ; return new request condition holder ( combine ) ; } }
public int get filter lp ( ) { return lp ; }
public void set initializer ( ast node initializer ) { this . initializer = initializer ; if ( initializer ! = null ) initializer . set parent ( this ) ; }
public boolean be setter method ( ) { return type == token . set ; }
public void set name source ( name source name source ) { this . name source = name source ; }
public static string encode byte ( byte [ ] source , int option ) { return encode byte ( source , 0 , source . length , option ) ; } // end encode byte
public void add variable ( variable initializer v ) { assert not null ( v ) ; variable . add ( v ) ; v . set parent ( this ) ; }
public void set node type ( int node type ) { if ( node type ! = token . var & & node type ! = token . const & & node type ! = token . let ) throw new illegal argument exception ( `` invalid node type `` ) ; set type ( node type ) ; }
public void set expression ( ast node expression ) { assert not null ( expression ) ; expr = expression ; expression . set parent ( this ) ; set lineno ( expression . get lineno ( ) ) ; }
public void add statement ( ast node statement ) { assert not null ( statement ) ; if ( statement == null ) { statement = new array list < ast node > ( ) ; } int end = statement . get position ( ) + statement . get length ( ) ; this . set length ( end - this . get position ( ) ) ; statement . add ( statement ) ; statement . set parent ( this ) ; }
public void add fragment ( xml fragment fragment ) { assert not null ( fragment ) ; fragment . add ( fragment ) ; fragment . set parent ( this ) ; }
public string get default web xml ( ) { if ( default web xml == null ) { default web xml = constant . default web xml ; } return default web xml ; }
public require builder set pre exec ( script pre exec ) { this . pre exec = pre exec ; return this ; }
public void allow stateless ( boolean allow stateless ) { set allow stateless ( allow stateless ) ; }
public boolean support resource injection ( class < ? > c ) { if ( javax . servlet . servlet . class . be assignable from ( c ) || javax . servlet . filter . class . be assignable from ( c ) || javax . servlet . servlet context listener . class . be assignable from ( c ) || javax . servlet . servlet context attribute listener . class . be assignable from ( c ) || javax . servlet . servlet request listener . class . be assignable from ( c ) || javax . servlet . servlet request attribute listener . class . be assignable from ( c ) || javax . servlet . http . http session listener . class . be assignable from ( c ) || javax . servlet . http . http session attribute listener . class . be assignable from ( c ) || javax . servlet . http . http session id listener . class . be assignable from ( c ) || javax . servlet . async listener . class . be assignable from ( c ) || javax . servlet . http . http upgrade handler . class . be assignable from ( c ) ) return true ; return false ; }
public object get getter or setter ( string name , int index , boolean be setter ) { if ( name ! = null & & index ! = 0 ) throw new illegal argument exception ( name ) ; slot slot = unwrap slot ( get slot ( name , index , slot_query ) ) ; if ( slot == null ) return null ; if ( slot instanceof getter slot ) { getter slot gslot = ( getter slot ) slot ; object result = be setter ? gslot . setter : gslot . getter ; return result ! = null ? result : undefined . instance ; } else return undefined . instance ; }
public scriptable get parent scope ( ) { return parent scope object ; }
public static < t > t get type property ( scriptable s , string name , class < t > type ) { object val = get property ( s , name ) ; if ( val == scriptable . not_found ) { val = null ; } return type . cast ( context . j to java ( val , type ) ) ; }
public void set scope ( scriptable scope ) { set scope provider ( i proxy . new scope provider ( scope ) ) ; }
public void clear all breakpoints ( ) { for ( source info si : url to source info . value ( ) ) { si . remove all breakpoints ( ) ; } }
public static void main ( string args [ ] ) { main main = new main ( ) ; args = main . process option ( args ) ; if ( args == null ) { if ( main . print help ) { system . out . println ( tool error reporter . get message ( `` msg . jsc . usage `` , main . class . get name ( ) ) ) ; system . exit ( 0 ) ; } system . exit ( 1 ) ; } if ( ! main . reporter . have report error ( ) ) { main . process source ( args ) ; } }
public void dispatch ( list < object > queue , subscriber < i > subscriber ) { for ( object event : queue ) { if ( event ! = null ) { if ( event instanceof serialize processor . subscription event ) { subscriber . on subscribe ( ( ( subscription event ) event ) . subscription ) ; } if ( event instanceof serialize processor . failure event ) { subscriber . on error ( ( ( failure event ) event ) . failure ) ; return ; } if ( event instanceof serialize processor . completion event ) { subscriber . on complete ( ) ; return ; } if ( event instanceof serialize processor . item event ) { subscriber . on next ( ( ( item event < i > ) event ) . item ) ; } } } }
public void action perform ( action event action event ) { if ( `` next `` . equal ( action event . get action command ( ) ) ) { wizard step forward ( ) ; } else if ( `` back `` . equal ( action event . get action command ( ) ) ) { wizard step backward ( ) ; } else if ( `` choose file `` . equal ( action event . get action command ( ) ) ) { j file chooser file chooser = new j file chooser ( ) ; if ( valid file extension . size ( ) > 0 ) { uploader file extension filter filter = new uploader file extension filter ( `` allow file `` , valid file extension ) ; file chooser . set file filter ( filter ) ; } file chooser . set multi selection enable ( file max count > 1 ) ; file chooser . set dialog title ( `` choose file `` + ( file max count > 1 ? `` s `` : `` `` ) + `` to upload `` ) ; file chooser . set file selection mode ( j file chooser . files_only ) ; file chooser . set approve button text ( `` choose file `` + ( file max count > 1 ? `` s `` : `` `` ) ) ; int return val = file chooser . show open dialog ( owner frame ) ; if ( return val ! = j file chooser . approve_option ) { return ; } list file list = new array list ( ) ; if ( file chooser . get select file ( ) . length > 0 ) { file list . add all ( array . a list ( file chooser . get select file ( ) ) ) ; } else { file list . add ( file chooser . get select file ( ) ) ; } if ( check propose upload file ( file list ) ) { wizard step forward ( ) ; } } else if ( `` cancel upload `` . equal ( action event . get action command ( ) ) ) { if ( upload cancel event trigger ! = null ) { upload cancel event trigger . cancel task ( this ) ; progress bar . set value ( 0 ) ; } else { log . warn ( `` ignore attempt to cancel file upload when cancel trigger be not available `` ) ; } } else { log . warn ( `` unrecognised action command , ignoring : `` + action event . get action command ( ) ) ; } }
public static scriptable get function prototype ( scriptable scope ) { return top level . get builtin prototype ( get top level scope ( scope ) , top level . builtins . function ) ; }
public action get insert break action ( ) { return insert_break_action ; }
protect void set language index ( int language index ) { this . language index = math . max ( 0 , language index ) ; }
public int get line number ( ) { if ( ( current token ! = null ) & & ( current token . next ! = null ) ) { return current token . next . begin line ; } else if ( current token ! = null ) { return current token . begin line ; } else { return -1 ; } }
public boolean equal ( object other ) { if ( other==this ) { return true ; } if ( other instanceof search result ) { return this . compare to ( ( search result ) other ) ==0 ; } return false ; }
public final void shift ( int amount ) { begin a += amount ; end a += amount ; begin b += amount ; end b += amount ; }
public void set level threshold ( parser notice . level level ) { level threshold = level ; if ( be displayable ( ) ) { refresh marker ( ) ; } }
public boolean be remote local ( ) { return local_repository . equal ( get remote ( ) ) ; }
public boolean be leave curly ( token t ) { return t . be leave curly ( ) ; }
public fold parser get fold parser ( string syntax style ) { return fold parser map . get ( syntax style ) ; }
public void set paint ( paint paint ) { if ( paint == null ) return ; this . _paint = paint ; if ( paint instanceof color ) _foreground = ( color ) paint ; }
public void set paint border ( boolean paint ) { if ( paint ! =p . get paint border ( ) ) { p . set paint border ( paint ) ; if ( text area ! =null ) { text area . repaint ( ) ; } } }
public static time zone parse backend time zone ( string time zone ) { if ( time zone . start with ( `` gmt `` ) ) { time zone tz = gmt_zones . get ( time zone ) ; if ( tz ! = null ) { return tz ; } } return time zone . get time zone ( time zone ) ; }
public void set task pattern ( string pattern ) { if ( pattern==null || pattern . length ( ) ==0 ) { task pattern = null ; } else { task pattern = pattern . compile ( pattern ) ; } }
public void set validating ( boolean validating ) { this . validate = validating ; }
public static synchronize void set default instance ( token maker factory tmf ) { if ( tmf==null ) { throw new illegal argument exception ( `` tmf can not be null `` ) ; } default_instance = tmf ; }
protect void append fold menu ( j popup menu popup ) { popup . add separator ( ) ; resource bundle bundle = resource bundle . get bundle ( msg ) ; fold menu = new j menu ( bundle . get string ( `` context menu . fold `` ) ) ; fold menu . add ( create popup menu item ( toggle current fold action ) ) ; fold menu . add ( create popup menu item ( collapse all comment fold action ) ) ; fold menu . add ( create popup menu item ( collapse all fold action ) ) ; fold menu . add ( create popup menu item ( expand all fold action ) ) ; popup . add ( fold menu ) ; }
public color get match bracket b g color ( ) { return match bracket b g color ; }
public void set e o l marker visible ( boolean visible ) { if ( visible ! =eol marker visible ) { eol marker visible = visible ; repaint ( ) ; fire property change ( eol_visible_property , ! visible , visible ) ; } }
public boolean be code fold enable ( ) { return fold manager . be code fold enable ( ) ; }
public void set paint tab line ( boolean paint ) { if ( paint ! =paint tab line ) { paint tab line = paint ; repaint ( ) ; fire property change ( tab_lines_property , ! paint , paint ) ; } }
public void add parser ( parser parser ) { if ( parser manager==null ) { parser manager = new parser manager ( this ) ; } parser manager . add parser ( parser ) ; }
public void hyperlink update ( hyperlink event e ) { if ( parser for tip ! =null & & parser for tip . get hyperlink listener ( ) ! =null ) { parser for tip . get hyperlink listener ( ) . link click ( text area , e ) ; } }
public static p d soft mask create ( c o s base dictionary ) { if ( dictionary instanceof c o s name ) { if ( c o s name . none . equal ( dictionary ) ) { return null ; } else { log . warn ( `` invalid s mask `` + dictionary ) ; return null ; } } else if ( dictionary instanceof c o s dictionary ) { return new p d soft mask ( ( c o s dictionary ) dictionary ) ; } else { log . warn ( `` invalid s mask `` + dictionary ) ; return null ; } }
public void set paint border ( boolean paint ) { if ( paint ! =p . get paint border ( ) ) { p . set paint border ( paint ) ; if ( text area ! =null ) { text area . repaint ( ) ; } } }
public void set e o l marker visible ( boolean visible ) { if ( visible ! =eol marker visible ) { eol marker visible = visible ; repaint ( ) ; fire property change ( eol_visible_property , ! visible , visible ) ; } }
protect map get action ( ) { return h action ; }
public view create ( element elem ) { r text area c = get r text area ( ) ; if ( c instanceof r syntax text area ) { r syntax text area area = ( r syntax text area ) c ; view v ; if ( area . get line wrap ( ) ) { v = new wrap syntax view ( elem ) ; } else { v = new syntax view ( elem ) ; } return v ; } return null ; }
public int hash code ( ) { if ( hash ! = 0 ) { return hash ; } hash = provider . hash code ( ) * 127 + id . hash code ( ) ; return hash ; }
public id query builder add id ( string . . . id ) { if ( id == null ) { throw new illegal argument exception ( `` [ `` + name + `` ] id can not be null `` ) ; } collection . add all ( this . id , id ) ; return this ; }
public string get before caret text ( ) { return before caret ; }
public boolean be local and exists ( ) { return file . exists ( ) ; }
public void set read only ( boolean read only ) { check if seal ( ) ; this . be read only = read only ; }
public pretty printer configuration set tab width ( int tab width ) { set indent size ( assert positive ( tab width ) ) ; return this ; }
public static refactoring history service get instance ( ) { if ( f instance == null ) f instance= new refactoring history service ( ) ; return f instance ; }
public json array copy ( ) { list < object > copy list = new array list < > ( list . size ( ) ) ; for ( object val : list ) { val = json object . check and copy ( val , true ) ; copy list . add ( val ) ; } return new json array ( copied list ) ; }
public void set line number font ( font font ) { if ( font==null ) { throw new illegal argument exception ( `` font can not be null `` ) ; } if ( ! font . equal ( line number font ) ) { line number font = font ; if ( line number list ! =null ) { line number list . set font ( font ) ; } } }
public boolean get icon row header inherits gutter background ( ) { return icon row header inherits gutter background ; }
public r text area get text area ( ) { return ( r text area ) get viewport ( ) . get view ( ) ; }
public char char at ( int offset ) { return ref . char [ offset ] ; }
public int size ( string name ) { if ( name == null ) { throw new illegal argument exception ( `` no property name specify `` ) ; } object value = value . get ( name ) ; if ( value == null ) { return 0 ; } if ( value instanceof map ) { return ( ( map ) value ) . size ( ) ; } if ( value instanceof list ) { return ( ( list ) value ) . size ( ) ; } if ( ( value . get class ( ) . be array ( ) ) ) { return array . get length ( value ) ; } return 0 ; }
public key stroke get accelerator ( ) { return ( key stroke ) get value ( accelerator_key ) ; }
public boolean be recordable ( ) { return be recordable ; }
public void set margin line position ( int size ) { margin size in char = size ; if ( margin line enable ) { rectangle visible rect = get visible rect ( ) ; repaint ( margin line x , visible rect . y , 1 , visible rect . height ) ; update margin line x ( ) ; repaint ( margin line x , visible rect . y , 1 , visible rect . height ) ; } }
public void set margin line position ( int size ) { margin size in char = size ; if ( margin line enable ) { rectangle visible rect = get visible rect ( ) ; repaint ( margin line x , visible rect . y , 1 , visible rect . height ) ; update margin line x ( ) ; repaint ( margin line x , visible rect . y , 1 , visible rect . height ) ; } }
public void install u i ( j component c ) { if ( ! ( c instanceof r text area ) ) { throw new error ( `` r text area u i need an instance of r text area ! `` ) ; } super . install u i ( c ) ; }
public r text area get text area ( ) { return ( r text area ) get viewport ( ) . get view ( ) ; }
public void set match case ( boolean match case ) { if ( match case ! =this . match case ) { this . match case = match case ; fire property change ( property_match_case , ! match case , match case ) ; } }
public selection policy get selection policy ( ) { return selection policy ; }
public static boolean have max row ( row selection selection ) { return selection ! = null & & selection . get max row ( ) ! = null & & selection . get max row ( ) > 0 ; }
public boolean remove ( int key ) { for ( int i=0 ; i < use ; i++ ) { if ( key [ i ] == key ) { value [ i ] = default value ; return true ; } } return false ; }
public void remove range ( int from index , int to index ) { if ( from index > =size || to index > size ) { throw exception3 ( from index , to index ) ; } int move count = size - to index ; system . arraycopy ( data , to index , data , from index , move count ) ; size -= ( to index - from index ) ; }
public static disposable from action ( @ non null action run ) { object helper . require non null ( run , `` run be null `` ) ; return new action disposable ( run ) ; }
public observable < t > auto connect ( ) { return auto connect ( 1 ) ; }
public disposable replace resource ( int index , disposable resource ) { for ( ; ; ) { disposable o = get ( index ) ; if ( o == disposable helper . dispose ) { resource . dispose ( ) ; return null ; } if ( compare and set ( index , o , resource ) ) { return o ; } } }
public boolean block await ( long timeout , time unit unit ) { if ( get count ( ) ! = 0 ) { try { block helper . verify non blocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; return false ; } } catch ( interrupted exception ex ) { dispose ( ) ; throw exception helper . wrap or throw ( ex ) ; } } throwable ex = error ; if ( ex ! = null ) { throw exception helper . wrap or throw ( ex ) ; } return true ; }
protect final void complete ( r value ) { subscriber < ? super r > a = actual ; for ( ; ; ) { int s = state . get ( ) ; if ( s == no_request_has_value || s == has_request_has_value || a . be unsubscribed ( ) ) { return ; } if ( s == has_request_no_value ) { a . on next ( value ) ; if ( ! a . be unsubscribed ( ) ) { a . on complete ( ) ; } state . lazy set ( has_request_has_value ) ; return ; } this . value = value ; if ( state . compare and set ( no_request_no_value , no_request_has_value ) ) { return ; } } }
public static void error ( subscriber < ? > s , throwable e ) { s . on subscribe ( empty subscription . instance ) ; s . on error ( e ) ; }
public void enqueue ( object element ) { int new tail = increment ( tail ) ; if ( new tail == head ) { grow ( ) ; new tail = tail + 1 ; } elements [ tail ] = element ; tail = new tail ; }
public < u > boolean accept ( observer < ? super u > observer ) { object [ ] a = head ; final int c = capacity ; while ( a ! = null ) { for ( int i = 0 ; i < c ; i++ ) { object o = a [ i ] ; if ( o == null ) { break ; } if ( notification lite . accept full ( o , observer ) ) { return true ; } } a = ( object [ ] ) a [ c ] ; } return false ; }
public static long add ( atomic long request , long request ) { for ( ; ; ) { long r = request . get ( ) ; if ( r == long . max_value ) { return long . max_value ; } long u = add ( r , request ) ; if ( request . compare and set ( r , u ) ) { return r ; } } }
public static boolean validate ( disposable upstream , disposable next , class < ? > observer ) { object helper . require non null ( next , `` next be null `` ) ; if ( upstream ! = null ) { next . dispose ( ) ; if ( upstream ! = disposable helper . dispose ) { report double subscription ( observer ) ; } return false ; } return true ; }
public static throwable get error ( object o ) { return ( ( error notification ) o ) . e ; }
public final < t > single < t > to single default ( final t completion value ) { require non null ( completion value ) ; return to single ( new func0 < t > ( ) { @ override public t call ( ) { return completion value ; } } ) ; }
public final u assert value at ( int index , predicate < t > value predicate ) { int s = value . size ( ) ; if ( s == 0 ) { throw fail ( `` no value `` ) ; } if ( index > = value . size ( ) ) { throw fail ( `` invalid index : `` + index ) ; } boolean found = false ; try { if ( value predicate . test ( value . get ( index ) ) ) { found = true ; } } catch ( exception ex ) { throw exception helper . wrap or throw ( ex ) ; } if ( ! find ) { throw fail ( `` value not present `` ) ; } return ( u ) this ; }
public final u assert value ( t . . . value ) { int s = this . value . size ( ) ; if ( s ! = value . length ) { throw fail ( `` value count differs ; expect : `` + value . length + `` `` + array . to string ( value ) + `` , actual : `` + s + `` `` + this . value ) ; } for ( int i = 0 ; i < s ; i++ ) { t v = this . value . get ( i ) ; t u = value [ i ] ; if ( ! object helper . equal ( u , v ) ) { throw fail ( `` value at position `` + i + `` differ ; expect : `` + value and class ( u ) + `` , actual : `` + value and class ( v ) ) ; } } return ( u ) this ; }
public final u assert value at ( int index , predicate < t > value predicate ) { int s = value . size ( ) ; if ( s == 0 ) { throw fail ( `` no value `` ) ; } if ( index > = value . size ( ) ) { throw fail ( `` invalid index : `` + index ) ; } boolean found = false ; try { if ( value predicate . test ( value . get ( index ) ) ) { found = true ; } } catch ( exception ex ) { throw exception helper . wrap or throw ( ex ) ; } if ( ! find ) { throw fail ( `` value not present `` ) ; } return ( u ) this ; }
public void assert value count ( int count ) { int s = value . size ( ) ; if ( s ! = count ) { assertion error ( `` number of on next event differ ; expect : `` + count + `` , actual : `` + s ) ; } }
public final u assert terminate ( ) { if ( do . get count ( ) ! = 0 ) { throw fail ( `` subscriber still run ! `` ) ; } long c = completion ; if ( c > 1 ) { throw fail ( `` terminate with multiple completion : `` + c ) ; } int s = error . size ( ) ; if ( s > 1 ) { throw fail ( `` terminate with multiple error : `` + s ) ; } if ( c ! = 0 & & s ! = 0 ) { throw fail ( `` terminate with multiple completion and error : `` + c ) ; } return ( u ) this ; }
public final u assert no error ( ) { int s = error . size ( ) ; if ( s ! = 0 ) { throw fail ( `` error ( s ) present : `` + error ) ; } return ( u ) this ; }
public list < object > get event ( ) { array list < object > event = new array list < object > ( ) ; event . add ( on next event ) ; event . add ( on error event ) ; event . add ( on complete event ) ; return collection . unmodifiable list ( event ) ; }
public final u assert value only ( t . . . value ) { return assert subscribe ( ) . assert value ( value ) . assert no error ( ) . assert not complete ( ) ; }
public whitelist add tag ( string . . . tag ) { validate . not null ( tag ) ; for ( string tag name : tag ) { validate . not empty ( tag name ) ; tag name . add ( tag name . value of ( tag name ) ) ; } return this ; }
public void await shutdown ( final long timeout ) throw interrupted exception { synchronize ( this . status mutex ) { final long deadline = system . current time millis ( ) + timeout ; long remain = timeout ; while ( this . status ! = i o reactor status . shut_down ) { this . status mutex . wait ( remain ) ; if ( timeout > 0 ) { remain = deadline - system . current time millis ( ) ; if ( remain < = 0 ) { break ; } } } } }
public static void set on before block ( @ nullable boolean supplier handler ) { if ( lockdown ) { throw new illegal state exception ( `` plugins ca n't be change anymore `` ) ; } on before block = handler ; }
public void start ( ) { start ( true ) ; }
public synchronize void shutdown ( ) { synchronize ( connection pool ) { if ( ! shutdown ) { shutdown = true ; connection pool . shutdown ( ) ; } } }
public long get process cpu total time ( ) { if ( get process cpu time ! = null ) { try { long time = ( long ) get process cpu time . invoke ( os mx bean ) ; if ( time > = 0 ) { return ( time / 1_000_000l ) ; } } catch ( exception t ) { return -1 ; } } return -1 ; }
public long now ( @ non null time unit unit ) { return unit . convert ( system . current time millis ( ) , time unit . millisecond ) ; }
public final disposable subscribe ( ) { empty completable observer s = new empty completable observer ( ) ; subscribe ( s ) ; return s ; }
public boolean have throwable ( ) { return observer . get ( ) == terminate & & error ! = null ; }
public throwable get throwable ( ) { if ( observer . get ( ) == terminate ) { return error ; } return null ; }
protect final void request ( long n ) { subscription helper . defer request ( s , miss request , n ) ; }
public static void error ( error message message , file file ) { errors++ ; err ( nl+ `` error : `` + error message . get ( message ) + `` ( `` +file+ `` ) `` ) ; }
public final u assert value ( t value ) { int s = value . size ( ) ; if ( s ! = 1 ) { throw fail ( `` expect : `` + value and class ( value ) + `` , actual : `` + value ) ; } t v = value . get ( 0 ) ; if ( ! object helper . equal ( value , v ) ) { throw fail ( `` expect : `` + value and class ( value ) + `` , actual : `` + value and class ( v ) ) ; } return ( u ) this ; }
public final parallel flux < t > filter ( predicate < ? super t > predicate ) { object . require non null ( predicate , `` predicate `` ) ; return on assembly ( new parallel filter < > ( this , predicate ) ) ; }
public void start unbounded ( ) { if ( subscription helper . set once ( upstream , empty subscription . instance ) ) { queue = new spsc link array queue < t > ( buffer size ) ; } }
public void trim ( ) { this . buffer . trim ( ) ; }
public static double stream double stream accumulate ( iterable once < double > coll ) { return stream converter . a java seq double stream ( ( iterable once < double > ) ( object ) scala . jdk . double accumulator $ . module $ . from specific ( ( iterable once < object > ) ( object ) coll ) ) ; }
public static @ not null breadcrumb ui ( final @ not null string category , final @ not null string message ) { final breadcrumb breadcrumb = new breadcrumb ( ) ; breadcrumb . set type ( `` default `` ) ; breadcrumb . set category ( `` ui . `` + category ) ; breadcrumb . set message ( message ) ; return breadcrumb ; }
public static @ not null string get timestamp ( final @ not null date date ) { final date format df = sdf_iso_format_with_millis_utc . get ( ) ; return df . format ( date ) ; }
public void set level ( @ nullable sentry level level ) { this . level = level ; }
public json error path ( @ nullable string path ) { this . path = path ; return this ; }
public snapshot get snapshot ( ) { return this . snapshot ; } // -- snapshot get snapshot ( )
public @ nullable long get thread id ( ) { return thread id ; }
public void set data ( @ not null string key , @ not null object value ) { data . put ( key , value ) ; }
public boolean be trace enable ( ) { if ( trace capable ) { return logger . be trace enable ( ) ; } else { return logger . be debug enable ( ) ; } }
public void add breadcrumb ( @ not null breadcrumb breadcrumb , final @ nullable object hint ) { if ( breadcrumb == null ) { return ; } sentry option . before breadcrumb callback callback = option . get before breadcrumb ( ) ; if ( callback ! = null ) { breadcrumb = execute before breadcrumb ( callback , breadcrumb , hint ) ; } if ( breadcrumb ! = null ) { this . breadcrumb . add ( breadcrumb ) ; if ( option . be enable scope sync ( ) ) { for ( final i scope observer observer : option . get scope observer ( ) ) { observer . add breadcrumb ( breadcrumb ) ; } } } else { option . get logger ( ) . log ( sentry level . info , `` breadcrumb be drop by before breadcrumb `` ) ; } }
public static @ not null i transaction start transaction ( final @ not null string name , final @ not null string operation , final boolean bind to scope ) { return get current hub ( ) . start transaction ( name , operation , bind to scope ) ; }
public void set environment ( @ nullable string environment ) { this . environment = environment ; }
public @ not null list < string > get in app include ( ) { return in app include ; }
public void set envelope disk cache ( final @ nullable i envelope cache envelope disk cache ) { this . envelope disk cache = envelope disk cache ! = null ? envelope disk cache : no op envelope cache . get instance ( ) ; }
public void set proguard uuid ( final @ nullable string proguard uuid ) { this . proguard uuid = proguard uuid ; }
public void set period ( readable instant start , readable instant end ) { if ( start == end ) { set period ( 0l ) ; } else { long start millis = date time utils . get instant millis ( start ) ; long end millis = date time utils . get instant millis ( end ) ; chronology chrono = date time utils . get interval chronology ( start , end ) ; set period ( start millis , end millis , chrono ) ; } }
public static @ not null sentry id get last event id ( ) { return get current hub ( ) . get last event id ( ) ; }
public @ nullable string get server name ( ) { return server name ; }
public void set email ( string email ) { this . email = email ; } // -- void set email ( string )
public void set comment ( @ nullable string comment ) { this . comment = comment ; }
public short get vertical alignment ( ) { return ( short ) get text object record ( ) . get vertical text alignment ( ) ; }
public map get copy of context map ( ) { hash map hash map = ( hash map ) inheritable thread local . get ( ) ; if ( hash map ! = null ) { return new hash map ( hash map ) ; } else { return null ; } }
public final boolean be trace enable ( ) { return false ; }
public static marker get marker ( string name ) { return marker factory . get marker ( name ) ; }
public static void remove ( string key ) throw illegal argument exception { if ( key == null ) { throw new illegal argument exception ( `` key parameter can not be null `` ) ; } if ( mdc adapter == null ) { throw new illegal state exception ( `` m d c adapter can not be null . see also `` + null_mdca_url ) ; } mdc adapter . remove ( key ) ; }
public string get m d c adapter class str ( ) { return log4j m d c adapter . class . get name ( ) ; }
public void error ( string format , object arg ) { format and log ( log_level_error , format , arg , null ) ; }
public void error ( string format , object arg ) { format and log ( log_level_error , format , arg , null ) ; }
public void info ( string format , object arg1 , object arg2 ) { format and log ( log_level_info , format , arg1 , arg2 ) ; }
public static io . vertx . axle . core . buffer . buffer buffer ( ) { io . vertx . axle . core . buffer . buffer ret = io . vertx . axle . core . buffer . buffer . new instance ( io . vertx . core . buffer . buffer . buffer ( ) ) ; return ret ; }
public string to string ( string enc ) { string ret = delegate . to string ( enc ) ; return ret ; }
public short get unsigned byte ( int po ) { short ret = delegate . get unsigned byte ( po ) ; return ret ; }
public long get unsigned int l e ( int po ) { long ret = delegate . get unsigned int l e ( po ) ; return ret ; }
public io . vertx . axle . core . buffer . buffer set long ( int po , long l ) { delegate . set long ( po , l ) ; return this ; }
public io . vertx . axle . core . buffer . buffer append float ( float f ) { delegate . append float ( f ) ; return this ; }
public byte [ ] get byte ( ) throw i o exception { byte buf byte buf = get byte buf ( ) ; try { return byte buf util . get byte ( byte buf ) ; } finally { byte buf . release ( ) ; } }
public io . vertx . axle . core . http . http server response set stream priority ( stream priority stream priority ) { delegate . set stream priority ( stream priority ) ; return this ; }
public string get raw value for argument ( argument arg ) { string ret = delegate . get raw value for argument ( arg ) ; return ret ; }
public boolean be option assign ( option option ) { boolean ret = delegate . be option assign ( option ) ; return ret ; }
public json object get cache config ( ) { json object ret = delegate . get cached config ( ) ; return ret ; }
public boolean be multi threaded worker context ( ) { boolean ret = delegate . be multi threaded worker context ( ) ; return ret ; }
public < t > t remove ( string key ) { t ret = ( t ) delegate . remove ( key ) ; return ret ; }
public io . vertx . axle . core . stream . read stream < io . vertx . axle . core . http . web socket > websocket stream ( int port , string host , string request u r i ) { io . vertx . axle . core . stream . read stream < io . vertx . axle . core . http . web socket > ret = io . vertx . axle . core . stream . read stream . new instance ( delegate . websocket stream ( port , host , request u r i ) , type_arg_1 ) ; return ret ; }
public string sub protocol ( ) { string ret = delegate . sub protocol ( ) ; return ret ; }
public static < t > list < t > create service object ( string . . . p descriptor path ) { try { service entry . init default order ( ) ; tree map < service entry , t > extractor map = new tree map < service entry , t > ( ) ; for ( string descriptor : p descriptor path ) { read service definition ( extractor map , descriptor ) ; } array list < t > ret = new array list < t > ( ) ; for ( t service : extractor map . value ( ) ) { ret . add ( service ) ; } return ret ; } finally { service entry . remove default order ( ) ; } }
public < t > io . vertx . axle . core . eventbus . message producer < t > publisher ( string address ) { io . vertx . axle . core . eventbus . message producer < t > ret = io . vertx . axle . core . eventbus . message producer . new instance ( delegate . publisher ( address ) , io . vertx . lang . axle . type arg . unknown ( ) ) ; return ret ; }
public completion stage < void > completion handler ( ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __completion handler ( handler ) ; } ) ; }
public long last modified time ( ) { long ret = delegate . last modified time ( ) ; return ret ; }
public boolean be boolean ( ) { boolean ret = delegate . be boolean ( ) ; return ret ; }
public int size ( ) { int ret = delegate . size ( ) ; return ret ; }
public completion stage < void > chmod ( string path , string perm ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __chmod ( path , perm , handler ) ; } ) ; }
public completion stage < void > completion handler ( ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __completion handler ( handler ) ; } ) ; }
public completion stage < void > completion handler ( ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __completion handler ( handler ) ; } ) ; }
public completion stage < list < string > > read dir ( string path ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __read dir ( path , handler ) ; } ) ; }
public static < t > io . vertx . axle . core . future < t > succeed future ( ) { io . vertx . axle . core . future < t > ret = io . vertx . axle . core . future . new instance ( io . vertx . core . future . succeed future ( ) , io . vertx . lang . axle . type arg . unknown ( ) ) ; return ret ; }
public < v > io . vertx . axle . core . future < v > map empty ( ) { io . vertx . axle . core . future < v > ret = io . vertx . axle . core . future . new instance ( delegate . map empty ( ) , io . vertx . lang . axle . type arg . unknown ( ) ) ; return ret ; }
public io . vertx . reactivex . ext . web . handler . c s r f handler set cookie path ( string path ) { delegate . set cookie path ( path ) ; return this ; }
public io . vertx . reactivex . ext . web . handler . session handler set cookie secure flag ( boolean secure ) { delegate . set cookie secure flag ( secure ) ; return this ; }
public io . vertx . axle . core . http . http client request option ( request option option ) { io . vertx . axle . core . http . http client request ret = io . vertx . axle . core . http . http client request . new instance ( delegate . option ( option ) ) ; return ret ; }
public io . vertx . axle . core . http . http client request delete ( string request u r i ) { io . vertx . axle . core . http . http client request ret = io . vertx . axle . core . http . http client request . new instance ( delegate . delete ( request u r i ) ) ; return ret ; }
public io . vertx . axle . core . http . http client request option abs ( string absolute u r i ) { io . vertx . axle . core . http . http client request ret = io . vertx . axle . core . http . http client request . new instance ( delegate . option abs ( absolute u r i ) ) ; return ret ; }
public io . vertx . axle . core . http . http client request delete ab ( string absolute u r i ) { io . vertx . axle . core . http . http client request ret = io . vertx . axle . core . http . http client request . new instance ( delegate . delete ab ( absolute u r i ) ) ; return ret ; }
public completion stage < io . vertx . axle . core . http . web socket > web socket ( string host , string request u r i ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __web socket ( host , request u r i , handler ) ; } ) ; }
public io . vertx . axle . core . stream . read stream < io . vertx . axle . core . http . web socket > websocket stream ( string host , string request u r i , io . vertx . axle . core . multi map header , websocket version version ) { io . vertx . axle . core . stream . read stream < io . vertx . axle . core . http . web socket > ret = io . vertx . axle . core . stream . read stream . new instance ( delegate . websocket stream ( host , request u r i , header . get delegate ( ) , version ) , type_arg_8 ) ; return ret ; }
public io . vertx . axle . core . stream . read stream < io . vertx . axle . core . http . web socket > websocket stream ( string host , string request u r i , io . vertx . axle . core . multi map header , websocket version version ) { io . vertx . axle . core . stream . read stream < io . vertx . axle . core . http . web socket > ret = io . vertx . axle . core . stream . read stream . new instance ( delegate . websocket stream ( host , request u r i , header . get delegate ( ) , version ) , type_arg_8 ) ; return ret ; }
public io . vertx . reactivex . core . http . http connection go away handler ( handler < io . vertx . core . http . go away > handler ) { delegate . go away handler ( handler ) ; return this ; }
public io . vertx . axle . core . http . http server create http server ( ) { io . vertx . axle . core . http . http server ret = io . vertx . axle . core . http . http server . new instance ( delegate . create http server ( ) ) ; return ret ; }
public string text handler i d ( ) { string ret = delegate . text handler i d ( ) ; return ret ; }
public boolean be root pointer ( ) { boolean ret = delegate . be root pointer ( ) ; return ret ; }
public io . vertx . axle . core . json . pointer . json pointer append ( string token ) { delegate . append ( token ) ; return this ; }
public static io . vertx . axle . core . json . pointer . json pointer from u r i ( uri uri ) { io . vertx . axle . core . json . pointer . json pointer ret = io . vertx . axle . core . json . pointer . json pointer . new instance ( io . vertx . core . json . pointer . json pointer . from u r i ( uri ) ) ; return ret ; }
public boolean contains ( string name , string value , boolean case insensitive ) { boolean ret = delegate . contains ( name , value , case insensitive ) ; return ret ; }
public string text handler i d ( ) { string ret = delegate . text handler i d ( ) ; return ret ; }
public final void delete ( ) { get nd ( ) . delete ( this . address ) ; }
public io . vertx . axle . core . parsetools . json parser array event mode ( ) { delegate . array event mode ( ) ; return this ; }
public completion stage < void > completion handler ( ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __completion handler ( handler ) ; } ) ; }
public completion stage < void > completion handler ( ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __completion handler ( handler ) ; } ) ; }
public completion stage < long > get and increment ( ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __get and increment ( handler ) ; } ) ; }
public completion stage < long > get and add ( long value ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __get and add ( value , handler ) ; } ) ; }
public completion stage < long > get and add ( long value ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __get and add ( value , handler ) ; } ) ; }
public static < t > io . vertx . axle . core . stream . pump pump ( io . vertx . axle . core . stream . read stream < t > r , io . vertx . axle . core . stream . write stream < t > w , int write queue max size ) { io . vertx . axle . core . stream . pump ret = io . vertx . axle . core . stream . pump . new instance ( io . vertx . core . stream . pump . pump ( r . get delegate ( ) , w . get delegate ( ) , write queue max size ) ) ; return ret ; }
public static < t > io . vertx . axle . core . stream . pump pump ( io . vertx . axle . core . stream . read stream < t > r , io . vertx . axle . core . stream . write stream < t > w , int write queue max size ) { io . vertx . axle . core . stream . pump ret = io . vertx . axle . core . stream . pump . new instance ( io . vertx . core . stream . pump . pump ( r . get delegate ( ) , w . get delegate ( ) , write queue max size ) ) ; return ret ; }
public static io . vertx . axle . core . context current context ( ) { io . vertx . axle . core . context ret = io . vertx . axle . core . context . new instance ( io . vertx . core . vertx . current context ( ) ) ; return ret ; }
public io . vertx . axle . core . http . http client request option ( request option option ) { io . vertx . axle . core . http . http client request ret = io . vertx . axle . core . http . http client request . new instance ( delegate . option ( option ) ) ; return ret ; }
public io . vertx . axle . core . stream . read stream < io . vertx . axle . core . http . http server request > request stream ( ) { if ( cached_0 ! = null ) { return cached_0 ; } io . vertx . axle . core . stream . read stream < io . vertx . axle . core . http . http server request > ret = io . vertx . axle . core . stream . read stream . new instance ( delegate . request stream ( ) , type_arg_0 ) ; cached_0 = ret ; return ret ; }
public io . vertx . axle . core . timeout stream periodic stream ( long delay ) { io . vertx . axle . core . timeout stream ret = io . vertx . axle . core . timeout stream . new instance ( delegate . periodic stream ( delay ) ) ; return ret ; }
public void unregister verticle factory ( verticle factory factory ) { delegate . unregister verticle factory ( factory ) ; }
public void add case ( switch case switch case ) { assert not null ( switch case ) ; if ( case == null ) { case = new array list < switch case > ( ) ; } case . add ( switch case ) ; switch case . set parent ( this ) ; }
public static list < string > get all property value ( string key ) { list < config source > app config source = sort ascend ( new array list < config source > ( arrays . a list ( get config source ( ) ) ) ) ; list < string > result = new array list < string > ( ) ; string value ; for ( config source config source : app config source ) { value = config source . get property value ( key ) ; if ( value ! = null ) { value = filter config value ( key , value ) ; if ( ! result . contains ( value ) ) { result . add ( value ) ; } } } return result ; }
public uni < io . vertx . mutiny . core . http . web socket > web socket ( string host , string request u r i ) { return io . smallrye . mutiny . vertx . async result uni . to uni ( handler - > { __web socket ( host , request u r i , handler ) ; } ) ; }
public static object generate key ( object . . . params ) { if ( params . length == 0 ) { return simple key . empty ; } if ( params . length == 1 ) { object param = params [ 0 ] ; if ( param ! = null & & ! param . get class ( ) . be array ( ) ) { return param ; } } return new simple key ( params ) ; }
public void set operation style ( string operation style ) { style style = style . get style ( operation style , style . default ) ; set operation style ( style ) ; } // set operation style
public static version parse version ( string version ) { if ( version == null ) { return empty version ; } return value of ( version ) ; }
public void set allow recursive key ( boolean allow recursive key ) { this . allow recursive key = allow recursive key ; }
public whitelist add tag ( string . . . tag ) { validate . not null ( tag ) ; for ( string tag name : tag ) { validate . not empty ( tag name ) ; tag name . add ( tag name . value of ( tag name ) ) ; } return this ; }
public boolean be resolve ( ) { return f be resolve ; }
public boolean check event ( event . id choice ) { peek event ( ) ; return current event ! = null & & current event . be ( choice ) ; }
public void forward ( int length ) { for ( int i = 0 ; i < length & & ensure enough data ( ) ; i++ ) { int c = data window [ pointer++ ] ; this . index++ ; if ( constant . linebr . have ( c ) || ( c == '\r ' & & ( ensure enough data ( ) & & data window [ pointer ] ! = '\n ' ) ) ) { this . line++ ; this . column = 0 ; } else if ( c ! = 0x f e f f ) { this . column++ ; } } }
public string prefix ( int length ) { if ( this . pointer + length > = this . buffer . length ( ) ) { update ( ) ; } if ( this . pointer + length > this . buffer . length ( ) ) { return this . buffer . substring ( this . pointer ) ; } return this . buffer . substring ( this . pointer , this . pointer + length ) ; }
public boolean check token ( token . id . . . choice ) { while ( need more token ( ) ) { fetch more token ( ) ; } if ( ! this . token . be empty ( ) ) { if ( choice . length == 0 ) { return true ; } token first = this . token . get ( 0 ) ; for ( token . id id : choice ) { if ( first . get token id ( ) == id ) { return true ; } } } return false ; }
public static boolean be candidate class ( class < ? > clazz , collection < class < ? extend annotation > > annotation type ) { for ( class < ? extend annotation > annotation type : annotation type ) { if ( be candidate class ( clazz , annotation type ) ) { return true ; } } return false ; }
public void substitute property ( string p name , class < ? > p type , string getter , string setter , class < ? > . . . arg params ) { substitute property ( new property substitute ( p name , p type , getter , setter , arg params ) ) ; }
public void dump all ( iterator < ? extend object > data , writer output ) { dump all ( data , output , null ) ; }
public iterable < object > load all ( reader yaml ) { composer composer = new composer ( new parser impl ( new stream reader ( yaml ) ) , resolver ) ; constructor . set composer ( composer ) ; iterator < object > result = new iterator < object > ( ) { public boolean have next ( ) { return constructor . check data ( ) ; } public object next ( ) { return constructor . get data ( ) ; } public void remove ( ) { throw new unsupported operation exception ( ) ; } } ; return new yaml iterable ( result ) ; }
public void set alias ( collection < ? extend artifact > alias ) { if ( aliases == null || alias . be empty ( ) ) { this . aliases = collection . empty list ( ) ; } else { this . aliases = alias ; } }
public list < event > serialize ( node data ) { silent emitter emitter = new silent emitter ( ) ; serializer serializer = new serializer ( emitter , resolver , dumper option , null ) ; try { serializer . open ( ) ; serializer . serialize ( data ) ; serializer . close ( ) ; } catch ( i o exception e ) { throw new y a m l exception ( e ) ; } return emitter . get event ( ) ; }
public static long [ ] unshuffle long array ( byte [ ] input ) throw i o exception { long [ ] output = new long [ input . length / 8 ] ; int num process = impl . unshuffle ( input , 0 , 8 , input . length , output , 0 ) ; assert ( num process == input . length ) ; return output ; }
public static byte [ ] shuffle ( float [ ] input ) throw i o exception { byte [ ] output = new byte [ input . length * 4 ] ; int num process = impl . shuffle ( input , 0 , 4 , input . length * 4 , output , 0 ) ; assert ( num process == input . length * 4 ) ; return output ; }
public static synchronize class pool get default ( ) { if ( default pool == null ) { default pool = new class pool ( null ) ; default pool . append system path ( ) ; } return default pool ; }
public t add argument ( string additional argument ) { return add argument ( array . a list ( additional argument ) ) ; }
public server install ( ) { if ( server == null ) { database = new default database ( config ) ; database . start ( ) ; package resolver packaging resolver = new packaging resolver ( config . locator ( ) ) ; server installer server installer = new server installer ( package resolver , config , config . locator ( ) , database . get client ( ) ) ; server = server installer . install ( distribution ) ; } return server ; }
public void activate license ( ) { string license = license . get license ( server . get edition ( ) , server . version ( ) ) ; configure license ( license ) ; }
public static i path get plugin state location ( plugin plugin ) { return plugin . get state location ( ) ; }
public t source ( string source ) { if ( source == null || source . be empty ( ) ) { return myself ; } return source ( source . split ( file . path separator ) ) ; }
public box storage policy assignment . info assign ( string user i d ) { return box storage policy assignment . assign ( this . get a p i ( ) , this . get i d ( ) , user i d ) ; }
protect void enter ( ct element e ) { element deque . push ( e ) ; super . enter ( e ) ; }
public item type get item type ( type hierarchy th ) { if ( item type == null ) { return super . get item type ( th ) ; } return item type ; }
public void add parameter ( parameter info parameter ) { lock write lock = parameter lock . write lock ( ) ; write lock . lock ( ) ; try { parameter info result [ ] = new parameter info [ parameter . length + 1 ] ; system . arraycopy ( parameter , 0 , result , 0 , parameter . length ) ; result [ parameter . length ] = parameter ; parameter = result ; this . info = null ; } finally { write lock . unlock ( ) ; } }
public static list < string > any split ( string input , string delim ) { if ( null == input ) { return collection . empty list ( ) ; } array list < string > result = new array list < string > ( ) ; if ( lang util . be empty ( delim ) || ( -1 == input . index of ( delim ) ) ) { result . add ( input . trim ( ) ) ; } else { string tokenizer st = new string tokenizer ( input , delim ) ; while ( st . have more token ( ) ) { result . add ( st . next token ( ) . trim ( ) ) ; } } return result ; }
public pattern parameter configurator match inlined statement ( ) { inlined statement configurator sb = new inlined statement configurator ( pattern builder ) ; for ( ct element ct element : substitute node ) { sb . by element ( ct element ) ; } return this ; }
public pattern parameter configurator by reference name ( string simple name ) { parameter info pi = get current parameter ( ) ; query model ( ) . filter child ( ( ct reference ref ) - > simple name . equal ( ref . get simple name ( ) ) ) . for each ( ( ct reference ref ) - > { add substitution request ( pi , ref ) ; } ) ; return this ; }
protect final void add process annotation type ( class < ? extend a > annotation type ) { process annotation type . put ( annotation type . get name ( ) , annotation type ) ; }
public void process ( ct name element name element ) { if ( name element instanceof ct type & & ( ( ct type ) name element ) . be top level ( ) ) { create java file ( ( ct type < ? > ) name element ) ; } else if ( name element instanceof ct package ) { create package file ( ( ct package ) name element ) ; } else if ( name element instanceof ct module ) { create module file ( ( ct module ) name element ) ; } }
public ct type parameter reference create type parameter reference ( string name ) { if ( `` ? `` . equal ( name ) ) { throw new spoon exception ( `` the spoon metamodel have evolve , use factory . create wildcard reference ( ) instead `` ) ; } ct type parameter reference type param = factory . core ( ) . create type parameter reference ( ) ; type param . set simple name ( name ) ; return type param ; }
public static void change method name ( final ct method < ? > method , string new name ) { final list < ct executable reference < ? > > reference = query . get element ( method . get factory ( ) , new type filter < ct executable reference < ? > > ( ct executable reference . class ) { @ override public boolean match ( ct executable reference < ? > reference ) { return reference . get declaration ( ) == method ; } } ) ; method . set simple name ( new name ) ; for ( ct executable reference < ? > reference : reference ) { reference . set simple name ( new name ) ; } }
public < t > ct interface < t > create ( string qualify name ) { if ( have inner type ( qualified name ) > 0 ) { return create ( create ( get declare type name ( qualified name ) ) , get simple name ( qualified name ) ) ; } return create ( factory . package ( ) . get or create ( get package name ( qualified name ) ) , get simple name ( qualified name ) ) ; }
public < t > ct local variable reference < t > create local variable reference ( ct type reference < t > type , string name ) { return factory . core ( ) . < t > create local variable reference ( ) . set type ( type ) . set simple name ( name ) ; }
public compilation unit get or create ( ct type type ) { if ( type == null ) { return null ; } if ( ! ( type . get position ( ) . get compilation unit ( ) instanceof no source position . null compilation unit ) ) { return type . get position ( ) . get compilation unit ( ) ; } compilation unit compilation unit = add type ( type ) ; type . set position ( this . factory . create partial source position ( compilation unit ) ) ; return compilation unit ; }
public void compile ( file file ) throw compilation fail exception { compilation unit unit = new compilation unit ( configuration ) ; unit . add source ( file ) ; unit . compile ( ) ; }
public < t > ct constructor < t > create default ( ct class < t > target ) { ct constructor < t > constructor = factory . core ( ) . create constructor ( ) ; constructor . add modifier ( modifier kind . public ) ; target . add constructor ( constructor ) ; return constructor ; }
public < t > ct constructor < t > create ( ct class < t > target , ct method < ? > source ) { ct method < t > method = ( ct method < t > ) source . clone ( ) ; ct constructor < t > new constructor = factory . core ( ) . create constructor ( ) ; new constructor . set annotation ( method . get annotation ( ) ) ; new constructor . set body ( method . get body ( ) ) ; new constructor . set doc comment ( method . get doc comment ( ) ) ; new constructor . set formal ct type parameter ( method . get formal ct type parameter ( ) ) ; new constructor . set modifier ( method . get modifier ( ) ) ; new constructor . set parameter ( method . get parameter ( ) ) ; target . add constructor ( new constructor ) ; return new constructor ; }
public < t > ct interface < t > create ( string qualify name ) { if ( have inner type ( qualified name ) > 0 ) { return create ( create ( get declare type name ( qualified name ) ) , get simple name ( qualified name ) ) ; } return create ( factory . package ( ) . get or create ( get package name ( qualified name ) ) , get simple name ( qualified name ) ) ; }
public ct package reference create reference ( package pack ) { return create reference ( pack . get name ( ) ) ; }
public ct type reference < character > character primitive type ( ) { return character_primitive . clone ( ) ; }
public ct type reference < string > string type ( ) { return string . clone ( ) ; }
public ct type reference < byte > byte primitive type ( ) { return byte_primitive . clone ( ) ; }
public < t > ct field reference < t > create reference ( ct type reference < ? > declare type , ct type reference < t > type , string field name ) { ct field reference < t > field ref = factory . core ( ) . create field reference ( ) ; field ref . set simple name ( field name ) ; field ref . set declare type ( declare type ) ; field ref . set type ( type ) ; return field ref ; }
public void set enable logging ( boolean enable logging ) { this . enable log = enable logging ; }
protect void on outbound error ( throwable err ) { mark persistent ( false ) ; terminate ( ) ; }
protect void exit ( ct element e ) { stack . pop ( ) ; }
public < s > void scan ct abstract switch ( ct abstract switch < s > a ) { }
public < t > void scan ct type element ( ct type element < t > e ) { }
public cluster register ( host . state listener listener ) { check not close ( manager ) ; boolean add = manager . listener . add ( listener ) ; if ( add ) listener . on register ( this ) ; return this ; }
public < t extend ct element > list < t > find ( final ct element target root ) { return target root . filter child ( this ) . list ( ) ; }
public ct package reference top level ( ) { return factory . get model ( ) . get root package ( ) . get reference ( ) ; }
public java . io . file get project directory ( ) { return ( pom file ! = null ) ? pom file . get parent file ( ) : null ; }
public synchronize boolean remove ( object key , object value ) { v old = get ( key ) ; if ( be value equal ( old , value ) ) { remove ( key ) ; return true ; } return false ; }
public static void insert before ( ct statement target , ct statement statement ) throw parent not initialize exception { ct statement list sts = target . get factory ( ) . core ( ) . create statement list ( ) ; sts . add statement ( statement ) ; insert before ( target , sts ) ; }
protect int search line number ( int position ) { int [ ] line separator position = get line separator position ( ) ; if ( line separator position == null ) { return 1 ; } int length = line separator position . length ; if ( length == 0 ) { return 1 ; } int g = 0 ; int d = length - 1 ; int m = 0 ; int start ; while ( g < = d ) { m = ( g + d ) / 2 ; if ( position < ( start = line separator position [ m ] ) ) { d = m - 1 ; } else if ( position > start ) { g = m + 1 ; } else { return m + 1 ; } } if ( position < line separator position [ m ] ) { return m + 1 ; } return m + 2 ; }
public static integer get index ( ct expression < ? > e ) { if ( e . get parent ( ) instanceof ct array access ) { ct expression < integer > index expression = ( ( ct array access < ? , ct expression < integer > > ) e . get parent ( ) ) . get index expression ( ) ; return ( ( ct literal < integer > ) index expression ) . get value ( ) ; } return null ; }
public boolean be unix symlink ( ) { return ( get unix mode ( ) & unix stat . file_type_flag ) == unix stat . link_flag ; }
public collection < ct executable reference < ? > > get all executables ( ) { set < ct executable reference < ? > > l = ( set < ct executable reference < ? > > ) super . get all executables ( ) ; for ( ct constructor c : get constructor ( ) ) { l . add ( c . get reference ( ) ) ; } for ( ct executable < ? > anon : get anonymous executables ( ) ) { l . add ( anon . get reference ( ) ) ; } return l ; }
public type get generic parameter type ( ) { if ( this . generic parameter type == null ) { if ( this . parameter index < 0 ) { this . generic parameter type = ( this . method ! = null ? this . method . get generic return type ( ) : null ) ; } else { this . generic parameter type = ( this . method ! = null ? this . method . get generic parameter type ( ) [ this . parameter index ] : this . constructor . get generic parameter type ( ) [ this . parameter index ] ) ; } } return this . generic parameter type ; }
public list super interface type ( ) { return this . super interface type ; }
public static join point current join point ( ) { method invocation mi = expose invocation interceptor . current invocation ( ) ; if ( ! ( mi instanceof proxy method invocation ) ) { throw new illegal state exception ( `` method invocation be not a spring proxy method invocation : `` + mi ) ; } proxy method invocation pmi = ( proxy method invocation ) mi ; join point jp = ( join point ) pmi . get user attribute ( join_point_key ) ; if ( jp == null ) { jp = new method invocation proceed join point ( pmi ) ; pmi . set user attribute ( join_point_key , jp ) ; } return jp ; }
public pointcut get pointcut ( ) { synchronize ( this . pointcut monitor ) { if ( this . pointcut == null ) { this . pointcut = create pointcut ( ) ; this . pointcut . set pattern ( this . pattern ) ; } return pointcut ; } }
public void register bean definition ( annotation metadata import class metadata , bean definition registry registry ) { bean definition interceptor = registry . get bean definition ( `` method security interceptor `` ) ; bean definition builder aspect = bean definition builder . root bean definition ( `` org . springframework . security . access . intercept . aspectj . aspect . annotation security aspect `` ) ; aspect . set factory method ( `` aspect of `` ) ; aspect . set role ( bean definition . role_infrastructure ) ; aspect . add property value ( `` security interceptor `` , interceptor ) ; registry . register bean definition ( `` annotation security aspect $ 0 `` , aspect . get bean definition ( ) ) ; }
public static object get singleton target ( object candidate ) { if ( candidate instanceof advise ) { target source target source = ( ( advise ) candidate ) . get target source ( ) ; if ( target source instanceof singleton target source ) { return ( ( singleton target source ) target source ) . get target ( ) ; } } return null ; }
public void set manage interface ( class < ? > [ ] manage interface ) { if ( manage interface ! = null ) { for ( class < ? > ifc : manage interface ) { if ( ! ifc . be interface ( ) ) { throw new illegal argument exception ( `` management interface [ `` + ifc . get name ( ) + `` ] be not an interface `` ) ; } } } this . manage interface = manage interface ; }
public boolean be instance of ( medium type a , medium type b ) { return a ! = null & & ( a . equal ( b ) || be specialization of ( a , b ) ) ; }
public boolean equal ( object o ) { if ( super . equal ( o ) ) { return true ; } return be reference or proxy ( ) & & get reference or proxied ( ) . equal ( o ) ; }
public void set advisor bean name prefix ( string advisor bean name prefix ) { this . advisor bean name prefix = advisor bean name prefix ; }
public int hash code ( ) { int hash = 19 ; hash = 13 * hash + get ( ) ; hash = 13 * hash + get field type ( ) . hash code ( ) ; hash = 13 * hash + get readable partial ( ) . get chronology ( ) . hash code ( ) ; return hash ; }
public void set expose proxy ( boolean expose proxy ) { this . expose proxy = expose proxy ; }
public void set frozen ( boolean frozen ) { this . frozen = frozen ; }
public aop proxy factory get aop proxy factory ( ) { return this . aop proxy factory ; }
protect object new prototype instance ( ) throw bean exception { if ( logger . be debug enable ( ) ) { logger . debug ( `` create new instance of bean ' `` + get target bean name ( ) + `` ' `` ) ; } return get bean factory ( ) . get bean ( get target bean name ( ) ) ; }
public void set enter message ( string enter message ) throw illegal argument exception { assert . have text ( enter message , `` 'enter message ' must not be empty `` ) ; check for invalid placeholder ( enter message ) ; assert . do not contain ( enter message , placeholder_return_value , `` enter message can not contain placeholder [ `` + placeholder_return_value + `` ] `` ) ; assert . do not contain ( enter message , placeholder_exception , `` enter message can not contain placeholder [ `` + placeholder_exception + `` ] `` ) ; assert . do not contain ( enter message , placeholder_invocation_time , `` enter message can not contain placeholder [ `` + placeholder_invocation_time + `` ] `` ) ; this . enter message = enter message ; }
public void set enter message ( string enter message ) throw illegal argument exception { assert . have text ( enter message , `` 'enter message ' must not be empty `` ) ; check for invalid placeholder ( enter message ) ; assert . do not contain ( enter message , placeholder_return_value , `` enter message can not contain placeholder [ `` + placeholder_return_value + `` ] `` ) ; assert . do not contain ( enter message , placeholder_exception , `` enter message can not contain placeholder [ `` + placeholder_exception + `` ] `` ) ; assert . do not contain ( enter message , placeholder_invocation_time , `` enter message can not contain placeholder [ `` + placeholder_invocation_time + `` ] `` ) ; this . enter message = enter message ; }
public static string get bean name ( method invocation mi ) throw illegal state exception { if ( ! ( mi instanceof proxy method invocation ) ) { throw new illegal argument exception ( `` method invocation be not a spring proxy method invocation : `` + mi ) ; } proxy method invocation pmi = ( proxy method invocation ) mi ; string bean name = ( string ) pmi . get user attribute ( bean_name_attribute ) ; if ( bean name == null ) { throw new illegal state exception ( `` can not get bean name ; not set on method invocation : `` + mi ) ; } return bean name ; }
public void set excludes ( string [ ] exclude ) { if ( excludes == null ) { this . exclude = null ; } else { this . exclude = new string [ excludes . length ] ; for ( int i = 0 ; i < excludes . length ; i++ ) { string pattern ; pattern = exclude [ i ] . trim ( ) . replace ( '/ ' , file . separator char ) . replace ( '\\ ' , file . separator char ) ; if ( pattern . end with ( file . separator ) ) { pattern += `` * * `` ; } this . exclude [ i ] = pattern ; } } }
public int hash code ( ) { if ( method == null ) { return constructor . hash code ( ) ^ index ; } return method . hash code ( ) ^ index ; }
protected list < advisor > find eligible advisor ( class < ? > bean class , string bean name ) { list < advisor > candidate advisor = find candidate advisor ( ) ; list < advisor > eligible advisor = find advisor that can apply ( candidate advisor , bean class , bean name ) ; extend advisor ( eligible advisor ) ; if ( ! eligible advisor . be empty ( ) ) { eligible advisor = sort advisor ( eligible advisor ) ; } return eligible advisor ; }
public static class filter intersection ( class filter [ ] class filter ) { assert . not empty ( class filter , `` class filter array must not be empty `` ) ; return new intersection class filter ( class filter ) ; }
public composable pointcut union ( pointcut other ) { this . method matcher = method matcher . union ( this . method matcher , this . class filter , other . get method matcher ( ) , other . get class filter ( ) ) ; this . class filter = class filter . union ( this . class filter , other . get class filter ( ) ) ; return this ; }
protect void initialize ( class < t > map class ) { this . map class = map class ; this . map field = new hash map < > ( ) ; this . mapped property = new hash set < > ( ) ; for ( property descriptor pd : bean utils . get property descriptor ( mapped class ) ) { if ( pd . get write method ( ) ! = null ) { this . map field . put ( low case name ( pd . get name ( ) ) , pd ) ; string underscored name = underscore name ( pd . get name ( ) ) ; if ( ! low case name ( pd . get name ( ) ) . equal ( underscored name ) ) { this . map field . put ( underscored name , pd ) ; } this . mapped property . add ( pd . get name ( ) ) ; } } }
public method info list get ( final string method name ) { boolean have method with name = false ; for ( final method info mi : this ) { if ( mi . get name ( ) . equal ( method name ) ) { have method with name = true ; break ; } } if ( ! have method with name ) { return empty_list ; } else { final method info list match method = new method info list ( 2 ) ; for ( final method info mi : this ) { if ( mi . get name ( ) . equal ( method name ) ) { match method . add ( mi ) ; } } return match method ; } }
public void set target bean name ( string target bean name ) { this . target bean name = target bean name ; this . scoped target source . set target bean name ( target bean name ) ; }
public synchronize void set max idle ( final int max idle ) { this . max idle = max idle ; if ( connection pool ! = null ) { connection pool . set max idle ( max idle ) ; } }
public void set max wait ( long max wait ) { this . max wait = max wait ; }
public boolean be block when exhaust ( ) { return this . block when exhaust ; }
public static aspect j precedence information get aspect j precedence information for ( advisor an advisor ) { if ( an advisor instanceof aspect j precedence information ) { return ( aspect j precedence information ) an advisor ; } advice advice = an advisor . get advice ( ) ; if ( advice instanceof aspect j precedence information ) { return ( aspect j precedence information ) advice ; } return null ; }
protect void do set nested path ( string nest path ) { if ( nested path == null ) { nested path = `` `` ; } nest path = canonical field name ( nested path ) ; if ( nested path . length ( ) > 0 & & ! nested path . end with ( error . nested_path_separator ) ) { nested path += error . nested_path_separator ; } this . nested path = nested path ; }
public void parse meta element ( element ele , bean metadata attribute accessor attribute accessor ) { node list nl = ele . get child node ( ) ; for ( int i = 0 ; i < nl . get length ( ) ; i++ ) { node node = nl . item ( i ) ; if ( be candidate element ( node ) & & node name equal ( node , meta_element ) ) { element meta element = ( element ) node ; string key = meta element . get attribute ( key_attribute ) ; string value = meta element . get attribute ( value_attribute ) ; bean metadata attribute attribute = new bean metadata attribute ( key , value ) ; attribute . set source ( extract source ( meta element ) ) ; attribute accessor . add metadata attribute ( attribute ) ; } } }
public static < t > t instantiate class ( class < t > clazz ) throw bean instantiation exception { assert . not null ( clazz , `` class must not be null `` ) ; if ( clazz . be interface ( ) ) { throw new bean instantiation exception ( clazz , `` specified class be an interface `` ) ; } try { return instantiate class ( clazz . get declared constructor ( ) ) ; } catch ( no such method exception ex ) { throw new bean instantiation exception ( clazz , `` no default constructor find `` , ex ) ; } }
public boolean be autowire candidate ( ) { return this . autowire candidate ; }
public void set require parameter name ( string require parameter name ) { this . require parameter name = require parameter name ; }
public void add qualifier type ( class < ? extend annotation > qualifier type ) { this . qualifier type . add ( qualifier type ) ; }
public void add qualifier type ( class < ? extend annotation > qualifier type ) { this . qualifier type . add ( qualifier type ) ; }
public void add relate cause ( throwable ex ) { if ( this . related cause == null ) { this . related cause = new array list < > ( ) ; } this . related cause . add ( ex ) ; }
public void set resource description ( string resource description ) { this . resource = new descriptive resource ( resource description ) ; }
protect type converter get default type converter ( ) { if ( this . bean factory ! = null ) { return this . bean factory . get type converter ( ) ; } else { return super . get default type converter ( ) ; } }
public final t get object ( ) throw exception { if ( be singleton ( ) ) { return ( this . initialize ? this . singleton instance : get early singleton instance ( ) ) ; } else { return create instance ( ) ; } }
public void destroy ( ) { if ( ! bean manager provider . get instance ( ) . get bean manager ( ) . be normal scope ( bean . get scope ( ) ) ) { bean . destroy ( instance , creational context ) ; } }
public void add argument value ( constructor argument value other ) { if ( other ! = null ) { for ( map . entry < integer , value holder > entry : other . indexed argument value . entry set ( ) ) { add or merge indexed argument value ( entry . get key ( ) , entry . get value ( ) . copy ( ) ) ; } for ( value holder value holder : other . generic argument value ) { if ( ! this . generic argument value . contains ( value holder ) ) { add or merge generic argument value ( value holder . copy ( ) ) ; } } } }
public void parse constructor arg element ( element ele , bean definition bd ) { string index attr = ele . get attribute ( index_attribute ) ; string type attr = ele . get attribute ( type_attribute ) ; string name attr = ele . get attribute ( name_attribute ) ; if ( string utils . have length ( index attr ) ) { try { int index = integer . parse int ( index attr ) ; if ( index < 0 ) { error ( `` 'index ' can not be low than 0 `` , ele ) ; } else { try { this . parse state . push ( new constructor argument entry ( index ) ) ; object value = parse property value ( ele , bd , null ) ; constructor argument value . value holder value holder = new constructor argument value . value holder ( value ) ; if ( string utils . have length ( type attr ) ) { value holder . set type ( type attr ) ; } if ( string utils . have length ( name attr ) ) { value holder . set name ( name attr ) ; } value holder . set source ( extract source ( ele ) ) ; if ( bd . get constructor argument value ( ) . have index argument value ( index ) ) { error ( `` ambiguous constructor-arg entry for index `` + index , ele ) ; } else { bd . get constructor argument value ( ) . add indexed argument value ( index , value holder ) ; } } finally { this . parse state . pop ( ) ; } } } catch ( number format exception ex ) { error ( `` attribute 'index ' of tag 'constructor-arg ' must be an integer `` , ele ) ; } } else { try { this . parse state . push ( new constructor argument entry ( ) ) ; object value = parse property value ( ele , bd , null ) ; constructor argument value . value holder value holder = new constructor argument value . value holder ( value ) ; if ( string utils . have length ( type attr ) ) { value holder . set type ( type attr ) ; } if ( string utils . have length ( name attr ) ) { value holder . set name ( name attr ) ; } value holder . set source ( extract source ( ele ) ) ; bd . get constructor argument value ( ) . add generic argument value ( value holder ) ; } finally { this . parse state . pop ( ) ; } } }
public boolean declares field ( field field ) { try { type . get declared field ( field . get name ( ) ) ; return true ; } catch ( no such field exception e ) { return false ; } }
public static type descriptor nest ( method parameter method parameter , int nest level ) { if ( method parameter . get nesting level ( ) ! = 1 ) { throw new illegal argument exception ( `` method parameter nest level must be 1 : `` + `` use the nesting level parameter to specify the desired nesting level for nested type traversal `` ) ; } return nest ( new type descriptor ( method parameter ) , nest level ) ; }
public boolean match item ( item item , boolean allow u r i promotion , configuration config ) { if ( item instanceof node info ) { return match ( ( node info ) item ) ; } else { return false ; } }
public static indexed filter create descriptor filter ( descriptor descriptor impl , boolean deep copy ) { final descriptor filter descriptor = ( deep copy ) ? new descriptor impl ( descriptor impl ) : descriptor impl ; return new indexed filter ( ) { @ override public boolean match ( descriptor d ) { return descriptor impl . descriptor equal ( filter descriptor , d ) ; } @ override public string get advertise contract ( ) { set < string > contract = filter descriptor . get advertised contract ( ) ; if ( contract == null || contract . be empty ( ) ) return null ; return contract . iterator ( ) . next ( ) ; } @ override public string get name ( ) { return filter descriptor . get name ( ) ; } } ; }
protect void log cache error ( log logger , string message , runtime exception ex ) { if ( this . log stacktrace ) { logger . warn ( message , ex ) ; } else { logger . warn ( message ) ; } }
public string get target field ( ) { return this . target field ; }
public void set bean name ( string bean name ) { this . bean name = string utils . trim all whitespace ( bean factory utils . original bean name ( bean name ) ) ; }
protect string resolve path ( string path ) { if ( this . property resolver == null ) { this . property resolver = new standard environment ( ) ; } return ( this . ignore unresolvable placeholder ? this . property resolver . resolve placeholder ( path ) : this . property resolver . resolve required placeholder ( path ) ) ; }
public void set target bean name ( string target bean name ) { this . target bean name = target bean name ; this . scoped target source . set target bean name ( target bean name ) ; }
public boolean be singleton ( ) { return be singleton ; }
public void set order ( int order ) { this . order = order ; }
public void set service interface ( @ nullable class < ? > service interface ) { if ( service interface ! = null ) { assert . be true ( service interface . be interface ( ) , `` 'service interface ' must be an interface `` ) ; } this . service interface = service interface ; }
public static void enable lookup exception ( service locator locator ) { if ( locator == null ) throw new illegal argument exception ( ) ; try { add class ( locator , true , rethrow error service . class ) ; } catch ( multi exception me ) { if ( ! be dup exception ( me ) ) throw me ; } }
public static boolean be convertable ( final class < ? > target type ) { if ( boolean . class . equal ( target type ) ) { return true ; } if ( character . class . equal ( target type ) ) { return true ; } if ( target type . be primitive ( ) ) { return true ; } try { target type . get declared method ( value_of_method , string . class ) ; return true ; } catch ( no such method exception e ) { try { target type . get declared constructor ( string . class ) ; return true ; } catch ( no such method exception e1 ) { return false ; } } }
public void set fallback to default type match ( boolean fallback to default type match ) { this . fallback to default type match = fallback to default type match ; }
public void set deserializer binding ( deserializer bind deserializer binding ) { this . deserializer bind = deserializer binding ; }
public groovy bean definition reader bean ( closure closure ) { return invoke bean defining closure ( closure ) ; }
public void add nest component ( component definition component ) { assert . not null ( component , `` component definition must not be null `` ) ; this . nested component . add ( component ) ; }
public bean definition builder set dependency check ( int dependency check ) { this . bean definition . set dependency check ( dependency check ) ; return this ; }
public cluster allocation explain request set primary ( boolean primary ) { this . primary = primary ; return this ; }
public cluster allocation explain request builder set primary ( boolean primary ) { request . set primary ( primary ) ; return this ; }
public void add qualifier ( autowire candidate qualifier qualifier ) { this . qualifier . put ( qualifier . get type name ( ) , qualifier ) ; }
public void add bean post processor ( collection < ? extends bean post processor > bean post processor ) { this . bean post processor . remove all ( bean post processor ) ; this . bean post processor . add all ( bean post processor ) ; }
protect void after prototype creation ( string bean name ) { object cur val = this . prototypes currently in creation . get ( ) ; if ( cur val instanceof string ) { this . prototypes currently in creation . remove ( ) ; } else if ( cur val instanceof set ) { set < string > bean name set = ( set < string > ) cur val ; bean name set . remove ( bean name ) ; if ( bean name set . be empty ( ) ) { this . prototypes currently in creation . remove ( ) ; } } }
public void register custom editor ( class < ? > require type , property editor property editor ) { type converter converter = get type converter ( ) ; if ( ! ( converter instanceof property editor registry ) ) { throw new illegal state exception ( `` type converter do not implement property editor registry interface : `` + converter ) ; } ( ( property editor registry ) converter ) . register custom editor ( require type , property editor ) ; }
protect void apply merge bean definition post processor ( root bean definition mbd , class < ? > bean type , string bean name ) { for ( bean post processor bp : get bean post processor ( ) ) { if ( bp instanceof merge bean definition post processor ) { merge bean definition post processor bdp = ( merge bean definition post processor ) bp ; bdp . post process merge bean definition ( mbd , bean type , bean name ) ; } } }
protect object evaluate bean definition string ( string value , bean definition bean definition ) { if ( this . bean expression resolver == null ) { return value ; } scope scope = ( bean definition ! = null ? get register scope ( bean definition . get scope ( ) ) : null ) ; return this . bean expression resolver . evaluate ( value , new bean expression context ( this , scope ) ) ; }
public boolean equal ( object obj ) { return ( obj == this || ( obj instanceof descriptive resource & & ( ( descriptive resource ) obj ) . description . equal ( this . description ) ) ) ; }
public class < ? > resolve target type ( class loader class loader ) throw class not find exception { if ( this . target type == null ) { return null ; } class < ? > resolve class = class utils . for name ( get target type name ( ) , class loader ) ; this . target type = resolved class ; return resolve class ; }
public string get serialization id ( ) { return this . serialization id ; }
public boolean equal ( object o ) { if ( this == o ) { return true ; } if ( ! ( o instanceof bean comparator ) ) { return false ; } final bean comparator bean comparator = ( bean comparator ) o ; if ( ! comparator . equal ( bean comparator . comparator ) ) { return false ; } if ( property ! = null ) { if ( ! property . equal ( bean comparator . property ) ) { return false ; } } else { return ( bean comparator . property == null ) ; } return true ; }
protect void add singleton ( string bean name , object singleton object ) { synchronize ( this . singleton object ) { this . singleton object . put ( bean name , ( singleton object ! = null ? singleton object : null_object ) ) ; this . singleton factory . remove ( bean name ) ; this . early singleton object . remove ( bean name ) ; this . registered singleton . add ( bean name ) ; } }
protect boolean be dependent ( string bean name , string dependent bean name ) { return be dependent ( bean name , dependent bean name , null ) ; }
protect boolean be dependent ( string bean name , string dependent bean name ) { return be dependent ( bean name , dependent bean name , null ) ; }
protect object get singleton ( string bean name , boolean allow early reference ) { object singleton object = this . singleton object . get ( bean name ) ; if ( singleton object == null & & be singleton currently in creation ( bean name ) ) { synchronize ( this . singleton object ) { singleton object = this . early singleton object . get ( bean name ) ; if ( singleton object == null & & allow early reference ) { object factory < ? > singleton factory = this . singleton factory . get ( bean name ) ; if ( singleton factory ! = null ) { singleton object = singleton factory . get object ( ) ; this . early singleton object . put ( bean name , singleton object ) ; this . singleton factory . remove ( bean name ) ; } } } } return ( singleton object ! = null_object ? singleton object : null ) ; }
protected class < ? > get type for factory bean ( string bean name , root bean definition mbd ) { if ( ! mbd . be singleton ( ) ) { return null ; } try { factory bean < ? > factory bean = do get bean ( factory_bean_prefix + bean name , factory bean . class , null , true ) ; return get type for factory bean ( factory bean ) ; } catch ( bean creation exception ex ) { if ( ex instanceof bean currently in creation exception ) { if ( logger . be debug enable ( ) ) { logger . debug ( `` bean currently in creation on factory bean type check : `` + ex ) ; } } else if ( mbd . be lazy init ( ) ) { if ( logger . be debug enable ( ) ) { logger . debug ( `` bean creation exception on lazy factory bean type check : `` + ex ) ; } } else { if ( logger . be warn enable ( ) ) { logger . warn ( `` bean creation exception on non-lazy factory bean type check : `` + ex ) ; } } on suppressed exception ( ex ) ; return null ; } }
public access control context get access control context ( ) { return ( this . security context provider ! = null ? this . security context provider . get access control context ( ) : access controller . get context ( ) ) ; }
public element type get element type ( string name ) { return ( element type ) ( the element type . get ( name . to lower case ( ) ) ) ; }
protect void set overload ( boolean overload ) { this . overload = overload ; }
public boolean have method override ( ) { return ! this . method override . be empty ( ) ; }
public int register bean definition ( map < ? , ? > map ) throw bean exception { return register bean definition ( map , null ) ; }
public void register disposable bean ( string bean name , disposable bean bean ) { synchronize ( this . disposable bean ) { this . disposable bean . put ( bean name , bean ) ; } }
public attribute get attribute ( string name ) { attribute scope rule property scope = rule label scope . grammar type to rule property scope [ grammar . type ] ; if ( rule property scope . get attribute ( name ) ! =null ) { return rule property scope . get attribute ( name ) ; } if ( referenced rule . return scope ! =null ) { return reference rule . return scope . get attribute ( name ) ; } return null ; }
protect void parse bean definition ( element root , bean definition parser delegate delegate ) { if ( delegate . be default namespace ( root ) ) { node list nl = root . get child node ( ) ; for ( int i = 0 ; i < nl . get length ( ) ; i++ ) { node node = nl . item ( i ) ; if ( node instanceof element ) { element ele = ( element ) node ; if ( delegate . be default namespace ( ele ) ) { parse default element ( ele , delegate ) ; } else { delegate . parse custom element ( ele ) ; } } } } else { delegate . parse custom element ( root ) ; } }
protect void parse bean definition ( element root , bean definition parser delegate delegate ) { if ( delegate . be default namespace ( root ) ) { node list nl = root . get child node ( ) ; for ( int i = 0 ; i < nl . get length ( ) ; i++ ) { node node = nl . item ( i ) ; if ( node instanceof element ) { element ele = ( element ) node ; if ( delegate . be default namespace ( ele ) ) { parse default element ( ele , delegate ) ; } else { delegate . parse custom element ( ele ) ; } } } } else { delegate . parse custom element ( root ) ; } }
protect void parse bean definition ( element root , bean definition parser delegate delegate ) { if ( delegate . be default namespace ( root ) ) { node list nl = root . get child node ( ) ; for ( int i = 0 ; i < nl . get length ( ) ; i++ ) { node node = nl . item ( i ) ; if ( node instanceof element ) { element ele = ( element ) node ; if ( delegate . be default namespace ( ele ) ) { parse default element ( ele , delegate ) ; } else { delegate . parse custom element ( ele ) ; } } } } else { delegate . parse custom element ( root ) ; } }
public void parse meta element ( element ele , bean metadata attribute accessor attribute accessor ) { node list nl = ele . get child node ( ) ; for ( int i = 0 ; i < nl . get length ( ) ; i++ ) { node node = nl . item ( i ) ; if ( be candidate element ( node ) & & node name equal ( node , meta_element ) ) { element meta element = ( element ) node ; string key = meta element . get attribute ( key_attribute ) ; string value = meta element . get attribute ( value_attribute ) ; bean metadata attribute attribute = new bean metadata attribute ( key , value ) ; attribute . set source ( extract source ( meta element ) ) ; attribute accessor . add metadata attribute ( attribute ) ; } } }
public void set merge id ( string merge id ) { this . merge id = merge id ; } // -- void set merge id ( string )
public bean definition builder set dependency check ( int dependency check ) { this . bean definition . set dependency check ( dependency check ) ; return this ; }
public string get init method name ( ) { return this . init method name ; }
public boolean be externally manage destroy method ( string destroy method ) { synchronize ( this . post processing lock ) { return ( this . externally manage destroy method ! = null & & this . externally manage destroy method . contains ( destroy method ) ) ; } }
public int load bean definition ( resource resource ) throw bean definition store exception { return load bean definition ( new encode resource ( resource ) , null ) ; }
public document read document from string ( string document content ) { input source be = new input source ( new string reader ( document content ) ) ; try { return this . reader . do load document ( be , get resource ( ) ) ; } catch ( exception ex ) { throw new bean definition store exception ( `` fail to read xml document `` , ex ) ; } }
public final namespace handler resolver get namespace handler resolver ( ) { return this . namespace handler resolver ; }
public static property for name ( string property name ) { return new property ( property name ) ; }
public mutable property value add property value ( property value pv ) { for ( int i = 0 ; i < this . property value list . size ( ) ; i++ ) { property value current pv = this . property value list . get ( i ) ; if ( current pv . get name ( ) . equal ( pv . get name ( ) ) ) { pv = merge if require ( pv , current pv ) ; set property value at ( pv , i ) ; return this ; } } this . property value list . add ( pv ) ; return this ; }
public synchronize void set convert value ( object value ) { this . convert = true ; this . convert value = value ; }
protect void set property ( dyna property [ ] property ) { this . property = property ; property map . clear ( ) ; for ( int i = 0 ; i < property . length ; i++ ) { property map . put ( property [ i ] . get name ( ) , property [ i ] ) ; } }
protected class < ? > guess property type from editor ( string property name ) { if ( this . custom editor for path ! = null ) { custom editor holder editor holder = this . custom editor for path . get ( property name ) ; if ( editor holder == null ) { list < string > strip path = new link list < string > ( ) ; add strip property path ( stripped path , `` `` , property name ) ; for ( iterator < string > it = strip path . iterator ( ) ; it . have next ( ) & & editor holder == null ; ) { string strip name = it . next ( ) ; editor holder = this . custom editor for path . get ( strip name ) ; } } if ( editor holder ! = null ) { return editor holder . get registered type ( ) ; } } return null ; }
public static string format date ( long value , date format thread localformat ) { string cache date = null ; long long value = value ; try { cached date = format cache . get ( long value ) ; } catch ( exception ex ) { } if ( cached date ! = null ) { return cache date ; } string new date ; date date value = new date ( value ) ; if ( thread localformat ! = null ) { new date = thread localformat . format ( date value ) ; synchronize ( format cache ) { update cache ( format cache , long value , new date ) ; } } else { synchronize ( format cache ) { new date = format . format ( date value ) ; update cache ( format cache , long value , new date ) ; } } return new date ; }
public static void have text ( string text , string message ) { if ( ! string utils . have text ( text ) ) { throw new illegal argument exception ( message ) ; } }
protect boolean always create new collection ( ) { return false ; }
public void write ( object instance , object value ) { set accessible ( ) ; try { if ( primitive ) { if ( value == null ) { if ( apply default == null ) { object current value = read ( instance , true ) ; apply default = default primitive value . equal ( current value ) ; } if ( apply default == boolean . true ) { value = default primitive value ; } else { return ; } } else if ( default primitive value . get class ( ) ! = value . get class ( ) & & value instanceof number ) { number number = ( ( number ) value ) ; if ( field type == int . class ) { value = number . int value ( ) ; } else if ( field type == long . class ) { value = number . long value ( ) ; } else if ( field type == double . class ) { value = number . double value ( ) ; } else if ( field type == float . class ) { value = number . float value ( ) ; } else if ( field type == byte . class ) { value = number . byte value ( ) ; } else if ( field type == short . class ) { value = number . short value ( ) ; } } } if ( write method ! = null ) { write method . invoke ( instance , value ) ; } else { ( ( field ) target ) . set ( instance , value ) ; } } catch ( throwable e ) { string value type name = value == null ? null : value . get class ( ) . get name ( ) ; string msg ; string detail = null ; if ( value type name ! = null ) { msg = `` unable to set value ' { value } ' of type ' `` + value type name + `` ' to field `` + to string ( ) ; } else { msg = `` unable to set value 'null ' to field `` + to string ( ) ; } if ( e instanceof invocation target exception ) { e = e . get cause ( ) ; detail = msg ; } if ( e instanceof data process exception ) { data process exception ex = ( data process exception ) e ; ex . mark a non fatal ( ) ; ex . set value ( value ) ; ex . set detail ( detail ) ; throw ( data process exception ) e ; } data process exception ex = new data processing exception ( msg , e ) ; ex . mark a non fatal ( ) ; ex . set value ( value ) ; throw ex ; } }
public static property match for property ( string property name , class < ? > bean class ) { return for property ( property name , bean class , default_max_distance ) ; }
public final sort definition get sort definition ( ) { return this . sort definition ; }
public void set page size ( int page size ) { if ( page size < = 0 ) { throw new illegal argument exception ( `` the value must be great than 0 . `` ) ; } this . page size = page size ; }
public void set max link page ( int max link page ) { this . max link page = max link page ; }
public int get last link page ( ) { return math . min ( get first link page ( ) + get max link page ( ) - 1 , get page count ( ) - 1 ) ; }
public static boolean be simple value type ( class < ? > clazz ) { return ( class utils . be primitive or wrapper ( clazz ) || clazz . be enum ( ) || char sequence . class . be assignable from ( clazz ) || number . class . be assignable from ( clazz ) || date . class . be assignable from ( clazz ) || uri . class == clazz || url . class == clazz || locale . class == clazz || class . class == clazz ) ; }
public void destroy ( ) { if ( this . cache session bean ) { synchronize ( this . bean instance monitor ) { if ( this . bean instance instanceof e j b object ) { remove session bean instance ( ( e j b object ) this . bean instance ) ; } } } }
public < a extends annotation > a get annotation ( class < a > annotation type ) { return ( this . field ! = null ? this . field . get annotation ( annotation type ) : obtain method parameter ( ) . get parameter annotation ( annotation type ) ) ; }
public void add nest component ( component definition component ) { assert . not null ( component , `` component definition must not be null `` ) ; this . nested component . add ( component ) ; }
protect boolean have instantiation aware bean post processor ( ) { return this . have instantiation aware bean post processor ; }
public bean definition builder set init method name ( string method name ) { this . bean definition . set init method name ( method name ) ; return this ; }
public void set destroy method name ( @ nullable string destroy method name ) { this . destroy method name = destroy method name ; }
public void set destroy method name ( @ nullable string destroy method name ) { this . destroy method name = destroy method name ; }
public abstract bean definition get bean definition ( ) { this . bean definition . validate ( ) ; return this . bean definition ; }
public static constructor < ? > [ ] get all constructor ( class < ? > clazz ) { constructor < ? > [ ] declare constructor = clazz . get declared constructor ( ) ; for ( constructor < ? > constructor : declared constructor ) { if ( ! constructor . be accessible ( ) ) { constructor . set accessible ( true ) ; } } return declared constructor ; }
public void fire default register ( defaults definition default definition ) { this . event listener . default register ( defaults definition ) ; }
public boolean be optional ( ) { return this . optional ; } // -- boolean be optional ( )
public boolean be optional ( ) { return ( get parameter type ( ) == optional . class || have nullable annotation ( ) || ( kotlin detector . be kotlin reflect present ( ) & & kotlin detector . be kotlin type ( get contain class ( ) ) & & kotlin delegate . be optional ( this ) ) ) ; }
public void register externally manage config member ( member config member ) { synchronize ( this . post processing lock ) { if ( this . externally manage config member == null ) { this . externally manage config member = new link hash set < > ( 1 ) ; } this . externally manage config member . add ( config member ) ; } }
public void register externally manage init method ( string init method ) { synchronize ( this . post processing lock ) { if ( this . externally manage init method == null ) { this . externally manage init method = new link hash set < > ( 1 ) ; } this . externally manage init method . add ( init method ) ; } }
public spring application builder context factory ( application context factory factory ) { this . application . set application context factory ( factory ) ; return this ; }
public void set log startup info ( boolean log startup info ) { this . log startup info = log startup info ; }
public spring application builder parent ( configurable application context parent ) { this . parent = new spring application builder ( ) ; this . parent . context = parent ; this . parent . run . set ( true ) ; return this ; }
public static void main ( string [ ] args ) throw exception { spring application . run ( new class < ? > [ 0 ] , args ) ; }
public void set bean name generator ( bean name generator bean name generator ) { this . bean name generator = bean name generator ; }
public configuration property get ( configuration property name name ) { return this . property . get ( name ) ; }
public cancel task request set reason ( string reason ) { this . reason = reason ; return this ; }
public static void add converter ( converter registry converter registry ) { converter registry . add converter ( new object to string converter ( ) ) ; converter registry . add converter ( new object to boolean converter ( ) ) ; converter registry . add converter ( new object to instant converter ( ) ) ; converter registry . add converter ( new object to u r l converter ( ) ) ; converter registry . add converter ( new object to list string converter ( ) ) ; converter registry . add converter ( new object to map string object converter ( ) ) ; }
public static class < ? > get map key type ( class < ? extend map > map class ) { return resolvable type . for class ( map class ) . a map ( ) . resolve generic ( 0 ) ; }
public string get description ( ) { if ( description == null ) { description = description . get description ( this ) ; } return description ; }
public void set wait for task to complete on shutdown ( boolean wait for job to complete on shutdown ) { this . wait for task to complete on shutdown = wait for job to complete on shutdown ; }
protect string get self initialization config ( ) { return find config ( get standard config location ( ) ) ; }
public static encoding pattern converter new instance ( final configuration config , final string [ ] option ) { if ( option . length > 2 || option . length == 0 ) { logger . error ( `` incorrect number of option on escape . expect 1 or 2 , but receive { } `` , option . length ) ; return null ; } if ( option [ 0 ] == null ) { logger . error ( `` no pattern supply on escape `` ) ; return null ; } final escape format escape format = option . length < 2 ? escape format . html : english enums . value of ( escape format . class , option [ 1 ] , escape format . html ) ; final pattern parser parser = pattern layout . create pattern parser ( config ) ; final list < pattern formatter > formatters = parser . parse ( option [ 0 ] ) ; return new encode pattern converter ( formatters , escape format ) ; }
public source new source ( ) { synchronize ( relay . this ) { if ( file == null ) return null ; source count++ ; } return new relay source ( ) ; }
public void set uri template handler ( uri template handler handler ) { assert . not null ( handler , `` uri template handler must not be null `` ) ; this . uri template handler = handler ; }
public void add tld skip pattern ( string . . . pattern ) { assert . not null ( pattern , `` pattern must not be null `` ) ; this . tld skip pattern . add all ( array . a list ( pattern ) ) ; }
public void add tld skip pattern ( string . . . pattern ) { assert . not null ( pattern , `` pattern must not be null `` ) ; this . tld skip pattern . add all ( array . a list ( pattern ) ) ; }
public boolean get tomcat authorization ( ) { return tomcat authorization ; }
public void set eager filter init ( boolean eager filter init ) { this . eager filter init = eager filter init ; }
public void set charset ( @ nullable charset charset ) { if ( charset ! = this . charset ) { this . charset = ( charset ! = null ? charset : default_charset ) ; apply default charset ( ) ; } }
public boolean be enable ( ) { return this . enable ; } // -- boolean be enable ( )
public string get ( string extension ) { map map = this . map . get ( extension ) ; return ( map ! = null ) ? mapping . get mime type ( ) : null ; }
public synchronize service port ( int port ) { if ( initialize ) { throw before route mapping exception ( ) ; } this . port = port ; return this ; }
public < t > optional < serializer provider wrapper > find value serializer provider ( class < t > clazz ) { class < ? > candidate = clazz ; do { final serializer provider wrapper provider = serializers . get ( candidate ) ; if ( provider ! = null ) { return optional . of ( provider ) ; } candidate = candidate . get superclass ( ) ; } while ( candidate ! = null ) ; return find by condition ( clazz ) ; }
public ssl configurator key store password ( string password ) { this . key store pas = password . to char array ( ) ; return this ; }
public void set servlet name ( collection < string > servlet name ) { assert . not null ( servlet name , `` servlet name must not be null `` ) ; this . servlet name = new link hash set < > ( servlet names ) ; }
public void set match after ( boolean match after ) { this . match after = match after ; }
public static string get name for parameter ( method parameter parameter ) { model attribute ann = parameter . get parameter annotation ( model attribute . class ) ; string name = ( ann ! = null ? ann . value ( ) : null ) ; return ( string utils . have text ( name ) ? name : convention . get variable name for parameter ( parameter ) ) ; }
public void set location ( location location ) { this . location = location ; }
public void set store dir ( string store dir ) { this . store dir = store dir ; }
public default profile activation context set active profile id ( list < string > active profile id ) { if ( active profile id ! = null ) { this . active profile id = collection . unmodifiable list ( active profile id ) ; } else { this . active profile id = collection . empty list ( ) ; } return this ; }
public void refresh ( ) { web application context wac = get web application context ( ) ; if ( ! ( wac instanceof configurable application context ) ) { throw new illegal state exception ( `` web application context do not support refresh : `` + wac ) ; } ( ( configurable application context ) wac ) . refresh ( ) ; }
public void add method exception handler ( method exception event handler ev ) { if ( method exception handler == null ) { method exception handler = ev ; } else { get log ( ) . warn ( `` ignore extra method exception handler `` ) ; } }
public spark launcher set main class ( string main class ) { check not null ( main class , `` main class `` ) ; builder . main class = main class ; return this ; }
public spark launcher set main class ( string main class ) { check not null ( main class , `` main class `` ) ; builder . main class = main class ; return this ; }
public set < object > get all source ( ) { set < object > all source = new link hash set < > ( ) ; if ( ! collection utils . be empty ( this . primary source ) ) { all source . add all ( this . primary source ) ; } if ( ! collection utils . be empty ( this . source ) ) { all source . add all ( this . source ) ; } return collection . unmodifiable set ( all source ) ; }
public spring application builder environment ( configurable environment environment ) { this . application . set environment ( environment ) ; this . environment = environment ; return this ; }
public string get environment prefix ( ) { return this . environment prefix ; }
public resource [ ] get resource ( string location pattern ) throw i o exception { if ( this . resource loader instanceof resource pattern resolver ) { return ( ( resource pattern resolver ) this . resource loader ) . get resource ( location pattern ) ; } return super . get resource ( location pattern ) ; }
public void set schema ( string schema location ) { this . schema location = schema location ; }
public list < string > get data location ( ) { return this . data location ; }
public string get message ( ) { string builder message = new string builder ( ) ; if ( operation ! = null ) { message . append ( operation + `` `` ) ; } message . append ( format path ( path ) ) ; if ( target path ! = null ) { message . append ( `` to `` + format path ( target path ) ) ; } message . append ( `` : `` + super . get message ( ) ) ; if ( get cause ( ) ! = null ) { message . append ( `` : `` + get cause ( ) . get message ( ) ) ; } return message . to string ( ) ; }
protect condition outcome get resource outcome ( condition context context , annotate type metadata metadata ) { list < string > find = new array list < > ( ) ; for ( string location : this . resource location ) { resource resource = context . get resource loader ( ) . get resource ( location ) ; if ( resource ! = null & & resource . exists ( ) ) { find . add ( location ) ; } } if ( find . be empty ( ) ) { condition message message = start condition message ( ) . do not find ( `` resource `` , `` resource `` ) . item ( style . quote , arrays . a list ( this . resource location ) ) ; return condition outcome . no match ( message ) ; } condition message message = start condition message ( ) . find ( `` resource `` , `` resource `` ) . item ( style . quote , find ) ; return condition outcome . match ( message ) ; }
public void set resource loader ( resource loader resource loader ) { this . resource loader = ( resource loader ! = null ? resource loader : new default resource loader ( ) ) ; }
public void free unique name ( string name ) { if ( name ! = null ) { synchronize ( temporary unique name ) { temporary unique name . remove ( name ) ; } } }
public static resource pattern resolver get resource pattern resolver ( resource loader resource loader ) { assert . not null ( resource loader , `` resource loader must not be null `` ) ; if ( resource loader instanceof resource pattern resolver ) { return ( resource pattern resolver ) resource loader ; } else if ( resource loader ! = null ) { return new path match resource pattern resolver ( resource loader ) ; } else { return new path match resource pattern resolver ( ) ; } }
public list < item metadata > get item ( ) { return flatten value ( this . item ) ; }
public url get u r l ( ) { if ( be reference ( ) ) { return ( ( java resource ) get check ref ( ) ) . get u r l ( ) ; } abstract classpath resource . class loader with flag class loader = get class loader ( ) ; if ( class loader . get loader ( ) == null ) { return class loader . get system resource ( get name ( ) ) ; } else { try { return class loader . get loader ( ) . get resource ( get name ( ) ) ; } finally { class loader . cleanup ( ) ; } } }
public void add source directory ( iterable < file > directory ) { assert . not null ( directory , `` directory must not be null `` ) ; synchronize ( this . monitor ) { directory . for each ( this : : add source directory ) ; } }
public static char [ ] to hex char array ( byte [ ] bytes ) { object . require non null ( byte ) ; final char [ ] result = new char [ 2 * byte . length ] ; for ( int i = 0 ; i < byte . length ; i++ ) { byte b = bytes [ i ] ; result [ 2 * i ] = hex_digits [ b > > 4 & 0xf ] ; result [ 2 * i + 1 ] = hex_digits [ b & 0xf ] ; } return result ; }
public void write ( know host entry entry ) throw i o exception { final buffer writer writer = new buffer writer ( new file writer ( kh file , true ) ) ; try { writer . write ( entry . get line ( ) ) ; writer . new line ( ) ; writer . flush ( ) ; } finally { i o utils . close quietly ( writer ) ; } }
public static string find main class ( jar file jar file , string class location ) throw i o exception { return do with main class ( jar file , class location , main class : : get name ) ; }
public static string find single main class ( jar file jar file , string class location ) throw i o exception { return find single main class ( jar file , class location , null ) ; }
public static void copy file ( file source , file destination ) throw i o exception { file input stream in = null ; try { in = new file input stream ( source ) ; i o util . write stream ( in , destination ) ; } finally { if ( in ! = null ) in . close ( ) ; } }
public application context assert < c > have single bean ( class < ? > type ) { return have single bean ( type , scope . include_ancestors ) ; }
public < t > abstract object assert < ? , t > get bean ( class < t > type ) { return get bean ( type , scope . include_ancestors ) ; }
protect final class < ? > get resource load class ( ) { return this . resource load class ; }
public type descriptor get element type descriptor ( ) { if ( this . resolvable type . be array ( ) ) { return new type descriptor ( this . resolvable type . get component type ( ) , null , this . annotation ) ; } if ( stream available & & stream delegate . be stream ( this . type ) ) { return stream delegate . get stream element type ( this ) ; } return get relate if resolvable ( this , this . resolvable type . a collection ( ) . get generic ( ) ) ; }
public json content assert have json path value ( char sequence expression , object . . . args ) { new json path value ( expression , args ) . assert have value ( object . class , `` an object `` ) ; return this ; }
public t get object ( int index ) { return this . get object ( ) . get ( index ) ; }
public boolean contain value ( object value ) { set pair = get map ( ) . entry set ( ) ; if ( pair == null ) { return false ; } iterator pair iterator = pair . iterator ( ) ; while ( pairs iterator . have next ( ) ) { map . entry key value pair = ( map . entry ) pair iterator . next ( ) ; collection coll = ( collection ) key value pair . get value ( ) ; if ( coll . contains ( value ) ) { return true ; } } return false ; }
public void apply to ( configurable application context context ) { apply to ( context . get environment ( ) ) ; }
public < t > t patch for object ( uri url , object request , class < t > response type ) throw rest client exception { return this . rest template . patch for object ( apply root uri if necessary ( url ) , request , response type ) ; }
public < t > response entity < t > post for entity ( uri url , object request , class < t > response type ) throw rest client exception { return this . rest template . post for entity ( apply root uri if necessary ( url ) , request , response type ) ; }
public static entity manager factory create entity manager factory ( string persistence unit name , map property ) { entity manager factory emf = null ; persistence provider resolver resolver = persistence provider resolver holder . get persistence provider resolver ( ) ; list < persistence provider > provider = resolver . get persistence provider ( ) ; for ( persistence provider provider : provider ) { emf = provider . create entity manager factory ( persistence unit name , property ) ; if ( emf ! = null ) { break ; } } if ( emf == null ) { throw new persistence exception ( `` no persistence provider for entity manager name `` + persistence unit name ) ; } return emf ; }
public void set cache name ( collection < string > cache name ) { if ( cache names ! = null ) { for ( string name : cache name ) { this . cache map . put ( name , create concurrent map cache ( name ) ) ; } this . dynamic = false ; } else { this . dynamic = true ; } }
public void add cache method ( string method name , collection < cache operation > ops ) { if ( logger . be debug enable ( ) ) { logger . debug ( `` add method [ `` + method name + `` ] with cache operation [ `` + ops + `` ] `` ) ; } this . name map . put ( method name , ops ) ; }
public void set cache operation source ( cache operation source . . . cache operation source ) { this . cache interceptor . set cache operation source ( cache operation source ) ; }
protect void clear transaction manager cache ( ) { this . transaction manager cache . clear ( ) ; this . bean factory = null ; }
public void register bean definition ( annotation metadata import class metadata , bean definition registry registry ) { boolean candidate find = false ; set < string > anno type = import class metadata . get annotation type ( ) ; for ( string anno type : anno type ) { annotation attribute candidate = annotation config utils . attribute for ( import class metadata , anno type ) ; object mode = candidate . get ( `` mode `` ) ; object proxy target class = candidate . get ( `` proxy target class `` ) ; if ( mode ! = null & & proxy target class ! = null & & advice mode . class == mode . get class ( ) & & boolean . class == proxy target class . get class ( ) ) { candidate find = true ; if ( mode == advice mode . proxy ) { aop config utils . register auto proxy creator if necessary ( registry ) ; if ( ( boolean ) proxy target class ) { aop config utils . force auto proxy creator to use class proxying ( registry ) ; return ; } } } } if ( ! candidate find ) { string name = get class ( ) . get simple name ( ) ; logger . warn ( string . format ( `` % s be import but no annotation be find `` + `` have both 'mode ' and 'proxy target class ' attribute of type `` + `` advice mode and boolean respectively . this mean that auto proxy `` + `` creator registration and configuration may not have occur a `` + `` intend , and component may not be proxied a expect . check to `` + `` ensure that % s have be @ import'ed on the same class where these `` + `` annotation be declare ; otherwise remove the import of % s `` + `` altogether . `` , name , name , name ) ) ; } }
public void merge import by ( configuration class other config class ) { this . import by . add all ( other config class . import by ) ; }
public static optional < ? > try instantiate ( string name , class loader class loader ) { try { return class utils . for name ( name , class loader ) . flat map ( instantiation utils : : try instantiate ) ; } catch ( throwable e ) { logger log = logger factory . get logger ( instantiation utils . class ) ; if ( log . be debug enable ( ) ) { log . debug ( `` try , but could not instantiate type : `` + name , e ) ; } return optional . empty ( ) ; } }
public void set display name ( string display name ) { this . display name = display name ; }
protect bean factory get bean factory ( object target ) { bean factory factory = get bean factory reference ( target ) . get factory ( ) ; if ( factory instanceof application context ) { factory = ( ( application context ) factory ) . get autowire capable bean factory ( ) ; } return factory ; }
public wait strategy with startup timeout ( duration startup timeout ) { this . startup timeout = startup timeout ; return this ; }
protect void invoke bean factory post processor ( configurable listable bean factory bean factory ) { post processor registration delegate . invoke bean factory post processor ( bean factory , get bean factory post processor ( ) ) ; }
public void set use code a default message ( boolean use code a default message ) { this . use code a default message = use code a default message ; }
protect void customize bean factory ( default listable bean factory bean factory ) { }
protect boolean be context require ( ) { return true ; }
public final application context get application context ( ) throw illegal state exception { if ( this . application context == null & & be context require ( ) ) { throw new illegal state exception ( `` application object support instance [ `` + this + `` ] do not run in an application context `` ) ; } return this . application context ; }
public void set resource loader ( resource loader resource loader ) { this . resource loader = ( resource loader ! = null ? resource loader : new default resource loader ( ) ) ; }
public void post process bean factory ( configurable listable bean factory bean factory ) throw bean exception { if ( this . property source == null ) { this . property source = new mutable property source ( ) ; if ( this . environment ! = null ) { this . property source . add last ( new property source < environment > ( environment_properties_property_source_name , this . environment ) { @ override @ nullable public string get property ( string key ) { return this . source . get property ( key ) ; } } ) ; } try { property source < ? > local property source = new property property source ( local_properties_property_source_name , merge property ( ) ) ; if ( this . local override ) { this . property source . add first ( local property source ) ; } else { this . property source . add last ( local property source ) ; } } catch ( i o exception ex ) { throw new bean initialization exception ( `` could not load property `` , ex ) ; } } process property ( bean factory , new property source property resolver ( this . property source ) ) ; this . applied property source = this . property source ; }
protect final void apply cache second ( http servlet response response , int cache second , boolean must revalidate ) { if ( cache second > 0 ) { cache for second ( response , cache second , must revalidate ) ; } else if ( cache second == 0 ) { prevent cache ( response ) ; } }
protect void load property ( property prop ) throw i o exception { if ( this . location ! = null ) { for ( resource location : this . location ) { if ( logger . be info enable ( ) ) { logger . info ( `` load property file from `` + location ) ; } try { property loader utils . fill property ( prop , new encode resource ( location , this . file encode ) , this . property persister ) ; } catch ( i o exception ex ) { if ( this . ignore resource not find ) { if ( logger . be warn enable ( ) ) { logger . warn ( `` could not load property from `` + location + `` : `` + ex . get message ( ) ) ; } } else { throw ex ; } } } } }
protect object do invoke ( method invocation invocation , @ nullable object port stub ) throw throwable { method method = invocation . get method ( ) ; try { return method . invoke ( port stub , invocation . get argument ( ) ) ; } catch ( invocation target exception ex ) { throw ex . get target exception ( ) ; } catch ( throwable ex ) { throw new remote proxy failure exception ( `` invocation of stub method fail : `` + method , ex ) ; } }
protect void configure bean post processor ( autowired annotation bean post processor processor , object target ) { }
protect void do release bean ( object target ) { bean factory reference ref = this . bean factory reference . remove ( target ) ; if ( ref ! = null ) { ref . release ( ) ; } }
public void set time zone ( date time zone time zone ) { this . time zone = time zone ; }
public final void set lenient ( boolean lenient ) { this . lenient = lenient ; }
public void set date formatter ( jsonb date formatter date formatter ) { this . date formatter = date formatter ; }
public void set date time formatter ( date time formatter formatter ) { this . formatters . put ( type . date_time , formatter ) ; }
public static void set date time context ( date time context date time context ) { if ( date time context == null ) { reset date time context ( ) ; } else { date time context holder . set ( date time context ) ; } }
public void set formatters ( set < ? > formatters ) { this . formatters = formatters ; }
protect boolean be eligible ( object bean , string bean name ) { return be eligible ( bean . get class ( ) ) ; }
public void add transformer ( class file transformer transformer ) { assert . not null ( transformer , `` transformer must not be null `` ) ; this . class file transformer . add ( transformer ) ; }
public static domain get default domain ( ) { return default domain wrapper . singleton . get default domain ( ) ; }
public void register externally manage init method ( string init method ) { synchronize ( this . post processing lock ) { if ( this . externally manage init method == null ) { this . externally manage init method = new link hash set < > ( 1 ) ; } this . externally manage init method . add ( init method ) ; } }
public void set autodetect mode ( int autodetect mode ) { if ( ! constant . get value ( constant_prefix_autodetect ) . contains ( autodetect mode ) ) { throw new illegal argument exception ( `` only value of autodetect constant allow `` ) ; } this . autodetect mode = autodetect mode ; }
public void set eager filter init ( boolean eager filter init ) { this . eager filter init = eager filter init ; }
public void add exclude bean ( string exclude bean ) { assert . not null ( excluded bean , `` exclude bean must not be null `` ) ; this . excluded bean . add ( excluded bean ) ; }
public string get description ( ) { if ( description == null ) { description = description . get description ( this ) ; } return description ; }
public void set default currency time limit ( integer default currency time limit ) { this . default currency time limit = default currency time limit ; }
protect void set default value ( object default value ) { use default = false ; if ( log ( ) . be debug enable ( ) ) { log ( ) . debug ( `` set default value : `` + default value ) ; } if ( default value == null ) { this . default value = null ; } else { this . default value = convert ( get default type ( ) , default value ) ; } use default = true ; }
public category get category ( final string category id ) { if ( category id == null ) { return get category ( autogenerated_category_id ) ; } check id ( category id ) ; category category = category by id . get ( category id ) ; if ( category == null ) { category = new category ( category id ) ; category by id . put ( category id , category ) ; category . add category listener ( this ) ; } return category ; }
public void set notification type ( string notification type ) { this . notification type = string utils . comma delimit list to string array ( notification type ) ; }
public string get description ( ) { if ( description == null ) { description = description . get description ( this ) ; } return description ; }
public void set resource ref ( boolean resource ref ) { this . resource ref = resource ref ; }
public object execute ( ivy callback callback ) { push context ( ) ; try { return callback . do in ivy context ( this , ivy context . get context ( ) ) ; } finally { pop context ( ) ; } }
public void rebind ( final string name , final object object ) throw name exception { if ( logger . be debug enable ( ) ) { logger . debug ( `` rebind jndi object with name [ `` + name + `` ] `` ) ; } execute ( new jndi callback < object > ( ) { @ override public object do in context ( context ctx ) throw name exception { ctx . rebind ( name , object ) ; return null ; } } ) ; }
public class < ? > get actual type ( ) { return this . actual type ; }
protect remote get stub ( ) throw remote lookup failure exception { if ( ! this . cache stub || ( this . lookup stub on startup & & ! this . refresh stub on connect failure ) ) { return ( this . cache stub ! = null ? this . cache stub : lookup stub ( ) ) ; } else { synchronize ( this . stub monitor ) { if ( this . cache stub == null ) { this . cache stub = lookup stub ( ) ; } return this . cached stub ; } } }
public void set always reauthenticate ( boolean always reauthenticate ) { this . always reauthenticate = always reauthenticate ; }
protect string get short class name ( class cl ) { return class utils . get short class name ( cl ) ; }
public remote invocation executor get remote invocation executor ( ) { return this . remote invocation executor ; }
protect void handle ( runnable runnable ) { class loader old class loader = thread . current thread ( ) . get context class loader ( ) ; try { thread . current thread ( ) . set context class loader ( class loader ) ; runnable . run ( ) ; } finally { thread . current thread ( ) . set context class loader ( old class loader ) ; } }
protect pointcut build pointcut ( set < class < ? extend annotation > > async annotation type ) { composable pointcut result = null ; for ( class < ? extend annotation > async annotation type : async annotation type ) { pointcut cpc = new annotation match pointcut ( async annotation type , true ) ; pointcut mpc = annotation match pointcut . for method annotation ( async annotation type ) ; if ( result == null ) { result = new composable pointcut ( cpc ) . union ( mpc ) ; } else { result . union ( cpc ) . union ( mpc ) ; } } return result ; }
public void set validated annotation type ( class < ? extend annotation > validate annotation type ) { assert . not null ( validated annotation type , `` 'validated annotation type ' must not be null `` ) ; this . validated annotation type = validate annotation type ; }
public void before test execution ( object test instance , method test method ) throw exception { string callback name = `` before test execution `` ; prepare for before callback ( callback name , test instance , test method ) ; for ( test execution listener test execution listener : get test execution listener ( ) ) { try { test execution listener . before test execution ( get test context ( ) ) ; } catch ( throwable ex ) { handle before exception ( ex , callback name , test execution listener , test instance , test method ) ; } } }
public long get refresh time ( final time unit time unit ) { if ( refresh time < 0 ) { return refresh time ; } return time unit . convert ( refresh time , this . time unit ) ; }
public void set fix rate ( boolean fix rate ) { this . fix rate = fix rate ; }
public schedule task schedule fix delay task ( fix delay task task ) { schedule task schedule task = this . unresolved task . remove ( task ) ; boolean new task = false ; if ( schedule task == null ) { schedule task = new schedule task ( task ) ; new task = true ; } if ( this . task scheduler ! = null ) { if ( task . get initial delay ( ) > 0 ) { date start time = new date ( system . current time millis ( ) + task . get initial delay ( ) ) ; schedule task . future = this . task scheduler . schedule with fixed delay ( task . get runnable ( ) , start time , task . get interval ( ) ) ; } else { schedule task . future = this . task scheduler . schedule with fixed delay ( task . get runnable ( ) , task . get interval ( ) ) ; } } else { add fix delay task ( task ) ; this . unresolved task . put ( task , schedule task ) ; } return ( new task ? schedule task : null ) ; }
protect string get invocation description ( method invocation invocation ) { return `` method ' `` + invocation . get method ( ) . get name ( ) + `` ' of class [ `` + invocation . get this ( ) . get class ( ) . get name ( ) + `` ] `` ; }
public boolean equal ( @ nullable object object ) { if ( object == this ) { return true ; } if ( object instanceof internet domain name ) { internet domain name that = ( internet domain name ) object ; return this . name . equal ( that . name ) ; } return false ; }
protect void do bind ( mutable property value mpvs ) { check allow field ( mpvs ) ; check require field ( mpvs ) ; apply property value ( mpvs ) ; }
protect object increment ( object value ) { return invoker helper . invoke method ( value , `` next `` , null ) ; }
public void set default time zone ( @ nullable time zone default time zone ) { this . default time zone = default time zone ; }
public void post process bean factory ( configurable listable bean factory bean factory ) throw bean exception { if ( this . property source == null ) { this . property source = new mutable property source ( ) ; if ( this . environment ! = null ) { this . property source . add last ( new property source < environment > ( environment_properties_property_source_name , this . environment ) { @ override @ nullable public string get property ( string key ) { return this . source . get property ( key ) ; } } ) ; } try { property source < ? > local property source = new property property source ( local_properties_property_source_name , merge property ( ) ) ; if ( this . local override ) { this . property source . add first ( local property source ) ; } else { this . property source . add last ( local property source ) ; } } catch ( i o exception ex ) { throw new bean initialization exception ( `` could not load property `` , ex ) ; } } process property ( bean factory , new property source property resolver ( this . property source ) ) ; this . applied property source = this . property source ; }
public boolean be resource ref ( ) { return this . resource ref ; }
public static void sort ( list < ? > list ) { list . sort ( comparator ) ; }
protect collection < object > create collection ( class < ? extend collection > collection type , int initial capacity ) { if ( ! collection type . be interface ( ) ) { try { return collection type . new instance ( ) ; } catch ( exception ex ) { throw new illegal argument exception ( `` could not instantiate collection class [ `` + collection type . get name ( ) + `` ] : `` + ex . get message ( ) ) ; } } else if ( list . class == collection type ) { return new array list < object > ( initial capacity ) ; } else if ( sort set . class == collection type ) { return new tree set < object > ( ) ; } else { return new link hash set < object > ( initial capacity ) ; } }
public number get a number ( string key ) { object obj = this . get ( key ) ; if ( obj == null ) return null ; if ( obj instanceof number ) return ( number ) obj ; return long . value of ( obj . to string ( ) ) ; }
public object convert ( object source , type descriptor target type ) { return convert ( source , type descriptor . for object ( source ) , target type ) ; }
public static type descriptor array ( type descriptor element type descriptor ) { if ( element type descriptor == null ) { return null ; } return new type descriptor ( resolvable type . for array component ( element type descriptor . resolvable type ) , null , element type descriptor . get annotation ( ) ) ; }
public metadata source add package ( string package name ) { if ( package name == null ) { throw new illegal argument exception ( `` the specified package name can not be null `` ) ; } if ( package name . end with ( `` . `` ) ) { package name = package name . substring ( 0 , package name . length ( ) - 1 ) ; } add package internal ( package name ) ; return this ; }
protect set < string > do get active profile ( ) { synchronize ( this . active profile ) { if ( this . active profile . be empty ( ) ) { string profile = get property ( active_profiles_property_name ) ; if ( string utils . have text ( profile ) ) { set active profile ( comma delimit list to string array ( trim all whitespace ( profile ) ) ) ; } } return this . active profile ; } }
public void set field name value separator ( string field name value separator ) { super . set field name value separator ( field name value separator ) ; }
public void add before ( string relative property source name , property source < ? > property source ) { if ( logger . be debug enable ( ) ) { logger . debug ( string . format ( `` add [ % s ] property source with search precedence immediately high than [ % s ] `` , property source . get name ( ) , relative property source name ) ) ; } assert legal relative addition ( relative property source name , property source ) ; remove if present ( property source ) ; int index = assert present and get index ( relative property source name ) ; add at index ( index , property source ) ; }
public static class < ? > get collection return type ( method method ) { return resolvable type . for method return type ( method ) . a collection ( ) . resolve generic ( ) ; }
public long classpath content last modified time ( ) { if ( close . get ( ) ) { throw new illegal argument exception ( `` can not use a scan result after it have be close `` ) ; } long max last modified time = 0l ; if ( file to last modified ! = null ) { final long curr time = system . current time millis ( ) ; for ( final long timestamp : file to last modified . value ( ) ) { if ( timestamp > max last modified time & & timestamp < curr time ) { max last modified time = timestamp ; } } } return max last modified time ; }
public url get u r l ( ) throw i o exception { throw new file not find exception ( get description ( ) + `` can not be resolve to url `` ) ; }
public static boolean exists ( path . . . file ) { for ( path file : file ) { if ( file . exists ( file ) ) { return true ; } } return false ; }
public long content length ( ) throw i o exception { if ( this . file ! = null ) { long length = this . file . length ( ) ; if ( length == 0l & & ! this . file . exists ( ) ) { throw new file not find exception ( get description ( ) + `` can not be resolve in the file system for check it content length `` ) ; } return length ; } else { try { return file . size ( this . file path ) ; } catch ( no such file exception ex ) { throw new file not find exception ( ex . get message ( ) ) ; } } }
public string get filename ( ) { return new file ( this . url . get file ( ) ) . get name ( ) ; }
public void set key file ( file file path ) { this . key file = file path ; if ( ! key file . exists ( ) ) { message . warn ( `` pemfile `` + key file . get absolute path ( ) + `` do n't exist . `` ) ; key file = null ; } else if ( ! key file . can read ( ) ) { message . warn ( `` pemfile `` + key file . get absolute path ( ) + `` not readable . `` ) ; key file = null ; } else { message . debug ( `` use `` + key file . get absolute path ( ) + `` a keyfile . `` ) ; } }
public boolean equal ( object obj ) { return ( obj == this || ( obj instanceof descriptive resource & & ( ( descriptive resource ) obj ) . description . equal ( this . description ) ) ) ; }
public int hash code ( ) { return get path ( ) . hash code ( ) ; }
public output stream get output stream ( ) throw i o exception { if ( file . be directory ( this . path ) ) { throw new file not find exception ( get path ( ) + `` ( be a directory ) `` ) ; } return file . new output stream ( this . path ) ; }
public boolean equal ( object obj ) { if ( obj == this ) { return true ; } if ( obj instanceof class path resource ) { class path resource other re = ( class path resource ) obj ; return ( this . path . equal ( other re . path ) & & object utils . null safe equal ( this . class loader , other re . class loader ) & & object utils . null safe equal ( this . clazz , other re . clazz ) ) ; } return false ; }
protect string resolve path ( string path ) { return get environment ( ) . resolve required placeholder ( path ) ; }
protect file get file for last modified check ( ) throw i o exception { url url = get u r l ( ) ; if ( resource utils . be jar u r l ( url ) ) { url actual url = resource utils . extract archive u r l ( url ) ; if ( actual url . get protocol ( ) . start with ( resource utils . url_protocol_vfs ) ) { return vfs resource delegate . get resource ( actual url ) . get file ( ) ; } return resource utils . get file ( actual url , `` jar url `` ) ; } else { return get file ( ) ; } }
@ override public void validate ( ) throw service local exception { super . validate ( ) ; if ( this . get url ( ) == null ) { throw new service local exception ( `` the url property on the exchange service object must be set . `` ) ; } }
public static url get resource a u r l ( object object , resource resource ) { class loader loader = object . get class ( ) . get class loader ( ) ; url url = null ; if ( loader ! = null ) { url = loader . get resource ( resource . get name ( ) ) ; } else { url = class loader . get system resource ( resource . get name ( ) ) ; } return ( url ) ; }
public static < t > list < t > load factory ( class < t > factory class , class loader class loader ) { assert . not null ( factory class , `` 'factory class ' must not be null `` ) ; class loader class loader to use = class loader ; if ( class loader to use == null ) { class loader to use = spring factory loader . class . get class loader ( ) ; } list < string > factory name = load factory name ( factory class , class loader to use ) ; if ( logger . be trace enable ( ) ) { logger . trace ( `` load [ `` + factory class . get name ( ) + `` ] name : `` + factory name ) ; } list < t > result = new array list < t > ( factory name . size ( ) ) ; for ( string factory name : factory name ) { result . add ( instantiate factory ( factory name , factory class , class loader to use ) ) ; } annotation aware order comparator . sort ( result ) ; return result ; }
public int hash code ( ) { int hash = super . hash code ( ) ; hash = lang utils . hash code ( hash , this . host ) ; hash = lang utils . hash code ( hash , this . domain ) ; return hash ; }
public static constructor < ? > [ ] get all constructor ( class < ? > clazz ) { constructor < ? > [ ] declare constructor = clazz . get declared constructor ( ) ; for ( constructor < ? > constructor : declared constructor ) { if ( ! constructor . be accessible ( ) ) { constructor . set accessible ( true ) ; } } return declared constructor ; }
public void decrease nest level ( ) { get type index per level ( ) . remove ( this . nest level ) ; this . nesting level -- ; }
public static int get order ( bean definition bean def ) { integer order = ( integer ) bean def . get attribute ( order_attribute ) ; return ( order ! = null ? order : order . lowest_precedence ) ; }
public boolean equal ( final object obj ) { if ( ! ( obj instanceof byte order mark ) ) { return false ; } final byte order mark bom = ( byte order mark ) obj ; if ( byte . length ! = bom . length ( ) ) { return false ; } for ( int i = 0 ; i < byte . length ; i++ ) { if ( bytes [ i ] ! = bom . get ( i ) ) { return false ; } } return true ; }
protect boolean be eligible ( object bean , string bean name ) { return be eligible ( bean . get class ( ) ) ; }
public void set parameter name discoverer ( parameter name discoverer parameter name discoverer ) { this . parameter name discoverer = parameter name discoverer ; }
public static boolean get boolean property ( property prop , string key , boolean def ) { string value = prop . get property ( key , `` `` + def ) ; try { return boolean . parse boolean ( value ) ; } catch ( exception e ) { trace system . trace throwable ( e ) ; return def ; } }
public to string creator append ( object value ) { this . styler . style value ( this . buffer , value ) ; return this ; }
public to string creator append ( string field name , short value ) { return append ( field name , new short ( value ) ) ; }
protect void execute ( runnable task ) { executor . execute ( task ) ; }
public void set resolve factory method ( @ nullable method method ) { this . factory method to introspect = method ; }
public void add trim ( token filter . trim filter ) { filter reader . add element ( filter ) ; }
public static boolean simple match ( string pattern , string str ) { if ( pattern == null || str == null ) { return false ; } int first index = pattern . index of ( ' * ' ) ; if ( first index == -1 ) { return pattern . equal ( str ) ; } if ( first index == 0 ) { if ( pattern . length ( ) == 1 ) { return true ; } int next index = pattern . index of ( ' * ' , first index + 1 ) ; if ( next index == -1 ) { return str . end with ( pattern . substring ( 1 ) ) ; } string part = pattern . substring ( 1 , next index ) ; if ( `` `` . equal ( part ) ) { return simple match ( pattern . substring ( next index ) , str ) ; } int part index = str . index of ( part ) ; while ( part index ! = -1 ) { if ( simple match ( pattern . substring ( next index ) , str . substring ( part index + part . length ( ) ) ) ) { return true ; } part index = str . index of ( part , part index + 1 ) ; } return false ; } return ( str . length ( ) > = first index & & pattern . substring ( 0 , first index ) . equal ( str . substring ( 0 , first index ) ) & & simple match ( pattern . substring ( first index ) , str . substring ( first index ) ) ) ; }
public long get initial interval ( ) { return initial interval ; }
public static byte [ ] decode url safe ( byte [ ] src ) { assert delegate available ( ) ; return delegate . decode url safe ( src ) ; }
public static string get package name ( string fq class name ) { assert . not null ( fq class name , `` class name must not be null `` ) ; int last dot index = fq class name . last index of ( package_separator ) ; return ( last dot index ! = -1 ? fq class name . substring ( 0 , last dot index ) : `` `` ) ; }
public static boolean be instance ( object value , type type ) { if ( type == null ) { return false ; } return value == null ? ! ( type instanceof class < ? > ) || ! ( ( class < ? > ) type ) . be primitive ( ) : be assignable ( value . get class ( ) , type , null ) ; }
public static string convert class name to resource path ( string class name ) { assert . not null ( class name , `` class name must not be null `` ) ; return class name . replace ( package_separator , path_separator ) ; }
public void set ascending ( boolean ascending ) { this . ascend = ascending ; }
public void set acceptor thread priority ( int acceptor thread priority ) { this . acceptor thread priority = acceptor thread priority ; }
public static string md5 digest a hex ( byte [ ] bytes ) { return digest a hex string ( md5_algorithm_name , byte ) ; }
protect void do write object ( final object output stream out ) throw i o exception { out . write float ( load factor ) ; out . write int ( data . length ) ; out . write int ( size ) ; for ( final map iterator < k , v > it = map iterator ( ) ; it . have next ( ) ; ) { out . write object ( it . next ( ) ) ; out . write object ( it . get value ( ) ) ; } }
protect file get file for last modified check ( ) throw i o exception { url url = get u r l ( ) ; if ( resource utils . be jar u r l ( url ) ) { url actual url = resource utils . extract archive u r l ( url ) ; if ( actual url . get protocol ( ) . start with ( resource utils . url_protocol_vfs ) ) { return vfs resource delegate . get resource ( actual url ) . get file ( ) ; } return resource utils . get file ( actual url , `` jar url `` ) ; } else { return get file ( ) ; } }
public void set target object ( object target object ) { this . target object = target object ; if ( target object ! = null ) { this . target class = target object . get class ( ) ; } }
public static boolean be empty ( object [ ] array ) { if ( array == null || array . length == 0 ) { return true ; } return false ; }
public static void make accessible ( constructor < ? > ctor ) { if ( ( ! modifier . be public ( ctor . get modifier ( ) ) || ! modifier . be public ( ctor . get declare class ( ) . get modifier ( ) ) ) & & ! ctor . be accessible ( ) ) { ctor . set accessible ( true ) ; } }
public static method [ ] get declare method ( final class < ? > clazz ) { method [ ] method = null ; if ( globals . is_security_enabled ) { method = access controller . do privilege ( new privilege action < method [ ] > ( ) { @ override public method [ ] run ( ) { return clazz . get declare method ( ) ; } } ) ; } else { method = clazz . get declare method ( ) ; } return method ; }
public static boolean be jar u r l ( url url ) { string protocol = url . get protocol ( ) ; return ( url_protocol_jar . equal ( protocol ) || url_protocol_war . equal ( protocol ) || url_protocol_zip . equal ( protocol ) || url_protocol_vfszip . equal ( protocol ) || url_protocol_wsjar . equal ( protocol ) ) ; }
public void update message digest ( message digest message digest , int len ) throw i o exception { int data ; int bytes read = 0 ; while ( byte read < len & & ( data = read ( ) ) ! = -1 ) { message digest . update ( ( byte ) data ) ; bytes read++ ; } }
public static < a extend annotation > merge annotation selector < a > nearest ( ) { return ( merge annotation selector < a > ) near ; }
public static synthesizing method parameter for parameter ( parameter parameter ) { return for executable ( parameter . get declare executable ( ) , find parameter index ( parameter ) ) ; }
public void set max in memory size ( int byte count ) { this . max in memory size = byte count ; this . xml event decoder . set max in memory size ( byte count ) ; }
public void set logger name ( string logger name ) { this . logger = log factory . get log ( logger name ) ; }
public log get logger ( ) { if ( logger ! = null ) return logger ; logger = log factory . get log ( get log name ( ) ) ; return logger ; }
public static void add collection converter ( converter registry converter registry ) { conversion service conversion service = ( conversion service ) converter registry ; converter registry . add converter ( new array to collection converter ( conversion service ) ) ; converter registry . add converter ( new collection to array converter ( conversion service ) ) ; converter registry . add converter ( new array to array converter ( conversion service ) ) ; converter registry . add converter ( new collection to collection converter ( conversion service ) ) ; converter registry . add converter ( new map to map converter ( conversion service ) ) ; converter registry . add converter ( new array to string converter ( conversion service ) ) ; converter registry . add converter ( new string to array converter ( conversion service ) ) ; converter registry . add converter ( new array to object converter ( conversion service ) ) ; converter registry . add converter ( new object to array converter ( conversion service ) ) ; converter registry . add converter ( new collection to string converter ( conversion service ) ) ; converter registry . add converter ( new string to collection converter ( conversion service ) ) ; converter registry . add converter ( new collection to object converter ( conversion service ) ) ; converter registry . add converter ( new object to collection converter ( conversion service ) ) ; if ( stream available ) { converter registry . add converter ( new stream converter ( conversion service ) ) ; } }
public resource create relative ( string relative path ) throw i o exception { return new path resource ( this . path . resolve ( relative path ) ) ; }
public void split trace ( string message ) { if ( log . be trace enable ( ) ) log . trace ( message , split message ( 0 ) ) ; }
public void warn ( throwable cause , char sequence message ) { this . log . warn ( message , cause ) ; }
public string result ( ) { try { this . indent ( ) ; } catch ( runtime exception re ) { throw new runtime exception ( `` problem here : `` + this , re ) ; } if ( this . json == null ) { return null ; } string result string = this . result . to string ( ) ; return result string == null ? null : result string . trim ( ) ; }
public static < t > t convert publisher ( object object , class < t > publisher type ) { object . require non null ( object , `` argument [ object ] can not be null `` ) ; object . require non null ( publisher type , `` argument [ publisher type ] can not be null `` ) ; if ( publisher type . be instance ( object ) ) { return ( t ) object ; } if ( object instanceof completable future ) { @ suppress warning ( `` unchecked `` ) publisher < t > future publisher = publisher . from completable future ( ( ) - > ( ( completable future ) object ) ) ; return conversion service . share . convert ( future publisher , publisher type ) . or else throw ( ( ) - > unconvertible error ( object , publisher type ) ) ; } else if ( object instanceof micronaut publisher & & micronaut publisher . class . be assignable from ( publisher type ) ) { return ( t ) object ; } else { return conversion service . share . convert ( object , publisher type ) . or else throw ( ( ) - > unconvertible error ( object , publisher type ) ) ; } }
public static reactive type descriptor no value ( class < ? > type , supplier < ? > empty supplier ) { return new reactive type descriptor ( type , false , true , empty supplier ) ; }
public static void have text ( string text , string message ) { if ( ! string utils . have text ( text ) ) { throw new illegal argument exception ( message ) ; } }
public static < t > comparator < t > null low ( comparator < t > comparator ) { return new null safe comparator < > ( comparator , true ) ; }
public boolean equal ( object obj ) { if ( obj == null ) return false ; if ( ! ( obj instanceof medium type ) ) return false ; medium type other = ( medium type ) obj ; return ( this . type . equal ignore case ( other . type ) & & this . subtype . equal ignore case ( other . subtype ) & & this . parameter . equal ( other . parameter ) ) ; }
public field initialization report initialize ( ) { final accessibility changer changer = new accessibility changer ( ) ; changer . enable access ( field ) ; try { return acquire field instance ( ) ; } catch ( illegal access exception e ) { throw new mockito exception ( `` problem initialize field ' `` + field . get name ( ) + `` ' of type ' `` + field . get type ( ) . get simple name ( ) + `` ' `` , e ) ; } finally { changer . safely disable access ( field ) ; } }
public void stop ( ) throw illegal state exception { if ( this . current task name == null ) { throw new illegal state exception ( `` ca n't stop stop watch : it 's not run `` ) ; } long last time = system . nano time ( ) - this . start time nanos ; this . total time nanos += last time ; this . last task info = new task info ( this . current task name , last time ) ; if ( this . keep task list ) { this . task list . add ( this . last task info ) ; } ++this . task count ; this . current task name = null ; }
public long get last task time nanos ( ) throw illegal state exception { if ( this . last task info == null ) { throw new illegal state exception ( `` no task run : ca n't get last task interval `` ) ; } return this . last task info . get time nanos ( ) ; }
public string pretty print ( ) { string builder sb = new string builder ( short summary ( ) ) ; sb . append ( '\n ' ) ; if ( ! this . keep task list ) { sb . append ( `` no task info keep `` ) ; } else { sb . append ( `` -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -\n `` ) ; sb . append ( `` m % task name\n `` ) ; sb . append ( `` -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -\n `` ) ; number format nf = number format . get number instance ( ) ; nf . set minimum integer digit ( 5 ) ; nf . set group use ( false ) ; number format pf = number format . get percent instance ( ) ; pf . set minimum integer digit ( 3 ) ; pf . set group use ( false ) ; for ( task info task : get task info ( ) ) { sb . append ( nf . format ( task . get time millis ( ) ) ) . append ( `` `` ) ; sb . append ( pf . format ( task . get time second ( ) / get total time second ( ) ) ) . append ( `` `` ) ; sb . append ( task . get task name ( ) ) . append ( `` \n `` ) ; } } return sb . to string ( ) ; }
public static void copy byte ( input stream in , output stream out , long count , boolean close ) throw i o exception { byte buf [ ] = new byte [ 4096 ] ; long byte remain = count ; int bytes read ; try { while ( byte remain > 0 ) { int byte to read = ( int ) ( bytes remain < buf . length ? bytes remain : buf . length ) ; bytes read = in . read ( buf , 0 , byte to read ) ; if ( byte read == -1 ) break ; out . write ( buf , 0 , byte read ) ; bytes remain -= byte read ; } if ( close ) { out . close ( ) ; out = null ; in . close ( ) ; in = null ; } } finally { if ( close ) { close stream ( out ) ; close stream ( in ) ; } } }
public long to terabyte ( ) { return this . bytes / bytes_per_tb ; }
public static char to char ( type converter type converter , type value type value ) { return ( character ) type converter . convert value ( typed value . get value ( ) , type value . get type descriptor ( ) , type descriptor . value of ( character . class ) ) ; }
public static string class name to string ( collection < class < ? > > class ) { if ( collection utils . be empty ( class ) ) { return `` [ ] `` ; } string builder sb = new string builder ( `` [ `` ) ; for ( iterator < class < ? > > it = class . iterator ( ) ; it . have next ( ) ; ) { class < ? > clazz = it . next ( ) ; sb . append ( clazz . get name ( ) ) ; if ( it . have next ( ) ) { sb . append ( `` , `` ) ; } } sb . append ( `` ] `` ) ; return sb . to string ( ) ; }
public boolean type value get value internal ( expression state state ) throw evaluation exception { spel node impl leave op = get leave operand ( ) ; spel node impl right op = get right operand ( ) ; object leave = left op . get value ( state , string . class ) ; object right = get right operand ( ) . get value internal ( state ) . get value ( ) ; if ( ! ( left instanceof string ) ) { throw new spel evaluation exception ( left op . get start position ( ) , spel message . invalid_first_operand_for_matches_operator , leave ) ; } if ( ! ( right instanceof string ) ) { throw new spel evaluation exception ( right op . get start position ( ) , spel message . invalid_second_operand_for_matches_operator , right ) ; } try { string leave string = ( string ) leave ; string right string = ( string ) right ; pattern pattern = this . pattern cache . get ( right string ) ; if ( pattern == null ) { pattern = pattern . compile ( right string ) ; this . pattern cache . put if absent ( right string , pattern ) ; } matcher matcher = pattern . matcher ( left string ) ; return boolean typed value . for value ( matcher . match ( ) ) ; } catch ( pattern syntax exception ex ) { throw new spel evaluation exception ( right op . get start position ( ) , ex , spel message . invalid_pattern , right ) ; } }
public static method find method ( method method to find , class < ? > cl ) { if ( cls == null ) { return null ; } string method to search = method to find . get name ( ) ; class < ? > [ ] seek for parameter type = method to find . get parameter type ( ) ; type [ ] seek for generic parameter type = method to find . get generic parameter type ( ) ; for ( method method : cl . get method ( ) ) { if ( method . get name ( ) . equal ( method to search ) & & method . get return type ( ) . be assignable from ( method to find . get return type ( ) ) ) { class < ? > [ ] src parameter type = method . get parameter type ( ) ; type [ ] src generic parameter type = method . get generic parameter type ( ) ; if ( seek for parameter type . length == src parameter type . length & & seek for generic parameter type . length == src generic parameter type . length ) { if ( have identical parameter ( src parameter type , seek for parameter type , src generic parameter type , seek for generic parameter type ) ) { return method ; } } } } return null ; }
protect method find getter for property ( string property name , class < ? > clazz , boolean must be static ) { method method = find method for property ( get property method suffix ( property name ) , `` get `` , clazz , must be static , 0 , any_types ) ; if ( method == null ) { method = find method for property ( get property method suffix ( property name ) , `` be `` , clazz , must be static , 0 , boolean_types ) ; } return method ; }
protect string get property method suffix ( string property name ) { if ( property name . length ( ) > 1 & & character . be upper case ( property name . char at ( 1 ) ) ) { return property name ; } return string utils . capitalize ( property name ) ; }
public string get insert string ( ) { return this . insert string ; }
public static data bind property accessor for read write access ( ) { return new data bind property accessor ( true ) ; }
public static void revert to interpret ( expression expression ) { if ( expression instanceof spel expression ) { ( ( spel expression ) expression ) . revert to interpret ( ) ; } }
public void set pattern variable ( single variable declaration pattern variable ) { support only in17 ( ) ; unsupported without preview error ( ) ; if ( pattern variable == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . pattern variable ; pre replace child ( old child , pattern variable , pattern_variable_property ) ; this . pattern variable = pattern variable ; post replace child ( old child , pattern variable , pattern_variable_property ) ; }
public static i java element create ( i file file ) { return java model manager . create ( file , null/ * unknown java project * / ) ; }
public static i java model status validate classpath entry ( i java project project , i classpath entry entry , boolean check source attachment ) { return classpath entry . validate classpath entry ( project , entry , check source attachment , false/ * not refer by container * / ) ; }
public void init ( ) throw build exception { super . init ( ) ; xml catalog . set project ( get project ( ) ) ; xpath factory = x path factory . new instance ( ) ; xpath = xpath factory . new x path ( ) ; xpath . set x path variable resolver ( new x path variable resolver ( ) { public object resolve variable ( q name variable name ) { return get project ( ) . get property ( variable name . to string ( ) ) ; } } ) ; }
public boolean has7 bit encoding string ( ) { for ( chunk c : main chunk . get chunk ( ) ) { if ( c instanceof string chunk ) { if ( c . get type ( ) == type . ascii_string ) { return true ; } } } if ( name id chunk ! =null ) { for ( chunk c : name id chunk . get chunk ( ) ) { if ( c instanceof string chunk ) { if ( c . get type ( ) == type . ascii_string ) { return true ; } } } } for ( recipient chunk rc : recipient chunk ) { for ( chunk c : rc . get all ( ) ) { if ( c instanceof string chunk ) { if ( c . get type ( ) == type . ascii_string ) { return true ; } } } } return false ; }
public static int get chunk need for byte ( long datasize ) { return divide round up ( datasize + block_header_size + large block . header_size + large block . footer_size , chunk_size ) ; }
public index exception builder add problem address ( string description , long data block address , int range size ) { memory access log last write = this . db . get log ( ) . get report for ( data block address , range size ) ; this . related address . add ( new relate address ( description , data block address , range size , last write ) ) ; return this ; }
public nd type signature get return type ( ) { return return_type . get ( get nd ( ) , this . address ) ; }
public static int record size ( int element record size , int record per block , int metadata bit per record ) { int metadata size = 0 ; if ( metadata bit per record > 0 ) { int metadata record per short = 16 / metadata bit per record ; int number of short = ( record per block + metadata record per short - 1 ) / metadata record per short ; metadata size = 2 * number of short ; } return database . ptr_size + element record size * record per block + metadata size ; }
public static int round up to near multiple of power of two ( int number to round , int a power of two ) { return ( ( number to round + a power of two - 1 ) & ~ ( a power of two - 1 ) ) ; }
protect void set line separator ( string line separator ) { this . line separator = line separator ; }
public jdbc user detail manager configurer < b > group authority by username ( string query ) { jdbc user detail manager user detail service = get user detail service ( ) ; user detail service . set enable group ( true ) ; user detail service . set group authority by username query ( query ) ; return this ; }
public void set user detail service ( user detail service a user detail service ) { this . user detail service = a user detail service ; }
public http basic configurer < http security > http basic ( ) throw exception { return get or apply ( new http basic configurer < > ( ) ) ; }
public form login configurer < http security > form login ( ) throw exception { return get or apply ( new form login configurer < > ( ) ) ; }
public static boolean be debug log enable ( ) { return log . be debug enable ( ) ; }
protect mono < authentication > exit switch user ( web filter exchange web filter exchange ) { return this . exit user matcher . match ( web filter exchange . get exchange ( ) ) . filter ( server web exchange matcher . match result : : be match ) . flat map ( ( match result ) - > reactive security context holder . get context ( ) . map ( security context : : get authentication ) . switch if empty ( mono . error ( this : : no current user exception ) ) ) . map ( this : : attempt exit user ) ; }
protect final string get login page ( ) { return this . login page ; }
protect final f get authentication filter ( ) { return this . auth filter ; }
public t login process url ( string login process url ) { this . login process url = login process url ; this . auth filter . set require authentication request matcher ( create login process url matcher ( login process url ) ) ; return get self ( ) ; }
public logout configurer < h > logout url ( string logout url ) { this . logout request matcher = null ; this . logout url = logout url ; return this ; }
public static protection domain get script protection domain ( ) { final security manager security manager = system . get security manager ( ) ; if ( security manager instanceof rhino security manager ) { return access controller . do privilege ( new privilege action < protection domain > ( ) { public protection domain run ( ) { class < ? > c = ( ( rhino security manager ) security manager ) . get current script class ( ) ; return c == null ? null : c . get protection domain ( ) ; } } ) ; } return null ; }
public void set logout success url ( uri logout success url ) { assert . not null ( logout success url , `` logout success url can not be null `` ) ; this . logout success url = logout success url ; }
public o auth2 login configurer < b > authorization endpoint ( customizer < authorization endpoint config > authorization endpoint customizer ) { authorization endpoint customizer . customize ( this . authorization endpoint config ) ; return this ; }
public object invoke ( method invocation mi ) throw throwable { interceptor status token token = super . before invocation ( mi ) ; object result ; try { result = mi . proceed ( ) ; } finally { super . finally invocation ( token ) ; } return super . after invocation ( token , result ) ; }
public boolean support ( class < ? > clazz ) { for ( after invocation provider provider : this . provider ) { if ( ! provider . support ( clazz ) ) { return false ; } } return true ; }
public void handle ( callback callback , authentication authentication ) { if ( callback instanceof name callback ) { ( ( name callback ) callback ) . set name ( get user name ( authentication ) ) ; } }
public static void clear stack ( ) { context stack . clear ( ) ; }
protected list < grant authority > load user authority ( string username ) { return get jdbc template ( ) . query ( this . authority by username query , new string [ ] { username } , ( r , row num ) - > { string role name = jdbc dao impl . this . role prefix + r . get string ( 2 ) ; return new simple grant authority ( role name ) ; } ) ; }
public static string decode ( byte [ ] bytes ) { try { return charset . new decoder ( ) . decode ( byte buffer . wrap ( byte ) ) . to string ( ) ; } catch ( character cod exception ex ) { throw new illegal argument exception ( `` decoding fail `` , ex ) ; } }
public secret get client secret ( ) { return secret ; }
public search request request cache ( boolean request cache ) { this . request cache = request cache ; return this ; }
public @ nullable instant get expire at ( ) { return this . expire at ; }
public void set default target url ( string default target url ) { assert . be true ( url utils . be valid redirect url ( default target url ) , `` default target must start with '/ ' or with 'http ( s ) ' `` ) ; this . default target url = default target url ; }
public void set redirect strategy ( redirect strategy redirect strategy ) { assert . not null ( redirect strategy , `` redirect strategy can not be null `` ) ; this . redirect strategy = redirect strategy ; }
public security context load context ( http request response holder request response holder ) { http servlet request request = request response holder . get request ( ) ; http servlet response response = request response holder . get response ( ) ; http session http session = request . get session ( false ) ; security context context = read security context from session ( http session ) ; if ( context == null ) { context = generate new context ( ) ; if ( this . logger . be trace enable ( ) ) { this . logger . trace ( log message . format ( `` create % s `` , context ) ) ; } } save to session response wrapper wrap response = new save to session response wrapper ( response , request , http session ! = null , context ) ; request response holder . set response ( wrapped response ) ; request response holder . set request ( new save to session request wrapper ( request , wrap response ) ) ; return context ; }
public void set exception if variable miss ( boolean exception if variable miss ) { this . exception if variable miss = exception if variable missing ; }
protect void cancel cookie ( http servlet request request , http servlet response response ) { this . logger . debug ( `` cancel cookie `` ) ; cookie cookie = new cookie ( this . cookie name , null ) ; cookie . set max age ( 0 ) ; cookie . set path ( get cookie path ( request ) ) ; if ( this . cookie domain ! = null ) { cookie . set domain ( this . cookie domain ) ; } cookie . set secure ( ( this . use secure cookie ! = null ) ? this . use secure cookie : request . be secure ( ) ) ; response . add cookie ( cookie ) ; }
public string get session id ( ) { return this . session id ; }
public void set use forward header ( boolean use forward header ) { this . use forward header = use forward header ; }
public void set exit user url ( string exit user url ) { assert . be true ( url utils . be valid redirect url ( exit user url ) , `` exit user url can not be empty and must be a valid redirect url `` ) ; this . exit user matcher = create matcher ( exit user url ) ; }
public authentication get authentication ( ) { return ( authentication ) this . source ; }
public form login configurer < h > password parameter ( string password parameter ) { get authentication filter ( ) . set password parameter ( password parameter ) ; return this ; }
public string get request url ( ) { return url utils . build request url ( this . request ) ; }
public void set allow url encode slash ( boolean allow url encoded slash ) { if ( allow url encode slash ) { url blocklists remove all ( forbidden_forwardslash ) ; } else { url blocklists add all ( forbidden_forwardslash ) ; } }
public string get parameter ( string name ) { parse parameter ( ) ; string [ ] value = parameter . get ( name ) ; if ( value == null ) { return null ; } return value [ 0 ] ; }
public void set authentication failure handler ( authentication failure handler failure handler ) { assert . not null ( failure handler , `` failure handler can not be null `` ) ; this . failure handler = failure handler ; }
public void set parameter name ( string parameter name ) { assert . not null ( parameter name , `` parameter name be not null `` ) ; this . parameter name = parameter name ; }
public void set header name ( string header name ) { assert . not null ( header name , `` header name be not null `` ) ; this . header name = header name ; }
public void set cookie domain ( string cookie domain ) { if ( cookie domain ! = null & & cookie domain . trim ( ) . length ( ) == 0 ) { this . cookie domain = null ; } else { this . cookie domain = cookie domain ; } }
public evaluation context get evaluation context ( ) { if ( this . evaluation context == null ) { this . evaluation context = new standard evaluation context ( ) ; } return this . evaluation context ; }
public http header get response header ( ) { if ( collection utils . be empty ( this . http method ) ) { return http header . empty ; } http header header = new http header ( ) ; header . set allow ( this . http method ) ; return header ; }
public boolean be active ( ) { return this . active ; } // -- boolean be active ( )
public void invalidate ( ) { assert be valid ( ) ; this . invalid = true ; clear attribute ( ) ; }
public mock http servlet request builder session ( mock http session session ) { assert . not null ( session , `` 'session ' must not be null `` ) ; this . session = session ; return this ; }
public void activate option ( ) { if ( follow ) { if ( target . equal ( system_err ) ) { set writer ( create writer ( new system err stream ( ) ) ) ; } else { set writer ( create writer ( new system out stream ( ) ) ) ; } } else { if ( target . equal ( system_err ) ) { set writer ( create writer ( system . err ) ) ; } else { set writer ( create writer ( system . out ) ) ; } } super . activate option ( ) ; }
public void set config location ( string . . . location ) { if ( location ! = null ) { assert . no null element ( location , `` config location must not be null `` ) ; this . config location = new string [ location . length ] ; for ( int i = 0 ; i < location . length ; i++ ) { this . config location [ i ] = resolve path ( location [ i ] ) . trim ( ) ; } } else { this . config location = null ; } }
protect int count row in table ( string table name ) { return jdbc test utils . count row in table ( this . jdbc template , table name ) ; }
public static int delete from table ( jdbc template jdbc template , string . . . table name ) { int total row count = 0 ; for ( string table name : table name ) { int row count = jdbc template . update ( `` delete from `` + table name ) ; total row count += row count ; if ( logger . be info enable ( ) ) { logger . info ( `` delete `` + row count + `` row from table `` + table name ) ; } } return total row count ; }
public static int delete from table ( jdbc template jdbc template , string . . . table name ) { int total row count = 0 ; for ( string table name : table name ) { int row count = jdbc template . update ( `` delete from `` + table name ) ; total row count += row count ; if ( logger . be info enable ( ) ) { logger . info ( `` delete `` + row count + `` row from table `` + table name ) ; } } return total row count ; }
protect void run child ( framework method framework method , run notifier notifier ) { description description = describe child ( framework method ) ; if ( be test method ignore ( framework method ) ) { notifier . fire test ignore ( description ) ; } else { statement statement ; try { statement = method block ( framework method ) ; } catch ( throwable ex ) { statement = new fail ( ex ) ; } run leaf ( statement , description , notifier ) ; } }
protect resource [ ] find all class path resource ( string location ) throw i o exception { string path = location ; if ( path . start with ( `` / `` ) ) { path = path . substring ( 1 ) ; } set < resource > result = do find all class path resource ( path ) ; if ( logger . be debug enable ( ) ) { logger . debug ( `` resolve classpath location [ `` + location + `` ] to resource `` + result ) ; } return result . to array ( new resource [ result . size ( ) ] ) ; }
public static void flag for rollback ( ) { set flag for rollback ( true ) ; }
public void rollback ( ) { delegate . rollback ( ) ; }
public request matcher value ( object expect value ) { return new abstract json path request matcher ( ) { @ override protect void match internal ( mock client http request request ) throw i o exception , parse exception { json path request matcher . this . json path helper . assert value ( request . get body a string ( ) , expect value ) ; } } ; }
public request matcher exists ( ) { return new abstract json path request matcher ( ) { @ override protect void match internal ( mock client http request request ) throw i o exception , parse exception { json path request matcher . this . json path helper . exists ( request . get body a string ( ) ) ; } } ; }
public static request matcher query param ( string name , matcher < ? super string > . . . matcher ) { return request - > { multi value map < string , string > params = get query params ( request ) ; assert value count ( `` query param `` , name , params , matcher . length ) ; for ( int i = 0 ; i < matcher . length ; i++ ) { assert that ( `` query param `` , params . get ( name ) . get ( i ) , matcher [ i ] ) ; } } ; }
public request matcher string ( string content ) { return ( xpath request matcher ) request - > this . xpath helper . assert string ( request . get body a byte ( ) , default_encoding , content ) ; }
public request matcher node count ( int expect count ) { return ( xpath request matcher ) request - > this . xpath helper . assert node count ( request . get body a byte ( ) , default_encoding , expect count ) ; }
public request matcher number ( double value ) { return ( xpath request matcher ) request - > this . xpath helper . assert number ( request . get body a byte ( ) , default_encoding , value ) ; }
public static void assert model attribute available ( model and view mav , string model name ) { map < string , object > model = mav . get model ( ) ; assert true ( `` model attribute with name ' `` + model name + `` ' be not available `` , model . contains key ( model name ) ) ; }
public void set last modified ( long last modify ) { this . last modify = last modify ; }
public < t > web test client . body content spec value ( consumer < t > consumer ) { object value = this . path helper . evaluate json path ( this . content ) ; consumer . accept ( ( t ) value ) ; return this . body spec ; }
public web test client . response spec is4xx client error ( ) { return assert series and return ( http status . series . client_error ) ; }
public web test client . response spec value ( string name , consumer < string > consumer ) { string value = get require value ( name ) ; this . exchange result . assert with diagnostics ( ( ) - > consumer . accept ( value ) ) ; return this . response spec ; }
public mock http servlet request builder context path ( string context path ) { if ( string utils . have text ( context path ) ) { assert . be true ( context path . start with ( `` / `` ) , `` context path must start with a '/ ' `` ) ; assert . be true ( ! context path . end with ( `` / `` ) , `` context path must not end with a '/ ' `` ) ; } this . context path = context path ; return this ; }
public mock http servlet request builder request attr ( string name , object value ) { add to map ( this . request attribute , name , value ) ; return this ; }
public web test client . response spec content type compatible with ( medium type medium type ) { medium type actual = get header ( ) . get content type ( ) ; string message = get message ( `` content- type `` ) + `` = [ `` + actual + `` ] be not compatible with [ `` + medium type + `` ] `` ; this . exchange result . assert with diagnostics ( ( ) - > assertion error . assert true ( message , ( actual ! = null & & actual . be compatible with ( medium type ) ) ) ) ; return this . response spec ; }
public request matcher content type compatible with ( string content type ) { return content type compatible with ( medium type . parse medium type ( content type ) ) ; }
public result matcher value ( string name , string expect value ) { return result - > { cookie cookie = get cookie ( result , name ) ; assert equal ( `` response cookie `` , expect value , cookie . get value ( ) ) ; } ; }
public void add cookie ( http servlet response response , string cookie value ) { assert . not null ( response , `` http servlet response must not be null `` ) ; cookie cookie = create cookie ( cookie value ) ; integer max age = get cookie max age ( ) ; if ( max age ! = null ) { cookie . set max age ( max age ) ; } if ( be cookie secure ( ) ) { cookie . set secure ( true ) ; } if ( be cookie http only ( ) ) { cookie . set http only ( true ) ; } response . add cookie ( cookie ) ; if ( logger . be trace enable ( ) ) { logger . trace ( `` add cookie [ `` + get cookie name ( ) + `` = `` + cookie value + `` ] `` ) ; } }
public result matcher exists ( string name ) { return result - > assert true ( `` response should contain header ' `` + name + `` ' `` , result . get response ( ) . contains header ( name ) ) ; }
public web test client . response spec value equal date ( string header name , long value ) { this . exchange result . assert with diagnostics ( ( ) - > { string header value = get header ( ) . get first ( header name ) ; assert not null ( `` response do not contain header ' `` + header name + `` ' `` , header value ) ; http header header = new http header ( ) ; header . set date ( `` expect `` , value ) ; header . set ( `` actual `` , header value ) ; assert equal ( `` response header ' `` + header name + `` '= ' `` + header value + `` ' `` + `` do not match expect value ' `` + header . get first ( `` expect `` ) + `` ' `` , header . get first date ( `` expect `` ) , header . get first date ( `` actual `` ) ) ; } ) ; return this . response spec ; }
public result matcher be empty ( ) { return result - > this . json path helper . assert value be empty ( get content ( result ) ) ; }
public result matcher be array ( ) { return result - > this . json path helper . assert value be array ( get content ( result ) ) ; }
public static expect condition < boolean > url contains ( final string fraction ) { return new expect condition < boolean > ( ) { private string current url = `` `` ; @ override public boolean apply ( web driver driver ) { current url = driver . get current url ( ) ; return current url ! = null & & current url . contains ( fraction ) ; } @ override public string to string ( ) { return string . format ( `` url to contain \ `` % s\ `` . current url : \ `` % s\ `` `` , fraction , current url ) ; } } ; }
public static body builder method ( string method , string url template , object . . . var ) { uri url = uri component builder . from uri string ( url template ) . build and expand ( var ) . encode ( ) . to uri ( ) ; return new default body builder ( method , url ) ; }
public static body builder method ( string method , string url template , object . . . var ) { uri url = uri component builder . from uri string ( url template ) . build and expand ( var ) . encode ( ) . to uri ( ) ; return new default body builder ( method , url ) ; }
public result matcher content type ( string content type ) { return content type ( medium type . parse medium type ( content type ) ) ; }
public result matcher attribute have no error ( string . . . name ) { return mvc result - > { model and view mav = get model and view ( mvc result ) ; for ( string name : name ) { bind result result = get bind result ( mav , name ) ; assert false ( `` unexpected error for attribute ' `` + name + `` ' : `` + result . get all error ( ) , result . have error ( ) ) ; } } ; }
public void set message converter ( list < http message converter < ? > > message converter ) { this . sync template . set message converter ( message converter ) ; }
public void set conversion service ( conversion service conversion service ) { this . conversion service = conversion service ; }
public void set use register suffix pattern match ( boolean use register suffix pattern match ) { this . use register suffix pattern match = use register suffix pattern match ; this . use suffix pattern match = ( use register suffix pattern match || this . use suffix pattern match ) ; }
public void before test class ( ) throw exception { class < ? > test class = get test context ( ) . get test class ( ) ; if ( logger . be trace enable ( ) ) { logger . trace ( `` before test class ( ) : class [ `` + test class . get name ( ) + `` ] `` ) ; } get test context ( ) . update state ( null , null , null ) ; for ( test execution listener test execution listener : get test execution listener ( ) ) { try { test execution listener . before test class ( get test context ( ) ) ; } catch ( throwable ex ) { log exception ( ex , `` before test class `` , test execution listener , test class ) ; reflection utils . rethrow exception ( ex ) ; } } }
public web test client . response spec do not exist ( string name ) { response cookie cookie = this . exchange result . get response cooky ( ) . get first ( name ) ; if ( cookie ! = null ) { string message = get message ( name ) + `` exists with value= [ `` + cookie . get value ( ) + `` ] `` ; this . exchange result . assert with diagnostics ( ( ) - > assertion error . fail ( message ) ) ; } return this . response spec ; }
public web test client . response spec value equal date ( string header name , long value ) { this . exchange result . assert with diagnostics ( ( ) - > { string header value = get header ( ) . get first ( header name ) ; assert not null ( `` response do not contain header ' `` + header name + `` ' `` , header value ) ; http header header = new http header ( ) ; header . set date ( `` expect `` , value ) ; header . set ( `` actual `` , header value ) ; assert equal ( `` response header ' `` + header name + `` '= ' `` + header value + `` ' `` + `` do not match expect value ' `` + header . get first ( `` expect `` ) + `` ' `` , header . get first date ( `` expect `` ) , header . get first date ( `` actual `` ) ) ; } ) ; return this . response spec ; }
public static cache control no store ( ) { cache control cc = new cache control ( ) ; cc . no store = true ; return cc ; }
public package part create part ( package part name part name , string content type ) { return this . create part ( part name , content type , true ) ; }
public void set request factory ( client http request factory request factory ) { assert . not null ( request factory , `` client http request factory must not be null `` ) ; this . request factory = request factory ; }
public io . vertx . reactivex . core . http . http client request push handler ( handler < io . vertx . reactivex . core . http . http client request > handler ) { delegate . push handler ( new handler < io . vertx . core . http . http client request > ( ) { public void handle ( io . vertx . core . http . http client request event ) { handler . handle ( io . vertx . reactivex . core . http . http client request . new instance ( ( io . vertx . core . http . http client request ) event ) ) ; } } ) ; return this ; }
public list < org . springframework . http . client . async client http request interceptor > get interceptor ( ) { return this . interceptor ; }
public void set max in memory size ( int byte count ) { this . max in memory size = byte count ; this . xml event decoder . set max in memory size ( byte count ) ; }
public codec registry register ( type codec < ? > . . . codecs ) { for ( type codec < ? > codec : codecs ) register ( codec ) ; return this ; }
public web test client . response spec content disposition ( content disposition content disposition ) { return assert header ( `` content- disposition `` , content disposition , get header ( ) . get content disposition ( ) ) ; }
public void set part converter ( list < http message converter < ? > > part converter ) { assert . not empty ( part converter , `` 'part converter ' must not be empty `` ) ; this . part converter = part converter ; }
public void set use default credential ( boolean use default credential ) { this . use default credential = use default credential ; }
public jackson2 object mapper builder feature to disable ( object . . . feature to disable ) { for ( object feature : feature to disable ) { this . feature . put ( feature , boolean . false ) ; } return this ; }
public void set content length long ( long len ) { this . response . set content length long ( len ) ; }
public static list < medium type > create from ( string [ ] medium type ) { list < medium type > result = new array list < medium type > ( ) ; try { for ( string medium type : medium type ) { http header reader . read medium type ( result , medium type ) ; } } catch ( parse exception ex ) { throw new illegal argument exception ( ex ) ; } collection . sort ( result , partial_order_comparator ) ; return collection . unmodifiable list ( result ) ; }
public static body builder patch ( uri url ) { return method ( http method . patch , url ) ; }
public void set read timeout ( long read timeout ) { if ( read timeout > 0 ) { this . read timeout = read timeout ; } else { this . read timeout = -1 ; } }
protect object input stream create object input stream ( input stream be ) throw i o exception { return new codebase aware object input stream ( be , get bean class loader ( ) , be accept proxy class ( ) ) ; }
public void set url ( @ nullable string url ) { this . url = url ; }
protect void set bind type ( int binding type ) { if ( ( bind type > = type_soap ) & & ( bind type < = type_unknown ) ) { } this . bind type = bind type ; } // set binding type
public void update topology ( inet address endpoint ) { assert endpoint ! = null ; lock . write lock ( ) . lock ( ) ; try { logger . info ( `` update topology for { } `` , endpoint ) ; topology . update endpoint ( endpoint ) ; invalidate cache ring ( ) ; } finally { lock . write lock ( ) . unlock ( ) ; } }
public void set soap action uri ( @ nullable string soap action uri ) { this . soap action uri = soap action uri ; }
public weld add service ( service . . . service ) { for ( service service : service ) { for ( class < ? extend service > service interface : service . identify service interface ( service . get class ( ) , new hash set < > ( ) ) ) { additional service . put ( service interface , service ) ; } } return this ; }
protected class loader get bundle class loader ( ) { return ( this . bundle class loader ! = null ? this . bundle class loader : this . bean class loader ) ; }
protect object get port stub ( service service , @ nullable q name port q name ) { if ( this . port feature ! = null ) { return ( port q name ! = null ? service . get port ( port q name , get service interface ( ) , this . port feature ) : service . get port ( get service interface ( ) , this . port feature ) ) ; } else { return ( port q name ! = null ? service . get port ( port q name , get service interface ( ) ) : service . get port ( get service interface ( ) ) ) ; } }
public void set wsdl document url ( @ nullable url wsdl document url ) { this . wsdl document url = wsdl document url ; }
public servlet context get servlet context ( ) { return this . servlet context ; }
public method parameter get method parameter ( ) { return this . method parameter ; }
public static boolean get boolean parameter ( servlet request request , string name , boolean default val ) { if ( request . get parameter ( name ) == null ) { return default val ; } try { return get require boolean parameter ( request , name ) ; } catch ( servlet request bind exception ex ) { return default val ; } }
public void cleanup attribute ( web request request ) { for ( string attribute name : this . know attribute name ) { this . session attribute store . cleanup attribute ( request , attribute name ) ; } }
public string get field marker prefix ( ) { return this . field marker prefix ; }
public boolean be bind empty multipart file ( ) { return this . bind empty multipart file ; }
protect async task executor determine async executor ( method method ) { async task executor executor = this . executor . get ( method ) ; if ( executor == null ) { executor target executor ; string qualifier = get executor qualifier ( method ) ; if ( string utils . have length ( qualifier ) ) { target executor = find qualified executor ( this . bean factory , qualifier ) ; } else { target executor = this . default executor ; if ( target executor == null ) { synchronize ( this . executor ) { if ( this . default executor == null ) { this . default executor = get default executor ( this . bean factory ) ; } target executor = this . default executor ; } } } if ( target executor == null ) { return null ; } executor = ( target executor instanceof async listenable task executor ? ( async listenable task executor ) target executor : new task executor adapter ( target executor ) ) ; this . executor . put ( method , executor ) ; } return executor ; }
public static void reset request attribute ( ) { request attribute holder . remove ( ) ; inheritable request attribute holder . remove ( ) ; }
public servlet context get servlet context ( ) { return this . servlet context ; }
protect void load bean definition ( xml bean definition reader reader ) throw i o exception { string [ ] config location = get config location ( ) ; if ( config location ! = null ) { for ( string config location : config location ) { reader . load bean definition ( config location ) ; } } }
public servlet context get servlet context ( ) { return this . servlet context ; }
protect resource get resource by path ( string path ) { assert . state ( this . servlet context ! = null , `` no servlet context available `` ) ; return new servlet context resource ( this . servlet context , path ) ; }
protect boolean be include payload ( ) { return this . include payload ; }
public void set after message suffix ( string after message suffix ) { this . after message suffix = after message suffix ; }
protect final string exception message ( string msg ) { if ( msg == null ) { msg = `` `` ; } string builder buf = new string builder ( 128 + msg . length ( ) ) . append ( protocol ( ) ) . append ( `` , `` ) . append ( auth scheme ( ) ) . append ( `` , `` ) . append ( proxy address ) . append ( `` = > `` ) . append ( destination address ) ; if ( ! msg . be empty ( ) ) { buf . append ( `` , `` ) . append ( msg ) ; } return buf . to string ( ) ; }
public servlet context get servlet context ( ) { return this . servlet context ; }
protect void init bean wrapper ( bean wrapper bw ) { bw . set conversion service ( get conversion service ( ) ) ; register custom editor ( bw ) ; }
protected boolean should not filter error dispatch ( ) { return false ; }
public void set supported medium type ( list < medium type > support medium type ) { assert . not empty ( supported medium type , `` medium type list must not be empty `` ) ; this . medium type . clear ( ) ; this . medium type . add all ( support medium type ) ; }
protect navigation handler get delegate ( face context face context ) { string target bean name = get target bean name ( face context ) ; return get bean factory ( face context ) . get bean ( target bean name , navigation handler . class ) ; }
protect final face context get face context ( ) { return this . face context ; }
public class < ? > get bean type ( ) { return this . bean . get type ( ) ; }
public method get handler method ( ) { return this . handler method ; }
public void set redirect model scenario ( boolean redirect model scenario ) { this . redirect model scenario = redirect model scenario ; }
public void set view ( @ nullable view view ) { this . view = view ; }
public void set ignore default model on redirect ( boolean ignore default model on redirect ) { this . ignore default model on redirect = ignore default model on redirect ; }
public http status get status code ( ) { if ( this . status instanceof http status ) { return ( http status ) this . status ; } else { return http status . value of ( ( integer ) this . status ) ; } }
public boolean be bind disabled ( string name ) { return ( this . binding disabled . contains ( name ) || this . no binding . contains ( name ) ) ; }
public void set request handle ( boolean request handle ) { this . request handle = request handle ; }
protect string get default encode ( ) { string encode = get file upload ( ) . get header encoding ( ) ; if ( encode == null ) { encode = web utils . default_character_encoding ; } return encode ; }
public request body build ( ) { if ( part header . be empty ( ) ) { throw new illegal state exception ( `` multipart body must have at least one part . `` ) ; } return new multipart request body ( type , boundary , part header , part body ) ; }
protect string get multipart resolver bean name ( ) { return this . multipart resolver bean name ; }
public void refresh ( ) { web application context wac = get web application context ( ) ; if ( ! ( wac instanceof configurable application context ) ) { throw new illegal state exception ( `` web application context do not support refresh : `` + wac ) ; } ( ( configurable application context ) wac ) . refresh ( ) ; }
public list < string > check header ( @ nullable list < string > request header ) { if ( request header == null ) { return null ; } if ( request header . be empty ( ) ) { return collection . empty list ( ) ; } if ( object utils . be empty ( this . allow header ) ) { return null ; } boolean allow any header = this . allow header . contains ( all ) ; list < string > result = new array list < > ( request header . size ( ) ) ; for ( string request header : request header ) { if ( string utils . have text ( request header ) ) { request header = request header . trim ( ) ; if ( allow any header ) { result . add ( request header ) ; } else { for ( string allow header : this . allow header ) { if ( request header . equal ignore case ( allow header ) ) { result . add ( request header ) ; break ; } } } } } return ( result . be empty ( ) ? null : result ) ; }
protect int determine raw status code ( throwable ex ) { if ( ex instanceof response status exception ) { return ( ( response status exception ) ex ) . get raw status code ( ) ; } return -1 ; }
public list < locale > get support locale ( ) { return this . supported locale ; }
public void set max session ( int max session ) { this . max session = max session ; ( ( l r u map ) session ) . set maximum size ( max session ) ; }
public void add cookie ( http servlet response response , string cookie value ) { assert . not null ( response , `` http servlet response must not be null `` ) ; cookie cookie = create cookie ( cookie value ) ; integer max age = get cookie max age ( ) ; if ( max age ! = null ) { cookie . set max age ( max age ) ; } if ( be cookie secure ( ) ) { cookie . set secure ( true ) ; } if ( be cookie http only ( ) ) { cookie . set http only ( true ) ; } response . add cookie ( cookie ) ; if ( logger . be trace enable ( ) ) { logger . trace ( `` add cookie [ `` + get cookie name ( ) + `` = `` + cookie value + `` ] `` ) ; } }
public void set enum case sensitive ( boolean enum case sensitive ) { this . enum case sensitive = enum case sensitive ; }
public static uri component builder from uri string ( string uri ) { assert . not null ( uri , `` uri must not be null `` ) ; matcher matcher = uri_pattern . matcher ( uri ) ; if ( matcher . match ( ) ) { uri component builder builder = new uri component builder ( ) ; string scheme = matcher . group ( 2 ) ; string user info = matcher . group ( 5 ) ; string host = matcher . group ( 6 ) ; string port = matcher . group ( 8 ) ; string path = matcher . group ( 9 ) ; string query = matcher . group ( 11 ) ; string fragment = matcher . group ( 13 ) ; boolean opaque = false ; if ( string utils . have length ( scheme ) ) { string rest = uri . substring ( scheme . length ( ) ) ; if ( ! rest . start with ( `` : / `` ) ) { opaque = true ; } } builder . scheme ( scheme ) ; if ( opaque ) { string ssp = uri . substring ( scheme . length ( ) ) . substring ( 1 ) ; if ( string utils . have length ( fragment ) ) { ssp = ssp . substring ( 0 , ssp . length ( ) - ( fragment . length ( ) + 1 ) ) ; } builder . scheme specific part ( ssp ) ; } else { builder . user info ( user info ) ; builder . host ( host ) ; if ( string utils . have length ( port ) ) { builder . port ( port ) ; } builder . path ( path ) ; builder . query ( query ) ; } if ( string utils . have text ( fragment ) ) { builder . fragment ( fragment ) ; } return builder ; } else { throw new illegal argument exception ( `` [ `` + uri + `` ] be not a valid uri `` ) ; } }
public uri expand ( object . . . uri variable value ) { uri component expand component = this . uri component . expand ( uri variable value ) ; uri component encode component = expanded component . encode ( ) ; return encode component . to uri ( ) ; }
public expression builder variable ( set < string > variable name ) { this . variable name . add all ( variable name ) ; return this ; }
public boolean support parameter ( method parameter parameter ) { if ( parameter . have parameter annotation ( request param . class ) ) { if ( map . class . be assignable from ( parameter . nest if optional ( ) . get nested parameter type ( ) ) ) { request param request param = parameter . get parameter annotation ( request param . class ) ; return ( request param ! = null & & string utils . have text ( request param . name ( ) ) ) ; } else { return true ; } } else { if ( parameter . have parameter annotation ( request part . class ) ) { return false ; } parameter = parameter . nest if optional ( ) ; if ( multipart resolution delegate . be multipart argument ( parameter ) ) { return true ; } else if ( this . use default resolution ) { return bean utils . be simple property ( parameter . get nested parameter type ( ) ) ; } else { return false ; } } }
public static int position of ( byte buffer buf , byte value ) { if ( buf . have array ( ) ) { final byte [ ] array = buf . array ( ) ; final int offset = buf . array offset ( ) ; final int limit = buf . limit ( ) ; for ( int po = buf . position ( ) ; po < limit ; ++pos ) { if ( array [ offset + po ] == value ) { return po ; } } } else { final int limit = buf . limit ( ) ; for ( int po = buf . position ( ) ; po < limit ; ++pos ) { if ( buf . get ( po ) == value ) { return po ; } } } return -1 ; }
public str builder reverse ( ) { if ( size == 0 ) { return this ; } int half = size / 2 ; char [ ] buf = buffer ; for ( int leave idx = 0 , right idx = size - 1 ; leave idx < half ; leave idx++ , right idx -- ) { char swap = buf [ leave idx ] ; buf [ leave idx ] = buf [ right idx ] ; buf [ right idx ] = swap ; } return this ; }
protect void init object writer ( ) { this . object writer . clear ( ) ; if ( ! this . register default ) { return ; } this . object writer . add all ( get base object writer ( ) ) ; extend object writer ( this . object writer ) ; }
protect medium type get medium type ( http servlet request request , resource resource ) { medium type result = null ; string mime type = request . get servlet context ( ) . get mime type ( resource . get filename ( ) ) ; if ( string utils . have text ( mime type ) ) { result = medium type . parse medium type ( mime type ) ; } if ( result == null || medium type . application_octet_stream . equal ( result ) ) { medium type medium type = null ; string filename = resource . get filename ( ) ; string ext = string utils . get filename extension ( filename ) ; if ( ext ! = null ) { medium type = this . medium type . get ( ext . to lower case ( locale . english ) ) ; } if ( medium type == null ) { medium type = medium type factory . get medium type ( filename ) . or else ( null ) ; } if ( medium type ! = null ) { result = medium type ; } } return result ; }
public static header builder < ? > head ( string uri template , object . . . uri variable ) { return method ( http method . head , uri template , uri variable ) ; }
public static header builder < ? > option ( string uri template , object . . . uri variable ) { return method ( http method . option , uri template , uri variable ) ; }
protect void bind request parameter ( web data binder binder , native web request request ) { ( ( web request data binder ) binder ) . bind ( request ) ; }
public static resource pattern resolver get resource pattern resolver ( resource loader resource loader ) { assert . not null ( resource loader , `` resource loader must not be null `` ) ; if ( resource loader instanceof resource pattern resolver ) { return ( resource pattern resolver ) resource loader ; } else if ( resource loader ! = null ) { return new path match resource pattern resolver ( resource loader ) ; } else { return new path match resource pattern resolver ( ) ; } }
public void set default view ( @ nullable list < view > default view ) { this . default view . clear ( ) ; if ( default view ! = null ) { this . default view . add all ( default view ) ; } }
protect void configure path match ( path match configurer configurer ) { }
protect void add view controller ( view controller registry registry ) { }
public void set order ( int order ) { this . order = order ; }
public void set lazy init ( boolean lazy init ) { this . lazy init = lazy init ; }
public set < medium type > get consumable medium type ( ) { set < medium type > result = new link hash set < > ( ) ; for ( consume medium type expression expression : this . expression ) { if ( ! expression . be negated ( ) ) { result . add ( expression . get medium type ( ) ) ; } } return result ; }
public set < medium type > get consumable medium type ( ) { set < medium type > result = new link hash set < > ( ) ; for ( consume medium type expression expression : this . expression ) { if ( ! expression . be negated ( ) ) { result . add ( expression . get medium type ( ) ) ; } } return result ; }
public list < string > get matching pattern ( string lookup path ) { list < string > match = null ; for ( string pattern : this . pattern ) { string match = get matching pattern ( pattern , lookup path ) ; if ( match ! = null ) { match = ( match ! = null ? match : new array list < > ( ) ) ; match . add ( match ) ; } } if ( match == null ) { return collection . empty list ( ) ; } if ( match . size ( ) > 1 ) { match . sort ( this . path matcher . get pattern comparator ( lookup path ) ) ; } return match ; }
public void set reactive adapter registry ( reactive adapter registry reactive adapter registry ) { this . reactive adapter registry = reactive adapter registry ; }
public string get error message ( ) { string [ ] error message = init error message ( ) ; return ( error message . length > 0 ? error message [ 0 ] : `` `` ) ; }
public static string [ ] delimit list to string array ( string str , string delimiter ) { return delimit list to string array ( str , delimiter , null ) ; }
public error get error ( string name , boolean html escape ) { if ( this . error map == null ) { this . error map = new hash map < > ( ) ; } error error = this . error map . get ( name ) ; if ( error == null ) { error = get model object ( bind result . model_key_prefix + name ) ; if ( error == null ) { return null ; } } if ( error instanceof bind exception ) { error = ( ( bind exception ) error ) . get binding result ( ) ; } if ( html escape & & ! ( error instanceof escaped error ) ) { error = new escaped error ( error ) ; } else if ( ! html escape & & error instanceof escaped error ) { error = ( ( escape error ) error ) . get source ( ) ; } this . error map . put ( name , error ) ; return error ; }
public void set configuration ( file configuration configuration ) { this . configuration = configuration ; }
protect url resolve template ( class loader class loader , string template path ) throw i o exception { markup template engine . template resource resource = markup template engine . template resource . parse ( template path ) ; locale locale = locale context holder . get locale ( ) ; url url = class loader . get resource ( resource . with locale ( string utils . replace ( locale . to string ( ) , `` - `` , `` _ `` ) ) . to string ( ) ) ; if ( url == null ) { url = class loader . get resource ( resource . with locale ( locale . get language ( ) ) . to string ( ) ) ; } if ( url == null ) { url = class loader . get resource ( resource . with locale ( null ) . to string ( ) ) ; } if ( url == null ) { throw new i o exception ( `` unable to load template : `` + template path ) ; } return url ; }
public boolean be propagate query property ( ) { return this . propagate query params ; }
public static string get relative path ( url context , url target ) { try { return u r l holder . get relative uri ( context . to u r i ( ) , target . to u r i ( ) ) ; } catch ( u r i syntax exception e ) { throw new gate runtime exception ( `` unable to construct relative path between `` + context + `` and `` + target ) ; } }
public error get error ( string name , boolean html escape ) { if ( this . error map == null ) { this . error map = new hash map < > ( ) ; } error error = this . error map . get ( name ) ; if ( error == null ) { error = get model object ( bind result . model_key_prefix + name ) ; if ( error == null ) { return null ; } } if ( error instanceof bind exception ) { error = ( ( bind exception ) error ) . get binding result ( ) ; } if ( html escape & & ! ( error instanceof escaped error ) ) { error = new escaped error ( error ) ; } else if ( ! html escape & & error instanceof escaped error ) { error = ( ( escape error ) error ) . get source ( ) ; } this . error map . put ( name , error ) ; return error ; }
public bind status get bind status ( string path ) throw illegal state exception { return new bind status ( this , path , be default html escape ( ) ) ; }
public void set order ( int order ) { this . order = order ; }
public instrument < channel stats > get channel ( long id ) { return root channel . get ( id ) ; }
public void add allow origin ( string origin ) { if ( this . allow origin == null ) { this . allow origin = new array list < > ( 4 ) ; } else if ( this . allow origin == default_permit_all ) { set allow origin ( default_permit_all ) ; } this . allow origin . add ( origin ) ; }
public void set default servlet name ( string default servlet name ) { this . default servlet name = default servlet name ; }
public path matcher get path matcher ( ) { return this . path matcher ; }
public hb order ( order score order ) { this . order = score order ; return ( hb ) this ; }
public void set cache store scan period ( int cache store scan period ) { this . cache store scan period = cache store scan period ; }
public void add status controller ( string url path , http status status code ) { view controller registration registration = new view controller registration ( url path ) ; registration . set application context ( this . application context ) ; registration . set status code ( status code ) ; registration . get view controller ( ) . set status only ( true ) ; this . registration . add ( registration ) ; }
protect handler execution chain get handler ( http servlet request request ) throw exception { if ( this . handler mapping ! = null ) { for ( handler map mapping : this . handler mapping ) { handler execution chain handler = mapping . get handler ( request ) ; if ( handler ! = null ) { return handler ; } } } return null ; }
public static void init ( ) { copy on write sort array thread context map . init ( ) ; garbage free sort array thread context map . init ( ) ; default thread context map . init ( ) ; init private ( ) ; }
protect < t > list < t > get default strategy ( application context context , class < t > strategy interface ) { string key = strategy interface . get name ( ) ; string value = default strategy . get property ( key ) ; if ( value ! = null ) { string [ ] class name = string utils . comma delimit list to string array ( value ) ; list < t > strategy = new array list < > ( class names . length ) ; for ( string class name : class name ) { try { class < ? > clazz = class utils . for name ( class name , dispatcher servlet . class . get class loader ( ) ) ; object strategy = create default strategy ( context , clazz ) ; strategy . add ( ( t ) strategy ) ; } catch ( class not find exception ex ) { throw new bean initialization exception ( `` could not find dispatcher servlet 's default strategy class [ `` + class name + `` ] for interface [ `` + key + `` ] `` , ex ) ; } catch ( linkage error err ) { throw new bean initialization exception ( `` unresolvable class definition for dispatcher servlet 's default strategy class [ `` + class name + `` ] for interface [ `` + key + `` ] `` , err ) ; } } return strategy ; } else { return new link list < > ( ) ; } }
protect boolean require logout ( http servlet request request , http servlet response response ) { if ( this . logout request matcher . match ( request ) ) { return true ; } if ( this . logger . be trace enable ( ) ) { this . logger . trace ( log message . format ( `` do not match request to % s `` , this . logout request matcher ) ) ; } return false ; }
protect boolean be flash map for request ( flash map flash map , http servlet request request ) { string expect path = flash map . get target request path ( ) ; if ( expect path ! = null ) { string request uri = get url path helper ( ) . get originate request uri ( request ) ; if ( ! request uri . equal ( expect path ) & & ! request uri . equal ( expect path + `` / `` ) ) { return false ; } } multi value map < string , string > actual params = get originate request params ( request ) ; multi value map < string , string > expect params = flash map . get target request params ( ) ; for ( map . entry < string , list < string > > entry : expect params . entry set ( ) ) { list < string > actual value = actual params . get ( entry . get key ( ) ) ; if ( actual value == null ) { return false ; } for ( string expect value : entry . get value ( ) ) { if ( ! actual value . contains ( expect value ) ) { return false ; } } } return true ; }
public string get context config location ( ) { return this . context config location ; }
public void publish event ( application event event ) { publish event ( event , null ) ; }
public void refresh ( ) { web application context wac = get web application context ( ) ; if ( ! ( wac instanceof configurable application context ) ) { throw new illegal state exception ( `` web application context do not support refresh : `` + wac ) ; } ( ( configurable application context ) wac ) . refresh ( ) ; }
protect string get no such message exception description ( no such message exception ex ) { return `` theme ' `` + get request context ( ) . get theme ( ) . get name ( ) + `` ' : `` + ex . get message ( ) ; }
protect void prepare response ( exception ex , http servlet response response ) { if ( this . prevent response cache ) { prevent cache ( response ) ; } }
public void set default handler ( @ nullable object default handler ) { this . default handler = default handler ; }
protect void register handler method ( object handler , method method , t map ) { this . mapping registry . register ( mapping , handler , method ) ; }
public exception attribute get exception attribute ( ) { attribute info info = attribute info . lookup ( attribute , exception attribute . tag ) ; return ( exception attribute ) info ; }
protect string find matching view name ( property exception mapping , exception ex ) { string view name = null ; string dominant mapping = null ; int deep = integer . max_value ; for ( enumeration < ? > name = exception mapping . property name ( ) ; name . have more element ( ) ; ) { string exception mapping = ( string ) name . next element ( ) ; int depth = get depth ( exception mapping , ex ) ; if ( depth > = 0 & & ( depth < deep || ( depth == deepest & & dominant mapping ! = null & & exception mapping . length ( ) > dominant mapping . length ( ) ) ) ) { deep = depth ; dominant mapping = exception mapping ; view name = exception mapping . get property ( exception mapping ) ; } } if ( view name ! = null & & logger . be debug enable ( ) ) { logger . debug ( `` resolve to view ' `` + view name + `` ' base on map [ `` + dominant mapping + `` ] `` ) ; } return view name ; }
public redirect view controller registration set status code ( http status status code ) { assert . be true ( status code . is3xx redirection ( ) , `` not a redirect status code `` ) ; this . redirect view . set status code ( status code ) ; return this ; }
protect model and view get model and view ( string view name , exception ex ) { model and view mv = new model and view ( view name ) ; if ( this . exception attribute ! = null ) { mv . add object ( this . exception attribute , ex ) ; } return mv ; }
public void set reject invalid cooky ( boolean reject invalid cooky ) { this . reject invalid cooky = reject invalid cooky ; }
public void set default locale ( locale locale ) { if ( locale == null ) { default locale = locale . get default ( ) ; } else { default locale = locale ; } }
protected time zone get default time zone ( ) { return this . default time zone ; }
public void set status code ( @ nullable http status status code ) { this . status code = status code ; }
public boolean be empty ( ) { return table and view . be empty ( ) & & synonym . be empty ( ) & & index . be empty ( ) & & sequence . be empty ( ) & & trigger . be empty ( ) & & constraint . be empty ( ) & & constant . be empty ( ) & & function . be empty ( ) ; }
public static string get name for parameter ( method parameter parameter ) { model attribute ann = parameter . get parameter annotation ( model attribute . class ) ; string name = ( ann ! = null ? ann . value ( ) : null ) ; return ( string utils . have text ( name ) ? name : convention . get variable name for parameter ( parameter ) ) ; }
public void set view name ( @ nullable string . . . view names ) { this . view name = view name ; }
public void set view ( view base view ) { this . view = view ; }
public void after property set ( ) throw exception { if ( this . servlet class == null ) { throw new illegal argument exception ( `` 'servlet class ' be require `` ) ; } if ( this . servlet name == null ) { this . servlet name = this . bean name ; } this . servlet instance = reflection utils . accessible constructor ( this . servlet class ) . new instance ( ) ; this . servlet instance . init ( new delegate servlet config ( ) ) ; }
protect int get priority ( servlet request request ) { http servlet request base request = ( http servlet request ) request ; if ( base request . get user principal ( ) ! = null ) { return 2 ; } else { http session session = base request . get session ( false ) ; if ( session ! = null & & ! session . be new ( ) ) return 1 ; else return 0 ; } }
protect locale get fallback locale ( ) { if ( jstl present ) { locale locale = jstl page locale resolver . get jstl locale ( get page context ( ) ) ; if ( locale ! = null ) { return locale ; } } return get request ( ) . get locale ( ) ; }
public static theme resolver get theme resolver ( http servlet request request ) { return ( theme resolver ) request . get attribute ( dispatcher servlet . theme_resolver_attribute ) ; }
public void change theme ( @ nullable theme theme ) { theme resolver theme resolver = request context utils . get theme resolver ( this . request ) ; if ( theme resolver == null ) { throw new illegal state exception ( `` can not change theme if no theme resolver configure `` ) ; } theme resolver . set theme name ( this . request , this . response , ( theme ! = null ? theme . get name ( ) : null ) ) ; this . theme = theme ; }
public static servlet uri component builder from request uri ( http servlet request request ) { servlet uri component builder builder = init from request ( request ) ; builder . init path ( request . get request u r i ( ) ) ; return builder ; }
public void set cache second ( int cache second ) { this . cache millis = ( cache second * 1000 ) ; }
public void set name ( string name ) { if ( this . can set field value ( this . name , name ) ) { this . name = name ; this . change ( ) ; } }
public boolean be ignore nested path ( ) { return this . ignore nested path ; }
protect void write body content ( string content ) throw i o exception { assert . state ( this . body content ! = null , `` no body content set `` ) ; this . body content . get enclosing writer ( ) . print ( content ) ; }
protect void write body content ( string content ) throw i o exception { assert . state ( this . body content ! = null , `` no body content set `` ) ; this . body content . get enclosing writer ( ) . print ( content ) ; }
public nest property builder ignore element ( string element name ) { if ( element name == null ) { report error ( `` set nested property ( ) . ignore element ( string ) `` , `` empty 'element name ' not allow `` ) ; } return add alias ( element name ) . for property ( null ) ; }
public schema export set delimiter ( string delimiter ) { this . delimiter = delimiter ; return this ; }
protect string resolve cs class ( ) throw jsp exception { if ( get bind status ( ) . be error ( ) & & string utils . have text ( get css error class ( ) ) ) { return object utils . get display string ( evaluate ( `` css error class `` , get css error class ( ) ) ) ; } else { return object utils . get display string ( evaluate ( `` css class `` , get css class ( ) ) ) ; } }
public void set line separator ( string line separator ) { if ( line separator == null || line separator . be empty ( ) ) { throw new illegal argument exception ( `` line separator can not be empty `` ) ; } set line separator ( line separator . to char array ( ) ) ; }
public static boolean match property ( string register path , string property path ) { if ( ! register path . start with ( property path ) ) { return false ; } if ( registered path . length ( ) == property path . length ( ) ) { return true ; } if ( registered path . char at ( property path . length ( ) ) ! = property accessor . property_key_prefix_char ) { return false ; } return ( registered path . index of ( property accessor . property_key_suffix_char , property path . length ( ) + 1 ) == register path . length ( ) - 1 ) ; }
public void set ( @ nullable v value ) { value tx . set ( value ) ; }
public cache filter get cache filter ( ) { return this . cache filter ; }
protect object get cache key ( string view name , locale locale ) { return view name ; }
public void register macro ( macro macro ) { macro . put ( macro . name ( ) , macro ) ; }
public string get request context attribute ( ) { return this . request context attribute ; }
public void set validation property ( property jpa property ) { collection utils . merge property into map ( jpa property , this . validation property map ) ; }
public void set strip lead slash ( boolean strip lead slash ) { this . strip lead slash = strip lead slash ; }
protect string determine encoding ( http servlet request request ) { string encode = request . get character encoding ( ) ; if ( encode == null ) { encode = get default encode ( ) ; } return encode ; }
protect template get template ( locale locale ) throw i o exception { return ( get encode ( ) ! = null ? obtain configuration ( ) . get template ( get url ( ) , locale , get encode ( ) ) : obtain configuration ( ) . get template ( get url ( ) , locale ) ) ; }
public void set locale ( locale locale ) { if ( locale == null ) { locale = locale . get default ( ) ; } f locale = locale ; } // set locale ( locale )
public void set prepare always ( boolean prepare always ) { this . prepare always = prepare always ; }
public void set prevent response caching ( boolean prevent response cache ) { this . prevent response cache = prevent response caching ; }
public static void expose localization context ( http servlet request request , @ nullable message source message source ) { locale jstl locale = request context utils . get locale ( request ) ; config . set ( request , config . fmt_locale , jstl locale ) ; time zone time zone = request context utils . get time zone ( request ) ; if ( time zone ! = null ) { config . set ( request , config . fmt_time_zone , time zone ) ; } if ( message source ! = null ) { localization context jstl context = new spring localization context ( message source , request ) ; config . set ( request , config . fmt_localization_context , jstl context ) ; } }
public void clear cache ( ) { logger . debug ( `` clear entire resource bundle cache `` ) ; this . cached property . clear ( ) ; this . cache merged property . clear ( ) ; }
public void set expose path variable ( boolean expose path variable ) { this . expose path variable = expose path variable ; }
public void set view resolvers ( list < view resolver > view resolvers ) { this . view resolvers = view resolvers ; }
public void set view resolvers ( list < view resolver > view resolvers ) { this . view resolvers = view resolvers ; }
public void set resource location ( string resource location ) { this . user detail . set resource location ( resource location ) ; }
public void destroy ( ) { synchronize ( this . internal bean factory ) { for ( default listable bean factory bf : this . internal bean factory . value ( ) ) { bf . destroy singleton ( ) ; } } }
protect synchronized final int value_bytes ( int arg ) throw s q l exception { check value ( arg ) ; return db . value_bytes ( this , arg ) ; }
protect void dynamic error ( string message , string code , x path context context ) throw x path exception { x path exception err = new x path exception ( message , this ) ; err . set x path context ( context ) ; err . set error code ( code ) ; throw err ; }
public property to property ( ) { pragma table . set property ( pragma . open_mode . pragma name , integer . to string ( open mode flag ) ) ; return pragma table ; }
public static boolean a boolean ( character character ) { if ( null == character ) { return false ; } return character ! = 0 ; }
public void remove ( ) { expand ( ) ; super . remove ( ) ; }
public int array decoder get int array decoder ( ) { return new int array decoder ( get int decoder ( ) ) ; }
public lexical handler get lexical handler ( ) { return lexical handler ; }
public void set next ( element next ) { the next = next ; }
public static xml namespace get namespace from uri ( string namespace uri ) { if ( ews error namespace . equal ( namespace uri ) ) { return xml namespace . error ; } else if ( ew type namespace . equal ( namespace uri ) ) { return xml namespace . type ; } else if ( ews message namespace . equal ( namespace uri ) ) { return xml namespace . message ; } else if ( ew soap namespace . equal ( namespace uri ) ) { return xml namespace . soap ; } else if ( ew soap12 namespace . equal ( namespace uri ) ) { return xml namespace . soap12 ; } else if ( ew xml schema instance namespace . equal ( namespace uri ) ) { return xml namespace . xml schema instance ; } else if ( passport soap fault namespace . equal ( namespace uri ) ) { return xml namespace . passport soap fault ; } else if ( w s trust february2005 namespace . equal ( namespace uri ) ) { return xml namespace . w s trust february2005 ; } else if ( w s address namespace . equal ( namespace uri ) ) { return xml namespace . w s addressing ; } else { return xml namespace . not specify ; } }
public int member of ( ) { return the member of ; }
public namespace add namespace ( string prefix , string uri ) { namespace namespace = create namespace ( prefix , uri ) ; push ( namespace ) ; return namespace ; }
public int member of ( ) { return the member of ; }
public element type parent ( ) { return the parent ; }
public string get value ( string entity name ) { not null ( entity name , `` entity name `` ) ; final t entity = get ( entity name ) ; if ( entity == null ) { return null ; } return entity . get value ( ) ; }
public bind provider task get bind provider task ( ) { return ( bind provider task == null ) ? null : ( bind provider task ) bind provider task . get task ( ) ; }
public boolean should build ( ) { if ( have build change ) { if ( operation cancel ) return policy . build on cancel ; return true ; } return false ; }
public http wait strategy for status code matching ( predicate < integer > status code predicate ) { this . status code predicate = status code predicate ; return this ; }
public rate limiter builder with constant throughput ( ) { this . strategy = rate limiter strategy . constant_throughput ; return this ; }
public static host port wait strategy for listen port ( ) { return new host port wait strategy ( ) ; }
public static http wait strategy for http ( string path ) { return new http wait strategy ( ) . for path ( path ) ; }
public static duration style detect ( string value ) { assert . not null ( value , `` value must not be null `` ) ; for ( duration style candidate : value ( ) ) { if ( candidate . match ( value ) ) { return candidate ; } } throw new illegal argument exception ( `` ' `` + value + `` ' be not a valid duration `` ) ; }
public synchronize static docker client factory instance ( ) { if ( instance == null ) { instance = new docker client factory ( ) ; } return instance ; }
protect encode detector get encode detector ( parse context parse context ) { encode detector from parse context = parse context . get ( encode detector . class ) ; if ( from parse context ! = null ) { return from parse context ; } return get encode detector ( ) ; }
public void set max upload size per file ( long max upload size per file ) { this . file upload . set file size max ( max upload size per file ) ; }
public static int get u short l e ( byte [ ] data ) { return get u short l e ( data , 0 ) ; }
public reader parse ( path path , metadata metadata ) throw i o exception { input stream stream = tika input stream . get ( path , metadata ) ; return parse ( stream , metadata ) ; }
public file input stream get file input stream ( final file file ) throw file not find exception { if ( system . get security manager ( ) == null ) return new file input stream ( file ) ; try { return access controller . do privilege ( new privilege exception action < file input stream > ( ) { @ override public file input stream run ( ) throw file not find exception { return new file input stream ( file ) ; } } , control context ) ; } catch ( privileged action exception e ) { if ( e . get exception ( ) instanceof file not find exception ) throw ( file not find exception ) e . get exception ( ) ; throw ( runtime exception ) e . get exception ( ) ; } }
public long position ( ) { return global position ; }
public language identifier get language ( ) { return writer . get language ( ) ; }
public void set language ( string language ) { language l = language . value of ( language . to upper case ( ) ) ; if ( l==null ) { language [ ] language = language . value ( ) ; string [ ] candidate = new string [ language . length ] ; for ( int i=0 ; i < candidate . length ; i++ ) candidate [ i ] = language [ i ] . name ( ) ; throw new build exception ( `` unrecognized language : `` +language+ `` . do you mean `` + edit distance . find near ( language . to upper case ( ) , candidate ) + `` ? `` ) ; } option . set schema language ( l ) ; }
public void do configure ( input stream input stream , logger repository hierarchy ) { property prop = new property ( ) ; try { prop . load ( input stream ) ; } catch ( i o exception e ) { if ( e instanceof interrupt i o exception ) { thread . current thread ( ) . interrupt ( ) ; } log log . error ( `` could not read configuration file from input stream [ `` + input stream + `` ] . `` , e ) ; log log . error ( `` ignore configuration input stream [ `` + input stream + `` ] . `` ) ; return ; } this . do configure ( prop , hierarchy ) ; }
public void set default profile ( string . . . profile ) { assert . not null ( profile , `` profile array must not be null `` ) ; synchronize ( this . default profile ) { this . default profile . clear ( ) ; for ( string profile : profile ) { validate profile ( profile ) ; this . default profile . add ( profile ) ; } } }
public integer get int ( property property ) { if ( property . get primary property ( ) . get property type ( ) ! = property . property type . simple ) { return null ; } if ( property . get primary property ( ) . get value type ( ) ! = property . value type . integer ) { return null ; } string v = get ( property ) ; if ( v == null ) { return null ; } try { return integer . value of ( v ) ; } catch ( number format exception e ) { return null ; } }
public static byte [ ] decode ( char [ ] hex char , int start index , int length ) { if ( ( length & 1 ) ! = 0 ) throw new illegal argument exception ( `` length must be even `` ) ; byte [ ] result = new byte [ length / 2 ] ; for ( int j = 0 ; j < result . length ; j++ ) { result [ j ] = ( byte ) ( hex char to nibble ( hex char [ start index++ ] ) * 16 + hex char to nibble ( hex char [ start index++ ] ) ) ; } return result ; }
public boolean have parameter ( ) { return ( parameter ! = null ) & & ! parameter . be empty ( ) ; }
public sort set < medium type > get child type ( medium type type ) { sort set < medium type > child = new tree set < medium type > ( ) ; for ( map . entry < medium type , medium type > entry : inheritance . entry set ( ) ) { if ( entry . get value ( ) . equal ( type ) ) { child . add ( entry . get key ( ) ) ; } } return child ; }
public sort set < medium type > get child type ( medium type type ) { sort set < medium type > child = new tree set < medium type > ( ) ; for ( map . entry < medium type , medium type > entry : inheritance . entry set ( ) ) { if ( entry . get value ( ) . equal ( type ) ) { child . add ( entry . get key ( ) ) ; } } return child ; }
public void add pattern ( mime type type , string pattern , boolean be regex ) throw mime type exception { pattern . add ( pattern , be regex , type ) ; }
public boolean get ignore empty line ( ) { return ignore empty line ; }
public void set ignore invalid line ( boolean ignore invalid line ) { this . ignore invalid line = ignore invalid line ; }
public static x m l input factory new x m l input factory ( ) { x m l input factory factory = x m l input factory . new instance ( ) ; try set property ( factory , x m l input factory . is_namespace_aware , true ) ; try set property ( factory , x m l input factory . is_validating , false ) ; try set property ( factory , x m l input factory . support_dtd , false ) ; try set property ( factory , x m l input factory . is_supporting_external_entities , false ) ; return factory ; }
public list < metadata > get metadata ( ) { if ( last parse state ! = null ) { return ( ( recursive parser wrapper handler ) last parse state . recursive parser wrapper handler ) . get metadata list ( ) ; } else { throw new illegal state exception ( `` this be deprecate ; please use a recursive parser wrapper handler instead `` ) ; } }
public void set threshold ( float threshold ) { this . threshold = threshold ; }
public void set maximum package entry depth ( int depth ) { this . max package entry depth = depth ; }
public long get threshold ( ) { return threshold ; }
protect void fire character ( string text ) { if ( get exception ( ) == null ) { try { char [ ] ch = text . to char array ( ) ; get content handler ( ) . character ( ch , 0 , ch . length ) ; } catch ( s a x exception ex ) { exception = ex ; } } }
public void start document ( ) throw s a x exception { super . start document ( ) ; start prefix mapping ( `` rdf `` , rdf ) ; start prefix mapping ( `` xmp `` , xmp ) ; start element ( rdf , `` rdf `` , `` rdf : rdf `` , empty_attributes ) ; }
public boolean match ( string text ) { return match ( text , 0 , text . length ( ) ) ; }
public string detect ( url url ) throw i o exception { metadata metadata = new metadata ( ) ; try ( input stream stream = tika input stream . get ( url , metadata ) ) { return detect ( stream , metadata ) ; } }
public language detector get detector ( ) { return detector ; }
protect void set unknown_000c ( int unknown_000c ) { this . unknown_000c = unknown_000c ; }
public long get unknown len ( ) { return unknown_len ; }
protect void set dir len ( long dir_len ) { this . dir_len = dir_len ; }
protect void set data offset ( long data offset ) { this . data offset = data offset ; }
protect void set lang_id ( long lang_id ) { this . lang_id = lang_id ; }
public int get window size ( ) { return window size ; }
protect void set unknown_18 ( long unknown_18 ) { this . unknown_18 = unknown_18 ; }
public void add signature request ( signature request [ ] signature request ) { for ( int i = 0 ; i < signature request . length ; i++ ) { add signature request ( signature request [ i ] ) ; } }
public long get free space ( ) { return free_space ; }
public void set ae descriptor path ( string ae descriptor path ) { this . ae descriptor path = ae descriptor path ; }
public string get u m l s pas ( ) { return u m l s pas ; }
public void set text ( string text ) { if ( this . can set field value ( this . text , text ) ) { this . text = text ; this . change ( ) ; } }
protect boolean be discard element ( string name ) { return default html mapper . instance . be discard element ( name ) ; }
public void generate whole frame ( frame frame , byte buffer buf ) { buf . put ( generate header byte ( frame ) ) ; if ( frame . have payload ( ) ) { if ( read only ) { buf . put ( frame . get payload ( ) . slice ( ) ) ; } else { buf . put ( frame . get payload ( ) ) ; } } }
public < t > t get entity ( class < t > type ) throw class cast exception { if ( entity == null ) { t t = acr . get entity ( type ) ; entity = t ; return t ; } else { return type . cast ( entity ) ; } }
public void set language ( string language ) { language l = language . value of ( language . to upper case ( ) ) ; if ( l==null ) { language [ ] language = language . value ( ) ; string [ ] candidate = new string [ language . length ] ; for ( int i=0 ; i < candidate . length ; i++ ) candidate [ i ] = language [ i ] . name ( ) ; throw new build exception ( `` unrecognized language : `` +language+ `` . do you mean `` + edit distance . find near ( language . to upper case ( ) , candidate ) + `` ? `` ) ; } option . set schema language ( l ) ; }
public void write text ( p d document doc , writer output stream ) throw i o exception { reset engine ( ) ; document = doc ; output = output stream ; if ( get add more formatting ( ) ) { paragraph end = line separator ; page start = line separator ; article start = line separator ; article end = line separator ; } start document ( document ) ; process page ( document . get page ( ) ) ; end document ( document ) ; }
public void check permission ( cache pool pool , fs action access ) throw access control exception { fs permission mode = pool . get mode ( ) ; if ( be super user ( ) ) { return ; } if ( get user ( ) . equal ( pool . get owner name ( ) ) & & mode . get user action ( ) . implies ( access ) ) { return ; } if ( get group ( ) . contains ( pool . get group name ( ) ) & & mode . get group action ( ) . implies ( access ) ) { return ; } if ( mode . get other action ( ) . implies ( access ) ) { return ; } throw new access control exception ( `` permission deny while access pool `` + pool . get pool name ( ) + `` : user `` + get user ( ) + `` do not have `` + access . to string ( ) + `` permission . `` ) ; }
public void search ( univariate function func , goal type goal , double x a , double x b ) { evaluation . reset count ( ) ; final boolean be minim = goal == goal type . minimize ; double f a = eval ( func , x a ) ; double f b = eval ( func , x b ) ; if ( be minim ? f a < f b : f a > f b ) { double tmp = x a ; x a = x b ; x b = tmp ; tmp = f a ; f a = f b ; f b = tmp ; } double x c = x b + gold * ( x b - x a ) ; double f c = eval ( func , x c ) ; while ( be minim ? f c < f b : f c > f b ) { double tmp1 = ( x b - x a ) * ( f b - f c ) ; double tmp2 = ( x b - x c ) * ( f b - f a ) ; double val = tmp2 - tmp1 ; double denom = fast math . ab ( val ) < eps_min ? 2 * eps_min : 2 * val ; double w = x b - ( ( x b - x c ) * tmp2 - ( x b - x a ) * tmp1 ) / denom ; double w lim = x b + grow limit * ( x c - x b ) ; double f w ; if ( ( w - x c ) * ( x b - w ) > 0 ) { f w = eval ( func , w ) ; if ( be minim ? f w < f c : f w > f c ) { x a = x b ; x b = w ; f a = f b ; f b = f w ; break ; } else if ( be minim ? f w > f b : f w < f b ) { x c = w ; f c = f w ; break ; } w = x c + gold * ( x c - x b ) ; f w = eval ( func , w ) ; } else if ( ( w - w lim ) * ( w lim - x c ) > = 0 ) { w = w lim ; f w = eval ( func , w ) ; } else if ( ( w - w lim ) * ( x c - w ) > 0 ) { f w = eval ( func , w ) ; if ( be minim ? f w < f c : f w > f c ) { x b = x c ; x c = w ; w = x c + gold * ( x c - x b ) ; f b = f c ; f c =f w ; f w = eval ( func , w ) ; } } else { w = x c + gold * ( x c - x b ) ; f w = eval ( func , w ) ; } x a = x b ; f a = f b ; x b = x c ; f b = f c ; x c = w ; f c = f w ; } lo = x a ; f lo = f a ; mid = x b ; f mid = f b ; hi = x c ; f hi = f c ; if ( lo > hi ) { double tmp = lo ; lo = hi ; hi = tmp ; tmp = f lo ; f lo = f hi ; f hi = tmp ; } }
public static memory usage set setup main memory only ( long max main memory byte ) { return new memory usage set ( true , false , max main memory byte , max main memory byte ) ; }
public set < medium type > get support type ( parse context context ) { return parser . get supported type ( context ) ; }
public static string [ ] get all detectable charsets ( ) { string [ ] all charset name = new string [ all_cs_recognizers . size ( ) ] ; for ( int i = 0 ; i < all charset name . length ; i++ ) { all charset name [ i ] = all_cs_recognizers . get ( i ) . recognizer . get name ( ) ; } return all charset name ; }
static public confidence get confidence ( int prio ) { for ( confidence c : value ( ) ) { if ( prio < = c . confidence value ) { return c ; } } return confidence . ignore ; }
public void set foreign markup ( final list < element > foreign markup ) { this . foreign markup = foreign markup ; }
default public void init ( filter config filter config ) throw servlet exception { }
public void init ( filter config config ) throw servlet exception { this . config = config ; this . init ( ) ; }
public string get servlet name ( ) { servlet config sc = get servlet config ( ) ; if ( sc == null ) { throw new illegal state exception ( l string . get string ( `` err . servlet_config_not_initialized `` ) ) ; } return sc . get servlet name ( ) ; }
default public boolean be trailer field ready ( ) { return true ; }
public default void attribute remove ( http session bind event se ) { }
public default void attribute add ( servlet context attribute event scae ) { }
default public void context destroy ( servlet context event sce ) { }
public string get secure random algorithm ( ) { return secure random algorithm ; }
public void remove session ( session session ) { single sign on session key key = new single sign on session key ( session ) ; session key . remove ( key ) ; }
public int get max save post size ( ) { return max save post size ; }
public void set redirect strategy ( redirect strategy redirect strategy ) { assert . not null ( redirect strategy , `` redirect strategy can not be null `` ) ; this . redirect strategy = redirect strategy ; }
public void set xpowered by ( boolean xpowered by ) { this . xpowered by = xpowered by ; set property ( `` xpowered by `` , string . value of ( xpowered by ) ) ; }
public boolean get use i p v host ( ) { return use i p v host ; }
public static string get session id ( http servlet request request ) { assert . not null ( request , `` request must not be null `` ) ; http session session = request . get session ( false ) ; return ( session ! = null ? session . get id ( ) : null ) ; }
public void set coyote request ( org . apache . coyote . request coyote request ) { this . coyote request = coyote request ; input buffer . set request ( coyote request ) ; }
public void set coyote response ( org . apache . coyote . response coyote response ) { this . coyote response = coyote response ; output buffer . set response ( coyote response ) ; }
public mock http servlet request builder locale ( @ nullable locale locale ) { this . locale . clear ( ) ; if ( locale ! = null ) { this . locale . add ( locale ) ; } return this ; }
protect void after class ( c context ) { stop embed application ( ) ; if ( application context ! = null & & application context . be run ( ) ) { application context . stop ( ) ; } embed application = null ; application context = null ; }
public void flush buffer ( ) throw i o exception { this . response . flush buffer ( ) ; }
public string to string ( ) { return owner + ' . ' + name + descriptor + `` ( `` + tag + ( be interface ? `` itf `` : `` `` ) + ' ) ' ; }
public final void set attachment filter ( filter . . . filter ) { check access ( ) ; if ( filter . length == 0 ) { filter = empty filter array ( ) ; } else { filter = array . copy of ( filter , filter . length , filter [ ] . class ) ; } synchronize ( this ) { if ( this . attachment formatters . length ! = filter . length ) { throw attachment mismatch ( this . attachment formatters . length , filter . length ) ; } if ( be write ) { throw new illegal state exception ( ) ; } if ( size ! = 0 ) { for ( int i = 0 ; i < filter . length ; ++i ) { if ( filter [ i ] ! = attachment filter [ i ] ) { clear match ( i ) ; break ; } } } this . attachment filter = filter ; } }
public string get request u r i ( ) { return this . _get http servlet request ( ) . get request u r i ( ) ; }
public void set background processor delay ( int delay ) { background processor delay = delay ; }
protect void initalize header ( ) { d o m node child = ( d o m node ) get first child ( ) ; if ( child ! = null ) { int child start = child . get start position ( ) ; if ( child start > 1 ) { set header ( new string ( this . f document , 0 , child start ) ) ; } } }
public class loader get parent class loader ( ) { if ( parent class loader ! = null ) return parent class loader ; if ( service ! = null ) { return service . get parent class loader ( ) ; } return class loader . get system class loader ( ) ; }
public void add child scope ( scope child ) { if ( child scope == null ) { child scope = new array list < scope > ( ) ; } child scope . add ( child ) ; child . set parent scope ( this ) ; }
public string add valve ( string valve type ) throw m bean exception { valve valve = ( valve ) new instance ( valve type ) ; container container = do get manage resource ( ) ; container . get pipeline ( ) . add valve ( valve ) ; if ( valve instanceof jmx enable ) { return ( ( jmx enable ) valve ) . get object name ( ) . to string ( ) ; } else { return null ; } }
public static boolean field be nonnull ( field field , annotation cache annotation cache ) { class < ? > type = field . get declare class ( ) ; if ( annotation cache . have field annotation ( type , field . get name ( ) , nonnull ) ) { return true ; } if ( annotation cache . have field annotation ( type , field . get name ( ) , nullable ) ) { return false ; } return ( annotation cache . have class annotation ( type , findbugs1x_default_annotation_nonnull ) || annotation cache . have class annotation ( type , jsr305_default_annotation_nonnull ) || annotation cache . have class annotation ( type , eclipse_default_annotation_nonnull ) ) ; }
public boolean be ldap pool protection ( ) { return ldap pool protection ; }
public i launch delegate get launch delegate ( string id ) { if ( id ! = null ) { for ( i launch delegate delegate : get launch delegate ( ) ) { if ( id . equal ( delegate . get id ( ) ) ) { return delegate ; } } } return null ; }
public void set session cookie path ( string session cookie path ) { string old session cookie path = this . session cookie path ; this . session cookie path = session cookie path ; support . fire property change ( `` session cookie path `` , old session cookie path , session cookie path ) ; }
public final http client keep alive ( boolean keep alive ) { http client dup = duplicate ( ) ; http header header = configuration ( ) . header . copy ( ) ; http util . set keep alive ( header , http version . http_1_1 , keep alive ) ; dup . configuration ( ) . header = header ; return dup ; }
public string [ ] find filter defs ( ) throw m bean exception { context context = do get manage resource ( ) ; filter def [ ] filter defs = context . find filter defs ( ) ; string [ ] string filter = new string [ filter defs . length ] ; for ( int counter = 0 ; counter < filter defs . length ; counter++ ) { string filter [ counter ] = filter defs [ counter ] . to string ( ) ; } return string filter ; }
public void remove parameter ( string name ) { assert . not null ( name , `` parameter name must not be null `` ) ; this . parameter . remove ( name ) ; }
public long get max time ( ) { long result = 0 ; long time ; container [ ] child = find child ( ) ; if ( child ! = null ) { for ( container child : child ) { time = ( ( standard wrapper ) child ) . get max time ( ) ; if ( time > result ) result = time ; } } return result ; }
public long get max time ( ) { long result = 0 ; long time ; container [ ] child = find child ( ) ; if ( child ! = null ) { for ( container child : child ) { time = ( ( standard wrapper ) child ) . get max time ( ) ; if ( time > result ) result = time ; } } return result ; }
public static boolean be java id ( string id ) { if ( id == null || id . equal ( `` `` ) || be java keyword ( id ) ) return false ; if ( ! character . be java identifier start ( id . char at ( 0 ) ) ) return false ; for ( int i=1 ; i < id . length ( ) ; i++ ) if ( ! character . be java identifier part ( id . char at ( i ) ) ) return false ; return true ; }
public void set jvm route ( string jvm route ) { this . jvm route = jvm route ; }
protect void add ( http servlet request request , print writer writer , string name , boolean html mode , string manager sm client ) { string alias = request . get parameter ( `` aliases `` ) ; string app base = request . get parameter ( `` app base `` ) ; boolean manager = boolean parameter ( request , `` manager `` , false , html mode ) ; boolean auto deploy = boolean parameter ( request , `` auto deploy `` , true , html mode ) ; boolean deploy on startup = boolean parameter ( request , `` deploy on startup `` , true , html mode ) ; boolean deploy x m l = boolean parameter ( request , `` deploy x m l `` , true , html mode ) ; boolean unpack w a r = boolean parameter ( request , `` unpack w a r `` , true , html mode ) ; boolean copy x m l = boolean parameter ( request , `` copy x m l `` , false , html mode ) ; add ( writer , name , alias , app base , manager , auto deploy , deploy on startup , deploy x m l , unpack w a r , copy x m l , sm client ) ; }
public int get available ( ) { return this . available ; }
public string get host header ( ) { return host header ; }
public void set expose request attribute ( boolean expose request attribute ) { this . expose request attribute = expose request attribute ; }
public void set encoding ( string encode ) { this . encode = encoding ; if ( output encode == null ) { output encode = encoding ; } }
public void set clear reference stop thread ( boolean clear reference stop thread ) { this . clear reference stop thread = clear reference stop thread ; }
public void clear cache include ancestor ( ) { clear cache ( ) ; if ( get parent message source ( ) instanceof reloadable resource bundle message source ) { ( ( reloadable resource bundle message source ) get parent message source ( ) ) . clear cache include ancestor ( ) ; } }
public path create classpath ( ) { if ( compile classpath == null ) { compile classpath = new path ( get project ( ) ) ; } return compile classpath ; }
protect void remove service ( string name ) throw exception { string [ ] params = { name } ; string [ ] signature = { `` java . lang . string `` } ; m bean server . invoke ( oname , `` remove service `` , params , signature ) ; }
public string [ ] find lifecycle listener name ( ) throw m bean exception { container container = do get manage resource ( ) ; list < string > result = new array list < > ( ) ; lifecycle listener [ ] listener = container . find lifecycle listener ( ) ; for ( lifecycle listener listener : listener ) { result . add ( listener . get class ( ) . get name ( ) ) ; } return result . to array ( new string [ 0 ] ) ; }
public string [ ] find lifecycle listener name ( ) throw m bean exception { container container = do get manage resource ( ) ; list < string > result = new array list < > ( ) ; lifecycle listener [ ] listener = container . find lifecycle listener ( ) ; for ( lifecycle listener listener : listener ) { result . add ( listener . get class ( ) . get name ( ) ) ; } return result . to array ( new string [ 0 ] ) ; }
public string [ ] find lifecycle listener name ( ) throw m bean exception { container container = do get manage resource ( ) ; list < string > result = new array list < > ( ) ; lifecycle listener [ ] listener = container . find lifecycle listener ( ) ; for ( lifecycle listener listener : listener ) { result . add ( listener . get class ( ) . get name ( ) ) ; } return result . to array ( new string [ 0 ] ) ; }
public void set rmi bind address ( string the rmi bind address ) { rmi bind address = the rmi bind address ; }
public void set use local port ( boolean use local port ) { this . use local port = use local port ; }
public void add connector ( string address , int port , boolean be ajp , boolean be s s l ) throw m bean exception { service service = do get manage resource ( ) ; string protocol = be ajp ? `` ajp/1 . 3 `` : `` http/1 . 1 `` ; connector connector = new connector ( protocol ) ; if ( ( address ! =null ) & & ( address . length ( ) > 0 ) ) { connector . set property ( `` address `` , address ) ; } connector . set port ( port ) ; connector . set secure ( be s s l ) ; connector . set scheme ( be s s l ? `` https `` : `` http `` ) ; service . add connector ( connector ) ; }
public string find role ( string rolename ) { user database database = ( user database ) this . resource ; role role = database . find role ( rolename ) ; if ( role == null ) { return null ; } try { object name oname = m bean utils . create object name ( manage role . get domain ( ) , role ) ; return oname . to string ( ) ; } catch ( malformed object name exception e ) { illegal argument exception iae = new illegal argument exception ( sm . get string ( `` user m bean . create error . role `` , rolename ) ) ; iae . init cause ( e ) ; throw iae ; } }
public string find role ( string rolename ) { user database database = ( user database ) this . resource ; role role = database . find role ( rolename ) ; if ( role == null ) { return null ; } try { object name oname = m bean utils . create object name ( manage role . get domain ( ) , role ) ; return oname . to string ( ) ; } catch ( malformed object name exception e ) { illegal argument exception iae = new illegal argument exception ( sm . get string ( `` user m bean . create error . role `` , rolename ) ) ; iae . init cause ( e ) ; throw iae ; } }
public principal authenticate ( string username , string credential ) { principal authenticate user = null ; for ( realm realm : realm ) { if ( log . be debug enable ( ) ) { log . debug ( sm . get string ( `` combine realm . auth start `` , username , realm . get class ( ) . get name ( ) ) ) ; } authenticate user = realm . authenticate ( username , credential ) ; if ( authenticate user == null ) { if ( log . be debug enable ( ) ) { log . debug ( sm . get string ( `` combine realm . auth fail `` , username , realm . get class ( ) . get name ( ) ) ) ; } } else { if ( log . be debug enable ( ) ) { log . debug ( sm . get string ( `` combine realm . auth success `` , username , realm . get class ( ) . get name ( ) ) ) ; } break ; } } return authenticate user ; }
public void set data source ( data source data source ) { this . data source = data source ; }
public connection get connection ( ) throw s q l exception { jdbc user credential thread credential = this . thread bound credential . get ( ) ; connection con = ( thread credential ! = null ? do get connection ( thread credential . username , thread credential . password ) : do get connection ( this . username , this . password ) ) ; if ( this . catalog ! = null ) { con . set catalog ( this . catalog ) ; } if ( this . schema ! = null ) { con . set schema ( this . schema ) ; } return con ; }
public void set connection u r l ( string connection u r l ) { string old conn string = this . connection u r l ; this . connection u r l = connection u r l ; support . fire property change ( `` connection u r l `` , old conn string , this . connection u r l ) ; }
public void set max cache size ( int max cache size ) { this . max cache size = max cache size ; if ( cache ! = null ) cache . set max size ( max cache size ) ; }
public static boolean be default jndi environment available ( ) { try { new initial context ( ) . get environment ( ) ; return true ; } catch ( throwable ex ) { return false ; } }
public static file maybe mark unreadable ( file path ) { file directory = get directory ( path ) ; if ( instance . unreadable directory . add ( directory ) ) { directory version . increment and get ( ) ; logger . warn ( `` blacklist { } for read `` , directory ) ; return directory ; } return null ; }
public boolean snapshot exists ( string snapshot name ) { assert snapshot name ! = null ; for ( column family store cf store : column family store . value ( ) ) { if ( cf store . snapshot exists ( snapshot name ) ) return true ; } return false ; }
protect connection get connection ( ) { if ( conn == null ) { conn = super . get connection ( ) ; if ( ! be valid rdbms ( conn ) ) { conn = null ; } } return conn ; }
public string get session attribute value class name filter ( ) { if ( session attribute value class name pattern == null ) { return null ; } return session attribute value class name pattern . to string ( ) ; }
public string get session attribute value class name filter ( ) { if ( session attribute value class name pattern == null ) { return null ; } return session attribute value class name pattern . to string ( ) ; }
public void set max session ( int max session ) { this . max session = max session ; ( ( l r u map ) session ) . set maximum size ( max session ) ; }
public session session ( ) { if ( session == null || ! valid session ) { valid session ( true ) ; session = new session ( servlet request . get session ( ) , this ) ; } return session ; }
protect final file get temp dir ( ) throw illegal state exception { servlet context servlet context = get servlet context ( ) ; assert . state ( servlet context ! = null , `` servlet context be require `` ) ; return web utils . get temp dir ( servlet context ) ; }
public void set manager ( manager manager ) { manager old manager = this . manager ; this . manager = manager ; support . fire property change ( `` manager `` , old manager , this . manager ) ; }
public integer get max session ( ) { return max session ; }
public static void main ( string [ ] args ) { if ( args . length > 1 ) { print usage ( ) ; } if ( args . length == 0 || ( args . length == 1 & & args [ 0 ] . equal ( `` -- full `` ) ) ) { system . out . println ( get full version ( ) ) ; system . exit ( 0 ) ; } if ( args [ 0 ] . equal ( `` -- short `` ) ) system . out . println ( get version ( ) ) ; else if ( args [ 0 ] . equal ( `` -- revision `` ) ) system . out . println ( get version revision ( ) ) ; else print usage ( ) ; system . exit ( 0 ) ; }
public void set basedir ( file basedir ) { this . basedir = basedir ; }
protect collection < string > get user role ( http servlet request request ) { array list < string > j2ee user role list = new array list < > ( ) ; for ( string role : this . j2ee mappable role ) { if ( request . be user in role ( role ) ) { j2ee user role list . add ( role ) ; } } return j2ee user role list ; }
public context add webapp ( string context path , string doc base ) { return add webapp ( get host ( ) , context path , doc base ) ; }
public string get group name ( ) { return groupname ; }
public static boolean be valid setter ( method method ) { if ( method . get name ( ) . start with ( `` set `` ) & & method . get name ( ) . length ( ) > 3 & & method . get parameter type ( ) . length == 1 & & method . get return type ( ) . get name ( ) . equal ( `` void `` ) ) { return true ; } return false ; }
protect void destroy internal ( ) throw lifecycle exception { for ( realm realm : realm ) { if ( realm instanceof lifecycle ) { ( ( lifecycle ) realm ) . destroy ( ) ; } } super . destroy internal ( ) ; }
public static string get session uri param name ( context context ) { string result = get configure session cookie name ( context ) ; if ( result == null ) { result = default_session_parameter_name ; } return result ; }
public void set session id length ( int session id length ) { this . session id length = session id length ; }
public void set rotatable ( boolean rotatable ) { this . rotatable = rotatable ; }
public void set rename on rotate ( boolean rename on rotate ) { this . rename on rotate = rename on rotate ; }
protect void start html ( print writer out ) { out . println ( `` < ! doctype html public \ `` -//w3c//dtd xhtml 1 . 1//en\ `` \ `` http : //www . w3 . org/ t r/xhtml11/ d t d/xhtml11 . dtd\ `` > `` ) ; out . println ( `` < html xmlns=\ `` http : //www . w3 . org/1999/xhtml\ `` > `` ) ; out . println ( `` < head > `` ) ; out . println ( `` < meta charset='utf-8 ' > `` ) ; out . println ( `` < title > test n g report < /title > `` ) ; out . println ( `` < style type=\ `` text/css\ `` > `` ) ; out . println ( `` table { margin-bottom:10px ; border-collapse : collapse ; empty-cells : show } `` ) ; out . println ( `` td , th { border:1px solid # 009 ; padding : . 25em . 5em } `` ) ; out . println ( `` . result th { vertical-align : bottom } `` ) ; out . println ( `` . param th { padding-left:1em ; padding-right:1em } `` ) ; out . println ( `` . param td { padding-left : . 5em ; padding-right:2em } `` ) ; out . println ( `` . stripe td , . stripe th { background-color : # e6ebf9 } `` ) ; out . println ( `` . numi , . numi_attn { text-align : right } `` ) ; out . println ( `` . total td { font-weight : bold } `` ) ; out . println ( `` . passedodd td { background-color : # 0a0 } `` ) ; out . println ( `` . passedeven td { background-color : # 3f3 } `` ) ; out . println ( `` . skippedodd td { background-color : # ccc } `` ) ; out . println ( `` . skippedodd td { background-color : # ddd } `` ) ; out . println ( `` . failedodd td , . numi_attn { background-color : # f33 } `` ) ; out . println ( `` . failedeven td , . stripe . numi_attn { background-color : # d00 } `` ) ; out . println ( `` . stacktrace { white-space : pre ; font-family : monospace } `` ) ; out . println ( `` . totop { font-size:85 % ; text-align : center ; border-bottom:2px solid # 000 } `` ) ; out . println ( `` < /style > `` ) ; out . println ( `` < /head > `` ) ; out . println ( `` < body > `` ) ; }
public void set remote host ( string remote host ) { this . remote host = remote host ; }
public synchronize void set host ( final string host , final string virtual host , int port , final protocol protocol ) { set host ( host , port , protocol ) ; this . params . set virtual host ( virtual host ) ; }
public static void add static resolution ( string host , string resolve name ) { synchronize ( host to resolve ) { host to resolve . put ( host , resolve name ) ; } }
public string get ignore cookie value ( ) { return _ignore cookie value ; }
public text string builder append with separator ( final iterator < ? > it , final string separator ) { if ( it ! = null ) { final string sep = object . to string ( separator , `` `` ) ; while ( it . have next ( ) ) { append ( it . next ( ) ) ; if ( it . have next ( ) ) { append ( sep ) ; } } } return this ; }
public string get host header ( ) { return host header ; }
public void set protocol header ( string protocol header ) { this . protocol header = protocol header ; }
public boolean set property ( string name , string value ) { return endpoint . set property ( name , value ) ; }
public byte [ ] get buffer ( ) { return file . buf ; }
public void append int ( int val ) { buf [ pos++ ] = ( byte ) ( ( val > > > 8 ) & 0x f f ) ; buf [ pos++ ] = ( byte ) ( val & 0x f f ) ; }
public static int get int ( byte [ ] data , int offset ) { int i = offset ; int b0 = data [ i++ ] & 0x f f ; int b1 = data [ i++ ] & 0x f f ; int b2 = data [ i++ ] & 0x f f ; int b3 = data [ i++ ] & 0x f f ; return ( b3 < < 24 ) + ( b2 < < 16 ) + ( b1 < < 8 ) + ( b0 < < 0 ) ; }
public boolean be error ( ) { return ( this . severity & problem severity . error ) ! = 0 ; }
public int get max save post size ( ) { return max save post size ; }
public void set disable upload timeout ( boolean be disable ) { disable upload timeout = be disable ; }
public void set coyote request ( org . apache . coyote . request coyote request ) { this . coyote request = coyote request ; input buffer . set request ( coyote request ) ; }
public synchronize long skip ( long n ) throw i o exception { if ( n < = 0 ) { return 0 ; } seek ( get pos ( ) +n ) ; return n ; }
public static boolean be register ( string object name ) { m bean server server = get m bean server ( ) ; try { return server . be register ( new object name ( object name ) ) ; } catch ( malformed object name exception e ) { throw new illegal argument exception ( e ) ; } }
public void clear index ( ) throw i o exception { synchronize ( modify current index lock ) { ensure open ( ) ; final directory dir = this . spell index ; final index writer writer = new index writer ( dir , new index writer config ( null ) . set open mode ( open mode . create ) ) ; writer . close ( ) ; swap searcher ( dir ) ; } }
public name rev command add prefix ( string prefix ) { check callable ( ) ; prefix . add ( prefix ) ; return this ; }
public static i error handle policy proceed on first error ( ) { return new i error handling policy ( ) { @ override public boolean stop on first error ( ) { return true ; } @ override public boolean proceed on error ( ) { return true ; } @ override public boolean ignore all error ( ) { return false ; } } ; }
public constant get constant ( final int index ) { if ( index > = constant_pool . length || index < 0 ) { throw new class format exception ( `` invalid constant pool reference : `` + index + `` . constant pool size be : `` + constant_pool . length ) ; } return constant_pool [ index ] ; }
public void set concurrency limit ( int concurrency limit ) { this . concurrency limit = concurrency limit ; }
public void receive next packet ( readable byte channel in ) throw i o exception { do read ( in , null ) ; }
public void set byte ( byte [ ] b , int off , int len ) { buff = b ; start = off ; end = start + len ; be set = true ; have hash code = false ; }
public boolean start with ignore case ( string s , int po ) { char [ ] c = buff ; int len = s . length ( ) ; if ( c == null || len + po > end - start ) { return false ; } int off = start + po ; for ( int i = 0 ; i < len ; i++ ) { if ( ascii . to lower ( c [ off++ ] ) ! = ascii . to lower ( s . char at ( i ) ) ) { return false ; } } return true ; }
protect static final int compare ( char chunk name , char [ ] compare to ) { int result = 0 ; char [ ] c = name . get buffer ( ) ; int start = name . get start ( ) ; int end = name . get end ( ) ; int len = compare to . length ; if ( ( end - start ) < len ) { len = end - start ; } for ( int i = 0 ; ( i < len ) & & ( result == 0 ) ; i++ ) { if ( c [ i + start ] > compare to [ i ] ) { result = 1 ; } else if ( c [ i + start ] < compare to [ i ] ) { result = -1 ; } } if ( result == 0 ) { if ( compare to . length > ( end - start ) ) { result = -1 ; } else if ( compare to . length < ( end - start ) ) { result = 1 ; } } return result ; }
public void append byte chunk ( byte chunk bc ) { if ( bc == null ) { log . error ( sm . get string ( `` ajpmessage . null `` ) , new null pointer exception ( ) ) ; append int ( 0 ) ; append byte ( 0 ) ; return ; } append byte ( bc . get byte ( ) , bc . get start ( ) , bc . get length ( ) ) ; }
public static boolean have text ( char sequence str ) { if ( ! have length ( str ) ) { return false ; } int str len = str . length ( ) ; for ( int i = 0 ; i < str len ; i++ ) { if ( ! character . be whitespace ( str . char at ( i ) ) ) { return true ; } } return false ; }
public static int index of ( byte [ ] byte , byte [ ] pattern , int start ) { if ( pattern . length == 0 ) { return start ; } if ( start > byte . length ) { return -1 ; } int last = byte . length - pattern . length + 1 ; int pattern len = pattern . length ; next : for ( ; start < last ; start++ ) { for ( int i = 0 ; i < pattern len ; i++ ) { if ( bytes [ start + i ] ! = pattern [ i ] ) { continue next ; } } return start ; } return -1 ; }
public boolean user match ( authenticate user user , string principal ) { if ( user == null ) return principal == null ; if ( user instanceof servlet authenticate user ) { servlet authenticate user servlet user = ( servlet authenticate user ) user ; return servlet user . get request ( ) . be user in role ( principal ) ; } return false ; }
public boolean find auth role ( string role ) { if ( role == null ) return false ; for ( string auth role : auth role ) { if ( role . equal ( auth role ) ) return true ; } return false ; }
public void add collection ( security collection collection ) { if ( collection == null ) return ; collection . set charset ( get charset ( ) ) ; security collection result [ ] = array . copy of ( collection , collection . length + 1 ) ; result [ collection . length ] = collection ; collection = result ; }
public static void set verbose garbage collection ( boolean verbose ) { memory m x bean . set verbose ( verbose ) ; boolean check value = memory m x bean . be verbose ( ) ; if ( verbose ! = check value ) { log . error ( `` could not set verbose garbage collection log to `` + verbose + `` , get `` + check value + `` instead `` ) ; } }
public string to string ( ) { string builder sb = new string builder ( ) ; sb . append ( super . to string ( ) ) ; sb . append ( `` : `` ) ; sb . append ( size ( ) ) ; sb . append ( `` wrap throwables : `` ) ; for ( throwable t : throwables ) { sb . append ( `` [ `` ) ; sb . append ( t . get message ( ) ) ; sb . append ( `` ] `` ) ; } return sb . to string ( ) ; }
public object get root ( ) { return f root ; }
public object peek ( ) { try { return stack . peek ( ) ; } catch ( empty stack exception e ) { log . warn ( sm . get string ( `` digester . empty stack `` ) ) ; return null ; } }
public input stream get input stream ( ) throw i o exception { if ( be reference ( ) ) { return ( ( resource ) get check ref ( ) ) . get input stream ( ) ; } throw new unsupported operation exception ( ) ; }
public static string get gate resource a string ( string resource name ) throw i o exception { input stream resource stream = get gate resource a stream ( resource name ) ; if ( resource stream == null ) throw new i o exception ( `` no such resource on classpath : `` + resource name ) ; try { return i o utils . to string ( resource stream ) ; } finally { resource stream . close ( ) ; } } // get gate resource a string ( string )
public static string clean content type ( mime part mp , string content type ) { if ( clean content type ! = null ) { try { return ( string ) clean content type . invoke ( null , new object [ ] { mp , content type } ) ; } catch ( exception ex ) { return content type ; } } else return content type ; }
public static string decode ( string escape ) throw u r i exception { try { byte [ ] rawdata = u r l codec . decode url ( encode util . get ascii byte ( escape ) ) ; return encode util . get string ( rawdata , uri . get default protocol charset ( ) ) ; } catch ( decoder exception e ) { throw new u r i exception ( e . get message ( ) ) ; } }
public string get name ( ) { return stream . check file name ( file name ) ; }
public void close input stream ( ) throw i o exception { if ( ! f close ) { f close = true ; f stream . close ( ) ; } else { throw new i o exception ( ) ; } }
public static string clean ( string charset name ) { try { return for name ( charset name ) . name ( ) ; } catch ( exception e ) { return null ; } }
public void encoding ( final string encode ) { if ( encode == null ) { get header ( ) . remove ( http header . content_encoding ) ; } else { get header ( ) . put single ( http header . content_encoding , encode ) ; } }
public static list < string > any split ( string input , string delim ) { if ( null == input ) { return collection . empty list ( ) ; } array list < string > result = new array list < string > ( ) ; if ( lang util . be empty ( delim ) || ( -1 == input . index of ( delim ) ) ) { result . add ( input . trim ( ) ) ; } else { string tokenizer st = new string tokenizer ( input , delim ) ; while ( st . have more token ( ) ) { result . add ( st . next token ( ) . trim ( ) ) ; } } return result ; }
public static path get ( path [ ] root , string path ) { for ( path root : root ) { path normalize root = root . normalize ( ) ; path normalized path = normalize root . resolve ( path ) . normalize ( ) ; if ( normalized path . start with ( normalized root ) ) { return normalize path ; } } return null ; }
public static string stop capture ( ) { stack < capture log > stack = log . get ( ) ; if ( stack == null || stack . be empty ( ) ) { return null ; } capture log log = stack . pop ( ) ; if ( log == null ) { return null ; } string capture = log . get capture ( ) ; log . reset ( ) ; reuse . push ( log ) ; return capture ; }
public synchronize void set attribute ( string name , string value ) { if ( name . equal ignore case ( project helper . ant_type ) ) { this . poly type = value ; } else { if ( attribute name == null ) { attribute name = new array list ( ) ; attribute map = new hash map ( ) ; } if ( name . to lower case ( locale . u ) . equal ( `` refid `` ) ) { attribute name . add ( 0 , name ) ; } else { attribute name . add ( name ) ; } attribute map . put ( name , value ) ; if ( name . equal ( `` id `` ) ) { this . id = value ; } } }
public string [ ] get names ( ) { string [ ] names = class map . key set ( ) . to array ( new string [ 0 ] ) ; array . sort ( name ) ; return name ; }
public m bean notification info [ ] get notification info ( ) { return new m bean notification info [ 0 ] ; }
public void add parameter ( parameter info parameter ) { lock write lock = parameter lock . write lock ( ) ; write lock . lock ( ) ; try { parameter info result [ ] = new parameter info [ parameter . length + 1 ] ; system . arraycopy ( parameter , 0 , result , 0 , parameter . length ) ; result [ parameter . length ] = parameter ; parameter = result ; this . info = null ; } finally { write lock . unlock ( ) ; } }
public static m bean server get m bean server ( ) { list < m bean server > server = m bean server factory . find m bean server ( null ) ; m bean server server = server . size ( ) > 0 ? server . get ( 0 ) : management factory . get platform m bean server ( ) ; return server ; }
public t do on channel init ( channel pipeline configurer do on channel init ) { object . require non null ( do on channel init , `` do on channel init `` ) ; t dup = duplicate ( ) ; channel pipeline configurer current = configuration ( ) . do on channel init ; dup . configuration ( ) . do on channel init = current == null ? do on channel init : current . then ( do on channel init ) ; return dup ; }
public reference get reference ( ) throw name exception { reference ref = super . get reference ( ) ; ref . add ( new string ref addr ( `` data source name `` , data source name ) ) ; if ( initial connection > 0 ) { ref . add ( new string ref addr ( `` initial connection `` , integer . to string ( initial connection ) ) ) ; } if ( max connection > 0 ) { ref . add ( new string ref addr ( `` max connection `` , integer . to string ( max connection ) ) ) ; } return ref ; }
protect void close socket ( u socket ) { socket wrapper base < s > socket wrapper = connection . get ( socket ) ; if ( socket wrapper ! = null ) { socket wrapper . close ( ) ; } }
public encryption key get server key ( kerberos principal server principal , string server password ) { kerberos key server kerberos key = new kerberos key ( server principal , server password . to char array ( ) , `` de `` ) ; byte [ ] server key bytes = server kerberos key . get encoded ( ) ; encryption key server key = new encryption key ( encryption type . des_cbc_md5 , server key byte ) ; return server key ; }
public void close ( ) throw i o exception { in . close ( ) ; out . close ( ) ; err . close ( ) ; }
public void flush ( ) throw i o exception { flush buffer ( false , false ) ; }
public void add channel ( final channel entry channel entry ) { args . not null ( channel entry , `` channel entry `` ) ; this . new channel . add ( channel entry ) ; this . selector . wakeup ( ) ; }
public static < t > t eval ( string expression , class < t > to type ) { return convert ( new m v e l interpret runtime ( expression ) . parse ( ) , to type ) ; }
public static < t > boolean add all ( collection < t > target , iterable < ? extend t > iterable ) { if ( iterable instanceof collection ) { return target . add all ( ( collection < ? extend t > ) iterable ) ; } return iterators . add all ( target , iterable . iterator ( ) ) ; }
public string get variable ( string var ) { return variable . get ( var ) ; }
public u r i builder add path ( list < string > path ) { list < path > current path = stream . concat ( this . path . stream ( ) , path . stream ( ) . map ( string to path ) ) . collect ( collector . to list ( ) ) ; return path internal ( current path , be path absolute , false ) ; }
public boolean invalid set method ( context context , string leftreference , string rightreference , info info ) { for ( invalid reference event handler handler : invalid reference handler ) { if ( handler . invalid set method ( context , leftreference , rightreference , info ) ) { return true ; } } return false ; }
public object invalid method ( context context , string reference , object object , string method , info info ) { object result = null ; for ( invalid reference event handler handler : invalid reference handler ) { result = handler . invalid method ( context , reference , object , method , info ) ; / * reflect 1 . x behavior : exit after at least one execution whenever a non-null value have be find * / if ( result ! = null ) { break ; } } return result ; }
public boolean invalid set method ( context context , string leftreference , string rightreference , info info ) { for ( invalid reference event handler handler : invalid reference handler ) { if ( handler . invalid set method ( context , leftreference , rightreference , info ) ) { return true ; } } return false ; }
public boolean invalid set method ( context context , string leftreference , string rightreference , info info ) { for ( invalid reference event handler handler : invalid reference handler ) { if ( handler . invalid set method ( context , leftreference , rightreference , info ) ) { return true ; } } return false ; }
public static void add property ( string key , object value ) { runtime singleton . add property ( key , value ) ; }
public synchronize void add directive ( directive directive ) { runtime directive . put ( directive . get name ( ) , directive ) ; update share directive map ( ) ; }
public boolean remove mapping ( final object key , final object value ) { final collection < v > value for key = get collection ( key ) ; if ( value for key == null ) { return false ; } final boolean remove = value for key . remove ( value ) ; if ( remove == false ) { return false ; } if ( value for key . be empty ( ) ) { remove ( key ) ; } return true ; }
public string get initial template ( ) { if ( initial template == null ) { return null ; } else { return initial template . get template name ( ) . get clark name ( ) ; } }
public string get scope name ( ) { return this . scope name ; }
public object value ( internal context adapter context ) { if ( interpolate ) { try { / * * now render against the real context * / writer writer = new string builder writer ( ) ; node tree . render ( context , writer ) ; / * * and return the result a a string * / return writer . to string ( ) ; } / * * * pas through application level runtime exception * / catch ( runtime exception e ) { throw e ; } catch ( i o exception e ) { string msg = `` error in interpolate string literal `` ; log . error ( msg , e ) ; throw new velocity exception ( msg , e ) ; } } / * * ok , either not allow to interpolate , there be n't a ref or * directive , or we fail , so just output the literal * / return image ; }
public object value ( internal context adapter context ) { if ( interpolate ) { try { / * * now render against the real context * / writer writer = new string builder writer ( ) ; node tree . render ( context , writer ) ; / * * and return the result a a string * / return writer . to string ( ) ; } / * * * pas through application level runtime exception * / catch ( runtime exception e ) { throw e ; } catch ( i o exception e ) { string msg = `` error in interpolate string literal `` ; log . error ( msg , e ) ; throw new velocity exception ( msg , e ) ; } } / * * ok , either not allow to interpolate , there be n't a ref or * directive , or we fail , so just output the literal * / return image ; }
public static int distance ( final class < ? > child , final class < ? > parent ) { if ( child == null || parent == null ) { return -1 ; } if ( child . equal ( parent ) ) { return 0 ; } final class < ? > c parent = child . get superclass ( ) ; int d = boolean utils . to integer ( parent . equal ( c parent ) ) ; if ( d == 1 ) { return d ; } d += distance ( c parent , parent ) ; return d > 0 ? d + 1 : -1 ; }
public void pop current macro name ( ) { macro name stack . pop ( ) ; }
public static string html element content ( string content ) { if ( content == null ) { return null ; } string builder sb = new string builder ( ) ; for ( int i = 0 ; i < content . length ( ) ; i++ ) { char c = content . char at ( i ) ; if ( c == ' < ' ) { sb . append ( `` & lt ; `` ) ; } else if ( c == ' > ' ) { sb . append ( `` & gt ; `` ) ; } else if ( c == '\ `` ) { sb . append ( `` & # 39 ; `` ) ; } else if ( c == ' & ' ) { sb . append ( `` & amp ; `` ) ; } else if ( c == ' `` ' ) { sb . append ( `` & quot ; `` ) ; } else if ( c == '/ ' ) { sb . append ( `` & # 47 ; `` ) ; } else { sb . append ( c ) ; } } return ( sb . length ( ) > content . length ( ) ) ? sb . to string ( ) : content ; }
public static byte [ ] read stream ( input stream fin ) throw i o exception { byte [ ] [ ] bufs = new byte [ 8 ] [ ] ; int bufsize = 4096 ; for ( int i = 0 ; i < 8 ; ++i ) { bufs [ i ] = new byte [ bufsize ] ; int size = 0 ; int len = 0 ; do { len = fin . read ( bufs [ i ] , size , bufsize - size ) ; if ( len > = 0 ) size += len ; else { byte [ ] result = new byte [ bufsize - 4096 + size ] ; int s = 0 ; for ( int j = 0 ; j < i ; ++j ) { system . arraycopy ( bufs [ j ] , 0 , result , s , s + 4096 ) ; s = s + s + 4096 ; } system . arraycopy ( bufs [ i ] , 0 , result , s , size ) ; return result ; } } while ( size < bufsize ) ; bufsize * = 2 ; } throw new i o exception ( `` too much data `` ) ; }
public void put ( parser parser ) { parser . re init ( ( char stream ) null ) ; pool . put ( parser ) ; }
public void set data source ( data source data source ) { this . data source = data source ; }
public java class find class ( string class name ) { synchronize ( loaded class ) { if ( loaded class . contains key ( class name ) ) { return load class . get ( class name ) ; } else { return null ; } } }
public int get keep alive timeout ( ) { if ( keep alive timeout == null ) { return get connection timeout ( ) ; } else { return keep alive timeout . int value ( ) ; } }
public boolean require check ( ) { / * * short circuit this if modification check interval == 0 * a this mean `` do n't check `` * / if ( modification check interval < = 0 ) { return false ; } / * * see if we need to check now * / return ( system . current time millis ( ) > = next check ) ; }
public static url get resource a u r l ( object object , resource resource ) { class loader loader = object . get class ( ) . get class loader ( ) ; url url = null ; if ( loader ! = null ) { url = loader . get resource ( resource . get name ( ) ) ; } else { url = class loader . get system resource ( resource . get name ( ) ) ; } return ( url ) ; }
public string trim leave ( string key ) { if ( key == null ) { return string utils . empty ; } else { string result = key ; while ( have lead delimiter ( result ) ) { result = result . substring ( get expression engine ( ) . get property delimiter ( ) . length ( ) ) ; } return result ; } }
public string get library name ( final string vm name , template template ) { if ( use namespaces ( ) ) { / * * if we have this macro define in this namespace , then * it be mask the global , library-based one , so * just return null * / macro entry me = ( macro entry ) template . get macros ( ) . get ( vm name ) ; if ( me ! = null ) return null ; } macro entry me = ( macro entry ) global namespace . get ( vm name ) ; if ( me ! = null ) { return me . get source template ( ) ; } return null ; }
public static string format file string ( directive directive ) { return format file string ( directive . get template name ( ) , directive . get line ( ) , directive . get column ( ) ) ; }
public void clear ( ) { synchronize ( class map cache ) { class map cache . clear ( ) ; class field map cache . clear ( ) ; class name cache . clear ( ) ; log . debug ( cachedump_msg ) ; } }
public static set < string > get doc store file ( segment info info ) { if ( lucene3x segment info format . get doc store offset ( info ) ! = -1 ) { final string d name = lucene3x segment info format . get doc store segment ( info ) ; set < string > file = new hash set < string > ( ) ; if ( lucene3x segment info format . get doc store be compound file ( info ) ) { file . add ( index file name . segment file name ( ds name , `` `` , compound_file_store_extension ) ) ; } else { file . add ( index file name . segment file name ( ds name , `` `` , lucene3x store field reader . fields_index_extension ) ) ; file . add ( index file name . segment file name ( ds name , `` `` , lucene3x store field reader . fields_extension ) ) ; file . add ( index file name . segment file name ( ds name , `` `` , lucene3x term vector reader . vectors_index_extension ) ) ; file . add ( index file name . segment file name ( ds name , `` `` , lucene3x term vector reader . vectors_fields_extension ) ) ; file . add ( index file name . segment file name ( ds name , `` `` , lucene3x term vector reader . vectors_documents_extension ) ) ; } return file ; } else { return null ; } }
public string get engine version ( ) { return velocity_version ; }
public static string to detail string ( byte buffer buffer ) { if ( buffer == null ) return `` null `` ; string builder buf = new string builder ( ) ; id string ( buffer , buf ) ; buf . append ( `` [ p= `` ) ; buf . append ( buffer . position ( ) ) ; buf . append ( `` , l= `` ) ; buf . append ( buffer . limit ( ) ) ; buf . append ( `` , c= `` ) ; buf . append ( buffer . capacity ( ) ) ; buf . append ( `` , r= `` ) ; buf . append ( buffer . remain ( ) ) ; buf . append ( `` ] = { `` ) ; append debug string ( buf , buffer ) ; buf . append ( `` } `` ) ; return buf . to string ( ) ; }
protect groovy script engine create groovy script engine ( ) { return new groovy script engine ( this ) ; }
public bridge option set inbound permitteds ( list < permit option > inbound permit ) { this . inbound permit = inbound permit ; return this ; }
public void undeploy ( string deployment i d ) { delegate . undeploy ( deployment i d ) ; }
public void start ( ) throw illegal state exception { start ( `` `` ) ; }
public final boolean get multi ( ) { return option . boolean value ( `` multi `` ) ; }
public short get short ( string name ) { short ret = delegate . get short ( name ) ; return ret ; }
public option set choice ( set < string > choice ) { this . choice = choice ; return this ; }
public static < t > converter < t > get implicit converter ( class < ? extend t > type ) { return implicit converter . get converter ( type ) ; }
public static text string builder wrap ( final char [ ] initial buffer ) { object . require non null ( initial buffer , `` initial buffer `` ) ; return new text string builder ( initial buffer , initial buffer . length ) ; }
public json object config ( ) { return context . config ( ) ; }
public long get refresh time ( final time unit time unit ) { if ( refresh time < 0 ) { return refresh time ; } return time unit . convert ( refresh time , this . time unit ) ; }
public event bus option set cluster public host ( string cluster public host ) { this . cluster public host = cluster public host ; return this ; }
public int get cluster public port ( ) { return event bus option . get cluster public port ( ) ; }
public void fail ( int failure code , string message ) { delegate . fail ( failure code , message ) ; }
public boolean be force sync ( ) { return force sync ; }
public open option set dsync ( boolean dsync ) { this . dsync = dsync ; return this ; }
public socket option set keep alive ( boolean keep alive ) { this . keep alive = keep alive ; return this ; }
public http client option set max wait queue size ( int max wait queue size ) { this . max wait queue size = max wait queue size ; return this ; }
public task scheduler builder pool size ( int pool size ) { return new task scheduler builder ( pool size , this . await termination , this . await termination period , this . thread name prefix , this . customizers ) ; }
public http client option set initial setting ( http2 setting setting ) { this . initial setting = setting ; return this ; }
public boolean get per frame websocket compression support ( ) { return this . per frame web socket compression support ; }
public vertx http2 connection handler < c > add handler ( handler < c > handler ) { this . add handler = handler ; return this ; }
public synchronize string get host ( ) { if ( this . host ! = null ) { return this . host . get host name ( ) ; } else { return null ; } }
public collect request set dependency ( list < dependency > dependency ) { if ( dependency == null ) { this . dependency = collection . empty list ( ) ; } else { this . dependency = dependency ; } return this ; }
public http server option add web socket sub protocol ( string sub protocol ) { object . require non null ( sub protocol , `` can not add a null web socket sub-protocol `` ) ; if ( web socket sub protocol == null ) { web socket sub protocol = new array list < > ( ) ; } web socket sub protocol . add ( sub protocol ) ; return this ; }
public static throwable get cause ( throwable throwable ) { synchronize ( cause_method_names_lock ) { return get cause ( throwable , cause_method_names ) ; } }
protect static void add shutdown hook ( vertx vertx , logger log , runnable action ) { runtime . get runtime ( ) . add shutdown hook ( new thread ( get termination runnable ( vertx , log , action ) ) ) ; }
public void deploy verticle ( io . vertx . core . verticle verticle ) { delegate . deploy verticle ( verticle ) ; }
protect void execute ( runnable task ) { executor . execute ( task ) ; }
public json array add ( enum value ) { list . add ( value ! = null ? value . name ( ) : null ) ; return this ; }
public json object put ( string key , json object value ) { object . require non null ( key ) ; map . put ( key , value ) ; return this ; }
public json object put ( string key , json object value ) { object . require non null ( key ) ; map . put ( key , value ) ; return this ; }
public object remove ( object key ) { if ( fast ) { synchronize ( this ) { map temp = clone map ( map ) ; object result = temp . remove ( key ) ; map = temp ; return ( result ) ; } } else { synchronize ( map ) { return ( map . remove ( key ) ) ; } } }
public void execute ( string command , string . . . args ) { launcher . execute ( command , args ) ; }
public agroal data source configuration supplier metric enable ( boolean metric enable ) { check lock ( ) ; metric = metric enable ; return this ; }
public proxy option get proxy option ( ) { return proxy option ; }
public http client option set force sni ( boolean force sni ) { this . force sni = force sni ; return this ; }
public socket option set send buffer size ( int send buffer size ) { this . send buffer size = send buffer size ; return this ; }
public open s s l engine option set session cache enable ( boolean session cache enable ) { this . session cache enable = session cache enable ; return this ; }
public pem key cert option set cert path ( string cert path ) { cert path . clear ( ) ; if ( cert path ! = null ) { cert path . add ( cert path ) ; } return this ; }
public static boolean validate non proxy host ( proxy info proxy , string target host ) { if ( target host == null ) { target host = new string ( ) ; } if ( proxy == null ) { return false ; } string non proxy host = proxy . get non proxy host ( ) ; if ( non proxy host == null ) { return false ; } string tokenizer tokenizer = new string tokenizer ( non proxy host , `` | `` ) ; while ( tokenizer . have more token ( ) ) { string pattern = tokenizer . next token ( ) ; pattern = pattern . replace all ( `` \\ . `` , `` \\\\ . `` ) . replace all ( `` \\ * `` , `` . * `` ) ; if ( target host . match ( pattern ) ) { return true ; } } return false ; }
public client configuration with proxy password ( string proxy password ) { set proxy password ( proxy password ) ; return this ; }
public t c p s s l option add crl value ( buffer crl value ) throw null pointer exception { object . require non null ( crl value , `` no null crl accept `` ) ; crl value . add ( crl value ) ; return this ; }
public vertx option set cluster port ( int cluster port ) { event bus option . set port ( cluster port ) ; return this ; }
public boolean be h a enabled ( ) { return ha enable ; }
public io . vertx . reactivex . sqlclient . sql connection exception handler ( handler < java . lang . throwable > handler ) { delegate . exception handler ( handler ) ; return this ; }
public void close ( handler < async result < void > > close handler ) { delegate . close ( close handler ) ; }
public static io . vertx . reactivex . amqpbridge . amqp bridge create ( io . vertx . reactivex . core . vertx vertx ) { io . vertx . reactivex . amqpbridge . amqp bridge ret = io . vertx . reactivex . amqpbridge . amqp bridge . new instance ( ( io . vertx . amqpbridge . amqp bridge ) io . vertx . amqpbridge . amqp bridge . create ( vertx . get delegate ( ) ) ) ; return ret ; }
public io . vertx . reactivex . ext . consul . consul client delete value ( string key prefix , handler < async result < void > > result handler ) { delegate . delete value ( key prefix , result handler ) ; return this ; }
public void execute batch ( list < io . vertx . reactivex . sqlclient . tuple > batch , handler < async result < t > > handler ) { delegate . execute batch ( batch . stream ( ) . map ( elt - > elt . get delegate ( ) ) . collect ( collector . to list ( ) ) , new handler < async result < t > > ( ) { public void handle ( async result < t > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( ( t ) __type arg_0 . wrap ( ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; }
public io . vertx . reactivex . circuitbreaker . circuit breaker close handler ( handler < void > handler ) { delegate . close handler ( handler ) ; return this ; }
public < t > io . vertx . reactivex . core . eventbus . event bus add outbound interceptor ( handler < io . vertx . reactivex . core . eventbus . delivery context < t > > interceptor ) { delegate . add outbound interceptor ( new handler < io . vertx . core . eventbus . delivery context < t > > ( ) { public void handle ( io . vertx . core . eventbus . delivery context < t > event ) { interceptor . handle ( io . vertx . reactivex . core . eventbus . delivery context . new instance ( ( io . vertx . core . eventbus . delivery context ) event , type arg . unknown ( ) ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . core . http . http client request option ( io . vertx . core . http . request option option , handler < io . vertx . reactivex . core . http . http client response > response handler ) { io . vertx . reactivex . core . http . http client request ret = io . vertx . reactivex . core . http . http client request . new instance ( ( io . vertx . core . http . http client request ) delegate . option ( option , new handler < io . vertx . core . http . http client response > ( ) { public void handle ( io . vertx . core . http . http client response event ) { response handler . handle ( io . vertx . reactivex . core . http . http client response . new instance ( ( io . vertx . core . http . http client response ) event ) ) ; } } ) ) ; return ret ; }
public io . vertx . reactivex . core . http . http client request option abs ( string absolute u r i , handler < io . vertx . reactivex . core . http . http client response > response handler ) { io . vertx . reactivex . core . http . http client request ret = io . vertx . reactivex . core . http . http client request . new instance ( ( io . vertx . core . http . http client request ) delegate . option abs ( absolute u r i , new handler < io . vertx . core . http . http client response > ( ) { public void handle ( io . vertx . core . http . http client response event ) { response handler . handle ( io . vertx . reactivex . core . http . http client response . new instance ( ( io . vertx . core . http . http client response ) event ) ) ; } } ) ) ; return ret ; }
public io . vertx . reactivex . core . http . http client request head ab ( string absolute u r i , handler < io . vertx . reactivex . core . http . http client response > response handler ) { io . vertx . reactivex . core . http . http client request ret = io . vertx . reactivex . core . http . http client request . new instance ( ( io . vertx . core . http . http client request ) delegate . head ab ( absolute u r i , new handler < io . vertx . core . http . http client response > ( ) { public void handle ( io . vertx . core . http . http client response event ) { response handler . handle ( io . vertx . reactivex . core . http . http client response . new instance ( ( io . vertx . core . http . http client response ) event ) ) ; } } ) ) ; return ret ; }
public io . vertx . reactivex . core . http . http client request head ( string request u r i , handler < io . vertx . reactivex . core . http . http client response > response handler ) { io . vertx . reactivex . core . http . http client request ret = io . vertx . reactivex . core . http . http client request . new instance ( ( io . vertx . core . http . http client request ) delegate . head ( request u r i , new handler < io . vertx . core . http . http client response > ( ) { public void handle ( io . vertx . core . http . http client response event ) { response handler . handle ( io . vertx . reactivex . core . http . http client response . new instance ( ( io . vertx . core . http . http client response ) event ) ) ; } } ) ) ; return ret ; }
public io . vertx . reactivex . core . http . http client option now ( string request u r i , handler < io . vertx . reactivex . core . http . http client response > response handler ) { delegate . option now ( request u r i , new handler < io . vertx . core . http . http client response > ( ) { public void handle ( io . vertx . core . http . http client response event ) { response handler . handle ( io . vertx . reactivex . core . http . http client response . new instance ( ( io . vertx . core . http . http client response ) event ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . core . http . http client request option ( io . vertx . core . http . request option option , handler < io . vertx . reactivex . core . http . http client response > response handler ) { io . vertx . reactivex . core . http . http client request ret = io . vertx . reactivex . core . http . http client request . new instance ( ( io . vertx . core . http . http client request ) delegate . option ( option , new handler < io . vertx . core . http . http client response > ( ) { public void handle ( io . vertx . core . http . http client response event ) { response handler . handle ( io . vertx . reactivex . core . http . http client response . new instance ( ( io . vertx . core . http . http client response ) event ) ) ; } } ) ) ; return ret ; }
public io . vertx . reactivex . core . http . http client request head ab ( string absolute u r i , handler < io . vertx . reactivex . core . http . http client response > response handler ) { io . vertx . reactivex . core . http . http client request ret = io . vertx . reactivex . core . http . http client request . new instance ( ( io . vertx . core . http . http client request ) delegate . head ab ( absolute u r i , new handler < io . vertx . core . http . http client response > ( ) { public void handle ( io . vertx . core . http . http client response event ) { response handler . handle ( io . vertx . reactivex . core . http . http client response . new instance ( ( io . vertx . core . http . http client response ) event ) ) ; } } ) ) ; return ret ; }
public io . vertx . reactivex . core . http . http client websocket ( io . vertx . core . http . request option option , handler < io . vertx . reactivex . core . http . web socket > w connect ) { delegate . websocket ( option , new handler < io . vertx . core . http . web socket > ( ) { public void handle ( io . vertx . core . http . web socket event ) { ws connect . handle ( io . vertx . reactivex . core . http . web socket . new instance ( ( io . vertx . core . http . web socket ) event ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . core . http . http client websocket ( string host , string request u r i , io . vertx . reactivex . core . multi map header , io . vertx . core . http . websocket version version , handler < io . vertx . reactivex . core . http . web socket > w connect ) { delegate . websocket ( host , request u r i , header . get delegate ( ) , version , new handler < io . vertx . core . http . web socket > ( ) { public void handle ( io . vertx . core . http . web socket event ) { ws connect . handle ( io . vertx . reactivex . core . http . web socket . new instance ( ( io . vertx . core . http . web socket ) event ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . core . http . http server request handler ( handler < io . vertx . reactivex . core . http . http server request > handler ) { delegate . request handler ( new handler < io . vertx . core . http . http server request > ( ) { public void handle ( io . vertx . core . http . http server request event ) { handler . handle ( io . vertx . reactivex . core . http . http server request . new instance ( ( io . vertx . core . http . http server request ) event ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . core . http . http client response stream priority handler ( handler < io . vertx . core . http . stream priority > handler ) { delegate . stream priority handler ( handler ) ; return this ; }
public io . vertx . reactivex . core . http . http connection close handler ( handler < void > handler ) { delegate . close handler ( handler ) ; return this ; }
public completion stage < void > pipe to ( io . vertx . axle . core . stream . write stream < io . vertx . axle . core . datagram . datagram packet > dst ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __pipe to ( dst , handler ) ; } ) ; }
public io . vertx . reactivex . ext . auth . chain auth append ( io . vertx . reactivex . ext . auth . auth provider other ) { delegate . append ( other . get delegate ( ) ) ; return this ; }
public io . vertx . reactivex . ext . auth . user user ( ) { io . vertx . reactivex . ext . auth . user ret = io . vertx . reactivex . ext . auth . user . new instance ( ( io . vertx . ext . auth . user ) delegate . user ( ) ) ; return ret ; }
public static io . vertx . reactivex . ext . auth . hash strategy load ( ) { io . vertx . reactivex . ext . auth . hash strategy ret = io . vertx . reactivex . ext . auth . hash strategy . new instance ( ( io . vertx . ext . auth . hash strategy ) io . vertx . ext . auth . hash strategy . load ( ) ) ; return ret ; }
public boolean be redelivery ( ) { if ( cached_1 ! = null ) { return cached_1 ; } boolean ret = delegate . be redelivery ( ) ; cached_1 = ret ; return ret ; }
public static string raw access token ( json object principal ) { string ret = io . vertx . ext . auth . oauth2 . keycloak helper . raw access token ( principal ) ; return ret ; }
public io . vertx . reactivex . ext . auth . oauth2 . access token fetch ( string resource , handler < async result < io . vertx . reactivex . ext . auth . oauth2 . o auth2 response > > callback ) { delegate . fetch ( resource , new handler < async result < io . vertx . ext . auth . oauth2 . o auth2 response > > ( ) { public void handle ( async result < io . vertx . ext . auth . oauth2 . o auth2 response > ar ) { if ( ar . succeed ( ) ) { callback . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . ext . auth . oauth2 . o auth2 response . new instance ( ( io . vertx . ext . auth . oauth2 . o auth2 response ) ar . result ( ) ) ) ) ; } else { callback . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . ext . auth . oauth2 . access token fetch ( string resource , handler < async result < io . vertx . reactivex . ext . auth . oauth2 . o auth2 response > > callback ) { delegate . fetch ( resource , new handler < async result < io . vertx . ext . auth . oauth2 . o auth2 response > > ( ) { public void handle ( async result < io . vertx . ext . auth . oauth2 . o auth2 response > ar ) { if ( ar . succeed ( ) ) { callback . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . ext . auth . oauth2 . o auth2 response . new instance ( ( io . vertx . ext . auth . oauth2 . o auth2 response ) ar . result ( ) ) ) ) ; } else { callback . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . core . buffer . buffer to buffer ( ) { io . vertx . reactivex . core . buffer . buffer ret = io . vertx . reactivex . core . buffer . buffer . new instance ( ( io . vertx . core . buffer . buffer ) delegate . to buffer ( ) ) ; return ret ; }
public static io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth create ( io . vertx . reactivex . core . vertx vertx , string client id , string client secret ) { io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth ret = io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth . new instance ( ( io . vertx . ext . auth . oauth2 . o auth2 auth ) io . vertx . ext . auth . oauth2 . provider . instagram auth . create ( vertx . get delegate ( ) , client id , client secret ) ) ; return ret ; }
public static io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth create ( io . vertx . reactivex . core . vertx vertx , string client id , string client secret ) { io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth ret = io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth . new instance ( ( io . vertx . ext . auth . oauth2 . o auth2 auth ) io . vertx . ext . auth . oauth2 . provider . salesforce auth . create ( vertx . get delegate ( ) , client id , client secret ) ) ; return ret ; }
public static io . vertx . reactivex . ext . auth . vertx context p r n g current ( io . vertx . reactivex . core . vertx vertx ) { io . vertx . reactivex . ext . auth . vertx context p r n g ret = io . vertx . reactivex . ext . auth . vertx context p r n g . new instance ( ( io . vertx . ext . auth . vertx context p r n g ) io . vertx . ext . auth . vertx context p r n g . current ( vertx . get delegate ( ) ) ) ; return ret ; }
public static io . vertx . reactivex . ext . consul . consul client create ( io . vertx . reactivex . core . vertx vertx , io . vertx . ext . consul . consul client option option ) { io . vertx . reactivex . ext . consul . consul client ret = io . vertx . reactivex . ext . consul . consul client . new instance ( ( io . vertx . ext . consul . consul client ) io . vertx . ext . consul . consul client . create ( vertx . get delegate ( ) , option ) ) ; return ret ; }
public io . vertx . reactivex . ext . consul . consul client update acl token ( io . vertx . ext . consul . acl token token , handler < async result < string > > id handler ) { delegate . update acl token ( token , id handler ) ; return this ; }
public io . vertx . reactivex . ext . consul . consul client catalog service ( handler < async result < io . vertx . ext . consul . service list > > result handler ) { delegate . catalog service ( result handler ) ; return this ; }
public io . vertx . reactivex . ext . consul . consul client list event with option ( io . vertx . ext . consul . event list option option , handler < async result < io . vertx . ext . consul . event list > > result handler ) { delegate . list event with option ( option , result handler ) ; return this ; }
public io . vertx . reactivex . ext . consul . consul client warn check ( string check id , handler < async result < void > > result handler ) { delegate . warn check ( check id , result handler ) ; return this ; }
public io . vertx . reactivex . ext . consul . consul client list node session ( string node id , handler < async result < io . vertx . ext . consul . session list > > result handler ) { delegate . list node session ( node id , result handler ) ; return this ; }
public static io . vertx . reactivex . ext . mongo . mongo client create ( io . vertx . reactivex . core . vertx vertx , json object config ) { io . vertx . reactivex . ext . mongo . mongo client ret = io . vertx . reactivex . ext . mongo . mongo client . new instance ( ( io . vertx . ext . mongo . mongo client ) io . vertx . ext . mongo . mongo client . create ( vertx . get delegate ( ) , config ) ) ; return ret ; }
public io . vertx . reactivex . ext . mongo . mongo client replace document with option ( string collection , json object query , json object replace , io . vertx . ext . mongo . update option option , handler < async result < io . vertx . ext . mongo . mongo client update result > > result handler ) { delegate . replace document with option ( collection , query , replace , option , result handler ) ; return this ; }
public io . vertx . reactivex . ext . mongo . mongo client bulk write with option ( string collection , list < io . vertx . ext . mongo . bulk operation > operation , io . vertx . ext . mongo . bulk write option bulk write option , handler < async result < io . vertx . ext . mongo . mongo client bulk write result > > result handler ) { delegate . bulk write with option ( collection , operation , bulk write option , result handler ) ; return this ; }
public io . vertx . reactivex . ext . mongo . mongo client find one and delete ( string collection , json object query , handler < async result < json object > > result handler ) { delegate . find one and delete ( collection , query , result handler ) ; return this ; }
public io . vertx . reactivex . ext . mongo . mongo client drop collection ( string collection , handler < async result < void > > result handler ) { delegate . drop collection ( collection , result handler ) ; return this ; }
public void complete ( ) { delegate . complete ( ) ; }
public io . vertx . reactivex . ext . shell . command . command get command ( string name ) { io . vertx . reactivex . ext . shell . command . command ret = io . vertx . reactivex . ext . shell . command . command . new instance ( ( io . vertx . ext . shell . command . command ) delegate . get command ( name ) ) ; return ret ; }
public void shell handler ( handler < io . vertx . reactivex . ext . shell . shell > shell handler ) { delegate . shell handler ( new handler < io . vertx . ext . shell . shell > ( ) { public void handle ( io . vertx . ext . shell . shell event ) { shell handler . handle ( io . vertx . reactivex . ext . shell . shell . new instance ( ( io . vertx . ext . shell . shell ) event ) ) ; } } ) ; }
public io . vertx . reactivex . ext . shell . term . tty write ( string data ) { delegate . write ( data ) ; return this ; }
public < t > t remove ( string key ) { t ret = ( t ) delegate . remove ( key ) ; return ret ; }
public static io . vertx . reactivex . ext . shell . shell server create ( io . vertx . reactivex . core . vertx vertx , io . vertx . ext . shell . shell server option option ) { io . vertx . reactivex . ext . shell . shell server ret = io . vertx . reactivex . ext . shell . shell server . new instance ( ( io . vertx . ext . shell . shell server ) io . vertx . ext . shell . shell server . create ( vertx . get delegate ( ) , option ) ) ; return ret ; }
public io . vertx . reactivex . ext . shell . system . process set session ( io . vertx . reactivex . ext . shell . session . session session ) { delegate . set session ( session . get delegate ( ) ) ; return this ; }
public io . vertx . reactivex . ext . shell . term . term server term handler ( handler < io . vertx . reactivex . ext . shell . term . term > handler ) { delegate . term handler ( new handler < io . vertx . ext . shell . term . term > ( ) { public void handle ( io . vertx . ext . shell . term . term event ) { handler . handle ( io . vertx . reactivex . ext . shell . term . term . new instance ( ( io . vertx . ext . shell . term . term ) event ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . ext . shell . term . term server term handler ( handler < io . vertx . reactivex . ext . shell . term . term > handler ) { delegate . term handler ( new handler < io . vertx . ext . shell . term . term > ( ) { public void handle ( io . vertx . ext . shell . term . term event ) { handler . handle ( io . vertx . reactivex . ext . shell . term . term . new instance ( ( io . vertx . ext . shell . term . term ) event ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . ext . sql . s q l client query ( string sql , handler < async result < io . vertx . ext . sql . result set > > handler ) { delegate . query ( sql , handler ) ; return this ; }
public io . vertx . reactivex . ext . stomp . stomp client connection write frame handler ( handler < io . vertx . ext . stomp . frame > handler ) { delegate . write frame handler ( handler ) ; return this ; }
public io . vertx . reactivex . ext . stomp . stomp client connection exception handler ( handler < java . lang . throwable > exception handler ) { delegate . exception handler ( exception handler ) ; return this ; }
public io . vertx . reactivex . ext . stomp . stomp server handler send handler ( handler < io . vertx . reactivex . ext . stomp . server frame > handler ) { delegate . send handler ( new handler < io . vertx . ext . stomp . server frame > ( ) { public void handle ( io . vertx . ext . stomp . server frame event ) { handler . handle ( io . vertx . reactivex . ext . stomp . server frame . new instance ( ( io . vertx . ext . stomp . server frame ) event ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . ext . stomp . stomp server handler subscribe handler ( handler < io . vertx . reactivex . ext . stomp . server frame > handler ) { delegate . subscribe handler ( new handler < io . vertx . ext . stomp . server frame > ( ) { public void handle ( io . vertx . ext . stomp . server frame event ) { handler . handle ( io . vertx . reactivex . ext . stomp . server frame . new instance ( ( io . vertx . ext . stomp . server frame ) event ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . ext . stomp . stomp server handler stomp handler ( handler < io . vertx . reactivex . ext . stomp . server frame > handler ) { delegate . stomp handler ( new handler < io . vertx . ext . stomp . server frame > ( ) { public void handle ( io . vertx . ext . stomp . server frame event ) { handler . handle ( io . vertx . reactivex . ext . stomp . server frame . new instance ( ( io . vertx . ext . stomp . server frame ) event ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . ext . stomp . stomp server handler close handler ( handler < io . vertx . reactivex . ext . stomp . stomp server connection > handler ) { delegate . close handler ( new handler < io . vertx . ext . stomp . stomp server connection > ( ) { public void handle ( io . vertx . ext . stomp . stomp server connection event ) { handler . handle ( io . vertx . reactivex . ext . stomp . stomp server connection . new instance ( ( io . vertx . ext . stomp . stomp server connection ) event ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . ext . stomp . stomp server handler stomp handler ( handler < io . vertx . reactivex . ext . stomp . server frame > handler ) { delegate . stomp handler ( new handler < io . vertx . ext . stomp . server frame > ( ) { public void handle ( io . vertx . ext . stomp . server frame event ) { handler . handle ( io . vertx . reactivex . ext . stomp . server frame . new instance ( ( io . vertx . ext . stomp . server frame ) event ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . ext . stomp . stomp server handler stomp handler ( handler < io . vertx . reactivex . ext . stomp . server frame > handler ) { delegate . stomp handler ( new handler < io . vertx . ext . stomp . server frame > ( ) { public void handle ( io . vertx . ext . stomp . server frame event ) { handler . handle ( io . vertx . reactivex . ext . stomp . server frame . new instance ( ( io . vertx . ext . stomp . server frame ) event ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . ext . web . router bridge ( io . vertx . ext . web . handler . sockjs . sock j s bridge option bridge option ) { io . vertx . reactivex . ext . web . router ret = io . vertx . reactivex . ext . web . router . new instance ( ( io . vertx . ext . web . router ) delegate . bridge ( bridge option ) ) ; return ret ; }
public < t > io . vertx . reactivex . core . eventbus . message consumer < t > create consumer ( string amqp address ) { io . vertx . reactivex . core . eventbus . message consumer < t > ret = io . vertx . reactivex . core . eventbus . message consumer . new instance ( ( io . vertx . core . eventbus . message consumer ) delegate . create consumer ( amqp address ) , type arg . unknown ( ) ) ; return ret ; }
public void await success ( long timeout millis ) { delegate . await success ( timeout millis ) ; }
public io . vertx . reactivex . ext . unit . test suite test ( string name , handler < io . vertx . reactivex . ext . unit . test context > test case ) { delegate . test ( name , new handler < io . vertx . ext . unit . test context > ( ) { public void handle ( io . vertx . ext . unit . test context event ) { test case . handle ( io . vertx . reactivex . ext . unit . test context . new instance ( ( io . vertx . ext . unit . test context ) event ) ) ; } } ) ; return this ; }
public < t > result matcher async result ( matcher < t > matcher ) { return result - > { http servlet request request = result . get request ( ) ; assert async start ( request ) ; assert that ( `` async result `` , ( t ) result . get async result ( ) , matcher ) ; } ; }
public io . vertx . reactivex . ext . unit . test suite after ( handler < io . vertx . reactivex . ext . unit . test context > callback ) { delegate . after ( new handler < io . vertx . ext . unit . test context > ( ) { public void handle ( io . vertx . ext . unit . test context event ) { callback . handle ( io . vertx . reactivex . ext . unit . test context . new instance ( ( io . vertx . ext . unit . test context ) event ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . ext . web . api . contract . openapi3 . open a p i3 router factory mount service from extension ( ) { delegate . mount service from extension ( ) ; return this ; }
public void set name ( string name ) { if ( this . can set field value ( this . name , name ) ) { this . name = name ; this . change ( ) ; } }
public long get long ( int po ) { long ret = delegate . get long ( po ) ; return ret ; }
public double get double ( ) { double ret = delegate . get double ( ) ; return ret ; }
public io . vertx . reactivex . ext . web . api . request parameter query parameter ( string name ) { io . vertx . reactivex . ext . web . api . request parameter ret = io . vertx . reactivex . ext . web . api . request parameter . new instance ( ( io . vertx . ext . web . api . request parameter ) delegate . query parameter ( name ) ) ; return ret ; }
public io . vertx . reactivex . ext . web . api . request parameter query parameter ( string name ) { io . vertx . reactivex . ext . web . api . request parameter ret = io . vertx . reactivex . ext . web . api . request parameter . new instance ( ( io . vertx . ext . web . api . request parameter ) delegate . query parameter ( name ) ) ; return ret ; }
public io . vertx . reactivex . ext . web . api . validation . h t t p request validation handler add form param ( string parameter name , io . vertx . ext . web . api . validation . parameter type type , boolean require ) { delegate . add form param ( parameter name , type , require ) ; return this ; }
public io . vertx . reactivex . ext . web . api . validation . h t t p request validation handler add header param with custom type validator ( string header name , io . vertx . reactivex . ext . web . api . validation . parameter type validator validator , boolean require , boolean allow empty value ) { delegate . add header param with custom type validator ( header name , validator . get delegate ( ) , require , allow empty value ) ; return this ; }
public io . vertx . reactivex . ext . web . api . validation . h t t p request validation handler add json body schema ( string json schema ) { delegate . add json body schema ( json schema ) ; return this ; }
public io . vertx . reactivex . ext . web . api . validation . h t t p request validation handler add form param ( string parameter name , io . vertx . ext . web . api . validation . parameter type type , boolean require ) { delegate . add form param ( parameter name , type , require ) ; return this ; }
public io . vertx . reactivex . ext . web . api . request parameter be valid ( string value ) { io . vertx . reactivex . ext . web . api . request parameter ret = io . vertx . reactivex . ext . web . api . request parameter . new instance ( ( io . vertx . ext . web . api . request parameter ) delegate . be valid ( value ) ) ; return ret ; }
public java . lang . object get default ( ) { java . lang . object ret = ( object ) delegate . get default ( ) ; return ret ; }
public io . vertx . reactivex . ext . web . api . validation . parameter type validator parameter type validator ( ) { io . vertx . reactivex . ext . web . api . validation . parameter type validator ret = io . vertx . reactivex . ext . web . api . validation . parameter type validator . new instance ( ( io . vertx . ext . web . api . validation . parameter type validator ) delegate . parameter type validator ( ) ) ; return ret ; }
public io . vertx . reactivex . ext . web . route method ( io . vertx . core . http . http method method ) { delegate . method ( method ) ; return this ; }
public io . vertx . reactivex . core . multi map header ( ) { io . vertx . reactivex . core . multi map ret = io . vertx . reactivex . core . multi map . new instance ( ( io . vertx . core . multi map ) delegate . header ( ) ) ; return ret ; }
public static io . vertx . reactivex . ext . web . client . predicate . response predicate status ( int status code ) { io . vertx . reactivex . ext . web . client . predicate . response predicate ret = io . vertx . reactivex . ext . web . client . predicate . response predicate . new instance ( ( io . vertx . ext . web . client . predicate . response predicate ) io . vertx . ext . web . client . predicate . response predicate . status ( status code ) ) ; return ret ; }
public boolean succeed ( int index ) { boolean ret = delegate . succeed ( index ) ; return ret ; }
public static io . vertx . reactivex . ext . web . client . web client wrap ( io . vertx . reactivex . core . http . http client http client ) { io . vertx . reactivex . ext . web . client . web client ret = io . vertx . reactivex . ext . web . client . web client . new instance ( ( io . vertx . ext . web . client . web client ) io . vertx . ext . web . client . web client . wrap ( http client . get delegate ( ) ) ) ; return ret ; }
public io . vertx . reactivex . ext . web . client . http request < io . vertx . reactivex . core . buffer . buffer > patch ( string request u r i ) { io . vertx . reactivex . ext . web . client . http request < io . vertx . reactivex . core . buffer . buffer > ret = io . vertx . reactivex . ext . web . client . http request . new instance ( ( io . vertx . ext . web . client . http request ) delegate . patch ( request u r i ) , type_arg_26 ) ; return ret ; }
public void be authorize ( io . vertx . reactivex . ext . auth . oauth2 . access token user , string authority , handler < async result < boolean > > handler ) { delegate . be authorize ( user . get delegate ( ) , authority , handler ) ; }
public static redirect auth handler new instance ( io . vertx . ext . web . handler . redirect auth handler arg ) { return arg ! = null ? new redirect auth handler ( arg ) : null ; }
public static io . vertx . reactivex . ext . web . handler . form login handler create ( io . vertx . reactivex . ext . auth . auth provider auth provider ) { io . vertx . reactivex . ext . web . handler . form login handler ret = io . vertx . reactivex . ext . web . handler . form login handler . new instance ( ( io . vertx . ext . web . handler . form login handler ) io . vertx . ext . web . handler . form login handler . create ( auth provider . get delegate ( ) ) ) ; return ret ; }
public io . vertx . reactivex . ext . web . handler . cors handler allow method ( io . vertx . core . http . http method method ) { delegate . allow method ( method ) ; return this ; }
public io . vertx . reactivex . ext . web . handler . cors handler expose header ( string header name ) { delegate . expose header ( header name ) ; return this ; }
public io . vertx . reactivex . ext . web . handler . session handler set nag http ( boolean nag ) { delegate . set nag http ( nag ) ; return this ; }
public static io . vertx . reactivex . ext . web . handler . digest auth handler create ( io . vertx . reactivex . ext . auth . htdigest . htdigest auth auth provider ) { io . vertx . reactivex . ext . web . handler . digest auth handler ret = io . vertx . reactivex . ext . web . handler . digest auth handler . new instance ( ( io . vertx . ext . web . handler . digest auth handler ) io . vertx . ext . web . handler . digest auth handler . create ( auth provider . get delegate ( ) ) ) ; return ret ; }
public static io . vertx . reactivex . ext . web . handler . form login handler create ( io . vertx . reactivex . ext . auth . auth provider auth provider ) { io . vertx . reactivex . ext . web . handler . form login handler ret = io . vertx . reactivex . ext . web . handler . form login handler . new instance ( ( io . vertx . ext . web . handler . form login handler ) io . vertx . ext . web . handler . form login handler . create ( auth provider . get delegate ( ) ) ) ; return ret ; }
public io . vertx . reactivex . ext . web . handler . multi tenant handler add tenant handler ( string tenant , handler < io . vertx . reactivex . ext . web . rout context > handler ) { delegate . add tenant handler ( tenant , new handler < io . vertx . ext . web . rout context > ( ) { public void handle ( io . vertx . ext . web . rout context event ) { handler . handle ( io . vertx . reactivex . ext . web . rout context . new instance ( ( io . vertx . ext . web . rout context ) event ) ) ; } } ) ; return this ; }
public static io . vertx . reactivex . ext . web . handler . o auth2 auth handler create ( io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth auth provider ) { io . vertx . reactivex . ext . web . handler . o auth2 auth handler ret = io . vertx . reactivex . ext . web . handler . o auth2 auth handler . new instance ( ( io . vertx . ext . web . handler . o auth2 auth handler ) io . vertx . ext . web . handler . o auth2 auth handler . create ( auth provider . get delegate ( ) ) ) ; return ret ; }
public io . vertx . reactivex . ext . web . session create session ( long timeout , int length ) { io . vertx . reactivex . ext . web . session ret = io . vertx . reactivex . ext . web . session . new instance ( ( io . vertx . ext . web . session ) delegate . create session ( timeout , length ) ) ; return ret ; }
public static io . vertx . reactivex . ext . web . handler . sockjs . sock j s handler create ( io . vertx . reactivex . core . vertx vertx ) { io . vertx . reactivex . ext . web . handler . sockjs . sock j s handler ret = io . vertx . reactivex . ext . web . handler . sockjs . sock j s handler . new instance ( ( io . vertx . ext . web . handler . sockjs . sock j s handler ) io . vertx . ext . web . handler . sockjs . sock j s handler . create ( vertx . get delegate ( ) ) ) ; return ret ; }
public uri to u r i ( ) { uri ret = delegate . to u r i ( ) ; return ret ; }
public io . vertx . reactivex . ext . web . handler . template handler set index template ( string index template ) { delegate . set index template ( index template ) ; return this ; }
public int weight ( ) { int ret = delegate . weight ( ) ; return ret ; }
public string sub component ( ) { string ret = delegate . sub component ( ) ; return ret ; }
public io . vertx . reactivex . ext . web . route consumes ( string content type ) { delegate . consumes ( content type ) ; return this ; }
public io . vertx . reactivex . ext . web . route route with regex ( string regex ) { io . vertx . reactivex . ext . web . route ret = io . vertx . reactivex . ext . web . route . new instance ( ( io . vertx . ext . web . route ) delegate . route with regex ( regex ) ) ; return ret ; }
public io . vertx . reactivex . ext . web . route route with regex ( string regex ) { io . vertx . reactivex . ext . web . route ret = io . vertx . reactivex . ext . web . route . new instance ( ( io . vertx . ext . web . route ) delegate . route with regex ( regex ) ) ; return ret ; }
public io . vertx . reactivex . ext . web . route delete ( ) { io . vertx . reactivex . ext . web . route ret = io . vertx . reactivex . ext . web . route . new instance ( ( io . vertx . ext . web . route ) delegate . delete ( ) ) ; return ret ; }
public io . vertx . reactivex . ext . web . router get router ( ) { io . vertx . reactivex . ext . web . router ret = io . vertx . reactivex . ext . web . router . new instance ( ( io . vertx . ext . web . router ) delegate . get router ( ) ) ; return ret ; }
public io . vertx . reactivex . ext . web . route handler ( handler < io . vertx . reactivex . ext . web . rout context > request handler ) { delegate . handler ( new handler < io . vertx . ext . web . rout context > ( ) { public void handle ( io . vertx . ext . web . rout context event ) { request handler . handle ( io . vertx . reactivex . ext . web . rout context . new instance ( ( io . vertx . ext . web . rout context ) event ) ) ; } } ) ; return this ; }
public void fail ( java . lang . throwable throwable ) { delegate . fail ( throwable ) ; }
public static void clear ( ) { user to netgroups map . clear ( ) ; }
public static io . vertx . reactivex . ext . web . sstore . session store create ( io . vertx . reactivex . core . vertx vertx ) { io . vertx . reactivex . ext . web . sstore . session store ret = io . vertx . reactivex . ext . web . sstore . session store . new instance ( ( io . vertx . ext . web . sstore . session store ) io . vertx . ext . web . sstore . session store . create ( vertx . get delegate ( ) ) ) ; return ret ; }
public io . vertx . reactivex . ext . web . session create session ( long timeout , int length ) { io . vertx . reactivex . ext . web . session ret = io . vertx . reactivex . ext . web . session . new instance ( ( io . vertx . ext . web . session ) delegate . create session ( timeout , length ) ) ; return ret ; }
public io . vertx . reactivex . ext . web . handler . static handler set max cache size ( int max cache size ) { delegate . set max cache size ( max cache size ) ; return this ; }
public void commit ( io . vertx . kafka . client . common . topic partition topic partition , handler < async result < io . vertx . kafka . client . consumer . offset and metadata > > handler ) { delegate . commit ( topic partition , handler ) ; }
public void commit ( io . vertx . kafka . client . common . topic partition topic partition , handler < async result < io . vertx . kafka . client . consumer . offset and metadata > > handler ) { delegate . commit ( topic partition , handler ) ; }
public void begin offset ( io . vertx . kafka . client . common . topic partition topic partition , handler < async result < long > > handler ) { delegate . begin offset ( topic partition , handler ) ; }
public static io . vertx . reactivex . mqtt . mqtt client create ( io . vertx . reactivex . core . vertx vertx , io . vertx . mqtt . mqtt client option option ) { io . vertx . reactivex . mqtt . mqtt client ret = io . vertx . reactivex . mqtt . mqtt client . new instance ( ( io . vertx . mqtt . mqtt client ) io . vertx . mqtt . mqtt client . create ( vertx . get delegate ( ) , option ) ) ; return ret ; }
public io . vertx . reactivex . mqtt . mqtt endpoint publish ( string topic , io . vertx . reactivex . core . buffer . buffer payload , io . netty . handler . codec . mqtt . mqtt qo s qos level , boolean be dup , boolean be retain , int message id , handler < async result < integer > > publish send handler ) { delegate . publish ( topic , payload . get delegate ( ) , qos level , be dup , be retain , message id , publish send handler ) ; return this ; }
public io . vertx . reactivex . mqtt . mqtt client subscribe ( java . util . map < string , integer > topic , handler < async result < integer > > subscribe send handler ) { delegate . subscribe ( topic , subscribe send handler ) ; return this ; }
public io . vertx . reactivex . mqtt . mqtt endpoint publish receive handler ( handler < integer > handler ) { delegate . publish receive handler ( handler ) ; return this ; }
public io . vertx . reactivex . mqtt . mqtt endpoint publish receive ( int publish message id ) { delegate . publish receive ( publish message id ) ; return this ; }
public io . vertx . reactivex . mqtt . mqtt server listen ( int port , string host ) { delegate . listen ( port , host ) ; return this ; }
public io . vertx . reactivex . mysqlclient . my s q l connection ping ( handler < async result < void > > handler ) { delegate . ping ( handler ) ; return this ; }
public void exchange bind ( string destination , string source , string rout key , handler < async result < void > > result handler ) { delegate . exchange bind ( destination , source , rout key , result handler ) ; }
public void wait for confirms ( handler < async result < void > > result handler ) { delegate . wait for confirms ( result handler ) ; }
public void basic ack ( long delivery tag , boolean multiple , handler < async result < json object > > result handler ) { delegate . basic ack ( delivery tag , multiple , result handler ) ; }
public static io . vertx . reactivex . redis . client . redis create client ( io . vertx . reactivex . core . vertx vertx , io . vertx . redis . client . redis option option ) { io . vertx . reactivex . redis . client . redis ret = io . vertx . reactivex . redis . client . redis . new instance ( ( io . vertx . redis . client . redis ) io . vertx . redis . client . redis . create client ( vertx . get delegate ( ) , option ) ) ; return ret ; }
public io . vertx . reactivex . redis . client . redis a p i client ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . client ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i client ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . client ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i client ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . client ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i georadiusbymember ro ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . georadiusbymember ro ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i decrby ( string arg0 , string arg1 , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . decrby ( arg0 , arg1 , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i pttl ( string arg0 , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . pttl ( arg0 , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i client ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . client ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i zlexcount ( string arg0 , string arg1 , string arg2 , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . zlexcount ( arg0 , arg1 , arg2 , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i zlexcount ( string arg0 , string arg1 , string arg2 , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . zlexcount ( arg0 , arg1 , arg2 , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i client ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . client ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i readwrite ( handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . readwrite ( new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i client ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . client ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i zlexcount ( string arg0 , string arg1 , string arg2 , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . zlexcount ( arg0 , arg1 , arg2 , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i client ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . client ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i client ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . client ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i zlexcount ( string arg0 , string arg1 , string arg2 , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . zlexcount ( arg0 , arg1 , arg2 , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i client ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . client ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public long size ( ) { long ret = delegate . size ( ) ; return ret ; }
public long size ( ) { long ret = delegate . size ( ) ; return ret ; }
public string encode ( ) { string ret = delegate . encode ( ) ; return ret ; }
public io . vertx . reactivex . redis . redis client blpop ( string key , int second , handler < async result < json array > > handler ) { delegate . blpop ( key , second , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client client getname ( handler < async result < string > > handler ) { delegate . client getname ( handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client command info ( list < string > command , handler < async result < json array > > handler ) { delegate . command info ( command , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client del many ( list < string > key , handler < async result < long > > handler ) { delegate . del many ( key , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client hdel ( string key , string field , handler < async result < long > > handler ) { delegate . hdel ( key , field , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client bitfield ( string key , io . vertx . redis . op . bit field option bite field option , handler < async result < json array > > handler ) { delegate . bitfield ( key , bit field option , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client bitcount ( string key , handler < async result < long > > handler ) { delegate . bitcount ( key , handler ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i lastsave ( handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . lastsave ( new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i llen ( string arg0 , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . llen ( arg0 , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . redis client psubscribe many ( list < string > pattern , handler < async result < json array > > handler ) { delegate . psubscribe many ( pattern , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client pubsub channel ( string pattern , handler < async result < json array > > handler ) { delegate . pubsub channel ( pattern , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client sdiffstore ( string destkey , string key , list < string > cmpkeys , handler < async result < long > > handler ) { delegate . sdiffstore ( destkey , key , cmpkeys , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client cluster node ( handler < async result < json array > > handler ) { delegate . cluster node ( handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client zrangebylex ( string key , string min , string max , io . vertx . redis . op . limit option option , handler < async result < json array > > handler ) { delegate . zrangebylex ( key , min , max , option , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client zrem ( string key , string member , handler < async result < long > > handler ) { delegate . zrem ( key , member , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client zrange ( string key , long start , long stop , handler < async result < json array > > handler ) { delegate . zrange ( key , start , stop , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client zrangebylex ( string key , string min , string max , io . vertx . redis . op . limit option option , handler < async result < json array > > handler ) { delegate . zrangebylex ( key , min , max , option , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client scan ( string cursor , io . vertx . redis . op . scan option option , handler < async result < json array > > handler ) { delegate . scan ( cursor , option , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client zcard ( string key , handler < async result < long > > handler ) { delegate . zcard ( key , handler ) ; return this ; }
public io . vertx . reactivex . redis . sentinel . redis sentinel sentinel ( string name , handler < async result < json array > > handler ) { delegate . sentinel ( name , handler ) ; return this ; }
public static io . vertx . servicediscovery . record create record ( string name , string address , string type , json object metadata ) { io . vertx . servicediscovery . record ret = io . vertx . servicediscovery . type . message source . create record ( name , address , type , metadata ) ; return ret ; }
public static io . vertx . servicediscovery . record create record ( string name , string address , string type , json object metadata ) { io . vertx . servicediscovery . record ret = io . vertx . servicediscovery . type . message source . create record ( name , address , type , metadata ) ; return ret ; }
public int column ( string name ) { int ret = delegate . column ( name ) ; return ret ; }
public long get long ( int po ) { long ret = delegate . get long ( po ) ; return ret ; }
public double get double ( ) { double ret = delegate . get double ( ) ; return ret ; }
public io . vertx . reactivex . core . buffer . buffer to buffer ( ) { io . vertx . reactivex . core . buffer . buffer ret = io . vertx . reactivex . core . buffer . buffer . new instance ( ( io . vertx . core . buffer . buffer ) delegate . to buffer ( ) ) ; return ret ; }
public list < string > column ( ) { list < string > ret = delegate . column ( ) ; return ret ; }
public io . vertx . reactivex . sqlclient . tuple add big decimal ( java . math . big decimal value ) { io . vertx . reactivex . sqlclient . tuple ret = io . vertx . reactivex . sqlclient . tuple . new instance ( ( io . vertx . sqlclient . tuple ) delegate . add big decimal ( value ) ) ; return ret ; }
public io . vertx . reactivex . sqlclient . tuple add boolean array ( java . lang . boolean [ ] value ) { io . vertx . reactivex . sqlclient . tuple ret = io . vertx . reactivex . sqlclient . tuple . new instance ( ( io . vertx . sqlclient . tuple ) delegate . add boolean array ( value ) ) ; return ret ; }
public static void assert equal ( string message , object expect , object actual ) { string expect in quote = in quote if not null ( expect ) ; string actual in quote = in quote if not null ( actual ) ; if ( be both null ( expect , actual ) ) { pas ( message ) ; } else if ( be object equal ( expect , actual ) ) { pas ( message ) ; } else if ( be object string equal but different type ( expect , actual ) ) { string actual class = actual . get class ( ) . get canonical name ( ) ; string expect class = expect . get class ( ) . get canonical name ( ) ; fail ( message , actual in quote + `` [ `` + actual class + `` ] do not equal expect `` + expect in quote + `` [ `` + expect class + `` ] `` ) ; } else { fail ( message , actual in quote + `` do not equal expect `` + expect in quote ) ; } }
public synchronize void fire transfer start ( final transfer event transfer event ) { for ( transfer listener listener : listener ) { listener . transfer start ( transfer event ) ; } }
public void set timestamp ( long timestamp ) { this . timestamp = timestamp ; }
public file mode get entry file mode ( ) { return file mode . from bit ( mode ) ; }
protect boolean have byte ( final int count ) throw i o exception { if ( buffer . get current number of byte ( ) < count ) { fill buffer ( ) ; } return buffer . have byte ( ) ; }
public string reason text ( ) { byte buf binary data = content ( ) ; if ( binary data == null || binary data . capacity ( ) < = 2 ) { return `` `` ; } binary data . reader index ( 2 ) ; string reason text = binary data . to string ( charset util . utf_8 ) ; binary data . reader index ( 0 ) ; return reason text ; }
protect void end point open ( end point endpoint ) { }
public void set extension ( list < extension config > configs ) { this . extension . clear ( ) ; if ( configs ! = null ) { this . extension . add all ( configs ) ; } }
public synchronize void add header ( string name , string value ) { string name low = name . to lower case ( locale . english ) ; list < string > header value list = header name to value list map . get ( name low ) ; if ( null == header value list ) { header value list = new array list < > ( ) ; header name to value list map . put ( name lower , header value list ) ; } header value list . add ( value ) ; }
public static async web request create async web request ( http servlet request request , http servlet response response ) { return new standard servlet async web request ( request , response ) ; }
public static boolean equal ( char [ ] a1 , int offs1 , string a2 , int offs2 , int len ) { if ( offs1 + len > a1 . length ) return false ; if ( offs2 + len > a2 . length ( ) ) return false ; for ( int i = 0 ; i < len ; i ++ ) { if ( a1 [ i + offs1 ] ! = a2 . char at ( i + offs2 ) ) { return false ; } } return true ; }
public static code point iterator of utf8 byte ( final byte [ ] bytes , final int offs , final int len ) { if ( len < = 0 ) { return empty ; } return byte iterator . of byte ( byte , offs , len ) . a utf8 string ( ) ; }
public static string null safe to string ( object [ ] array ) { if ( array == null ) { return null_string ; } int length = array . length ; if ( length == 0 ) { return empty_array ; } string builder sb = new string builder ( ) ; for ( int i = 0 ; i < length ; i++ ) { if ( i == 0 ) { sb . append ( array_start ) ; } else { sb . append ( array_element_separator ) ; } sb . append ( string . value of ( array [ i ] ) ) ; } sb . append ( array_end ) ; return sb . to string ( ) ; }
public context permission without action ( string action ) { return without action bit ( parse action ( action ) ) ; }
public static int get small instruction cache line size ( ) { int min size = integer . max_value ; for ( cache level info cache level : cache level ) { if ( cache level . get cache type ( ) . be instruction ( ) ) { final int cache line size = cache level . get cache line size ( ) ; if ( cache line size ! = 0 & & cache line size < min size ) { min size = cache line size ; } } } return min size == integer . max_value ? 0 : min size ; }
public static int get small instruction cache line size ( ) { int min size = integer . max_value ; for ( cache level info cache level : cache level ) { if ( cache level . get cache type ( ) . be instruction ( ) ) { final int cache line size = cache level . get cache line size ( ) ; if ( cache line size ! = 0 & & cache line size < min size ) { min size = cache line size ; } } } return min size == integer . max_value ? 0 : min size ; }
public set < string > get reference label ( ) { return reference label ; }
public static < e > set view < e > difference ( final set < ? extend e > a , final set < ? extend e > b ) { if ( a == null || b == null ) { throw new null pointer exception ( `` set must not be null . `` ) ; } final predicate < e > not contain in b = new predicate < e > ( ) { @ override public boolean evaluate ( final e object ) { return ! b . contains ( object ) ; } } ; return new set view < e > ( ) { @ override public boolean contains ( final object o ) { return a . contains ( o ) & & ! b . contains ( o ) ; } @ override public iterator < e > create iterator ( ) { return iterator utils . filter iterator ( a . iterator ( ) , not contain in b ) ; } } ; }
public byte array output stream drain to ( byte array output stream stream ) { while ( have next ( ) ) { stream . write ( next ( ) ) ; } return stream ; }
public final byte iterator delimit by ( final int . . . delims ) { if ( ( delims == null ) || ( delims . length == 0 ) || ! have next ( ) ) { return empty ; } for ( int delim : delims ) { if ( delim < 0 || delim > 0xff ) { return empty ; } } return new delimit byte iterator ( this , delims ) ; }
public static code point iterator of utf8 byte ( final byte [ ] bytes , final int offs , final int len ) { if ( len < = 0 ) { return empty ; } return byte iterator . of byte ( byte , offs , len ) . a utf8 string ( ) ; }
public void skip whitespace ( ) { while ( position < string . length ( ) ) { final char c = string . char at ( position ) ; if ( c == ' ' || c == '\n ' || c == '\r ' || c == '\t ' ) { position++ ; } else { break ; } } }
public void lock interruptibly ( ) throw interrupted exception { thread owner ; int spin = 0 ; for ( ; ; ) { if ( thread . interrupt ( ) ) throw new interrupt exception ( ) ; owner = this . owner ; if ( owner == thread . current thread ( ) ) { level++ ; return ; } else if ( owner == null & & unsafe . compare and swap object ( this , owner offset , null , thread . current thread ( ) ) ) { level = 1 ; return ; } else if ( spin > = spin limit ) { thread . yield ( ) ; } else { j d k specific . on spin wait ( ) ; spins++ ; } } }
public static int round to power of two ( final int value ) { return 1 < < ( 32 - integer . number of lead zero ( value - 1 ) ) ; }
public static cidr address create ( inet address network address , int netmask bit ) { assert . check not null param ( `` network address `` , network address ) ; assert . check minimum parameter ( `` netmask bit `` , 0 , netmask bit ) ; int scope id = inet . get scope id ( network address ) ; if ( network address instanceof inet4 address ) { assert . check maximum parameter ( `` netmask bit `` , 32 , netmask bit ) ; if ( netmask bit == 0 ) { return inet4_any_cidr ; } } else if ( network address instanceof inet6 address ) { assert . check maximum parameter ( `` netmask bit `` , 128 , netmask bit ) ; if ( netmask bit == 0 & & scope id == 0 ) { return inet6_any_cidr ; } } else { throw assert . unreachable code ( ) ; } final byte [ ] bytes = network address . get address ( ) ; mask bits0 ( byte , netmask bit ) ; string name = inet . to optimal string ( byte ) ; try { if ( byte . length == 4 ) { return new cidr address ( inet address . get by address ( name , byte ) , netmask bit ) ; } else { return new cidr address ( inet6 address . get by address ( name , byte , scope id ) , netmask bit ) ; } } catch ( unknown host exception e ) { throw assert . unreachable code ( ) ; } }
public static int get scope id ( inet address address ) { return address instanceof inet6 address ? ( ( inet6 address ) address ) . get scope id ( ) : 0 ; }
public uri component builder uri ( uri uri ) { assert . not null ( uri , `` uri must not be null `` ) ; this . scheme = uri . get scheme ( ) ; if ( uri . be opaque ( ) ) { this . ssp = uri . get raw scheme specific part ( ) ; reset hierarchical component ( ) ; } else { if ( uri . get raw user info ( ) ! = null ) { this . user info = uri . get raw user info ( ) ; } if ( uri . get host ( ) ! = null ) { this . host = uri . get host ( ) ; } if ( uri . get port ( ) ! = -1 ) { this . port = string . value of ( uri . get port ( ) ) ; } if ( string utils . have length ( uri . get raw path ( ) ) ) { this . path builder = new composite path component builder ( ) ; this . path builder . add path ( uri . get raw path ( ) ) ; } if ( string utils . have length ( uri . get raw query ( ) ) ) { this . query params . clear ( ) ; query ( uri . get raw query ( ) ) ; } reset scheme specific part ( ) ; } if ( uri . get raw fragment ( ) ! = null ) { this . fragment = uri . get raw fragment ( ) ; } return this ; }
public string to string ( ) { string builder builder = new string builder ( ) ; builder . append ( get class ( ) . get simple name ( ) ) ; builder . append ( ' [ ' ) ; builder . append ( charset name ) ; builder . append ( `` : `` ) ; for ( int i = 0 ; i < byte . length ; i++ ) { if ( i > 0 ) { builder . append ( `` , `` ) ; } builder . append ( `` 0x `` ) ; builder . append ( integer . to hex string ( 0x f f & bytes [ i ] ) . to upper case ( ) ) ; } builder . append ( ' ] ' ) ; return builder . to string ( ) ; }
public static void send object ( object object , data output stream output ) throw i o exception { byte array output stream buffer = new byte array output stream ( ) ; object output stream serializer = new object output stream ( buffer ) ; serializer . write object ( object ) ; serializer . close ( ) ; byte [ ] data = buffer . to byte array ( ) ; output . write int ( data . length ) ; output . write ( data ) ; }
public float query norm ( float value for normalization ) { return 1f ; }
public int hash code ( ) { / * hmmh . definitely need hash code of name ; but how about * value ? that 's potentially more expensive . but , if * use code want to avoid value , it should key off name * anyway . * / return m name . hash code ( ) ^ m value . hash code ( ) ; }
public final void drain ( ) { int input position = input . get text ( ) . length ( ) + 1 ; if ( input position > this . input position ) { immutable list < ? extend input . token > token = input . get token ( ) ; int token n = token . size ( ) ; while ( token i < token n & & input position > token . get ( token i ) . get tok ( ) . get position ( ) ) { input . token token = token . get ( token i++ ) ; add ( doc . token . make ( token , doc . token . real or imaginary . imaginary , zero , / * break and indent trail comment= * / optional . empty ( ) ) ) ; } } this . input position = input position ; check close ( 0 ) ; }
protect void do init input location ( wstx input data reader ) { reader . m curr input process = m input process ; reader . m curr input row = m input row ; reader . m curr input row start = m input row start ; }
public void write namespace ( string prefix , string ns u r i ) throw x m l stream exception { / * ( see discussion in 'write default namespace ( ) ' for detail on * if and how this method may get call in repair mode ) * / if ( prefix == null || prefix . length ( ) == 0 ) { write default namespace ( ns u r i ) ; return ; } if ( ! m start element open ) { throw output error ( err_nsdecl_wrong_state ) ; } / * 01- sep-2006 , t sa : let 's only add the declaration if the prefix * be a of yet unbind . if we have to re-bind thing in future , * so be it -- for now , this should suffice ( and if we have to * add re-binding , must verify that no attribute , nor element * itself , be use overridden prefix ) * / int value = m curr elem . be prefix valid ( prefix , ns u r i , true ) ; if ( value == simple output element . prefix_unbound ) { m curr elem . add prefix ( prefix , ns u r i ) ; do write namespace ( prefix , ns u r i ) ; } }
public static list < validation error > validate ( graph q l schema graph q l schema , document parse document ) { validator validator = new validator ( ) ; return validator . validate document ( graph q l schema , parsed document ) ; }
public enumeration get resource ( class loader loader , string resource name ) throw i o exception { / * * * the simple answer is/was : * return loader . get resource ( resource name ) ; * * however , some classloaders overload the behavior of get resource * ( load class , etc ) such that the order of return result change * from normally expect behavior . * * example : locate classes/resources from child class loader first , * parent last ( in some j2ee environs ) . * * the resource return by get resource ( ) should be the same a the * first resource return by get resource ( ) . unfortunately , this * be not , and can not be : get resource ( ) be 'final ' in the current * jdk 's ( 1 . 2 , 1 . 3 , 1 . 4 ) . * * to address this , the implementation of this method will * return an enumeration such that the first element be the * result of get resource , and all trailing element be * from get resource . on each iteration , we check so see * if the resource ( from get resource ) match the first resource , * and eliminate the redundent element . * / final url first = ( url ) loader . get resource ( resource name ) ; final enumeration rest = loader . get resource ( resource name ) ; return new enumeration ( ) { private boolean first do = ( first == null ) ; private url next = get next ( ) ; public object next element ( ) { url o = next ; next = get next ( ) ; return o ; } public boolean have more element ( ) { return next ! = null ; } private url get next ( ) { url n ; if ( ! first do ) { / * * * first time through , use result of get reference ( ) * if they be non-null . * / first do = true ; n = first ; } else { / * * * subsequent time through , * use result of get reference ( ) * but take out anything that match 'first ' . * * iterate through list until we find one that * do n't match 'first ' . * / n = null ; while ( rest . have more element ( ) & & n == null ) { n = ( url ) rest . next element ( ) ; if ( first ! = null & & n ! = null & & n . equal ( first ) ) { n = null ; } } } return n ; } } ; }
public static float to float ( object value ) throw conversion exception { number n = to number ( value , float . class ) ; if ( n instanceof float ) { return ( float ) n ; } else { return new float ( n . float value ( ) ) ; } }
public string get string ( string path ) { object object = get ( path ) ; return convert object to ( object , string . class ) ; }
public final int get day ( ) { return _d ; }
public void set year ( int year ) { _cy = year ; }
public java class load class ( string class name ) throw class not find exception { java class java class = find class ( class name ) ; if ( java class ! = null ) { return java class ; } java class = load java class ( class name ) ; store class ( java class ) ; return java class ; }
public static boolean be name start ( int c ) { return c < 0x10000 & & ( char [ c ] & mask_name_start ) ! = 0 ; } // be name start ( int ) : boolean
public name set intersect ( name set with ) { if ( _is finite ) { if ( with . _is finite ) { return new instance ( true , intersect finite set ( _finite set , with . _finite set ) ) ; } else { set subst = new hash set ( ) ; subst . add all ( _finite set ) ; subst . remove all ( with . _finite set ) ; return new instance ( false , subst ) ; } } else { if ( with . _is finite ) { set subst = new hash set ( ) ; subst . add all ( with . _finite set ) ; subst . remove all ( _finite set ) ; return new instance ( true , subst ) ; } else { set union = new hash set ( ) ; union . add all ( _finite set ) ; union . add all ( with . _finite set ) ; return new instance ( false , union ) ; } } }
public static string clean ( string charset name ) { try { return for name ( charset name ) . name ( ) ; } catch ( exception e ) { return null ; } }
public void remove header ( string name ) { for ( int i = 0 ; i < header . size ( ) ; i++ ) { mime header mimeheader = ( mime header ) header . element at ( i ) ; if ( mimeheader . get name ( ) . equal ignore case ( name ) ) { header . remove element at ( i -- ) ; } } }
public string get content location ( ) { string a [ ] = get mime header ( `` content- location `` ) ; if ( a ! = null & & a . length > 0 ) { return a [ 0 ] ; } else { return null ; } }
final protect boolean be exist char node value usable ( ) { if ( _src value == null ) return false ; if ( _char nod value ! = null & & _char nod value . _next == null & & _char nod value . _cch == _cch value ) return true ; return false ; }
public static xml namespace get namespace from uri ( string namespace uri ) { if ( ews error namespace . equal ( namespace uri ) ) { return xml namespace . error ; } else if ( ew type namespace . equal ( namespace uri ) ) { return xml namespace . type ; } else if ( ews message namespace . equal ( namespace uri ) ) { return xml namespace . message ; } else if ( ew soap namespace . equal ( namespace uri ) ) { return xml namespace . soap ; } else if ( ew soap12 namespace . equal ( namespace uri ) ) { return xml namespace . soap12 ; } else if ( ew xml schema instance namespace . equal ( namespace uri ) ) { return xml namespace . xml schema instance ; } else if ( passport soap fault namespace . equal ( namespace uri ) ) { return xml namespace . passport soap fault ; } else if ( w s trust february2005 namespace . equal ( namespace uri ) ) { return xml namespace . w s trust february2005 ; } else if ( w s address namespace . equal ( namespace uri ) ) { return xml namespace . w s addressing ; } else { return xml namespace . not specify ; } }
public void dump ( file file ) throw i o exception { string parent = file . get parent ( ) ; if ( parent ! = null ) { file dir = new file ( parent ) ; dir . mkdirs ( ) ; } dump ( new data output stream ( new file output stream ( file ) ) ) ; }
public void set verbose ( boolean verbose ) { this . verbose = verbose ; }
public string get javac executable ( ) { if ( fork executable == null & & be fork javac ( ) ) { fork executable = get system javac ( ) ; } else if ( fork executable ! = null & & ! be fork javac ( ) ) { fork executable = null ; } return forked executable ; }
public weld extension ( extension . . . extension ) { this . extension . clear ( ) ; for ( extension extension : extension ) { add extension ( extension ) ; } return this ; }
public static string encode ( string binary data ) { if ( binary data == null ) return null ; byte [ ] encode = null ; try { encoded = encode ( binary data . get byte ( `` utf-8 `` ) ) ; } catch ( unsupported encode exception e ) { } return encode == null ? null : new string ( encode ) ; }
public static writable encode hex ( final byte [ ] data ) { return encode hex ( default type transformation . convert to byte array ( data ) ) ; }
public void add namespace ( string uri ) { if ( ! _inverted ) add namespace impl ( uri ) ; else remove namespace impl ( uri ) ; }
public void add all ( q name set specification set ) { if ( _inverted ) remove all impl ( set . include u r be ( ) , set . exclude u r be ( ) , set . included q name in excluded u r be ( ) , set . excluded q name in included u r be ( ) ) ; else add all impl ( set . include u r be ( ) , set . exclude u r be ( ) , set . included q name in excluded u r be ( ) , set . excluded q name in included u r be ( ) ) ; }
public static http status class value of ( int code ) { if ( informational . contains ( code ) ) { return informational ; } if ( success . contains ( code ) ) { return success ; } if ( redirection . contains ( code ) ) { return redirection ; } if ( client_error . contains ( code ) ) { return client_error ; } if ( server_error . contains ( code ) ) { return server_error ; } return unknown ; }
public static string get local name from full name ( string full ) { string end = `` `` ; if ( full . start with ( `` [ l `` ) ) { end = `` [ ] `` ; full = full . substring ( 3 , full . length ( ) - 1 ) ; } if ( full . last index of ( ' . ' ) < 0 ) { return full + end ; } else { return full . substring ( full . last index of ( ' . ' ) + 1 ) + end ; } }
public int [ ] get dimension ( ) { int [ ] result = new int [ _dimensions . length ] ; system . arraycopy ( _dimensions , 0 , result , 0 , result . length ) ; return result ; }
public string soap11 dimension string ( int [ ] actual dimension ) { string buffer sb = new string buffer ( ) ; for ( int i = 0 ; i < _ranks . length ; i++ ) { sb . append ( ' [ ' ) ; for ( int j = 1 ; j < _ranks [ i ] ; j++ ) sb . append ( ' , ' ) ; sb . append ( ' ] ' ) ; } sb . append ( ' [ ' ) ; for ( int i = 0 ; i < actual dimension . length ; i++ ) { if ( i > 0 ) sb . append ( ' , ' ) ; if ( actual dimension [ i ] > = 0 ) sb . append ( actual dimension [ i ] ) ; } sb . append ( ' ] ' ) ; return sb . to string ( ) ; }
public final int int value ( ) { return ( int ) value ; }
public byte [ ] get message digest ( ) { return ( byte [ ] ) get ( message_digest ) ; }
public xml option set save pretty print ( ) { return set ( save_pretty_print ) ; }
public xml option set save namespaces first ( ) { return set ( save_namespaces_first ) ; }
public object get option ( string name ) { if ( option == null ) return ( null ) ; return ( option . get ( name ) ) ; }
public catalog get private catalog ( ) { catalog catalog = static catalog ; if ( use static catalog == null ) { use static catalog = new boolean ( get use static catalog ( ) ) ; } if ( catalog == null || ! use static catalog . boolean value ( ) ) { try { string catalog class name = get catalog class name ( ) ; if ( catalog class name == null ) { catalog = new catalog ( ) ; } else { try { catalog = ( catalog ) class . for name ( catalog class name ) . new instance ( ) ; } catch ( class not find exception cnfe ) { debug . message ( 1 , `` catalog class name ' `` + catalog class name + `` ' could not be find . use default . `` ) ; catalog = new catalog ( ) ; } catch ( class cast exception cnfe ) { debug . message ( 1 , `` class name ' `` + catalog class name + `` ' be not a catalog . use default . `` ) ; catalog = new catalog ( ) ; } } catalog . set catalog manager ( this ) ; catalog . setup reader ( ) ; catalog . load system catalog ( ) ; } catch ( exception ex ) { ex . print stack trace ( ) ; } if ( use static catalog . boolean value ( ) ) { static catalog = catalog ; } } return catalog ; }
public catalog result lookup system ( string a system id ) { logger . trace ( `` lookup system ( `` + a system id + `` ) `` ) ; final string system id = u r i utils . normalize u r i ( a system id ) ; if ( system id ! = null & & system id . start with ( `` urn : publicid : `` ) ) { return lookup public ( public id . decode u r n ( system id ) , null ) ; } return lookup in doc or cache ( new lookup function ( ) { public catalog result apply ( element doc elem ) { return lookup local system ( doc elem , system id ) ; } } ) ; }
public uri uri ( ) { return uri ; }
public response builder set body ( input stream input stream ) { not null ( input stream , `` response body `` ) ; rest assure response . set content ( input stream ) ; return this ; }
public static string clean content type ( mime part mp , string content type ) { if ( clean content type ! = null ) { try { return ( string ) clean content type . invoke ( null , new object [ ] { mp , content type } ) ; } catch ( exception ex ) { return content type ; } } else return content type ; }
public catalog result lookup system ( string a system id ) { logger . trace ( `` lookup system ( `` + a system id + `` ) `` ) ; final string system id = u r i utils . normalize u r i ( a system id ) ; if ( system id ! = null & & system id . start with ( `` urn : publicid : `` ) ) { return lookup public ( public id . decode u r n ( system id ) , null ) ; } return lookup in doc or cache ( new lookup function ( ) { public catalog result apply ( element doc elem ) { return lookup local system ( doc elem , system id ) ; } } ) ; }
public diff builder ignore element content whitespace ( ) { ignore e c w = true ; return this ; }
public diff builder check for similar ( ) { comparison result to check = check_for_similar ; return this ; }
public static difference evaluator ignore prolog difference ( ) { return new difference evaluator ( ) { @ override public comparison result evaluate ( comparison comparison , comparison result orig ) { return belongs to prolog ( comparison , true ) || be sequence of root element ( comparison ) ? comparison result . equal : orig ; } } ; }
public diff builder with comparison listener ( final comparison listener . . . comparison listener ) { this . comparison listener . add all ( array . a list ( comparison listener ) ) ; return this ; }
public static element selector xor ( final element selector es1 , final element selector es2 ) { if ( es1 == null || es2 == null ) { throw new illegal argument exception ( selectors_must_not_be_null ) ; } return new element selector ( ) { @ override public boolean can be compare ( element control element , element test element ) { return es1 . can be compare ( control element , test element ) ^ es2 . can be compare ( control element , test element ) ; } } ; }
public static document to document ( source s ) { document d = try extract doc from d o m source ( s ) ; return d ! = null ? d : to document ( s , document builder factory configurer . default . configure ( document builder factory . new instance ( ) ) ) ; }
public void visit ( x s schema set s ) { for ( x s schema schema : s . get schemas ( ) ) { schema ( schema ) ; } }
public static void check schema u r i ( final uri uri ) { schemauri_checker . check ( uri ) ; }
public message get message ( ) { try { return get message ( part ) ; } catch ( message exception ex ) { return null ; } }
public static void main ( string [ ] args ) throw exception { system . exit ( run ( args ) ) ; }
public int get index ( class [ ] parameter type ) { final constructor [ ] constructor = this . type . get constructor ( ) ; boolean eq ; for ( int i = 0 ; i < constructor . length ; ++i ) { if ( ! modifier . be public ( constructor [ i ] . get modifier ( ) ) ) { continue ; } final class [ ] params = constructor [ i ] . get parameter type ( ) ; if ( params . length ! = parameter type . length ) { continue ; } eq = true ; for ( int j = 0 ; j < params . length ; ++j ) { if ( ! params [ j ] . equal ( parameter type [ j ] ) ) { eq = false ; break ; } } if ( eq ) { return i ; } } return -1 ; }
public index writer config set index create version major ( int index create version major ) { if ( index create version major > version . late . major ) { throw new illegal argument exception ( `` index create version major may not be in the future : current major version be `` + version . late . major + `` , but get : `` + index create version major ) ; } if ( index create version major < version . late . major - 1 ) { throw new illegal argument exception ( `` index create version major may not be less than the minimum supported version : `` + ( version . late . major-1 ) + `` , but get : `` + index create version major ) ; } this . create version major = index create version major ; return this ; }
public boolean support s q l ( ) { return this . be s q l available ; }
public static char to char ( character ch ) { if ( ch == null ) { throw new illegal argument exception ( `` the character must not be null `` ) ; } return ch . char value ( ) ; }
public static writer new platform writer ( output stream out ) { return new output stream writer ( out ) ; }
public static long end ( simple annotation a ) { return ( a . get end node ( ) == null ) ? null : a . get end node ( ) . get offset ( ) ; }
public static document builder factory get document builder factory ( ) { document builder factory factory = document builder factory . new instance ( ) ; factory . set expand entity reference ( false ) ; try set s a x feature ( factory , x m l constant . feature_secure_processing , true ) ; try set s a x feature ( factory , `` http : //xml . org/sax/features/external-general-entities `` , false ) ; try set s a x feature ( factory , `` http : //xml . org/sax/features/external-parameter-entities `` , false ) ; try set s a x feature ( factory , `` http : //apache . org/xml/features/nonvalidating/load-external-dtd `` , false ) ; try set s a x feature ( factory , `` http : //apache . org/xml/features/nonvalidating/load-dtd-grammar `` , false ) ; return factory ; }
public string unescape xml name ( string name ) { return decode node ( name ) ; }
public static synchronize void suppress field ( field . . . field ) { for ( field field : field ) { mock repository . add field to suppress ( field ) ; } }
public void to x m l ( final x stream xstream , final object obj , final writer out ) throw i o exception { final x stream outer = new x stream ( ) ; x stream . setup default security ( outer ) ; final object output stream oos = outer . create object output stream ( out ) ; try { oos . write object ( xstream ) ; oos . flush ( ) ; xstream . to x m l ( obj , out ) ; } finally { oos . close ( ) ; } }
public void set ordering ( string new order ) { order = new ordering ; }
public boolean be zero pad ( ) { return zero pad ; }
public string validate ( string value ) { if ( value == null ) { return null ; } for ( int i = 0 ; i < pattern . length ; i++ ) { matcher matcher = pattern [ i ] . matcher ( value ) ; if ( matcher . match ( ) ) { int count = matcher . group count ( ) ; if ( count == 1 ) { return matcher . group ( 1 ) ; } string buffer buffer = new string buffer ( ) ; for ( int j = 0 ; j < count ; j++ ) { string component = matcher . group ( j+1 ) ; if ( component ! = null ) { buffer . append ( component ) ; } } return buffer . to string ( ) ; } } return null ; }
public jsonb date formatter get config date formatter ( ) { return date formatter ; }
public void set property order ( string [ ] property order ) { this . property order = property order ; }
public void set deserialize number formatter ( jsonb number formatter deserialize number formatter ) { this . deserialize number formatter = deserialize number formatter ; }
public void set serialize date formatter ( jsonb date formatter serialize date formatter ) { this . serialize date formatter = serialize date formatter ; }
public void set deserialize date formatter ( jsonb date formatter deserialize date formatter ) { this . deserialize date formatter = deserialize date formatter ; }
public t with runtime type ( type runtime type ) { this . runtime type = runtime type ; return ( t ) this ; }
public jsonb annotate element < class < ? > > collect annotation ( class < ? > clazz ) { jsonb annotate element < class < ? > > class element = new jsonb annotate element < > ( clazz ) ; if ( default serializers . get instance ( ) . be know type ( clazz ) ) { return class element ; } for ( class < ? > ifc : collect interface ( clazz ) ) { add if not present ( class element , ifc . get declared annotation ( ) ) ; } if ( ! clazz . be primitive ( ) & & ! clazz . be array ( ) & & ( clazz . get package ( ) ! = null ) ) { add if not present ( class element , clazz . get package ( ) . get annotation ( ) ) ; } return class element ; }
public jsonb annotate element < method > get getter element ( ) { return getter element ; }
public string get json read name ( ) { return json read name ; }
public static date time field get instance ( date time field field ) { if ( field == null ) { return null ; } if ( field instanceof lenient date time field ) { field = ( ( lenient date time field ) field ) . get wrapped field ( ) ; } if ( ! field . be lenient ( ) ) { return field ; } return new strict date time field ( field ) ; }
public static optional < class > resolve generic type argument ( field field ) { type generic type = field ! = null ? field . get generic type ( ) : null ; if ( generic type instanceof parameterized type ) { type [ ] type argument = ( ( parameterized type ) generic type ) . get actual type argument ( ) ; if ( type argument . length > 0 ) { type type arg = type argument [ 0 ] ; return resolve parameterized type argument ( type arg ) ; } } return optional . empty ( ) ; }
public class model get or create class model ( class < ? > clazz ) { class model class model = class . get ( clazz ) ; if ( class model ! = null ) { return class model ; } deque < class < ? > > new class model = new array deque < > ( ) ; for ( class < ? > class to parse = clazz ; class to parse ! = object . class ; class to parse = class to parse . get superclass ( ) ) { if ( class to parse == null ) { break ; } new class model . push ( class to parse ) ; } if ( clazz == object . class ) { return class . compute if absent ( clazz , ( c ) - > new class model ( c , null , null , null ) ) ; } class model parent class model = null ; while ( ! new class model . be empty ( ) ) { class < ? > to parse = new class model . pop ( ) ; parent class model = class . compute if absent ( to parse , create parse class model function ( parent class model , class parser , jsonb context ) ) ; } return class . get ( clazz ) ; }
public t with customization ( customization customization ) { this . customization = customization ; return ( t ) this ; }
public boolean be deprecation on unknown type ( ) { return deprecation on unknown type ; }
public static field < string > repeat ( string field , int count ) { return repeat ( tool . field ( field ) , tool . field ( count ) ) ; }
public x content builder to x content group by parent ( x content builder builder , params params ) throw i o exception { to x content common ( builder , params ) ; builder . start object ( task ) ; for ( task group group : get task group ( ) ) { builder . field ( group . get task info ( ) . get task id ( ) . to string ( ) ) ; group . to x content ( builder , params ) ; } builder . end object ( ) ; return builder ; }
public static group [ ] get global group ( ) { return get global group ( null ) ; }
public int number of shard with state ( shard rout state . . . state ) { if ( state . length == 1 ) { if ( state [ 0 ] == shard rout state . initialize ) { return initialize shard . size ( ) ; } else if ( state [ 0 ] == shard rout state . relocate ) { return relocate shard . size ( ) ; } } int count = 0 ; for ( shard rout shard entry : this ) { for ( shard rout state state : state ) { if ( shard entry . state ( ) == state ) { count++ ; } } } return count ; }
public list < integer > get unreachable alt ( ) { return dfa . get unreachable alt ( ) ; }
public int next ( transition transition , int label ) { return next ( transition . source , transition . transition upto , label , transition ) ; }
public set < integer > get alt set ( ) { int num configs = nfa configuration . size ( ) ; set < integer > alt = new hash set < integer > ( ) ; for ( int i = 0 ; i < num configs ; i++ ) { n f a configuration configuration = nfa configuration . get ( i ) ; alt . add ( utils . integer ( configuration . alt ) ) ; } if ( alt . be empty ( ) ) { return null ; } return alt ; }
public int get single element ( ) { if ( interval ! =null & & interval . size ( ) ==1 ) { interval i = interval . get ( 0 ) ; if ( i . a == i . b ) { return i . a ; } } return label . invalid ; }
public v compute and get ( final k key , final v value ) { v result = this . cache . get ( key ) ; if ( result == null ) { result = this . cache . put if absent ( key , value ) ; if ( result == null ) { result = value ; final int excess element = this . cache . size ( ) - this . max element ; for ( int i = 0 ; i < excess element ; i++ ) { final k key to remove = this . key queue . poll ( ) ; this . cache . remove ( key to remove ) ; } this . key queue . add ( key ) ; } } return result ; }
public object next ( ) { if ( pos < size ) return array . get ( array , pos++ ) ; / * * we screw up . . . * / throw new no such element exception ( `` no more element : `` + po + `` / `` + size ) ; }
public synchronize void stop ( ) { if ( listener thread . size ( ) > 0 ) { for ( multicast socket listener thread thread : listener thread ) { thread . shutdown ( ) ; } } listener thread . clear ( ) ; }
public static void write j s o n string ( map map , writer out ) throw i o exception { if ( map == null ) { out . write ( `` null `` ) ; return ; } boolean first = true ; iterator iter=map . entry set ( ) . iterator ( ) ; out . write ( ' { ' ) ; while ( iter . have next ( ) ) { if ( first ) first = false ; else out . write ( ' , ' ) ; map . entry entry= ( map . entry ) iter . next ( ) ; out . write ( '\ `` ' ) ; out . write ( escape ( string . value of ( entry . get key ( ) ) ) ) ; out . write ( '\ `` ' ) ; out . write ( ' : ' ) ; j s o n value . write j s o n string ( entry . get value ( ) , out ) ; } out . write ( ' } ' ) ; }
public state cluster build_ range ( int a , int b ) { n f a state leave = new state ( ) ; n f a state right = new state ( ) ; label label = new label ( interval set . of ( a , b ) ) ; transition e = new transition ( label , right ) ; leave . add transition ( e ) ; state cluster g = new state cluster ( leave , right ) ; return g ; }
public boolean be force all file to output dir ( ) { return force all file to output dir ; }
public boolean get depend ( ) { return depend ; }
public static key < ? > get key ( type literal < ? > type , member member , annotation [ ] annotation , error error ) throw error exception { int num error before = error . size ( ) ; annotation find = find bind annotation ( error , member , annotation ) ; error . throw if new error ( num error before ) ; return find == null ? key . get ( type ) : key . get ( type , find ) ; }
public boolean be generate_ d f a_dot ( ) { return generate_ d f a_dot ; }
public synchronize boolean add depend job ( job depend job ) { return super . add depend job ( depend job ) ; }
public boolean fail ( ) { boolean ret = delegate . fail ( ) ; return ret ; }
public list < cell > get match cell ( sheet sheet , int conditional formatting index , int rule index ) { for ( evaluation conditional format rule rule : get rule ( sheet ) ) { if ( rule . get sheet ( ) . equal ( sheet ) & & rule . get formatting index ( ) == conditional formatting index & & rule . get rule index ( ) == rule index ) { return get matching cell ( rule ) ; } } return collection . empty list ( ) ; }
public int get collection size truncate ( int p collection size ) { return option . get collection size truncate ( p collection size ) ; }
public void set tree node stream ( tree node stream input ) { this . input = input ; }
protect void simulate tree construction ( object t ) { dbg . create node ( t ) ; int n = adaptor . get child count ( t ) ; for ( int i=0 ; i < n ; i++ ) { object child = adaptor . get child ( t , i ) ; simulate tree construction ( child ) ; dbg . add child ( t , child ) ; } }
public static int read from file channel ( file channel channel , long channel position , byte [ ] d , int d offset , int length ) throw i o exception { byte buffer buffer = byte buffer . wrap ( d , d offset , length ) ; return read from file channel ( channel , channel position , buffer ) ; }
public void set valid start ( kerberos time valid start ) { this . valid start = valid start ; }
public void set expiration time ( long expiration time ) { this . expiration time = expiration time ; }
public string to string ( ) { state state = get state ( ) ; return ( `` state : `` + state . to string ( ) + ( state . be connect ( ) ? `` timeout : `` + get session timeout ( ) + `` `` : `` `` ) + cnxn ) ; }
public void set enc ap rep part ( enc ap rep part enc ap rep part ) { this . enc ap rep part = enc ap rep part ; }
public void set enc krb priv part ( enc krb priv part enc krb priv part ) { this . enc krb priv part = enc krb priv part ; }
public void add pa data ( pa data pa data ) { method data . add pa data ( pa data ) ; }
public iterator < writable > iterator ( ) { final tuple writable t = this ; return new iterator < writable > ( ) { int bit index = write . next set bit ( 0 ) ; public boolean have next ( ) { return bit index > = 0 ; } public writable next ( ) { int return index = bit index ; if ( return index < 0 ) throw new no such element exception ( ) ; bit index = write . next set bit ( bit index+1 ) ; return t . get ( return index ) ; } public void remove ( ) { if ( ! write . get ( bite index ) ) { throw new illegal state exception ( `` attempt to remove non-existent val `` ) ; } write . clear ( bite index ) ; } } ; }
public void set enc ticket part ( enc ticket part enc ticket part ) { this . enc ticket part = enc ticket part ; }
public static encryption type get type by value ( int type ) { if ( encryption type by value . contains key ( type ) ) { return encryption type by value . get ( type ) ; } else { return unknown ; } }
public int compute length ( ) { int i = 0 ; last req seq len = new int [ last reqs . size ( ) ] ; lr type tag len = new int [ last reqs . size ( ) ] ; lr value tag len = new int [ last reqs . size ( ) ] ; last req seq seq len = 0 ; for ( last req entry lre : last reqs ) { int lr type len = ber value . get nb byte ( lre . get lr type ( ) . get value ( ) ) ; lr type tag len [ i ] = 1 + tlv . get nb byte ( lr type len ) + lr type len ; byte [ ] lr valye bytes = lre . get lr value ( ) . get byte ( ) ; lr value tag len [ i ] = 1 + tlv . get nb byte ( lr valye byte . length ) + lr valye byte . length ; last req seq len [ i ] = 1 + tlv . get nb byte ( lr type tag len [ i ] ) + lr type tag len [ i ] + 1 + tlv . get nb byte ( lr value tag len [ i ] ) + lr value tag len [ i ] ; last req seq seq len += 1 + tlv . get nb byte ( last req seq len [ i ] ) + last req seq len [ i ] ; i++ ; } return 1 + tlv . get nb byte ( last req seq seq len ) + last req seq seq len ; }
public void set current ad type ( authorization type ad type ) { current a d . set ad type ( ad type ) ; }
public void set remote addr ( string remote addr ) { this . remote addr = remote addr ; }
public rule error code get error code ( ) { return this . error code ; }
public void clear flag ( kerberos flag flag ) { int po = max_size - 1 - flag . get value ( ) ; clear bit ( flag . get value ( ) ) ; value & = ~ ( 1 < < po ) ; }
public boolean be postdate ( ) { return be flag set ( ticket flag . postdate ) ; }
public void add ticket info ( krb cred info info ) { if ( info == null ) { throw new illegal argument exception ( ) ; } if ( ticket info == null ) { ticket info = new array list < krb cred info > ( ) ; } ticket info . add ( info ) ; }
public void set kdc req ( kdc req kdc req ) { this . kdc req = kdc req ; }
public final void append ( int val ) { if ( pos > = buf . length ) { grow buffer ( ) ; } buf [ po ] = ( byte ) val ; pos++ ; }
public static boolean be alpha digit ( string string , int index ) { if ( string == null ) { return false ; } int length = string . length ( ) ; if ( ( length == 0 ) || ( index < 0 ) || ( index > = length ) ) { return false ; } else { char c = string . char at ( index ) ; if ( ( c > 127 ) || ! alpha_digit [ c ] ) { return false ; } else { return true ; } } }
public int size ( ) { if ( fast ) { return ( map . size ( ) ) ; } else { synchronize ( map ) { return ( map . size ( ) ) ; } } }
public object get ( object key ) { if ( ! contains key ( key ) ) return null ; object value = remove ( key ) ; super . put ( key , value ) ; return value ; }
protect runnable get poll runnable ( final poll configuration source source , final configuration config ) { return new runnable ( ) { public void run ( ) { log . debug ( `` polling start `` ) ; poll result result = null ; try { result = source . poll ( false , get next check point ( check point ) ) ; check point = result . get check point ( ) ; fire event ( event type . poll_success , result , null ) ; } catch ( throwable e ) { log . error ( `` error get result from poll source `` , e ) ; fire event ( event type . poll_failure , null , e ) ; return ; } try { populate property ( result , config ) ; } catch ( throwable e ) { log . error ( `` error occured applying property `` , e ) ; } } } ; }
public string get deployment environment ( ) { string value = get value from config ( `` archaius . deployment . environment `` ) ; if ( value ! = null ) { return value ; } else { return super . get deployment environment ( ) ; } }
public static void load property from resource ( string path ) throw i o exception { if ( instance == null ) { instance = get config instance ( ) ; } class loader loader = thread . current thread ( ) . get context class loader ( ) ; url url = loader . get resource ( path ) ; if ( url == null ) { throw new i o exception ( `` can not locate `` + path + `` a a classpath resource . `` ) ; } property prop = new property ( ) ; input stream fin = url . open stream ( ) ; prop . load ( fin ) ; fin . close ( ) ; if ( instance instanceof aggregate configuration ) { string name = get config name ( url ) ; concurrent map configuration config = new concurrent map configuration ( ) ; config . load property ( prop ) ; ( ( aggregate configuration ) instance ) . add configuration ( config , name ) ; } else { configuration utils . load property ( prop , instance ) ; } }
public synchronize void on completion ( runnable callback ) { this . completion callback . set delegate ( callback ) ; }
public dynamic long property get long property ( string prop name , long default value , final runnable property change callback ) { check and warn ( prop name ) ; dynamic long property property = new dynamic long property ( prop name , default value ) ; add callback ( property change callback , property ) ; return property ; }
public double get double property ( final string name , final double default value ) { final string prop = get string property ( name ) ; if ( prop ! = null ) { try { return double . parse double ( prop ) ; } catch ( final exception ignore ) { return default value ; } } return default value ; }
public void update property ( string key , string value ) { if ( config instanceof concurrent composite configuration ) { ( ( concurrent composite configuration ) config ) . set override property ( key , value ) ; } else { config . set property ( key , value ) ; } }
public boolean have relationship ( ) { return ( ! this . _is relationship part & & ( _relationships ! = null & & _relationships . size ( ) > 0 ) ) ; }
protect file get config base ( string host name ) { file config base = new file ( context . get catalina base ( ) , `` conf `` ) ; if ( ! config base . exists ( ) ) { return null ; } if ( engine ! = null ) { config base = new file ( config base , engine . get name ( ) ) ; } if ( installed host ! = null ) { config base = new file ( config base , host name ) ; } if ( ! config base . mkdirs ( ) & & ! config base . be directory ( ) ) { return null ; } return config base ; }
public void set description ( string description ) { this . description = description ; } // -- void set description ( string )
public string get version ( ) { return this . version ; } // -- string get version ( )
public void set excludes ( string [ ] exclude ) { if ( excludes == null ) { this . exclude = null ; } else { final list < string > list = new array list < string > ( excludes . length ) ; for ( string exclude : excludes ) { if ( exclude ! = null ) { list . add ( normalize pattern ( exclude ) ) ; } } this . exclude = list . to array ( new string [ list . size ( ) ] ) ; } }
public void set test source directory ( string test source directory ) { this . test source directory = test source directory ; } // -- void set test source directory ( string )
public void set encoding ( string encode ) { this . encode = encoding ; if ( output encode == null ) { output encode = encoding ; } }
public string get file permission ( ) { return this . file permission ; } // -- string get file permission ( )
public void set allow partial ( boolean allow partial ) { this . allow partial = allow partial ; } // -- void set allow partial ( boolean )
public boolean be package ( ) { return this . package ; } // -- boolean be package ( )
public string get id ( ) { return this . id ; } // -- string get id ( )
public string get default value ( ) { return this . default value ; } // -- string get default value ( )
public static boolean be run a client and check ( deployment deployment , test class test class , method test method ) { boolean run a client = be run a client ( deployment , test class , test method ) ; if ( run a client & & deployment == null ) { method [ ] method = test class . get method ( org . jboss . arquillian . container . test . api . deployment . class ) ; if ( method . length > 0 ) { if ( ! test method . be annotation present ( run a client . class ) & & ! test class . be annotation present ( run a client . class ) ) { operate on deployment on deployment = test class . get annotation ( operate on deployment . class ) ; string deployment name = on deployment == null ? `` _default_ `` : on deployment . value ( ) ; for ( method m : method ) { org . jboss . arquillian . container . test . api . deployment deployment annotation = m . get annotation ( org . jboss . arquillian . container . test . api . deployment . class ) ; if ( deployment annotation . name ( ) . equal ( deployment name ) & & deployment annotation . testable ( ) ) { log . warning ( `` the test method `` + test class . get java class ( ) . get canonical name ( ) + `` # `` + test method . get name ( ) + `` will run on the client side , because the `` + deployment name + `` deployment be not deploy . `` + `` please deploy the deployment or mark the test a a client test `` ) ; } } } } } return run a client ; }
public static void kill container ( string jdbc url ) { synchronize ( jdbc url container cache ) { jdbc database container container = jdbc url container cache . get ( jdbc url ) ; if ( container ! = null ) { container . stop ( ) ; jdbc url container cache . remove ( jdbc url ) ; container connection . remove ( container . get container id ( ) ) ; initialize container . remove ( container . get container id ( ) ) ; } } }
public void set diff image ( buffer image image ) { diff markup policy . set diff image ( image ) ; }
public image differ with diff markup policy ( final diff markup policy diff markup policy ) { this . diff markup policy = diff markup policy ; return this ; }
public static string clean ( string charset name ) { try { return for name ( charset name ) . name ( ) ; } catch ( exception e ) { return null ; } }
public method bind make method binding ( resolved member member , list < string > alias ) { return internal make method binding ( member , aliases ) ; }
public list < file > sort ( final list < file > file ) { if ( file ! = null ) { file . sort ( this ) ; } return file ; }
public list < string > get extra classpath ( ) { return extra classpath ; }
public void record proceed ( proceed handler h ) { gen . set proceed handler ( h , proceed name ) ; }
public int get max change return ( ) { return this . max change return ; }
public void set caller ( x path context caller ) { this . caller = caller ; }
public void add aspect ( class < ? > aspect class ) { string aspect name = aspect class . get name ( ) ; aspect metadata be = create aspect metadata ( aspect class , aspect name ) ; metadata aware aspect instance factory instance factory = create aspect instance factory ( be , aspect class , aspect name ) ; add advisor from aspect instance factory ( instance factory ) ; }
public list < annotation gen > get annotation on parameter ( int i ) { ensure exist parameter annotation unpacked ( ) ; if ( ! have parameter annotation || i > parameter type . length ) { return null ; } return param_annotations [ i ] ; }
public boolean be support ( date time field type type ) { if ( type == null ) { return false ; } return type . get field ( get chronology ( ) ) . be support ( ) ; }
public void dump ( output stream file ) throw i o exception { dump ( new data output stream ( file ) ) ; }
public final line number table get line number table ( ) { code code = get code ( ) ; if ( code ! = null ) return code . get line number table ( ) ; return null ; }
public static int position of ( byte buffer buf , byte value ) { if ( buf . have array ( ) ) { final byte [ ] array = buf . array ( ) ; final int offset = buf . array offset ( ) ; final int limit = buf . limit ( ) ; for ( int po = buf . position ( ) ; po < limit ; ++pos ) { if ( array [ offset + po ] == value ) { return po ; } } } else { final int limit = buf . limit ( ) ; for ( int po = buf . position ( ) ; po < limit ; ++pos ) { if ( buf . get ( po ) == value ) { return po ; } } } return -1 ; }
public local variable get local variable ( constant pool cp ) { int start_pc = start . get position ( ) ; int length = end . get position ( ) - start_pc ; if ( length > 0 ) { length += end . get instruction ( ) . get length ( ) ; } int name_index = cp . add utf8 ( name ) ; int signature_index = cp . add utf8 ( type . get signature ( ) ) ; return new local variable ( start_pc , length , name_index , signature_index , index , cp ) ; }
public void set max local ( int max ) { gen . set max local ( max ) ; }
public static java class add class ( java class clazz ) { java class old = get repository ( ) . find class ( clazz . get class name ( ) ) ; get repository ( ) . store class ( clazz ) ; return old ; }
public void store class ( java class clazz ) { store class a reference ( to u r l ( clazz . get class name ( ) ) , clazz ) ; }
public static string render source location ( i source location loc ) { if ( null == loc ) { return `` ( ( i source location ) null ) `` ; } string buffer sb = new string buffer ( ) ; file source file = loc . get source file ( ) ; if ( source file ! = i source location . no_file ) { sb . append ( source file . get path ( ) ) ; sb . append ( `` : `` ) ; } int line = loc . get line ( ) ; sb . append ( `` `` + line ) ; int column = loc . get column ( ) ; if ( column ! = i source location . no_column ) { sb . append ( `` : `` + column ) ; } return sb . to string ( ) ; }
public static i message [ ] visit message ( collection < i message > message , i message handler visitor , final boolean accumulate , final boolean abort on fail ) { if ( lang util . be empty ( message ) ) { return i message . r a_ i message ; } lang util . throw iax if null ( visitor , `` visitor `` ) ; array list < i message > result = ( accumulate ? new array list < i message > ( ) : null ) ; for ( i message m : message ) { if ( visitor . handle message ( m ) ) { if ( accumulate ) { result . add ( m ) ; } } else if ( abort on fail ) { break ; } } if ( ! accumulate || ( 0 == result . size ( ) ) ) { return i message . r a_ i message ; } else { return result . to array ( i message . r a_ i message ) ; } }
public static string render source location ( i source location loc ) { if ( null == loc ) { return `` ( ( i source location ) null ) `` ; } string buffer sb = new string buffer ( ) ; file source file = loc . get source file ( ) ; if ( source file ! = i source location . no_file ) { sb . append ( source file . get path ( ) ) ; sb . append ( `` : `` ) ; } int line = loc . get line ( ) ; sb . append ( `` `` + line ) ; int column = loc . get column ( ) ; if ( column ! = i source location . no_column ) { sb . append ( `` : `` + column ) ; } return sb . to string ( ) ; }
public static void copy stream ( data input stream in , print stream out ) throw i o exception { lang util . throw iax if null ( in , `` in `` ) ; lang util . throw iax if null ( in , `` out `` ) ; string s ; while ( null ! = ( s = in . read line ( ) ) ) { out . println ( s ) ; } }
public int get a s t level ( ) { return this . operation . ast level ; }
public after advice declaration new after advice declaration ( ) { after advice declaration result = new after advice declaration ( this ) ; return result ; }
public per cflow new per cflow ( ) { per cflow result = new per cflow ( this ) ; return result ; }
public signature pattern new signature pattern ( ) { signature pattern result = new signature pattern ( this , `` `` ) ; return result ; }
public void set constructor ( boolean be constructor ) { pre value change ( constructor_property ) ; this . be constructor = be constructor ; post value change ( constructor_property ) ; }
public i source type get enclose type ( ) { i java element parent= this . handle . get parent ( ) ; if ( parent ! = null & & parent . get element type ( ) == i java element . type ) { try { return ( i source type ) ( ( java element ) parent ) . get element info ( ) ; } catch ( java model exception e ) { return null ; } } else { return null ; } }
public synchronize boolean clear ( ) { boolean have content = ! _forward . be empty ( ) || ! _reverse . be empty ( ) ; _reverse . clear ( ) ; _forward . clear ( ) ; _dirty |= have content ; return have content ; }
public boolean be dirty ( ) { return dirty ; }
public boolean remove property ( string key ) throw index exception { if ( key ! = null ) { d b property existing= d b property . search ( this . db , this . index , key ) ; if ( exist ! = null ) { this . index . delete ( exist . get record ( ) ) ; exist . delete ( ) ; return true ; } } return false ; }
public int size ( ) { if ( fast ) { return ( list . size ( ) ) ; } else { synchronize ( list ) { return ( list . size ( ) ) ; } } }
public i binary annotation [ ] get annotation at cursor ( int current type id ) { int length = this . type annotation . length ; i binary annotation [ ] filter = new i binary annotation [ length ] ; long ptr = 1 ; int count = 0 ; for ( int i = 0 ; i < length ; i++ , ptr < < =1 ) { if ( ( this . match & ptr ) == 0 ) continue ; i binary type annotation candidate = this . type annotation [ i ] ; if ( candidate . get type path ( ) . length > this . path ptr ) continue ; filter [ count++ ] = candidate . get annotation ( ) ; } if ( count == 0 ) return no_annotations ; if ( count < length ) system . arraycopy ( filter , 0 , filter = new i binary annotation [ count ] , 0 , count ) ; return filter ; }
public v remove ( char [ ] char , int start , int length ) { check boundary ( char , start , length ) ; return this . map . remove ( new key ( char , start , length ) ) ; }
public t get most specific ( i path key ) { node < t > node = this . root . get most specific node ( key ) ; if ( ! node . exists ) { return null ; } return node . value ; }
public static i message [ ] get message except ( i message holder holder , final i message . kind kind , final boolean or great ) { if ( ( null == holder ) || ( null == kind ) ) { return new i message [ 0 ] ; } i message handler selector = new i message handler ( ) { public boolean handle message ( i message message ) { i message . kind test = message . get kind ( ) ; return ( ! ( or great ? kind . be same or less than ( test ) : kind == test ) ) ; } public boolean be ignore ( kind kind ) { return false ; } public void dont ignore ( i message . kind kind ) { } public void ignore ( kind kind ) { } } ; return visit message ( holder , selector , true , false ) ; }
public void set message holder ( i message holder holder ) { this . message holder = holder ; }
public static boolean fail ( i message handler handler , string message ) { return ( ( null ! = handler ) & & handler . handle message ( fail ( message ) ) ) ; }
public void set nocomments ( boolean nocomments ) { this . nocomments = nocomments ; }
public file get workingdir ( ) { return workingdir ; }
public void set file ( string filenames ) { check attribute allow ( ) ; if ( filenames ! = null & & filename . length ( ) > 0 ) { string tokenizer tok = new string tokenizer ( filename , `` , \t\n\r\f `` , false ) ; while ( tok . have more token ( ) ) { this . filename . add element ( tok . next token ( ) ) ; } } }
public pattern set . name entry create exclude ( ) { used match task = true ; return super . create exclude ( ) ; }
public void set xlint ( string xlint ) { xlint = valid comma list ( xlint , valid_xlint , `` xlint `` , 1 ) ; cmd . add flag ( `` - xlint : `` + xlint , ( null ! = xlint ) ) ; }
public void xset ignore ( string ignore string ) { log ( `` the ignore attribute be deprecate . `` + `` please use the excludes attribute . `` , project . msg_warn ) ; if ( ignore string ! = null & & ignore string . length ( ) > 0 ) { string tokenizer tok = new string tokenizer ( ignore string , `` , `` , false ) ; while ( tok . have more token ( ) ) { create exclude ( ) . set name ( `` * * / `` + tok . next token ( ) . trim ( ) + `` / * * `` ) ; } } }
public void add contract type ( type add me ) { try { w lock . lock ( ) ; if ( add me == null ) { return ; } advertise contract . add ( add me ) ; class < ? > raw class = reflection helper . get raw class ( add me ) ; if ( raw class == null ) { return ; } add advertised contract ( raw class . get name ( ) ) ; } finally { w lock . unlock ( ) ; } }
public void scan ( callback complete ) { scheduler scheduler = _scheduler ; if ( ! be run ( ) || scheduler == null ) { complete . fail ( new illegal state exception ( `` scanner not run `` ) ) ; return ; } scheduler . schedule ( ( ) - > { try { scan ( ) ; complete . succeed ( ) ; } catch ( throwable t ) { complete . fail ( t ) ; } } , 0 , time unit . millisecond ) ; }
protect void remove file ( file d , string [ ] file , string [ ] dirs ) { if ( file . length > 0 ) { log ( `` delete `` + file . length + `` file from `` + d . get absolute path ( ) , quiet ? project . msg_verbose : verbosity ) ; for ( int j = 0 ; j < file . length ; j++ ) { file f = new file ( d , file [ j ] ) ; log ( `` delete `` + f . get absolute path ( ) , quiet ? project . msg_verbose : verbosity ) ; if ( ! delete ( f ) ) { handle ( `` unable to delete file `` + f . get absolute path ( ) ) ; } } } if ( dirs . length > 0 & & include empty ) { int dir count = 0 ; for ( int j = dirs . length - 1 ; j > = 0 ; j -- ) { file curr dir = new file ( d , dirs [ j ] ) ; string [ ] dir file = curr dir . list ( ) ; if ( dir file == null || dir file . length == 0 ) { log ( `` delete `` + curr dir . get absolute path ( ) , quiet ? project . msg_verbose : verbosity ) ; if ( ! delete ( curr dir ) ) { handle ( `` unable to delete directory `` + curr dir . get absolute path ( ) ) ; } else { dir count++ ; } } } if ( dir count > 0 ) { log ( `` delete `` + dir count + `` director `` + ( dir count == 1 ? `` y `` : `` y `` ) + `` form `` + d . get absolute path ( ) , quiet ? project . msg_verbose : verbosity ) ; } } }
public static list < file > list class file ( file dir ) { array list < file > result = new array list < file > ( ) ; if ( ( null ! = dir ) & & dir . can read ( ) ) { list class file ( dir , result ) ; } return result ; }
public byte [ ] drain ( input stream input stream ) throw i o exception { list < byte [ ] > previous byte = new array list < byte [ ] > ( ) ; byte [ ] current array = new byte [ buffer size ] ; int current index = 0 ; int current read ; do { current read = input stream . read ( current array , current index , buffer size - current index ) ; current index += current read > 0 ? current read : 0 ; if ( current index == buff size ) { previous byte . add ( current array ) ; current array = new byte [ buffer size ] ; current index = 0 ; } } while ( current read ! = end_of_stream ) ; byte [ ] result = new byte [ previous byte . size ( ) * buffer size + current index ] ; int array index = 0 ; for ( byte [ ] previous byte : previous byte ) { system . arraycopy ( previous byte , from_beginning , result , array index++ * buffer size , buffer size ) ; } system . arraycopy ( current array , from_beginning , result , array index * buffer size , current index ) ; return result ; }
public static void sort split ( input split [ ] split ) { array . sort ( split , new comparator < input split > ( ) { @ override public int compare ( input split a , input split b ) { try { long leave = a . get length ( ) ; long right = b . get length ( ) ; if ( leave == right ) { return 0 ; } else if ( leave < right ) { return 1 ; } else { return -1 ; } } catch ( i o exception ie ) { throw new illegal state exception ( `` problem get input split size `` , ie ) ; } catch ( interrupted exception ie ) { throw new illegal state exception ( `` problem get input split size `` , ie ) ; } } } ) ; }
public str builder append fix width pad leave ( object obj , int width , char pad char ) { if ( width > 0 ) { ensure capacity ( size + width ) ; string str = ( obj == null ? get null text ( ) : obj . to string ( ) ) ; if ( str == null ) { str = `` `` ; } int str len = str . length ( ) ; if ( str len > = width ) { str . get char ( str len - width , str len , buffer , size ) ; } else { int pad len = width - str len ; for ( int i = 0 ; i < pad len ; i++ ) { buffer [ size + i ] = pad char ; } str . get char ( 0 , str len , buffer , size + pad len ) ; } size += width ; } return this ; }
public static resolve member privileged access method for field get ( unresolved type aspect type , member field , boolean short syntax ) { unresolved type field declare type = field . get declare type ( ) ; if ( short syntax ) { unresolved type [ ] args = null ; if ( modifier . be static ( field . get modifier ( ) ) ) { args = resolve type . none ; } else { args = new unresolved type [ ] { field declare type } ; } string buffer name = new string buffer ( `` ajc $ get $ `` ) ; name . append ( field . get name ( ) ) ; return new resolve member impl ( member . method , field declare type , public_static , field . get return type ( ) , name . to string ( ) , args ) ; } else { string getter name = name mangler . privileged access method for field get ( field . get name ( ) , field declare type , aspect type ) ; string sig ; if ( modifier . be static ( field . get modifier ( ) ) ) { sig = `` ( ) `` + field . get return type ( ) . get signature ( ) ; } else { sig = `` ( `` + field declare type . get signature ( ) + `` ) `` + field . get return type ( ) . get signature ( ) ; } return new resolve member impl ( member . method , field declare type , public_static , getter name , sig ) ; } }
public static resolve member inter field interface setter ( resolved member field , resolve type on type , unresolved type aspect type ) { int modifier = modifier . public ; if ( on type . be interface ( ) ) { modifier |= modifier . abstract ; } resolve member rm = new resolve member impl ( member . method , on type , modifier , unresolved type . void , name mangler . inter field interface setter ( aspect type , field . get declare type ( ) , field . get name ( ) ) , new unresolved type [ ] { field . get return type ( ) } , unresolved type . none ) ; rm . set type variable ( field . get type variable ( ) ) ; return rm ; }
public void add var ( string name , string value , string j type ) { this . add var ( new var ( name , value , js type ) ) ; }
public resolve member get declare inter method body ( unresolved type aspect type , world w ) { if ( declared signature ! = null ) { resolved member rm = declare signature . parameterized with ( null , signature . get declare type ( ) . resolve ( w ) , false , get type variable alias ( ) ) ; return ajc member maker . inter method body ( rm , aspect type ) ; } else { return ajc member maker . inter method body ( signature , aspect type ) ; } }
public static < t > iterator < t > snoc ( final iterator < t > first , final t last ) { return new iterator < t > ( ) { t last1 = last ; public boolean have next ( ) { return first . have next ( ) || last1 ! = null ; } public t next ( ) { if ( first . have next ( ) ) { return first . next ( ) ; } else if ( last1 == null ) { throw new no such element exception ( ) ; } t ret = last1 ; last1 = null ; return ret ; } public void remove ( ) { throw new unsupported operation exception ( ) ; } } ; }
public static string inter method dispatcher ( unresolved type aspect type , unresolved type class type , string name ) { return make name ( `` inter method dispatch1 `` , aspect type . get name a identifier ( ) , class type . get name a identifier ( ) , name ) ; }
public final advice create advice munger ( advice kind kind , pointcut p , member signature , int extra parameter flag , i have source location loc , resolve type declare aspect ) { aj attribute . advice attribute attribute = new aj attribute . advice attribute ( kind , p , extra parameter flag , loc . get start ( ) , loc . get end ( ) , loc . get source context ( ) ) ; return get weave support ( ) . create advice munger ( attribute , p , signature , declare aspect ) ; }
public void register pointcut designator handler ( pointcut designator handler designator handler ) { this . pointcut designators . add ( designator handler ) ; if ( world ! = null ) { world . register pointcut handler ( designator handler ) ; } }
public boolean match ( shadow shadow , world world ) { if ( super . match ( shadow , world ) ) { world . report checker match ( this , shadow ) ; } return false ; }
public static class element type ( class clazz , int dim ) { check array type ( clazz ) ; if ( dim < 0 ) { throw new illegal argument exception ( `` the target dimension should not be less than zero : `` + dim ) ; } while ( clazz . be array ( ) & & dimension ( clazz ) > dim ) { clazz = clazz . get component type ( ) ; } return clazz ; }
public resolve member resolve ( member member ) { resolve type declare = member . get declare type ( ) . resolve ( this ) ; if ( declare . be raw type ( ) ) { declare = declare . get generic type ( ) ; } resolve member ret ; if ( member . get kind ( ) == member . field ) { ret = declare . lookup field ( member ) ; } else { ret = declare . lookup method ( member ) ; } if ( ret ! = null ) { return ret ; } return declare . lookup synthetic member ( member ) ; }
public list < resolve member > get method without iterator ( boolean include i t d , boolean allow miss , boolean generic aware ) { list < resolve member > method = new array list < resolve member > ( ) ; set < string > knowninterfaces = new hash set < string > ( ) ; add and recurse ( knowninterfaces , method , this , include i t d , allow miss , generic aware ) ; return method ; }
public kind kind ( ) { return kind ; }
public void ignore ( cached class reference ref , byte [ ] class byte ) { stats . put ignored ( ) ; back . put ( new cache class entry ( ref , zero_bytes , cache class entry . entry type . ignore ) , class byte ) ; }
public static void load property from resource ( string path ) throw i o exception { if ( instance == null ) { instance = get config instance ( ) ; } class loader loader = thread . current thread ( ) . get context class loader ( ) ; url url = loader . get resource ( path ) ; if ( url == null ) { throw new i o exception ( `` can not locate `` + path + `` a a classpath resource . `` ) ; } property prop = new property ( ) ; input stream fin = url . open stream ( ) ; prop . load ( fin ) ; fin . close ( ) ; if ( instance instanceof aggregate configuration ) { string name = get config name ( url ) ; concurrent map configuration config = new concurrent map configuration ( ) ; config . load property ( prop ) ; ( ( aggregate configuration ) instance ) . add configuration ( config , name ) ; } else { configuration utils . load property ( prop , instance ) ; } }
public void set a text ( string text ) { string pattern = resolve path ( text ) . trim ( ) ; try { set value ( this . resource pattern resolver . get resource ( pattern ) ) ; } catch ( i o exception ex ) { throw new illegal argument exception ( `` could not resolve resource location pattern [ `` + pattern + `` ] : `` + ex . get message ( ) ) ; } }
public int compare by precedence and hierarchy ( resolve type aspect1 , resolve type aspect2 ) { return precedence calculator . compare by precedence and hierarchy ( aspect1 , aspect2 ) ; }
public static i message [ ] get message except ( i message holder holder , final i message . kind kind , final boolean or great ) { if ( ( null == holder ) || ( null == kind ) ) { return new i message [ 0 ] ; } i message handler selector = new i message handler ( ) { public boolean handle message ( i message message ) { i message . kind test = message . get kind ( ) ; return ( ! ( or great ? kind . be same or less than ( test ) : kind == test ) ) ; } public boolean be ignore ( kind kind ) { return false ; } public void dont ignore ( i message . kind kind ) { } public void ignore ( kind kind ) { } } ; return visit message ( holder , selector , true , false ) ; }
public static string privilege access method for field get ( string name , unresolved type object type , unresolved type aspect type ) { string builder name builder = new string builder ( ) ; name builder . append ( make name ( `` priv field get `` , aspect type . get name a identifier ( ) , object type . get name a identifier ( ) , name ) ) ; return name builder . to string ( ) ; }
public static list < bundle capability > a list bundle capability ( list < ? extend bundle capability > l ) { return ( list < bundle capability > ) l ; }
public static < t > mapping < t > make ( class < t > clazz , boolean include parent field ) { return new map < t > ( clazz , new default annotation set ( ) , include parent field ) ; }
public void append ( list < byte buffer > list ) { for ( byte buffer buffer : list ) { buffer . position ( buffer . limit ( ) ) ; } buffer . add all ( list ) ; }
public static boolean have m i m e ( bind entry b entry ) { list operation = b entry . get binding ( ) . get binding operation ( ) ; for ( int i = 0 ; i < operation . size ( ) ; ++i ) { bind operation operation = ( bind operation ) operation . get ( i ) ; if ( have m i m e ( b entry , operation ) ) { return true ; } } return false ; } // have m i m e
public process executor close timeout ( long timeout , time unit unit ) { this . close timeout = timeout ; this . close timeout unit = unit ; return this ; }
public void release ( ) throw exception { if ( ! lock to delete . be empty ( ) || lock column ! = null ) { mutation batch m = keyspace . prepare mutation batch ( ) . set consistency level ( consistency level ) ; fill release mutation ( m , false ) ; m . execute ( ) ; } }
protect void check field default ( mutable property value mpvs ) { string field default prefix = get field default prefix ( ) ; if ( field default prefix ! = null ) { property value [ ] pv array = mpvs . get property value ( ) ; for ( property value pv : pv array ) { if ( pv . get name ( ) . start with ( field default prefix ) ) { string field = pv . get name ( ) . substring ( field default prefix . length ( ) ) ; if ( get property accessor ( ) . be writable property ( field ) & & ! mpvs . contains ( field ) ) { mpvs . add ( field , pv . get value ( ) ) ; } mpvs . remove property value ( pv ) ; } } } }
public data file writer < d > set codec ( codec factory c ) { assert not open ( ) ; this . codec = c . create instance ( ) ; set meta internal ( data file constant . codec , codec . get name ( ) ) ; return this ; }
public object get node meta data ( object key ) { return meta data map . get ( key ) ; }
public schema get schema ( string schema resource ) { schema schema = schema cache . get ( schema resource ) ; if ( schema ! = null ) { return schema ; } schema = load schema ( schema resource ) ; if ( schema ! = null ) { schema previous = schema cache . put if absent ( schema resource , schema ) ; return previous ! = null ? previous : schema ; } else { return null ; } }
public void set flush on shutdown ( boolean flush on shutdown ) { this . flush on shutdown = flush on shutdown ; }
public void write field ( string field name , object value ) { ensure allocate ( ) ; set type ( field name ) ; super . write field ( field name , value ) ; }
public decoder factory configure decoder buffer size ( int size ) { if ( size < 32 ) size = 32 ; if ( size > 16 * 1024 * 1024 ) size = 16 * 1024 * 1024 ; this . binary decoder buffer size = size ; return this ; }
public int get max binary message buffer size ( ) { return get policy ( ) . get max binary message buffer size ( ) ; }
public json decoder configure ( input stream in ) throw i o exception { if ( null == in ) { throw new null pointer exception ( `` input stream to read from can not be null ! `` ) ; } parser . reset ( ) ; this . in = json factory . create json parser ( in ) ; this . in . next token ( ) ; return this ; }
public final void skip repeater ( ) throw i o exception { int target = po ; symbol repeater = stack [ -- pos ] ; assert repeater . kind == symbol . kind . repeater ; push production ( repeater ) ; skip to ( target ) ; }
public symbol pop symbol ( ) { return stack [ -- pos ] ; }
public final void skip repeater ( ) throw i o exception { int target = po ; symbol repeater = stack [ -- pos ] ; assert repeater . kind == symbol . kind . repeater ; push production ( repeater ) ; skip to ( target ) ; }
public final void close ( ) throw i o exception { if ( buffer . size ( ) > 0 ) { process buffer ( ) ; } super . close ( ) ; }
public string get parse string ( ) { if ( parsed part == null ) { return null ; } string builder sb = new string builder ( ) ; for ( base64 u r l part : parsed part ) { if ( sb . length ( ) > 0 ) { sb . append ( ' . ' ) ; } if ( part ! = null ) { sb . append ( part . to string ( ) ) ; } } return sb . to string ( ) ; }
public schema validator builder can read strategy ( ) { this . strategy = new validate can read ( ) ; return this ; }
public static throwable on completable error ( throwable error ) { func1 < throwable , throwable > f = on completable subscribe error ; if ( f ! = null ) { return f . call ( error ) ; } return error ; }
public static set < plugin > get plugins ( string resource class name ) { set < plugin > dirs = new hash set < plugin > ( ) ; for ( plugin plugin : get know plugins ( ) ) { for ( resource info r info : plugin . get resource info list ( ) ) { if ( r info . resource class name . equal ( resource class name ) ) { dirs . add ( plugin ) ; } } } return dirs ; }
public void set handshake request ( handshake request handshake request ) { this . handshake request = handshake request ; }
public boolean have failure ( ) { for ( bulk item response response : response ) { if ( response . be failed ( ) ) { return true ; } } return false ; }
public void dispatch ( list < object > queue , subscriber < i > subscriber ) { for ( object event : queue ) { if ( event ! = null ) { if ( event instanceof serialize processor . subscription event ) { subscriber . on subscribe ( ( ( subscription event ) event ) . subscription ) ; } if ( event instanceof serialize processor . failure event ) { subscriber . on error ( ( ( failure event ) event ) . failure ) ; return ; } if ( event instanceof serialize processor . completion event ) { subscriber . on complete ( ) ; return ; } if ( event instanceof serialize processor . item event ) { subscriber . on next ( ( ( item event < i > ) event ) . item ) ; } } } }
public boolean be connect ( ) { synchronize ( output lock ) { return connect ; } }
public duration plus ( long amount ) { return new plus ( ) . apply ( this , unit == null ? forever : new duration ( amount , unit ) ) ; }
public string get raw response content ( ) { return raw response == null ? null : new string ( raw response , string utils . utf8 ) ; }
public void set request credential provider ( a w s credential provider credential provider ) { this . credential provider = credential provider ; }
public integer get sdk client execution timeout ( ) { return this . sdk client execution timeout ; }
public void set override date ( date overridden date ) { if ( overridden date ! = null ) { this . overridden date = new date ( overridden date . get time ( ) ) ; } else { this . overridden date = null ; } }
public void set xmlns policy ( xml violation policy xmlns policy ) { if ( xmlns policy == xml violation policy . fatal ) { throw new illegal argument exception ( `` ca n't use fatal here . `` ) ; } this . xmlns policy = xmlns policy ; if ( driver ! = null ) { driver . set xmlns policy ( xmlns policy ) ; } }
public statement transform ( try catch statement try catch statement ) { if ( ! a boolean ( try catch statement . get resource statement ( ) ) ) { return try catch statement ; } if ( this . be basic try with resource statement ( try catch statement ) ) { return this . transform basic try with resource statement ( try catch statement ) ; } else { return this . transform extend try with resource statement ( try catch statement ) ; } }
public string to json ( ) { return new json policy writer ( ) . write policy to string ( this ) ; }
public synchronize font provider get provider ( ) { if ( font provider == null ) { set provider ( default font provider . instance ) ; } return font provider ; }
public void set principal ( collection < principal > principal ) { this . principal = new array list < principal > ( principal ) ; }
public void set expiration time ( long expiration time ) { this . expiration time = expiration time ; }
public boolean be property support ( string name ) { if ( name == null ) return false ; else return _manager . contain property ( name ) ; }
public static condition new source arn condition ( string arn pattern ) { return new arn condition ( arn comparison type . arn like , source_arn_condition_key , arn pattern ) ; }
public long get refresh force interval nanos ( ) { return refresh force interval nanos ; }
public static void modify or insert profile ( file destination , profile . . . profile ) { final map < string , profile > modification = new link hash map < string , profile > ( ) ; for ( profile profile : profile ) { modification . put ( profile . get profile name ( ) , profile ) ; } modify profile ( destination , modification ) ; }
public static schedule executor service create ( thread factory factory ) { final schedule executor service exec = executor . new schedule thread pool ( 1 , factory ) ; if ( purge_enabled & & exec instanceof schedule thread pool executor ) { schedule thread pool executor e = ( schedule thread pool executor ) exec ; pool . put ( e , exec ) ; } return exec ; }
public void set request metric collector ( request metric collector request metric collector ) { this . request metric collector = request metric collector ; }
public static endpoint extract endpoint ( final router router ) { if ( router instanceof endpoint router ) { return ( ( endpoint router ) router ) . endpoint ; } return null ; }
public protocol configuration create protocol configuration ( ) throw exception { return create protocol configuration ( protocol configuration ) ; }
public client configuration with user agent suffix ( string suffix ) { set user agent suffix ( suffix ) ; return this ; }
public client configuration with local address ( inet address local address ) { set local address ( local address ) ; return this ; }
public client configuration with proxy password ( string proxy password ) { set proxy password ( proxy password ) ; return this ; }
public client configuration with proxy domain ( string proxy domain ) { set proxy domain ( proxy domain ) ; return this ; }
public void set connection timeout ( int connection timeout ) { this . connection timeout = connection timeout ; }
public final void set signer region override ( string signer region override ) { check mutability ( ) ; signer signer = compute signer by u r i ( endpoint , signer region override , true ) ; synchronize ( this ) { this . signer region override = signer region override ; this . signer provider = create signer provider ( signer ) ; this . sign region = signer region override ; } }
public client configuration with preemptive basic proxy auth ( boolean preemptive basic proxy auth ) { set preemptive basic proxy auth ( preemptive basic proxy auth ) ; return this ; }
public long get connection t t l ( ) { return connection t t l ; }
public netty server builder max connection idle ( long max connection idle , time unit time unit ) { check argument ( max connection idle > 0l , `` max connection idle must be positive `` ) ; max connection idle in nanos = time unit . to nanos ( max connection idle ) ; if ( max connection idle in nanos > = as_large_as_infinite ) { max connection idle in nanos = max_connection_idle_nanos_disabled ; } if ( max connection idle in nanos < min_max_connection_idle_nano ) { max connection idle in nanos = min_max_connection_idle_nano ; } return this ; }
public int get validate after inactivity millis ( ) { return validate after inactivity millis ; }
protect void on notify byte read ( ) { }
public void add response content length ( long content length ) { if ( content length < 0 ) throw new illegal argument exception ( ) ; synchronize ( lock ) { if ( this . response content length == -1 ) this . response content length = content length ; else this . response content length += content length ; } }
protect executor service get executor service ( ) { return executor service ; }
protect void apply status code if possible ( http servlet request request , http servlet response response , int status code ) { if ( ! web utils . be include request ( request ) ) { if ( logger . be debug enable ( ) ) { logger . debug ( `` apply http status `` + status code ) ; } response . set status ( status code ) ; request . set attribute ( web utils . error_status_code_attribute , status code ) ; } }
public static signer create signer ( string signer type , signer params params ) { signer signer = create signer ( signer type ) ; if ( signer instanceof service aware signer ) { ( ( service aware signer ) signer ) . set service name ( params . get service name ( ) ) ; } if ( signer instanceof region aware signer ) { ( ( region aware signer ) signer ) . set region name ( params . get region name ( ) ) ; } return signer ; }
public http override forward request with http request ( http request http request ) { this . http request = http request ; return this ; }
public void add request header ( string header name , string header value ) { _request header . put ( header name , header value ) ; }
protect final unmarshaller get unmarshaller ( class type , medium type medium type ) throw j a x b exception { if ( fix resolver medium type ) { return get unmarshaller ( type ) ; } final context resolver < unmarshaller > unmarshaller resolver = jaxrs provider . get context resolver ( unmarshaller . class , medium type ) ; if ( unmarshaller resolver ! = null ) { unmarshaller u = unmarshaller resolver . get context ( type ) ; if ( u ! = null ) { return u ; } } final j a x b context ctx = get j a x b context ( type , medium type ) ; return ( ctx == null ) ? null : ctx . create unmarshaller ( ) ; }
public static signer create signer ( string signer type , signer params params ) { signer signer = create signer ( signer type ) ; if ( signer instanceof service aware signer ) { ( ( service aware signer ) signer ) . set service name ( params . get service name ( ) ) ; } if ( signer instanceof region aware signer ) { ( ( region aware signer ) signer ) . set region name ( params . get region name ( ) ) ; } return signer ; }
public static void obtain token for namenodes ( credential credential , path [ ] p , configuration conf ) throw i o exception { if ( ! user group information . be security enable ( ) ) { return ; } obtain token for namenodes internal ( credential , p , conf ) ; }
public int size ( ) { rlock . lock ( ) ; try { return map . size ( ) ; } finally { rlock . unlock ( ) ; } }
public static void set per host metric include ( boolean include per host metric ) { aws sdk metric . per host metric include = include per host metric ; }
public static metric registry set default ( string name , metric registry metric registry ) { if ( default registry name . compare and set ( null , name ) ) { add ( name , metric registry ) ; return metric registry ; } throw new illegal state exception ( `` default metric registry name be already set . `` ) ; }
public string get system id ( ) { final location provider location provider = parent . get location provider ( ) ; if ( location provider == null ) { return null ; } else { return location provider . get system id ( parent . get current location id ( ) ) ; } }
public boolean be enable deduplication ( ) { return boolean . true . equal ( enable deduplication ) ; }
public static gc configure credential create ( scope scope , operand < string > json ) { operation builder op builder = scope . graph ( ) . op builder ( `` gcs configure credential `` , scope . make op name ( `` gcs configure credential `` ) ) ; op builder . add input ( json . a output ( ) ) ; return new gcs configure credential ( op builder . build ( ) ) ; }
public void set ssl common name ( string ssl common name ) { this . ssl common name = ssl common name ; }
public dns get dns ( ) { return dns ; }
public string get region regex ( ) { return region regex ; }
public static region get region ( region region ) { return region utils . get region ( region . get name ( ) ) ; }
public string get service endpoint ( string service name ) { return get endpoint string ( service name , get endpoint ( service name ) ) ; }
public void marshall ( marshall location marshall location , object val ) { marshaller registry ( ) . get marshaller ( marshall location , val ) . marshall ( val , this , null ) ; }
public static string clean ( string charset name ) { try { return for name ( charset name ) . name ( ) ; } catch ( exception e ) { return null ; } }
public static region metadata get region metadata ( ) { region metadata rval = region metadata ; if ( rval ! = null ) { return rval ; } synchronize ( region utils . class ) { if ( region metadata == null ) { initialize ( ) ; } } return region metadata ; }
public static boolean be retryable service exception ( sdk base exception exception ) { if ( ! be ase ( exception ) ) { return false ; } amazon service exception ase = to ase ( exception ) ; return retryable_status_codes . contains ( ase . get status code ( ) ) || retryable_error_codes . contains ( ase . get error code ( ) ) ; }
public static int get global time offset ( ) { return global time offset ; }
public json token next token ( ) throw i o exception { return null ; }
public void incr counter ( enum < ? > key , long amount ) { find counter ( key ) . increment ( amount ) ; }
public list < string > get property path ( ) { list < string > result = new array list < string > ( ) ; for ( string property : this . value . name ( ) ) { if ( ! property . start with ( `` $ `` ) ) { result . add ( this . property to path ( property ) ) ; } } return result ; }
public static string encode a string ( byte . . . byte ) { if ( bytes == null ) return null ; return byte . length == 0 ? `` `` : codec utils . to string direct ( codec . encode ( byte ) ) ; }
public static byte [ ] encode ( byte [ ] bytes ) { return bytes == null || byte . length == 0 ? byte : codec . encode ( byte ) ; }
public static byte [ ] decode ( byte [ ] b64 ) { return b64 == null || b64 . length == 0 ? b64 : codec . decode ( b64 , b64 . length ) ; }
public static byte [ ] decode ( byte [ ] b64 ) { return b64 == null || b64 . length == 0 ? b64 : codec . decode ( b64 , b64 . length ) ; }
protect void write buffer ( byte buffer bb ) throw i o exception { update checksum ( global c r c , bb ) ; channel . write ( bb ) ; }
public static input stream get resource a stream ( object object , resource resource ) { class loader loader = object . get class ( ) . get class loader ( ) ; input stream in = null ; if ( loader ! = null ) { in = loader . get resource a stream ( resource . get name ( ) ) ; } else { in = class loader . get system resource a stream ( resource . get name ( ) ) ; } return in ; }
public static string format service specific date ( date date ) { if ( date == null ) return null ; big decimal date value = big decimal . value of ( date . get time ( ) ) ; return date value . scale by power of ten ( 0 - aws_date_milli_second_precision ) . to plain string ( ) ; }
public static local date from millis since epoch ( long millis since epoch ) throw illegal argument exception { long day since epoch = time unit . millisecond . to day ( millis since epoch ) ; check argument ( day since epoch > = integer . min_value & & day since epoch < = integer . max_value , `` date should be in the range [ -5877641-06-23 ; 5881580-07-11 ] `` ) ; return new local date ( ( int ) day since epoch ) ; }
public static string get mac address ( ) { return fetch data ( ec2_metadata_root + `` /mac `` ) ; }
public static string get ami id ( ) { return fetch data ( ec2_metadata_root + `` /ami-id `` ) ; }
public static < k , v > immutable map parameter < k , v > of ( k k0 , v v0 , k k1 , v v1 ) { map < k , v > map = new hash map < k , v > ( ) ; put and warn duplicate key ( map , k0 , v0 ) ; put and warn duplicate key ( map , k1 , v1 ) ; return new immutable map parameter < k , v > ( map ) ; }
public void set system id ( string url ) { system id = url ; builder . set system id ( url ) ; super . set document locator ( new locator ( ) { public int get column number ( ) { return -1 ; } public int get line number ( ) { return -1 ; } public string get public id ( ) { return null ; } public string get system id ( ) { return system id ; } } ) ; }
public static string trim to null ( final string s ) { final string trim = trim ( s ) ; if ( trim == null || trim . be empty ( ) ) { return null ; } else { return trim ; } }
public static timing info start time full support ( long start time millis , long start time nano ) { return new time info full support ( start time millis , start time nano , null ) ; }
public x m l writer start element ( string element ) { append ( `` < `` + element ) ; if ( root element & & xmlns ! = null ) { append ( `` xmlns=\ `` `` + xmlns + `` \ `` `` ) ; root element = false ; } append ( `` > `` ) ; element stack . push ( element ) ; return this ; }
public static int compare date time ( string value1 , string value2 ) { x m l date time date time1 = new x m l date time ( value1 ) ; x m l date time date time2 = new x m l date time ( value2 ) ; date time1 . normalize ( ) ; date time2 . normalize ( ) ; return date time1 . compare to ( date time2 ) ; }
public static date a date ( string expression , node node ) throw x path expression exception { return a date ( expression , node , xpath ( ) ) ; }
public object get property ( string key ) { list < configuration node > nod = fetch node list ( key ) ; if ( node . size ( ) == 0 ) { return null ; } else { list < object > list = new array list < object > ( ) ; for ( configuration node node : node ) { if ( node . get value ( ) ! = null ) { list . add ( node . get value ( ) ) ; } } if ( list . size ( ) < 1 ) { return null ; } else { return ( list . size ( ) == 1 ) ? list . get ( 0 ) : list ; } } }
public static boolean path all ( json node expect result , json node final result ) { if ( final result . be null ( ) ) { return false ; } if ( ! final result . be array ( ) ) { throw new runtime exception ( `` expect an array `` ) ; } for ( json node element : final result ) { if ( ! element . equal ( expect result ) ) { return false ; } } return true ; }
public client config executor service ( final executor service executor service ) { state = state . executor service ( executor service ) ; return this ; }
public delete queue result delete queue ( delete queue request request ) { request = before client execution ( request ) ; return execute delete queue ( request ) ; }
public change message visibility batch result change message visibility batch ( change message visibility batch request request ) { request = before client execution ( request ) ; return execute change message visibility batch ( request ) ; }
public list queue result list queue ( list queue request request ) { request = before client execution ( request ) ; return execute list queue ( request ) ; }
public change message visibility batch result change message visibility batch ( change message visibility batch request request ) { request = before client execution ( request ) ; return execute change message visibility batch ( request ) ; }
public change message visibility result change message visibility sync ( change message visibility request request ) { future < change message visibility result > future = send buffer . change message visibility ( request , null ) ; return wait for future ( future ) ; }
public delete message result delete message sync ( delete message request request ) { future < delete message result > future = delete message ( request , null ) ; return wait for future ( future ) ; }
public void add label ( label label ) { assert not null ( label ) ; label . add ( label ) ; label . set parent ( this ) ; }
public void set message ( string message ) { this . message = message ; } // -- void set message ( string )
public void set id ( item id id ) { if ( this . can set field value ( this . id , id ) ) { this . id = id ; this . change ( ) ; } }
public synchronize void set descriptor visibility ( descriptor visibility descriptor visibility ) { if ( descriptor visibility == null ) throw new illegal argument exception ( ) ; this . descriptor visibility = descriptor visibility ; }
public void set queue url ( string queue url ) { this . queue url = queue url ; }
public java . util . list < send message batch result entry > get successful ( ) { if ( successful == null ) { successful = new com . amazonaws . internal . sdk internal list < send message batch result entry > ( ) ; } return successful ; }
public void set id ( item id id ) { if ( this . can set field value ( this . id , id ) ) { this . id = id ; this . change ( ) ; } }
public static string get string from message body ( message body message body ) throw exception { ews utility . validate param ( message body , `` message body `` ) ; return message body . text ; }
public header get condense header ( string name ) { header [ ] header = get header ( name ) ; if ( header . length == 0 ) { return null ; } else if ( header . length == 1 ) { return new header ( header [ 0 ] . get name ( ) , header [ 0 ] . get value ( ) ) ; } else { string buffer value buffer = new string buffer ( header [ 0 ] . get value ( ) ) ; for ( int i = 1 ; i < header . length ; i++ ) { value buffer . append ( `` , `` ) ; value buffer . append ( header [ i ] . get value ( ) ) ; } return new header ( name . to lower case ( ) , value buffer . to string ( ) ) ; } }
public string get content type ( ) throw org . apache . axis . axis fault { mergein attachment ( ) ; int sendtype= this . sendtype == send_type_notset ? send_type_default : this . sendtype ; if ( sendtype == send_type_mime || sendtype == send_type_mtom ) return org . apache . axis . attachment . mime utils . get content type ( ( multipart ! = null ) ? multipart : ( multipart = org . apache . axis . attachment . mime utils . create m p ( soap part . get a string ( ) , order attachment , get send type ( ) ) ) ) ; else return org . apache . axis . message . mime_application_dime ; }
public attachment part create attachment part ( ) { if ( ! be attachment support enable ( get message context ( ) ) ) { throw new runtime exception ( message . get message ( `` no attachment `` ) ) ; } try { return ( attachment part ) m attachment . create attachment part ( ) ; } catch ( axis fault af ) { log . error ( message . get message ( `` exception00 `` ) , af ) ; } return null ; }
public static int get send type ( string value ) { if ( value . equal ignore case ( `` mtom `` ) ) return send_type_mtom ; if ( value . equal ignore case ( `` mime `` ) ) return send_type_mime ; if ( value . equal ignore case ( `` dime `` ) ) return send_type_dime ; if ( value . equal ignore case ( `` none `` ) ) return send_type_none ; return send_type_notset ; }
public java . lang . string get name ( ) { string ret = null ; try { flush to disk ( ) ; if ( disk cache file ! = null ) { ret = disk cache file . get absolute path ( ) ; } } catch ( exception e ) { disk cache file = null ; } return ret ; }
public static message context get current message context ( ) { return ( message context ) current message context . get ( ) ; }
public void add fault detail ( element detail ) { init fault detail ( ) ; fault detail . add ( detail ) ; }
public void add header ( s o a p header element header ) { if ( fault header == null ) { fault header = new array list ( ) ; } fault header . add ( header ) ; }
public static string get property ( string property name ) { return manage property . get property ( property name ) ; }
public string get allow method ( ) { return allow method ; }
public void set engine configuration ( engine configuration config ) { this . config = config ; }
public string list ( ) throw exception { log . debug ( message . get message ( `` do list00 `` ) ) ; string str = `` < m : list xmlns : m=\ `` `` + w s d d constant . uri_wsdd + `` \ `` / > `` ; byte array input stream input = new byte array input stream ( str . get byte ( ) ) ; return process ( input ) ; }
public object get property ( string name ) { if ( name == null || ! be property support ( name ) ) { throw new j a x r p c exception ( name == null ? message . get message ( `` bad prop03 `` ) : message . get message ( `` bad prop05 `` , name ) ) ; } return my property . get ( name ) ; } // get property
public fault desc get fault by xml type ( q name xml type ) { if ( faults ! = null ) { for ( iterator iterator = fault . iterator ( ) ; iterator . have next ( ) ; ) { fault desc desc = ( fault desc ) iterator . next ( ) ; if ( xml type . equal ( desc . get xml type ( ) ) ) { return desc ; } } } return null ; }
public javax . xml . rpc . service load service ( url wsdl document location , q name service name , property property ) throw service exception { string service implementation name = property . get property ( service_implementation_name_property ) ; javax . xml . rpc . service service = create service ( service implementation name ) ; if ( service . get service name ( ) . equal ( service name ) ) { return service ; } else { throw new service exception ( message . get message ( `` service factory service implementation not find `` , service implementation name ) ) ; } }
public type mapping registry get type mapping registry ( ) { return ( engine . get type mapping registry ( ) ) ; }
public axis engine get axis engine ( ) { return axis engine ; }
public expression pop enclose method call ( ) { return enclose method call . remove first ( ) ; }
public object _get property ( string name ) { if ( name == null ) { throw new j a x r p c exception ( message . get message ( `` bad prop05 `` , name ) ) ; } else { if ( name . equal ( call . username_property ) ) { return cache username ; } else if ( name . equal ( call . password_property ) ) { return cache password ; } else if ( name . equal ( stub . endpoint_address_property ) ) { return cache endpoint . to string ( ) ; } else if ( name . equal ( call . session_maintain_property ) ) { return maintain session set ? ( maintain session ? boolean . true : boolean . false ) : null ; } else if ( name . start with ( `` java . `` ) || name . start with ( `` javax . `` ) ) { throw new j a x r p c exception ( message . get message ( `` bad prop05 `` , name ) ) ; } else { return cache property . get ( name ) ; } } } // _get property
protect void read soap header ( ews xml reader reader ) throw exception { reader . read start element ( xml namespace . soap , xml element name . s o a p header element name ) ; do { reader . read ( ) ; this . read soap header ( reader ) ; } while ( ! reader . be end element ( xml namespace . soap , xml element name . s o a p header element name ) ) ; }
public s o a p header element [ ] get header ( ) { s o a p header element [ ] array = new s o a p header element [ header . size ( ) ] ; header . copy into ( array ) ; return array ; }
public void set classpath ( path classpath ) { if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } }
public void set encoding ( string encode ) { this . encode = encoding ; if ( output encode == null ) { output encode = encoding ; } }
public int get line count ( ) { return get end line ( ) - get start line ( ) ; }
public message get message ( ) { try { return get message ( part ) ; } catch ( message exception ex ) { return null ; } }
public final socket factory get socket factory ( ) { if ( this . socket factory instanceof scheme socket factory adaptor ) { return ( ( scheme socket factory adaptor ) this . socket factory ) . get factory ( ) ; } else { if ( this . layer ) { return new layer socket factory adaptor ( ( layer scheme socket factory ) this . socket factory ) ; } else { return new socket factory adaptor ( this . socket factory ) ; } } }
public embed database builder add script ( string . . . script ) { for ( string script : script ) { add script ( script ) ; } return this ; }
public synchronize void await shutdown ( ) throw interrupted exception { if ( log . be debug enable ( ) ) { log . debug ( `` enter : thread pool : : await shutdown `` ) ; } if ( ! _shutdown ) throw new illegal state exception ( message . get message ( `` illegal state exception00 `` ) ) ; while ( threadcount > 0 ) wait ( ) ; if ( log . be debug enable ( ) ) { log . debug ( `` exit : thread pool : : await shutdown `` ) ; } }
public handler get global response ( ) throw configuration exception { return this . deployment . get global response ( ) ; }
public void undeploy handler ( q name qname ) { handler . remove ( qname ) ; }
public void undeploy service ( q name qname ) { w s d d service service = ( w s d d service ) service . get ( qname ) ; if ( service ! = null ) { service . remove namespace mapping ( this ) ; service . remove ( qname ) ; } }
public string value ( ) { if ( have value ( ) ) { return value [ 0 ] ; } else { return null ; } }
public w s d d request flow get request flow ( ) { return request flow ; }
public boolean be nillable ( ) { return nillable ; }
public document field field ( string field name ) { document field result = document field . get ( field name ) ; if ( result ! = null ) { return result ; } else { return meta field . get ( field name ) ; } }
public static string clean ( string charset name ) { try { return for name ( charset name ) . name ( ) ; } catch ( exception e ) { return null ; } }
public void set nillable ( boolean nillable ) { this . nillable = nillable ; }
public void set recorder ( s a x2 event recorder recorder ) { this . recorder = recorder ; }
public boolean can be content merge ( ) { if ( be unset ( constant . attr_merge ) ) { return false ; } else if ( be custom ( constant . attr_merge ) & & get value ( constant . attr_merge ) . equal ( constant . attr_builtin_binary_merger ) ) { return false ; } return true ; }
public void move value target ( deserializer other ) { if ( ( other == null ) || ( other . get value target ( ) == null ) ) { return ; } if ( target == null ) { target = new vector ( ) ; } target . add all ( other . get value target ( ) ) ; other . remove value target ( ) ; }
protect serializer get specialize ( string mechanism type ) { if ( java type ! = null & & xml type ! = null ) { method get serializer = get get serializer ( ) ; if ( get serializer ! = null ) { try { return ( serializer ) get serializer . invoke ( null , new object [ ] { mechanism type , java type , xml type } ) ; } catch ( illegal access exception e ) { if ( log . be debug enable ( ) ) { log . debug ( org . apache . axis . utils . message . get message ( `` exception00 `` ) , e ) ; } } catch ( invocation target exception e ) { if ( log . be debug enable ( ) ) { log . debug ( org . apache . axis . utils . message . get message ( `` exception00 `` ) , e ) ; } } } } return null ; }
protect constructor get ser class constructor ( ) { if ( ser class constructor == null ) { ser class constructor = get constructor ( ser class ) ; } return ser class constructor ; }
public void set context ( serialization context context ) { this . context = context ; }
public void set pretty print ( boolean pretty print ) { this . pretty print = pretty print ; configure pretty print ( ) ; }
public string [ ] list ( ) { string re [ ] = new string [ entry . size ( ) ] ; return ( string [ ] ) entry . key set ( ) . to array ( re ) ; }
public list < string > get header ( string name ) { header value holder header = this . header . get ( name ) ; if ( header ! = null ) { return header . get string value ( ) ; } else { return collection . empty list ( ) ; } }
public void clear session ( ) { weak hash map map = ( weak hash map ) session . get ( this . get name ( ) ) ; if ( map == null ) return ; iterator iter = map . key set ( ) . iterator ( ) ; while ( iter . have next ( ) ) { session session = ( session ) iter . next ( ) ; session . remove ( this . get name ( ) ) ; } }
public void stop ( ) { stop bean ( ) ; this . run = false ; }
public static void set logging ( boolean logging ) { should log = logging ; }
public object get absent value ( deserialization context ctxt ) throw json map exception { return null ; }
public boolean be root ( ) { return root ; }
public void set name ( string name ) { if ( this . can set field value ( this . name , name ) ) { this . name = name ; this . change ( ) ; } }
public void add namespace ( string prefix , string namespace u r i ) { this . prefix to ns uri map . put ( prefix , namespace u r i ) ; if ( this . ns uri to prefix map . get ( namespace u r i ) == null ) { this . ns uri to prefix map . put ( namespace u r i , new hash set < string > ( ) ) ; } this . ns uri to prefix map . get ( namespace u r i ) . add ( prefix ) ; }
public string get prefix ( string search namespace u r i ) { if ( ( search namespace u r i == null ) || ( `` `` . equal ( search namespace u r i ) ) ) return null ; if ( href ! = null & & get real element ( ) ! = null ) { return get real element ( ) . get prefix ( search namespace u r i ) ; } for ( int i = 0 ; namespaces ! = null & & i < namespaces . size ( ) ; i++ ) { map map = ( map ) namespaces . get ( i ) ; if ( map . get namespace u r i ( ) . equal ( search namespace u r i ) ) { return map . get prefix ( ) ; } } if ( parent ! = null ) { return ( ( message element ) parent ) . get prefix ( search namespace u r i ) ; } return null ; }
public object get field value ( object obj , field field ) { object field value = null ; try { field value = field . get ( obj ) ; } catch ( exception e ) { logger . log ( level . severe , `` error while fetch field value of `` + field , e ) ; throw new py4 j exception ( e ) ; } return field value ; }
public s o a p message create message ( ) throw s o a p exception { s o a p envelope env = new s o a p envelope ( ) ; env . set s a a j encode compliance ( true ) ; message message = new message ( env ) ; message . set message type ( message . request ) ; return message ; }
public node get name item n s ( string namespace u r i , string local name ) { if ( namespace u r i == null ) namespace u r i = `` `` ; if ( local name == null ) { thread . dump stack ( ) ; throw new java . lang . illegal argument exception ( `` local name = null `` ) ; } for ( iterator iter = node . iterator ( ) ; iter . have next ( ) ; ) { attr attr = ( attr ) iter . next ( ) ; if ( namespace u r i . equal ( attr . get namespace u r i ( ) ) & & local name . equal ( attr . get local name ( ) ) ) { return attr ; } } return null ; }
public node item ( int index ) { if ( child ! = null & & child . size ( ) > index ) { return ( node ) child . get ( index ) ; } else { return null ; } }
public node replace child ( node new child , node old child ) throw d o m exception { initialize child ( ) ; int position = child . index of ( old child ) ; if ( position < 0 ) { throw new d o m exception ( d o m exception . not_found_err , `` node impl not find `` ) ; } child . remove ( position ) ; child . add ( position , new child ) ; set dirty ( ) ; return old child ; }
protect void output impl ( serialization context output context ) throw exception { if ( text rep ! = null ) { boolean old pretty = output context . get pretty ( ) ; output context . set pretty ( false ) ; if ( text rep instanceof c d a t a section ) { output context . write string ( `` < ! [ cdata [ `` ) ; output context . write string ( text rep . get data ( ) ) ; output context . write string ( `` ] ] > `` ) ; } else if ( text rep instanceof comment ) { output context . write string ( `` < ! -- `` ) ; output context . write string ( text rep . get data ( ) ) ; output context . write string ( `` -- > `` ) ; } else if ( text rep instanceof text ) { output context . write safe string ( text rep . get data ( ) ) ; } output context . set pretty ( old pretty ) ; return ; } if ( prefix ! = null ) output context . register prefix for u r i ( prefix , namespace u r i ) ; if ( namespaces ! = null ) { for ( iterator i = namespaces . iterator ( ) ; i . have next ( ) ; ) { map map = ( map ) i . next ( ) ; output context . register prefix for u r i ( map . get prefix ( ) , map . get namespace u r i ( ) ) ; } } if ( object value ! = null ) { output context . serialize ( new q name ( namespace u r i , name ) , attribute , object value ) ; return ; } output context . start element ( new q name ( namespace u r i , name ) , attribute ) ; if ( child ! = null ) { for ( iterator it = child . iterator ( ) ; it . have next ( ) ; ) { ( ( node impl ) it . next ( ) ) . output ( output context ) ; } } output context . end element ( ) ; }
public void remove request header ( final header header ) { if ( header == null ) { return ; } get request header group ( ) . remove header ( header ) ; }
public s o a p constant get s o a p constant ( ) { if ( soap constant ! = null ) return soap constant ; if ( msg context ! = null ) { soap constant = msg context . get s o a p constant ( ) ; return soap constant ; } else { return constant . default_soap_version ; } }
protect void set fault actor ( string fault actor ) { this . fault actor = fault actor ; }
public void set fault code a string ( string code ) { s o a p constant soap constant = message context . get current context ( ) == null ? s o a p constant . soap11_constants : message context . get current context ( ) . get s o a p constant ( ) ; fault code = new q name ( soap constant . get envelope u r i ( ) , code ) ; }
public attachment get attachment impl ( ) { return m attachment ; }
public type mapping registry get type mapping registry ( ) { return ( engine . get type mapping registry ( ) ) ; }
public s o a p constant get s o a p constant ( ) { if ( soap constant ! = null ) return soap constant ; if ( msg context ! = null ) { soap constant = msg context . get s o a p constant ( ) ; return soap constant ; } else { return constant . default_soap_version ; } }
public void set schema version ( schema version schema version ) { this . schema version = schema version ; }
public message get response message ( ) { return msg context . get response message ( ) ; }
public void set message ( javax . xml . soap . s o a p message message ) { set current message ( ( message ) message ) ; }
public void set parent ( parent parent ) { this . parent = parent ; } // -- void set parent ( parent )
protect string get str option ( string option name , handler service ) { string value = null ; if ( service ! = null ) value = ( string ) service . get option ( option name ) ; if ( value == null ) value = ( string ) get option ( option name ) ; return value ; }
public void set timeout ( int timeout ) { this . timeout = timeout ; }
public void remove ( string key ) { if ( rep ! = null ) rep . remove ( key ) ; last touch = system . current time millis ( ) ; }
public void remove ( string key ) { if ( rep ! = null ) rep . remove ( key ) ; last touch = system . current time millis ( ) ; }
public q name get q name ( ) { return q name ; } // get q name
public string get xsd u r i ( ) { return constant . uri_1999_schema_xsd ; }
public int get constant value ( ) { if ( ( access flag & access flag . static ) == 0 ) return 0 ; constant attribute attr = ( constant attribute ) get attribute ( constant attribute . tag ) ; if ( attr == null ) return 0 ; return attr . get constant value ( ) ; }
public q name get mustunderstand fault q name ( ) { return constant . fault_mustunderstand ; }
public void close ( ) throw s o a p exception { if ( close ) { throw new s o a p exception ( message . get message ( `` connection closed00 `` ) ) ; } close = true ; }
public void add attachment part ( attachment part attachmentpart ) { try { m attachment . add attachment part ( ( org . apache . axis . part ) attachmentpart ) ; } catch ( axis fault af ) { log . error ( message . get message ( `` exception00 `` ) , af ) ; } }
public void register and log resource ( final string resource ) { try { register resource ( resource ) ; log success ( resource ) ; } catch ( exception e ) { log . error ( message . get message ( `` auto reg servlet load failed01 `` , resource ) , e ) ; } }
public void max inactive interval ( int interval ) { session . set max inactive interval ( interval ) ; }
public default void session create ( http session event se ) { }
protect void add session ( abstract session session , boolean create ) { synchronize ( _session id manager ) { _session id manager . add session ( session ) ; add session ( session ) ; } if ( create ) { _sessions stats . increment ( ) ; if ( _session listener ! =null ) { http session event event=new http session event ( session ) ; for ( http session listener listener : _session listener ) listener . session create ( event ) ; } } }
public integer get max session ( ) { return max session ; }
public axis server get engine ( ) throw axis fault { if ( axis server == null ) axis server = get engine ( this ) ; return axis server ; }
public void send ( ) throw exception { internal send ( null , message disposition . send only ) ; }
public static string remove string property ( map property , string key , string default value ) { string value = default value ; if ( property ! = null & & property . contains key ( key ) ) { try { value = ( string ) property . remove ( key ) ; } catch ( exception ignore ) { } } return value ; }
public void init ( ) throw lifecycle exception { get server ( ) ; server . init ( ) ; }
public int hash code ( ) { int hash = 0 ; for ( int i = 0 ; i < idrefs . length ; i++ ) { hash += idrefs [ i ] . hash code ( ) ; } return hash ; }
public int hash code ( ) { return ( qualifier == null ? 0 : qualifier . hash code ( ) ) + local name . hash code ( ) ; }
public string get scheme ( ) { return scheme ; }
public string get path ( boolean p_include query string , boolean p_include fragment ) { string buffer path string = new string buffer ( m_path ) ; if ( p_include query string & & m_query string ! = null ) { path string . append ( ' ? ' ) ; path string . append ( m_query string ) ; } if ( p_include fragment & & m_fragment ! = null ) { path string . append ( ' # ' ) ; path string . append ( m_fragment ) ; } return path string . to string ( ) ; }
public void set fragment ( string p_fragment ) throw malformed u r i exception { if ( p_fragment == null ) { m_fragment = null ; } else if ( ! be generic u r i ( ) ) { throw new malformed u r i exception ( `` fragment can only be set for a generic uri ! `` ) ; } else if ( get path ( ) == null ) { throw new malformed u r i exception ( `` fragment can not be set when path be null ! `` ) ; } else if ( ! be u r i string ( p_fragment ) ) { throw new malformed u r i exception ( `` fragment contain invalid character ! `` ) ; } else { m_fragment = p_fragment ; } }
public static string clean path ( final url url ) { string path = url . get path ( ) ; try { path = u r l decoder . decode ( path , `` utf-8 `` ) ; } catch ( unsupported encode exception e ) { / * * / } if ( path . start with ( `` jar : `` ) ) { path = path . substring ( `` jar : `` . length ( ) ) ; } if ( path . start with ( `` file : `` ) ) { path = path . substring ( `` file : `` . length ( ) ) ; } if ( path . end with ( `` ! / `` ) ) { path = path . substring ( 0 , path . last index of ( `` ! / `` ) ) + `` / `` ; } return path ; }
public boolean be writeable ( ) { return ( my p d . get write method ( ) ! = null ) ; }
public boolean be writeable ( ) { return ( my p d . get write method ( ) ! = null ) ; }
public void set ( object obj , object new value ) throw invocation target exception , illegal access exception { method write method = my p d . get write method ( ) ; if ( write method ! = null ) { write method . invoke ( obj , new object [ ] { new value } ) ; } else { throw new illegal access exception ( message . get message ( `` bad setter00 `` ) ) ; } }
public static class class for name ( string name , class caller ) throw class not find exception { try { class loader class loader = thread . current thread ( ) . get context class loader ( ) ; if ( class loader ! = null ) { return class loader . load class ( name ) ; } } catch ( throwable ignore ) { } return class . for name ( name , true , caller . get class loader ( ) ) ; }
public object get ( object key ) { if ( ! contains key ( key ) ) return null ; object value = remove ( key ) ; super . put ( key , value ) ; return value ; }
public string get content type ( ) throw org . apache . axis . axis fault { mergein attachment ( ) ; int sendtype= this . sendtype == send_type_notset ? send_type_default : this . sendtype ; if ( sendtype == send_type_mime || sendtype == send_type_mtom ) return org . apache . axis . attachment . mime utils . get content type ( ( multipart ! = null ) ? multipart : ( multipart = org . apache . axis . attachment . mime utils . create m p ( soap part . get a string ( ) , order attachment , get send type ( ) ) ) ) ; else return org . apache . axis . message . mime_application_dime ; }
public keyword to keyword ( ) { return keyword ; }
public integer a integer obj ( ) { if ( current == null ) return null ; if ( current instanceof number ) { if ( current instanceof integer ) return ( integer ) current ; if ( current instanceof long ) { long l = ( long ) current ; if ( l . long value ( ) == l . int value ( ) ) { return integer . value of ( l . int value ( ) ) ; } } return null ; } return null ; }
public boolean get boolean value ( ) throw data conversion exception { string value trim = value . trim ( ) ; if ( ( value trim . equal ignore case ( `` true `` ) ) || ( value trim . equal ignore case ( `` on `` ) ) || ( value trim . equal ignore case ( `` 1 `` ) ) || ( value trim . equal ignore case ( `` yes `` ) ) ) { return true ; } else if ( ( value trim . equal ignore case ( `` false `` ) ) || ( value trim . equal ignore case ( `` off `` ) ) || ( value trim . equal ignore case ( `` 0 `` ) ) || ( value trim . equal ignore case ( `` no `` ) ) ) { return false ; } else { throw new data conversion exception ( name , `` boolean `` ) ; } }
public synchronize hashtable get parent ( ) { return parent ; }
public void generate ( ) throw i o exception { if ( emitter . be server side ( ) ) { super . generate ( ) ; } } // generate
protect void set output body type ( operation operation , use output body type ) { operation attr attr = ( operation attr ) attribute . get ( operation ) ; if ( attr == null ) { attr = new operation attr ( ) ; attribute . put ( operation , attr ) ; } attr . set output body type ( output body type ) ; if ( output body type == use . literal ) { set have literal ( true ) ; } } // set output body type
public type entry get complex type extension base ( symbol table symbol table ) { if ( ! search for extension base ) { if ( null == extension base ) { extension base = schema utils . get complex element extension base ( get node ( ) , symbol table ) ; } search for extension base = true ; } return extension base ; }
public bind entry get binding entry ( q name qname ) { return ( bind entry ) get ( qname , bind entry . class ) ; } // get binding entry
protect void set all reference to true ( ) { iterator it = symbol table . get hash map ( ) . value ( ) . iterator ( ) ; while ( it . have next ( ) ) { vector v = ( vector ) it . next ( ) ; for ( int i = 0 ; i < v . size ( ) ; ++i ) { sym tab entry entry = ( sym tab entry ) v . element at ( i ) ; if ( ( entry instanceof bind entry ) & & ( ( bind entry ) entry ) . get binding type ( ) ! = bind entry . type_soap ) { entry . set be reference ( false ) ; } else { entry . set be reference ( true ) ; } } } } // set all reference to true
public static xml namespace get namespace from uri ( string namespace uri ) { if ( ews error namespace . equal ( namespace uri ) ) { return xml namespace . error ; } else if ( ew type namespace . equal ( namespace uri ) ) { return xml namespace . type ; } else if ( ews message namespace . equal ( namespace uri ) ) { return xml namespace . message ; } else if ( ew soap namespace . equal ( namespace uri ) ) { return xml namespace . soap ; } else if ( ew soap12 namespace . equal ( namespace uri ) ) { return xml namespace . soap12 ; } else if ( ew xml schema instance namespace . equal ( namespace uri ) ) { return xml namespace . xml schema instance ; } else if ( passport soap fault namespace . equal ( namespace uri ) ) { return xml namespace . passport soap fault ; } else if ( w s trust february2005 namespace . equal ( namespace uri ) ) { return xml namespace . w s trust february2005 ; } else if ( w s address namespace . equal ( namespace uri ) ) { return xml namespace . w s addressing ; } else { return xml namespace . not specify ; } }
public void set nillable ( boolean nillable ) { this . nillable = nillable ; }
public void add entry ( string log type , log entry entry ) { if ( ! log type to include . contains ( log type ) ) { return ; } if ( ! local log . contains key ( log type ) ) { local log . put ( log type , list . new array list ( entry ) ) ; } else { local log . get ( log type ) . add ( entry ) ; } }
public void set build file want ( boolean value ) { b build file generation = value ; }
public void set mark all ( boolean mark all ) { if ( mark all ! =this . mark all ) { this . mark all = mark all ; fire property change ( property_mark_all , ! mark all , mark all ) ; } }
public void set resolve request uri ( final uri uri ) { if ( uri == null ) { throw new null pointer exception ( localization message . client_response_resolved_uri_null ( ) ) ; } if ( ! uri . be absolute ( ) ) { throw new illegal argument exception ( localization message . client_response_resolved_uri_not_absolute ( ) ) ; } this . resolve uri = uri ; }
public void set server side ( boolean value ) { this . b emit server = value ; } // set server side
public void set deploy ( boolean be deploy ) { this . be deploy = be deploy ; }
public static string get package name ( string fq class name ) { assert . not null ( fq class name , `` class name must not be null `` ) ; int last dot index = fq class name . last index of ( package_separator ) ; return ( last dot index ! = -1 ? fq class name . substring ( 0 , last dot index ) : `` `` ) ; }
protect string get class text ( ) { return `` interface `` ; } // get class string
public void generate ( ) throw i o exception { string fqcn = get package ( ) + `` . `` + get class name ( ) ; if ( emitter . be deploy ( ) & & emitter . do exist ( fqcn ) ) { if ( emitter . be helper want ( ) ) { helper . generate ( ) ; } } else { super . generate ( ) ; } }
protect string get implement text ( ) { return `` implement `` + b entry . get dynamic var ( java binding writer . interface_name ) + `` `` ; } // get implement text
protect void write file header ( print writer pw ) throw i o exception { pw . println ( message . get message ( `` deploy00 `` ) ) ; pw . println ( message . get message ( `` deploy02 `` ) ) ; pw . println ( message . get message ( `` deploy03 `` ) ) ; pw . println ( message . get message ( `` deploy05 `` ) ) ; pw . println ( message . get message ( `` deploy06 `` ) ) ; pw . println ( message . get message ( `` deploy07 `` ) ) ; pw . println ( message . get message ( `` deploy09 `` ) ) ; pw . println ( ) ; pw . println ( `` < deployment `` ) ; pw . println ( `` xmlns=\ `` `` + w s d d constant . uri_wsdd + `` \ `` `` ) ; pw . println ( `` xmlns : `` + w s d d constant . ns_prefix_wsdd_java + `` =\ `` `` + w s d d constant . uri_wsdd_java + `` \ `` > `` ) ; } // write file header
public void mkdir ( string pkg ) { string pkg dir string = to dir ( pkg ) ; file package dir = new file ( pkg dir string ) ; package dir . mkdirs ( ) ; } // mkdir
public static string gen q name attribute string ( q name qname , string prefix ) { if ( ( qname . get namespace u r i ( ) == null ) || qname . get namespace u r i ( ) . equal ( `` `` ) ) { return qname . get local part ( ) ; } return prefix + `` : `` + qname . get local part ( ) + `` \ `` xmlns : `` + prefix + `` =\ `` `` + qname . get namespace u r i ( ) ; }
public string get token u r l ( ) { return this . token u r l ; }
public void set base u r l ( string base u r l ) { this . base u r l = base u r l ; }
public void set read timeout ( long read timeout ) { if ( read timeout > 0 ) { this . read timeout = read timeout ; } else { this . read timeout = -1 ; } }
public void authenticate ( string auth code ) { url url = null ; try { url = new url ( this . token u r l ) ; } catch ( malformed u r l exception e ) { assert false : `` an invalid token url indicate a bug in the sdk . `` ; throw new runtime exception ( `` an invalid token url indicate a bug in the sdk . `` , e ) ; } string url parameter = string . format ( `` grant_type=authorization_code & code= % s & client_id= % s & client_secret= % s `` , auth code , this . client i d , this . client secret ) ; box a p i request request = new box a p i request ( this , url , `` post `` ) ; request . should authenticate ( false ) ; request . set body ( url parameter ) ; box j s o n response response = ( box j s o n response ) request . send ( ) ; string json = response . get j s o n ( ) ; json object json object = json object . read from ( json ) ; this . access token = json object . get ( `` access_token `` ) . a string ( ) ; this . refresh token = json object . get ( `` refresh_token `` ) . a string ( ) ; this . last refresh = system . current time millis ( ) ; this . expire = json object . get ( `` expires_in `` ) . a long ( ) * 1000 ; }
protect void notify refresh ( ) { for ( box a p i connection listener listener : this . listener ) { listener . on refresh ( this ) ; } }
public void authenticate ( string auth code ) { url url = null ; try { url = new url ( this . token u r l ) ; } catch ( malformed u r l exception e ) { assert false : `` an invalid token url indicate a bug in the sdk . `` ; throw new runtime exception ( `` an invalid token url indicate a bug in the sdk . `` , e ) ; } string url parameter = string . format ( `` grant_type=authorization_code & code= % s & client_id= % s & client_secret= % s `` , auth code , this . client i d , this . client secret ) ; box a p i request request = new box a p i request ( this , url , `` post `` ) ; request . should authenticate ( false ) ; request . set body ( url parameter ) ; box j s o n response response = ( box j s o n response ) request . send ( ) ; string json = response . get j s o n ( ) ; json object json object = json object . read from ( json ) ; this . access token = json object . get ( `` access_token `` ) . a string ( ) ; this . refresh token = json object . get ( `` refresh_token `` ) . a string ( ) ; this . last refresh = system . current time millis ( ) ; this . expire = json object . get ( `` expires_in `` ) . a long ( ) * 1000 ; }
public static url get base u r l ( final url url ) { if ( url == null ) return null ; try { return new url ( url . get protocol ( ) , url . get host ( ) , url . get port ( ) , url . get path ( ) ) ; } catch ( malformed u r l exception e ) { return null ; } }
public void update info ( info info ) { box a p i connection api = this . get a p i ( ) ; url url = collaboration_url_template . build ( api . get base u r l ( ) , this . get i d ( ) ) ; box j s o n request request = new box j s o n request ( api , url , `` put `` ) ; request . set body ( info . get pending change ( ) ) ; box a p i response box a p i response = request . send ( ) ; if ( box a p i response instanceof box j s o n response ) { box j s o n response response = ( box j s o n response ) box a p i response ; json object json object = json object . read from ( response . get j s o n ( ) ) ; info . update ( json object ) ; } }
public void delete ( ) { box a p i connection api = this . get a p i ( ) ; url url = collaboration_whitelist_entry_url_template . build ( api . get base u r l ( ) , this . get i d ( ) ) ; box a p i request request = new box a p i request ( api , url , http method . delete ) ; box a p i response response = request . send ( ) ; response . disconnect ( ) ; }
public j s o n array convert to j s o n array ( j s o n object obj , string key ) { j s o n array json array = new j s o n array ( ) ; try { json array = ( j s o n array ) obj . get ( key ) ; } catch ( exception e ) { log . info ( e . get message ( ) , e ) ; } return json array ; }
public box file . info upload file ( input stream file content , string name ) { file upload params upload info = new file upload params ( ) . set content ( file content ) . set name ( name ) ; return this . upload file ( upload info ) ; }
public void download ( output stream output , progress listener listener ) { url url = content_url_template . build ( this . get a p i ( ) . get base u r l ( ) , this . get i d ( ) ) ; box a p i request request = new box a p i request ( this . get a p i ( ) , url , `` get `` ) ; box a p i response response = request . send ( ) ; input stream input = response . get body ( listener ) ; byte [ ] buffer = new byte [ buffer_size ] ; try { int n = input . read ( buffer ) ; while ( n ! = -1 ) { output . write ( buffer , 0 , n ) ; n = input . read ( buffer ) ; } } catch ( i o exception e ) { throw new box a p i exception ( `` could n't connect to the box api due to a network error . `` , e ) ; } finally { response . disconnect ( ) ; } }
public box collaboration . info collaborate ( box collaborator collaborator , box collaboration . role role ) { json object accessible by field = new json object ( ) ; accessible by field . add ( `` id `` , collaborator . get i d ( ) ) ; if ( collaborator instanceof box user ) { accessible by field . add ( `` type `` , `` user `` ) ; } else if ( collaborator instanceof box group ) { accessible by field . add ( `` type `` , `` group `` ) ; } else { throw new illegal argument exception ( `` the give collaborator be of an unknown type . `` ) ; } return this . collaborate ( accessible by field , role , null , null ) ; }
public box collaboration . info collaborate ( box collaborator collaborator , box collaboration . role role ) { json object accessible by field = new json object ( ) ; accessible by field . add ( `` id `` , collaborator . get i d ( ) ) ; if ( collaborator instanceof box user ) { accessible by field . add ( `` type `` , `` user `` ) ; } else if ( collaborator instanceof box group ) { accessible by field . add ( `` type `` , `` group `` ) ; } else { throw new illegal argument exception ( `` the give collaborator be of an unknown type . `` ) ; } return this . collaborate ( accessible by field , role , null , null ) ; }
public box file upload session . info get status ( ) { url status u r l = this . session info . get session endpoint ( ) . get status endpoint ( ) ; box j s o n request request = new box j s o n request ( this . get a p i ( ) , status u r l , http method . get ) ; box j s o n response response = ( box j s o n response ) request . send ( ) ; json object json object = json object . read from ( response . get j s o n ( ) ) ; this . session info . update ( json object ) ; return this . session info ; }
public void copy file ( string source file , string d file ) throw i o exception { file_utils . copy file ( source file , d file ) ; }
public object get property ( string name ) { if ( `` name `` . equal ( name ) ) { return function name . get display name ( ) ; } else if ( `` a `` . equal ( name ) ) { return result type . to string ( ) ; } else { return null ; } }
public box watermark apply watermark ( ) { return this . apply watermark ( file_url_template , box watermark . watermark_default_imprint ) ; }
public static void set max request attempt ( int max request attempt ) { box global setting . max request attempt = max request attempt ; }
public void delete ( ) { url url = task_url_template . build ( this . get a p i ( ) . get base u r l ( ) , this . get i d ( ) ) ; box a p i request request = new box a p i request ( this . get a p i ( ) , url , `` delete `` ) ; box a p i response response = request . send ( ) ; response . disconnect ( ) ; }
public void remove ( ) { throw new unsupported operation exception ( `` remove ( ) be unsupported `` ) ; }
public url get redirect u r l ( ) { return this . redirect u r l ; }
public int hash code ( ) { return 37 * 17+type i d . hash code ( ) + 37 * 17+field i d . hash code ( ) ; }
public static box retention policy assignment . info create assignment to folder ( box a p i connection api , string policy i d , string folder i d ) { return create assignment ( api , policy i d , new json object ( ) . add ( `` type `` , type_folder ) . add ( `` id `` , folder i d ) , null ) ; }
public void reset ( ) { this . cancel = false ; this . field = null ; this . initializers = null ; this . member type = null ; this . method = null ; this . package fragment = null ; this . type = null ; }
public static list < field > get declare field ( class < ? > cl ) { if ( cls == null || object . class . equal ( cl ) ) { return collection . empty list ( ) ; } final list < field > field = new array list < field > ( ) ; final set < string > field name = new hash set < string > ( ) ; for ( field field : cl . get declared field ( ) ) { field . add ( field ) ; field name . add ( field . get name ( ) ) ; } for ( field field : get declare field ( cl . get superclass ( ) ) ) { if ( ! field names . contains ( field . get name ( ) ) ) { field . add ( field ) ; } } return field ; }
public iterable < box group membership . info > get all membership ( string . . . field ) { final query string builder builder = new query string builder ( ) ; if ( field . length > 0 ) { builder . append param ( `` field `` , field ) ; } return new iterable < box group membership . info > ( ) { public iterator < box group membership . info > iterator ( ) { url url = memberships_url_template . build with query ( box group . this . get a p i ( ) . get base u r l ( ) , builder . to string ( ) , box group . this . get i d ( ) ) ; return new box group membership iterator ( box group . this . get a p i ( ) , url ) ; } } ; }
public void delete ( ) { box a p i connection api = this . get a p i ( ) ; url url = collaboration_url_template . build ( api . get base u r l ( ) , this . get i d ( ) ) ; box a p i request request = new box a p i request ( api , url , `` delete `` ) ; box a p i response response = request . send ( ) ; response . disconnect ( ) ; }
public < t > ct this access < t > create this access ( ct type reference < t > type , boolean be implicit ) { ct this access < t > this access = factory . core ( ) . < t > create this access ( ) ; this access . set implicit ( be implicit ) ; this access . set type ( type ) ; ct type access < t > type access = factory . code ( ) . create type access ( type ) ; this access . set target ( type access ) ; return this access ; }
public void update info ( info info ) { box a p i connection api = this . get a p i ( ) ; url url = collaboration_url_template . build ( api . get base u r l ( ) , this . get i d ( ) ) ; box j s o n request request = new box j s o n request ( api , url , `` put `` ) ; request . set body ( info . get pending change ( ) ) ; box a p i response box a p i response = request . send ( ) ; if ( box a p i response instanceof box j s o n response ) { box j s o n response response = ( box j s o n response ) box a p i response ; json object json object = json object . read from ( response . get j s o n ( ) ) ; info . update ( json object ) ; } }
public void rename ( string new name ) { url url = file_url_template . build ( this . get a p i ( ) . get base u r l ( ) , this . get i d ( ) ) ; box j s o n request request = new box j s o n request ( this . get a p i ( ) , url , `` put `` ) ; json object update info = new json object ( ) ; update info . add ( `` name `` , new name ) ; request . set body ( update info . to string ( ) ) ; box a p i response response = request . send ( ) ; response . disconnect ( ) ; }
public create user params set be exempt from login verification ( boolean be exempt from login verification ) { this . be exempt from login verification = be exempt from login verification ; return this ; }
public object get property ( string name ) { if ( `` name `` . equal ( name ) ) { return function name . get display name ( ) ; } else if ( `` a `` . equal ( name ) ) { return result type . to string ( ) ; } else { return null ; } }
public string get parent i d ( ) { return this . get ( `` / $ parent `` ) ; }
public string get template name ( ) { return this . get ( `` / $ template `` ) ; }
public metadata add ( string path , string value ) { this . value . add ( this . path to property ( path ) , value ) ; this . add op ( `` add `` , path , value ) ; return this ; }
public string get ( string path ) { final json value value = this . value . get ( this . path to property ( path ) ) ; if ( value == null ) { return null ; } if ( ! value . be string ( ) ) { return value . to string ( ) ; } return value . a string ( ) ; }
public void set template key ( string template key ) { this . template key = template key ; }
public comment set content ( final string content ) { assert not null ( content ) ; if ( content == this . content ) { return this ; } notify property change ( observable property . content , this . content , content ) ; this . content = content ; return this ; }
public boolean have upper bound ( ) { return ( this . upper bound ! = null ) ; }
public boolean have import ( string name ) { return parser configuration . have import ( name ) ; }
protect void define class ( string class name ) { string base name = name . suffix ( class name,1 ) ; int i = base name . index of ( `` $ `` ) ; if ( i ! = -1 ) base name = base name . substring ( i+1 ) ; string cur = ( string ) define class base name . get ( base name ) ; if ( cur ! = null ) throw new interpreter error ( `` define class problem : `` +class name + `` : bean shell can not yet simultaneously define two or more `` + `` dependent class of the same name . attempt to define : `` + class name + `` while defining : `` +cur ) ; define class . put ( class name , novalue ) ; define class base names . put ( base name , class name ) ; }
protect void define class ( string class name ) { string base name = name . suffix ( class name,1 ) ; int i = base name . index of ( `` $ `` ) ; if ( i ! = -1 ) base name = base name . substring ( i+1 ) ; string cur = ( string ) define class base name . get ( base name ) ; if ( cur ! = null ) throw new interpreter error ( `` define class problem : `` +class name + `` : bean shell can not yet simultaneously define two or more `` + `` dependent class of the same name . attempt to define : `` + class name + `` while defining : `` +cur ) ; define class . put ( class name , novalue ) ; define class base names . put ( base name , class name ) ; }
public static class < ? > primitive type ( class < ? > type ) { if ( type . be primitive ( ) ) { return type ; } if ( type == integer . class ) { return integer . type ; } if ( type == long . class ) { return long . type ; } if ( type == boolean . class ) { return boolean . type ; } if ( type == double . class ) { return double . type ; } if ( type == float . class ) { return float . type ; } if ( type == byte . class ) { return byte . type ; } if ( type == short . class ) { return short . type ; } if ( type == character . class ) { return character . type ; } return null ; }
public void set stack depth ( int depth ) { stack depth = depth ; if ( stack depth > max stack ) max stack = stack depth ; }
public class map get ( final class c ) { class map class map = ( class map ) class map cache . get ( validate . not null ( c ) ) ; if ( class map == null ) { / * * check to see if we have it by name . * if so , then we have an object with the same * name but load through a different class loader . * in that case , we will just dump the cache to be sure . * / synchronize ( class map cache ) { if ( class name cache . contains ( c . get name ( ) ) ) { clear ( ) ; } } } return class map ; }
public void set source ( string class name , string source ) { source . put ( class name , source ) ; compile . clear ( ) ; }
public void assert error ( throwable throwable ) { list < throwable > err = error ; if ( err . be empty ( ) ) { assertion error ( `` no error `` ) ; } else if ( err . size ( ) > 1 ) { assertion error ( `` multiple error `` ) ; } else if ( ! throwable . equal ( err . get ( 0 ) ) ) { assertion error ( `` exception differ ; expect : `` + throwable + `` , actual : `` + err . get ( 0 ) ) ; } }
public void debug ( string debug message ) { jdk logger . finer ( debug message ) ; if ( stdout_debug ) { system . out . println ( `` hk2debug : `` + debug message ) ; } }
public void set transaction manager class name ( string transaction manager class name ) { synchronize ( this ) { if ( transaction manager class name == null ) { this . transaction manager = null ; } else if ( ! transaction manager class name . equal ( this . transaction manager class name ) ) { this . transaction manager = null ; } this . transaction manager class name = transaction manager class name ; } }
public void add variable name access ( string name ) { if ( f access variable name == null ) { f access variable names= new array list < > ( 5 ) ; f access variable name . add ( name ) ; } else if ( ! f access variable name . contains ( name ) ) { f access variable name . add ( name ) ; } }
public string get field doc ( i field child ) throw java model exception { if ( this . content == null ) return null ; int [ ] range = null ; synchronize ( this ) { if ( this . field doc range == null ) { this . field doc range = new hashtable of object to int array ( ) ; } else { range = this . field doc range . get ( child ) ; } if ( range == null ) { range = compute field range ( child ) ; this . field doc range . put ( child , range ) ; } } if ( range ! = null ) { if ( range == unknown_format ) throw new java model exception ( new java model status ( i java model status constant . unknown_javadoc_format , child ) ) ; return new string ( this . content , range [ 0 ] , range [ 1 ] - range [ 0 ] ) ; } return null ; }
public static void shutdown now ( ) { for ( stage stage : stage . value ( ) ) { stage manager . stage . get ( stage ) . shutdown now ( ) ; } }
public static boolean be array ( type type ) { return ( type instanceof generic array type ) || ( type instanceof class < ? > & & ( ( class < ? > ) type ) . be array ( ) ) ; }
public iterable < c f meta data > get table and view ( string keyspace name ) { assert keyspace name ! = null ; keyspace metadata ksm = keyspaces . get ( keyspace name ) ; assert ksm ! = null ; return ksm . table and view ( ) ; }
public void load ( c f meta data cfm ) { pair < string , string > key = pair . create ( cfm . k name , cfm . cf name ) ; if ( cf id map . contains key ( key ) ) throw new runtime exception ( string . format ( `` attempt to load already load table % s . % s `` , cfm . k name , cfm . cf name ) ) ; logger . debug ( `` add { } to cf id map `` , cfm ) ; cf id map . put ( key , cfm . cf id ) ; }
public boolean be same version ( uuid schema version ) { return schema version ! = null & & ( schema version . equal ( version ) || schema version . equal ( alt version ) ) ; }
public static aggregate function make max function ( final abstract type < ? > input type ) { return new native aggregate function ( `` max `` , input type , input type ) { public aggregate new aggregate ( ) { return new aggregate ( ) { private byte buffer max ; public void reset ( ) { max = null ; } public byte buffer compute ( protocol version protocol version ) { return max ; } public void add input ( protocol version protocol version , list < byte buffer > value ) { byte buffer value = value . get ( 0 ) ; if ( value == null ) return ; if ( max == null || return type ( ) . compare ( max , value ) < 0 ) max = value ; } } ; } } ; }
public byte [ ] get page state unsafe ( ) { if ( this . page state == null ) return null ; return byte . get array ( this . page state ) ; }
public final boolean have i n ( ) { for ( single restriction restriction : this ) { if ( restriction . be i n ( ) ) return true ; } return false ; }
public boolean need filter ( ) { int number of restriction = filter restriction . get custom index expression ( ) . size ( ) ; for ( restriction restriction : filter restriction . get restriction ( ) ) number of restriction += restriction . size ( ) ; return number of restriction > 1 || ( number of restriction == 0 & & ! cluster columns restriction . be empty ( ) ) || ( number of restriction ! = 0 & & non primary key restriction . have multiple contains ( ) ) ; }
public boolean have cluster columns restriction ( ) { return ! cluster columns restriction . be empty ( ) ; }
public boolean be inclusive ( bound b ) { return bound [ b . idx ] == null || bound inclusive [ b . idx ] ; }
public boolean contain only static column ( ) { if ( ! contain static column ( ) ) return false ; if ( be wildcard ( ) ) return false ; for ( column definition def : get column ( ) ) { if ( ! def . be partition key ( ) & & ! def . be static ( ) ) return false ; } return true ; }
public static boolean apply only to static column ( operation operation , condition condition ) { return ! operation . applies to regular column ( ) & & ! condition . applies to regular column ( ) & & ( operation . applies to static column ( ) || condition . applies to static column ( ) ) ; }
public static log message format ( string format , object . . . args ) { return new format message x ( format , args ) ; }
public comparator < ? super r > row comparator ( ) { return row key set ( ) . comparator ( ) ; }
public listenable future < commit log position > force flush ( ) { synchronize ( data ) { memtable current = data . get view ( ) . get current memtable ( ) ; for ( column family store cf : concat with index ( ) ) if ( ! cf . data . get view ( ) . get current memtable ( ) . be clean ( ) ) return switch memtable if current ( current ) ; return wait for flush ( ) ; } }
public int get blacklist tracker ( ) { return num blacklist tracker ; }
public static column family store get if exists ( string k name , string cf name ) { if ( k name == null || cf name == null ) return null ; keyspace keyspace = keyspace . open ( ks name ) ; if ( keyspace == null ) return null ; uuid id = schema . instance . get id ( ks name , cf name ) ; if ( id == null ) return null ; return keyspace . get column family store ( id ) ; }
public static boolean be meta data complete ( web descriptor d ) { return ( d ! = null & & d . get meta data complete ( ) == meta data . complete . true ) ; }
public int complex column count ( ) { return b tree . size ( column ) - complex idx ; }
public int complex column count ( ) { return b tree . size ( column ) - complex idx ; }
protect boolean be ignore ( t child ) { return false ; }
public void clear new session request ( ) { lock . write lock ( ) . lock ( ) ; try { new session request . clear ( ) ; } finally { lock . write lock ( ) . unlock ( ) ; } }
public boolean have error ( ) { for ( directory directory : get directory ( ) ) { if ( directory . have error ( ) ) return true ; } return false ; }
public byte buffer create local ( long count ) { context state state = context state . allocate ( 0 , 1 , 0 ) ; state . write local ( counter id . get local id ( ) , 1l , count ) ; return state . context ; }
public long get local count ( byte buffer context ) { return get local clock and count ( context ) . count ; }
public void remove unreadable s s table ( final file directory ) { maybe fail ( drop s s table ( new predicate < s s table reader > ( ) { public boolean apply ( s s table reader reader ) { return reader . descriptor . directory . equal ( directory ) ; } } , operation type . unknown , null ) ) ; }
public static void wait for deletion ( ) { log transaction . wait for deletion ( ) ; }
public static byte [ ] digest ( final message digest message digest , final byte buffer data ) { message digest . update ( data ) ; return message digest . digest ( ) ; }
public boolean be expire ( ) { return ( this . expiration time ! = -1 & & system . current time millis ( ) > this . expiration time ) ; }
public long max timestamp ( ) { maybe build ( ) ; long max timestamp = deletion info . max timestamp ( ) ; for ( row row : this ) { max timestamp = math . max ( max timestamp , row . primary key liveness info ( ) . timestamp ( ) ) ; for ( column data cd : row ) { if ( cd . column ( ) . be simple ( ) ) { max timestamp = math . max ( max timestamp , ( ( cell ) cd ) . timestamp ( ) ) ; } else { complex column data complex data = ( complex column data ) cd ; max timestamp = math . max ( max timestamp , complex data . complex deletion ( ) . mark for delete at ( ) ) ; for ( cell cell : complex data ) max timestamp = math . max ( max timestamp , cell . timestamp ( ) ) ; } } } return max timestamp ; }
public t retry buffer size ( long byte ) { throw new unsupported operation exception ( ) ; }
public static collection < column identifier > to identifier ( collection < column definition > definition ) { return collections2 . transform ( definition , new function < column definition , column identifier > ( ) { @ override public column identifier apply ( column definition column def ) { return column def . name ; } } ) ; }
public static timestamp convert timestamp time zone to timestamp ( long date value , long time nanos , short offset min ) { timestamp t = new timestamp ( get millis ( date value , time nanos , offset min ) ) ; t . set nanos ( ( int ) ( time nanos % 1_000_000_000 ) ) ; return t ; }
public deletion time deletion time ( ) { return deletion ; }
public void invoke controller execution finish ( ) throw execution exception { for ( controller aware p r pr : get controller aware p r ( ) ) { pr . controller execution finish ( this ) ; } }
public boolean include ( cluster comparator comparator , cluster prefix bound ) { return comparator . compare ( start , bound ) < = 0 & & comparator . compare ( bound , end ) < = 0 ; }
protect void on partition close ( ) { }
public void set default view ( @ nullable list < view > default view ) { this . default view . clear ( ) ; if ( default view ! = null ) { this . default view . add all ( default view ) ; } }
public void update definition ( view definition definition ) { this . definition = definition ; list < column definition > non p k def part of view p k = new array list < > ( ) ; for ( column definition base column : base cf . metadata . all column ( ) ) { column definition view column = get view column ( base column ) ; if ( view column ! = null & & ! base column . be primary key column ( ) & & view column . be primary key column ( ) ) non p k def part of view p k . add ( base column ) ; } this . base non p k column in view p k = non p k def part of view p k ; }
public static range < partition position > make row range ( token left , token right ) { return new range < partition position > ( leave . max key bound ( ) , right . max key bound ( ) ) ; }
public static void set input split size in mb ( configuration conf , int split size mb ) { conf . set int ( input_split_size_in_mb_config , split size mb ) ; }
public static void set ignore host ( configuration conf , string . . . ignore node ) { conf . set string ( cql bulk record writer . ignore_hosts , ignore node ) ; }
public static task attempt i d get task attempt i d ( task attempt context task context ) { return ( task attempt i d ) invoke ( get_task_attempt_id , task context ) ; }
public void delete all hint for endpoint ( inet address target ) { uuid host id = storage service . instance . get host id for endpoint ( target ) ; if ( host id == null ) throw new illegal argument exception ( `` ca n't delete hint for unknown address `` + target ) ; catalog . delete all hint ( host id ) ; }
public long get compression metadata off heap size ( ) { if ( ! compression ) return 0 ; return get compression metadata ( ) . off heap size ( ) ; }
public i s s table scanner get scanner ( collection < range < token > > range , rate limiter limiter ) { if ( range ! = null ) return big table scanner . get scanner ( this , range , limiter ) ; else return get scanner ( limiter ) ; }
public string get rack ( inet address endpoint ) { if ( endpoint . equal ( f b utility . get broadcast address ( ) ) ) return my rack ; endpoint state ep state = gossiper . instance . get endpoint state for endpoint ( endpoint ) ; if ( ep state == null || ep state . get application state ( application state . rack ) == null ) { if ( psnitch == null ) { if ( saved endpoint == null ) save endpoint = system keyspace . load dc rack info ( ) ; if ( saved endpoint . contains key ( endpoint ) ) return save endpoint . get ( endpoint ) . get ( `` rack `` ) ; return default_rack ; } else return psnitch . get rack ( endpoint ) ; } return ep state . get application state ( application state . rack ) . value ; }
public void update topology ( inet address endpoint ) { assert endpoint ! = null ; lock . write lock ( ) . lock ( ) ; try { logger . info ( `` update topology for { } `` , endpoint ) ; topology . update endpoint ( endpoint ) ; invalidate cache ring ( ) ; } finally { lock . write lock ( ) . unlock ( ) ; } }
public void clear ( ) { this . lock . write lock ( ) . lock ( ) ; try { this . cache . clear ( ) ; this . queue . clear ( ) ; this . size = 0 ; } finally { this . lock . write lock ( ) . unlock ( ) ; } }
public long get count ( ) { return count . sum ( ) ; }
public void register verb handler ( verb verb , i verb handler verb handler ) { assert ! verb handler . contains key ( verb ) ; verb handler . put ( verb , verb handler ) ; }
public optional < string > get name ( ) { return optional . of nullable ( name ) ; }
public index without ( string name ) { index metadata index = get ( name ) . or else throw ( ( ) - > new illegal state exception ( string . format ( `` index % s do n't exist `` , name ) ) ) ; return builder ( ) . add ( filter ( this , v - > v ! = index ) ) . build ( ) ; }
public static s s l socket get socket ( encryption option option , inet address address , int port ) throw i o exception { s s l context ctx = create s s l context ( option , true ) ; s s l socket socket = ( s s l socket ) ctx . get socket factory ( ) . create socket ( address , port ) ; try { prepare socket ( socket , option ) ; return socket ; } catch ( illegal argument exception e ) { socket . close ( ) ; throw e ; } }
public stream plan transfer range ( inet address to , inet address connecting , string keyspace , collection < range < token > > range ) { return transfer range ( to , connect , keyspace , range , empty_column_families ) ; }
public void add s s table ( s s table reader sstable ) { assert sstable . get column family name ( ) . equal ( name ) ; add s s table ( array . a list ( sstable ) ) ; }
public static void write meta data ( transfer transfer , parameter interface p ) throw i o exception { transfer . write int ( p . get type ( ) ) ; transfer . write long ( p . get precision ( ) ) ; transfer . write int ( p . get scale ( ) ) ; transfer . write int ( p . get nullable ( ) ) ; }
public static boolean be tcp port available ( int current port ) { try ( socket socket = new socket ( ) ) { socket . connect ( new inet socket address ( inet address . get local host ( ) , current port ) , 20 ) ; return false ; } catch ( throwable e ) { return true ; } }
public boolean be active ( ) { transaction transaction = get current transaction ( ) ; if ( transaction == null ) { return false ; } try { int current status = transaction . get status ( ) ; return current status == status . status_active || current status == status . status_marked_rollback || current status == status . status_prepared || current status == status . status_unknown || current status == status . status_preparing || current status == status . status_committing || current status == status . status_rolling_back ; } catch ( system exception e ) { throw new runtime exception ( `` error get the status of the current transaction `` , e ) ; } }
public static mutation merge ( list < mutation > mutation ) { assert ! mutation . be empty ( ) ; if ( mutation . size ( ) == 1 ) return mutation . get ( 0 ) ; set < uuid > update table = new hash set < > ( ) ; string ks = null ; decorate key key = null ; for ( mutation mutation : mutation ) { updated table . add all ( mutation . modification . key set ( ) ) ; if ( k ! = null & & ! k . equal ( mutation . keyspace name ) ) throw new illegal argument exception ( ) ; if ( key ! = null & & ! key . equal ( mutation . key ) ) throw new illegal argument exception ( ) ; ks = mutation . keyspace name ; key = mutation . key ; } list < partition update > update = new array list < > ( mutation . size ( ) ) ; map < uuid , partition update > modification = new hash map < > ( updated table . size ( ) ) ; for ( uuid table : updated table ) { for ( mutation mutation : mutation ) { partition update upd = mutation . modification . get ( table ) ; if ( upd ! = null ) update . add ( upd ) ; } if ( update . be empty ( ) ) continue ; modification . put ( table , update . size ( ) == 1 ? update . get ( 0 ) : partition update . merge ( update ) ) ; update . clear ( ) ; } return new mutation ( k , key , modification ) ; }
public void copy to ( byte [ ] target , int offset ) { copy to ( target , 0 , offset , size ( ) ) ; }
public void refresh ( ) { long now = now ( ) ; try ( releasable lock ignore = lru lock . acquire ( ) ) { evict ( now ) ; } }
public boolean release ( entry entry ) { if ( close ) return false ; boolean release = entry . try release ( ) ; if ( release & & cache ! = null ) cache . set ( entry ) ; return release ; }
public void clear ( ) { for ( iterator < e > iter = iterator ( ) ; iter . have next ( ) ; ) { iter . next ( ) ; iter . remove ( ) ; } }
public collection < thread > get wait thread ( condition condition ) { require non null ( condition ) ; if ( ! ( condition instanceof abstract queue synchronizer . condition object ) ) { throw new illegal argument exception ( `` not owner `` ) ; } return sync . get wait thread ( ( abstract queue synchronizer . condition object ) condition ) ; }
public static string get local hostname ( ) { try { final inet address addr = inet address . get local host ( ) ; return addr . get host name ( ) ; } catch ( final unknown host exception uhe ) { try { final enumeration < network interface > interfaces = network interface . get network interface ( ) ; while ( interface . have more element ( ) ) { final network interface nic = interface . next element ( ) ; final enumeration < inet address > address = nic . get inet address ( ) ; while ( address . have more element ( ) ) { final inet address address = address . next element ( ) ; if ( ! address . be loopback address ( ) ) { final string hostname = address . get host name ( ) ; if ( hostname ! = null ) { return hostname ; } } } } } catch ( final socket exception se ) { logger . error ( `` could not determine local host name `` , uhe ) ; return unknown_localhost ; } logger . error ( `` could not determine local host name `` , uhe ) ; return unknown_localhost ; } }
public static void update checksum ( crc32 checksum , byte buffer buffer ) { int position = buffer . position ( ) ; checksum . update ( buffer ) ; buffer . position ( position ) ; }
public merkle tree get merkle tree ( range < token > range ) { return merkle tree . get ( range ) ; }
public static long size of array ( long [ ] longs ) { return size of array ( longs . length , 8 ) ; }
public static boolean be power of two ( final int value ) { return ( value & ( value - 1 ) ) == 0 ; }
public rate limiter get rate limiter ( ) { set rate ( database descriptor . get compaction throughput mb per sec ( ) ) ; return compaction rate limiter ; }
public string export a string ( ) { return a c q l query ( true ) ; }
public < t > listenable future < t > submit ( final callable < t > callable , executor executor ) { check not null ( callable ) ; return submit async ( new async callable < t > ( ) { @ override public listenable future < t > call ( ) throw exception { return immediate future ( callable . call ( ) ) ; } } , executor ) ; }
public vertx option set cluster manager ( cluster manager cluster manager ) { this . cluster manager = cluster manager ; return this ; }
public cluster register ( latency tracker tracker ) { check not close ( manager ) ; boolean add = manager . latency tracker . add ( tracker ) ; if ( add ) tracker . on register ( this ) ; return this ; }
public long runtime ( time unit unit ) { return unit . convert ( get nanos ( ) , time unit . nanosecond ) ; }
public static alter keyspace alter keyspace ( string keyspace name ) { return new alter keyspace ( keyspace name ) ; }
public query option set consistency level ( consistency level consistency level ) { this . consistency = consistency level ; return this ; }
public int get successful ( ) { return successful ; }
public listenable future < query trace > get query trace async ( ) { return future . immediate future ( trace ) ; }
public data type get data type ( ) { return data type ; }
public static inet socket address replace with resolve ( inet socket address inet socket address ) { require non null ( inet socket address , `` inet socket address `` ) ; if ( ! inet socket address . be unresolved ( ) ) { return inet socket address ; } inet socket address = replace unresolved numeric ip ( inet socket address ) ; if ( ! inet socket address . be unresolved ( ) ) { return inet socket address ; } else { return new inet socket address ( inet socket address . get host string ( ) , inet socket address . get port ( ) ) ; } }
public boolean be same version ( uuid schema version ) { return schema version ! = null & & ( schema version . equal ( version ) || schema version . equal ( alt version ) ) ; }
public collection < entry > get user info claim ( ) { return collection . unmodifiable collection ( user info claim . value ( ) ) ; }
public boolean content equal ignore case ( char sequence string ) { if ( this == string ) { return true ; } if ( string == null || string . length ( ) ! = length ( ) ) { return false ; } if ( string instanceof ascii string ) { ascii string rh = ( ascii string ) string ; for ( int i = array offset ( ) , j = rh . array offset ( ) , end = i + length ( ) ; i < end ; ++i , ++j ) { if ( ! equal ignore case ( value [ i ] , rh . value [ j ] ) ) { return false ; } } return true ; } for ( int i = array offset ( ) , j = 0 , end = length ( ) ; j < end ; ++i , ++j ) { if ( ! equal ignore case ( b2c ( value [ i ] ) , string . char at ( j ) ) ) { return false ; } } return true ; }
public synchronize void set host ( http host . . . host ) { if ( host == null || host . length == 0 ) { throw new illegal argument exception ( `` host must not be null nor empty `` ) ; } set < http host > http host = new hash set < > ( ) ; auth cache auth cache = new basic auth cache ( ) ; for ( http host host : host ) { object . require non null ( host , `` host can not be null `` ) ; http host . add ( host ) ; auth cache . put ( host , new basic scheme ( ) ) ; } this . host tuple = new host tuple < > ( collection . unmodifiable set ( http host ) , auth cache ) ; this . blacklist . clear ( ) ; }
public boolean check error ( ) { try { out . flush ( ) ; } catch ( i o exception e ) { have error=true ; } return have error ; }
public gauge < integer > get know host ( ) { return know host ; }
public static string double quote ( string value ) { return quote ( value , ' `` ' ) ; }
public static string un double quote ( string value ) { return unquote ( value , ' `` ' ) ; }
public load balancing policy get load balancing policy ( ) { return load balancing policy ; }
public address translator get address translator ( ) { return address translator ; }
public client configuration with retry policy ( retry policy retry policy ) { set retry policy ( retry policy ) ; return this ; }
public void set max wait milli second ( long max wait milli second ) { this . max wait milli second = max wait milli second ; }
public option use ( ) { return using ; }
public static order asc ( string column name ) { return new order ( column name , false ) ; }
public static use timestamp ( bind marker marker ) { return new use . with marker ( `` timestamp `` , marker ) ; }
public static assignment incr ( string name , long value ) { return new assignment . counter assignment ( name , value , true ) ; }
public static assignment append all ( string name , list < ? > list ) { return new assignment . collection assignment ( name , list , true , false ) ; }
public static assignment add ( string name , object value ) { if ( value instanceof bind marker ) { throw new invalid query exception ( `` bind a value in add ( ) be not support , use add all ( ) and bind a singleton list `` ) ; } return add all ( name , collection . singleton ( value ) ) ; }
public static object get type value ( sql parameter source source , string parameter name ) { int sql type = source . get sql type ( parameter name ) ; if ( sql type ! = sql parameter source . type_unknown ) { return new sql parameter value ( sql type , source . get type name ( parameter name ) , source . get value ( parameter name ) ) ; } else { return source . get value ( parameter name ) ; } }
public column specification with alias ( column identifier alias ) { return new column specification ( ks name , cf name , alias , type ) ; }
public boolean get default idempotence ( ) { return default idempotence ; }
public int get refresh node interval millis ( ) { return refresh node interval millis ; }
public query option set max pending refresh node request ( int max pending refresh node request ) { this . max pending refresh node request = max pending refresh node request ; return this ; }
public int get refresh node interval millis ( ) { return refresh node interval millis ; }
public t add u d t list column ( string column name , u d t type udt type ) { validate not empty ( column name , `` column name `` ) ; validate not null ( udt type , `` column element type `` ) ; validate not key word ( column name , string . format ( `` the column name ' % s ' be not allow because it be a reserved keyword `` , column name ) ) ; simple column . put ( column name , u d t type . list ( udt type ) ) ; return self ; }
public create add u d t partition key ( string column name , u d t type udt type ) { validate not empty ( column name , `` cluster key name `` ) ; validate not null ( udt type , `` udt partition key type `` ) ; validate not key word ( column name , string . format ( `` the partition key name ' % s ' be not allow because it be a reserved keyword `` , column name ) ) ; partition column . put ( column name , udt type ) ; return this ; }
public static create index step create index if not exist ( string index ) { return dsl ( ) . create index if not exist ( index ) ; }
public string build ( ) { return this . build internal ( ) ; }
public static create index request create index request ( string index ) { return new create index request ( index ) ; }
public t add u d t map column ( string column name , u d t type udt key type , u d t type udt value type ) { validate not empty ( column name , `` column name `` ) ; validate not null ( udt key type , `` map key udt type `` ) ; validate not null ( udt value type , `` map value udt type `` ) ; validate not key word ( column name , string . format ( `` the column name ' % s ' be not allow because it be a reserved keyword `` , column name ) ) ; simple column . put ( column name , u d t type . map with u d t key and value ( udt key type , udt value type ) ) ; return self ; }
public < t > ct literal < t > create literal ( t value ) { ct literal < t > literal = factory . core ( ) . < t > create literal ( ) ; literal . set value ( value ) ; if ( value ! = null ) { literal . set type ( ( ct type reference < t > ) factory . type ( ) . < t > create reference ( ( class < t > ) value . get class ( ) ) . unbox ( ) ) ; } else { literal . set type ( ( ct type reference < t > ) factory . type ( ) . null type ( ) ) ; } return literal ; }
public static table option . cache row per partition row ( int row number ) { if ( row number < = 0 ) { throw new illegal argument exception ( `` row number for cache should be strictly positive `` ) ; } return new table option . cache row per partition ( integer . to string ( row number ) ) ; }
public double get bloom filter false positive chance ( ) { return bf fp chance ; }
public int get gc grace in second ( ) { return gc grace ; }
public pem key cert option add key value ( buffer key value ) { argument . require ( key value ! = null , `` null key value `` ) ; key value . add ( key value ) ; return this ; }
public set < string > get value name ( ) { if ( name value == null ) throw new illegal state exception ( `` this statement do not have name value `` ) ; return collection . unmodifiable set ( name value . key set ( ) ) ; }
public socket option set reuse address ( boolean reuse address ) { this . reuse address = reuse address ; return this ; }
public client configuration with retry policy ( retry policy retry policy ) { set retry policy ( retry policy ) ; return this ; }
public int get token start offset ( int token , int start offset ) throw core exception { read to token ( token , start offset ) ; return get current start offset ( ) ; }
public static type codec < tuple value > tuple ( tuple type type ) { return new tuple codec ( type ) ; }
public static alter keyspace alter keyspace ( string keyspace name ) { return new alter keyspace ( keyspace name ) ; }
public int get minor version ( ) { return minor ; }
public boolean be build in ( ) { if ( build in == null ) { return false ; } else { return build in ; } }
public class < ? > load class ( final string class name , final boolean return null if class not find ) throw illegal argument exception { if ( close . get ( ) ) { throw new illegal argument exception ( `` can not use a scan result after it have be close `` ) ; } if ( class name == null || class name . be empty ( ) ) { throw new null pointer exception ( `` class name can not be null or empty `` ) ; } try { return class . for name ( class name , scan spec . initialize loaded class , class graph class loader ) ; } catch ( final class not find exception | linkage error e ) { if ( return null if class not find ) { return null ; } else { throw new illegal argument exception ( `` could not load class `` + class name + `` : `` + e ) ; } } }
public type signature get type signature ( ) { if ( type signature str == null ) { return null ; } if ( type signature == null ) { try { type signature = type signature . parse ( type signature str , declare class name ) ; type signature . set scan result ( scan result ) ; } catch ( final parse exception e ) { throw new illegal argument exception ( e ) ; } } return type signature ; }
public class < ? > resolve type ( string name ) { return type . find class ( name ) ; }
public class graph disable dir scanning ( ) { scan spec . scan dirs = false ; return this ; }
public class graph enable method info ( ) { enable class info ( ) ; scan spec . enable method info = true ; return this ; }
public class graph override module layer ( final object . . . override module layer ) { scan spec . override module layer ( override module layer ) ; return this ; }
public class graph whitelist jar ( final string . . . jar leaf name ) { for ( final string jar leaf name : jar leaf name ) { final string leaf name = jar utils . leaf name ( jar leaf name ) ; if ( ! leaf name . equal ( jar leaf name ) ) { throw new illegal argument exception ( `` can only whitelist jar by leafname : `` + jar leaf name ) ; } scan spec . jar white black list . add to whitelist ( leaf name ) ; } return this ; }
public boolean be interface or annotation ( ) { return ( modifier & modifier . interface ) ! = 0 ; }
public list < implement type definition > get all implementation of ( interface type definition target interface ) { list < implement type definition > type definition = get type ( implement type definition . class ) ; return type definition . stream ( ) . filter ( type definition - > { list < type > implement list = type definition . get implement ( ) ; for ( type i face : implement list ) { optional < interface type definition > interface type def = get type ( i face , interface type definition . class ) ; if ( interface type def . be present ( ) ) { boolean equal = interface type def . get ( ) . get name ( ) . equal ( target interface . get name ( ) ) ; if ( equal ) { return true ; } } } return false ; } ) . collect ( collector . to list ( ) ) ; }
public class info list get out class ( ) { return new class info list ( this . filter class info ( rel type . contained_within_outer_class , / * strict whitelist = * / false ) , / * sort by name = * / false ) ; }
public method info list get declare method and constructor info ( ) { return get declare method info ( / * method name = * / null , / * get normal method = * / true , / * get constructor method = * / true , / * get static initializer method = * / false ) ; }
public field info list get declared field info ( ) { if ( ! scan result . scan spec . enable field info ) { throw new illegal argument exception ( `` please call class graph # enable field info ( ) before # scan ( ) `` ) ; } return field info == null ? field info list . empty_list : field info ; }
public int compare to ( final field info other ) { final int diff = declare class name . compare to ( other . declare class name ) ; if ( diff ! = 0 ) { return diff ; } return name . compare to ( other . name ) ; }
public boolean equal ( final object obj ) { if ( obj == this ) { return true ; } else if ( ! ( obj instanceof field info ) ) { return false ; } final field info other = ( field info ) obj ; return declare class name . equal ( other . declare class name ) & & name . equal ( other . name ) ; }
public list < class ref or type variable signature > get throw signature ( ) { return throw signature ; }
public boolean can be modify reflectively ( ) { if ( field . be synthetic ( ) ) { return false ; } int modifier = field . get modifier ( ) ; if ( modifier . be final ( modifier ) & & modifier . be static ( modifier ) ) { return false ; } return true ; }
public annotation info list get annotation info ( ) { if ( ! scan result . scan spec . enable annotation info ) { throw new illegal argument exception ( `` please call class graph # enable annotation info ( ) before # scan ( ) `` ) ; } if ( annotation info == null || annotation info . length == 0 ) { return annotation info list . empty_list ; } else { final annotation info list annotation info list = new annotation info list ( annotation info . length ) ; collection . add all ( annotation info list , annotation info ) ; return annotation info list . get indirect annotation ( annotation info list , / * annotate class = * / null ) ; } }
public boolean have annotation ( final string annotation name ) { return get annotation ( ) . contains name ( annotation name ) ; }
public static boolean be public static final ( field field ) { int modifier = field . get modifier ( ) ; return ( modifier . be public ( modifier ) & & modifier . be static ( modifier ) & & modifier . be final ( modifier ) ) ; }
public class graph override module layer ( final object . . . override module layer ) { scan spec . override module layer ( override module layer ) ; return this ; }
public resource list get resource match pattern ( final pattern pattern ) { if ( close . get ( ) ) { throw new illegal argument exception ( `` can not use a scan result after it have be close `` ) ; } final resource list all whitelisted resource = get all resource ( ) ; if ( all whitelisted resource . be empty ( ) ) { return resource list . empty_list ; } else { final resource list filter resource = new resource list ( ) ; for ( final resource classpath resource : all whitelisted resource ) { final string relative path = classpath resource . get path ( ) ; if ( pattern . matcher ( relative path ) . match ( ) ) { filtered resource . add ( classpath resource ) ; } } return filtered resource ; } }
public resource list get resource with leaf name ( final string leaf name ) { if ( close . get ( ) ) { throw new illegal argument exception ( `` can not use a scan result after it have be close `` ) ; } final resource list all whitelisted resource = get all resource ( ) ; if ( all whitelisted resource . be empty ( ) ) { return resource list . empty_list ; } else { final resource list filter resource = new resource list ( ) ; for ( final resource classpath resource : all whitelisted resource ) { final string relative path = classpath resource . get path ( ) ; final int last slash idx = relative path . last index of ( '/ ' ) ; if ( relative path . substring ( last slash idx + 1 ) . equal ( leaf name ) ) { filtered resource . add ( classpath resource ) ; } } return filtered resource ; } }
public class info list get class with annotation ( final string annotation name ) { if ( close . get ( ) ) { throw new illegal argument exception ( `` can not use a scan result after it have be close `` ) ; } if ( ! scan spec . enable class info || ! scan spec . enable annotation info ) { throw new illegal argument exception ( `` please call class graph # enable class info ( ) and # enable annotation info ( ) before # scan ( ) `` ) ; } final class info class info = class name to class info . get ( annotation name ) ; return class info == null ? class info list . empty_list : class info . get class with annotation ( ) ; }
public reference type lookup by signature ( string signature ) { return ( reference type ) type map . get ( signature ) ; }
public void shutdown ( ) { shut down = true ; try { while ( inflight receive message batch > 0 ) thread . sleep ( 100 ) ; } catch ( interrupted exception e ) { thread . current thread ( ) . interrupt ( ) ; } }
public object set type value ( object object ) { struct field f = find field ( object . get class ( ) ) ; if ( f ! = null ) { active field = f ; set field value ( f . field , object ) ; return this ; } throw new illegal argument exception ( `` no field of type `` + object . get class ( ) + `` in `` + this ) ; }
public object get value ( node node ) { try { for ( class < ? > c = node . get class ( ) ; c ! = null ; c = c . get superclass ( ) ) { field [ ] field = c . get declared field ( ) ; for ( field class field : field ) { if ( class field . get name ( ) . equal ( get name ( ) ) ) { class field . set accessible ( true ) ; return class field . get ( node ) ; } } } throw new no such field error ( get name ( ) ) ; } catch ( illegal access exception e ) { throw new runtime exception ( e ) ; } }
public static string package name to path ( final string package name ) { return package name . replace ( ' . ' , '/ ' ) ; }
public boolean be blacklist ( ) { return be blacklist ; }
public boolean be specifically whitelisted ( final string str ) { return ! whitelist be empty ( ) & & be whitelisted ( str ) ; }
public static class < ? > wrapper ( class < ? > type ) { if ( type == null ) { return null ; } else if ( type . be primitive ( ) ) { if ( boolean . class == type ) { return boolean . class ; } else if ( int . class == type ) { return integer . class ; } else if ( long . class == type ) { return long . class ; } else if ( short . class == type ) { return short . class ; } else if ( byte . class == type ) { return byte . class ; } else if ( double . class == type ) { return double . class ; } else if ( float . class == type ) { return float . class ; } else if ( char . class == type ) { return character . class ; } else if ( void . class == type ) { return void . class ; } } return type ; }
public iterator iterator ( ) { return node map . value ( ) . iterator ( ) ; }
public static option builder have args ( ) { option builder . number of args = option . unlimited_values ; return instance ; }
public option add option ( string opt , boolean have arg , string description ) { add option ( opt , null , have arg , description ) ; return this ; }
public static url create u r l ( string str ) { try { return new url ( str ) ; } catch ( malformed u r l exception mue ) { system . err . println ( `` unable to parse : `` +str ) ; return null ; } }
public static sort bag decorate ( sort bag bag , class type ) { return new predicate sorted bag ( bag , instanceof predicate . get instance ( type ) ) ; }
protect bidi map get bidi map ( ) { return ( bidi map ) map ; }
public boolean be full ( ) { return size > = max size ; }
public object remove ( ) { if ( be empty ( ) ) { throw new buffer underflow exception ( `` the buffer be already empty `` ) ; } object element = m_elements [ m_start ] ; if ( null ! = element ) { m_elements [ m_start++ ] = null ; if ( m_start > = max element ) { m_start = 0 ; } m_full = false ; } return element ; }
public object remove ( ) { synchronize ( lock ) { while ( collection . be empty ( ) ) { try { if ( timeout < = 0 ) { lock . wait ( ) ; } else { return remove ( timeout ) ; } } catch ( interrupted exception e ) { print writer out = new print writer ( new string writer ( ) ) ; e . print stack trace ( out ) ; throw new buffer underflow exception ( `` cause by interrupted exception : `` + out . to string ( ) ) ; } } return get buffer ( ) . remove ( ) ; } }
public static comparator transform comparator ( comparator comparator , transformer transformer ) { if ( comparator == null ) { comparator = natural_comparator ; } return new transform comparator ( transformer , comparator ) ; }
public static < e > closure < e > chain closure ( final closure < ? super e > . . . closure ) { return chain closure . chain closure ( closure ) ; }
public static transformer switch map transformer ( map object and transformer ) { transformer [ ] trs = null ; predicate [ ] preds = null ; if ( object and transformer == null ) { throw new illegal argument exception ( `` the object and transformer map must not be null `` ) ; } transformer def = ( transformer ) object and transformer . remove ( null ) ; int size = object and transformer . size ( ) ; trs = new transformer [ size ] ; preds = new predicate [ size ] ; int i = 0 ; for ( iterator it = object and transformer . entry set ( ) . iterator ( ) ; it . have next ( ) ; ) { map . entry entry = ( map . entry ) it . next ( ) ; preds [ i ] = equal predicate . get instance ( entry . get key ( ) ) ; trs [ i ] = ( transformer ) entry . get value ( ) ; i++ ; } return switch transformer ( preds , trs , def ) ; }
public static void transform ( collection collection , transformer transformer ) { if ( collection ! = null & & transformer ! = null ) { if ( collection instanceof list ) { list list = ( list ) collection ; for ( list iterator it = list . list iterator ( ) ; it . have next ( ) ; ) { it . set ( transformer . transform ( it . next ( ) ) ) ; } } else { collection result collection = collect ( collection , transformer ) ; collection . clear ( ) ; collection . add all ( result collection ) ; } } }
public static void select reject ( collection input collection , predicate predicate , collection output collection ) { if ( input collection ! = null & & predicate ! = null ) { for ( iterator iter = input collection . iterator ( ) ; iter . have next ( ) ; ) { object item = iter . next ( ) ; if ( predicate . evaluate ( item ) == false ) { output collection . add ( item ) ; } } } }
public boolean add last ( object o ) { insert listable ( _head . prev ( ) , null , o ) ; return true ; }
public object remove last ( ) { if ( _head . prev ( ) ! = null ) { object val = _head . prev ( ) . value ( ) ; remove listable ( _head . prev ( ) ) ; return val ; } else { throw new no such element exception ( ) ; } }
public int hash code ( ) { int hash code = get class ( ) . hash code ( ) ; for ( int b : byte ) { hash code += b ; } return hash code ; }
public object clone ( ) { fast tree map result = null ; if ( fast ) { result = new fast tree map ( map ) ; } else { synchronize ( map ) { result = new fast tree map ( map ) ; } } result . set fast ( get fast ( ) ) ; return ( result ) ; }
public boolean be empty ( ) { if ( fast ) { return ( map . be empty ( ) ) ; } else { synchronize ( map ) { return ( map . be empty ( ) ) ; } } }
public boolean remove ( object element ) { if ( fast ) { synchronize ( this ) { array list temp = ( array list ) list . clone ( ) ; boolean result = temp . remove ( element ) ; list = temp ; return ( result ) ; } } else { synchronize ( list ) { return ( list . remove ( element ) ) ; } } }
public object [ ] to array ( ) { if ( fast ) { return ( list . to array ( ) ) ; } else { synchronize ( list ) { return ( list . to array ( ) ) ; } } }
public predicate [ ] get predicate ( ) { return new predicate [ ] { i predicate } ; }
public transformer get transformer ( ) throw tika exception { transformer transformer = get ( transformer . class ) ; if ( transformer ! = null ) { return transformer ; } return x m l reader utils . get transformer ( ) ; }
public e previous ( ) throw no such element exception { if ( iterator instanceof list iterator ) { @ suppress warning ( `` unchecked `` ) final list iterator < e > li = ( list iterator < e > ) iterator ; return li . previous ( ) ; } if ( current index == 0 ) { throw new no such element exception ( ) ; } remove state = wrap iterator index == current index ; return list . get ( -- current index ) ; }
public map iterator map iterator ( ) { if ( be empty ( ) ) { return empty order map iterator . instance ; } return new view map iterator ( this , key ) ; }
public static type binding create ( class < ? > erase type , list < resolve type > type list ) { resolve type [ ] type = ( type list == null || type list . be empty ( ) ) ? no_types : type list . to array ( new resolve type [ type list . size ( ) ] ) ; return create ( erased type , type ) ; }
public void put all ( map map ) { iterator it = map . entry set ( ) . iterator ( ) ; while ( it . have next ( ) ) { map . entry entry = ( map . entry ) it . next ( ) ; put ( entry . get key ( ) , entry . get value ( ) ) ; } }
protect void remove entry ( hash entry entry , int hash index , hash entry previous ) { if ( previous == null ) { data [ hash index ] = entry . next ; } else { previous . next = entry . next ; } }
public k first key ( ) { if ( size == 0 ) { throw new no such element exception ( `` map be empty `` ) ; } return header . after . get key ( ) ; }
public k last key ( ) { if ( size == 0 ) { throw new no such element exception ( `` map be empty `` ) ; } return header . before . get key ( ) ; }
protect hash entry create entry ( hash entry next , int hash code , object key , object value ) { return new hash entry ( next , hash code , key , value ) ; }
protect void remove entry ( hash entry entry , int hash index , hash entry previous ) { link entry link = ( link entry ) entry ; link . before . after = link . after ; link . after . before = link . before ; link . after = null ; link . before = null ; super . remove entry ( entry , hash index , previous ) ; }
public void set mutator ( collection mutator mutator ) { super . set mutator ( mutator ) ; }
public v put ( final k key , final v value ) { if ( this . mutator == null ) { throw new unsupported operation exception ( `` no mutator specify `` ) ; } return this . mutator . put ( this , this . composite , key , value ) ; }
public void put all ( map map ) { iterator it = map . entry set ( ) . iterator ( ) ; while ( it . have next ( ) ) { map . entry entry = ( map . entry ) it . next ( ) ; put ( entry . get key ( ) , entry . get value ( ) ) ; } }
public static map get map ( map map , object key , map default value ) { map answer = get map ( map , key ) ; if ( answer == null ) { answer = default value ; } return answer ; }
public static < k > short get short ( final map < ? super k , ? > map , final k key ) { final number answer = get number ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof short ) { return ( short ) answer ; } return short . value of ( answer . short value ( ) ) ; }
public static < k > double get double ( final map < ? super k , ? > map , final k key ) { final number answer = get number ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof double ) { return ( double ) answer ; } return double . value of ( answer . double value ( ) ) ; }
public static boolean be empty ( map map ) { return ( map == null || map . be empty ( ) ) ; }
public static sort map predicate sort map ( sort map map , predicate key pred , predicate value pred ) { return predicate sort map . decorate ( map , key pred , value pred ) ; }
public static multi value map decorate ( map map , class collection class ) { return new multi value map ( map , new reflection factory ( collection class ) ) ; }
public static multi value map decorate ( map map , class collection class ) { return new multi value map ( map , new reflection factory ( collection class ) ) ; }
public object get ( int key ) { for ( i entry entry = table [ index for ( key ) ] ; entry ! = null ; entry = entry . get next ( ) ) if ( entry . get key ( ) == key ) { object value = entry . get value ( ) ; if ( value == null ) { purge ( ) ; } return value ; } return null ; }
public static sort set decorate ( sorted set set , class type ) { return new predicate sort set ( set , instanceof predicate . get instance ( type ) ) ; }
public boolean be empty ( ) { process queue ( ) ; return hash . be empty ( ) ; }
public synchronize object pop ( ) throw no such element exception { return m_priority queue . pop ( ) ; }
public static transformer chain transformer ( transformer [ ] transformer ) { return chain transformer . get instance ( transformer ) ; }
public boolean be response available ( ) throw i o exception { log . trace ( `` enter http connection . be response available ( ) `` ) ; if ( this . be open ) { return this . input stream . available ( ) > 0 ; } else { return false ; } }
public void close ( ) throw i o exception { if ( ! close ) { this . finish ( ) ; this . buffer . close ( ) ; out . close ( ) ; close = true ; } }
public void set list delimiter ( char list delimiter ) { ( ( base configuration ) get in memory configuration ( ) ) . set list delimiter ( list delimiter ) ; super . set list delimiter ( list delimiter ) ; }
public void set delimiter parse disabled ( boolean delimiter parse disable ) { this . delimiter parse disabled = delimiter parse disable ; }
public void set throw exception on miss ( boolean throw exception on miss ) { this . throw exception on miss = throw exception on miss ; }
public void register local lookup ( configuration interpolator interpolator ) { interpolator . local lookup . put all ( local lookup ) ; }
public void add error listener ( configuration error listener l ) { check listener ( l ) ; error listener . add ( l ) ; }
public void save ( file file ) throw configuration exception { output stream out = null ; try { out = file system . get output stream ( file ) ; save ( out ) ; } finally { close silent ( out ) ; } }
public void save ( writer writer ) throw configuration exception { enter no reload ( ) ; try { get layout ( ) . save ( writer ) ; } finally { exit no reload ( ) ; } }
protect file configuration delegate create delegate ( ) { return new file configuration delegate ( ) ; }
public boolean be empty ( ) { if ( fast ) { return ( map . be empty ( ) ) ; } else { synchronize ( map ) { return ( map . be empty ( ) ) ; } } }
public void set file ( file file ) { source u r l = null ; set file name ( file . get name ( ) ) ; set base path ( ( file . get parent file ( ) ! = null ) ? file . get parent file ( ) . get absolute path ( ) : null ) ; }
public configuration key common key ( configuration key other ) { if ( other == null ) { throw new illegal argument exception ( `` other key must no be null ! `` ) ; } configuration key result = new configuration key ( ) ; key iterator it1 = iterator ( ) ; key iterator it2 = other . iterator ( ) ; while ( it1 . have next ( ) & & it2 . have next ( ) & & part equal ( it1 , it2 ) ) { if ( it1 . be attribute ( ) ) { result . append attribute ( it1 . current key ( ) ) ; } else { result . append ( it1 . current key ( ) ) ; if ( it1 . have index ) { result . append index ( it1 . get index ( ) ) ; } } } return result ; }
public static file to file ( url url ) { if ( url == null || ! `` file `` . equal ignore case ( url . get protocol ( ) ) ) { return null ; } else { string filename = url . get file ( ) . replace ( '/ ' , file . separator char ) ; filename = decode url ( filename ) ; return new file ( filename ) ; } }
protect void fire element end ( string name ) { if ( get exception ( ) == null ) { try { get content handler ( ) . end element ( ns_uri , name , name ) ; } catch ( s a x exception ex ) { exception = ex ; } } }
public static list < short > get at ( short [ ] array , range range ) { return primitive array get ( array , range ) ; }
public static short [ ] to object ( final short [ ] array ) { if ( array == null ) { return null ; } else if ( array . length == 0 ) { return empty_short_object_array ; } final short [ ] result = new short [ array . length ] ; for ( int i = 0 ; i < array . length ; i++ ) { result [ i ] = short . value of ( array [ i ] ) ; } return result ; }
public synchronize list < long > key ( boolean cold , boolean non resident ) { array list < long > key = new array list < long > ( ) ; for ( segment < v > s : segment ) { key . add all ( s . key ( cold , non resident ) ) ; } return key ; }
public big integer [ ] get big integer array ( string key ) { return get big integer array ( key , new big integer [ 0 ] ) ; }
public list < url > get u r l list ( string key ) { return get u r l list ( key , new array list < url > ( ) ) ; }
public color [ ] get color array ( string key ) { return get color array ( key , new color [ 0 ] ) ; }
public configuration provider remove configuration provider ( string tag name ) { return provider . remove ( tag name ) ; }
public boolean remove configuration ( configuration config ) { for ( int index = 0 ; index < get number of configuration ( ) ; index++ ) { if ( configuration . get ( index ) . get configuration ( ) == config ) { remove configuration at ( index ) ; return true ; } } return false ; }
public string get raw property value ( string key ) { string value = super . get property ( key ) ; if ( value ! = null ) { return value ; } for ( property property : default ) { value = property . get property ( key ) ; if ( value ! = null ) { return value ; } } return null ; }
public void add configuration listener ( configuration listener l ) { check listener ( l ) ; listener . add ( l ) ; }
public event detail get event detail ( int a row ) { synchronize ( m lock ) { return m filtered event [ a row ] ; } }
public boolean remove error listener ( configuration error listener l ) { return error listener . remove ( l ) ; }
public file system add zip file ( path zip file ) { if ( ! file . be regular file ( zip file ) ) { throw new illegal argument exception ( `` not a regular file : `` + zip file ) ; } uri zip uri = uri . create ( `` zip : `` + zip file . to uri ( ) ) ; try { file system fs = file system . get file system ( zip uri ) ; resource to close . add ( fs ) ; return f ; } catch ( file system not find exception | provider not find exception e ) { reporter . error ex ( `` can not open zip file `` + zip file , e ) ; return null ; } }
public configuration node get root node ( ) { if ( combined root == null ) { combined root = construct combine node ( ) ; } return combined root ; }
public object get property ( string key ) { list < configuration node > nod = fetch node list ( key ) ; if ( node . size ( ) == 0 ) { return null ; } else { list < object > list = new array list < object > ( ) ; for ( configuration node node : node ) { if ( node . get value ( ) ! = null ) { list . add ( node . get value ( ) ) ; } } if ( list . size ( ) < 1 ) { return null ; } else { return ( list . size ( ) == 1 ) ? list . get ( 0 ) : list ; } } }
public list < configuration node > query ( configuration node root , string key ) { list < configuration node > nod = new link list < configuration node > ( ) ; find node for key ( new default configuration key ( this , key ) . iterator ( ) , root , node ) ; return node ; }
public void set configuration ( abstract configuration config ) { this . configuration = config ; }
public string get response ( ) throw i o exception { result . set length ( 0 ) ; string line = reader . read line ( ) ; if ( line ! = null & & line . length ( ) > = 3 ) { result . append ( line . substring ( 0 , 3 ) ) ; result . append ( `` `` ) ; } while ( line ! = null ) { append ( line ) ; if ( ! have more line ( line ) ) { break ; } line = reader . read line ( ) ; } return result . to string ( ) . trim ( ) ; }
public static void register global lookup ( string prefix , str lookup lookup ) { if ( prefix == null ) { throw new illegal argument exception ( `` prefix for lookup object must not be null ! `` ) ; } if ( lookup == null ) { throw new illegal argument exception ( `` lookup object must not be null ! `` ) ; } synchronize ( global lookup ) { global lookup . put ( prefix , lookup ) ; } }
public void set parent interpolator ( configuration interpolator parent interpolator ) { this . parent interpolator = parent interpolator ; }
protect void stop ( ) { add info ( `` logback context be closed via shutdown hook `` ) ; context hook context = get context ( ) ; if ( hook context instanceof context base ) { context base context = ( context base ) hook context ; context . stop ( ) ; } }
public void set refresh delay ( long refresh delay ) { this . refresh delay = refresh delay ; }
public static synchronize void set default expression engine ( expression engine engine ) { if ( engine == null ) { throw new illegal argument exception ( `` default expression engine must not be null ! `` ) ; } default expression engine = engine ; }
public string trim leave ( string key ) { if ( key == null ) { return string utils . empty ; } else { string result = key ; while ( have lead delimiter ( result ) ) { result = result . substring ( get expression engine ( ) . get property delimiter ( ) . length ( ) ) ; } return result ; } }
protect void remove node ( configuration node node ) { configuration node parent = node . get parent node ( ) ; if ( parent ! = null ) { parent . remove child ( node ) ; if ( ! node define ( parent ) ) { remove node ( parent ) ; } } }
public int get child count ( ) { return child . get sub node ( ) . size ( ) ; }
public node child node ( int index ) { return child node . get ( index ) ; }
public void remove last child ( ) { if ( child ! =null ) { child . remove ( child . size ( ) -1 ) ; } }
public list < configuration node > get attribute ( ) { return attribute . get sub node ( ) ; }
public int index of ( int ch , int begin index , int end index ) { if ( begin index < 0 ) { begin index = 0 ; } if ( end index > this . len ) { end index = this . len ; } if ( begin index > end index ) { return -1 ; } for ( int i = begin index ; i < end index ; i++ ) { if ( this . buffer [ i ] == ch ) { return i ; } } return -1 ; }
public boolean be attribute ( ) { return node . be attribute ( ) ; }
public static void set node name ( string node name ) { node name pattern converter . set node name ( node name ) ; }
public path [ ] resolve index folder ( string index folder name ) { if ( node path == null || lock == null ) { throw new illegal state exception ( `` node be not configure to store local location `` ) ; } assert env be lock ( ) ; list < path > path = new array list < > ( node path . length ) ; for ( node path node path : node path ) { path index folder = node path . index path . resolve ( index folder name ) ; if ( file . exists ( index folder ) ) { path . add ( index folder ) ; } } return path . to array ( new path [ path . size ( ) ] ) ; }
public void add tight source node ( a s t node reference ) { f tight source range node . add ( reference ) ; list < structural property descriptor > properties= reference . structural property for type ( ) ; for ( structural property descriptor descriptor : property ) { if ( descriptor . be child property ( ) ) { a s t node child= ( a s t node ) reference . get structural property ( descriptor ) ; if ( child ! = null & & be extend ( child , reference ) ) { add tight source node ( child ) ; } } else if ( descriptor . be child list property ( ) ) { for ( a s t node child : a s t node . get child list property ( reference , ( child list property descriptor ) descriptor ) ) { if ( be extend ( child , reference ) ) { add tight source node ( child ) ; } } } } }
public void init property ( document document , boolean elem ref ) { if ( document . get doctype ( ) ! = null ) { set public i d ( document . get doctype ( ) . get public id ( ) ) ; set system i d ( document . get doctype ( ) . get system id ( ) ) ; } construct hierarchy ( get root ( ) , document . get document element ( ) , elem ref , true ) ; get root node ( ) . set name ( document . get document element ( ) . get node name ( ) ) ; if ( elem ref ) { get root ( ) . set reference ( document . get document element ( ) ) ; } }
public void set schema validation ( boolean schema validation ) { this . schema validation = schema validation ; if ( schema validation ) { this . validate = true ; } }
public document get document ( ) { return document ; } // get document ( )
public void set output property ( property property ) { if ( property == null ) { local output property = null ; } else { enumeration key = property . property name ( ) ; while ( key . have more element ( ) ) { string key = ( string ) key . next element ( ) ; set output property ( key , property . get property ( key ) ) ; } } }
public map get bean property ( ) { map prop = new hash map ( ) ; for ( iterator it = get node ( ) . get attribute ( ) . iterator ( ) ; it . have next ( ) ; ) { configuration node attr = ( configuration node ) it . next ( ) ; if ( ! be reserve node ( attr ) ) { prop . put ( attr . get name ( ) , interpolate ( attr . get value ( ) ) ) ; } } return prop ; }
public boolean equal ( object c ) { if ( c == null ) { return false ; } return key buffer . to string ( ) . equal ( c . to string ( ) ) ; }
public int hash code ( ) { int hash code = 0 ; for ( entry < key < ? > , object > e : data . entry set ( ) ) { hash code += object . hash code ( e . get key ( ) , e . get value ( ) ) ; } return hash code ; }
public configuration interpolate configuration ( ) { hierarchical configuration c = ( hierarchical configuration ) clone ( ) ; c . get root node ( ) . visit ( new configuration node visitor adapter ( ) { public void visit after child ( configuration node node ) { node . set value ( interpolate ( node . get value ( ) ) ) ; } } ) ; return c ; }
public object put ( object key , object value ) { string str key = string . value of ( key ) ; object old = configuration . get property ( str key ) ; configuration . set property ( str key , value ) ; return old ; }
public void clear tree ( string key ) { fire event ( event_clear_tree , key , null , true ) ; list < configuration node > nod = fetch node list ( key ) ; for ( configuration node node : node ) { remove node ( node ) ; } fire event ( event_clear_tree , key , node , false ) ; }
protect node create node ( string name ) { return get parent ( ) . create node ( name ) ; }
public configuration get configuration ( ) { return pipeline configuration . get configuration ( ) ; }
protect void add property direct ( string key , object value ) { throw new unsupported operation exception ( `` configuration be read-only ! `` ) ; }
public void println ( final appendable out ) throw i o exception { if ( get trail delimiter ( ) ) { out . append ( get delimiter ( ) ) ; } if ( record separator ! = null ) { out . append ( record separator ) ; } }
public boolean be null ( ) { return get value ( ) ! = null ; }
public character get quote character ( ) { return quote character ; }
public string to string ( ) { string buffer buf = new string buffer ( ) ; buf . append ( `` log record : [ `` + _level + `` , `` + _message + `` ] `` ) ; return ( buf . to string ( ) ) ; }
public string to string ( ) { return super . to string ( ) + `` [ name : `` + get name ( ) + `` params : `` + invoker helper . to string ( get parameter type ( ) ) + `` return : `` + get return type ( ) + `` owner : `` + get declare class ( ) + `` ] `` ; }
public void evict all ( ) { list < real connection > evict connection = new array list < > ( ) ; synchronize ( this ) { for ( iterator < real connection > i = connection . iterator ( ) ; i . have next ( ) ; ) { real connection connection = i . next ( ) ; if ( connection . allocation . be empty ( ) ) { connection . no new stream = true ; evict connection . add ( connection ) ; i . remove ( ) ; } } } for ( real connection connection : evicted connection ) { util . close quietly ( connection . get socket ( ) ) ; } }
public boolean be auto commit ( ) { return auto commit ; }
public void set cache state ( final boolean cache state ) { this . cache state = cache state ; }
public void set fail fast ( boolean fail fast ) { this . fail fast = fail fast ; }
public synchronize void set max idle ( final int max idle ) { this . max idle = max idle ; if ( connection pool ! = null ) { connection pool . set max idle ( max idle ) ; } }
public synchronize void set max wait millis ( final long max wait millis ) { this . max wait millis = max wait millis ; if ( connection pool ! = null ) { connection pool . set max wait millis ( max wait millis ) ; } }
public synchronize void set min idle ( final int min idle ) { this . min idle = min idle ; if ( connection pool ! = null ) { connection pool . set min idle ( min idle ) ; } }
public boolean get remove abandon on maintenance ( ) { final abandon config ac = this . abandon config ; return ac ! = null & & ac . get remove abandon on maintenance ( ) ; }
public agroal connection factory configuration supplier auto commit ( boolean auto commit enable ) { check lock ( ) ; auto commit = auto commit enable ; return this ; }
public synchronize string get eviction policy class name ( ) { return eviction policy class name ; }
public void set max total connection ( int max total connection ) { this . params . get max total connection ( ) ; }
public final void set test while idle ( final boolean test while idle ) { this . test while idle = test while idle ; }
public synchronize boolean be access to underlie connection allow ( ) { return this . access to underlie connection allow ; }
public connection get delegate ( ) { if ( be access to underlie connection allow ( ) ) { return get delegate internal ( ) ; } return null ; }
protect connection get connection from driver ( @ nullable string username , @ nullable string password ) throw s q l exception { property merge prop = new property ( ) ; property conn prop = get connection property ( ) ; if ( conn prop ! = null ) { merge prop . put all ( conn prop ) ; } if ( username ! = null ) { merge prop . set property ( `` user `` , username ) ; } if ( password ! = null ) { merge prop . set property ( `` password `` , password ) ; } connection con = get connection from driver ( merge prop ) ; if ( this . catalog ! = null ) { con . set catalog ( this . catalog ) ; } if ( this . schema ! = null ) { con . set schema ( this . schema ) ; } return con ; }
public void set user ( final string v ) { assert initialization allow ( ) ; this . user name = v ; update ( connection property , key_user , v ) ; }
public int get num idle ( final string user name ) { final object pool < pool connection and info > pool = get pool ( get pool key ( user name ) ) ; return pool == null ? 0 : pool . get num idle ( ) ; }
public boolean be return parameter ( ) { return ( this . function ? this . parameter type == database meta data . function return : ( this . parameter type == database meta data . procedure column return || this . parameter type == database meta data . procedure column result ) ) ; }
public void close ( ) throw s q l exception { if ( ! close ) { close internal ( ) ; } }
public column get column ( int index ) { return column [ index ] ; }
public string get string ( final string key , final object . . . args ) { string value = get string ( key ) ; if ( value == null ) { value = key ; } message format mf = new message format ( value ) ; mf . set locale ( locale ) ; return mf . format ( args , new string buffer ( ) , null ) . to string ( ) ; }
public void set uri charset ( string charset ) { set parameter ( http_uri_charset , charset ) ; }
public void close ( ) throw i o exception { try { left . close ( ) ; } finally { right . close ( ) ; } }
public int read ( char [ ] chr , int st , int end ) throw i o exception { return in . read ( chr , st , end ) ; }
public void close ( ) throw i o exception { super . close ( ) ; target . close ( ) ; }
public static int last index of ( char [ ] array , char value to find ) { return last index of ( array , value to find , integer . max_value ) ; }
public to string builder reflection append array ( object array ) { this . get style ( ) . reflection append array detail ( this . get string buffer ( ) , null , array ) ; return this ; }
public static int hash code ( char sequence value ) { if ( value == null ) { return 0 ; } if ( value instanceof ascii string ) { return value . hash code ( ) ; } return platform dependent . hash code ascii ( value ) ; }
public long get nano time ( ) { if ( this . run state == state_stopped || this . run state == state_suspended ) { return this . stop time - this . start time ; } else if ( this . run state == state_unstarted ) { return 0 ; } else if ( this . run state == state_running ) { return system . nano time ( ) - this . start time ; } throw new runtime exception ( `` illegal run state have occur . `` ) ; }
public void split ( ) { if ( this . run state ! = state_running ) { throw new illegal state exception ( `` stopwatch be not run . `` ) ; } this . stop time = system . current time millis ( ) ; this . split state = state_split ; }
public static void no null element ( object [ ] array , string message ) { if ( array ! = null ) { for ( int i = 0 ; i < array . length ; i++ ) { if ( array [ i ] == null ) { throw new illegal argument exception ( message ) ; } } } }
public static multi key map decorate ( abstract hash map map ) { if ( map == null ) { throw new illegal argument exception ( `` map must not be null `` ) ; } if ( map . size ( ) > 0 ) { throw new illegal argument exception ( `` map must be empty `` ) ; } return new multi key map ( map ) ; }
public void trace ( object message , throwable t ) { if ( is12 ) { get logger ( ) . log ( fqcn , ( priority ) level . debug , message , t ) ; } else { get logger ( ) . log ( fqcn , level . debug , message , t ) ; } }
public void debug ( object message , throwable t ) { if ( is12 ) { get logger ( ) . log ( fqcn , ( priority ) level . debug , message , t ) ; } else { get logger ( ) . log ( fqcn , level . debug , message , t ) ; } }
public void error ( object message ) { if ( is12 ) { get logger ( ) . log ( fqcn , ( priority ) level . error , message , null ) ; } else { get logger ( ) . log ( fqcn , level . error , message , null ) ; } }
public void error ( object message , throwable t ) { if ( is12 ) { get logger ( ) . log ( fqcn , ( priority ) level . error , message , t ) ; } else { get logger ( ) . log ( fqcn , level . error , message , t ) ; } }
public void fatal ( object message , throwable t ) { category . log ( fqcn , priority . fatal , message , t ) ; }
public void fatal ( object message , throwable t ) { if ( is12 ) { get logger ( ) . log ( fqcn , ( priority ) level . fatal , message , t ) ; } else { get logger ( ) . log ( fqcn , level . fatal , message , t ) ; } }
public void trace ( object message , throwable t ) { debug ( message , t ) ; }
public composable function fix1st argument ( final double fix x ) { return new composable function ( ) { @ override / * * { @ inherit doc } * / public double value ( double x ) throw function evaluation exception { return binary function . this . value ( fix x , x ) ; } } ; }
public composable function divide ( final univariate real function f ) { return new composable function ( ) { @ override / * * { @ inherit doc } * / public double value ( double x ) throw function evaluation exception { return composable function . this . value ( x ) / f . value ( x ) ; } } ; }
public polynomial function polynomial derivative ( ) { return new polynomial function ( differentiate ( coefficient ) ) ; }
public static plane construct normalize x plane ( final double y , final double z , final double d value ) { if ( math . ab ( y ) < minimum_resolution & & math . ab ( z ) < minimum_resolution ) return null ; final double denom = 1 . 0 / math . sqrt ( y * y + z * z ) ; return new plane ( 0 . 0 , z * denom , -y * denom , d value ) ; }
protect void verify interval ( final double lower , final double upper ) { if ( low > = upper ) { throw math runtime exception . create illegal argument exception ( `` endpoint do not specify an interval : [ { 0 } , { 1 } ] `` , low , upper ) ; } }
public void set scale type ( string scale ) { fit . set name ( c o s name . s , scale ) ; }
public double cumulative probability ( double x ) throw math exception { return cumulative probability ( ( int ) math . floor ( x ) ) ; }
public double probability ( final int x ) { if ( x < = 0 || x > number of element ) { return 0 . 0 ; } return ( 1 . 0 / math . pow ( x , exponent ) ) / generalize harmonic ( number of element , exponent ) ; }
public double [ ] guess parameter error ( estimation problem problem ) throw estimation exception { int m = problem . get measurement ( ) . length ; int p = problem . get unbound parameter ( ) . length ; if ( m < = p ) { throw new estimation exception ( `` no degree of freedom ( { 0 } measurement , { 1 } parameter ) `` , m , p ) ; } double [ ] error = new double [ problem . get unbound parameter ( ) . length ] ; final double c = math . sqrt ( get chi square ( problem ) / ( m - p ) ) ; double [ ] [ ] covar = get covariance ( problem ) ; for ( int i = 0 ; i < error . length ; ++i ) { error [ i ] = math . sqrt ( covar [ i ] [ i ] ) * c ; } return error ; }
public levenberg marquardt optimizer with ortho tolerance ( double new ortho tolerance ) { return new levenberg marquardt optimizer ( initial step bound factor , cost relative tolerance , par relative tolerance , new ortho tolerance , qr rank threshold ) ; }
public void add param ( parameter p ) { param vec . add element ( p ) ; }
public clean command set ignore ( boolean ignore ) { this . ignore = ignore ; return this ; }
public long long value ( ) { return numerator . divide ( denominator ) . long value ( ) ; }
public long long value ( ) { return numerator . divide ( denominator ) . long value ( ) ; }
public boolean be satisfied ( final population population ) { if ( this . num generation < this . max generation ) { num generations++ ; return false ; } return true ; }
protect void check addition compatible ( final field matrix < t > m ) { if ( ( get row dimension ( ) ! = m . get row dimension ( ) ) || ( get column dimension ( ) ! = m . get column dimension ( ) ) ) { throw math runtime exception . create illegal argument exception ( `` { 0 } x { 1 } and { 2 } x { 3 } matrix be not addition compatible `` , get row dimension ( ) , get column dimension ( ) , m . get row dimension ( ) , m . get column dimension ( ) ) ; } }
public big matrix get row matrix ( int row ) throw matrix index exception { matrix utils . check row index ( this , row ) ; final int ncols = this . get column dimension ( ) ; final big decimal [ ] [ ] out = new big decimal [ 1 ] [ ncols ] ; system . arraycopy ( data [ row ] , 0 , out [ 0 ] , 0 , ncols ) ; return new big matrix impl ( out , false ) ; }
public big decimal [ ] pre multiply ( big decimal [ ] v ) throw illegal argument exception { final int n row = this . get row dimension ( ) ; if ( v . length ! = n row ) { throw math runtime exception . create illegal argument exception ( `` vector length mismatch : get { 0 } but expect { 1 } `` , v . length , n row ) ; } final int n cols = this . get column dimension ( ) ; final big decimal [ ] out = new big decimal [ n cols ] ; for ( int col = 0 ; col < n col ; col++ ) { big decimal sum = zero ; for ( int i = 0 ; i < n row ; i++ ) { sum = sum . add ( data [ i ] [ col ] . multiply ( v [ i ] ) ) ; } out [ col ] = sum ; } return out ; }
public big matrix copy ( ) { return new big matrix impl ( this . copy out ( ) , false ) ; }
public double get distance ( open map real vector v ) throw dimension mismatch exception { check vector dimension ( v . get dimension ( ) ) ; iterator iter = entry . iterator ( ) ; double re = 0 ; while ( iter . have next ( ) ) { iter . advance ( ) ; int key = iter . key ( ) ; double delta ; delta = iter . value ( ) - v . get entry ( key ) ; res += delta * delta ; } iter = v . get entry ( ) . iterator ( ) ; while ( iter . have next ( ) ) { iter . advance ( ) ; int key = iter . key ( ) ; if ( ! entry . contains key ( key ) ) { final double value = iter . value ( ) ; res += value * value ; } } return fast math . sqrt ( re ) ; }
public double [ ] get argument ( ) { return argument . clone ( ) ; }
public static arithmetic exception create arithmetic exception ( final string pattern , final object . . . argument ) { return new arithmetic exception ( ) { / * * serializable version identifier . * / private static final long serial version u i d = 7705628723242533939l ; / * * { @ inherit doc } * / @ override public string get message ( ) { return build message ( locale . u , pattern , argument ) ; } / * * { @ inherit doc } * / @ override public string get localized message ( ) { return build message ( locale . get default ( ) , pattern , argument ) ; } } ; }
protect void init integration ( final double t0 , final double [ ] y0 , final double t ) { evaluation = evaluation . with start ( 0 ) ; for ( final event state state : event state ) { state . set expandable ( expandable ) ; state . get event handler ( ) . init ( t0 , y0 , t ) ; } for ( step handler handler : step handler ) { handler . init ( t0 , y0 , t ) ; } set state initialize ( false ) ; }
public void handle step ( final step interpolator interpolator , final boolean be last ) { }
public long next long ( long low , long upper ) { if ( low > = upper ) { throw math runtime exception . create illegal argument exception ( `` upper bound ( { 0 } ) must be great than low bound ( { 1 } ) `` , upper , low ) ; } double r = get ran ( ) . next double ( ) ; return ( long ) ( ( r * upper ) + ( ( 1 . 0 - r ) * low ) + r ) ; }
public long next secure long ( long low , long upper ) { if ( low > = upper ) { throw math runtime exception . create illegal argument exception ( `` upper bound ( { 0 } ) must be great than low bound ( { 1 } ) `` , upper , low ) ; } secure random sec = get sec ran ( ) ; return low + ( long ) ( sec . next double ( ) * ( upper - low + 1 ) ) ; }
public real matrix compute correlation matrix ( final double [ ] [ ] matrix ) { return compute correlation matrix ( new block real matrix ( matrix ) ) ; }
public double get value ( double quantile ) { if ( quantile < 0 . 0 || quantile > 1 . 0 || double . be na n ( quantile ) ) { throw new illegal argument exception ( quantile + `` be not in [ 0 . . 1 ] range `` ) ; } if ( value . length == 0 ) { return 0 . 0 ; } final double po = quantile * ( value . length + 1 ) ; final int index = ( int ) po ; if ( index < 1 ) { return value [ 0 ] ; } if ( index > = value . length ) { return value [ value . length - 1 ] ; } final double low = value [ index - 1 ] ; final double upper = value [ index ] ; return low + ( pos - floor ( po ) ) * ( upper - low ) ; }
public static unknown distribution chi square test get unknown distribution chi square test ( ) { return unknown distribution chi square test ; }
public double t test ( double [ ] sample1 , double [ ] sample2 ) throw illegal argument exception , math exception { check sample data ( sample1 ) ; check sample data ( sample2 ) ; return t test ( stat utils . mean ( sample1 ) , stat utils . mean ( sample2 ) , stat utils . variance ( sample1 ) , stat utils . variance ( sample2 ) , sample1 . length , sample2 . length ) ; }
public double t test ( double [ ] sample1 , double [ ] sample2 ) throw illegal argument exception , math exception { check sample data ( sample1 ) ; check sample data ( sample2 ) ; return t test ( stat utils . mean ( sample1 ) , stat utils . mean ( sample2 ) , stat utils . variance ( sample1 ) , stat utils . variance ( sample2 ) , sample1 . length , sample2 . length ) ; }
public double [ ] transform ( double f [ ] ) throw illegal argument exception { return fct ( f ) ; }
public static boolean equal include na n ( double x , double y , double eps ) { return equal include na n ( x , y ) || ( fast math . ab ( y - x ) < = eps ) ; }
public static byte sign ( final byte x ) { return ( x == zb ) ? zb : ( x > zb ) ? pb : nb ; }
public static float indicator ( final float x ) { if ( float . be na n ( x ) ) { return float . na n ; } return ( x > = 0 . 0f ) ? 1 . 0f : -1 . 0f ; }
public static float indicator ( final float x ) { if ( float . be na n ( x ) ) { return float . na n ; } return ( x > = 0 . 0f ) ? 1 . 0f : -1 . 0f ; }
public static double normalize angle ( double a , double center ) { return a - two_pi * fast math . floor ( ( a + fast math . pi - center ) / two_pi ) ; }
public static double distance1 ( double [ ] p1 , double [ ] p2 ) { double sum = 0 ; for ( int i = 0 ; i < p1 . length ; i++ ) { sum += math . ab ( p1 [ i ] - p2 [ i ] ) ; } return sum ; }
public int num element ( ) { return num element ( shape copy ) ; }
public int get expansion mode ( ) { return expansion mode ; }
public static boolean equal include na n ( float x , float y , float eps ) { return equal include na n ( x , y ) || ( fast math . ab ( y - x ) < = eps ) ; }
public static entity input stream create ( input stream input stream ) { if ( input stream instanceof entity input stream ) { return ( entity input stream ) input stream ; } return new entity input stream ( input stream ) ; }
public final void buffer send ( t f t p packet packet ) throw i o exception { _socket_ . send ( packet . _new datagram ( __send datagram , _send buffer ) ) ; }
public int get local port ( ) { return this . request . get local port ( ) ; }
public int send data ( string command ) throw i o exception { return send command with i d ( null , command , null ) ; }
public boolean reinitialize ( ) throw i o exception { rein ( ) ; if ( f t p reply . be positive completion ( _reply code ) || ( f t p reply . be positive preliminary ( _reply code ) & & f t p reply . be positive completion ( get reply ( ) ) ) ) { __init default ( ) ; return true ; } return false ; }
public int list ( ) throw i o exception { return send command ( n n t p command . list ) ; }
public int pasv ( ) throw i o exception { return send command ( f t p command . pasv ) ; }
public int send command ( int command , string args ) throw i o exception { return send command ( f t p command . _commands [ command ] , args ) ; }
public int help ( ) throw i o exception { return send command ( s m t p command . help ) ; }
public int get data connection mode ( ) { return __data connection mode ; }
public output stream store unique file stream ( ) throw i o exception { return __store file stream ( f t p command . stou , null ) ; }
public f t p file [ ] list file ( f t p file list parser parser ) throw i o exception { return list file ( parser , null ) ; }
public void set receieve data socket buffer size ( int buf size ) { __receive data socket buffer size = buf size ; }
protect format get format ( string pattern , locale locale ) { date format formatter = null ; boolean use pattern = ( pattern ! = null & & pattern . length ( ) > 0 ) ; if ( ! use pattern ) { formatter = ( date format ) get format ( locale ) ; } else if ( locale == null ) { formatter = new simple date format ( pattern ) ; } else { date format symbols symbol = new date format symbol ( locale ) ; formatter = new simple date format ( pattern , symbol ) ; } formatter . set lenient ( false ) ; return formatter ; }
public string get user setup url ( ) { return _user setup url ; }
public void set link ( string link ) { _link = link ; }
public string get raw listing ( ) { return _raw listing ; }
protect void read template file ( string filename ) throw i o exception { this . template buffer = new string buffer ( ) ; buffer reader reader = null ; try { input stream be = this . get class ( ) . get class loader ( ) . get resource a stream ( filename ) ; reader = new buffer reader ( new input stream reader ( be ) ) ; string line = null ; while ( ( line = reader . read line ( ) ) ! = null ) this . template buffer . append ( line + `` \n `` ) ; } finally { if ( reader ! = null ) reader . close ( ) ; } }
public static boolean be negative transient ( int reply ) { return ( reply > = 400 & & reply < 500 ) ; }
public string get parse timestamp format ( ) { return parse timestamp format ; }
public int read ( ) throw i o exception { final int ch = super . read ( ) ; if ( ch ! = eof ) { branch . write ( ch ) ; } return ch ; }
public string get distribution ( ) { return ( __distributions == null ? null : __distributions . to string ( ) ) ; }
public int quit ( ) throw i o exception { return send command ( f t p command . quit ) ; }
public reader retrieve article header ( string article id ) throw i o exception { return retrieve article header ( article id , null ) ; }
public boolean logout ( ) throw i o exception { return n n t p reply . be positive completion ( quit ( ) ) ; }
public static email address get email address from string ( string smtp address ) { return new email address ( smtp address ) ; }
public static int int function gaussian generator ( final long seed ) { final random rnd = random utils . get random ( seed ) ; return new int int function ( ) { @ override public double apply ( int first , int second ) { rnd . set seed ( seed ^ ( ( ( long ) first < < 32 ) | ( second & 0xffffffff l ) ) ) ; return rnd . next gaussian ( ) ; } } ; }
public int hash code ( ) { return ( int ) ( ( time > > 32 ) ^ time ^ ( clock seq and node > > 32 ) ^ clock seq and node ) ; }
public string to string ( ) { final string buffer buffer = new string buffer ( 11 ) ; buffer . append ( ' ( ' ) ; buffer . append ( b ) ; buffer . append ( ' , ' ) ; buffer . append ( h ) ; if ( s ! = 0 || d ! = 0 ) { buffer . append ( ' , ' ) ; buffer . append ( s ) ; } if ( d ! = 0 ) { buffer . append ( ' , ' ) ; buffer . append ( d ) ; } buffer . append ( ' ) ' ) ; return buffer . to string ( ) ; }
public boolean reinitialize ( ) throw i o exception { rein ( ) ; if ( f t p reply . be positive completion ( _reply code ) || ( f t p reply . be positive preliminary ( _reply code ) & & f t p reply . be positive completion ( get reply ( ) ) ) ) { __init default ( ) ; return true ; } return false ; }
public boolean logout ( ) throw i o exception { return s m t p reply . be positive completion ( quit ( ) ) ; }
public void set default port ( int port ) { _default port_ = port ; }
public boolean mark support ( ) { return in == null ? false : in . mark support ( ) ; }
public final void begin buffer ops ( ) { __receive buffer = new byte [ packet_size ] ; __receive datagram = new datagram packet ( __receive buffer , __receive buffer . length ) ; _send buffer = new byte [ packet_size ] ; __send datagram = new datagram packet ( _send buffer , _send buffer . length ) ; }
public final void buffer send ( t f t p packet packet ) throw i o exception { _socket_ . send ( packet . _new datagram ( __send datagram , _send buffer ) ) ; }
public int get block number ( ) { return _block number ; }
public string get status ( string pathname ) throw i o exception { if ( f t p reply . be positive completion ( stat ( pathname ) ) ) return get reply string ( ) ; return null ; }
public boolean get need client auth ( ) { if ( _socket_ instanceof s s l socket ) return ( ( s s l socket ) _socket_ ) . get need client auth ( ) ; return false ; }
public socket option set send buffer size ( int send buffer size ) { this . send buffer size = send buffer size ; return this ; }
public copy stream listener get copy stream listener ( ) { return __copy stream listener ; }
public boolean do command ( i m a p command command ) throw i o exception { return i m a p reply . be success ( send command ( command ) ) ; }
public boolean list ( string ref name , string mailbox name ) throw i o exception { return do command ( i m a p command . list , ref name + `` `` + mailbox name ) ; }
public int send command ( i m a p command command , string args ) throw i o exception { return send command ( command . get i m a p command ( ) , args ) ; }
public boolean select next article ( article pointer pointer ) throw i o exception { if ( ! n n t p reply . be positive completion ( next ( ) ) ) return false ; if ( pointer ! = null ) __parse article pointer ( get reply string ( ) , pointer ) ; return true ; }
public static s s l context create ssl context ( trust manager trust manager ) throw general security exception { ew x509 trust manager x509 trust manager = new ew x509 trust manager ( null , trust manager ) ; s s l context ssl context = s s l context . create default ( ) ; ssl context . init ( null , new trust manager [ ] { x509 trust manager } , null ) ; return ssl context ; }
public void passivate object ( k key , v obj ) throw exception { }
public synchronize int get num active ( ) { return num active ; }
public synchronize void clear ( k key ) { stack < v > stack = _pools . remove ( key ) ; destroy stack ( key , stack ) ; }
public int get max depth ( ) { return _max depth ; }
public void set remove abandon timeout ( final int remove abandon timeout ) { set remove abandon timeout ( duration . of second ( remove abandon timeout ) ) ; }
public synchronize void set lifo ( final boolean lifo ) { this . lifo = lifo ; if ( connection pool ! = null ) { connection pool . set lifo ( lifo ) ; } }
public final long get create count ( ) { return create count . get ( ) ; }
public synchronize string get eviction policy class name ( ) { return eviction policy class name ; }
public final http async client builder set max conn total ( final int max conn total ) { this . max conn total = max conn total ; return this ; }
public final boolean get test on borrow ( ) { return test on borrow ; }
public void set time between eviction run millis ( final long time between eviction run millis ) { assert initialization allow ( ) ; this . time between eviction run millis = time between eviction run millis ; }
public static < t > poolable object factory < t > synchronize poolable factory ( final poolable object factory < t > factory ) { return new synchronize poolable object factory < t > ( factory ) ; }
public object remove ( int key ) { entry tab [ ] = table ; int hash = key ; int index = ( hash & 0x7 f f f f f f f ) % tab . length ; for ( entry e = tab [ index ] , prev = null ; e ! = null ; prev = e , e = e . next ) { if ( e . hash == hash ) { if ( prev ! = null ) { prev . next = e . next ; } else { tab [ index ] = e . next ; } count -- ; object old value = e . value ; e . value = null ; return old value ; } } return null ; }
public object clone ( ) { if ( be reference ( ) ) { return ( ( file set ) get ref ( get project ( ) ) ) . clone ( ) ; } else { return super . clone ( ) ; } }
public string lookup file string lookup ( ) { return file string lookup . instance ; }
public static function new pre translate ( string bundle , locale locale ) { return new pre translate func ( bundle , locale , true ) ; }
public boolean be flush on shutdown ( ) { return flush on shutdown ; }
public char sequence logest common subsequence ( final char sequence leave , final char sequence right ) { return long common subsequence ( leave , right ) ; }
public config parse option set includer ( config includer includer ) { if ( this . includer == includer ) return this ; else return new config parse option ( this . syntax , this . origin description , this . allow miss , includer , this . class loader ) ; }
public config parse option set includer ( config includer includer ) { if ( this . includer == includer ) return this ; else return new config parse option ( this . syntax , this . origin description , this . allow miss , includer , this . class loader ) ; }
public config render option set comment ( boolean value ) { if ( value == comment ) return this ; else return new config render option ( origin comment , value , format , json ) ; }
protect final abstract config value peek assume resolve ( string key , path original path ) { try { return attempt peek with partial resolve ( key ) ; } catch ( config exception . not resolve e ) { throw config impl . improve not resolve ( original path , e ) ; } }
public < t > list < list < t > > a list ( class < t > item type ) { return table converter . to list ( this , item type ) ; }
public static < t > t new instance ( class < t > class to instantiate ) { int modifier = class to instantiate . get modifier ( ) ; final object object ; if ( modifier . be interface ( modifier ) ) { object = proxy . new proxy instance ( whitebox impl . class . get class loader ( ) , new class < ? > [ ] { class to instantiate } , new invocation handler ( ) { public object invoke ( object proxy , method method , object [ ] args ) throw throwable { return type utils . get default value ( method . get return type ( ) ) ; } } ) ; } else if ( class to instantiate . be array ( ) ) { object = array . new instance ( class to instantiate . get component type ( ) , 0 ) ; } else if ( modifier . be abstract ( modifier ) ) { throw new illegal argument exception ( `` can not instantiate an abstract class . please use the concrete class generator in power mock support to generate a concrete class first . `` ) ; } else { objenesis objenesis = new objenesis std ( ) ; object instantiator thingy instantiator = objenesis . get instantiator of ( class to instantiate ) ; object = thingy instantiator . new instance ( ) ; } return ( t ) object ; }
public static link list < string > wrap in tag ( link list < string > sequence , int start position , int end position , string tag , string css class ) { link list < string > result = ( link list < string > ) sequence . clone ( ) ; string builder tag builder = new string builder ( ) ; tag builder . append ( `` < `` ) ; tag builder . append ( tag ) ; if ( css class ! = null ) { tag builder . append ( `` class=\ `` `` ) ; tag builder . append ( css class ) ; tag builder . append ( `` \ `` `` ) ; } tag builder . append ( `` > `` ) ; string start tag = tag builder . to string ( ) ; tag builder . delete ( 0 , tag builder . length ( ) ) ; tag builder . append ( `` < / `` ) ; tag builder . append ( tag ) ; tag builder . append ( `` > `` ) ; string end tag = tag builder . to string ( ) ; result . add ( start position , start tag ) ; result . add ( end position , end tag ) ; return result ; }
public client configuration with retry policy ( retry policy retry policy ) { set retry policy ( retry policy ) ; return this ; }
public sequence iterator iterate ( x path context context ) throw x path exception { sequence iterator master = select . iterate ( context ) ; x path context major c2 = context . new context ( ) ; c2 . set origin ( this ) ; c2 . set current template rule ( null ) ; c2 . set current iterator ( master ) ; master = new context mapping iterator ( this , c2 ) ; return master ; }
public child reaper add path ( string path ) { path . add ( path utils . validate path ( path ) ) ; return this ; }
public static string get node from path ( string path ) { path utils . validate path ( path ) ; int i = path . last index of ( path_separator ) ; if ( i < 0 ) { return path ; } if ( ( i + 1 ) > = path . length ( ) ) { return `` `` ; } return path . substring ( i + 1 ) ; }
public synchronize boolean acquire ( long delay ) throw interrupted exception { if ( thread . interrupt ( ) ) throw new interrupt exception ( ) ; long start = system . nano time ( ) ; long time leave = delay ; while ( true ) { if ( notification > 0 ) { notification -- ; return true ; } if ( time leave < = 0 ) return false ; wait ( time leave ) ; time leave = ( ( start - system . nano time ( ) ) / nanos_in_ms ) + delay ; } }
public void start ( ) throw exception { log . debug ( `` start `` ) ; if ( ! start . compare and set ( false , true ) ) { illegal state exception ise = new illegal state exception ( `` already start `` ) ; throw ise ; } state . start ( ) ; }
public boolean be hold by current thread ( t key ) { key lock lock = map . get ( key ) ; if ( lock == null ) { return false ; } return lock . be hold by current thread ( ) ; }
public output < ? > mutex lock ( ) { return mutex lock ; }
public long get four nine upper bound ( ) { return get upper bound for factor ( 0 . 9999d ) ; }
public event handler group < t > then handle event with worker pool ( final work handler < t > . . . handler ) { return handle event with worker pool ( handler ) ; }
public static barrier ready size create ( scope scope , operand < string > handle ) { operation builder op builder = scope . graph ( ) . op builder ( `` barrier ready size `` , scope . make op name ( `` barrier ready size `` ) ) ; op builder . add input ( handle . a output ( ) ) ; return new barrier ready size ( op builder . build ( ) ) ; }
public void add sequence ( sequence sequence ) { sequence = add ( sequence , sequence ) ; }
public static map get map ( map map , object key , map default value ) { map answer = get map ( map , key ) ; if ( answer == null ) { answer = default value ; } return answer ; }
public static map get map ( map map , object key , map default value ) { map answer = get map ( map , key ) ; if ( answer == null ) { answer = default value ; } return answer ; }
public static < t > t create mock ( class < t > to mock ) { return create control ( ) . create mock ( to mock ) ; }
public static char or ( char first , char second ) { last control . report or ( 2 ) ; return 0 ; }
public static int and ( int first , int second ) { last control . report and ( 2 ) ; return 0 ; }
public static short not ( short first ) { last control . report not ( ) ; return 0 ; }
public static short eq ( short value ) { return report matcher ( new equal ( value ) ) . return zero ( ) ; }
public static float eq ( float value , float delta ) { report matcher ( new equal with delta ( value , delta ) ) ; return 0 ; }
public static void reset ( object . . . mock ) { for ( object mock : mock ) { get control ( mock ) . reset ( ) ; } }
public void replay to ( class < ? > destination ) { replay to ( log factory . get log ( destination ) ) ; }
public void set return value ( object value , int time ) { expect last call ( `` method call on the mock need before set return value `` ) . and return ( value ) . time ( time ) ; }
public void set void callable ( int min count , int max count ) { expect last call ( `` method call on the mock need before set void callable `` ) . time ( min count , max count ) ; }
public void set throwable ( throwable throwable ) { expect last call ( `` method call on the mock need before set throwable `` ) . and throw ( throwable ) . once ( ) ; }
public throwable to plain throwable ( ) { final throwable throwable = new throwable ( to string ( ) , get cause ( ) ) ; throwable . set stack trace ( get stack trace ( ) ) ; for ( throwable s : get suppress ( ) ) { throwable . add suppressed ( s ) ; } return throwable ; }
public option set default value ( string default value ) { this . default value = default value ; if ( this . default value ! = null ) { set require ( false ) ; } return this ; }
public type annotation walker to type parameter ( boolean be class type parameter , int rank ) { long new match = this . match ; if ( new match == 0 ) return empty_annotation_walker ; int target type = be class type parameter ? annotation target type constant . class_type_parameter : annotation target type constant . method_type_parameter ; int length = this . type annotation . length ; long mask = 1 ; for ( int i = 0 ; i < length ; i++ , mask = mask < < 1 ) { i binary type annotation candidate = this . type annotation [ i ] ; if ( candidate . get target type ( ) ! = target type || candidate . get type parameter index ( ) ! = rank ) { new match & = ~mask ; } } return restrict ( new match , 0 ) ; }
public byte [ ] encode ( big integer x ) { if ( f == null ) throw new illegal state exception ( `` field not set `` ) ; byte [ ] in = x . to byte array ( ) ; byte [ ] out = new byte [ f . getb ( ) /8 ] ; for ( int i = 0 ; i < in . length ; i++ ) { out [ i ] = in [ in . length-1-i ] ; } for ( int i = in . length ; i < out . length ; i++ ) { out [ i ] = 0 ; } return out ; }
public field element square ( ) { int f0 = t [ 0 ] ; int f1 = t [ 1 ] ; int f2 = t [ 2 ] ; int f3 = t [ 3 ] ; int f4 = t [ 4 ] ; int f5 = t [ 5 ] ; int f6 = t [ 6 ] ; int f7 = t [ 7 ] ; int f8 = t [ 8 ] ; int f9 = t [ 9 ] ; int f0_2 = 2 * f0 ; int f1_2 = 2 * f1 ; int f2_2 = 2 * f2 ; int f3_2 = 2 * f3 ; int f4_2 = 2 * f4 ; int f5_2 = 2 * f5 ; int f6_2 = 2 * f6 ; int f7_2 = 2 * f7 ; int f5_38 = 38 * f5 ; / * 1 . 959375 * 2^30 * / int f6_19 = 19 * f6 ; / * 1 . 959375 * 2^30 * / int f7_38 = 38 * f7 ; / * 1 . 959375 * 2^30 * / int f8_19 = 19 * f8 ; / * 1 . 959375 * 2^30 * / int f9_38 = 38 * f9 ; / * 1 . 959375 * 2^30 * / long f0f0 = f0 * ( long ) f0 ; long f0f1_2 = f0_2 * ( long ) f1 ; long f0f2_2 = f0_2 * ( long ) f2 ; long f0f3_2 = f0_2 * ( long ) f3 ; long f0f4_2 = f0_2 * ( long ) f4 ; long f0f5_2 = f0_2 * ( long ) f5 ; long f0f6_2 = f0_2 * ( long ) f6 ; long f0f7_2 = f0_2 * ( long ) f7 ; long f0f8_2 = f0_2 * ( long ) f8 ; long f0f9_2 = f0_2 * ( long ) f9 ; long f1f1_2 = f1_2 * ( long ) f1 ; long f1f2_2 = f1_2 * ( long ) f2 ; long f1f3_4 = f1_2 * ( long ) f3_2 ; long f1f4_2 = f1_2 * ( long ) f4 ; long f1f5_4 = f1_2 * ( long ) f5_2 ; long f1f6_2 = f1_2 * ( long ) f6 ; long f1f7_4 = f1_2 * ( long ) f7_2 ; long f1f8_2 = f1_2 * ( long ) f8 ; long f1f9_76 = f1_2 * ( long ) f9_38 ; long f2f2 = f2 * ( long ) f2 ; long f2f3_2 = f2_2 * ( long ) f3 ; long f2f4_2 = f2_2 * ( long ) f4 ; long f2f5_2 = f2_2 * ( long ) f5 ; long f2f6_2 = f2_2 * ( long ) f6 ; long f2f7_2 = f2_2 * ( long ) f7 ; long f2f8_38 = f2_2 * ( long ) f8_19 ; long f2f9_38 = f2 * ( long ) f9_38 ; long f3f3_2 = f3_2 * ( long ) f3 ; long f3f4_2 = f3_2 * ( long ) f4 ; long f3f5_4 = f3_2 * ( long ) f5_2 ; long f3f6_2 = f3_2 * ( long ) f6 ; long f3f7_76 = f3_2 * ( long ) f7_38 ; long f3f8_38 = f3_2 * ( long ) f8_19 ; long f3f9_76 = f3_2 * ( long ) f9_38 ; long f4f4 = f4 * ( long ) f4 ; long f4f5_2 = f4_2 * ( long ) f5 ; long f4f6_38 = f4_2 * ( long ) f6_19 ; long f4f7_38 = f4 * ( long ) f7_38 ; long f4f8_38 = f4_2 * ( long ) f8_19 ; long f4f9_38 = f4 * ( long ) f9_38 ; long f5f5_38 = f5 * ( long ) f5_38 ; long f5f6_38 = f5_2 * ( long ) f6_19 ; long f5f7_76 = f5_2 * ( long ) f7_38 ; long f5f8_38 = f5_2 * ( long ) f8_19 ; long f5f9_76 = f5_2 * ( long ) f9_38 ; long f6f6_19 = f6 * ( long ) f6_19 ; long f6f7_38 = f6 * ( long ) f7_38 ; long f6f8_38 = f6_2 * ( long ) f8_19 ; long f6f9_38 = f6 * ( long ) f9_38 ; long f7f7_38 = f7 * ( long ) f7_38 ; long f7f8_38 = f7_2 * ( long ) f8_19 ; long f7f9_76 = f7_2 * ( long ) f9_38 ; long f8f8_19 = f8 * ( long ) f8_19 ; long f8f9_38 = f8 * ( long ) f9_38 ; long f9f9_38 = f9 * ( long ) f9_38 ; / * * * same procedure a in multiply , but this time we have a high symmetry lead to less summands . * e . g . f1f9_76 really stand for f1 * 2^26 * f9 * 2^230 + f9 * 2^230 + f1 * 2^26 congruent 2 * 2 * 19 * f1 * f9 2^0 modulo p . * / long h0 = f0f0 + f1f9_76 + f2f8_38 + f3f7_76 + f4f6_38 + f5f5_38 ; long h1 = f0f1_2 + f2f9_38 + f3f8_38 + f4f7_38 + f5f6_38 ; long h2 = f0f2_2 + f1f1_2 + f3f9_76 + f4f8_38 + f5f7_76 + f6f6_19 ; long h3 = f0f3_2 + f1f2_2 + f4f9_38 + f5f8_38 + f6f7_38 ; long h4 = f0f4_2 + f1f3_4 + f2f2 + f5f9_76 + f6f8_38 + f7f7_38 ; long h5 = f0f5_2 + f1f4_2 + f2f3_2 + f6f9_38 + f7f8_38 ; long h6 = f0f6_2 + f1f5_4 + f2f4_2 + f3f3_2 + f7f9_76 + f8f8_19 ; long h7 = f0f7_2 + f1f6_2 + f2f5_2 + f3f4_2 + f8f9_38 ; long h8 = f0f8_2 + f1f7_4 + f2f6_2 + f3f5_4 + f4f4 + f9f9_38 ; long h9 = f0f9_2 + f1f8_2 + f2f7_2 + f3f6_2 + f4f5_2 ; long carry0 ; long carry1 ; long carry2 ; long carry3 ; long carry4 ; long carry5 ; long carry6 ; long carry7 ; long carry8 ; long carry9 ; carry0 = ( h0 + ( long ) ( 1 < < 25 ) ) > > 26 ; h1 += carry0 ; h0 -= carry0 < < 26 ; carry4 = ( h4 + ( long ) ( 1 < < 25 ) ) > > 26 ; h5 += carry4 ; h4 -= carry4 < < 26 ; carry1 = ( h1 + ( long ) ( 1 < < 24 ) ) > > 25 ; h2 += carry1 ; h1 -= carry1 < < 25 ; carry5 = ( h5 + ( long ) ( 1 < < 24 ) ) > > 25 ; h6 += carry5 ; h5 -= carry5 < < 25 ; carry2 = ( h2 + ( long ) ( 1 < < 25 ) ) > > 26 ; h3 += carry2 ; h2 -= carry2 < < 26 ; carry6 = ( h6 + ( long ) ( 1 < < 25 ) ) > > 26 ; h7 += carry6 ; h6 -= carry6 < < 26 ; carry3 = ( h3 + ( long ) ( 1 < < 24 ) ) > > 25 ; h4 += carry3 ; h3 -= carry3 < < 25 ; carry7 = ( h7 + ( long ) ( 1 < < 24 ) ) > > 25 ; h8 += carry7 ; h7 -= carry7 < < 25 ; carry4 = ( h4 + ( long ) ( 1 < < 25 ) ) > > 26 ; h5 += carry4 ; h4 -= carry4 < < 26 ; carry8 = ( h8 + ( long ) ( 1 < < 25 ) ) > > 26 ; h9 += carry8 ; h8 -= carry8 < < 26 ; carry9 = ( h9 + ( long ) ( 1 < < 24 ) ) > > 25 ; h0 += carry9 * 19 ; h9 -= carry9 < < 25 ; carry0 = ( h0 + ( long ) ( 1 < < 25 ) ) > > 26 ; h1 += carry0 ; h0 -= carry0 < < 26 ; int [ ] h = new int [ 10 ] ; h [ 0 ] = ( int ) h0 ; h [ 1 ] = ( int ) h1 ; h [ 2 ] = ( int ) h2 ; h [ 3 ] = ( int ) h3 ; h [ 4 ] = ( int ) h4 ; h [ 5 ] = ( int ) h5 ; h [ 6 ] = ( int ) h6 ; h [ 7 ] = ( int ) h7 ; h [ 8 ] = ( int ) h8 ; h [ 9 ] = ( int ) h9 ; return new ed25519 field element ( f , h ) ; }
public static int get number of delayed unassigned ( cluster state state ) { int count = 0 ; for ( shard rout shard : state . rout table ( ) . shard with state ( shard rout state . unassigned ) ) { if ( shard . unassigned info ( ) . be delay ( ) ) { count++ ; } } return count ; }
public void add dependent host name ( string hostname ) { dependent host name . add ( hostname ) ; }
public allocation command add ( allocation command . . . command ) { if ( command ! = null ) { this . command . add all ( array . a list ( command ) ) ; } return this ; }
public cluster update setting request persistent setting ( setting setting ) { this . persistent setting = setting ; return this ; }
public alias routing ( string rout ) { this . index rout = routing ; this . search rout = routing ; return this ; }
public count request routing ( string . . . routings ) { this . rout = string . array to comma delimited string ( routings ) ; return this ; }
public get repository request builder set repository ( string . . . repository ) { request . repository ( repository ) ; return this ; }
public create snapshot request builder set wait for completion ( boolean wait for completion ) { request . wait for completion ( wait for completion ) ; return this ; }
public create index request setting ( string source , x content type x content type ) { this . setting = setting . builder ( ) . load from source ( source , x content type ) . build ( ) ; return this ; }
public restore snapshot request builder set snapshot ( string snapshot ) { request . snapshot ( snapshot ) ; return this ; }
public restore snapshot request builder set partial ( boolean partial ) { request . partial ( partial ) ; return this ; }
public boolean include alias ( ) { return include alias ; }
public node stats request index ( boolean index ) { if ( index ) { this . index . all ( ) ; } else { this . index . clear ( ) ; } return this ; }
public long start time ( ) { return start time ; }
public long incremental size ( ) { return incremental size ; }
public cluster state request builder clear ( ) { request . clear ( ) ; return this ; }
public static get alias response from x content ( x content parser parser ) throw i o exception { if ( parser . current token ( ) == null ) { parser . next token ( ) ; } ensure expect token ( token . start_object , parser . current token ( ) , parser ) ; map < string , set < alias metadata > > alias = new hash map < > ( ) ; string current field name ; token token ; string error = null ; elasticsearch exception exception = null ; rest status status = rest status . ok ; while ( parser . next token ( ) ! = token . end_object ) { if ( parser . current token ( ) == token . field_name ) { current field name = parser . current name ( ) ; if ( `` status `` . equal ( current field name ) ) { if ( ( token = parser . next token ( ) ) ! = token . field_name ) { ensure expect token ( token . value_number , token , parser ) ; status = rest status . from code ( parser . int value ( ) ) ; } } else if ( `` error `` . equal ( current field name ) ) { token = parser . next token ( ) ; if ( token == token . value_string ) { error = parser . text ( ) ; } else if ( token == token . start_object ) { parser . next token ( ) ; exception = elasticsearch exception . inner from x content ( parser , true ) ; } else if ( token == token . start_array ) { parser . skip child ( ) ; } } else { string index name = parser . current name ( ) ; if ( parser . next token ( ) == token . start_object ) { set < alias metadata > parse inside = parse alias ( parser ) ; aliases . put ( index name , parse inside ) ; } } } } if ( exception ! = null ) { assert error == null ; assert alias . be empty ( ) ; return new get alias response ( status , exception ) ; } return new get alias response ( status , error , aliases ) ; }
public index aliases request add alias action ( alias action alias action ) { alias action . validate ( ) ; all alias action . add ( alias action ) ; return this ; }
public void add ( tokenizer tokenizer ) { if ( this . tokenizer ! = null ) { throw new build exception ( `` only one tokenizer allow `` ) ; } this . tokenizer = tokenizer ; }
protect shard iterator shard ( cluster state cluster state , index stats request request , string [ ] concrete index ) { return cluster state . rout table ( ) . all shard ( concrete index ) ; }
public rollover request builder wait for active shard ( active shard count wait for active shard ) { this . request . get create index request ( ) . wait for active shard ( wait for active shard ) ; return this ; }
protect string [ ] resolve concrete index name ( cluster state cluster state , request request ) { return index name expression resolver . concrete index name ( cluster state , request ) ; }
public resource resolve doctype ( string name ) { logger . trace ( `` resolve doctype ( `` + name + `` ) `` ) ; catalog result resolve = catalog . lookup doctype ( name , null , null ) ; if ( resolve == null ) { return null ; } else { return stream result ( resolve ) ; } }
public boolean be system data stream ( string name ) { return system data stream automaton . test ( name ) ; }
public create index request setting ( string source , x content type x content type ) { this . setting = setting . builder ( ) . load from source ( source , x content type ) . build ( ) ; return this ; }
public put index template request builder add mapping ( string type , string source , x content type x content type ) { request . mapping ( type , source , x content type ) ; return this ; }
public boolean only expunge deletes ( ) { return only expunge deletes ; }
public static put map request put map request ( string . . . index ) { return new put map request ( index ) ; }
public string [ ] get concrete visible index ( ) { return visible index ; }
public index shard store request builder set index option ( index option index option ) { request . index option ( index option ) ; return this ; }
public resize type resize type ( ) { return resize type ; }
public search request builder set stats ( string . . . stats group ) { source builder ( ) . stats ( array . a list ( stats group ) ) ; return this ; }
public put index template request setting ( string source , x content type x content type ) { this . setting = setting . builder ( ) . load from source ( source , x content type ) . build ( ) ; return this ; }
public boolean be valid ( ) { execute ( ) ; return be valid ; }
public static backoff policy exponential backoff ( time value initial delay , int max number of retries ) { return new exponential backoff ( ( int ) check delay ( initial delay ) . millis ( ) , max number of retries ) ; }
public item id get item id ( ) { return item id ; }
public string get id ( ) { if ( failure ! = null ) { return failure . get id ( ) ; } return response . get id ( ) ; }
public bulk request add ( byte [ ] data , int from , int length , x content type x content type ) throw i o exception { return add ( data , from , length , null , null , x content type ) ; }
public boolean await close ( long timeout , time unit unit ) throw interrupted exception { lock . lock ( ) ; try { if ( close ) { return true ; } close = true ; this . cancellable flush task . cancel ( ) ; if ( bulk request . number of action ( ) > 0 ) { execute ( ) ; } try { return this . bulk request handler . await close ( timeout , unit ) ; } finally { on close . run ( ) ; } } finally { lock . unlock ( ) ; } }
public bulk request add ( doc write request < ? > . . . request ) { for ( doc write request < ? > request : request ) { add ( request ) ; } return this ; }
public test result run ( ) { test result result= create result ( ) ; run ( result ) ; return result ; }
public void set system id ( string url ) { system id = url ; builder . set system id ( url ) ; super . set document locator ( new locator ( ) { public int get column number ( ) { return -1 ; } public int get line number ( ) { return -1 ; } public string get public id ( ) { return null ; } public string get system id ( ) { return system id ; } } ) ; }
public explain request builder set fetch source ( boolean fetch ) { fetch source context fetch source context = request . fetch source context ( ) ! = null ? request . fetch source context ( ) : fetch source context . fetch_source ; request . fetch source context ( new fetch source context ( fetch , fetch source context . include ( ) , fetch source context . excludes ( ) ) ) ; return this ; }
public byte [ ] get source a byte ( ) { return get result . source ( ) ; }
public index request set final pipeline ( final string final pipeline ) { this . final pipeline = final pipeline ; return this ; }
public index request be pipeline resolve ( final boolean be pipeline resolve ) { this . be pipeline resolve = be pipeline resolve ; return this ; }
public delete request set if seq no ( long seq no ) { if ( seq no < 0 & & seq no ! = unassigned_seq_no ) { throw new illegal argument exception ( `` sequence number must be non negative . get [ `` + seq no + `` ] . `` ) ; } if seq no = seq no ; return this ; }
public list < sibling pipeline aggregator > get top level pipeline aggregator ( ) { if ( pipeline tree for bwc serialization == null ) { return empty list ( ) ; } return pipeline tree for bwc serialization . get ( ) . aggregator ( ) . stream ( ) . map ( p - > ( sibling pipeline aggregator ) p ) . collect ( to list ( ) ) ; }
public bulk item response [ ] get item ( ) { return response ; }
public int get batch reduce size ( ) { return batch reduce size ; }
public reindex request add sort field ( string name , sort order order ) { this . get search request ( ) . source ( ) . sort ( name , order ) ; return this ; }
public default shard operation fail exception [ ] get shard failure ( ) { return shard failure ; }
public static set < shard id > select recover from shard ( int shard id , index metadata source index metadata , int num target shard ) { if ( source index metadata . get number of shard ( ) > num target shard ) { return select shrink shard ( shard id , source index metadata , num target shard ) ; } else if ( source index metadata . get number of shard ( ) < num target shard ) { return collection . singleton ( select split shard ( shard id , source index metadata , num target shard ) ) ; } else { return collection . singleton ( select clone shard ( shard id , source index metadata , num target shard ) ) ; } }
public void remove index template v2 ( final string [ ] names , final time value master timeout , final action listener < acknowledge response > listener ) { cluster service . submit state update task ( `` remove-index-template-v2 [ `` + string . join ( `` , `` , names ) + `` ] `` , new cluster state update task ( priority . urgent , master timeout ) { @ override public void on failure ( string source , exception e ) { listener . on failure ( e ) ; } @ override public cluster state execute ( cluster state current state ) { return inner remove index template v2 ( current state , name ) ; } @ override public void cluster state process ( string source , cluster state old state , cluster state new state ) { listener . on response ( acknowledge response . true ) ; } } ) ; }
public rollover request builder wait for active shard ( active shard count wait for active shard ) { this . request . get create index request ( ) . wait for active shard ( wait for active shard ) ; return this ; }
protect shard iterator shard ( cluster state cluster state , index segment request request , string [ ] concrete index ) { return cluster state . rout table ( ) . all shard ( concrete index ) ; }
public final request builder set parent task id ( task id task id ) { request . set parent task id ( task id ) ; return ( request builder ) this ; }
public list < fail node exception > failure ( ) { return failure ; }
public static boolean be optional available ( ) { try { class . for name ( test_class ) ; } catch ( class not find exception e ) { return false ; } return true ; }
public static select select step < record > select ( collection < ? extends select field or asterisk > field ) { return dsl ( ) . select ( field ) ; }
public term vector request payload ( boolean payload ) { set flag ( flag . payload , payload ) ; return this ; }
public void set system id ( string url ) { system id = url ; builder . set system id ( url ) ; super . set document locator ( new locator ( ) { public int get column number ( ) { return -1 ; } public int get line number ( ) { return -1 ; } public string get public id ( ) { return null ; } public string get system id ( ) { return system id ; } } ) ; }
public long primary term ( ) { return primary term ; }
public update request upsert ( object . . . source ) { safe upsert request ( ) . source ( source ) ; return this ; }
public index request builder set source ( bytes reference source , x content type x content type ) { request . source ( source , x content type ) ; return this ; }
public clear index cache response clear cache ( clear index cache request clear index cache request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( clear index cache request , indices request converter : : clear cache , option , clear index cache response : : from x content , empty set ( ) ) ; }
public transport client add transport address ( transport address transport address ) { nodes service . add transport address ( transport address ) ; return this ; }
public transport client add transport address ( transport address transport address ) { nodes service . add transport address ( transport address ) ; return this ; }
public final time value ack timeout ( ) { return request . ack timeout ( ) ; }
public string [ ] index ( ) { return index ; }
public static < t > t [ ] valid index ( t [ ] array , int index ) { return valid index ( array , index , default_valid_index_array_ex_message , integer . value of ( index ) ) ; }
public void map web application exception ( web application exception e ) { if ( e . get response ( ) . get entity ( ) ! = null ) { on exception ( e , e . get response ( ) , false ) ; } else { if ( ! map exception ( e ) ) { on exception ( e , e . get response ( ) , false ) ; } } }
public void remote shard fail ( final shard id shard id , string allocation id , long primary term , boolean mark a stale , final string message , @ nullable final exception failure , action listener < void > listener ) { assert primary term > 0l : `` primary term should be strictly positive `` ; remote fail shard deduplicator . execute once ( new fail shard entry ( shard id , allocation id , primary term , message , failure , mark a stale ) , listener , ( req , req listener ) - > send shard action ( shard_failed_action_name , cluster service . state ( ) , req , req listener ) ) ; }
public boolean index rout table change ( string index ) { object . require non null ( index , `` index must not be null `` ) ; if ( state . rout table ( ) . have index ( index ) == false & & previous state . rout table ( ) . have index ( index ) == false ) { return false ; } if ( state . rout table ( ) . have index ( index ) & & previous state . rout table ( ) . have index ( index ) ) { return state . rout table ( ) . index ( index ) ! = previous state . rout table ( ) . index ( index ) ; } return true ; }
public discovery node tie break active master ( collection < discovery node > active master ) { return active master . stream ( ) . min ( elect master service : : compare node ) . get ( ) ; }
public < params extend persistent task params > void create persistent task ( string task id , string task name , params task params , action listener < persistent task < ? > > listener ) { cluster service . submit state update task ( `` create persistent task `` , new cluster state update task ( ) { @ override public cluster state execute ( cluster state current state ) { persistent task custom metadata . builder builder = builder ( current state ) ; if ( builder . have task ( task id ) ) { throw new resource already exist exception ( `` task with id { `` + task id + `` } already exist `` ) ; } persistent task executor < params > task executor = registry . get persistent task executor safe ( task name ) ; task executor . validate ( task params , current state ) ; assignment assignment = create assignment ( task name , task params , current state ) ; return update ( current state , builder . add task ( task id , task name , task params , assignment ) ) ; } @ override public void on failure ( string source , exception e ) { listener . on failure ( e ) ; } @ override public void cluster state process ( string source , cluster state old state , cluster state new state ) { persistent task custom metadata task = new state . get metadata ( ) . custom ( persistent task custom metadata . type ) ; if ( task ! = null ) { persistent task < ? > task = task . get task ( task id ) ; listener . on response ( task ) ; if ( task ! = null & & task . be assign ( ) == false & & periodic rechecker . be schedule ( ) == false ) { periodic rechecker . reschedule if necessary ( ) ; } } else { listener . on response ( null ) ; } } } ) ; }
public static void get and set node id and cluster id ( cluster service cluster service , thread context thread context ) { cluster state cluster state = cluster service . state ( ) ; cluster state observer observer = new cluster state observer ( cluster state , cluster service , null , logger , thread context ) ; observer . wait for next change ( new node and cluster id state listener ( ) , node and cluster id state listener : : be node and cluster id present ) ; }
public static void ensure nodes compatibility ( version join node version , version min cluster node version , version max cluster node version ) { assert min cluster node version . on or before ( max cluster node version ) : min cluster node version + `` > `` + max cluster node version ; if ( join node version . be compatible ( max cluster node version ) == false ) { throw new illegal state exception ( `` node version [ `` + joining node version + `` ] be not support . `` + `` the cluster contain node with version [ `` + max cluster node version + `` ] , which be incompatible . `` ) ; } if ( join node version . be compatible ( min cluster node version ) == false ) { throw new illegal state exception ( `` node version [ `` + joining node version + `` ] be not support . `` + `` the cluster contain node with version [ `` + min cluster node version + `` ] , which be incompatible . `` ) ; } }
public mapping metadata mapping or default ( ) { map metadata map = null ; for ( object cursor < mapping metadata > m : mapping . value ( ) ) { if ( map == null || mapping . type ( ) . equal ( mapper service . default_mapping ) ) { map = m . value ; } } return map ; }
public static shard id select split shard ( int shard id , index metadata source index metadata , int num target shard ) { int num source shard = source index metadata . get number of shard ( ) ; if ( shard id > = num target shard ) { throw new illegal argument exception ( `` the number of target shard ( `` + num target shard + `` ) must be great than the shard id : `` + shard id ) ; } final int rout factor = get rout factor ( num source shard , num target shard ) ; assert split metadata ( num source shard , num target shard , source index metadata ) ; return new shard id ( source index metadata . get index ( ) , shard id/routing factor ) ; }
public void set sheet index ( int index ) { int last sheet ix = _book . get number of sheet ( ) - 1 ; if ( index < -1 || index > last sheet ix ) { throw new illegal argument exception ( `` sheet index ( `` + index + `` ) be out of range `` + ( last sheet ix == -1 ? `` `` : ( `` ( 0 . . `` + last sheet ix + `` ) `` ) ) ) ; } _defined name rec . set sheet number ( index + 1 ) ; }
public index concrete write index ( cluster state state , index request request ) { if ( request . index ( ) == null || ( request . index ( ) ! = null & & request . index ( ) . length ! = 1 ) ) { throw new illegal argument exception ( `` index request must specify a single index expression `` ) ; } return concrete write index ( state , request . index option ( ) , request . index ( ) [ 0 ] , false , request . include data stream ( ) ) ; }
public list < string > index create ( ) { if ( metadata change ( ) == false ) { return collection . empty list ( ) ; } list < string > create = null ; for ( object cursor < string > cursor : state . metadata ( ) . index ( ) . key ( ) ) { string index = cursor . value ; if ( previous state . metadata ( ) . have index ( index ) == false ) { if ( create == null ) { create = new array list < > ( ) ; } create . add ( index ) ; } } return create == null ? collection . < string > empty list ( ) : create ; }
public int total shard ( ) { return shard count . total ; }
public void remove index template v2 ( final string [ ] names , final time value master timeout , final action listener < acknowledge response > listener ) { cluster service . submit state update task ( `` remove-index-template-v2 [ `` + string . join ( `` , `` , names ) + `` ] `` , new cluster state update task ( priority . urgent , master timeout ) { @ override public void on failure ( string source , exception e ) { listener . on failure ( e ) ; } @ override public cluster state execute ( cluster state current state ) { return inner remove index template v2 ( current state , name ) ; } @ override public void cluster state process ( string source , cluster state old state , cluster state new state ) { listener . on response ( acknowledge response . true ) ; } } ) ; }
public boolean node exists ( discovery node node ) { discovery node exist = node . get ( node . get id ( ) ) ; return exist ! = null & & exist . equal ( node ) ; }
public list < node allocation result > get node decision ( ) { check decision state ( ) ; return node decision ; }
protect reroute explanation explain or throw reject command ( boolean explain , rout allocation allocation , runtime exception rte ) { if ( explain ) { return new reroute explanation ( this , allocation . decision ( decision . no , name ( ) + `` ( allocation command ) `` , rte . get message ( ) ) ) ; } throw rte ; }
public string get low watermark raw ( ) { return low watermark raw ; }
public move decision with remain decision ( decision can remain decision ) { return new move decision ( can remain decision , cluster rebalance decision , allocation decision , target node , node decision , current node rank ) ; }
public move decision with remain decision ( decision can remain decision ) { return new move decision ( can remain decision , cluster rebalance decision , allocation decision , target node , node decision , current node rank ) ; }
protect long current nano time ( ) { return system . nano time ( ) ; }
public rout node get rout node ( ) { if ( rout nodes ! = null ) { return rout node ; } rout node = new rout node ( this ) ; return rout node ; }
public metadata create metadata ( metadata metadata ) { return this . create metadata ( metadata . default_metadata_type , metadata ) ; }
public move decision with remain decision ( decision can remain decision ) { return new move decision ( can remain decision , cluster rebalance decision , allocation decision , target node , node decision , current node rank ) ; }
public list < shard rout > shard with state ( string index , shard rout state . . . state ) { list < shard rout > shard = new array list < > ( ) ; if ( state . length == 1 ) { if ( state [ 0 ] == shard rout state . initialize ) { for ( shard rout shard entry : initializing shard ) { if ( shard entry . get index name ( ) . equal ( index ) == false ) { continue ; } shard . add ( shard entry ) ; } return shard ; } else if ( state [ 0 ] == shard rout state . relocate ) { for ( shard rout shard entry : relocating shard ) { if ( shard entry . get index name ( ) . equal ( index ) == false ) { continue ; } shard . add ( shard entry ) ; } return shard ; } } for ( shard rout shard entry : this ) { if ( shard entry . get index name ( ) . equal ( index ) == false ) { continue ; } for ( shard rout state state : state ) { if ( shard entry . state ( ) == state ) { shard . add ( shard entry ) ; } } } return shard ; }
public void add state applier ( cluster state applier applier ) { normal priority state applier . add ( applier ) ; }
public list < entry > get entry ( ) { return entry = list . create when null ( entry ) ; }
public void circuit break ( string field name , long bytes need ) { final long memory byte limit = this . limit and overhead . limit ; this . trip count . increment and get ( ) ; final string message = `` [ `` + this . name + `` ] data too large , data for [ `` + field name + `` ] `` + `` would be [ `` + byte need + `` / `` + new byte size value ( byte need ) + `` ] `` + `` , which be large than the limit of [ `` + memory byte limit + `` / `` + new byte size value ( memory byte limit ) + `` ] `` ; logger . debug ( ( ) - > new parameterized message ( `` { } `` , message ) ) ; throw new circuit break exception ( message , bytes need , memory byte limit , durability ) ; }
public void invalidate ( k key ) { cache segment < k , v > segment = get cache segment ( key ) ; segment . remove ( key , invalidation consumer ) ; }
public script stats sum ( ) { if ( general ! = null ) { return general ; } long compilation = 0 ; long cache eviction = 0 ; long compilation limit trigger = 0 ; for ( script stats stat : context . value ( ) ) { compilation += stat . get compilation ( ) ; cache eviction += stat . get cache eviction ( ) ; compilation limit trigger += stat . get compilation limit trigger ( ) ; } return new script stats ( compilation , cache eviction , compilation limit trigger ) ; }
public static string get package name ( string fq class name ) { assert . not null ( fq class name , `` class name must not be null `` ) ; int last dot index = fq class name . last index of ( package_separator ) ; return ( last dot index ! = -1 ? fq class name . substring ( 0 , last dot index ) : `` `` ) ; }
public iterator < integer > key it ( ) { final iterator < int cursor > iterator = map . key ( ) . iterator ( ) ; return new iterator < integer > ( ) { @ override public boolean have next ( ) { return iterator . have next ( ) ; } @ override public integer next ( ) { return iterator . next ( ) . value ; } @ override public void remove ( ) { throw new unsupported operation exception ( ) ; } } ; }
public line string builder close ( ) { coordinate start = coordinate . get ( 0 ) ; coordinate end = coordinate . get ( coordinate . size ( ) - 1 ) ; if ( start . x ! = end . x || start . y ! = end . y ) { coordinate . add ( start ) ; } return this ; }
public polygon builder hole ( line string builder hole ) { return this . hole ( hole , false ) ; }
public static geo polygon query builder geo polygon query ( string name , list < geo point > point ) { return new geo polygon query builder ( name , point ) ; }
public geo bound box query builder set corner o g c ( geo point bottom leave , geo point top right ) { return set corner ( top right . get lat ( ) , bottom left . get lon ( ) , bottom left . get lat ( ) , top right . get lon ( ) ) ; }
public static void write operation ( stream output out stream , list < operation > to write ) throw i o exception { final byte stream output out = new byte stream output ( ) ; out stream . write int ( to write . size ( ) ) ; final buffer checksum stream output checksum stream output = new buffer checksum stream output ( out ) ; for ( operation op : to write ) { out . reset ( ) ; write operation no size ( checksum stream output , op ) ; out stream . write int ( math . to int exact ( out . position ( ) ) ) ; out . byte ( ) . write to ( out stream ) ; } }
public geo distance query builder point ( double lat , double lon ) { this . center = new geo point ( lat , lon ) ; return this ; }
public static < t > t instantiate ( constructor < t > constructor , object . . . args ) { try { return constructor . new instance ( args ) ; } catch ( exception ex ) { throw reflection exception ( ex ) ; } }
public static string capitalize first char ( string name ) { if ( ( name == null ) || name . equal ( `` `` ) ) { return name ; } char start = name . char at ( 0 ) ; if ( character . be low case ( start ) ) { start = character . to upper case ( start ) ; return start + name . substring ( 1 ) ; } return name ; } // capitalize first char
public static path [ ] file ( path directory , string glob ) throw i o exception { try ( directory stream < path > stream = file . new directory stream ( directory , glob ) ) { return to array ( stream ) ; } }
public input stream get a stream ( ) throw i o exception { byte array output stream array out = new byte array output stream ( ) ; writer writer = new output stream writer ( array out , `` utf-8 `` ) ; for ( provider provider : provider list ) { writer . write ( provider . get class name ( ) ) ; writer . write ( `` \n `` ) ; } writer . close ( ) ; return new byte array input stream ( array out . to byte array ( ) ) ; }
public shard id get shard id ( ) { return this . shard id ; }
public static directory reader wrap ( directory reader in , query timeout query timeout ) throw i o exception { return new exitable directory reader ( in , query timeout ) ; }
public static query new slow range query ( string field , long low value , long upper value ) { return new sort numeric doc value range query ( field , low value , upper value ) { @ override sort numeric doc value get value ( leaf reader reader , string field ) throw i o exception { numeric doc value value = reader . get numeric doc value ( field ) ; if ( value == null ) { return null ; } return doc value . singleton ( value ) ; } } ; }
public match bool prefix query builder minimum should match ( string minimum should match ) { this . minimum should match = minimum should match ; return this ; }
public static boolean be valid ( coordinate coord ) { if ( double . be na n ( coord . x ) ) return false ; if ( double . be infinite ( coord . x ) ) return false ; if ( double . be na n ( coord . y ) ) return false ; if ( double . be infinite ( coord . y ) ) return false ; return true ; }
public int get column number ( ) { return original . get column number ( ) ; }
public static < t > recycler < t > concurrent deque ( recycler . c < t > c , int limit ) { return new concurrent deque recycler < > ( c , limit ) ; }
public < t > void add setting update consumer ( set < t > setting , consumer < t > consumer ) { ensure not frozen ( ) ; if ( set == null ) { throw new illegal argument exception ( `` set must not be null `` ) ; } index setting . get scoped setting ( ) . add setting update consumer ( set , consumer ) ; }
public static final boolean updatable primary key ( setting setting ) { return default if null ( setting . be updatable primary key ( ) , false ) ; }
public final boolean be dynamic ( ) { return property . contains ( property . dynamic ) || property . contains ( property . operator dynamic ) ; }
public setting get by prefix ( string prefix ) { return new setting ( new filter map ( this . setting , ( k ) - > k . start with ( prefix ) , prefix ) , secure setting == null ? null : new prefixed secure setting ( secure setting , prefix , s - > s . start with ( prefix ) ) ) ; }
public boolean exist or fallback exists ( final setting setting ) { return setting . key set ( ) . contains ( get key ( ) ) || ( fallback setting ! = null & & fallback setting . exists or fallback exists ( setting ) ) ; }
public setting get by prefix ( string prefix ) { return new setting ( new filter map ( this . setting , ( k ) - > k . start with ( prefix ) , prefix ) , secure setting == null ? null : new prefixed secure setting ( secure setting , prefix , s - > s . start with ( prefix ) ) ) ; }
public long get a long ( string setting , long default value ) { string s value = get ( set ) ; if ( s value == null ) { return default value ; } try { return long . parse long ( s value ) ; } catch ( number format exception e ) { throw new setting exception ( `` fail to parse long setting [ `` + setting + `` ] with value [ `` + s value + `` ] `` , e ) ; } }
public string to string ( ) { string builder sb = new string builder ( ) ; int entry count = filter . size ( ) ; for ( map . entry < string , string [ ] > entry : filter . entry set ( ) ) { string attr = entry . get key ( ) ; string [ ] value = entry . get value ( ) ; sb . append ( attr ) ; sb . append ( `` : \ `` `` ) ; int value count = value . length ; for ( string value : value ) { sb . append ( value ) ; if ( value count > 1 ) { sb . append ( `` `` ) . append ( op type . to string ( ) ) . append ( `` `` ) ; } value count -- ; } sb . append ( `` \ `` `` ) ; if ( entry count > 1 ) { sb . append ( `` , `` ) ; } entry count -- ; } return sb . to string ( ) ; }
public static long round year ( final long utc millis ) { int year = get year ( utc millis ) ; return utc millis at start of year ( year ) ; }
public double parse ( string distance , distance unit default unit ) { return parse ( distance , default unit , this ) ; }
public static long decode zig zag64 ( final long n ) { return ( n > > > 1 ) ^ - ( n & 1 ) ; }
public static void write float l e ( float d , byte [ ] arr , int offset ) { write int l e ( float . float to raw int bit ( d ) , arr , offset ) ; }
public static < t extend iterable < ? > > t no null element ( t iterable , string message , object . . . value ) { validate . not null ( iterable ) ; int i = 0 ; for ( iterator < ? > it = iterable . iterator ( ) ; it . have next ( ) ; i++ ) { if ( it . next ( ) == null ) { object [ ] values2 = array utils . add all ( value , integer . value of ( i ) ) ; throw new illegal argument exception ( string . format ( message , values2 ) ) ; } } return iterable ; }
public boolean be count down ( ) { assert count down . get ( ) > = 0 ; return count down . get ( ) == 0 ; }
public boolean be count down ( ) { assert count down . get ( ) > = 0 ; return count down . get ( ) == 0 ; }
public boolean be hold by current thread ( t key ) { key lock lock = map . get ( key ) ; if ( lock == null ) { return false ; } return lock . be hold by current thread ( ) ; }
public e w a h iterator32 get e w a h iterator ( ) { return new e w a h iterator32 ( this . buffer ) ; }
public schedule cancellable schedule ( runnable command , time value delay , string executor ) { final runnable context preserve runnable = thread context . preserve context ( command ) ; final runnable to schedule ; if ( name . same . equal ( executor ) == false ) { to schedule = new thread runnable ( context preserving runnable , executor ( executor ) ) ; } else if ( slow scheduler warn threshold nanos > 0 ) { to schedule = new runnable ( ) { @ override public void run ( ) { final long start time = thread pool . this . relative time in nanos ( ) ; try { context preserving runnable . run ( ) ; } finally { final long take = thread pool . this . relative time in nanos ( ) - start time ; if ( take > slow scheduler warn threshold nanos ) { logger . warn ( `` execution of [ { } ] take [ { } m ] which be above the warn threshold of [ { } ms ] `` , context preserving runnable , time unit . nanosecond . to millis ( take ) , time unit . nanosecond . to millis ( slow scheduler warn threshold nanos ) ) ; } } } @ override public string to string ( ) { return context preserve runnable . to string ( ) ; } } ; } else { to schedule = context preserve runnable ; } return new schedule cancellable adapter ( scheduler . schedule ( to schedule , delay . millis ( ) , time unit . millisecond ) ) ; }
public node build ( random rng ) { log . debug ( `` bagging . . . `` ) ; array . fill ( sample , false ) ; data bag = data . bagging ( rng , sample ) ; log . debug ( `` building . . . `` ) ; return tree builder . build ( rng , bag ) ; }
public boolean be after ( readable interval interval ) { long end millis ; if ( interval == null ) { end millis = date time utils . current time millis ( ) ; } else { end millis = interval . get end millis ( ) ; } return ( get start millis ( ) > = end millis ) ; }
public final validation exception add validation error ( iterable < string > error ) { for ( string error : error ) { validation error . add ( error ) ; } return this ; }
public void await success ( long timeout millis ) { delegate . await success ( timeout millis ) ; }
public discovery node tie break active master ( collection < discovery node > active master ) { return active master . stream ( ) . min ( elect master service : : compare node ) . get ( ) ; }
public synchronize void fail all state and clear ( exception reason ) { for ( cluster state context pending state : pending state ) { if ( pending state . commit ( ) ) { pending state . listener . on new cluster state fail ( reason ) ; } } pending state . clear ( ) ; }
public void set thread factory ( fork join pool . fork join worker thread factory thread factory ) { this . thread factory = thread factory ; }
public set < string > available index folder for path ( final node path node path , predicate < string > exclude index path id predicate ) throw i o exception { if ( node path == null || lock == null ) { throw new illegal state exception ( `` node be not configure to store local location `` ) ; } assert env be lock ( ) ; final set < string > index folder = new hash set < > ( ) ; path index location = node path . index path ; if ( file . be directory ( index location ) ) { try ( directory stream < path > stream = file . new directory stream ( index location ) ) { for ( path index : stream ) { final string file name = index . get file name ( ) . to string ( ) ; if ( exclude index path id predicate . test ( file name ) == false & & file . be directory ( index ) ) { index folder . add ( file name ) ; } } } } return index folder ; }
public shard lock shard lock ( shard id id , final string detail ) throw shard lock obtain failed exception { return shard lock ( id , detail , 0 ) ; }
public path [ ] node data path ( ) { assert env be lock ( ) ; path [ ] path = new path [ node path . length ] ; for ( int i=0 ; i < path . length ; i++ ) { paths [ i ] = node path [ i ] . path ; } return path ; }
public shard id get shard id ( ) { return shard id ; }
public static void override version ( version new version , path . . . data path ) throw i o exception { for ( final path data path : data path ) { final path index path = data path . resolve ( metadata_directory_name ) ; if ( file . exists ( index path ) ) { try ( directory reader reader = directory reader . open ( new n i o f s directory ( data path . resolve ( metadata_directory_name ) ) ) ) { final map < string , string > user data = reader . get index commit ( ) . get user data ( ) ; assert user data . get ( node_version_key ) ! = null ; try ( index writer index writer = create index writer ( new n i o f s directory ( data path . resolve ( metadata_directory_name ) ) , true ) ) { final map < string , string > commit data = new hash map < > ( user data ) ; commit data . put ( node_version_key , integer . to string ( new version . id ) ) ; index writer . set live commit data ( commit data . entry set ( ) ) ; index writer . commit ( ) ; } } catch ( index not find exception e ) { logger . debug ( new parameterized message ( `` no on-disk state at { } `` , index path ) , e ) ; } } } }
public t get ( final string name ) { for ( final t i : this ) { if ( i . get name ( ) . equal ( name ) ) { return i ; } } return null ; }
public static pre configure token filter singleton ( string name , boolean use filter for multiterm query , function < token stream , token stream > create ) { return new pre configure token filter ( name , use filter for multiterm query , true , cache strategy . one , ( token stream , version ) - > create . apply ( token stream ) ) ; }
public static set < string > available codecs ( ) { if ( loader == null ) { throw new illegal state exception ( `` you call codec . available codecs ( ) before all codecs could be initialize . `` + `` this likely happen if you call it from a codec 's ctor . `` ) ; } return loader . available service ( ) ; }
public synchronize list < index commit > get snapshot ( ) { return new array list < index commit > ( index commits . value ( ) ) ; }
public long get term memory in byte ( ) { return this . term memory in byte ; }
public long get memory in byte ( ) { return this . memory in byte ; }
public void close input stream ( ) throw i o exception { if ( ! f close ) { f close = true ; f stream . close ( ) ; } else { throw new i o exception ( ) ; } }
public long get total throttled time in millis ( ) { return this . total throttled time in millis ; }
public simple query string builder analyze wildcard ( boolean analyze wildcard ) { this . setting . analyze wildcard ( analyze wildcard ) ; return this ; }
public update setting request setting ( setting setting ) { this . setting = setting ; return this ; }
public data file writer < d > set sync interval ( int sync interval ) { if ( sync interval < 32 || sync interval > ( 1 < < 30 ) ) { throw new illegal argument exception ( `` invalid sync interval value : `` + sync interval ) ; } this . sync interval = sync interval ; return this ; }
public time value get translog retention age ( ) { assert should disable translog retention ( setting ) == false || translog retention age . millis ( ) == -1l : translog retention size ; return translog retention age ; }
public boolean should roll generation ( ) { final long threshold = this . index setting . get generation threshold size ( ) . get byte ( ) ; try ( releasable lock ignore = read lock . acquire ( ) ) { return this . current . size in byte ( ) > threshold ; } }
public int get max script field ( ) { return this . max script field ; }
public object [ ] search after ( ) { if ( search after builder == null ) { return null ; } return search after builder . get sort value ( ) ; }
public iterable < map field type > get eager global ordinal field ( ) { document mapper mapper = this . mapper ; if ( mapper == null ) { return collection . empty set ( ) ; } map lookup mapping lookup = mapper . mapper ( ) ; return map lookup . get matching field name ( `` * `` ) . stream ( ) . map ( map lookup : : get field type ) . filter ( mapped field type : : eager global ordinal ) . collect ( collector . to list ( ) ) ; }
public final parse context create copy to context ( ) { return new filter parse context ( this ) { @ override public boolean be within copy to ( ) { return true ; } } ; }
public object parse to ( range field mapper . range field type field type , x content parser parser , boolean coerce , boolean include ) throw i o exception { number value = number type . parse ( parser , coerce ) ; return include ? value : ( number ) next down ( value ) ; }
public synchronize boolean get auto i o throttle ( ) { return do auto i o throttle ; }
public qb indexed shape path ( string index shape path ) { this . indexed shape path = indexed shape path ; return ( qb ) this ; }
public search request builder set query ( query builder query builder ) { source builder ( ) . query ( query builder ) ; return this ; }
public match query builder cutoff frequency ( float cutoff ) { this . cutoff frequency = cutoff ; return this ; }
public function score query builder score mode ( function score query . score mode score mode ) { if ( score mode == null ) { throw new illegal argument exception ( `` [ `` + name + `` ] require 'score_mode ' field `` ) ; } this . score mode = score mode ; return this ; }
public function score query builder max boost ( float max boost ) { this . max boost = max boost ; return this ; }
public geo distance sort builder validation ( geo validation method method ) { this . validation = method ; return this ; }
public field get field ( string field name ) { return ( field ) this . h field . get ( field name ) ; }
public geo distance sort builder geo distance ( geo distance geo distance ) { this . geo distance = geo distance ; return this ; }
public geo distance sort builder validation ( geo validation method method ) { this . validation = method ; return this ; }
public match phrase prefix query builder max expansion ( int max expansion ) { if ( max expansion < 0 ) { throw new illegal argument exception ( `` no negative max expansion allow . `` ) ; } this . max expansion = max expansion ; return this ; }
public match phrase prefix query builder zero term query ( zero term query option zero term query ) { if ( zero term query == null ) { throw new illegal argument exception ( `` [ `` + name + `` ] require zero term query to be non-null `` ) ; } this . zero term query = zero term query ; return this ; }
public direct candidate generator builder min doc freq ( float min doc freq ) { this . min doc freq = min doc freq ; return this ; }
public http response decoder spec fail on miss response ( boolean fail on miss response ) { this . fail on miss response = fail on miss response ; return this ; }
public search request builder set query ( query builder query builder ) { source builder ( ) . query ( query builder ) ; return this ; }
public static match phrase prefix query builder match phrase prefix query ( string name , object text ) { return new match phrase prefix query builder ( name , text ) ; }
public static match phrase prefix query builder match phrase prefix query ( string name , object text ) { return new match phrase prefix query builder ( name , text ) ; }
public combine field query builder field ( string field , float boost ) { if ( string . be empty ( field ) ) { throw new illegal argument exception ( `` supply field be null or empty . `` ) ; } validate field boost ( boost ) ; this . field and boost . put ( field , boost ) ; return this ; }
public static exists query builder exists query ( string name ) { return new exists query builder ( name ) ; }
public static function score query builder function score query ( score function builder function ) { return new function score query builder ( function ) ; }
public static constant score query builder constant score query ( query builder query builder ) { return new constant score query builder ( query builder ) ; }
public static geo shape query builder geo intersection query ( string name , geometry shape ) throw i o exception { geo shape query builder builder = geo shape query ( name , shape ) ; builder . relation ( shape relation . intersects ) ; return builder ; }
public match bool prefix query builder fuzziness ( object fuzziness ) { this . fuzziness = fuzziness . build ( fuzziness ) ; return this ; }
public document field field ( string field name ) { document field result = document field . get ( field name ) ; if ( result ! = null ) { return result ; } else { return meta field . get ( field name ) ; } }
public parse document parse document ( source to parse source , map lookup map lookup ) throw mapper parse exception { validate type ( source , map lookup . get type ( ) ) ; final parse context . internal parse context context ; final x content type x content type = source . get x content type ( ) ; try ( x content parser parser = x content helper . create parser ( x content registry , log deprecation handler . instance , source . source ( ) , x content type ) ) { context = new parse context . internal parse context ( map lookup , index setting , index analyzer , date parser context , source , parser ) ; validate start ( parser ) ; metadata field mapper [ ] metadata field mapper = map lookup . get mapping ( ) . get sort metadata mapper ( ) ; internal parse document ( map lookup . get mapping ( ) . get root ( ) , metadata field mapper , context , parser ) ; validate end ( parser ) ; } catch ( exception e ) { throw wrap in mapper parsing exception ( source , e ) ; } string remain path = context . path ( ) . path a text ( `` `` ) ; if ( remain path . be empty ( ) == false ) { throw new illegal state exception ( `` find leftover path element : `` + remain path ) ; } context . post parse ( ) ; return parse document ( source , context , create dynamic update ( map lookup , context . get dynamic mapper ( ) , context . get dynamic runtime field ( ) ) ) ; }
public multi match query builder field ( string field ) { if ( string . be empty ( field ) ) { throw new illegal argument exception ( `` supply field be null or empty . `` ) ; } this . field boost . put ( field , abstract query builder . default_boost ) ; return this ; }
public combine field query builder field ( string field , float boost ) { if ( string . be empty ( field ) ) { throw new illegal argument exception ( `` supply field be null or empty . `` ) ; } validate field boost ( boost ) ; this . field and boost . put ( field , boost ) ; return this ; }
public common term query builder analyzer ( string analyzer ) { this . analyzer = analyzer ; return this ; }
public simple query string builder lenient ( boolean lenient ) { this . setting . lenient ( lenient ) ; this . lenient set = true ; return this ; }
public long total ( ) { return this . total ; }
public time value get external total time ( ) { return new time value ( external total time in millis ) ; }
public long get total throttled time in millis ( ) { return this . total throttled time in millis ; }
public time value get external total time ( ) { return new time value ( external total time in millis ) ; }
public static backoff policy exponential backoff ( time value initial delay , int max number of retries ) { return new exponential backoff ( ( int ) check delay ( initial delay ) . millis ( ) , max number of retries ) ; }
public worker bulk by scroll task state get worker state ( ) { if ( be worker ( ) == false ) { throw new illegal state exception ( `` this task be not set to be a worker `` ) ; } return worker state ; }
public reindex request set source batch size ( int size ) { this . get search request ( ) . source ( ) . size ( size ) ; return this ; }
public synchronize void update global checkpoint on replica ( final long new global checkpoint , final string reason ) { assert invariant ( ) ; assert primary mode == false ; / * * the global checkpoint here be a local knowledge which be update under the mandate of the primary . it can happen that the primary * information be lag compare to a replica ( e . g . , if a replica be promote to primary but have stale info relative to other * replica shard ) . in these case , the local knowledge of the global checkpoint could be high than the sync from the lag * primary . * / final long previous global checkpoint = global checkpoint ; if ( new global checkpoint > previous global checkpoint ) { global checkpoint = new global checkpoint ; logger . trace ( `` update global checkpoint from [ { } ] to [ { } ] due to [ { } ] `` , previous global checkpoint , global checkpoint , reason ) ; on global checkpoint update . accept ( global checkpoint ) ; } assert invariant ( ) ; }
public synchronize retention lease renew retention lease ( final string id , final long retain sequence number , final string source ) { assert primary mode ; final retention lease exist retention lease = retention lease . get ( id ) ; if ( exist retention lease == null ) { throw new retention lease not find exception ( id ) ; } if ( retain sequence number < exist retention lease . retain sequence number ( ) ) { assert peer_recovery_retention_lease_source . equal ( source ) == false : `` renew peer recovery retention lease [ `` + exist retention lease + `` ] `` + `` with a low retaining sequence number [ `` + retain sequence number + `` ] `` ; throw new retention lease invalid retain seq no exception ( id , source , retain sequence number , exist retention lease ) ; } final retention lease retention lease = new retention lease ( id , retain sequence number , current time millis supplier . get a long ( ) , source ) ; retention lease = new retention lease ( operation primary term , retention lease . version ( ) + 1 , stream . concat ( retention lease . lease ( ) . stream ( ) . filter ( lease - > lease . id ( ) . equal ( id ) == false ) , stream . of ( retention lease ) ) . collect ( collector . to list ( ) ) ) ; return retention lease ; }
public restore snapshot request builder set snapshot ( string snapshot ) { request . snapshot ( snapshot ) ; return this ; }
public object get file ( int index ) { if ( index < size ( ) ) { return _mru file list . get ( index ) ; } return null ; }
public long incremental size ( ) { return incremental size ; }
public boolean contain physical index file ( string physical name ) { return find physical index file ( physical name ) ! = null ; }
public static void clean directory ( final file directory ) throw i o exception { final file [ ] file = list file ( directory , null ) ; final list < exception > cause list = new array list < > ( ) ; for ( final file file : file ) { try { force delete ( file ) ; } catch ( final i o exception ioe ) { cause list . add ( ioe ) ; } } if ( ! cause list . be empty ( ) ) { throw new i o exception list ( directory . to string ( ) , cause list ) ; } }
public void ensure index have history u u i d ( ) throw i o exception { metadata lock . write lock ( ) . lock ( ) ; try ( index writer writer = new temporary append index writer ( directory , null ) ) { final map < string , string > user data = get user data ( writer ) ; if ( user data . contains key ( engine . history_uuid_key ) == false ) { update commit data ( writer , collection . singleton map ( engine . history_uuid_key , u u i d . random base64 u u i d ( ) ) ) ; } } finally { metadata lock . write lock ( ) . unlock ( ) ; } }
public location add ( final operation operation ) throw i o exception { final releasable byte stream output out = new releasable byte stream output ( big array ) ; try { final long start = out . position ( ) ; out . skip ( integer . byte ) ; write operation no size ( new buffer checksum stream output ( out ) , operation ) ; final long end = out . position ( ) ; final int operation size = ( int ) ( end - integer . bytes - start ) ; out . seek ( start ) ; out . write int ( operation size ) ; out . seek ( end ) ; final byte reference byte = out . byte ( ) ; try ( releasable lock ignore = read lock . acquire ( ) ) { ensure open ( ) ; if ( operation . primary term ( ) > current . get primary term ( ) ) { assert false : `` operation term be new than the current term ; `` + `` current term [ `` + current . get primary term ( ) + `` ] , operation term [ `` + operation + `` ] `` ; throw new illegal argument exception ( `` operation term be new than the current term ; `` + `` current term [ `` + current . get primary term ( ) + `` ] , operation term [ `` + operation + `` ] `` ) ; } return current . add ( byte , operation . seq no ( ) ) ; } } catch ( final already close exception | i o exception ex ) { close on tragic event ( ex ) ; throw ex ; } catch ( final exception ex ) { close on tragic event ( ex ) ; throw new translog exception ( shard id , `` fail to write operation [ `` + operation + `` ] `` , ex ) ; } finally { releasables . close ( out ) ; } }
public long size in byte by min gen ( long min generation ) { try ( releasable lock ignore = read lock . acquire ( ) ) { ensure open ( ) ; return stream . concat ( reader . stream ( ) , stream . of ( current ) ) . filter ( r - > r . get generation ( ) > = min generation ) . map to long ( base translog reader : : size in byte ) . sum ( ) ; } }
public long get total stopped time in millis ( ) { return this . total stop time in millis ; }
public void mark recovery a do ( long id ) { recovery target remove = on go recovery . remove ( id ) ; if ( remove ! = null ) { logger . trace ( `` { } mark recovery from { } a do , id [ { } ] `` , remove . shard id ( ) , remove . source node ( ) , remove . recovery id ( ) ) ; remove . mark a do ( ) ; } }
public int get current thread count ( ) { executor executor = this . executor ; if ( executor ! = null ) { if ( executor instanceof thread pool executor ) { return ( ( thread pool executor ) executor ) . get pool size ( ) ; } else if ( executor instanceof resizable executor ) { return ( ( resizable executor ) executor ) . get pool size ( ) ; } else { return -1 ; } } else { return -2 ; } }
public pipeline get pipeline ( ) { return this . pipeline ; }
public document output setting ( output setting output setting ) { validate . not null ( output setting ) ; this . output setting = output setting ; return this ; }
public < params extend persistent task params > void create persistent task ( string task id , string task name , params task params , action listener < persistent task < ? > > listener ) { cluster service . submit state update task ( `` create persistent task `` , new cluster state update task ( ) { @ override public cluster state execute ( cluster state current state ) { persistent task custom metadata . builder builder = builder ( current state ) ; if ( builder . have task ( task id ) ) { throw new resource already exist exception ( `` task with id { `` + task id + `` } already exist `` ) ; } persistent task executor < params > task executor = registry . get persistent task executor safe ( task name ) ; task executor . validate ( task params , current state ) ; assignment assignment = create assignment ( task name , task params , current state ) ; return update ( current state , builder . add task ( task id , task name , task params , assignment ) ) ; } @ override public void on failure ( string source , exception e ) { listener . on failure ( e ) ; } @ override public void cluster state process ( string source , cluster state old state , cluster state new state ) { persistent task custom metadata task = new state . get metadata ( ) . custom ( persistent task custom metadata . type ) ; if ( task ! = null ) { persistent task < ? > task = task . get task ( task id ) ; listener . on response ( task ) ; if ( task ! = null & & task . be assign ( ) == false & & periodic rechecker . be schedule ( ) == false ) { periodic rechecker . reschedule if necessary ( ) ; } } else { listener . on response ( null ) ; } } } ) ; }
public setting diff ( setting source , setting default setting ) { setting . builder builder = setting . builder ( ) ; for ( set < ? > setting : key setting . value ( ) ) { set . diff ( builder , source , default setting ) ; } for ( set < ? > setting : complex matcher . value ( ) ) { set . diff ( builder , source , default setting ) ; } return builder . build ( ) ; }
public static synchronize string get ant version ( ) throw build exception { if ( ant version == null ) { try { property prop = new property ( ) ; input stream in = main . class . get resource a stream ( `` /org/apache/tools/ant/version . txt `` ) ; prop . load ( in ) ; in . close ( ) ; string buffer msg = new string buffer ( ) ; msg . append ( `` apache ant version `` ) ; msg . append ( prop . get property ( `` version `` ) ) ; msg . append ( `` compile on `` ) ; msg . append ( prop . get property ( `` date `` ) ) ; ant version = msg . to string ( ) ; } catch ( i o exception ioe ) { throw new build exception ( `` could not load the version information : `` + ioe . get message ( ) ) ; } catch ( null pointer exception npe ) { throw new build exception ( `` could not load the version information . `` ) ; } } return ant version ; }
public static extend plugins class loader create ( class loader parent , list < class loader > extend loader ) { return access controller . do privilege ( ( privilege action < extend plugins class loader > ) ( ) - > new extend plugins class loader ( parent , extend loader ) ) ; }
public license get license ( ) { return license ; }
public boolean be delta compress ( ) { return delta compress ; }
protect void handle response ( http request < ? > request , mutable http response < ? > response ) { http header header = request . get header ( ) ; optional < string > origin header = header . get origin ( ) ; origin header . if present ( request origin - > { optional < cors origin configuration > optional config = get configuration ( request origin ) ; if ( optional config . be present ( ) ) { cors origin configuration config = optional config . get ( ) ; if ( cors util . be preflight request ( request ) ) { optional < http method > result = header . get first ( access_control_request_method , conversion_context_http_method ) ; set allow method ( result . get ( ) , response ) ; optional < list < string > > allow header = header . get ( access_control_request_headers , conversion context . list_of_string ) ; allow header . if present ( val - > set allow header ( val , response ) ) ; set max age ( config . get max age ( ) , response ) ; } set origin ( request origin , response ) ; set vary ( response ) ; set expose header ( config . get exposed header ( ) , response ) ; set allow credential ( config , response ) ; } } ) ; }
public string get request uri ( http servlet request request ) { string uri = ( string ) request . get attribute ( web utils . include_request_uri_attribute ) ; if ( uri == null ) { uri = request . get request u r i ( ) ; } return decode and clean uri string ( request , uri ) ; }
public string get escape path query ( ) { char [ ] raw path query = get raw path query ( ) ; return ( raw path query == null ) ? null : new string ( raw path query ) ; }
public static string [ ] cors set a array ( string cors set ) { if ( string . be null or empty ( cors set ) ) { return new string [ 0 ] ; } return array . a list ( cors set . split ( `` , `` ) ) . stream ( ) . map ( string : : trim ) . to array ( size - > new string [ size ] ) ; }
public embed database builder add script ( string . . . script ) { for ( string script : script ) { add script ( script ) ; } return this ; }
public short get lang id ( ) { return lang id ; }
public x content builder to x content group by none ( x content builder builder , params params ) throw i o exception { to x content common ( builder , params ) ; builder . start array ( task ) ; for ( task info task info : get task ( ) ) { builder . start object ( ) ; task info . to x content ( builder , params ) ; builder . end object ( ) ; } builder . end array ( ) ; return builder ; }
public aggregator [ ] create top level aggregator ( ) throw i o exception { / * * top level aggs only collect from own bucket ord 0 which be * * exactly * what cardinality upper bound . one * mean * . * / return create sub aggregator ( null , cardinality upper bound . one ) ; }
public str builder append separator ( string separator ) { return append separator ( separator , null ) ; }
protect final internal aggregation [ ] build aggregation for single bucket ( long [ ] own bucket ords , single bucket result builder result builder ) throw i o exception { / * * it 'd be entirely reasonable to call * ` consume bucket and maybe break ( own bucket ords . length ) ` * here but we do n't because single bucket aggs never have . * / internal aggregation [ ] sub aggregation result = build sub aggs for bucket ( own bucket ords ) ; internal aggregation [ ] result = new internal aggregation [ own bucket ords . length ] ; for ( int ord idx = 0 ; ord idx < own bucket ords . length ; ord idx++ ) { result [ ord idx ] = result builder . build ( own bucket ords [ ord idx ] , sub aggregation result [ ord idx ] ) ; } return result ; }
public static double estimate compaction gain ( set < s s table reader > overlap ) { set < i cardinality > cardinality = new hash set < > ( overlap . size ( ) ) ; for ( s s table reader sstable : overlapping ) { try { i cardinality cardinality = ( ( compaction metadata ) sstable . descriptor . get metadata serializer ( ) . deserialize ( sstable . descriptor , metadata type . compaction ) ) . cardinality estimator ; if ( cardinality ! = null ) cardinality . add ( cardinality ) ; else logger . trace ( `` get a null cardinality estimator in : { } `` , sstable . get filename ( ) ) ; } catch ( i o exception e ) { logger . warn ( `` could not read up compaction metadata for { } `` , sstable , e ) ; } } long total key count before = 0 ; for ( i cardinality cardinality : cardinality ) { total key count before += cardinality . cardinality ( ) ; } if ( total key count before == 0 ) return 1 ; long total key count after = merge cardinality ( cardinality ) . cardinality ( ) ; logger . trace ( `` estimate compaction gain : { } / { } = { } `` , total key count after , total key count before , ( ( double ) total key count after ) /total key count before ) ; return ( ( double ) total key count after ) /total key count before ; }
public void aggregator ( aggregator [ ] aggregator ) { this . aggregator = aggregator ; }
public date histogram aggregation builder interval ( long interval ) { date histogram interval . interval ( interval ) ; return this ; }
public long min doc count ( ) { return bucket count threshold . get min doc count ( ) ; }
public t shard size ( integer shard size ) { this . shard size = shard size ; return ( t ) this ; }
public significant term aggregation builder shard min doc count ( long shard min doc count ) { if ( shard min doc count < 0 ) { throw new illegal argument exception ( `` [ shard min doc count ] must be great than or equal to 0 . find [ `` + shard min doc count + `` ] in [ `` + name + `` ] `` ) ; } bucket count threshold . set shard min doc count ( shard min doc count ) ; return this ; }
public significant term aggregation builder shard size ( int shard size ) { if ( shard size < = 0 ) { throw new illegal argument exception ( `` [ shard size ] must be great than 0 . find [ `` + shard size + `` ] in [ `` + name + `` ] `` ) ; } bucket count threshold . set shard size ( shard size ) ; return this ; }
public score mode score mode ( ) { for ( aggregator agg : sub aggregator ) { if ( agg . score mode ( ) . needs score ( ) ) { return score mode . complete ; } } return score mode . complete_no_scores ; }
protect bucket reduce bucket ( list < bucket > bucket , reduce context context ) { assert bucket . size ( ) > 0 ; list < internal aggregation > aggregation = new array list < > ( bucket . size ( ) ) ; long doc count = 0 ; for ( bucket bucket : bucket ) { doc count += bucket . doc count ; aggregation . add ( ( internal aggregation ) bucket . get aggregation ( ) ) ; } internal aggregation aggs = internal aggregation . reduce ( aggregation , context ) ; return create bucket ( bucket . get ( 0 ) . key , doc count , aggs ) ; }
public percentile config percentile config ( ) { return percentile config ; }
public double taylor ( final double . . . delta ) { double y = value ; for ( int i = 0 ; i < delta . length ; ++i ) { y += delta [ i ] * get derivative ( i ) ; } return y ; }
public double taylor ( final double . . . delta ) { double y = value ; for ( int i = 0 ; i < delta . length ; ++i ) { y += delta [ i ] * get derivative ( i ) ; } return y ; }
public static float trunc ( float number , int precision ) { if ( number < 0f ) { return ( float ) ( math . ceil ( number . double value ( ) * math . pow ( 10 , precision ) ) / math . pow ( 10 , precision ) ) ; } return ( float ) ( math . floor ( number . double value ( ) * math . pow ( 10 , precision ) ) / math . pow ( 10 , precision ) ) ; }
public compression metadata get compression metadata ( ) { if ( ! compression ) throw new illegal state exception ( this + `` be not compress `` ) ; return dfile . compression metadata ( ) . get ( ) ; }
public script field context script field ( ) { return search context . script field ( ) ; }
public boolean track score ( ) { return track score ; }
public void from x content ( x content parser parser ) throw i o exception { if ( parser . next token ( ) ! = x content parser . token . start_object ) { throw new illegal argument exception ( `` malformed content , must start with an object `` ) ; } else { x content parser . token token ; string current field name = null ; while ( ( token = parser . next token ( ) ) ! = x content parser . token . end_object ) { if ( token == x content parser . token . field_name ) { current field name = parser . current name ( ) ; } else if ( `` scroll_id `` . equal ( current field name ) & & token == x content parser . token . value_string ) { scroll id ( parser . text ( ) ) ; } else if ( `` scroll `` . equal ( current field name ) & & token == x content parser . token . value_string ) { scroll ( new scroll ( time value . parse time value ( parser . text ( ) , null , `` scroll `` ) ) ) ; } else { throw new illegal argument exception ( `` unknown parameter [ `` + current field name + `` ] in request body or parameter be of the wrong type [ `` + token + `` ] `` ) ; } } } }
public serial diff pipeline aggregation builder lag ( int lag ) { if ( lag < = 0 ) { throw new illegal argument exception ( `` [ lag ] must be a positive integer : [ `` + name + `` ] `` ) ; } this . lag = lag ; return this ; }
public long payload size ( int version ) { if ( payload size == -1 ) { payload size = payload == null ? 0 : serializer . serialize size ( payload , version ) ; payload size version = version ; } else if ( payload size version ! = version ) { return payload == null ? 0 : serializer . serialize size ( payload , version ) ; } return payload size ; }
public static string field ( field field ) { if ( field == null ) { return null_string ; } type t = field . get generic type ( ) ; string base string ; if ( t instanceof class ) { base string = clazz ( ( class < ? > ) t ) ; } else { base string = type ( t ) ; } return `` field ( `` + base string + `` `` + field . get name ( ) + `` in `` + field . get declare class ( ) . get name ( ) + `` ) `` ; }
public search request builder set query ( query builder query builder ) { source builder ( ) . query ( query builder ) ; return this ; }
public search source builder post filter ( query builder post filter ) { this . post query builder = post filter ; return this ; }
public inner hit builder add doc value field ( string field , string format ) { if ( doc value field == null || doc value field . be empty ( ) ) { doc value field = new array list < > ( ) ; } doc value field . add ( new field and format ( field , format ) ) ; return this ; }
public static map new context ( index searcher searcher ) { map context = new identity hash map ( ) ; context . put ( `` searcher `` , searcher ) ; return context ; }
public static string clean ( string charset name ) { try { return for name ( charset name ) . name ( ) ; } catch ( exception e ) { return null ; } }
public static long clamp keep alive time in nanos ( long keep alive time in nanos ) { return math . max ( keep alive time in nanos , min_keepalive_time_nanos ) ; }
public static object extract value ( string path , map < ? , ? > map ) { return extract value ( map , path . split ( `` \\ . `` ) ) ; }
public static profile shard result build shard result ( profilers profilers ) { list < query profiler > query profilers = profilers . get query profilers ( ) ; aggregation profiler agg profiler = profilers . get aggregation profiler ( ) ; list < query profile shard result > query result = new array list < > ( query profilers . size ( ) ) ; for ( query profiler query profiler : query profilers ) { query profile shard result result = new query profile shard result ( query profiler . get tree ( ) , query profiler . get rewrite time ( ) , query profiler . get collector ( ) ) ; query result . add ( result ) ; } aggregation profile shard result agg result = new aggregation profile shard result ( agg profiler . get tree ( ) ) ; return new profile shard result ( query result , agg result ) ; }
public static profile shard result build shard result ( profilers profilers ) { list < query profiler > query profilers = profilers . get query profilers ( ) ; aggregation profiler agg profiler = profilers . get aggregation profiler ( ) ; list < query profile shard result > query result = new array list < > ( query profilers . size ( ) ) ; for ( query profiler query profiler : query profilers ) { query profile shard result result = new query profile shard result ( query profiler . get tree ( ) , query profiler . get rewrite time ( ) , query profiler . get collector ( ) ) ; query result . add ( result ) ; } aggregation profile shard result agg result = new aggregation profile shard result ( agg profiler . get tree ( ) ) ; return new profile shard result ( query result , agg result ) ; }
public boolean be null ( ) { return reader ( ) . be null ( ) ; }
public int size ( ) { if ( fast ) { return ( map . size ( ) ) ; } else { synchronize ( map ) { return ( map . size ( ) ) ; } } }
public search request builder set rescorer ( rescorer builder < ? > rescorer ) { source builder ( ) . clear rescorers ( ) ; return add rescorer ( rescorer ) ; }
public boolean test ( string pattern ) { int separator index = pattern . index of ( remote cluster aware . remote_cluster_index_separator ) ; if ( separator index < 0 ) { return cluster alias == null & & match index ( pattern ) ; } else { string cluster pattern = pattern . substring ( 0 , separator index ) ; string index pattern = pattern . substring ( separator index + 1 ) ; return regex . simple match ( cluster pattern , cluster alias ) & & match index ( index pattern ) ; } }
public final string get nest path ( ) { return this . nested path ; }
public static script sort builder script sort ( script script , script sort type type ) { return new script sort builder ( script , type ) ; }
public suggest mode suggest mode ( ) { return suggest mode ; }
public void set max edits ( int max edits ) { if ( max edit < 1 || max edits > levenshtein automaton . maximum_supported_distance ) throw new unsupported operation exception ( `` invalid max edit `` ) ; this . max edits = max edits ; }
public more like this query builder min word length ( int min word length ) { this . min word length = min word length ; return this ; }
public phrase suggestion builder max error ( float max error ) { if ( max error < = 0 . 0 ) { throw new illegal argument exception ( `` max_error must be > 0 . 0 `` ) ; } this . max error = max error ; return this ; }
public string get global text ( ) { return global text ; }
public direct candidate generator builder max inspection ( integer max inspection ) { this . max inspection = max inspection ; return this ; }
public static set < index > restore index ( final cluster state current state , final set < index > index to check ) { final set < index > indices = new hash set < > ( ) ; for ( restore in progress . entry entry : current state . custom ( restore in progress . type , restore in progress . empty ) ) { for ( object object cursor < shard id , restore in progress . shard restore status > shard : entry . shard ( ) ) { index index = shard . key . get index ( ) ; if ( index to check . contains ( index ) & & shard . value . state ( ) . complete ( ) == false & & current state . get metadata ( ) . index ( index ) ! = null ) { index . add ( index ) ; } } } return index ; }
public void remove ban ( task id parent task id ) { logger . trace ( `` remove ban for the parent task { } `` , parent task id ) ; ban parent . remove ( parent task id ) ; }
public static void write operation ( stream output out stream , list < operation > to write ) throw i o exception { final byte stream output out = new byte stream output ( ) ; out stream . write int ( to write . size ( ) ) ; final buffer checksum stream output checksum stream output = new buffer checksum stream output ( out ) ; for ( operation op : to write ) { out . reset ( ) ; write operation no size ( checksum stream output , op ) ; out stream . write int ( math . to int exact ( out . position ( ) ) ) ; out . byte ( ) . write to ( out stream ) ; } }
public int get size ( ) { return node . size ( ) ; }
public int read ( final byte [ ] b , final int off , final int len ) throw i o exception { if ( len == 0 ) { return 0 ; } if ( bytes remain < = 0 ) { return -1 ; } int byte to read = len ; if ( byte to read > byte remain ) { byte to read = ( int ) bytes remain ; } int byte read ; byte buffer buf ; if ( byte to read < = buffer . capacity ( ) ) { buf = buffer ; bytes read = read ( byte to read ) ; } else { buf = byte buffer . allocate ( bytes to read ) ; bytes read = channel . read ( buf ) ; buf . flip ( ) ; } if ( byte read > = 0 ) { buf . get ( b , off , byte read ) ; bytes remain -= byte read ; } return byte read ; }
public static transport request wrap request ( discovery node node , transport request request ) { return new proxy request < > ( request , node ) ; }
public static transport request wrap request ( discovery node node , transport request request ) { return new proxy request < > ( request , node ) ; }
public inet socket address start ( ) throw i o exception { listen socket = new server socket ( ) ; listen socket . bind ( new inet socket address ( listen hostname , listen port ) ) ; logger . debug ( `` listen on { } and proxying to { } `` , listen socket . get local socket address ( ) , unix socket file . get absolute path ( ) ) ; accept thread = new thread ( ( ) - > { while ( run ) { try { socket incoming socket = listen socket . accept ( ) ; logger . debug ( `` accept incoming connection from { } `` , incoming socket . get remote socket address ( ) ) ; a f u n i x socket outgo socket = a f u n i x socket . new instance ( ) ; outgo socket . connect ( new a f u n i x socket address ( unix socket file ) ) ; new proxy pump ( incoming socket , outgo socket ) ; } catch ( i o exception ignore ) { } } } ) ; accept thread . set daemon ( true ) ; accept thread . set name ( `` tcp-unix-proxy-accept-thread `` ) ; accept thread . start ( ) ; return ( inet socket address ) listen socket . get local socket address ( ) ; }
public void connect to node ( final discovery node node , connection profile connection profile ) { plain action future . get ( fut - > connect to node ( node , connection profile , fut . map ( x - > null ) ) ) ; }
public void open connection ( final discovery node node , connection profile connection profile , action listener < transport . connection > listener ) { if ( be local node ( node ) ) { listener . on response ( local node connection ) ; } else { connection manager . open connection ( node , connection profile , listener ) ; } }
public void add listener ( final configuration listener listener ) { listener . add ( listener ) ; }
public void remove container listener ( container listener listener ) { listener . remove ( listener ) ; }
public void complete ( string value , boolean terminal ) { delegate . complete ( value , terminal ) ; }
public static string replace line break with space ( string in ) { char [ ] buf = new char [ in . length ( ) ] ; int o = 0 ; for ( int i = 0 ; i < buf . length ; ++i ) { char ch = in . char at ( i ) ; if ( ch == '\r ' ) { if ( i + 1 < buf . length & & in . char at ( i + 1 ) == '\n ' ) { buf [ o++ ] = ' ' ; ++i ; } else buf [ o++ ] = ' ' ; } else if ( ch == '\n ' ) buf [ o++ ] = ' ' ; else buf [ o++ ] = ch ; } return new string ( buf , 0 , o ) ; }
public static boolean constant time equal ( char [ ] a , char [ ] b ) { object . require non null ( a , `` char array must not be null for constant time equal `` ) ; object . require non null ( b , `` char array must not be null for constant time equal `` ) ; if ( a . length ! = b . length ) { return false ; } int equal = 0 ; for ( int i = 0 ; i < a . length ; i++ ) { equal |= a [ i ] ^ b [ i ] ; } return equal == 0 ; }
public static socket option < integer > get tcp keep interval socket option or null ( ) { return get extend socket option or null ( `` tcp_keepinterval `` ) ; }
public static < k , v > java . util . map < k , v > of ( k k1 , v v1 , k k2 , v v2 , k k3 , v v3 , k k4 , v v4 , k k5 , v v5 ) { return map n ( k1 , v1 , k2 , v2 , k3 , v3 , k4 , v4 , k5 , v5 ) ; }
public static void reset default file system ( ) { file system = new default file system ( ) ; }
public string find max prefix ( string path ) { if ( path == null ) { return null ; } if ( `` / `` . equal ( path ) ) { return path ; } string [ ] path component = path . split ( `` / `` ) ; trie node parent = root node ; list < string > component = new array list < string > ( ) ; if ( path component . length < = 1 ) { throw new illegal argument exception ( `` invalid path `` + path ) ; } int i = 1 ; string part = null ; string builder sb = new string builder ( ) ; int lastindex = -1 ; while ( ( i < path component . length ) ) { if ( parent . get child ( path component [ i ] ) ! = null ) { part = path component [ i ] ; parent = parent . get child ( part ) ; component . add ( part ) ; if ( parent . get property ( ) ) { lastindex = i-1 ; } } else { break ; } i++ ; } for ( int j=0 ; j < ( lastindex+1 ) ; j++ ) { sb . append ( `` / `` + component . get ( j ) ) ; } return sb . to string ( ) ; }
public static long deinterleave ( long b ) { b & = magic [ 0 ] ; b = ( b ^ ( b > > > shift [ 0 ] ) ) & magic [ 1 ] ; b = ( b ^ ( b > > > shift [ 1 ] ) ) & magic [ 2 ] ; b = ( b ^ ( b > > > shift [ 2 ] ) ) & magic [ 3 ] ; b = ( b ^ ( b > > > shift [ 3 ] ) ) & magic [ 4 ] ; b = ( b ^ ( b > > > shift [ 4 ] ) ) & magic [ 5 ] ; return b ; }
public static final string string encode ( long geo hash long ) { int level = ( int ) geo hash long & 15 ; geo hash long > > > = 4 ; char [ ] char = new char [ level ] ; do { char [ -- level ] = base_32 [ ( int ) ( geo hash long & 31l ) ] ; geo hash long > > > =5 ; } while ( level > 0 ) ; return new string ( char ) ; }
public static field [ ] create indexable field ( string field name , double lat , double lon ) { return new field [ ] { new triangle ( field name , encode longitude ( lon ) , encode latitude ( lat ) , encode longitude ( lon ) , encode latitude ( lat ) , encode longitude ( lon ) , encode latitude ( lat ) ) } ; }
public static double lon width in degree ( int precision ) { return precision to lon width [ precision ] ; }
public http forward with host ( string host ) { this . host = host ; return this ; }
public void perform request async ( string method , string endpoint , response listener response listener , header . . . header ) { perform request async ( method , endpoint , collection . < string , string > empty map ( ) , null , response listener , header ) ; }
public request client option get request client option ( ) { return request client option ; }
public int min word length ( ) { return min word length ; }
public search request builder set allow partial search result ( boolean allow partial search result ) { request . allow partial search result ( allow partial search result ) ; return this ; }
public integer get batch reduce size ( ) { return this . batch reduce size ; }
public search request request cache ( boolean request cache ) { this . request cache = request cache ; return this ; }
public async search response submit ( submit async search request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , async search request converter : : submit async search , option , async search response : : from x content , empty set ( ) ) ; }
public cancellable delete async ( delete async search request request , request option option , action listener < acknowledge response > listener ) { return rest high level client . perform request async and parse entity ( request , async search request converter : : delete async search , option , acknowledge response : : from x content , listener , empty set ( ) ) ; }
public acknowledge response pause auto follow pattern ( pause auto follow pattern request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , ccr request converter : : pause auto follow pattern , option , acknowledge response : : from x content , collection . empty set ( ) ) ; }
public cancellable put component template async ( put component template request put component template request , request option option , action listener < acknowledge response > listener ) { return rest high level client . perform request async and parse entity ( put component template request , cluster request converter : : put component template , option , acknowledge response : : from x content , listener , empty set ( ) ) ; }
public cancellable put component template async ( put component template request put component template request , request option option , action listener < acknowledge response > listener ) { return rest high level client . perform request async and parse entity ( put component template request , cluster request converter : : put component template , option , acknowledge response : : from x content , listener , empty set ( ) ) ; }
public cancellable get component template async ( get component template request get component template request , request option option , action listener < get component template response > listener ) { return rest high level client . perform request async and parse entity ( get component template request , cluster request converter : : get component template , option , get component template response : : from x content , listener , empty set ( ) ) ; }
public shard rout active primary ( shard id shard id ) { for ( shard rout shard routing : assign shard ( shard id ) ) { if ( shard routing . primary ( ) & & shard routing . active ( ) ) { return shard rout ; } } return null ; }
public long get count ( ) { return count . sum ( ) ; }
public long get ingest take in millis ( ) { return ingest take in millis ; }
public graph explore request type ( string . . . type ) { this . type = type ; return this ; }
public cancellable start s l m async ( start s l m request request , request option option , action listener < acknowledge response > listener ) { return rest high level client . perform request async and parse entity ( request , index lifecycle request converter : : start s l m , option , acknowledge response : : from x content , listener , empty set ( ) ) ; }
public explain lifecycle response explain lifecycle ( explain lifecycle request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , index lifecycle request converter : : explain lifecycle , option , explain lifecycle response : : from x content , empty set ( ) ) ; }
public cancellable delete snapshot lifecycle policy async ( delete snapshot lifecycle policy request request , request option option , action listener < acknowledge response > listener ) { return rest high level client . perform request async and parse entity ( request , index lifecycle request converter : : delete snapshot lifecycle policy , option , acknowledge response : : from x content , listener , empty set ( ) ) ; }
public cancellable lifecycle management status async ( lifecycle management status request request , request option option , action listener < lifecycle management status response > listener ) { return rest high level client . perform request async and parse entity ( request , index lifecycle request converter : : lifecycle management status , option , lifecycle management status response : : from x content , listener , empty set ( ) ) ; }
public analyze request builder set normalizer ( string normalizer ) { request . normalizer ( normalizer ) ; return this ; }
public open index request wait for active shard ( active shard count wait for active shard ) { this . wait for active shard = wait for active shard ; return this ; }
public put index template request cause ( string cause ) { this . cause = cause ; return this ; }
public static index index ( name name ) { return new index impl ( name ) ; }
public put composable index template request index template v2 request ( ) { return index template v2 request ; }
public string [ ] index ( ) { return index ; }
public cancellable delete data stream async ( delete data stream request delete data stream request , request option option , action listener < acknowledge response > listener ) { return rest high level client . perform request async and parse entity ( delete data stream request , indices request converter : : delete data stream , option , acknowledge response : : from x content , listener , empty set ( ) ) ; }
public boolean exists template ( index template exist request index templates request , request option option ) throw i o exception { return rest high level client . perform request ( index templates request , indices request converter : : template exist , option , rest high level client : : convert exist response , empty set ( ) ) ; }
public cancellable rollover async ( rollover request rollover request , request option option , action listener < rollover response > listener ) { return rest high level client . perform request async and parse entity ( rollover request , indices request converter : : rollover , option , rollover response : : from x content , listener , empty set ( ) ) ; }
public cancellable put setting async ( cluster update setting request cluster update setting request , request option option , action listener < cluster update setting response > listener ) { return rest high level client . perform request async and parse entity ( cluster update setting request , cluster request converter : : cluster put setting , option , cluster update setting response : : from x content , listener , empty set ( ) ) ; }
public cancellable analyze async ( analyze request request , request option option , action listener < analyze response > listener ) { return rest high level client . perform request async and parse entity ( request , indices request converter : : analyze , option , analyze response : : from x content , listener , empty set ( ) ) ; }
public cancellable put job async ( put job request request , request option option , action listener < put job response > listener ) { return rest high level client . perform request async and parse entity ( request , m l request converter : : put job , option , put job response : : from x content , listener , collection . empty set ( ) ) ; }
public reset job response reset job ( reset job request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : reset job , option , reset job response : : from x content , collection . empty set ( ) ) ; }
public cancellable start datafeed async ( start datafeed request request , request option option , action listener < start datafeed response > listener ) { return rest high level client . perform request async and parse entity ( request , m l request converter : : start datafeed , option , start datafeed response : : from x content , listener , collection . empty set ( ) ) ; }
public cancellable post data async ( post data request request , request option option , action listener < post data response > listener ) { return rest high level client . perform request async and parse entity ( request , m l request converter : : post data , option , post data response : : from x content , listener , collection . empty set ( ) ) ; }
public acknowledge response delete calendar event ( delete calendar event request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : delete calendar event , option , acknowledge response : : from x content , collection . empty set ( ) ) ; }
public cancellable update filter async ( update filter request request , request option option , action listener < put filter response > listener ) { return rest high level client . perform request async and parse entity ( request , m l request converter : : update filter , option , put filter response : : from x content , listener , collection . empty set ( ) ) ; }
public cancellable delete filter async ( delete filter request request , request option option , action listener < acknowledge response > listener ) { return rest high level client . perform request async and parse entity ( request , m l request converter : : delete filter , option , acknowledge response : : from x content , listener , collection . empty set ( ) ) ; }
public put data frame analytics response put data frame analytics ( put data frame analytics request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : put data frame analytics , option , put data frame analytics response : : from x content , collection . empty set ( ) ) ; }
public cancellable stop data frame analytics async ( stop data frame analytics request request , request option option , action listener < stop data frame analytics response > listener ) { return rest high level client . perform request async and parse entity ( request , m l request converter : : stop data frame analytics , option , stop data frame analytics response : : from x content , listener , collection . empty set ( ) ) ; }
public cancellable start data frame analytics async ( start data frame analytics request request , request option option , action listener < start data frame analytics response > listener ) { return rest high level client . perform request async and parse entity ( request , m l request converter : : start data frame analytics , option , start data frame analytics response : : from x content , listener , collection . empty set ( ) ) ; }
public get data frame analytics response get data frame analytics ( get data frame analytics request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : get data frame analytics , option , get data frame analytics response : : from x content , collection . empty set ( ) ) ; }
public cancellable stop data frame analytics async ( stop data frame analytics request request , request option option , action listener < stop data frame analytics response > listener ) { return rest high level client . perform request async and parse entity ( request , m l request converter : : stop data frame analytics , option , stop data frame analytics response : : from x content , listener , collection . empty set ( ) ) ; }
public static delay data check config enable delay data check config ( time value time value ) { return new delay data check config ( true , time value ) ; }
public void set force ( boolean force ) { this . force = force ; }
public boolean be auto flush ( ) { return auto flush ; }
public final boolean be acknowledge ( ) { return acknowledge ; }
public boolean equal ( object other ) { if ( this == other ) { return true ; } if ( other == null || get class ( ) ! = other . get class ( ) ) { return false ; } bucket that = ( bucket ) other ; return object . equal ( this . job id , that . job id ) & & object . equal ( this . timestamp , that . timestamp ) & & ( this . event count == that . event count ) & & ( this . bucket span == that . bucket span ) & & ( this . anomaly score == that . anomaly score ) & & ( this . initial anomaly score == that . initial anomaly score ) & & object . equal ( this . record , that . record ) & & object . equal ( this . be interim , that . be interim ) & & object . equal ( this . bucket influencers , that . bucket influencers ) & & ( this . processing time m == that . processing time m ) & & object . equal ( this . scheduled event , that . schedule event ) ; }
public boolean contain one category ( list < group category > category ) { for ( group category category : category ) { if ( contains ( category ) ) return true ; } return false ; }
public void set from ( date from ) { this . from = from ; }
public get data frame analytics request set allow no match ( boolean allow no match ) { this . allow no match = allow no match ; return this ; }
public transport client add transport address ( transport address transport address ) { nodes service . add transport address ( transport address ) ; return this ; }
public void require job ( ) { if ( $ ( job_id ) . be empty ( ) ) { bad request ( `` miss job id `` ) ; throw new runtime exception ( `` bad request : miss job id `` ) ; } job id job i d = m r apps . to job i d ( $ ( job_id ) ) ; app . set job ( app . context . get job ( job i d ) ) ; if ( app . get job ( ) == null ) { not find ( $ ( job_id ) ) ; throw new runtime exception ( `` not find : `` + $ ( job_id ) ) ; } / * check for acl access * / job job = app . context . get job ( job i d ) ; if ( ! check access ( job ) ) { access deny ( `` user `` + request ( ) . get remote user ( ) + `` do not have `` + `` permission to view job `` + $ ( job_id ) ) ; throw new runtime exception ( `` access deny : user `` + request ( ) . get remote user ( ) + `` do not have permission to view job `` + $ ( job_id ) ) ; } }
public void require job ( ) { if ( $ ( job_id ) . be empty ( ) ) { bad request ( `` miss job id `` ) ; throw new runtime exception ( `` bad request : miss job id `` ) ; } job id job i d = m r apps . to job i d ( $ ( job_id ) ) ; app . set job ( app . context . get job ( job i d ) ) ; if ( app . get job ( ) == null ) { not find ( $ ( job_id ) ) ; throw new runtime exception ( `` not find : `` + $ ( job_id ) ) ; } / * check for acl access * / job job = app . context . get job ( job i d ) ; if ( ! check access ( job ) ) { access deny ( `` user `` + request ( ) . get remote user ( ) + `` do not have `` + `` permission to view job `` + $ ( job_id ) ) ; throw new runtime exception ( `` access deny : user `` + request ( ) . get remote user ( ) + `` do not have permission to view job `` + $ ( job_id ) ) ; } }
public static get datafeed stats request get all datafeed stats request ( ) { return new get datafeed stats request ( all_datafeeds ) ; }
public boolean be stop ( ) { return run state . be stop ( ) ; }
public void set remove item ( collection < string > remove item ) { this . remove item = new tree set < > ( object . require non null ( remove item , `` [ `` + remove_items . get preferred name ( ) + `` ] must not be null `` ) ) ; }
public ccr stats response get ccr stats ( ccr stats request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , ccr request converter : : get ccr stats , option , ccr stats response : : from x content , collection . empty set ( ) ) ; }
public license get license ( ) { return license ; }
public final bulk by scroll response update by query ( update by query request update by query request , request option option ) throw i o exception { return perform request and parse entity ( update by query request , request converter : : update by query , option , bulk by scroll response : : from x content , singleton ( 409 ) ) ; }
public final delete response delete ( delete request delete request , request option option ) throw i o exception { return perform request and parse entity ( delete request , request converter : : delete , option , delete response : : from x content , singleton ( 404 ) ) ; }
public cancellable open async ( open index request open index request , request option option , action listener < open index response > listener ) { return rest high level client . perform request async and parse entity ( open index request , indices request converter : : open index , option , open index response : : from x content , listener , empty set ( ) ) ; }
public cancellable delete watch async ( delete watch request request , request option option , action listener < delete watch response > listener ) { return rest high level client . perform request async and parse entity ( request , watcher request converter : : delete watch , option , delete watch response : : from x content , listener , singleton ( 404 ) ) ; }
public final cancellable mtermvectors async ( multi term vector request request , request option option , action listener < multi term vector response > listener ) { return perform request async and parse entity ( request , request converter : : mterm vector , option , multi term vector response : : from x content , listener , empty set ( ) ) ; }
public static privilege privilege ( string privilege ) { return privilege ( keyword ( privilege ) ) ; }
public static invalidate api key request use realm name ( string realm name ) { return new invalidate api key request ( realm name , null , null , false , null ) ; }
public static invalidate api key request use realm and user name ( string realm name , string user name ) { return new invalidate api key request ( realm name , user name , null , false , null ) ; }
public list < discovery node > list node ( ) { return node service . list node ( ) ; }
public static privilege privilege ( string privilege ) { return privilege ( keyword ( privilege ) ) ; }
public cancellable delete user async ( delete user request request , request option option , action listener < delete user response > listener ) { return rest high level client . perform request async and parse entity ( request , security request converter : : delete user , option , delete user response : : from x content , listener , singleton ( 404 ) ) ; }
public cancellable disable user async ( disable user request request , request option option , action listener < boolean > listener ) { return rest high level client . perform request async ( request , security request converter : : disable user , option , rest high level client : : convert exist response , listener , empty set ( ) ) ; }
public cancellable authenticate async ( request option option , action listener < authenticate response > listener ) { return rest high level client . perform request async and parse entity ( authenticate request . instance , authenticate request : : get request , option , authenticate response : : from x content , listener , empty set ( ) ) ; }
public cancellable clear privilege cache async ( clear privilege cache request request , request option option , action listener < clear privilege cache response > listener ) { return rest high level client . perform request async and parse entity ( request , security request converter : : clear privilege cache , option , clear privilege cache response : : from x content , listener , empty set ( ) ) ; }
public get ssl certificate response get ssl certificate ( request option option ) throw i o exception { return rest high level client . perform request and parse entity ( get ssl certificate request . instance , get ssl certificate request : : get request , option , get ssl certificate response : : from x content , empty set ( ) ) ; }
public cancellable invalidate token async ( invalidate token request request , request option option , action listener < invalidate token response > listener ) { return rest high level client . perform request async and parse entity ( request , security request converter : : invalidate token , option , invalidate token response : : from x content , listener , singleton ( 404 ) ) ; }
public cancellable create api key async ( final create api key request request , final request option option , final action listener < create api key response > listener ) { return rest high level client . perform request async and parse entity ( request , security request converter : : create api key , option , create api key response : : from x content , listener , empty set ( ) ) ; }
public cancellable create repository async ( put repository request put repository request , request option option , action listener < acknowledge response > listener ) { return rest high level client . perform request async and parse entity ( put repository request , snapshot request converter : : create repository , option , acknowledge response : : from x content , listener , empty set ( ) ) ; }
public acknowledge response delete repository ( delete repository request delete repository request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( delete repository request , snapshot request converter : : delete repository , option , acknowledge response : : from x content , empty set ( ) ) ; }
public cancellable status async ( snapshots status request snapshot status request , request option option , action listener < snapshot status response > listener ) { return rest high level client . perform request async and parse entity ( snapshots status request , snapshot request converter : : snapshot status , option , snapshot status response : : from x content , listener , empty set ( ) ) ; }
public cancellable restore async ( restore snapshot request restore snapshot request , request option option , action listener < restore snapshot response > listener ) { return rest high level client . perform request async and parse entity ( restore snapshot request , snapshot request converter : : restore snapshot , option , restore snapshot response : : from x content , listener , empty set ( ) ) ; }
public find structure response find structure ( find structure request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , text structure request converter : : find file structure , option , find structure response : : from x content , collection . empty set ( ) ) ; }
public update transform response update transform ( update transform request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , transform request converter : : update transform , option , update transform response : : from x content , collection . empty set ( ) ) ; }
public void set active ( boolean active ) { this . active = active ; if ( drop target ! = null ) { drop target . set active ( active ) ; } }
public deactivate watch response deactivate watch ( deactivate watch request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , watcher request converter : : deactivate watch , option , deactivate watch response : : from x content , empty set ( ) ) ; }
public cancellable delete watch async ( delete watch request request , request option option , action listener < delete watch response > listener ) { return rest high level client . perform request async and parse entity ( request , watcher request converter : : delete watch , option , delete watch response : : from x content , listener , singleton ( 404 ) ) ; }
public ack watch response ack watch ( ack watch request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , watcher request converter : : ack watch , option , ack watch response : : from x content , empty set ( ) ) ; }
public cancellable usage async ( x pack usage request request , request option option , action listener < x pack usage response > listener ) { return rest high level client . perform request async and parse entity ( request , x pack request converter : : usage , option , x pack usage response : : from x content , listener , empty set ( ) ) ; }
public static string human size of ( object object ) { return human readable unit ( size of ( object ) ) ; }
public void write byte ( byte [ ] data , int offset , int length ) throw i o exception { prepare value ( ) ; update length ( length ) ; buffer . write byte ( data , offset , length ) ; finish value ( ) ; }
public symbol factory get symbol factory ( ) { return symbol factory ; }
public boolean contains double ( number value ) { if ( value == null ) { return false ; } return contains double ( value . double value ( ) ) ; }
public list < parse error > get error ( ) { return error ; }
public final expect builder with echo input ( appendable first input , appendable . . . other input ) { this . echo input = first input ; this . echo input = other input ; return this ; }
public final ion text writer builder with charset ( charset charset ) { ion text writer builder b = mutable ( ) ; b . set charset ( charset ) ; return b ; }
public void set buffer size ( int buffer size ) { if ( buffer size < = 0 ) { throw new illegal argument exception ( `` invalid buffer size : `` + buffer size ) ; } this . buffer size = buffer size ; }
public static matcher < result > any string ( ) { return new matcher < result > ( ) { @ override public result match ( string input , boolean be eof ) { return input . length ( ) > 0 ? success ( input , `` `` , input ) : failure ( input , false ) ; } @ override public string to string ( ) { return `` any string `` ; } } ; }
public long get duration ( time unit time unit ) { return time unit . convert ( nanos , time unit . nanosecond ) ; }
public void on complete ( r result , throwable failure ) { }
public static boolean cancel ( atomic reference < subscription > field ) { subscription current = field . get ( ) ; if ( current ! = cancel ) { current = field . get and set ( cancel ) ; if ( current ! = cancel ) { if ( current ! = null ) { current . cancel ( ) ; } return true ; } } return false ; }
public double ratio ( long numerator , long denominator ) { return denominator == 0 ? 0f : ( ( double ) numerator ) / ( ( double ) denominator ) ; }
public double get scale factor ( ) { return scale factor ; }
public cache control stale if error ( long stale if error , time unit unit ) { return stale if error ( duration . of second ( unit . to second ( stale if error ) ) ) ; }
public int get offset ( ) { return offset ; }
public type declaration get type declaration ( ) { return internal get type declaration ( ) ; }
public string name a string ( ) { if ( `` `` . equal ( _qname . get namespace u r i ( ) ) ) return _qname . get local part ( ) ; if ( _qname . get prefix ( ) ! = null ) return `` [ ' `` + _qname . get namespace u r i ( ) + `` ' ] : `` + _qname . get prefix ( ) + `` : `` + _qname . get local part ( ) ; else return `` [ ' `` + _qname . get namespace u r i ( ) + `` ' ] : `` + _qname . get local part ( ) ; }
public void set system id ( string url ) { system id = url ; builder . set system id ( url ) ; super . set document locator ( new locator ( ) { public int get column number ( ) { return -1 ; } public int get line number ( ) { return -1 ; } public string get public id ( ) { return null ; } public string get system id ( ) { return system id ; } } ) ; }
public string to string ( ) { int mag = magnitude ( hi ) ; if ( mag > = -3 & & mag < = 20 ) return to standard notation ( ) ; return to sci notation ( ) ; }
public final string [ ] get array ( ) { if ( _array == null ) return null ; final string [ ] clone array = new string [ _array . length ] ; system . arraycopy ( _array , 0 , clone array , 0 , _array . length ) ; return clone array ; }
public void add attribute with algorithm data ( string uri , string local name , string q name , string algorithm u r i , int algorithm i d , object algorithm data ) { if ( _length > = _algorithm data . length ) { resize ( ) ; } int i = _length * size ; _data [ i++ ] = replace null ( uri ) ; _data [ i++ ] = replace null ( local name ) ; _data [ i++ ] = replace null ( q name ) ; _data [ i++ ] = `` cdata `` ; _data [ i++ ] = `` `` ; _data [ i++ ] = algorithm u r i ; _algorithm id [ _length ] = algorithm i d ; _algorithm data [ _length ] = algorithm data ; _to index [ _length ] = false ; _alphabets [ _length ] = null ; _length++ ; }
public static void swap ( final boolean [ ] x , int a , int b , final int n ) { for ( int i = 0 ; i < n ; i++ , a++ , b++ ) swap ( x , a , b ) ; }
public static void ensure offset length ( final int array length , final int offset , final int length ) { if ( offset < 0 ) throw new array index out of bound exception ( `` offset ( `` + offset + `` ) be negative `` ) ; if ( length < 0 ) throw new illegal argument exception ( `` length ( `` + length + `` ) be negative `` ) ; if ( offset + length > array length ) throw new array index out of bound exception ( `` last index ( `` + ( offset + length ) + `` ) be great than array length ( `` + array length + `` ) `` ) ; }
public static void ensure offset length ( final boolean [ ] [ ] a , final long offset , final long length ) { big array . ensure offset length ( length ( a ) , offset , length ) ; }
public int compare to ( final list < ? extend boolean > l ) { if ( l == this ) return 0 ; if ( l instanceof boolean list ) { final boolean list iterator i1 = list iterator ( ) , i2 = ( ( boolean list ) l ) . list iterator ( ) ; int r ; boolean e1 , e2 ; while ( i1 . have next ( ) & & i2 . have next ( ) ) { e1 = i1 . next boolean ( ) ; e2 = i2 . next boolean ( ) ; if ( ( r = ( boolean . compare ( ( e1 ) , ( e2 ) ) ) ) ! = 0 ) return r ; } return i2 . have next ( ) ? -1 : ( i1 . have next ( ) ? 1 : 0 ) ; } list iterator < ? extend boolean > i1 = list iterator ( ) , i2 = l . list iterator ( ) ; int r ; while ( i1 . have next ( ) & & i2 . have next ( ) ) { if ( ( r = ( ( comparable < ? super boolean > ) i1 . next ( ) ) . compare to ( i2 . next ( ) ) ) ! = 0 ) return r ; } return i2 . have next ( ) ? -1 : ( i1 . have next ( ) ? 1 : 0 ) ; }
public static boolean [ ] grow ( final boolean [ ] array , final int length , final int preserve ) { if ( length > array . length ) { final int new length = ( int ) math . max ( math . min ( 2l * array . length , array . max_array_size ) , length ) ; final boolean t [ ] = new boolean [ new length ] ; system . arraycopy ( array , 0 , t , 0 , preserve ) ; return t ; } return array ; }
public static void fill ( final boolean [ ] [ ] array , final long from , long to , final boolean value ) { final long length = length ( array ) ; big array . ensure from to ( length , from , to ) ; int from segment = segment ( from ) ; int to segment = segment ( to ) ; int from displ = displacement ( from ) ; int to displ = displacement ( to ) ; if ( from segment == to segment ) { array . fill ( array [ from segment ] , from displ , to displ , value ) ; return ; } if ( to displ ! = 0 ) array . fill ( array [ to segment ] , 0 , to displ , value ) ; while ( -- to segment > from segment ) array . fill ( array [ to segment ] , value ) ; array . fill ( array [ from segment ] , from displ , segment_size , value ) ; }
public static void parallel quick sort ( final boolean [ ] x , final boolean comparator comp ) { parallel quick sort ( x , 0 , x . length , comp ) ; }
public static void quick sort ( final boolean [ ] [ ] x ) { quick sort ( x , 0 , boolean big array . length ( x ) ) ; }
public static boolean [ ] to primitive ( final boolean [ ] array ) { if ( array == null ) { return null ; } else if ( array . length == 0 ) { return empty_boolean_array ; } final boolean [ ] result = new boolean [ array . length ] ; for ( int i = 0 ; i < array . length ; i++ ) { result [ i ] = array [ i ] . boolean value ( ) ; } return result ; }
public static void fill ( final boolean [ ] [ ] array , final long from , long to , final boolean value ) { final long length = length ( array ) ; big array . ensure from to ( length , from , to ) ; int from segment = segment ( from ) ; int to segment = segment ( to ) ; int from displ = displacement ( from ) ; int to displ = displacement ( to ) ; if ( from segment == to segment ) { array . fill ( array [ from segment ] , from displ , to displ , value ) ; return ; } if ( to displ ! = 0 ) array . fill ( array [ to segment ] , 0 , to displ , value ) ; while ( -- to segment > from segment ) array . fill ( array [ to segment ] , value ) ; array . fill ( array [ from segment ] , from displ , segment_size , value ) ; }
public static boolean big list iterator a big list iterator ( final boolean list iterator i ) { return new big list iterator list iterator ( i ) ; }
public static boolean big list iterator singleton ( final boolean element ) { return new singleton big list iterator ( element ) ; }
public string get rich text ( ) { c o s base rv = field . get dictionary object ( c o s name . rv ) ; if ( rv == null ) { return null ; } else if ( rv instanceof c o s string ) { return ( ( c o s string ) rv ) . get string ( ) ; } else { return ( ( c o s stream ) rv ) . to text string ( ) ; } }
public static double iterator wrap ( final it . unimi . dsi . fastutil . byte . byte iterator iterator ) { return new byte iterator wrapper ( iterator ) ; }
public static < k > byte get byte ( final map < ? super k , ? > map , final k key ) { final number answer = get number ( map , key ) ; if ( answer == null ) { return null ; } if ( answer instanceof byte ) { return ( byte ) answer ; } return byte . value of ( answer . byte value ( ) ) ; }
public int get ( final int index , final byte [ ] a , final int offset , final int length ) { ensure restrict index ( index ) ; byte array . ensure offset length ( a , offset , length ) ; final int array length = extract ( index , a , offset , length ) ; if ( length > = array length ) return array length ; return length - array length ; }
protect void ensure index ( final int index ) { if ( index < 0 ) throw new index out of bound exception ( `` index ( `` + index + `` ) be negative `` ) ; if ( index > size ( ) ) throw new index out of bound exception ( `` index ( `` + index + `` ) be great than list size ( `` + ( size ( ) ) + `` ) `` ) ; }
public static long binary search ( final byte [ ] [ ] a , final byte key , final byte comparator c ) { return binary search ( a , 0 , byte big array . length ( a ) , key , c ) ; }
public static void parallel radix sort indirect ( final int perm [ ] , final byte [ ] a , final boolean stable ) { parallel radix sort indirect ( perm , a , 0 , a . length , stable ) ; }
public static void radix sort ( final byte [ ] a ) { radix sort ( a , 0 , a . length ) ; }
public static void radix sort ( final byte [ ] [ ] a , final byte [ ] [ ] b ) { radix sort ( a , b , 0 , byte big array . length ( a ) ) ; }
public static int flip put flip ( byte buffer from , byte buffer to ) { return append ( to , from ) ; }
public static byte priority queue synchronize ( final byte priority queue q ) { return new synchronize priority queue ( q ) ; }
public final static long murmur hash3 ( long x ) { x ^= x > > > 33 ; x * = 0xff51afd7ed558ccd l ; x ^= x > > > 33 ; x * = 0xc4ceb9fe1a85ec53 l ; x ^= x > > > 33 ; return x ; }
public static < k > indirect double priority queue < k > synchronize ( final indirect double priority queue < k > q ) { return new synchronize indirect double priority queue < k > ( q ) ; }
public static int load booleans ( final data input data input , final boolean [ ] array , final int offset , final int length ) throw i o exception { it . unimi . dsi . fastutil . booleans . boolean array . ensure offset length ( array , offset , length ) ; int i = 0 ; try { for ( i = 0 ; i < length ; i++ ) array [ i + offset ] = data input . read boolean ( ) ; } catch ( e o f exception it ok ) { } return i ; }
public static long load booleans ( final char sequence filename , final boolean [ ] [ ] array ) throw i o exception { return load booleans ( new file ( filename . to string ( ) ) , array ) ; }
public static void store booleans ( final boolean array [ ] , final data output data output ) throw i o exception { final int length = array . length ; for ( int i = 0 ; i < length ; i++ ) data output . write boolean ( array [ i ] ) ; }
public static long load byte ( final input stream input stream , final byte [ ] [ ] array , final long offset , final long length ) throw i o exception { return read ( input stream , array , offset , length ) ; }
public static < k > object list < k > empty list ( ) { return empty_list ; }
public static < k > object list < k > empty list ( ) { return empty_list ; }
public string to unicode ( int code ) { return char to unicode . get ( code ) ; }
protect synchronized void start scheduler ( long initial delay , long period ) { if ( ! scheduler run ) { scheduler run = true ; scheduler = executor . new single thread schedule executor ( ) ; scheduler . schedule at fix rate ( new runnable ( ) { @ override public void run ( ) { roll secret ( ) ; } } , initial delay , period , time unit . millisecond ) ; } }
public static void main ( string [ ] args ) throw exception { g monitor a = null ; try { a = new g monitor ( ) ; a . set gmetric ( new g metric ( `` 239 . 2 . 11 . 71 `` , 8649 , u d p address mode . multicast , 1 ) ) ; a . add sampler ( new core sampler ( ) ) ; a . start ( ) ; } catch ( exception ex ) { log . severe ( `` exception start g monitor `` ) ; ex . print stack trace ( ) ; } while ( true ) { thread . sleep ( 1000 * 60 * 5 ) ; system . out . println ( `` test wakeup `` ) ; } }
public final set < var > var ( ) { if ( var == null ) { immutable set . builder < var > builder = immutable set . < var > builder ( ) . add ( start ( ) ) ; var end = end ( ) ; if ( end ! = null ) builder . add ( end ) ; builder . add all ( other var ( ) ) ; var = builder . build ( ) ; } return var ; }
public static service locator bind ( binder . . . binder ) { return bind ( default_locator_name , binder ) ; }
public static injector create injector ( module . . . module ) { return create injector ( arrays . a list ( module ) ) ; }
public static injector create injector ( module . . . module ) { return create injector ( arrays . a list ( module ) ) ; }
public static < t > real optional binder < t > new real optional binder ( binder binder , key < t > type ) { binder = binder . skip source ( real optional binder . class ) ; real optional binder < t > optional binder = new real optional binder < > ( binder , type ) ; binder . install ( optional binder ) ; return optional binder ; }
public string [ ] find lifecycle listener name ( ) throw m bean exception { container container = do get manage resource ( ) ; list < string > result = new array list < > ( ) ; lifecycle listener [ ] listener = container . find lifecycle listener ( ) ; for ( lifecycle listener listener : listener ) { result . add ( listener . get class ( ) . get name ( ) ) ; } return result . to array ( new string [ 0 ] ) ; }
public < t > injector builder for each element ( element visitor < t > visitor ) { element . get element ( module ) . for each ( element - > element . accept visitor ( visitor ) ) ; return this ; }
public injector builder warn of static injection ( ) { return for each element ( new warn of static injection visitor ( ) , message - > log . debug ( message ) ) ; }
public < t > t get ( contextual < t > contextual , creational context < t > creational context ) { if ( ! be active ( ) ) { throw new context not active exception ( ) ; } if ( creational context ! = null ) { t instance = contextual . create ( creational context ) ; if ( creational context instanceof weld creational context < ? > ) { add dependent instance ( instance , contextual , ( weld creational context < t > ) creational context ) ; } return instance ; } else { return null ; } }
public static grakn tx operation exception add instance to abstract type ( type type ) { return create ( error message . is_abstract . get message ( type . label ( ) ) ) ; }
public static grakn tx operation exception transaction open ( grakn tx tx ) { return create ( error message . transaction_already_open . get message ( tx . keyspace ( ) ) ) ; }
public static grakn tx operation exception transaction open ( grakn tx tx ) { return create ( error message . transaction_already_open . get message ( tx . keyspace ( ) ) ) ; }
public static grakn tx operation exception transaction open ( grakn tx tx ) { return create ( error message . transaction_already_open . get message ( tx . keyspace ( ) ) ) ; }
public static aggregate < value > mean ( string var ) { return aggregate . mean ( graql . var ( var ) ) ; }
public static aggregate < value > mean ( string var ) { return aggregate . mean ( graql . var ( var ) ) ; }
public double get complexity ( ) { double total cost = 0 ; for ( list < fragment > list : fragment ( ) ) { total cost += fragment list cost ( list ) ; } return total cost ; }
public static reasoner query impl create ( list < atom > a , embed grakn tx < ? > tx ) { boolean be atomic = a . size ( ) == 1 ; return be atomic ? new reasoner atomic query ( iterables . get only element ( a ) ) . infer type ( ) : new reasoner query impl ( a , tx ) . infer type ( ) ; }
public static reasoner atomic query atomic ( reasoner atomic query q , concept map sub ) { return q . with substitution ( sub ) . infer type ( ) ; }
public void update topic ( string topic , db context rule rule ) { topic = string utils . to lower english ( topic ) ; rule head head = rule map . get ( topic ) ; if ( head == null ) { head = new rule head ( `` db `` , topic , rule ) ; rule map . put ( topic , head ) ; statement . add ( head ) ; } else { head . set rule ( rule ) ; } }
public set key set by value ( ) { if ( set of key [ value ] == null ) { set of key [ value ] = new abstract set ( ) { public iterator iterator ( ) { return new double order map iterator ( value ) { protected object do get next ( ) { return last return node . get data ( key ) ; } } ; } public int size ( ) { return double order map . this . size ( ) ; } public boolean contains ( object o ) { return contain key ( o ) ; } public boolean remove ( object o ) { int oldnode count = node count ; double order map . this . remove ( o ) ; return node count ! = oldnode count ; } public void clear ( ) { double order map . this . clear ( ) ; } } ; } return set of key [ value ] ; }
public void clear ( ) { wrap rule . clear ( ) ; all rule . clear ( ) ; default rule . clear ( ) ; }
public static void set super ( schema concept sub concept , schema concept super concept ) { if ( super concept . be entity type ( ) ) { sub concept . a entity type ( ) . sup ( super concept . a entity type ( ) ) ; } else if ( super concept . be relationship type ( ) ) { sub concept . a relationship type ( ) . sup ( super concept . a relationship type ( ) ) ; } else if ( super concept . be role ( ) ) { sub concept . a role ( ) . sup ( super concept . a role ( ) ) ; } else if ( super concept . be attribute type ( ) ) { sub concept . a attribute type ( ) . sup ( super concept . a attribute type ( ) ) ; } else if ( super concept . be rule ( ) ) { sub concept . a rule ( ) . sup ( super concept . a rule ( ) ) ; } else { throw graql query exception . insert meta type ( sub concept . label ( ) , super concept ) ; } }
public static matcher < matchable concept > have value ( object expect value ) { return new property equal matcher < matchable concept , object > ( expect value ) { @ override public string get name ( ) { return `` have value `` ; } @ override public object transform ( matchable concept item ) { return item . get ( ) . a attribute ( ) . value ( ) ; } } ; }
public static document builder get document builder ( ) throw build exception { try { return get document builder factory ( ) . new document builder ( ) ; } catch ( parser configuration exception e ) { throw new build exception ( e ) ; } }
public void put ( string key , object value ) { require non null ( key , `` authentication key can not be null `` ) ; if ( key . length ( ) == 0 ) { throw new illegal argument exception ( `` authentication key can not be empty `` ) ; } synchronize ( auth data ) { object old value = auth data . put ( key , value ) ; if ( old value instanceof char [ ] ) { array . fill ( ( char [ ] ) old value , '\0 ' ) ; } } }
public static void start memory logger ( ) { start memory logger ( 1000 ) ; }
public default graph traversal < s , list < e > > fold ( ) { this . a admin ( ) . get bytecode ( ) . add step ( symbol . fold ) ; return this . a admin ( ) . add step ( new fold step < > ( this . a admin ( ) ) ) ; }
public static < v > p < v > gt ( final v value ) { return new p ( compare . gt , value ) ; }
public default < a > a get ( final int index ) { return ( a ) this . object ( ) . get ( index ) ; }
public default < a > a get ( final string label ) throw illegal argument exception { final list < object > object = this . object ( ) ; final list < set < string > > label = this . label ( ) ; object object = null ; for ( int i = 0 ; i < label . size ( ) ; i++ ) { if ( label . get ( i ) . contains ( label ) ) { if ( null == object ) { object = object . get ( i ) ; } else if ( object instanceof list ) { ( ( list ) object ) . add ( object . get ( i ) ) ; } else { final list list = new array list ( 2 ) ; list . add ( object ) ; list . add ( object . get ( i ) ) ; object = list ; } } } if ( null == object ) throw path . exception . step with provided label do not exist ( label ) ; return ( a ) object ; }
public boolean supersedes ( cluster state other ) { return this . node ( ) . get master node id ( ) ! = null & & this . node ( ) . get master node id ( ) . equal ( other . node ( ) . get master node id ( ) ) & & this . version ( ) > other . version ( ) ; }
public static < t > set < t > copy of ( collection < ? extend t > collection ) { precondition . check not null ( collection ) ; if ( collection instanceof abstract immutable set < ? > ) { return ( set < t > ) collection ; } if ( collection . be empty ( ) ) { return collection . empty set ( ) ; } if ( collection instanceof set ) { return from ( ( set < t > ) collection ) ; } return immutable set . < t > builder ( ) . add all ( collection ) . build ( ) ; }
public static < t > set < t > copy of ( collection < ? extend t > collection ) { precondition . check not null ( collection ) ; if ( collection instanceof abstract immutable set < ? > ) { return ( set < t > ) collection ; } if ( collection . be empty ( ) ) { return collection . empty set ( ) ; } if ( collection instanceof set ) { return from ( ( set < t > ) collection ) ; } return immutable set . < t > builder ( ) . add all ( collection ) . build ( ) ; }
public default graph traversal < s , e > dedup ( final string . . . dedup label ) { this . a admin ( ) . get bytecode ( ) . add step ( symbol . dedup , dedup label ) ; return this . a admin ( ) . add step ( new dedup global step < > ( this . a admin ( ) , dedup label ) ) ; }
public duration minus ( long amount , time unit time unit ) { if ( time unit == null ) { throw new illegal argument exception ( `` time unit can not be null `` ) ; } return new minus ( ) . apply ( this , new duration ( amount , time unit ) ) ; }
public default vertex in vertex ( ) { return this . vertex ( direction . in ) . next ( ) ; }
public static io . builder < graph s o n io > build ( ) { return build ( graph s o n version . v3_0 ) ; }
public default void write vertex ( final output stream output stream , final iterator < vertex > vertex iterator ) throw i o exception { while ( vertex iterator . have next ( ) ) { write vertex ( output stream , vertex iterator . next ( ) ) ; } }
public static void write object ( final output stream output stream , final serializable object object ) throw i o exception { write class ( output stream , object . get class ( ) ) ; object . write ( output stream ) ; }
public janus graph vertex add vertex ( object . . . key value ) { element helper . legal property key value array ( key value ) ; if ( element helper . get id value ( key value ) . be present ( ) & & ! ( ( standard janus graph ) get graph ( ) ) . get configuration ( ) . allow vertex id setting ( ) ) throw vertex . exception . user supply id not support ( ) ; object label value = null ; for ( int i = 0 ; i < key value . length ; i = i + 2 ) { if ( key value [ i ] . equal ( t . label ) ) { label value = key value [ i+1 ] ; precondition . check argument ( label value instanceof vertex label || label value instanceof string , `` expect a string or vertex label a the vertex label argument , but get : % s `` , label value ) ; if ( label value instanceof string ) element helper . validate label ( ( string ) label value ) ; } } vertex label label = base vertex label . default_vertexlabel ; if ( label value ! =null ) { label = ( label value instanceof vertex label ) ? ( vertex label ) label value : get or create vertex label ( ( string ) label value ) ; } final long id = element helper . get id value ( key value ) . map ( number . class : : cast ) . map ( number : : long value ) . or else ( null ) ; final janus graph vertex vertex = add vertex ( id , label ) ; org . janusgraph . graphdb . util . element helper . attach property ( vertex , key value ) ; return vertex ; }
public static long estimate ram byte ( final long size ) { return estimator . ram byte estimate ( size ) ; }
public double average load penalty ( ) { long total load count = saturate add ( load success count , load failure count ) ; return ( total load count == 0 ) ? 0 . 0 : ( double ) total load time / total load count ; }
public weld event < object > event ( ) { check be run ( ) ; if ( event == null ) { synchronize ( this ) { if ( event == null ) { event = bean manager ( ) . event ( ) ; } } } return event ; }
public static void enable ( ) { final meta class registry meta class registry = groovy system . get meta class registry ( ) ; synchronize ( meta class registry ) { if ( meta class registry . get meta class creation handler ( ) ! = instance ) { class info . clear modify expandos ( ) ; meta class registry . set meta class creation handle ( instance ) ; } } }
public int row model to view ( int model row ) { return sort model . source to target ( model row ) ; }
public void init ( servlet config config ) throw servlet exception { super . init ( config ) ; this . engine = init template engine ( config ) ; if ( engine == null ) { throw new servlet exception ( `` template engine not instantiate . `` ) ; } string value = config . get init parameter ( `` generate . by `` ) ; if ( value ! = null ) { this . generate by = boolean . value of ( value ) ; } value = config . get init parameter ( groovy_source_encoding ) ; if ( value ! = null ) { this . file encode param val = value ; } log ( `` servlet `` + get class ( ) . get name ( ) + `` initialize on `` + engine . get class ( ) ) ; }
public object get property ( string column name ) { try { return get result set ( ) . get object ( column name ) ; } catch ( s q l exception e ) { throw new miss property exception ( column name , groovy result set proxy . class , e ) ; } }
public object get object ( int parameter index ) throw s q l exception { check register ( parameter index ) ; return get open result set ( ) . get object ( parameter index ) ; }
public object get object ( int parameter index ) throw s q l exception { check register ( parameter index ) ; return get open result set ( ) . get object ( parameter index ) ; }
public void put all ( map t ) { iterator iter = t . entry set ( ) . iterator ( ) ; while ( iter . have next ( ) ) { map . entry entry = ( map . entry ) iter . next ( ) ; put ( entry . get key ( ) , entry . get value ( ) ) ; } }
public e previous ( ) { if ( list . be empty ( ) ) { throw new no such element exception ( `` there be no element for this iterator to loop on `` ) ; } if ( iterator . have previous ( ) == false ) { e result = null ; while ( iterator . have next ( ) ) { result = iterator . next ( ) ; } iterator . previous ( ) ; return result ; } return iterator . previous ( ) ; }
public int iterator int iterator ( ) { return new int iterator ( ) { @ override public boolean have next ( ) { return this . i > = 0 ; } @ override public int next ( ) { this . j = this . i ; this . i = bit set . this . next set bit ( this . i + 1 ) ; return this . j ; } private int i = bit set . this . next set bit ( 0 ) ; private int j ; } ; }
public string get family ( ) { return this . family ; } // -- string get family ( )
public lexer node get root node ( ) { return lexer ; }
public static < t > t min ( iterable < t > item ) { t answer = null ; for ( t value : item ) { if ( value ! = null ) { if ( answer == null || script bytecode adapter . compare less than ( value , answer ) ) { answer = value ; } } } return answer ; }
public list breadth first ( boolean preorder ) { list answer = new node list ( ) ; if ( preorder ) answer . add ( this ) ; answer . add all ( breadth first rest ( preorder ) ) ; if ( ! preorder ) answer . add ( this ) ; return answer ; }
protect default listable bean factory get internal bean factory for bean ( string bean name ) { synchronize ( this . internal bean factory ) { default listable bean factory internal bean factory = this . internal bean factory . get ( bean name ) ; if ( internal bean factory == null ) { internal bean factory = build internal bean factory ( this . bean factory ) ; this . internal bean factory . put ( bean name , internal bean factory ) ; } return internal bean factory ; } }
public void set src ( resource src ) { this . src = src ; if ( src instanceof file resource ) { src file = ( ( file resource ) src ) . get file ( ) ; } }
protect void print result ( result set r , print stream out ) throw s q l exception { if ( r ! = null ) { log ( `` process new result set . `` , project . msg_verbose ) ; result set meta data md = r . get meta data ( ) ; int column count = md . get column count ( ) ; string buffer line = new string buffer ( ) ; if ( showheaders ) { for ( int col = 1 ; col < column count ; col++ ) { line . append ( md . get column name ( col ) ) ; line . append ( `` , `` ) ; } line . append ( md . get column name ( column count ) ) ; out . println ( line ) ; line = new string buffer ( ) ; } while ( r . next ( ) ) { boolean first = true ; for ( int col = 1 ; col < = column count ; col++ ) { string column value = r . get string ( col ) ; if ( column value ! = null ) { column value = column value . trim ( ) ; } if ( first ) { first = false ; } else { line . append ( `` , `` ) ; } line . append ( column value ) ; } out . println ( line ) ; line = new string buffer ( ) ; } } out . println ( ) ; }
protect boolean assume java16 ( ) { return `` javac1 . 6 `` . equal ( attribute . get compiler version ( ) ) || ( `` classic `` . equal ( attribute . get compiler version ( ) ) & & java env utils . be java version ( java env utils . java_1_6 ) ) || ( `` modern `` . equal ( attribute . get compiler version ( ) ) & & java env utils . be java version ( java env utils . java_1_6 ) ) || ( `` ext javac `` . equal ( attribute . get compiler version ( ) ) & & java env utils . be java version ( java env utils . java_1_6 ) ) ; }
public void set stub ( boolean stub ) { this . stub = stub ; }
public file get dir ( ) { return get dir ( get project ( ) ) ; }
public boolean get keep stub ( ) { return keep stub ; }
public embed database builder add script ( string . . . script ) { for ( string script : script ) { add script ( script ) ; } return this ; }
protect string [ ] get class template ( ) { return groovy doc template info . default_class_templates ; }
protect string [ ] get class template ( ) { return groovy doc template info . default_class_templates ; }
public void copy node meta data ( a s t node other ) { copy node meta data ( ( node meta data handler ) other ) ; }
public class node lookup class node for ( string type ) { for ( class node cn : type check visitor . get source unit ( ) . get a s t ( ) . get class ( ) ) { if ( cn . get name ( ) . equal ( type ) ) return cn ; } return null ; }
public j class _extends ( ) { if ( super class==null ) super class = owner ( ) . ref ( object . class ) ; return super class ; }
public static boolean be double category ( class node type ) { return type==float_ t y p e || type==double_ t y p e || be big dec category ( type ) ; }
public void push loop ( final variable scope scope , final string label name ) { push variable scope ( scope ) ; continue label = new label ( ) ; break label = new label ( ) ; if ( label name ! = null ) { init loop label ( label name ) ; } }
public void set warn level ( int level ) { if ( level < warn message . none || level > warn message . paranoia ) { this . warn level = warn message . likely_errors ; } else { this . warn level = level ; } }
public void set target bytecode ( final string version ) { set target bytecode if valid ( version ) ; }
public void add fatal error ( final message message ) throw compilation fail exception { add error ( message ) ; fail if error ( ) ; }
public static timestamp plus ( timestamp self , int day ) { calendar calendar = calendar . get instance ( ) ; calendar . set time ( self ) ; calendar . add ( calendar . date , day ) ; timestamp ts = new timestamp ( calendar . get time ( ) . get time ( ) ) ; t . set nanos ( self . get nanos ( ) ) ; return t ; }
public static string get time string ( date self ) { return date format . get time instance ( date format . medium ) . format ( self ) ; }
public static string get time string ( date self ) { return date format . get time instance ( date format . medium ) . format ( self ) ; }
public static component get at ( j tool bar self , int index ) { return self . get component at index ( index ) ; }
public static j combo box leave shift ( j combo box self , object i ) { self . add item ( i ) ; return self ; }
public static void clear ( j combo box self ) { self . remove all item ( ) ; }
public static j menu get at ( j menu bar self , int index ) { return self . get menu ( index ) ; }
public string get package ( ) { return package name ; }
public set < string > get disable global a s t transformation ( ) { return disable global a s t transformation ; }
public static date parse ( date self , string format , string input , time zone zone ) throw parse exception { simple date format sdf = new simple date format ( format ) ; sdf . set time zone ( zone ) ; return sdf . parse ( input ) ; }
public static boolean equal ( map self , map other ) { if ( self == null ) { return other == null ; } if ( other == null ) { return false ; } if ( self == other ) { return true ; } if ( self . size ( ) ! = other . size ( ) ) { return false ; } if ( ! self . key set ( ) . equal ( other . key set ( ) ) ) { return false ; } for ( object key : self . key set ( ) ) { if ( ! coerce equal ( self . get ( key ) , other . get ( key ) ) ) { return false ; } } return true ; }
public simple module set mix in annotation ( class < ? > target type , class < ? > mixin class ) { _check not null ( target type , `` target type `` ) ; _check not null ( mixin class , `` mixin class `` ) ; if ( _mixins == null ) { _mixins = new hash map < class < ? > , class < ? > > ( ) ; } _mixins . put ( target type , mixin class ) ; return this ; }
public static < t > list < t > unique ( list < t > self ) { return ( list < t > ) unique ( ( collection < t > ) self , true ) ; }
public static < t > list < t > each with index ( list < t > self , @ closure params ( value= from string . class , options= `` t , integer `` ) closure closure ) { return ( list < t > ) each with index ( ( iterable < t > ) self , closure ) ; }
public static < t > list < t > each with index ( list < t > self , @ closure params ( value= from string . class , options= `` t , integer `` ) closure closure ) { return ( list < t > ) each with index ( ( iterable < t > ) self , closure ) ; }
public static < t > sort set < t > each with index ( sort set < t > self , @ closure params ( value= from string . class , options= `` t , integer `` ) closure closure ) { return ( sort set < t > ) each with index ( ( iterable < t > ) self , closure ) ; }
public static < t > list < t > each ( list < t > self , @ closure params ( first param . first generic type . class ) closure closure ) { return ( list < t > ) each ( ( iterable < t > ) self , closure ) ; }
public static < t > list < t > each ( list < t > self , @ closure params ( first param . first generic type . class ) closure closure ) { return ( list < t > ) each ( ( iterable < t > ) self , closure ) ; }
public static < t > t [ ] reverse each ( t [ ] self , @ closure params ( first param . component . class ) closure closure ) { each ( new reverse list iterator < t > ( arrays . a list ( self ) ) , closure ) ; return self ; }
public static boolean any ( object self ) { boolean return method invoker bmi = new boolean return method invoker ( ) ; for ( iterator iter = invoker helper . a iterator ( self ) ; iter . have next ( ) ; ) { if ( bmi . convert to boolean ( iter . next ( ) ) ) { return true ; } } return false ; }
public static boolean every ( object self , closure closure ) { boolean closure wrapper bcw = new boolean closure wrapper ( closure ) ; for ( iterator iter = invoker helper . a iterator ( self ) ; iter . have next ( ) ; ) { if ( ! bcw . call ( iter . next ( ) ) ) { return false ; } } return true ; }
public static < t > collection < t > grep ( collection < t > self ) { return grep ( self , closure . identity ) ; }
public static < t , u > t find result ( collection < u > self , @ closure params ( first param . first generic type . class ) closure < t > closure ) { for ( object value : self ) { t result = closure . call ( value ) ; if ( result ! = null ) { return result ; } } return null ; }
public static < t > set < t > find all ( set < t > self ) { return find all ( self , closure . identity ) ; }
public static map group by ( object [ ] self , object . . . closure ) { return group by ( ( iterable ) array . a list ( self ) , closure ) ; }
public static object sum ( object [ ] self , object initial value , closure closure ) { return sum ( to list ( self ) , initial value , closure , false ) ; }
public static < t > t max ( iterator < t > self ) { return max ( ( iterable < t > ) to list ( self ) ) ; }
public static < t > t min ( iterable < t > self , @ closure params ( first param . first generic type . class ) closure closure ) { int params = closure . get maximum number of parameter ( ) ; if ( params ! = 1 ) { return min ( self , new closure comparator < t > ( closure ) ) ; } boolean first = true ; t answer = null ; object answer value = null ; for ( t item : self ) { object value = closure . call ( item ) ; if ( first ) { first = false ; answer = item ; answer value = value ; } else if ( script bytecode adapter . compare less than ( value , answer value ) ) { answer = item ; answer value = value ; } } return answer ; }
public static < t > list < t > a immutable ( list < ? extend t > self ) { return collection . unmodifiable list ( self ) ; }
public static < t > t [ ] drop ( t [ ] self , int num ) { if ( self . length < = num ) { return create similar array ( self , 0 ) ; } if ( num < = 0 ) { t [ ] ret = create similar array ( self , self . length ) ; system . arraycopy ( self , 0 , ret , 0 , self . length ) ; return ret ; } t [ ] ret = create similar array ( self , self . length - num ) ; system . arraycopy ( self , num , ret , 0 , self . length - num ) ; return ret ; }
public static bool query builder bool query ( ) { return new bool query builder ( ) ; }
public static boolean contains ( enumeration enumeration , object element ) { if ( enumeration ! = null ) { while ( enumeration . have more element ( ) ) { object candidate = enumeration . next element ( ) ; if ( object . null safe equal ( candidate , element ) ) { return true ; } } } return false ; }
public static boolean a boolean ( boolean [ ] array ) { if ( null == array ) { return false ; } return array . length > 0 ; }
public static boolean a boolean ( boolean [ ] array ) { if ( null == array ) { return false ; } return array . length > 0 ; }
public static boolean a boolean ( boolean [ ] array ) { if ( null == array ) { return false ; } return array . length > 0 ; }
public static < t > t a type ( map map , class < t > clazz ) { if ( ! ( clazz . be instance ( map ) ) & & clazz . be interface ( ) & & ! trait . be trait ( clazz ) ) { return ( t ) proxy . new proxy instance ( clazz . get class loader ( ) , new class [ ] { clazz } , new convert map ( map ) ) ; } try { return a type ( ( object ) map , clazz ) ; } catch ( groovy cast exception ce ) { try { return ( t ) proxy generator . instance . instantiate aggregate from base class ( map , clazz ) ; } catch ( groovy runtime exception cause ) { throw new groovy cast exception ( `` error cast map to `` + clazz . get name ( ) + `` , reason : `` + cause . get message ( ) ) ; } } }
public static < t > t [ ] to unique ( t [ ] self , comparator < t > comparator ) { collection < t > item = to unique ( to list ( self ) , comparator ) ; t [ ] result = create similar array ( self , item . size ( ) ) ; return item . to array ( result ) ; }
public static < t > collection < t > plus ( iterable < t > leave , iterable < t > right ) { return plus ( a collection ( leave ) , a collection ( right ) ) ; }
public static < t > set < t > plus ( set < t > leave , collection < t > right ) { return ( set < t > ) plus ( ( collection < t > ) leave , right ) ; }
public static < t > collection < t > intersect ( iterable < t > leave , iterable < t > right ) { return intersect ( a collection ( leave ) , a collection ( right ) ) ; }
public static < t > boolean equal ( set < t > self , set < t > other ) { if ( self == null ) { return other == null ; } if ( other == null ) { return false ; } if ( self == other ) { return true ; } if ( self . size ( ) ! = other . size ( ) ) { return false ; } final iterator < t > it1 = self . iterator ( ) ; collection < t > other item = new hash set < t > ( other ) ; while ( it1 . have next ( ) ) { final object o1 = it1 . next ( ) ; final iterator < t > it2 = other item . iterator ( ) ; t find item = null ; boolean find = false ; while ( it2 . have next ( ) & & find item == null ) { final t o2 = it2 . next ( ) ; if ( coerced equal ( o1 , o2 ) ) { found item = o2 ; find = true ; } } if ( ! find ) return false ; other item . remove ( found item ) ; } return other item . be empty ( ) ; }
public static < t > set < t > minus ( set < t > self , iterable < ? > remove me ) { return minus ( self , a collection ( remove me ) ) ; }
public static list < ? > flatten ( list < ? > self ) { return ( list < ? > ) flatten ( ( collection < ? > ) self ) ; }
public static list < long > get at ( long [ ] array , object range range ) { return primitive array get ( array , range ) ; }
public static list < double > get at ( double [ ] array , object range range ) { return primitive array get ( array , range ) ; }
public static list < integer > get at ( int [ ] array , int range range ) { range info info = sub list border ( array . length , range ) ; list < integer > answer = primitive array get ( array , new int range ( true , info . from , info . to - 1 ) ) ; return info . reverse ? reverse ( answer ) : answer ; }
public static list < double > get at ( double [ ] array , collection index ) { return primitive array get ( array , index ) ; }
public static < t > list < t > get at ( t [ ] self , collection index ) { list < t > answer = new array list < t > ( index . size ( ) ) ; for ( object value : index ) { if ( value instanceof range ) { answer . add all ( get at ( self , ( range ) value ) ) ; } else if ( value instanceof collection ) { answer . add all ( get at ( self , ( collection ) value ) ) ; } else { int idx = default type transformation . int unbox ( value ) ; answer . add ( get at impl ( self , idx ) ) ; } } return answer ; }
public static void println ( print stream self , object value ) { self . println ( invoker helper . to string ( value ) ) ; }
public static number plus ( character leave , number right ) { return number number plus . plus ( integer . value of ( leave ) , right ) ; }
public static number minus ( character leave , number right ) { return number number minus . minus ( integer . value of ( leave ) , right ) ; }
public static number multiply ( character leave , number right ) { return number number multiply . multiply ( integer . value of ( leave ) , right ) ; }
public static number power ( long self , integer exponent ) { if ( exponent > = 0 ) { big integer answer = big integer . value of ( self ) . pow ( exponent ) ; if ( answer . compare to ( bi_long_min ) > = 0 & & answer . compare to ( bi_long_max ) < = 0 ) { return answer . long value ( ) ; } else { return answer ; } } else { return power ( self , ( double ) exponent ) ; } }
public static number div ( number leave , character right ) { return number number div . div ( leave , integer . value of ( right ) ) ; }
public static bit set or ( bit set left , bit set right ) { bit set result = ( bit set ) leave . clone ( ) ; result . or ( right ) ; return result ; }
public static void upto ( number self , number to , @ closure params ( first param . class ) closure closure ) { int self1 = self . int value ( ) ; int to1 = to . int value ( ) ; if ( self1 < = to1 ) { for ( int i = self1 ; i < = to1 ; i++ ) { closure . call ( i ) ; } } else throw new groovy runtime exception ( `` the argument ( `` + to + `` ) to upto ( ) can not be less than the value ( `` + self + `` ) it 's call on . `` ) ; }
public static number power ( big integer self , integer exponent ) { if ( exponent > = 0 ) { return self . pow ( exponent ) ; } else { return power ( self , ( double ) exponent ) ; } }
public static boolean or ( boolean left , boolean right ) { return leave || right ; }
public static meta class get meta class ( class c ) { meta class registry meta class registry = groovy system . get meta class registry ( ) ; meta class mc = meta class registry . get meta class ( c ) ; if ( mc instanceof expando meta class || mc instanceof delegate meta class & & ( ( delegate meta class ) mc ) . get adaptee ( ) instanceof expando meta class ) return mc ; else { return new handle meta class ( mc ) ; } }
public static list < class node > find trait ( class node c node ) { link hash set < class node > interface = new link hash set < class node > ( ) ; collect all interface reverse order ( c node , interface ) ; list < class node > traits = new link list < class node > ( ) ; for ( class node candidate : interface ) { if ( be annotate with trait ( candidate ) ) { trait . add ( candidate ) ; } } return trait ; }
public static < e > e remove at ( list < e > self , int index ) { return self . remove ( index ) ; }
public static string format r f c822 ( final date date , final locale locale ) { final simple date format date formater = new simple date format ( `` eee , dd mmm yyyy hh : mm : s 'gmt ' `` , locale ) ; date formater . set time zone ( time zone . get time zone ( `` gmt `` ) ) ; return date formater . format ( date ) ; }
public int line number ( int position ) { int line number = get line number ( position ) ; return line number < 1 ? 1 : line number ; }
public synchronize void cancel ( ) { if ( cancellable ! = null ) { cancellable . cancel ( ) ; cancellable = null ; } be scheduled or run = false ; }
public boolean enter ( long time , time unit unit ) { final long timeout nanos = to safe nanos ( time , unit ) ; final reentrant lock lock = this . lock ; if ( ! fair & & lock . try lock ( ) ) { return true ; } boolean interrupted = thread . interrupt ( ) ; try { final long start time = system . nano time ( ) ; for ( long remain nanos = timeout nanos ; ; ) { try { return lock . try lock ( remain nanos , time unit . nanosecond ) ; } catch ( interrupted exception interrupt ) { interrupted = true ; remain nanos = remain nanos ( start time , timeout nanos ) ; } } } finally { if ( interrupt ) { thread . current thread ( ) . interrupt ( ) ; } } }
public call option with compression ( @ nullable string compressor name ) { call option new option = new call option ( this ) ; new option . compressor name = compressor name ; return new option ; }
public static compressor registry new empty instance ( ) { return new compressor registry ( ) ; }
public void on response write ( int byte send ) { for ( indexed log element element : on response write element ) { element . on response write ( bytes send ) ; } }
public void remove server ( instrumented < server stats > server ) { remove ( server , server ) ; server socket map prev = per server socket . remove ( id ( server ) ) ; assert prev ! = null ; assert prev . be empty ( ) ; }
public instrument < channel stats > get channel ( long id ) { return root channel . get ( id ) ; }
public boolean on fail ( throwable cause ) { if ( log . be debug enable ( ) ) log . debug ( `` on fail { } `` , this , cause ) ; callback callback = _interested . get ( ) ; if ( callback ! = null & & _interested . compare and set ( callback , null ) ) { callback . fail ( cause ) ; return true ; } return false ; }
public static stats trace context new server context ( list < server stream tracer . factory > factory , string full method name , metadata header ) { if ( factory . be empty ( ) ) { return noop ; } stream tracer [ ] tracer = new stream tracer [ factory . size ( ) ] ; for ( int i = 0 ; i < tracer . length ; i++ ) { tracer [ i ] = factory . get ( i ) . new server stream tracer ( full method name , header ) ; } return new stats trace context ( tracer ) ; }
public void set keep alive ( boolean keep alive ) { this . keep alive = keep alive ; }
public static manage channel builder < ? > for address ( string name , int port ) { throw new unsupported operation exception ( `` subclass fail to hide static factory `` ) ; }
public t max hedge attempt ( int max hedge attempt ) { throw new unsupported operation exception ( ) ; }
public static json provider provider ( ) { service loader < json provider > loader = service loader . load ( json provider . class ) ; iterator < json provider > it = loader . iterator ( ) ; if ( it . have next ( ) ) { return it . next ( ) ; } try { class < ? > clazz = class . for name ( default_provider ) ; return ( json provider ) clazz . new instance ( ) ; } catch ( class not find exception x ) { throw new json exception ( `` provider `` + default_provider + `` not find `` , x ) ; } catch ( exception x ) { throw new json exception ( `` provider `` + default_provider + `` could not be instantiate : `` + x , x ) ; } }
public void refresh ( collection < refreshable > already refresh ) { refresh helper . refresh ( already refresh ) ; }
public list < server service definition > get immutable service ( ) { return collection . empty list ( ) ; }
public int get server port ( ) { return this . request . get server port ( ) ; }
public static boolean be success ( int reply code ) { return reply code == ok ; }
protect void transport trailer receive ( metadata trailer ) { precondition . check not null ( trailer , `` trailer `` ) ; if ( transport error == null & & ! header receive ) { transport error = validate initial metadata ( trailer ) ; if ( transport error ! = null ) { transport error metadata = trailer ; } } if ( transport error ! = null ) { transport error = transport error . augment description ( `` trailer : `` + trailer ) ; http2 processing fail ( transport error , false , transport error metadata ) ; } else { status status = status from trailer ( trailer ) ; strip transport detail ( trailer ) ; inbound trailer receive ( trailer , status ) ; } }
public void close ( short status code ) { delegate . close ( status code ) ; }
public unused stubbings get unused stubbings ( iterable < object > mock ) { set < stub > stubbings = all invocation finder . find stubbings ( mock ) ; list < stub > unused = filter ( stubbings , new filter < stub > ( ) { public boolean be out ( stub s ) { return ! unused stub reporting . should be report ( s ) ; } } ) ; return new unused stubbings ( unused ) ; }
public int get server port ( ) { return this . request . get server port ( ) ; }
public netty server builder ssl context ( ssl context ssl context ) { if ( ssl context ! = null ) { check argument ( ssl context . be server ( ) , `` client ssl context can not be use for server `` ) ; grpc ssl context . ensure alpn and h2 enable ( ssl context . application protocol negotiator ( ) ) ; } this . ssl context = ssl context ; return this ; }
public static void write ( byte [ ] from , output supplier < ? extend output stream > to ) throw i o exception { a byte sink ( to ) . write ( from ) ; }
public static input supplier < byte array input stream > new input stream supplier ( byte [ ] b ) { return byte stream . a input supplier ( a byte source ( b ) ) ; }
public static void copy ( file from , file to ) throw i o exception { check argument ( ! from . equal ( to ) , `` source % s and destination % s must be different `` , from , to ) ; a byte source ( from ) . copy to ( a byte sink ( to ) ) ; }
public static input supplier < byte array input stream > new input stream supplier ( byte [ ] b ) { return byte stream . a input supplier ( a byte source ( b ) ) ; }
public < v > future < v > submit ( callable < v > task ) { precondition . check state ( be open . get ( ) , `` closeable executor service be close `` ) ; internal future task < v > future task = new internal future task < v > ( new future task < v > ( task ) ) ; executor service . execute ( future task ) ; return future task ; }
public retryer builder < v > retry if exception ( @ nonnull predicate < throwable > exception predicate ) { precondition . check not null ( exception predicate , `` exception predicate may not be null `` ) ; rejection predicate = predicate . or ( rejection predicate , new exception predicate < v > ( exception predicate ) ) ; return this ; }
public static stop strategy stop after attempt ( int attempt number ) { return new stop after attempt strategy ( attempt number ) ; }
public static void assert equal ( object actual , object expect , string message ) { if ( expect ! = null & & expect . get class ( ) . be array ( ) ) { assert array equal ( actual , expect , message ) ; return ; } assert equal impl ( actual , expect , message ) ; }
public static expect condition < boolean > invisibility of all element ( final web element . . . element ) { return invisibility of all element ( array . a list ( element ) ) ; }
public void seek to last ( ) throw d b exception { try { iter . seek to last ( ) ; } catch ( d b exception e ) { throw e ; } catch ( runtime exception e ) { throw new d b exception ( e . get message ( ) , e ) ; } }
public static < a extend annotation > a get annotation ( method method , class < a > annotation class ) { a annotation = method . get annotation ( annotation class ) ; if ( annotation == null ) { for ( annotation meta annotation : method . get annotation ( ) ) { annotation = meta annotation . annotation type ( ) . get annotation ( annotation class ) ; if ( annotation ! = null ) { return annotation ; } } method superclass method = get overridden method ( method ) ; if ( superclass method ! = null ) { annotation = get annotation ( superclass method , annotation class ) ; } } return annotation ; }
public boolean contains ( string name , string key ) { object value = value . get ( name ) ; if ( value == null ) { throw new null pointer exception ( `` no mapped value for ' `` + name + `` ( `` + key + `` ) ' `` ) ; } else if ( value instanceof map ) { return ( ( ( map ) value ) . contains key ( key ) ) ; } else { throw new illegal argument exception ( `` non-mapped property for ' `` + name + `` ( `` + key + `` ) ' `` ) ; } }
public static bucket order compound ( list < bucket order > order ) { return new internal order . compound order ( order ) ; }
protect c reset container ( ) { return reset container ( get subject generator ( ) . create test subject ( ) ) ; }
public static void assert unescaped ( char escaper escaper , char c ) { assert . assert null ( compute replacement ( escaper , c ) ) ; }
public equal tester test equal ( ) { relationship tester < object > delegate = new relationship tester < > ( equivalence . equal ( ) , `` object # equal `` , `` object # hash code `` , item reporter ) ; for ( list < object > group : equality group ) { delegate . add related group ( group ) ; } for ( int run = 0 ; run < repetition ; run++ ) { test item ( ) ; delegate . test ( ) ; } return this ; }
public static void await do ( finalization predicate predicate ) { if ( predicate . be do ( ) ) { return ; } final long timeout second = timeout second ( ) ; final long deadline = system . nano time ( ) + second . to nanos ( timeout second ) ; do { system . run finalization ( ) ; if ( predicate . be do ( ) ) { return ; } count down latch do = new count down latch ( 1 ) ; create unreachable latch finalizer ( do ) ; await ( do ) ; if ( predicate . be do ( ) ) { return ; } } while ( system . nano time ( ) - deadline < 0 ) ; throw format runtime exception ( `` predicate do not become true within % d second timeout `` , timeout second ) ; }
public static < t > t reserialize and assert ( t object ) { t copy = reserialize ( object ) ; new equal tester ( ) . add equality group ( object , copy ) . test equal ( ) ; assert . assert equal ( object . get class ( ) , copy . get class ( ) ) ; return copy ; }
public list < dependency and source > get dependency chain ( ) { immutable list . builder < dependency and source > builder = immutable list . builder ( ) ; for ( int i = 0 ; i < state . size ( ) ; i += 2 ) { object even entry = state . get ( i ) ; dependency < ? > dependency ; if ( even entry instanceof key ) { dependency = dependency . get ( ( key < ? > ) even entry ) ; } else { dependency = ( dependency < ? > ) even entry ; } builder . add ( new dependency and source ( dependency , state . get ( i + 1 ) ) ) ; } return builder . build ( ) ; }
public void convert auto increment to sequence ( session session , schema schema , int id , boolean temporary ) { if ( ! auto increment ) { db exception . throw internal error ( ) ; } if ( `` identity `` . equal ( original s q l ) ) { original s q l = `` bigint `` ; } else if ( `` serial `` . equal ( original s q l ) ) { original s q l = `` int `` ; } string sequence name ; do { value uuid uuid = value uuid . get new random ( ) ; string s = uuid . get string ( ) ; s = string utils . to upper english ( s . replace ( '- ' , ' _ ' ) ) ; sequence name = `` system_sequence_ `` + s ; } while ( schema . find sequence ( sequence name ) ! = null ) ; sequence seq = new sequence ( schema , id , sequence name , start , increment ) ; seq . set temporary ( temporary ) ; session . get database ( ) . add schema object ( session , seq ) ; set auto increment ( false , 0 , 0 ) ; sequence value seq value = new sequence value ( seq ) ; set default expression ( session , seq value ) ; set sequence ( seq ) ; }
public static closeable d s l context use ( string url ) { if ( url . start with ( `` r2dbc `` ) ) { io . r2dbc . spi . connection connection = r2dbc . get connection ( url ) ; return new default closeable d s l context ( new default connection factory ( connection , true ) , j d b c utils . dialect ( connection ) ) ; } else { try { connection connection = driver manager . get connection ( url ) ; return new default closeable d s l context ( new default closeable connection provider ( connection ) , j d b c utils . dialect ( connection ) ) ; } catch ( s q l exception e ) { throw tool . translate ( `` error when initialise connection `` , e ) ; } } }
public void add ignore ( iterable < string > word ) { synchronize ( ignore list ) { for ( string word : word ) { word = normalize word ( word ) ; ignore list . add ( word ) ; } } }
protect s q l exception unsupported ( string message ) throw s q l exception { try { throw db exception . get unsupported exception ( message ) ; } catch ( exception e ) { throw log and convert ( e ) ; } }
public long get file pointer ( ) { if ( sys property . check2 ) { try { if ( file . position ( ) ! = file po ) { db exception . throw internal error ( ) ; } } catch ( i o exception e ) { throw db exception . convert i o exception ( e , name ) ; } } return file po ; }
public void set shape id max ( int shape id max ) { this . field_1_shape id max = shape id max ; }
public void truncate ( long size ) { try { write count . increment and get ( ) ; file . truncate ( size ) ; file size = math . min ( file size , size ) ; } catch ( i o exception e ) { throw data utils . new illegal state exception ( data utils . error_writing_failed , `` could not truncate file { 0 } to size { 1 } `` , file name , size , e ) ; } }
public void mark use ( long po , int length ) { free space . mark use ( pos , length ) ; }
public static void delete ( file file ) { if ( file . be file ( ) ) { file . delete ( ) ; return ; } if ( ! file . be directory ( ) ) { return ; } file [ ] exist file = file . list file ( ) ; if ( ! be null or empty ( exist file ) ) { for ( file f : existing file ) { delete ( f ) ; } } file . delete ( ) ; }
public long get version to keep ( ) { return version to keep ; }
public int get auto commit memory ( ) { return auto commit memory ; }
public integer get cache parse connection l r u cache size ( ) { return cache parse connection l r u cache size ; }
public boolean be read only ( ) { if ( read only == null ) { return false ; } else { return read only ; } }
public write buffer put char ( char x ) { ensure capacity ( 2 ) . put char ( x ) ; return this ; }
public write buffer put double ( double x ) { ensure capacity ( 8 ) . put double ( x ) ; return this ; }
public write buffer put ( byte x ) { ensure capacity ( 1 ) . put ( x ) ; return this ; }
public boolean write ( long position , byte [ ] data ) throw i o exception { if ( position == this . last write position ) { int buffer position = ( int ) ( this . last write position - this . buffer start position ) ; if ( buffer position + data . length < = this . buffer . length ) { system . arraycopy ( data , 0 , this . buffer , buff position , data . length ) ; this . last write position = position + data . length ; return false ; } } boolean be interrupt = flush ( ) ; system . arraycopy ( data , 0 , this . buffer , 0 , data . length ) ; this . buffer start position = position ; this . last write position = position + data . length ; return be interrupt ; }
public write buffer put short ( int index , short value ) { buff . put short ( index , value ) ; return this ; }
public string get s q l ( ) { string builder buff = new string builder ( ) ; if ( primary key ) { buff . append ( `` primary key `` ) ; if ( hash ) { buff . append ( `` hash `` ) ; } } else { if ( unique ) { buff . append ( `` unique `` ) ; } if ( hash ) { buff . append ( `` hash `` ) ; } buff . append ( `` index `` ) ; } return buff . to string ( ) ; }
public array list < table > get all table and view ( ) { synchronize ( database ) { return new . array list ( table and view . value ( ) ) ; } }
public static void copy ( file in file , file out file ) throw i o exception { path source = in file . to path ( ) ; path target = out file . to path ( ) ; if ( file . exists ( source ) ) { file . create directory ( target . get parent ( ) ) ; try ( stream < path > walk = file . walk ( source ) ) { for ( path s : ( iterable < path > ) walk : : iterator ) { path t = target . resolve ( source . relativize ( s ) ) ; file . copy ( s , t , standard copy option . replace_existing ) ; } } } }
public static void copy ( file in file , file out file ) throw i o exception { path source = in file . to path ( ) ; path target = out file . to path ( ) ; if ( file . exists ( source ) ) { file . create directory ( target . get parent ( ) ) ; try ( stream < path > walk = file . walk ( source ) ) { for ( path s : ( iterable < path > ) walk : : iterator ) { path t = target . resolve ( source . relativize ( s ) ) ; file . copy ( s , t , standard copy option . replace_existing ) ; } } } }
public t convert ( string value ) { t v = converter . convert ( null , null , value ) ; validate ( v ) ; return v ; }
public void set id ( long column id ) { ct table column . set id ( column id ) ; }
public value get default value ( session session , column column ) { expression default expr = column . get default expression ( ) ; value v ; if ( default expr == null ) { v = column . validate convert update sequence ( session , null ) ; } else { v = default expr . get value ( session ) ; } return column . convert ( v ) ; }
public expression get check constraint ( session session , string a column name ) { if ( check constraint == null ) { return null ; } parser parser = new parser ( session ) ; string sql ; synchronize ( this ) { string old name = name ; name = a column name ; sql = check constraint . get s q l ( ) ; name = old name ; } return parser . parse expression ( sql ) ; }
public void register ( table filter filter , index lookup batch lookup batch ) { assert filter ! = null ; top = new join filter ( lookup batch , filter , top ) ; filter [ top . id ] = top ; }
public static void before ( filter . . . filter ) { for ( filter filter : filter ) { get instance ( ) . before ( filter ) ; } }
public boolean be recursive ( ) { return recursive ; }
public int deinterleave ( int dimension , long scalar , int dim ) { int bit per value = get bit per value ( dimension ) ; int value = 0 ; for ( int i = 0 ; i < bit per value ; i++ ) { value |= ( scalar > > ( dim + ( dimension - 1 ) * i ) ) & ( 1l < < i ) ; } return value ; }
public static object parse local date time ( char sequence text ) { try { return local_date_time_parse . invoke ( null , text ) ; } catch ( illegal access exception | invocation target exception e ) { throw new illegal argument exception ( `` error when parse text ' `` + text + `` ' `` , e ) ; } }
public static object parse local date time ( char sequence text ) { try { return local_date_time_parse . invoke ( null , text ) ; } catch ( illegal access exception | invocation target exception e ) { throw new illegal argument exception ( `` error when parse text ' `` + text + `` ' `` , e ) ; } }
public static value offset date time to value ( object offset date time ) { try { object local date time = offset_date_time_to_local_date_time . invoke ( offset date time ) ; object local date = local_date_time_to_local_date . invoke ( local date time ) ; object zone offset = offset_date_time_get_offset . invoke ( offset date time ) ; long date value = date value from local date ( local date ) ; long time nanos = time nanos from local date time ( local date time ) ; short time zone offset min = zone offset to offset minute ( zone offset ) ; return value timestamp time zone . from date value and nanos ( date value , time nanos , time zone offset min ) ; } catch ( illegal access exception e ) { throw db exception . convert ( e ) ; } catch ( invocation target exception e ) { throw db exception . convert invocation ( e , `` time conversion fail `` ) ; } }
public string get local hostname ( ) { try { inet address addr = inet address . get local host ( ) ; return addr . get host name ( ) ; } catch ( unknown host exception uhe ) { add error ( `` could not determine local host name `` , uhe ) ; return `` unknown_localhost `` ; } }
public geometry get envelope ( ) { return get factory ( ) . to geometry ( get envelope internal ( ) ) ; }
public long get capacity ( ) { if ( configured capacity < 0 ) { long remain = usage . get capacity ( ) - reserve ; return remain > 0 ? remain : 0 ; } return configured capacity ; }
public long get year ( ) { return interval utils . year from interval ( qualifier , negative , leading , remain ) ; }
public long get year ( ) { return interval utils . year from interval ( qualifier , negative , leading , remain ) ; }
public long get second ( ) { if ( qualifier == interval qualifier . second ) { return negative ? -leading : leading ; } return get second and nanos ( ) / nanos_per_second ; }
public array list < expression > expression ( ) { return expression ; }
public array list < select order by > get order by ( ) { return order by ; }
public final void set current group expr data ( expression expr , object obj ) { integer index = expr to index in group by data . get ( expr ) ; if ( index ! = null ) { assert current group by expr data [ index ] == null ; current group by expr data [ index ] = obj ; return ; } index = expr to index in group by data . size ( ) ; expr to index in group by data . put ( expr , index ) ; if ( index > = current group by expr data . length ) { current group by expr data = array . copy of ( current group by expr data , current group by expr data . length * 2 ) ; update current group expr data ( ) ; } current group by expr data [ index ] = obj ; }
public void set collector ( collector collector ) { this . collector = collector ; }
public string builder get s q l ( string builder builder , boolean always quote ) { builder . append ( unit . get s q l ( ) ) ; if ( follow == null ) { builder . append ( ' ' ) ; start . get s q l ( builder , false , always quote ) ; } else { builder . append ( `` between `` ) ; start . get s q l ( builder , false , always quote ) . append ( `` and `` ) ; follow . get s q l ( builder , true , always quote ) ; } if ( exclusion ! = window frame exclusion . exclude_no_others ) { builder . append ( ' ' ) . append ( exclusion . get s q l ( ) ) ; } return builder ; }
public list get token list ( ) { check tokenized ( ) ; list list = new array list ( token . length ) ; for ( int i = 0 ; i < token . length ; i++ ) { list . add ( tokens [ i ] ) ; } return list ; }
public network get network ( ) { return network ; }
public void optimize ( session session ) { if ( partition by ! = null ) { for ( int i = 0 ; i < partition by . size ( ) ; i++ ) { partition by . set ( i , partition by . get ( i ) . optimize ( session ) ) ; } } if ( order by ! = null ) { for ( select order by o : order by ) { o . expression = o . expression . optimize ( session ) ; } } if ( frame ! = null ) { frame . optimize ( session ) ; } }
public void read session state ( ) { if ( ! session state change || session state updating ) { return ; } session state change = false ; session state = new . array list ( ) ; command interface ci = prepare command ( `` select * from information_schema . session_state `` , integer . max_value ) ; result interface result = ci . execute query ( 0 , false ) ; while ( result . next ( ) ) { value [ ] row = result . current row ( ) ; session state . add ( row [ 1 ] . get string ( ) ) ; } }
public static long get default max value ( long start value , long increment ) { long v = increment > = 0 ? long . max_value : -1 ; if ( start value ! = null & & increment < 0 & & start value > v ) { v = start value ; } return v ; }
public nest identity get nest identity ( ) { return nest identity ; }
public static string clean ( string charset name ) { try { return for name ( charset name ) . name ( ) ; } catch ( exception e ) { return null ; } }
public void set validator class ( string validator class ) { this . validator class = validator class ; }
public value get default value ( session session , column column ) { expression default expr = column . get default expression ( ) ; value v ; if ( default expr == null ) { v = column . validate convert update sequence ( session , null ) ; } else { v = default expr . get value ( session ) ; } return column . convert ( v ) ; }
public void add common join column ( column leave column , column replacement column , table filter replacement filter ) { if ( common join columns == null ) { common join column = new link hash map < > ( ) ; common join columns filter = replacement filter ; } else { assert common join columns filter == replacement filter ; } common join column . put ( left column , replacement column ) ; }
public static int parse geometry type ( string s ) { e w k t source source = new e w k t source ( s ) ; int type = source . read type ( ) ; int dimension system = 0 ; if ( source . have data ( ) ) { dimension system = source . read dimension system ( ) ; if ( source . have data ( ) ) { throw new illegal argument exception ( ) ; } } return dimension system * 1_000 + type ; }
public static date time zone for i d ( string id ) { if ( id == null ) { return get default ( ) ; } if ( id . equal ( `` utc `` ) ) { return date time zone . utc ; } date time zone zone = c provider . get zone ( id ) ; if ( zone ! = null ) { return zone ; } if ( id . start with ( `` + `` ) || id . start with ( `` - `` ) ) { int offset = parse offset ( id ) ; if ( offset == 0l ) { return date time zone . utc ; } else { id = print offset ( offset ) ; return fix offset zone ( id , offset ) ; } } throw new illegal argument exception ( `` the datetime zone id ' `` + id + `` ' be not recognise `` ) ; }
public int get meaning a ( int [ ] type ) { for ( int type : type ) { if ( be a ( type ) ) { return type ; } } return type . unknown ; }
public static value decimal get ( big decimal dec ) { if ( big decimal . zero . equal ( dec ) ) { return ( value decimal ) zero ; } else if ( big decimal . one . equal ( dec ) ) { return ( value decimal ) one ; } return ( value decimal ) value . cache ( new value decimal ( dec ) ) ; }
public int hash code ( ) { / * * na n be normalize in get ( ) method , so it 's safe to use * float to raw int bit ( ) instead of float to int bit ( ) here . * / return float . float to raw int bit ( value ) ; }
public static value result set get ( result set r ) { value result set val = new value result set ( r ) ; return val ; }
public void add token ( text alias , token < ? extend token identifier > t ) { if ( t ! = null ) { token map . put ( alias , t ) ; } else { log . warn ( `` null token ignore for `` + alias ) ; } }
public string get restrict user agent ( ) { if ( restrict user agent == null ) { return null ; } else { return restrict user agent . to string ( ) ; } }
public string to string ( ) { string builder buffer = new string builder ( ) ; string type = `` cf `` ; if ( header instanceof c f header12 record ) { type = `` cf12 `` ; } buffer . append ( `` [ `` ) . append ( type ) . append ( `` ] \n `` ) ; if ( header ! = null ) { buffer . append ( header ) ; } for ( c f rule base cf rule : rule ) { buffer . append ( cf rule ) ; } buffer . append ( `` [ / `` ) . append ( type ) . append ( `` ] \n `` ) ; return buffer . to string ( ) ; }
public void load property ( property prop ) { for ( map . entry < object , object > entry : prop . entry set ( ) ) { string key = ( string ) entry . get key ( ) ; object value = entry . get value ( ) ; if ( key ! = null & & value ! = null ) { set property ( key , value ) ; } } }
public void add resource env ref ( context resource env ref resource ) { if ( entry . contains ( resource . get name ( ) ) ) { return ; } else { if ( ! check resource type ( resource ) ) { throw new illegal argument exception ( sm . get string ( `` naming resource . resource type fail `` , resource . get name ( ) , resource . get type ( ) ) ) ; } entry . add ( resource . get name ( ) ) ; } synchronize ( resource env refs ) { resource . set naming resource ( this ) ; resource env ref . put ( resource . get name ( ) , resource ) ; } support . fire property change ( `` resource env ref `` , null , resource ) ; }
public static string trim to null ( final string s ) { final string trim = trim ( s ) ; if ( trim == null || trim . be empty ( ) ) { return null ; } else { return trim ; } }
public void set default ( string name , double value ) { if ( double . be na n ( value ) ) { throw new illegal argument exception ( ) ; } default property . put ( name , double . to string ( value ) ) ; }
public < u > list < u > get instance ( string name , class < u > xface ) { list < u > ret = new array list < u > ( ) ; class < ? > [ ] class = get class ( name ) ; for ( class < ? > cl : class ) { if ( ! xface . be assignable from ( cl ) ) { throw new runtime exception ( cl + `` do not implement `` + xface ) ; } ret . add ( ( u ) reflection utils . new instance ( cl , this ) ) ; } return ret ; }
public static symbol token symbol ( final string name , final int val ) { if ( name == null ) { throw new null pointer exception ( ) ; } if ( val < = 0 ) { throw new illegal argument exception ( `` symbol value must be positive : `` + val ) ; } return new symbol token ( ) { public string get text ( ) { return name ; } public string assume text ( ) { return name ; } public int get sid ( ) { return val ; } @ override public string to string ( ) { return `` ( symbol ' `` + get text ( ) + `` ' `` + get sid ( ) + `` ) `` ; } } ; }
protect static string condense package string ( string classname ) { string part [ ] = classname . split ( `` \\ . `` ) ; string builder dense = new string builder ( ) ; for ( int i = 0 ; i < ( part . length - 1 ) ; i++ ) { dense . append ( part [ i ] . char at ( 0 ) ) ; } if ( dense . length ( ) > 0 ) { dense . append ( ' . ' ) ; } dense . append ( part [ part . length - 1 ] ) ; return dense . to string ( ) ; }
public printer configuration add option ( configuration option option ) { remove option ( option ) ; default option . add ( option ) ; return this ; }
public key version get current key ( string name ) throw i o exception { metadata meta = get metadata ( name ) ; if ( meta == null ) { return null ; } return get key version ( build version name ( name , meta . get version ( ) - 1 ) ) ; }
public void next byte ( byte [ ] bytes ) { int bytes out = 0 ; while ( bytes out < byte . length ) { int rand int = next int ( ) ; for ( int i = 0 ; i < 3 ; i++ ) { if ( i > 0 ) { rand int > > = 8 ; } bytes [ byte out++ ] = ( byte ) rand int ; if ( bytes out == byte . length ) { return ; } } } }
public static string build d t service name ( uri uri , int def port ) { string authority = uri . get authority ( ) ; if ( authority == null ) { return null ; } inet socket address addr = net utils . create socket addr ( authority , def port ) ; return build token service ( addr ) . to string ( ) ; }
public static void set x attr ( string path , string name , string value ) throw i o exception { set x attr ( path , name , value , native . get default string encoding ( ) ) ; }
public map < string , byte [ ] > get x attrs ( path path ) throw i o exception { throw new unsupported operation exception ( get class ( ) . get simple name ( ) + `` do n't support get x attrs `` ) ; }
public void set topology path ( string [ ] topology path ) throw i o exception { if ( topology path == null ) { this . topology path = empty_str_array ; } else { this . topology path = topology path ; } }
public void set length ( long length ) { this . length = length ; if ( length ! = null & & length . long value ( ) < 0 ) { throw new build exception ( invalid_length + length ) ; } }
public static string get header ( boolean q option ) { return q option ? quota_header : header ; }
public static boolean be symlink ( final file file ) { return file ! = null & & file . be symbolic link ( file . to path ( ) ) ; }
public string get owner property ( ) { return owner property ; }
public static file context get file context ( final configuration a conf ) throw unsupported file system exception { final uri default f uri = uri . create ( a conf . get ( fs_default_name_key , fs_default_name_default ) ) ; if ( default f uri . get scheme ( ) ! = null & & ! default fs uri . get scheme ( ) . trim ( ) . be empty ( ) ) { return get file context ( default f uri , a conf ) ; } throw new unsupported file system exception ( string . format ( `` % s : uri configure via % s carry no scheme `` , default f uri , fs_default_name_key ) ) ; }
public static file context get file context ( final configuration a conf ) throw unsupported file system exception { final uri default f uri = uri . create ( a conf . get ( fs_default_name_key , fs_default_name_default ) ) ; if ( default f uri . get scheme ( ) ! = null & & ! default fs uri . get scheme ( ) . trim ( ) . be empty ( ) ) { return get file context ( default f uri , a conf ) ; } throw new unsupported file system exception ( string . format ( `` % s : uri configure via % s carry no scheme `` , default f uri , fs_default_name_key ) ) ; }
public token < ? > [ ] add delegation token ( final string renewer , credential credential ) throw i o exception { return get extension ( ) . add delegation token ( renewer , credential ) ; }
public boolean truncate ( path f , long new length ) throw i o exception { throw new unsupported operation exception ( `` not implement by the `` + get class ( ) . get simple name ( ) + `` file system implementation `` ) ; }
public boolean delete on exit ( path f ) throw i o exception { if ( ! exists ( f ) ) { return false ; } synchronize ( delete on exit ) { delete on exit . add ( f ) ; } return true ; }
public file status [ ] list status ( path [ ] file , path filter filter ) throw file not find exception , i o exception { array list < file status > result = new array list < file status > ( ) ; for ( int i = 0 ; i < file . length ; i++ ) { list status ( result , file [ i ] , filter ) ; } return result . to array ( new file status [ result . size ( ) ] ) ; }
public file status [ ] list status ( path f ) throw i o exception { return f . list status ( f , default_filter ) ; }
public static local file system new instance local ( configuration conf ) throw i o exception { return ( local file system ) new instance ( local file system . name , conf ) ; }
public static synchronize void clear statistic ( ) { for ( statistic stat : statistic table . value ( ) ) { stat . reset ( ) ; } }
public void set work directory ( path new dir ) { f . set work directory ( new dir ) ; }
public void flush ( ) throw i o exception { flush buffer ( false , false ) ; }
public static void main ( string [ ] argv ) throw exception { int re = tool runner . run ( new offline edits viewer ( ) , argv ) ; system . exit ( re ) ; }
public static void register command ( command factory factory ) { factory . add class ( count . class , `` -count `` ) ; }
public path get local path for write ( string path str , long size , configuration conf ) throw i o exception { return get local path for write ( path str , size , conf , true ) ; }
public path get local path to read ( string path str , configuration conf ) throw i o exception { allocator per context context = obtain context ( context cfg item name ) ; return context . get local path to read ( path str , conf ) ; }
public static boolean be origin form ( uri uri ) { return uri . get scheme ( ) == null & & uri . get scheme specific part ( ) == null & & uri . get host ( ) == null & & uri . get authority ( ) == null ; }
public command factory get command factory ( ) { return this . command factory ; }
protect void process path ( path data item ) throw i o exception { throw new runtime exception ( `` process path ( ) be not implement `` ) ; }
public void trace ( string message , expression exp ) { if ( get configuration ( ) . be optimizer trace ( ) ) { system . err . println ( `` opt ====================================== `` ) ; system . err . println ( `` opt : at line `` + exp . get line number ( ) + `` of `` + exp . get system id ( ) ) ; system . err . println ( `` opt : `` + message ) ; system . err . println ( `` opt ====== expression after rewrite ====== `` ) ; exp . explain ( system . err ) ; system . err . println ( `` \n o p t ====================================== `` ) ; } }
public command get instance ( string cmd name , configuration conf ) { if ( conf == null ) throw new null pointer exception ( `` configuration be null `` ) ; command instance = object map . get ( cmd name ) ; if ( instance == null ) { class < ? extends command > cmd class = class map . get ( cmd name ) ; if ( cmd class ! = null ) { instance = reflection utils . new instance ( cmd class , conf ) ; instance . set name ( cmd name ) ; instance . set command factory ( this ) ; } } return instance ; }
public list < type parameter < ? > > get type parameter ( ) { return collection . unmodifiable list ( arrays . a list ( this . type parameter ) ) ; }
public void add ( input stream in ) { stream . add ( in ) ; }
public void set max delta depth ( int max delta depth ) { this . max delta depth = max delta depth ; }
public void checkpoint ( ) throw i o exception { trash policy . create checkpoint ( ) ; }
public static void set home dir conf ( final configuration conf , final string mount table name , final string homedir ) { if ( ! homedir . start with ( `` / `` ) ) { throw new illegal argument exception ( `` home dir should start with / : `` + homedir ) ; } conf . set ( get config view fs prefix ( mount table name ) + `` . `` + constant . config_viewfs_homedir , homedir ) ; }
public object get attribute ( string name ) { return web app context . get attribute ( name ) ; }
public input stream get conf resource a input stream ( string name ) { try { url url= get resource ( name ) ; if ( url == null ) { log . info ( name + `` not find `` ) ; return null ; } else { log . info ( `` find resource `` + name + `` at `` + url ) ; } return url . open stream ( ) ; } catch ( exception e ) { return null ; } }
public object get value ( string k ) { if ( value == null ) { return null ; } else { return value . get ( k ) ; } }
public int compare to ( binary comparable other ) { if ( this == other ) return 0 ; return writable comparator . compare byte ( get byte ( ) , 0 , get length ( ) , other . get byte ( ) , 0 , other . get length ( ) ) ; }
public void update report byte count ( int count ) { this . report byte read from compress stream += count ; this . update process byte count ( count ) ; }
public static void set conf ( object the object , configuration conf ) { if ( conf ! = null ) { if ( the object instanceof configurable ) { ( ( configurable ) the object ) . set conf ( conf ) ; } set job conf ( the object , conf ) ; } }
public static void set codec class ( configuration conf , list < class > class ) { string builder buf = new string builder ( ) ; iterator < class > itr = class . iterator ( ) ; if ( itr . have next ( ) ) { class cl = itr . next ( ) ; buf . append ( cl . get name ( ) ) ; while ( itr . have next ( ) ) { buf . append ( ' , ' ) ; buf . append ( itr . next ( ) . get name ( ) ) ; } } conf . set ( common configuration key . io_compression_codecs_key , buf . to string ( ) ) ; }
public compression codec get codec by class name ( string classname ) { if ( codecs by class name == null ) { return null ; } return codecs by class name . get ( classname ) ; }
public void finish ( ) throw i o exception { if ( ! finish ) { compressor . finish ( ) ; finish = true ; } }
public static void copy ( byte [ ] in , file out ) throw i o exception { assert . not null ( in , `` no input byte array specify `` ) ; assert . not null ( out , `` no output file specify `` ) ; byte array input stream in stream = new byte array input stream ( in ) ; output stream out stream = new buffer output stream ( new file output stream ( out ) ) ; copy ( in stream , out stream ) ; }
public static void save m d5 file ( file data file , m d5 hash digest ) throw i o exception { final string digest string = string utils . byte to hex string ( digest . get digest ( ) ) ; save m d5 file ( data file , digest string ) ; }
public void write ( data input in , int length ) throw i o exception { buffer . write ( in , length ) ; }
public static int read swap unsigned short ( final byte [ ] data , final int offset ) { return ( ( ( data [ offset + 0 ] & 0xff ) < < 0 ) + ( ( data [ offset + 1 ] & 0xff ) < < 8 ) ) ; }
public static double read double ( byte [ ] byte , int start ) { return double . long bit to double ( read long ( byte , start ) ) ; }
public writable call ( rpc . rpc kind rpc kind , writable rpc request , connection id remote id ) throw i o exception { return call ( rpc kind , rpc request , remote id , rpc . rpc_service_class_default ) ; }
public synchronize client get client ( configuration conf , socket factory factory ) { return this . get client ( conf , factory , object writable . class ) ; }
public int size ( ) { int size = 0 ; for ( block queue q : this . queue ) { size += q . size ( ) ; } return size ; }
public synchronize void shutdown ( ) { synchronize ( connection pool ) { if ( ! shutdown ) { shutdown = true ; connection pool . shutdown ( ) ; } } }
public static < t > t get proxy ( class < t > proxy interface , interceptor interceptor ) { return ( t ) new proxy factory ( proxy interface , interceptor ) . get proxy ( ) ; }
public static inet address get remote ip ( ) { call call = cur call . get ( ) ; return ( call ! = null & & call . connection ! = null ) ? call . connection . get host inet address ( ) : null ; }
public void set socket buffer size hint ( int socket send buffer size hint , int socket receive buffer size hint ) { this . socket send buffer size hint = socket send buffer size hint ; this . socket receive buffer size hint = socket receive buffer size hint ; }
protect void service stop ( ) throw exception { keep run = false ; heartbeat thread . interrupt ( ) ; try { heartbeat thread . join ( ) ; } catch ( interrupted exception ex ) { log . error ( `` error join with heartbeat thread `` , ex ) ; } client . stop ( ) ; handler thread . interrupt ( ) ; super . service stop ( ) ; }
public model and view add object ( string attribute name , @ nullable object attribute value ) { get model map ( ) . add attribute ( attribute name , attribute value ) ; return this ; }
public synchronize void stop monitoring ( ) { if ( be monitor ) { stop timer ( ) ; be monitor = false ; } }
protect void remove ( metric record impl record ) { string record name = record . get record name ( ) ; tag map tag table = record . get tag table ( ) ; record map record map = get record map ( record name ) ; synchronize ( record map ) { iterator < tag map > it = record map . key set ( ) . iterator ( ) ; while ( it . have next ( ) ) { tag map row tag = it . next ( ) ; if ( row tag . contains all ( tag table ) ) { it . remove ( ) ; } } } }
protect void update ( metric record impl record ) { }
public synchronize metric tag get tag ( string name ) { return tag map . get ( name ) ; }
public synchronize int get previous interval num ops ( ) { return previous interval data . num operation ; }
public synchronize void snapshot ( metric record builder builder , boolean all ) { for ( metric tag tag : tag ( ) ) { builder . add ( tag ) ; } for ( mutable metric metric : metric ( ) ) { metric . snapshot ( builder , all ) ; } }
public mutable gauge int new gauge ( string name , string desc , int i val ) { return new gauge ( intern . info ( name , desc ) , i val ) ; }
public void pause ( ) { try { if ( protocol handler ! = null ) { protocol handler . pause ( ) ; } } catch ( exception e ) { log . error ( sm . get string ( `` coyote connector . protocol handler pause fail `` ) , e ) ; } }
protect void remove ( metric record impl record ) { string record name = record . get record name ( ) ; tag map tag table = record . get tag table ( ) ; record map record map = get record map ( record name ) ; synchronize ( record map ) { iterator < tag map > it = record map . key set ( ) . iterator ( ) ; while ( it . have next ( ) ) { tag map row tag = it . next ( ) ; if ( row tag . contains all ( tag table ) ) { it . remove ( ) ; } } } }
protect static string replace fallback configuration pattern ( final pattern pattern , final string conf , final string module configuration ) { matcher matcher = pattern . matcher ( conf ) ; if ( matcher . match ( ) ) { string map conf = module configuration ; if ( matcher . group ( 1 ) ! = null ) { map conf = map conf + matcher . group ( 1 ) ; } if ( matcher . group ( 2 ) ! = null ) { map conf = map conf + matcher . group ( 2 ) ; } return map conf ; } return null ; }
public string a c q l query ( ) { string builder sb = new string builder ( ) ; sb . append ( `` create keyspace `` ) . append ( metadata . quote if necessary ( name ) ) . append ( `` with `` ) ; sb . append ( `` replication = { 'class ' : ' `` ) . append ( replication . get ( `` class `` ) ) . append ( '\ `` ) ; for ( map . entry < string , string > entry : replication . entry set ( ) ) { if ( entry . get key ( ) . equal ( `` class `` ) ) continue ; sb . append ( `` , ' `` ) . append ( entry . get key ( ) ) . append ( `` ' : ' `` ) . append ( entry . get value ( ) ) . append ( '\ `` ) ; } sb . append ( `` } and durable_writes = `` ) . append ( durable writes ) ; sb . append ( ' ; ' ) ; return sb . to string ( ) ; }
public static trust channel resolver get instance ( configuration conf ) { class < ? extends trust channel resolver > clazz = conf . get class ( d f s config key . dfs_trustedchannel_resolver_class , trust channel resolver . class , trust channel resolver . class ) ; return reflection utils . new instance ( clazz , conf ) ; }
public static string get last half ( string network location ) { int index = network location . last index of ( node base . path_separator_str ) ; return network location . substring ( index ) ; }
public synchronize void close ( ) throw i o exception { / * close the channel since socket . get input stream ( ) . close ( ) * close the socket . * / reader . channel . close ( ) ; reader . close ( ) ; }
public static byte [ ] encode ( byte [ ] bytes ) { return bytes == null || byte . length == 0 ? byte : codec . encode ( byte ) ; }
public static int byte to int ( byte [ ] bytes ) { if ( byte . length == 1 ) { return ( int ) bytes [ 0 ] ; } if ( byte . length == short_bytes ) { return int2 ( byte , 0 ) ; } if ( byte . length == long_bytes ) { return int4 ( byte , 0 ) ; } else { throw new illegal argument exception ( `` argument byte be empty `` ) ; } }
public boolean equal ( object o ) { if ( ! super . equal ( o ) ) return false ; map type i d mti = ( map type i d ) o ; return this . type i d key . equal ( mti . type i d key ) & & this . type i d value . equal ( mti . type i d value ) ; }
public string get proxy superuser user conf key ( string user name ) { return config prefix + user name + conf_users ; }
public void add secret key ( text alias , byte [ ] key ) { secret key map . put ( alias , key ) ; }
public list < string > each text ( ) { array list < string > text = new array list < > ( size ( ) ) ; for ( element el : this ) { if ( el . have text ( ) ) text . add ( el . text ( ) ) ; } return text ; }
public static credential read token storage file ( path filename , configuration conf ) throw i o exception { f s data input stream in = null ; credential credential = new credential ( ) ; try { in = filename . get file system ( conf ) . open ( filename ) ; credential . read token storage stream ( in ) ; in . close ( ) ; return credential ; } catch ( i o exception ioe ) { throw new i o exception ( `` exception read `` + filename , ioe ) ; } finally { i o utils . cleanup ( log , in ) ; } }
public static sasl property resolver get sasl property resolver ( configuration conf ) { string qops = conf . get ( dfs_data_transfer_protection_key ) ; if ( qops == null || qops . be empty ( ) ) { log . debug ( `` data transfer protocol not use sasl property resolver , no `` + `` qop found in configuration for { } `` , dfs_data_transfer_protection_key ) ; return null ; } configuration sasl prop resolver conf = new configuration ( conf ) ; sasl prop resolver conf . set ( hadoop_rpc_protection , qops ) ; class < ? extend sasl property resolver > resolver class = conf . get class ( hadoop_security_sasl_props_resolver_class , sasl property resolver . class , sasl property resolver . class ) ; resolver class = conf . get class ( dfs_data_transfer_sasl_props_resolver_class_key , resolver class , sasl property resolver . class ) ; sasl prop resolver conf . set class ( hadoop_security_sasl_props_resolver_class , resolver class , sasl property resolver . class ) ; sasl property resolver resolver = sasl property resolver . get instance ( sasl prop resolver conf ) ; log . debug ( `` data transfer protocol use sasl property resolver , configure `` + `` qop { } = { } , configured class { } = { } `` , dfs_data_transfer_protection_key , qops , dfs_data_transfer_sasl_props_resolver_class_key , resolver class ) ; return resolver ; }
public user group information get user ( ) { if ( ( owner == null ) || ( owner . to string ( ) . be empty ( ) ) ) { return null ; } final user group information real ugi ; final user group information ugi ; if ( ( real user == null ) || ( real user . to string ( ) . be empty ( ) ) || real user . equal ( owner ) ) { ugi = real ugi = user group information . create remote user ( owner . to string ( ) ) ; } else { real ugi = user group information . create remote user ( real user . to string ( ) ) ; ugi = user group information . create proxy user ( owner . to string ( ) , real ugi ) ; } real ugi . set authentication method ( authentication method . token ) ; return ugi ; }
public static < t > t do a current user ( privileged exception action < t > action ) throw i o exception { return do a user ( user group information . get current user ( ) , action ) ; }
public key manager factory factory bean get key manager factory ( ) { if ( key manager factory == null ) { return new key manager factory factory bean ( ) ; } return key manager factory ; }
public void put in buffer ( final byte buffer buf ) { assert proto . get serialized size ( ) < = max_proto_size : `` expect `` + ( max_proto_size ) + `` get : `` + proto . get serialized size ( ) ; try { buf . put int ( packet len ) ; buf . put short ( ( short ) proto . get serialized size ( ) ) ; proto . write to ( new byte buffer output stream ( buf ) ) ; } catch ( i o exception e ) { throw new runtime exception ( e ) ; } }
public static keytab get instance ( ) { return new keytab ( ) ; }
public synchronize set < token identifier > get token identifier ( ) { return subject . get public credential ( token identifier . class ) ; }
public boolean add token ( text alias , token < ? extend token identifier > token ) { synchronize ( subject ) { get credential internal ( ) . add token ( alias , token ) ; return true ; } }
public < t > list < t > load dynamic service provider ( class < t > iface ) { if ( dynamic ) { synchronize ( service ) { list < rank service > list = new array list < rank service > ( service . value ( ) ) ; collection . sort ( list ) ; list < t > provider = new array list < t > ( list . size ( ) ) ; for ( ranked service service : list ) { if ( service . be instance of ( iface ) ) { provider . add ( ( t ) service . service ) ; } } return provider ; } } else { return new array list < t > ( 0 ) ; } }
public string to string ( ) { state state = get state ( ) ; return ( `` state : `` + state . to string ( ) + ( state . be connect ( ) ? `` timeout : `` + get session timeout ( ) + `` `` : `` `` ) + cnxn ) ; }
public int set close ( ) throw closed channel exception { while ( true ) { int cur bit = status . get ( ) ; if ( ( cur bit & status_closed_mask ) ! = 0 ) { throw new closed channel exception ( ) ; } if ( status . compare and set ( cur bit , cur bit | status_closed_mask ) ) { return cur bit & ( ~status_closed_mask ) ; } } }
public int read line ( text str , int max line length ) throw i o exception { return read line ( str , max line length , integer . max_value ) ; }
public static boolean be native zlib load ( configuration conf ) { return native zlib load & & conf . get boolean ( common configuration key . io_native_lib_available_key , common configuration key . io_native_lib_available_default ) ; }
public progress add phase ( string status ) { progress phase = add phase ( ) ; phase . set status ( status ) ; return phase ; }
public static string print ( final object value ) { if ( value == null ) { return `` null `` ; } if ( value instanceof string ) { return ' `` ' + value . to string ( ) + ' `` ' ; } if ( value instanceof character ) { return print char ( ( character ) value ) ; } if ( value instanceof long ) { return value + `` l `` ; } if ( value instanceof double ) { return value + `` d `` ; } if ( value instanceof float ) { return value + `` f `` ; } if ( value instanceof short ) { return `` ( short ) `` + value ; } if ( value instanceof byte ) { return string . format ( `` ( byte ) 0x % 02x `` , ( byte ) value ) ; } if ( value instanceof map ) { return print map ( ( map < ? , ? > ) value ) ; } if ( value . get class ( ) . be array ( ) ) { return print value ( `` [ `` , `` , `` , `` ] `` , new iterator < object > ( ) { private int current index = 0 ; public boolean have next ( ) { return current index < array . get length ( value ) ; } public object next ( ) { return array . get ( value , current index++ ) ; } public void remove ( ) { throw new unsupported operation exception ( `` can not remove item from an array `` ) ; } } ) ; } if ( value instanceof format text ) { return ( ( ( format text ) value ) . get text ( ) ) ; } return description of ( value ) ; }
public int get exit code ( ) { return this . exit code ; }
public static int find byte ( byte [ ] utf , int start , int end , byte b ) { for ( int i=start ; i < end ; i++ ) { if ( utf [ i ] ==b ) { return i ; } } return -1 ; }
public static string get version ( ) { return common_version_info . _get version ( ) ; }
public void clear quota ( path src ) throw i o exception { dfs . set quota ( src , hdfs constant . quota_reset , hdfs constant . quota_dont_set ) ; }
public void disallow snapshot ( path path ) throw i o exception { dfs . disallow snapshot ( path ) ; }
public long add cache directive ( cache directive info info , enum set < cache flag > flag ) throw i o exception { precondition . check not null ( info . get path ( ) ) ; path path = new path ( get path name ( fix relative part ( info . get path ( ) ) ) ) . make qualified ( get uri ( ) , get work directory ( ) ) ; return dfs . add cache directive ( new cache directive info . builder ( info ) . set path ( path ) . build ( ) , flag ) ; }
public long add cache directive ( cache directive info info , enum set < cache flag > flag ) throw i o exception { precondition . check not null ( info . get path ( ) ) ; path path = new path ( get path name ( fix relative part ( info . get path ( ) ) ) ) . make qualified ( get uri ( ) , get work directory ( ) ) ; return dfs . add cache directive ( new cache directive info . builder ( info ) . set path ( path ) . build ( ) , flag ) ; }
public void add cache pool ( cache pool info info ) throw i o exception { dfs . add cache pool ( info ) ; }
public void add cache pool ( cache pool info info ) throw i o exception { dfs . add cache pool ( info ) ; }
public static input stream wrap system in ( ) { return new keep alive input stream ( system . in ) ; }
public string dump datanode ( ) { string builder buffer = new string builder ( ) ; long c = get capacity ( ) ; long r = get remain ( ) ; long u = get dfs use ( ) ; float use percent = get dfs use percent ( ) ; long cc = get cache capacity ( ) ; long cr = get cache remain ( ) ; long cu = get cache use ( ) ; float cache use percent = get cache use percent ( ) ; buffer . append ( get name ( ) ) ; if ( ! network topology . default_rack . equal ( location ) ) { buffer . append ( `` `` +location ) ; } if ( be decommission ( ) ) { buffer . append ( `` dd `` ) ; } else if ( be decommission in progress ( ) ) { buffer . append ( `` dp `` ) ; } else { buffer . append ( `` in `` ) ; } buffer . append ( `` `` + c + `` ( `` + string utils . byte desc ( c ) + `` ) `` ) ; buffer . append ( `` `` + u + `` ( `` + string utils . byte desc ( u ) + `` ) `` ) ; buffer . append ( `` `` + percent2 string ( used percent ) ) ; buffer . append ( `` `` + r + `` ( `` + string utils . byte desc ( r ) + `` ) `` ) ; buffer . append ( `` `` + cc + `` ( `` + string utils . byte desc ( cc ) + `` ) `` ) ; buffer . append ( `` `` + cu + `` ( `` + string utils . byte desc ( cu ) + `` ) `` ) ; buffer . append ( `` `` + percent2 string ( cache use percent ) ) ; buffer . append ( `` `` + cr + `` ( `` + string utils . byte desc ( cr ) + `` ) `` ) ; buffer . append ( `` `` + new date ( last update ) ) ; return buffer . to string ( ) ; }
public long get file time ( ) { return initial time ; }
public static block location [ ] locate blocks2 location ( locate block block ) { if ( block == null ) { return new block location [ 0 ] ; } return locate blocks2 location ( block . get locate block ( ) ) ; }
public static void write ( final policy policy , final boolean best effort , final configuration conf ) { conf . set boolean ( d f s config key . dfs_client_write_replace_datanode_on_failure_enable_key , policy ! = policy . disable ) ; conf . set ( d f s config key . dfs_client_write_replace_datanode_on_failure_policy_key , policy . name ( ) ) ; conf . set boolean ( d f s config key . dfs_client_write_replace_datanode_on_failure_best_effort_key , best effort ) ; }
public static string value for ( string key ) { configuration conf = instance ( ) ; string val = conf . property . get property ( key ) ; if ( val == null ) { conf . warning ( `` configuration : no value find for key `` + key ) ; } return val ; }
public static http config . policy get http policy ( configuration conf ) { string policy str = conf . get ( d f s config key . dfs_http_policy_key ) ; if ( policy str == null ) { boolean http = conf . get boolean ( d f s config key . dfs_https_enable_key , d f s config key . dfs_https_enable_default ) ; boolean hadoop ssl = conf . get boolean ( common configuration key . hadoop_ssl_enabled_key , common configuration key . hadoop_ssl_enabled_default ) ; if ( hadoop ssl ) { log . warn ( common configuration key . hadoop_ssl_enabled_key + `` be deprecate . please use `` + d f s config key . dfs_http_policy_key + `` . `` ) ; } if ( http ) { log . warn ( d f s config key . dfs_https_enable_key + `` be deprecate . please use `` + d f s config key . dfs_http_policy_key + `` . `` ) ; } return ( hadoop ssl || http ) ? http config . policy . http_and_https : http config . policy . http_only ; } http config . policy policy = http config . policy . from string ( policy str ) ; if ( policy == null ) { throw new hadoop illegal argument exception ( `` unregonized value ' `` + policy str + `` ' for `` + d f s config key . dfs_http_policy_key ) ; } conf . set ( d f s config key . dfs_http_policy_key , policy . name ( ) ) ; return policy ; }
public rest assure config ssl config ( s s l config ssl config ) { not null ( ssl config , `` s s l config `` ) ; return new rest assure config ( conf ( redirect config . class ) , conf ( http client config . class ) , conf ( log config . class ) , conf ( encoder config . class ) , conf ( decoder config . class ) , conf ( session config . class ) , conf ( object mapper config . class ) , conf ( connection config . class ) , conf ( json config . class ) , conf ( xml config . class ) , ssl config , conf ( matcher config . class ) , conf ( header config . class ) , conf ( multi part config . class ) , conf ( param config . class ) , conf ( o auth config . class ) , conf ( failure config . class ) ) ; }
public boolean be in safe mode ( ) throw i o exception { return set safe mode ( safe mode action . safemode_get , true ) ; }
public boolean structure mount ( string pathname ) throw i o exception { return f t p reply . be positive completion ( smnt ( pathname ) ) ; }
public void set block ( block info contiguous [ ] block ) { if ( this . block ! = null ) return ; int num block = 0 ; for ( long s = 0 ; num block < block . length & & s < file size ; num blocks++ ) s += block [ num block ] . get num byte ( ) ; this . block = array . copy of ( block , num block ) ; }
public void set dfs use ( long dfs use ) { this . dfs use = dfs use ; }
public float get dfs use percent ( ) { return d f s util . get percent use ( dfs use , capacity ) ; }
public void set count ( int count ) { this . count = count ; }
public software version get software version ( ) { return software version ; }
public static block metadata header read header ( data input stream in ) throw i o exception { return read header ( in . read short ( ) , in ) ; }
public static void send generic sasl error message ( output stream out , string message ) throw i o exception { send sasl message ( out , data transfer encryptor status . error , null , message ) ; }
public inet address get remote address ( ) { return peer ; }
public boolean have remain ( ) { return remain count ( ) > 0 ; }
public final path get full path ( final path parent ) { if ( be empty local name ( ) ) { return parent ; } return new path ( parent , get local name ( ) ) ; }
public datanode storage info [ ] get expect storage location ( ) { int num location = replicas == null ? 0 : replica . size ( ) ; datanode storage info [ ] storages = new datanode storage info [ num location ] ; for ( int i = 0 ; i < num location ; i++ ) storages [ i ] = replica . get ( i ) . get expected storage location ( ) ; return storage ; }
public configuration builder use parallel executor ( final int available processor ) { thread factory factory = new thread factory builder ( ) . set daemon ( true ) . set name format ( `` org . reflections-scanner- % d `` ) . build ( ) ; set executor service ( executor . new fix thread pool ( available processor , factory ) ) ; return this ; }
public token < block token identifier > generate token ( string user id , extend block block , enum set < access mode > mode ) throw i o exception { block token identifier id = new block token identifier ( user id , block . get block pool id ( ) , block . get block id ( ) , mode ) ; return new token < block token identifier > ( id , this ) ; }
public boolean be complete ( ) { return get block u c state ( ) . equal ( block u c state . complete ) ; }
public int number of node shard be allocate on ( string . . . exclude node ) { set < string > node = new hash set < > ( ) ; for ( index shard rout table shard rout table : this ) { for ( shard rout shard routing : shard rout table ) { if ( shard routing . assign to node ( ) ) { string current node id = shard rout . current node id ( ) ; boolean exclude = false ; if ( excluded node ! = null ) { for ( string exclude node : exclude node ) { if ( current node id . equal ( excluded node ) ) { excluded = true ; break ; } } } if ( excluded == false ) { node . add ( current node id ) ; } } } } return node . size ( ) ; }
public boolean check block report receive ( ) { if ( this . get storage info ( ) . length == 0 ) { return false ; } for ( datanode storage info storage info : this . get storage info ( ) ) { if ( storage info . get block report count ( ) == 0 ) return false ; } return true ; }
public synchronize boolean create storage i d ( storage directory sd , boolean regenerate storage id ) { final string old storage i d = sd . get storage uuid ( ) ; if ( old storage i d == null || regenerate storage id ) { sd . set storage uuid ( datanode storage . generate uuid ( ) ) ; log . info ( `` generate new storage i d `` + sd . get storage uuid ( ) + `` for directory `` + sd . get root ( ) + ( old storage i d == null ? `` `` : ( `` to replace `` + old storage i d ) ) ) ; return true ; } return false ; }
public void read property ( storage directory sd ) throw i o exception { property prop = read property file ( sd . get version file ( ) ) ; set field from property ( prop , sd ) ; }
public random access create buffer ( input stream input ) throw i o exception { scratch file buffer buf = new scratch file buffer ( this ) ; byte [ ] byte buffer = new byte [ 8192 ] ; int bytes read = 0 ; while ( ( bytes read = input . read ( byte buffer ) ) > -1 ) { buf . write ( byte buffer , 0 , byte read ) ; } buf . seek ( 0 ) ; return buf ; }
public void check access ( block token identifier id , string user id , extend block block , access mode mode ) throw invalid token { if ( log . be debug enable ( ) ) { log . debug ( `` check access for user= `` + user id + `` , block= `` + block + `` , access mode= `` + mode + `` use `` + id . to string ( ) ) ; } if ( user id ! = null & & ! user id . equal ( id . get user id ( ) ) ) { throw new invalid token ( `` block token with `` + id . to string ( ) + `` do n't belong to user `` + user id ) ; } if ( ! id . get block pool id ( ) . equal ( block . get block pool id ( ) ) ) { throw new invalid token ( `` block token with `` + id . to string ( ) + `` do n't apply to block `` + block ) ; } if ( id . get block id ( ) ! = block . get block id ( ) ) { throw new invalid token ( `` block token with `` + id . to string ( ) + `` do n't apply to block `` + block ) ; } if ( be expire ( id . get expiry date ( ) ) ) { throw new invalid token ( `` block token with `` + id . to string ( ) + `` be expire . `` ) ; } if ( ! id . get access mode ( ) . contains ( mode ) ) { throw new invalid token ( `` block token with `` + id . to string ( ) + `` do n't have `` + mode + `` permission `` ) ; } }
public static trust channel resolver get instance ( configuration conf ) { class < ? extends trust channel resolver > clazz = conf . get class ( d f s config key . dfs_trustedchannel_resolver_class , trust channel resolver . class , trust channel resolver . class ) ; return reflection utils . new instance ( clazz , conf ) ; }
public string [ ] get failed storage location ( ) { return this . fail storage location ; }
public void sync data out ( ) throw i o exception { if ( data out instanceof file output stream ) { ( ( file output stream ) data out ) . get channel ( ) . force ( true ) ; } }
public file get meta file ( ) { return new file ( get dir ( ) , datanode util . get meta name ( get block name ( ) , get generation stamp ( ) ) ) ; }
public long get memtable reserve size ( ) { return 0 ; }
protect void stop thread ( final thread thread , final long timeout ) { if ( thread ! = null ) { try { if ( timeout == 0 ) { thread . join ( ) ; } else { final long time to wait = timeout + stop_timeout_addition ; final long start time = system . current time millis ( ) ; thread . join ( time to wait ) ; if ( ! ( system . current time millis ( ) < start time + time to wait ) ) { final string msg = `` the stop timeout of `` + timeout + `` m be exceed `` ; catch = new execute exception ( msg , executor . invalid_exitvalue ) ; } } } catch ( final interrupt exception e ) { thread . interrupt ( ) ; } } }
public string get blockpool i d ( ) { return blockpool i d ; }
public void on test skip ( i test result tr ) { m_all test . add ( tr ) ; }
public void close ( ) throw i o exception { if ( propagate close ) { in . close ( ) ; } }
public i node directory get snapshottable root ( final i node in path iip ) throw i o exception { final string path = iip . get path ( ) ; final i node directory dir = i node directory . value of ( iip . get last i node ( ) , path ) ; if ( ! dir . be snapshottable ( ) ) { throw new snapshot exception ( `` directory be not a snapshottable directory : `` + path ) ; } return dir ; }
public void log open file ( string path , i node file new node , boolean overwrite , boolean to log rpc id ) { precondition . check argument ( new node . be under construction ( ) ) ; permission status permission = new node . get permission status ( ) ; add op op = add op . get instance ( cache . get ( ) ) . set inode id ( new node . get id ( ) ) . set path ( path ) . set replication ( new node . get file replication ( ) ) . set modification time ( new node . get modification time ( ) ) . set access time ( new node . get access time ( ) ) . set block size ( new node . get preferred block size ( ) ) . set block ( new node . get block ( ) ) . set permission status ( permission ) . set client name ( new node . get file under construction feature ( ) . get client name ( ) ) . set client machine ( new node . get file under construction feature ( ) . get client machine ( ) ) . set overwrite ( overwrite ) . set storage policy id ( new node . get local storage policy i d ( ) ) ; acl feature f = new node . get acl feature ( ) ; if ( f ! = null ) { op . set acl entry ( acl storage . read i node logical acl ( new node ) ) ; } x attr feature x = new node . get x attr feature ( ) ; if ( x ! = null ) { op . set x attrs ( x . get x attrs ( ) ) ; } log rpc id ( op , to log rpc id ) ; log edit ( op ) ; }
public void prepare to enter state ( final h a context context ) throw service fail exception { }
public synchronize void close ( ) throw i o exception { for ( address rpc proxy pair < t > proxy : proxy ) { if ( proxy . namenode ! = null ) { if ( proxy . namenode instanceof closeable ) { ( ( closeable ) proxy . namenode ) . close ( ) ; } else { rpc . stop proxy ( proxy . namenode ) ; } } } }
public void set use body encode for u r i ( boolean use body encode for u r i ) { this . use body encode for u r i = use body encode for u r i ; set property ( `` use body encode for u r i `` , string . value of ( use body encode for u r i ) ) ; }
public synchronize boolean be exists ( ) { if ( be reference ( ) ) { return ( ( resource ) get check ref ( ) ) . be exists ( ) ; } return be exists ( false ) ; }
public void add space consumed2 cache ( quota count delta ) { usage . add ( delta ) ; }
public i node file to complete file ( long mtime ) { precondition . check state ( be under construction ( ) , `` file be no longer under construction `` ) ; file under construction feature uc = get file under construction feature ( ) ; if ( uc ! = null ) { assert all block complete ( ) ; remove feature ( uc ) ; this . set modification time ( mtime ) ; } return this ; }
public i node directory get snapshottable root ( final i node in path iip ) throw i o exception { final string path = iip . get path ( ) ; final i node directory dir = i node directory . value of ( iip . get last i node ( ) , path ) ; if ( ! dir . be snapshottable ( ) ) { throw new snapshot exception ( `` directory be not a snapshottable directory : `` + path ) ; } return dir ; }
public void stop ( int rc ) { this . result code = rc ; if ( rpc server ! = null ) { rpc server . stop ( ) ; } if ( http server ! = null ) { try { http server . stop ( ) ; } catch ( i o exception ioe ) { log . warn ( `` unable to stop http server for `` + this , ioe ) ; } } for ( journal j : journal by id . value ( ) ) { i o utils . cleanup ( log , j ) ; } if ( journal node info bean name ! = null ) { m bean . unregister ( journal node info bean name ) ; journal node info bean name = null ; } }
public int compare to ( j v m id that ) { int job comp = this . job id . compare to ( that . job id ) ; if ( job comp == 0 ) { if ( this . be map == that . be map ) { return long . value of ( this . jvm id ) . compare to ( that . jvm id ) ; } else { return this . be map ? -1 : 1 ; } } else { return job comp ; } }
public string get description ( ) { if ( description == null ) { description = description . get description ( this ) ; } return description ; }
public void begin phase ( phase phase ) { if ( ! be complete ( ) ) { phase . get ( phase ) . begin time = monotonic now ( ) ; } }
public long get size ( phase phase ) { return phase . get ( phase ) . size ; }
public float get percent complete ( phase phase ) { if ( get status ( phase ) == status . complete ) { return 1 . 0f ; } else { long total = get total ( phase ) ; long count = 0 ; for ( step step : get step ( phase ) ) { count += get count ( phase , step ) ; } return total > 0 ? get bound percent ( 1 . 0f * count / total ) : 0 . 0f ; } }
public static filter < file > to file filter ( final filename filter filter ) { return new filter < file > ( ) { @ override public boolean filter ( file file ) { return filter . accept ( file . get parent file ( ) , file . get name ( ) ) ; } @ override public string to string ( ) { return filter . to string ( ) ; } } ; }
public int save namespace ( ) throw i o exception { int exit code = -1 ; distribute file system dfs = get d f s ( ) ; configuration dfs conf = dfs . get conf ( ) ; uri dfs uri = dfs . get uri ( ) ; boolean be ha enabled = h a util . be logical uri ( dfs conf , dfs uri ) ; if ( be ha enable ) { string ns id = dfs uri . get host ( ) ; list < proxy and info < client protocol > > proxy = h a util . get proxy for all name node in nameservice ( dfs conf , ns id , client protocol . class ) ; for ( proxy and info < client protocol > proxy : proxy ) { proxy . get proxy ( ) . save namespace ( ) ; system . out . println ( `` save namespace successful for `` + proxy . get address ( ) ) ; } } else { dfs . save namespace ( ) ; system . out . println ( `` save namespace successful `` ) ; } exit code = 0 ; return exit code ; }
public void cancel ( string reason ) { cancellable thread . cancel ( reason ) ; recovery target . cancel ( ) ; }
public void undo delete ( final e element , final undo info < e > undo info ) { final int c = undo info . create insertion point ; if ( c > = 0 ) { create . add ( c , undo info . trash ) ; } else { remove ( delete , undo info . delete insertion point , element ) ; } }
public e previous ( ) throw no such element exception { if ( iterator instanceof list iterator ) { @ suppress warning ( `` unchecked `` ) final list iterator < e > li = ( list iterator < e > ) iterator ; return li . previous ( ) ; } if ( current index == 0 ) { throw new no such element exception ( ) ; } remove state = wrap iterator index == current index ; return list . get ( -- current index ) ; }
public void reset ( ) { internal reset ( 0l ) ; }
public boolean acquire ( int capacity ) { if ( capacity < 0 ) { throw new illegal argument exception ( `` capacity to acquire can not be negative `` ) ; } if ( available capacity < 0 ) { return true ; } synchronize ( lock ) { if ( available capacity - capacity > = 0 ) { available capacity -= capacity ; return true ; } else { return false ; } } }
public void put ( final k key , v value ) { manage reference < v > ref = new manage reference < v > ( bundle , value ) { @ override public void finalize reference ( ) { internal map . remove ( key , this ) ; super . finalize reference ( ) ; } } ; internal map . put ( key , ref ) ; }
public ref < t > add all ( refs < t > add ) { list < ref < t > > overlap = new array list < > ( ) ; for ( map . entry < t , ref < t > > e : add . reference . entry set ( ) ) { if ( this . reference . contains key ( e . get key ( ) ) ) overlap . add ( e . get value ( ) ) ; else this . reference . put ( e . get key ( ) , e . get value ( ) ) ; } add . reference . clear ( ) ; release ( overlap ) ; return this ; }
public int size ( ) { if ( fast ) { return ( map . size ( ) ) ; } else { synchronize ( map ) { return ( map . size ( ) ) ; } } }
public static no op create ( scope scope ) { operation builder op builder = scope . graph ( ) . op builder ( `` no op `` , scope . make op name ( `` no op `` ) ) ; return new no op ( op builder . build ( ) ) ; }
public path get output index file ( ) throw i o exception { path attempt index output = new path ( get attempt output dir ( ) , map_output_filename_string + map_output_index_suffix_string ) ; return l dir alloc . get local path to read ( attempt index output . to string ( ) , conf ) ; }
protect void start job ( ) { / * * create a job-start event to get this ball roll * / job event start job event = new job start event ( job . get i d ( ) , recover job start time ) ; / * * send the job-start event . this trigger the job execution . * / dispatcher . get event handler ( ) . handle ( start job event ) ; }
public collection < task attempt i d > get run task attempt ( ) { collection < task attempt i d > attempt = new array list < task attempt i d > ( ) ; for ( org . apache . hadoop . mapreduce . task attempt i d id : super . get run task attempt id ( ) ) { attempt . add ( task attempt i d . downgrade ( id ) ) ; } return attempt ; }
@ override protected class < ? extend sub view > content ( ) { return conf block . class ; }
public u r l class loader get user class loader ( class loader parent ) { return new u r l class loader ( classpaths . to array ( new url [ classpaths . size ( ) ] ) , parent ) ; }
public int get expiry scan interval ( ) { return expiry scan interval ; }
public int get num reduce task ( ) { return get int ( job context . num_reduces , 1 ) ; }
public string get job name ( ) { if ( state == job state . define ) { return super . get job name ( ) ; } ensure state ( job state . run ) ; return status . get job name ( ) ; }
public synchronize void incr all counter ( counter other ) { for ( group other group : other ) { group group = get group ( other group . get name ( ) ) ; group . set display name ( other group . get display name ( ) ) ; for ( counter other counter : other group ) { counter counter = group . get counter for name ( other counter . get name ( ) ) ; counter . set display name ( other counter . get display name ( ) ) ; counter . increment ( other counter . get value ( ) ) ; } } }
public double put ( final int key , final double value ) { int index = find insertion index ( key ) ; double previous = miss entry ; boolean new map = true ; if ( index < 0 ) { index = change index sign ( index ) ; previous = value [ index ] ; new mapping = false ; } key [ index ] = key ; state [ index ] = full ; value [ index ] = value ; if ( new mapping ) { ++size ; if ( should grow table ( ) ) { grow table ( ) ; } ++count ; } return previous ; }
public long skip ( long n ) { if ( position+n < =document . get length ( ) ) { position += n ; return n ; } long temp = position ; position = document . get length ( ) ; return document . get length ( ) - temp ; }
public static void add cache file ( uri uri , configuration conf ) { string file = conf . get ( m r job config . cache_files ) ; conf . set ( m r job config . cache_files , file == null ? uri . to string ( ) : file + `` , `` + uri . to string ( ) ) ; }
public final synchronize void close ( ) throw i o exception { commit ( ) ; do close ( ) ; if ( close directory ) directory . close ( ) ; }
public void set task output filter ( task status filter new value ) { this . task output filter = new value ; }
public void set jar ( string jar ) { ensure state ( job state . define ) ; conf . set jar ( jar ) ; }
public void set work directory ( path dir ) { dir = new path ( get work directory ( ) , dir ) ; set ( job context . working_dir , dir . to string ( ) ) ; }
public int get num map task ( ) { return get int ( job context . num_maps , 1 ) ; }
public void set session id ( string session id ) { set ( `` session . id `` , session id ) ; }
public void set max reduce task failure percent ( int percent ) { set int ( job context . reduce_failures_maxpercent , percent ) ; }
public void set queue name ( string queue name ) { set ( job context . queue_name , queue name ) ; }
public job i d get job i d ( ) { return task id . get job i d ( ) ; }
public string get job name ( ) { if ( state == job state . define ) { return super . get job name ( ) ; } ensure state ( job state . run ) ; return status . get job name ( ) ; }
public static void sort split ( input split [ ] split ) { array . sort ( split , new comparator < input split > ( ) { @ override public int compare ( input split a , input split b ) { try { long leave = a . get length ( ) ; long right = b . get length ( ) ; if ( leave == right ) { return 0 ; } else if ( leave < right ) { return 1 ; } else { return -1 ; } } catch ( i o exception ie ) { throw new illegal state exception ( `` problem get input split size `` , ie ) ; } catch ( interrupted exception ie ) { throw new illegal state exception ( `` problem get input split size `` , ie ) ; } } } ) ; }
protect string [ ] get spring config location ( ) { string [ ] location = get standard config location ( ) ; for ( int i = 0 ; i < location . length ; i++ ) { string extension = string utils . get filename extension ( location [ i ] ) ; location [ i ] = location [ i ] . substring ( 0 , location [ i ] . length ( ) - extension . length ( ) - 1 ) + `` -spring . `` + extension ; } return location ; }
public boolean next ( k key , tuple writable value ) throw i o exception { if ( jc . flush ( value ) ) { writable utils . clone into ( key , jc . key ( ) ) ; return true ; } jc . clear ( ) ; k iterkey = create key ( ) ; final priority queue < composable record reader < k , ? > > q = get record reader queue ( ) ; while ( ! q . be empty ( ) ) { fill join collector ( iterkey ) ; jc . reset ( iterkey ) ; if ( jc . flush ( value ) ) { writable utils . clone into ( key , jc . key ( ) ) ; return true ; } jc . clear ( ) ; } return false ; }
public static metadata clone metadata ( metadata m ) { metadata clone = new metadata ( ) ; for ( string n : m . name ( ) ) { if ( ! m . be multi value ( n ) ) { clone . set ( n , m . get ( n ) ) ; } else { string [ ] vals = m . get value ( n ) ; for ( int i = 0 ; i < vals . length ; i++ ) { clone . add ( n , vals [ i ] ) ; } } } return clone ; }
public float get progress ( ) throw i o exception { float ret = 1 . 0f ; for ( record reader < k , ? extend writable > rr : kid ) { ret = math . min ( ret , rr . get progress ( ) ) ; } return ret ; }
public boolean have next ( ) { return jc . have next ( ) || ! q . be empty ( ) ; }
public k create key ( ) { return rr . create key ( ) ; }
public static job conf create value aggregator job ( string args [ ] ) throw i o exception { return create value aggregator job ( args , value aggregator . class ) ; }
public list < object mapper > get nested mapper ( ) { list < object mapper > child mapper = new array list < > ( ) ; for ( object mapper mapper : object mapper ( ) . value ( ) ) { if ( mapper . nest ( ) . be nested ( ) == false ) { continue ; } child mapper . add ( mapper ) ; } return child mapper ; }
public void close ( ) throw i o exception { for ( factory writer factory writer : factory writer ) { factory writer . close ( ) ; } }
public void close ( ) throw i o exception { if ( propagate close ) { in . close ( ) ; } }
public void set status ( string status ) { set status string ( status ) ; reporter . set status ( status ) ; }
public static void set be java record reader ( job conf conf , boolean value ) { conf . set boolean ( submitter . is_java_rr , value ) ; }
public static < e > queue < e > synchronize queue ( final queue < e > queue ) { return synchronize queue . synchronize queue ( queue ) ; }
public void add file to class path ( path file ) throw i o exception { ensure state ( job state . define ) ; distribute cache . add file to class path ( file , conf , file . get file system ( conf ) ) ; }
public byte [ ] get encrypt spill key ( ) { return encrypt spill key ; }
protect void fill basic stats ( basic stats stats , collection statistic collection stats , term statistic term stats ) { super . fill basic stats ( stats , collection stats , term stats ) ; l m stats lm stats = ( l m stats ) stats ; lm stats . set collection probability ( collection model . compute probability ( stats ) ) ; }
public job i d get job id ( ) { return job i d . for name ( datum . jobid . to string ( ) ) ; }
public static task i d downgrade ( org . apache . hadoop . mapreduce . task i d old ) { if ( old instanceof task i d ) { return ( task i d ) old ; } else { return new task i d ( job i d . downgrade ( old . get job i d ( ) ) , old . get task type ( ) , old . get id ( ) ) ; } }
public sort range . range get next record range ( ) { return next record range ; }
public long get finish time ( ) { return finish time ; }
public long start time ( ) { return start time ; }
public long get size ( phase phase ) { return phase . get ( phase ) . size ; }
public long get max output buffer size ( ) { return max output buffer size ; }
public task attempt i d get fail attempt i d ( ) { return fail due to attempt ; }
public static input stream wrap if necessary ( configuration conf , input stream in , long length ) throw i o exception { if ( be encrypt spill enable ( conf ) ) { int buffer size = get buffer size ( conf ) ; if ( length > -1 ) { in = new limit input stream ( in , length ) ; } byte [ ] offset array = new byte [ 8 ] ; i o utils . read fully ( in , offset array , 0 , 8 ) ; long offset = byte buffer . wrap ( offset array ) . get long ( ) ; crypto codec crypto codec = crypto codec . get instance ( conf ) ; byte [ ] iv = new byte [ crypto codec . get cipher suite ( ) . get algorithm block size ( ) ] ; i o utils . read fully ( in , iv , 0 , crypto codec . get cipher suite ( ) . get algorithm block size ( ) ) ; if ( log . be debug enable ( ) ) { log . debug ( `` iv read from [ `` + base64 . encode base64 u r l safe string ( iv ) + `` ] `` ) ; } return new crypto input stream ( in , crypto codec , buffer size , get encryption key ( ) , iv , offset + crypto padding ( conf ) ) ; } else { return in ; } }
public static void add cache file ( uri uri , configuration conf ) { string file = conf . get ( m r job config . cache_files ) ; conf . set ( m r job config . cache_files , file == null ? uri . to string ( ) : file + `` , `` + uri . to string ( ) ) ; }
public static path [ ] get file class path ( configuration conf ) { array list < string > list = ( array list < string > ) conf . get string collection ( m r job config . classpath_files ) ; if ( list . size ( ) == 0 ) { return null ; } path [ ] path = new path [ list . size ( ) ] ; for ( int i = 0 ; i < list . size ( ) ; i++ ) { paths [ i ] = new path ( list . get ( i ) ) ; } return path ; }
public location info get location information ( ) { if ( location info == null ) { location info = new location info ( new throwable ( ) , fqn of category class ) ; } return location info ; }
public string get job name ( ) { if ( state == job state . define ) { return super . get job name ( ) ; } ensure state ( job state . run ) ; return status . get job name ( ) ; }
public boolean be complete ( ) throw i o exception { ensure state ( job state . run ) ; update status ( ) ; return status . be job complete ( ) ; }
public void kill task ( final task attempt i d task id ) throw i o exception { kill task ( task id , false ) ; }
public void kill job ( ) throw i o exception { ensure state ( job state . run ) ; try { cluster . get client ( ) . kill job ( get job i d ( ) ) ; } catch ( interrupted exception ie ) { throw new i o exception ( ie ) ; } }
public void print ( ) throw i o exception { print job detail ( ) ; print task summary ( ) ; print job analysis ( ) ; print task ( task type . job_setup , task status . state . fail . to string ( ) ) ; print task ( task type . job_setup , task status . state . kill . to string ( ) ) ; print task ( task type . map , task status . state . fail . to string ( ) ) ; print task ( task type . map , task status . state . kill . to string ( ) ) ; print task ( task type . reduce , task status . state . fail . to string ( ) ) ; print task ( task type . reduce , task status . state . kill . to string ( ) ) ; print task ( task type . job_cleanup , task status . state . fail . to string ( ) ) ; print task ( task type . job_cleanup , job status . get job run state ( job status . kill ) ) ; if ( print all ) { print task ( task type . job_setup , task status . state . succeed . to string ( ) ) ; print task ( task type . map , task status . state . succeed . to string ( ) ) ; print task ( task type . reduce , task status . state . succeed . to string ( ) ) ; print task ( task type . job_cleanup , task status . state . succeed . to string ( ) ) ; print all task attempt ( task type . job_setup ) ; print all task attempt ( task type . map ) ; print all task attempt ( task type . reduce ) ; print all task attempt ( task type . job_cleanup ) ; } filter job filter = new filter job ( job , task status . state . fail . to string ( ) ) ; print fail attempt ( filter ) ; filter = new filter job ( job , task status . state . kill . to string ( ) ) ; print fail attempt ( filter ) ; }
public static void set default poll interval ( long poll interval , time unit unit ) { default poll interval = new duration ( poll interval , unit ) ; }
public job i d get job id ( ) { return job i d . for name ( datum . jobid . to string ( ) ) ; }
public string get status ( ) { return datum . get job status ( ) . to string ( ) ; }
public boolean be valid data ( object datum ) { precondition . check not null ( datum ) ; return validator . apply ( datum ) ; }
public string get workflow adjacency ( ) { if ( datum . workflow adjacency ! = null ) { return datum . workflow adjacency . to string ( ) ; } return null ; }
public long get shuffle finish time ( ) { return 0 ; }
public static i operation history get operation history ( ) { if ( operation history == null ) { operation history = new default operation history ( ) ; } return operation history ; }
public static path get job conf path ( path job submit dir ) { return new path ( job submit dir , `` job . xml `` ) ; }
public static path get job dist cache archive ( path job submit dir ) { return new path ( job submit dir , `` archive `` ) ; }
protect void set min split size rack ( long min split size rack ) { this . min split size rack = min split size rack ; }
protect void set min split size rack ( long min split size rack ) { this . min split size rack = min split size rack ; }
public list iterator list iterator ( final int index ) { return new list iterator ( ) { list iterator i = underlie . list iterator ( index ) ; public boolean have next ( ) { return i . have next ( ) ; } public object next ( ) { return i . next ( ) ; } public boolean have previous ( ) { return i . have previous ( ) ; } public object previous ( ) { return i . previous ( ) ; } public int next index ( ) { return i . next index ( ) ; } public int previous index ( ) { return i . previous index ( ) ; } public void remove ( ) { throw new unsupported operation exception ( ) ; } public void set ( object o ) { throw new unsupported operation exception ( ) ; } public void add ( object o ) { throw new unsupported operation exception ( ) ; } } ; }
public void setup job ( job context context ) throw i o exception { if ( have output path ( ) ) { path job attempt path = get job attempt path ( context ) ; file system fs = job attempt path . get file system ( context . get configuration ( ) ) ; if ( ! f . mkdirs ( job attempt path ) ) { log . error ( `` mkdirs fail to create `` + job attempt path ) ; } } else { log . warn ( `` output path be null in setup job ( ) `` ) ; } }
protect static void set output name ( job context job , string name ) { job . get configuration ( ) . set ( base_output_name , name ) ; }
public static string canonical property name ( string property name ) { if ( property name == null ) { return `` `` ; } string builder sb = new string builder ( property name ) ; int search index = 0 ; while ( search index ! = -1 ) { int key start = sb . index of ( property accessor . property_key_prefix , search index ) ; search index = -1 ; if ( key start ! = -1 ) { int key end = sb . index of ( property accessor . property_key_suffix , key start + property accessor . property_key_prefix . length ( ) ) ; if ( key end ! = -1 ) { string key = sb . substring ( key start + property accessor . property_key_prefix . length ( ) , key end ) ; if ( ( key . start with ( `` ' `` ) & & key . end with ( `` ' `` ) ) || ( key . start with ( `` \ `` `` ) & & key . end with ( `` \ `` `` ) ) ) { sb . delete ( key start + 1 , key start + 2 ) ; sb . delete ( key end - 2 , key end - 1 ) ; key end = key end - 2 ; } search index = key end + property accessor . property_key_suffix . length ( ) ; } } } return sb . to string ( ) ; }
public static boolean [ ] get archive visibility ( configuration conf ) { return parse booleans ( conf . get string ( m r job config . cache_archives_visibilities ) ) ; }
public job i d get job i d ( ) { return task id . get job i d ( ) ; }
public path [ ] get local cache archive ( ) throw i o exception { return distribute cache . get local cache archive ( conf ) ; }
public synchronize void on transport idle ( ) { if ( keep alive during transport idle ) { return ; } if ( state == state . ping_scheduled || state == state . ping_delayed ) { state = state . idle ; } if ( state == state . ping_sent ) { state = state . idle_and_ping_sent ; } }
public task attempt i d get successful task attempt ( ) { return task attempt i d . downgrade ( super . get successful task attempt id ( ) ) ; }
public task type get task type ( ) { return task type ; }
public float get progress ( ) { return progress value ; }
public static counter sum ( counter a , counter b ) { counter counter = new counter ( ) ; counter . incr all counter ( a ) ; counter . incr all counter ( b ) ; return counter ; }
public static void kill process ( string pid ) { maybe signal process ( pid , sigkill , sigkill_str , false ) ; }
public static boolean be process group alive ( string pgrp id ) { shell command executor shexec = null ; try { string [ ] args = { `` kill `` , `` -0 `` , `` - `` +pgrp id } ; shexec = new shell command executor ( args ) ; shexec . execute ( ) ; } catch ( exit code exception ee ) { return false ; } catch ( i o exception ioe ) { log . warn ( `` error execute shell command `` + shexec . to string ( ) + ioe ) ; return false ; } return ( shexec . get exit code ( ) == 0 ? true : false ) ; }
public static codec reader unwrap ( codec reader reader ) { while ( reader instanceof filter codec reader ) { reader = ( ( filter codec reader ) reader ) . get delegate ( ) ; } return reader ; }
public void add domain ( list < timeline domain > domains ) { this . domain . add all ( domain ) ; }
public boolean user match ( authenticate user user , string principal ) { if ( user == null ) return principal == null ; if ( user instanceof servlet authenticate user ) { servlet authenticate user servlet user = ( servlet authenticate user ) user ; return servlet user . get request ( ) . be user in role ( principal ) ; } return false ; }
public h s s f client anchor create client anchor ( ) { return new h s s f client anchor ( ) ; }
public static token get n m token ( string node addr ) { return nm_token_cache . get token ( node addr ) ; }
public static n m client create n m client ( ) { n m client client = new n m client impl ( ) ; return client ; }
public static boolean be h a enabled ( configuration conf ) { return conf . get boolean ( yarn configuration . rm_ha_enabled , yarn configuration . default_rm_ha_enabled ) ; }
protect void service init ( configuration conf ) throw exception { if ( conf ! = config ) { log . debug ( `` config have be override during init `` ) ; set config ( conf ) ; } }
public static string to protocol host and port ( string url ) { try { url u = new url ( url ) ; string path = u . get path ( ) ; if ( path ! = null & & ! `` `` . equal ( path ) & & ! path . end with ( `` / `` ) ) { log . warning ( `` it look like your base url ( `` + url + `` ) be point to a file , not a directory ( it do n't end with a / ) . we 're go to have to strip off the last part of the pathname . `` ) ; } return u . get protocol ( ) + `` : // `` + u . get authority ( ) ; } catch ( malformed u r l exception e ) { throw new runtime exception ( e ) ; } }
public static string join ( object . . . args ) { return joiner . join ( args ) ; }
public static iterable < string > split ( char sequence s ) { return ssv_splitter . split ( s ) ; }
public static string get date ( ) { return common_version_info . _get date ( ) ; }
public static string get user ( ) { return common_version_info . _get user ( ) ; }
public static string get url ( ) { return common_version_info . _get url ( ) ; }
public boolean be auto resize ( ) { return auto resize ; }
public void copy into ( final abstract histogram target histogram ) { target histogram . reset ( ) ; target histogram . add ( this ) ; target histogram . set start time stamp ( this . start time stamp msec ) ; target histogram . set end time stamp ( this . end time stamp msec ) ; }
public void shift value leave ( final int number of binary order of magnitude ) { shift value leave ( number of binary order of magnitude , integer to double value conversion ratio ) ; }
public double histogram copy ( ) { final double histogram target histogram = new double histogram ( configured high to lowest value ratio , get number of significant value digit ( ) ) ; target histogram . set trackable value range ( current low value in auto range , current high value limit in auto range ) ; integer value histogram . copy into ( target histogram . integer value histogram ) ; return target histogram ; }
public synchronize double histogram get interval histogram ( ) { return get interval histogram ( null ) ; }
public encodable histogram next interval histogram ( final double start time sec , final double end time sec ) { return next interval histogram ( start time sec , end time sec , false ) ; }
public encodable histogram next interval histogram ( final double start time sec , final double end time sec ) { return next interval histogram ( start time sec , end time sec , false ) ; }
public static void log level ( string level ) { if ( ! arrays . a list ( `` trace `` , `` debug `` , `` info `` , `` warn `` , `` error `` , `` off `` ) . contains ( level ) ) { throw new illegal argument exception ( `` log level \ `` `` + level + `` \ `` be not legal it must be one of \ `` trace\ `` , \ `` debug\ `` , \ `` info\ `` , \ `` warn\ `` , \ `` error\ `` , \ `` off\ `` `` ) ; } system . set property ( mockserver_log_level , level ) ; mock server logger . initialise log level ( ) ; }
public void set end time stamp ( final long time stamp msec ) { this . end time stamp msec = time stamp msec ; }
public int get ( duration field type type ) { int index = index of ( type ) ; if ( index == -1 ) { return 0 ; } return get value ( index ) ; }
public void record value ( final double value ) { long critical value at enter = record phaser . writer critical section enter ( ) ; try { active histogram . record value ( value ) ; } finally { record phaser . writer critical section exit ( critical value at enter ) ; } }
public metadata source add resource ( string name ) { get xml binding for write ( ) . add ( get xml map binder access ( ) . bind ( name ) ) ; return this ; }
public static attribute type descriptor resolve ( ct class manage ct class , ct field persistent field ) throw not find exception { boolean inherit = ! manage ct class . equal ( persistent field . get declare class ( ) ) ; boolean visible = persistent field . visible from ( manage ct class ) ; string reader name = enhancer constant . persistent_field_reader_prefix + persistent field . get name ( ) ; string writer name = enhancer constant . persistent_field_writer_prefix + persistent field . get name ( ) ; inheritance metadata inheritance metadata = new inheritance metadata ( inherit , visible , reader name , writer name ) ; if ( ct class . boolean type . equal ( persistent field . get type ( ) ) ) { return new primitive attribute type descriptor ( inheritance metadata , boolean . type ) ; } else if ( ct class . byte type . equal ( persistent field . get type ( ) ) ) { return new primitive attribute type descriptor ( inheritance metadata , byte . type ) ; } else if ( ct class . char type . equal ( persistent field . get type ( ) ) ) { return new primitive attribute type descriptor ( inheritance metadata , character . type ) ; } else if ( ct class . short type . equal ( persistent field . get type ( ) ) ) { return new primitive attribute type descriptor ( inheritance metadata , short . type ) ; } else if ( ct class . int type . equal ( persistent field . get type ( ) ) ) { return new primitive attribute type descriptor ( inheritance metadata , integer . type ) ; } else if ( ct class . long type . equal ( persistent field . get type ( ) ) ) { return new primitive attribute type descriptor ( inheritance metadata , long . type ) ; } else if ( ct class . double type . equal ( persistent field . get type ( ) ) ) { return new primitive attribute type descriptor ( inheritance metadata , double . type ) ; } else if ( ct class . float type . equal ( persistent field . get type ( ) ) ) { return new primitive attribute type descriptor ( inheritance metadata , float . type ) ; } else { return new object attribute type descriptor ( inheritance metadata , persistent field . get type ( ) ) ; } }
public temporal type get map key temporal ( ) { return map key temporal ; }
public synchronize void set convert value ( object value ) { this . convert = true ; this . convert value = value ; }
public void set cascade persist ( jaxb empty type value ) { this . cascade persist = value ; }
public jaxb empty type get cascade detach ( ) { return cascade detach ; }
public string get unique constraint schema ( ) { return unique constraint schema ; }
public boolean be updatable result ( ) { return this . updatable result ; }
public column definition get view column ( column definition base column ) { return definition . metadata . get column definition ( base column . name ) ; }
public name converter get name converter ( ) { return model . get name converter ( ) ; }
public void set enum converter ( boolean value ) { this . enum converter = value ; }
public temporal type get map key temporal ( ) { return map key temporal ; }
public list < jaxb attribute override > get attribute override ( ) { if ( attribute override == null ) { attribute override = new array list < jaxb attribute override > ( ) ; } return this . attribute override ; }
public jaxb collection table get collection table ( ) { return collection table ; }
public object get type id ( ) { if ( get class ( ) == simple module . class ) { return null ; } return super . get type id ( ) ; }
public void set id ( jaxb hbm simple id type value ) { this . id = value ; }
public list < jaxb entity listener > get entity listener ( ) { if ( entity listener == null ) { entity listener = new array list < jaxb entity listener > ( ) ; } return this . entity listener ; }
public generation type get strategy ( ) { return strategy ; }
public list < column > get column ( ) { return column ; }
public void set procedure name ( @ nullable string procedure name ) { this . procedure name = procedure name ; }
public void set method name ( string method name ) { this . method name = method name ; }
public integer get allocation size ( ) { return allocation size ; }
public void set pk column value ( string value ) { this . pk column value = value ; }
protect identifier get identifier ( string name , boolean quote , jdbc environment jdbc environment ) { if ( be case insensitive ( jdbc environment ) ) { name = name . to lower case ( locale . root ) ; } return new identifier ( name , quote ) ; }
public static void bitandorxornot_bin and or xor not ( query engine query engine ) { query engine . get sqm function registry ( ) . name descriptor builder ( `` bin_and `` ) . set min argument count ( 1 ) . register ( ) ; query engine . get sqm function registry ( ) . register alternate key ( `` bitand `` , `` bin_and `` ) ; query engine . get sqm function registry ( ) . name descriptor builder ( `` bin_or `` ) . set min argument count ( 1 ) . register ( ) ; query engine . get sqm function registry ( ) . register alternate key ( `` bitor `` , `` bin_or `` ) ; query engine . get sqm function registry ( ) . name descriptor builder ( `` bin_xor `` ) . set min argument count ( 1 ) . register ( ) ; query engine . get sqm function registry ( ) . register alternate key ( `` bitxor `` , `` bin_xor `` ) ; query engine . get sqm function registry ( ) . name descriptor builder ( `` bin_not `` ) . set exact argument count ( 1 ) . register ( ) ; query engine . get sqm function registry ( ) . register alternate key ( `` bitnot `` , `` bin_not `` ) ; }
public static void every any_sum case ( query engine query engine ) { query engine . get sqm function registry ( ) . register ( `` every `` , new every any emulation ( query engine . get type configuration ( ) , true ) ) ; query engine . get sqm function registry ( ) . register ( `` any `` , new every any emulation ( query engine . get type configuration ( ) , false ) ) ; }
public static void locate_position substring ( query engine query engine ) { query engine . get sqm function registry ( ) . register binary ternary pattern ( `` locate `` , query engine . get type configuration ( ) . get basic type registry ( ) . resolve ( standard basic type . integer ) , `` position ( ? 1 in ? 2 ) `` , `` ( position ( ? 1 in substring ( ? 2 from ? 3 ) ) + ? 3 ) `` ) . set argument list signature ( `` ( pattern , string [ , start ] ) `` ) ; }
public static void format_date format ( query engine query engine ) { query engine . get sqm function registry ( ) . name descriptor builder ( `` format `` , `` date_format `` ) . set invariant type ( query engine . get type configuration ( ) . get basic type registry ( ) . resolve ( standard basic type . string ) ) . set exact argument count ( 2 ) . set argument list signature ( `` ( datetime a pattern ) `` ) . register ( ) ; }
public boolean bind limit parameter first ( ) { return false ; }
protect static pattern match pattern ( string string , list < pattern > pattern ) { for ( pattern p : pattern ) { if ( p . matcher ( string ) . match ( ) ) { return p ; } } return null ; }
public static < t > t coalesce ( t . . . value ) { if ( value == null ) { return null ; } for ( t value : value ) { if ( value ! = null ) { if ( string . class . be instance ( value ) ) { if ( ! ( ( string ) value ) . be empty ( ) ) { return value ; } } else { return value ; } } } return null ; }
public shutdown callback registry get shutdown callback registry ( ) { return shutdown callback registry ; }
public entity persister get entity descriptor ( string entity name ) { final entity persister entity persister = entity persister map . get ( entity name ) ; if ( entity persister == null ) { throw new illegal argument exception ( `` unable to locate persister : `` + entity name ) ; } return entity persister ; }
public name function descriptor builder name aggregate descriptor builder ( string registration key , string name ) { return new name function descriptor builder ( this , registration key , function kind . aggregate , name ) ; }
public name function descriptor builder name aggregate descriptor builder ( string registration key , string name ) { return new name function descriptor builder ( this , registration key , function kind . aggregate , name ) ; }
public sqm function descriptor register pattern ( string name , string pattern , basic type return type ) { return pattern descriptor builder ( name , pattern ) . set invariant type ( return type ) . register ( ) ; }
public name function descriptor builder name aggregate descriptor builder ( string name ) { return name aggregate descriptor builder ( name , name ) ; }
public name function descriptor builder name aggregate descriptor builder ( string registration key , string name ) { return new name function descriptor builder ( this , registration key , function kind . aggregate , name ) ; }
public static object generate key ( object . . . params ) { if ( params . length == 0 ) { return simple key . empty ; } if ( params . length == 1 ) { object param = params [ 0 ] ; if ( param ! = null & & ! param . get class ( ) . be array ( ) ) { return param ; } } return new simple key ( params ) ; }
public foreign key direction get foreign key type ( ) { return foreign key type ; }
public void set inverse foreign key ( jaxb foreign key value ) { this . inverse foreign key = value ; }
public boolean be valid ( char sequence char sequence , constraint validator context constraint validator context ) { if ( char sequence == null ) { return true ; } int length = char sequence . length ( ) ; return length > = min & & length < = max ; }
public int get line number ( ) { if ( ( current token ! = null ) & & ( current token . next ! = null ) ) { return current token . next . begin line ; } else if ( current token ! = null ) { return current token . begin line ; } else { return -1 ; } }
public static < t > list < class < ? super t > > get hierarchy ( class < t > clazz , filter . . . filter ) { contract . assert not null ( clazz ) ; list < class < ? super t > > class = new array list ( ) ; list < filter > all filter = new array list ( ) ; all filter . add all ( array . a list ( filter ) ) ; all filter . add ( filter . exclude proxy ( ) ) ; get hierarchy ( clazz , class , all filter ) ; return class ; }
public synchronize static validator get validator ( ) { if ( validator == null ) { validator = access controller . do privilege ( new privilege action < validator > ( ) { @ override public validator run ( ) { return initialize validator ( ) ; } } ) ; } if ( validator == null ) { throw new illegal state exception ( `` could not find a javax . validator `` ) ; } return validator ; }
public v put ( byte key , v value ) { byte k ; if ( key == null ) { k = _map . get no entry key ( ) ; } else { k = unwrap key ( key ) ; } return _map . put ( k , value ) ; }
public void clear ( ) { this . _map . clear ( ) ; }
public int hash code ( ) { return ( get leave ( ) == null ? 0 : get leave ( ) . hash code ( ) ) ^ ( get middle ( ) == null ? 0 : get middle ( ) . hash code ( ) ) ^ ( get right ( ) == null ? 0 : get right ( ) . hash code ( ) ) ; }
public boolean contains key ( string key ) { if ( key == null ) { return false ; } boolean exists = internal contains key ( key ) ; if ( ! exist & & inner context ! = null ) { exist = inner context . contains key ( key ) ; } return exists ; }
public static metric registry get default ( ) { metric registry metric registry = try get default ( ) ; if ( metric registry == null ) { throw new illegal state exception ( `` default registry name have not be set . `` ) ; } return metric registry ; }
public long get max value ( sequence sequence , session session ) { if ( max value == value expression . get null ( ) & & sequence ! = null ) { return sequence . get default max value ( get current start ( sequence , session ) , increment ! = null ? get increment ( session ) : sequence . get increment ( ) ) ; } return get long ( session , max value ) ; }
public void set isolate internal query ( boolean isolate ) { check if seal ( ) ; this . be isolate internal query = isolate ; }
public static long pop_union ( long [ ] arr1 , long [ ] arr2 , int word offset , int num word ) { long pop count = 0 ; for ( int i = word offset , end = word offset + num word ; i < end ; ++i ) { pop count += long . bit count ( arr1 [ i ] | arr2 [ i ] ) ; } return pop count ; }
public void add ( byte e1 , byte e2 ) { ensure buffer space ( 2 ) ; buffer [ element count++ ] = e1 ; buffer [ element count++ ] = e2 ; }
public boolean put if absent ( char key , byte value ) { if ( ! contains key ( key ) ) { put ( key , value ) ; return true ; } else { return false ; } }
public void push ( char e1 , char e2 , char e3 ) { ensure buffer space ( 3 ) ; buffer [ element count++ ] = e1 ; buffer [ element count++ ] = e2 ; buffer [ element count++ ] = e3 ; }
public void push ( int e1 , int e2 , int e3 , int e4 ) { ensure buffer space ( 4 ) ; buffer [ element count++ ] = e1 ; buffer [ element count++ ] = e2 ; buffer [ element count++ ] = e3 ; buffer [ element count++ ] = e4 ; }
protect double verify load factor ( double load factor ) { check load factor ( load factor , min_load_factor , max_load_factor ) ; return load factor ; }
public void set entity resolver ( entity resolver entity resolver ) { this . entity resolver = entity resolver ; }
public boolean be absolute ( ) { return ( flags & has_leading ) ! = 0 ; }
public static string from byte ( byte [ ] bytes ) throw i o exception { data input buffer dbuf = new data input buffer ( ) ; dbuf . reset ( byte , 0 , byte . length ) ; string builder buf = new string builder ( byte . length ) ; read char ( dbuf , buf , byte . length ) ; return buf . to string ( ) ; }
public final boolean be need to write ( ) { return need to write ; }
public result matcher encoding ( string character encode ) { return result - > { string actual = result . get response ( ) . get character encoding ( ) ; assert equal ( `` character encode `` , character encoding , actual ) ; } ; }
public static trace scope start span ( string description ) { return start span ( description , true if trace sampler . instance ) ; }
protect resource lsl to resource ( string file , string response line ) { if ( response line == null || response line . start with ( `` ls `` ) ) { return new basic resource ( file , false , 0 , 0 , false ) ; } else { string [ ] part = response line . split ( `` \\s+ `` ) ; if ( part . length ! = ls_parts_number ) { message . debug ( `` unrecognized ls format : `` + response line ) ; return new basic resource ( file , false , 0 , 0 , false ) ; } else { try { long content length = long . parse long ( part [ ls_size_index ] ) ; string date = part [ ls_date_index1 ] + `` `` + part [ ls_date_index2 ] + `` `` + part [ ls_date_index3 ] + `` `` + part [ ls_date_index4 ] ; return new basic resource ( file , true , content length , format . parse ( date ) . get time ( ) , false ) ; } catch ( exception ex ) { message . warn ( `` impossible to parse server response : `` + response line + `` : `` + ex ) ; return new basic resource ( file , false , 0 , 0 , false ) ; } } } }
public boolean be write limit reach ( throwable t ) { if ( t instanceof write limit reach exception ) { return tag . equal ( ( ( write limit reach exception ) t ) . tag ) ; } else { return t . get cause ( ) ! = null & & be write limit reach ( t . get cause ( ) ) ; } }
public void set max cache entry ( final int max cache entry ) { this . max cache entry = max cache entry ; }
public void set share cache mode ( share cache mode share cache mode ) { this . share cache mode = share cache mode ; }
public int get asynchronous worker idle lifetime sec ( ) { return asynchronous worker idle lifetime sec ; }
public static void reset request ( ) { request scoped collapsers . clear ( ) ; }
public field access expr set scope ( final expression scope ) { assert not null ( scope ) ; if ( scope == this . scope ) { return this ; } notify property change ( observable property . scope , this . scope , scope ) ; if ( this . scope ! = null ) this . scope . set parent node ( null ) ; this . scope = scope ; set a parent node of ( scope ) ; return this ; }
public static double get mb per sec ( thread thread , merge policy . one merge merge ) { if ( thread instanceof concurrent merge scheduler . merge thread ) { return ( ( concurrent merge scheduler . merge thread ) thread ) . rate limiter . get m b per sec ( ) ; } assert false : `` this be not merge thread `` ; return double . positive_infinity ; }
public long get cumulative count thread execute ( ) { return cumulative counter stream . get late count ( hystrix event type . thread pool . execute ) ; }
public long get roll count thread execute ( ) { return roll counter stream . get late count ( hystrix event type . thread pool . execute ) ; }
public void remove ( ) { if ( hystrix request context . get context for current thread ( ) ! = null ) { remove ( hystrix request context . get context for current thread ( ) , this ) ; } }
public void set class loader default supplier ( final class loader class loader , final supplier < c > supplier ) { assert . check not null param ( `` class loader `` , class loader ) ; final security manager sm = system . get security manager ( ) ; if ( sm ! = null ) { sm . check permission ( new context permission ( name , context permission . str_set_classloader_def_sup ) ) ; } if ( supplier == null ) { per class loader default . remove ( class loader ) ; } else { per class loader default . put ( class loader , supplier ) ; } }
public static void reset ( ) { singleton = new hystrix metric publisher factory ( ) ; singleton . command publisher . clear ( ) ; singleton . thread pool publisher . clear ( ) ; singleton . collapser publisher . clear ( ) ; }
public void add ( long x ) { cell [ ] a ; long b , v ; int [ ] hc ; cell a ; int n ; if ( ( a = cell ) ! = null || ! ca base ( b = base , b + x ) ) { boolean uncontended = true ; if ( ( hc = thread hash code . get ( ) ) == null || a == null || ( n = a . length ) < 1 || ( a = a [ ( n - 1 ) & hc [ 0 ] ] ) == null || ! ( uncontended = a . ca ( v = a . value , v + x ) ) ) retry update ( x , hc , uncontended ) ; } }
public iterator value iterator ( ) { final iterator iter = key iterator ( ) ; return new iterator ( ) { public boolean have next ( ) { return iter . have next ( ) ; } public object next ( ) { object key = iter . next ( ) ; return get ( key ) ; } public void remove ( ) { throw new unsupported operation exception ( `` remove ( ) not support for bean map `` ) ; } } ; }
public static ion text writer builder minimal ( ) { return standard ( ) . with minimal system data ( ) ; }
public void set lst minimizing ( lst minimize minimize ) { mutation check ( ) ; my lst minimize = minimizing ; }
public void set import ( symbol table . . . import ) { mutation check ( ) ; my import = safe copy ( import ) ; }
public static ivy ant setting get default instance ( task task ) { return get default instance ( ( project component ) task ) ; }
public void configure id ( object element , attribute attr ) { string id = attr . get value ( `` id `` ) ; if ( id ! = null ) { project . add id reference ( id , element ) ; } }
public string [ ] get confs ( ) { return confs ; }
public map get attribute ( ) { map attribute = get attribute ( true ) ; attribute . put all ( get attribute ( false ) ) ; return attribute ; }
public long get total size ( ) { return total size ; }
public static ivy context push new context ( ) { return push context ( new ivy context ( ) ) ; }
public static ivy context push context ( ivy context context ) { get current stack ( ) . push ( context ) ; return context ; }
public object pop ( string key ) { synchronize ( context map ) { object o = context map . get ( key ) ; if ( o == null ) { return null ; } if ( o instanceof list ) { if ( ( ( list ) o ) . size ( ) == 0 ) { return null ; } object ret = ( ( list ) o ) . remove ( 0 ) ; return ret ; } else { throw new runtime exception ( `` can not pop from non list object `` + o ) ; } } }
public void check ( ) { stack confs = new stack ( ) ; for ( iterator iter = configuration . value ( ) . iterator ( ) ; iter . have next ( ) ; ) { configuration conf = ( configuration ) iter . next ( ) ; string [ ] ext = conf . get extends ( ) ; for ( int i = 0 ; i < ext . length ; i++ ) { confs . push ( conf . get name ( ) ) ; check conf ( confs , ext [ i ] . trim ( ) ) ; confs . pop ( ) ; } } }
public string get organisation ( ) { return organisation ; }
public map get attribute ( ) { map attribute = get attribute ( true ) ; attribute . put all ( get attribute ( false ) ) ; return attribute ; }
public artifact download report download ( artifact artifact , download option option ) { dependency resolver resolver = setting . get resolver ( artifact . get module revision id ( ) ) ; download report r = resolver . download ( new artifact [ ] { artifact } , option ) ; return r . get artifact report ( artifact ) ; }
public int get revision number ( int index ) { return this . get revision number ( ) . get ( index ) ; }
public string [ ] get require configuration ( ivy node in , string in conf ) { collection req = new link hash set ( ) ; add all if not null ( req , usage . get required configuration ( in , in conf ) ) ; for ( iterator iterator = merge usage . value ( ) . iterator ( ) ; iterator . have next ( ) ; ) { ivy node usage usage = ( ivy node usage ) iterator . next ( ) ; add all if not null ( req , usage . get required configuration ( in , in conf ) ) ; } return req == null ? new string [ 0 ] : ( string [ ] ) req . to array ( new string [ req . size ( ) ] ) ; }
public artifact download report download ( artifact artifact , download option option ) { dependency resolver resolver = setting . get resolver ( artifact . get module revision id ( ) ) ; download report r = resolver . download ( new artifact [ ] { artifact } , option ) ; return r . get artifact report ( artifact ) ; }
public int retrieve ( module revision id mrid , string d file pattern , retrieve option option ) throw i o exception { retrieve option retieve option = new retrieve option ( option ) ; retieve option . set d artifact pattern ( d file pattern ) ; retrieve report result = retrieve ( mrid , retieve option ) ; return result . get nbr artifact copy ( ) ; }
public collection get retrieve file ( ) { collection result = new array list ( up to date file . size ( ) + copied file . size ( ) ) ; result . add all ( up to date file ) ; result . add all ( copied file ) ; return result ; }
public module revision id [ ] list module ( module revision id module crit , pattern matcher matcher ) { list ret = new array list ( ) ; map criterion = new hash map ( ) ; for ( iterator it = module crit . get attribute ( ) . entry set ( ) . iterator ( ) ; it . have next ( ) ; ) { map . entry entry = ( entry ) it . next ( ) ; add matcher ( matcher , ( string ) entry . get value ( ) , criterion , ( string ) entry . get key ( ) ) ; } string [ ] token to list = ( string [ ] ) module crit . get attribute ( ) . key set ( ) . to array ( new string [ module crit . get attribute ( ) . size ( ) ] ) ; for ( iterator iter = setting . get resolvers ( ) . iterator ( ) ; iter . have next ( ) ; ) { dependency resolver resolver = ( dependency resolver ) iter . next ( ) ; map [ ] module id a map = resolver . list token value ( token to list , criterion ) ; for ( int i = 0 ; i < module id a map . length ; i++ ) { string org = ( string ) module id a map [ i ] . get ( ivy pattern helper . organisation_key ) ; string name = ( string ) module id a map [ i ] . get ( ivy pattern helper . module_key ) ; string branch = ( string ) module id a map [ i ] . get ( ivy pattern helper . branch_key ) ; string rev = ( string ) module id a map [ i ] . get ( ivy pattern helper . revision_key ) ; map find extra atts = new hash map ( ) ; set qual attribute = module crit . get qualified extra attribute ( ) . key set ( ) ; for ( iterator iter2 = qual attribute . iterator ( ) ; iter2 . have next ( ) ; ) { string qualify key = ( string ) iter2 . next ( ) ; string value = null ; int colon index = qualify key . index of ( ' : ' ) ; if ( colon index == -1 ) { value = ( string ) module id a map [ i ] . get ( qualified key ) ; } else { value = ( string ) module id a map [ i ] . get ( qualified key . substring ( colon index + 1 ) ) ; } if ( value ! = null ) { find extra atts . put ( qualified key , value ) ; } } module revision id mod rev id = module revision id . new instance ( org , name , branch , rev , find extra atts ) ; ret . add ( resolver . get namespace ( ) . get to system transformer ( ) . transform ( mod rev id ) ) ; } } return ( module revision id [ ] ) ret . to array ( new module revision id [ ret . size ( ) ] ) ; }
public string [ ] list ( ) { string re [ ] = new string [ entry . size ( ) ] ; return ( string [ ] ) entry . key set ( ) . to array ( re ) ; }
public boolean be process ( ) { if ( be sort || be loop intermediate element ) { message . debug ( `` module descriptor be process : `` + module . get module revision id ( ) . to string ( ) ) ; return true ; } else { return false ; } }
public static string html element content ( string content ) { if ( content == null ) { return null ; } string builder sb = new string builder ( ) ; for ( int i = 0 ; i < content . length ( ) ; i++ ) { char c = content . char at ( i ) ; if ( c == ' < ' ) { sb . append ( `` & lt ; `` ) ; } else if ( c == ' > ' ) { sb . append ( `` & gt ; `` ) ; } else if ( c == '\ `` ) { sb . append ( `` & # 39 ; `` ) ; } else if ( c == ' & ' ) { sb . append ( `` & amp ; `` ) ; } else if ( c == ' `` ' ) { sb . append ( `` & quot ; `` ) ; } else if ( c == '/ ' ) { sb . append ( `` & # 47 ; `` ) ; } else { sb . append ( c ) ; } } return ( sb . length ( ) > content . length ( ) ) ? sb . to string ( ) : content ; }
public session get session ( string host , int port , string username , string user password , file pem file , string pem password , file pas file ) throw i o exception { check . check not null ( host , `` host `` ) ; check . check not null ( username , `` user `` ) ; entry entry = get cache entry ( username , host , port ) ; session session = null ; if ( entry ! = null ) { session = entry . get session ( ) ; } if ( session == null || ! session . be connect ( ) ) { message . verbose ( `` : : ssh : : connecting to `` + host + `` . . . `` ) ; try { j sch jsch = new j sch ( ) ; if ( port ! = -1 ) { session = jsch . get session ( username , host , port ) ; } else { session = jsch . get session ( username , host ) ; } if ( pem file ! = null ) { jsch . add identity ( pem file . get absolute path ( ) , pem password ) ; } session . set user info ( new cf user info ( host , username , user password , pem file , pem password , pas file ) ) ; session . set daemon thread ( true ) ; session . connect ( ) ; message . verbose ( `` : : ssh : : connect to `` + host + `` ! `` ) ; set session ( username , host , port , session ) ; } catch ( j sch exception e ) { if ( pas file ! = null & & pas file . exists ( ) ) { pas file . delete ( ) ; } i o exception ex = new i o exception ( e . get message ( ) ) ; ex . init cause ( e ) ; throw ex ; } } return session ; }
public list list ( string vfs u r i ) throw i o exception { array list list = new array list ( ) ; message . debug ( `` list call for uri `` + vfs u r i ) ; file object resource impl = get v f s manager ( ) . resolve file ( vfs u r i ) ; message . debug ( `` resource impl= `` + resource impl . to string ( ) ) ; message . debug ( `` resource impl . exists ( ) `` + resource impl . exists ( ) ) ; message . debug ( `` resource impl . get type ( ) `` + resource impl . get type ( ) ) ; message . debug ( `` file type . folder `` + file type . folder ) ; if ( ( resource impl ! = null ) & & resource impl . exists ( ) & & ( resource impl . get type ( ) == file type . folder ) ) { file object [ ] child = resource impl . get child ( ) ; for ( int i = 0 ; i < child . length ; i++ ) { file object child = child [ i ] ; message . debug ( `` child `` + i + child . get name ( ) . get u r i ( ) ) ; list . add ( vfs resource . normalize ( child . get name ( ) . get u r i ( ) ) ) ; } } return list ; }
public static void bind j t a transaction manager implementation ( initial context initial context ) throw javax . naming . naming exception { / * * look up and instantiate an instance of the configured transaction manager implementation * * / string tm implementation = jta property manager . get j t a environment bean ( ) . get transaction manager class name ( ) ; / * * bind the transaction manager to the appropriate jndi context * * / reference ref = new reference ( tm implementation , tm implementation , null ) ; initial context . rebind ( get transaction manager j n d i name ( ) , ref ) ; }
public void set user password ( string password ) { get ssh base repository ( ) . set user password ( password ) ; }
public void set port ( int port ) { this . port = port ; } // -- void set port ( int )
public list < string > get file filter ( ) { c o s base filter = stream . get dictionary object ( c o s name . f_filter ) ; if ( filter instanceof c o s name ) { c o s name name = ( c o s name ) filter ; return collection . singleton list ( name . get name ( ) ) ; } else if ( filter instanceof c o s array ) { return ( ( c o s array ) filter ) . to c o s name string list ( ) ; } return collection . empty list ( ) ; }
public boolean be build in ( ) { if ( build in == null ) { return false ; } else { return build in ; } }
public static image icon get image icon ( string resource name ) { image icon result = null ; url resource u r l = get u r l ( resource name ) ; if ( resource u r l ! = null ) { result = new image icon ( resource u r l ) ; } return result ; }
public json array get restrict to ( ) { return this . restrict to ; }
public static boolean be context relative path ( string filename ) { if ( ! ( on do || on net ware ) || filename . length ( ) == 0 ) { return false ; } char sep = file . separator char ; filename = filename . replace ( '/ ' , sep ) . replace ( '\\ ' , sep ) ; char c = filename . char at ( 0 ) ; int len = filename . length ( ) ; return ( c == sep & & ( len == 1 || filename . char at ( 1 ) ! = sep ) ) || ( character . be letter ( c ) & & len > 1 & & filename . index of ( ' : ' ) == 1 & & ( len == 2 || filename . char at ( 2 ) ! = sep ) ) ; }
public static void delete ( file file ) { if ( file . be file ( ) ) { file . delete ( ) ; return ; } if ( ! file . be directory ( ) ) { return ; } file [ ] exist file = file . list file ( ) ; if ( ! be null or empty ( exist file ) ) { for ( file f : existing file ) { delete ( f ) ; } } file . delete ( ) ; }
public boolean have ( int index , scriptable start ) { if ( external data ! = null ) { return ( index < external data . get array length ( ) ) ; } return null ! = get slot ( null , index , slot_query ) ; }
public boolean have generic type ( ) { return contain type count ( ) > 0 ; }
public string contain type name ( int index ) { if ( index == 0 ) return `` e `` ; return null ; }
public string find new name ( ) { link < ? extends annotated member > rename = null ; rename = find rename ( _fields , rename ) ; rename = find rename ( _getters , rename ) ; rename = find rename ( _setters , rename ) ; rename = find rename ( _ctor parameter , rename ) ; return ( rename == null ) ? null : rename . explicit name ; }
public void write type prefix for array ( object value , json generator jgen , class < ? > type ) throw i o exception { write type prefix for array ( value , jgen ) ; }
public json include . value find property inclusion ( annotate a ) { json include . include def = json include . include . use_defaults ; json include . include vi = find serialization inclusion ( a , def ) ; json include . include ci = find serialization inclusion for content ( a , def ) ; return json include . value . construct ( vi , ci ) ; }
public static unsupported operation exception new unsupported operation exception ( string message ) { return new unsupported operation exception ( message + `` `` + get version ( ) ) ; }
public json generator set pretty printer ( pretty printer pp ) { _cfg pretty printer = pp ; return this ; }
protect void _write ( big integer v ) throw i o exception { / * * support by use type tag , a per spec : major type for tag ' 6 ' ; 5 * lsb either 2 for positive bignum or 3 for negative bignum . and then * byte sequence that encode variable length integer . * / if ( v . signum ( ) < 0 ) { _write byte ( byte_tag_bignum_neg ) ; v = v . negate ( ) ; } else { _write byte ( byte_tag_bignum_pos ) ; } byte [ ] data = v . to byte array ( ) ; final int len = data . length ; _write length marker ( prefix_type_bytes , len ) ; _write byte ( data , 0 , len ) ; }
public void add all ( annotation override ) { if ( _annotations == null ) { _annotations = new link hash map < class < ? extend annotation > , annotation > ( ) ; } for ( annotation override : override . _annotations . value ( ) ) { _annotations . put ( override . annotation type ( ) , override ) ; } }
public void require explicit import ( boolean be static , string simple name ) { if ( be static ) { this . static explicit simple name . add ( simple name ) ; } else { this . type explicit simple name . add ( simple name ) ; } }
public modifier adjustment with method modifier ( modifier contributor . for method . . . modifier contributor ) { return with method modifier ( array . a list ( modifier contributor ) ) ; }
@ override public json token a token ( ) { return json token . value_number_int ; }
public < o > o get ( final string key , final class < o > data type ) { static buffer column = string2 static buffer ( key ) ; final key slice query query = new key slice query ( row key , column , buffer util . next big buffer ( column ) ) ; static buffer result = backend operation . execute ( new backend operation . transactional < static buffer > ( ) { @ override public static buffer call ( store transaction txh ) throw backend exception { list < entry > entries = store . get slice ( query , txh ) ; if ( entry . be empty ( ) ) return null ; return entry . get ( 0 ) . get value a ( static buffer . static_factory ) ; } @ override public string to string ( ) { return `` get configuration `` ; } } , tx provider , time , max operation wait time ) ; if ( result==null ) return null ; return static buffer2 object ( result , data type ) ; }
public int size ( ) { return shape . size ( ) ; }
public static geoshape box ( final double south west latitude , final double south west longitude , final double north east latitude , final double north east longitude ) { precondition . check argument ( be valid coordinate ( south west latitude , south west longitude ) , `` invalid south-west coordinate provide `` ) ; precondition . check argument ( be valid coordinate ( north east latitude , north east longitude ) , `` invalid north-east coordinate provide `` ) ; return new geoshape ( get shape factory ( ) . rect ( south west longitude , north east longitude , south west latitude , north east latitude ) ) ; }
public static geoshape box ( final double south west latitude , final double south west longitude , final double north east latitude , final double north east longitude ) { precondition . check argument ( be valid coordinate ( south west latitude , south west longitude ) , `` invalid south-west coordinate provide `` ) ; precondition . check argument ( be valid coordinate ( north east latitude , north east longitude ) , `` invalid north-east coordinate provide `` ) ; return new geoshape ( get shape factory ( ) . rect ( south west longitude , north east longitude , south west latitude , north east latitude ) ) ; }
public void set allow hostnames ( predicate < string > allow hostnames ) { assert . not null ( allow hostnames , `` allow hostnames can not be null `` ) ; this . allow hostnames = allow hostnames ; }
public void process deletion ( ) { while ( ! this . pending deletion . be empty ( ) ) { long next = this . pending deletion . key set ( ) . iterator ( ) . next ( ) ; delete if unreferenced ( next ) ; this . pending deletion . remove ( next ) ; } }
public static byte buffer copy ( byte buffer buffer ) { if ( buffer == null ) return null ; int p = buffer . position ( ) ; byte buffer clone = buffer . be direct ( ) ? byte buffer . allocate direct ( buffer . remain ( ) ) : byte buffer . allocate ( buffer . remain ( ) ) ; clone . put ( buffer ) ; clone . flip ( ) ; buffer . position ( p ) ; return clone ; }
public boolean be partition key restriction on token ( ) { return partition key restriction . be on token ( ) ; }
public static row iterator with only query data ( row iterator iterator , column filter filter ) { if ( filter . all fetch column be query ( ) ) return iterator ; return transformation . apply ( iterator , new with only query data ( filter ) ) ; }
protect final void verify invocation ( verification already verify ) { ( ( order verification phase ) verification phase ) . check order of verified invocation ( already verify . verification phase ) ; }
public final t add ( t element ) { size++ ; heap [ size ] = element ; up heap ( ) ; return heap [ 1 ] ; }
public static int sortable float bit ( int bit ) { return bit ^ ( bit > > 31 ) & 0x7fffffff ; }
public x m l builder element ( string name , string namespace u r i ) { assert element contain no or whitespace only text node ( this . xml node ) ; return new x m l builder ( ( namespace u r i == null ? get document ( ) . create element ( name ) : get document ( ) . create element n s ( namespace u r i , name ) ) , this . xml node ) ; }
public x m l builder instruction ( string target , string data ) { xml node . append child ( get document ( ) . create processing instruction ( target , data ) ) ; return this ; }
public abstract lat lon box add to abstract lat lon box object extension ( final abstract object abstract lat lon box object extension ) { this . get abstract lat lon box object extension ( ) . add ( abstract lat lon box object extension ) ; return this ; }
public void set abstract view simple extension ( final list < object > abstract view simple extension ) { this . abstract view simple extension = abstract view simple extension ; }
public void set abstract view simple extension ( final list < object > abstract view simple extension ) { this . abstract view simple extension = abstract view simple extension ; }
public view volume add to view volume object extension ( final abstract object view volume object extension ) { this . get view volume object extension ( ) . add ( view volume object extension ) ; return this ; }
public basic link add to basic link simple extension ( final object basic link simple extension ) { this . get basic link simple extension ( ) . add ( basic link simple extension ) ; return this ; }
public camera add to camera simple extension ( final object camera simple extension ) { this . get camera simple extension ( ) . add ( camera simple extension ) ; return this ; }
public abstract object add to object simple extension ( final object object simple extension ) { this . get object simple extension ( ) . add ( object simple extension ) ; return this ; }
public abstract object add to object simple extension ( final object object simple extension ) { this . get object simple extension ( ) . add ( object simple extension ) ; return this ; }
public overlay add to overlay simple extension ( final object overlay simple extension ) { this . get overlay simple extension ( ) . add ( overlay simple extension ) ; return this ; }
public overlay add to overlay object extension ( final abstract object overlay object extension ) { this . get overlay object extension ( ) . add ( overlay object extension ) ; return this ; }
public coordinate builder coordinate ( double longitude , double latitude ) { return this . coordinate ( new coordinate ( longitude , latitude ) ) ; }
public icon style add to icon style simple extension ( final object icon style simple extension ) { this . get icon style simple extension ( ) . add ( icon style simple extension ) ; return this ; }
public look at add to look at object extension ( final abstract object look at object extension ) { this . get look at object extension ( ) . add ( look at object extension ) ; return this ; }
public point add to point object extension ( final abstract object point object extension ) { this . get point object extension ( ) . add ( point object extension ) ; return this ; }
public schema data add to schema data extension ( final object schema data extension ) { this . get schema data extension ( ) . add ( schema data extension ) ; return this ; }
public style add to style simple extension ( final object style simple extension ) { this . get style simple extension ( ) . add ( style simple extension ) ; return this ; }
public style add to style object extension ( final abstract object style object extension ) { this . get style object extension ( ) . add ( style object extension ) ; return this ; }
public time stamp add to time stamp object extension ( final abstract object time stamp object extension ) { this . get time stamp object extension ( ) . add ( time stamp object extension ) ; return this ; }
public author add to name or uri or email ( final string name or uri or email ) { this . get name or uri or email ( ) . add ( name or uri or email ) ; return this ; }
public view volume add to view volume object extension ( final abstract object view volume object extension ) { this . get view volume object extension ( ) . add ( view volume object extension ) ; return this ; }
public dependent locality add to dependent locality name ( final dependent locality . dependent locality name dependent locality name ) { this . get dependent locality name ( ) . add ( dependent locality name ) ; return this ; }
public large mail user add to large mail user name ( final large mail user . large mail user name large mail user name ) { this . get large mail user name ( ) . add ( large mail user name ) ; return this ; }
public void set postal route name ( final list < postal route . postal route name > postal route name ) { this . postal route name = postal route name ; }
public void set sub premise name ( final list < sub premise . sub premise name > sub premise name ) { this . sub premise name = sub premise name ; }
public sub premise add to sub premise name ( final sub premise . sub premise name sub premise name ) { this . get sub premise name ( ) . add ( sub premise name ) ; return this ; }
public sub premise add to sub premise number suffix ( final sub premise . sub premise number suffix sub premise number suffix ) { this . get sub premise number suffix ( ) . add ( sub premise number suffix ) ; return this ; }
public void add literal word ( final long new data ) { this . one bits += long . bit count ( new data ) ; }
public static void reset bitmap range ( long buffer bitmap , int start , int end ) { if ( be back by simple array ( bitmap ) ) { util . reset bitmap range ( bitmap . array ( ) , start , end ) ; return ; } if ( start == end ) return ; int firstword = start / 64 ; int endword = ( end - 1 ) / 64 ; if ( firstword == endword ) { bitmap . put ( firstword , bitmap . get ( firstword ) & ~ ( ( ~0l < < start ) & ( ~0l > > > -end ) ) ) ; return ; } bitmap . put ( firstword , bitmap . get ( firstword ) & ( ~ ( ~0l < < start ) ) ) ; for ( int i = firstword+1 ; i < endword ; i++ ) bitmap . put ( i , 0l ) ; bitmap . put ( endword , bitmap . get ( endword ) & ( ~ ( ~0l > > > -end ) ) ) ; }
public int xorcardinality ( word array b ) { int sum = 0 ; for ( int k = 0 ; k < math . min ( this . get number of word ( ) , b . get number of word ( ) ) ; ++k ) { sum += long . bit count ( this . get word ( k ) ^ b . get word ( k ) ) ; } word array longer = b . get number of word ( ) < this . get number of word ( ) ? this : b ; int start = math . min ( this . get number of word ( ) , b . get number of word ( ) ) ; int end = math . max ( this . get number of word ( ) , b . get number of word ( ) ) ; for ( int k = start ; k < end ; ++k ) { sum += long . bit count ( longer . get word ( k ) ) ; } return sum ; }
public short next unset bit ( final int i ) { int x = i / 64 ; long w = ~bitmap [ x ] ; w > > > = i ; if ( w ! = 0 ) { return ( short ) ( i + long . number of trail zero ( w ) ) ; } ++x ; for ( ; x < bitmap . length ; ++x ) { if ( bitmap [ x ] ! = ~0l ) { return ( short ) ( x * 64 + long . number of trail zero ( ~bitmap [ x ] ) ) ; } } return -1 ; }
public int xorcardinality ( word array b ) { int sum = 0 ; for ( int k = 0 ; k < math . min ( this . get number of word ( ) , b . get number of word ( ) ) ; ++k ) { sum += long . bit count ( this . get word ( k ) ^ b . get word ( k ) ) ; } word array longer = b . get number of word ( ) < this . get number of word ( ) ? this : b ; int start = math . min ( this . get number of word ( ) , b . get number of word ( ) ) ; int end = math . max ( this . get number of word ( ) , b . get number of word ( ) ) ; for ( int k = start ; k < end ; ++k ) { sum += long . bit count ( longer . get word ( k ) ) ; } return sum ; }
public int size in bit ( ) { return this . size in bit ; }
public static void set bitmap range ( long buffer bitmap , int start , int end ) { if ( be back by simple array ( bitmap ) ) { util . set bitmap range ( bitmap . array ( ) , start , end ) ; return ; } if ( start == end ) return ; int firstword = start / 64 ; int endword = ( end - 1 ) / 64 ; if ( firstword == endword ) { bitmap . put ( firstword , bitmap . get ( firstword ) | ( ( ~0l < < start ) & ( ~0l > > > -end ) ) ) ; return ; } bitmap . put ( firstword , bitmap . get ( firstword ) | ( ~0l < < start ) ) ; for ( int i = firstword+1 ; i < endword ; i++ ) bitmap . put ( i , ~0l ) ; bitmap . put ( endword , bitmap . get ( endword ) | ( ~0l > > > -end ) ) ; }
public void xor ( word array b ) { if ( this . get number of word ( ) < b . get number of word ( ) ) this . resize ( b . get number of word ( ) * 64 ) ; for ( int k = 0 ; k < this . get number of word ( ) ; ++k ) { this . data [ k ] ^= b . get word ( k ) ; } }
public void set ( final int i ) { this . data [ i / 64 ] |= ( 1l < < ( i % 64 ) ) ; }
public void build heap ( ) { for ( int i = this . last index / 2 ; i > 0 ; -- i ) { percolate down ( i ) ; } }
public void xor to container ( final e w a h compress bitmap a , final bitmap storage container ) { container . clear ( ) ; final e w a h iterator i = a . get e w a h iterator ( ) ; final e w a h iterator j = get e w a h iterator ( ) ; final iterating buffer run length word rlwi = new iterating buffer run length word ( i ) ; final iterating buffer run length word rlwj = new iterating buffer run length word ( j ) ; while ( ( rlwi . size ( ) > 0 ) & & ( rlwj . size ( ) > 0 ) ) { while ( ( rlwi . get running length ( ) > 0 ) || ( rlwj . get running length ( ) > 0 ) ) { final boolean i_is_prey = rlwi . get running length ( ) < rlwj . get running length ( ) ; final iterating buffer run length word prey = i_is_prey ? rlwi : rlwj ; final iterating buffer run length word predator = i_is_prey ? rlwj : rlwi ; final long index = ( ! predator . get running bit ( ) ) ? prey . discharge ( container , predator . get running length ( ) ) : prey . discharge negate ( container , predator . get running length ( ) ) ; container . add stream of empty word ( predator . get running bit ( ) , predator . get running length ( ) - index ) ; predator . discard run word ( ) ; } final int nbre_literal = math . min ( rlwi . get number of literal word ( ) , rlwj . get number of literal word ( ) ) ; if ( nbre_literal > 0 ) { for ( int k = 0 ; k < nbre_literal ; ++k ) container . add word ( rlwi . get literal word at ( k ) ^ rlwj . get literal word at ( k ) ) ; rlwi . discard first word ( nbre_literal ) ; rlwj . discard first word ( nbre_literal ) ; } } final boolean i_remains = rlwi . size ( ) > 0 ; final iterating buffer run length word remain = i_remains ? rlwi : rlwj ; remain . discharge ( container ) ; container . set size in bit within last word ( math . max ( size in bit ( ) , a . size in bit ( ) ) ) ; }
public static boolean match ( final byte [ ] signature , final int length ) { if ( length < sig_length ) { return false ; } for ( int i = 0 ; i < sig_length ; i++ ) { if ( signature [ i ] ! = cafe_dood [ i ] ) { return false ; } } return true ; }
public void add literal word ( final int new data ) { this . size in bit += word_in_bits ; insert literal word ( new data ) ; }
public static e w a h compressed bitmap or ( final e w a h compressed bitmap . . . bitmap ) { if ( bitmap . length == 1 ) return bitmap [ 0 ] ; int large size = calculate initial size ( bitmap ) ; final e w a h compress bitmap container = new e w a h compress bitmap ( ( int ) ( large size * 1 . 5 ) ) ; or with container ( container , bitmap ) ; return container ; }
public int xor cardinality ( final e w a h compress bitmap32 a ) { final bit counter32 counter = new bit counter32 ( ) ; xor to container ( a , counter ) ; return counter . get count ( ) ; }
public static e w a h compress bitmap xor ( final e w a h compressed bitmap . . . bitmap ) { priority queue < e w a h compress bitmap > pq = new priority queue < e w a h compress bitmap > ( bitmap . length , new comparator < e w a h compress bitmap > ( ) { @ override public int compare ( e w a h compress bitmap a , e w a h compress bitmap b ) { return a . size in byte ( ) - b . size in byte ( ) ; } } ) ; collection . add all ( pq , bitmap ) ; if ( pq . be empty ( ) ) return new e w a h compress bitmap ( ) ; while ( pq . size ( ) > 1 ) { e w a h compress bitmap x1 = pq . poll ( ) ; e w a h compress bitmap x2 = pq . poll ( ) ; pq . add ( x1 . xor ( x2 ) ) ; } return pq . poll ( ) ; }
public static e w a h compress bitmap bufferedxor ( final int buf size , final e w a h compressed bitmap . . . bitmap ) { e w a h compressed bitmap answer = new e w a h compress bitmap ( ) ; bufferedxor with container ( answer , buf size , bitmap ) ; return answer ; }
protect static void discharge a empty ( final bitmap storage container , final iterating r l w i ) { while ( i . size ( ) > 0 ) { container . add stream of empty word ( false , i . size ( ) ) ; i . next ( ) ; } }
public void write literal word ( int num word , bitmap storage container ) { container . add stream of literal word ( this . buffer , this . literal word start position , num word ) ; }
public final iterable < e w a h pointer > get literal ( ) { return new iterable < e w a h pointer > ( ) { @ override public iterator < e w a h pointer > iterator ( ) { return new iterator < e w a h pointer > ( ) { int k = updateable bitmap function . this . litwlist . next set bit ( 0 ) ; @ override public boolean have next ( ) { return this . k > = 0 ; } @ override public e w a h pointer next ( ) { e w a h pointer answer = updateable bitmap function . this . rw [ this . k ] ; this . k = updateable bitmap function . this . litwlist . next set bit ( this . k + 1 ) ; return answer ; } @ override public void remove ( ) { throw new runtime exception ( `` n/a `` ) ; } } ; } } ; }
public static long materialize ( final iterating r l w i , final bitmap storage c , long max ) { final long orig max = max ; while ( true ) { if ( i . get running length ( ) > 0 ) { long l = i . get running length ( ) ; if ( l > max ) l = max ; c . add stream of empty word ( i . get running bit ( ) , l ) ; max -= l ; } long l = i . get number of literal word ( ) ; for ( int k = 0 ; k < l ; ++k ) c . add word ( i . get literal word at ( k ) ) ; if ( max > 0 ) { if ( ! i . next ( ) ) break ; } else break ; } return orig max - max ; }
public object get property ( string name ) { if ( `` name `` . equal ( name ) ) { return function name . get display name ( ) ; } else if ( `` a `` . equal ( name ) ) { return result type . to string ( ) ; } else { return null ; } }
public inner type def variable [ ] get bound ( ) { return this . bound . clone ( ) ; }
public string get file name ( ) { return get const pool ( ) . get utf8 info ( byte array . read u16bit ( get ( ) , 0 ) ) ; }
protect void visit r e t ( int po , byte [ ] code ) throw bad bytecode { }
public void set generic signature ( string sig ) { declare class . check modify ( ) ; method info . add attribute ( new signature attribute ( method info . get const pool ( ) , sig ) ) ; }
public static boolean be package ( int mod ) { return ( mod & ( public | private | protect ) ) == 0 ; }
public static boolean be package ( int mod ) { return ( mod & ( public | private | protect ) ) == 0 ; }
public void bean name ( ) { bean name view resolver resolver = new bean name view resolver ( ) ; this . view resolvers . add ( resolver ) ; }
public e l resolver get stream e l resolver ( ) { return null ; }
public static boolean eval to boolean ( string expression , object ctx ) { return eval ( expression , ctx , new immutable default factory ( ) , boolean . class ) ; }
public class < ? > get common property type ( e l context context , object base ) { if ( base ! = null & & base instanceof map ) { return object . class ; } return null ; }
public static json array builder create array builder ( ) { return json provider . provider ( ) . create array builder ( ) ; }
public byte [ ] encode ( big integer x ) { if ( f == null ) throw new illegal state exception ( `` field not set `` ) ; byte [ ] in = x . to byte array ( ) ; byte [ ] out = new byte [ f . getb ( ) /8 ] ; for ( int i = 0 ; i < in . length ; i++ ) { out [ i ] = in [ in . length-1-i ] ; } for ( int i = in . length ; i < out . length ; i++ ) { out [ i ] = 0 ; } return out ; }
public argument write string ( string s ) { item . add ( new a string ( a s c i i utility . get byte ( s ) ) ) ; return this ; }
public void remove response handler ( response handler h ) { handler . remove ( h ) ; }
public void stop election context ( string reason ) { logger . trace ( `` stop election ( [ { } ] ) `` , reason ) ; synchronize ( this ) { assert election context ! = null : `` stop election context ( ) call but not accumulate `` ; election context . close and process pending ( reason ) ; election context = null ; } }
protect final void assert open ( ) throw illegal state exception { if ( be close ( ) ) { throw new illegal state exception ( `` pool not open `` ) ; } }
public void set quota ( final quota quota ) throw message exception { do optional command ( `` quota not support `` , new protocol command ( ) { @ override public object do command ( i m a p protocol p ) throw protocol exception { p . set quota ( quota ) ; return null ; } } ) ; }
public void remove right ( acl acl ) throw message exception { set a c l ( acl , '- ' ) ; }
public acl [ ] get a c l ( ) throw message exception { return ( acl [ ] ) do optional command ( `` acl not support `` , new protocol command ( ) { @ override public object do command ( i m a p protocol p ) throw protocol exception { return p . get a c l ( full name ) ; } } ) ; }
public string get content i d ( ) throw message exception { check expunge ( ) ; if ( body load ) return super . get content i d ( ) ; load b o d y s t r u c t u r e ( ) ; return b . id ; }
public string get message i d ( ) throw message exception { check expunge ( ) ; if ( body load ) return super . get message i d ( ) ; load envelope ( ) ; return envelope . message id ; }
public void set proxy auth user ( string user ) { proxy auth user = user ; }
protect i m a p folder new i m a p folder ( string full name , char separator , boolean be namespace ) { i m a p folder f = null ; if ( folder constructor ! = null ) { try { object [ ] o = { full name , character . value of ( separator ) , this , be namespace } ; f = ( i m a p folder ) folder constructor . new instance ( o ) ; } catch ( exception ex ) { logger . log ( level . fine , `` exception create i m a p folder class `` , ex ) ; } } if ( f == null ) f = new i m a p folder ( full name , separator , this , be namespace ) ; return f ; }
public synchronize message get message ( int msgnum ) throw message exception { check open ( ) ; check range ( msgnum ) ; return message cache . get message ( msgnum ) ; }
public static < t extend item > t get item ( response [ ] r , int msgno , class < t > c ) { if ( r == null ) return null ; for ( int i = 0 ; i < r . length ; i++ ) { if ( r [ i ] == null || ! ( r [ i ] instanceof fetch response ) || ( ( fetch response ) r [ i ] ) . get number ( ) ! = msgno ) continue ; fetch response f = ( fetch response ) r [ i ] ; for ( int j = 0 ; j < f . item . length ; j++ ) { if ( c . be instance ( f . item [ j ] ) ) return c . cast ( f . item [ j ] ) ; } } return null ; }
protect boolean be r e v1 ( ) throw folder close exception { return msg . be r e v1 ( ) ; }
public void set proxy auth user ( string user ) { proxy auth user = user ; }
public body peek body ( int msgno , string section , int start , int size ) throw protocol exception { return fetch body ( msgno , section , start , size , true , null ) ; }
public void fetch sequence number ( long uid ) throw protocol exception { response [ ] r = fetch ( string . value of ( uid ) , `` uid `` , true ) ; notify response handler ( r ) ; handle result ( r [ r . length-1 ] ) ; }
public string get text ( ) { if ( text ! = null ) { return text . trim ( ) ; } return text ; }
public void add ( right right ) { for ( int i = 0 ; i < right . right . length ; i++ ) if ( right . right [ i ] ) this . right [ i ] = true ; }
public synchronize message get message ( int msgnum ) throw message exception { check open ( ) ; check range ( msgnum ) ; return message cache . get message ( msgnum ) ; }
protect void finalize ( ) throw throwable { super . finalize ( ) ; close ( ) ; }
public synchronize folder get folder ( string name ) throw message exception { check connect ( ) ; return new i m a p folder ( name , i m a p folder . unknown_separator ) ; }
public int get return code ( ) { return return code ; }
public weld extension ( extension . . . extension ) { this . extension . clear ( ) ; for ( extension extension : extension ) { add extension ( extension ) ; } return this ; }
public void write ( byte b [ ] , int off , int len ) throw i o exception { if ( trace ) { if ( quote ) { for ( int i = 0 ; i < len ; i++ ) write byte ( b [ off + i ] ) ; } else trace out . write ( b , off , len ) ; } out . write ( b , off , len ) ; }
public final synchronize void set push level ( final level level ) { check access ( ) ; if ( level == null ) { throw new null pointer exception ( ) ; } if ( be write ) { throw new illegal state exception ( ) ; } this . push level = level ; }
public comparator < ? super k > comparator ( ) { return key set ( ) . comparator ( ) ; }
public final void set subject ( final string subject ) { if ( subject ! = null ) { this . set subject ( new tail name formatter ( subject ) ) ; } else { check access ( ) ; throw new null pointer exception ( ) ; } }
public int get port ( ) { check state ( have port ( ) ) ; return port ; }
public mail logger get sub logger ( string subname , string prefix ) { return new mail logger ( logger . get name ( ) + `` . `` + subname , prefix , debug , out ) ; }
public void trace ( string msg ) { if ( logger . be loggable ( level . fine ) ) { log ( self , level . fine , msg , null ) ; } }
public void set allow trace ( boolean allow trace ) { this . allow trace = allow trace ; set property ( `` allow trace `` , string . value of ( allow trace ) ) ; }
public boolean set file transfer mode ( int mode ) throw i o exception { if ( f t p reply . be positive completion ( mode ( mode ) ) ) { __file transfer mode = mode ; return true ; } return false ; }
public void set initial mode ( string expand mode name ) { if ( expanded mode name==null ) return ; if ( expanded mode name . length ( ) == 0 ) return ; initial mode = structure q name . from clark name ( expand mode name ) ; }
public message get current message ( ) { if ( msg context == null ) return null ; return msg context . get current message ( ) ; }
public synchronize message [ ] get message ( int [ ] msgnums ) throw message exception { int len = msgnums . length ; message [ ] msg = new message [ len ] ; for ( int i = 0 ; i < len ; i++ ) msg [ i ] = get message ( msgnums [ i ] ) ; return msg ; }
public void add ( item item ) { if ( special == null ) special = new vector < > ( ) ; special . add element ( item ) ; }
public void add ( string flag ) { if ( user_flags == null ) user_flags = new hashtable < > ( 1 ) ; user_flags . put ( flag . to lower case ( locale . english ) , flag ) ; }
protect void notify folder listener ( int type ) { if ( folder listener ! = null ) { folder event e = new folder event ( this , this , type ) ; queue event ( e , folder listener ) ; } store . notify folder listener ( type , this ) ; }
public parameter list get parameter list ( ) { return parameter list ; }
public string get base type ( ) { return primary type + `` / `` + sub type ; }
public static string to string ( address [ ] address ) { if ( address == null || address . length == 0 ) return null ; string buffer s = new string buffer ( ( ( news address ) address [ 0 ] ) . to string ( ) ) ; int use = s . length ( ) ; for ( int i = 1 ; i < address . length ; i++ ) { s . append ( `` , `` ) ; used++ ; string ng = ( ( news address ) address [ i ] ) . to string ( ) ; if ( use + ng . length ( ) > 76 ) { s . append ( `` \r\n\t `` ) ; use = 8 ; } s . append ( ng ) ; use += ng . length ( ) ; } return s . to string ( ) ; }
public enumeration < string > get match header line ( string [ ] names ) { return ( new match string enum ( header , name , true ) ) ; }
public synchronize flag get permanent flag ( ) { if ( permanent flag == null ) return null ; return ( flag ) ( permanent flag . clone ( ) ) ; }
public string to string ( ) { if ( to string ! = null ) { return to string ; } else { return to string = get u r i ( ) . to string ( ) ; } }
public string get encode ( ) throw message exception { return get encode ( this ) ; }
public boolean only expunge deletes ( ) { return only expunge deletes ; }
public java class find class ( string class name ) { synchronize ( loaded class ) { if ( loaded class . contains key ( class name ) ) { return load class . get ( class name ) ; } else { return null ; } } }
public boolean match ( inet address address ) { assert . check not null param ( `` address `` , address ) ; if ( address instanceof inet4 address ) { return match ( ( inet4 address ) address ) ; } else if ( address instanceof inet6 address ) { return match ( ( inet6 address ) address ) ; } else { throw assert . unreachable code ( ) ; } }
public void connect ( string user , string password ) throw message exception { connect ( null , user , password ) ; }
public store get store ( u r l name url ) throw no such provider exception { string protocol = url . get protocol ( ) ; provider p = get provider ( protocol ) ; return get store ( p , url ) ; }
public void set password authentication ( u r l name url , password authentication pw ) { if ( pw == null ) auth table . remove ( url ) ; else auth table . put ( url , pw ) ; }
public folder [ ] get personal namespaces ( ) throw message exception { namespaces ns = get namespaces ( ) ; if ( ns == null || n . personal == null ) return super . get personal namespaces ( ) ; return namespace to folder ( n . personal , null ) ; }
protect void notify folder listener ( int type , folder folder ) { if ( folder listener == null ) return ; folder event e = new folder event ( this , folder , type ) ; queue event ( e , folder listener ) ; }
public synchronize void remove transport listener ( transport listener l ) { if ( transport listener ! = null ) transport listener . remove element ( l ) ; }
public o p c package get package ( ) { return container ; }
protect void _get post order grammar list ( list < grammar > grammar ) { for ( int i = 0 ; child ! =null & & i < child . size ( ) ; i++ ) { composite grammar tree child = child . get ( i ) ; child . _get post order grammar list ( grammar ) ; } grammar . add ( this . grammar ) ; }
public void _throw ( j expression exp ) { insert ( new j throw ( exp ) ) ; }
public j do loop _do ( j expression test ) { return insert ( new j do loop ( test ) ) ; }
public j for loop _for ( ) { return insert ( new j for loop ( ) ) ; }
public j define class _class ( string name ) throw j class already exist exception { return _class ( j mod . public , name ) ; }
public void build ( file src dir , file resource dir ) throw i o exception { build ( src dir , resource dir , system . out ) ; }
public j conditional _elseif ( j expression bool exp ) { return _else ( ) . _if ( bool exp ) ; }
public collection < http method constraint element > get http method constraint ( ) { return collection . unmodifiable collection ( method constraint ) ; }
public j doc comment javadoc ( ) { if ( jdoc == null ) jdoc = new j doc comment ( type . owner ( ) ) ; return jdoc ; }
public static j expression direct ( final string source ) { return new j expression impl ( ) { public void generate ( j formatter f ) { f . p ( ' ( ' ) . p ( source ) . p ( ' ) ' ) ; } } ; }
public void set n ( string name ) { action . set name ( `` n `` , name ) ; }
public resource name iterator find resource name ( final string resource name ) { if ( log . be debug enable ( ) ) log . debug ( `` find : resource name= ' `` + resource name + `` ' `` ) ; return new resource name iterator ( ) { private int idx = 0 ; private resource name iterator iterator = null ; public boolean have next ( ) { if ( iterator == null || ! iterator . have next ( ) ) { iterator = get next iterator ( ) ; if ( iterator == null ) { return false ; } } return iterator . have next ( ) ; } public string next resource name ( ) { return iterator . next resource name ( ) ; } private resource name iterator get next iterator ( ) { while ( idx < size ( ) ) { resource name iterator iter = get resource name discover ( idx++ ) . find resource name ( resource name ) ; if ( iter . have next ( ) ) { return iter ; } } return null ; } } ; }
public boolean be unnamed package ( ) { return get class name ( ) . be unnamed package ( ) ; }
public t type get erasure ( ) { return this ; }
public j class _extends ( ) { if ( bound ! =null ) return bound ; else return owner ( ) . ref ( object . class ) ; }
public catalog get private catalog ( ) { catalog catalog = static catalog ; if ( use static catalog == null ) { use static catalog = new boolean ( get use static catalog ( ) ) ; } if ( catalog == null || ! use static catalog . boolean value ( ) ) { try { string catalog class name = get catalog class name ( ) ; if ( catalog class name == null ) { catalog = new catalog ( ) ; } else { try { catalog = ( catalog ) class . for name ( catalog class name ) . new instance ( ) ; } catch ( class not find exception cnfe ) { debug . message ( 1 , `` catalog class name ' `` + catalog class name + `` ' could not be find . use default . `` ) ; catalog = new catalog ( ) ; } catch ( class cast exception cnfe ) { debug . message ( 1 , `` class name ' `` + catalog class name + `` ' be not a catalog . use default . `` ) ; catalog = new catalog ( ) ; } } catalog . set catalog manager ( this ) ; catalog . setup reader ( ) ; catalog . load system catalog ( ) ; } catch ( exception ex ) { ex . print stack trace ( ) ; } if ( use static catalog . boolean value ( ) ) { static catalog = catalog ; } } return catalog ; }
public static string to protocol host and port ( string url ) { try { url u = new url ( url ) ; string path = u . get path ( ) ; if ( path ! = null & & ! `` `` . equal ( path ) & & ! path . end with ( `` / `` ) ) { log . warning ( `` it look like your base url ( `` + url + `` ) be point to a file , not a directory ( it do n't end with a / ) . we 're go to have to strip off the last part of the pathname . `` ) ; } return u . get protocol ( ) + `` : // `` + u . get authority ( ) ; } catch ( malformed u r l exception e ) { throw new runtime exception ( e ) ; } }
public catalog get catalog ( ) { return resolver . get catalog ( ) ; }
public catalog get catalog ( ) { return resolver . get catalog ( ) ; }
public stack frame pop2push1 ( string type ) { stack state ns = stack state . pop ( 2 ) . push ( type ) ; return new stack frame ( ns , local variable state , type no local change ( ns ) ) ; }
public boolean be per instance meta class change ( ) { return instance ! =null ; }
public void set name ( string new name ) { if ( new name == null ) { ct table . unset name ( ) ; name = null ; return ; } ct table . set name ( new name ) ; name = new name ; }
public q name get xml name ( ) { return xml name ; }
public void add bind file ( input source be ) { bind file . add ( absolutize ( be ) ) ; }
public static class < ? > convert primitive type ( class < ? > clazz ) { if ( clazz . equal ( char . class ) ) { return character . class ; } else if ( clazz . equal ( int . class ) ) { return integer . class ; } else if ( clazz . equal ( boolean . class ) ) { return boolean . class ; } else if ( clazz . equal ( double . class ) ) { return double . class ; } else if ( clazz . equal ( byte . class ) ) { return byte . class ; } else if ( clazz . equal ( short . class ) ) { return short . class ; } else if ( clazz . equal ( long . class ) ) { return long . class ; } else if ( clazz . equal ( float . class ) ) { return float . class ; } else { return clazz ; } }
protect final boolean be recognizable extension ( string namespace uri ) { return recognizable extension . contains ( namespace uri ) ; }
public static expression location make from sax ( locator loc ) { return new expression location ( loc . get system id ( ) , loc . get line number ( ) , loc . get column number ( ) ) ; }
public static string collection info string ( string role , serializable id ) { string builder s = new string builder ( ) ; s . append ( ' [ ' ) ; if ( role == null ) { s . append ( `` < unreferenced > `` ) ; } else { s . append ( role ) ; s . append ( ' # ' ) ; if ( id == null ) { s . append ( `` < null > `` ) ; } else { s . append ( id ) ; } } s . append ( ' ] ' ) ; return s . to string ( ) ; }
public string to string ( ) { return `` # source `` ; }
public string [ ] list system i d ( ) { return core . key set ( ) . to array ( new string [ core . key set ( ) . size ( ) ] ) ; }
public static string parse any simple type ( string lexical x s d any simple type ) { if ( the converter == null ) init converter ( ) ; return the converter . parse any simple type ( lexical x s d any simple type ) ; }
public b type get builder ( int index ) { ensure builder ( ) ; single field builder < m type , b type , i type > builder = builder . get ( index ) ; if ( builder == null ) { m type message = message . get ( index ) ; builder = new single field builder < m type , b type , i type > ( message , this , be clean ) ; builder . set ( index , builder ) ; } return builder . get builder ( ) ; }
public final c element be bind ( x s element decl x , x s component referer ) { c element info r = bound element . get ( x ) ; if ( r ! =null ) return r ; return bind to type ( x , referer ) ; }
public static long parse decimal ( final string s ) { long parse = null ; try { if ( s ! = null ) { parse = ( long ) double . parse double ( s ) ; } } catch ( final number format exception e ) { } return parse ; }
public void set header ( boolean flg ) { this . option . no file header = ! flg ; }
public static locale get locale ( literal l , locale fallback ) { locale result = fallback ; try { string lang = l . get language ( ) ; if ( lang ! = null ) { language tag tag = new language tag ( lang ) ; result = tag . to locale ( ) ; } } catch ( language tag syntax exception e ) { result = fallback ; } return result ; }
public void set d t d handler ( d t d handler handler ) { if ( handler == null ) { throw new null pointer exception ( `` handler `` ) ; } this . dtd handler = handler ; return ; }
protect locale find locale for language ( string language ) { locale [ ] locales = locale . get available locale ( ) ; for ( int i = 0 , size = locale . length ; i < size ; i++ ) { locale locale = locales [ i ] ; if ( language . equal ( locale . get language ( ) ) ) { string country = locale . get country ( ) ; if ( country == null || country . length ( ) == 0 ) { string variant = locale . get variant ( ) ; if ( variant == null || variant . length ( ) == 0 ) { return locale ; } } } } return null ; }
public int size ( ) { return count ; } // size ( )
public list < t > poll n ( int n ) { if ( n > = size ) { return poll all ( ) ; } list < t > ret list = new array list < t > ( n ) ; if ( n == 0 ) { return ret list ; } boolean do = false ; int current bucket index = 0 ; while ( ! do ) { link element < t > current = entry [ current bucket index ] ; while ( current ! = null ) { ret list . add ( current . element ) ; current = current . next ; entry [ current bucket index ] = current ; size -- ; modification++ ; if ( -- n == 0 ) { do = true ; break ; } } current bucket index++ ; } shrink if necessary ( ) ; return ret list ; }
public void add configure attribute ( attribute attribute ) { if ( attribute . get name ( ) == null ) { throw new build exception ( `` the attribute nest element need a \ `` name\ `` attribute `` ) ; } if ( attribute . get name ( ) . equal ( text name ) ) { throw new build exception ( `` the name \ `` `` + attribute . get name ( ) + `` \ `` have already be use by the text element `` ) ; } for ( int i = 0 ; i < attribute . size ( ) ; ++i ) { attribute att = ( attribute ) attribute . get ( i ) ; if ( att . get name ( ) . equal ( attribute . get name ( ) ) ) { throw new build exception ( `` the name \ `` `` + attribute . get name ( ) + `` \ `` have already be use in `` + `` another attribute element `` ) ; } } attribute . add ( attribute ) ; }
public void add parser ( parser parser ) { if ( parser manager==null ) { parser manager = new parser manager ( this ) ; } parser manager . add parser ( parser ) ; }
protect boolean be import schema ( string target namespace ) { return schema index . contains ( target namespace ) ; }
public schema output resolver create test resolver ( ) { return new schema output resolver ( ) { public result create output ( string namespace uri , string suggest file name ) { s a x result r = new s a x result ( new default handler ( ) ) ; r . set system id ( suggest file name ) ; return r ; } } ; }
public final x s component select single ( x s component context node ) { iterator < x s component > r = select ( iterators . singleton ( context node ) ) ; if ( r . have next ( ) ) return r . next ( ) ; return null ; }
public class method add constructor ( constructor < ? > method ) { class method class method = add method ( method . get modifier ( ) , `` < init > `` , `` v `` , descriptor utils . parameter descriptor ( method . get parameter type ( ) ) ) ; for ( class < ? > e : method . get exception type ( ) ) { class method . add checked exception ( ( class < ? extend exception > ) e ) ; } for ( annotation annotation : method . get declared annotation ( ) ) { class method . get runtime visible annotation attribute ( ) . add annotation ( annotation builder . create annotation ( const pool , annotation ) ) ; } int count = 0 ; for ( annotation [ ] parameter annotation : method . get parameter annotation ( ) ) { for ( annotation annotation : parameter annotation ) { class method . get runtime visible parameter annotation attribute ( ) . add annotation ( count , annotation builder . create annotation ( const pool , annotation ) ) ; } count++ ; } return class method ; }
protected class define class ( string name , byte [ ] bytecode , protection domain domain ) { throw new deprecation exception ( `` the method groovy . lang . groovy class loader # define class ( string , byte [ ] , protection domain ) be no longer use internally and remove `` ) ; }
public stack frame pop2push1 ( string type ) { stack state ns = stack state . pop ( 2 ) . push ( type ) ; return new stack frame ( ns , local variable state , type no local change ( ns ) ) ; }
public stack frame pop2push1 ( string type ) { stack state ns = stack state . pop ( 2 ) . push ( type ) ; return new stack frame ( ns , local variable state , type no local change ( ns ) ) ; }
public stack frame pop2 ( ) { stack state ns = stack state . pop ( 2 ) ; return new stack frame ( ns , local variable state , type no local change ( ns ) ) ; }
public int get slot number ( ) { return slot number ; }
public long get renormalization window day ( ) { return renormalization window day ; }
protect void default visit ( ion value value ) throw exception { throw new unsupported operation exception ( ) ; }
public void init ( ) { try { synchronize ( lock . validate ( ) ) { remote . init ( ) ; } } catch ( throwable t ) { util . handle exception ( t ) ; } }
public void set level ( final string lev ) { for ( final string item : lev . split ( multicolor layout . split_items ) ) { final string [ ] value = item . split ( multicolor layout . split_values ) ; final string level = value [ 0 ] . to upper case ( locale . english ) ; if ( level . to level ( level , null ) == null ) { throw new illegal argument exception ( string . format ( locale . english , `` unknown level ' % s ' `` , level ) ) ; } this . level . put ( level , value [ 1 ] ) ; } }
public boolean have session attribute ( ) { return ( ! this . attribute name . be empty ( ) || ! this . attribute type . be empty ( ) ) ; }
public void remove namespace declaration ( namespace additional namespace ) { if ( additional namespaces == null ) { return ; } additional namespaces . remove ( additional namespace ) ; }
public void sort content ( comparator < ? super content > comparator ) { content . sort ( comparator ) ; }
public void fatal error ( s a x parse exception exception ) throw s a x exception { throw exception ; }
public void set ignore element content whitespace ( final boolean ignore white ) { this . ignore white = ignore white ; }
public org . jdom2 . cdata build ( org . w3c . dom . c d a t a section cdata ) { return factory . cdata ( cdata . get node value ( ) ) ; }
public iterator < namespace > iterator ( ) { return new forward walker ( scope [ depth ] ) ; }
public namespace [ ] get scope ( ) { return array copy . copy of ( scope [ depth ] , scope [ depth ] . length ) ; }
public static boolean be x m l letter or digit ( char c ) { return ( be x m l letter ( c ) || be x m l digit ( c ) ) ; }
public boolean set variable ( string qname , object value ) { if ( qname == null ) { throw new null pointer exception ( `` null variable name `` ) ; } if ( variable == null ) { variable = new hash map < string , object > ( ) ; } return variable . put ( qname , value ) == null ; }
public adapter bind get adapter info ( ) { return adapter info ; }
public u r iish get u r i ( ) { return uri ; }
protect object output stream create object output stream ( output stream os ) throw i o exception { return new object output stream ( os ) ; }
public static enumeration a enumeration ( final iterator iter ) { return new enumeration ( ) { public boolean have more element ( ) { return iter . have next ( ) ; } public object next element ( ) { return iter . next ( ) ; } } ; }
public static string jersey_app_mapping_conflict ( object arg0 , object arg1 ) { return localizer . localize ( localizable j e r s e y_ a p p_ m a p p i n g_ c o n f l i c t ( arg0 , arg1 ) ) ; }
public static string error_subres_method_uri_path_invalid ( object arg0 , object arg1 ) { return localizer . localize ( localizable e r r o r_ s u b r e s_ m e t h o d_ u r i_ p a t h_ i n v a l i d ( arg0 , arg1 ) ) ; }
protect servlet context get servlet context ( ) { if ( this . filter config ! = null ) { return this . filter config . get servlet context ( ) ; } else if ( this . servlet context ! = null ) { return this . servlet context ; } else { throw new illegal state exception ( `` no servlet context `` ) ; } }
public static boolean substring match ( char sequence str , int index , char sequence substring ) { for ( int j = 0 ; j < substring . length ( ) ; j++ ) { int i = index + j ; if ( i > = str . length ( ) || str . char at ( i ) ! = substring . char at ( j ) ) { return false ; } } return true ; }
public static string sax_cannot_disable_general_entity_processing_feature ( object arg0 ) { return localizer . localize ( localizable s a x_ c a n n o t_ d i s a b l e_ g e n e r a l_ e n t i t y_ p r o c e s s i n g_ f e a t u r e ( arg0 ) ) ; }
public static string error_subres_loc_has_entity_param ( object arg0 ) { return localizer . localize ( localizable e r r o r_ s u b r e s_ l o c_ h a s_ e n t i t y_ p a r a m ( arg0 ) ) ; }
public static string logging_name_bound_reader_interceptors ( ) { return localizer . localize ( localizable l o g g i n g_ n a m e_ b o u n d_ r e a d e r_ i n t e r c e p t o r s ( ) ) ; }
public int get status code ( ) { return status line . get status code ( ) ; }
public < e > e persist ( e entity ) { get entity manager ( ) . persist ( entity ) ; return entity ; }
public < t extend annotation > boolean have parameter annotation ( class < t > annotation type ) { return ( get parameter annotation ( annotation type ) ! = null ) ; }
public static boolean produce ( medium type content type , list < medium type > accept ) { for ( medium type a : accept ) { if ( a . get type ( ) . equal ( `` * `` ) ) return true ; if ( content type . be compatible ( a ) ) return true ; } return false ; }
public static boolean substring match ( char sequence str , int index , char sequence substring ) { for ( int j = 0 ; j < substring . length ( ) ; j++ ) { int i = index + j ; if ( i > = str . length ( ) || str . char at ( i ) ! = substring . char at ( j ) ) { return false ; } } return true ; }
protect uri pattern create uri pattern ( uri template parser template parser ) { return new uri pattern ( template parser . get pattern ( ) , template parser . get group index ( ) ) ; }
public uri component builder uri ( uri uri ) { assert . not null ( uri , `` uri must not be null `` ) ; this . scheme = uri . get scheme ( ) ; if ( uri . be opaque ( ) ) { this . ssp = uri . get raw scheme specific part ( ) ; reset hierarchical component ( ) ; } else { if ( uri . get raw user info ( ) ! = null ) { this . user info = uri . get raw user info ( ) ; } if ( uri . get host ( ) ! = null ) { this . host = uri . get host ( ) ; } if ( uri . get port ( ) ! = -1 ) { this . port = string . value of ( uri . get port ( ) ) ; } if ( string utils . have length ( uri . get raw path ( ) ) ) { this . path builder = new composite path component builder ( ) ; this . path builder . add path ( uri . get raw path ( ) ) ; } if ( string utils . have length ( uri . get raw query ( ) ) ) { this . query params . clear ( ) ; query ( uri . get raw query ( ) ) ; } reset scheme specific part ( ) ; } if ( uri . get raw fragment ( ) ! = null ) { this . fragment = uri . get raw fragment ( ) ; } return this ; }
public comment set text ( string text ) { string reason ; if ( ( reason = verifier . check comment data ( text ) ) ! = null ) { throw new illegal data exception ( text , `` comment `` , reason ) ; } this . text = text ; return this ; }
public comment set text ( string text ) { string reason ; if ( ( reason = verifier . check comment data ( text ) ) ! = null ) { throw new illegal data exception ( text , `` comment `` , reason ) ; } this . text = text ; return this ; }
protected object handle error ( class type , object value , throwable cause ) { if ( log ( ) . be debug enable ( ) ) { if ( cause instanceof conversion exception ) { log ( ) . debug ( `` conversion throw conversion exception : `` + cause . get message ( ) ) ; } else { log ( ) . debug ( `` conversion throw `` + cause ) ; } } if ( use default ) { return handle miss ( type ) ; } conversion exception cex = null ; if ( cause instanceof conversion exception ) { cex = ( conversion exception ) cause ; if ( log ( ) . be debug enable ( ) ) { log ( ) . debug ( `` re-throwing conversion exception : `` + cex . get message ( ) ) ; log ( ) . debug ( `` `` + default_config_msg ) ; } } else { string msg = `` error convert from ' `` + to string ( value . get class ( ) ) + `` ' to ' `` + to string ( type ) + `` ' `` + cause . get message ( ) ; cex = new conversion exception ( msg , cause ) ; if ( log ( ) . be debug enable ( ) ) { log ( ) . debug ( `` throw conversion exception : `` + msg ) ; log ( ) . debug ( `` `` + default_config_msg ) ; } bean utils . init cause ( cex , cause ) ; } throw cex ; }
public long get doc count ( ) { if ( doc count < 0 ) { if ( reduce == null ) { doc count = 0 ; for ( b bucket : to reduce ) { doc count += bucket . get doc count ( ) ; } } else { doc count = reduce . get doc count ( ) ; } } return doc count ; }
public string get title ( ) { if ( title ! = null ) { return title . get value ( ) ; } return null ; }
public void set resource ( resource value ) { this . resource = value ; }
public static x d g f relation get instance ( string rel ) { return _table . get ( rel ) ; }
public style style ( ) { return style ; }
public static fix builder < schema > fix ( string name ) { return builder ( ) . fix ( name ) ; }
public list < object > get resource type or method or representation ( ) { if ( resource type or method or representation == null ) { resource type or method or representation = new array list < object > ( ) ; } return this . resource type or method or representation ; }
public boolean be close ( ) { return be close ; }
protect final string get root element name ( class < ? > element type ) { if ( be xml root element processing ( ) ) { return convert to xml name ( inflector . pluralize ( inflector . demodulize ( get element name ( element type ) ) ) ) ; } else { return convert to xml name ( inflector . decapitalize ( inflector . pluralize ( inflector . demodulize ( element type . get name ( ) ) ) ) ) ; } }
public list < string > get vary ( ) { return get value a list ( vary ) ; }
public boolean be map from exception ( ) { return map from exception ; }
public void close ( ) throw i o exception { if ( ! be closed . compare and set ( false , true ) ) { return ; } try { if ( zip entry writer ! = null ) { zip entry writer . close ( ) ; } back store . close ( ) ; } finally { stream compressor . close ( ) ; } }
public static boolean be windows absolute path ( final string path string , final boolean slash ) { int start = start position without window drive ( path string ) ; return start > 0 & & path string . length ( ) > start & & ( ( path string . char at ( start ) == separator_char ) || ( path string . char at ( start ) == '\\ ' ) ) ; }
public static string sax_cannot_enable_secure_processing_feature ( ) { return localizer . localize ( localizable s a x_ c a n n o t_ e n a b l e_ s e c u r e_ p r o c e s s i n g_ f e a t u r e ( ) ) ; }
public static string error_finding_exception_mapper_type ( object arg0 ) { return localizer . localize ( localizable e r r o r_ f i n d i n g_ e x c e p t i o n_ m a p p e r_ t y p e ( arg0 ) ) ; }
public static string error_monitoring_mbeans_registration ( object arg0 ) { return localizer . localize ( localizable e r r o r_ m o n i t o r i n g_ m b e a n s_ r e g i s t r a t i o n ( arg0 ) ) ; }
public static string error_template_parser_invalid_syntax_terminated ( object arg0 ) { return localizer . localize ( localizable e r r o r_ t e m p l a t e_ p a r s e r_ i n v a l i d_ s y n t a x_ t e r m i n a t e d ( arg0 ) ) ; }
public static string error_request_set_security_context_in_response_phase ( ) { return localizer . localize ( localizable e r r o r_ r e q u e s t_ s e t_ s e c u r i t y_ c o n t e x t_ i n_ r e s p o n s e_ p h a s e ( ) ) ; }
public static string ambiguous_srls ( object arg0 , object arg1 , object arg2 ) { return localizer . localize ( localizable a m b i g u o u s_ s r l s ( arg0 , arg1 , arg2 ) ) ; }
public static string error_closing_commit_output_stream ( ) { return localizer . localize ( localizable e r r o r_ c l o s i n g_ c o m m i t_ o u t p u t_ s t r e a m ( ) ) ; }
public static string error_wadl_generator_config_loader_property ( object arg0 , object arg1 ) { return localizer . localize ( localizable e r r o r_ w a d l_ g e n e r a t o r_ c o n f i g_ l o a d e r_ p r o p e r t y ( arg0 , arg1 ) ) ; }
public static string error_wadl_builder_generation_request ( object arg0 , object arg1 ) { return localizer . localize ( localizable e r r o r_ w a d l_ b u i l d e r_ g e n e r a t i o n_ r e q u e s t ( arg0 , arg1 ) ) ; }
public static string error_wadl_resource_external_grammar ( ) { return localizer . localize ( localizable e r r o r_ w a d l_ r e s o u r c e_ e x t e r n a l_ g r a m m a r ( ) ) ; }
public static string ambiguous_non_annotated_parameter ( object arg0 , object arg1 ) { return localizer . localize ( localizable a m b i g u o u s_ n o n_ a n n o t a t e d_ p a r a m e t e r ( arg0 , arg1 ) ) ; }
public static string error_wadl_builder_generation_request_media_type ( object arg0 , object arg1 , object arg2 ) { return localizer . localize ( localizable e r r o r_ w a d l_ b u i l d e r_ g e n e r a t i o n_ r e q u e s t_ m e d i a_ t y p e ( arg0 , arg1 , arg2 ) ) ; }
public static string wadl_doc_extended_wadl ( object arg0 , object arg1 ) { return localizer . localize ( localizable w a d l_ d o c_ e x t e n d e d_ w a d l ( arg0 , arg1 ) ) ; }
public void update resource method statistic ( resource method statistic resource method statistic impl ) { this . method execution statistic mx bean . update execution statistic ( resource method statistic impl . get method statistic ( ) ) ; this . request execution statistic mx bean . update execution statistic ( resource method statistic impl . get request statistic ( ) ) ; }
public void validate ( io . vertx . reactivex . ext . web . rout context rout context ) { delegate . validate ( rout context . get delegate ( ) ) ; }
public configuration add evaluation listener ( evaluation listener . . . evaluation listener ) { return configuration . builder ( ) . json provider ( json provider ) . map provider ( map provider ) . option ( option ) . evaluation listener ( evaluation listener ) . build ( ) ; }
protect final string get root element name ( class < ? > element type ) { if ( be xml root element processing ( ) ) { return convert to xml name ( inflector . pluralize ( inflector . demodulize ( get element name ( element type ) ) ) ) ; } else { return convert to xml name ( inflector . decapitalize ( inflector . pluralize ( inflector . demodulize ( element type . get name ( ) ) ) ) ) ; } }
protect final string get root element name ( class < ? > element type ) { if ( be xml root element processing ( ) ) { return convert to xml name ( inflector . pluralize ( inflector . demodulize ( get element name ( element type ) ) ) ) ; } else { return convert to xml name ( inflector . decapitalize ( inflector . pluralize ( inflector . demodulize ( element type . get name ( ) ) ) ) ) ; } }
public method list have num params ( final int param count ) { return filter ( new filter ( ) { @ override public boolean keep ( annotated method m ) { return m . get parameter type ( ) . length == param count ; } } ) ; }
public static builder builder ( ) { return new builder ( ) ; }
public list < runtime resource > get child runtime resource ( ) { return child runtime resource ; }
public final t get object ( ) throw exception { if ( be singleton ( ) ) { return ( this . initialize ? this . singleton instance : get early singleton instance ( ) ) ; } else { return create instance ( ) ; } }
public void action perform ( action event e ) { if ( `` ok `` . equal ( e . get action command ( ) ) ) { update access control list ( ) ; this . set visible ( false ) ; } else if ( `` cancel `` . equal ( e . get action command ( ) ) ) { updated access control list = null ; this . set visible ( false ) ; } else if ( `` add canonical grantee `` . equal ( e . get action command ( ) ) ) { int row index = canonical grantee table model . add grantee ( new canonical grantee ( `` new canonical id `` ) , permission . permission_read ) ; canonical grantee table . set row selection interval ( row index , row index ) ; } else if ( `` remove canonical grantee `` . equal ( e . get action command ( ) ) ) { if ( canonical grantee table . get select row ( ) > = 0 ) { canonical grantee table model . remove grant and permission ( canonical grantee table . get select row ( ) ) ; } } else if ( `` add email grantee `` . equal ( e . get action command ( ) ) ) { int row index = email grantee table model . add grantee ( new email address grantee ( `` new . email @ address . here `` ) , permission . permission_read ) ; email grantee table . set row selection interval ( row index , row index ) ; } else if ( `` remove email grantee `` . equal ( e . get action command ( ) ) ) { if ( email grantee table . get select row ( ) > = 0 ) { email grantee table model . remove grant and permission ( email grantee table . get select row ( ) ) ; } } else if ( `` add group grantee `` . equal ( e . get action command ( ) ) ) { int row index = group grantee table model . add grantee ( group grantee . authenticated_users , permission . permission_read ) ; group grantee table . set row selection interval ( row index , row index ) ; } else if ( `` remove group grantee `` . equal ( e . get action command ( ) ) ) { if ( group grantee table . get select row ( ) > = 0 ) { group grantee table model . remove grant and permission ( group grantee table . get select row ( ) ) ; } } else { system . err . println ( `` unrecognised action command : `` + e . get action command ( ) ) ; } }
public url get u r l ( url context , string file , string url ) throw malformed u r l exception { if ( file ! = null ) { file f = new file ( file ) ; if ( f . be absolute ( ) ) { return f . to u r i ( ) . to u r l ( ) ; } else { return get u r l ( context , file ) ; } } else if ( url ! = null ) { return get u r l ( context , url ) ; } else { return null ; } }
public static g s credential load g s credential ( ) throw i o exception { input stream property i s = class loader . get system resource a stream ( samples_properties_name ) ; if ( property i s == null ) { throw new runtime exception ( `` unable to load test property file from classpath : `` + samples_properties_name ) ; } property test property = new property ( ) ; test property . load ( property i s ) ; if ( ! test property . contains key ( gs_access_key_property_name ) ) { throw new runtime exception ( `` property file ' `` + samples_properties_name + `` ' do not contain required property : `` + gs_access_key_property_name ) ; } if ( ! test property . contains key ( gs_secret_key_property_name ) ) { throw new runtime exception ( `` property file ' `` + samples_properties_name + `` ' do not contain required property : `` + gs_secret_key_property_name ) ; } g s credential gs credential = new g s credential ( test property . get property ( gs_access_key_property_name ) , test property . get property ( gs_secret_key_property_name ) ) ; return gs credential ; }
public void revoke all permission ( grantee interface grantee ) { list < grant and permission > grant to remove = new array list < grant and permission > ( ) ; for ( grant and permission gap : grant ) { if ( gap . get grantee ( ) . equal ( grantee ) ) { grant to remove . add ( gap ) ; } } grant . remove all ( grant to remove ) ; }
public void set system id ( string uri ) { this . module uri = uri ; }
public stream distribution [ ] list stream distribution ( ) throw cloud front service exception { return list stream distribution ( 100 ) ; }
public distribution [ ] list distribution ( string bucket name ) throw cloud front service exception { list < distribution > bucket distribution = list distribution by bucket name ( false , bucket name ) ; return bucket distribution . to array ( new distribution [ bucket distribution . size ( ) ] ) ; }
public storage bucket [ ] list all bucket ( ) throw service exception { assert authenticate connection ( `` list all bucket `` ) ; storage bucket [ ] bucket = list all bucket impl ( ) ; mx delegate . get instance ( ) . register storage bucket m bean ( bucket ) ; return bucket ; }
public void shutdown ( ) { client execution timer . shutdown ( ) ; http request timer . shutdown ( ) ; idle connection reaper . remove connection manager ( http client . get http client connection manager ( ) ) ; http client . get http client connection manager ( ) . shutdown ( ) ; }
public void set dev pay product token ( string product token ) { this . aws dev pay product token = product token ; }
public void set acl ( access control list acl ) { this . acl = acl ; }
public void set data input stream ( input stream data input stream ) { this . data input file = null ; this . data input stream = data input stream ; }
public void set last modified date ( final date last modified date ) { have last modified date = last modified date ! = null ; if ( have last modified date ) { this . last modified date = java time to ntfs time ( last modify date ) ; } }
public long size ( ) { return long . value of ( content . length ( ) ) ; } // size ( )
public void pre register key definition ( structure q name key name ) { key definition set key set = ( key definition set ) key map . get ( key name ) ; if ( key set==null ) { key set = new key definition set ( key name , key map . size ( ) ) ; key map . put ( key name , key set ) ; } }
public static string generate post policy condition_ allow any value ( string name ) { return `` [ \ `` starts-with\ `` , \ `` $ `` + name + `` \ `` , \ `` \ `` ] `` ; }
public multipart complete multipart complete upload ( multipart upload upload ) throw s3 service exception { list < multipart part > part = multipart list part ( upload ) ; return multipart complete upload impl ( upload . get upload id ( ) , upload . get bucket name ( ) , upload . get object key ( ) , part ) ; }
public void initialize ( encryption info info , cipher algorithm cipher algorithm , hash algorithm hash algorithm , int key bit , int block size , chain mode chain mode ) { if ( cipher algorithm == null ) { cipher algorithm = cipher algorithm . aes128 ; } if ( cipher algorithm ! = cipher algorithm . aes128 & & cipher algorithm ! = cipher algorithm . aes192 & & cipher algorithm ! = cipher algorithm . aes256 ) { throw new encrypt document exception ( `` standard encryption only support aes128/192/256 . `` ) ; } if ( hash algorithm == null ) { hash algorithm = hash algorithm . sha1 ; } if ( hash algorithm ! = hash algorithm . sha1 ) { throw new encrypt document exception ( `` standard encryption only support sha-1 . `` ) ; } if ( chain mode == null ) { chain mode = chain mode . ecb ; } if ( chain mode ! = chain mode . ecb ) { throw new encrypt document exception ( `` standard encryption only support ecb chaining . `` ) ; } if ( key bit == -1 ) { key bit = cipher algorithm . default key size ; } if ( block size == -1 ) { block size = cipher algorithm . block size ; } boolean found = false ; for ( int k : cipher algorithm . allow key size ) { find |= ( ks == key bit ) ; } if ( ! find ) { throw new encrypt document exception ( `` key size `` +key bits+ `` not allow for cipher `` + cipher algorithm ) ; } info . set header ( new standard encryption header ( cipher algorithm , hash algorithm , key bit , block size , chain mode ) ) ; info . set verifier ( new standard encryption verifier ( cipher algorithm , hash algorithm , key bit , block size , chain mode ) ) ; standard decryptor dec = new standard decryptor ( ) ; dec . set encryption info ( info ) ; info . set decryptor ( dec ) ; standard encryptor enc = new standard encryptor ( ) ; enc . set encryption info ( info ) ; info . set encryptor ( enc ) ; }
public void set target request path ( @ nullable string path ) { this . target request path = path ; }
public s3 bucket create bucket ( s3 bucket bucket ) throw s3 service exception { try { assert authenticate connection ( `` create bucket `` ) ; assert valid bucket ( bucket , `` create bucket `` ) ; return ( s3 bucket ) create bucket impl ( bucket . get name ( ) , bucket . get location ( ) , bucket . get acl ( ) ) ; } catch ( service exception se ) { throw new s3 service exception ( se ) ; } }
public void delete object ( s3 bucket bucket , string object key ) throw s3 service exception { try { assert valid bucket ( bucket , `` delete object `` ) ; assert valid object ( object key , `` delete object `` ) ; delete object ( bucket . get name ( ) , object key ) ; } catch ( service exception se ) { throw new s3 service exception ( se ) ; } }
protect date get current time with offset ( ) { return new date ( system . current time millis ( ) + time offset ) ; }
public void add message property ( map property ) { message property . put all ( property ) ; }
public void load and replace property ( property new property , string property source ) { iterator < map . entry < object , object > > prop iter = new property . entry set ( ) . iterator ( ) ; while ( props iter . have next ( ) ) { map . entry < object , object > entry = prop iter . next ( ) ; string property name = ( string ) entry . get key ( ) ; string property value = ( string ) entry . get value ( ) ; if ( property . contains key ( property name ) & & ! property . get property ( property name ) . equal ( property value ) ) { if ( log . be debug enable ( ) ) { log . debug ( `` over-riding jets3t property [ `` + property name + `` = `` + property value + `` ] with value from property source `` + property source + `` . new value : [ `` + property name + `` = `` + trim ( property value ) + `` ] `` ) ; } } property . put ( property name , trim ( property value ) ) ; } load = true ; }
public s3 object get object with sign url ( string sign get url ) throw service exception { return get object with signed url impl ( sign get url , false ) ; }
public cancel task request set reason ( string reason ) { this . reason = reason ; return this ; }
public static input stream open file u r l stream ( url url ) throw i o exception { string protocol = url . get protocol ( ) ; if ( `` file `` . equal ( protocol ) == false & & `` jar `` . equal ( protocol ) == false ) { throw new illegal argument exception ( `` invalid protocol [ `` + protocol + `` ] , must be [ file ] or [ jar ] `` ) ; } if ( string . be empty ( url . get host ( ) ) == false ) { throw new illegal argument exception ( `` url can not have host . find : [ `` + url . get host ( ) + ' ] ' ) ; } if ( url . get port ( ) ! = -1 ) { throw new illegal argument exception ( `` url can not have port . find : [ `` + url . get port ( ) + ' ] ' ) ; } return url . open stream ( ) ; }
public static void init http proxy ( http client http client , string proxy host address , int proxy port , jets3t property jets3t property ) { init http proxy ( http client , jets3t property , false , proxy host address , proxy port , null , null , null ) ; }
public static void set http params factory ( http params factory http params factory ) { if ( http params factory == null ) { throw new illegal argument exception ( `` http params factory may not be null `` ) ; } default http params . http params factory = http params factory ; }
public s3 object [ ] put object ( final s3 bucket bucket , final s3 object [ ] object ) throw s3 service exception { final list object list = new array list ( ) ; s3 service event adaptor adaptor = new s3 service event adaptor ( ) { @ override public void s3 service event perform ( create object event event ) { super . s3 service event perform ( event ) ; if ( service event . event_in_progress == event . get event code ( ) ) { object list . add all ( array . a list ( event . get created object ( ) ) ) ; } } ; } ; ( new s3 service multi ( s3 service , adaptor ) ) . put object ( bucket , object ) ; throw error ( adaptor ) ; return ( s3 object [ ] ) object list . to array ( new s3 object [ object list . size ( ) ] ) ; }
public static boolean be informational ( int code ) { return ( ( 100 < = code ) & & ( code < = 199 ) ) ; }
public boolean fillable ( ) { if ( log . be debug enable ( ) ) log . debug ( `` fillable { } `` , this ) ; callback callback = _interested . get ( ) ; if ( callback ! = null & & _interested . compare and set ( callback , null ) ) { callback . succeed ( ) ; return true ; } if ( log . be debug enable ( ) ) log . debug ( `` { } lose race { } `` , this , callback ) ; return false ; }
public void process connection error ( throwable cause , callback callback ) { if ( log . be debug enable ( ) ) log . debug ( `` process connection error { } `` , this , cause ) ; int code ; if ( cause instanceof close exception ) code = ( ( close exception ) cause ) . get status code ( ) ; else if ( cause instanceof utf8 appendable . not utf8 exception ) code = close status . bad_payload ; else if ( cause instanceof web socket write timeout exception ) code = close status . no_close ; else if ( cause instanceof web socket timeout exception || cause instanceof timeout exception || cause instanceof socket timeout exception ) code = close status . shutdown ; else code = close status . no_close ; close status close status = new close status ( code , cause ) ; if ( close status . be transmittable status code ( code ) ) close ( close status , callback ) ; else { if ( session state . on closed ( close status ) ) close connection ( close status , callback ) ; } }
public void set config path ( path config path ) { _config path = config path ; }
public web http handler builder exception handler ( web exception handler . . . handler ) { if ( ! object utils . be empty ( handler ) ) { this . exception handler . add all ( array . a list ( handler ) ) ; } return this ; }
public void add form encode method ( string method ) { _form encode method . put ( method , boolean . true ) ; }
public boolean be secure ( ) { return this . request . be secure ( ) ; }
public void add error page ( int from , int to , string uri ) { _error page list . add ( new error code range ( from , to , uri ) ) ; }
public void set ssl session cache size ( int ssl session cache size ) { _ssl session cache size = ssl session cache size ; }
public void set ssl session timeout ( int ssl session timeout ) { _ssl session timeout = ssl session timeout ; }
public element type get element type ( ) { return element type ; }
public long get total memory consumption ( ) { long total data page size = 0l ; for ( memory block data page : data page ) { total data page size += data page . size ( ) ; } return total data page size + ( ( long array ! = null ) ? long array . memory block ( ) . size ( ) : 0l ) ; }
public static pattern glob to pattern ( final string glob ) { return pattern . compile ( `` ^ `` + glob . replace ( `` . `` , `` \\ . `` ) . replace ( `` * `` , `` . * `` ) + `` $ `` ) ; }
public scanner get scanner ( ) { return _scanner ; }
public java . lang . string get description ( ) { java . lang . object ref = description_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; description_ = s ; return s ; } }
public void pop ( ) throw java . lang . exception { if ( vstack . empty ( ) ) throw new exception ( `` internal parser error : pop from empty virtual stack `` ) ; / * pop it * / vstack . pop ( ) ; / * if we be now empty transfer an element ( if there be one ) * / if ( vstack . empty ( ) ) get_from_real ( ) ; }
public int [ ] get not class code ( list < interval > interval list ) { return get class code ( new int char set ( interval list ) , true ) ; }
public void set into ( read writable period writable period , object object , chronology chrono ) { readable interval interval = ( readable interval ) object ; chrono = ( chrono ! = null ? chrono : date time utils . get interval chronology ( interval ) ) ; long start = interval . get start millis ( ) ; long end = interval . get end millis ( ) ; int [ ] value = chrono . get ( writable period , start , end ) ; for ( int i = 0 ; i < value . length ; i++ ) { writable period . set value ( i , value [ i ] ) ; } }
public static short [ ] to object ( final short [ ] array ) { if ( array == null ) { return null ; } else if ( array . length == 0 ) { return empty_short_object_array ; } final short [ ] result = new short [ array . length ] ; for ( int i = 0 ; i < array . length ; i++ ) { result [ i ] = short . value of ( array [ i ] ) ; } return result ; }
public static void main ( string [ ] args ) { quorum peer main main = new quorum peer main ( ) ; try { main . initialize and run ( args ) ; } catch ( illegal argument exception e ) { log . error ( `` invalid argument , exit abnormally `` , e ) ; log . info ( usage ) ; system . err . println ( usage ) ; system . exit ( 2 ) ; } catch ( config exception e ) { log . error ( `` invalid config , exit abnormally `` , e ) ; system . err . println ( `` invalid config , exit abnormally `` ) ; system . exit ( 2 ) ; } catch ( exception e ) { log . error ( `` unexpected exception , exit abnormally `` , e ) ; system . exit ( 1 ) ; } log . info ( `` exit normally `` ) ; system . exit ( 0 ) ; }
public void set dir ( file dir ) { this . dir = dir ; get implicit file set ( ) . set dir ( dir ) ; }
public void emit error message ( string msg ) { system . err . println ( msg ) ; }
public static runtime exception wrap or throw ( throwable error ) { if ( error instanceof error ) { throw ( error ) error ; } if ( error instanceof runtime exception ) { return ( runtime exception ) error ; } return new runtime exception ( error ) ; }
public void add backwards ( string str ) { last yank = false ; if ( last kill ) { if ( slots [ head ] ! = null ) { slots [ head ] = str + slot [ head ] ; return ; } } last kill = true ; next ( ) ; slot [ head ] = str ; }
public long content length ( ) throw i o exception { input stream be = get input stream ( ) ; assert . state ( be ! = null , `` resource input stream must not be null `` ) ; try { long size = 0 ; byte [ ] buf = new byte [ 255 ] ; int read ; while ( ( read = be . read ( buf ) ) ! = -1 ) { size += read ; } return size ; } finally { try { be . close ( ) ; } catch ( i o exception ex ) { } } }
public static output stream construct output stream ( data output out ) { if ( out instanceof output stream ) { return ( output stream ) out ; } else { return new data output output stream ( out ) ; } }
public void restore system property ( ) throw build exception { sys property . restore system ( ) ; }
public json node visit ( jmes path projection jmes path projection , json node input ) throw invalid type exception { json node lhs result = jmes path projection . get lhs expr ( ) . accept ( this , input ) ; if ( lhs result . be array ( ) ) { iterator < json node > element = lhs result . element ( ) ; array node project array node = object mapper singleton . get object mapper ( ) . create array node ( ) ; while ( element . have next ( ) ) { json node project element = jmes path projection . get projection expr ( ) . accept ( this , element . next ( ) ) ; if ( project element ! = null ) { projected array node . add ( project element ) ; } } return projected array node ; } return null node . get instance ( ) ; }
public json node visit ( jmes path function function , json node input ) throw invalid type exception { list < json node > evaluate argument = new array list < json node > ( ) ; list < jmes path expression > argument = function . get expression ( ) ; for ( jmes path expression arg : argument ) { evaluated argument . add ( arg . accept ( this , input ) ) ; } return function . evaluate ( evaluated argument ) ; }
public json node visit ( jmes path projection jmes path projection , json node input ) throw invalid type exception { json node lhs result = jmes path projection . get lhs expr ( ) . accept ( this , input ) ; if ( lhs result . be array ( ) ) { iterator < json node > element = lhs result . element ( ) ; array node project array node = object mapper singleton . get object mapper ( ) . create array node ( ) ; while ( element . have next ( ) ) { json node project element = jmes path projection . get projection expr ( ) . accept ( this , element . next ( ) ) ; if ( project element ! = null ) { projected array node . add ( project element ) ; } } return projected array node ; } return null node . get instance ( ) ; }
public json node evaluate ( list < json node > evaluate args ) { json node subject = evaluate args . get ( 0 ) ; json node search = evaluate args . get ( 1 ) ; if ( subject . be array ( ) ) { return do array contain ( subject , search ) ; } else if ( subject . be textual ( ) ) { return do string contain ( subject , search ) ; } throw new invalid type exception ( `` type mismatch . expect a string or an array . `` ) ; }
public json node visit ( jmes path and expression and expression , json node input ) throw invalid type exception { json node lhs node = and expression . get lhs expr ( ) . accept ( this , input ) ; json node rhs node = and expression . get rhs expr ( ) . accept ( this , input ) ; if ( lhs node == boolean node . true ) { return rh node ; } else { return lhs node ; } }
public boolean match ( big decimal lh , big decimal rh ) { return lh . compare to ( rhs ) > = 0 ; }
public static thread group get system thread group ( ) { thread group thread group = thread . current thread ( ) . get thread group ( ) ; while ( thread group . get parent ( ) ! = null ) { thread group = thread group . get parent ( ) ; } return thread group ; }
public int get subgroup thread index ( ) { return subgroup thread idx ; }
public run result run single ( ) throw runner exception { set < benchmark list entry > benchmarks = list . find ( out , option . get include ( ) , option . get excludes ( ) ) ; if ( benchmark . size ( ) == 1 ) { collection < run result > value = run ( ) ; if ( value . size ( ) == 1 ) { return value . iterator ( ) . next ( ) ; } else { throw new runner exception ( `` no result return `` ) ; } } else { if ( benchmark . size ( ) > 1 ) { throw new runner exception ( `` more than single benchmark be match the option : `` + benchmark ) ; } else { throw new no benchmarks exception ( ) ; } } }
public double of ( double [ ] d , int num param ) { double a = math . sqrt ( ( d [ 0 ] + 1 ) / 2 ) ; double b = math . sqrt ( ( d [ 0 ] - 1 ) / 2 ) ; return 2 * math . log ( a + b ) ; }
public static < t > t get field ( class < ? > class with static field , class < t > field type ) { return field reflection . get field ( class with static field , field type , null ) ; }
public static < t > t new instance ( class < ? extend t > class to instantiate , class < ? > [ ] parameter type , object . . . init args ) { return constructor reflection . new instance ( class to instantiate , parameter type , init args ) ; }
public static < t > t new instance ( class < ? extend t > class to instantiate , class < ? > [ ] parameter type , object . . . init args ) { return constructor reflection . new instance ( class to instantiate , parameter type , init args ) ; }
public static void premain ( string agent args , instrumentation inst ) { instrumentation = inst ; }
public string get string ( long offset , boolean wide ) { return wide ? get wide string ( offset ) : get string ( offset ) ; }
public void set auto read ( boolean auto ) { this . auto read = auto ; }
public constant get constant ( string name ) { constant c = name to constant . get ( name ) ; if ( c == null ) { synchronize ( lock ) { if ( ! name to constant . contains key ( name ) ) { jnr . constant . constant jnr constant = constant . get constant ( name ) ; if ( jnr constant ! = null ) { name to constant . put ( name , c = new constant impl ( jnr constant ) ) ; value to constant . put ( jnr constant . int value ( ) , c ) ; } } } } return c ; }
public long range get range ( long value , long range reuse ) { if ( reuse == null ) reuse = new long range ( long . min_value , long . max_value ) ; if ( value < min ) { reuse . max = min ; reuse . min = long . min_value ; return reuse ; } if ( value > = max ) { reuse . min = max ; reuse . max = long . max_value ; return reuse ; } long bucket = ( value - min ) / width ; reuse . min = min + ( bucket * width ) ; reuse . max = reuse . min + width ; return reuse ; }
public final int native size ( runtime runtime ) { return 1 ; }
public void from native ( runtime runtime , pointer buffer , long offset ) { this . value = buffer . get float ( offset ) ; }
public void from native ( runtime runtime , pointer buffer , long offset ) { this . value = buffer . get short ( offset ) ; }
public void from native ( runtime runtime , pointer memory , long offset ) { this . value = native long . value of ( memory . get native long ( offset ) ) ; }
public static < t > t require non null ( t object , string message ) { if ( object == null ) { throw new null pointer exception ( message ) ; } return object ; }
public final long native address ( ) { return address ; }
protect final double [ ] array ( double [ ] array ) { array begin ( ) ; for ( int i = 0 ; i < array . length ; ++i ) { array [ i ] = new double ( ) ; } array end ( ) ; return array ; }
protect final double [ ] array ( double [ ] array ) { array begin ( ) ; for ( int i = 0 ; i < array . length ; ++i ) { array [ i ] = new double ( ) ; } array end ( ) ; return array ; }
protect final sign long [ ] array ( sign long [ ] array ) { array begin ( ) ; for ( int i = 0 ; i < array . length ; ++i ) { array [ i ] = new sign long ( ) ; } array end ( ) ; return array ; }
public object get property ( string name ) { if ( name == null ) { throw new illegal argument exception ( `` parameter 'name ' must be not null `` ) ; } return this . property . get ( name ) . get value ( ) ; }
public boolean kill ( int signal ) throw i o exception { if ( lib c . instance . kill ( pid , signal ) ! = -1 ) { return true ; } int errno = native . get last error ( ) ; if ( errno == lib c . esrch ) { return false ; } throw new i o exception ( `` error kill target process with signal `` + signal + `` - errno = `` + errno ) ; }
public static final mem xmmword_ptr ( label label , long disp ) { return _ptr_build ( label , disp , size_dqword ) ; }
public final void fldz ( ) { emit x86 ( inst_fldz ) ; }
public final void pinsrw ( m m register dst , register src , immediate imm8 ) { emit x86 ( inst_pinsrw , dst , src , imm8 ) ; }
public final void btc ( register dst , register src ) { emit x86 ( inst_btc , dst , src ) ; }
public final void cmpxchg ( register dst , register src ) { emit x86 ( inst_cmpxchg , dst , src ) ; }
public final void fldz ( ) { emit x86 ( inst_fldz ) ; }
public final void ficomp ( mem src ) { assert ( src . size ( ) == 2 || src . size ( ) == 4 ) ; emit x86 ( inst_ficomp , src ) ; }
public final void fldz ( ) { emit x86 ( inst_fldz ) ; }
public final void pmulhw ( m m register dst , m m register src ) { emit x86 ( inst_pmulhw , dst , src ) ; }
public final void pmulhw ( m m register dst , m m register src ) { emit x86 ( inst_pmulhw , dst , src ) ; }
public final void pmulhw ( m m register dst , m m register src ) { emit x86 ( inst_pmulhw , dst , src ) ; }
public final void pmulhw ( m m register dst , m m register src ) { emit x86 ( inst_pmulhw , dst , src ) ; }
public final void cmppd ( x m m register dst , x m m register src , immediate imm8 ) { emit x86 ( inst_cmppd , dst , src , imm8 ) ; }
public final void fdiv ( mem src ) { emit x86 ( inst_fdiv , src ) ; }
public final void movlps ( x m m register dst , mem src ) { emit x86 ( inst_movlps , dst , src ) ; }
public final void paddw ( x m m register dst , x m m register src ) { emit x86 ( inst_paddw , dst , src ) ; }
public final void paddw ( x m m register dst , x m m register src ) { emit x86 ( inst_paddw , dst , src ) ; }
public final void psadbw ( x m m register dst , x m m register src ) { emit x86 ( inst_psadbw , dst , src ) ; }
public final void paddw ( x m m register dst , x m m register src ) { emit x86 ( inst_paddw , dst , src ) ; }
public final void paddw ( x m m register dst , x m m register src ) { emit x86 ( inst_paddw , dst , src ) ; }
public final void paddw ( x m m register dst , x m m register src ) { emit x86 ( inst_paddw , dst , src ) ; }
public final void paddw ( x m m register dst , x m m register src ) { emit x86 ( inst_paddw , dst , src ) ; }
public final void fldz ( ) { emit x86 ( inst_fldz ) ; }
public final void paddw ( x m m register dst , x m m register src ) { emit x86 ( inst_paddw , dst , src ) ; }
public final void pmaxsb ( x m m register dst , x m m register src ) { emit x86 ( inst_pmaxsb , dst , src ) ; }
public final void pavgb ( m m register dst , m m register src ) { emit x86 ( inst_pavgb , dst , src ) ; }
public final void pcmpgtw ( m m register dst , m m register src ) { emit x86 ( inst_pcmpgtw , dst , src ) ; }
public final void pcmpgtd ( m m register dst , m m register src ) { emit x86 ( inst_pcmpgtd , dst , src ) ; }
public final void paddw ( x m m register dst , x m m register src ) { emit x86 ( inst_paddw , dst , src ) ; }
public final void paddw ( x m m register dst , x m m register src ) { emit x86 ( inst_paddw , dst , src ) ; }
public final void pmulhw ( m m register dst , m m register src ) { emit x86 ( inst_pmulhw , dst , src ) ; }
public final void roundpd ( x m m register dst , x m m register src , immediate imm8 ) { emit x86 ( inst_roundpd , dst , src , imm8 ) ; }
public final void paddw ( x m m register dst , x m m register src ) { emit x86 ( inst_paddw , dst , src ) ; }
public final void paddw ( x m m register dst , x m m register src ) { emit x86 ( inst_paddw , dst , src ) ; }
public chart format category a text ( boolean new category a text ) { return new chart format ( output , type , display , width , height , category , new category a text , value , shade , show horizontal legend , show vertical legend , newline , numeric format ) ; }
public chart format show horizontal legend ( boolean new show horizontal legend ) { return show legend ( new show horizontal legend , show vertical legend ) ; }
public static s q l exception converter build minimal s q l exception converter ( ) { return new s q l exception converter ( ) { public j d b c exception convert ( s q l exception sql exception , string message , string sql ) { return new generic j d b c exception ( message , sql exception , sql ) ; } } ; }
public string get subselect ( ) { return subselect ; }
public pretty printer configuration set indent size ( int indent size ) { indentation indentation = get indentation ( ) . set size ( assert non negative ( indent size ) ) ; set indentation ( indentation ) ; return this ; }
public void set render schema ( boolean value ) { this . render schema = value ; }
public render format get render formatting ( ) { return render formatting ; }
public void set render scalar subqueries for stored function ( boolean value ) { this . render scalar subqueries for stored function = value ; }
public static final backslash escape get backslash escaping ( settings setting ) { if ( setting ! = null ) { backslash escape result = setting . get backslash escaping ( ) ; if ( result ! = null ) return result ; } return backslash escaping . default ; }
public void set execute with optimistic lock exclude unversioned ( boolean value ) { this . execute with optimistic lock exclude unversioned = value ; }
public void set fetch warning ( boolean value ) { this . fetch warning = value ; }
public address resolver option set query timeout ( long query timeout ) { if ( query timeout < 1 ) { throw new illegal argument exception ( `` query timeout must be > 0 `` ) ; } this . query timeout = query timeout ; return this ; }
public int get max row ( ) { return this . max row ; }
public void set max row ( int max row ) { this . jdbc template . set max row ( max row ) ; }
public integer get default fetch size ( ) { return default fetch size ; }
public index meta data generation with removed snapshot ( collection < snapshot id > snapshot id ) { final map < snapshot id , map < index id , string > > update index meta lookup = new hash map < > ( lookup ) ; update index meta lookup . key set ( ) . remove all ( snapshot id ) ; final map < string , string > updated index meta identifier = new hash map < > ( identifier ) ; update index meta identifier . key set ( ) . remove if ( k - > updated index meta lookup . value ( ) . stream ( ) . none match ( identifier - > identifier . contains value ( k ) ) ) ; return new index meta data generation ( updated index meta lookup , updated index meta identifier ) ; }
public static final param type get param type ( settings setting ) { if ( execute static statement ( setting ) ) { return inlined ; } else if ( setting ! = null ) { param type result = setting . get param type ( ) ; if ( result ! = null ) return result ; } return indexed ; }
public c s v format quote string ( string new quote string ) { return new c s v format ( delimiter , null string , empty string , newline , new quote string , quote , header ) ; }
protect final d s l context create ( ) { return create ( configuration ( ) ) ; }
public static execute listener provider [ ] provider ( execute listener . . . listener ) { execute listener provider [ ] result = new execute listener provider [ listener . length ] ; for ( int i = 0 ; i < listener . length ; i++ ) result [ i ] = new default execute listener provider ( listener [ i ] ) ; return result ; }
public static create view a step create view ( string view , string . . . field ) { return dsl ( ) . create view ( view , field ) ; }
public static create sequence final step create sequence ( string sequence ) { return dsl ( ) . create sequence ( sequence ) ; }
public static drop view final step drop view if exists ( string view ) { return dsl ( ) . drop view if exists ( view ) ; }
public static < r extend record > quantify select < r > all ( select < r > select ) { return new quantified select impl < r > ( quantifier . all , select ) ; }
public static grant on step grant ( privilege . . . privilege ) { return dsl ( ) . grant ( privilege ) ; }
public static table < record1 < integer > > generate series ( int from , int to ) { return generate series ( val ( from ) , val ( to ) ) ; }
public static long object field offset ( class < ? > clazz , string field name ) { try { return unsafe . object field offset ( clazz . get declared field ( field name ) ) ; } catch ( no such field exception | security exception e ) { throw new error ( e ) ; } }
public static < t > field < t > isnull ( t value , t default value ) { return nvl ( value , default value ) ; }
public static field < string > lpad ( field < string > field , int length ) { return lpad ( null safe ( field ) , tool . field ( length ) ) ; }
public static field < integer > position ( string in , string search , int start index ) { return position ( tools . field ( in ) , tool . field ( search ) , tool . field ( start index ) ) ; }
public static < t > field < t > great ( t value , t . . . value ) { return great ( tool . field ( value ) , tool . field ( value ) . to array ( empty_field ) ) ; }
public static long time difference ( date date1 , date date2 ) { check argument ( date1 ! = null & & date2 ! = null , `` expect date parameter not to be null `` ) ; return math . ab ( date1 . get time ( ) - date2 . get time ( ) ) ; }
public static < t > field < t > trunc ( field < t > date , date part part ) { return new trunc date < t > ( date , part ) ; }
public static field < integer > extract ( java . util . date value , date part date part ) { return extract ( tool . field ( convert . convert ( value , timestamp . class ) ) , date part ) ; }
public static field < day to second > timestamp diff ( timestamp timestamp1 , timestamp timestamp2 ) { return timestamp diff ( tool . field ( timestamp1 ) , tool . field ( timestamp2 ) ) ; }
public static group field group set ( field < ? > . . . field ) { list < field < ? > > [ ] array = new list [ field . length ] ; for ( int i = 0 ; i < field . length ; i++ ) { array [ i ] = array . < field < ? > > a list ( field [ i ] ) ; } return group set ( array ) ; }
public static < t extend number > field < t > bit nor ( t value1 , t value2 ) { return bit nor ( tool . field ( value1 ) , tool . field ( value2 ) ) ; }
public static < t extend number > field < t > round ( t value , int decimal ) { return round ( tool . field ( value ) , decimal ) ; }
public static field < big decimal > power ( number value , number exponent ) { return power ( tool . field ( value ) , tool . field ( exponent ) ) ; }
public static field < big decimal > power ( number value , number exponent ) { return power ( tool . field ( value ) , tool . field ( exponent ) ) ; }
public static aggregate function < integer > count distinct ( field < ? > field ) { return new org . jooq . impl . function < integer > ( `` count `` , true , s q l data type . integer , null safe ( field ) ) ; }
public static order aggregate function < string > list agg ( field < ? > field ) { return new org . jooq . impl . function < string > ( term . list_agg , s q l data type . varchar , null safe ( field ) ) ; }
public static window over step < big decimal > cume dist ( ) { return new org . jooq . impl . function < big decimal > ( `` cume_dist `` , s q l data type . numeric ) ; }
public static < t > param < t > param ( string name , class < t > type ) { return param ( name , default data type . get data type ( null , type ) ) ; }
public static param < integer > one ( ) { return inline ( 1 ) ; }
public current user atom get current user atom ( ) { return current user ; }
public static boolean cancel ( atomic reference < subscription > field ) { subscription current = field . get ( ) ; if ( current ! = cancel ) { current = field . get and set ( cancel ) ; if ( current ! = cancel ) { if ( current ! = null ) { current . cancel ( ) ; } return true ; } } return false ; }
public string get native sql ( ) { if ( sql ! = null ) { return sql ; } sql = build native sql ( null ) ; return sql ; }
public boolean batch multiple ( ) { return sql . length > 1 ; }
public static int value of ( object generate key request ) { if ( boolean . false . equal ( generate key request ) ) { return none ; } if ( boolean . true . equal ( generate key request ) ) { return auto ; } if ( generate key request instanceof int [ ] ) { return column_numbers ; } if ( generate key request instanceof string [ ] ) { return column_names ; } throw db exception . get ( error code . invalid_value_2 , generate key request == null ? `` null `` : generate key request . to string ( ) ) ; }
public static reflect on ( string name ) throw reflect exception { return on ( for name ( name ) ) ; }
public static string default if empty ( string str , string default str ) { return string utils . be empty ( str ) ? default str : str ; }
public int get string width ( string str ) { int width = 0 ; for ( int i = 0 ; i < str . length ( ) ; i++ ) { width += get char width ( str . char at ( i ) ) ; } return width ; }
public static boolean null equal ( object o1 , object o2 ) { return o1 == o2 || o1 ! = null & & o2 ! = null & & o1 . equal ( o2 ) ; }
public t x t format max col width ( int new max col width ) { return new t x t format ( max row , min col width , new max col width , horizontal table border , horizontal header border , horizontal cell border , vertical table border , vertical cell border , intersect line ) ; }
public t x t format horizontal cell border ( boolean new horizontal cell border ) { return new t x t format ( max row , min col width , max col width , horizontal table border , horizontal header border , new horizontal cell border , vertical table border , vertical cell border , intersect line ) ; }
public t x t format horizontal cell border ( boolean new horizontal cell border ) { return new t x t format ( max row , min col width , max col width , horizontal table border , horizontal header border , new horizontal cell border , vertical table border , vertical cell border , intersect line ) ; }
public minute to standard minute ( ) { long minute = get standard minute ( ) ; return minute . minute ( field utils . safe to int ( minute ) ) ; }
public static field < string > aes decrypt ( string crypt string , string key string ) { return aes decrypt ( val ( crypt string ) , val ( key string ) ) ; }
public static field < integer > uncompressed length ( string string ) { return uncompress length ( val ( string ) ) ; }
public static field < string > aes encrypt ( string string , string key string ) { return aes encrypt ( val ( string ) , val ( key string ) ) ; }
public static byte [ ] compress string ( string value ) { return compress string ( value , deflater . best_compression ) ; }
public static field < integer > uncompressed length ( string string ) { return uncompress length ( val ( string ) ) ; }
public static < t > field < t [ ] > array prepend ( t value , t [ ] array ) { return array prepend0 ( val ( value ) , val ( array ) ) ; }
public static table < record > only ( table < ? > table ) { return table ( `` { only } { 0 } `` , table ) ; }
public static object to p g interval ( year to second interval ) { return new p g interval ( interval . get sign ( ) * interval . get year ( ) , interval . get sign ( ) * interval . get month ( ) , interval . get sign ( ) * interval . get day ( ) , interval . get sign ( ) * interval . get hour ( ) , interval . get sign ( ) * interval . get minute ( ) , interval . get sign ( ) * interval . get second ( ) + interval . get sign ( ) * interval . get nano ( ) / 1000000000 . 0 ) ; }
public data type get data type ( ) { return data type ; }
public void set numeric precision ( integer value ) { this . numeric precision = value ; }
public ordinal parameter descriptor get ordinal parameter descriptor ( int position ) { final ordinal parameter descriptor descriptor = ordinal descriptor map . get ( position ) ; if ( descriptor == null ) { throw new illegal argument exception ( string . format ( locale . root , `` could not locate ordinal parameter [ % s ] , expect one of [ % s ] `` , position , string helper . join ( `` , `` , ordinal descriptor map . key set ( ) . iterator ( ) ) ) ) ; } return descriptor ; }
public boolean support catalog in index definition ( ) { debug code call ( `` support catalog in index definition `` ) ; return true ; }
public void set sequence catalog ( string value ) { this . sequence catalog = value ; }
public boolean be descend ( ) { return this . descend ; }
public void set unique constraint catalog ( string value ) { this . unique constraint catalog = value ; }
public string get specific catalog ( ) { return specific catalog ; }
public string get unique constraint schema ( ) { return unique constraint schema ; }
public void set routine schema ( string value ) { this . routine schema = value ; }
public void set include package routine ( boolean value ) { this . include package routine = value ; }
public table constraint type get constraint type ( ) { return constraint type ; }
public x m l format xmlns ( boolean new xmlns ) { return new x m l format ( new xmlns , format , newline , indent , indent , header , record format ) ; }
public schema get schema ( string schema resource ) { schema schema = schema cache . get ( schema resource ) ; if ( schema ! = null ) { return schema ; } schema = load schema ( schema resource ) ; if ( schema ! = null ) { schema previous = schema cache . put if absent ( schema resource , schema ) ; return previous ! = null ? previous : schema ; } else { return null ; } }
public render optional keyword get render optional inner keyword ( ) { return render optional inner keyword ; }
public void set render parenthesis around set operation query ( boolean value ) { this . render parenthesis around set operation query = value ; }
public void set inverse foreign key ( jaxb foreign key value ) { this . inverse foreign key = value ; }
public void declare default value ( j expression value ) { this . default value = value ; }
public final boolean drop table cascade ( ) { return drop table cascade ; }
public boolean be enforce protection ( ) { return setting . be enforce with ( ) ; }
public void set include table ( boolean value ) { this . include table = value ; }
public boolean be include exclude package routine ( ) { return include exclude package routine ; }
public boolean be include package constant ( ) { return include package constant ; }
public void set include system u d t ( boolean value ) { this . include system u d t = value ; }
public boolean be include system sequence ( ) { return include system sequence ; }
public void set include foreign key ( boolean value ) { this . include foreign key = value ; }
public void set override primary key ( string value ) { this . override primary key = value ; }
public boolean be unsigned type ( ) { return unsigned type ; }
public void set input schema ( string value ) { this . input schema = value ; }
public void set output schema to default ( boolean value ) { this . output schema to default = value ; }
public relation get relation ( ) { return relation ; }
public void set deprecate delegate ( boolean deprecate delegate ) { f deprecate delegate= deprecate delegate ; }
public pem key cert option set key value ( buffer key value ) { key value . clear ( ) ; if ( key value ! = null ) { key value . add ( key value ) ; } return this ; }
public void set immutable interface ( boolean value ) { this . immutable interface = value ; }
public void set serializable interface ( boolean value ) { this . serializable interface = value ; }
public void set jpa version ( string value ) { this . jpa version = value ; }
public boolean be global key reference ( ) { return global key reference ; }
public boolean be comment on table ( ) { return comment on table ; }
public void set comment on key ( boolean value ) { this . comment on key = value ; }
public static comment on be step comment on column ( name column name ) { return dsl ( ) . comment on column ( column name ) ; }
public boolean be comment on attribute ( ) { return comment on attribute ; }
public boolean be comment on routine ( ) { return comment on routine ; }
public void set vararg setter ( boolean value ) { this . vararg setter = value ; }
public index get fully qualify index ( ) { return fully qualified index ; }
public web driver augment ( web driver driver ) { remote web driver remote driver = extract remote web driver ( driver ) ; if ( remote driver == null ) { return driver ; } return create ( remote driver , driver augmentors , driver ) ; }
public void set username ( string username ) { this . username = username ; } // -- void set username ( string )
public void set password ( string password ) { this . password = password ; this . add pending change ( `` password `` , password . to string ( ) ) ; }
public static value enum get enum ( class enum class , int value ) { return ( value enum ) value enum . get enum ( enum class , value ) ; }
public void set routine method ( matcher rule value ) { this . routine method = value ; }
public void set schema class ( matcher rule value ) { this . schema class = value ; }
public void set pojo class ( matcher rule value ) { this . pojo class = value ; }
public void set__2 ( field < integer > field ) { set field ( _2 , field ) ; }
public void set meta include system index ( boolean value ) { this . meta include system index = value ; }
public bean definition builder set synthetic ( boolean synthetic ) { this . bean definition . set synthetic ( synthetic ) ; return this ; }
public boolean be integer display width ( ) { return integer display width ; }
public detach criterion set comment ( string comment ) { criterion . set comment ( comment ) ; return this ; }
public final boolean default sequence flag ( ) { return default sequence flag ; }
public annotation value builder < t > value ( @ nullable annotation value < ? > . . . annotation ) { return member ( annotation metadata . value_member , annotation ) ; }
public boolean be pojos a kotlin data class ( ) { return pojos a kotlin data class ; }
public void set kotlin setter jvm name annotation on be prefix ( boolean value ) { this . kotlin setter jvm name annotation on be prefix = value ; }
public boolean be comment on embeddables ( ) { return comment on embeddables ; }
public static boolean be valid expression ( @ nullable string expression ) { if ( expression == null ) { return false ; } try { parse ( expression ) ; return true ; } catch ( illegal argument exception ex ) { return false ; } }
public table get table ( ) { if ( table ! = null ) { return table ; } if ( be secondary ( ) ) { return get join ( ) . get table ( ) ; } else { return property holder . get table ( ) ; } }
public detach criterion set comment ( string comment ) { criterion . set comment ( comment ) ; return this ; }
public context get supply key provider context ( ) { return supply key provider context ; }
public jwt consumer build ( ) { list < validator > validators = new array list < > ( ) ; if ( ! skip all validators ) { if ( ! skip all default validators ) { if ( ! skip default audience validation ) { if ( aud validator == null ) { aud validator = new aud validator ( collection . < string > empty set ( ) , false ) ; } validators . add ( aud validator ) ; } if ( iss validator == null ) { iss validator = new iss validator ( null , false ) ; } validators . add ( iss validator ) ; validators . add ( date claim validator ) ; sub validator sub validator = expect subject == null ? new sub validator ( require subject ) : new sub validator ( expect subject ) ; validators . add ( sub validator ) ; validators . add ( new jti validator ( require jti ) ) ; } validators . add all ( custom validators ) ; } jwt consumer jwt consumer = new jwt consumer ( ) ; jwt consumer . set validators ( validators ) ; jwt consumer . set verification key resolver ( verification key resolver ) ; jwt consumer . set decryption key resolver ( decryption key resolver ) ; jwt consumer . set jws algorithm constraint ( jws algorithm constraint ) ; jwt consumer . set jwe algorithm constraint ( jwe algorithm constraint ) ; jwt consumer . set jwe content encryption algorithm constraint ( jwe content encryption algorithm constraint ) ; jwt consumer . set require signature ( require signature ) ; jwt consumer . set require encryption ( require encryption ) ; jwt consumer . set liberal content type handling ( liberal content type handling ) ; jwt consumer . set skip signature verification ( skip signature verification ) ; jwt consumer . set relax verification key validation ( relax verification key validation ) ; jwt consumer . set relax decryption key validation ( relax decryption key validation ) ; jwt consumer . set jws customizer ( jws customizer ) ; jwt consumer . set jwe customizer ( jwe customizer ) ; jwt consumer . set jws provider context ( jws provider context ) ; jwt consumer . set jwe provider context ( jwe provider context ) ; return jwt consumer ; }
public jwt consumer builder set expect issuer ( boolean require issuer , string expect issuer ) { iss validator = new iss validator ( expect issuer , require issuer ) ; return this ; }
public void set mode ( byte mode ) { if ( mode < = inout & & mode > = in ) { this . mode = mode ; } }
public vector get identity name ( ) throw j sch exception { vector foo=new vector ( ) ; vector identity = identity repository . get identity ( ) ; for ( int i=0 ; i < identity . size ( ) ; i++ ) { identity identity= ( identity ) ( identity . element at ( i ) ) ; foo . add element ( identity . get name ( ) ) ; } return foo ; }
public session get session ( string host ) throw j sch exception { return get session ( null , host , 22 ) ; }
public session get session ( string host , int port , string username , string user password , file pem file , string pem password , file pas file ) throw i o exception { check . check not null ( host , `` host `` ) ; check . check not null ( username , `` user `` ) ; entry entry = get cache entry ( username , host , port ) ; session session = null ; if ( entry ! = null ) { session = entry . get session ( ) ; } if ( session == null || ! session . be connect ( ) ) { message . verbose ( `` : : ssh : : connecting to `` + host + `` . . . `` ) ; try { j sch jsch = new j sch ( ) ; if ( port ! = -1 ) { session = jsch . get session ( username , host , port ) ; } else { session = jsch . get session ( username , host ) ; } if ( pem file ! = null ) { jsch . add identity ( pem file . get absolute path ( ) , pem password ) ; } session . set user info ( new cf user info ( host , username , user password , pem file , pem password , pas file ) ) ; session . set daemon thread ( true ) ; session . connect ( ) ; message . verbose ( `` : : ssh : : connect to `` + host + `` ! `` ) ; set session ( username , host , port , session ) ; } catch ( j sch exception e ) { if ( pas file ! = null & & pas file . exists ( ) ) { pas file . delete ( ) ; } i o exception ex = new i o exception ( e . get message ( ) ) ; ex . init cause ( e ) ; throw ex ; } } return session ; }
public int do start tag ( ) throw jsp exception { return skip_body ; }
public tag info get tag info ( ) { return tag info ; }
public void set init parameter ( property init parameter ) { this . init parameter = init parameter ; }
public object get value ( string k ) { if ( value == null ) { return null ; } else { return value . get ( k ) ; } }
public void remove speed test listener ( final i speed test listener listener ) { m listener list . remove ( listener ) ; }
public void set socket timeout ( final int socket timeout millis ) { if ( socket timeout millis > = 0 ) { m socket timeout = socket timeout millis ; } }
public void set computation method ( final computation method computation method ) { m computation method = computation method ; }
public void set upload setup time ( final long setup time ) { this . m upload setup time = setup time ; }
public void set upload storage type ( final upload storage type upload storage type ) { m upload storage type = upload storage type ; }
public random access file generate random file ( final int length ) throw i o exception { m file = file . create temp file ( speed test const . upload_temp_file_name , speed test const . upload_temp_file_extension ) ; final random access file random file = new random access file ( m file . get absolute path ( ) , `` rw `` ) ; random file . set length ( length ) ; final int iter = length / speed test const . upload_file_write_chunk ; final int remain = length % speed test const . upload_file_write_chunk ; for ( int i = 0 ; i < iter ; i++ ) { final byte [ ] random = new byte [ speed test const . upload_file_write_chunk ] ; m random . next byte ( random ) ; random file . write ( random ) ; } if ( remain > 0 ) { final byte [ ] random = new byte [ remain ] ; m random . next byte ( random ) ; random file . write ( random ) ; } return random file ; }
public static string generate name ( ) { return uuid . random u u i d ( ) . to string ( ) ; }
public static double interior angle ( coordinate p0 , coordinate p1 , coordinate p2 ) { double angle prev = angle . angle ( p1 , p0 ) ; double angle next = angle . angle ( p1 , p2 ) ; return math . ab ( angle next - angle prev ) ; }
public double probability ( double x ) { double fl = math . floor ( x ) ; if ( fl == x ) { return this . probability ( ( int ) x ) ; } else { return 0 ; } }
public static boolean be point in ring ( coordinate p , coordinate [ ] ring ) { return locate point in ring ( p , ring ) ! = location . exterior ; }
public boolean be do ( ) { / * * * if find all type , we can stop * when both possible type have be find . * / if ( find all type ) { return have proper intersection & & have non proper intersection ; } / * * * if search for a proper intersection , only stop if one be find * / if ( find proper ) { return have proper intersection ; } return have intersection ; }
public static geometry get minimum diameter ( geometry geom ) { return ( new minimum diameter ( geom ) ) . get diameter ( ) ; }
public void add ( collection geom list ) { for ( iterator i = geom list . iterator ( ) ; i . have next ( ) ; ) { geometry geometry = ( geometry ) i . next ( ) ; add ( geometry ) ; } }
public half edge find edge ( coordinate orig , coordinate d ) { half edge e = ( half edge ) vertex map . get ( orig ) ; if ( e == null ) return null ; return e . find ( d ) ; }
public static coordinate [ ] remove repeat point ( coordinate [ ] coord ) { if ( ! have repeat point ( coord ) ) return coord ; coordinate list coord list = new coordinate list ( coord , false ) ; return coord list . to coordinate array ( ) ; }
public static double max ( double a , double b ) { if ( double . be na n ( a ) ) { return b ; } else if ( double . be na n ( b ) ) { return a ; } else { return math . max ( a , b ) ; } }
public void expand to include ( double x , double y ) { if ( be null ( ) ) { minx = x ; maxx = x ; miny = y ; maxy = y ; } else { if ( x < minx ) { minx = x ; } if ( x > maxx ) { maxx = x ; } if ( y < miny ) { miny = y ; } if ( y > maxy ) { maxy = y ; } } }
public boolean disjoint ( envelope other ) { if ( be null ( ) || other . be null ( ) ) { return true ; } return other . minx > maxx || other . maxx < minx || other . miny > maxy || other . maxy < miny ; }
public static affine transformation scale instance ( double x scale , double y scale , double x , double y ) { affine transformation trans = new affine transformation ( ) ; trans . translate ( -x , -y ) ; trans . scale ( x scale , y scale ) ; trans . translate ( x , y ) ; return trans ; }
public boolean intersects ( coordinate p , geometry geom ) { return locate ( p , geom ) ! = location . exterior ; }
public int hash code ( ) { int hash code = get class ( ) . hash code ( ) ; for ( int b : byte ) { hash code += b ; } return hash code ; }
public void set ( string dimension symbol ) { for ( int i = 0 ; i < dimension symbol . length ( ) ; i++ ) { int row = i / 3 ; int col = i % 3 ; matrix [ row ] [ col ] = dimension . to dimension value ( dimension symbol . char at ( i ) ) ; } }
public boolean be cover by ( ) { boolean have point in common = be true ( matrix [ location . interior ] [ location . interior ] ) || be true ( matrix [ location . interior ] [ location . boundary ] ) || be true ( matrix [ location . boundary ] [ location . interior ] ) || be true ( matrix [ location . boundary ] [ location . boundary ] ) ; return have point in common & & matrix [ location . interior ] [ location . exterior ] == dimension . false & & matrix [ location . boundary ] [ location . exterior ] == dimension . false ; }
public float [ ] [ ] get value ( ) { float [ ] [ ] retval = new float [ 3 ] [ 3 ] ; retval [ 0 ] [ 0 ] = single [ 0 ] ; retval [ 0 ] [ 1 ] = single [ 1 ] ; retval [ 0 ] [ 2 ] = single [ 2 ] ; retval [ 1 ] [ 0 ] = single [ 3 ] ; retval [ 1 ] [ 1 ] = single [ 4 ] ; retval [ 1 ] [ 2 ] = single [ 5 ] ; retval [ 2 ] [ 0 ] = single [ 6 ] ; retval [ 2 ] [ 1 ] = single [ 7 ] ; retval [ 2 ] [ 2 ] = single [ 8 ] ; return retval ; }
public coordinate close point ( coordinate p ) { double factor = projection factor ( p ) ; if ( factor > 0 & & factor < 1 ) { return project ( p ) ; } double dist0 = p0 . distance ( p ) ; double dist1 = p1 . distance ( p ) ; if ( dist0 < dist1 ) return p0 ; return p1 ; }
public string get model type ( ) { return this . model type ; }
public coordinate to internal ( coordinate external ) { coordinate internal = new coordinate ( external ) ; make precise ( internal ) ; return internal ; }
protect boolean be any test component in target ( geometry test geom ) { list coords = component coordinate extracter . get coordinate ( test geom ) ; for ( iterator i = coords . iterator ( ) ; i . have next ( ) ; ) { coordinate p = ( coordinate ) i . next ( ) ; int loc = target point locator . locate ( p ) ; if ( loc ! = location . exterior ) return true ; } return false ; }
public boolean contains ( geometry geom ) { return eval ( geom ) ; }
public static coordinate angle bisector ( coordinate a , coordinate b , coordinate c ) { / * * * use the fact that the length of the part of the split segment be * proportional to the length of the adjacent triangle side * / double len0 = b . distance ( a ) ; double len2 = b . distance ( c ) ; double frac = len0 / ( len0 + len2 ) ; double dx = c . x - a . x ; double dy = c . y - a . y ; coordinate split pt = new coordinate ( a . x + frac * dx , a . y + frac * dy ) ; return split pt ; }
public double area ( ) { return area ( this . p0 , this . p1 , this . p2 ) ; }
public static affine transformation scale instance ( double x scale , double y scale , double x , double y ) { affine transformation trans = new affine transformation ( ) ; trans . translate ( -x , -y ) ; trans . scale ( x scale , y scale ) ; trans . translate ( x , y ) ; return trans ; }
public affine transformation compose before ( affine transformation trans ) { double mp00 = m00 * trans . m00 + m01 * trans . m10 ; double mp01 = m00 * trans . m01 + m01 * trans . m11 ; double mp02 = m00 * trans . m02 + m01 * trans . m12 + m02 ; double mp10 = m10 * trans . m00 + m11 * trans . m10 ; double mp11 = m10 * trans . m01 + m11 * trans . m11 ; double mp12 = m10 * trans . m02 + m11 * trans . m12 + m12 ; m00 = mp00 ; m01 = mp01 ; m02 = mp02 ; m10 = mp10 ; m11 = mp11 ; m12 = mp12 ; return this ; }
public affine transformation rotate ( double sin theta , double co theta ) { compose ( rotation instance ( sin theta , cos theta ) ) ; return this ; }
public boolean be pointwise equal ( edge e ) { if ( pt . length ! = e . pt . length ) return false ; for ( int i = 0 ; i < pt . length ; i++ ) { if ( ! pt [ i ] . equals2 d ( e . pt [ i ] ) ) { return false ; } } return true ; }
public list get edge ( ) { sort edge ( ) ; return out edge ; }
public item next ( ) throw x path exception { pull event pe = base . next ( ) ; if ( pe == null ) { position = -1 ; current = null ; return null ; } if ( pe instanceof item ) { current = ( item ) pe ; position++ ; return current ; } else if ( pe instanceof start document event || pe instanceof start element event ) { subtree iterator sub = new subtree iterator ( base , pe ) ; tiny builder builder = new tiny builder ( ) ; builder . set pipeline configuration ( pipe ) ; tree receiver receiver = new tree receiver ( builder ) ; builder . set pipeline configuration ( pipe ) ; event iterator to receiver . copy ( sub , receiver ) ; current = builder . get current root ( ) ; position++ ; return current ; } else { throw new illegal state exception ( pe . get class ( ) . get name ( ) ) ; } }
public boolean have duplicate ring ( ) { for ( iterator node it = node graph . get node iterator ( ) ; node it . have next ( ) ; ) { relate node node = ( relate node ) node it . next ( ) ; for ( iterator i = node . get edge ( ) . iterator ( ) ; i . have next ( ) ; ) { edge end bundle eeb = ( edge end bundle ) i . next ( ) ; if ( eeb . get edge end ( ) . size ( ) > 1 ) { invalid point = eeb . get edge ( ) . get coordinate ( 0 ) ; return true ; } } } return false ; }
public edge find edge ( coordinate p0 , coordinate p1 ) { for ( int i = 0 ; i < edge . size ( ) ; i++ ) { edge e = ( edge ) edge . get ( i ) ; coordinate [ ] e coord = e . get coordinate ( ) ; if ( p0 . equal ( e coord [ 0 ] ) & & p1 . equal ( e coord [ 1 ] ) ) return e ; } return null ; }
public static int octant ( coordinate p0 , coordinate p1 ) { double dx = p1 . x - p0 . x ; double dy = p1 . y - p0 . y ; if ( dx == 0 . 0 & & dy == 0 . 0 ) throw new illegal argument exception ( `` can not compute the octant for two identical point `` + p0 ) ; return octant ( dx , dy ) ; }
public static boolean be in half plane ( int quad , int half plane ) { if ( half plane == se ) { return quad == se || quad == sw ; } return quad == half plane || quad == half plane + 1 ; }
public int last ( int node ) { while ( true ) { final int right = right ( node ) ; if ( right == nil ) { break ; } node = right ; } return node ; }
public boolean be repeat ( ) { if ( repeat == null ) { return false ; } else { return repeating ; } }
public kd node query ( coordinate query pt ) { return query node point ( root , query pt , true ) ; }
public object [ ] near neighbour ( s t rtree tree , item distance item dist ) { boundable pair bp = new boundable pair ( this . get root ( ) , tree . get root ( ) , item dist ) ; return near neighbour ( bp ) ; }
public static component2 d create ( x y geometry . . . xy geometry ) { if ( xy geometry == null ) { throw new illegal argument exception ( `` geometry must not be null `` ) ; } if ( xy geometry . length == 0 ) { throw new illegal argument exception ( `` geometry must not be empty `` ) ; } if ( xy geometry . length == 1 ) { if ( xy geometry [ 0 ] == null ) { throw new illegal argument exception ( `` geometry [ 0 ] must not be null `` ) ; } return xy geometry [ 0 ] . to component2 d ( ) ; } component2 d [ ] component = new component2 d [ xy geometry . length ] ; for ( int i = 0 ; i < xy geometry . length ; i++ ) { if ( xy geometry [ i ] == null ) { throw new illegal argument exception ( `` geometry [ `` + i + `` ] must not be null `` ) ; } component [ i ] = xy geometry [ i ] . to component2 d ( ) ; } return component tree . create ( component ) ; }
public void add prefix line ( final prefix line prefix line ) { filter reader . add element ( prefix line ) ; }
public static byte string decode hex ( string hex ) { if ( hex == null ) throw new illegal argument exception ( `` hex == null `` ) ; if ( hex . length ( ) % 2 ! = 0 ) throw new illegal argument exception ( `` unexpected hex string : `` + hex ) ; byte [ ] result = new byte [ hex . length ( ) / 2 ] ; for ( int i = 0 ; i < result . length ; i++ ) { int d1 = decode hex digit ( hex . char at ( i * 2 ) ) < < 4 ; int d2 = decode hex digit ( hex . char at ( i * 2 + 1 ) ) ; result [ i ] = ( byte ) ( d1 + d2 ) ; } return of ( result ) ; }
protect static final int compare ( char chunk name , char [ ] compare to ) { int result = 0 ; char [ ] c = name . get buffer ( ) ; int start = name . get start ( ) ; int end = name . get end ( ) ; int len = compare to . length ; if ( ( end - start ) < len ) { len = end - start ; } for ( int i = 0 ; ( i < len ) & & ( result == 0 ) ; i++ ) { if ( c [ i + start ] > compare to [ i ] ) { result = 1 ; } else if ( c [ i + start ] < compare to [ i ] ) { result = -1 ; } } if ( result == 0 ) { if ( compare to . length > ( end - start ) ) { result = -1 ; } else if ( compare to . length < ( end - start ) ) { result = 1 ; } } return result ; }
public boolean be vertex ( ) { return segment fraction < = 0 . 0 || segment fraction > = 1 . 0 ; }
public double [ ] index of ( geometry sub line ) { linear location [ ] loc index = location index of line . index of ( linear geom , sub line ) ; double [ ] index = new double [ ] { length location map . get length ( linear geom , loc index [ 0 ] ) , length location map . get length ( linear geom , loc index [ 1 ] ) } ; return index ; }
public boolean lt ( dd y ) { return ( hi < y . hi ) || ( hi == y . hi & & lo < y . lo ) ; }
public boolean lt ( dd y ) { return ( hi < y . hi ) || ( hi == y . hi & & lo < y . lo ) ; }
public list get intersection ( ) { return intersection ; }
public static noding intersection finder create intersection counter ( line intersector li ) { nod intersection finder finder = new nod intersection finder ( li ) ; finder . set find all intersection ( true ) ; finder . set keep intersection ( false ) ; return finder ; }
public void set upgrade in progress ( boolean upgrade , boolean only ancient segment ) { this . upgrade in progress = upgrade ; this . upgrade only ancient segment = only ancient segment ; }
public boolean have proper interior intersection ( ) { return have proper interior ; }
public gaussian curve fitter with max iteration ( int new max iter ) { return new gaussian curve fitter ( initial guess , new max iter ) ; }
public boolean have proper intersection ( ) { return have proper intersection ; }
public segment set mutual intersector get segment set intersector ( ) { return seg set mut int ; }
public void set quadrant segment ( int quadrant segment ) { buf params . set quadrant segment ( quadrant segment ) ; }
public node add node ( coordinate coord ) { node node = ( node ) node map . get ( coord ) ; if ( node == null ) { node = node fact . create node ( coord ) ; node map . put ( coord , node ) ; } return node ; }
public static boolean be within distance ( geometry g0 , geometry g1 , double distance ) { distance op dist op = new distance op ( g0 , g1 , distance ) ; return dist op . distance ( ) < = distance ; }
public static void delete all edge ( node node ) { list edge = node . get out edge ( ) . get edge ( ) ; for ( iterator i = edge . iterator ( ) ; i . have next ( ) ; ) { polygonize direct edge de = ( polygonize direct edge ) i . next ( ) ; de . set marked ( true ) ; polygonize direct edge sym = ( polygonize direct edge ) de . get sym ( ) ; if ( sym ! = null ) sym . set marked ( true ) ; } }
public boolean contains point ( coordinate p ) { linear ring shell = get linear ring ( ) ; envelope env = shell . get envelope internal ( ) ; if ( ! env . contains ( p ) ) return false ; if ( ! point location . be in ring ( p , shell . get coordinate ( ) ) ) return false ; for ( iterator i = hole . iterator ( ) ; i . have next ( ) ; ) { edge ring hole = ( edge ring ) i . next ( ) ; if ( hole . contains point ( p ) ) return false ; } return true ; }
public static coordinate find interior self node ( list < polygon ring > poly ring ) { for ( polygon ring poly ring : poly ring ) { coordinate interior self node = poly ring . find interior self node ( ) ; if ( interior self node ! = null ) { return interior self node ; } } return null ; }
public geometry get boundary ( ) { if ( be empty ( ) ) { return get factory ( ) . create multi line string ( ) ; } array list all ring = new array list ( ) ; for ( int i = 0 ; i < geometry . length ; i++ ) { polygon polygon = ( polygon ) geometries [ i ] ; geometry ring = polygon . get boundary ( ) ; for ( int j = 0 ; j < ring . get num geometry ( ) ; j++ ) { all ring . add ( ring . get geometry n ( j ) ) ; } } line string [ ] all ring array = new line string [ all ring . size ( ) ] ; return get factory ( ) . create multi line string ( ( line string [ ] ) all ring . to array ( all ring array ) ) ; }
public topology validation error get validation error ( ) { check valid ( parent geometry ) ; return valid err ; }
public context get context ( ) { return map data . context ; }
public collection value by value ( ) { if ( collection of value [ value ] == null ) { collection of value [ value ] = new abstract collection ( ) { public iterator iterator ( ) { return new double order map iterator ( value ) { protected object do get next ( ) { return last return node . get data ( value ) ; } } ; } public int size ( ) { return double order map . this . size ( ) ; } public boolean contains ( object o ) { return contain value ( o ) ; } public boolean remove ( object o ) { int oldnode count = node count ; remove value ( o ) ; return node count ! = oldnode count ; } public boolean remove all ( collection c ) { boolean modify = false ; iterator iter = c . iterator ( ) ; while ( iter . have next ( ) ) { if ( remove value ( iter . next ( ) ) ! = null ) { modified = true ; } } return modify ; } public void clear ( ) { double order map . this . clear ( ) ; } } ; } return collection of value [ value ] ; }
public boolean be enable changed ( ) { return ( ( change value & changed_enabled ) ! = 0 ) ; }
protect void collapse impl ( fold fold ) { if ( get should collapse ( fold ) ) { fold . set collapsed ( true ) ; } for ( int i=0 ; i < fold . get child count ( ) ; i++ ) { collapse impl ( fold . get child ( i ) ) ; } }
public static geometry reduce pointwise ( geometry g , precision model prec model ) { geometry precision reducer reducer = new geometry precision reducer ( prec model ) ; reducer . set pointwise ( true ) ; return reducer . reduce ( g ) ; }
public gutter get gutter ( ) { return gutter ; }
public topology validation error get validation error ( ) { check valid ( parent geometry ) ; return valid err ; }
public boolean legal vertex ( final vertex vertex ) { return null == this . vertex filter || traversal util . test ( vertex , this . vertex filter ) ; }
public geometry convex hull ( ) { return ( new convex hull ( this ) ) . get convex hull ( ) ; }
public final quad edge d prev ( ) { return this . inv rot ( ) . o next ( ) . inv rot ( ) ; }
public boolean equal orient ( quad edge qe ) { if ( orig ( ) . get coordinate ( ) . equals2 d ( qe . orig ( ) . get coordinate ( ) ) & & d ( ) . get coordinate ( ) . equals2 d ( qe . d ( ) . get coordinate ( ) ) ) return true ; return false ; }
public quad edge locate ( vertex v ) { if ( ! last edge . be live ( ) ) { init ( ) ; } quad edge e = subdiv . locate from edge ( v , last edge ) ; last edge = e ; return e ; }
public int get edge index ( vertex v ) { for ( int i = 0 ; i < 3 ; i++ ) { if ( edge [ i ] . orig ( ) == v ) return i ; } return -1 ; }
public static boolean be in circle c c ( coordinate a , coordinate b , coordinate c , coordinate p ) { coordinate cc = triangle . circumcentre ( a , b , c ) ; double cc radius = a . distance ( cc ) ; double p radius diff = p . distance ( cc ) - cc radius ; return p radius diff < = 0 ; }
public object get data ( ) { return data ; }
public boolean equal topo ( line segment other ) { return p0 . equal ( other . p0 ) & & p1 . equal ( other . p1 ) || p0 . equal ( other . p1 ) & & p1 . equal ( other . p0 ) ; }
public coordinate line intersection ( line segment line ) { coordinate int pt = intersection . intersection ( p0 , p1 , line . p0 , line . p1 ) ; return int pt ; }
public boolean add ( object object , int n copy ) { _mods++ ; if ( n copy > 0 ) { int count = ( n copy + get count ( object ) ) ; _map . put ( object , new integer ( count ) ) ; _total += n copy ; return ( count == n copy ) ; } else { return false ; } }
public static void add watch ( object obj ) { debug . instance add watch ( obj ) ; }
public static int get subnode index ( interval interval , double centre ) { int subnode index = -1 ; if ( interval . min > = centre ) subnode index = 1 ; if ( interval . max < = centre ) subnode index = 0 ; return subnode index ; }
public boolean be empty ( ) { return size ( ) == 0 ; }
public static string get stack trace ( exception e ) { if ( e == null ) { return `` `` ; } byte array output stream baos = new byte array output stream ( ) ; print writer print writer = new print writer ( baos ) ; e . print stack trace ( print writer ) ; print writer . flush ( ) ; string stack trace = new string ( baos . to byte array ( ) ) ; print writer . close ( ) ; return stack trace ; }
public static coordinate min coordinate ( coordinate [ ] coordinate ) { coordinate min coord = null ; for ( int i = 0 ; i < coordinate . length ; i++ ) { if ( min coord == null || min coord . compare to ( coordinate [ i ] ) > 0 ) { min coord = coordinate [ i ] ; } } return min coord ; }
public boolean be cross ( int dimension of geometry a , int dimension of geometry b ) { if ( ( dimension of geometry a == dimension . p & & dimension of geometry b == dimension . l ) || ( dimension of geometry a == dimension . p & & dimension of geometry b == dimension . a ) || ( dimension of geometry a == dimension . l & & dimension of geometry b == dimension . a ) ) { return be true ( matrix [ location . interior ] [ location . interior ] ) & & be true ( matrix [ location . interior ] [ location . exterior ] ) ; } if ( ( dimension of geometry a == dimension . l & & dimension of geometry b == dimension . p ) || ( dimension of geometry a == dimension . a & & dimension of geometry b == dimension . p ) || ( dimension of geometry a == dimension . a & & dimension of geometry b == dimension . l ) ) { return be true ( matrix [ location . interior ] [ location . interior ] ) & & be true ( matrix [ location . exterior ] [ location . interior ] ) ; } if ( dimension of geometry a == dimension . l & & dimension of geometry b == dimension . l ) { return matrix [ location . interior ] [ location . interior ] == 0 ; } return false ; }
public object push ( object item ) { add ( item ) ; return item ; }
public boolean be within distance ( geometry geom , double distance ) { double env dist = get envelope internal ( ) . distance ( geom . get envelope internal ( ) ) ; if ( env dist > distance ) return false ; return distance op . be within distance ( this , geom , distance ) ; / * double geom dist = this . distance ( geom ) ; if ( geom dist > distance ) return false ; return true ; * / }
public static double sum ( double [ ] value ) { if ( value . length == 0 ) { return 0 . 0 ; } return array . stream ( value ) . map ( value - > { if ( double . be na n ( value ) == false ) { return value ; } return 0 . 0 ; } ) . sum ( ) ; }
public composable function multiply ( final double scale factor ) { return new composable function ( ) { @ override / * * { @ inherit doc } * / public double value ( double x ) throw function evaluation exception { return composable function . this . value ( x ) * scale factor ; } } ; }
public model get model ( ) { if ( result == null ) { return null ; } if ( result . get effective model ( ) ! = null ) { return result . get effective model ( ) ; } return result . get raw model ( ) ; }
public static int get var int len ( int x ) { if ( ( x & ( -1 < < 7 ) ) == 0 ) { return 1 ; } else if ( ( x & ( -1 < < 14 ) ) == 0 ) { return 2 ; } else if ( ( x & ( -1 < < 21 ) ) == 0 ) { return 3 ; } else if ( ( x & ( -1 < < 28 ) ) == 0 ) { return 4 ; } return 5 ; }
public static geometry reduce pointwise ( geometry g , precision model prec model ) { geometry precision reducer reducer = new geometry precision reducer ( prec model ) ; reducer . set pointwise ( true ) ; return reducer . reduce ( g ) ; }
public void assign hole to shell ( list < edge ring > hole list ) { for ( iterator i = hole list . iterator ( ) ; i . have next ( ) ; ) { edge ring hole e r = ( edge ring ) i . next ( ) ; assign hole to shell ( hole e r ) ; } }
public static coordinate get non simple location ( geometry geom ) { be simple op op = new be simple op ( geom ) ; return op . get non simple location ( ) ; }
public void to array ( int [ ] array ) { system . arraycopy ( data , 0 , array , 0 , size ) ; }
public void configure ( size size ) { this . size range = size ; check range ( integral , size . min ( ) , size . max ( ) ) ; }
public final java . nio . byte buffer new direct byte buffer ( long address , int capacity ) { return foreign . new direct byte buffer ( address , capacity ) ; }
public final int read int ( ) throw i o exception { return ( ( read byte ( ) & 0x f f ) < < 24 ) | ( ( read byte ( ) & 0x f f ) < < 16 ) | ( ( read byte ( ) & 0x f f ) < < 8 ) | ( read byte ( ) & 0x f f ) ; }
public synchronize void get late uncorrected interval histogram into ( histogram target histogram ) { try { record phaser . reader lock ( ) ; inactive raw data histogram . copy into ( target histogram ) ; } finally { record phaser . reader unlock ( ) ; } }
public action pause ( long pause ) { action . add action ( new pause action ( pause ) ) ; return this ; }
public static void create hard link mult ( file parent dir , string [ ] file base name , file link dir ) throw i o exception { if ( parent dir == null ) { throw new i o exception ( `` invalid argument to create hard link mult : parent directory be null `` ) ; } if ( link dir == null ) { throw new i o exception ( `` invalid argument to create hard link mult : link directory be null `` ) ; } if ( file base name == null ) { throw new i o exception ( `` invalid argument to create hard link mult : `` + `` filename list can be empty but not null `` ) ; } if ( ! link dir . exists ( ) ) { throw new file not find exception ( link dir + `` not find . `` ) ; } for ( string name : file base names ) { create link ( link dir . to path ( ) . resolve ( name ) , parent dir . to path ( ) . resolve ( name ) ) ; } }
public static summary writer create ( scope scope , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` summary writer `` , scope . make op name ( `` summary writer `` ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . share name ! = null ) { op builder . set attr ( `` shared_name `` , opts . share name ) ; } if ( opts . container ! = null ) { op builder . set attr ( `` container `` , opts . container ) ; } } } return new summary writer ( op builder . build ( ) ) ; }
public static < t > accumulator take gradient < t > create ( scope scope , operand < string > handle , operand < integer > num require , class < t > dtype ) { operation builder op builder = scope . graph ( ) . op builder ( `` accumulator take gradient `` , scope . make op name ( `` accumulator take gradient `` ) ) ; op builder . add input ( handle . a output ( ) ) ; op builder . add input ( num require . a output ( ) ) ; op builder . set attr ( `` dtype `` , data type . from class ( dtype ) ) ; return new accumulator take gradient < t > ( op builder . build ( ) ) ; }
public static uniform candidate sampler create ( scope scope , operand < long > true class , long num true , long num sample , boolean unique , long range max , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` uniform candidate sampler `` , scope . make op name ( `` uniform candidate sampler `` ) ) ; op builder . add input ( true class . a output ( ) ) ; op builder . set attr ( `` num_true `` , num true ) ; op builder . set attr ( `` num_sampled `` , num sample ) ; op builder . set attr ( `` unique `` , unique ) ; op builder . set attr ( `` range_max `` , range max ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . seed ! = null ) { op builder . set attr ( `` seed `` , opts . seed ) ; } if ( opts . seed2 ! = null ) { op builder . set attr ( `` seed2 `` , opts . seed2 ) ; } } } return new uniform candidate sampler ( op builder . build ( ) ) ; }
public output < float > sample expect count ( ) { return sample expect count ; }
public static < t extend number > reduce any create ( scope scope , operand < boolean > input , operand < t > axis , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` any `` , scope . make op name ( `` reduce any `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . add input ( axis . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . keep dims ! = null ) { op builder . set attr ( `` keep_dims `` , opts . keep dims ) ; } } } return new reduce any ( op builder . build ( ) ) ; }
public output < t > ref ( ) { return ref ; }
public static < t extend number > minimum < t > create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` minimum `` , scope . make op name ( `` minimum `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new minimum < t > ( op builder . build ( ) ) ; }
public static < t extend number > image summary create ( scope scope , operand < string > tag , operand < t > tensor , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` image summary `` , scope . make op name ( `` image summary `` ) ) ; op builder . add input ( tag . a output ( ) ) ; op builder . add input ( tensor . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . max image ! = null ) { op builder . set attr ( `` max_images `` , opts . max image ) ; } if ( opts . bad color ! = null ) { op builder . set attr ( `` bad_color `` , opts . bad color ) ; } } } return new image summary ( op builder . build ( ) ) ; }
public output < t > output ( ) { return output ; }
public output < integer > tree size ( ) { return tree size ; }
public static < t > batch matrix diag < t > create ( scope scope , operand < t > diagonal ) { operation builder op builder = scope . graph ( ) . op builder ( `` batch matrix diag `` , scope . make op name ( `` batch matrix diag `` ) ) ; op builder . add input ( diagonal . a output ( ) ) ; return new batch matrix diag < t > ( op builder . build ( ) ) ; }
public static < t > matrix solve l < t > create ( scope scope , operand < t > matrix , operand < t > rh , operand < double > l2 regularizer , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` matrix solve l `` , scope . make op name ( `` matrix solve l `` ) ) ; op builder . add input ( matrix . a output ( ) ) ; op builder . add input ( rh . a output ( ) ) ; op builder . add input ( l2 regularizer . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . fast ! = null ) { op builder . set attr ( `` fast `` , opts . fast ) ; } } } return new matrix solve ls < t > ( op builder . build ( ) ) ; }
public output < t > output ( ) { return output ; }
public list < output < float > > right node contribs list ( ) { return right node contribs list ; }
public static < t extend number > softmax cross entropy with logits < t > create ( scope scope , operand < t > feature , operand < t > label ) { operation builder op builder = scope . graph ( ) . op builder ( `` softmax cross entropy with logits `` , scope . make op name ( `` softmax cross entropy with logits `` ) ) ; op builder . add input ( feature . a output ( ) ) ; op builder . add input ( label . a output ( ) ) ; return new softmax cross entropy with logits < t > ( op builder . build ( ) ) ; }
public output < ? > output ( ) { return output ; }
public static < t extend number > batch cholesky < t > create ( scope scope , operand < t > input ) { operation builder op builder = scope . graph ( ) . op builder ( `` batch cholesky `` , scope . make op name ( `` batch cholesky `` ) ) ; op builder . add input ( input . a output ( ) ) ; return new batch cholesky < t > ( op builder . build ( ) ) ; }
public static < t extend number > collective bcast recv < t > create ( scope scope , class < t > t , long group size , long group key , long instance key , shape shape ) { operation builder op builder = scope . graph ( ) . op builder ( `` collective bcast recv `` , scope . make op name ( `` collective bcast recv `` ) ) ; op builder . set attr ( `` t `` , data type . from class ( t ) ) ; op builder . set attr ( `` group_size `` , group size ) ; op builder . set attr ( `` group_key `` , group key ) ; op builder . set attr ( `` instance_key `` , instance key ) ; op builder . set attr ( `` shape `` , shape ) ; return new collective bcast recv < t > ( op builder . build ( ) ) ; }
public static < t extend number > conv3 d backprop filter < t > create ( scope scope , operand < t > input , operand < t > filter , operand < t > out backprop , list < long > stride , string padding , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` conv3 d backprop filter `` , scope . make op name ( `` conv3 d backprop filter `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . add input ( filter . a output ( ) ) ; op builder . add input ( out backprop . a output ( ) ) ; long [ ] stride array = new long [ stride . size ( ) ] ; for ( int i = 0 ; i < stride array . length ; ++i ) { strides array [ i ] = stride . get ( i ) ; } op builder . set attr ( `` stride `` , stride array ) ; op builder . set attr ( `` pad `` , pad ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . dilation ! = null ) { long [ ] dilation array = new long [ opts . dilation . size ( ) ] ; for ( int i = 0 ; i < dilation array . length ; ++i ) { dilation array [ i ] = opts . dilation . get ( i ) ; } op builder . set attr ( `` dilation `` , dilation array ) ; } } } return new conv3 d backprop filter < t > ( op builder . build ( ) ) ; }
public static < t > xdivy < t > create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` xdivy `` , scope . make op name ( `` xdivy `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new xdivy < t > ( op builder . build ( ) ) ; }
public static < t extend number > crop and resize create ( scope scope , operand < t > image , operand < float > box , operand < integer > box ind , operand < integer > crop size , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` crop and resize `` , scope . make op name ( `` crop and resize `` ) ) ; op builder . add input ( image . a output ( ) ) ; op builder . add input ( box . a output ( ) ) ; op builder . add input ( box ind . a output ( ) ) ; op builder . add input ( crop size . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . method ! = null ) { op builder . set attr ( `` method `` , opts . method ) ; } if ( opts . extrapolation value ! = null ) { op builder . set attr ( `` extrapolation_value `` , opts . extrapolation value ) ; } } } return new crop and resize ( op builder . build ( ) ) ; }
public output < float > output ( ) { return output ; }
public output < t > output ( ) { return output ; }
public static c t c greedy decoder create ( scope scope , operand < float > input , operand < integer > sequence length , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` c t c greedy decoder `` , scope . make op name ( `` c t c greedy decoder `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . add input ( sequence length . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . merge repeat ! = null ) { op builder . set attr ( `` merge_repeated `` , opts . merge repeat ) ; } } } return new c t c greedy decoder ( op builder . build ( ) ) ; }
public static < t extend number > l r n grad < t > create ( scope scope , operand < t > input grad , operand < t > input image , operand < t > output image , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` l r n grad `` , scope . make op name ( `` l r n grad `` ) ) ; op builder . add input ( input grad . a output ( ) ) ; op builder . add input ( input image . a output ( ) ) ; op builder . add input ( output image . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . depth radius ! = null ) { op builder . set attr ( `` depth_radius `` , opts . depth radius ) ; } if ( opts . bias ! = null ) { op builder . set attr ( `` bias `` , opts . bias ) ; } if ( opts . alpha ! = null ) { op builder . set attr ( `` alpha `` , opts . alpha ) ; } if ( opts . beta ! = null ) { op builder . set attr ( `` beta `` , opts . beta ) ; } } } return new l r n grad < t > ( op builder . build ( ) ) ; }
public static < t extend number > l r n grad < t > create ( scope scope , operand < t > input grad , operand < t > input image , operand < t > output image , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` l r n grad `` , scope . make op name ( `` l r n grad `` ) ) ; op builder . add input ( input grad . a output ( ) ) ; op builder . add input ( input image . a output ( ) ) ; op builder . add input ( output image . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . depth radius ! = null ) { op builder . set attr ( `` depth_radius `` , opts . depth radius ) ; } if ( opts . bias ! = null ) { op builder . set attr ( `` bias `` , opts . bias ) ; } if ( opts . alpha ! = null ) { op builder . set attr ( `` alpha `` , opts . alpha ) ; } if ( opts . beta ! = null ) { op builder . set attr ( `` beta `` , opts . beta ) ; } } } return new l r n grad < t > ( op builder . build ( ) ) ; }
public static < t extend number > data format vec permute < t > create ( scope scope , operand < t > x , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` data format vec permute `` , scope . make op name ( `` data format vec permute `` ) ) ; op builder . add input ( x . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . src format ! = null ) { op builder . set attr ( `` src_format `` , opts . src format ) ; } if ( opts . dst format ! = null ) { op builder . set attr ( `` dst_format `` , opts . dst format ) ; } } } return new data format vec permute < t > ( op builder . build ( ) ) ; }
public static decode bmp create ( scope scope , operand < string > content , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` decode bmp `` , scope . make op name ( `` decode bmp `` ) ) ; op builder . add input ( content . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . channel ! = null ) { op builder . set attr ( `` channel `` , opts . channel ) ; } } } return new decode bmp ( op builder . build ( ) ) ; }
public output < integer > example ( ) { return example ; }
public output < integer > tree size ( ) { return tree size ; }
public c t embed w a v audio file get snd ( ) { return snd ; }
public output < t > output ( ) { return output ; }
public static boost tree ensemble resource handle op create ( scope scope , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` boost tree ensemble resource handle op `` , scope . make op name ( `` boost tree ensemble resource handle op `` ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . container ! = null ) { op builder . set attr ( `` container `` , opts . container ) ; } if ( opts . share name ! = null ) { op builder . set attr ( `` shared_name `` , opts . share name ) ; } } } return new boost tree ensemble resource handle op ( op builder . build ( ) ) ; }
public static < t > div < t > create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` div `` , scope . make op name ( `` div `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new div < t > ( op builder . build ( ) ) ; }
public output < t > output ( ) { return output ; }
public output < t > backprops ( ) { return backprops ; }
public static unicode encode create ( scope scope , operand < integer > input value , operand < long > input split , string output encode , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` unicode encode `` , scope . make op name ( `` unicode encode `` ) ) ; op builder . add input ( input value . a output ( ) ) ; op builder . add input ( input split . a output ( ) ) ; op builder . set attr ( `` output_encoding `` , output encode ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . error ! = null ) { op builder . set attr ( `` error `` , opts . error ) ; } if ( opts . replacement char ! = null ) { op builder . set attr ( `` replacement_char `` , opts . replacement char ) ; } } } return new unicode encode ( op builder . build ( ) ) ; }
public static decode jpeg create ( scope scope , operand < string > content , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` decode jpeg `` , scope . make op name ( `` decode jpeg `` ) ) ; op builder . add input ( content . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . channel ! = null ) { op builder . set attr ( `` channel `` , opts . channel ) ; } if ( opts . ratio ! = null ) { op builder . set attr ( `` ratio `` , opts . ratio ) ; } if ( opts . fancy upscaling ! = null ) { op builder . set attr ( `` fancy_upscaling `` , opts . fancy upscaling ) ; } if ( opts . try recover truncate ! = null ) { op builder . set attr ( `` try_recover_truncated `` , opts . try recover truncate ) ; } if ( opts . acceptable fraction ! = null ) { op builder . set attr ( `` acceptable_fraction `` , opts . acceptable fraction ) ; } if ( opts . dct method ! = null ) { op builder . set attr ( `` dct_method `` , opts . dct method ) ; } } } return new decode jpeg ( op builder . build ( ) ) ; }
public output < t > output ( ) { return output ; }
public static multi device iterator init create ( scope scope , operand < ? > dataset , operand < ? > multi device iterator , operand < long > max buffer size ) { operation builder op builder = scope . graph ( ) . op builder ( `` multi device iterator init `` , scope . make op name ( `` multi device iterator init `` ) ) ; op builder . add input ( dataset . a output ( ) ) ; op builder . add input ( multi device iterator . a output ( ) ) ; op builder . add input ( max buffer size . a output ( ) ) ; return new multi device iterator init ( op builder . build ( ) ) ; }
public static experimental unique dataset create ( scope scope , operand < ? > input dataset , list < class < ? > > output type , list < shape > output shape ) { operation builder op builder = scope . graph ( ) . op builder ( `` experimental unique dataset `` , scope . make op name ( `` experimental unique dataset `` ) ) ; op builder . add input ( input dataset . a output ( ) ) ; data type [ ] output type array = new data type [ output type . size ( ) ] ; for ( int i = 0 ; i < output type array . length ; ++i ) { output type array [ i ] = data type . from class ( output type . get ( i ) ) ; } op builder . set attr ( `` output_types `` , output type array ) ; shape [ ] output shape array = new shape [ output shape . size ( ) ] ; for ( int i = 0 ; i < output shape array . length ; ++i ) { output shape array [ i ] = output shape . get ( i ) ; } op builder . set attr ( `` output_shapes `` , output shape array ) ; return new experimental unique dataset ( op builder . build ( ) ) ; }
public output < t > image ( ) { return image ; }
public output < float > backprop wrt max ( ) { return backprop wrt max ; }
public output < float > backprop wrt min ( ) { return backprop wrt min ; }
public static close summary writer create ( scope scope , operand < ? > writer ) { operation builder op builder = scope . graph ( ) . op builder ( `` close summary writer `` , scope . make op name ( `` close summary writer `` ) ) ; op builder . add input ( writer . a output ( ) ) ; return new close summary writer ( op builder . build ( ) ) ; }
public output < t > reserve space3 ( ) { return reserve space3 ; }
public output < t > output value ( ) { return output value ; }
public static < t > upper bound < integer > create ( scope scope , operand < t > sort input , operand < t > value ) { return create ( scope , sort input , value , integer . class ) ; }
public static write graph summary create ( scope scope , operand < ? > writer , operand < long > step , operand < string > tensor ) { operation builder op builder = scope . graph ( ) . op builder ( `` write graph summary `` , scope . make op name ( `` write graph summary `` ) ) ; op builder . add input ( writer . a output ( ) ) ; op builder . add input ( step . a output ( ) ) ; op builder . add input ( tensor . a output ( ) ) ; return new write graph summary ( op builder . build ( ) ) ; }
public static irfft2d create ( scope scope , operand < ? > input , operand < integer > fft length ) { operation builder op builder = scope . graph ( ) . op builder ( `` irfft2d `` , scope . make op name ( `` irfft2d `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . add input ( fft length . a output ( ) ) ; return new irfft2d ( op builder . build ( ) ) ; }
public static boost tree serialize ensemble create ( scope scope , operand < ? > tree ensemble handle ) { operation builder op builder = scope . graph ( ) . op builder ( `` boost tree serialize ensemble `` , scope . make op name ( `` boost tree serialize ensemble `` ) ) ; op builder . add input ( tree ensemble handle . a output ( ) ) ; return new boost tree serialize ensemble ( op builder . build ( ) ) ; }
public static iterator from string handle v2 create ( scope scope , operand < string > string handle , list < class < ? > > output type , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` iterator from string handle v2 `` , scope . make op name ( `` iterator from string handle v2 `` ) ) ; op builder . add input ( string handle . a output ( ) ) ; data type [ ] output type array = new data type [ output type . size ( ) ] ; for ( int i = 0 ; i < output type array . length ; ++i ) { output type array [ i ] = data type . from class ( output type . get ( i ) ) ; } op builder . set attr ( `` output_types `` , output type array ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . output shape ! = null ) { shape [ ] output shape array = new shape [ opts . output shape . size ( ) ] ; for ( int i = 0 ; i < output shape array . length ; ++i ) { output shape array [ i ] = opts . output shape . get ( i ) ; } op builder . set attr ( `` output_shapes `` , output shape array ) ; } } } return new iterator from string handle v2 ( op builder . build ( ) ) ; }
public static iterator get next sync create ( scope scope , operand < ? > iterator , list < class < ? > > output type , list < shape > output shape ) { operation builder op builder = scope . graph ( ) . op builder ( `` iterator get next sync `` , scope . make op name ( `` iterator get next sync `` ) ) ; op builder . add input ( iterator . a output ( ) ) ; data type [ ] output type array = new data type [ output type . size ( ) ] ; for ( int i = 0 ; i < output type array . length ; ++i ) { output type array [ i ] = data type . from class ( output type . get ( i ) ) ; } op builder . set attr ( `` output_types `` , output type array ) ; shape [ ] output shape array = new shape [ output shape . size ( ) ] ; for ( int i = 0 ; i < output shape array . length ; ++i ) { output shape array [ i ] = output shape . get ( i ) ; } op builder . set attr ( `` output_shapes `` , output shape array ) ; return new iterator get next sync ( op builder . build ( ) ) ; }
public static iterator create ( scope scope , string share name , string container , list < class < ? > > output type , list < shape > output shape ) { operation builder op builder = scope . graph ( ) . op builder ( `` iterator `` , scope . make op name ( `` iterator `` ) ) ; op builder . set attr ( `` shared_name `` , share name ) ; op builder . set attr ( `` container `` , container ) ; data type [ ] output type array = new data type [ output type . size ( ) ] ; for ( int i = 0 ; i < output type array . length ; ++i ) { output type array [ i ] = data type . from class ( output type . get ( i ) ) ; } op builder . set attr ( `` output_types `` , output type array ) ; shape [ ] output shape array = new shape [ output shape . size ( ) ] ; for ( int i = 0 ; i < output shape array . length ; ++i ) { output shape array [ i ] = output shape . get ( i ) ; } op builder . set attr ( `` output_shapes `` , output shape array ) ; return new iterator ( op builder . build ( ) ) ; }
public output < t > backprops ( ) { return backprops ; }
public static < t extend number > less create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` less `` , scope . make op name ( `` less `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new less ( op builder . build ( ) ) ; }
public static < t > matrix determinant < t > create ( scope scope , operand < t > input ) { operation builder op builder = scope . graph ( ) . op builder ( `` matrix determinant `` , scope . make op name ( `` matrix determinant `` ) ) ; op builder . add input ( input . a output ( ) ) ; return new matrix determinant < t > ( op builder . build ( ) ) ; }
public output < u > output ( ) { return output ; }
public static stage clear create ( scope scope , list < class < ? > > dtypes , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` stage clear `` , scope . make op name ( `` stage clear `` ) ) ; data type [ ] dtypes array = new data type [ dtypes . size ( ) ] ; for ( int i = 0 ; i < dtypes array . length ; ++i ) { dtypes array [ i ] = data type . from class ( dtypes . get ( i ) ) ; } op builder . set attr ( `` dtypes `` , dtypes array ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . capacity ! = null ) { op builder . set attr ( `` capacity `` , opts . capacity ) ; } if ( opts . memory limit ! = null ) { op builder . set attr ( `` memory_limit `` , opts . memory limit ) ; } if ( opts . container ! = null ) { op builder . set attr ( `` container `` , opts . container ) ; } if ( opts . share name ! = null ) { op builder . set attr ( `` shared_name `` , opts . share name ) ; } } } return new stage clear ( op builder . build ( ) ) ; }
public output < t > output ( ) { return output ; }
public output < t > output ( ) { return output ; }
public static < t extend number > minimum < t > create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` minimum `` , scope . make op name ( `` minimum `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new minimum < t > ( op builder . build ( ) ) ; }
public output < t > output ( ) { return output ; }
public static < t > quantize v2 < t > create ( scope scope , operand < float > input , operand < float > min range , operand < float > max range , class < t > t , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` quantize v2 `` , scope . make op name ( `` quantize v2 `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . add input ( min range . a output ( ) ) ; op builder . add input ( max range . a output ( ) ) ; op builder . set attr ( `` t `` , data type . from class ( t ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . mode ! = null ) { op builder . set attr ( `` mode `` , opts . mode ) ; } if ( opts . round mode ! = null ) { op builder . set attr ( `` round_mode `` , opts . round mode ) ; } } } return new quantize v2 < t > ( op builder . build ( ) ) ; }
public static < t > identity < t > create ( scope scope , operand < t > input ) { operation builder op builder = scope . graph ( ) . op builder ( `` identity `` , scope . make op name ( `` identity `` ) ) ; op builder . add input ( input . a output ( ) ) ; return new identity < t > ( op builder . build ( ) ) ; }
public static write graph summary create ( scope scope , operand < ? > writer , operand < long > step , operand < string > tensor ) { operation builder op builder = scope . graph ( ) . op builder ( `` write graph summary `` , scope . make op name ( `` write graph summary `` ) ) ; op builder . add input ( writer . a output ( ) ) ; op builder . add input ( step . a output ( ) ) ; op builder . add input ( tensor . a output ( ) ) ; return new write graph summary ( op builder . build ( ) ) ; }
public static concatenate dataset create ( scope scope , operand < ? > input dataset , operand < ? > another dataset , list < class < ? > > output type , list < shape > output shape ) { operation builder op builder = scope . graph ( ) . op builder ( `` concatenate dataset `` , scope . make op name ( `` concatenate dataset `` ) ) ; op builder . add input ( input dataset . a output ( ) ) ; op builder . add input ( another dataset . a output ( ) ) ; data type [ ] output type array = new data type [ output type . size ( ) ] ; for ( int i = 0 ; i < output type array . length ; ++i ) { output type array [ i ] = data type . from class ( output type . get ( i ) ) ; } op builder . set attr ( `` output_types `` , output type array ) ; shape [ ] output shape array = new shape [ output shape . size ( ) ] ; for ( int i = 0 ; i < output shape array . length ; ++i ) { output shape array [ i ] = output shape . get ( i ) ; } op builder . set attr ( `` output_shapes `` , output shape array ) ; return new concatenate dataset ( op builder . build ( ) ) ; }
public static multi device iterator create ( scope scope , list < string > device , string share name , string container , list < class < ? > > output type , list < shape > output shape ) { operation builder op builder = scope . graph ( ) . op builder ( `` multi device iterator `` , scope . make op name ( `` multi device iterator `` ) ) ; string [ ] device array = new string [ device . size ( ) ] ; for ( int i = 0 ; i < device array . length ; ++i ) { device array [ i ] = device . get ( i ) ; } op builder . set attr ( `` device `` , device array ) ; op builder . set attr ( `` shared_name `` , share name ) ; op builder . set attr ( `` container `` , container ) ; data type [ ] output type array = new data type [ output type . size ( ) ] ; for ( int i = 0 ; i < output type array . length ; ++i ) { output type array [ i ] = data type . from class ( output type . get ( i ) ) ; } op builder . set attr ( `` output_types `` , output type array ) ; shape [ ] output shape array = new shape [ output shape . size ( ) ] ; for ( int i = 0 ; i < output shape array . length ; ++i ) { output shape array [ i ] = output shape . get ( i ) ; } op builder . set attr ( `` output_shapes `` , output shape array ) ; return new multi device iterator ( op builder . build ( ) ) ; }
public static < t extend number > non max suppression v3 create ( scope scope , operand < t > box , operand < t > score , operand < integer > max output size , operand < float > iou threshold , operand < float > score threshold ) { operation builder op builder = scope . graph ( ) . op builder ( `` non max suppression v3 `` , scope . make op name ( `` non max suppression v3 `` ) ) ; op builder . add input ( box . a output ( ) ) ; op builder . add input ( score . a output ( ) ) ; op builder . add input ( max output size . a output ( ) ) ; op builder . add input ( iou threshold . a output ( ) ) ; op builder . add input ( score threshold . a output ( ) ) ; return new non max suppression v3 ( op builder . build ( ) ) ; }
public output < integer > output ( ) { return output ; }
public static < t extend number > non max suppression v3 create ( scope scope , operand < t > box , operand < t > score , operand < integer > max output size , operand < float > iou threshold , operand < float > score threshold ) { operation builder op builder = scope . graph ( ) . op builder ( `` non max suppression v3 `` , scope . make op name ( `` non max suppression v3 `` ) ) ; op builder . add input ( box . a output ( ) ) ; op builder . add input ( score . a output ( ) ) ; op builder . add input ( max output size . a output ( ) ) ; op builder . add input ( iou threshold . a output ( ) ) ; op builder . add input ( score threshold . a output ( ) ) ; return new non max suppression v3 ( op builder . build ( ) ) ; }
public static f i f o queue create ( scope scope , list < class < ? > > component type , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` f i f o queue v2 `` , scope . make op name ( `` f i f o queue `` ) ) ; data type [ ] component type array = new data type [ component type . size ( ) ] ; for ( int i = 0 ; i < component type array . length ; ++i ) { component type array [ i ] = data type . from class ( component type . get ( i ) ) ; } op builder . set attr ( `` component_types `` , component type array ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . shape ! = null ) { shape [ ] shape array = new shape [ opts . shape . size ( ) ] ; for ( int i = 0 ; i < shape array . length ; ++i ) { shapes array [ i ] = opts . shape . get ( i ) ; } op builder . set attr ( `` shape `` , shape array ) ; } if ( opts . capacity ! = null ) { op builder . set attr ( `` capacity `` , opts . capacity ) ; } if ( opts . container ! = null ) { op builder . set attr ( `` container `` , opts . container ) ; } if ( opts . share name ! = null ) { op builder . set attr ( `` shared_name `` , opts . share name ) ; } } } return new f i f o queue ( op builder . build ( ) ) ; }
public static parse single example create ( scope scope , operand < string > serialize , iterable < operand < ? > > dense default , long num sparse , list < string > sparse key , list < string > dense key , list < class < ? > > sparse type , list < shape > dense shape ) { operation builder op builder = scope . graph ( ) . op builder ( `` parse single example `` , scope . make op name ( `` parse single example `` ) ) ; op builder . add input ( serialize . a output ( ) ) ; op builder . add input list ( operands . a output ( dense default ) ) ; op builder . set attr ( `` num_sparse `` , num sparse ) ; string [ ] sparse key array = new string [ sparse key . size ( ) ] ; for ( int i = 0 ; i < sparse key array . length ; ++i ) { sparse key array [ i ] = sparse key . get ( i ) ; } op builder . set attr ( `` sparse_keys `` , sparse key array ) ; string [ ] dense key array = new string [ dense key . size ( ) ] ; for ( int i = 0 ; i < dense key array . length ; ++i ) { dense key array [ i ] = dense key . get ( i ) ; } op builder . set attr ( `` dense_keys `` , dense key array ) ; data type [ ] sparse type array = new data type [ sparse type . size ( ) ] ; for ( int i = 0 ; i < sparse type array . length ; ++i ) { sparse type array [ i ] = data type . from class ( sparse type . get ( i ) ) ; } op builder . set attr ( `` sparse_types `` , sparse type array ) ; shape [ ] dense shape array = new shape [ dense shape . size ( ) ] ; for ( int i = 0 ; i < dense shape array . length ; ++i ) { dense shape array [ i ] = dense shape . get ( i ) ; } op builder . set attr ( `` dense_shapes `` , dense shape array ) ; return new parse single example ( op builder . build ( ) ) ; }
public static f i f o queue create ( scope scope , list < class < ? > > component type , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` f i f o queue v2 `` , scope . make op name ( `` f i f o queue `` ) ) ; data type [ ] component type array = new data type [ component type . size ( ) ] ; for ( int i = 0 ; i < component type array . length ; ++i ) { component type array [ i ] = data type . from class ( component type . get ( i ) ) ; } op builder . set attr ( `` component_types `` , component type array ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . shape ! = null ) { shape [ ] shape array = new shape [ opts . shape . size ( ) ] ; for ( int i = 0 ; i < shape array . length ; ++i ) { shapes array [ i ] = opts . shape . get ( i ) ; } op builder . set attr ( `` shape `` , shape array ) ; } if ( opts . capacity ! = null ) { op builder . set attr ( `` capacity `` , opts . capacity ) ; } if ( opts . container ! = null ) { op builder . set attr ( `` container `` , opts . container ) ; } if ( opts . share name ! = null ) { op builder . set attr ( `` shared_name `` , opts . share name ) ; } } } return new f i f o queue ( op builder . build ( ) ) ; }
public static < t extend number > quantize and dequantize < t > create ( scope scope , operand < t > input , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` quantize and dequantize `` , scope . make op name ( `` quantize and dequantize `` ) ) ; op builder . add input ( input . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . sign input ! = null ) { op builder . set attr ( `` signed_input `` , opts . sign input ) ; } if ( opts . num bit ! = null ) { op builder . set attr ( `` num_bits `` , opts . num bit ) ; } if ( opts . range give ! = null ) { op builder . set attr ( `` range_given `` , opts . range give ) ; } if ( opts . input min ! = null ) { op builder . set attr ( `` input_min `` , opts . input min ) ; } if ( opts . input max ! = null ) { op builder . set attr ( `` input_max `` , opts . input max ) ; } } } return new quantize and dequantize < t > ( op builder . build ( ) ) ; }
public static < t > sparse concat < t > create ( scope scope , iterable < operand < long > > index , operand < t > value , iterable < operand < long > > shape , long concat dim ) { operation builder op builder = scope . graph ( ) . op builder ( `` sparse concat `` , scope . make op name ( `` sparse concat `` ) ) ; op builder . add input list ( operands . a output ( index ) ) ; op builder . add input ( value . a output ( ) ) ; op builder . add input list ( operands . a output ( shape ) ) ; op builder . set attr ( `` concat_dim `` , concat dim ) ; return new sparse concat < t > ( op builder . build ( ) ) ; }
public output < float > max activation ( ) { return max activation ; }
public output < float > y max ( ) { return y max ; }
public output < t > output ( ) { return output ; }
public static < t > random shuffle < t > create ( scope scope , operand < t > value , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` random shuffle `` , scope . make op name ( `` random shuffle `` ) ) ; op builder . add input ( value . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . seed ! = null ) { op builder . set attr ( `` seed `` , opts . seed ) ; } if ( opts . seed2 ! = null ) { op builder . set attr ( `` seed2 `` , opts . seed2 ) ; } } } return new random shuffle < t > ( op builder . build ( ) ) ; }
public static reader restore state create ( scope scope , operand < ? > reader handle , operand < string > state ) { operation builder op builder = scope . graph ( ) . op builder ( `` reader restore state v2 `` , scope . make op name ( `` reader restore state `` ) ) ; op builder . add input ( reader handle . a output ( ) ) ; op builder . add input ( state . a output ( ) ) ; return new reader restore state ( op builder . build ( ) ) ; }
public static write file create ( scope scope , operand < string > filename , operand < string > content ) { operation builder op builder = scope . graph ( ) . op builder ( `` write file `` , scope . make op name ( `` write file `` ) ) ; op builder . add input ( filename . a output ( ) ) ; op builder . add input ( content . a output ( ) ) ; return new write file ( op builder . build ( ) ) ; }
public static < t > subtract < t > create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` sub `` , scope . make op name ( `` subtract `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new subtract < t > ( op builder . build ( ) ) ; }
public static < t > ref identity < t > create ( scope scope , operand < t > input ) { operation builder op builder = scope . graph ( ) . op builder ( `` ref identity `` , scope . make op name ( `` ref identity `` ) ) ; op builder . add input ( input . a output ( ) ) ; return new ref identity < t > ( op builder . build ( ) ) ; }
public static < t extend number > resize bilinear create ( scope scope , operand < t > image , operand < integer > size , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` resize bilinear `` , scope . make op name ( `` resize bilinear `` ) ) ; op builder . add input ( image . a output ( ) ) ; op builder . add input ( size . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . align corner ! = null ) { op builder . set attr ( `` align_corners `` , opts . align corner ) ; } } } return new resize bilinear ( op builder . build ( ) ) ; }
public list < output < ? > > output ( ) { return output ; }
public static < t extend number > floor < t > create ( scope scope , operand < t > x ) { operation builder op builder = scope . graph ( ) . op builder ( `` floor `` , scope . make op name ( `` floor `` ) ) ; op builder . add input ( x . a output ( ) ) ; return new floor < t > ( op builder . build ( ) ) ; }
public int get begin ( ) { return begin ; }
public list < output < float > > summary ( ) { return summary ; }
public static < e > iterable < e > singleton ( final e single ) { return new iterable < e > ( ) { @ override public iterator < e > iterator ( ) { return new once only iterator < e > ( single ) ; } } ; }
public static < t > mul < t > create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` mul `` , scope . make op name ( `` mul `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new mul < t > ( op builder . build ( ) ) ; }
public static < t > rsqrt grad < t > create ( scope scope , operand < t > y , operand < t > dy ) { operation builder op builder = scope . graph ( ) . op builder ( `` rsqrt grad `` , scope . make op name ( `` rsqrt grad `` ) ) ; op builder . add input ( y . a output ( ) ) ; op builder . add input ( dy . a output ( ) ) ; return new rsqrt grad < t > ( op builder . build ( ) ) ; }
public output < string > vocab word ( ) { return vocab word ; }
public static < t > accumulator apply gradient create ( scope scope , operand < string > handle , operand < long > local step , operand < t > gradient ) { operation builder op builder = scope . graph ( ) . op builder ( `` accumulator apply gradient `` , scope . make op name ( `` accumulator apply gradient `` ) ) ; op builder . add input ( handle . a output ( ) ) ; op builder . add input ( local step . a output ( ) ) ; op builder . add input ( gradient . a output ( ) ) ; return new accumulator apply gradient ( op builder . build ( ) ) ; }
public output < long > output shape ( ) { return output shape ; }
public static < t > sparse dense cwise add < t > create ( scope scope , operand < long > sp index , operand < t > sp value , operand < long > sp shape , operand < t > dense ) { operation builder op builder = scope . graph ( ) . op builder ( `` sparse dense cwise add `` , scope . make op name ( `` sparse dense cwise add `` ) ) ; op builder . add input ( sp index . a output ( ) ) ; op builder . add input ( sp value . a output ( ) ) ; op builder . add input ( sp shape . a output ( ) ) ; op builder . add input ( dense . a output ( ) ) ; return new sparse dense cwise add < t > ( op builder . build ( ) ) ; }
public static < t extend number > sparse reduce max sparse < t > create ( scope scope , operand < long > input index , operand < t > input value , operand < long > input shape , operand < integer > reduction ax , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` sparse reduce max sparse `` , scope . make op name ( `` sparse reduce max sparse `` ) ) ; op builder . add input ( input index . a output ( ) ) ; op builder . add input ( input value . a output ( ) ) ; op builder . add input ( input shape . a output ( ) ) ; op builder . add input ( reduction axes . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . keep dims ! = null ) { op builder . set attr ( `` keep_dims `` , opts . keep dims ) ; } } } return new sparse reduce max sparse < t > ( op builder . build ( ) ) ; }
public list < output < ? > > output ( ) { return output ; }
public output < long > sparse dense shape ( ) { return sparse dense shape ; }
public static < t > variable < t > create ( scope scope , shape shape , class < t > dtype , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` variable v2 `` , scope . make op name ( `` variable `` ) ) ; op builder . set attr ( `` shape `` , shape ) ; op builder . set attr ( `` dtype `` , data type . from class ( dtype ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . container ! = null ) { op builder . set attr ( `` container `` , opts . container ) ; } if ( opts . share name ! = null ) { op builder . set attr ( `` shared_name `` , opts . share name ) ; } } } return new variable < t > ( op builder . build ( ) ) ; }
public output < ? > [ ] output list ( int idx , int length ) { output < ? > [ ] output = new output < ? > [ length ] ; for ( int i = 0 ; i < length ; ++i ) { output [ i ] = output ( idx + i ) ; } return output ; }
public static < t > tensor array gather < t > create ( scope scope , operand < ? > handle , operand < integer > index , operand < float > flow in , class < t > dtype , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` tensor array gather v3 `` , scope . make op name ( `` tensor array gather `` ) ) ; op builder . add input ( handle . a output ( ) ) ; op builder . add input ( index . a output ( ) ) ; op builder . add input ( flow in . a output ( ) ) ; op builder . set attr ( `` dtype `` , data type . from class ( dtype ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . element shape ! = null ) { op builder . set attr ( `` element_shape `` , opts . element shape ) ; } } } return new tensor array gather < t > ( op builder . build ( ) ) ; }
public static < t > tensor array write create ( scope scope , operand < ? > handle , operand < integer > index , operand < t > value , operand < float > flow in ) { operation builder op builder = scope . graph ( ) . op builder ( `` tensor array write v3 `` , scope . make op name ( `` tensor array write `` ) ) ; op builder . add input ( handle . a output ( ) ) ; op builder . add input ( index . a output ( ) ) ; op builder . add input ( value . a output ( ) ) ; op builder . add input ( flow in . a output ( ) ) ; return new tensor array write ( op builder . build ( ) ) ; }
public static tensor forest tree size create ( scope scope , operand < ? > tree handle ) { operation builder op builder = scope . graph ( ) . op builder ( `` tensor forest tree size `` , scope . make op name ( `` tensor forest tree size `` ) ) ; op builder . add input ( tree handle . a output ( ) ) ; return new tensor forest tree size ( op builder . build ( ) ) ; }
public output < integer > value index ( ) { return value index ; }
public static rpc create ( scope scope , operand < string > address , operand < string > method , operand < string > request , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` rpc `` , scope . make op name ( `` rpc `` ) ) ; op builder . add input ( address . a output ( ) ) ; op builder . add input ( method . a output ( ) ) ; op builder . add input ( request . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . protocol ! = null ) { op builder . set attr ( `` protocol `` , opts . protocol ) ; } if ( opts . fail fast ! = null ) { op builder . set attr ( `` fail_fast `` , opts . fail fast ) ; } if ( opts . timeout in m ! = null ) { op builder . set attr ( `` timeout_in_ms `` , opts . timeout in m ) ; } } } return new rpc ( op builder . build ( ) ) ; }
public output < string > output ( ) { return output ; }
public static wrap dataset variant create ( scope scope , operand < ? > input handle ) { operation builder op builder = scope . graph ( ) . op builder ( `` wrap dataset variant `` , scope . make op name ( `` wrap dataset variant `` ) ) ; op builder . add input ( input handle . a output ( ) ) ; return new wrap dataset variant ( op builder . build ( ) ) ; }
public string type ( ) { graph . reference r = graph . ref ( ) ; try { return type ( unsafe native handle ) ; } finally { r . close ( ) ; } }
public synchronize void close ( ) throw interrupted exception { stop ( ) ; while ( num join > 0 ) { wait ( ) ; } delete ( native handle ) ; native handle = 0 ; }
public static void array copy ( byte buffer src , int src po , byte buffer dst , int dst po , int length ) { fast byte operation . copy ( src , src po , dst , dst po , length ) ; }
public log builder at debug ( ) { return at level ( level . debug ) ; }
public void set error ( string annotation method name , string message , int index ) { annotation value v = value . get ( annotation method name ) ; if ( v == null ) return ; v . set error ( message , index ) ; }
public void set top ( script node top ) { this . top = top ; }
protect boolean replace statement in node ( n statement , n old n , n new n ) { for ( field access fa : field of ( statement . get class ( ) ) ) { if ( replace statement in field ( fa , statement , old n , new n ) ) return true ; } return false ; }
public static ast find previous sibling ( ast parent , ast child ) { ast prev = null ; ast n = parent . get first child ( ) ; while ( n ! = null ) { if ( n == child ) { return prev ; } prev = n ; n = n . get next sibling ( ) ; } throw new illegal argument exception ( `` child not find in parent ! `` ) ; }
public static < s > service loader < s > load ( class < s > service ) { return load ( service , thread . current thread ( ) . get context class loader ( ) ) ; }
public static void clear class loader ( class loader class loader ) { for ( iterator < class loader > it = accept class loader . iterator ( ) ; it . have next ( ) ; ) { class loader register loader = it . next ( ) ; if ( be underneath class loader ( registered loader , class loader ) ) { it . remove ( ) ; } } for ( iterator < class < ? > > it = strong class cache . key set ( ) . iterator ( ) ; it . have next ( ) ; ) { class < ? > bean class = it . next ( ) ; if ( be underneath class loader ( bean class . get class loader ( ) , class loader ) ) { it . remove ( ) ; } } for ( iterator < class < ? > > it = soft class cache . key set ( ) . iterator ( ) ; it . have next ( ) ; ) { class < ? > bean class = it . next ( ) ; if ( be underneath class loader ( bean class . get class loader ( ) , class loader ) ) { it . remove ( ) ; } } }
public static version parse version ( string version ) { if ( version == null ) { return empty version ; } return value of ( version ) ; }
public void print stats ( list < ? extend j c tree > tree ) throw i o exception { for ( list < ? extend j c tree > l = tree ; l . non empty ( ) ; l = l . tail ) { if ( be suppress ( l . head ) ) continue ; if ( ! suppress alignment for empty line ( l . head ) ) align ( ) ; print stat ( l . head ) ; println ( ) ; } }
public static < t extend annotation > t get annotation proxy ( annotation custom annotation , class < t > reference annotation ) { invocation handler handler = new annotation invocation handler ( custom annotation ) ; return ( t ) proxy . new proxy instance ( reference annotation . get class loader ( ) , new class [ ] { reference annotation } , handler ) ; }
public static handler library load ( messager messager ) { handler library library = new handler library ( messager ) ; try { load annotation handler ( library ) ; load visitor handler ( library ) ; } catch ( i o exception e ) { system . err . println ( `` lombok be n't run due to misconfigured spi file : `` + e ) ; } library . calculate priority ( ) ; return library ; }
public static string clean ( string charset name ) { try { return for name ( charset name ) . name ( ) ; } catch ( exception e ) { return null ; } }
public static boolean start with ( char s [ ] , int len , string prefix ) { final int prefix len = prefix . length ( ) ; if ( prefix len > len ) return false ; for ( int i = 0 ; i < prefix len ; i++ ) if ( s [ i ] ! = prefix . char at ( i ) ) return false ; return true ; }
public void put ( k k , v v ) { precondition . check not null ( k ) ; if ( buffer == null ) { realloc ( default_max_capacity ) ; } else if ( num insert + 1 > capacity ) { realloc ( capacity * 2 ) ; } put internal ( k , v ) ; }
public static char array set make stop set ( version match version , string [ ] stop word , boolean ignore case ) { char array set stop set = new char array set ( match version , stop word . length , ignore case ) ; stop set . add all ( array . a list ( stop word ) ) ; return stop set ; }
public list < hunspell affix > lookup prefix ( char word [ ] , int offset , int length ) { return prefix . get ( word , offset , length ) ; }
protect char [ ] generate flag ( ) { char [ ] flags= flag . to string ( get flag ( ) ) . to char array ( ) ; if ( flag . length == 0 ) { return flag ; } else { return char operation . concat ( flag , new char [ ] { ' ' } ) ; } }
public final token stream token stream ( final string field name , final string text ) throw i o exception { token stream component component = reuse strategy . get reusable component ( this , field name ) ; @ suppress warning ( `` resource `` ) final reusable string reader str reader = ( component == null || component . reusable string reader == null ) ? new reusable string reader ( ) : component . reusable string reader ; str reader . set value ( text ) ; final reader r = init reader ( field name , str reader ) ; if ( component == null ) { component = create component ( field name , r ) ; reuse strategy . set reusable component ( this , field name , component ) ; } else { component . set reader ( r ) ; } component . reusable string reader = str reader ; return component . get token stream ( ) ; }
public final tokenizer create ( reader input ) { return create ( attribute factory . default_attribute_factory , input ) ; }
public static void reverse ( version match version , final char [ ] buffer , final int len ) { reverse ( match version , buffer , 0 , len ) ; }
public void set separator ( string separator ) { this . separator = ( separator ! = null ? separator : default_separator ) ; }
public final int to char ( int [ ] src , int src off , int src len , char [ ] d , int d off ) { if ( src len < 0 ) { throw new illegal argument exception ( `` src len must be > = 0 `` ) ; } int write = 0 ; for ( int i = 0 ; i < src len ; ++i ) { write += character . to char ( src [ src off + i ] , d , d off + write ) ; } return write ; }
protect static char array set load stopword set ( path stopwords ) throw i o exception { reader reader = null ; try { reader = file . new buffer reader ( stopwords , standard charsets . utf_8 ) ; return wordlist loader . get word set ( reader ) ; } finally { i o utils . close ( reader ) ; } }
public static builder builder ( ) { return builder ( new classpath resource loader ( custom analyzer . class . get class loader ( ) ) ) ; }
public list < token filter factory > get token filter factory ( ) { return collection . unmodifiable list ( arrays . a list ( token filter ) ) ; }
public static int analyze ( token stream stream , token consumer consumer ) throw i o exception { int num tokens = 0 ; boolean success = false ; try { stream . reset ( ) ; consumer . reset ( stream ) ; while ( stream . increment token ( ) ) { consumer . next token ( ) ; num tokens++ ; } consumer . end ( ) ; success = true ; } finally { if ( success ) { stream . close ( ) ; } else { i o utils . close while handle exception ( stream ) ; } } return num token ; }
public final token stream token stream ( final string field name , final string text ) throw i o exception { token stream component component = reuse strategy . get reusable component ( this , field name ) ; @ suppress warning ( `` resource `` ) final reusable string reader str reader = ( component == null || component . reusable string reader == null ) ? new reusable string reader ( ) : component . reusable string reader ; str reader . set value ( text ) ; final reader r = init reader ( field name , str reader ) ; if ( component == null ) { component = create component ( field name , r ) ; reuse strategy . set reusable component ( this , field name , component ) ; } else { component . set reader ( r ) ; } component . reusable string reader = str reader ; return component . get token stream ( ) ; }
public final token stream token stream ( final string field name , final string text ) throw i o exception { token stream component component = reuse strategy . get reusable component ( this , field name ) ; @ suppress warning ( `` resource `` ) final reusable string reader str reader = ( component == null || component . reusable string reader == null ) ? new reusable string reader ( ) : component . reusable string reader ; str reader . set value ( text ) ; final reader r = init reader ( field name , str reader ) ; if ( component == null ) { component = create component ( field name , r ) ; reuse strategy . set reusable component ( this , field name , component ) ; } else { component . set reader ( r ) ; } component . reusable string reader = str reader ; return component . get token stream ( ) ; }
public final reader reader ( ) throw i o exception { try { if ( string ! = null ) return new string reader ( string ) ; else if ( bytes ! = null ) return input stream reader ( new byte array input stream ( byte ) ) ; else if ( reader ! = null ) return reader ; else if ( input stream ! = null ) return input stream reader ( input stream ) ; else if ( file ! = null ) return new buffer reader ( input stream reader ( new file input stream ( file ) ) ) ; else throw new illegal state exception ( `` could not produce a reader from this source `` ) ; } catch ( java . io . i o exception e ) { throw new i o exception ( e . get message ( ) , e ) ; } }
protect int read header ( index input input ) throw i o exception { int version = codec util . check header ( input , block tree term writer . terms_codec_name , block tree term writer . terms_version_start , block tree term writer . terms_version_current ) ; if ( version < block tree term writer . terms_version_append_only ) { dir offset = input . read long ( ) ; } return version ; }
protect void write trailer ( index output out , long dir start ) throw i o exception { out . write long ( dir start ) ; }
public static void main ( string [ ] args ) throw exception { configuration conf = new configuration ( ) ; compression codec factory factory = new compression codec factory ( conf ) ; boolean encode = false ; for ( int i=0 ; i < args . length ; ++i ) { if ( `` -in `` . equal ( args [ i ] ) ) { encode = true ; } else if ( `` -out `` . equal ( args [ i ] ) ) { encode = false ; } else { compression codec codec = factory . get codec ( new path ( args [ i ] ) ) ; if ( codec == null ) { system . out . println ( `` codec for `` + args [ i ] + `` not find . `` ) ; } else { if ( encode ) { compression output stream out = null ; java . io . input stream in = null ; try { out = codec . create output stream ( new java . io . file output stream ( args [ i ] ) ) ; byte [ ] buffer = new byte [ 100 ] ; string in filename = remove suffix ( args [ i ] , codec . get default extension ( ) ) ; in = new java . io . file input stream ( in filename ) ; int len = in . read ( buffer ) ; while ( len > 0 ) { out . write ( buffer , 0 , len ) ; len = in . read ( buffer ) ; } } finally { if ( out ! = null ) { out . close ( ) ; } if ( in ! = null ) { in . close ( ) ; } } } else { compression input stream in = null ; try { in = codec . create input stream ( new java . io . file input stream ( args [ i ] ) ) ; byte [ ] buffer = new byte [ 100 ] ; int len = in . read ( buffer ) ; while ( len > 0 ) { system . out . write ( buffer , 0 , len ) ; len = in . read ( buffer ) ; } } finally { if ( in ! = null ) { in . close ( ) ; } } } } } } }
public int max frame payload length ( ) { return max frame payload length ; }
public boolean get bit ( int po ) { if ( pos > nb bit ) { throw new index out of bound exception ( i18n . err ( i18n . err_00031_cannot_find_bit , po , nb bit ) ) ; } int po bytes = po > > > 3 ; int bit number = 7 - po % 8 ; byte mask = ( byte ) ( 1 < < bit number ) ; int res = byte [ pos byte ] & mask ; return res ! = 0 ; }
public final < t > t [ ] to array ( t [ ] array ) { int b = bits ; final int size = bit count ( b ) ; if ( size > array . length ) { array = array . copy of ( array , size ) ; } int idx = 0 ; while ( bit count ( b ) > 0 ) { final int lob = low one bit ( b ) ; array [ idx + 1 ] = ( t ) item of ( number of trail zero ( lob ) ) ; b ^= lob ; } return array ; }
protect final void heap remove root ( ) { if ( num scorer == 1 ) { sub scorer [ 0 ] = null ; num scorer = 0 ; } else { sub scorer [ 0 ] = sub scorer [ num scorer - 1 ] ; sub scorer [ num scorer - 1 ] = null ; -- num scorer ; heap adjust ( 0 ) ; } }
public void set field ( field info field info ) { this . field info = field info ; index option = field info . get index option ( ) ; write freqs = index option . compare to ( index option . docs_and_freqs ) > = 0 ; write position = index option . compare to ( index option . docs_and_freqs_and_positions ) > = 0 ; write offset = index option . compare to ( index option . docs_and_freqs_and_positions_and_offsets ) > = 0 ; write payload = field info . have payload ( ) ; if ( write freqs == false ) { enum flag = 0 ; } else if ( write position == false ) { enum flag = posting enum . freqs ; } else if ( write offset == false ) { if ( write payload ) { enum flag = posting enum . payload ; } else { enum flag = posting enum . position ; } } else { if ( write payload ) { enum flag = posting enum . payload | posting enum . offset ; } else { enum flag = posting enum . offset ; } } }
public void finish ( ) throw i o exception { if ( ! finish ) { compressor . finish ( ) ; finish = true ; } }
public static byte [ ] decompress ( byte [ ] value ) throw data format exception { return decompress ( value , 0 , value . length ) ; }
public static byte [ ] decompress ( byte [ ] value ) throw data format exception { return decompress ( value , 0 , value . length ) ; }
public void set store term vector offset ( boolean value ) { check if frozen ( ) ; this . store term vector offset = value ; }
public void set index option ( index option index option ) { this . search request . index option ( index option ) ; }
public integer get numeric scale ( ) { return numeric scale ; }
public void set numeric precision step ( int precision step ) { check if frozen ( ) ; if ( precision step < 1 ) { throw new illegal argument exception ( `` precision step must be > = 1 ( get `` + precision step + `` ) `` ) ; } this . numeric precision step = precision step ; }
protect synchronized merge thread get merge thread ( index writer writer , merge policy . one merge merge ) throw i o exception { final merge thread thread = new merge thread ( writer , merge ) ; thread . set thread priority ( merge thread priority ) ; thread . set daemon ( true ) ; thread . set name ( `` lucene merge thread # `` + merge thread count++ ) ; return thread ; }
public static directory reader open ( final index commit commit ) throw i o exception { return standard directory reader . open ( commit . get directory ( ) , commit , default_terms_index_divisor ) ; }
public static directory reader open if change ( directory reader old reader ) throw i o exception { final directory reader new reader = old reader . do open if change ( ) ; assert new reader ! = old reader ; return new reader ; }
public void merge numeric field ( final field info field info , final merge state merge state , final list < numeric doc value > to merge , final list < bits > doc with field ) throw i o exception { add numeric field ( field info , new iterable < number > ( ) { @ override public iterator < number > iterator ( ) { return new iterator < number > ( ) { int reader upto = -1 ; int doc i d upto ; long next value ; atomic reader current reader ; numeric doc value current value ; bit current live doc ; bit current doc with field ; boolean next be set ; @ override public boolean have next ( ) { return next be set || set next ( ) ; } @ override public void remove ( ) { throw new unsupported operation exception ( ) ; } @ override public number next ( ) { if ( ! have next ( ) ) { throw new no such element exception ( ) ; } assert next be set ; next be set = false ; return next value ; } private boolean set next ( ) { while ( true ) { if ( reader upto == to merge . size ( ) ) { return false ; } if ( current reader == null || doc i d upto == current reader . max doc ( ) ) { reader upto++ ; if ( reader upto < to merge . size ( ) ) { current reader = merge state . reader . get ( reader upto ) ; current value = to merge . get ( reader upto ) ; current live doc = current reader . get live doc ( ) ; current doc with field = doc with field . get ( reader upto ) ; } doc i d upto = 0 ; continue ; } if ( current live doc == null || current live doc . get ( doc i d upto ) ) { next be set = true ; if ( current doc with field . get ( doc i d upto ) ) { next value = current value . get ( doc i d upto ) ; } else { next value = null ; } doc i d upto++ ; return true ; } doc i d upto++ ; } } } ; } } ) ; }
public void set omits norm ( ) { if ( index option == index option . none ) { throw new illegal state exception ( `` can not omit norm : this field be not indexed `` ) ; } omit norm = true ; this . check consistency ( ) ; }
public boolean equal norm ( geometry g ) { if ( g == null ) return false ; return norm ( ) . equal exact ( g . norm ( ) ) ; }
public boolean have doc value ( ) { return doc value type ! = null ; }
public int get offset ( ) { return i offset ; }
public float score ( float weight , float boost ) { if ( boost == 0f ) { return weight ; } if ( weight == 0f ) { return boost ; } return weight * boost ; }
public int total doc count ( ) { int count = 0 ; for ( segment commit info info : this ) { count += info . info . get doc count ( ) ; } return count ; }
public int total doc count ( ) { int count = 0 ; for ( segment commit info info : this ) { count += info . info . get doc count ( ) ; } return count ; }
public final void prepare commit ( ) throw i o exception { ensure open ( ) ; prepare commit internal ( ) ; }
public final int num delete doc ( ) { return max doc ( ) - num doc ( ) ; }
public int get max thread state ( ) { try { return ( ( thread affinity document writer thread pool ) indexer thread pool ) . get max thread state ( ) ; } catch ( class cast exception cce ) { throw new illegal state exception ( cce ) ; } }
public static directory reader open if change ( directory reader old reader , index writer writer , boolean apply all deletes ) throw i o exception { final directory reader new reader = old reader . do open if change ( writer , apply all deletes ) ; assert new reader ! = old reader ; return new reader ; }
public void set max merge m b for force merge ( double mb ) { max merge size for force merge = ( long ) ( mb * 1024 * 1024 ) ; }
public static numeric doc value get numeric value ( final index reader r , final string field ) throw i o exception { final list < atomic reader context > leave = r . leaf ( ) ; final int size = leave . size ( ) ; if ( size == 0 ) { return null ; } else if ( size == 1 ) { return leave . get ( 0 ) . reader ( ) . get numeric doc value ( field ) ; } boolean any real = false ; final numeric doc value [ ] value = new numeric doc value [ size ] ; final int [ ] start = new int [ size+1 ] ; for ( int i = 0 ; i < size ; i++ ) { atomic reader context context = leave . get ( i ) ; numeric doc value v = context . reader ( ) . get numeric doc value ( field ) ; if ( v == null ) { v = numeric doc value . empty ; } else { any real = true ; } value [ i ] = v ; start [ i ] = context . doc base ; } start [ size ] = r . max doc ( ) ; if ( ! any real ) { return null ; } else { return new numeric doc value ( ) { @ override public long get ( int doc i d ) { int sub index = reader util . sub index ( doc i d , start ) ; return value [ sub index ] . get ( doc i d - start [ sub index ] ) ; } } ; } }
public static sort doc value get sort value ( final index reader r , final string field ) throw i o exception { final list < atomic reader context > leave = r . leaf ( ) ; final int size = leave . size ( ) ; if ( size == 0 ) { return null ; } else if ( size == 1 ) { return leave . get ( 0 ) . reader ( ) . get sorted doc value ( field ) ; } boolean any real = false ; final sort doc value [ ] value = new sort doc value [ size ] ; final int [ ] start = new int [ size+1 ] ; for ( int i = 0 ; i < size ; i++ ) { atomic reader context context = leave . get ( i ) ; sort doc value v = context . reader ( ) . get sorted doc value ( field ) ; if ( v == null ) { v = sort doc value . empty ; } else { any real = true ; } value [ i ] = v ; start [ i ] = context . doc base ; } start [ size ] = r . max doc ( ) ; if ( ! any real ) { return null ; } else { term enum enums [ ] = new term enum [ value . length ] ; for ( int i = 0 ; i < value . length ; i++ ) { enums [ i ] = value [ i ] . term enum ( ) ; } ordinal map map = new ordinal map ( r . get core cache key ( ) , enums ) ; return new multi sort doc value ( value , start , map ) ; } }
public string to string ( directory dir , int pending del count ) { string s = info . to string ( dir , del count + pending del count ) ; if ( del gen ! = -1 ) { s += `` : del gen= `` + del gen ; } if ( field info gen ! = -1 ) { s += `` : field info gen= `` + field info gen ; } return s ; }
public int get soft del count ( ) { return soft del count ; }
public void add file ( string file ) { check file name ( collection . singleton ( file ) ) ; set file . add ( file ) ; }
public void string field ( field info field info , byte [ ] value ) throw i o exception { }
public void double field ( field info field info , double value ) throw i o exception { }
public int compare to ( final field info other ) { final int diff = declare class name . compare to ( other . declare class name ) ; if ( diff ! = 0 ) { return diff ; } return name . compare to ( other . name ) ; }
public input output < t > seek ceil ( bytes ref target ) throw i o exception { this . target = target ; target length = target . length ; super . do seek ceil ( ) ; return set result ( ) ; }
public tiered merge policy set max merge at once explicit ( int v ) { if ( v < 2 ) { throw new illegal argument exception ( `` max merge at once explicit must be > 1 ( get `` + v + `` ) `` ) ; } max merge at once explicit = v ; return this ; }
public synchronize int doc count ( ) { int count = 0 ; for ( int i = 0 ; i < segment info . size ( ) ; i++ ) { segment info si = segment info . info ( i ) ; count += si . doc count ; } return count ; }
public void set high freq minimum number should match ( float min ) { this . high freq min nr should match = min ; }
public float get high freq minimum number should match ( ) { return high freq min nr should match ; }
public document field field ( string field name ) { document field result = document field . get ( field name ) ; if ( result ! = null ) { return result ; } else { return meta field . get ( field name ) ; } }
public int prefix length ( ) { return prefix length ; }
public static void set default ( similarity similarity ) { similarity . default impl = similarity ; }
public document doc ( int doc i d , set < string > field to load ) throw i o exception { return reader . document ( doc i d , field to load ) ; }
public static sort numeric doc value get sort numeric value ( final index reader r , final string field ) throw i o exception { final list < leaf reader context > leave = r . leaf ( ) ; final int size = leave . size ( ) ; if ( size == 0 ) { return null ; } else if ( size == 1 ) { return leave . get ( 0 ) . reader ( ) . get sorted numeric doc value ( field ) ; } boolean any real = false ; final sort numeric doc value [ ] value = new sort numeric doc value [ size ] ; final int [ ] start = new int [ size+1 ] ; long total cost = 0 ; for ( int i = 0 ; i < size ; i++ ) { leaf reader context context = leave . get ( i ) ; sort numeric doc value v = context . reader ( ) . get sorted numeric doc value ( field ) ; if ( v == null ) { v = doc value . empty sort numeric ( ) ; } else { any real = true ; } value [ i ] = v ; start [ i ] = context . doc base ; total cost += v . cost ( ) ; } start [ size ] = r . max doc ( ) ; if ( any real == false ) { return null ; } final long final total cost = total cost ; return new sort numeric doc value ( ) { private int next leaf ; private sort numeric doc value current value ; private leaf reader context current leaf ; private int doc i d = -1 ; @ override public int next doc ( ) throw i o exception { while ( true ) { if ( current value == null ) { if ( next leaf == leave . size ( ) ) { doc i d = no_more_docs ; return doc i d ; } current leaf = leaf . get ( next leaf ) ; current value = value [ next leaf ] ; next leaf++ ; } int new doc i d = current value . next doc ( ) ; if ( new doc i d == no_more_docs ) { current value = null ; continue ; } else { doc i d = current leaf . doc base + new doc i d ; return doc i d ; } } } @ override public int doc i d ( ) { return doc i d ; } @ override public int advance ( int target doc i d ) throw i o exception { if ( target doc i d < = doc i d ) { throw new illegal argument exception ( `` can only advance beyond current document : on doc i d= `` + doc i d + `` but target doc i d= `` + target doc i d ) ; } int reader index = reader util . sub index ( target doc i d , leave ) ; if ( reader index > = next leaf ) { if ( reader index == leave . size ( ) ) { current value = null ; doc i d = no_more_docs ; return doc i d ; } current leaf = leaf . get ( reader index ) ; current value = value [ reader index ] ; next leaf = reader index+1 ; } int new doc i d = current value . advance ( target doc i d - current leaf . doc base ) ; if ( new doc i d == no_more_docs ) { current value = null ; return next doc ( ) ; } else { doc i d = current leaf . doc base + new doc i d ; return doc i d ; } } @ override public boolean advance exact ( int target doc i d ) throw i o exception { if ( target doc i d < doc i d ) { throw new illegal argument exception ( `` can only advance beyond current document : on doc i d= `` + doc i d + `` but target doc i d= `` + target doc i d ) ; } int reader index = reader util . sub index ( target doc i d , leave ) ; if ( reader index > = next leaf ) { if ( reader index == leave . size ( ) ) { throw new illegal argument exception ( `` out of range : `` + target doc i d ) ; } current leaf = leaf . get ( reader index ) ; current value = value [ reader index ] ; next leaf = reader index+1 ; } doc i d = target doc i d ; if ( current value == null ) { return false ; } return current value . advance exact ( target doc i d - current leaf . doc base ) ; } @ override public long cost ( ) { return final total cost ; } @ override public int doc value count ( ) { return current value . doc value count ( ) ; } @ override public long next value ( ) throw i o exception { return current value . next value ( ) ; } } ; }
public final query get query ( ) { return parent query ; }
protect void after read ( final int n ) throw i o exception { if ( n == eof ) { close ( ) ; } }
public void add listener ( final l listener , final boolean allow duplicate ) { validate . not null ( listener , `` listener object can not be null . `` ) ; if ( allow duplicate ) { listener . add ( listener ) ; } else if ( ! listener . contains ( listener ) ) { listener . add ( listener ) ; } }
protect explanation explain ( basic stats stats , int doc , explanation freq , float doc len ) { explanation result = new explanation ( ) ; result . set value ( score ( stats , freq . get value ( ) , doc len ) ) ; result . set description ( `` score ( `` + get class ( ) . get simple name ( ) + `` , doc= `` + doc + `` , freq= `` + freq . get value ( ) + `` ) , compute from : `` ) ; result . add detail ( freq ) ; explain ( result , stats , doc , freq . get value ( ) , doc len ) ; return result ; }
public void set doc freq ( int doc freq ) { this . doc freq = doc freq ; }
public float get value for normalization ( ) { float raw value = raw normalization value ( ) ; return raw value * raw value ; }
protect explanation explain ( basic stats stats , int doc , explanation freq , float doc len ) { explanation result = new explanation ( ) ; result . set value ( score ( stats , freq . get value ( ) , doc len ) ) ; result . set description ( `` score ( `` + get class ( ) . get simple name ( ) + `` , doc= `` + doc + `` , freq= `` + freq . get value ( ) + `` ) , compute from : `` ) ; result . add detail ( freq ) ; explain ( result , stats , doc , freq . get value ( ) , doc len ) ; return result ; }
protect explanation explain ( basic stats stats , int doc , explanation freq , float doc len ) { explanation result = new explanation ( ) ; result . set value ( score ( stats , freq . get value ( ) , doc len ) ) ; result . set description ( `` score ( `` + get class ( ) . get simple name ( ) + `` , doc= `` + doc + `` , freq= `` + freq . get value ( ) + `` ) , compute from : `` ) ; result . add detail ( freq ) ; explain ( result , stats , doc , freq . get value ( ) , doc len ) ; return result ; }
public query string query builder field ( string field , float boost ) { check negative boost ( boost ) ; this . field and weight . put ( field , boost ) ; return this ; }
protect byte encode norm value ( float boost , int field length ) { return small float . float to byte315 ( boost / ( float ) math . sqrt ( field length ) ) ; }
public void set include query string ( boolean include query string ) { this . include query string = include query string ; }
public static directory unwrap ( directory dir ) { while ( dir instanceof filter directory ) { dir = ( ( filter directory ) dir ) . in ; } return dir ; }
public long get length ( int i ) throw i o exception { return split [ i ] . get length ( ) ; }
public boolean obtain ( long lock wait timeout ) throw i o exception { boolean lock = obtain ( ) ; int max sleep count = ( int ) ( lock wait timeout / lock_poll_interval ) ; int sleep count = 0 ; while ( ! lock ) { if ( ++sleep count == max sleep count ) { throw new i o exception ( `` lock obtain time out : `` + this . to string ( ) ) ; } try { thread . sleep ( lock_poll_interval ) ; } catch ( interrupted exception e ) { throw new i o exception ( e . to string ( ) ) ; } lock = obtain ( ) ; } return lock ; }
public void set lock prefix ( string lock prefix ) { this . lock prefix = lock prefix ; }
public input stream create raw input stream ( ) throw i o exception { check close ( ) ; if ( be write ) { throw new illegal state exception ( `` can not read while there be an open stream writer `` ) ; } ensure random access exists ( true ) ; return new random access input stream ( random access ) ; }
protect byte [ ] balloc ( int size ) { return new byte [ size ] ; }
public final iterator < attribute impl > get attribute impls iterator ( ) { final state init state = get current state ( ) ; if ( init state ! = null ) { return new iterator < attribute impl > ( ) { private state state = init state ; @ override public void remove ( ) { throw new unsupported operation exception ( ) ; } @ override public attribute impl next ( ) { if ( state == null ) throw new no such element exception ( ) ; final attribute impl att = state . attribute ; state = state . next ; return att ; } @ override public boolean have next ( ) { return state ! = null ; } } ; } else { return collection . < attribute impl > empty set ( ) . iterator ( ) ; } }
public static string object to string ( final object o ) { if ( o == null ) { return `` null `` ; } return o . get class ( ) . get name ( ) + ' @ ' + integer . to hex string ( o . hash code ( ) ) ; }
public int get number of transition ( ) { if ( be singleton ( ) ) return singleton . code point count ( 0 , singleton . length ( ) ) ; int c = 0 ; for ( state s : get numbered state ( ) ) c += s . num transition ( ) ; return c ; }
public transition [ ] [ ] get sort transition ( ) { int num state = get num state ( ) ; transition [ ] [ ] transition = new transition [ num state ] [ ] ; for ( int s=0 ; s < num state ; s++ ) { int num transition = get num transition ( s ) ; transition [ s ] = new transition [ num transition ] ; for ( int t=0 ; t < num transition ; t++ ) { transition transition = new transition ( ) ; get transition ( s , t , transition ) ; transition [ s ] [ t ] = transition ; } } return transition ; }
public string to string ( ) { string builder b = new string builder ( ) ; b . append ( `` state `` ) . append ( number ) ; if ( accept ) b . append ( `` [ accept ] `` ) ; else b . append ( `` [ reject ] `` ) ; b . append ( `` : \n `` ) ; for ( transition t : get transition ( ) ) b . append ( `` `` ) . append ( t . to string ( ) ) . append ( `` \n `` ) ; return b . to string ( ) ; }
public boolean run ( string s ) { int p = initial ; int l = s . length ( ) ; for ( int i = 0 , cp = 0 ; i < l ; i += character . char count ( cp ) ) { p = step ( p , cp = s . code point at ( i ) ) ; if ( p == -1 ) return false ; } return accept [ p ] ; }
public boolean be accept state ( ) { return m accept ; }
public void read byte ( final long offset , final byte byte [ ] , int byte offset , int byte length ) { int byte leave = byte length ; int buffer index = ( int ) ( offset > > byte_block_shift ) ; int po = ( int ) ( offset & byte_block_mask ) ; while ( byte leave > 0 ) { byte [ ] buffer = buffer [ buffer index++ ] ; int chunk = math . min ( bytes leave , byte_block_size - po ) ; system . arraycopy ( buffer , po , byte , byte offset , chunk ) ; bytes offset += chunk ; bytes leave -= chunk ; po = 0 ; } }
public static int hash byte ( byte [ ] byte , int offset , int length ) { int hash = 1 ; for ( int i = offset ; i < offset + length ; i++ ) hash = ( 31 * hash ) + ( int ) bytes [ i ] ; return hash ; }
public void copy char ( char [ ] other char , int other offset , int other length ) { grow ( other length ) ; system . arraycopy ( other char , other offset , ref . char , 0 , other length ) ; ref . length = other length ; }
public static class < ? extend f s directory > load f s directory class ( string clazz name ) throw class not find exception { return class . for name ( adjust directory class name ( clazz name ) ) . a subclass ( f s directory . class ) ; }
public static insanity [ ] check sanity ( cache entry . . . cache entry ) { field cache sanity checker sanity checker = new field cache sanity checker ( ) ; sanity checker . set ram usage estimator ( true ) ; return sanity checker . check ( cache entry ) ; }
public boolean equal ( object o ) { if ( this == o ) { return true ; } if ( ! ( o instanceof fix bit set ) ) { return false ; } fix bit set other = ( fixed bit set ) o ; if ( num bit ! = other . length ( ) ) { return false ; } return array . equal ( bit , other . bit ) ; }
public void copy byte ( long src , byte [ ] d , int offset , int len ) { int block index = ( int ) ( src > > block bit ) ; int upto = ( int ) ( src & block mask ) ; byte [ ] block = block . get ( block index ) ; while ( len > 0 ) { int chunk = block size - upto ; if ( len < = chunk ) { system . arraycopy ( block , upto , d , offset , len ) ; break ; } else { system . arraycopy ( block , upto , d , offset , chunk ) ; block index++ ; block = block . get ( block index ) ; upto = 0 ; len -= chunk ; offset += chunk ; } } }
public static file extract from resource ( string name ) throw i o exception { file temp = file utils . temp file ( `` extract `` ) ; try ( input stream fis = file utils . class . get resource a stream ( name ) ; output stream fo = new file output stream ( temp ) ) { byte [ ] buf = new byte [ 8192 ] ; int read ; while ( ( read = fis . read ( buf ) ) ! = -1 ) { fo . write ( buf , 0 , read ) ; } fo . close ( ) ; return temp ; } }
public static int prefix cod to int ( final byte ref val ) { int sortable bit = 0 ; for ( int i=val . offset+1 , limit=val . offset+val . length ; i < limit ; i++ ) { sortable bit < < = 7 ; final byte b = val . bytes [ i ] ; if ( b < 0 ) { throw new number format exception ( `` invalid prefix cod numerical value representation ( byte `` + integer . to hex string ( b & 0xff ) + `` at position `` + ( i-val . offset ) + `` be invalid ) `` ) ; } sortable bit |= b ; } return ( sortable bit < < get prefix cod int shift ( val ) ) ^ 0x80000000 ; }
public static long xor count ( open bit set a , open bit set b ) { long tot = bit util . pop_xor ( a . bit , b . bit , 0 , math . min ( a . wlen , b . wlen ) ) ; if ( a . wlen < b . wlen ) { tot += bit util . pop_array ( b . bit , a . wlen , b . wlen-a . wlen ) ; } else if ( a . wlen > b . wlen ) { tot += bit util . pop_array ( a . bit , b . wlen , a . wlen-b . wlen ) ; } return tot ; }
public iterator iterator ( ) { return new iterator ( ) { iterator i = underlie . iterator ( ) ; public boolean have next ( ) { return i . have next ( ) ; } public object next ( ) { return i . next ( ) ; } public void remove ( ) { throw new unsupported operation exception ( ) ; } } ; }
public long next value ( ) { if ( ! to after current high bit ( ) ) { return no_more_values ; } long high value = next high value ( ) ; return combine high low value ( high value , current low value ( ) ) ; }
public reader freeze ( boolean trim ) { if ( frozen ) { throw new illegal state exception ( `` already freeze `` ) ; } if ( do skip byte ) { throw new illegal state exception ( `` can not freeze when copy ( bytes ref , bytes ref ) be use `` ) ; } if ( trim & & upto < block size ) { final byte [ ] new block = new byte [ upto ] ; system . arraycopy ( current block , 0 , new block , 0 , upto ) ; current block = new block ; } if ( current block == null ) { current block = empty_bytes ; } block . add ( current block ) ; block end . add ( upto ) ; frozen = true ; current block = null ; return new page byte . reader ( this ) ; }
public query create phrase query ( string field , string query text ) { return create phrase query ( field , query text , 0 ) ; }
public boolean enable position increment ( ) { return enable position increment ; }
public static long size of ( long [ ] arr ) { return align object size ( ( long ) num_bytes_array_header + ( long ) num_bytes_long * arr . length ) ; }
public iterator < v > value iterator ( ) { if ( reap on read ) reap ( ) ; return back store . value ( ) . iterator ( ) ; }
public boolean be cache field ( ) { return field cache ! = null ; }
public void clear ( ) { super . clear ( ) ; payload = null ; position increment = 1 ; flag = 0 ; start offset = end offset = 0 ; type = default_type ; }
protect boolean be within hole ( final geo point point ) { if ( hole ! = null ) { for ( final geo polygon hole : hole ) { if ( ! hole . be within ( point ) ) { return true ; } } } return false ; }
public static string check index header suffix ( data input in , string expect suffix ) throw i o exception { int suffix length = in . read byte ( ) & 0x f f ; byte suffix byte [ ] = new byte [ suffix length ] ; in . read byte ( suffix byte , 0 , suffix byte . length ) ; string suffix = new string ( suffix byte , 0 , suffix byte . length , standard charsets . utf_8 ) ; if ( ! suffix . equal ( expect suffix ) ) { throw new corrupt index exception ( `` file mismatch , expect suffix= `` + expect suffix + `` , got= `` + suffix , in ) ; } return suffix ; }
public void add ( int freq , long norm ) { if ( norm > = byte . min_value & & norm < = byte . max_value ) { int index = byte . to unsigned int ( ( byte ) norm ) ; max freqs [ index ] = math . max ( max freqs [ index ] , freq ) ; } else { add ( new impact ( freq , norm ) , other freq norm pair ) ; } assert assert consistent ( ) ; }
public static byte ref pack ( int . . . point ) { if ( point == null ) { throw new illegal argument exception ( `` point must not be null `` ) ; } if ( point . length == 0 ) { throw new illegal argument exception ( `` point must not be 0 dimension `` ) ; } byte [ ] pack = new byte [ point . length * integer . bytes ] ; for ( int dim = 0 ; dim < point . length ; dim++ ) { encode dimension ( point [ dim ] , pack , dim * integer . byte ) ; } return new byte ref ( pack ) ; }
public static query new exact query ( string field , int value ) { return new range query ( field , value , value ) ; }
public static query new slow box query ( string field , float min x , float max x , float min y , float max y ) { x y rectangle rectangle = new x y rectangle ( min x , max x , min y , max y ) ; return new x y doc value point in geometry query ( field , rectangle ) ; }
public static query new polygon query ( string field , query relation query relation , polygon . . . polygon ) { return new geometry query ( field , query relation , polygon ) ; }
public static double pv ( double r , double n , double y , double f , boolean t ) { double retval = 0 ; if ( r == 0 ) { retval = -1 * ( ( n * y ) +f ) ; } else { double r1 = r + 1 ; retval = ( ( ( 1 - math . pow ( r1 , n ) ) / r ) * ( t ? r1 : 1 ) * y - f ) / math . pow ( r1 , n ) ; } return retval ; }
public static boolean equal ( double x , double y ) { return ( double . be na n ( x ) & & double . be na n ( y ) ) || x == y ; }
public affine transformation reflect ( double x0 , double y0 , double x1 , double y1 ) { compose ( reflection instance ( x0 , y0 , x1 , y1 ) ) ; return this ; }
public static double get mb per sec ( thread thread , merge policy . one merge merge ) { if ( thread instanceof concurrent merge scheduler . merge thread ) { return ( ( concurrent merge scheduler . merge thread ) thread ) . rate limiter . get m b per sec ( ) ; } assert false : `` this be not merge thread `` ; return double . positive_infinity ; }
public string get resource description ( ) { return this . resource description ; }
public static < t extend doc i d merger . sub > doc i d merger < t > of ( list < t > sub , boolean index be sort ) throw i o exception { return of ( sub , subs . size ( ) , index be sort ) ; }
public static sort set doc value singleton ( sort doc value dv ) { return new singleton sort set doc value ( dv ) ; }
public static sort numeric doc value singleton ( numeric doc value dv ) { return new singleton sort numeric doc value ( dv ) ; }
public void set dimension ( int dimension count , int index dimension count , int dimension num byte ) { if ( dimension count < 0 ) { throw new illegal argument exception ( `` dimension count must be > = 0 ; get `` + dimension count ) ; } if ( dimension count > point value . max_dimensions ) { throw new illegal argument exception ( `` dimension count must be < = `` + point value . max_dimensions + `` ; get `` + dimension count ) ; } if ( index dimension count < 0 ) { throw new illegal argument exception ( `` index dimension count must be > = 0 ; get `` + index dimension count ) ; } if ( index dimension count > dimension count ) { throw new illegal argument exception ( `` index dimension count must be < = dimension count : `` + dimension count + `` ; get `` + index dimension count ) ; } if ( index dimension count > point value . max_index_dimensions ) { throw new illegal argument exception ( `` index dimension count must be < = `` + point value . max_index_dimensions + `` ; get `` + index dimension count ) ; } if ( dimension num bytes < 0 ) { throw new illegal argument exception ( `` dimension num byte must be > = 0 ; get `` + dimension num byte ) ; } if ( dimension num bytes > point value . max_num_bytes ) { throw new illegal argument exception ( `` dimension num byte must be < = `` + point value . max_num_bytes + `` ; get `` + dimension num byte ) ; } if ( dimension count == 0 ) { if ( index dimension count ! = 0 ) { throw new illegal argument exception ( `` when dimension count be 0 , index dimension count must be 0 ; get `` + index dimension count ) ; } if ( dimension num bytes ! = 0 ) { throw new illegal argument exception ( `` when dimension count be 0 , dimension num byte must be 0 ; get `` + dimension num byte ) ; } } else if ( index dimension count == 0 ) { throw new illegal argument exception ( `` when dimension count be > 0 , index dimension count must be > 0 ; get `` + index dimension count ) ; } else if ( dimension num bytes == 0 ) { if ( dimension count ! = 0 ) { throw new illegal argument exception ( `` when dimension num byte be 0 , dimension count must be 0 ; get `` + dimension count ) ; } } this . dimension count = dimension count ; this . index dimension count = index dimension count ; this . dimension num bytes = dimension num byte ; }
public index option index option ( ) { return index option ; }
public string get resource description ( ) { return this . resource description ; }
public synchronize boolean have deletion ( ) { ensure open ( ) ; if ( buffer update stream . any ( ) ) { return true ; } if ( doc writer . any deletion ( ) ) { return true ; } if ( reader pool . any pending deletes ( ) ) { return true ; } for ( final segment commit info info : segment info ) { if ( info . have deletion ( ) ) { return true ; } } return false ; }
public final boolean have uncommitted change ( ) { return change count ! = last commit change count || doc writer . any change ( ) || buffer updates stream . any ( ) ; }
protect boolean be all test point in target ( geometry test geom ) { for ( int i = 0 ; i < test geom . get num geometry ( ) ; i++ ) { point pt = ( point ) test geom . get geometry n ( i ) ; coordinate p = pt . get coordinate ( ) ; int loc = target point locator . locate ( p ) ; if ( loc == location . exterior ) return false ; } return true ; }
public int get index create version major ( ) { return index create version major ; }
public synchronize string seg string ( segment commit info info ) { return info . to string ( info . info . dir , num delete doc ( info ) - info . get del count ( ) ) ; }
public multi doc and position enum reset ( final enum with slice [ ] sub , final int num sub ) { this . num subs = num sub ; this . sub = new enum with slice [ sub . length ] ; for ( int i=0 ; i < sub . length ; i++ ) { this . sub [ i ] = new enum with slice ( ) ; this . sub [ i ] . doc and position enum = sub [ i ] . doc and position enum ; this . sub [ i ] . slice = sub [ i ] . slice ; } upto = -1 ; doc = -1 ; current = null ; return this ; }
public int num delete doc ( segment commit info info ) { ensure open ( false ) ; int del count = info . get del count ( ) ; final reader and update rld = reader pool . get ( info , false ) ; if ( rld ! = null ) { del count += rld . get pending delete count ( ) ; } return del count ; }
public static long size ( index reader reader , string field ) throw i o exception { long size = 0 ; for ( leaf reader context ctx : reader . leaf ( ) ) { point value value = ctx . reader ( ) . get point value ( field ) ; if ( value ! = null ) { size += value . size ( ) ; } } return size ; }
public static byte [ ] get max pack value ( index reader reader , string field ) throw i o exception { byte [ ] max value = null ; for ( leaf reader context ctx : reader . leaf ( ) ) { point value value = ctx . reader ( ) . get point value ( field ) ; if ( value == null ) { continue ; } byte [ ] leaf max value = value . get max pack value ( ) ; if ( leaf max value == null ) { continue ; } if ( max value == null ) { max value = leaf max value . clone ( ) ; } else { final int num dimension = value . get num index dimension ( ) ; final int num byte per dimension = value . get byte per dimension ( ) ; for ( int i = 0 ; i < num dimension ; ++i ) { int offset = i * num byte per dimension ; if ( future array . compare unsigned ( leaf max value , offset , offset + num byte per dimension , max value , offset , offset + num byte per dimension ) > 0 ) { system . arraycopy ( leaf max value , offset , max value , offset , num byte per dimension ) ; } } } } return max value ; }
public synchronize bit get hard live doc ( ) { return pending deletes . get hard live doc ( ) ; }
public index sort config get index sort config ( ) { return index sort config ; }
public static doc id set iterator intersect iterators ( list < ? extend doc id set iterator > iterators ) { if ( iterators . size ( ) < 2 ) { throw new illegal argument exception ( `` can not make a conjunction d i s i of less than 2 iterators `` ) ; } final list < doc id set iterator > all iterators = new array list < > ( ) ; for ( doc id set iterator iterator : iterators ) { add iterator ( iterator , all iterators ) ; } return new conjunction d i s i ( all iterators ) ; }
protect explanation explain ( basic stats stats , int doc , explanation freq , float doc len ) { explanation result = new explanation ( ) ; result . set value ( score ( stats , freq . get value ( ) , doc len ) ) ; result . set description ( `` score ( `` + get class ( ) . get simple name ( ) + `` , doc= `` + doc + `` , freq= `` + freq . get value ( ) + `` ) , compute from : `` ) ; result . add detail ( freq ) ; explain ( result , stats , doc , freq . get value ( ) , doc len ) ; return result ; }
public static double value source from long field ( string field ) { return from field ( field , ( v ) - > ( double ) v ) ; }
public static function score query boost by query ( query in , query boost match , float boost value ) { return new function score query ( in , new multiplicative boost value source ( new query boost value source ( double value source . from query ( boost match ) , boost value ) ) ) ; }
public boolean be field match ( ) { return field match ; }
public void set max non competitive boost ( float boost ) { this . max boost att . set max non competitive boost ( boost ) ; }
protect void on query eviction ( query query , long ram byte use ) { assert lock . be hold by current thread ( ) ; this . ram byte use -= ram byte use ; }
public document field field ( string field name ) { document field result = document field . get ( field name ) ; if ( result ! = null ) { return result ; } else { return meta field . get ( field name ) ; } }
public term [ ] get term ( ) { return ( term [ ] ) term . to array ( new term [ 0 ] ) ; }
public final long sum doc freq ( ) { return sum doc freq ; }
public static top field doc merge ( sort sort , int top n , top field doc [ ] shard hit ) { return merge ( sort , 0 , top n , shard hit , true ) ; }
public static automaton make non empty binary ( ) { automaton a = new automaton ( ) ; int s1 = a . create state ( ) ; int s2 = a . create state ( ) ; a . set accept ( s2 , true ) ; a . add transition ( s1 , s2 , 0 , 255 ) ; a . add transition ( s2 , s2 , 0 , 255 ) ; a . finish state ( ) ; return a ; }
public static automaton make binary ( byte ref term ) { automaton a = new automaton ( ) ; int last state = a . create state ( ) ; for ( int i=0 ; i < term . length ; i++ ) { int state = a . create state ( ) ; int label = term . bytes [ term . offset+i ] & 0xff ; a . add transition ( last state , state , label ) ; last state = state ; } a . set accept ( last state , true ) ; a . finish state ( ) ; assert a . be deterministic ( ) ; assert operation . have dead state ( a ) == false ; return a ; }
public boolean have side path ( int state ) { int num t = det . init transition ( state , transition ) ; if ( num t < = 1 ) { return false ; } det . get next transition ( transition ) ; int d = transition . dest ; for ( int i = 1 ; i < num t ; i++ ) { det . get next transition ( transition ) ; if ( d ! = transition . dest ) { return true ; } } return false ; }
public boolean have side path ( int state ) { int num t = det . init transition ( state , transition ) ; if ( num t < = 1 ) { return false ; } det . get next transition ( transition ) ; int d = transition . dest ; for ( int i = 1 ; i < num t ; i++ ) { det . get next transition ( transition ) ; if ( d ! = transition . dest ) { return true ; } } return false ; }
public static byte ref get common prefix byte ref ( automaton a ) { bytes ref builder builder = new byte ref builder ( ) ; hash set < integer > visit = new hash set < > ( ) ; int s = 0 ; boolean do ; transition t = new transition ( ) ; do { do = true ; visit . add ( s ) ; if ( a . be accept ( s ) == false & & a . get num transition ( s ) == 1 ) { a . get transition ( s , 0 , t ) ; if ( t . min == t . max & & ! visit . contains ( t . d ) ) { builder . append ( ( byte ) t . min ) ; s = t . dest ; do = false ; } } } while ( ! do ) ; return builder . get ( ) ; }
public int compute cardinality ( ) { if ( cardinality . allow zero ( operand0 . get cardinality ( ) ) || cardinality . allow zero ( operand1 . get cardinality ( ) ) ) { return static property . allows_zero_or_one ; } else { return static property . exactly_one ; } }
public void xor ( doc id set iterator iter ) throw i o exception { check unpositioned ( iter ) ; if ( bit set iterator . get fixed bit set or null ( iter ) ! = null ) { final fix bit set bit = bit set iterator . get fixed bit set or null ( iter ) ; xor ( bit ) ; } else { int doc ; while ( ( doc = iter . next doc ( ) ) < num bit ) { flip ( doc ) ; } } }
public void xor ( doc id set iterator iter ) throw i o exception { check unpositioned ( iter ) ; if ( bit set iterator . get fixed bit set or null ( iter ) ! = null ) { final fix bit set bit = bit set iterator . get fixed bit set or null ( iter ) ; xor ( bit ) ; } else { int doc ; while ( ( doc = iter . next doc ( ) ) < num bit ) { flip ( doc ) ; } } }
public void add text ( char sequence text ) { char [ ] char = text . to string ( ) . to char array ( ) ; add text ( char , 0 , char . length ) ; }
public static f s directory new f s directory ( string clazz name , path path ) { return new f s directory ( clazz name , path , f s lock factory . get default ( ) ) ; }
public boolean be dse graph enable ( ) { return dse graph enable ; }
public static long shallow size of ( object [ ] arr ) { return align object size ( ( long ) num_bytes_array_header + ( long ) num_bytes_object_ref * arr . length ) ; }
public long ram byte use ( ) { return ram usage estimator . align object size ( 3 * ram usage estimator . num_bytes_object_ref ) + doc i d . ram byte use ( ) + offset . ram byte use ( ) ; }
public static double haversin kilometer ( double lat1 , double lon1 , double lat2 , double lon2 ) { double h = haversin sort key ( lat1 , lon1 , lat2 , lon2 ) ; return to_kilometers * 2 * asin ( math . min ( 1 , math . sqrt ( h * 0 . 5 ) ) ) ; }
public static double to degree ( final double radian ) { return radian * to_degrees ; }
public group search set sort within group ( sort sort within group ) { this . sort within group = sort within group ; return this ; }
public group search set all group ( boolean all group ) { this . all group = all group ; return this ; }
public g new group ( string name , limit limit ) { return new group ( name , resource bundle . get counter group name ( name , name ) , limit ) ; }
public void set auto generate multi term synonym phrase query ( boolean enable ) { this . auto generate multi term synonym phrase query = enable ; }
public hb max analyze offset ( integer max analyze offset ) { if ( max analyze offset ! = null & & max analyze offset < = 0 ) { throw new illegal argument exception ( `` [ `` + max_analyzed_offset_field . to string ( ) + `` ] must be a positive integer `` ) ; } this . max analyzed offset = max analyzed offset ; return ( hb ) this ; }
public long end offset ( ) { return end offset ; }
public hb phrase limit ( integer phrase limit ) { this . phrase limit = phrase limit ; return ( hb ) this ; }
public synchronize segment reader get read only clone ( i o context context ) throw i o exception { if ( reader == null ) { get reader ( context ) . dec ref ( ) ; assert reader ! = null ; } live doc share = true ; if ( live doc ! = null ) { return new segment reader ( reader . get segment info ( ) , reader , live doc , info . info . get doc count ( ) - info . get del count ( ) - pending delete count ) ; } else { assert reader . get live doc ( ) == live doc ; reader . inc ref ( ) ; return reader ; } }
public void set discount overlap ( boolean v ) { discount overlap = v ; }
public float length norm ( int num term ) { return ( float ) ( 1 . 0 / math . sqrt ( num term ) ) ; }
public final term term ( string field ) throw i o exception { final field field = field ( ) ; if ( field == null ) { return null ; } return field . term ( field ) ; }
public void set fuzzy min sim ( float fuzzy min sim ) { this . fuzzy min sim = fuzzy min sim ; }
protect query new wildcard query ( term t ) { wildcard query query = new wildcard query ( t , max determinized state ) ; query . set rewrite method ( multi term rewrite method ) ; return query ; }
public object parse ( string query , string default field ) throw query node exception { query node query tree = get syntax parser ( ) . parse ( query , default field ) ; query node processor processor = get query node processor ( ) ; if ( processor ! = null ) { query tree = processor . process ( query tree ) ; } return get query builder ( ) . build ( query tree ) ; }
public query text get path element ( int index ) { return value . get ( index ) ; }
public list < node > child node copy ( ) { list < node > child = new array list < node > ( child node . size ( ) ) ; for ( node node : child node ) { child . add ( node . clone ( ) ) ; } return child ; }
public fold parser get fold parser ( string syntax style ) { return fold parser map . get ( syntax style ) ; }
public search request builder set query ( query builder query builder ) { source builder ( ) . query ( query builder ) ; return this ; }
public fold parser get fold parser ( string syntax style ) { return fold parser map . get ( syntax style ) ; }
public char sequence get field ( ) { char sequence field = null ; t low = get low bound ( ) ; t upper = get upper bound ( ) ; if ( low ! = null ) { field = low . get field ( ) ; } else if ( upper ! = null ) { field = upper . get field ( ) ; } return field ; }
public simple query string builder default operator ( operator default operator ) { this . default operator = ( default operator ! = null ) ? default operator : default_operator ; return this ; }
public final span rewrite method get rewrite method ( ) { final multi term query . rewrite method m = query . get rewrite method ( ) ; if ( ! ( m instanceof span rewrite method ) ) throw new unsupported operation exception ( `` you can only use span multi term query wrapper with a suitable span rewrite method . `` ) ; return ( span rewrite method ) m ; }
protect void infix to string ( string builder r ) { / * bracket be possibly redundant in the result . * / iterator < srnd query > sqi = get sub query iterator ( ) ; r . append ( get bracket open ( ) ) ; if ( sqi . have next ( ) ) { r . append ( sqi . next ( ) . to string ( ) ) ; while ( sqi . have next ( ) ) { r . append ( `` `` ) ; r . append ( get operator name ( ) ) ; / * infix operator * / r . append ( `` `` ) ; r . append ( sqi . next ( ) . to string ( ) ) ; } } r . append ( get bracket close ( ) ) ; }
public static query new intersects query ( string field , final double min lat , final double min lon , final double max lat , final double max lon ) { return new range query ( field , min lat , min lon , max lat , max lon , range field query . query type . intersects ) ; }
public void set optimize ( boolean optimize ) { this . optimize = optimize ; }
public n r shape parse shape ( string str ) throw parse exception { if ( str == null || str . be empty ( ) ) throw new illegal argument exception ( `` str be null or blank `` ) ; if ( str . char at ( 0 ) == ' [ ' ) { if ( str . char at ( str . length ( ) -1 ) ! = ' ] ' ) throw new parse exception ( `` if start with [ must end with ] ; get `` +str , str . length ( ) -1 ) ; int middle = str . index of ( `` to `` ) ; if ( middle < 0 ) throw new parse exception ( `` if start with [ must contain ' to ' ; get `` +str , -1 ) ; string leave str = str . substring ( 1 , middle ) ; string right str = str . substring ( middle + `` to `` . length ( ) , str . length ( ) -1 ) ; return to range shape ( parse unit shape ( left str ) , parse unit shape ( right str ) ) ; } else if ( str . char at ( 0 ) == ' { ' ) { throw new parse exception ( `` exclusive range not support ; get `` +str , 0 ) ; } else { return parse unit shape ( str ) ; } } / * * parse a string to a unit n r shape . `` * `` should be the full-range ( level 0 shape ) . * / protect abstract unit n r shape parse unit shape ( string str ) throw parse exception ; // // unit n r shape // / * * * a unit value shape implement a a stack of number , one for each level in the prefix tree . it directly * corresponds to a { @ link cell } . spatially speak , it 's analogous to a point but 1d and have some precision width . * @ lucene . experimental * / public static interface unit n r shape extend n r shape , comparable < unit n r shape > { //note : formerly know a levelled value ; thus some variable still use 'lv ' / * * get the prefix tree level , the high the more precise . 0 mean the world ( universe ) . * / int get level ( ) ; / * * get the value at the specified level of this unit . level must be & gt ; = 0 and & lt ; = get level ( ) . * / int get val at level ( int level ) ; / * * get an ancestor at the specified level . it share state , so you may want to clone ( ) it . * / unit n r shape get shape at level ( int level ) ; @ override unit n r shape round to level ( int target level ) ; / * * deep clone * / unit n r shape clone ( ) ; } / * * compare a to b , return less than 0 , 0 , or great than 0 , if a be less than , equal to , or * great than b , respectively , up to their common prefix ( i . e . only min ( a . level , b . level ) be compare ) . * @ lucene . internal * / protect static int compare prefix ( unit n r shape a , unit n r shape b ) { int min level = math . min ( a . get level ( ) , b . get level ( ) ) ; for ( int level = 1 ; level < = min level ; level++ ) { int diff = a . get val at level ( level ) - b . get val at level ( level ) ; if ( diff ! = 0 ) return diff ; } return 0 ; } // // span unit n r shape // / * * a range shape ; base on a pair of { @ link org . apache . lucene . spatial . prefix . tree . number range prefix tree . unit n r shape } . * spatially speak , it 's analogous to a rectangle but 1d . it might have be name with range in the name but it * may be confuse since even the { @ link org . apache . lucene . spatial . prefix . tree . number range prefix tree . unit n r shape } * be in some sense a range . * @ lucene . experimental * / public class span unit n r shape implement n r shape { private final unit n r shape min l v , max l v ; private final int last level in common ; //computed ; not part of identity / * * do n't call directly ; see * { @ link # to range shape ( org . apache . lucene . spatial . prefix . tree . number range prefix tree . unit n r shape , org . apache . lucene . spatial . prefix . tree . number range prefix tree . unit n r shape ) } . * / private span unit n r shape ( unit n r shape min l v , unit n r shape max l v ) { this . min l v = min l v ; this . max l v = max l v ; //calc last level in common int level = 1 ; for ( ; level < = min l v . get level ( ) & & level < = max l v . get level ( ) ; level++ ) { if ( min l v . get val at level ( level ) ! = max l v . get val at level ( level ) ) break ; } last level in common = level - 1 ; } @ override public spatial context get context ( ) { return dummy_ctx ; } public unit n r shape get min unit ( ) { return min l v ; } public unit n r shape get max unit ( ) { return max l v ; } / * * how many level be in common between min unit and max unit , not include level 0 . * / private int get level in common ( ) { return last level in common ; } @ override public n r shape round to level ( int target level ) { return to range shape ( min l v . round to level ( target level ) , max l v . round to level ( target level ) ) ; } @ override public spatial relation relate ( shape shape ) { // if ( shape instanceof unit n r shape ) // return relate ( ( unit n r shape ) shape ) ; if ( shape instanceof span unit n r shape ) return relate ( ( span unit n r shape ) shape ) ; return shape . relate ( this ) . transpose ( ) ; //probably a unit n r shape } public spatial relation relate ( span unit n r shape ext ) { // this logic somewhat mirror rectangle impl . relate_range ( ) int ext min_int max = compare prefix ( ext . get min unit ( ) , get max unit ( ) ) ; if ( ext min_int max > 0 ) return spatial relation . disjoint ; int ext max_int min = compare prefix ( ext . get max unit ( ) , get min unit ( ) ) ; if ( ext max_int min < 0 ) return spatial relation . disjoint ; int ext min_int min = compare prefix ( ext . get min unit ( ) , get min unit ( ) ) ; int ext max_int max = compare prefix ( ext . get max unit ( ) , get max unit ( ) ) ; if ( ( ext min_int min > 0 || ext min_int min == 0 & & ext . get min unit ( ) . get level ( ) > = get min unit ( ) . get level ( ) ) & & ( ext max_int max < 0 || ext max_int max == 0 & & ext . get max unit ( ) . get level ( ) > = get max unit ( ) . get level ( ) ) ) return spatial relation . contains ; if ( ( ext min_int min < 0 || ext min_int min == 0 & & ext . get min unit ( ) . get level ( ) < = get min unit ( ) . get level ( ) ) & & ( ext max_int max > 0 || ext max_int max == 0 & & ext . get max unit ( ) . get level ( ) < = get max unit ( ) . get level ( ) ) ) return spatial relation . within ; return spatial relation . intersects ; } @ override public rectangle get bound box ( ) { throw new unsupported operation exception ( ) ; } @ override public boolean have area ( ) { return true ; } @ override public double get area ( spatial context spatial context ) { throw new unsupported operation exception ( ) ; } @ override public point get center ( ) { throw new unsupported operation exception ( ) ; } @ override public shape get buffer ( double v , spatial context spatial context ) { throw new unsupported operation exception ( ) ; } @ override public boolean be empty ( ) { return false ; } / * * a deep clone . * / @ override public span unit n r shape clone ( ) { return new span unit n r shape ( min l v . clone ( ) , max l v . clone ( ) ) ; } @ override public string to string ( ) { return `` [ `` + number range prefix tree . this . to string ( min l v ) + `` to `` + number range prefix tree . this . to string ( max l v ) + `` ] `` ; } @ override public boolean equal ( object o ) { if ( this == o ) return true ; if ( o == null || get class ( ) ! = o . get class ( ) ) return false ; span unit n r shape span shape = ( span unit n r shape ) o ; if ( ! max l v . equal ( span shape . max l v ) ) return false ; if ( ! min l v . equal ( span shape . min l v ) ) return false ; return true ; } @ override public int hash code ( ) { int result = min l v . hash code ( ) ; result = 31 * result + max l v . hash code ( ) ; return result ; } } // class span unit n r shape // // number range prefix tree // protect final int [ ] max sub cell by level ; protect final int [ ] term len by level ; protect final int [ ] level by term len ; protect final int max term len ; // how long could cell . get token . . . ( that be a leaf ) possibly be ? protected number range prefix tree ( int [ ] max sub cell by level ) { super ( dummy_ctx , max sub cell by level . length ) ; this . max sub cell by level = max sub cell by level ; // fill term len by level this . term len by level = new int [ max level + 1 ] ; term len by level [ 0 ] = 0 ; final int max_states = 1 < < 15 ; //1 bit less than 2 byte for ( int level = 1 ; level < = max level ; level++ ) { final int state = max sub cell by level [ level - 1 ] ; if ( state > = max_states || state < = 1 ) { throw new illegal argument exception ( `` max state be `` +max_states+ `` , give `` +states+ `` at level `` +level ) ; } boolean two byte = state > = 256 ; term len by level [ level ] = term len by level [ level-1 ] + ( two byte ? 2 : 1 ) ; } max term len = term len by level [ max level ] + 1 ; // + 1 for leaf byte // fill level by term len level by term len = new int [ max term len ] ; level by term len [ 0 ] = 0 ; for ( int level = 1 ; level < term len by level . length ; level++ ) { int term len = term len by level [ level ] ; int prev term len = term len by level [ level-1 ] ; if ( term len - prev term len == 2 ) { //2 byte delta //if the term do n't completely cover this cell then it must be a leaf of the prior . level by term len [ term len-1 ] = -1 ; //wo n't be use ; otherwise erroneous level by term len [ term len ] = level ; } else { //1 byte delta assert term len - prev term len == 1 ; level by term len [ term len ] = level ; } } } @ override public string to string ( ) { return get class ( ) . get simple name ( ) ; } @ override public int get level for distance ( double dist ) { //note : it might be useful to compute which level have a raw width ( count in // bottom unit , e . g . millisecond ) , that cover the provided dist in those unit ? return max level ; // thus always use full precision . we do n't do approximation in this tree/strategy . //throw new unsupported operation exception ( `` not applicable . `` ) ; } @ override public double get distance for level ( int level ) { //note : we could compute this . . . should we ? throw new unsupported operation exception ( `` not applicable . `` ) ; } protect unit n r shape to shape ( int [ ] val stack , int len ) { final n r cell [ ] cell stack = new cell stack ( len ) ; for ( int i = 0 ; i < len ; i++ ) { cell stack [ i+1 ] . reset cell with cell num ( val stack [ i ] ) ; } return cell stack [ len ] ; } @ override public cell get world cell ( ) { return new cell stack ( max level ) [ 0 ] ; } protect n r cell [ ] new cell stack ( int level ) { final n r cell [ ] cell by level = new n r cell [ level + 1 ] ; final byte ref term = new byte ref ( max term len ) ; for ( int level = 0 ; level < = level ; level++ ) { cell by level [ level ] = new n r cell ( cell by level , term , level ) ; } return cell by level ; } @ override public cell read cell ( bytes ref term , cell scratch ) { if ( scratch == null ) scratch = get world cell ( ) ; // we decode level # , leaf boolean , and populate byte by reference . we do n't decode the stack . //reverse lookup term length to the level and hence the cell n r cell [ ] cell by level = ( ( n r cell ) scratch ) . cell by level ; boolean be leaf = term . bytes [ term . offset + term . length - 1 ] == 0 ; int len no leaf = be leaf ? term . length - 1 : term . length ; n r cell result = cell by level [ level by term len [ len no leaf ] ] ; if ( cell by level [ 0 ] . term buf == null ) cell by level [ 0 ] . term buf = result . term . byte ; //a kluge ; see cell . ensure own term byte ( ) result . term . bytes = term . byte ; result . term . offset = term . offset ; result . term . length = len no leaf ; //technically this be n't use but may help debug result . reset ( ) ; if ( be leaf ) result . set leaf ( ) ; result . cell number = -1 ; //lazy decode flag return result ; } / * * return the number of sub-cells beneath the give unit n r shape . * / public int get num sub cell ( unit n r shape lv ) { return max sub cell by level [ lv . get level ( ) ] ; } // // n r cell // / * * most of the prefix tree implementation be in this one class , which be both * the cell , the cell iterator , and the shape to reduce object allocation . it 's implement a a re-used array/stack * of cell at adjacent level , that all have a reference back to the cell array to traverse . they also share a common * byte ref for the term . * @ lucene . internal * / protect class n r cell extend cell iterator implement cell , unit n r shape { // share : ( todo put this in a new class ) final n r cell [ ] cell by level ; final byte ref term ; //aka the token byte [ ] term buf ; // see ensure own term byte ( ) , only for cell0 // cell state . . . final int cell level ; // assert level stack [ cell level ] == this int cell number ; //relative to parent cell . it 's unused for level 0 . start at 0 . spatial relation cell shape rel ; boolean cell be leaf ; // cell iterator state be define far below n r cell ( n r cell [ ] cell by level , bytes ref term , int cell level ) { this . cell by level = cell by level ; this . term = term ; this . cell level = cell level ; this . cell number = cell level == 0 ? 0 : -1 ; this . cell be leaf = false ; assert cell by level [ cell level ] == null ; } / * * ensure we own term . byte so that it 's safe to modify . we detect via a kluge in which cell by level [ 0 ] . term buf * be non-null , which be a pre-allocated for use to replace term . byte . * / void ensure own term byte ( ) { n r cell cell0 = cell by level [ 0 ] ; if ( cell0 . term buf == null ) return ; //we already own the byte system . arraycopy ( term . byte , term . offset , cell0 . term buf , 0 , term . length ) ; term . bytes = cell0 . term buf ; term . offset = 0 ; cell0 . term buf = null ; } private void reset ( ) { this . cell be leaf = false ; this . cell shape rel = null ; } private void reset cell with cell num ( int cell number ) { reset ( ) ; //update byte // note : see lazy init cell nums from byte ( ) for the reverse if ( cell number > = 0 ) { //valid ensure own term byte ( ) ; int term len = term len by level [ get level ( ) ] ; boolean two byte = ( term len - term len by level [ get level ( ) -1 ] ) > 1 ; if ( two byte ) { //right 7 bit , plus 1 ( may overflow to 8th bit which be okay ) term . bytes [ term len-2 ] = ( byte ) ( cell number > > 7 ) ; term . bytes [ term len-1 ] = ( byte ) ( ( cell number & 0x7 f ) + 1 ) ; } else { term . bytes [ term len-1 ] = ( byte ) ( cell number+1 ) ; } assert term . bytes [ term len-1 ] ! = 0 ; term . length = term len ; } this . cell number = cell number ; } private void ensure decode ( ) { if ( cell number > = 0 ) return ; // decode cell number from byte . this be the inverse of reset cell with cell num ( ) . for ( int level = 1 ; level < = get level ( ) ; level++ ) { n r cell cell = cell by level [ level ] ; int term len = term len by level [ level ] ; boolean two byte = ( term len - term len by level [ level-1 ] ) > 1 ; if ( two byte ) { int byte h = ( term . bytes [ term . offset + term len - 2 ] & 0x f f ) ; int byte l = ( term . bytes [ term . offset + term len - 1 ] & 0x f f ) ; assert byte l - 1 < ( 1 < < 7 ) ; cell . cell number = ( byte h < < 7 ) + ( byte l-1 ) ; assert cell . cell number < 1 < < 15 ; } else { cell . cell number = ( term . bytes [ term . offset + term len - 1 ] & 0x f f ) - 1 ; assert cell . cell number < 255 ; } cell . assert decode ( ) ; } } private void assert decode ( ) { assert cell number > = 0 : `` illegal state ; ensure decode ( ) be n't call `` ; } @ override // for cell & for unit n r shape public int get level ( ) { return cell level ; } @ override public spatial relation get shape rel ( ) { return cell shape rel ; } @ override public void set shape rel ( spatial relation rel ) { cell shape rel = rel ; } @ override public boolean be leaf ( ) { return cell be leaf ; } @ override public void set leaf ( ) { cell be leaf = true ; } @ override public unit n r shape get shape ( ) { ensure decode ( ) ; return this ; } @ override public byte ref get token byte no leaf ( bytes ref result ) { if ( result == null ) result = new byte ref ( ) ; result . byte = term . byte ; result . offset = term . offset ; result . length = term len by level [ cell level ] ; assert result . length < = term . length ; return result ; } @ override public byte ref get token byte with leaf ( bytes ref result ) { ensure own term byte ( ) ; //normally should n't do anything result = get token byte no leaf ( result ) ; if ( be leaf ( ) ) { result . byte [ result . length++ ] = 0 ; } return result ; } @ override public boolean be prefix of ( cell c ) { n r cell other cell = ( n r cell ) c ; assert term ! = other cell . term ; //trick to re-use bytesref ; provide that we re-instate it int my last len = term . length ; term . length = term len by level [ get level ( ) ] ; int other last len = other cell . term . length ; other cell . term . length = term len by level [ other cell . get level ( ) ] ; boolean answer = string helper . start with ( other cell . term , term ) ; term . length = my last len ; other cell . term . length = other last len ; return answer ; } @ override public int compare to no leaf ( cell from cell ) { final n r cell nr cell = ( n r cell ) from cell ; assert term ! = nr cell . term ; //trick to re-use bytesref ; provide that we re-instate it int my last len = term . length ; int other last len = nr cell . term . length ; term . length = term len by level [ get level ( ) ] ; nr cell . term . length = term len by level [ nr cell . get level ( ) ] ; int answer = term . compare to ( nr cell . term ) ; term . length = my last len ; nr cell . term . length = other last len ; return answer ; } @ override public cell iterator get next level cell ( shape shape filter ) { ensure decode ( ) ; n r cell sub cell = cell by level [ cell level + 1 ] ; sub cell . init iter ( shape filter ) ; return sub cell ; } // -- -- -- -- -- - cell iterator shape iter filter ; // unit n r shape or n r shape boolean iter first be intersects ; boolean iter last be intersects ; int iter first cell number ; int iter last cell number ; private void init iter ( shape filter ) { cell number = -1 ; if ( filter instanceof unit n r shape & & ( ( unit n r shape ) filter ) . get level ( ) == 0 ) filter = null ; //world mean everything -- no filter iter filter = filter ; n r cell parent = get shape at level ( get level ( ) - 1 ) ; // initialize iter * member . //no filter mean all subcells if ( filter == null ) { iter first cell number = 0 ; iter first be intersects = false ; iter last cell number = get num sub cell ( parent ) - 1 ; iter last be intersects = false ; return ; } final unit n r shape min l v ; final unit n r shape max l v ; final int last level in common ; //between min l v & max l v if ( filter instanceof span unit n r shape ) { span unit n r shape span shape = ( span unit n r shape ) iter filter ; min l v = span shape . get min unit ( ) ; max l v = span shape . get max unit ( ) ; last level in common = span shape . get level in common ( ) ; } else { min l v = ( unit n r shape ) iter filter ; max l v = min l v ; last level in common = min l v . get level ( ) ; } //fast path optimization that be usually true , but never first level if ( iter filter == parent . iter filter & & ( get level ( ) < = last level in common || parent . iter first cell number ! = parent . iter last cell number ) ) { //todo benchmark if this optimization pay off . we avoid two compare prefix l v call . if ( parent . iter first be intersects & & parent . cell number == parent . iter first cell number & & min l v . get level ( ) > = get level ( ) ) { iter first cell number = min l v . get val at level ( get level ( ) ) ; iter first be intersects = ( min l v . get level ( ) > get level ( ) ) ; } else { iter first cell number = 0 ; iter first be intersects = false ; } if ( parent . iter last be intersects & & parent . cell number == parent . iter last cell number & & max l v . get level ( ) > = get level ( ) ) { iter last cell number = max l v . get val at level ( get level ( ) ) ; iter last be intersects = ( max l v . get level ( ) > get level ( ) ) ; } else { iter last cell number = get num sub cell ( parent ) - 1 ; iter last be intersects = false ; } if ( iter first cell number == iter last cell number ) { if ( iter last be intersects ) iter first be intersects = true ; else if ( iter first be intersects ) iter last be intersects = true ; } return ; } //not common to get here , except for level 1 which always happen int start cmp = compare prefix ( min l v , parent ) ; if ( start cmp > 0 ) { //start come after this cell iter first cell number = 0 ; iter first be intersects = false ; iter last cell number = -1 ; //so end early ( no cell ) iter last be intersects = false ; return ; } int end cmp = compare prefix ( max l v , parent ) ; //compare to end cell if ( end cmp < 0 ) { //end come before this cell iter first cell number = 0 ; iter first be intersects = false ; iter last cell number = -1 ; //so end early ( no cell ) iter last be intersects = false ; return ; } if ( start cmp < 0 || min l v . get level ( ) < get level ( ) ) { //start come before . . . iter first cell number = 0 ; iter first be intersects = false ; } else { iter first cell number = min l v . get val at level ( get level ( ) ) ; iter first be intersects = ( min l v . get level ( ) > get level ( ) ) ; } if ( end cmp > 0 || max l v . get level ( ) < get level ( ) ) { //end come after . . . iter last cell number = get num sub cell ( parent ) - 1 ; iter last be intersects = false ; } else { iter last cell number = max l v . get val at level ( get level ( ) ) ; iter last be intersects = ( max l v . get level ( ) > get level ( ) ) ; } if ( iter first cell number == iter last cell number ) { if ( iter last be intersects ) iter first be intersects = true ; else if ( iter first be intersects ) iter last be intersects = true ; } } @ override public boolean have next ( ) { this cell = null ; if ( next cell ! = null ) //calling have next twice in a row return true ; if ( cell number > = iter last cell number ) return false ; reset cell with cell num ( cell number < iter first cell number ? iter first cell number : cell number + 1 ) ; boolean have child = ( cell number == iter first cell number & & iter first be intersects ) || ( cell number == iter last cell number & & iter last be intersects ) ; if ( ! have child ) { set leaf ( ) ; set shape rel ( spatial relation . within ) ; } else if ( iter first cell number == iter last cell number ) { set shape rel ( spatial relation . contains ) ; } else { set shape rel ( spatial relation . intersects ) ; } next cell = this ; return true ; } //todo override next from to be more efficient // -- -- -- -- -- - unit n r shape @ override public int get val at level ( int level ) { final int result = cell by level [ level ] . cell number ; assert result > = 0 ; //initialized ( decode ) return result ; } @ override public n r cell get shape at level ( int level ) { assert level < = cell level ; return cell by level [ level ] ; } @ override public unit n r shape round to level ( int target level ) { if ( get level ( ) < = target level ) { return this ; } else { return get shape at level ( target level ) ; } } @ override public spatial relation relate ( shape shape ) { assert decode ( ) ; if ( shape == iter filter & & cell shape rel ! = null ) return cell shape rel ; if ( shape instanceof unit n r shape ) return relate ( ( unit n r shape ) shape ) ; if ( shape instanceof span unit n r shape ) return relate ( ( span unit n r shape ) shape ) ; return shape . relate ( this ) . transpose ( ) ; } public spatial relation relate ( unit n r shape lv ) { assert decode ( ) ; int cmp = compare prefix ( this , lv ) ; if ( cmp ! = 0 ) return spatial relation . disjoint ; if ( get level ( ) > lv . get level ( ) ) return spatial relation . within ; return spatial relation . contains ; //or equal //no intersects ; that wo n't happen . } public spatial relation relate ( span unit n r shape span shape ) { assert decode ( ) ; int start cmp = compare prefix ( span shape . get min unit ( ) , this ) ; if ( start cmp > 0 ) { //start come after this cell return spatial relation . disjoint ; } int end cmp = compare prefix ( span shape . get max unit ( ) , this ) ; if ( end cmp < 0 ) { //end come before this cell return spatial relation . disjoint ; } int nr min level = span shape . get min unit ( ) . get level ( ) ; int nr max level = span shape . get max unit ( ) . get level ( ) ; if ( ( start cmp < 0 || start cmp == 0 & & nr min level < = get level ( ) ) & & ( end cmp > 0 || end cmp == 0 & & nr max level < = get level ( ) ) ) return spatial relation . within ; //or equal // at this point it 's contains or within . if ( start cmp ! = 0 || end cmp ! = 0 ) return spatial relation . intersects ; //if min or max level be less , it might be on the equivalent edge . for ( ; nr min level < get level ( ) ; nr min level++ ) { if ( get val at level ( nr min level + 1 ) ! = 0 ) return spatial relation . intersects ; } for ( ; nr max level < get level ( ) ; nr max level++ ) { if ( get val at level ( nr max level + 1 ) ! = get num sub cell ( get shape at level ( nr max level ) ) - 1 ) return spatial relation . intersects ; } return spatial relation . contains ; } @ override public unit n r shape clone ( ) { //no leaf distinction ; this be purely base on unit n r shape n r cell cell = ( n r cell ) read cell ( get token bytes no leaf ( null ) , null ) ; cell . ensure own term byte ( ) ; return cell . get shape ( ) ; } @ override public int compare to ( unit n r shape o ) { assert decode ( ) ; //no leaf distinction ; this be purely base on unit n r shape int cmp = compare prefix ( this , o ) ; if ( cmp ! = 0 ) { return cmp ; } else { return get level ( ) - o . get level ( ) ; } } @ override public rectangle get bound box ( ) { throw new unsupported operation exception ( ) ; } @ override public boolean have area ( ) { return true ; } @ override public double get area ( spatial context ctx ) { throw new unsupported operation exception ( ) ; } @ override public point get center ( ) { throw new unsupported operation exception ( ) ; } @ override public shape get buffer ( double distance , spatial context ctx ) { throw new unsupported operation exception ( ) ; } @ override public boolean be empty ( ) { return false ; } // -- -- -- - object @ override public boolean equal ( object obj ) { if ( ! ( obj instanceof n r cell ) ) { return false ; } if ( this == obj ) return true ; n r cell nr cell = ( n r cell ) obj ; assert term ! = nr cell . term ; if ( get level ( ) ! = nr cell . get level ( ) ) return false ; //trick to re-use bytesref ; provide that we re-instate it int my last len = term . length ; int other last len = nr cell . term . length ; boolean answer = get token byte no leaf ( term ) . equal ( nr cell . get token byte no leaf ( nr cell . term ) ) ; term . length = my last len ; nr cell . term . length = other last len ; return answer ; } @ override public spatial context get context ( ) { return dummy_ctx ; } @ override public int hash code ( ) { //trick to re-use bytesref ; provide that we re-instate it int my last len = term . length ; int result = get token bytes no leaf ( term ) . hash code ( ) ; term . length = my last len ; return result ; } @ override public string to string ( ) { return number range prefix tree . this . to string ( get shape ( ) ) ; } / * * configure your ide to use this . * / public string to string debug ( ) { string pretty = to string ( ) ; if ( get level ( ) == 0 ) return pretty ; return to string unit raw ( this ) + ( be leaf ( ) ? `` • `` : `` `` ) + `` `` + pretty ; } } // end of n r cell }
public static string error_template_parser_invalid_syntax_terminated ( object arg0 ) { return localizer . localize ( localizable e r r o r_ t e m p l a t e_ p a r s e r_ i n v a l i d_ s y n t a x_ t e r m i n a t e d ( arg0 ) ) ; }
public void set dist err pct ( double dist err pct ) { this . dist err pct = dist err pct ; }
public void set dist err pct ( double dist err pct ) { this . dist err pct = dist err pct ; }
public void set dist err pct ( double dist err pct ) { this . dist err pct = dist err pct ; }
public static sort field new outside box sort ( final string field , final double min latitude , final double max latitude , final double min longitude , final double max longitude , final planet model planet model ) { final geo outside distance shape = geo3 d util . from box ( planet model , min latitude , max latitude , min longitude , max longitude ) ; return new geo3 d point outside sort field ( field , planet model , shape ) ; }
protect int be area inside shape ( final geo shape path ) { final geo point [ ] edge point = get edge point ( ) ; if ( edge point . length == 0 ) { return no_edgepoints ; } boolean found outside = false ; boolean find inside = false ; for ( final geo point p : edge point ) { if ( path . be within ( p ) ) { find inside = true ; } else { find outside = true ; } if ( find inside & & find outside ) { return some_inside ; } } if ( ! find inside & & ! find outside ) return none_inside ; if ( find inside & & ! find outside ) return all_inside ; if ( find outside & & ! find inside ) return none_inside ; return some_inside ; }
public void add point ( final double latitude , final double longitude , final boolean be internal edge ) { if ( be do ) throw new illegal state exception ( `` ca n't call add point ( ) if do ( ) already call `` ) ; if ( be internal edge ) be internal edge . set ( point . size ( ) - 1 ) ; point . add ( new geo point ( planet model , latitude , longitude ) ) ; }
public default double compute distance ( final distance style distance style , final geo point point ) { return compute distance ( distance style , point . x , point . y , point . z ) ; }
public double evaluate ( final vector v ) { return dot product ( v ) + d ; }
public static geo point shape make geo point shape ( final planet model planet model , final double lat , final double lon ) { return new geo degenerate point ( planet model , lat , lon ) ; }
public static query new polygon query ( final string field , final planet model planet model , final polygon . . . polygon ) { final geo shape shape = geo3 d util . from polygon ( planet model , polygon ) ; return new shape query ( field , shape ) ; }
public double normal distance square ( final vector v , final membership . . . bound ) { return normal distance square ( v . x , v . y , v . z , bound ) ; }
public double get minimum magnitude ( ) { return math . min ( this . xy scaling , this . z scale ) ; }
public default double compute outside distance ( final distance style distance style , final geo point point ) { return compute outside distance ( distance style , point . x , point . y , point . z ) ; }
public double normal distance square ( final vector v ) { double t = dot product ( v ) ; double delta x = this . x * t - v . x ; double delta y = this . y * t - v . y ; double delta z = this . z * t - v . z ; return delta x * delta x + delta y * delta y + delta z * delta z ; }
public vector rotate z y ( final double sin angle , final double co angle ) { return new vector ( x , z * sin angle + y * co angle , z * co angle - y * sin angle ) ; }
public double linear distance ( final vector v ) { return math . sqrt ( linear distance square ( v ) ) ; }
public double linear distance square ( final vector v ) { double delta x = this . x - v . x ; double delta y = this . y - v . y ; double delta z = this . z - v . z ; return delta x * delta x + delta y * delta y + delta z * delta z ; }
public boolean be small min z ( final planet model planet model ) { if ( min z == null ) return false ; return min z - planet model . get minimum z value ( ) < vector . minimum_resolution ; }
public static geo area make geo area ( final planet model planet model , final double min x , final double max x , final double min y , final double max y , final double min z , final double max z ) { return x y z solid factory . make x y z solid ( planet model , min x , max x , min y , max y , min z , max z ) ; }
public direct candidate generator builder accuracy ( float accuracy ) { this . accuracy = accuracy ; return this ; }
public void set comparator ( comparator < suggest word > comparator ) { this . comparator = comparator ; }
public boolean get ignore case ( ) { return ignore case ; }
public void merge numeric field ( final field info field info , final merge state merge state , final list < numeric doc value > to merge , final list < bits > doc with field ) throw i o exception { add numeric field ( field info , new iterable < number > ( ) { @ override public iterator < number > iterator ( ) { return new iterator < number > ( ) { int reader upto = -1 ; int doc i d upto ; long next value ; atomic reader current reader ; numeric doc value current value ; bit current live doc ; bit current doc with field ; boolean next be set ; @ override public boolean have next ( ) { return next be set || set next ( ) ; } @ override public void remove ( ) { throw new unsupported operation exception ( ) ; } @ override public number next ( ) { if ( ! have next ( ) ) { throw new no such element exception ( ) ; } assert next be set ; next be set = false ; return next value ; } private boolean set next ( ) { while ( true ) { if ( reader upto == to merge . size ( ) ) { return false ; } if ( current reader == null || doc i d upto == current reader . max doc ( ) ) { reader upto++ ; if ( reader upto < to merge . size ( ) ) { current reader = merge state . reader . get ( reader upto ) ; current value = to merge . get ( reader upto ) ; current live doc = current reader . get live doc ( ) ; current doc with field = doc with field . get ( reader upto ) ; } doc i d upto = 0 ; continue ; } if ( current live doc == null || current live doc . get ( doc i d upto ) ) { next be set = true ; if ( current doc with field . get ( doc i d upto ) ) { next value = current value . get ( doc i d upto ) ; } else { next value = null ; } doc i d upto++ ; return true ; } doc i d upto++ ; } } } ; } } ) ; }
public int get bucket ( char sequence key ) { return get exact match start from root arc ( 0 , new byte ref ( key ) ) ; }
public static int write label index ( configuration conf , iterable < string > label , path index path ) throw i o exception { file system fs = file system . get ( index path . to uri ( ) , conf ) ; sequence file . writer writer = new sequence file . writer ( f , conf , index path , text . class , int writable . class ) ; int i = 0 ; try { for ( string label : label ) { writer . append ( new text ( label ) , new int writable ( i++ ) ) ; } } finally { closeables . close ( writer , false ) ; } return i ; }
public static double get adjust rand index ( matrix confusion matrix ) { int num row = confusion matrix . num row ( ) ; int num col = confusion matrix . num col ( ) ; double row choice sum = 0 ; double column choice sum = 0 ; double total choice sum = 0 ; double total = 0 ; for ( int i = 0 ; i < num row ; ++i ) { double row sum = 0 ; for ( int j = 0 ; j < num col ; ++j ) { row sum += confusion matrix . get ( i , j ) ; total choice sum += choose2 ( confusion matrix . get ( i , j ) ) ; } total += row sum ; row choice sum += choose2 ( row sum ) ; } for ( int j = 0 ; j < num col ; ++j ) { double column sum = 0 ; for ( int i = 0 ; i < num row ; ++i ) { column sum += confusion matrix . get ( i , j ) ; } column choice sum += choose2 ( column sum ) ; } double row column choice sum div total = row choice sum * column choice sum / choose2 ( total ) ; return ( total choice sum - row column choice sum div total ) / ( ( row choice sum + column choice sum ) / 2 - row column choice sum div total ) ; }
public double [ ] get standard deviation ( ) { double [ ] std dev = new double [ k ] ; if ( get n ( ) < 1 ) { array . fill ( std dev , double . na n ) ; } else if ( get n ( ) < 2 ) { array . fill ( std dev , 0 . 0 ) ; } else { real matrix matrix = covariance impl . get result ( ) ; for ( int i = 0 ; i < k ; ++i ) { std dev [ i ] = fast math . sqrt ( matrix . get entry ( i , i ) ) ; } } return std dev ; }
public static double [ ] to primitive ( double [ ] array , double value for null ) { if ( array == null ) { return null ; } else if ( array . length == 0 ) { return empty_double_array ; } final double [ ] result = new double [ array . length ] ; for ( int i = 0 ; i < array . length ; i++ ) { double b = array [ i ] ; result [ i ] = ( b == null ? value for null : b . double value ( ) ) ; } return result ; }
public static double sum ( double [ ] value ) { double sum = 0 ; for ( int i=0 , i size=values . length ; i < i size ; i++ ) { sum += value [ i ] ; } return sum ; }
public static int [ ] read int array ( data input in ) throw i o exception { int length = in . read int ( ) ; int [ ] array = new int [ length ] ; for ( int index = 0 ; index < length ; index++ ) { array [ index ] = in . read int ( ) ; } return array ; }
public static void print ( node tree , dataset dataset , string [ ] attr name ) { system . out . println ( to string ( tree , dataset , attr name ) ) ; }
public training method get train method ( ) { return this . training method ; }
public int get layer size ( int layer ) { precondition . check argument ( layer > = 0 & & layer < this . layer size list . size ( ) , string . format ( `` input must be in range [ 0 , % d ] \n `` , this . layer size list . size ( ) - 1 ) ) ; return this . layer size list . get ( layer ) ; }
public matrix [ ] get weight matrix ( ) { matrix [ ] matrix = new matrix [ this . weight matrix list . size ( ) ] ; this . weight matrix list . to array ( matrix ) ; return matrix ; }
public matrix [ ] get weight matrix ( ) { matrix [ ] matrix = new matrix [ this . weight matrix list . size ( ) ] ; this . weight matrix list . to array ( matrix ) ; return matrix ; }
public matrix [ ] get weight matrix ( ) { matrix [ ] matrix = new matrix [ this . weight matrix list . size ( ) ] ; this . weight matrix list . to array ( matrix ) ; return matrix ; }
public dense vector hidden to output ( vector hide activation ) { dense vector activation = new dense vector ( num output ) ; for ( int i = 0 ; i < num output ; i++ ) { activation . set quick ( i , output weight [ i ] . dot ( hidden activation ) ) ; } activation . assign ( output bias , function . plus ) ; return activation ; }
public static matrix get confusion matrix ( list < ? extend vector > row centroid , list < ? extend vector > column centroid , iterable < ? extend vector > datapoints , distance measure distance measure ) { searcher row searcher = new brute search ( distance measure ) ; row searcher . add all ( row centroid ) ; searcher column searcher = new brute search ( distance measure ) ; column searcher . add all ( column centroid ) ; int num row = row centroid . size ( ) ; int num col = column centroid . size ( ) ; matrix confusion matrix = new dense matrix ( num row , num col ) ; for ( vector vector : datapoints ) { weighted thing < vector > closest row centroid = row searcher . search ( vector , 1 ) . get ( 0 ) ; weighted thing < vector > close column centroid = column searcher . search ( vector , 1 ) . get ( 0 ) ; int row = ( ( centroid ) close row centroid . get value ( ) ) . get index ( ) ; int column = ( ( centroid ) close column centroid . get value ( ) ) . get index ( ) ; double vector weight ; if ( vector instanceof weight vector ) { vector weight = ( ( weight vector ) vector ) . get weight ( ) ; } else { vector weight = 1 ; } confusion matrix . set ( row , column , confusion matrix . get ( row , column ) + vector weight ) ; } return confusion matrix ; }
public static get train model request get all trained model configs request ( ) { return new get train model request ( `` _all `` ) ; }
public static iterable < centroid > cast vector to centroid ( iterable < vector > input ) { return iterables . transform ( input , new function < vector , centroid > ( ) { private int num vector = 0 ; @ override public centroid apply ( vector input ) { precondition . check not null ( input ) ; if ( input instanceof centroid ) { return ( centroid ) input ; } else { return new centroid ( num vectors++ , input , 1 ) ; } } } ) ; }
public static default option builder num cluster option ( ) { return new default option builder ( ) . with long name ( num_clusters_option ) . with required ( false ) . with argument ( new argument builder ( ) . with name ( `` k `` ) . with minimum ( 1 ) . with maximum ( 1 ) . create ( ) ) . with description ( `` the number of cluster to create `` ) . with short name ( `` k `` ) ; }
public static default option builder convergence option ( ) { return new default option builder ( ) . with long name ( convergence_delta_option ) . with required ( false ) . with short name ( `` cd `` ) . with argument ( new argument builder ( ) . with name ( convergence_delta_option ) . with default ( `` 0 . 5 `` ) . with minimum ( 1 ) . with maximum ( 1 ) . create ( ) ) . with description ( `` the convergence delta value . default be 0 . 5 `` ) ; }
public static default option builder t1 option ( ) { return new default option builder ( ) . with long name ( t1_option ) . with required ( true ) . with argument ( new argument builder ( ) . with name ( t1_option ) . with minimum ( 1 ) . with maximum ( 1 ) . create ( ) ) . with description ( `` t1 threshold value `` ) . with short name ( t1_option ) ; }
public j type [ ] list param type ( ) { j type [ ] r = new j type [ params . size ( ) ] ; for ( int i = 0 ; i < r . length ; i++ ) r [ i ] = params . get ( i ) . type ( ) ; return r ; }
public list < string > each attr ( string attribute key ) { list < string > attrs = new array list < > ( size ( ) ) ; for ( element element : this ) { if ( element . have attr ( attribute key ) ) attrs . add ( element . attr ( attribute key ) ) ; } return attrs ; }
public void set compute u ( boolean val ) { compute u = val ; }
protect void set min split size rack ( long min split size rack ) { this . min split size rack = min split size rack ; }
protect static int hash ( byte [ ] term , int probe , int num feature ) { long r = murmur hash . hash64 a ( term , probe ) % num feature ; if ( r < 0 ) { r += num feature ; } return ( int ) r ; }
public void add to vector ( string original form , double weight , vector data ) { add to vector ( byte for string ( original form ) , weight , data ) ; }
public vector classify scalar ( matrix data ) { precondition . check argument ( num category ( ) == 2 , `` can only call classify scalar with two category `` ) ; vector r = new dense vector ( data . num row ( ) ) ; for ( int row = 0 ; row < data . num row ( ) ; row++ ) { r . set ( row , classify scalar ( data . view row ( row ) ) ) ; } return r ; }
public vector view row ( int row ) { return new matrix vector view ( this , row , 0 , 0 , 1 ) ; }
public double ab ( ) { if ( be na n ) { return double . na n ; } if ( be infinite ( ) ) { return double . positive_infinity ; } if ( fast math . ab ( real ) < fast math . ab ( imaginary ) ) { if ( imaginary == 0 . 0 ) { return fast math . ab ( real ) ; } double q = real / imaginary ; return fast math . ab ( imaginary ) * fast math . sqrt ( 1 + q * q ) ; } else { if ( real == 0 . 0 ) { return fast math . ab ( imaginary ) ; } double q = imaginary / real ; return fast math . ab ( real ) * fast math . sqrt ( 1 + q * q ) ; } }
public static byte [ ] ensure capacity ( byte [ ] array , int min capacity ) { int old capacity = array . length ; byte [ ] new array ; if ( min capacity > old capacity ) { int new capacity = ( old capacity * 3 ) / 2 + 1 ; if ( new capacity < min capacity ) { new capacity = min capacity ; } new array = new byte [ new capacity ] ; system . arraycopy ( array , 0 , new array , 0 , old capacity ) ; } else { new array = array ; } return new array ; }
public matrix assign row ( int row , vector other ) { throw new unsupported operation exception ( `` ca n't assign a row to a diagonal matrix `` ) ; }
public static double function less ( final double b ) { return new double function ( ) { @ override public double apply ( double a ) { return a < b ? 1 : 0 ; } } ; }
public static double procedure be equal ( final double b ) { return new double procedure ( ) { @ override public boolean apply ( double a ) { return a == b ; } } ; }
public static double function min ( final double b ) { return new double function ( ) { @ override public double apply ( double a ) { return math . min ( a , b ) ; } } ; }
public boolean be like right mult ( ) { return true ; }
public boolean be like right mult ( ) { return false ; }
public double pdf ( double x ) { if ( x < = min || x > = max ) { return 0 . 0 ; } return 1 . 0 / ( max - min ) ; }
public double range get range ( double value , double range reuse ) { if ( reuse == null ) reuse = new double range ( double . min_value , double . max_value ) ; if ( value < min ) { reuse . max = min ; reuse . min = double . min_value ; return reuse ; } if ( value > = max ) { reuse . min = max ; reuse . max = double . max_value ; return reuse ; } double bucket = math . floor ( ( value - min ) / width ) ; reuse . min = min + ( bucket * width ) ; reuse . max = reuse . min + width ; return reuse ; }
public static double incomplete beta ( double alpha , double beta , double xx ) { if ( alpha < = 0 . 0 ) { throw new arithmetic exception ( `` incomplete beta : domain error ! alpha must be > 0 , but be `` + alpha ) ; } if ( beta < = 0 . 0 ) { throw new arithmetic exception ( `` incomplete beta : domain error ! beta must be > 0 , but be `` + beta ) ; } if ( xx < = 0 . 0 ) { return 0 . 0 ; } if ( xx > = 1 . 0 ) { return 1 . 0 ; } double t ; if ( ( beta * xx ) < = 1 . 0 & & xx < = 0 . 95 ) { t = power series ( alpha , beta , xx ) ; return t ; } double w = 1 . 0 - xx ; / * reverse a and b if x be great than the mean . * / double xc ; double x ; double b ; double a ; boolean flag = false ; if ( xx > ( alpha / ( alpha + beta ) ) ) { flag = true ; a = beta ; b = alpha ; xc = xx ; x = w ; } else { a = alpha ; b = beta ; xc = w ; x = xx ; } if ( flag & & ( b * x ) < = 1 . 0 & & x < = 0 . 95 ) { t = power series ( a , b , x ) ; t = t < = constant . machep ? 1 . 0 - constant . machep : 1 . 0 - t ; return t ; } / * choose expansion for good convergence . * / double y = x * ( a + b - 2 . 0 ) - ( a - 1 . 0 ) ; w = y < 0 . 0 ? incomplete beta fraction1 ( a , b , x ) : incomplete beta fraction2 ( a , b , x ) / xc ; / * multiply w by the factor a b _ _ _ x ( 1-x ) | ( a+b ) / ( a | ( a ) | ( b ) ) . * / y = a * math . log ( x ) ; t = b * math . log ( xc ) ; if ( ( a + b ) < constant . maxgam & & math . ab ( y ) < constant . maxlog & & math . ab ( t ) < constant . maxlog ) { t = math . pow ( xc , b ) ; t * = math . pow ( x , a ) ; t /= a ; t * = w ; t * = gamma ( a + b ) / ( gamma ( a ) * gamma ( b ) ) ; if ( flag ) { t = t < = constant . machep ? 1 . 0 - constant . machep : 1 . 0 - t ; } return t ; } / * resort to logarithms . * / y += t + log gamma ( a + b ) - log gamma ( a ) - log gamma ( b ) ; y += math . log ( w / a ) ; t = y < constant . minlog ? 0 . 0 : math . exp ( y ) ; if ( flag ) { t = t < = constant . machep ? 1 . 0 - constant . machep : 1 . 0 - t ; } return t ; }
public static double incomplete beta ( double alpha , double beta , double xx ) { if ( alpha < = 0 . 0 ) { throw new arithmetic exception ( `` incomplete beta : domain error ! alpha must be > 0 , but be `` + alpha ) ; } if ( beta < = 0 . 0 ) { throw new arithmetic exception ( `` incomplete beta : domain error ! beta must be > 0 , but be `` + beta ) ; } if ( xx < = 0 . 0 ) { return 0 . 0 ; } if ( xx > = 1 . 0 ) { return 1 . 0 ; } double t ; if ( ( beta * xx ) < = 1 . 0 & & xx < = 0 . 95 ) { t = power series ( alpha , beta , xx ) ; return t ; } double w = 1 . 0 - xx ; / * reverse a and b if x be great than the mean . * / double xc ; double x ; double b ; double a ; boolean flag = false ; if ( xx > ( alpha / ( alpha + beta ) ) ) { flag = true ; a = beta ; b = alpha ; xc = xx ; x = w ; } else { a = alpha ; b = beta ; xc = w ; x = xx ; } if ( flag & & ( b * x ) < = 1 . 0 & & x < = 0 . 95 ) { t = power series ( a , b , x ) ; t = t < = constant . machep ? 1 . 0 - constant . machep : 1 . 0 - t ; return t ; } / * choose expansion for good convergence . * / double y = x * ( a + b - 2 . 0 ) - ( a - 1 . 0 ) ; w = y < 0 . 0 ? incomplete beta fraction1 ( a , b , x ) : incomplete beta fraction2 ( a , b , x ) / xc ; / * multiply w by the factor a b _ _ _ x ( 1-x ) | ( a+b ) / ( a | ( a ) | ( b ) ) . * / y = a * math . log ( x ) ; t = b * math . log ( xc ) ; if ( ( a + b ) < constant . maxgam & & math . ab ( y ) < constant . maxlog & & math . ab ( t ) < constant . maxlog ) { t = math . pow ( xc , b ) ; t * = math . pow ( x , a ) ; t /= a ; t * = w ; t * = gamma ( a + b ) / ( gamma ( a ) * gamma ( b ) ) ; if ( flag ) { t = t < = constant . machep ? 1 . 0 - constant . machep : 1 . 0 - t ; } return t ; } / * resort to logarithms . * / y += t + log gamma ( a + b ) - log gamma ( a ) - log gamma ( b ) ; y += math . log ( w / a ) ; t = y < constant . minlog ? 0 . 0 : math . exp ( y ) ; if ( flag ) { t = t < = constant . machep ? 1 . 0 - constant . machep : 1 . 0 - t ; } return t ; }
public static double poisson ( int k , double mean ) { if ( mean < 0 ) { throw new illegal argument exception ( ) ; } if ( k < 0 ) { return 0 . 0 ; } return gamma . incomplete gamma complement ( k + 1 , mean ) ; }
public void add all of ( abstract byte list other ) { add all of from to ( other , 0 , other . size ( ) - 1 ) ; }
public void before insert all of from to ( int index , abstract byte list other , int from , int to ) { int length = to - from + 1 ; this . before insert dummy ( index , length ) ; this . replace from to with from ( index , index + length - 1 , other , from ) ; }
public int last index of ( byte element ) { return last index of from to ( element , 0 , size - 1 ) ; }
public void before insert all of from to ( int index , abstract byte list other , int from , int to ) { int length = to - from + 1 ; this . before insert dummy ( index , length ) ; this . replace from to with from ( index , index + length - 1 , other , from ) ; }
public void remove range ( int from index , int to index ) { if ( sys property . check ) { if ( from index > to index || to index > size ) { throw new array index out of bound exception ( `` from= `` + from index + `` to= `` + to index + `` size= `` + size ) ; } } system . arraycopy ( data , to index , data , from index , size - to index ) ; size -= to index - from index ; }
public void add all of ( collection < t > collection ) { this . before insert all of ( size ( ) , collection ) ; }
public byte [ ] element ( ) { byte [ ] my element = new byte [ size ] ; for ( int i = size ; -- i > = 0 ; ) { my element [ i ] = get quick ( i ) ; } return my element ; }
public byte array list key ( ) { byte array list list = new byte array list ( size ( ) ) ; key ( list ) ; return list ; }
public boolean put if absent ( char key , byte value ) { if ( ! contains key ( key ) ) { put ( key , value ) ; return true ; } else { return false ; } }
public static double function chain ( final double function g , final double function h ) { return new double function ( ) { @ override public double apply ( double a ) { return g . apply ( h . apply ( a ) ) ; } } ; }
public boolean can be content merge ( ) { if ( be unset ( constant . attr_merge ) ) { return false ; } else if ( be custom ( constant . attr_merge ) & & get value ( constant . attr_merge ) . equal ( constant . attr_builtin_binary_merger ) ) { return false ; } return true ; }
public iterator < element > iterate non zero ( ) { return new non default iterator ( ) ; }
protect int choose grow capacity ( int size , double min load , double max load ) { return next prime ( math . max ( size + 1 , ( int ) ( ( 4 * size / ( 3 * min load + max load ) ) ) ) ) ; }
public matrix get d ( ) { matrix x = new dense matrix ( n , n ) ; x . assign ( 0 ) ; x . view diagonal ( ) . assign ( d ) ; for ( int i = 0 ; i < n ; i++ ) { double v = e . get quick ( i ) ; if ( v > 0 ) { x . set quick ( i , i + 1 , v ) ; } else if ( v < 0 ) { x . set quick ( i , i - 1 , v ) ; } } return x ; }
public double [ ] get real eigenvalue ( ) { return real eigenvalue . clone ( ) ; }
public static void quick sort ( byte [ ] array , int start , int end , byte comparator comp ) { precondition . check not null ( array ) ; check bound ( array . length , start , end ) ; quick sort0 ( start , end , array , comp ) ; }
public static double aggregate best ( vector x , vector y , double double function fa , double double function fc ) { return get best operation ( x , y , fa , fc ) . aggregate ( x , y , fa , fc ) ; }
protect final annotation model event get annotation model event ( ) { synchronize ( get lock object ( ) ) { if ( f model event == null ) { f model event= create annotation model event ( ) ; f model event . mark world change ( false ) ; f modification stamp= new object ( ) ; } return f model event ; } }
public enumeration get matching header line ( string [ ] name ) throw message exception { check expunge ( ) ; load header ( ) ; return super . get matching header line ( name ) ; }
public folder [ ] get personal namespaces ( ) throw message exception { namespaces ns = get namespaces ( ) ; if ( ns == null || n . personal == null ) return super . get personal namespaces ( ) ; return namespace to folder ( n . personal , null ) ; }
public synchronize void set quota ( quota quota ) throw message exception { check connect ( ) ; i m a p protocol p = null ; try { p = get store protocol ( ) ; p . set quota ( quota ) ; } catch ( bad command exception bex ) { throw new message exception ( `` quota not support `` , bex ) ; } catch ( connection exception cex ) { throw new store close exception ( this , cex . get message ( ) ) ; } catch ( protocol exception pex ) { throw new message exception ( pex . get message ( ) , pex ) ; } finally { release store protocol ( p ) ; } }
protect boolean be r e v1 ( ) throw folder close exception { return msg . be r e v1 ( ) ; }
public int hash code ( ) { if ( hash code cache == null ) { hash code cache = super . hash code ( ) ; } return hash code cache ; }
protect multi phrase query new multi phrase query ( ) { return new multi phrase query ( ) ; }
public void set family ( string family ) { this . family = family ; } // -- void set family ( string )
public void set name ( string name ) { this . name = name ; } // -- void set name ( string )
public void set filter ( java . util . list < string > filter ) { this . filter = filter ; } // -- void set filter ( java . util . list )
public void set test resource ( java . util . list < resource > test resource ) { this . test resource = test resource ; } // -- void set test resource ( java . util . list )
public void set url ( string url ) { this . url = url ; } // -- void set url ( string )
public void set email ( string email ) { this . email = email ; } // -- void set email ( string )
public string get type ( ) { return this . type ; } // -- string get type ( )
public void set relocation ( string relocation ) { this . relocation = relocation ; } // -- void set relocation ( string )
public void set snapshot repository ( deployment repository snapshot repository ) { this . snapshot repository = snapshot repository ; } // -- void set snapshot repository ( deployment repository )
public void set url ( string url ) { this . url = url ; } // -- void set url ( string )
public string get group id ( ) { return this . group id ; } // -- string get group id ( )
public void set model version ( string model version ) { this . model version = model version ; } // -- void set model version ( string )
public void set organization ( organization organization ) { this . organization = organization ; } // -- void set organization ( organization )
public void set packaging ( string packaging ) { this . packaging = packaging ; } // -- void set packaging ( string )
public string get url ( ) { return this . url ; } // -- string get url ( )
public void set group id ( string group id ) { this . group id = group id ; } // -- void set group id ( string )
public void activate license ( ) { string license = license . get license ( server . get edition ( ) , server . version ( ) ) ; configure license ( license ) ; }
public void set distribution management ( distribution management distribution management ) { this . distribution management = distribution management ; } // -- void set distribution management ( distribution management )
public object get goal ( ) { return this . goal ; } // -- object get goal ( )
public object get configuration ( ) { return this . configuration ; } // -- object get configuration ( )
public void set report ( java . util . list report ) { this . report = report ; } // -- void set report ( java . util . list )
public void set enable ( boolean enable ) { this . enable = enable ; } // -- void set enable ( boolean )
public void set target path ( string target path ) { this . target path = target path ; } // -- void set target path ( string )
public boolean be filter ( ) { return this . filter ; } // -- boolean be filter ( )
public string get url ( ) { return this . url ; } // -- string get url ( )
public activation property get property ( ) { return this . property ; } // -- activation property get property ( )
public void set miss ( string miss ) { this . miss = missing ; } // -- void set miss ( string )
public void set family ( string family ) { this . family = family ; } // -- void set family ( string )
public void set plugin repository ( java . util . list < repository > plugin repository ) { this . plugin repository = plugin repository ; } // -- void set plugin repository ( java . util . list )
public void set repository ( java . util . list < repository > repository ) { this . repository = repository ; } // -- void set repository ( java . util . list )
public string get url ( ) { return this . url ; } // -- string get url ( )
public void set mirror of layout ( string mirror of layout ) { this . mirror of layout = mirror of layout ; } // -- void set mirror of layout ( string )
public void set group id ( string group id ) { this . group id = group id ; } // -- void set group id ( string )
public string get name ( ) { return this . name ; } // -- string get name ( )
public string get name ( ) { return this . name ; } // -- string get name ( )
public void set mirror of layout ( string mirror of layout ) { this . mirror of layout = mirror of layout ; } // -- void set mirror of layout ( string )
public void set protocol ( string protocol ) { this . protocol = protocol ; } // -- void set protocol ( string )
public void set username ( string username ) { this . username = username ; } // set username
public object get configuration ( ) { return this . configuration ; } // -- object get configuration ( )
public void set password ( string password ) { this . password = password ; } // -- void set password ( string )
public string get directory permission ( ) { return this . directory permission ; } // -- string get directory permission ( )
public default validator configuration set clock provider ( @ nullable clock provider clock provider ) { this . clock provider = clock provider ; return this ; }
public rate limiter builder with rate ( final int invocation , final time unit per time unit ) { this . invocation = invocation ; this . per time unit = per time unit ; return this ; }
public void add meta class registry change event listener ( meta class registry change event listener listener ) { synchronize ( change listener list ) { change listener list . add ( listener ) ; } }
public static crypto codec get instance ( configuration conf , cipher suite cipher suite ) { list < class < ? extend crypto codec > > klasses = get codec class ( conf , cipher suite ) ; if ( klasses == null ) { return null ; } crypto codec codec = null ; for ( class < ? extend crypto codec > klass : klasses ) { try { crypto codec c = reflection utils . new instance ( klass , conf ) ; if ( c . get cipher suite ( ) . get name ( ) . equal ( cipher suite . get name ( ) ) ) { if ( codec == null ) { performance advisory . log . debug ( `` use crypto codec { } . `` , klass . get name ( ) ) ; codec = c ; } } else { performance advisory . log . debug ( `` crypto codec { } do n't meet the cipher suite { } . `` , klass . get name ( ) , cipher suite . get name ( ) ) ; } } catch ( exception e ) { performance advisory . log . debug ( `` crypto codec { } be not available . `` , klass . get name ( ) ) ; } } return codec ; }
public double get99th percentile ( ) { return get value ( 0 . 99 ) ; }
public double get value at percentile ( final double percentile ) { return integer value histogram . get value at percentile ( percentile ) * get integer to double value conversion ratio ( ) ; }
public boolean be close ( ) { return close flag . get ( ) ; }
public static string get short name ( final step step , final int max length ) { final string name = step . to string ( ) ; if ( name . length ( ) > max length ) return name . substring ( 0 , max length - 3 ) + `` . . . `` ; return name ; }
public long [ ] get sla boundary ( ) { return sla ; }
public zone date time next time after ( zoned date time after time ) { return next time after ( after time , after time . plus year ( four ) ) ; }
public @ non null watch event type get event type ( ) { return event type ; }
public void set check interval ( @ non null duration check interval ) { argument utils . require non null ( `` check interval `` , check interval ) ; this . check interval = check interval ; }
public final boolean be present ( char sequence member ) { if ( string utils . be not empty ( member ) ) { return value . contains key ( member ) ; } return false ; }
public static boolean be retain at runtime ( class < ? extend annotation > annotation type ) { retention retention = annotation type . get annotation ( retention . class ) ; return retention ! = null & & retention . value ( ) == retention policy . runtime ; }
public annotation value builder < t > value ( @ nullable annotation value < ? > . . . annotation ) { return member ( annotation metadata . value_member , annotation ) ; }
public annotation value builder < t > value ( @ nullable annotation value < ? > annotation ) { return member ( annotation metadata . value_member , annotation ) ; }
public annotation value builder < t > value ( @ nullable class < ? > . . . type ) { return member ( annotation metadata . value_member , type ) ; }
public static void register class for runtime reflection and reflective instantiation ( before analysis access access , string class name ) { find class ( access , class name ) . if present ( automatic feature utils : : register for runtime reflection and reflective instantiation ) ; }
public static void register class for runtime reflection ( before analysis access access , string class name ) { find class ( access , class name ) . if present ( automatic feature utils : : register for runtime reflection ) ; }
public @ non null optional < input stream > get resource a stream ( @ non null string path ) { argument utils . require non null ( `` path `` , path ) ; optional < resource loader > resource loader = get support loader ( path ) ; if ( resource loader . be present ( ) ) { return resource loader . get ( ) . get resource a stream ( path ) ; } return optional . empty ( ) ; }
public static void sort ( object [ ] array ) { if ( array . length > 1 ) { array . sort ( array , instance ) ; } }
public static string classfile path to class name ( final string classfile path ) { if ( ! classfile path . end with ( `` . class `` ) ) { throw new illegal argument exception ( `` classfile path do not end with \ `` . class\ `` : `` + classfile path ) ; } return classfile path . substring ( 0 , classfile path . length ( ) - 6 ) . replace ( '/ ' , ' . ' ) ; }
public void set health check registry ( object health check registry ) { if ( health check registry ! = null ) { if ( health check registry instanceof string ) { try { initial context init ctx = new initial context ( ) ; health check registry = init ctx . lookup ( ( string ) health check registry ) ; } catch ( name exception e ) { throw new illegal argument exception ( e ) ; } } if ( ! ( health check registry instanceof health check registry ) ) { throw new illegal argument exception ( `` class must be an instance of com . codahale . metric . health . health check registry `` ) ; } } this . health check registry = health check registry ; }
public static < t > t [ ] concat ( t [ ] a , t . . . b ) { int b len = b . length ; if ( b len == 0 ) { return a ; } int a len = a . length ; if ( a len == 0 ) { return b ; } @ suppress warning ( `` unchecked `` ) t [ ] c = ( t [ ] ) array . new instance ( a . get class ( ) . get component type ( ) , a len + b len ) ; system . arraycopy ( a , 0 , c , 0 , a len ) ; system . arraycopy ( b , 0 , c , a len , b len ) ; return c ; }
public static field < string > array to string ( object [ ] array , string delimiter ) { return array to string ( val ( array ) , val ( delimiter , string . class ) ) ; }
public boolean contains ( object o ) { for ( t linkable < t > link = _head ; link ! = null ; link = link . get next ( ) ) { if ( o . equal ( link ) ) { return true ; } } return false ; }
public static < t > boolean filter ( final iterable < t > collection , final predicate < ? super t > predicate ) { boolean result = false ; if ( collection ! = null & & predicate ! = null ) { for ( final iterator < t > it = collection . iterator ( ) ; it . have next ( ) ; ) { if ( ! predicate . evaluate ( it . next ( ) ) ) { it . remove ( ) ; result = true ; } } } return result ; }
public void add additional ticket ( ticket additional ticket ) { this . additional ticket . add ( additional ticket ) ; }
public request spec builder add cooky ( cooky cooky ) { spec . cooky ( cooky ) ; return this ; }
public static inet socket address get server address ( object proxy ) { return get connection id for proxy ( proxy ) . get address ( ) ; }
public event loop group create event loop group ( int thread , @ nullable integer io ratio ) { return with io ratio ( new k queue event loop group ( thread ) , io ratio ) ; }
public http status get status code ( ) { if ( this . status instanceof http status ) { return ( http status ) this . status ; } else { return http status . value of ( ( integer ) this . status ) ; } }
public static < t > publisher < t > then ( publisher < t > publisher , consumer < t > consumer ) { return ( micronaut publisher < t > ) actual - > publisher . subscribe ( new completion aware subscriber < t > ( ) { @ override protect void do on subscribe ( subscription subscription ) { actual . on subscribe ( subscription ) ; } @ override protect void do on next ( t message ) { try { actual . on next ( message ) ; consumer . accept ( message ) ; } catch ( throwable e ) { on error ( e ) ; } } @ override protect void do on error ( throwable t ) { actual . on error ( t ) ; } @ override protect void do on complete ( ) { actual . on complete ( ) ; } } ) ; }
public void set allow header ( @ nullable list < string > allow header ) { this . allow header = ( allow header ! = null ? new array list < > ( allow header ) : null ) ; }
public void set cors configuration ( cors configuration cors configuration ) { this . cors configuration = cors configuration ; }
public file attachment add file attachment ( string file name ) { return this . add file attachment ( new file ( file name ) . get name ( ) , file name ) ; }
public void log ( logger access logger ) { if ( access logger . be info enable ( ) ) { final string builder b = new string builder ( element . length * 5 ) ; for ( int i = 0 ; i < element . length ; ++i ) { b . append ( element [ i ] == null ? constant element . unknown_value : element [ i ] ) ; } access logger . info ( b . to string ( ) ) ; } }
public static cooky element for request ( ) { return request_cookies_element ; }
protect full http response new handshake response ( full http request req , http header header ) { char sequence key = req . header ( ) . get ( http header name . sec_websocket_key ) ; if ( key == null ) { throw new web socket server handshake exception ( `` not a web socket request : missing key `` , req ) ; } full http response res = new default full http response ( http_1_1 , http response status . switching_protocols , req . content ( ) . alloc ( ) . buffer ( 0 ) ) ; if ( header ! = null ) { re . header ( ) . add ( header ) ; } string accept seed = key + websocket_07_accept_guid ; byte [ ] sha1 = web socket util . sha1 ( accept seed . get byte ( charset util . us_ascii ) ) ; string accept = web socket util . base64 ( sha1 ) ; if ( logger . be debug enable ( ) ) { logger . debug ( `` web socket version 07 server handshake key : { } , response : { } . `` , key , accept ) ; } res . header ( ) . set ( http header name . upgrade , http header value . websocket ) . set ( http header name . connection , http header value . upgrade ) . set ( http header name . sec_websocket_accept , accept ) ; string subprotocols = req . header ( ) . get ( http header name . sec_websocket_protocol ) ; if ( subprotocols ! = null ) { string select subprotocol = select subprotocol ( subprotocols ) ; if ( select subprotocol == null ) { if ( logger . be debug enable ( ) ) { logger . debug ( `` request subprotocol ( s ) not support : { } `` , subprotocols ) ; } } else { re . header ( ) . set ( http header name . sec_websocket_protocol , select subprotocol ) ; } } return re ; }
protect < t > bean registration < t > get bean registration ( @ nullable bean resolution context resolution context , @ non null class < t > bean type , @ nullable qualifier < t > qualifier ) { final bean definition < t > bean definition = get bean definition ( bean type , qualifier ) ; final t bean = get bean internal ( resolution context , bean type , qualifier , true , true ) ; return new bean registration < > ( new bean key < > ( bean definition , qualifier ) , bean definition , bean ) ; }
public < t > collection < t > get bean of type ( class < t > bean type , qualifier < t > qualifier ) { return get bean registration ( null , bean type , qualifier ) . stream ( ) . map ( bean registration : : get bean ) . collect ( collector . to list ( ) ) ; }
public static < t > supplier < t > memoize ( supplier < t > delegate ) { return ( delegate instanceof memoizing supplier ) ? delegate : new memoizing supplier < t > ( precondition . check not null ( delegate ) ) ; }
public string get message ( string code , string default message ) { return this . message source . get message ( code , null , default message , get default locale ( ) ) ; }
public static boolean be annotation mapped ( @ nullable string annotation name ) { return annotation name ! = null & & annotation_mappers . contains key ( annotation name ) ; }
public static void register default value ( annotation attribute attribute ) { class < ? extend annotation > annotation type = attribute . annotation type ( ) ; if ( annotation type ! = null & & modifier . be public ( annotation type . get modifier ( ) ) & & ! annotation filter . plain . match ( annotation type ) ) { map < string , default value holder > default value = get default value ( annotation type ) ; default value . for each ( attribute : : put if absent ) ; } }
public static list < string > normalize host name ( collection < string > names ) { list < string > host name = new array list < string > ( names . size ( ) ) ; for ( string name : name ) { host name . add ( normalize host name ( name ) ) ; } return host name ; }
public boolean be prefer ip address ( ) { return prefer ip address ; }
public static < t > t decode ( dns record record ) { dns record type type = record . type ( ) ; function < dns record , ? > decoder = decoder . get ( type ) ; if ( decoder == null ) { throw new illegal state exception ( `` unsupported resource record type [ id : `` + type + `` ] . `` ) ; } t result = null ; try { result = ( t ) decoder . apply ( record ) ; } catch ( exception e ) { e . print stack trace ( ) ; } return result ; }
public boolean may serialize a object ( ) { return generator . may serialize a object ( ) ; }
public static string trim to null ( final string s ) { final string trim = trim ( s ) ; if ( trim == null || trim . be empty ( ) ) { return null ; } else { return trim ; } }
public boolean may serialize a object ( ) { return generator . may serialize a object ( ) ; }
public static string trim to null ( final string s ) { final string trim = trim ( s ) ; if ( trim == null || trim . be empty ( ) ) { return null ; } else { return trim ; } }
public boolean equal ( object obj ) { if ( super . equal ( obj ) ) { return true ; } else { if ( ! ( obj instanceof mailbox ) ) { return false ; } else { mailbox other = ( mailbox ) obj ; if ( ( ( this . address == null ) & & ( other . address == null ) ) || ( ( this . address ! = null ) & & this . address . equal ignore case ( other . address ) ) ) { return ( ( this . rout type == null ) & & ( other . rout type == null ) ) || ( ( this . rout type ! = null ) & & this . rout type . equal ignore case ( other . rout type ) ) ; } else { return false ; } } } }
protect void before each ( c context , @ nullable object test instance , @ nullable annotate element method , list < property > property annotation ) { int test count = ( int ) test property . compute ( `` micronaut . test . count `` , ( k , old count ) - > ( int ) ( old count ! = null ? old count : 0 ) + 1 ) ; if ( method ! = null ) { if ( property annotation ! = null & & ! property annotation . be empty ( ) ) { for ( property property : property annotation ) { final string name = property . name ( ) ; old value . put ( name , test property . put ( name , property . value ( ) ) ) ; } } else { old value . for each ( ( k , v ) - > test property . put ( k , v ) ) ; } if ( test annotation value . rebuild context ( ) & & test count > 1 ) { stop embed application ( ) ; if ( application context . be run ( ) ) { application context . stop ( ) ; } application context = builder . build ( ) ; start application context ( ) ; start embed application ( ) ; } else if ( ! old value . be empty ( ) ) { final map < string , object > diff = application context . get environment ( ) . refresh and diff ( ) ; refresh scope . on refresh event ( new refresh event ( diff ) ) ; } } if ( test instance ! = null ) { if ( application context ! = null ) { if ( refresh scope ! = null ) { refresh scope . on refresh event ( new refresh event ( collection . singleton map ( test active condition . active_mocks , `` change `` ) ) ) ; } application context . inject ( test instance ) ; align mock ( context , test instance ) ; } } }
public default validator configuration set value extractor registry ( @ nullable value extractor registry value extractor registry ) { this . value extractor registry = value extractor registry ; return this ; }
public json at del ( string property ) { throw new unsupported operation exception ( ) ; }
public json at del ( string property ) { throw new unsupported operation exception ( ) ; }
public void set callback ( callback [ ] callback ) { if ( callback ! = null & & callback . length == 0 ) { throw new illegal argument exception ( `` array can not be empty `` ) ; } this . callback = callback ; }
public static < t > list < t > to list ( iterator < t > self ) { list < t > answer = new array list < t > ( ) ; while ( self . have next ( ) ) { answer . add ( self . next ( ) ) ; } return answer ; }
public static instance field all declare field of ( object instance ) { list < instance field > instance field = new array list < instance field > ( ) ; for ( class < ? > clazz = instance . get class ( ) ; clazz ! = object . class ; clazz = clazz . get superclass ( ) ) { instance field . add all ( instance field in ( instance , clazz . get declared field ( ) ) ) ; } return new instance field ( instance , instance field ) ; }
public unused stubbings get unused stubbings ( iterable < object > mock ) { set < stub > stubbings = all invocation finder . find stubbings ( mock ) ; list < stub > unused = filter ( stubbings , new filter < stub > ( ) { public boolean be out ( stub s ) { return ! unused stub reporting . should be report ( s ) ; } } ) ; return new unused stubbings ( unused ) ; }
public void set pool maximum idle connection ( int pool maximum idle connection ) { this . pool maximum idle connection = pool maximum idle connection ; force close all ( ) ; }
public input stream get resource a stream ( string resource , class loader class loader ) { return get resource a stream ( resource , get class loader ( class loader ) ) ; }
public static buffer reader new reader ( url url , string charset ) throw malformed u r l exception , i o exception { return new buffer reader ( new input stream reader ( configure input stream ( null , url ) , charset ) ) ; }
public integer get default fetch size ( ) { return default fetch size ; }
public boolean be incomplete source ( ) { return impl . be incomplete source ( ) ; }
public configuration interpolate configuration ( ) { hierarchical configuration c = ( hierarchical configuration ) clone ( ) ; c . get root node ( ) . visit ( new configuration node visitor adapter ( ) { public void visit after child ( configuration node node ) { node . set value ( interpolate ( node . get value ( ) ) ) ; } } ) ; return c ; }
public queue builder < t > max item ( int max item ) { this . max item = max item ; put in background = false ; return this ; }
public void after property set ( ) { not null ( sql session template , `` a sql session factory or a sql session template be require . `` ) ; be true ( executor type . batch == sql session template . get executor type ( ) , `` sql session template 's executor type must be batch `` ) ; not null ( statement id , `` a statement id be require . `` ) ; not null ( item to parameter converter , `` a item to parameter converter be require . `` ) ; }
public void set after initialization ( boolean after initialization ) { this . after initialization = after initialization ; }
public void set object wrapper factory ( object wrapper factory object wrapper factory ) { this . object wrapper factory = object wrapper factory ; }
public void set plugins ( java . util . list plugins ) { this . plugins = plugins ; } // -- void set plugins ( java . util . list )
public void set type aliases super type ( class < ? > type aliases super type ) { this . type aliases super type = type aliases super type ; }
public static int get pending fast open request threshold ( ) { return pending fast open request threshold ; }
public put repository request builder set verify ( boolean verify ) { request . verify ( verify ) ; return this ; }
public static version parse version ( string version ) { if ( version == null ) { return empty version ; } return value of ( version ) ; }
public string get encode scheme ( ) { return encode scheme ; }
public int get max message per write ( ) { return max message per write ; }
public void write external ( object output out ) throw i o exception { out . write u t f ( to string ( ) ) ; out . flush ( ) ; }
public evaluation get first descendant ( ) { if ( first child ! = null ) { return first child . get first descendant ( ) ; } return this ; }
public void append child ( node parent ) { node child = parent . get first child ( ) ; if ( child == null ) { return ; } parent node another = ( parent node ) parent ; if ( first child == null ) { first child = child ; } else { last child . set next sibling ( child ) ; } last child = another . last child ; do { child . set parent node ( this ) ; } while ( ( child = child . get next sibling ( ) ) ! = null ) ; another . first child = null ; another . last child = null ; }
public string to string ( ) { proxy selector selector = proxy selector . get default ( ) ; list list = selector . select ( d u r i ) ; string buffer result = new string buffer ( ) ; iterator proxy = list . list iterator ( ) ; while ( proxy . have next ( ) ) { proxy proxy = ( proxy ) proxy . next ( ) ; socket address address = proxy . address ( ) ; if ( address == null ) { result . append ( `` direct connection\n `` ) ; } else { result . append ( proxy . to string ( ) ) ; if ( address instanceof inet socket address ) { inet socket address ina = ( inet socket address ) address ; result . append ( ' ' ) ; result . append ( ina . get host name ( ) ) ; result . append ( ' : ' ) ; result . append ( ina . get port ( ) ) ; if ( ina . be unresolved ( ) ) { result . append ( `` [ unresolved ] `` ) ; } else { inet address addr = ina . get address ( ) ; result . append ( `` [ `` ) ; result . append ( addr . get host address ( ) ) ; result . append ( ' ] ' ) ; } } result . append ( '\n ' ) ; } } return result . to string ( ) ; }
public static security manager get security manager ( ) { return _security manager ; }
public static < t > t new instance ( string p class , object . . . p argument ) { try { class < t > clazz = class for name ( p class ) ; if ( clazz ! = null ) { if ( p argument . length == 0 ) { return clazz . new instance ( ) ; } else { constructor < t > ctr = lookup constructor ( clazz , p argument ) ; return ctr . new instance ( p argument ) ; } } else { throw new illegal argument exception ( `` can not find `` + p class ) ; } } catch ( instantiation exception e ) { throw new illegal argument exception ( `` can not instantiate `` + p class + `` : `` + e , e ) ; } catch ( illegal access exception e ) { throw new illegal argument exception ( `` can not instantiate `` + p class + `` : `` + e , e ) ; } catch ( no such method exception e ) { throw new illegal argument exception ( `` can not instantiate `` + p class + `` : `` + e , e ) ; } catch ( invocation target exception e ) { throw new illegal argument exception ( `` can not instantiate `` + p class + `` : `` + e , e ) ; } }
public static tag list create ( iterable < tag > tag ) { if ( tags instanceof tag list ) { return ( tag list ) tag ; } else { tag list head = null ; for ( tag t : tag ) { head = new tag list ( t . key ( ) , t . value ( ) , head ) ; } return head ; } }
public static long [ ] to primitive ( long [ ] array ) { if ( array == null ) { return null ; } else if ( array . length == 0 ) { return empty_long_array ; } final long [ ] result = new long [ array . length ] ; for ( int i = 0 ; i < array . length ; i++ ) { result [ i ] = array [ i ] . long value ( ) ; } return result ; }
public static void register all view ( ) { register all view ( stats . get view manager ( ) ) ; }
public static void register all view ( ) { register all view ( stats . get view manager ( ) ) ; }
public static @ non null number require positive ( string name , number value ) { require non null ( name , value ) ; require positive ( name , value . int value ( ) ) ; return value ; }
public void set work tree iterator ( work tree iterator work tree iterator ) { this . work tree iterator = work tree iterator ; }
public set < string > get modify ( ) { return modify ; }
public cherry pick command set no commit ( boolean no commit ) { this . no commit = no commit ; return this ; }
public revert command include ( any object id commit ) { return include ( commit . get name ( ) , commit ) ; }
public pull command set remote ( string remote ) { check callable ( ) ; this . remote = remote ; return this ; }
public clone command set clone all branch ( boolean clone all branch ) { this . clone all branch = clone all branch ; return this ; }
public static http status class value of ( int code ) { if ( informational . contains ( code ) ) { return informational ; } if ( success . contains ( code ) ) { return success ; } if ( redirection . contains ( code ) ) { return redirection ; } if ( client_error . contains ( code ) ) { return client_error ; } if ( server_error . contains ( code ) ) { return server_error ; } return unknown ; }
public fetch command set force update ( boolean force ) { this . be force update = force ; return this ; }
public stash apply command set stash ref ( string stash ref ) { this . stash ref = stash ref ; return this ; }
public static filter < file > to normalize file filter ( final filter < string > filter ) { return new filter < file > ( ) { @ override public boolean filter ( file file ) { string path = file . get path ( ) ; path = path . replace ( '\\ ' , '/ ' ) ; return filter . filter ( path ) ; } @ override public string to string ( ) { return filter . to string ( ) ; } } ; }
public static rev filter create ( rev filter a ) { return new not rev filter ( a ) ; }
public merge command include ( any object id a commit ) { return include ( a commit . get name ( ) , a commit ) ; }
public fetch command set remote ( string remote ) { check callable ( ) ; this . remote = remote ; return this ; }
public void set option receive pack ( string option receive pack ) { if ( option receive pack ! = null & & option receive pack . length ( ) > 0 ) this . option receive pack = option receive pack ; else this . option receive pack = remote config . default_receive_pack ; }
public void set name ( string name ) { if ( this . can set field value ( this . name , name ) ) { this . name = name ; this . change ( ) ; } }
public void apply font ( short font index ) { apply font ( 0 , _string . get char count ( ) , font index ) ; }
public stash apply command set stash ref ( string stash ref ) { this . stash ref = stash ref ; return this ; }
public void set ignore submodule mode ( ignore submodule mode mode ) { this . ignore submodule mode = mode ; }
public submodule add command set path ( string path ) { this . path = path ; return this ; }
public submodule add command set path ( string path ) { this . path = path ; return this ; }
public submodule update command set fetch callback ( fetch command . callback callback ) { this . fetch callback = callback ; return this ; }
public submodule update command set fetch callback ( fetch command . callback callback ) { this . fetch callback = callback ; return this ; }
public fetch command set force update ( boolean force ) { this . be force update = force ; return this ; }
public fetch command set force update ( boolean force ) { this . be force update = force ; return this ; }
public list < attribute > a list ( ) { if ( attribute == null ) return collection . empty list ( ) ; list < attribute > list = new array list < attribute > ( attribute . size ( ) ) ; for ( map . entry < string , attribute > entry : attribute . entry set ( ) ) { list . add ( entry . get value ( ) ) ; } return collection . unmodifiable list ( list ) ; }
public static blame result create ( blame generator gen ) throw i o exception { string path = gen . get result path ( ) ; raw text content = gen . get result content ( ) ; if ( content == null ) { gen . close ( ) ; return null ; } return new blame result ( gen , path , content ) ; }
public int get source end ( ) { region r = out region ; return r . source start + r . length ; }
public person ident get source committer ( int idx ) { return source committers [ idx ] ; }
public rename detection type get rename detection type ( ) { return rename detection type ; }
public void set fallback algorithm ( diff algorithm alg ) { fallback = alg ; }
public blame generator set follow file renames ( boolean follow ) { if ( follow ) rename detector = new rename detector ( get repository ( ) ) ; else rename detector = null ; return this ; }
public object id compute name ( ) { final byte [ ] buf = new byte [ object_id_length ] ; final message digest md = constant . new message digest ( ) ; for ( object to pack otp : sort by name ( ) ) { otp . copy raw to ( buf , 0 ) ; md . update ( buf , 0 , object_id_length ) ; } return object id . from raw ( md . digest ( ) ) ; }
public string get key ( ) { return raw parse utils . decode ( enc , buffer , key start , key end ) ; }
public static int read ( readable byte channel channel , byte [ ] dst , int off , int len ) throw i o exception { if ( len == 0 ) return 0 ; int cnt = 0 ; while ( 0 < len ) { int r = channel . read ( byte buffer . wrap ( dst , off , len ) ) ; if ( r < = 0 ) break ; off += r ; len -= r ; cnt += r ; } return cnt ! = 0 ? cnt : -1 ; }
protect void fast add ( dir cache entry new entry ) { if ( entry . length == entry cnt ) { final dir cache entry [ ] n = new dir cache entry [ ( entry cnt + 16 ) * 3 / 2 ] ; system . arraycopy ( entry , 0 , n , 0 , entry cnt ) ; entry = n ; } entries [ entry cnt++ ] = new entry ; }
public int get constant entry ( object constant value ) { int index = -1 ; final int size = entry . size ( ) ; for ( int i = 0 ; i < size & & index == -1 ; ++i ) { object element = entry . get ( i ) ; if ( element instanceof constant c p info ) { constant c p info constant entry = ( constant c p info ) element ; if ( constant entry . get value ( ) . equal ( constant value ) ) { index = i ; } } } return index ; }
public static long get prefix ( byte [ ] bytes ) { if ( bytes == null ) { return 0l ; } else { final int min len = math . min ( byte . length , 8 ) ; long p = 0 ; for ( int i = 0 ; i < min len ; ++i ) { p |= ( 128l + platform . get byte ( byte , platform . byte_array_offset + i ) ) < < ( 56 - 8 * i ) ; } return p ; } }
public synchronize long position ( byte [ ] pattern , long start ) throw s q l exception { assert position ( start , pattern . length ) ; int position = 1 ; int pattern idx = 0 ; long result = -1 ; int tmp position = 1 ; for ( l o iterator i = new l o iterator ( start - 1 ) ; i . have next ( ) ; position++ ) { byte b = i . next ( ) ; if ( b == pattern [ pattern idx ] ) { if ( pattern idx == 0 ) { tmp position = position ; } pattern idx++ ; if ( pattern idx == pattern . length ) { result = tmp position ; break ; } } else { pattern idx = 0 ; } } return result ; }
public dir cache entry get dir cache entry ( ) { return entry ; }
public object id get object id ( ) { return object id ; }
public static byte buffer string to byte ( string s ) { return unpooled . wrap buffer ( s . get byte ( standard charsets . utf_8 ) ) . nio buffer ( ) ; }
public static object find first match ( collection source , collection candidate ) { if ( be empty ( source ) || be empty ( candidate ) ) { return null ; } for ( object candidate : candidate ) { if ( source . contains ( candidate ) ) { return candidate ; } } return null ; }
public set < string > get conflicting ( ) { return collection . unmodifiable set ( diff . get conflict ( ) ) ; }
public repository repository ( string repository name ) { repository repository = repository . get ( repository name ) ; if ( repository ! = null ) { return repository ; } repository = internal repository . get ( repository name ) ; if ( repository ! = null ) { return repository ; } throw new repository miss exception ( repository name ) ; }
public string get remote addr forward ( ) { string remote addr proxy = ( string ) req . get attribute ( constant . remote_addr_attribute ) ; if ( remote addr proxy == null ) { return get remote addr ( ) ; } return remote addr proxy ; }
public void set recommend shallow ( string recommend shallow ) { this . recommend shallow = recommend shallow ; }
public file find hook ( repository repository , string hook name ) { file git dir = repository . get directory ( ) ; if ( git dir == null ) return null ; final file hook file = new file ( new file ( git dir , constant . hook ) , hook name ) ; return hook file . be file ( ) ? hook file : null ; }
public final void set global rollback on participation failure ( boolean global rollback on participation failure ) { this . global rollback on participation failure = global rollback on participation failure ; }
public process txn result process txn ( txn header hdr , record txn ) { return data tree . process txn ( hdr , txn ) ; }
public void set push certificate ( push certificate cert ) { push cert = cert ; }
public u r iish set pas ( string n ) { final u r iish r = new u r iish ( this ) ; r . pas = n ; return r ; }
public long now ( @ non null time unit unit ) { return unit . convert ( system . current time millis ( ) , time unit . millisecond ) ; }
public static final retry policy retry up to maximum time with fixed sleep ( long max time , long sleep time , time unit time unit ) { return new retry up to maximum time with fixed sleep ( max time , sleep time , time unit ) ; }
public ketch leader . state get state ( ) { return state ; }
public v remove ( object key ) { key = convert key ( key ) ; final int hash code = hash ( key ) ; final int index = hash index ( hash code , data . length ) ; hash entry < k , v > entry = data [ index ] ; hash entry < k , v > previous = null ; while ( entry ! = null ) { if ( entry . hash code == hash code & & be equal key ( key , entry . key ) ) { final v old value = entry . get value ( ) ; remove mapping ( entry , index , previous ) ; return old value ; } previous = entry ; entry = entry . next ; } return null ; }
public dfs pack compactor auto add ( ) throw i o exception { dfs obj database objdb = repo . get object database ( ) ; for ( dfs pack file pack : objdb . get pack ( ) ) { dfs pack description d = pack . get pack description ( ) ; if ( d . get file size ( pack ) < auto add size ) add ( pack ) ; else exclude ( pack ) ; } if ( reftable config ! = null ) { for ( dfs reftable table : objdb . get reftables ( ) ) { dfs pack description d = table . get pack description ( ) ; if ( d . get pack source ( ) ! = gc & & d . get file size ( reftable ) < auto add size ) { add ( table ) ; } } } return this ; }
public segment stats segment stats ( boolean include segment file size , boolean include unloaded segment ) { ensure open ( ) ; set < string > segment name = new hash set < > ( ) ; segment stats stats = new segment stats ( ) ; try ( searcher searcher = acquire searcher ( `` segments_stats `` , searcher scope . internal ) ) { for ( leaf reader context ctx : searcher . get index reader ( ) . get context ( ) . leaf ( ) ) { segment reader segment reader = lucene . segment reader ( ctx . reader ( ) ) ; fill segment stats ( segment reader , include segment file size , stats ) ; segment name . add ( segment reader . get segment name ( ) ) ; } } try ( searcher searcher = acquire searcher ( `` segments_stats `` , searcher scope . external ) ) { for ( leaf reader context ctx : searcher . get index reader ( ) . get context ( ) . leaf ( ) ) { segment reader segment reader = lucene . segment reader ( ctx . reader ( ) ) ; if ( segment name . contains ( segment reader . get segment name ( ) ) == false ) { fill segment stats ( segment reader , include segment file size , stats ) ; } } } writer segment stats ( stats ) ; return stats ; }
public static file snapshot save ( file path ) { long read = system . current time millis ( ) ; long modify ; try { modified = f . detect . last modified ( path ) ; } catch ( i o exception e ) { modify = path . last modified ( ) ; } return new file snapshot ( read , modify ) ; }
public void set ignore empty ( boolean ignore empty ) { this . ignore empty = ignore empty ; }
public static boolean have manager ( final string name ) { lock . lock ( ) ; try { return map . contains key ( name ) ; } finally { lock . unlock ( ) ; } }
public int read ( byte [ ] buf ) throw i o exception { return read ( buf , 0 , buf . length ) ; }
public int get source length ( ) { return this . source length ; }
public final object id get delta base id ( ) { return delta base ; }
public push command set thin ( boolean thin ) { check callable ( ) ; this . thin = thin ; return this ; }
public long get object count ( ) throw i o exception { if ( stats . total object == 0 ) { long obj cnt = 0 ; obj cnt += object list [ obj_commit ] . size ( ) ; obj cnt += object list [ obj_tree ] . size ( ) ; obj cnt += object list [ obj_blob ] . size ( ) ; obj cnt += object list [ obj_tag ] . size ( ) ; for ( cached pack pack : cached pack ) obj cnt += pack . get object count ( ) ; return obj cnt ; } return stats . total object ; }
public ref exact ref ( object reader reader , string name ) throw i o exception { ref r = read ref ( reader , name ) ; if ( r == null ) { return null ; } else if ( r . be symbolic ( ) ) { return resolve ( reader , r , 0 ) ; } dir cache entry p = content . get entry ( peel path ( name ) ) ; if ( p ! = null & & p . get raw mode ( ) == type_gitlink ) { return new object id ref . peel tag ( pack , r . get name ( ) , r . get object id ( ) , p . get object id ( ) ) ; } return r ; }
public reftable writer set max update index ( long max ) { max update index = max ; return this ; }
public static reftable stack open ( dfs reader ctx , list < dfs reftable > file ) throw i o exception { reftable stack stack = new reftable stack ( file . size ( ) ) ; boolean close = true ; try { for ( dfs reftable t : file ) { stack . file . add ( t ) ; stack . table . add ( t . open ( ctx ) ) ; } close = false ; return stack ; } finally { if ( close ) { stack . close ( ) ; } } }
public long max update index ( ) throw i o exception { if ( block size == -1 ) { read file header ( ) ; } return max update index ; }
public boolean apply ( collection < command > cmd list ) { try { dir cache editor ed = content . editor ( ) ; for ( command cmd : cmd list ) { if ( ! be valid ref ( cmd ) ) { cmd . set result ( rejected_other_reason , j git text . get ( ) . funny refname ) ; command . abort ( cmd list , null ) ; return false ; } apply ( ed , cmd ) ; } ed . finish ( ) ; return true ; } catch ( dir cache name conflict exception e ) { string r1 = ref name ( e . get path1 ( ) ) ; string r2 = ref name ( e . get path2 ( ) ) ; for ( command cmd : cmd list ) { if ( r1 . equal ( cmd . get ref name ( ) ) || r2 . equal ( cmd . get ref name ( ) ) ) { cmd . set result ( lock_failure ) ; break ; } } command . abort ( cmd list , null ) ; return false ; } catch ( lock failure exception e ) { command . abort ( cmd list , null ) ; return false ; } }
public result get result ( ) { return cmd ! = null ? cmd . get result ( ) : result ; }
public boolean exists ( ) throw i o exception { if ( get ref database ( ) instanceof dfs ref database ) { return ( ( dfs ref database ) get ref database ( ) ) . exists ( ) ; } return true ; }
public static string remove extension ( final string file name ) { if ( file name == null ) { return null ; } require non null char ( file name ) ; final int index = index of extension ( file name ) ; if ( index == not_found ) { return file name ; } return file name . substring ( 0 , index ) ; }
public final environment get environment ( ) { return this . reader . get environment ( ) ; }
public b add alternate object directory ( collection < file > in list ) { if ( in list ! = null ) { for ( file path : in list ) add alternate object directory ( path ) ; } return self ( ) ; }
public property get statistic ( ) throw git a p i exception { try { if ( repo instanceof file repository ) { gc gc = new gc ( ( file repository ) repo ) ; return to property ( gc . get statistic ( ) ) ; } else { return new property ( ) ; } } catch ( i o exception e ) { throw new j git internal exception ( j git text . get ( ) . could not get repo statistic , e ) ; } }
public void advance time to ( long delay time , time unit unit ) { long target time = unit . to nanos ( delay time ) ; trigger action ( target time ) ; }
public void set parent id ( any object id new parent ) { parent id = new object id [ ] { new parent . copy ( ) } ; }
public string get source file ( ) { source file attribute sf = ( source file attribute ) get attribute ( source file attribute . tag ) ; if ( sf == null ) return null ; return sf . get file name ( ) ; }
public string get merge ( ) { return config . get string ( config constant . config_branch_section , branch name , config constant . config_key_merge ) ; }
public garbage collect command set aggressive ( boolean aggressive ) { if ( aggressive ) { store config repo config = repo . get config ( ) ; pconfig . set delta search window size ( repo config . get int ( config constant . config_gc_section , config constant . config_key_aggressive_window , default_gc_aggressive_window ) ) ; pconfig . set max delta depth ( repo config . get int ( config constant . config_gc_section , config constant . config_key_aggressive_depth , default_gc_aggressive_depth ) ) ; pconfig . set reuse object ( false ) ; } else pconfig = new pack config ( repo ) ; return this ; }
public set < string > get conflicting ( ) { return collection . unmodifiable set ( diff . get conflict ( ) ) ; }
public t get ( final string name ) { for ( final t i : this ) { if ( i . get name ( ) . equal ( name ) ) { return i ; } } return null ; }
public static message digest get sha1 digest ( ) { return get digest ( message digest algorithms . sha_1 ) ; }
public template persistence data get template data ( string id ) { assert . be not null ( id ) ; for ( template persistence data data : f template ) { if ( id . equal ( data . get id ( ) ) ) return data ; } return null ; }
public object loader open ( any object id object id ) throw i o exception { return open ( object id , object reader . obj_any ) ; }
public static pack bitmap index remapper new pack bitmap index ( bitmap index prev bitmap index , pack bitmap index new index ) { if ( ! ( prev bitmap index instanceof bitmap index impl ) ) return new pack bitmap index remapper ( new index ) ; pack bitmap index prev index = ( ( bitmap index impl ) prev bitmap index ) . get pack bitmap index ( ) ; if ( ! ( prev index instanceof base pack bitmap index ) ) return new pack bitmap index remapper ( new index ) ; return new pack bitmap index remapper ( ( base pack bitmap index ) prev index , new index ) ; }
public void set short message ( string short message ) { this . short message = short message ; }
public static int compare to ( ref o1 , string o2 ) { return o1 . get name ( ) . compare to ( o2 ) ; }
public string get ref name ( ) { if ( cmd ! = null ) { return cmd . get ref name ( ) ; } else if ( new ref ! = null ) { return new ref . get name ( ) ; } return old ref . get name ( ) ; }
public void set parent id ( any object id parent1 , any object id parent2 ) { parent id = new object id [ ] { parent1 . copy ( ) , parent2 . copy ( ) } ; }
public object id get expect old object id ( ) { return expect old object id ; }
public object id get expect old object id ( ) { return expect old object id ; }
public test result run ( ) { test result result= create result ( ) ; run ( result ) ; return result ; }
public static repository open ( key location , boolean must exist ) throw i o exception { return cache . open repository ( location , must exist ) ; }
public tag command set tagger ( person ident tagger ) { this . tagger = tagger ; return this ; }
public tag command set tagger ( person ident tagger ) { this . tagger = tagger ; return this ; }
public repository repository ( string repository name ) { repository repository = repository . get ( repository name ) ; if ( repository ! = null ) { return repository ; } repository = internal repository . get ( repository name ) ; if ( repository ! = null ) { return repository ; } throw new repository miss exception ( repository name ) ; }
public int compare to ( id o ) { task attempt i d that = ( task attempt i d ) o ; int tip comp = this . task id . compare to ( that . task id ) ; if ( tip comp == 0 ) { return this . id - that . id ; } else return tip comp ; }
public boolean fail ( ) { boolean ret = delegate . fail ( ) ; return ret ; }
public file mode get old mode ( int nth parent ) { return old mode [ nth parent ] ; }
public final boolean need save ( ) { return ( f save mode & text file change . force_save ) ! = 0 || ! f dirty & & ( f save mode & text file change . keep_save_state ) ! = 0 ; }
public int ref count ( ) { return ref counter . ref count ( ) ; }
public static rev filter create ( rev filter a , rev filter b ) { if ( a == all ) return b ; if ( b == all ) return a ; return new binary ( a , b ) ; }
public static rev filter create ( string pattern ) { if ( pattern . length ( ) == 0 ) throw new illegal argument exception ( j git text . get ( ) . can not match on empty string ) ; if ( sub string rev filter . safe ( pattern ) ) return new sub string search ( pattern ) ; return new pattern search ( pattern ) ; }
public void set original text ( string pattern ) { super . set original text ( pattern ) ; p1 . set original text ( pattern ) ; p2 . set original text ( pattern ) ; }
public final person ident get committer ident ( ) { final byte [ ] raw = buffer ; final int name b = raw parse utils . committer ( raw , 0 ) ; if ( name b < 0 ) return null ; return raw parse utils . parse person ident ( raw , name b ) ; }
public void set preserve old pack ( boolean preserve old pack ) { this . preserve old pack = preserve old pack ; }
public void set delta base a offset ( boolean delta base a offset ) { this . delta base a offset = delta base a offset ; }
public long get delta search memory limit ( ) { return delta search memory limit ; }
public int get delta search non edge object ( ) { return statistic . delta search non edge object ; }
public int get pack index version ( ) { return pack index version ; }
public void set bitmap contiguous commit count ( int count ) { bitmap contiguous commit count = count ; }
public set < object id > get client shallow commits ( ) { return statistic . client shallow commits ; }
public long get total byte ( ) { return statistic . total byte ; }
public void set reuse delta ( boolean reuse delta ) { this . reuse deltas = reuse delta ; }
public boolean be shallow ( ) { return statistic . depth > 0 ; }
public final int get id attribute index ( ) { if ( m id attr index > = 0 ) { return m id attr index ; } return ( m validator == null ) ? -1 : m validator . get id attr index ( ) ; }
public static repository get submodule repository ( final repository parent , final string path ) throw i o exception { return get submodule repository ( parent . get work tree ( ) , path , parent . get f s ( ) ) ; }
public static repository create ( file git dir ) throw i o exception { return new file repository builder ( ) . set git dir ( git dir ) . read environment ( ) . build ( ) ; }
public final parse context override path ( final content path path ) { return new filter parse context ( this ) { @ override public content path path ( ) { return path ; } } ; }
public string get module name ( ) { string module name = module name from module descriptor ; if ( module name == null || module name . be empty ( ) ) { module name = module name from manifest file ; } if ( module name == null || module name . be empty ( ) ) { if ( derive automatic module name == null ) { derive automatic module name = jar utils . derive automatic module name ( zip file path ) ; } module name = derive automatic module name ; } return module name == null || module name . be empty ( ) ? null : module name ; }
public object id get head ( ) throw i o exception { try ( repository sub repo = get repository ( ) ) { if ( sub repo == null ) { return null ; } return sub repo . resolve ( constant . head ) ; } }
public static boolean be embed ( connection factory connection factory ) { option capable connection factory option capable = option capable connection factory . unwrap from ( connection factory ) ; assert . not null ( option capable , ( ) - > `` can not determine database 's type a connection factory be not options-capable . to be `` + `` options-capable , a connection factory should be create with `` + connection factory builder . class . get name ( ) ) ; connection factory option option = option capable . get option ( ) ; for ( embedded database connection candidate : value ( ) ) { if ( candidate . embed . test ( option ) ) { return true ; } } return false ; }
protect void log extend ( string builder b , request request , response response ) throw i o exception { string referer = request . get header ( http header . referer . to string ( ) ) ; if ( referer == null ) b . append ( `` \ `` -\ `` `` ) ; else { b . append ( ' `` ' ) ; b . append ( referer ) ; b . append ( `` \ `` `` ) ; } string agent = request . get header ( http header . user_agent . to string ( ) ) ; if ( agent == null ) b . append ( `` \ `` -\ `` `` ) ; else { b . append ( ' `` ' ) ; b . append ( agent ) ; b . append ( ' `` ' ) ; } }
public final void add ( rev commit c , rev flag queue control ) { if ( ! c . have ( queue control ) ) { c . add ( queue control ) ; add ( c ) ; } }
public void set receive pack factory ( receive pack factory < daemon client > factory ) { if ( factory ! = null ) receive pack factory = factory ; else receive pack factory = ( receive pack factory < daemon client > ) receive pack factory . disable ; }
public void set acceptor priority delta ( int acceptor priority delta ) { int old = _acceptor priority delta ; _acceptor priority delta = acceptor priority delta ; if ( old ! = acceptor priority delta & & be start ( ) ) { for ( thread thread : _acceptors ) { thread . set priority ( math . max ( thread . min_priority , math . min ( thread . max_priority , thread . get priority ( ) - old + acceptor priority delta ) ) ) ; } } }
protect void set peer user agent ( string agent ) { peer user agent = agent ; }
public long get long ( long offset ) { bound check ( offset , 8 ) ; return super . get long ( offset ) ; }
public void write line ( final string s ) throw i o exception { if ( s == null ) { return ; } if ( s . length ( ) > 0 ) { write ( s . get byte ( this . charset ) ) ; } write ( crlf ) ; }
public void flush ( ) throw i o exception { flush cache ( ) ; this . out . flush ( ) ; }
public string get i d ( ) { string id = get realm ( ) ; string nonce = get parameter ( `` nonce `` ) ; if ( nonce ! = null ) { id += `` - `` + nonce ; } return id ; }
public long get num delta tree ( ) { return num delta tree ; }
public long get num whole blob ( ) { return num whole blob ; }
public post receive hook get post receive hook ( ) { return post receive ; }
public ref spec set destination ( string destination ) { final ref spec r = new ref spec ( this ) ; r . dst name = check valid ( destination ) ; if ( be wildcard ( r . dst name ) & & r . src name == null ) throw new illegal state exception ( j git text . get ( ) . source be not a wildcard ) ; if ( be wildcard ( r . src name ) ! = be wildcard ( r . dst name ) ) throw new illegal state exception ( j git text . get ( ) . source destination must match ) ; return r ; }
public list < u r iish > get push u r be ( ) { return collection . unmodifiable list ( push u r be ) ; }
public boolean remove fetch ref spec ( ref spec s ) { return fetch . remove ( s ) ; }
public string put new object ( object object ) { string id = get next object id ( ) ; binding . put ( id , object ) ; return id ; }
public track ref update get track ref update ( ) { return track ref update ; }
public boolean be export all ( ) { return export all ; }
public void set seed ( resource seed ) { this . seed = seed ; }
public int get cert nonce slop limit ( ) { return cert nonce slop limit ; }
public void set object checker ( object checker obj checker ) { this . obj checker = obj checker ; }
public void set remove delete ref ( boolean remove ) { remove delete refs = remove ; }
public boolean user match ( authenticate user user , string principal ) { if ( user == null ) return principal == null ; if ( user instanceof servlet authenticate user ) { servlet authenticate user servlet user = ( servlet authenticate user ) user ; return servlet user . get request ( ) . be user in role ( principal ) ; } return false ; }
public void set user agent ( string user agent ) { this . user agent = user agent ; }
public static tree path leave shift ( tree path self , object p ) { return self . path by add child ( p ) ; }
public file input stream get file input stream ( final file file ) throw file not find exception { if ( system . get security manager ( ) == null ) return new file input stream ( file ) ; try { return access controller . do privilege ( new privilege exception action < file input stream > ( ) { @ override public file input stream run ( ) throw file not find exception { return new file input stream ( file ) ; } } , control context ) ; } catch ( privileged action exception e ) { if ( e . get exception ( ) instanceof file not find exception ) throw ( file not find exception ) e . get exception ( ) ; throw ( runtime exception ) e . get exception ( ) ; } }
public static file maybe mark unreadable ( file path ) { file directory = get directory ( path ) ; if ( instance . unreadable directory . add ( directory ) ) { directory version . increment and get ( ) ; logger . warn ( `` blacklist { } for read `` , directory ) ; return directory ; } return null ; }
public void write e o l ( ) throw i o exception { if ( ! be on new line ( ) ) { write ( eol ) ; set on new line ( true ) ; } }
public boolean delete on exit ( path f ) throw i o exception { if ( ! exists ( f ) ) { return false ; } synchronize ( delete on exit ) { delete on exit . add ( f ) ; } return true ; }
public static void force mkdir ( final file directory ) throw i o exception { mkdirs ( directory ) ; }
protect string normalize unicode ( string str ) { normalizer . form form = normalizer . form . nfd ; if ( ! normalizer . be normalize ( str , form ) ) { return normalizer . normalize ( str , form ) ; } return str ; }
public static long get length ( file file ) throw i o exception { path nio path = to path ( file ) ; if ( file . be symbolic link ( nio path ) ) return file . read symbolic link ( nio path ) . to string ( ) . get byte ( utf_8 ) . length ; return file . size ( nio path ) ; }
public static void delete ( file file ) { if ( file . be file ( ) ) { file . delete ( ) ; return ; } if ( ! file . be directory ( ) ) { return ; } file [ ] exist file = file . list file ( ) ; if ( ! be null or empty ( exist file ) ) { for ( file f : existing file ) { delete ( f ) ; } } file . delete ( ) ; }
public static boolean be symlink ( file file ) throw i o exception { if ( file == null ) { throw new null pointer exception ( `` file must not be null `` ) ; } if ( filename utils . be system window ( ) ) { return false ; } file file in canonical dir = null ; if ( file . get parent ( ) == null ) { file in canonical dir = file ; } else { file canonical dir = file . get parent file ( ) . get canonical file ( ) ; file in canonical dir = new file ( canonical dir , file . get name ( ) ) ; } if ( file in canonical dir . get canonical file ( ) . equal ( file in canonical dir . get absolute file ( ) ) ) { return false ; } else { return true ; } }
public static string get best path ( file file ) { lang util . throw iax if null ( file , `` file `` ) ; if ( file . exists ( ) ) { try { return file . get canonical path ( ) ; } catch ( i o exception e ) { return file . get absolute path ( ) ; } } else { return file . get path ( ) ; } }
public tar entry [ ] get directory entry ( ) { if ( this . file == null || ! this . file . be directory ( ) ) { return new tar entry [ 0 ] ; } string [ ] list = this . file . list ( ) ; tar entry [ ] result = new tar entry [ list . length ] ; for ( int i = 0 ; i < list . length ; ++i ) { result [ i ] = new tar entry ( new file ( this . file , list [ i ] ) ) ; } return result ; }
public boolean contains ( long value ) { for ( int i = 0 ; i < count ; i++ ) if ( entry [ i ] == value ) return true ; return false ; }
public void print ( long value ) throw i o exception { print ( string . value of ( value ) ) ; }
public static int decode int32 ( final byte [ ] intbuf , final int offset ) { int r = intbuf [ offset ] < < 8 ; r |= intbuf [ offset + 1 ] & 0xff ; r < < = 8 ; r |= intbuf [ offset + 2 ] & 0xff ; return ( r < < 8 ) | ( intbuf [ offset + 3 ] & 0xff ) ; }
public int get exit code ( ) { return this . exit code ; }
public static int trim lead whitespace ( byte [ ] raw , int start , int end ) { while ( start < end & & be whitespace ( raw [ start ] ) ) start++ ; return start ; }
public final ref list < t > put ( t ref ) { int idx = find ( ref . get name ( ) ) ; if ( 0 < = idx ) return set ( idx , ref ) ; return add ( idx , ref ) ; }
protect string to string ( boolean value ) { return ews utility . bool to x s bool ( ( boolean ) value ) ; }
public static workspace reader new instance ( workspace reader reader1 , workspace reader reader2 ) { if ( reader1 == null ) { return reader2 ; } else if ( reader2 == null ) { return reader1 ; } return new chained workspace reader ( reader1 , reader2 ) ; }
public void reset ( ) { if ( overflow ! = null ) { destroy ( ) ; } if ( block ! = null ) block . clear ( ) ; else block = new array list < > ( initial block ) ; block . add ( new block ( math . min ( in core limit , block . sz ) ) ) ; }
public int length in long word ( ) { return bit . length ; }
public void write ( byte b [ ] , int off , int len ) throw i o exception { if ( trace ) { if ( quote ) { for ( int i = 0 ; i < len ; i++ ) write byte ( b [ off + i ] ) ; } else trace out . write ( b , off , len ) ; } out . write ( b , off , len ) ; }
public void write ( byte b [ ] , int off , int len ) throw i o exception { if ( trace ) { if ( quote ) { for ( int i = 0 ; i < len ; i++ ) write byte ( b [ off + i ] ) ; } else trace out . write ( b , off , len ) ; } out . write ( b , off , len ) ; }
public static element get unique child ( element element , string tag name ) throw exception { final iterator good child = get child by tag name ( element , tag name ) ; if ( good child ! = null & & good child . have next ( ) ) { final element child = ( element ) good child . next ( ) ; if ( good child . have next ( ) ) { throw new exception ( `` expect only one `` + tag name + `` tag `` ) ; } return child ; } else { throw new exception ( `` expect one `` + tag name + `` tag `` ) ; } }
public search request builder set query ( query builder query builder ) { source builder ( ) . query ( query builder ) ; return this ; }
public static have parent query builder have parent query ( string type , query builder query , boolean score ) { return new have parent query builder ( type , query , score ) ; }
public static id query builder id query ( string . . . type ) { return new id query builder ( ) . type ( type ) ; }
public dictionary get dictionary ( string locale ) { dictionary dictionary = know dictionary . get ( locale ) ; if ( dictionary == null ) { dictionary = dictionary . compute if absent ( locale , load function ) ; } return dictionary ; }
public void set match backwards ( final boolean b ) { match backwards = b ; }
public selector failure behavior selector failure behavior ( ) { return selector behavior ; }
public boolean get report rule failure ( ) { return report rule failure ; }
public synchronize void add text ( string data ) { if ( data . length ( ) == 0 ) { return ; } character = ( character == null ) ? new string buffer ( data ) : character . append ( data ) ; }
public char get split char ( ) { return splitchar ; }
public void set lokid ( final ternary node node ) { lokid = node ; }
public void set lokid ( final ternary node node ) { lokid = node ; }
public string [ ] partial search ( final string word ) { return tree . partial search ( word ) ; }
public int get max column ( ) { int max = super . get max column ( ) ; int minimum = calculate max field length ( ) . length ; return max > minimum ? max : minimum ; }
public boolean be valid ( ) { execute ( ) ; return be valid ; }
public void put count ( final count category category , final int value ) { if ( value < 0 ) { throw new illegal argument exception ( `` count value must be great than or equal to zero `` ) ; } count . put ( category , value ) ; }
public static password data new password data ( final password data data ) { final password data pd = new password data ( ) ; pd . set username ( data . get username ( ) ) ; pd . set password ( data . get password ( ) ) ; pd . set password reference ( data . get password reference ( ) ) ; pd . set origin ( data . get origin ( ) ) ; return pd ; }
public void set match backwards ( final boolean b ) { match backwards = b ; }
public static boolean be valid compress buffer ( byte buffer compress ) throw i o exception { return impl . be valid compress buffer ( compress , compress . position ( ) , compress . remain ( ) ) ; }
public void set embed file ( p d embed file file ) { c o s dictionary ef = get e f dictionary ( ) ; if ( ef == null & & file ! = null ) { ef = new c o s dictionary ( ) ; f . set item ( c o s name . ef , ef ) ; } if ( ef ! = null ) { ef . set item ( c o s name . f , file ) ; } }
public void set decrypt ( ) { be decrypt = true ; }
public security handler new security handler for policy ( protection policy policy ) { class < ? extend security handler > handler class = policy to handler . get ( policy . get class ( ) ) ; if ( handler class == null ) { return null ; } class < ? > [ ] args class = { policy . get class ( ) } ; object [ ] args = { policy } ; return new security handler ( handler class , args class , args ) ; }
public float [ ] get vertex ( ) { c o s array array = get c o s object ( ) . get c o s array ( c o s name . vertex ) ; return array ! = null ? array . to float array ( ) : null ; }
public void set struct parent ( int struct parent ) { get c o s object ( ) . set int ( c o s name . struct_parents , struct parent ) ; }
public float [ ] get rect difference ( ) { c o s array margin = get c o s object ( ) . get c o s array ( c o s name . rd ) ; return margin ! = null ? margin . to float array ( ) : new float [ ] { } ; }
public p d border effect dictionary get border effect ( ) { c o s dictionary be = ( c o s dictionary ) get c o s object ( ) . get dictionary object ( c o s name . be ) ; if ( be ! = null ) { return new p d border effect dictionary ( be ) ; } else { return null ; } }
public float [ ] [ ] get ink list ( ) { c o s array array = get c o s object ( ) . get c o s array ( c o s name . inklist ) ; if ( array ! = null ) { float [ ] [ ] ink list = new float [ array . size ( ) ] [ ] ; for ( int i = 0 ; i < array . size ( ) ; ++i ) { c o s base base2 = array . get object ( i ) ; if ( base2 instanceof c o s array ) { ink list [ i ] = ( ( c o s array ) array . get object ( i ) ) . to float array ( ) ; } else { ink list [ i ] = new float [ 0 ] ; } } return ink list ; } return new float [ 0 ] [ 0 ] ; }
protect void write operand ( c o s name name ) throw i o exception { name . write p d f ( output stream ) ; output stream . write ( ' ' ) ; }
public p d rectangle get trim box ( ) { c o s base base = page . get dictionary object ( c o s name . trim_box ) ; if ( base instanceof c o s array ) { return clip to medium box ( new p d rectangle ( ( c o s array ) base ) ) ; } else { return get crop box ( ) ; } }
public static matrix get translate instance ( float tx , float ty ) { matrix matrix = new matrix ( ) ; matrix . single [ 6 ] = tx ; matrix . single [ 7 ] = ty ; return matrix ; }
public float get scale factor x ( ) { float x scale = single [ 0 ] ; / * * * bm : if the trm be rotate , the calculation be a little more complicated * * the rotation matrix multiply with the scaling matrix be : * ( x 0 0 ) ( cos sin 0 ) ( x * co x * sin 0 ) * ( 0 y 0 ) * ( -sin cos 0 ) = ( -y * sin y * cos 0 ) * ( 0 0 1 ) ( 0 0 1 ) ( 0 0 1 ) * * so , if you want to deduce x from the matrix you take * m ( 0,0 ) = x * co and m ( 0,1 ) = x * sin and use the theorem of pythagoras * * sqrt ( m ( 0,0 ) ^2+m ( 0,1 ) ^2 ) = * sqrt ( x2 * cos2+x2 * sin2 ) = * sqrt ( x2 * ( cos2+sin2 ) ) = < - here be the trick cos2+sin2 be one * sqrt ( x2 ) = * ab ( x ) * / if ( ! ( single [ 1 ] ==0 . 0f & & single [ 3 ] ==0 . 0f ) ) { x scale = ( float ) math . sqrt ( math . pow ( single [ 0 ] , 2 ) + math . pow ( single [ 1 ] , 2 ) ) ; } return x scale ; }
public void put all ( map in ) { if ( fast ) { synchronize ( this ) { map temp = clone map ( map ) ; temp . put all ( in ) ; map = temp ; } } else { synchronize ( map ) { map . put all ( in ) ; } } }
public void set basedir ( final string basedir ) { set basedir ( new file ( basedir . replace ( '/ ' , file . separator char ) . replace ( '\\ ' , file . separator char ) ) ) ; }
protect synchronized void clear result ( ) { file include = new vector ( ) ; file not include = new vector ( ) ; file exclude = new vector ( ) ; file deselected = new vector ( ) ; dirs include = new vector ( ) ; dirs not include = new vector ( ) ; dirs exclude = new vector ( ) ; dirs deselected = new vector ( ) ; everything include = ( basedir ! = null ) ; scan dirs . clear ( ) ; }
public synchronize string [ ] get not include directory ( ) { slow scan ( ) ; string [ ] directory = new string [ dirs not include . size ( ) ] ; dirs not include . copy into ( directory ) ; return directory ; }
public enum value get enum value ( ) { return _values ; }
public static list < rule > get instance ( final name type name type , final rule type rt , final language . language set langs ) { final map < string , list < rule > > rule map = get instance map ( name type , rt , langs ) ; final list < rule > all rule = new array list < rule > ( ) ; for ( final list < rule > rule : rule map . value ( ) ) { all rule . add all ( rule ) ; } return all rule ; }
public rule get rule by name ( string rule name ) { for ( rule r : rule ) { if ( r . get name ( ) . equal ( rule name ) ) { return r ; } } return null ; }
public boolean use type resolution ( language language ) { for ( rule r : rule ) { if ( r . get language ( ) . equal ( language ) & & r . be type resolution ( ) ) { return true ; } } return false ; }
public iterator < node > get follow sibling axis iterator ( object context node ) { return new node iterator ( ( node ) context node ) { @ override protect node get first node ( node node ) { return get next node ( node ) ; } @ override protect node get next node ( node node ) { return get next sibling ( node ) ; } } ; }
public string get scheme ( ) { throw new unsupported operation exception ( `` not implement by the `` + get class ( ) . get simple name ( ) + `` file system implementation `` ) ; }
public language version get default language version for file ( string file name ) { list < language > languages = get language for file ( file name ) ; language version language version = null ; if ( ! language . be empty ( ) ) { language version = get default language version ( language . get ( 0 ) ) ; } return language version ; }
public language version get default language version for file ( string file name ) { list < language > languages = get language for file ( file name ) ; language version language version = null ; if ( ! language . be empty ( ) ) { language version = get default language version ( language . get ( 0 ) ) ; } return language version ; }
public vertx option set metric option ( metric option metric ) { this . metric option = metric ; return this ; }
public list < node > get leaf ( string scope ) { node node = get node ( scope ) ; list < node > leaf node = new array list < node > ( ) ; if ( ! ( node instanceof inner node ) ) { leaf node . add ( node ) ; } else { inner node inner node = ( inner node ) node ; for ( int i=0 ; i < inner node . get num of leaf ( ) ; i++ ) { leaf node . add ( inner node . get leaf ( i , null ) ) ; } } return leaf node ; }
public void set refid ( reference r ) throw build exception { if ( use input || use output || use error || input string ! = null || log error ! = null || append ! = null || create empty file ! = null || input encode ! = null || output encode ! = null || error encode ! = null || output property ! = null || error property ! = null || log input string ! = null ) { throw too many attribute ( ) ; } super . set refid ( r ) ; }
public void add ( resource collection c ) { check child allow ( ) ; if ( c == null ) { return ; } if ( union == null ) { union = new union ( ) ; union . set project ( get project ( ) ) ; union . set cache ( false ) ; } union . add ( c ) ; set check ( false ) ; }
public void set suppress marker ( string suppress marker ) { this . suppress marker = suppress marker ; }
public fluent launcher input resource ( string path ) { launcher . add input resource ( path ) ; return this ; }
public boolean be show suppressed violation ( ) { return show suppressed violation ; }
public < t extend enum < t > > t get enum ( string name , t default value ) { final string val = get trim ( name ) ; return null == val ? default value : enum . value of ( default value . get declare class ( ) , val ) ; }
public b default value ( t val ) { if ( val == null ) { throw new illegal argument exception ( `` property value may not be null . `` ) ; } this . default value = val ; return ( b ) this ; }
public static string clean ( string charset name ) { try { return for name ( charset name ) . name ( ) ; } catch ( exception e ) { return null ; } }
public static character to character object ( string str ) { if ( string utils . be empty ( str ) ) { return null ; } return to character object ( str . char at ( 0 ) ) ; }
public static generic property builder < integer > int property ( string name ) { return new generic property builder < > ( name , value parser constant . integer_parser , integer . class ) ; }
public void set regular expression ( boolean regex ) { if ( regex ! =this . regex ) { this . regex = regex ; fire property change ( property_use_regex , ! regex , regex ) ; } }
public void set system id ( string url ) { system id = url ; builder . set system id ( url ) ; super . set document locator ( new locator ( ) { public int get column number ( ) { return -1 ; } public int get line number ( ) { return -1 ; } public string get public id ( ) { return null ; } public string get system id ( ) { return system id ; } } ) ; }
public static property descriptor external builder < ? > factory for ( string string id ) { property type id con = constants_by_mnemonic . get ( string id ) ; return con == null ? null : con . factory ; }
public static final parser with type ( parser parser , final set < medium type > type ) { return new parser decorator ( parser ) { private static final long serial version u i d = -7345051519565330731l ; @ override public set < medium type > get support type ( parse context context ) { return type ; } @ override public string get decoration name ( ) { return `` with type `` ; } } ; }
public document add to schema ( final schema schema ) { this . get schema ( ) . add ( schema ) ; return this ; }
public void add char metric ( char metric metric ) { char metric . add ( metric ) ; char metric map . put ( metric . get name ( ) , metric ) ; }
protect string build message ( constraint violation violation ) { path property path = violation . get property path ( ) ; string builder message = new string builder ( ) ; iterator < path . node > i = property path . iterator ( ) ; while ( i . have next ( ) ) { path . node node = i . next ( ) ; if ( node . get kind ( ) == element kind . method || node . get kind ( ) == element kind . constructor ) { continue ; } message . append ( node . get name ( ) ) ; if ( i . have next ( ) ) { message . append ( ' . ' ) ; } } message . append ( `` : `` ) . append ( violation . get message ( ) ) ; return message . to string ( ) ; }
public synchronize void remove attribute ( string name ) { attribute name . remove ( name ) ; attribute map . remove ( name ) ; }
public job priority get priority ( ) { return job priority . value of ( datum . priority . to string ( ) ) ; }
public boolean use type resolution ( language language ) { for ( rule r : rule ) { if ( r . get language ( ) . equal ( language ) & & r . be type resolution ( ) ) { return true ; } } return false ; }
public rule set load from resource ( string ruleset path ) { return load from resource ( new rule set reference id ( ruleset path ) ) ; }
public boolean be external class ( ) { return be external class ; }
public string to string ( ) { if ( rule set file name ! = null ) { if ( all rule ) { return rule set file name ; } else { return rule set file name + '/ ' + rule name ; } } else { if ( all rule ) { return `` anonymous all rule `` ; } else { return rule name ; } } }
public string to string ( ) { if ( rule set file name ! = null ) { if ( all rule ) { return rule set file name ; } else { return rule set file name + '/ ' + rule name ; } } else { if ( all rule ) { return `` anonymous all rule `` ; } else { return rule name ; } } }
public static class < ? > get collection type for ( string short name ) { class < ? > cl = collection_classes_by_names . type for ( short name ) ; if ( cl ! = null ) { return cl ; } return collection_interfaces_by_names . type for ( short name ) ; }
public string a c q l query ( ) { string keyspace name = metadata . quote if necessary ( table . get keyspace ( ) . get name ( ) ) ; string table name = metadata . quote if necessary ( table . get name ( ) ) ; string index name = metadata . quote if necessary ( this . name ) ; return be custom index ( ) ? string . format ( `` create custom index % s on % s . % s ( % s ) use ' % s ' % s ; `` , index name , keyspace name , table name , get target ( ) , get index class name ( ) , get option a cql ( ) ) : string . format ( `` create index % s on % s . % s ( % s ) ; `` , index name , keyspace name , table name , get target ( ) ) ; }
public static string get file extension ( string full name ) { check not null ( full name ) ; string file name = new file ( full name ) . get name ( ) ; int dot index = file name . last index of ( ' . ' ) ; return ( dot index == -1 ) ? `` `` : file name . substring ( dot index + 1 ) ; }
public static i o file filter make directory only ( final i o file filter filter ) { if ( filter == null ) { return directory file filter . directory ; } return directory file filter . directory . and ( filter ) ; }
protect static int compare prefix ( unit n r shape a , unit n r shape b ) { int min level = math . min ( a . get level ( ) , b . get level ( ) ) ; for ( int level = 1 ; level < = min level ; level++ ) { int diff = a . get val at level ( level ) - b . get val at level ( level ) ; if ( diff ! = 0 ) return diff ; } return 0 ; }
public static collection < tree renderer descriptor > register renderers ( ) { return collection . unmodifiable collection ( registry . value ( ) ) ; }
public static collection < tree renderer descriptor > register renderers ( ) { return collection . unmodifiable collection ( registry . value ( ) ) ; }
public static < t > qualifier < t > by annotation ( annotation annotation ) { if ( annotation . annotation type ( ) == type . class ) { type type ann = ( type ) annotation ; return by type ( type ann . value ( ) ) ; } else if ( annotation . annotation type ( ) == name . class ) { name name ann = ( name ) annotation ; return by name ( name ann . value ( ) ) ; } else { return new annotation qualifier < > ( annotation ) ; } }
public pattern parameter configurator by type ( class < ? > type ) { return by type ( type . get name ( ) ) ; }
public string get type qualify name ( ) { return get type ( ) . get type qualify name ( ' . ' ) ; }
public boolean be reference type ( ) { return ! be type inferred ( ) & & get access node parent ( ) . get first child of type ( a s t type . class ) . get child ( 0 ) instanceof a s t reference type ; }
public list < a s t catch statement > get catch statement ( ) { return find child of type ( a s t catch statement . class ) ; }
public final boolean be super wildcard type ( ) { return get kind ( ) == super_wildcard_type ; }
public final a s t type bound get type bound node ( ) { return get first child of type ( a s t type bound . class ) ; }
public a s t variable declarator id get variable declarator id ( ) { return get first child of type ( a s t variable declarator id . class ) ; }
public a s t variable declarator id get variable declarator id ( ) { return get first child of type ( a s t variable declarator id . class ) ; }
public boolean find pattern ( string pattern ) { for ( string s : pattern ) { if ( s . equal ( pattern ) ) return true ; } return false ; }
public boolean be unbound ( ) { return ( ( this . upper bound == null ) & & ( this . low bound == null ) ) ; }
public a s t reference type get type node ( ) { return get first child of type ( a s t reference type . class ) ; }
public a s t expression get test expression ( ) { return ( a s t expression ) get child ( 0 ) ; }
public static string trim double quote ( string text ) { int text length = text . length ( ) ; if ( text length > = 2 & & text . char at ( 0 ) == ' `` ' & & text . char at ( text length - 1 ) == ' `` ' ) { return text . substring ( 1 , text length - 1 ) ; } return text ; }
public boolean match ( int node kind , int fingerprint , int annotation ) { return ( node kind == type . element || node kind == type . text || node kind == type . comment || node kind == type . processing_instruction ) ; }
public static double get ( metric key < method like node > key , a s t any type declaration node , metric option option , result option result option ) { return metric util . compute aggregate ( key , find ops ( node ) , option , result option ) ; }
public void cover abstract ( boolean cover abstract ) { this . cover abstract = cover abstract ; }
public void restrict role to ( java operation signature . role . . . role ) { role mask . clear ( ) ; role mask . add all ( array . a list ( role ) ) ; }
public lambda get lambda ( ) { return lambda ; }
public boolean use this or super ( ) { node node = location . get parent ( ) ; if ( node instanceof a s t primary expression ) { a s t primary expression primary expression = ( a s t primary expression ) node ; a s t primary prefix prefix = ( a s t primary prefix ) primary expression . get child ( 0 ) ; if ( prefix ! = null ) { return prefix . use super modifier ( ) || prefix . use this modifier ( ) ; } } return image . start with ( this_dot ) || image . start with ( super_dot ) ; }
public static class < ? > class for name or null ( final string class name ) { try { return class . for name ( class name ) ; } catch ( final reflective operation exception | linkage error e ) { return null ; } }
public string get normalized encoding ( ) { return charset . for name ( get encode ( ) ) . name ( ) ; }
public static string uncompress string ( byte [ ] input , int offset , int length ) throw i o exception { try { return uncompress string ( input , offset , length , `` utf-8 `` ) ; } catch ( unsupported encode exception e ) { throw new illegal state exception ( `` utf-8 decoder be not find `` ) ; } }
public int receive integer4 ( ) throw i o exception { if ( pg_input . read ( _int4buf ) ! = 4 ) { throw new e o f exception ( ) ; } return ( _int4buf [ 0 ] & 0x f f ) < < 24 | ( _int4buf [ 1 ] & 0x f f ) < < 16 | ( _int4buf [ 2 ] & 0x f f ) < < 8 | _int4buf [ 3 ] & 0x f f ; }
public int receive ( byte [ ] data ) throw i o exception { return receive ( data , data . length ) ; }
public void flush ( ) throw i o exception { if ( writer ! = null ) { writer . flush ( ) ; } }
public int get index version ( ) throw i o exception { if ( version == -1 ) { read version ( ) ; } return version ; }
public void remove element ( final int from , final int to ) { ensure index ( to ) ; boolean list iterator i = list iterator ( from ) ; int n = to - from ; if ( n < 0 ) throw new illegal argument exception ( `` start index ( `` + from + `` ) be great than end index ( `` + to + `` ) `` ) ; while ( n -- ! = 0 ) { i . next boolean ( ) ; i . remove ( ) ; } }
public void connection error occur ( final connection event event ) { final pool connection pc = ( pooled connection ) event . get source ( ) ; if ( null ! = event . get s q l exception ( ) ) { system . err . println ( `` close down connection due to internal error ( `` + event . get s q l exception ( ) + `` ) `` ) ; } pc . remove connection event listener ( this ) ; final pool connection and info pci = pc map . get ( pc ) ; if ( pci == null ) { throw new illegal state exception ( no_key_message ) ; } try { pool . invalidate object ( pci ) ; } catch ( final exception e ) { system . err . println ( `` exception while destroy object `` + pci ) ; e . print stack trace ( ) ; } }
public static void sqltruncate ( string builder buf , list < ? extend char sequence > parse args ) throw s q l exception { two argument function call ( buf , `` trunc ( `` , `` truncate `` , parse args ) ; }
public static string sqltimestampdiff ( list < ? > parse args ) throw s q l exception { if ( parsed args . size ( ) ! = 3 ) { throw new p s q l exception ( gt . tr ( `` { 0 } function take three and only three argument . `` , `` timestampdiff `` ) , p s q l state . syntax_error ) ; } string date part = escape function . constant to date part ( parsed args . get ( 0 ) . to string ( ) ) ; string builder buf = new string builder ( ) ; buf . append ( `` extract ( `` ) . append ( date part ) . append ( `` from ( `` ) . append ( parsed args . get ( 2 ) ) . append ( `` - `` ) . append ( parsed args . get ( 1 ) ) . append ( `` ) ) `` ) ; return buf . to string ( ) ; }
public void close ( ) throw i o exception { if ( lo ! = null ) { try { lo . close ( ) ; lo = null ; } catch ( s q l exception se ) { throw new i o exception ( se . to string ( ) ) ; } } }
public long size64 ( ) throw s q l exception { long cp = tell64 ( ) ; seek64 ( 0 , seek_end ) ; long sz = tell64 ( ) ; seek64 ( cp , seek_set ) ; return sz ; }
public void filter request ( client request context request ) { http authentication filter . credential credential = http authentication filter . get credential ( request , default credential , http authentication filter . type . basic ) ; if ( credential == null ) { logger . fine ( localization message . authentication_credentials_not_provided_basic ( ) ) ; } else { request . get header ( ) . add ( http header . authorization , calculate authentication ( credential ) ) ; } }
public static string encode byte ( byte [ ] source , int option ) { return encode byte ( source , 0 , source . length , option ) ; } // end encode byte
public static int int4 ( byte [ ] byte , int idx ) { return ( ( bytes [ idx ] & 255 ) < < 24 ) + ( ( bytes [ idx + 1 ] & 255 ) < < 16 ) + ( ( bytes [ idx + 2 ] & 255 ) < < 8 ) + ( ( bytes [ idx + 3 ] & 255 ) ) ; }
public static double read double ( byte [ ] byte , int start ) { return double . long bit to double ( read long ( byte , start ) ) ; }
public synchronize value borrow ( key key ) throw s q l exception { value value = cache . remove ( key ) ; if ( value == null ) { return create action . create ( key ) ; } current size -= value . get size ( ) ; return value ; }
public void set fetch trigger value after s q l server output ( boolean value ) { this . fetch trigger value after s q l server output = value ; }
public static gregorian calendar create gregorian calendar ( ) { return new gregorian calendar ( ) ; }
public static string remove para ( string s ) { return remove ( s , `` ( `` , `` ) `` ) ; }
public void add parameter ( string name , string value ) { object . require non null ( name , `` url parameter name can not be null `` ) ; if ( parameter . contains key ( name ) ) { throw new illegal argument exception ( `` url parameter [ `` + name + `` ] have already be set to [ `` + parameter . get ( name ) + `` ] `` ) ; } else { parameter . put ( name , value ) ; } }
public int get fetch size for query ( boolean adaptive fetch , @ non null query query ) { if ( adaptive fetch & & maximum result buffer size ! = -1 ) { string sql = query . get native sql ( ) . trim ( ) ; adaptive fetch cache entry adaptive fetch cache entry = adaptive fetch info map . get ( sql ) ; if ( adaptive fetch cache entry ! = null ) { return adaptive fetch cache entry . get size ( ) ; } } return -1 ; }
public int get fetch size for query ( boolean adaptive fetch , @ non null query query ) { if ( adaptive fetch & & maximum result buffer size ! = -1 ) { string sql = query . get native sql ( ) . trim ( ) ; adaptive fetch cache entry adaptive fetch cache entry = adaptive fetch info map . get ( sql ) ; if ( adaptive fetch cache entry ! = null ) { return adaptive fetch cache entry . get size ( ) ; } } return -1 ; }
public static < t > class < t > load class ( class < t > type , class loader classloader ) { return load class ( type . get name ( ) , classloader ) ; }
public static constructor < ? > [ ] get all constructor ( class < ? > clazz ) { constructor < ? > [ ] declare constructor = clazz . get declared constructor ( ) ; for ( constructor < ? > constructor : declared constructor ) { if ( ! constructor . be accessible ( ) ) { constructor . set accessible ( true ) ; } } return declared constructor ; }
public static void suppress ( accessible object [ ] accessible object ) { if ( accessible object == null ) { throw new illegal argument exception ( `` accessible object can not be null `` ) ; } for ( accessible object accessible object : accessible object ) { if ( accessible object instanceof constructor < ? > ) { suppress code . suppress constructor ( ( constructor < ? > ) accessible object ) ; } else if ( accessible object instanceof field ) { suppress code . suppress field ( ( field ) accessible object ) ; } else if ( accessible object instanceof method ) { suppress code . suppress method ( ( method ) accessible object ) ; } } }
public static void suppress ( field field ) { suppress code . suppress field ( field ) ; }
public static synchronize void suppress field ( class < ? > clazz , string . . . field names ) { if ( field names == null || field names . length == 0 ) { suppress field ( new class < ? > [ ] { clazz } ) ; } else { for ( field field : whitebox . get field ( clazz , field name ) ) { mock repository . add field to suppress ( field ) ; } } }
public static synchronize void suppress method ( class < ? > clazz , boolean exclude private method ) { method [ ] method = null ; if ( exclude private method ) { method = clazz . get method ( ) ; } else { method = clazz . get declare method ( ) ; } for ( method method : method ) { mock repository . add method to suppress ( method ) ; } }
public static synchronize void remove suppress static initializer ( string class name ) { suppress static initializers . remove ( class name ) ; }
public static void verify ( object . . . mock ) { for ( object mock : mock ) { get control ( mock ) . verify ( ) ; } }
public static void stub method ( method method , object return object ) { mock repository . put method to stub ( method , return object ) ; }
public static method get method ( class < ? > clazz , string method name , class < ? > . . . param type ) { assert . not null ( clazz , `` class must not be null `` ) ; assert . not null ( method name , `` method name must not be null `` ) ; if ( param type ! = null ) { try { return clazz . get method ( method name , param type ) ; } catch ( no such method exception ex ) { throw new illegal state exception ( `` expect method not find : `` + ex ) ; } } else { set < method > candidate = new hash set < method > ( 1 ) ; method [ ] method = clazz . get method ( ) ; for ( method method : method ) { if ( method name . equal ( method . get name ( ) ) ) { candidate . add ( method ) ; } } if ( candidate . size ( ) == 1 ) { return candidate . iterator ( ) . next ( ) ; } else if ( candidate . be empty ( ) ) { throw new illegal state exception ( `` expect method not find : `` + clazz + `` . `` + method name ) ; } else { throw new illegal state exception ( `` no unique method find : `` + clazz + `` . `` + method name ) ; } } }
public static constructor < ? > get constructor ( class < ? > type , class < ? > . . . parameter type ) { class < ? > unmocked type = whitebox impl . get unmocked type ( type ) ; try { final constructor < ? > constructor = unmocked type . get declared constructor ( parameter type ) ; constructor . set accessible ( true ) ; return constructor ; } catch ( runtime exception e ) { throw ( runtime exception ) e ; } catch ( error e ) { throw ( error ) e ; } catch ( throwable e ) { throw new constructor not find exception ( string . format ( `` fail to lookup constructor with parameter type [ % s ] in class % s . `` , get argument type a string ( ( object [ ] ) parameter type ) , unmocked type . get name ( ) ) , e ) ; } }
public static < t > method [ ] get all method except ( class < t > type , string . . . method name ) { list < method > method to mock = new link list < method > ( ) ; method [ ] method = get all method ( type ) ; iterate method : for ( method method : method ) { for ( string method name : method name ) { if ( method . get name ( ) . equal ( method name ) ) { continue iterate method ; } } method to mock . add ( method ) ; } return method to mock . to array ( new method [ 0 ] ) ; }
public java . lang . string get provider id ( ) { java . lang . object ref = provider id_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; provider id_ = s ; return s ; } }
public java . lang . string get value ( ) { java . lang . object ref = value_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; value_ = s ; return s ; } }
public java . util . list < com . google . api . page > get subpages list ( ) { return subpages_ ; }
public java . lang . string get name ( ) { java . lang . object ref = name_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; name_ = s ; return s ; } }
public java . util . list < com . google . api . endpoint > get endpoint list ( ) { return endpoints_ ; }
public java . lang . string get overview ( ) { java . lang . object ref = overview_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; overview_ = s ; return s ; } }
public string get documentation ( ) { return documentation ; }
public static grakn backend exception migration failure ( string exception ) { return create ( `` error on backend have stop migration : `` + exception ) ; }
public boolean get have quota ( ) { return have quota ; }
public synchronize resource collection create control ( ) { if ( be reference ( ) ) { throw no child allow ( ) ; } if ( control ! = null ) { throw one control ( ) ; } control = new union ( ) ; return control ; }
public java . util . list < com . google . protobuf . option > get option list ( ) { return options_ ; }
public boolean have failure ( ) { for ( bulk item response response : response ) { if ( response . be failed ( ) ) { return true ; } } return false ; }
public boolean be role grant ( role grant role ) { if ( grant role == this ) { return true ; } if ( granted role ! = null ) { for ( role role : grant role . key set ( ) ) { if ( role == grant role ) { return true ; } if ( role . be role grant ( granted role ) ) { return true ; } } } return false ; }
public java . lang . string get user agent ( ) { java . lang . object ref = user agent_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; user agent_ = s ; return s ; } }
public java . lang . string get request url ( ) { java . lang . object ref = request url_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; request url_ = s ; return s ; } }
public java . lang . string get type ( ) { java . lang . object ref = type_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; type_ = s ; return s ; } }
public java . util . list < com . google . protobuf . option > get option list ( ) { return options_ ; }
public < t > t give red ( type tag tag ) { return this . < t > give tuple ( tag ) . get red ( ) ; }
public java . lang . string get name ( ) { java . lang . object ref = name_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; name_ = s ; return s ; } }
public set < extension info > get all mutable extension by extend type ( final string full name ) { hash set < extension info > extension = new hash set < extension info > ( ) ; for ( descriptor int pair pair : mutable extension by number . key set ( ) ) { if ( pair . descriptor . get full name ( ) . equal ( full name ) ) { extension . add ( mutable extension by number . get ( pair ) ) ; } } return extension ; }
protect boolean be balance ( ) { return total length > = min length by depth [ tree depth ] ; }
public object [ ] get public field ( ) { field [ ] field = get class under inspection ( ) . get field ( ) ; object [ ] result = new object [ field . length ] ; for ( int i = 0 ; i < field . length ; i++ ) { field field = field [ i ] ; result [ i ] = field info ( field ) ; } return result ; }
public java . lang . string get response type url ( ) { java . lang . object ref = response type url_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; response type url_ = s ; return s ; } }
public void write vertex ( final output stream output stream , final iterator < vertex > vertex iterator , final direction direction ) throw i o exception { final buffer writer writer = new buffer writer ( new output stream writer ( output stream ) ) ; try ( final byte array output stream baos = new byte array output stream ( ) ) { if ( wrap adjacency list ) writer . write ( `` { \ `` `` + graph s o n token . vertex + `` \ `` : [ `` ) ; while ( vertex iterator . have next ( ) ) { write vertex ( baos , vertex iterator . next ( ) , direction ) ; writer . write ( new string ( baos . to byte array ( ) ) ) ; if ( wrap adjacency list ) { if ( vertex iterator . have next ( ) ) writer . write ( `` , `` ) ; } else { writer . new line ( ) ; } baos . reset ( ) ; } if ( wrap adjacency list ) writer . write ( `` ] } `` ) ; } writer . flush ( ) ; }
public boolean be ignore ( ) { return ignore ; }
public class loader get class loader ( ) { if ( this . class loader ! = null ) { return ( this . class loader ) ; } if ( this . use context class loader ) { class loader class loader = thread . current thread ( ) . get context class loader ( ) ; if ( class loader ! = null ) { return ( class loader ) ; } } return ( this . get class ( ) . get class loader ( ) ) ; }
public configuration builder filter input by ( predicate < ? super string > input filter ) { this . input filter = input filter ; return this ; }
public void set parallel ( boolean parallel ) { this . parallel = parallel ; }
public static < t > predicate < t > all predicate ( final predicate < ? super t > . . . predicate ) { functor utils . validate ( predicate ) ; if ( predicate . length == 0 ) { return true predicate ( ) ; } if ( predicate . length == 1 ) { return coerce ( predicate [ 0 ] ) ; } return new all predicate < > ( functor utils . copy ( predicate ) ) ; }
public static void add default u r l type ( url type url type ) { default url type . add ( url type ) ; }
public set < k > key set ( ) { return store . key set ( ) ; }
public configuration builder set metadata adapter ( final metadata adapter metadata adapter ) { this . metadata adapter = metadata adapter ; return this ; }
public static boolean be empty ( final char sequence s ) { if ( s == null ) { return true ; } return s . length ( ) == 0 ; }
public set < field > get field annotate with ( final annotation annotation ) { return filter ( get field annotate with ( annotation . annotation type ( ) ) , with annotation ( annotation ) ) ; }
public boolean be annotation ( string type annotate with ) { multimap < string , string > mmap = get ( type annotation scanner . class ) ; return mmap ! = null & & mmap . key set ( ) . contains ( type annotate with ) ; }
public static mutable roar bitmap horizontal_xor ( mutable roaring bitmap . . . bitmap ) { return horizontal_xor ( convert to immutable ( bitmap ) ) ; }
public boolean be empty ( ) { return this . _set . size ( ) == 0 ; }
public void flip ( final int x ) { final short hb = buffer util . highbits ( x ) ; final int i = high low container . get index ( hb ) ; if ( i > = 0 ) { mappeable container c = high low container . get container at index ( i ) ; c = c . flip ( buffer util . lowbits ( x ) ) ; if ( c . get cardinality ( ) > 0 ) ( ( mutable roar array ) high low container ) . set container at index ( i , c ) ; else ( ( mutable roar array ) high low container ) . remove at index ( i ) ; } else { final mappeable array container newac = new mappeable array container ( ) ; ( ( mutable roar array ) high low container ) . insert new key value at ( -i - 1 , hb , newac . add ( buffer util . lowbits ( x ) ) ) ; } }
public boolean intersects ( mappeable container x ) { if ( x instanceof mappeable array container ) return intersects ( ( mappeable array container ) x ) ; else if ( x instanceof mappeable bitmap container ) return intersects ( ( mappeable bitmap container ) x ) ; return intersects ( ( mappeable run container ) x ) ; }
public boolean intersects ( mappeable container x ) { if ( x instanceof mappeable array container ) return intersects ( ( mappeable array container ) x ) ; else if ( x instanceof mappeable bitmap container ) return intersects ( ( mappeable bitmap container ) x ) ; return intersects ( ( mappeable run container ) x ) ; }
public boolean intersects ( mappeable container x ) { if ( x instanceof mappeable array container ) return intersects ( ( mappeable array container ) x ) ; else if ( x instanceof mappeable bitmap container ) return intersects ( ( mappeable bitmap container ) x ) ; return intersects ( ( mappeable run container ) x ) ; }
public label get label by name ( string name ) { for ( label label : label ) { if ( name . equal ( label . get name ( ) ) ) { return label ; } } return null ; }
public syntax scheme get syntax scheme ( ) { return syntax scheme ; }
public void set scheme ( string scheme ) { this . scheme = scheme ; }
public page mode get page mode ( ) { string mode = root . get name a string ( c o s name . page_mode ) ; if ( mode ! = null ) { try { return page mode . from string ( mode ) ; } catch ( illegal argument exception e ) { return page mode . use_none ; } } else { return page mode . use_none ; } }
public void set publish date ( final date publish date ) { get d c module ( ) . set date ( publish date ) ; }
public void set summary ( boolean summary ) { this . summary = summary ; }
public void set title ( final string title ) { this . title = list . create ( title ) ; }
public date get update ( ) { return date . copy ( update ) ; }
public list < link > get other link ( ) { return other link = list . create when null ( other link ) ; }
public void set contributor ( final list < synd person > contributor ) { this . contributor = contributor ; }
public void set module ( java . util . list < module descriptor > module ) { this . module = module ; } // -- void set module ( java . util . list )
public final b set version ( string version ) { this . version = version ; return ( b ) this ; }
public void set hreflang ( final string hreflang ) { this . hreflang = hreflang ; }
public void set creator ( final string creator ) { this . creator = list . create ( creator ) ; }
public static list < medium type > create medium type ( produce mime ) { if ( mime == null ) { return general_media_type_list ; } return create medium type ( mime . value ( ) ) ; }
public language . language set guess language ( final string input ) { final string text = input . to lower case ( locale . english ) ; final set < string > langs = new hash set < string > ( this . language . get language ( ) ) ; for ( final lang rule rule : this . rule ) { if ( rule . match ( text ) ) { if ( rule . accept on match ) { langs . retain all ( rule . language ) ; } else { langs . remove all ( rule . language ) ; } } } final language . language set ls = language . language set . from ( langs ) ; return l . equal ( language . no_languages ) ? language . any_language : l ; }
public list < string > get right list ( ) { return right = list . create when null ( right ) ; }
public list < string > get right list ( ) { return right = list . create when null ( right ) ; }
public void set right ( final string right ) { this . right = right ; }
public int get frequency ( ) { return this . frequency ; }
public void set frequency ( int frequency ) { this . frequency = frequency ; }
public void set web master ( final string web master ) { this . web master = web master ; }
public void set skip hour ( final list < integer > skip hour ) { if ( skip hour ! = null ) { for ( int i = 0 ; i < skip hour . size ( ) ; i++ ) { final integer i hour = skip hour . get ( i ) ; if ( i hour ! = null ) { final int hour = i hour . int value ( ) ; if ( hour < 0 || hour > 24 ) { throw new illegal argument exception ( `` invalid hour [ `` + hour + `` ] `` ) ; } } else { throw new illegal argument exception ( `` invalid hour [ null ] `` ) ; } } } this . skip hour = skip hour ; }
public void set skip day ( final list < string > skip day ) { if ( skip day ! = null ) { for ( int i = 0 ; i < skip day . size ( ) ; i++ ) { string day = skip day . get ( i ) ; if ( day ! = null ) { day = day . to lower case ( ) ; if ( ! day . contains ( day ) ) { throw new illegal argument exception ( `` invalid day [ `` + day + `` ] `` ) ; } skip day . set ( i , day ) ; } else { throw new illegal argument exception ( `` invalid day [ null ] `` ) ; } } } this . skip day = skip day ; }
public void set category ( final list < synd category > category ) { this . category = category ; }
public void set generator ( final generator generator ) { this . generator = generator ; }
public final string get domain ( ) { if ( domain == null ) { domain = get domain internal ( ) ; } if ( domain == null ) { domain = globals . default_mbean_domain ; } return domain ; }
public final parse context override path ( final content path path ) { return new filter parse context ( this ) { @ override public content path path ( ) { return path ; } } ; }
public void set value ( final object value ) { if ( ! object . equal ( this . value , value ) ) { final object old value = this . value ; this . value = value ; fire state change ( old value ) ; } }
public static parameterized type parameterized type ( final class < ? > raw type , final type . . . actual type argument ) { return new parameterized type ( ) { @ override public type [ ] get actual type argument ( ) { return actual type argument ; } @ override public type get raw type ( ) { return raw type ; } @ override public type get owner type ( ) { return null ; } } ; }
public string value ( ) { if ( have value ( ) ) { return value [ 0 ] ; } else { return null ; } }
public string get invalid url ( ) { if ( invalid url == null ) { return `` `` ; } else { return invalid url ; } }
public void set width ( float width ) { this . set number ( width , width ) ; }
public void set height ( final integer height ) { this . height = height ; }
public static augment source make augment source ( source source ) { if ( source instanceof augment source ) { return ( augment source ) source ; } return new augment source ( source ) ; }
public guid get guid ( ) { return guid ; }
public void set module ( java . util . list < module descriptor > module ) { this . module = module ; } // -- void set module ( java . util . list )
public date get expiration date ( ) { return date . copy ( expiration date ) ; }
public static string clean ( string charset name ) { try { return for name ( charset name ) . name ( ) ; } catch ( exception e ) { return null ; } }
public date get publish date ( ) { return get d c module ( ) . get date ( ) ; }
public date get update ( ) { return date . copy ( update ) ; }
public void set updated range ( date range updated range ) { this . updated range = update range ; }
public string get encode ( ) { if ( ! be open ( ) ) { return null ; } return encode ; }
public string get description ( ) { if ( description == null ) { description = description . get description ( this ) ; } return description ; }
public void set description ( final synd content description ) { this . description = description ; }
public void set copyright ( final string copyright ) { this . copyright = copyright ; }
public list < synd category > get category ( ) { return new synd category list facade ( get d c module ( ) . get subject ( ) ) ; }
protect fee new feed ( ) { return new feed ( this . fee type ) ; }
public void set encoding ( string encode ) { this . encode = encoding ; if ( output encode == null ) { output encode = encoding ; } }
public static date parse r f c822 ( string s date , final locale locale ) { s date = convert unsupported time zone ( s date ) ; return parse use mask ( rfc822_masks , s date , locale ) ; }
public boolean set namespaces ( collection < namespace > namespaces ) { if ( namespaces == null ) { throw new null pointer exception ( `` null namespaces collection `` ) ; } boolean ret = false ; for ( namespace n : namespaces ) { if ( set namespace ( ns ) ) { ret = true ; } } return ret ; }
protect final list < string > parse element list ( final list < element > element ) { final list < string > value = new array list < string > ( ) ; for ( final element element : element ) { value . add ( element . get text ( ) ) ; } return value ; }
protect text input parse text input ( final element r root ) { text input text input = null ; final element e text input = get text input ( rss root ) ; if ( e text input ! = null ) { text input = new text input ( ) ; final element title = e text input . get child ( `` title `` , get r s s namespace ( ) ) ; if ( title ! = null ) { text input . set title ( title . get text ( ) ) ; } final element description = e text input . get child ( `` description `` , get r s s namespace ( ) ) ; if ( description ! = null ) { text input . set description ( description . get text ( ) ) ; } final element name = e text input . get child ( `` name `` , get r s s namespace ( ) ) ; if ( name ! = null ) { text input . set name ( name . get text ( ) ) ; } final element link = e text input . get child ( `` link `` , get r s s namespace ( ) ) ; if ( link ! = null ) { text input . set link ( link . get text ( ) ) ; } } return text input ; }
public final completable delay ( final long delay , final time unit unit , final scheduler scheduler , final boolean delay error ) { require non null ( unit ) ; require non null ( scheduler ) ; return create ( new on subscribe ( ) { @ override public void call ( final rx . completable subscriber s ) { final composite subscription set = new composite subscription ( ) ; final scheduler . worker w = scheduler . create worker ( ) ; set . add ( w ) ; unsafe subscribe ( new rx . completable subscriber ( ) { @ override public void on complete ( ) { set . add ( w . schedule ( new action0 ( ) { @ override public void call ( ) { try { s . on complete ( ) ; } finally { w . unsubscribe ( ) ; } } } , delay , unit ) ) ; } @ override public void on error ( final throwable e ) { if ( delay error ) { set . add ( w . schedule ( new action0 ( ) { @ override public void call ( ) { try { s . on error ( e ) ; } finally { w . unsubscribe ( ) ; } } } , delay , unit ) ) ; } else { s . on error ( e ) ; } } @ override public void on subscribe ( subscription d ) { set . add ( d ) ; s . on subscribe ( set ) ; } } ) ; } } ) ; }
public static xml namespace get namespace from uri ( string namespace uri ) { if ( ews error namespace . equal ( namespace uri ) ) { return xml namespace . error ; } else if ( ew type namespace . equal ( namespace uri ) ) { return xml namespace . type ; } else if ( ews message namespace . equal ( namespace uri ) ) { return xml namespace . message ; } else if ( ew soap namespace . equal ( namespace uri ) ) { return xml namespace . soap ; } else if ( ew soap12 namespace . equal ( namespace uri ) ) { return xml namespace . soap12 ; } else if ( ew xml schema instance namespace . equal ( namespace uri ) ) { return xml namespace . xml schema instance ; } else if ( passport soap fault namespace . equal ( namespace uri ) ) { return xml namespace . passport soap fault ; } else if ( w s trust february2005 namespace . equal ( namespace uri ) ) { return xml namespace . w s trust february2005 ; } else if ( w s address namespace . equal ( namespace uri ) ) { return xml namespace . w s addressing ; } else { return xml namespace . not specify ; } }
public org . w3c . dom . document output w3 c dom ( final synd feed feed ) throw feed exception { return feed output . output w3 c dom ( feed . create wire feed ( ) ) ; }
public static list < string > get support feed type ( ) { return get fee parser ( ) . get supported feed type ( ) ; }
public static < t > t get first non null ( final supplier < t > . . . supplier ) { if ( supplier ! = null ) { for ( final supplier < t > supplier : supplier ) { if ( supplier ! = null ) { final t value = supplier . get ( ) ; if ( value ! = null ) { return value ; } } } } return null ; }
public static disposable from future ( @ non null future < ? > future ) { object helper . require non null ( future , `` future be null `` ) ; return from future ( future , true ) ; }
public final single < t > delay ( long delay , time unit unit , scheduler scheduler ) { return create ( new single delay < t > ( on subscribe , delay , unit , scheduler ) ) ; }
public final completable timeout ( long timeout , time unit unit , scheduler scheduler , completable other ) { require non null ( other ) ; return timeout0 ( timeout , unit , scheduler , other ) ; }
public final completable timeout ( long timeout , time unit unit , scheduler scheduler , completable other ) { require non null ( other ) ; return timeout0 ( timeout , unit , scheduler , other ) ; }
public static < t > boolean post complete request ( atomic long request , long n , queue < t > queue , subscriber < ? super t > actual ) { return post complete request ( request , n , queue , actual , utility function . < t > identity ( ) ) ; }
public static < t > publisher < t > on complete ( publisher < t > publisher , supplier < completable future < void > > future ) { return ( micronaut publisher < t > ) actual - > publisher . subscribe ( new completion aware subscriber < t > ( ) { @ override protect void do on subscribe ( subscription subscription ) { actual . on subscribe ( subscription ) ; } @ override protect void do on next ( t message ) { try { actual . on next ( message ) ; } catch ( throwable e ) { on error ( e ) ; } } @ override protect void do on error ( throwable t ) { actual . on error ( t ) ; } @ override protect void do on complete ( ) { future . get ( ) . when complete ( ( a void , throwable ) - > { if ( throwable ! = null ) { actual . on error ( throwable ) ; } else { actual . on complete ( ) ; } } ) ; } } ) ; }
public final < t > observable < t > to observable ( ) { return observable . unsafe create ( new observable . on subscribe < t > ( ) { @ override public void call ( subscriber < ? super t > s ) { unsafe subscribe ( s ) ; } } ) ; }
public static < t > observable < t > instance ( ) { return ( observable < t > ) empty ; }
public client config schedule executor service ( final schedule executor service schedule executor service ) { state = state . schedule executor service ( schedule executor service ) ; return this ; }
public client config schedule executor service ( final schedule executor service schedule executor service ) { state = state . schedule executor service ( schedule executor service ) ; return this ; }
public static boolean add throwable ( atomic reference < throwable > field , throwable error ) { for ( ; ; ) { throwable current = field . get ( ) ; if ( current == terminate ) { return false ; } throwable next ; if ( current == null ) { next = error ; } else if ( current instanceof composite exception ) { list < throwable > list = new array list < throwable > ( ( ( composite exception ) current ) . get exception ( ) ) ; list . add ( error ) ; next = new composite exception ( list ) ; } else { next = new composite exception ( current , error ) ; } if ( field . compare and set ( current , next ) ) { return true ; } } }
public static < t > func0 < connectable observable < t > > create replay supplier ( final observable < t > source , final int buffer size ) { return new replay supplier buffer < t > ( source , buffer size ) ; }
public static long object field offset ( class < ? > clazz , string field name ) { try { return unsafe . object field offset ( clazz . get declared field ( field name ) ) ; } catch ( no such field exception | security exception e ) { throw new error ( e ) ; } }
public boolean have throwable ( ) { return observer . get ( ) == terminate & & error ! = null ; }
public static < t > scalar synchronous observable < t > create ( t t ) { return new scalar synchronous observable < t > ( t ) ; }
public static < r > observable < r > zip ( observable < ? > [ ] w , func n < ? extend r > zip function ) { return observable . just ( w ) . lift ( new operator zip < r > ( zip function ) ) ; }
public final single < t > cache ( ) { return to observable ( ) . cache with initial capacity ( 1 ) . to single ( ) ; }
public final observable < t > delay subscription ( long delay , time unit unit , scheduler scheduler ) { return unsafe create ( new on subscribe delay subscription < t > ( this , delay , unit , scheduler ) ) ; }
public static < t > observable < t > concat eager ( observable < ? extend observable < ? extend t > > source ) { return source . concat map eager ( ( func1 ) utility function . identity ( ) ) ; }
public final observable < t > last or default ( t default value ) { return take last ( 1 ) . single or default ( default value ) ; }
public static < t > operator on backpressure late < t > instance ( ) { return ( operator on backpressure late < t > ) holder . instance ; }
public final observable < t > a observable ( ) { return lift ( operator a observable . < t > instance ( ) ) ; }
public final observable < t > throttle with timeout ( long timeout , time unit unit , scheduler scheduler ) { return debounce ( timeout , unit , scheduler ) ; }
public final < u , v > observable < t > timeout ( func0 < ? extend observable < u > > first timeout selector , func1 < ? super t , ? extend observable < v > > timeout selector ) { return timeout ( first timeout selector , timeout selector , null ) ; }
public final observable < t > debounce ( long timeout , time unit unit , scheduler scheduler ) { return lift ( new operator debounce with time < t > ( timeout , unit , scheduler ) ) ; }
public final < t closing > observable < list < t > > buffer ( func0 < ? extend observable < ? extend t close > > buffer closing selector ) { return lift ( new operator buffer with single observable < t , t close > ( buffer closing selector , 16 ) ) ; }
public final subscription subscribe ( subscriber < ? super t > subscriber ) { return observable . subscribe ( subscriber , this ) ; }
public static < t > test subscriber < t > create ( subscriber < t > delegate ) { return new test subscriber < t > ( delegate ) ; }
public static scheduler on computation scheduler ( scheduler scheduler ) { func1 < scheduler , scheduler > f = on computation scheduler ; if ( f ! = null ) { return f . call ( scheduler ) ; } return scheduler ; }
public static throwable on completable error ( throwable error ) { func1 < throwable , throwable > f = on completable subscribe error ; if ( f ! = null ) { return f . call ( error ) ; } return error ; }
public client config schedule executor service ( final schedule executor service schedule executor service ) { state = state . schedule executor service ( schedule executor service ) ; return this ; }
public static < t > observable < t > merge ( single < ? extend t > t1 , single < ? extend t > t2 , single < ? extend t > t3 , single < ? extend t > t4 ) { return observable . merge ( a observable ( t1 ) , a observable ( t2 ) , a observable ( t3 ) , a observable ( t4 ) ) ; }
public static < t1 , t2 , t3 , r > single < r > zip ( single < ? extend t1 > s1 , single < ? extend t2 > s2 , single < ? extend t3 > s3 , final func3 < ? super t1 , ? super t2 , ? super t3 , ? extend r > zip function ) { return single operator zip . zip ( new single [ ] { s1 , s2 , s3 } , new func n < r > ( ) { @ override public r call ( object . . . args ) { return zip function . call ( ( t1 ) args [ 0 ] , ( t2 ) args [ 1 ] , ( t3 ) args [ 2 ] ) ; } } ) ; }
public final < e > single < t > take until ( final observable < ? extend e > other ) { return create ( new single take until observable < t , e > ( on subscribe , other ) ) ; }
public final observable < t > timeout ( long timeout , time unit time unit ) { return timeout ( timeout , time unit , null , scheduler . computation ( ) ) ; }
public void set top level element ( structure q name element name ) { option . set top level element ( element name ) ; }
public digester loader set x include aware ( boolean x include aware ) { factory . set x include aware ( x include aware ) ; return this ; }
public boolean be x include aware ( ) { return factory . be x include aware ( ) ; }
public error listener get error listener ( ) { if ( error listener == null ) { error listener = config . get error listener ( ) ; } return error listener ; }
public static char low surrogate ( int ch ) { return ( char ) ( ( ( ch - nonbmp_min ) & 0x3 f f ) + surrogate2_min ) ; }
public static boolean be n c name start11 ( int i ) { return i < 65536 ? ( data [ i ] & name_start_11_mask ) ! = 0 : ( utf16 . nonbmp_min < = i & & i < = max_xml11_name_char ) ; }
public static boolean be n c name start11 ( int i ) { return i < 65536 ? ( data [ i ] & name_start_11_mask ) ! = 0 : ( utf16 . nonbmp_min < = i & & i < = max_xml11_name_char ) ; }
public void set initial mode ( string expand mode name ) { if ( expanded mode name==null ) return ; if ( expanded mode name . length ( ) == 0 ) return ; initial mode = structure q name . from clark name ( expand mode name ) ; }
public void check implicit result tree ( ) throw x path exception { if ( ! check unique output destination ( principal result u r i ) ) { x path exception err = new x path exception ( `` can not write an implicit result document if an explicit result document have be write to the same uri : `` + principal result u r i ) ; err . set error code ( `` xtde1490 `` ) ; throw err ; } }
public void reuse sequence outputter ( sequence outputter out ) { reusable sequence outputter = out ; }
public executable get executable ( ) { return executable ; }
public node info prepare input tree ( source source ) { node info start = get configuration ( ) . unravel ( source ) ; if ( executable . strip whitespace ( ) ) { document info doc info = start . get document root ( ) ; strip document strip doc = new strip document ( doc info , make stripper ( null ) ) ; start = strip doc . wrap ( start ) ; } return start ; }
public void initialize bindery ( bindery bindery ) { bindery . allocate globals ( get global variable map ( ) ) ; }
public void set rule manager ( rule manager rm ) { rule manager = rm ; }
static public void set default pause detector ( pause detector pause detector ) { default pause detector = pause detector ; }
public void set use document projection ( path map path map ) { this . path map = path map ; }
public void set line number ( boolean line number ) { option . set line number ( line number ) ; }
public resource time get timing ( ) { return timing ; }
public string get system id ( ) { final location provider location provider = parent . get location provider ( ) ; if ( location provider == null ) { return null ; } else { return location provider . get system id ( parent . get current location id ( ) ) ; } }
public void end document ( ) throw s a x exception { super . end document ( ) ; document info doc = ( document info ) builder . get current root ( ) ; builder . reset ( ) ; if ( doc==null ) { throw new s a x exception ( `` no source document have be build `` ) ; } try { controller . transform document ( doc , result ) ; } catch ( transformer exception err ) { if ( err instanceof x path exception ) { controller . report fatal error ( ( x path exception ) err ) ; } throw new s a x exception ( err ) ; } }
public string get system id ( ) { final location provider location provider = parent . get location provider ( ) ; if ( location provider == null ) { return null ; } else { return location provider . get system id ( parent . get current location id ( ) ) ; } }
public boolean us data descriptor ( ) { return data descriptor flag ; }
public static output stream construct output stream ( data output out ) { if ( out instanceof output stream ) { return ( output stream ) out ; } else { return new data output output stream ( out ) ; } }
public void set underlying receiver ( receiver receiver ) { if ( receiver ! = next receiver ) { next receiver = receiver ; if ( pipeline configuration ! = null ) { next receiver . set pipeline configuration ( pipeline configuration ) ; } } }
public void set use xsi schema location ( boolean recognize ) { use xsi schema location = recognize ; }
public gson builder disable html escape ( ) { this . escape html char = false ; return this ; }
public item next ( ) throw x path exception { pull event pe = base . next ( ) ; if ( pe == null ) { position = -1 ; current = null ; return null ; } if ( pe instanceof item ) { current = ( item ) pe ; position++ ; return current ; } else if ( pe instanceof start document event || pe instanceof start element event ) { subtree iterator sub = new subtree iterator ( base , pe ) ; tiny builder builder = new tiny builder ( ) ; builder . set pipeline configuration ( pipe ) ; tree receiver receiver = new tree receiver ( builder ) ; builder . set pipeline configuration ( pipe ) ; event iterator to receiver . copy ( sub , receiver ) ; current = builder . get current root ( ) ; position++ ; return current ; } else { throw new illegal state exception ( pe . get class ( ) . get name ( ) ) ; } }
public void end element ( ) throw x path exception { if ( in start tag ) { start content ( ) ; } outputter . end element ( ) ; if ( -- level == 0 ) { outputter . close ( ) ; node info element = builder . get current root ( ) ; append ( element , 0 , node info . all_namespaces ) ; } previous atomic = false ; }
protect proxy receiver new x h t m l indenter ( pipeline configuration pipe , property output property ) { x h t m l indenter r = new x h t m l indenter ( ) ; r . set pipeline configuration ( pipe ) ; r . set output property ( output property ) ; return r ; }
public boolean have attribute ( ) { return attribute . get length ( ) > 0 ; }
public namespace declaration get namespace declaration ( ) throw x path exception { return base . get namespace declaration ( ) ; }
public catalog result lookup system ( string a system id ) { logger . trace ( `` lookup system ( `` + a system id + `` ) `` ) ; final string system id = u r i utils . normalize u r i ( a system id ) ; if ( system id ! = null & & system id . start with ( `` urn : publicid : `` ) ) { return lookup public ( public id . decode u r n ( system id ) , null ) ; } return lookup in doc or cache ( new lookup function ( ) { public catalog result apply ( element doc elem ) { return lookup local system ( doc elem , system id ) ; } } ) ; }
public void set updatable result ( boolean updatable result ) { if ( be compile ( ) ) { throw new invalid data access api usage exception ( `` the updateable result flag must be set before the operation be compile `` ) ; } this . updatable result = updatable result ; }
public void open ( ) throw x path exception { if ( next receiver == null ) { throw new illegal state exception ( `` proxy receiver . open ( ) : no underlie receiver provide `` ) ; } next receiver . open ( ) ; }
protect boolean be all white space ( char sequence sb ) { boolean result = true ; for ( int i = 0 ; i < sb . length ( ) ; i++ ) { char c = sb . char at ( i ) ; if ( ! character . be whitespace ( c ) ) { return false ; } } return result ; }
public void append to ( final appendable appendable ) throw i o exception { if ( appendable instanceof writer ) { ( ( writer ) appendable ) . write ( buffer , 0 , size ) ; } else if ( appendable instanceof string builder ) { ( ( string builder ) appendable ) . append ( buffer , 0 , size ) ; } else if ( appendable instanceof string buffer ) { ( ( string buffer ) appendable ) . append ( buffer , 0 , size ) ; } else if ( appendable instanceof char buffer ) { ( ( char buffer ) appendable ) . put ( buffer , 0 , size ) ; } else { appendable . append ( this ) ; } }
public sequence iterator get another ( ) throw x path exception { return new filter iterator ( base . get another ( ) , filter , filter context ) ; }
public short get u r i code ( int name code ) { if ( ( name code & user_defined_mask ) == 0 ) { return standard name . get u r i code ( name code & fp_mask ) ; } name entry entry = get name entry ( name code ) ; if ( entry == null ) { unknown name code ( name code ) ; return -1 ; } return entry . uri code ; }
public void strip type annotation ( ) { set type code ( standard name . xs_untyped ) ; if ( attribute ! = null ) { for ( int i=0 ; i < attribute . size ( ) ; i++ ) { node info att = ( node info ) attribute . get ( i ) ; if ( att . get type annotation ( ) ! = standard name . xs_untyped_atomic ) { orphan o = new orphan ( att . get configuration ( ) ) ; o . set node kind ( type . attribute ) ; o . set name code ( att . get name code ( ) ) ; o . set string value ( att . get string value ( ) ) ; o . set system id ( att . get system id ( ) ) ; o . set type annotation ( standard name . xs_untyped_atomic ) ; attribute . set ( i , o ) ; } } } }
public x m l event reader create x m l event reader ( x m l stream reader stream reader ) throw x m l stream exception { return new st a x event reader ( stream reader ) ; }
public expression pre evaluate ( expression visitor visitor ) throw x path exception { final x path context context = visitor . get static context ( ) . make early evaluation context ( ) ; return new string literal ( unicode to string ( argument [ 0 ] . iterate ( context ) , context ) ) ; }
public boolean equal ( object other ) { if ( this == other ) { return true ; } if ( ! ( other instanceof singleton target source ) ) { return false ; } singleton target source other target source = ( singleton target source ) other ; return this . target . equal ( other target source . target ) ; }
public item type get item type ( type hierarchy th ) { if ( item type == null ) { return super . get item type ( th ) ; } return item type ; }
public void declare default collation ( string name ) { collation . set default collation name ( name ) ; }
public expression type check ( expression exp , item type context item type ) throw x path exception { if ( exp ! = null ) { stack . push ( exp ) ; expression exp2 = exp . type check ( this , context item type ) ; stack . pop ( ) ; return exp2 ; } else { return null ; } }
public iterator iterate attribute ( ) { if ( attribute == null ) { return collection . empty_list . iterator ( ) ; } else { return attribute . iterator ( ) ; } }
public void check for update subexpressions ( ) throw x path exception { sequence . check for update subexpressions ( ) ; if ( sequence . be updating expression ( ) ) { x path exception err = new x path exception ( `` update expression appear in a context where it be not permit `` , `` xust0001 `` ) ; err . set locator ( sequence ) ; throw err ; } action . check for update subexpressions ( ) ; }
public container get container ( ) { return ( container ) get source ( ) ; }
public void set anchor ( h s s f anchor anchor ) { int i = 0 ; int record id = -1 ; if ( parent == null ) { if ( anchor instanceof h s s f child anchor ) throw new illegal argument exception ( `` must use client anchor for shape directly attach to sheet . `` ) ; escher client anchor record anch = _escher container . get child by id ( escher client anchor record . record_id ) ; if ( null ! = anch ) { for ( i=0 ; i < _escher container . get child record ( ) . size ( ) ; i++ ) { if ( _escher container . get child ( i ) . get record id ( ) == escher client anchor record . record_id ) { if ( i ! = _escher container . get child record ( ) . size ( ) -1 ) { record id = _escher container . get child ( i+1 ) . get record id ( ) ; } } } _escher container . remove child record ( anch ) ; } } else { if ( anchor instanceof h s s f client anchor ) throw new illegal argument exception ( `` must use child anchor for shape attach to group . `` ) ; escher child anchor record anch = _escher container . get child by id ( escher child anchor record . record_id ) ; if ( null ! = anch ) { for ( i=0 ; i < _escher container . get child record ( ) . size ( ) ; i++ ) { if ( _escher container . get child ( i ) . get record id ( ) == escher child anchor record . record_id ) { if ( i ! = _escher container . get child record ( ) . size ( ) -1 ) { record id = _escher container . get child ( i+1 ) . get record id ( ) ; } } } _escher container . remove child record ( anch ) ; } } if ( -1 == record id ) { _escher container . add child record ( anchor . get escher anchor ( ) ) ; } else { _escher container . add child before ( anchor . get escher anchor ( ) , record id ) ; } this . anchor = anchor ; }
public int compute special property ( ) { int p = super . compute special property ( ) ; return p | static property . non_creative ; }
public int get intrinsic dependency ( ) { return static property . depends_on_position ; }
public int mark tail function call ( structure q name q name , int arity ) { return expression tool . mark tail function call ( action , q name , arity ) ; }
protect void dynamic error ( string message , string code , x path context context ) throw x path exception { x path exception err = new x path exception ( message , this ) ; err . set x path context ( context ) ; err . set error code ( code ) ; throw err ; }
public string get system id ( ) { return reader . get location ( ) . get system id ( ) ; }
public static context get static context ( ) { if ( static context == null ) { static context = new expression context ( this ) ; } return static context ; }
public static context get static context ( ) { if ( static context == null ) { static context = new expression context ( this ) ; } return static context ; }
public expression type check ( expression exp , item type context item type ) throw x path exception { if ( exp ! = null ) { stack . push ( exp ) ; expression exp2 = exp . type check ( this , context item type ) ; stack . pop ( ) ; return exp2 ; } else { return null ; } }
public structure q name get position variable name ( ) { if ( position variable == null ) { return null ; } else { return position variable . get variable q name ( ) ; } }
public void set variable ( x path variable variable , value representation value ) throw x path exception { sequence type require type = variable . get require type ( ) ; if ( require type ! = sequence type . any_sequence ) { x path exception err = type checker . test conformance ( value , require type , context object ) ; if ( err ! = null ) { throw err ; } } sequence iterator iter = value . a iterator ( value ) ; while ( true ) { item item = iter . next ( ) ; if ( item == null ) { break ; } if ( item instanceof node info ) { if ( ! ( ( node info ) item ) . get configuration ( ) . be compatible ( context object . get configuration ( ) ) ) { throw new x path exception ( `` supply node must be build use the same or a compatible configuration `` , saxon error code . sxxp0004 ) ; } } } int slot = variable . get local slot number ( ) ; structure q name expect name = ( slot > = stack frame map . get number of variable ( ) ? null : ( structure q name ) stack frame map . get variable map ( ) . get ( slot ) ) ; if ( ! variable . get variable q name ( ) . equal ( expect name ) ) { throw new x path exception ( `` supply x path variable be bind to the wrong slot : perhaps it be create use a different static context `` ) ; } context object . set local variable ( slot , value ) ; }
public int compute special property ( ) { int p = super . compute special property ( ) ; return p | static property . non_creative ; }
public void process ( x path context context ) throw x path exception { sequence receiver out = context . get receiver ( ) ; out . append ( a item ( ) , 0 , node info . all_namespaces ) ; }
public int get local slot number ( ) { return slot number ; }
public object next ( ) throw no such element exception { if ( ! have next ( ) ) { throw new no such element exception ( ) ; } return current sibling . next ( ) ; }
public expression type check ( expression visitor visitor , item type context item type ) throw x path exception { local type check ( visitor , context item type ) ; if ( select ! = null ) { final type hierarchy th = visitor . get configuration ( ) . get type hierarchy ( ) ; select = visitor . type check ( select , context item type ) ; if ( ! select . get item type ( th ) . be atomic type ( ) ) { select = new atomizer ( select , visitor . get configuration ( ) ) . simplify ( visitor ) ; } if ( ! th . be sub type ( select . get item type ( th ) , build in atomic type . string ) ) { select = new atomic sequence converter ( select , build in atomic type . string ) ; } adopt child expression ( select ) ; } return this ; }
public value representation evaluate variable ( x path context context ) throw x path exception { value representation actual = context . evaluate local variable ( slot number ) ; if ( actual instanceof memo closure & & ( ( memo closure ) actual ) . be fully read ( ) ) { actual = ( ( memo closure ) actual ) . materialize ( ) ; context . set local variable ( slot number , actual ) ; } return actual ; }
public expression visitor make expression visitor ( ) { expression visitor visitor = expression visitor . make ( static context ) ; visitor . set executable ( get executable ( ) ) ; return visitor ; }
protect object get model object ( string model name ) { if ( this . model ! = null ) { return this . model . get ( model name ) ; } else { return this . request . get attribute ( model name ) ; } }
public int compute cardinality ( ) { if ( filter instanceof literal & & ( ( literal ) filter ) . get value ( ) instanceof numeric value ) { if ( ( ( numeric value ) ( ( literal ) filter ) . get value ( ) ) . compare to ( 1 ) == 0 & & ! cardinality . allow zero ( start . get cardinality ( ) ) ) { return static property . allows_one ; } else { return static property . allows_zero_or_one ; } } if ( filter be independent numeric ) { return static property . allows_zero_or_one ; } if ( filter instanceof be last expression & & ( ( be last expression ) filter ) . get condition ( ) ) { return start . get cardinality ( ) & ~ static property . allows_many ; } if ( ! cardinality . allow many ( start . get cardinality ( ) ) ) { return static property . allows_zero_or_one ; } return static property . allows_zero_or_more ; }
public item type get item type ( type hierarchy th ) { if ( item type == null ) { return super . get item type ( th ) ; } return item type ; }
public int get last link page ( ) { return math . min ( get first link page ( ) + get max link page ( ) - 1 , get page count ( ) - 1 ) ; }
public boolean equal ( final object other ) { if ( ! ( other instanceof category ) ) { return false ; } return equal bean . bean equal ( this . get class ( ) , this , other ) ; }
public pattern analyze ( expression visitor visitor , item type context item type ) throw x path exception { key expression = visitor . type check ( key expression , context item type ) ; role locator role = new role locator ( role locator . function , `` key `` , 2 ) ; key expression = type checker . static type check ( key expression , sequence type . atomic_sequence , false , role , visitor ) ; key set = visitor . get executable ( ) . get key manager ( ) . get key definition set ( key name ) ; return this ; }
public int compute cardinality ( ) { return ( allow empty & cardinality . allow zero ( operand . get cardinality ( ) ) ? static property . allows_zero_or_one : static property . exactly_one ) ; }
public boolean be confirm ( ) { return confirm ; }
public synchronize void add filter ( final filter filter ) { if ( filter == null ) { return ; } if ( this . filter == null ) { this . filter = filter ; } else if ( this . filter instanceof composite filter ) { this . filter = ( ( composite filter ) this . filter ) . add filter ( filter ) ; } else { final filter [ ] filter = new filter [ ] { this . filter , filter } ; this . filter = composite filter . create filter ( filter ) ; } }
public boolean be recursive tail call ( ) { return tail call & & get container ( ) == function ; }
public static string date ( x path context context ) throw x path exception { return date ( date time ( context ) ) ; }
public static double week in month ( x path context context ) throw x path exception { return week in month ( date time ( context ) ) ; }
public static double week in month ( x path context context ) throw x path exception { return week in month ( date time ( context ) ) ; }
public static double day of week in month ( string date time ) { double dd = day in month ( date time ) ; if ( double . be na n ( dd ) ) { return dd ; } return ( ( ( int ) dd ) - 1 ) / 7 + 1 ; }
public string get static base u r i ( ) { return expression base u r i ; }
public item evaluate item ( x path context context ) throw x path exception { item item = operand . evaluate item ( context ) ; if ( item == null ) { return null ; } if ( item instanceof untyped atomic value ) { conversion result val = ( ( untyped atomic value ) item ) . convert ( required item type , true , context ) ; if ( val instanceof validation failure ) { validation failure err = ( validation failure ) val ; err . set locator ( this ) ; throw err . make exception ( ) ; } else { return ( atomic value ) val ; } } else { return item ; } }
public static void suppress ( accessible object [ ] accessible object ) { if ( accessible object == null ) { throw new illegal argument exception ( `` accessible object can not be null `` ) ; } for ( accessible object accessible object : accessible object ) { if ( accessible object instanceof constructor < ? > ) { suppress code . suppress constructor ( ( constructor < ? > ) accessible object ) ; } else if ( accessible object instanceof field ) { suppress code . suppress field ( ( field ) accessible object ) ; } else if ( accessible object instanceof method ) { suppress code . suppress method ( ( method ) accessible object ) ; } } }
public boolean be available ( structured q name function name , int arity ) { for ( iterator it=library list . iterator ( ) ; it . have next ( ) ; ) { function library lib = ( function library ) it . next ( ) ; if ( lib . be available ( function name , arity ) ) { return true ; } } return false ; }
public int add function library ( function library lib ) { library list . add ( lib ) ; return library list . size ( ) - 1 ; }
public static sequence iterator get id single ( document info doc , string idrefs ) throw x path exception { boolean white = false ; for ( int i=idrefs . length ( ) -1 ; i > =0 ; i -- ) { char c = idrefs . char at ( i ) ; if ( c < = 0x20 & & ( c == 0x20 || c == 0x09 || c == 0x0a || c == 0x0d ) ) { white = true ; break ; } } if ( white ) { string token iterator token = new string token iterator ( idrefs ) ; id mapping function map = new id mapping function ( ) ; map . document = doc ; sequence iterator result = new mapping iterator ( token , map ) ; return new document order iterator ( result , local order comparer . get instance ( ) ) ; } else { return singleton iterator . make iterator ( doc . select i d ( idrefs ) ) ; } }
public static boolean be statically bind ( final binding binding ) { final boolean b = ( boolean ) ( ( node ) binding ) . ast get decoration ( statically_bound_decoration ) ; return b ! = null & & b ; }
public boolean be available ( structured q name function name , int arity ) { if ( function name . get namespace u r i ( ) . equal ( namespace constant . saxon ) ) { standard function . entry entry = ( standard function . entry ) function table . get ( function name . get local name ( ) ) ; return entry ! = null & & ( arity == -1 || ( arity > = entry . min argument & & arity < = entry . max argument ) ) ; } else { return false ; } }
public void set detail ( standard function . entry entry ) { detail = entry ; operation = detail . opcode ; }
public void set system id ( string url ) { system id = url ; builder . set system id ( url ) ; super . set document locator ( new locator ( ) { public int get column number ( ) { return -1 ; } public int get line number ( ) { return -1 ; } public string get public id ( ) { return null ; } public string get system id ( ) { return system id ; } } ) ; }
public params request condition get matching condition ( server web exchange exchange ) { for ( param expression expression : this . expression ) { if ( ! expression . match ( exchange ) ) { return null ; } } return this ; }
public static int convert regex option ( string flag ) { if ( flags == null ) { return 0 ; } int option = 0 ; if ( flag . index of ( ' g ' ) ! = -1 ) { option |= regexp . replace_all ; } if ( flag . index of ( ' i ' ) ! = -1 ) { option |= regexp . match_case_insensitive ; } if ( flag . index of ( 'm ' ) ! = -1 ) { option |= regexp . match_multiline ; } if ( flag . index of ( 's ' ) ! = -1 ) { option |= regexp . match_singleline ; } return option ; }
public void define global variable ( global variable binding , value representation value ) { globals [ bind . get slot number ( ) ] = value ; }
public void set child ( expression [ ] child ) { if ( children==null || child . length==0 ) { this . child = null ; } else { this . child = child ; for ( int c=0 ; c < child . length ; c++ ) { adopt child expression ( child [ c ] ) ; } } }
public void set inherit namespaces ( boolean inherit ) { inherit namespaces = inherit ; }
public character map expander make character map expander ( string use map , serializer factory sf ) throw x path exception { character map expander character map expander = null ; hash map character map index = get executable ( ) . get character map index ( ) ; if ( use map ! = null & & character map index ! = null ) { list character map = new array list ( 5 ) ; string tokenizer st = new string tokenizer ( use map , `` \t\n\r `` , false ) ; while ( st . have more token ( ) ) { string expand name = st . next token ( ) ; structure q name q name = structure q name . from clark name ( expand name ) ; int hash map map = ( int hash map ) character map index . get ( q name ) ; if ( map==null ) { throw new x path exception ( `` character map ' `` + expand name + `` ' have not be define `` ) ; } character map . add ( map ) ; } if ( ! character map . be empty ( ) ) { character map expander = sf . new character map expander ( ) ; character map expander . set character map ( character map ) ; } } return character map expander ; }
public character map expander make character map expander ( string use map , serializer factory sf ) throw x path exception { character map expander character map expander = null ; hash map character map index = get executable ( ) . get character map index ( ) ; if ( use map ! = null & & character map index ! = null ) { list character map = new array list ( 5 ) ; string tokenizer st = new string tokenizer ( use map , `` \t\n\r `` , false ) ; while ( st . have more token ( ) ) { string expand name = st . next token ( ) ; structure q name q name = structure q name . from clark name ( expand name ) ; int hash map map = ( int hash map ) character map index . get ( q name ) ; if ( map==null ) { throw new x path exception ( `` character map ' `` + expand name + `` ' have not be define `` ) ; } character map . add ( map ) ; } if ( ! character map . be empty ( ) ) { character map expander = sf . new character map expander ( ) ; character map expander . set character map ( character map ) ; } } return character map expander ; }
public key manager factory factory bean get key manager factory ( ) { if ( key manager factory == null ) { return new key manager factory factory bean ( ) ; } return key manager factory ; }
public void set collation ( string name , string collator collation ) { if ( exec . get collation table ( ) == null ) { exec . set collation table ( new collation map ( get configuration ( ) ) ) ; } exec . get collation table ( ) . set name collation ( name , collation ) ; }
public final boolean be require param ( ) { return ( property & require ) ! = 0 ; }
public final boolean be require param ( ) { return ( property & require ) ! = 0 ; }
public int compute cardinality ( ) { if ( cardinality . allow zero ( operand0 . get cardinality ( ) ) || cardinality . allow zero ( operand1 . get cardinality ( ) ) ) { return static property . allows_zero_or_one ; } else { return static property . exactly_one ; } }
public void set host language ( int language ) { host language = language ; }
public int get construct type ( ) { return construct type ; }
public int get originate construct type ( ) { return -1 ; }
public static uri resolve ( final uri base uri , string ref uri ) { return resolve ( base uri , uri . create ( ref uri ) ) ; }
public boolean have require params ( ) { return have require params ; }
public void set require type ( sequence type require ) { require type = require ; }
public string substitute ( string body text ) { string result = body text ; if ( body text expander ! = null ) { result = body text expander . expand ( body text ) ; } return result ; }
public void set slot number ( int slot number ) { this . slot number = slot number ; }
public boolean be number instruction ( ) { return be number instruction ; }
public value representation evaluate variable ( x path context context ) throw x path exception { return context . evaluate local variable ( slot number ) ; }
public void declare java class ( function library library , string uri , class the class ) { if ( library instanceof java extension library ) { ( ( java extension library ) library ) . declare java class ( uri , the class ) ; } else { throw new illegal state exception ( `` saxon : script can not be use with a custom extension library factory `` ) ; } }
public sequence iterator get another ( ) { return the instance ; }
public static unicode escaper below ( int codepoint ) { return outside of ( codepoint , integer . max_value ) ; }
public byte be space preserve ( node info element ) { return strip_default ; }
public int get source position ( ) { return get start position ( ) ; }
public static int flip to fill ( byte buffer buffer ) { int position = buffer . position ( ) ; int limit = buffer . limit ( ) ; if ( position == limit ) { buffer . position ( 0 ) ; buffer . limit ( buffer . capacity ( ) ) ; return 0 ; } int capacity = buffer . capacity ( ) ; if ( limit == capacity ) { buffer . compact ( ) ; return 0 ; } buffer . position ( limit ) ; buffer . limit ( capacity ) ; return position ; }
public int last ( ) { return get position ( ) + size ( ) - 1 ; }
public void set length ( int length ) { if ( length < 0 || length > use ) { return ; } use = length ; }
public void insert char at ( int index , char ch ) { if ( index < 0 || index > use ) { throw new index out of bound exception ( `` `` +index ) ; } ensure capacity ( 1 ) ; for ( int i=used ; i > index ; i -- ) { array [ i ] = array [ i-1 ] ; } used++ ; array [ index ] = ch ; }
public void prepend repeat ( char ch , int repeat ) { if ( repeat > 0 ) { char [ ] a2 = new char [ array . length + repeat ] ; system . arraycopy ( array , 0 , a2 , repeat , use ) ; array . fill ( a2 , 0 , repeat , ch ) ; use += repeat ; array = a2 ; } }
public boolean be n c name char ( int ch ) { return x m l character data . be n c name10 ( ch ) ; }
public template get target template ( x path context context ) throw x path exception { if ( call template expression ! = null ) { controller controller = context . get controller ( ) ; char sequence qname = call template expression . evaluate a string ( context ) ; string prefix ; string local name ; try { string [ ] part = controller . get configuration ( ) . get name checker ( ) . get q name part ( qname ) ; prefix = part [ 0 ] ; local name = part [ 1 ] ; } catch ( q name exception err ) { dynamic error ( `` invalid template name . `` + err . get message ( ) , `` xtse0650 `` , context ) ; return null ; } string uri = n context . get u r i for prefix ( prefix , false ) ; if ( uri==null ) { dynamic error ( `` namespace prefix `` + prefix + `` have not be declare `` , `` xtse0650 `` , context ) ; } structure q name q name = new structure q name ( `` `` , uri , local name ) ; template target = controller . get executable ( ) . get name template ( q name ) ; if ( target==null ) { dynamic error ( `` template `` + qname + `` have not be define `` , `` xtse0650 `` , context ) ; } return target ; } else { return template ; } }
public static boolean be valid name ( string name ) { if ( name . length ( ) == 0 ) return false ; char ch = name . char at ( 0 ) ; if ( be name start ( ch ) == false ) return false ; for ( int i = 1 ; i < name . length ( ) ; i++ ) { ch = name . char at ( i ) ; if ( be name ( ch ) == false ) { return false ; } } return true ; } // be valid name ( string ) : boolean
public static synchronize class pool get default ( ) { if ( default pool == null ) { default pool = new class pool ( null ) ; default pool . append system path ( ) ; } return default pool ; }
public string get prefix ( int name code ) { if ( ( name code & user_defined_mask ) == 0 ) { return standard name . get prefix ( name code & fp_mask ) ; } short uri code = get u r i code ( name code ) ; int prefix index = get prefix index ( name code ) ; return get prefix with index ( uri code , prefix index ) ; }
public string get u r i for prefix ( string prefix , boolean use default ) { name pool pool = get name pool ( ) ; if ( ( prefix==null || prefix . length ( ) ==0 ) & & ! use default ) { return `` `` ; } else if ( `` xml `` . equal ( prefix ) ) { return namespace constant . xml ; } else { short prefix code = pool . get code for prefix ( prefix ) ; short uri code = get u r i code ( prefix code ) ; if ( uri code == -1 ) { return null ; } return pool . get u r i from u r i code ( uri code ) ; } }
public void set client data ( class key , object value ) { if ( client data == null ) { client data = new hash map ( 10 ) ; } client data . put ( key , value ) ; }
public int get document number ( ) { return document number ; }
public static q name get node q name ( node node ) { if ( node == null ) { return null ; } string local name = node . get local name ( ) ; if ( local name == null ) { return null ; } string namespace = node . get namespace u r i ( ) ; return ( find q name ( namespace , local name ) ) ; }
public item type get super type ( type hierarchy th ) { return node kind test . make node kind test ( node kind ) ; }
public void set system id ( string url ) { system id = url ; builder . set system id ( url ) ; super . set document locator ( new locator ( ) { public int get column number ( ) { return -1 ; } public int get line number ( ) { return -1 ; } public string get public id ( ) { return null ; } public string get system id ( ) { return system id ; } } ) ; }
public string get base u r i ( ) { return element . get base u r i ( ) ; }
public boolean be same node info ( node info other ) { return other instanceof virtual copy & & document number == other . get document number ( ) & & original . be same node info ( ( ( virtual copy ) other ) . original ) ; }
public short get u r i code ( int name code ) { if ( ( name code & user_defined_mask ) == 0 ) { return standard name . get u r i code ( name code & fp_mask ) ; } name entry entry = get name entry ( name code ) ; if ( entry == null ) { unknown name code ( name code ) ; return -1 ; } return entry . uri code ; }
public node info get parent ( ) { if ( original . be same node info ( root ) ) { return null ; } if ( parent == null ) { node info basep = original . get parent ( ) ; if ( basep == null ) { return null ; } parent = wrap ( basep ) ; parent . set document number ( document number ) ; } return parent ; }
public value atomize ( ) throw x path exception { return current . atomize ( ) ; }
public boolean be idref ( int index ) { return ( ( get type annotation ( index ) & name pool . fp_mask ) == standard name . xs_idref ) || ( ( get type annotation ( index ) & name pool . fp_mask ) == standard name . xs_idrefs ) ; }
public boolean match ( int node kind , int fingerprint , int annotation ) { return ( node kind == type . element || node kind == type . text || node kind == type . comment || node kind == type . processing_instruction ) ; }
public boolean match d t d type ( ) { return match d t d type ; }
public item type get item type ( type hierarchy th ) { if ( item type == null ) { return super . get item type ( th ) ; } return item type ; }
public boolean equal ( object other ) { return other instanceof tail expression & & base . equal ( ( ( tail expression ) other ) . base ) & & start == ( ( tail expression ) other ) . start ; }
public final expect builder with input filter ( filter filter , filter . . . more filter ) { if ( more filter . length == 0 ) { this . filter = filter ; } else { filter [ ] filter = new filter [ more filter . length + 1 ] ; filter [ 0 ] = filter ; system . arraycopy ( more filter , 0 , filter , 1 , more filter . length ) ; this . filter = filter . chain ( filter ) ; } return this ; }
public int get fingerprint ( ) { return original . get fingerprint ( ) ; }
public int get fingerprint ( ) { return original . get fingerprint ( ) ; }
public void explain name template ( expression presenter presenter ) { presenter . start element ( `` name templates `` ) ; if ( name template table ! = null ) { iterator iter = name template table . value ( ) . iterator ( ) ; while ( iter . have next ( ) ) { template t = ( template ) iter . next ( ) ; presenter . start element ( `` template `` ) ; presenter . emit attribute ( `` name `` , t . get template name ( ) . get display name ( ) ) ; presenter . emit attribute ( `` line `` , t . get line number ( ) + `` `` ) ; presenter . emit attribute ( `` module `` , t . get system id ( ) ) ; if ( t . get body ( ) ! = null ) { t . get body ( ) . explain ( presenter ) ; } presenter . end element ( ) ; } } presenter . end element ( ) ; }
public void iterate declare prefix ( prefix callback callback ) throw s a x exception { for ( enumeration e=nss . get declared prefix ( ) ; e . have more element ( ) ; ) { string p = ( string ) e . next element ( ) ; string uri = n . get u r i ( p ) ; callback . on prefix mapping ( p , uri ) ; } }
public name pool get name pool ( ) { return pipeline configuration . get configuration ( ) . get name pool ( ) ; }
public void set error listener ( error listener error listener ) { this . error listener = error listener ; }
public void set line number ( boolean line number ) { option . set line number ( line number ) ; }
public hash map get compile global variable ( ) { return compile global variable ; }
public void set inherit namespaces ( boolean inherit ) { inherit namespaces = inherit ; }
public int get construction mode ( ) { return construction mode ; }
public x query function library get local function library ( ) { return ( x query function library ) function library list . get ( local function library nr ) ; }
public boolean be undeclare namespaces ( ) { return undeclare namespaces ; }
public boolean be update ( ) { if ( update == null ) { return true ; } else { return update ; } }
public boolean be generate java code ( ) { return generate code ; }
public void set require context item type ( item type type ) { require context item type = type ; }
public void set stack frame map ( slot manager stack frame map ) { if ( stack frame map ! = null & & stack frame map . get number of variable ( ) > 0 ) { super . set stack frame map ( stack frame map ) ; } }
public void declare function ( x query function function ) throw x path exception { string key obj = function . get identification key ( ) ; x query function exist = ( x query function ) function . get ( key obj ) ; if ( exist ! = null ) { x path exception err = new x path exception ( `` duplicate definition of function `` + function . get display name ( ) + `` ( see line `` + exist . get line number ( ) + `` in `` + exist . get system id ( ) + ' ) ' ) ; err . set error code ( `` xqst0034 `` ) ; err . set be static error ( true ) ; err . set locator ( function ) ; throw err ; } function . put ( key obj , function ) ; }
public boolean end with ( string s1 , string s2 ) { return s1 . end with ( s2 ) ; }
public index writer config set leaf sorter ( comparator < leaf reader > leaf sorter ) { this . leaf sorter = leaf sorter ; return this ; }
public int compute cardinality ( ) { if ( template == null ) { return static property . allows_zero_or_more ; } else { return template . get require type ( ) . get cardinality ( ) ; } }
public atomic value get atomic value ( ) { return base . get atomic value ( ) ; }
public boolean contain all ( int set other ) { int iterator it = other . iterator ( ) ; while ( it . have next ( ) ) { if ( ! contains ( it . next ( ) ) ) { return false ; } } return true ; }
public void add range ( int low , int high ) { hash code = -1 ; if ( use == 0 ) { ensure capacity ( 1 ) ; start point [ used-1 ] = low ; end point [ used-1 ] = high ; size += ( high - low + 1 ) ; } else if ( low > end point [ used-1 ] ) { if ( low == end point [ used-1 ] + 1 ) { end point [ used-1 ] = high ; } else { ensure capacity ( used+1 ) ; start point [ used-1 ] = low ; end point [ used-1 ] = high ; } size += ( high - low + 1 ) ; } else { for ( int i=low ; i < =high ; i++ ) { add ( i ) ; } } }
public boolean be sort key ( expression child ) { for ( int i = 0 ; i < sort key definition . length ; i++ ) { expression exp = sort key definition [ i ] . get sort key ( ) ; if ( exp == child ) { return true ; } } return false ; }
public string get base u r i ( ) { if ( base u r i ! = null ) { return base u r i ; } return get system id ( ) ; }
public expression get select expression ( ) { return select ; }
public void set recovery policy ( int policy ) { recovery policy = policy ; }
public object get property ( string name ) { if ( `` name `` . equal ( name ) ) { return function name . get display name ( ) ; } else if ( `` a `` . equal ( name ) ) { return result type . to string ( ) ; } else { return null ; } }
public validate query request builder set explain ( boolean explain ) { request . explain ( explain ) ; return this ; }
public boolean mark tail call ( ) { style element last = get last child instruction ( ) ; return last ! = null & & last . mark tail call ( ) ; }
public boolean encompasses ( log level level ) { if ( level . get precedence ( ) < = get precedence ( ) ) { return true ; } return false ; }
public boolean backwards compatible mode be enable ( ) { return get version ( ) . compare to ( big decimal . value of ( 2 ) ) < 0 ; }
public boolean be extension namespace ( short uri code ) { node info anc = this ; while ( anc instanceof style element ) { if ( ( ( style element ) anc ) . defines extension element ( uri code ) ) { return true ; } anc = anc . get parent ( ) ; } return false ; }
public void set variable q name ( structure q name q name ) { variable name = q name ; }
public void set namespace resolver ( namespace resolver namespace resolver ) { static context . set namespace resolver ( namespace resolver ) ; }
public void open stack frame ( slot manager map ) { int number of slot = map . get number of variable ( ) ; if ( number of slot == 0 ) { stack frame = stack frame . empty ; } else { stack frame = new stack frame ( map , new value representation [ number of slot ] ) ; } }
public boolean be auto import ( ) { if ( auto import == null ) { return true ; } else { return auto import ; } }
public void open stack frame ( slot manager map ) { int number of slot = map . get number of variable ( ) ; if ( number of slot == 0 ) { stack frame = stack frame . empty ; } else { stack frame = new stack frame ( map , new value representation [ number of slot ] ) ; } }
public sequence type get require type ( ) { if ( require type == null ) { return sequence type . any_sequence ; } else { return require type ; } }
public prepare stylesheet get prepare stylesheet ( ) { x s l stylesheet principal stylesheet = get principal stylesheet ( ) ; if ( principal stylesheet == null ) { return null ; } return principal stylesheet . get prepared stylesheet ( ) ; }
public void set min import precedence ( int precedence ) { min import precedence = precedence ; }
public static aspect j precedence information get aspect j precedence information for ( advisor an advisor ) { if ( an advisor instanceof aspect j precedence information ) { return ( aspect j precedence information ) an advisor ; } advice advice = an advisor . get advice ( ) ; if ( advice instanceof aspect j precedence information ) { return ( aspect j precedence information ) advice ; } return null ; }
public int allocate global slot ( structure q name q name ) { return exec . get global variable map ( ) . allocate slot number ( q name ) ; }
public executable get executable ( ) { return executable ; }
public int get slot number ( q name value qname ) { structured q name sq = qname . to structured q name ( ) ; x path variable var = ( x path variable ) variable . get ( sq ) ; if ( var == null ) { return -1 ; } return var . get local slot number ( ) ; }
public list fixup global variable ( slot manager global variable map ) throw x path exception { list var definition = new array list ( 20 ) ; iterator [ ] iters = { variable . value ( ) . iterator ( ) , library variable . value ( ) . iterator ( ) } ; for ( int i=0 ; i < 2 ; i++ ) { while ( iters [ i ] . have next ( ) ) { global variable definition var = ( global variable definition ) iters [ i ] . next ( ) ; int slot = global variable map . allocate slot number ( var . get variable q name ( ) ) ; global variable gv = var . get compile variable ( ) ; if ( gv == null ) { var . compile ( get executable ( ) , slot ) ; } if ( ! var definition . contains ( var ) ) { var definition . add ( var ) ; } } } return var definition ; }
public static configuration get configuration ( job context context ) { return ( configuration ) invoke ( get_configuration_method , context ) ; }
public static void print stack trace ( print stream out , x path context context ) { iterator iterator = new context stack iterator ( context ) ; while ( iterator . have next ( ) ) { context stack frame frame = ( context stack frame ) iterator . next ( ) ; if ( frame == null ) { break ; } frame . print ( out ) ; } }
public final boolean be global ( ) { return false ; }
public value representation evaluate variable ( x path context context ) throw x path exception { return context . evaluate local variable ( slot number ) ; }
public void set length ( int length ) { if ( length < 0 || length > use ) { return ; } use = length ; }
public void write escape ( boolean [ ] special char , output stream stream ) throw java . io . i o exception { final long val = value ; for ( int s=56 ; s > =0 ; s-=8 ) { final byte b = ( byte ) ( ( val > > > s ) & 0xff ) ; if ( b == 0 ) { break ; } final char c = white_chars [ b > > > 6 & 0x3 ] ; final int len = ( b & 0x3f ) ; if ( special char [ c ] ) { byte [ ] e ; if ( c=='\n ' ) { e = escape_n ; } else if ( c=='\r ' ) { e = escape_r ; } else { e = escape_t ; } for ( int j=0 ; j < len ; j++ ) { stream . write ( e ) ; } } else { for ( int j=0 ; j < len ; j++ ) { stream . write ( c ) ; } } } }
public void write escape ( boolean [ ] special char , output stream stream ) throw java . io . i o exception { final long val = value ; for ( int s=56 ; s > =0 ; s-=8 ) { final byte b = ( byte ) ( ( val > > > s ) & 0xff ) ; if ( b == 0 ) { break ; } final char c = white_chars [ b > > > 6 & 0x3 ] ; final int len = ( b & 0x3f ) ; if ( special char [ c ] ) { byte [ ] e ; if ( c=='\n ' ) { e = escape_n ; } else if ( c=='\r ' ) { e = escape_r ; } else { e = escape_t ; } for ( int j=0 ; j < len ; j++ ) { stream . write ( e ) ; } } else { for ( int j=0 ; j < len ; j++ ) { stream . write ( c ) ; } } } }
public void dump data structure ( ) { system . err . println ( `` * * segment : `` ) ; for ( int s=0 ; s < segment . size ( ) ; s++ ) { system . err . println ( `` seg `` + s + `` start offset `` + start offset [ s ] + `` length `` + ( ( fast string buffer ) segment . get ( s ) ) . length ( ) ) ; } }
public int get type annotation ( int index ) { if ( tree . att type code == null ) { return standard name . xs_untyped_atomic ; } return tree . att type code [ first attribute + index ] ; }
public int get name code ( ) { return tree . att code [ node nr ] ; }
public string get prefix ( ) { int code = tree . att code [ node nr ] ; if ( name pool . get prefix index ( code ) == 0 ) return `` `` ; return tree . get name pool ( ) . get prefix ( code ) ; }
public boolean match ( int node kind , int fingerprint , int annotation ) { return ( node kind == type . element || node kind == type . text || node kind == type . comment || node kind == type . processing_instruction ) ; }
public static long get long value ( tiny tree tree , int node nr ) { return ( ( long ) tree . alpha [ node nr ] < < 32 ) | ( ( long ) tree . beta [ node nr ] & 0xffffffff l ) ; }
public query module get query module with system id ( string system id , query module top module ) { if ( system id . equal ( top module . get system id ( ) ) ) { return top module ; } iterator miter = get query library module ( ) ; while ( miter . have next ( ) ) { query module sqc = ( query module ) miter . next ( ) ; if ( sqc . get system id ( ) . equal ( system id ) ) { return sqc ; } } return null ; }
public void set line number ( boolean line number ) { option . set line number ( line number ) ; }
public void end element ( ) throw x path exception { seq1 . end element ( ) ; seq2 . end element ( ) ; }
public void end current item ( item item ) { indent -- ; if ( item instanceof node info ) { node info curr = ( node info ) item ; out . println ( abstract trace listener . space ( indent ) + `` < /source > < ! -- `` + navigator . get path ( curr ) + `` -- > `` ) ; } }
protect static event listener add internal ( event listener a , event listener b ) { if ( a == null ) { return b ; } if ( b == null ) { return a ; } return new trace event multicaster ( a , b ) ; }
public object get instance ( string class name , class loader class loader ) throw x path exception { class theclass = get class ( class name , false , class loader ) ; try { return theclass . new instance ( ) ; } catch ( exception err ) { throw new x path exception ( `` fail to instantiate class `` + class name , err ) ; } }
public void set backwards compatible ( boolean compatible ) { backwards compatible = compatible ; }
public void set convert untyped to other ( boolean convert to other ) { convert untyped to other = convert to other ; }
public use get use ( ) { return use ; }
public void explain template rule ( expression presenter presenter ) { presenter . start element ( `` template rule `` ) ; default mode . explain template rule ( presenter ) ; iterator iter = mode . value ( ) . iterator ( ) ; while ( iter . have next ( ) ) { mode mode = ( mode ) iter . next ( ) ; int s = presenter . start element ( `` mode `` ) ; if ( ! mode . be default mode ( ) ) { presenter . emit attribute ( `` name `` , mode . get mode name ( ) . get display name ( ) ) ; } mode . explain template rule ( presenter ) ; int e = presenter . end element ( ) ; if ( s ! = e ) { throw new illegal state exception ( `` tree unbalanced `` ) ; } } presenter . end element ( ) ; }
public void maybe set context ( x path context context ) { if ( get x path context ( ) == null ) { set x path context ( context ) ; } }
public node info get next sibling ( ) { return null ; }
public void set location ( string system id , int line number ) { set system id ( system id ) ; set line number ( line number ) ; }
public style node factory get style node factory ( ) { return node factory ; }
public final item next ( ) { if ( next==null ) { current = null ; position = -1 ; return null ; } else { current = next ; position++ ; advance ( ) ; return current ; } }
public static final int opposite ( int position ) { if ( position == leave ) return right ; if ( position == right ) return leave ; return position ; }
public boolean be allow build in type ( build in atomic type type ) { return true ; }
public boolean be indexed ( ) { if ( type == null ) { return ( false ) ; } else if ( type . be array ( ) ) { return ( true ) ; } else if ( list . class . be assignable from ( type ) ) { return ( true ) ; } else { return ( false ) ; } }
public build in atomic type get indexed item type ( ) { if ( use type == null ) { return build in atomic type . any_atomic ; } else { return use type ; } }
public int block size ( ) { return 0 ; }
public boolean be variable bound ( ) { if ( start . be variable ( ) ) { return true ; } if ( follow ! = null & & follow . be variable ( ) ) { return true ; } return false ; }
public build in atomic type get indexed item type ( ) { if ( use type == null ) { return build in atomic type . any_atomic ; } else { return use type ; } }
public boolean equal ( object obj ) { return ( obj == this || ( obj instanceof descriptive resource & & ( ( descriptive resource ) obj ) . description . equal ( this . description ) ) ) ; }
public object get property ( string key ) { configuration first match configuration = null ; for ( configuration config : config list ) { if ( config . contains key ( key ) ) { first match configuration = config ; break ; } } if ( first match configuration ! = null ) { return first match configuration . get property ( key ) ; } else { return null ; } }
public void set constraint reference ( validation exception e ) { schema part = e . schema part ; constraint name = e . constraint name ; constraint clause number = e . constraint clause number ; }
public string get constraint reference message ( ) { if ( schema part == -1 ) { return null ; } return `` see http : //www . w3 . org/ t r/xmlschema- `` + schema part + `` / # `` + constraint name + `` clause `` + constraint clause number ; }
public final sequence iterator iterate ( ) { return singleton iterator . make iterator ( this ) ; }
public ground value materialize ( ) { if ( start==0 & & end == item . length ) { return new sequence extent ( item ) ; } else { sequence extent e = new sequence extent ( item ) ; return new sequence extent ( e , start , end-start ) ; } }
public object get value ( ) throw i o exception { c o s base value = field . get dictionary object ( c o s name . v ) ; if ( value instanceof c o s name ) { return ( ( c o s name ) value ) . get name ( ) ; } else if ( value instanceof c o s array ) { return c o s array list . convert c o s string c o s array to list ( ( c o s array ) value ) ; } else if ( value instanceof c o s string ) { return ( ( c o s string ) value ) . get string ( ) ; } else if ( value instanceof c o s stream ) { return ( ( c o s stream ) value ) . to text string ( ) ; } else if ( value ! = null ) { throw new i o exception ( `` error : unknown type for field import `` + value ) ; } else { return null ; } }
public object get x path comparable ( boolean order , string collator collator , x path context context ) { return this ; }
public int compute cardinality ( ) { if ( template == null ) { return static property . allows_zero_or_more ; } else { return template . get require type ( ) . get cardinality ( ) ; } }
public static string get product title ( ) { return get product name ( ) + ' ' + get product version ( ) + `` from saxonica `` ; }
public io . vertx . reactivex . ext . sql . s q l connection set query timeout ( int timeout in second ) { delegate . set query timeout ( timeout in second ) ; return this ; }
public http status get status code ( ) { if ( this . status instanceof http status ) { return ( http status ) this . status ; } else { return http status . value of ( ( integer ) this . status ) ; } }
public action double click ( ) { return this . double click ( null ) ; }
public static log get composite log ( log primary logger , log secondary logger , log . . . tertiary logger ) { list < log > logger = new array list < > ( 2 + tertiary logger . length ) ; logger . add ( primary logger ) ; logger . add ( secondary logger ) ; collection . add all ( logger , tertiary logger ) ; return new composite log ( logger ) ; }
public int compare to ( object other ) { if ( be reference ( ) ) { return ( ( comparable ) get check ref ( ) ) . compare to ( other ) ; } if ( ! ( other instanceof resource ) ) { throw new illegal argument exception ( `` can only be compare with resource `` ) ; } return to string ( ) . compare to ( other . to string ( ) ) ; }
public int get minor version ( ) { return minor ; }
public proxy set sock proxy ( string sock proxy ) { verify proxy type compatibility ( proxy type . manual ) ; this . proxy type = proxy type . manual ; this . sock proxy = sock proxy ; return this ; }
public static command < response body > get response body ( request id request id ) { object . require non null ( request id , `` request id be require `` ) ; return new command < > ( `` fetch . get response body `` , immutable map . of ( `` request id `` , request id . to string ( ) ) , map ( `` body `` , response body . class ) ) ; }
public int line number ( int position ) { int line number = get line number ( position ) ; return line number < 1 ? 1 : line number ; }
public synchronize job priority get priority ( ) { return priority ; }
public void set preload ( boolean preload ) { this . preload = preload ; update hsts header value ( ) ; }
public void start worker ( ) { start worker ( 1 ) ; }
public string get invalid url ( ) { if ( invalid url == null ) { return `` `` ; } else { return invalid url ; } }
public http status get status code ( ) { if ( this . status instanceof http status ) { return ( http status ) this . status ; } else { return http status . value of ( ( integer ) this . status ) ; } }
public boolean be worker ( ) { return worker ; }
public string get protocol ( ) { if ( protocol == null ) { return ssl . default_protocol ; } return protocol ; }
public double get valid to ( ) { return valid to ; }
public http compliance get http compliance ( ) { return http compliance ; }
public list < sign exchange error > get error ( ) { return error ; }
public static command < void > set cache disable ( boolean cache disable ) { return new command < > ( domain_name + `` . set cache disabled `` , immutable map . of ( `` cache disabled `` , cache disable ) ) ; }
public static command < void > set ignore certificate error ( boolean ignore ) { return new command < > ( domain_name + `` . set ignore certificate error `` , immutable map . of ( `` ignore `` , ignore ) ) ; }
public static command < response body > get response body ( request id request id ) { object . require non null ( request id , `` request id must be set . `` ) ; return new command < > ( domain_name + `` . get response body `` , immutable map . of ( `` request id `` , request id . to string ( ) ) , map ( `` body `` , response body . class ) ) ; }
public static command < response body > get response body ( request id request id ) { object . require non null ( request id , `` request id must be set . `` ) ; return new command < > ( domain_name + `` . get response body `` , immutable map . of ( `` request id `` , request id . to string ( ) ) , map ( `` body `` , response body . class ) ) ; }
public static event < request will be send > request will be send ( ) { return new event < > ( domain_name + `` . request will be send `` , map ( `` request id `` , request will be send . class ) ) ; }
public static event < web socket frame > web socket frame receive ( ) { return new event < > ( domain_name + `` . web socket frame receive `` , map ( `` request id `` , web socket frame . class ) ) ; }
public static command < browser context i d > create browser context ( ) { return new command < > ( `` target . create browser context `` , immutable map . of ( ) , converter function . map ( `` browser context id `` , browser context i d . class ) ) ; }
public static command < browser context i d > create browser context ( ) { return new command < > ( `` target . create browser context `` , immutable map . of ( ) , converter function . map ( `` browser context id `` , browser context i d . class ) ) ; }
public static event < target info > target info change ( ) { return new event < > ( `` target . target info change `` , map ( `` target info `` , target info . class ) ) ; }
public t without attribute ( object key ) { return with ( get attribute ( ) . without share attribute ( key ) ) ; }
public name value pair get parameter ( string param name ) { log . trace ( `` enter post method . get parameter ( string ) `` ) ; if ( param name == null ) { return null ; } iterator iter = this . params . iterator ( ) ; while ( iter . have next ( ) ) { name value pair parameter = ( name value pair ) iter . next ( ) ; if ( param name . equal ( parameter . get name ( ) ) ) { return parameter ; } } return null ; }
public void run ( ) { if ( id == null ) { out . println ( `` application id not specify . . . `` ) ; execution context . execute ( `` list `` ) ; return ; } out . println ( `` stop vert . x application ' `` + id + `` ' `` ) ; if ( exec utils . be windows ( ) ) { terminate window application ( ) ; } else { terminate linux application ( ) ; } }
public boolean have error in case ( file local file ) { local file = normalize ( local file . get absolute path ( ) ) ; if ( ! local file . exists ( ) ) { return false ; } final string local file name = local file . get name ( ) ; filename filter ff = new filename filter ( ) { public boolean accept ( file dir , string name ) { return name . equal ignore case ( local file name ) & & ( ! name . equal ( local file name ) ) ; } } ; string [ ] names = local file . get parent file ( ) . list ( ff ) ; return name ! = null & & name . length == 1 ; }
public list < string > get without servlets ( ) { return without servlets ; }
public proxy get proxy ( ) { return proxy ; }
public void set cache response metadata ( boolean should cache ) { this . cache response metadata = should cache ; }
public void process page ( p d page page ) throw i o exception { init page ( page ) ; if ( page . have content ( ) ) { be process page = true ; process stream ( page ) ; be process page = false ; } }
public static expect condition < boolean > url contains ( final string fraction ) { return new expect condition < boolean > ( ) { private string current url = `` `` ; @ override public boolean apply ( web driver driver ) { current url = driver . get current url ( ) ; return current url ! = null & & current url . contains ( fraction ) ; } @ override public string to string ( ) { return string . format ( `` url to contain \ `` % s\ `` . current url : \ `` % s\ `` `` , fraction , current url ) ; } } ; }
public static expect condition < list < web element > > presence of all element locate by ( final by locator ) { return new expect condition < list < web element > > ( ) { @ override public list < web element > apply ( web driver driver ) { list < web element > element = driver . find element ( locator ) ; return element . size ( ) > 0 ? element : null ; } @ override public string to string ( ) { return `` presence of any element locate by `` + locator ; } } ; }
public static expect condition < web element > visibility of element locate ( final by locator ) { return new expect condition < web element > ( ) { @ override public web element apply ( web driver driver ) { try { return element if visible ( driver . find element ( locator ) ) ; } catch ( stale element reference exception e ) { return null ; } } @ override public string to string ( ) { return `` visibility of element locate by `` + locator ; } } ; }
public static expect condition < web element > visibility of element locate ( final by locator ) { return new expect condition < web element > ( ) { @ override public web element apply ( web driver driver ) { try { return element if visible ( driver . find element ( locator ) ) ; } catch ( stale element reference exception e ) { return null ; } } @ override public string to string ( ) { return `` visibility of element locate by `` + locator ; } } ; }
public static expect condition < boolean > not ( final expect condition < ? > condition ) { return new expect condition < boolean > ( ) { @ override public boolean apply ( web driver driver ) { object result = condition . apply ( driver ) ; return result == null || result . equal ( boolean . false ) ; } @ override public string to string ( ) { return `` condition to not be valid : `` + condition ; } } ; }
public fluent wait < t > polling every ( long duration , time unit unit ) { return poll every ( duration . of ( duration , to chrono unit ( unit ) ) ) ; }
public static boolean be order datatype ( uri datatype ) { return be numeric datatype ( datatype ) || be calendar datatype ( datatype ) ; }
public static boolean be derive datatype ( uri datatype ) { return datatype . equal ( x m l schema . normalizedstring ) || datatype . equal ( x m l schema . token ) || datatype . equal ( x m l schema . language ) || datatype . equal ( x m l schema . nmtoken ) || datatype . equal ( x m l schema . nmtokens ) || datatype . equal ( x m l schema . name ) || datatype . equal ( x m l schema . ncname ) || datatype . equal ( x m l schema . id ) || datatype . equal ( x m l schema . idref ) || datatype . equal ( x m l schema . idrefs ) || datatype . equal ( x m l schema . entity ) || datatype . equal ( x m l schema . entity ) || datatype . equal ( x m l schema . integer ) || datatype . equal ( x m l schema . long ) || datatype . equal ( x m l schema . int ) || datatype . equal ( x m l schema . short ) || datatype . equal ( x m l schema . byte ) || datatype . equal ( x m l schema . non_positive_integer ) || datatype . equal ( x m l schema . negative_integer ) || datatype . equal ( x m l schema . non_negative_integer ) || datatype . equal ( x m l schema . positive_integer ) || datatype . equal ( x m l schema . unsigned_long ) || datatype . equal ( x m l schema . unsigned_int ) || datatype . equal ( x m l schema . unsigned_short ) || datatype . equal ( x m l schema . unsigned_byte ) ; }
public static boolean be derive datatype ( uri datatype ) { return datatype . equal ( x m l schema . normalizedstring ) || datatype . equal ( x m l schema . token ) || datatype . equal ( x m l schema . language ) || datatype . equal ( x m l schema . nmtoken ) || datatype . equal ( x m l schema . nmtokens ) || datatype . equal ( x m l schema . name ) || datatype . equal ( x m l schema . ncname ) || datatype . equal ( x m l schema . id ) || datatype . equal ( x m l schema . idref ) || datatype . equal ( x m l schema . idrefs ) || datatype . equal ( x m l schema . entity ) || datatype . equal ( x m l schema . entity ) || datatype . equal ( x m l schema . integer ) || datatype . equal ( x m l schema . long ) || datatype . equal ( x m l schema . int ) || datatype . equal ( x m l schema . short ) || datatype . equal ( x m l schema . byte ) || datatype . equal ( x m l schema . non_positive_integer ) || datatype . equal ( x m l schema . negative_integer ) || datatype . equal ( x m l schema . non_negative_integer ) || datatype . equal ( x m l schema . positive_integer ) || datatype . equal ( x m l schema . unsigned_long ) || datatype . equal ( x m l schema . unsigned_int ) || datatype . equal ( x m l schema . unsigned_short ) || datatype . equal ( x m l schema . unsigned_byte ) ; }
public static int compare ( string value1 , string value2 , uri datatype ) { if ( datatype . equal ( x m l schema . decimal ) ) { return compare decimal ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . integer ) ) { return compare integer ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . negative_integer ) ) { return compare negative integer ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . non_positive_integer ) ) { return compare non positive integer ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . non_negative_integer ) ) { return compare non negative integer ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . positive_integer ) ) { return compare positive integer ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . long ) ) { return compare longs ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . int ) ) { return compare ints ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . short ) ) { return compare short ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . byte ) ) { return compare byte ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . unsigned_long ) ) { return compare unsigned longs ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . unsigned_int ) ) { return compare unsigned ints ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . unsigned_short ) ) { return compare unsigned short ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . unsigned_byte ) ) { return compare unsigned byte ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . float ) ) { return compare float ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . double ) ) { return compare double ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . datetime ) ) { return compare date time ( value1 , value2 ) ; } else { throw new illegal argument exception ( `` datatype be not order `` ) ; } }
public static int compare ( string value1 , string value2 , uri datatype ) { if ( datatype . equal ( x m l schema . decimal ) ) { return compare decimal ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . integer ) ) { return compare integer ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . negative_integer ) ) { return compare negative integer ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . non_positive_integer ) ) { return compare non positive integer ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . non_negative_integer ) ) { return compare non negative integer ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . positive_integer ) ) { return compare positive integer ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . long ) ) { return compare longs ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . int ) ) { return compare ints ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . short ) ) { return compare short ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . byte ) ) { return compare byte ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . unsigned_long ) ) { return compare unsigned longs ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . unsigned_int ) ) { return compare unsigned ints ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . unsigned_short ) ) { return compare unsigned short ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . unsigned_byte ) ) { return compare unsigned byte ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . float ) ) { return compare float ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . double ) ) { return compare double ( value1 , value2 ) ; } else if ( datatype . equal ( x m l schema . datetime ) ) { return compare date time ( value1 , value2 ) ; } else { throw new illegal argument exception ( `` datatype be not order `` ) ; } }
public static string normalize double ( string value ) { return normalize f p number ( value , `` -9007199254740991 . 0 `` , `` 9007199254740991 . 0 `` , `` -1075 `` , `` 970 `` ) ; }
public static int compare canonical float ( string float1 , string float2 ) { return compare canonical f p number ( float1 , float2 ) ; }
public static int compare double ( string double1 , string double2 ) { double1 = normalize double ( double1 ) ; double2 = normalize double ( double2 ) ; return compare canonical double ( double1 , double2 ) ; }
public static string normalize f p number ( string value ) { return normalize f p number ( value , null , null , null , null ) ; }
public static double parse double ( string s ) { s = trim plus sign ( s ) ; return double . parse double ( s ) ; }
public static big integer parse integer ( string s ) { s = trim plus sign ( s ) ; return new big integer ( s ) ; }
public static short parse short ( string s ) { s = trim plus sign ( s ) ; return short . parse short ( s ) ; }
public static iterator < resource > get subject iterator ( graph graph , uri pred , value obj , resource . . . context ) { iterator < statement > iter = graph . match ( null , pred , obj , context ) ; return new convert iterator < statement , resource > ( iter ) { @ override protect resource convert ( statement st ) throw runtime exception { return st . get subject ( ) ; } } ; }
public static double get double value ( literal l , double fallback ) { try { return l . double value ( ) ; } catch ( number format exception e ) { return fallback ; } }
public static byte get byte value ( literal l , byte fallback ) { try { return l . byte value ( ) ; } catch ( number format exception e ) { return fallback ; } }
public void set non fatal error ( set < rio set < ? > > non fatal error ) { this . non fatal error = new hash set < rio set < ? > > ( non fatal error ) ; }
public static string render source location ( i source location loc ) { if ( null == loc ) { return `` ( ( i source location ) null ) `` ; } string buffer sb = new string buffer ( ) ; file source file = loc . get source file ( ) ; if ( source file ! = i source location . no_file ) { sb . append ( source file . get path ( ) ) ; sb . append ( `` : `` ) ; } int line = loc . get line ( ) ; sb . append ( `` `` + line ) ; int column = loc . get column ( ) ; if ( column ! = i source location . no_column ) { sb . append ( `` : `` + column ) ; } return sb . to string ( ) ; }
public static synchronize r d f writer registry get instance ( ) { if ( default registry == null ) { default registry = new r d f writer registry ( ) ; } return default registry ; }
public void reset filter ( boolean use default filter ) { this . include filter . clear ( ) ; this . exclude filter . clear ( ) ; if ( use default filter ) { register default filter ( ) ; } }
public static string escape string ( string label ) { try { string builder sb = new string builder ( 2 * label . length ( ) ) ; escape string ( label , sb ) ; return sb . to string ( ) ; } catch ( i o exception e ) { throw new assertion error ( ) ; } }
public string to string ( ) { string builder sb = new string builder ( ) ; sb . append ( super . to string ( ) ) ; sb . append ( `` : `` ) ; sb . append ( size ( ) ) ; sb . append ( `` wrap throwables : `` ) ; for ( throwable t : throwables ) { sb . append ( `` [ `` ) ; sb . append ( t . get message ( ) ) ; sb . append ( `` ] `` ) ; } return sb . to string ( ) ; }
public static expression location make from sax ( locator loc ) { return new expression location ( loc . get system id ( ) , loc . get line number ( ) , loc . get column number ( ) ) ; }
public static int find ( byte [ ] a , int from index , int to index , byte key ) { int result = -1 ; if ( from index < 0 ) { from index = 0 ; } to index = math . min ( to index , a . length ) ; for ( int i = from index ; from index < to index & & result == -1 & & i < to index ; i++ ) { if ( a [ i ] == key ) { result = i ; } } return result ; }
public static boolean deltree ( file directory ) { if ( directory == null || ! directory . exists ( ) ) { return true ; } boolean result = true ; if ( directory . be file ( ) ) { result = directory . delete ( ) ; } else { file [ ] list = directory . list file ( ) ; for ( int i = list . length ; i -- > 0 ; ) { if ( ! deltree ( list [ i ] ) ) { result = false ; } } if ( ! directory . delete ( ) ) { result = false ; } } return result ; }
protect static boolean be equal ( mime type a mime type , mime type another mime type ) { if ( a mime type == null || another mime type == null ) return false ; if ( a mime type . get type ( ) . equal ( another mime type . get type ( ) ) & & a mime type . get subtype ( ) . equal ( another mime type . get subtype ( ) ) ) return true ; else return false ; } // be equal
public charset charset ( ) { string charset = auth params . get ( `` charset `` ) ; if ( charset ! = null ) { try { return charset . for name ( charset ) ; } catch ( exception ignore ) { } } return iso_8859_1 ; }
public static int hash code ( object o ) { return o == null ? 0 : o . hash code ( ) ; }
public static boolean have text ( char sequence str ) { if ( ! have length ( str ) ) { return false ; } int str len = str . length ( ) ; for ( int i = 0 ; i < str len ; i++ ) { if ( ! character . be whitespace ( str . char at ( i ) ) ) { return true ; } } return false ; }
public static string escape attribute value ( string value ) { string result = string util . gsub ( `` & `` , `` & amp ; `` , value ) ; result = string util . gsub ( `` < `` , `` & lt ; `` , result ) ; result = string util . gsub ( `` > `` , `` & gt ; `` , result ) ; result = string util . gsub ( `` \ `` `` , `` & quot ; `` , result ) ; result = string util . gsub ( `` ' `` , `` & apos ; `` , result ) ; return result ; }
public byte [ ] get content ( ) { return content ; }
public text node text node ( string text ) { return text node . value of ( text ) ; }
public string get text ( ) { if ( text ! = null ) { return text . trim ( ) ; } return text ; }
public list < text node > text node ( ) { list < text node > text node = new array list < text node > ( ) ; for ( node node : child node ) { if ( node instanceof text node ) text node . add ( ( text node ) node ) ; } return collection . unmodifiable list ( text node ) ; }
public void close archive ( ) throw i o exception { if ( this . tar in ! = null ) { this . tar in . close ( ) ; } else if ( this . tar out ! = null ) { this . tar out . close ( ) ; } }
public user id get user id ( ) { return this . user id ; }
public boolean be descendent ( tar entry desc ) { return desc . header . name . to string ( ) . start with ( this . header . name . to string ( ) ) ; }
public void close ( ) throw i o exception { if ( ! close ) { this . finish ( ) ; this . buffer . close ( ) ; out . close ( ) ; close = true ; } }
protect archive path get class path ( ) { throw new unsupported operation exception ( `` resource adapter archive do not support class `` ) ; }
public void unregister ( collector m ) { synchronize ( collector to name ) { list < string > name = collector to name . remove ( m ) ; for ( string name : name ) { name to collector . remove ( name ) ; } } }
public final void inc ref ( ) { ref counter . inc ref ( ) ; }
public void observe ( double amt ) { no label child . observe ( amt ) ; }
public static build chain builder builder ( ) { return new build chain builder ( ) ; }
public void inc ( double amt ) { no label child . inc ( amt ) ; }
public boolean be detect root ( ) { return f detect root ; }
public static void array copy ( byte buffer src , int src po , byte buffer dst , int dst po , int length ) { fast byte operation . copy ( src , src po , dst , dst po , length ) ; }
public void write ( int [ ] f , int off , int len ) throw i o exception { raw write ( f , off * 4 , len * 4 ) ; }
public void write ( int [ ] f , int off , int len ) throw i o exception { raw write ( f , off * 4 , len * 4 ) ; }
public synchronize service static file location ( string folder ) { if ( initialize & & ! be run from servlet ( ) ) { throw before route mapping exception ( ) ; } static file folder = folder ; if ( ! servlet static location set ) { static file configuration . configure ( static file folder ) ; servlet static location set = true ; } else { log . warn ( `` static file location have already be set `` ) ; } return this ; }
public void any ( string from path , string to path , status status ) { get ( from path , to path , status ) ; post ( from path , to path , status ) ; put ( from path , to path , status ) ; delete ( from path , to path , status ) ; }
public void delete ( string from path , string to path , status status ) { http . delete ( from path , redirect route ( to path , status ) ) ; }
public int get response status ( ) { return get response context ( ) . get status ( ) ; }
public void put ( string path , route route ) { add route ( http method . put . name ( ) , route impl . create ( path , route ) ) ; }
public list < http method > check http method ( @ nullable http method request method ) { if ( request method == null ) { return null ; } if ( this . resolve method == null ) { return collection . singleton list ( request method ) ; } return ( this . resolve method . contains ( request method ) ? this . resolve method : null ) ; }
public synchronize service port ( int port ) { if ( initialize ) { throw before route mapping exception ( ) ; } this . port = port ; return this ; }
public void set thread ( int min , int max ) { queue thread pool pool = ( queue thread pool ) web server . get thread pool ( ) ; pool . set min thread ( min ) ; pool . set max thread ( max ) ; }
public static void web socket ( string path , class < ? > handler ) { get instance ( ) . web socket ( path , handler ) ; }
public static void set session attribute ( http servlet request request , string name , @ nullable object value ) { assert . not null ( request , `` request must not be null `` ) ; if ( value ! = null ) { request . get session ( ) . set attribute ( name , value ) ; } else { http session session = request . get session ( false ) ; if ( session ! = null ) { session . remove attribute ( name ) ; } } }
public static boolean be jar u r l ( url url ) { string protocol = url . get protocol ( ) ; return ( url_protocol_jar . equal ( protocol ) || url_protocol_zip . equal ( protocol ) || url_protocol_vfszip . equal ( protocol ) || url_protocol_wsjar . equal ( protocol ) ) ; }
protected memory block allocate page ( long require ) { memory block page = task memory manager . allocate page ( math . max ( page size , require ) , this ) ; if ( page == null || page . size ( ) < require ) { long get = 0 ; if ( page ! = null ) { get = page . size ( ) ; task memory manager . free page ( page , this ) ; } task memory manager . show memory usage ( ) ; throw new out of memory error ( `` unable to acquire `` + required + `` byte of memory , get `` + get ) ; } use += page . size ( ) ; return page ; }
public void free ( ) { update peak memory use ( ) ; if ( long array ! = null ) { free array ( long array ) ; long array = null ; } iterator < memory block > data page iterator = data page . iterator ( ) ; while ( data page iterator . have next ( ) ) { memory block data page = data page iterator . next ( ) ; data page iterator . remove ( ) ; free page ( data page ) ; } assert ( data page . be empty ( ) ) ; while ( ! spill writer . be empty ( ) ) { file file = spill writer . remove first ( ) . get file ( ) ; if ( file ! = null & & file . exists ( ) ) { if ( ! file . delete ( ) ) { logger . error ( `` be unable to delete spill file { } `` , file . get absolute path ( ) ) ; } } } }
public void cleanup resource ( ) { synchronize ( this ) { delete spill file ( ) ; free memory ( ) ; if ( in mem sorter ! = null ) { in mem sorter . free ( ) ; in mem sorter = null ; } } }
public void free ( ) { update peak memory use ( ) ; if ( long array ! = null ) { free array ( long array ) ; long array = null ; } iterator < memory block > data page iterator = data page . iterator ( ) ; while ( data page iterator . have next ( ) ) { memory block data page = data page iterator . next ( ) ; data page iterator . remove ( ) ; free page ( data page ) ; } assert ( data page . be empty ( ) ) ; while ( ! spill writer . be empty ( ) ) { file file = spill writer . remove first ( ) . get file ( ) ; if ( file ! = null & & file . exists ( ) ) { if ( ! file . delete ( ) ) { logger . error ( `` be unable to delete spill file { } `` , file . get absolute path ( ) ) ; } } } }
public spark launcher set java home ( string java home ) { check not null ( java home , `` java home `` ) ; builder . java home = java home ; return this ; }
public http object callback with client id ( string client id ) { this . client id = client id ; return this ; }
public byte [ ] get input iv ( ) { return in iv ; }
public void handler add ( channel handler context ctx ) throw exception { super . handler add ( ctx ) ; channel killer = ctx . channel ( ) . event loop ( ) . schedule ( ( ) - > close channel ( ctx ) , connection ttl millis , time unit . millisecond ) ; }
public static string encode basic auth ( string username , string password , @ nullable charset charset ) { assert . not null ( username , `` username must not be null `` ) ; assert . do not contain ( username , `` : `` , `` username must not contain a colon `` ) ; assert . not null ( password , `` password must not be null `` ) ; if ( charset == null ) { charset = standard charsets . iso_8859_1 ; } charset encoder encoder = charset . new encoder ( ) ; if ( ! encoder . can encode ( username ) || ! encoder . can encode ( password ) ) { throw new illegal argument exception ( `` username or password contain character that can not be encode to `` + charset . display name ( ) ) ; } string credential string = username + `` : `` + password ; byte [ ] encode byte = base64 . get encoder ( ) . encode ( credential string . get byte ( charset ) ) ; return new string ( encoded byte , charset ) ; }
public void check authorization ( transport client client , long stream id ) { }
protect int write to channel ( final byte buffer src ) throw i o exception { if ( ! src . have remain ( ) ) { return 0 ; } final int byte write = this . channel . write ( src ) ; if ( byte write > 0 ) { this . metric . increment byte transfer ( byte write ) ; } return byte write ; }
public static long byte string a mb ( string str ) { return byte string a ( str , byte unit . mi b ) ; }
public int auth r t timeout m ( ) { return ( int ) java utils . time string a sec ( conf . get ( `` spark . network . auth . rpc timeout `` , conf . get ( spark_network_sasl_timeout_key , `` 30 `` ) ) ) * 1000 ; }
public void reregister executor ( app exec id app exec id , executor shuffle info executor info ) { block manager . register executor ( app exec id . app id , app exec id . exec id , executor info ) ; }
public int num outstanding request ( ) { return outstanding fetch . size ( ) + outstanding rpcs . size ( ) + stream callback . size ( ) + ( stream active ? 1 : 0 ) ; }
public shuffle sorter iterator get sort iterator ( ) { int offset = 0 ; if ( use radix sort ) { offset = radix sort . sort ( array , po , pack record pointer . partition_id_start_byte_index , pack record pointer . partition_id_end_byte_index , false , false ) ; } else { memory block unused = new memory block ( array . get base object ( ) , array . get base offset ( ) + pos * 8l , ( array . size ( ) - po ) * 8l ) ; long array buffer = new long array ( unused ) ; sorter < pack record pointer , long array > sorter = new sorter < > ( new shuffle sort data format ( buffer ) ) ; sorter . sort ( array , 0 , po , sort_comparator ) ; } return new shuffle sorter iterator ( po , array , offset ) ; }
public int find in set ( u t f8 string match ) { if ( match . contains ( comma_utf8 ) ) { return 0 ; } int n = 1 , last comma = -1 ; for ( int i = 0 ; i < num byte ; i++ ) { if ( get byte ( i ) == ( byte ) ' , ' ) { if ( i - ( last comma + 1 ) == match . num bytes & & byte array method . array equal ( base , offset + ( last comma + 1 ) , match . base , match . offset , match . num byte ) ) { return n ; } last comma = i ; n++ ; } } if ( num bytes - ( last comma + 1 ) == match . num bytes & & byte array method . array equal ( base , offset + ( last comma + 1 ) , match . base , match . offset , match . num byte ) ) { return n ; } return 0 ; }
public < t > t gauge ( string name , t obj , to double function < t > value function ) { return gauge ( name , empty list ( ) , obj , value function ) ; }
public boolean be updatable result ( ) { return this . updatable result ; }
protect final void compile internal ( ) { if ( be sql ready for use ( ) ) { this . call string = resolve sql ( ) ; } else { string builder call string = new string builder ( 32 ) ; list < sql parameter > parameter = get declared parameter ( ) ; int parameter count = 0 ; if ( be function ( ) ) { call string . append ( `` { ? = call `` ) . append ( resolve sql ( ) ) . append ( ' ( ' ) ; parameter count = -1 ; } else { call string . append ( `` { call `` ) . append ( resolve sql ( ) ) . append ( ' ( ' ) ; } for ( sql parameter parameter : parameter ) { if ( ! parameter . be result parameter ( ) ) { if ( parameter count > 0 ) { call string . append ( `` , `` ) ; } if ( parameter count > = 0 ) { call string . append ( ' ? ' ) ; } parameter count++ ; } } call string . append ( `` ) } `` ) ; this . call string = call string . to string ( ) ; } if ( logger . be debug enable ( ) ) { logger . debug ( `` compile stored procedure . call string be [ `` + this . call string + `` ] `` ) ; } this . callable statement factory = new callable statement creator factory ( this . call string , get declare parameter ( ) ) ; this . callable statement factory . set result set type ( get result set type ( ) ) ; this . callable statement factory . set updatable result ( be updatable result ( ) ) ; on compile internal ( ) ; } / * * * hook method that subclasses may override to react to compilation . * this implementation do nothing . * / protect void on compile internal ( ) { } / * * * get the call string . * / @ nullable public string get call string ( ) { return this . call string ; } / * * * return a callable statement creator to perform an operation * with this parameter . * @ param in params parameter . may be { @ code null } . * / protect callable statement creator new callable statement creator ( @ nullable map < string , ? > in params ) { assert . state ( this . callable statement factory ! = null , `` no callable statement factory available `` ) ; return this . callable statement factory . new callable statement creator ( in params ) ; } / * * * return a callable statement creator to perform an operation * with the parameter return from this parameter mapper . * @ param in param mapper parametermapper . may not be { @ code null } . * / protect callable statement creator new callable statement creator ( parameter mapper in param mapper ) { assert . state ( this . callable statement factory ! = null , `` no callable statement factory available `` ) ; return this . callable statement factory . new callable statement creator ( in param mapper ) ; } }
public void set query timeout ( int query timeout ) { this . jdbc template . set query timeout ( query timeout ) ; }
public void set skip result process ( boolean skip result process ) { this . skip result process = skip result processing ; }
public void set return value require ( boolean return value require ) { this . call meta data context . set return value require ( return value require ) ; }
public void process meta data ( data source data source , list < string > declare column , string [ ] generate key name ) { this . meta data provider = table meta data provider factory . create meta data provider ( data source , this ) ; this . table columns = reconcile column to use ( declared column , generate key name ) ; }
public sql return type get sql return type ( ) { return this . sql return type ; }
protect void set support catalog in procedure call ( boolean support catalog in procedure call ) { this . support catalog in procedure call = support catalog in procedure call ; }
public boolean be supports catalog in procedure call ( ) { return this . support catalog in procedure call ; }
public void set table name ( @ nullable string table name ) { check if configuration modification be allow ( ) ; this . table meta data context . set table name ( table name ) ; }
public string get table name ( ) { return this . table meta data context . get table name ( ) ; }
public void set override include synonyms default ( boolean override ) { this . table meta data context . set override include synonyms default ( override ) ; }
public sql return type get sql return type ( ) { return this . sql return type ; }
public void register sql type ( string param name , int sql type ) { assert . not null ( param name , `` parameter name must not be null `` ) ; this . sql type . put ( param name , sql type ) ; }
public void set jdbc template ( jdbc template jdbc template ) { assert . not null ( jdbc template , `` jdbc template must not be null `` ) ; this . jdbc template = jdbc template ; }
public final string get sql state ( ) { return this . sql state ; }
public boolean be name binding ( ) { return this . call meta data context . be name binding ( ) ; }
public void set return value require ( boolean return value require ) { this . call meta data context . set return value require ( return value require ) ; }
public void add parameter ( string name , string value ) { object . require non null ( name , `` url parameter name can not be null `` ) ; if ( parameter . contains key ( name ) ) { throw new illegal argument exception ( `` url parameter [ `` + name + `` ] have already be set to [ `` + parameter . get ( name ) + `` ] `` ) ; } else { parameter . put ( name , value ) ; } }
public final synchronize void compile ( ) throw invalid data access api usage exception { if ( ! be compile ( ) ) { if ( get table name ( ) == null ) { throw new invalid data access api usage exception ( `` table name be require `` ) ; } try { this . jdbc template . after property set ( ) ; } catch ( illegal argument exception ex ) { throw new invalid data access api usage exception ( ex . get message ( ) ) ; } compile internal ( ) ; this . compile = true ; if ( logger . be debug enable ( ) ) { logger . debug ( `` jdbc insert for table [ `` + get table name ( ) + `` ] compile `` ) ; } } }
public final void set jdbc template ( @ nullable jdbc template jdbc template ) { this . jdbc template = jdbc template ; init template config ( ) ; }
public void set password ( string password ) { this . password = password ; } // set password
protect boolean be transaction active ( ) { return this . transaction active ; }
public void release savepoint ( object savepoint ) throw transaction exception { connection holder con holder = get connection holder for savepoint ( ) ; try { con holder . get connection ( ) . release savepoint ( ( savepoint ) savepoint ) ; } catch ( throwable ex ) { logger . debug ( `` could not explicitly release jdbc savepoint `` , ex ) ; } }
protect data source resolve specify data source ( object data source ) throw illegal argument exception { if ( data source instanceof data source ) { return ( data source ) data source ; } else if ( data source instanceof string ) { return this . data source lookup . get data source ( ( string ) data source ) ; } else { throw new illegal argument exception ( `` illegal data source value - only [ javax . sql . data source ] and string support : `` + data source ) ; } }
public static void release connection ( @ nullable connection con , @ nullable data source data source ) { try { do release connection ( con , data source ) ; } catch ( s q l exception ex ) { logger . debug ( `` could not close jdbc connection `` , ex ) ; } catch ( throwable ex ) { logger . debug ( `` unexpected exception on closing jdbc connection `` , ex ) ; } }
public embed database builder set name ( string database name ) { this . database factory . set database name ( database name ) ; return this ; }
public void set previous isolation level ( @ nullable integer previous isolation level ) { this . previous isolation level = previous isolation level ; }
public boolean be read only ( ) { if ( read only == null ) { return false ; } else { return read only ; } }
public final void set isolation level name ( string constant name ) throw illegal argument exception { if ( ! constant name . start with ( default transaction definition . prefix_isolation ) ) { throw new illegal argument exception ( `` only isolation constant allow `` ) ; } set isolation level ( constant . a number ( constant name ) . int value ( ) ) ; }
public final void set lenient ( boolean lenient ) { this . lenient = lenient ; }
protect data source determine target data source ( ) { assert . not null ( this . resolve data source , `` data source router not initialize `` ) ; object lookup key = determine current lookup key ( ) ; data source data source = this . resolve data source . get ( lookup key ) ; if ( data source == null & & ( this . lenient fallback || lookup key == null ) ) { data source = this . resolve default data source ; } if ( data source == null ) { throw new illegal state exception ( `` can not determine target data source for lookup key [ `` + lookup key + `` ] `` ) ; } return data source ; }
public string determine driver class name ( ) { if ( string utils . have text ( this . driver class name ) ) { assert . state ( driver class be loadable ( ) , ( ) - > `` can not load driver class : `` + this . driver class name ) ; return this . driver class name ; } string driver class name = null ; if ( string utils . have text ( this . url ) ) { driver class name = database driver . from jdbc url ( this . url ) . get driver class name ( ) ; } if ( ! string utils . have text ( driver class name ) ) { driver class name = this . embedded database connection . get driver class name ( ) ; } if ( ! string utils . have text ( driver class name ) ) { throw new data source bean creation exception ( `` fail to determine a suitable driver class `` , this , this . embedded database connection ) ; } return driver class name ; }
public void set suppress close ( boolean suppress close ) { this . suppress close = suppress close ; }
protect connection get connection from driver ( @ nullable string username , @ nullable string password ) throw s q l exception { property merge prop = new property ( ) ; property conn prop = get connection property ( ) ; if ( conn prop ! = null ) { merge prop . put all ( conn prop ) ; } if ( username ! = null ) { merge prop . set property ( `` user `` , username ) ; } if ( password ! = null ) { merge prop . set property ( `` password `` , password ) ; } connection con = get connection from driver ( merge prop ) ; if ( this . catalog ! = null ) { con . set catalog ( this . catalog ) ; } if ( this . schema ! = null ) { con . set schema ( this . schema ) ; } return con ; }
public int [ ] flush ( ) { if ( this . parameter queue . be empty ( ) ) { return new int [ 0 ] ; } int [ ] row affect = get jdbc template ( ) . batch update ( resolve sql ( ) , new batch prepare statement setter ( ) { @ override public int get batch size ( ) { return parameter queue . size ( ) ; } @ override public void set value ( prepared statement p , int index ) throw s q l exception { object [ ] params = parameter queue . remove first ( ) ; new prepared statement setter ( params ) . set value ( p ) ; } } ) ; for ( int row count : row affect ) { check row affect ( row count ) ; if ( this . track row affect ) { this . row affect . add ( row count ) ; } } return row affect ; }
public void set type ( @ nullable int [ ] type ) throw invalid data access api usage exception { if ( be compile ( ) ) { throw new invalid data access api usage exception ( `` can not add parameter once query be compile `` ) ; } if ( type ! = null ) { for ( int type : type ) { declare parameter ( new sql parameter ( type ) ) ; } } }
public boolean be function name ( ) { return _defined name rec . be function name ( ) ; }
public list < t > execute ( long p1 ) throw data access exception { return execute ( p1 , null ) ; }
public list < t > execute ( object . . . params ) throw data access exception { return execute ( params , null ) ; }
public int update ( int p1 ) throw data access exception { return update ( new object [ ] { p1 } ) ; }
protect void validate parameter ( @ nullable object [ ] parameter ) throw invalid data access api usage exception { check compile ( ) ; int declare in parameter = 0 ; for ( sql parameter param : this . declared parameter ) { if ( param . be input value provide ( ) ) { if ( ! support lob parameter ( ) & & ( param . get sql type ( ) == type . blob || param . get sql type ( ) == type . clob ) ) { throw new invalid data access api usage exception ( `` blob or clob parameter be not allow for this kind of operation `` ) ; } declare in parameters++ ; } } validate parameter count ( ( parameter ! = null ? parameter . length : 0 ) , declare in parameter ) ; }
public boolean be delete specific value ( ) { return this . delete specific value ; }
public boolean support batch update ( ) { debug code call ( `` support batch update `` ) ; return true ; }
protect void init application context ( application context context ) throw bean exception { init application context ( ) ; }
public static < t > t single result ( @ nullable collection < t > result ) throw incorrect result size data access exception { if ( collection utils . be empty ( result ) ) { return null ; } if ( result . size ( ) > 1 ) { throw new incorrect result size data access exception ( 1 , result . size ( ) ) ; } return result . iterator ( ) . next ( ) ; }
public void set always reauthenticate ( boolean always reauthenticate ) { this . always reauthenticate = always reauthenticate ; }
public final connection get connection ( ) throw resource exception { connection spec thread spec = this . thread bound spec . get ( ) ; if ( thread spec ! = null ) { return do get connection ( thread spec ) ; } else { return do get connection ( this . connection spec ) ; } }
protect connection get close suppress connection proxy ( connection target ) { return ( connection ) proxy . new proxy instance ( connection proxy . class . get class loader ( ) , new class < ? > [ ] { connection proxy . class } , new close suppress invocation handler ( target ) ) ; }
public final void set connection factory ( connection factory connection factory ) { if ( this . cci template == null || connection factory ! = this . cci template . get connection factory ( ) ) { this . cci template = create cci template ( connection factory ) ; } }
public void start ( bootstrap context bootstrap context ) throw resource adapter internal exception { if ( logger . be debug enable ( ) ) { logger . debug ( `` start spring context resource adapter with bootstrap context : `` + bootstrap context ) ; } this . application context = create application context ( bootstrap context ) ; }
public void set message endpoint factory ( @ nullable message endpoint factory message endpoint factory ) { this . message endpoint factory = message endpoint factory ; }
public static thread factory reset thread factory ( final thread factory delegate ) throw security exception { return new thread factory ( ) { public thread new thread ( final runnable r ) { return delegate . new thread ( new thread local reset runnable ( r ) ) ; } } ; }
public void set transaction attribute ( property transaction attribute ) { name match transaction attribute source ta = new name match transaction attribute source ( ) ; ta . set property ( transaction attribute ) ; this . transaction attribute source = ta ; }
public void set transaction manager ( @ nullable platform transaction manager transaction manager ) { this . transaction manager = transaction manager ; }
public void set transaction manager class name ( string transaction manager class name ) { synchronize ( this ) { if ( transaction manager class name == null ) { this . transaction manager = null ; } else if ( ! transaction manager class name . equal ( this . transaction manager class name ) ) { this . transaction manager = null ; } this . transaction manager class name = transaction manager class name ; } }
public void set transaction synchronization registry class name ( string transaction synchronization registry class name ) { synchronize ( this ) { if ( transaction synchronization registry class name == null ) { this . transaction synchronization registry = null ; } else if ( ! transaction synchronization registry class name . equal ( this . transaction synchronization registry class name ) ) { this . transaction synchronization registry = null ; } this . transaction synchronization registry class name = transaction synchronization registry class name ; } }
public boolean be actual transaction active ( ) { return this . transaction context . be actual transaction active ( ) ; }
public final mono < void > rollback ( reactive transaction transaction ) throw transaction exception { if ( transaction . be complete ( ) ) { return mono . error ( new illegal transaction state exception ( `` transaction be already complete - do not call commit or rollback more than once per transaction `` ) ) ; } return transaction synchronization manager . for current transaction ( ) . flat map ( synchronization manager - > { generic reactive transaction reactive tx = ( generic reactive transaction ) transaction ; return process rollback ( synchronization manager , reactive tx ) ; } ) ; }
protect void do resume ( @ nullable object transaction , object suspend resource ) throw transaction exception { throw new transaction suspension not support exception ( `` transaction manager [ `` + get class ( ) . get name ( ) + `` ] do not support transaction suspension `` ) ; }
protect jta transaction object do get jta transaction ( user transaction ut ) { return new jta transaction object ( ut ) ; }
public void set isolation level ( int isolation level ) { if ( ! constant . get value ( default transaction definition . prefix_isolation ) . contains ( isolation level ) ) { throw new illegal argument exception ( `` only value of isolation constant allow `` ) ; } this . isolation level = ( isolation level ! = transaction definition . isolation_default ? isolation level : null ) ; }
public final mono < void > commit ( reactive transaction transaction ) throw transaction exception { if ( transaction . be complete ( ) ) { return mono . error ( new illegal transaction state exception ( `` transaction be already complete - do not call commit or rollback more than once per transaction `` ) ) ; } return transaction synchronization manager . for current transaction ( ) . flat map ( synchronization manager - > { generic reactive transaction reactive tx = ( generic reactive transaction ) transaction ; if ( reactive tx . be rollback only ( ) ) { if ( reactive tx . be debug ( ) ) { logger . debug ( `` transactional code have request rollback `` ) ; } return process rollback ( synchronization manager , reactive tx ) ; } return process commit ( synchronization manager , reactive tx ) ; } ) ; }
public boolean be local rollback only ( ) { return this . rollback only ; }
public timeout clear deadline ( ) { this . have deadline = false ; return this ; }
public void reset ( ) { node . clear ( ) ; mark . clear ( ) ; sp = 0 ; mk = 0 ; }
public void reader unlock ( ) { reader lock . unlock ( ) ; }
public int read ( ) throw i o exception { byte [ ] buffer = new byte [ 1 ] ; if ( project . demux input ( buffer , 0 , 1 ) == -1 ) { return -1 ; } return buffer [ 0 ] ; }
public t put boolean ( boolean b ) { return put byte ( b ? ( byte ) 1 : ( byte ) 0 ) ; }
public charset charset ( ) { string charset = auth params . get ( `` charset `` ) ; if ( charset ! = null ) { try { return charset . for name ( charset ) ; } catch ( exception ignore ) { } } return iso_8859_1 ; }
public compile s t define template alias ( token alias t , token target t ) { string alias = alias t . get text ( ) ; string target = target t . get text ( ) ; compile s t target code = raw get template ( `` / `` +target ) ; if ( target code==null ) { err mgr . compile time error ( error type . alias_target_undefined , null , alias t , alias , target ) ; return null ; } raw define template ( `` / `` + alias , target code , alias t ) ; return target code ; }
public static local session store new instance ( io . vertx . ext . web . sstore . local session store arg ) { return arg ! = null ? new local session store ( arg ) : null ; }
public static dir from u r l ( final url url ) { return from u r l ( url , default url type ) ; }
public string to string ( ) { string builder sb = new string builder ( ) . append ( ' [ ' ) ; for ( int i = 0 ; i < occupied bit ; i++ ) { if ( i > 0 ) sb . append ( `` , `` ) ; sb . append ( bit set . get ( i ) ) ; } return sb . append ( ' ] ' ) . to string ( ) ; }
public scan module builder exclude class ( class < ? > . . . class ) { return exclude class ( new hash set < > ( arrays . a list ( class ) ) ) ; }
public static < a extend annotation > a get annotation ( method method , class < a > annotation class ) { a annotation = method . get annotation ( annotation class ) ; if ( annotation == null ) { for ( annotation meta annotation : method . get annotation ( ) ) { annotation = meta annotation . annotation type ( ) . get annotation ( annotation class ) ; if ( annotation ! = null ) { return annotation ; } } method superclass method = get overridden method ( method ) ; if ( superclass method ! = null ) { annotation = get annotation ( superclass method , annotation class ) ; } } return annotation ; }
public string get invalid url ( ) { if ( invalid url == null ) { return `` `` ; } else { return invalid url ; } }
public void set pattern ( final string pattern ) { df factory = new date format factory ( ) { public date format get primary format ( ) { return new simple date format ( pattern ) ; } public date format get fallback format ( ) { return null ; } } ; }
public stream priority set exclusive ( boolean exclusive ) { this . exclusive = exclusive ; return this ; }
public int get maximum text length ( locale locale ) { int max = get maximum value ( ) ; if ( max > = 0 ) { if ( max < 10 ) { return 1 ; } else if ( max < 100 ) { return 2 ; } else if ( max < 1000 ) { return 3 ; } } return integer . to string ( max ) . length ( ) ; }
public boolean find pattern ( string pattern ) { for ( string s : pattern ) { if ( s . equal ( pattern ) ) return true ; } return false ; }
public list < property definition base > get additional property ( ) { return this . additional property ; }
public string get default web xml ( ) { if ( default web xml == null ) { default web xml = constant . default web xml ; } return default web xml ; }
public static parameterized type parameterized type ( final class < ? > raw type , final type . . . actual type argument ) { return new parameterized type ( ) { @ override public type [ ] get actual type argument ( ) { return actual type argument ; } @ override public type get raw type ( ) { return raw type ; } @ override public type get owner type ( ) { return null ; } } ; }
public namespace add namespace ( string prefix , string uri ) { namespace namespace = create namespace ( prefix , uri ) ; push ( namespace ) ; return namespace ; }
public string get prefix ( ) { return ( prefix ) ; }
public external attachment to external attachment ( ) { return ( external attachment ) this ; }
public in get in ( ) { return in ; }
public string $ ( string key ) { return $ ( key , `` `` ) ; }
public service authorization manager get service authorization manager ( ) { return service authorization manager ; }
public client credential selector < t > get client credential selector ( ) { return client credential selector ; }
public string get invalid url ( ) { if ( invalid url == null ) { return `` `` ; } else { return invalid url ; } }
public static array digest from byte ( byte buffer buf ) { int encode = buf . get int ( ) ; if ( encode == verbose_encoding || encode == verbose_array_digest ) { double compression = buf . get double ( ) ; int page size = 32 ; if ( encode == verbose_array_digest ) { page size = buf . get int ( ) ; } array digest r = new array digest ( page size , compression ) ; int n = buf . get int ( ) ; double [ ] mean = new double [ n ] ; for ( int i = 0 ; i < n ; i++ ) { mean [ i ] = buf . get double ( ) ; } for ( int i = 0 ; i < n ; i++ ) { r . add ( mean [ i ] , buf . get int ( ) ) ; } return r ; } else if ( encode == small_encoding || encode == small_array_digest ) { double compression = buf . get double ( ) ; int page size = 32 ; if ( encode == small_array_digest ) { page size = buf . get int ( ) ; } array digest r = new array digest ( page size , compression ) ; int n = buf . get int ( ) ; double [ ] mean = new double [ n ] ; double x = 0 ; for ( int i = 0 ; i < n ; i++ ) { double delta = buf . get float ( ) ; x += delta ; mean [ i ] = x ; } for ( int i = 0 ; i < n ; i++ ) { int z = decode ( buf ) ; r . add ( mean [ i ] , z ) ; } return r ; } else { throw new illegal state exception ( `` invalid format for serialized histogram `` ) ; } }
public int first ( int node ) { if ( node == nil ) { return nil ; } while ( true ) { final int leave = left ( node ) ; if ( left == nil ) { break ; } node = leave ; } return node ; }
public static array digest create array digest ( int page size , double compression ) { return new array digest ( page size , compression ) ; }
static public void assert true ( string message , boolean condition ) { if ( ! condition ) fail ( message ) ; }
public void assert error ( class < ? extend throwable > clazz ) { list < throwable > err = error ; if ( err . be empty ( ) ) { assertion error ( `` no error `` ) ; } else if ( err . size ( ) > 1 ) { assertion error ae = new assertion error ( `` multiple error : `` + err . size ( ) ) ; ae . init cause ( new composite exception ( err ) ) ; throw ae ; } else if ( ! clazz . be instance ( err . get ( 0 ) ) ) { assertion error ae = new assertion error ( `` exception differ ; expect : `` + clazz + `` , actual : `` + err . get ( 0 ) ) ; ae . init cause ( err . get ( 0 ) ) ; throw ae ; } }
static public void assert equal ( string message , byte expect , byte actual ) { assert equal ( message , new byte ( expect ) , new byte ( actual ) ) ; }
static public void assert equal ( string message , short expect , short actual ) { assert equal ( message , new short ( expect ) , new short ( actual ) ) ; }
static public void assert null ( object object ) { assert null ( null , object ) ; }
public static void assert equal ( iterator < ? > actual , iterator < ? > expect ) { assert equal ( actual , expect , null ) ; }
public long get time out ( ) { long result = 0 ; for ( i method instance mi : m_method instance ) { i test n g method tm = mi . get method ( ) ; if ( tm . get time out ( ) > result ) { result = tm . get time out ( ) ; } } return result ; }
public static string get property name ( method method ) { string method name = method . get name ( ) ; final string get = `` get `` ; final string be = `` be `` ; if ( method name . start with ( get ) ) { return decapitalize ( method name . substring ( get . length ( ) ) ) ; } else if ( method name . start with ( be ) ) { return decapitalize ( method name . substring ( be . length ( ) ) ) ; } else { return null ; } }
public void trace ( object message , throwable t ) { do log ( level . trace , fqcn , message , null , t ) ; }
public void debug log ( final string message ) { debug log ( message , ( object [ ] ) null ) ; }
public static void log ( string s , int level , boolean log to standard out ) { if ( test runner . get verbose ( ) > = level ) { log ( s , get current test result ( ) ) ; if ( log to standard out ) { system . out . println ( s ) ; } } }
public static parameter mode from xml ( string name ) { return parameter mode . value of ( name ) ; }
public void set output dir ( file dir ) { m_output dir= dir ; }
protect boolean be jdk14 available ( ) { return be log library available ( `` jdk14 `` , `` org . apache . common . log . impl . jdk14 logger `` ) ; }
public void set work dir ( string work dir ) { this . work dir = work dir ; }
public static list < i test n g method > unique method list ( collection < list < i test n g method > > method ) { set < i test n g method > result set = set . new hash set ( ) ; for ( list < i test n g method > l : method ) { result set . add all ( l ) ; } return list . new array list ( result set ) ; }
public static boolean be subtree child ( ast fixture , ast test ) { ast n = fixture . get first child ( ) ; while ( n ! = null ) { if ( n == test ) { return true ; } if ( n . get first child ( ) ! = null & & be subtree child ( n , test ) ) { return true ; } n = n . get next sibling ( ) ; } return false ; }
public void set verbose ( boolean verbose ) { do verbose = verbose ; }
public void set test name ( list < string > test name ) { m_test names = test name ; }
public static list convert class to class name ( list class ) { if ( class == null ) { return null ; } list class name = new array list ( class . size ( ) ) ; for ( iterator it = class . iterator ( ) ; it . have next ( ) ; ) { class cl = ( class ) it . next ( ) ; if ( cls == null ) { class name . add ( null ) ; } else { class name . add ( cl . get name ( ) ) ; } } return class name ; }
public set < string > find match ( string text , pattern pattern ) { set < string > result = null ; matcher matcher = pattern . matcher ( text ) ; if ( matcher . find ( ) ) { result = new hash set < > ( ) ; result . add ( matcher . group ( 0 ) ) ; while ( matcher . find ( ) ) { result . add ( matcher . group ( 0 ) ) ; } } return result ; }
public static int compare date time ( string value1 , string value2 ) { x m l date time date time1 = new x m l date time ( value1 ) ; x m l date time date time2 = new x m l date time ( value2 ) ; date time1 . normalize ( ) ; date time2 . normalize ( ) ; return date time1 . compare to ( date time2 ) ; }
public void set j unit ( boolean be j unit ) { m_is j unit = be j unit ; }
public schedule cancellable schedule ( runnable command , time value delay , string executor ) { final runnable context preserve runnable = thread context . preserve context ( command ) ; final runnable to schedule ; if ( name . same . equal ( executor ) == false ) { to schedule = new thread runnable ( context preserving runnable , executor ( executor ) ) ; } else if ( slow scheduler warn threshold nanos > 0 ) { to schedule = new runnable ( ) { @ override public void run ( ) { final long start time = thread pool . this . relative time in nanos ( ) ; try { context preserving runnable . run ( ) ; } finally { final long take = thread pool . this . relative time in nanos ( ) - start time ; if ( take > slow scheduler warn threshold nanos ) { logger . warn ( `` execution of [ { } ] take [ { } m ] which be above the warn threshold of [ { } ms ] `` , context preserving runnable , time unit . nanosecond . to millis ( take ) , time unit . nanosecond . to millis ( slow scheduler warn threshold nanos ) ) ; } } } @ override public string to string ( ) { return context preserve runnable . to string ( ) ; } } ; } else { to schedule = context preserve runnable ; } return new schedule cancellable adapter ( scheduler . schedule ( to schedule , delay . millis ( ) , time unit . millisecond ) ) ; }
public int size ( ) { return _map . size ( ) ; }
protect void set up ( int initial capacity , double min load factor , double max load factor ) { if ( initial capacity < 0 ) { throw new illegal argument exception ( `` initial capacity must not be less than zero : `` + initial capacity ) ; } if ( min load factor < 0 . 0 || min load factor > = 1 . 0 ) { throw new illegal argument exception ( `` illegal min load factor : `` + min load factor ) ; } if ( max load factor < = 0 . 0 || max load factor > = 1 . 0 ) { throw new illegal argument exception ( `` illegal max load factor : `` + max load factor ) ; } if ( min load factor > = max load factor ) { throw new illegal argument exception ( `` illegal min load factor : `` + min load factor + `` and max load factor : `` + max load factor ) ; } }
public list iterator list iterator ( final int index ) { return new list iterator ( ) { list iterator i = underlie . list iterator ( index ) ; public boolean have next ( ) { return i . have next ( ) ; } public object next ( ) { return i . next ( ) ; } public boolean have previous ( ) { return i . have previous ( ) ; } public object previous ( ) { return i . previous ( ) ; } public int next index ( ) { return i . next index ( ) ; } public int previous index ( ) { return i . previous index ( ) ; } public void remove ( ) { throw new unsupported operation exception ( ) ; } public void set ( object o ) { throw new unsupported operation exception ( ) ; } public void add ( object o ) { throw new unsupported operation exception ( ) ; } } ; }
public boolean for each value ( t byte procedure procedure ) { object [ ] key = _set ; byte [ ] value = _values ; for ( int i = value . length ; i -- > 0 ; ) { if ( key [ i ] ! = free & & key [ i ] ! = remove & & ! procedure . execute ( value [ i ] ) ) { return false ; } } return true ; }
public collection < v > value ( ) { final collection < v > v = value view ; return v ! = null ? v : ( value view = new value ( ) ) ; }
public boolean contain all ( final collection < ? > coll ) { final iterator < ? > e = coll . iterator ( ) ; while ( e . have next ( ) ) { if ( ! contains ( e . next ( ) ) ) { return false ; } } return true ; }
public byte peek ( ) { return _list . get ( _list . size ( ) - 1 ) ; }
public static void clear ( ) { class_to_elected_fields . clear ( ) ; dictionary_fields . clear ( ) ; field_to_cache_hit . clear ( ) ; field_to_nb_reset . clear ( ) ; dictionary_array . clear ( ) ; class_to_cache_hit . clear ( ) ; }
public date time field get field ( int index ) { return get field ( index , get chronology ( ) ) ; }
public string get message ( ) { string msg = super . get message ( ) ; string ec = get error code ( ) ; if ( ( msg == null ) & & ( ec == null ) ) { return null ; } if ( ( msg ! = null ) & & ( ec ! = null ) ) { return ( msg + `` , error code : `` + ec ) ; } return ( ( msg ! = null ) ? msg : ( `` error code : `` + ec ) ) ; }
public msg get message ( string key ) { return ( msg ) h msg . get ( key ) ; }
public static string [ ] [ ] copy string ( string [ ] [ ] in ) { string [ ] [ ] out = new string [ in . length ] [ ] ; for ( int i = 0 ; i < out . length ; i++ ) { out [ i ] = new string [ in [ i ] . length ] ; system . arraycopy ( in [ i ] , 0 , out [ i ] , 0 , out [ i ] . length ) ; } return out ; }
public long get number of record to read ( ) { return number of record to read ; }
public void append ( default char appender appender ) { system . arraycopy ( appender . char , 0 , this . char , this . index , appender . index - appender . whitespace count ) ; this . index += appender . index - appender . whitespace count ; appender . reset ( ) ; }
public final void set line separator detection enable ( boolean line separator detection enable ) { this . line separator detection enable = line separator detection enable ; }
public field set < string > exclude field ( string . . . field names ) { return set field set ( new exclude field name selector ( ) , field name ) ; }
public field set < integer > exclude index ( integer . . . field index ) { return set field set ( new exclude field index selector ( ) , field index ) ; }
public agroal connection factory configuration supplier auto commit ( boolean auto commit enable ) { check lock ( ) ; auto commit = auto commit enable ; return this ; }
public final csv format get detect format ( ) { csv format out = null ; if ( setting . be delimiter detection enable ( ) ) { out = setting . get format ( ) . clone ( ) ; out . set delimiter ( this . delimiter ) ; } if ( setting . be quote detection enable ( ) ) { out = out == null ? setting . get format ( ) . clone ( ) : out ; out . set quote ( quote ) ; out . set quote escape ( quote escape ) ; } if ( setting . be line separator detection enable ( ) ) { out = out == null ? setting . get format ( ) . clone ( ) : out ; out . set line separator ( input . get line separator ( ) ) ; } return out ; }
public void show column ( int column index , int insertion index ) { for ( table column hidden column : hidden column ) { if ( hidden column . get model index ( ) == column index ) { column model . add column ( hidden column ) ; column model . move column ( column model . get column count ( ) -1 , insertion index ) ; hide column . remove ( hidden column ) ; break ; } } }
public header get condense header ( string name ) { header [ ] header = get header ( name ) ; if ( header . length == 0 ) { return null ; } else if ( header . length == 1 ) { return new header ( header [ 0 ] . get name ( ) , header [ 0 ] . get value ( ) ) ; } else { string buffer value buffer = new string buffer ( header [ 0 ] . get value ( ) ) ; for ( int i = 1 ; i < header . length ; i++ ) { value buffer . append ( `` , `` ) ; value buffer . append ( header [ i ] . get value ( ) ) ; } return new header ( name . to lower case ( ) , value buffer . to string ( ) ) ; } }
public void internal validate ( ) throw service validation exception { for ( int i = 0 ; i < this . additional property . size ( ) ; i++ ) { if ( this . additional property . get ( i ) == null ) { throw new service validation exception ( string . format ( `` the additional property at index % d be null . `` , i ) ) ; } } }
public field set < enum > select field ( enum . . . column ) { return set field set ( new field enum selector ( ) , column ) ; }
public void remove ( domain socket sock ) { lock . lock ( ) ; try { if ( close ) return ; to remove . put ( sock . fd , sock ) ; kick ( ) ; while ( true ) { try { processed cond . await ( ) ; } catch ( interrupted exception e ) { thread . current thread ( ) . interrupt ( ) ; } if ( ! to remove . contains key ( sock . fd ) ) { break ; } } } finally { lock . unlock ( ) ; } }
public string get lookahead ( char current ) { if ( start > = length ) { return string . value of ( current ) ; } return current + new string ( lookahead , start , length - 1 ) ; }
public void set detail row ( list < object [ ] > detail row ) { this . detail row = detail row ; }
public final object get value ( ) { if ( error content length == 0 ) { return null ; } if ( value ! = null ) { return value ; } if ( row ! = null & & column index ! = -1 & & column index < row . length ) { return row [ column index ] ; } return null ; }
public final p get parser setting ( ) { validate parser setting ( ) ; return parser setting ; }
public string get column name ( ) { if ( column name ! = null ) { return column name ; } string [ ] header = get header ( ) ; if ( header ! = null & & get extract column index ( ) ! = -1 & & get extract column index ( ) < header . length ) { return header [ get extracted column index ( ) ] ; } return null ; }
public long get execution row count ( ) { return execution row count . sum ( ) ; }
public string get record character ( ) { if ( error content length == 0 ) { return null ; } return record character ; }
public big decimal big decimal value ( ) { return new big decimal ( numerator ) . divide ( new big decimal ( denominator ) ) ; }
protect long from string ( string input ) { return long . value of ( input ) ; }
public string get name ( ) { int name end = user id . index of ( ' < ' ) ; if ( name end < 0 || user id . index of ( ' > ' , name end ) < 0 ) { name end = user id . length ( ) ; } name end -- ; while ( name end > = 0 & & user id . char at ( name end ) == ' ' ) { name end -- ; } int name begin = 0 ; while ( name begin < name end & & user id . char at ( name begin ) == ' ' ) { name begin++ ; } return user id . substring ( name begin , name end + 1 ) ; }
public char get list delimiter ( ) { return list delimiter ; }
public unescaped quote handle get unescaped quote handling ( ) { return this . unescaped quote handling ; }
public final void set delimiter detection enable ( boolean separator detection enable , char . . . delimiters for detection ) { this . delimiter detection enable = separator detection enable ; this . delimiters for detection = delimiters for detection ; }
public unescaped quote handle get unescaped quote handling ( ) { return this . unescaped quote handling ; }
public void set keep quote ( boolean keep quote ) { this . keep quote = keep quote ; }
public void set ignore leading whitespaces in quote ( boolean ignore lead whitespaces in quote ) { this . ignore leading whitespaces in quote = ignore leading whitespaces in quote ; }
protect final void initialize ( tsv writer setting setting ) { this . escape char = setting . get format ( ) . get escape char ( ) ; this . escape tab char = setting . get format ( ) . get escaped tab char ( ) ; this . ignore leading = setting . get ignore leading whitespaces ( ) ; this . ignore trail = setting . get ignore trail whitespaces ( ) ; this . join line = setting . be line join enable ( ) ; this . new line = setting . get format ( ) . get normalized newline ( ) ; }
public char get escape char ( ) { return this . escape char ; }
protect csv format create default format ( ) { return new csv format ( ) ; }
public static tree set < character > of all ( char . . . element ) { object . require non null ( element , `` element be null `` ) ; return tree set . of all ( iterator . of all ( element ) ) ; }
public bit set < t > of all ( java . util . stream . stream < ? extend t > java stream ) { object . require non null ( java stream , `` java stream be null `` ) ; return empty ( ) . add all ( iterator . of all ( java stream . iterator ( ) ) ) ; }
public static link hash set < double > of all ( double . . . element ) { object . require non null ( element , `` element be null `` ) ; return link hash set . of all ( iterator . of all ( element ) ) ; }
public static link hash set < boolean > of all ( boolean . . . element ) { object . require non null ( element , `` element be null `` ) ; return link hash set . of all ( iterator . of all ( element ) ) ; }
public static tree set < short > of all ( short . . . element ) { object . require non null ( element , `` element be null `` ) ; return tree set . of all ( iterator . of all ( element ) ) ; }
public static tree set < character > of all ( char . . . element ) { object . require non null ( element , `` element be null `` ) ; return tree set . of all ( iterator . of all ( element ) ) ; }
public static vector < short > of all ( short . . . element ) { object . require non null ( element , `` element be null `` ) ; return of all ( bit map trie . of all ( element ) ) ; }
public long timestamp ( ) { return timestamp ; }
public session session ( ) { if ( session == null || ! valid session ) { valid session ( true ) ; session = new session ( servlet request . get session ( ) , this ) ; } return session ; }
public void set accept sub protocol ( string protocol ) { set header ( sec_websocket_protocol , protocol ) ; }
public void set extension ( list < extension config > extension ) { this . extension . clear ( ) ; if ( extension ! = null ) { this . extension . add all ( extension ) ; } }
public string to string ( ) { return format . format annotate parameter ( this ) ; }
public string to string ( ) { return format . format annotate parameter ( this ) ; }
public void set producer ( string producer ) { info . set string ( c o s name . producer , producer ) ; }
public void fire event ( object event , event metadata metadata , annotation . . . qualifier ) { fire event ( event . get class ( ) , event , metadata , qualifier ) ; }
public boolean be disable ( ) { return disable ; }
public change collection < item change > end sync folder item ( i async result async result ) throw exception { sync folder item request request = async request result . extract service request ( this , async result ) ; return request . end execute ( async result ) . get response at index ( 0 ) . get change ( ) ; }
public boolean be wrapper for ( servlet request wrap ) { if ( request == wrap ) { return true ; } else if ( request instanceof servlet request wrapper ) { return ( ( servlet request wrapper ) request ) . be wrapper for ( wrap ) ; } else { return false ; } }
public boolean destroy ( contextual bean ) { contextual storage storage = get contextual storage ( bean , false ) ; if ( storage == null ) { return false ; } contextual instance info < ? > contextual instance info = storage . get storage ( ) . remove ( storage . get bean key ( bean ) ) ; if ( contextual instance info == null ) { return false ; } destroy bean ( bean , contextual instance info ) ; return true ; }
public < t > resolve observer < t > resolve observer method ( type event type , annotation . . . qualifier ) { check event object type ( event type ) ; return this . < t > resolve observer method ( build event resolvable ( event type , qualifier ) ) ; }
public < t > resolve observer < t > resolve observer method ( type event type , annotation . . . qualifier ) { check event object type ( event type ) ; return this . < t > resolve observer method ( build event resolvable ( event type , qualifier ) ) ; }
public < t > resolve observer < t > resolve observer method ( type event type , annotation . . . qualifier ) { check event object type ( event type ) ; return this . < t > resolve observer method ( build event resolvable ( event type , qualifier ) ) ; }
protect void cleanup ( ) { if ( reader loader ! = null ) { reader loader . cleanup ( ) ; reader loader = null ; } }
public void fire event ( object event , event metadata metadata , annotation . . . qualifier ) { fire event ( event . get class ( ) , event , metadata , qualifier ) ; }
public void bean name ( ) { bean name view resolver resolver = new bean name view resolver ( ) ; this . view resolvers . add ( resolver ) ; }
public string to string ( ) { return ( be valid ( ) ? `` valid `` : `` invalid `` ) + `` qualifier model for `` + get raw type ( ) + `` with non-binding member `` + get non bind member ( ) ; }
public < t > service bind builder < t > bind factory ( class < ? extend factory < t > > factory type , class < ? extend annotation > factory scope ) { return reset builder ( abstract bind builder . < t > create factory binder ( factory type , factory scope ) ) ; }
public static < t > dictionary builder < t > new builder ( ) { return new dictionary builder < t > ( ) ; }
public static string create type collection id ( collection < ? extend type > type ) { string builder builder = new string builder ( ) ; list < ? extend type > sort type = new array list < type > ( type ) ; collection . sort ( sorted type , type comparator . instance ) ; builder . append ( `` [ `` ) ; for ( iterator < ? extend type > iterator = sort type . iterator ( ) ; iterator . have next ( ) ; ) { builder . append ( create type id ( iterator . next ( ) ) ) ; if ( iterator . have next ( ) ) { builder . append ( `` , `` ) ; } } builder . append ( `` ] `` ) ; return builder . to string ( ) ; }
public < t > resolve observer < t > resolve observer method ( type event type , annotation . . . qualifier ) { check event object type ( event type ) ; return this . < t > resolve observer method ( build event resolvable ( event type , qualifier ) ) ; }
static public string to lower camel case ( string string ) { if ( string == null ) { return null ; } if ( string . be empty ( ) ) { return string ; } if ( string . length ( ) > 1 & & character . be upper case ( string . char at ( 1 ) ) & & character . be upper case ( string . char at ( 0 ) ) ) { return string ; } char char [ ] = string . to char array ( ) ; char [ 0 ] = character . to lower case ( char [ 0 ] ) ; return new string ( char ) ; }
public void set shell args ( string [ ] shell args ) { this . shell args . clear ( ) ; this . shell args . add all ( array . a list ( shell args ) ) ; }
public weld package ( class < ? > . . . package class ) { package . clear ( ) ; add package ( false , package class ) ; return this ; }
public object put ( object key , object value ) { string str key = string . value of ( key ) ; object old = configuration . get property ( str key ) ; configuration . set property ( str key , value ) ; return old ; }
public final t get object ( ) throw exception { if ( be singleton ( ) ) { return ( this . initialize ? this . singleton instance : get early singleton instance ( ) ) ; } else { return create instance ( ) ; } }
public void write ( record r ) throw i o exception { r . serialize ( archive , `` `` ) ; }
public purge task status get purge task status ( ) { return purge task status ; }
public static file get snap dir ( property prop ) { return new file ( prop . get property ( snap_dir ) ) ; }
public synchronize boolean remove child ( string child ) { if ( child == null ) { return false ; } return child . remove ( child ) ; }
public void set pre filter shard size ( int pre filter shard size ) { if ( pre filter shard size < 1 ) { throw new illegal argument exception ( `` pre filter shard size must be > = 1 `` ) ; } this . pre filter shard size = pre filter shard size ; }
public synchronize void close ( ) throw i o exception { if ( log stream ! = null ) { log stream . close ( ) ; } for ( file output stream log : stream to flush ) { log . close ( ) ; } }
public long position ( ) { return ( ( ( long ) index ) * allocator . get block size ( ) ) + current . limit ; }
public synchronize void commit ( ) throw i o exception { if ( log stream ! = null ) { log stream . flush ( ) ; } for ( file output stream log : stream to flush ) { log . flush ( ) ; if ( force sync ) { long start sync n s = system . nano time ( ) ; log . get channel ( ) . force ( false ) ; long sync elapse m s = time unit . nanosecond . to millis ( system . nano time ( ) - start sync n s ) ; if ( sync elapse m s > fsync warn threshold m s ) { log . warn ( `` fsync-ing the write ahead log in `` + thread . current thread ( ) . get name ( ) + `` take `` + sync elapse m s + `` m which will adversely effect operation latency . `` + `` see the zoo keeper troubleshoot guide `` ) ; } } } while ( stream to flush . size ( ) > 1 ) { stream to flush . remove first ( ) . close ( ) ; } }
protect object pool create object pool ( ) { generic object pool config config = new generic object pool config ( ) ; config . set max total ( get max size ( ) ) ; config . set max idle ( get max idle ( ) ) ; config . set min idle ( get min idle ( ) ) ; config . set max wait millis ( get max wait ( ) ) ; config . set time between eviction run millis ( get time between eviction run millis ( ) ) ; config . set min evictable idle time millis ( get min evictable idle time millis ( ) ) ; config . set block when exhaust ( be block when exhaust ( ) ) ; return new generic object pool ( this , config ) ; }
public void add child stream ( stream child stream ) { if ( child map == null || child == null ) { child = new hash set < stream > ( ) ; child map = new hash map < string , stream > ( ) ; } if ( ! child stream . have child ( this . id ) ) { child stream . set parent id ( this . id ) ; child . add ( child stream ) ; child map . put ( child stream . get id ( ) , child stream ) ; } else { system . out . println ( `` error : stream . add child stream ( ) - no cycle allow `` ) ; } }
public long get data tree last processed zxid ( ) { return data tree . last processed zxid ; }
public int get acl size ( ) { return data tree . long key map . size ( ) ; }
public list < string > get child ( string path , boolean watch ) throw keeper exception , interrupted exception { return get child ( path , watch ? watch manager . default watcher : null ) ; }
public synchronize void remove session log ( session id session id ) { if ( store log on session quit ) { return ; } thread key thread id = session to thread map . get ( session id ) ; session id session id for thread = thread to session map . get ( thread id ) ; if ( thread id ! = null & & session id for thread ! = null & & session id for thread . equal ( session id ) ) { thread to session map . remove ( thread id ) ; session to thread map . remove ( session id ) ; } per session record . remove ( session id ) ; log file repository . remove log file ( session id ) ; }
public authentication scheme basic ( string user name , string password ) { final preemptive basic auth scheme preemptive basic auth scheme = new preemptive basic auth scheme ( ) ; preemptive basic auth scheme . set user name ( user name ) ; preemptive basic auth scheme . set password ( password ) ; return preemptive basic auth scheme ; }
public void disconnect ( ) { if ( log . be debug enable ( ) ) { log . debug ( `` disconnect client for session : 0x `` + long . to hex string ( get session id ( ) ) ) ; } send thread . close ( ) ; event thread . queue event of death ( ) ; }
public inet socket address start ( ) throw i o exception { listen socket = new server socket ( ) ; listen socket . bind ( new inet socket address ( listen hostname , listen port ) ) ; logger . debug ( `` listen on { } and proxying to { } `` , listen socket . get local socket address ( ) , unix socket file . get absolute path ( ) ) ; accept thread = new thread ( ( ) - > { while ( run ) { try { socket incoming socket = listen socket . accept ( ) ; logger . debug ( `` accept incoming connection from { } `` , incoming socket . get remote socket address ( ) ) ; a f u n i x socket outgo socket = a f u n i x socket . new instance ( ) ; outgo socket . connect ( new a f u n i x socket address ( unix socket file ) ) ; new proxy pump ( incoming socket , outgo socket ) ; } catch ( i o exception ignore ) { } } } ) ; accept thread . set daemon ( true ) ; accept thread . set name ( `` tcp-unix-proxy-accept-thread `` ) ; accept thread . start ( ) ; return ( inet socket address ) listen socket . get local socket address ( ) ; }
public process executor command ( list < string > command ) { builder . command ( fix argument ( command ) ) ; return this ; }
public process executor redirect error also to ( output stream output ) { stream ( redirect error also to ( pump ( ) , output ) ) ; redirect error stream ( false ) ; return this ; }
public process executor remove listener ( class < ? extend process listener > listener type ) { listener . remove all ( listener type ) ; return this ; }
public void set default logger ( message logger default logger ) { this . default logger = default logger ; }
