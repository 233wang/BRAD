public void set human presentable name ( string human presentable name ) { this . human presentable name = human presentable name ; }
public data content handler create data content handler ( string mime type , data source d ) { return create data content handler ( mime type ) ; }
public command info [ ] get all command ( ) { if ( data source ! = null ) return get command map ( ) . get all command ( get base type ( ) , data source ) ; else return get command map ( ) . get all command ( get base type ( ) ) ; }
public string get name ( ) { return _file . get name ( ) ; }
public mime type parameter list get parameter ( ) { return parameter ; }
public int length ( ) { return value . size ( ) ; }
@ override public string to string ( ) { try { j s o n stringer stringer = new j s o n stringer ( ) ; write to ( stringer ) ; return stringer . to string ( ) ; } catch ( j s o n exception e ) { return null ; } }
public static object wrap ( object o ) { if ( o == null ) { return null ; } if ( o instanceof j s o n array || o instanceof j s o n object ) { return o ; } if ( o . equal ( null ) ) { return o ; } try { if ( o instanceof collection ) { return new j s o n array ( ( collection ) o ) ; } else if ( o . get class ( ) . be array ( ) ) { return new j s o n array ( o ) ; } if ( o instanceof map ) { return new j s o n object ( ( map ) o ) ; } if ( o instanceof boolean || o instanceof byte || o instanceof character || o instanceof double || o instanceof float || o instanceof integer || o instanceof long || o instanceof short || o instanceof string ) { return o ; } if ( o . get class ( ) . get package ( ) . get name ( ) . start with ( `` java . `` ) ) { return o . to string ( ) ; } } catch ( exception ignore ) { } return null ; }
public void reset thread context loader ( ) { if ( loader utils . be context loader available ( ) & & be context loader save ) { loader utils . set context class loader ( save context loader ) ; save context loader = null ; be context loader save = false ; } }
public void add java library ( ) { vector package = java env utils . get jre package ( ) ; enumeration e = package . element ( ) ; while ( e . have more element ( ) ) { string package name = ( string ) e . next element ( ) ; add system package root ( package name ) ; } }
public void set adapt to class ( class adapt to class ) { this . adapt to class = adapt to class ; }
public void set class loader ( class loader class loader ) { this . class loader = class loader ; }
public object create ( project project ) { return icreate ( project ) ; }
public void set exception ( throwable exception ) { this . exception = exception ; }
public throwable get exception ( ) { return cause ; }
public component helper get next ( ) { return next ; }
public void set project ( project project ) { this . project = project ; ant type table = new ant type table ( project ) ; }
public static void reset default excludes ( ) { default exclude = new vector ( ) ; for ( int i = 0 ; i < defaultexcludes . length ; i++ ) { default excludes . add ( defaultexcludes [ i ] ) ; } }
public synchronize void set case sensitive ( boolean be case sensitive ) { this . be case sensitive = be case sensitive ; }
public synchronize resource get resource ( string name ) { return new file resource ( basedir , name ) ; }
public int get status ( ) { return status ; }
public reader chain ( final reader rdr ) { class constant new filter = new class constant ( rdr ) ; return new filter ; }
public file get prepend ( ) { return prepend ; }
public void set end token ( final char end token ) { this . end token = end token ; }
public void set tablength ( final int tab length ) { this . tab length = tab length ; }
public reader chain ( final reader rdr ) { tail filter new filter = new tail filter ( rdr ) ; new filter . set line ( get line ( ) ) ; new filter . set skip ( get skip ( ) ) ; new filter . set initialized ( true ) ; return new filter ; }
public project get project ( ) { return project ; }
public void set current project name ( string name ) { this . current project name = name ; }
public void set ignore project tag ( boolean flag ) { this . ignore project tag = flag ; }
public unknown element parse unknown element ( project project , url source ) throw build exception { target dummy target = new target ( ) ; dummy target . set project ( project ) ; ant x m l context context = new ant x m l context ( project ) ; context . add target ( dummy target ) ; context . set implicit target ( dummy target ) ; parse ( context . get project ( ) , source , new root handler ( context , element handler ) ) ; task [ ] task = dummy target . get task ( ) ; if ( task . length ! = 1 ) { throw new build exception ( `` no task define `` ) ; } return ( unknown element ) task [ 0 ] ; }
protect static void set project handler ( ant handler handler ) { project handler = handler ; }
public void set input ( string input ) { this . input = input ; }
public boolean be input valid ( ) { return true ; }
public static synchronize introspection helper get helper ( class c ) { return get helper ( null , c ) ; }
public static void start ( string [ ] args , property additional user property , class loader core loader ) { main m = new main ( ) ; m . start ant ( args , additional user property , core loader ) ; }
public filter set get global filter set ( ) { return global filter set ; }
public void add filter ( string token , string value ) { if ( token == null ) { return ; } global filter set . add filter ( new filter set . filter ( token , value ) ) ; }
public file get base dir ( ) { if ( base dir == null ) { try { set basedir ( `` . `` ) ; } catch ( build exception ex ) { ex . print stack trace ( ) ; } } return base dir ; }
public boolean be keep go mode ( ) { return this . keep go mode ; }
public void add task definition ( string task name , class task class ) throw build exception { component helper . get component helper ( this ) . add task definition ( task name , task class ) ; }
public task create task ( string task type ) throw build exception { return component helper . get component helper ( this ) . create task ( task type ) ; }
protect void fire target start ( target target ) { build event event = new build event ( target ) ; iterator iter = listener . iterator ( ) ; while ( iter . have next ( ) ) { build listener listener = ( build listener ) iter . next ( ) ; listener . target start ( event ) ; } }
protect void fire message log ( task task , string message , int priority ) { fire message log ( task , message , null , priority ) ; }
public resource get resource ( string name ) { return new file resource ( get base dir ( ) , name ) ; }
public static void store child ( project project , object parent , object child , string tag ) { introspection helper ih = introspection helper . get helper ( project , parent . get class ( ) ) ; ih . store element ( project , parent , child , tag ) ; }
public static string extract name from component name ( string component name ) { int index = component name . last index of ( ' : ' ) ; if ( index == -1 ) { return component name ; } return component name . substring ( index + 1 ) ; }
public synchronize object get property ( string ns , string name ) { if ( name == null ) { return null ; } object o = get property hook ( ns , name , false ) ; if ( o ! = null ) { return o ; } return property . get ( name ) ; }
public synchronize enumeration get child ( ) { return ( child == null ) ? new collection utils . empty enumeration ( ) : collection . enumeration ( child ) ; }
public location get location ( ) { return location ; }
public void execute ( ) throw build exception { if ( test if condition ( ) & & test unless condition ( ) ) { for ( int task position = 0 ; task position < child . size ( ) ; ++task position ) { object o = child . get ( task position ) ; if ( o instanceof task ) { task task = ( task ) o ; task . perform ( ) ; } else { runtime configurable r = ( runtime configurable ) o ; r . maybe configure ( project ) ; } } } else if ( ! test if condition ( ) ) { project . log ( this , `` skip because property ' `` + project . replace property ( if condition ) + `` ' not set . `` , project . msg_verbose ) ; } else { project . log ( this , `` skip because property ' `` + project . replace property ( unless condition ) + `` ' set . `` , project . msg_verbose ) ; } }
protect void handle error flush ( string output ) { handle error output ( output ) ; }
public void set proxy ( object o ) { this . proxy = o ; }
public void set command ( string c ) { this . command = c ; }
public void set noexec ( boolean ne ) { noexec = ne ; }
public void set maxmemory ( string max ) { max memory = max ; }
public void set output ( string output file ) { this . output = output file ; }
public void add reference ( reference ref ) { reference . add element ( ref ) ; }
public void set compiler ( string compiler ) { log ( error_ignoring_compiler_option , project . msg_warn ) ; }
public string get compiler ( ) { return super . get compiler ( ) ; }
public void set preprocess dir ( file preprocess dir ) { this . preprocess dir = preprocess dir ; }
public void set search parent ( boolean search parent ) { this . search parent = search parent ; }
public void set file ( file file ) { this . file = file ; }
public void set read buffer size ( int size ) { this . read buffer size = size ; }
protect void check configuration ( ) { if ( ! have perm ) { throw new build exception ( `` require attribute perm not set in chmod `` , get location ( ) ) ; } if ( default set define & & default set . get dir ( get project ( ) ) ! = null ) { add fileset ( default set ) ; } super . check configuration ( ) ; }
protect boolean be valid o ( ) { return o . be family ( o . family_unix ) & & super . be valid o ( ) ; }
public void set parent name ( string name ) { this . parent name = name ; }
protect final enumeration get condition ( ) { return condition . element ( ) ; }
public void add uptodate ( up to date u ) { condition . add element ( u ) ; }
public void set substring ( string sub string ) { this . sub string = sub string ; }
public void set textfile ( boolean textfile ) { this . textfile = textfile ; }
public void set error begin at ( int error begin at ) { this . error begin at = error begin at ; }
public void set file ( file file ) { this . file = file ; }
public static boolean be version ( string version ) { return be os ( null , null , null , version ) ; }
public void set enable multiple mapping ( boolean enable multiple mapping ) { this . enable multiple mapping = enable multiple mapping ; }
public void set output encode ( string encode ) { this . output encode = encoding ; }
protect map scan ( resource [ ] from resource , file to dir ) { return build map ( from resource , to dir , get mapper ( ) ) ; }
public void set destfile ( final file d file ) { this . d file = d file ; }
public void add user ( final cv user user ) { cv user . add element ( user ) ; }
public void set userid ( final string user i d ) { this . user i d = user i d ; }
public string get displayname ( ) { return display name ; }
public void set classpath ref ( reference r ) { get delegate ( ) . set classpathref ( r ) ; }
public void add selector ( select selector selector ) { used match task = true ; super . add selector ( selector ) ; }
public void add or ( or selector selector ) { used match task = true ; super . add or ( selector ) ; }
public void add none ( none selector selector ) { used match task = true ; super . add none ( selector ) ; }
public void add depend ( depend selector selector ) { used match task = true ; super . add depend ( selector ) ; }
public void add srcfileset ( file set f ) { create source ( ) . add ( f ) ; }
public void set file ( file file ) { this . file = file ; }
public void set password ( string password ) { this . password = password ; }
public void set reply to ( string address ) { this . reply to list . add ( new email address ( address ) ) ; }
public void set to list ( string list ) { string tokenizer token = new string tokenizer ( list , `` , `` ) ; while ( token . have more token ( ) ) { to list . add element ( new email address ( token . next token ( ) ) ) ; } }
public void add bcc ( email address address ) { bcc list . add element ( address ) ; }
public void set value ( string value ) { this . value = value ; }
public void add text ( string text ) { buffer . append ( text ) ; }
public void set output ( string out ) { this . out = out ; }
public string [ ] get environment ( ) { return ( env == null || new environment ) ? env : patch environment ( ) ; }
public void set environment ( string [ ] env ) { this . env = env ; }
public synchronize void timeout occur ( watchdog w ) { if ( thread ! = null ) { time out = true ; thread . interrupt ( ) ; } notify all ( ) ; }
public void set max parallel ( int max ) { max parallel = max ; }
public void set force ( boolean b ) { force = b ; }
public mapper create mapper ( ) throw build exception { if ( mapper element ! = null ) { throw new build exception ( `` can not define more than one mapper `` , get location ( ) ) ; } mapper element = new mapper ( get project ( ) ) ; return mapper element ; }
protect void setup redirector ( ) { super . setup redirector ( ) ; redirector . set append property ( true ) ; }
protect string [ ] get commandline ( string src file , file base dir ) { return get commandline ( new string [ ] { src file } , new file [ ] { base dir } ) ; }
public void set d ( file d ) { this . d = d ; }
public void set d ( file dest ) { this . d = dest ; }
protect void pack ( ) { g z i p output stream z out = null ; try { z out = new g z i p output stream ( new file output stream ( zip file ) ) ; zip resource ( get src resource ( ) , z out ) ; } catch ( i o exception ioe ) { string msg = `` problem create gzip `` + ioe . get message ( ) ; throw new build exception ( msg , ioe , get location ( ) ) ; } finally { file utils . close ( z out ) ; } }
public void set manifest ( file manifest file ) { if ( ! manifest file . exists ( ) ) { throw new build exception ( `` manifest file : `` + manifest file + `` do not exist . `` , get location ( ) ) ; } this . manifest file = manifest file ; }
public void set classpath ( path classpath ) { if ( compile classpath == null ) { compile classpath = classpath ; } else { compile classpath . append ( classpath ) ; } }
public path create classpath ( ) { if ( compile classpath == null ) { compile classpath = new path ( get project ( ) ) ; } return compile classpath . create path ( ) ; }
public void set classpath ref ( reference r ) { create classpath ( ) . set refid ( r ) ; }
public void set listfiles ( boolean list ) { list file = list ; }
public boolean get listfiles ( ) { return list file ; }
public boolean get deprecation ( ) { return deprecation ; }
public string get memory maximum size ( ) { return memory maximum size ; }
public boolean get optimize ( ) { return optimize ; }
public void set sourcepath ( path src ) { if ( source path == null ) { source path = src ; } else { source path . append ( src ) ; } }
public void set private ( boolean b ) { add arg if ( b , `` -private `` ) ; }
public doclet info create doclet ( ) { if ( doclet == null ) { doclet = new doclet info ( ) ; } return doclet ; }
public void set author ( boolean b ) { author = b ; }
public void set nodeprecated ( boolean b ) { add arg if ( b , `` -nodeprecated `` ) ; }
public void set nodeprecatedlist ( boolean b ) { add arg if ( b , `` -nodeprecatedlist `` ) ; }
public void set notree ( boolean b ) { add arg if ( b , `` -notree `` ) ; }
public void set classpath ref ( reference r ) { create classpath ( ) . set refid ( r ) ; }
public void set autocommit ( boolean autocommit ) { this . autocommit = autocommit ; }
public string get user id ( ) { return user id ; }
public void set userid ( string user id ) { this . user id = user id ; }
public void set key ( string key ) { if ( key ! = null & & key . length ( ) > 0 ) { string tokenizer tok = new string tokenizer ( key , this . sep , false ) ; while ( tok . have more token ( ) ) { string token = tok . next token ( ) . trim ( ) ; string tokenizer itok = new string tokenizer ( token , `` = `` , false ) ; string name = itok . next token ( ) ; string value = itok . next token ( ) ; replacement . put ( name , value ) ; } } }
public void set resource ( string resource ) { assert src be java resource ( ) ; ( ( java resource ) src ) . set name ( resource ) ; }
public void set quiet ( final boolean quiet ) { this . quiet = quiet ; if ( quiet ) { this . fail on error = false ; } }
public final void add filter chain ( filter chain filter ) { filter chain . add element ( filter ) ; }
public void add configure element ( template element element ) { if ( element . get name ( ) == null ) { throw new build exception ( `` the element nest element need a \ `` name\ `` attribute `` ) ; } if ( element . get ( element . get name ( ) ) ! = null ) { throw new build exception ( `` the element `` + element . get name ( ) + `` have already be specify `` ) ; } if ( have implicit element || ( element . be implicit ( ) & & element . size ( ) ! = 0 ) ) { throw new build exception ( `` only one element allow when use implicit element `` ) ; } have implicit element = element . be implicit ( ) ; element . put ( element . get name ( ) , element ) ; }
public object create dynamic element ( string name ) throw build exception { throw new build exception ( `` not implement any more `` ) ; }
public section get main section ( ) { return main section ; }
public void set max parent level ( int level ) { this . max parent level = level ; }
public void set mode ( mode m ) { mode = m ; }
public void xset item ( string item string ) { log ( `` the item attribute be deprecate . `` + `` please use the include attribute . `` , project . msg_warn ) ; if ( item string == null || item string . equal ( `` * `` ) || item string . equal ( `` . `` ) ) { create include ( ) . set name ( `` * * `` ) ; } else { string tokenizer tok = new string tokenizer ( item string , `` , `` ) ; while ( tok . have more token ( ) ) { string pattern = tok . next token ( ) . trim ( ) ; if ( pattern . length ( ) > 0 ) { create include ( ) . set name ( pattern + `` / * * `` ) ; } } } }
public void add different ( different selector selector ) { fileset . add different ( selector ) ; }
protect void delete dir ( file d ) { delete dir ( d , false ) ; }
public void set new priority ( int new priority ) { if ( new priority < thread . min_priority || new priority > thread . max_priority ) { throw new build exception ( `` the thread priority be out of the range 1-10 `` ) ; } this . new priority = new integer ( new priority ) ; }
public void set src resource ( resource src ) { if ( src . be directory ( ) ) { throw new build exception ( `` the source ca n't be a directory `` ) ; } if ( src instanceof file resource ) { source = ( ( file resource ) src ) . get file ( ) ; } else if ( ! support non file resource ( ) ) { throw new build exception ( `` only file system resource be `` + `` support . `` ) ; } this . src = src ; }
public void execute ( ) throw build exception { validate ( ) ; resource s = get src resource ( ) ; if ( ! s . be exists ( ) ) { log ( `` nothing to do : `` + s . to string ( ) + `` do n't exist . `` ) ; } else if ( zip file . last modified ( ) < s . get last modified ( ) ) { log ( `` building : `` + zip file . get absolute path ( ) ) ; pack ( ) ; } else { log ( `` nothing to do : `` + zip file . get absolute path ( ) + `` be up to date . `` ) ; } }
public void set ignorewhitespace ( boolean ignore ) { if ( ignore ) { cmd . create argument ( ) . set value ( `` -l `` ) ; } }
public void set reverse ( boolean r ) { if ( r ) { cmd . create argument ( ) . set value ( `` -r `` ) ; } }
public boolean be reference ( ) { return refid ! = null ; }
public void set value ( string value ) { this . value = value ; }
protect output stream get err ( ) { return err ; }
protect void create process error pump ( input stream be , output stream o ) { error thread = create pump ( be , os ) ; }
public void set record state ( boolean state ) { if ( state ! = null ) { flush ( ) ; record = state . boolean value ( ) ; } }
public void sub build finish ( build event event ) { if ( event . get project ( ) == project ) { cleanup ( ) ; } }
public void set property file ( file property file ) { this . property file = property file ; }
public void set property ( string p ) { property = p ; }
protect commandline setup rmic command ( ) { string [ ] option = new string [ ] { `` - xnew `` } ; commandline commandline = super . setup rmic command ( option ) ; return commandline ; }
public void set source base ( file source base ) { this . source base = source base ; }
public string get stub version ( ) { return stub version ; }
public vector get file list ( ) { return compile list ; }
public void set includeantruntime ( boolean include ) { include ant runtime = include ; }
public implementation specific argument create compiler arg ( ) { implementation specific argument arg = new implementation specific argument ( ) ; facade . add implementation argument ( arg ) ; return arg ; }
public void execute ( ) throw build exception { for ( iterator i = nest task . iterator ( ) ; i . have next ( ) ; ) { task nest task = ( task ) i . next ( ) ; nest task . perform ( ) ; } }
public void set d dir ( file d dir ) { this . d dir = d dir ; }
public void handle output ( string output ) { if ( ant ! = null ) { ant . handle output ( output ) ; } else { super . handle output ( output ) ; } }
public void set generic antfile ( file afile ) { this . genericantfile = afile ; }
public void set failonerror ( boolean fail on error ) { this . fail on error = fail on error ; }
public void set buildpath ( path s ) { get buildpath ( ) . append ( s ) ; }
public void set include empty dirs ( boolean include empty ) { my copy . set include empty dirs ( include empty ) ; }
protect boolean check ( file basedir , string [ ] file ) { boolean up to date = true ; if ( ! archive be up to date ( file , basedir ) ) { up to date = false ; } for ( int i = 0 ; i < file . length ; ++i ) { if ( tar file . equal ( new file ( basedir , file [ i ] ) ) ) { throw new build exception ( `` a tar file can not include `` + `` itself `` , get location ( ) ) ; } } return up to date ; }
protect static final string [ ] get file name ( file set f ) { directory scanner d = f . get directory scanner ( f . get project ( ) ) ; string [ ] directories = d . get included directory ( ) ; string [ ] file per se = d . get included file ( ) ; string [ ] file = new string [ directory . length + file per se . length ] ; system . arraycopy ( directory , 0 , file , 0 , directory . length ) ; system . arraycopy ( file per se , 0 , file , directory . length , file per se . length ) ; return file ; }
public void set property ( string property ) { this . property = property ; }
public void set src resource ( resource src ) { if ( ! src . be exists ( ) ) { throw new build exception ( `` the archive do n't exist `` ) ; } if ( src . be directory ( ) ) { throw new build exception ( `` the archive ca n't be a directory `` ) ; } if ( src instanceof file resource ) { source = ( ( file resource ) src ) . get file ( ) ; } else if ( ! support non file resource ( ) ) { throw new build exception ( `` only file system resource be `` + `` support . `` ) ; } src resource = src ; }
public void set srcfile ( final file file ) { this . source file = file ; }
public void execute ( ) throw build exception { if ( property == null ) { throw new build exception ( `` property attribute be require . `` , get location ( ) ) ; } boolean up to date = eval ( ) ; if ( up to date ) { get project ( ) . set new property ( property , get value ( ) ) ; if ( mapper element == null ) { log ( `` file \ `` `` + target file . get absolute path ( ) + `` \ `` be up-to-date . `` , project . msg_verbose ) ; } else { log ( `` all target file be up-to-date . `` , project . msg_verbose ) ; } } }
protect boolean scan dir ( file src dir , string [ ] file ) { source file scanner sfs = new source file scanner ( this ) ; file name mapper mapper = get mapper ( ) ; file dir = src dir ; if ( mapper element == null ) { dir = null ; } return sfs . restrict ( file , src dir , dir , mapper ) . length == 0 ; }
public void set certificate ( boolean certificate ) { this . certificate = certificate ; }
protect void process timeout ( ) { log ( get task name ( ) + `` : timeout `` , project . msg_verbose ) ; if ( timeout property ! = null ) { get project ( ) . set new property ( timeout property , `` true `` ) ; } }
public void add configure x m l catalog ( x m l catalog catalog ) { xml catalog . add configured x m l catalog ( catalog ) ; }
public void set basedir ( file dir ) { base dir = dir ; }
public void set in ( file in file ) { this . in file = in file ; }
public void init ( ) throw build exception { super . init ( ) ; xml catalog . set project ( get project ( ) ) ; }
public void set filesonly ( boolean f ) { do filesonly = f ; }
public void set duplicate ( duplicate df ) { duplicate = df . get value ( ) ; }
public int get level ( ) { return level ; }
public void execute ( ) throw build exception { if ( double file pas ) { skip write = true ; execute main ( ) ; skip write = false ; execute main ( ) ; } else { execute main ( ) ; } }
protect void clean up ( ) { added dirs . clear ( ) ; add file . remove all element ( ) ; entry . clear ( ) ; add new file = false ; do update = save do update ; enumeration e = filesets from groupfilesets . element ( ) ; while ( e . have more element ( ) ) { zip file set zf = ( zip file set ) e . next element ( ) ; resource . remove element ( zf ) ; } filesets from groupfilesets . remove all element ( ) ; }
public synchronize pattern set . name entry create include file ( ) { if ( be reference ( ) ) { throw no child allow ( ) ; } directory scanner = null ; return default pattern . create include file ( ) ; }
public void add custom ( extend selector selector ) { append selector ( selector ) ; }
public void set classpath ( path classpath ) { if ( be reference ( ) ) { throw too many attribute ( ) ; } if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } }
public file get src ( project p ) { if ( be reference ( ) ) { return ( ( archive file set ) get ref ( p ) ) . get src ( p ) ; } return get src ( ) ; }
public file get src ( ) { if ( src instanceof file resource ) { return ( ( file resource ) src ) . get file ( ) ; } return null ; }
public string get prefix ( project p ) { if ( be reference ( ) ) { return ( ( archive file set ) get ref ( p ) ) . get prefix ( p ) ; } return prefix ; }
public iterator iterator ( ) { if ( be reference ( ) ) { return ( ( resource collection ) ( get ref ( get project ( ) ) ) ) . iterator ( ) ; } if ( src == null ) { return super . iterator ( ) ; } archive scanner a = ( archive scanner ) get directory scanner ( get project ( ) ) ; return a . get resource file ( ) ; }
/ * package-private for now * / iterator get resource file ( ) { if ( src == null ) { return new file resource iterator ( get basedir ( ) , get include file ( ) ) ; } scanme ( ) ; return match file entry . value ( ) . iterator ( ) ; }
public assertion get assertion ( ) { return assertion ; }
public string get classname ( ) { if ( ! execute jar ) { return java command . get executable ( ) ; } return null ; }
public commandline get vm command ( ) { return get actual v m command ( ) ; }
public path get bootclasspath ( ) { return bootclasspath ; }
public reference get refid ( ) { return ref ; }
public object clone ( ) { if ( be reference ( ) ) { return ( ( dir set ) get ref ( get project ( ) ) ) . clone ( ) ; } else { return super . clone ( ) ; } }
protect file list get ref ( project p ) { return ( file list ) get check ref ( p ) ; }
public void add strip line comment ( final strip line comment strip line comment ) { filter reader . add element ( strip line comment ) ; }
public void add ( chainable reader filter ) { filter reader . add element ( filter ) ; }
protect filter set get ref ( ) { return ( filter set ) get check ref ( filter set . class , `` filterset `` ) ; }
public synchronize hashtable get filter hash ( ) { if ( filter hash == null ) { filter hash = new hashtable ( get filter ( ) . size ( ) ) ; for ( enumeration e = get filter ( ) . element ( ) ; e . have more element ( ) ; ) { filter filter = ( filter ) e . next element ( ) ; filter hash . put ( filter . get token ( ) , filter . get value ( ) ) ; } } return filter hash ; }
public void set filtersfile ( file filter file ) throw build exception { if ( be reference ( ) ) { throw too many attribute ( ) ; } filter file . add ( filter file ) ; }
public synchronize void add filter ( filter filter ) { if ( be reference ( ) ) { throw no child allow ( ) ; } filter . add element ( filter ) ; filter hash = null ; }
public void add configure ( file name mapper file name mapper ) { add ( file name mapper ) ; }
public path element create path element ( ) throw build exception { if ( be reference ( ) ) { throw no child allow ( ) ; } path element pe = new path element ( ) ; add ( pe ) ; return pe ; }
public path concat system classpath ( ) { return concat system classpath ( `` last `` ) ; }
public string [ ] get include pattern ( project p ) { if ( be reference ( ) ) { return get ref ( p ) . get include pattern ( p ) ; } else { read file ( p ) ; return make array ( include list , p ) ; } }
public synchronize void set security manager ( ) throw build exception { orig sm = system . get security manager ( ) ; init ( ) ; system . set security manager ( new my s m ( ) ) ; active = true ; }
public void append name ( string name ) { property ref r = new property ref ( ) ; r . set name ( name ) ; add propertyref ( r ) ; }
public void append regex ( string regex ) { property ref r = new property ref ( ) ; r . set regex ( regex ) ; add propertyref ( r ) ; }
public void add configure error mapper ( mapper error mapper ) { if ( be reference ( ) ) { throw no child allow ( ) ; } if ( this . error mapper ! = null ) { if ( use error ) { throw new build exception ( `` attribute \ `` error\ `` `` + `` can not coexist with a nested < errormapper > `` ) ; } else { throw new build exception ( `` can not have > 1 < errormapper > `` ) ; } } this . error mapper = error mapper ; }
public object get reference object ( ) throw build exception { if ( project == null ) { throw new build exception ( `` no project set on reference to `` + refid ) ; } return get reference object ( project ) ; }
public void set name ( string name ) { check attribute allow ( ) ; this . name = name ; }
public long get last modified ( ) { if ( be reference ( ) ) { return ( ( resource ) get check ref ( ) ) . get last modified ( ) ; } if ( ! be exists ( ) || lastmodified == null ) { return unknown_datetime ; } long result = lastmodified . long value ( ) ; return result < unknown_datetime ? unknown_datetime : result ; }
public boolean equal ( object another ) { if ( this == another ) { return true ; } if ( be reference ( ) ) { return get check ref ( ) . equal ( another ) ; } if ( ! ( another . get class ( ) . equal ( get class ( ) ) ) ) { return false ; } archive resource r = ( archive resource ) another ; return get archive ( ) . equal ( r . get archive ( ) ) & & get name ( ) . equal ( r . get name ( ) ) ; }
public void set binary ( boolean b ) { binary = b ; }
protect int resource compare ( resource foo , resource bar ) { return ( int ) ( foo . get last modified ( ) - bar . get last modified ( ) ) ; }
public synchronize int hash code ( ) { if ( be reference ( ) ) { return get check ref ( ) . hash code ( ) ; } return v == null ? 0 : v . hash code ( ) ; }
public void set name ( string name ) throw build exception { throw new build exception ( `` you ca n't change the name of a compressed `` + `` resource `` ) ; }
public boolean have next ( ) { if ( wrap == null ) { return false ; } fail fast ( this ) ; return wrap . have next ( ) ; }
public void set file ( file f ) { check attribute allow ( ) ; file = f ; }
public file get file ( ) { return be reference ( ) ? ( ( file resource ) get check ref ( ) ) . get file ( ) : file ; }
public string get name ( ) { if ( be reference ( ) ) { return ( ( resource ) get check ref ( ) ) . get name ( ) ; } file b = get base dir ( ) ; return b == null ? get not null file ( ) . get name ( ) : file_utils . remove lead path ( b , get not null file ( ) ) ; }
public boolean have next ( ) { return po < file . length ; }
public synchronize pattern set merge pattern ( project p ) { if ( be reference ( ) ) { return get ref ( ) . merge pattern ( p ) ; } pattern set p = new pattern set ( ) ; p . append ( default pattern , p ) ; final int count = additional pattern . size ( ) ; for ( int i = 0 ; i < count ; i++ ) { object o = additional pattern . element at ( i ) ; p . append ( ( pattern set ) o , p ) ; } return p ; }
protect output stream wrap stream ( output stream out ) throw i o exception { return new g z i p output stream ( out ) ; }
public synchronize string to string ( ) { if ( be reference ( ) ) { return get check ref ( ) . to string ( ) ; } die on circular reference ( ) ; return w . to string ( ) ; }
public synchronize long get millis ( ) { return millis == null ? -1l : millis . long value ( ) ; }
public synchronize void set granularity ( long g ) { granularity = g ; }
public synchronize void set when ( time comparison c ) { when = c ; }
public string get type ( ) { return type ; }
public synchronize string get value ( ) { return get name ( ) ; }
public void selector create ( ) { if ( classname ! = null & & classname . length ( ) > 0 ) { try { class c = null ; if ( classpath == null ) { c = class . for name ( classname ) ; } else { ant class loader al = get project ( ) . create class loader ( classpath ) ; c = class . for name ( classname , true , al ) ; } dynselector = ( file selector ) c . new instance ( ) ; final project p = get project ( ) ; if ( p ! = null ) { p . set project reference ( dynselector ) ; } } catch ( class not find exception cnfexcept ) { set error ( `` selector `` + classname + `` not initialize , no such class `` ) ; } catch ( instantiation exception iexcept ) { set error ( `` selector `` + classname + `` not initialize , could not create class `` ) ; } catch ( illegal access exception iaexcept ) { set error ( `` selector `` + classname + `` not initialize , class not accessible `` ) ; } } else { set error ( `` there be no classname specify `` ) ; } }
public final path create classpath ( ) { if ( be reference ( ) ) { throw no child allow ( ) ; } if ( this . classpath == null ) { this . classpath = new path ( get project ( ) ) ; } return this . classpath . create path ( ) ; }
public void add param ( string key , object value ) { parameter par = new parameter ( ) ; par . set name ( key ) ; par . set value ( string . value of ( value ) ) ; config parameter . add ( par ) ; }
public boolean be select ( file basedir , string filename , file file ) { validate ( ) ; enumeration e = selector element ( ) ; boolean result ; while ( e . have more element ( ) ) { result = ( ( file selector ) e . next element ( ) ) . be select ( basedir , filename , file ) ; if ( result ) { return false ; } } return true ; }
public void set unless ( string unless property ) { this . unless property = unless property ; }
public void set uid ( int uid ) { check tar file set attribute allow ( ) ; user id set = true ; this . uid = uid ; }
public void set group ( string group name ) { check tar file set attribute allow ( ) ; group name set = true ; this . group name = group name ; }
public void set gid ( int gid ) { check tar file set attribute allow ( ) ; group id set = true ; this . gid = gid ; }
protect abstract file set get ref ( project p ) { die on circular reference ( p ) ; object o = get refid ( ) . get referenced object ( p ) ; if ( o instanceof tar file set ) { return ( abstract file set ) o ; } else if ( o instanceof file set ) { tar file set zfs = new tar file set ( ( file set ) o ) ; configure file set ( zfs ) ; return zfs ; } else { string msg = get refid ( ) . get ref id ( ) + `` doesn\'t denote a tarfileset or a fileset `` ; throw new build exception ( msg ) ; } }
public static int compare ( long t1 , long t2 ) { return compare ( t1 , t2 , file_utils . get file timestamp granularity ( ) ) ; }
public void set encoding ( string enc ) { check zip file set attribute allow ( ) ; this . encode = enc ; }
protect abstract file set get ref ( project p ) { die on circular reference ( p ) ; object o = get refid ( ) . get referenced object ( p ) ; if ( o instanceof zip file set ) { return ( abstract file set ) o ; } else if ( o instanceof file set ) { zip file set zfs = new zip file set ( ( file set ) o ) ; configure file set ( zfs ) ; return zfs ; } else { string msg = get refid ( ) . get ref id ( ) + `` doesn\'t denote a zipfileset or a fileset `` ; throw new build exception ( msg ) ; } }
public object clone ( ) { if ( be reference ( ) ) { return ( ( zip file set ) get ref ( get project ( ) ) ) . clone ( ) ; } else { return super . clone ( ) ; } }
public void set ignore error ( boolean b ) { ignore error = b ; }
public void add configure ( file name mapper file name mapper ) { add ( file name mapper ) ; }
public string to string ( ) { final string buffer sb = new string buffer ( ) ; for ( int i = 0 ; i < component . length ; i++ ) { if ( i ! = 0 ) { sb . append ( ' . ' ) ; } sb . append ( component [ i ] ) ; } return sb . to string ( ) ; }
public string get implementation ( ) { return user choice ! = null ? user choice : ( magic value ! = null ? magic value : default value ) ; }
public void set implementation ( string impl ) { this . impl = impl ; }
public file create temp file ( string prefix , string suffix , file parent dir ) { return create temp file ( prefix , suffix , parent dir , false ) ; }
public boolean file name equal ( file f1 , file f2 ) { return normalize ( f1 . get absolute path ( ) ) . equal ( normalize ( f2 . get absolute path ( ) ) ) ; }
public void rename ( file from , file to ) throw i o exception { if ( to . exists ( ) & & ! to . delete ( ) ) { throw new i o exception ( `` fail to delete `` + to + `` while try to rename `` + from ) ; } file parent = to . get parent file ( ) ; if ( parent ! = null & & ! parent . exists ( ) & & ! parent . mkdirs ( ) ) { throw new i o exception ( `` fail to create directory `` + parent + `` while try to rename `` + from ) ; } if ( ! from . rename to ( to ) ) { copy file ( from , to ) ; if ( ! from . delete ( ) ) { throw new i o exception ( `` fail to delete `` + from + `` while try to rename it . `` ) ; } } }
public static class loader get context class loader ( ) { thread current thread = thread . current thread ( ) ; return current thread . get context class loader ( ) ; }
public static boolean be context loader available ( ) { return true ; }
public object invoke ( string method name , class arg type , object arg ) { return reflect util . invoke ( obj , method name , arg type , arg ) ; }
public void add text ( string text ) { this . script += text ; }
public script runner base get script runner ( ) { script runner base runner = get runner ( ) ; if ( src file ! = null ) { runner . set src ( src file ) ; } if ( text ! = null ) { runner . add text ( text ) ; } if ( set bean ) { runner . bind to component ( project component ) ; } else { runner . bind to component minimum ( project component ) ; } return runner ; }
public synchronize void start ( ) { stop = false ; thread t = new thread ( this , `` watchdog `` ) ; t . set daemon ( true ) ; t . start ( ) ; }
public void set debug ( boolean debug ) { this . debug = debug ; }
public int get user id ( ) { return this . user id ; }
public void set group name ( string group name ) { this . group name = new string buffer ( group name ) ; }
public boolean be g n u long name entry ( ) { return link flag == lf_gnutype_longname & & name . to string ( ) . equal ( gnu_longlink ) ; }
public void close entry ( ) throw i o exception { if ( this . assem len > 0 ) { for ( int i = this . assem len ; i < this . assem buf . length ; ++i ) { this . assem buf [ i ] = 0 ; } this . buffer . write record ( this . assem buf ) ; this . curr bytes += this . assem len ; this . assem len = 0 ; } if ( this . curr bytes < this . curr size ) { throw new i o exception ( `` entry ' `` + curr name + `` ' close at ' `` + this . curr bytes + `` ' before the ' `` + this . curr size + `` ' byte specify in the header be write `` ) ; } }
public static long parse octal ( byte [ ] header , int offset , int length ) { long result = 0 ; boolean still pad = true ; int end = offset + length ; for ( int i = offset ; i < end ; ++i ) { if ( header [ i ] == 0 ) { break ; } if ( header [ i ] == ( byte ) ' ' || header [ i ] == ' 0 ' ) { if ( still pad ) { continue ; } if ( header [ i ] == ( byte ) ' ' ) { break ; } } still pad = false ; result = ( result < < 3 ) + ( header [ i ] - ' 0 ' ) ; } return result ; }
public void set user id ( int uid ) { this . uid = uid ; }
protect int get mode ( int mode ) { int type = file_flag ; if ( be link ( ) ) { type = link_flag ; } else if ( be directory ( ) ) { type = dir_flag ; } return type | ( mode & perm_mask ) ; }
public byte [ ] get central directory data ( ) { return no_bytes ; }
public byte [ ] get local file data data ( ) { return local data ; }
public long get external attribute ( ) { return external attribute ; }
public byte [ ] get local file data extra ( ) { byte [ ] extra = get extra ( ) ; return extra ! = null ? extra : new byte [ 0 ] ; }
public byte [ ] get byte ( ) { return zip long . get byte ( value ) ; }
public void set method ( int method ) { this . method = method ; }
public static int get value ( byte [ ] bytes ) { return get value ( byte , 0 ) ; }
public boolean be restrict ( ) { return restrict ; }
public void handle input ( input request request ) throw build exception { string prompt = get prompt ( request ) ; try { object console = reflect util . invoke static ( system . class , `` console `` ) ; do { char [ ] input = ( char [ ] ) reflect util . invoke ( console , `` read password `` , string . class , prompt , object [ ] . class , ( object [ ] ) null ) ; request . set input ( new string ( input ) ) ; / * for security zero char array after retrieve value * / java . util . array . fill ( input , ' ' ) ; } while ( ! request . be input valid ( ) ) ; } catch ( exception e ) { / * java6 not present use default handler * / super . handle input ( request ) ; } }
public static string get short ant version ( ) throw build exception { if ( short ant version == null ) { get ant version ( ) ; } return short ant version ; }
public static void set current prefix separator ( string sep ) { prefix separator . set ( sep ) ; }
public static void set in include mode ( boolean include mode ) { in include mode . set ( boolean . value of ( include mode ) ) ; }
public boolean test unless condition ( object value ) { return null or empty ( value ) || ! eval a boolean or property name ( value ) ; }
public void execute ( ) { restore wrapper id ( ) ; }
public void add ( resource r ) { if ( resource ! = null ) { throw new build exception ( `` only one resource can be test `` ) ; } resource = r ; }
protect void internal set encoding ( string encode ) { if ( native_encoding . equal ( encode ) ) { encode = null ; } this . encode = encoding ; }
public void set scan for unicode extra field ( boolean b ) { internal set scan for unicode extra field ( b ) ; }
protect final boolean be in include mode ( ) { return `` include `` . equal ( get task type ( ) ) ; }
public void set flatten attribute ( boolean b ) { flatten class path = b ; }
public static void set v m launcher ( project project , command launcher launcher ) { if ( project ! = null ) { project . add reference ( ant_vm_launcher_ref_id , launcher ) ; } }
public boolean get trim ( ) { return trim ! = null & & trim . boolean value ( ) ; }
public void execute ( ) { if ( name == null ) { throw new build exception ( `` miss attribute name `` ) ; } local property . get ( get project ( ) ) . add local ( name ) ; }
public file get dir ( ) { return dir ; }
protect file create list file ( vector file ) throw i o exception { file list file = file_utils . create temp file ( `` ant `` , `` `` , null , true , true ) ; buffer writer writer = null ; try { writer = new buffer writer ( new file writer ( list file ) ) ; final int size = file . size ( ) ; for ( int i = 0 ; i < size ; i++ ) { writer . write ( '\ `` ' + file . element at ( i ) . to string ( ) + '\ `` ' ) ; writer . new line ( ) ; } } finally { file utils . close ( writer ) ; } return list file ; }
public string get platform ( ) { return platform ; }
public string get comment file ( ) { return m cfile ; }
public boolean get preserve time ( ) { return m ptime ; }
public void set no data ( boolean ndata ) { m ndata = ndata ; }
public boolean get obsolete ( ) { return m obsolete ; }
public string get comment ( ) { return m comment ; }
public void set type name ( string tn ) { m type name = tn ; }
public void set checkin ( boolean ci ) { m checkin = ci ; }
public void set eltype ( string eltype ) { m eltype = eltype ; }
public void set v o b ( string vob ) { m v o b = vob ; }
public string get v o b ( ) { return m v o b ; }
public boolean get global ( ) { return m global ; }
public string get type kind ( ) { return m type kind ; }
public string get view path ( ) { return mview path ; }
public void read ( data input stream cp stream ) throw i o exception { index = cp stream . read unsigned short ( ) ; class name = `` unresolved `` ; }
public void read ( data input stream cp stream ) throw i o exception { set value ( new double ( cp stream . read double ( ) ) ) ; }
public void resolve ( constant pool constant pool ) { class c p info field class = ( class c p info ) constant pool . get entry ( class index ) ; field class . resolve ( constant pool ) ; field class name = field class . get class name ( ) ; name and type c p info nt = ( name and type c p info ) constant pool . get entry ( name and type index ) ; nt . resolve ( constant pool ) ; field name = nt . get name ( ) ; field type = nt . get type ( ) ; super . resolve ( constant pool ) ; }
public string get field name ( ) { return field name ; }
public string get interface method class name ( ) { return interface method class name ; }
public string get method class name ( ) { return method class name ; }
public void set fail on error ( boolean failonerror ) { this . failonerror = failonerror ; }
public void set regex ( string regex ) { if ( regex ! = null & & regex . length ( ) ! = 0 ) { this . regex = regex ; property set p = new property set ( ) ; p . set project ( get project ( ) ) ; p . append regex ( regex ) ; add propertyset ( p ) ; } }
public void set verify ( boolean verify ) { this . verify = verify ; }
public void set b a sdtd ( string in string ) { this . borland d t d = in string ; }
protect string get public id ( ) { return null ; }
public void set nogenic ( boolean a boolean ) { nogenic = a boolean ; }
public void set w l classpath ( path wl classpath ) { this . wl classpath = wl classpath ; }
public void set ejbc class ( string ejbc class ) { this . ejbc class = ejbc class ; }
protect descriptor handler get websphere descriptor handler ( final file src dir ) { descriptor handler handler = new descriptor handler ( get task ( ) , src dir ) { protect void process element ( ) { } } ; for ( iterator i = get config ( ) . dtd location . iterator ( ) ; i . have next ( ) ; ) { ejb jar . d t d location dtd location = ( ejb jar . d t d location ) i . next ( ) ; handler . register d t d ( dtd location . get public id ( ) , dtd location . get location ( ) ) ; } return handler ; }
public static extension [ ] get option ( final manifest manifest ) { return get list ( manifest , optional_extension_list ) ; }
public void set extension name ( final string extension name ) { verify not a reference ( ) ; this . extension name = extension name ; }
public void set implementation version ( final string implementation version ) { verify not a reference ( ) ; this . implementation version = new dewey decimal ( implementation version ) ; }
public void set property ( final string property ) { this . property name = property ; }
public string to string ( ) { return `` location [ `` + location + `` ] `` ; }
public void set start token ( string start token ) { this . start token = start token ; }
public void validate attribute ( ) throw build exception { if ( task . get action ( ) == null ) { throw new build exception ( `` the \ `` action\ `` attribute must be set `` ) ; } if ( ! be action valid ( ) ) { throw new build exception ( `` invalid action \ `` `` + task . get action ( ) + `` \ `` pass `` ) ; } if ( classpath == null ) { throw new build exception ( `` the classpath attribute must be set `` ) ; } }
public string get password ( ) { return password ; }
protect boolean be action valid ( ) { boolean valid = false ; string action = get task ( ) . get action ( ) ; for ( int i = 0 ; i < valid_actions . length ; i++ ) { if ( action . equal ( valid_actions [ i ] ) ) { valid = true ; break ; } } return valid ; }
public void set source ( file source ) { this . source = source ; }
public string get argument ( ) throw build exception { string action = get task ( ) . get action ( ) ; string args = null ; if ( action . equal ( action_deploy ) || action . equal ( action_update ) ) { args = build deploy args ( ) ; } else if ( action . equal ( action_delete ) || action . equal ( action_undeploy ) ) { args = build undeploy args ( ) ; } else if ( action . equal ( action_list ) ) { args = build list args ( ) ; } return args ; }
public void set text ( boolean plain text ) { optional attrs . put ( text , plain text ? boolean . true : boolean . false ) ; this . plain text = plain text ; }
public void set onetable ( boolean one table ) { optional attrs . put ( one_table , one table ? boolean . true : boolean . false ) ; }
public void set nodeprefix ( string node prefix ) { optional attrs . put ( node_prefix , node prefix ) ; }
public void set class ( string cl ) { this . cl = cl ; }
public file get uriroot ( ) { return uriroot ; }
public void set sock proxy port ( int port ) { this . sock proxy port = port ; }
public string get filename format ( ) { return filename format ; }
public void set filename format ( string f ) { filename format = f ; }
public void set line start ( string l ) { line start = l ; }
public string get pvcsproject ( ) { return pvc project ; }
public void set revision ( string r ) { revision = r ; }
public void set match ( string match ) { if ( regex ! = null ) { throw new build exception ( `` only one regular expression be allow `` ) ; } regex = new regular expression ( ) ; regex . set pattern ( match ) ; }
public void set output ( file output ) { this . output = output ; }
public void add configure schema ( schema location location ) { log ( `` add schema `` + location , project . msg_debug ) ; location . validate namespace ( ) ; schema location old = ( schema location ) schema location . get ( location . get namespace ( ) ) ; if ( old ! = null & & ! old . equal ( location ) ) { throw new build exception ( error_duplicate_schema + location ) ; } schema location . put ( location . get namespace ( ) , location ) ; }
protect x m l reader create default reader ( ) { s a x parser factory factory = s a x parser factory . new instance ( ) ; factory . set validating ( true ) ; factory . set namespace aware ( true ) ; x m l reader reader = null ; try { s a x parser sax parser = factory . new s a x parser ( ) ; reader = sax parser . get x m l reader ( ) ; } catch ( parser configuration exception e ) { throw new build exception ( error_parser_creation_failure , e ) ; } catch ( s a x exception e ) { throw new build exception ( error_parser_creation_failure , e ) ; } return reader ; }
public void execute script ( map attribute , map element ) { execute script ( attribute , element , null ) ; }
public void set manager ( string manager ) { helper . set manager ( manager ) ; }
public void set dynamic attribute ( string name , string value ) { script def definition = get script ( ) ; if ( ! definition . be attribute support ( name ) ) { throw new build exception ( `` < `` + get task type ( ) + `` > do not support the \ `` `` + name + `` \ `` attribute `` ) ; } attribute . put ( name , value ) ; }
public void fail ( string message ) { throw new build exception ( message ) ; }
protect string get vss server path ( ) { return v server path ; }
protect string get sos home ( ) { return sos home ; }
public void set label ( string label ) { super . set internal label ( label ) ; }
public void set version ( string version ) { super . set internal version ( version ) ; }
public void add setup ( sequential sequence ) { log override ( `` setup `` , setup ) ; setup = sequence ; }
public build exception get teardown exception ( ) { return teardown exception ; }
public void set command ( commandline cmdl ) { throw new build exception ( get task type ( ) + `` doesn\'t support the command attribute `` , get location ( ) ) ; }
public void set overwrite ( boolean owrite ) { this . overwrite = owrite ; }
protect void set internal from label ( final string from label ) { this . from label = from label ; }
protect string get version ( ) { return version ! = null ? flag_version + version : `` `` ; }
protect string get localpath ( ) { return local path ; }
public void set recursive ( boolean recursive ) { super . set internal recursive ( recursive ) ; }
public void set version ( string version ) { super . set internal version ( version ) ; }
public void set date ( string date ) { super . set internal date ( date ) ; }
public void set comment ( string comment ) { super . set internal comment ( comment ) ; }
public void set classpath ref ( reference r ) { create classpath ( ) . set refid ( r ) ; }
protect boolean be sax1 parser ( ) { return ( xml reader instanceof parser adapter ) ; }
public void set fail on error ( boolean value ) { fail on error = value ; }
public synchronize void add configure ( property helper property helper ) { if ( this . property helper ! = null ) { throw new build exception ( `` only one property helper can be instal `` ) ; } this . property helper = property helper ; }
public void set fail on no replacement ( boolean b ) { fail on no replacement = b ; }
public void set destdir ( file destdir ) { this . d dir = destdir ; }
public void set sig alg ( string sig alg ) { this . sig alg = sig alg ; }
public void set row count property ( string row count property ) { this . row count property = row count property ; }
public void add ( resource collection rc ) { get path ( ) . add ( rc ) ; }
public void set fail on error ( boolean b ) { fail on error = b ; }
public void set fail on no resource ( boolean b ) { fail on no resource = b ; }
protect final zip extra field [ ] get current extra field ( ) { return ( zip extra field [ ] ) current_zip_extra . get ( ) ; }
public void add ( file selector selector ) { append selector ( selector ) ; }
public void set value ( boolean value ) { this . value = value ; }
public long get last modified ( ) { if ( be reference ( ) ) { return ( ( resource ) get check ref ( ) ) . get last modified ( ) ; } if ( ! be exists ( ) || lastmodified == null ) { return unknown_datetime ; } long result = lastmodified . long value ( ) ; return result < unknown_datetime ? unknown_datetime : result ; }
protected archive file set configure archive ( archive file set afs , resource src ) { afs . set project ( get project ( ) ) ; afs . set src resource ( src ) ; return afs ; }
public void set regex ( string r ) { regex = r ; reg = null ; }
public void add text ( string text ) { check child allow ( ) ; set value ( get project ( ) . replace property ( text ) ) ; }
public static vector < string > tokenize path ( string path ) { return tokenize path ( path , file . separator ) ; }
public tokenized pattern to pattern ( ) { return new tokenized pattern ( path , tokenized path ) ; }
public file create temp file ( string prefix , string suffix , file parent dir ) { return create temp file ( prefix , suffix , parent dir , false , false ) ; }
public void add text ( string text ) { script += text ; }
public void add ( int index , e o ) { do add ( index , o ) ; }
public void rethrow any build exception ( ) { build exception ex = get build exception ( ) ; if ( ex ! = null ) { throw ex ; } }
public boolean be g n u long link entry ( ) { return link flag == lf_gnutype_longlink & & name . equal ( gnu_longlink ) ; }
public static big integer get value ( byte [ ] byte , int offset ) { long value = ( ( long ) bytes [ offset + byte_7 ] < < byte_7_shift ) & byte_7_mask ; value += ( ( long ) bytes [ offset + byte_6 ] < < byte_6_shift ) & byte_6_mask ; value += ( ( long ) bytes [ offset + byte_5 ] < < byte_5_shift ) & byte_5_mask ; value += ( ( long ) bytes [ offset + byte_4 ] < < byte_4_shift ) & byte_4_mask ; value += ( ( long ) bytes [ offset + byte_3 ] < < byte_3_shift ) & byte_3_mask ; value += ( ( long ) bytes [ offset + byte_2 ] < < byte_2_shift ) & byte_2_mask ; value += ( ( long ) bytes [ offset + byte_1 ] < < byte_1_shift ) & byte_1_mask ; value += ( ( long ) bytes [ offset ] & byte_mask ) ; big integer val = big integer . value of ( value ) ; return ( bytes [ offset + byte_7 ] & leftmost_bit ) == leftmost_bit ? val . set bit ( leftmost_bit_shift ) : val ; }
public void set fallback to u t f8 ( boolean b ) { fallback to u t f8 = b ; }
public int mark ( ) { return -1 ; }
public long get total s l l lookahead ops ( ) { decision info [ ] decision = atn simulator . get decision info ( ) ; long k = 0 ; for ( int i = 0 ; i < decision . length ; i++ ) { k += decision [ i ] . s l l_ total look ; } return k ; }
public void reset ( ) { seek ( 0 ) ; }
public boolean start before non disjoint ( interval other ) { return this . a < =other . a & & this . b > =other . a ; }
public static interval set or ( interval set [ ] set ) { interval set r = new interval set ( ) ; for ( interval set s : set ) r . add all ( s ) ; return r ; }
public int get max element ( ) { if ( be nil ( ) ) { throw new runtime exception ( `` set be empty `` ) ; } interval last = interval . get ( interval . size ( ) -1 ) ; return last . b ; }
public boolean equal ( object obj ) { if ( obj==null || ! ( obj instanceof interval set ) ) { return false ; } interval set other = ( interval set ) obj ; return this . interval . equal ( other . interval ) ; }
public int get ( int i ) { int n = interval . size ( ) ; int index = 0 ; for ( int j = 0 ; j < n ; j++ ) { interval i = interval . get ( j ) ; int a = i . a ; int b = i . b ; for ( int v=a ; v < =b ; v++ ) { if ( index==i ) { return v ; } index++ ; } } return -1 ; }
public void set token factory ( token factory < ? > factory ) { _input . get token source ( ) . set token factory ( factory ) ; }
public atn get a t n with bypass alt ( ) { string serialize atn = get serialize a t n ( ) ; if ( serialize atn == null ) { throw new unsupported operation exception ( `` the current parser do not support an atn with bypass alternative . `` ) ; } synchronize ( bypass alt atn cache ) { atn result = bypass alt atn cache . get ( serialize atn ) ; if ( result == null ) { a t n deserialization option deserialization option = new a t n deserialization option ( ) ; deserialization option . set generate rule bypass transition ( true ) ; result = new a t n deserializer ( deserialization option ) . deserialize ( serialize atn . to char array ( ) ) ; bypass alt atn cache . put ( serialize atn , result ) ; } return result ; } }
public terminal node create terminal node ( parser rule context parent , token t ) { return new terminal node impl ( t ) ; }
public < t extend parse tree > t add any child ( t t ) { if ( children==null ) child = new array list < > ( ) ; child . add ( t ) ; return t ; }
public terminal node add child ( terminal node t ) { t . set parent ( this ) ; return add any child ( t ) ; }
public terminal node add child ( token match token ) { terminal node impl t = new terminal node impl ( match token ) ; add any child ( t ) ; t . set parent ( this ) ; return t ; }
public parse info get parse info ( ) { return null ; }
public void set interpreter ( a t n interpreter interpreter ) { _interp = interpreter ; }
public boolean succeed ( ) { return mismatch node == null ; }
public void visit attribute ( final attribute attribute ) { if ( cv ! = null ) { cv . visit attribute ( attribute ) ; } }
public void visit permit subtype experimental ( final string permit subtype ) { if ( api ! = opcodes . asm8_experimental ) { throw new unsupported operation exception ( `` this feature require asm8_experimental `` ) ; } if ( cv ! = null ) { cv . visit permit subtype experimental ( permitted subtype ) ; } }
public int new module ( final string module name ) { return symbol table . add constant module ( module name ) . index ; }
public handle get bootstrap method ( ) { return bootstrap method ; }
public object get bootstrap method argument ( final int index ) { return bootstrap method argument [ index ] ; }
public void visit attribute ( final attribute attribute ) { if ( fv ! = null ) { fv . visit attribute ( attribute ) ; } }
public int get tag ( ) { return tag ; }
public annotation visitor visit annotation default ( ) { if ( mv ! = null ) { return mv . visit annotation default ( ) ; } return null ; }
public void visit int insn ( final int opcode , final int operand ) { if ( mv ! = null ) { mv . visit int insn ( opcode , operand ) ; } }
public void visit line number ( final int line , final label start ) { if ( mv ! = null ) { mv . visit line number ( line , start ) ; } }
public signature visitor visit class bound ( ) { return this ; }
protect module visitor create module remapper ( final module visitor module visitor ) { return new module remapper ( api , module visitor , remapper ) ; }
public string get descriptor ( ) { return descriptor ; }
public type get return type ( ) { return type . get return type ( descriptor ) ; }
public abstract insn node get previous ( ) { return previous insn ; }
public abstract insn node [ ] to array ( ) { int current insn index = 0 ; abstract insn node current insn = first insn ; abstract insn node [ ] insn node array = new abstract insn node [ size ] ; while ( current insn ! = null ) { insn node array [ current insn index ] = current insn ; current insn . index = current insn index++ ; current insn = current insn . next insn ; } return insn node array ; }
public void clear ( ) { remove all ( false ) ; }
public void accept ( final module visitor module visitor ) { module visitor . visit open ( packaze , access , module == null ? null : module . to array ( new string [ 0 ] ) ) ; }
public string get exception ( ) { return exception == null ? null : exception . to string ( ) ; }
public self be not close to ( big decimal expect , percentage percentage ) { big decimal . assert be not close to percentage ( info , actual , expect , percentage ) ; return myself ; }
public self be less than or equal to ( big decimal other ) { return super . be less than or equal to ( other ) ; }
public self be great than or equal to ( big decimal other ) { return super . be great than or equal to ( other ) ; }
public self contains sequence ( boolean . . . sequence ) { array . assert contain sequence ( info , actual , sequence ) ; return myself ; }
public self contains key ( k key ) { return contain key ( key ) ; }
public self contains key ( @ suppress warning ( `` unchecked `` ) k . . . key ) { map . assert contain key ( info , actual , key ) ; return myself ; }
public self contain only null ( ) { array . assert contain only null ( info , actual ) ; return myself ; }
public self do not contain sequence ( @ suppress warning ( `` unchecked `` ) element . . . sequence ) { array . assert do not contain sequence ( info , actual , sequence ) ; return myself ; }
public self be equal to ignore give field ( object other , string . . . property or field to ignore ) { object . assert be equal to ignore give field ( info , actual , other , comparator by property or field , get comparators by type ( ) , property or field to ignore ) ; return myself ; }
public self have no null field or property except ( string . . . property or field to ignore ) { object . assert have no null field or property except ( info , actual , property or field to ignore ) ; return myself ; }
public < t > self use comparator for type ( comparator < ? super t > comparator , class < t > type ) { get comparators by type ( ) . put ( type , comparator ) ; return myself ; }
public self be not equal to ( zone date time expect ) { return super . be not equal to ( same instant in actual time zone ( expect ) ) ; }
public static list < string > line of ( url url , charset charset ) { return u r l . line of ( url , charset ) ; }
public atomic reference array assert < t > contain only null ( ) { array . assert contain only null ( info , array ) ; return myself ; }
public atomic reference array assert < t > be ( condition < ? super t > condition ) { array . assert be ( info , array , condition ) ; return myself ; }
public atomic reference array assert < t > be exactly ( int time , condition < ? super t > condition ) { array . assert be exactly ( info , array , time , condition ) ; return myself ; }
public boolean match ( t value ) { check predicate ( predicate ) ; return predicate . test ( value ) ; }
public void override error message ( string new error message ) { override error message = new error message ; }
protect long get difference ( temporal temporal1 , temporal temporal2 ) { return ab ( unit . between ( temporal1 , temporal2 ) ) ; }
public void assert start with ( assertion info info , byte [ ] actual , byte [ ] sequence ) { array . assert start with ( info , failure , actual , sequence ) ; }
public boolean be remove assert j related element from stack trace ( ) { return remove assert j related element from stack trace ; }
public void assert same content a ( assertion info info , input stream actual , input stream expect ) { check not null ( expect , `` the input stream to compare to should not be null `` ) ; assert not null ( info , actual ) ; try { list < delta < string > > diffs = diff . diff ( actual , expect ) ; if ( diffs . be empty ( ) ) return ; throw failure . failure ( info , should have same content ( actual , expect , diffs ) ) ; } catch ( i o exception e ) { string msg = format ( `` unable to compare content of input stream : % n < % s > % nand : % n < % s > `` , actual , expect ) ; throw new input stream exception ( msg , e ) ; } }
public void assert be subset of ( assertion info info , iterable < ? > actual , iterable < ? > value ) { assert not null ( info , actual ) ; check iterable be not null ( info , value ) ; list < object > extra = stream ( actual ) . filter ( actual element - > ! iterable contains ( value , actual element ) ) . collect ( to list ( ) ) ; if ( extra . size ( ) > 0 ) throw failure . failure ( info , should be subset of ( actual , value , extra , comparison strategy ) ) ; }
public void assert be not zero ( assertion info info , number actual ) { assert not equal by comparison ( info , actual , zero ( ) ) ; }
public void assert be not negative ( assertion info info , number actual ) { assert great than or equal to ( info , actual , zero ( ) ) ; }
public void assert be not positive ( assertion info info , number actual ) { assert less than or equal to ( info , actual , zero ( ) ) ; }
public void assert contain only null ( assertion info info , object [ ] actual ) { array . assert contain only null ( info , failure , actual ) ; }
public void assert be not exactly instance of ( assertion info info , object actual , class < ? > type ) { if ( actual be exactly instance of type ( actual , type , info ) ) throw failure . failure ( info , should not be exactly instance ( actual , type ) ) ; }
public void assert be in ( assertion info info , object actual , object [ ] value ) { check be not null and not empty ( value ) ; assert be in ( info , actual , a list ( value ) ) ; }
public static synchronize string format a datetime ( date date ) { return date == null ? null : iso_date_time_format . format ( date ) ; }
public static calendar to calendar ( date date ) { if ( date == null ) { return null ; } calendar calendar = calendar . get instance ( ) ; calendar . set time ( date ) ; return calendar ; }
public static int millisecond of ( date date ) { return to calendar ( date ) . get ( calendar . millisecond ) ; }
public list < delta < t > > get delta ( ) { collection . sort ( delta , delta comparator . instance ) ; return delta ; }
public void set allow use private field ( boolean allow use private field ) { this . allow use private field = allow use private field ; }
public < t > t property value ( string property name , class < t > clazz , object target ) { method getter = get property getter ( property name , target ) ; try { return ( t ) getter . invoke ( target ) ; } catch ( class cast exception e ) { string msg = format ( `` unable to obtain the value of the property < ' % s ' > from < % s > - wrong property type specify < % s > `` , property name , target , clazz ) ; throw new introspection error ( msg , e ) ; } catch ( exception unexpected ) { string msg = format ( `` unable to obtain the value of the property < ' % s ' > from < % s > `` , property name , target ) ; throw new introspection error ( msg , unexpected ) ; } }
public self have size great than ( int boundary ) { array . assert have size great than ( info , actual , boundary ) ; return myself ; }
public self have size less than ( int boundary ) { iterables . assert have size less than ( info , actual , boundary ) ; return myself ; }
public self contain only ( @ suppress warning ( `` unchecked `` ) element . . . value ) { array . assert contain only ( info , actual , value ) ; return myself ; }
public self have all null field or property except ( string . . . property or field to ignore ) { object . assert have all null field or property except ( info , actual , property or field to ignore ) ; return myself ; }
public static abstract int array assert < ? > give ( int [ ] actual ) { return assume that ( actual ) ; }
public static abstract long assert < ? > give ( long actual ) { return assume that ( actual ) ; }
public static abstract float array assert < ? > give ( float [ ] actual ) { return assume that ( actual ) ; }
public static abstract character assert < ? > give ( char actual ) { return assume that ( actual ) ; }
public set < class < ? > > get ignore type ( ) { return ignore type ; }
public recursive comparison assert < ? > ignore field of type ( class < ? > . . . type to ignore ) { recursive comparison configuration . ignore field of type ( type to ignore ) ; return myself ; }
public self ignore collection order in field match regexes ( string . . . regexes ) { recursive comparison configuration . ignore collection order in field match regexes ( regexes ) ; return myself ; }
public void apply ( ) { assertion . set allow compare private field ( compare private field enable ( ) ) ; assertion . set allow extract private field ( extract private field enable ( ) ) ; assertion . set extract bare name property method ( bare name property extraction enable ( ) ) ; assertion . set lenient date parsing ( lenient date parsing enable ( ) ) ; assertion . set max element for printing ( max element for printing ( ) ) ; assertion . set max length for single line description ( max length for single line description ( ) ) ; assertion . set remove assert j related element from stack trace ( remove assert j related element from stack trace enable ( ) ) ; assertion . use representation ( representation ( ) ) ; additional date format ( ) . for each ( assertion : : register custom date format ) ; }
public void assert have size in byte ( assertion info info , file actual , long expect size in byte ) { assert be file ( info , actual ) ; if ( expect size in byte == actual . length ( ) ) return ; throw failure . failure ( info , should have size ( actual , expect size in byte ) ) ; }
public static < t > t [ ] array ( t . . . value ) { return value ; }
protect void fail with message ( string error message , object . . . argument ) { throw failure ( error message , argument ) ; }
public self have field or property ( string name ) { object . assert have field or property ( info , actual , name ) ; return myself ; }
public atomic reference assert < v > have value ( v expect value ) { be not null ( ) ; v actual value = actual . get ( ) ; if ( ! object . get comparison strategy ( ) . be equal ( actual value , expect value ) ) { throw assertion error ( should have value ( actual , expect value ) ) ; } return myself ; }
public static short2 d array assert give ( short [ ] [ ] actual ) { return assume that ( actual ) ; }
public self be equal to ignore null field ( object other ) { object . assert be equal to ignore null field ( info , actual , other , comparator by property or field , comparator by type ) ; return myself ; }
public self have no null field or property except ( string . . . property or field to ignore ) { object . assert have no null field or property except ( info , actual , property or field to ignore ) ; return myself ; }
public self have field or property ( string name ) { object . assert have field or property ( info , actual , name ) ; return myself ; }
public self be equal to compare field by field recursively ( object other ) { object . assert be equal to compare field by field recursively ( info , actual , other , comparator by property or field , comparator by type ) ; return myself ; }
public self be close to ( short expect , offset < short > offset ) { short . assert be close to ( info , actual , expect , offset ) ; return myself ; }
public atomic reference array assert < t > be ( condition < ? super t > condition ) { array . assert be ( info , array , condition ) ; return myself ; }
public v set value ( v value ) { throw new unsupported operation exception ( ) ; }
public void write ( final node node ) throw i o exception { write ( `` `` , node , new stack < node > ( ) ) ; }
public static < t > async queue < t > unbounded ( ) { return new unbounded queue < > ( ) ; }
public static < t > bound async queue < t > buffer ( final int max buffer ) { return new buffer queue < > ( max buffer ) ; }
public static void do not catch uncaught exception by default ( ) { default catch uncaught exception = false ; }
public condition factory condition evaluation listener ( condition evaluation listener condition evaluation listener ) { return new condition factory ( alias , timeout , poll interval , poll delay , catch uncaught exception , condition evaluation listener ) ; }
public < t > name and annotation field supplier < t > of type ( class < t > field type ) { this . expect field type = field type ; return new name and annotation field supplier < t > ( ) ; }
public static < t > t get internal state ( object object , class < t > field type ) { field find field = find field in hierarchy ( object , new assignable to field type matcher strategy ( field type ) ) ; try { return ( t ) find field . get ( object ) ; } catch ( illegal access exception e ) { throw new runtime exception ( `` internal error : fail to get field in method get internal state . `` , e ) ; } }
public static class < ? > get type ( object object ) { class < ? > type = null ; if ( be class ( object ) ) { type = ( class < ? > ) object ; } else if ( object ! = null ) { type = object . get class ( ) ; } return type ; }
public static void ignore exception by default ( final class < ? extend throwable > exception type ) { default exception ignorer = new predicate exception ignorer ( e - > e . get class ( ) . equal ( exception type ) ) ; }
public condition factory ignore exception match ( predicate < ? super throwable > predicate ) { return new condition factory ( alias , timeout constraint , poll interval , poll delay , catch uncaught exception , new predicate exception ignorer ( predicate ) , condition evaluation listener , executor lifecycle ) ; }
public asm visitor wrapper . for declared method on ( element matcher < ? super method description > matcher ) { return new asm visitor wrapper . for declared method ( ) . invokable ( matcher , this ) ; }
public modifier adjustment with method modifier ( element matcher < ? super method description > matcher , modifier contributor . for method . . . modifier contributor ) { return with method modifier ( matcher , arrays . a list ( modifier contributor ) ) ; }
public modifier adjustment with constructor modifier ( modifier contributor . for method . . . modifier contributor ) { return with constructor modifier ( array . a list ( modifier contributor ) ) ; }
public static type reference adjustment strict ( ) { return new type reference adjustment ( true , none ( ) ) ; }
public dynamic type . builder < ? > make record ( ) { type description . generic record = instrument type . default . of ( java type . record . get type stub ( ) . get name ( ) , type description . generic . object , visibility . public ) . with method ( new method description . token ( opcodes . acc_protected ) ) . with method ( new method description . token ( `` hash code `` , opcodes . acc_public | opcodes . acc_abstract , type description . for loaded type . of ( int . class ) . a generic type ( ) ) ) . with method ( new method description . token ( `` equal `` , opcodes . acc_public | opcodes . acc_abstract , type description . for loaded type . of ( boolean . class ) . a generic type ( ) , collection . singleton list ( type description . generic . object ) ) ) . with method ( new method description . token ( `` to string `` , opcodes . acc_public | opcodes . acc_abstract , type description . for loaded type . of ( string . class ) . a generic type ( ) ) ) . a generic type ( ) ; return new subclass dynamic type builder < object > ( instrument type factory . subclass ( name strategy . subclass ( record ) , opcodes . acc_public | opcodes . acc_final , record ) . with record ( true ) , class file version , auxiliary type name strategy , annotation value filter factory , annotation retention , implementation context factory , method graph compiler , type validation , visibility bridge strategy , class writer strategy , ignore method , record constructor strategy . instance ) . method ( be hash code ( ) ) . intercept ( record object method . hash_code ) . method ( be equal ( ) ) . intercept ( record object method . equal ) . method ( be to string ( ) ) . intercept ( record object method . to_string ) ; }
public < t > dynamic type . builder < t > rebase ( class < t > type ) { return rebase ( type , class file locator . for class loader . of ( type . get class loader ( ) ) ) ; }
public static stack manipulation of ( serializable value ) { if ( value == null ) { return null constant . instance ; } try { byte array output stream byte array output stream = new byte array output stream ( ) ; object output stream object output stream = new object output stream ( byte array output stream ) ; try { object output stream . write object ( value ) ; } finally { object output stream . close ( ) ; } return new serialize constant ( byte array output stream . to string ( charset ) ) ; } catch ( i o exception exception ) { throw new illegal state exception ( `` can not serialize `` + value , exception ) ; } }
public static stack manipulation of ( type definition type definition ) { if ( type definition . be primitive ( ) ) { if ( type definition . represent ( long . class ) ) { return long ; } else if ( type definition . represent ( double . class ) ) { return double ; } else if ( type definition . represent ( float . class ) ) { return float ; } else if ( type definition . represent ( void . class ) ) { return void ; } else { return integer ; } } else { return reference ; } }
public equal method with enumeration type field first ( ) { return with field order ( type property comparator . for_enumeration_types ) ; }
public static without specify target invoke ( method locator . factory method locator ) { return new without specify target ( method locator ) ; }
public method call with all argument ( ) { return with ( argument loader . for method parameter . of instrumented method . instance ) ; }
public static < t extend type definition > element matcher . junction < t > be primitive ( ) { return new primitive type matcher < t > ( ) ; }
protect void on visit var insn ( int opcode , int offset ) { super . visit var insn ( opcode , offset ) ; }
protect void on visit table switch insn ( int minimum , int maximum , label default target , label . . . label ) { super . visit table switch insn ( minimum , maximum , default target , label ) ; }
public double hit rate ( ) { long request count = request count ( ) ; return ( request count == 0 ) ? 1 . 0 : ( double ) hit count / request count ; }
public long eviction count ( ) { return eviction count ; }
public void advance ( long current time nanos ) { long previous time nanos = nanos ; try { nanos = current time nanos ; for ( int i = 0 ; i < shift . length ; i++ ) { long previous tick = ( previous time nanos > > > shift [ i ] ) ; long current tick = ( current time nanos > > > shift [ i ] ) ; if ( ( current tick - previous tick ) < = 0l ) { break ; } expire ( i , previous tick , current tick ) ; } } catch ( throwable t ) { nanos = previous time nanos ; throw t ; } }
public void set sourcepath ( final string p ) { if ( src path ! = null ) throw new build exception ( `` src path can not be specify twice . `` ) ; src path = new path ( get project ( ) , p ) ; }
public static conversion category from conversion char ( char c ) { for ( conversion category v : new conversion category [ ] { general , char , int , float , time } ) { if ( v . char . contains ( string . value of ( c ) ) ) { return v ; } } throw new illegal argument exception ( ) ; }
public static @ unsigned short to unsigned short ( @ unsigned byte b ) { return ( short ) ( ( ( int ) b ) & 0xff ) ; }
public static string to unsigned string ( @ unsigned short s , int radix ) { return integer . to unsigned string ( short . to unsigned int ( s ) , radix ) ; }
public resolve field [ ] get static field ( ) { if ( _static field == null ) { _static field = resolve static field ( ) ; } return _static field ; }
protect void register fast cloners ( ) { fast cloners . put ( gregorian calendar . class , new fast cloner calendar ( ) ) ; fast cloners . put ( array list . class , new fast cloner array list ( ) ) ; fast cloners . put ( link list . class , new fast cloner link list ( ) ) ; fast cloners . put ( hash set . class , new fast cloner hash set ( ) ) ; fast cloners . put ( hash map . class , new fast cloner hash map ( ) ) ; fast cloners . put ( tree map . class , new fast cloner tree map ( ) ) ; fast cloners . put ( concurrent hash map . class , new fast cloner concurrent hash map ( ) ) ; }
public void set extra null instead of clone ( final set < class < ? > > set ) { null instead . add all ( set ) ; }
public string get u r l ( ) { return _url ; }
public void remove comet listener ( ) { _comet listener . clear ( ) ; }
public void update transient interval ( long interval ) { _transient interval = interval ; }
public static string retrieve stream ( string id ) { return `` select * from `` + streams_table_name + `` where `` + streams_id_key + `` = `` + format text value ( id ) + `` ; `` ; }
public void add stream ( stream stream ) { if ( this . stream == null ) { this . stream = new hash set < stream > ( ) ; } this . stream . add ( stream ) ; }
public void add tag ( string tag ) { if ( tags == null ) { tags = new hash set < string > ( ) ; } tag . add ( tag ) ; }
public static boolean be online active ( ) { return online activate ; }
public void log ( string message ) { stream . println ( message + `` - thread : `` + thread . current thread ( ) . get name ( ) ) ; }
public void remove ( string name , string key ) { object value = value . get ( name ) ; if ( value == null ) { throw new null pointer exception ( `` no mapped value for ' `` + name + `` ( `` + key + `` ) ' `` ) ; } else if ( value instanceof map ) { ( ( map ) value ) . remove ( key ) ; } else { throw new illegal argument exception ( `` non-mapped property for ' `` + name + `` ( `` + key + `` ) ' `` ) ; } }
protect dyna property get dyna property ( string name ) { dyna property descriptor = get dyna class ( ) . get dyna property ( name ) ; if ( descriptor == null ) { throw new illegal argument exception ( `` invalid property name ' `` + name + `` ' `` ) ; } return ( descriptor ) ; }
public comparator get comparator ( ) { return comparator ; }
public string to string ( ) { return `` bean map < `` + string . value of ( bean ) + `` > `` ; }
public static boolean init cause ( throwable throwable , throwable cause ) { return bean utils bean . get instance ( ) . init cause ( throwable , cause ) ; }
public static boolean get cache fast ( map map ) { if ( map instanceof weak fast hash map ) { return ( ( weak fast hash map ) map ) . get fast ( ) ; } else { return false ; } }
public convert utils bean get convert utils ( ) { return convert utils bean ; }
protect object initial value ( ) { return null ; }
public string to string ( ) { return `` converter facade [ `` + converter . to string ( ) + `` ] `` ; }
public void set time zone ( time zone time zone ) { this . time zone = time zone ; }
public string get pattern ( ) { return pattern ; }
public void set pattern ( string pattern ) { this . pattern = pattern ; set use locale format ( true ) ; }
public string to string ( ) { string buffer buffer = new string buffer ( ) ; buffer . append ( to string ( get class ( ) ) ) ; buffer . append ( `` [ use default= `` ) ; buffer . append ( be use default ( ) ) ; buffer . append ( `` , use locale format= `` ) ; buffer . append ( use locale format ) ; if ( pattern ! = null ) { buffer . append ( `` , pattern= `` ) ; buffer . append ( pattern ) ; } if ( locale ! = null ) { buffer . append ( `` , locale= `` ) ; buffer . append ( locale ) ; } buffer . append ( ' ] ' ) ; return buffer . to string ( ) ; }
public static boolean get default boolean ( ) { return ( convert utils bean . get instance ( ) . get default boolean ( ) ) ; }
public static void set default boolean ( boolean new default boolean ) { convert utils bean . get instance ( ) . set default boolean ( new default boolean ) ; }
public class get type ( ) { return ( this . type ) ; }
public boolean be map ( ) { if ( type == null ) { return ( false ) ; } else { return ( map . class . be assignable from ( type ) ) ; } }
public boolean have nest ( string expression ) { if ( expression == null || expression . length ( ) == 0 ) { return false ; } else { return ( remove ( expression ) ! = null ) ; } }
public string remove ( string expression ) { if ( expression == null || expression . length ( ) == 0 ) { return null ; } string property = next ( expression ) ; if ( expression . length ( ) == property . length ( ) ) { return null ; } int start = property . length ( ) ; if ( expression . char at ( start ) == nest ) { start++ ; } return expression . substring ( start ) ; }
public boolean be restrict ( ) { return restrict ; }
public dyna bean [ ] to dyna bean array ( ) { if ( size ( ) == 0 & & element dyna bean type == null ) { return new lazy dyna bean [ 0 ] ; } dyna bean [ ] array = ( dyna bean [ ] ) array . new instance ( element dyna bean type , size ( ) ) ; for ( int i = 0 ; i < size ( ) ; i++ ) { array [ i ] = ( dyna bean ) get ( i ) ; } return array ; }
public object convert ( string [ ] value , class clazz ) { return convert ( value , clazz , get default locale ( ) , null ) ; }
public method get map write method ( ) { return map write method ref . get ( ) ; }
public void set map write method ( method map setter ) throw introspection exception { map write method ref = new map method reference ( mapped setter ) ; find mapped property type ( ) ; }
protect static property utils bean get instance ( ) { return bean utils bean . get instance ( ) . get property utils ( ) ; }
protect void advance ( ) throw s q l exception { if ( ! current & & ! eof ) { if ( dyna class . get result set ( ) . next ( ) ) { current = true ; eof = false ; } else { current = false ; eof = true ; } } }
public int hash code ( ) { if ( fast ) { int h = 0 ; iterator i = map . entry set ( ) . iterator ( ) ; while ( i . have next ( ) ) { h += i . next ( ) . hash code ( ) ; } return ( h ) ; } else { synchronize ( map ) { int h = 0 ; iterator i = map . entry set ( ) . iterator ( ) ; while ( i . have next ( ) ) { h += i . next ( ) . hash code ( ) ; } return ( h ) ; } } }
public object get instance ( ) { return instance ; }
public void set desc padding ( int padding ) { this . default desc pad = padding ; }
public comparator < option > get option comparator ( ) { return option comparator ; }
public void set option comparator ( comparator < option > comparator ) { this . option comparator = comparator ; }
public string get long opt ( ) { return long opt ; }
public void set require ( boolean require ) { this . require = require ; }
public static string to ascii string ( final byte [ ] raw ) { return new string ( to ascii char ( raw ) ) ; }
public static string crypt ( final string key ) { return crypt ( key , null ) ; }
public static message digest get md5 digest ( ) { return get digest ( message digest algorithms . md5 ) ; }
public static message digest update digest ( final message digest digest , final input stream data ) throw i o exception { final byte [ ] buffer = new byte [ stream_buffer_length ] ; int read = data . read ( buffer , 0 , stream_buffer_length ) ; while ( read > -1 ) { digest . update ( buffer , 0 , read ) ; read = data . read ( buffer , 0 , stream_buffer_length ) ; } return digest ; }
public static mac get hmac sha1 ( final byte [ ] key ) { return get initialize mac ( hmac algorithm . hmac_sha_1 , key ) ; }
public static string hmac md5 hex ( final byte [ ] key , final byte [ ] value to digest ) { return hex . encode hex string ( hmac md5 ( key , value to digest ) ) ; }
public static string hmac sha512 hex ( final byte [ ] key , final byte [ ] value to digest ) { return hex . encode hex string ( hmac sha512 ( key , value to digest ) ) ; }
public static string md5 crypt ( final byte [ ] key byte ) { return md5 crypt ( key byte , md5_prefix + b64 . get random salt ( 8 ) ) ; }
public name type get name type ( ) { return this . engine . get name type ( ) ; }
public boolean be concat ( ) { return this . engine . be concat ( ) ; }
public string get name ( ) { return this . name ; }
public r pattern get r context ( ) { return this . r context ; }
public int difference ( final string s1 , final string s2 ) throw encoder exception { return soundex utils . difference ( this , s1 , s2 ) ; }
public charset get charset ( ) { return this . charset ; }
public object encode ( final object obj ) throw encoder exception { if ( obj == null ) { return null ; } else if ( obj instanceof byte [ ] ) { return encode ( ( byte [ ] ) obj ) ; } else if ( obj instanceof string ) { return encode ( ( string ) obj ) ; } else { throw new encoder exception ( `` object of type `` + obj . get class ( ) . get name ( ) + `` can not be quoted-printable encode `` ) ; } }
public static boolean be available ( final string name ) { try { mac . get instance ( name ) ; return true ; } catch ( final no such algorithm exception e ) { return false ; } }
public static message digest get sha3_224 digest ( ) { return get digest ( message digest algorithms . sha3_224 ) ; }
public static message digest get sha3_384 digest ( ) { return get digest ( message digest algorithms . sha3_384 ) ; }
public static string sha3_256 hex ( final byte [ ] data ) { return hex . encode hex string ( sha3_256 ( data ) ) ; }
public void set encode blank ( boolean b ) { this . encode blank = b ; }
public boolean be empty ( ) { return map . be empty ( ) ; }
public iterator < e > iterator ( ) { return new bag iterator < > ( this ) ; }
public set < e > unique set ( ) { if ( unique set == null ) { unique set = unmodifiable set . < e > unmodifiable set ( map . key set ( ) ) ; } return unique set ; }
public static < e > bag < e > collection bag ( final bag < e > bag ) { return new collection bag < > ( bag ) ; }
public v put ( final k key , final v value ) { final v result = get ( key ) ; do put ( key , value ) ; return result ; }
public k get key ( final object value ) { check value ( value ) ; final node < k , v > node = lookup value ( value ) ; return node == null ? null : node . get key ( ) ; }
public k previous key ( final k key ) { check key ( key ) ; final node < k , v > node = next small ( lookup key ( key ) , key ) ; return node == null ? null : node . get key ( ) ; }
public string to string ( ) { return this . do to string ( key ) ; }
public void add composited ( final collection < e > composite collection ) { all . add ( composite collection ) ; }
public list < collection < e > > get collection ( ) { return unmodifiable list . unmodifiable list ( all ) ; }
protect collection < e > transform ( final collection < ? extend e > coll ) { final list < e > list = new array list < > ( coll . size ( ) ) ; for ( final e item : coll ) { list . add ( transform ( item ) ) ; } return list ; }
public static < c > boolean exists ( final iterable < c > input , final predicate < ? super c > predicate ) { return predicate ! = null & & iterable utils . match any ( input , predicate ) ; }
public static < o > collection < o > select reject ( final iterable < ? extend o > input collection , final predicate < ? super o > predicate ) { final collection < o > answer = input collection instanceof collection < ? > ? new array list < o > ( ( ( collection < ? > ) input collection ) . size ( ) ) : new array list < o > ( ) ; return select reject ( input collection , predicate , answer ) ; }
public static < t > factory < t > constant factory ( final t constant to return ) { return constant factory . constant factory ( constant to return ) ; }
public static < t > fluent iterable < t > of ( final iterable < t > iterable ) { iterable utils . check not null ( iterable ) ; if ( iterable instanceof fluent iterable < ? > ) { return ( fluent iterable < t > ) iterable ; } return new fluent iterable < > ( iterable ) ; }
public enumeration < e > a enumeration ( ) { return iterator utils . a enumeration ( iterator ( ) ) ; }
public void for each ( final closure < ? super e > closure ) { iterable utils . for each ( iterable , closure ) ; }
public boolean evaluate ( final t object ) { return i predicate1 . evaluate ( object ) & & i predicate2 . evaluate ( object ) ; }
public boolean evaluate ( final t object ) { if ( equator ! = null ) { return equator . equate ( i value , object ) ; } return i value . equal ( object ) ; }
public boolean evaluate ( final t object ) { for ( final predicate < ? super t > i predicate : i predicate ) { if ( i predicate . evaluate ( object ) ) { return false ; } } return true ; }
public void execute ( final e input ) { i transformer . transform ( input ) ; }
public boolean evaluate ( final t object ) { final boolean result = i transformer . transform ( object ) ; if ( result == null ) { throw new functor exception ( `` transformer must return an instanceof boolean , it be a null object `` ) ; } return result . boolean value ( ) ; }
public predicate < ? super e > get predicate ( ) { return i predicate ; }
public static < e > iterable < e > unique iterable ( final iterable < e > iterable ) { check not null ( iterable ) ; return new fluent iterable < e > ( ) { @ override public iterator < e > iterator ( ) { return new unique filter iterator < > ( iterable . iterator ( ) ) ; } } ; }
public static < e > e find ( final iterable < e > iterable , final predicate < ? super e > predicate ) { return iterator utils . find ( empty iterator if null ( iterable ) , predicate ) ; }
public static < e > long count match ( final iterable < e > input , final predicate < ? super e > predicate ) { if ( predicate == null ) { throw new null pointer exception ( `` predicate must not be null . `` ) ; } return size ( filter iterable ( empty if null ( input ) , predicate ) ) ; }
public static boolean be empty ( final iterable < ? > iterable ) { if ( iterable instanceof collection < ? > ) { return ( ( collection < ? > ) iterable ) . be empty ( ) ; } return iterator utils . be empty ( empty iterator if null ( iterable ) ) ; }
public boolean have next ( ) { return index < end index ; }
public object get array ( ) { return array ; }
public void remove ( ) { if ( collection ! = null ) { if ( last ! = null ) { collection . remove ( last ) ; } else { throw new illegal state exception ( `` next ( ) must have be call for remove ( ) to function `` ) ; } } else { throw new unsupported operation exception ( `` no collection associate with this iterator `` ) ; } }
public iterator < ? extend e > get iterator ( ) { return iterator ; }
public predicate < ? super e > get predicate ( ) { return predicate ; }
public iterator < e > iterator ( ) { if ( iterator instanceof resettable iterator ) { ( ( resettable iterator < ? extend e > ) iterator ) . reset ( ) ; } return type safe iterator ; }
public int previous index ( ) { if ( iterator instanceof list iterator ) { final list iterator < ? > li = ( list iterator < ? > ) iterator ; return li . previous index ( ) ; } return current index - 1 ; }
public e next ( ) { if ( collection . size ( ) == 0 ) { throw new no such element exception ( `` there be no element for this iterator to loop on `` ) ; } if ( iterator . have next ( ) == false ) { reset ( ) ; } return iterator . next ( ) ; }
public void remove ( ) { iterator . remove ( ) ; }
public void add ( final e obj ) { iterator . add ( obj ) ; }
public e next ( ) { update current iterator ( ) ; if ( have next == false ) { throw new no such element exception ( `` no more element in the iteration `` ) ; } last used iterator = current iterator ; final e result = current value ; current value = null ; have next = false ; return result ; }
public boolean have next ( ) { return before first & & ! remove ; }
public void remove ( ) { if ( remove allow ) { if ( remove || before first ) { throw new illegal state exception ( ) ; } object = null ; remove = true ; } else { throw new unsupported operation exception ( ) ; } }
protect boolean be cache full ( ) { return cache size > = maximum cache size ; }
protect node < e > create node ( final e value ) { final node < e > cache node = get node from cache ( ) ; if ( cached node == null ) { return super . create node ( value ) ; } cache node . set value ( value ) ; return cached node ; }
public void clear ( ) { mod count++ ; root = null ; size = 0 ; }
public static int hash code for list ( final collection < ? > list ) { if ( list == null ) { return 0 ; } int hash code = 1 ; final iterator < ? > it = list . iterator ( ) ; while ( it . have next ( ) ) { final object obj = it . next ( ) ; hash code = 31 * hash code + ( obj == null ? 0 : obj . hash code ( ) ) ; } return hash code ; }
public static < e > list < e > fix size list ( final list < e > list ) { return fix size list . fix size list ( list ) ; }
public set < k > key set ( ) { if ( key set == null ) { key set = new key set < > ( this ) ; } return key set ; }
public int hash code ( ) { int total = 0 ; final iterator < map . entry < k , v > > it = create entry set iterator ( ) ; while ( it . have next ( ) ) { total += it . next ( ) . hash code ( ) ; } return total ; }
protect boolean be set value check ( ) { return true ; }
protect void init ( ) { header = create entry ( null , -1 , null , null ) ; header . before = header . after = header ; }
protect void purge before write ( ) { purge ( ) ; }
public v get ( final object key ) { for ( int i = this . composite . length - 1 ; i > = 0 ; -- i ) { if ( this . composite [ i ] . contains key ( key ) ) { return this . composite [ i ] . get ( key ) ; } } return null ; }
public k last key ( ) { if ( size ( ) == 0 ) { throw new no such element exception ( `` map be empty `` ) ; } return insert order . get ( size ( ) - 1 ) ; }
public set < k > key set ( ) { return new key set view < > ( this ) ; }
public string to string ( ) { if ( be empty ( ) ) { return `` { } `` ; } final string builder buf = new string builder ( ) ; buf . append ( ' { ' ) ; boolean first = true ; for ( final map . entry < k , v > entry : entry set ( ) ) { final k key = entry . get key ( ) ; final v value = entry . get value ( ) ; if ( first ) { first = false ; } else { buf . append ( `` , `` ) ; } buf . append ( key == this ? `` ( this map ) `` : key ) ; buf . append ( '= ' ) ; buf . append ( value == this ? `` ( this map ) `` : value ) ; } buf . append ( ' } ' ) ; return buf . to string ( ) ; }
public boolean be scan until removable ( ) { return scan until removable ; }
protect int hash ( final object key1 , final object key2 ) { int h = 0 ; if ( key1 ! = null ) { h ^= key1 . hash code ( ) ; } if ( key2 ! = null ) { h ^= key2 . hash code ( ) ; } h += ~ ( h < < 9 ) ; h ^= h > > > 14 ; h += h < < 4 ; h ^= h > > > 10 ; return h ; }
protect void check key ( final multi key < ? > key ) { if ( key == null ) { throw new null pointer exception ( `` key must not be null `` ) ; } }
protect void validate ( final k key , final v value ) { if ( key predicate ! = null & & key predicate . evaluate ( key ) == false ) { throw new illegal argument exception ( `` can not add key - predicate reject it `` ) ; } if ( value predicate ! = null & & value predicate . evaluate ( value ) == false ) { throw new illegal argument exception ( `` can not add value - predicate reject it `` ) ; } }
public set < k > key set ( ) { return new key set ( ) ; }
public static < k > byte get byte value ( final map < ? super k , ? > map , final k key ) { final byte byte object = get byte ( map , key ) ; if ( byte object == null ) { return 0 ; } return byte object . byte value ( ) ; }
public static < k > short get short value ( final map < ? super k , ? > map , final k key ) { final short short object = get short ( map , key ) ; if ( short object == null ) { return 0 ; } return short object . short value ( ) ; }
public static < k > int get int value ( final map < ? super k , ? > map , final k key ) { final integer integer object = get integer ( map , key ) ; if ( integer object == null ) { return 0 ; } return integer object . int value ( ) ; }
public boolean put all ( final multi value map < ? extend k , ? extend v > map ) { if ( map == null ) { throw new null pointer exception ( `` map must not be null . `` ) ; } boolean change = false ; for ( final map . entry < ? extend k , ? extend v > entry : map . entry ( ) ) { change |= put ( entry . get key ( ) , entry . get value ( ) ) ; } return change ; }
public set < v > get ( final k key ) { return wrap collection ( key ) ; }
protect iterator < e > create unique set iterator ( ) { final transformer < entry < e > , e > transformer = new transformer < entry < e > , e > ( ) { @ override public e transform ( final entry < e > entry ) { return entry . get element ( ) ; } } ; return iterator utils . transform iterator ( entry set ( ) . iterator ( ) , transformer ) ; }
public static < e > multi set < e > synchronize multi set ( final multi set < e > multiset ) { return synchronize multi set . synchronized multi set ( multiset ) ; }
public static < t > predicate < t > null predicate ( ) { return null predicate . null predicate ( ) ; }
public static < t > predicate < t > equal predicate ( final t value ) { return equal predicate . equal predicate ( value ) ; }
public static < t > predicate < t > all predicate ( final collection < ? extend predicate < ? super t > > predicate ) { return all predicate . all predicate ( predicate ) ; }
protect queue < e > decorate ( ) { return ( queue < e > ) super . decorate ( ) ; }
public e get ( final int index ) { final int sz = size ( ) ; if ( index < 0 || index > = sz ) { throw new no such element exception ( string . format ( `` the specified index ( % 1 $ d ) be outside the available range [ 0 , % 2 $ d ) `` , integer . value of ( index ) , integer . value of ( sz ) ) ) ; } final int idx = ( start + index ) % max element ; return element [ idx ] ; }
public void accept ( final command visitor < t > visitor ) { visitor . visit keep command ( get object ( ) ) ; }
protect navigable set < e > decorate ( ) { return ( navigable set < e > ) super . decorate ( ) ; }
public boolean add ( final e obj ) { if ( mutator == null ) { throw new unsupported operation exception ( `` add ( ) be not support on composite set without a set mutator strategy `` ) ; } return mutator . add ( this , all , obj ) ; }
public void set mutator ( final set mutator < e > mutator ) { this . mutator = mutator ; }
public synchronize void add composited ( final set < e > set ) { for ( final set < e > exist set : get set ( ) ) { final collection < e > intersect = collection utils . intersection ( exist set , set ) ; if ( intersects . size ( ) > 0 ) { if ( this . mutator == null ) { throw new unsupported operation exception ( `` collision add composited set with no set mutator set `` ) ; } get mutator ( ) . resolve collision ( this , exist set , set , intersects ) ; if ( collection utils . intersection ( exist set , set ) . size ( ) > 0 ) { throw new illegal argument exception ( `` attempt to add illegal entry unresolved by set mutator . resolve collision ( ) `` ) ; } } } all . add ( set ) ; }
public void add composited ( final set < e > . . . set ) { for ( final set < e > set : set ) { add composited ( set ) ; } }
public static < t > transformer < class < ? extend t > , t > instantiate transformer ( ) { return instantiate transformer . instantiate transformer ( ) ; }
protect void push back byte ( final long push back ) { byte read -= push back ; }
public int get count ( ) { return ( int ) bytes read ; }
protect void count ( final int write ) { count ( ( long ) write ) ; }
public boolean be delete ( ) { return be delete ; }
public type get type ( ) { return type ; }
public void set size ( final long size ) { this . size = size ; }
public date get access time ( ) { return new date ( atime ) ; }
public int get level ( ) { return level ; }
public void set anti item ( final boolean be anti item ) { this . be anti item = be anti item ; }
public void set last modified date ( final long ntfs last modified date ) { this . last modified date = ntfs last modified date ; }
public void close ( ) throw i o exception { if ( channel ! = null ) { try { channel . close ( ) ; } finally { channel = null ; if ( password ! = null ) { array . fill ( password , ( byte ) 0 ) ; } password = null ; } } }
public void put archive entry ( final archive entry archive entry ) throw i o exception { final seven z archive entry entry = ( seven z archive entry ) archive entry ; file . add ( entry ) ; }
public void write ( final byte [ ] b ) throw i o exception { write ( b , 0 , b . length ) ; }
public long skip ( final long n ) throw i o exception { if ( n < = 0 || be directory ( ) ) { return 0 ; } final long available = entry size - entry offset ; final long skip = i o utils . skip ( be , math . min ( n , available ) ) ; count ( skip ) ; entry offset += skip ; return skip ; }
public short get alignment ( ) { return alignment ; }
public date get access java time ( ) { return zip to date ( access time ) ; }
public date get create java time ( ) { return zip to date ( create time ) ; }
public boolean be bit0_modify time present ( ) { return bit0_modify time present ; }
public boolean be bit2_create time present ( ) { return bit2_create time present ; }
public void set access time ( final zip long l ) { bit1_access time present = l ! = null ; flag = ( byte ) ( l ! = null ? ( flags | access_time_bit ) : ( flag & ~access_time_bit ) ) ; this . access time = l ; }
public long get g i d ( ) { return zip util . big to long ( gid ) ; }
public zip short get central directory length ( ) { return zero ; }
public void set raw flag ( final int raw flag ) { this . raw flag = raw flag ; }
public input stream get payload stream ( ) { return payload supplier . get ( ) ; }
public void delete dir ( final string dir name ) { add deletion ( new change ( dir name , change . type_delete_dir ) ) ; }
protect final void start back reference ( int offset , long length ) { back reference offset = offset ; bytes remain = length ; }
protect final int read back reference ( final byte [ ] b , final int off , final int len ) { final int avail = available ( ) ; if ( len > avail ) { try to copy ( len - avail ) ; } return read from buffer ( b , off , len ) ; }
public int get max literal length ( ) { return max literal length ; }
public static boolean be equal ( final byte [ ] buffer1 , final byte [ ] buffer2 ) { return be equal ( buffer1 , 0 , buffer1 . length , buffer2 , 0 , buffer2 . length , false ) ; }
public static boolean be array zero ( final byte [ ] a , final int size ) { for ( int i = 0 ; i < size ; i++ ) { if ( a [ i ] ! = 0 ) { return false ; } } return true ; }
public int bit cache ( ) { return bit cache size ; }
public static builder builder ( ) { return new builder ( ) ; }
public static tar archive struct sparse parse sparse ( final byte [ ] buffer , final int offset ) { long sparse offset = parse octal or binary ( buffer , offset , sparse_offset_len ) ; long sparse numbytes = parse octal or binary ( buffer , offset + sparse_offset_len , sparse_numbytes_len ) ; return new tar archive struct sparse ( sparse offset , sparse numbytes ) ; }
public void set encoding ( final string encode ) { this . encode = encoding ; this . zip encode = zip encode helper . get zip encoding ( encode ) ; if ( use u t f8 flag & & ! zip encode helper . be u t f8 ( encode ) ) { use u t f8 flag = false ; } }
public void delete ( final string file name ) { add deletion ( new change ( file name , change . type_delete ) ) ; }
public list < string > get add from stream ( ) { return add from stream ; }
public static string get compress filename ( final string file name ) { return file name util . get compressed filename ( file name ) ; }
public static int read ( final file file , final byte [ ] array ) throw i o exception { try ( file input stream input stream = new file input stream ( file ) ) { return read fully ( input stream , array , 0 , array . length ) ; } }
public long large ( ) { return large ; }
public long small ( ) { return small ; }
public boolean have content ( ) { return type_ r s . size ( ) > 0 ; }
public boolean be source file attribute ( ) { return false ; }
public void renumber ( final list byte code offset ) throw pack200 exception { if ( renumbered ) { throw new error ( `` try to renumber a line number table that have already be renumbered `` ) ; } renumbered = true ; final int [ ] start p c = get start p c ( ) ; for ( int index = 0 ; index < start p c . length ; index++ ) { start p c [ index ] = ( ( integer ) byte code offset . get ( start p c [ index ] ) ) . int value ( ) ; } }
public int invoke interface count ( ) { return name and type . invoke interface count ( ) ; }
public string outer class string ( ) { return cache outer class string ; }
public log get s a x logger ( ) { return sax log ; }
public void notation decl ( string name , string public id , string system id ) { if ( sax log . be debug enable ( ) ) { sax log . debug ( `` notation decl ( `` + name + `` , `` + public id + `` , `` + system id + `` ) `` ) ; } }
public void set entity resolver ( entity resolver entity resolver ) { this . entity resolver = entity resolver ; }
public void add call method ( string pattern , string method name ) { add rule ( pattern , new call method rule ( method name ) ) ; }
public void add set property ( string pattern ) { add rule ( pattern , new set property rule ( ) ) ; }
public object peek ( string stack name ) { return peek ( stack name , 0 ) ; }
public string get id ( ) { return id ; }
public declaration get declaration by id ( string id ) { declaration decl = ( declaration ) declaration by id . get ( id ) ; if ( ( decl == null ) & & ( parent ! = null ) ) { decl = parent . get declaration by id ( id ) ; } return decl ; }
public rule get parent ( ) { return parent ; }
public plugin manager get plugin manager ( ) { return plugin manager ; }
public rule factory get rule factory ( ) { return rule factory ; }
public void set digester ( digester digester ) { this . digester = digester ; }
public void add alias ( string element name , string property name ) { element name . put ( element name , property name ) ; }
public void set log ( log log ) { this . log = log ; }
public static digester create digester ( input source rule source , digester rule digester ) { rule set rule set = new from xml rule set ( rule source , rule digester ) ; digester digester = new digester ( ) ; digester . add rule set ( rule set ) ; return digester ; }
public boolean be exact match ( ) { return use exact match ; }
protect void add error ( string message pattern , object . . . argument ) { rule binder . add error ( message pattern , argument ) ; }
public object create builder create object ( ) { return add provider ( new object create builder ( key pattern , namespace u r i , main binder , this , class loader ) ) ; }
public plugin create rule builder create plugin ( ) { return add provider ( new plugin create rule builder ( key pattern , namespace u r i , main binder , this ) ) ; }
public object create builder use constructor ( class < ? > . . . constructor argument type ) { if ( constructor argument type == null ) { report error ( `` create object ( ) . use constructor ( class < ? > [ ] ) `` , `` null constructor argument type not allow `` ) ; return this ; } this . constructor argument type = constructor argument type ; return this ; }
public log get s a x logger ( ) { return sax log ; }
public boolean get use context class loader ( ) { return use context class loader ; }
public content handler get custom content handler ( ) { return custom content handler ; }
public void register ( string public id , url entity u r l ) { if ( log . be debug enable ( ) ) { log . debug ( `` register ( ' `` + public id + `` ' , ' `` + entity u r l + `` ' `` ) ; } entity validator . put ( public id , entity u r l ) ; }
public void add set property ( string pattern , string [ ] attribute name , string [ ] property name ) { add rule ( pattern , new set property rule ( attribute name , property name ) ) ; }
public boolean be ignore miss property ( ) { return this . ignore miss property ; }
public boolean be file ( ) { return be file ; }
public void flush ( ) { if ( buffer . size ( ) > 0 ) { process buffer ( ) ; } }
public static boolean be debug enabled ( ) { final string debug = system . get property ( commons_exec_debug , boolean . false . to string ( ) ) ; return boolean . true . to string ( ) . equal ignore case ( debug ) ; }
public static string authenticate ( username password credential credential , string charset ) { log . trace ( `` enter basic scheme . authenticate ( username password credential , string ) `` ) ; if ( credential == null ) { throw new illegal argument exception ( `` credential may not be null `` ) ; } if ( charset == null || charset . length ( ) == 0 ) { throw new illegal argument exception ( `` charset may not be null or empty `` ) ; } string buffer buffer = new string buffer ( ) ; buffer . append ( credential . get user name ( ) ) ; buffer . append ( `` : `` ) ; buffer . append ( credential . get password ( ) ) ; return `` basic `` + encoding util . get ascii string ( base64 . encode base64 ( encode util . get byte ( buffer . to string ( ) , charset ) ) ) ; }
public string get i d ( ) { return ntlmchallenge ; }
public string get parameter ( string name ) { if ( name == null ) { throw new illegal argument exception ( `` parameter name may not be null `` ) ; } if ( this . params == null ) { return null ; } return ( string ) this . params . get ( name . to lower case ( ) ) ; }
public int read ( ) throw i o exception { if ( close ) { throw new i o exception ( `` attempt read from closed stream . `` ) ; } if ( eof ) { return -1 ; } if ( pos > = chunk size ) { next chunk ( ) ; if ( eof ) { return -1 ; } } pos++ ; return in . read ( ) ; }
protect void flush cache ( ) throw i o exception { if ( cache position > 0 ) { byte chunk header [ ] = encode util . get ascii byte ( integer . to hex string ( cache position ) + `` \r\n `` ) ; stream . write ( chunk header , 0 , chunk header . length ) ; stream . write ( cache , 0 , cache position ) ; stream . write ( endchunk , 0 , endchunk . length ) ; cache position = 0 ; } }
public string get path ( ) { return cookie path ; }
public void set version ( int version ) { cookie version = version ; }
public name value pair [ ] get parameter ( ) { return this . parameter ; }
public static final header element [ ] parse element ( char [ ] header value ) { log . trace ( `` enter header element . parse element ( char [ ] ) `` ) ; if ( header value == null ) { return new header element [ ] { } ; } list element = new array list ( ) ; int i = 0 ; int from = 0 ; int len = header value . length ; boolean qouted = false ; while ( i < len ) { char ch = header value [ i ] ; if ( ch == ' `` ' ) { qouted = ! qouted ; } header element element = null ; if ( ( ! qouted ) & & ( ch == ' , ' ) ) { element = new header element ( header value , from , i ) ; from = i + 1 ; } else if ( i == len - 1 ) { element = new header element ( header value , from , len ) ; } if ( ( element ! = null ) & & ( element . get name ( ) ! = null ) ) { element . add ( element ) ; } i++ ; } return ( header element [ ] ) element . to array ( new header element [ element . size ( ) ] ) ; }
public void set header ( header [ ] header ) { clear ( ) ; for ( int i = 0 ; i < header . length ; i++ ) { add header ( header [ i ] ) ; } }
public header get first header ( string name ) { for ( iterator header iter = header . iterator ( ) ; header iter . have next ( ) ; ) { header header = ( header ) header iter . next ( ) ; if ( header . get name ( ) . equal ignore case ( name ) ) { return header ; } } return null ; }
public synchronize boolean proxy equal ( final http connection connection ) { if ( connection == null ) { throw new illegal argument exception ( `` connection may not be null `` ) ; } if ( this . proxy host ! = null ) { return this . proxy host . get host name ( ) . equal ignore case ( connection . get proxy host ( ) ) & & this . proxy host . get port ( ) == connection . get proxy port ( ) ; } else { return connection . get proxy host ( ) == null ; } }
public synchronize boolean be host set ( ) { return this . host ! = null ; }
public synchronize int get port ( ) { if ( this . host ! = null ) { return this . host . get port ( ) ; } else { return -1 ; } }
public synchronize string get proxy host ( ) { if ( this . proxy host ! = null ) { return this . proxy host . get host name ( ) ; } else { return null ; } }
public synchronize inet address get local address ( ) { return this . local address ; }
public synchronize void set strict mode ( boolean strict mode ) { if ( strict mode ) { this . params . make strict ( ) ; } else { this . params . make lenient ( ) ; } }
protect socket get socket ( ) { return this . socket ; }
public string get proxy host ( ) { return proxy host name ; }
public boolean be secure ( ) { return protocol in use . be secure ( ) ; }
public boolean close if stale ( ) throw i o exception { if ( be open & & be stale ( ) ) { log . debug ( `` connection be stale , close . . . `` ) ; close ( ) ; return true ; } return false ; }
public input stream get last response input stream ( ) { return last response input stream ; }
public http connection manager get http connection manager ( ) { return http connection manager ; }
public void release connection ( ) { log . trace ( `` enter http connection . release connection ( ) `` ) ; if ( lock ) { log . debug ( `` connection be lock . call to release connection ( ) ignore . `` ) ; } else if ( http connection manager ! = null ) { log . debug ( `` release connection back to connection manager . `` ) ; http connection manager . release connection ( this ) ; } else { log . warn ( `` http connection manager be null . connection can not be release . `` ) ; } }
public void set send buffer size ( int send buffer size ) throw socket exception { this . params . set send buffer size ( send buffer size ) ; }
public static byte [ ] get ascii byte ( final string data ) { if ( data == null ) { throw new illegal argument exception ( `` parameter may not be null `` ) ; } try { return data . get byte ( `` us-ascii `` ) ; } catch ( unsupported encode exception e ) { throw new runtime exception ( `` http client require ascii support `` ) ; } }
public void set do authentication ( boolean do authentication ) { this . do authentication = do authentication ; }
public header [ ] get request header ( ) { return get request header group ( ) . get all header ( ) ; }
public boolean validate ( ) { return true ; }
public string get escape password ( ) { char [ ] password = get raw password ( ) ; return ( password == null ) ? null : new string ( password ) ; }
public boolean get follow redirects ( ) { return false ; }
protect long get request content length ( ) { log . trace ( `` enter entity enclose method . get request content length ( ) `` ) ; if ( ! have request content ( ) ) { return 0 ; } if ( this . chunk ) { return -1 ; } if ( this . request entity == null ) { this . request entity = generate request entity ( ) ; } return ( this . request entity == null ) ? 0 : this . request entity . get content length ( ) ; }
protect void send disposition header ( output stream out ) throw i o exception { log . trace ( `` enter send disposition header ( output stream out ) `` ) ; super . send disposition header ( out ) ; string filename = this . source . get file name ( ) ; if ( filename ! = null ) { out . write ( file_name_bytes ) ; out . write ( quote_bytes ) ; out . write ( encode util . get ascii byte ( filename ) ) ; out . write ( quote_bytes ) ; } }
public string get file name ( ) { return ( file name == null ) ? `` noname `` : file name ; }
public long length ( ) throw i o exception { log . trace ( `` enter length ( ) `` ) ; if ( length of data ( ) < 0 ) { return -1 ; } byte array output stream overhead = new byte array output stream ( ) ; send start ( overhead ) ; send disposition header ( overhead ) ; send content type header ( overhead ) ; send transfer encode header ( overhead ) ; send end of header ( overhead ) ; send end ( overhead ) ; return overhead . size ( ) + length of data ( ) ; }
public void set name ( string name ) { if ( name == null ) { throw new illegal argument exception ( `` name must not be null `` ) ; } this . name = name ; }
protect long get request content length ( ) throw i o exception { log . trace ( `` enter multipart post method . get request content length ( ) `` ) ; return part . get length of part ( get part ( ) ) ; }
public boolean remove parameter ( string param name , string param value ) throw illegal argument exception { log . trace ( `` enter post method . remove parameter ( string , string ) `` ) ; if ( param name == null ) { throw new illegal argument exception ( `` parameter name may not be null `` ) ; } if ( param value == null ) { throw new illegal argument exception ( `` parameter value may not be null `` ) ; } iterator iter = this . params . iterator ( ) ; while ( iter . have next ( ) ) { name value pair pair = ( name value pair ) iter . next ( ) ; if ( param name . equal ( pair . get name ( ) ) & & param value . equal ( pair . get value ( ) ) ) { iter . remove ( ) ; return true ; } } return false ; }
public boolean be connection stale checking enable ( ) { return this . params . be stale check enable ( ) ; }
public int get connection in use ( ) { return get connection in pool ( ) ; }
public void set authentication preemptive ( boolean value ) { set boolean parameter ( preemptive_authentication , value ) ; }
public int get default max connection per host ( ) { return get max connection per host ( host configuration . any_host_configuration ) ; }
public void set max total connection ( int max total connection ) { set int parameter ( http connection manager params . max_total_connections , max total connection ) ; }
public void set so timeout ( int timeout ) { set int parameter ( so_timeout , timeout ) ; }
public int get receive buffer size ( ) { return get int parameter ( so_rcvbuf , -1 ) ; }
public void set linger ( int value ) { set int parameter ( so_linger , value ) ; }
public boolean be opaque part ( ) { return _is_opaque_part ; }
public boolean have authority ( ) { return ( _authority ! = null ) || _is_net_path ; }
public static string get default document charset ( ) { return default document charset ; }
public static string get default document charset by locale ( ) { return default document charset by locale ; }
public char [ ] get raw userinfo ( ) { return _userinfo ; }
public string get escaped current hier path ( ) throw u r i exception { char [ ] path = get raw current hier path ( ) ; return ( path == null ) ? null : new string ( path ) ; }
public string get fragment ( ) throw u r i exception { return ( _fragment == null ) ? null : decode ( _fragment , get protocol charset ( ) ) ; }
public void set user name ( string user name ) { if ( user name == null ) { throw new illegal argument exception ( `` username may not be null `` ) ; } this . user name = user name ; }
public int hash code ( ) { int hash = lang utils . hash_seed ; hash = lang utils . hash code ( hash , this . user name ) ; hash = lang utils . hash code ( hash , this . password ) ; return hash ; }
public void connect ( ) throw i o exception { log . trace ( `` enter http u r l connection . connect ( ) `` ) ; throw new runtime exception ( `` this class can only be use with already `` + `` retrieve data `` ) ; }
public void set always use quote ( boolean always use quote ) { this . always use quote = always use quote ; }
public static string encode path ( string unescaped ) throw u r i exception { return encode path ( unescaped , uri . get default protocol charset ( ) ) ; }
public int length ( ) { return byte . length ; }
public file [ ] sort ( final file . . . file ) { if ( file ! = null ) { array . sort ( file , this ) ; } return file ; }
public string to string ( ) { return super . to string ( ) + `` [ `` + delegate . to string ( ) + `` ] `` ; }
public static double read swap double ( final byte [ ] data , final int offset ) { return double . long bit to double ( read swap long ( data , offset ) ) ; }
public static int read swap integer ( final input stream input ) throw i o exception { final int value1 = read ( input ) ; final int value2 = read ( input ) ; final int value3 = read ( input ) ; final int value4 = read ( input ) ; return ( ( value1 & 0xff ) < < 0 ) + ( ( value2 & 0xff ) < < 8 ) + ( ( value3 & 0xff ) < < 16 ) + ( ( value4 & 0xff ) < < 24 ) ; }
public list < path > get file list ( ) { return file list ; }
public static path counter clean directory ( final path directory ) throw i o exception { return clean directory ( directory , empty_delete_option_array ) ; }
public static path counter count directory ( final path directory ) throw i o exception { return visit file tree ( new count path visitor ( counter . long path counter ( ) ) , directory ) . get path counter ( ) ; }
public static boolean directory and file content equal ( final path path1 , final path path2 ) throw i o exception { return directory and file content equal ( path1 , path2 , empty_link_option_array , empty_open_option_array , empty_file_visit_option_array ) ; }
public string to string ( ) { return `` file delete strategy [ `` + name + `` ] `` ; }
public boolean accept ( final file file ) { return file . can read ( ) ; }
public boolean accept ( final file file ) { return file . be file ( ) ; }
public static i o file filter prefix file filter ( final string prefix ) { return new prefix file filter ( prefix ) ; }
public static i o file filter suffix file filter ( final string suffix ) { return new suffix file filter ( suffix ) ; }
public static list < i o file filter > to list ( final i o file filter . . . filter ) { if ( filter == null ) { throw new illegal argument exception ( `` the filter must not be null `` ) ; } final list < i o file filter > list = new array list < > ( filter . length ) ; for ( int i = 0 ; i < filter . length ; i++ ) { if ( filter [ i ] == null ) { throw new illegal argument exception ( `` the filter [ `` + i + `` ] be null `` ) ; } list . add ( filter [ i ] ) ; } return list ; }
public boolean accept ( final file file ) { return accept base name ( file . get name ( ) ) ; }
public boolean accept ( final file file ) { return accept ( file == null ? null : file . get name ( ) ) ; }
public static string normalize ( final string file name ) { return do normalize ( file name , system_separator , true ) ; }
public static string separator to system ( final string path ) { if ( path == null ) { return null ; } return be system window ( ) ? separator to window ( path ) : separator to unix ( path ) ; }
public boolean be reserve file name ( final char sequence candidate ) { return array . binary search ( reserve file name , candidate ) > = 0 ; }
public static file create parent directory ( final file file ) throw i o exception { return mkdirs ( get parent file ( file ) ) ; }
public static string get user directory path ( ) { return system . get property ( `` user . home `` ) ; }
public static collection < file > list file ( final file directory , final string [ ] extension , final boolean recursive ) { try { return to list ( stream file ( directory , recursive , extension ) ) ; } catch ( final i o exception e ) { throw new unchecked i o exception ( directory . to string ( ) , e ) ; } }
public static string read file to string ( final file file , final string charset name ) throw i o exception { return read file to string ( file , charsets . to charset ( charset name ) ) ; }
public static void touch ( final file file ) throw i o exception { object . require non null ( file , `` file `` ) ; if ( ! file . exists ( ) ) { open output stream ( file ) . close ( ) ; } set last modified ( file , system . current time millis ( ) ) ; }
public void mark ( final int read ahead limit ) { mark = idx ; }
public int read ( final char [ ] array , final int offset , final int length ) { if ( idx > = end ( ) ) { return eof ; } object . require non null ( array , `` array `` ) ; if ( length < 0 || offset < 0 || offset + length > array . length ) { throw new index out of bound exception ( `` array size= `` + array . length + `` , offset= `` + offset + `` , length= `` + length ) ; } if ( char sequence instanceof string ) { final int count = math . min ( length , end ( ) - idx ) ; ( ( string ) char sequence ) . get char ( idx , idx + count , array , offset ) ; idx += count ; return count ; } if ( char sequence instanceof string builder ) { final int count = math . min ( length , end ( ) - idx ) ; ( ( string builder ) char sequence ) . get char ( idx , idx + count , array , offset ) ; idx += count ; return count ; } if ( char sequence instanceof string buffer ) { final int count = math . min ( length , end ( ) - idx ) ; ( ( string buffer ) char sequence ) . get char ( idx , idx + count , array , offset ) ; idx += count ; return count ; } int count = 0 ; for ( int i = 0 ; i < length ; i++ ) { final int c = read ( ) ; if ( c == eof ) { return count ; } array [ offset + i ] = ( char ) c ; count++ ; } return count ; }
public long skip ( final long number of byte ) throw i o exception { if ( eof ) { throw new i o exception ( `` skip after end of file `` ) ; } if ( position == size ) { return do end of file ( ) ; } position += number of byte ; long return length = number of byte ; if ( position > size ) { return length = number of byte - ( position - size ) ; position = size ; } return return length ; }
public long get position ( ) { return position ; }
public synchronize void mark ( final int readlimit ) { if ( ! mark support ) { throw unsupported operation exception . mark ( ) ; } mark = position ; this . readlimit = readlimit ; }
public int read ( ) { final integer value = block queue . poll ( ) ; return value == null ? eof : ( ( 0x f f ) & value ) ; }
public long available long ( ) throw i o exception { return random access file . length ( ) - random access file . get file pointer ( ) ; }
public random access file get random access file ( ) { return random access file ; }
public void close ( ) throw i o exception { channel . close ( ) ; }
public boolean be cause of ( final throwable exception ) { return tag i o exception . be tag with ( exception , tag ) ; }
public long get delay ( ) { return delay millis ; }
public static input stream to input stream ( final string input ) { return to input stream ( input , charset . default charset ( ) ) ; }
public static input stream to input stream ( final string input , final charset charset ) { return new byte array input stream ( input . get byte ( charsets . to charset ( charset ) ) ) ; }
public file filter get file filter ( ) { return file filter ; }
public void add listener ( final file alteration listener listener ) { if ( listener ! = null ) { listener . add ( listener ) ; } }
public long get length ( ) { return length ; }
public void set exists ( final boolean exists ) { this . exist = exists ; }
public t get appendable ( ) { return appendable ; }
public void write ( final char [ ] cbuf , final int off , final int len ) throw i o exception { object . require non null ( cbuf , `` character array be miss `` ) ; if ( len < 0 || ( off + len ) > cbuf . length ) { throw new index out of bound exception ( `` array size= `` + cbuf . length + `` , offset= `` + off + `` , length= `` + len ) ; } for ( int i = 0 ; i < len ; i++ ) { appendable . append ( cbuf [ off + i ] ) ; } }
public void write ( final int c ) throw i o exception { appendable . append ( ( char ) c ) ; }
public void close ( ) throw i o exception { super . close ( ) ; close = true ; }
public void write ( final int idx ) throw i o exception { out . write ( idx ) ; }
public void flush ( ) throw i o exception { list < exception > cause list = null ; int i = 0 ; for ( final writer w : writer ) { if ( w ! = null ) { try { w . flush ( ) ; } catch ( final i o exception e ) { cause list = add ( cause list , i , e ) ; } } i++ ; } if ( not empty ( cause list ) ) { throw new i o exception list ( `` flush `` , cause list ) ; } }
public void close ( ) throw i o exception { process input ( true ) ; flush output ( ) ; writer . close ( ) ; }
public string get default encode ( ) { return default encode ; }
public validate object input stream reject ( final string . . . pattern ) { for ( final string pattern : pattern ) { reject matcher . add ( new wildcard class name matcher ( pattern ) ) ; } return this ; }
public static boolean be tag with ( final throwable throwable , final object tag ) { return tag ! = null & & throwable instanceof tag i o exception & & tag . equal ( ( ( tag i o exception ) throwable ) . tag ) ; }
public int compare ( file file1 , file file2 ) { long result = file1 . last modified ( ) - file2 . last modified ( ) ; if ( result < 0 ) { return -1 ; } else if ( result > 0 ) { return 1 ; } else { return 0 ; } }
public static i o file filter age file filter ( file cutoff reference ) { return new age file filter ( cutoff reference ) ; }
public static string get full path no end separator ( string filename ) { return do get full path ( filename , false ) ; }
public static boolean equal normalize on system ( string filename1 , string filename2 ) { return equal ( filename1 , filename2 , true , i o case . system ) ; }
public synchronize void reset ( ) throw i o exception { fb index = mark fb index ; if ( mark at start ) { first bytes = null ; } in . reset ( ) ; }
public int read ( char [ ] array , int offset , int length ) { if ( idx > = char sequence . length ( ) ) { return -1 ; } if ( array == null ) { throw new null pointer exception ( `` character array be miss `` ) ; } if ( length < 0 || offset < 0 || offset + length > array . length ) { throw new index out of bound exception ( `` array size= `` + array . length + `` , offset= `` + offset + `` , length= `` + length ) ; } int count = 0 ; for ( int i = 0 ; i < length ; i++ ) { int c = read ( ) ; if ( c == -1 ) { return count ; } array [ offset + i ] = ( char ) c ; count++ ; } return count ; }
public void handle ( string line ) { }
public static char [ ] to char array ( reader input ) throw i o exception { char array writer sw = new char array writer ( ) ; copy ( input , sw ) ; return sw . to char array ( ) ; }
public static list < string > read line ( input stream input ) throw i o exception { return read line ( input , charset . default charset ( ) ) ; }
public static list < string > read line ( input stream input , charset encode ) throw i o exception { input stream reader reader = new input stream reader ( input , charsets . to charset ( encode ) ) ; return read line ( reader ) ; }
public static input stream to input stream ( char sequence input , charset encode ) { return to input stream ( input . to string ( ) , encode ) ; }
public static void write ( string data , writer output ) throw i o exception { if ( data ! = null ) { output . write ( data ) ; } }
public static void write ( string buffer data , output stream output , string encode ) throw i o exception { if ( data ! = null ) { output . write ( data . to string ( ) . get byte ( charsets . to charset ( encode ) ) ) ; } }
public static void copy ( input stream input , writer output ) throw i o exception { copy ( input , output , charset . default charset ( ) ) ; }
public static void copy ( input stream input , writer output , charset encode ) throw i o exception { input stream reader in = new input stream reader ( input , charsets . to charset ( encode ) ) ; copy ( in , output ) ; }
public static boolean content equal ( input stream input1 , input stream input2 ) throw i o exception { if ( ! ( input1 instanceof buffer input stream ) ) { input1 = new buffer input stream ( input1 ) ; } if ( ! ( input2 instanceof buffer input stream ) ) { input2 = new buffer input stream ( input2 ) ; } int ch = input1 . read ( ) ; while ( eof ! = ch ) { int ch2 = input2 . read ( ) ; if ( ch ! = ch2 ) { return false ; } ch = input1 . read ( ) ; } int ch2 = input2 . read ( ) ; return ch2 == eof ; }
public void on start ( final file alteration observer observer ) { }
public byte [ ] get data ( ) { if ( memory output stream ! = null ) { return memory output stream . to byte array ( ) ; } return null ; }
public static void close quietly ( final closeable . . . closeables ) { if ( closeables == null ) { return ; } for ( final closeable closeable : closeables ) { close quietly ( closeable ) ; } }
public static char [ ] to char array ( final input stream be ) throw i o exception { return to char array ( be , charset . default charset ( ) ) ; }
public static string to string ( final byte [ ] input , final string encode ) throw i o exception { return new string ( input , charsets . to charset ( encode ) ) ; }
public static boolean content equal ( input stream input1 , input stream input2 ) throw i o exception { if ( input1 == input2 ) { return true ; } if ( ! ( input1 instanceof buffer input stream ) ) { input1 = new buffer input stream ( input1 ) ; } if ( ! ( input2 instanceof buffer input stream ) ) { input2 = new buffer input stream ( input2 ) ; } int ch = input1 . read ( ) ; while ( eof ! = ch ) { final int ch2 = input2 . read ( ) ; if ( ch ! = ch2 ) { return false ; } ch = input1 . read ( ) ; } final int ch2 = input2 . read ( ) ; return ch2 == eof ; }
public static boolean be empty file ( final path file ) throw i o exception { return file . size ( file ) < = 0 ; }
public static long copy ( final reader input , final appendable output ) throw i o exception { return copy ( input , output , char buffer . allocate ( default_buffer_size ) ) ; }
public static boolean be equal ( object array1 , object array2 ) { return new equal builder ( ) . append ( array1 , array2 ) . be equal ( ) ; }
public static object [ ] null to empty ( object [ ] array ) { if ( array == null || array . length == 0 ) { return empty_object_array ; } return array ; }
public static object [ ] subarray ( object [ ] array , int start index inclusive , int end index exclusive ) { if ( array == null ) { return null ; } if ( start index inclusive < 0 ) { start index inclusive = 0 ; } if ( end index exclusive > array . length ) { end index exclusive = array . length ; } int new size = end index exclusive - start index inclusive ; class type = array . get class ( ) . get component type ( ) ; if ( new size < = 0 ) { return ( object [ ] ) array . new instance ( type , 0 ) ; } object [ ] subarray = ( object [ ] ) array . new instance ( type , new size ) ; system . arraycopy ( array , start index inclusive , subarray , 0 , new size ) ; return subarray ; }
public static int last index of ( object [ ] array , object object to find , int start index ) { if ( array == null ) { return index_not_found ; } if ( start index < 0 ) { return index_not_found ; } else if ( start index > = array . length ) { start index = array . length - 1 ; } if ( object to find == null ) { for ( int i = start index ; i > = 0 ; i -- ) { if ( array [ i ] == null ) { return i ; } } } else { for ( int i = start index ; i > = 0 ; i -- ) { if ( object to find . equal ( array [ i ] ) ) { return i ; } } } return index_not_found ; }
public static int last index of ( long [ ] array , long value to find ) { return last index of ( array , value to find , integer . max_value ) ; }
public static int index of ( double [ ] array , double value to find , int start index , double tolerance ) { if ( array utils . be empty ( array ) ) { return index_not_found ; } if ( start index < 0 ) { start index = 0 ; } double min = value to find - tolerance ; double max = value to find + tolerance ; for ( int i = start index ; i < array . length ; i++ ) { if ( array [ i ] > = min & & array [ i ] < = max ) { return i ; } } return index_not_found ; }
public static long [ ] to primitive ( long [ ] array , long value for null ) { if ( array == null ) { return null ; } else if ( array . length == 0 ) { return empty_long_array ; } final long [ ] result = new long [ array . length ] ; for ( int i = 0 ; i < array . length ; i++ ) { long b = array [ i ] ; result [ i ] = ( b == null ? value for null : b . long value ( ) ) ; } return result ; }
public static short [ ] to primitive ( short [ ] array ) { if ( array == null ) { return null ; } else if ( array . length == 0 ) { return empty_short_array ; } final short [ ] result = new short [ array . length ] ; for ( int i = 0 ; i < array . length ; i++ ) { result [ i ] = array [ i ] . short value ( ) ; } return result ; }
public static float [ ] to primitive ( float [ ] array , float value for null ) { if ( array == null ) { return null ; } else if ( array . length == 0 ) { return empty_float_array ; } final float [ ] result = new float [ array . length ] ; for ( int i = 0 ; i < array . length ; i++ ) { float b = array [ i ] ; result [ i ] = ( b == null ? value for null : b . float value ( ) ) ; } return result ; }
public static boolean be not empty ( object [ ] array ) { return ( array ! = null & & array . length ! = 0 ) ; }
public equal builder append ( short lh , short rh ) { if ( be equal == false ) { return this ; } be equals = ( lhs == rh ) ; return this ; }
public equal builder append ( object [ ] lh , object [ ] rh ) { if ( be equal == false ) { return this ; } if ( lhs == rh ) { return this ; } if ( lhs == null || rh == null ) { this . set equal ( false ) ; return this ; } if ( lh . length ! = rh . length ) { this . set equal ( false ) ; return this ; } for ( int i = 0 ; i < lh . length & & be equal ; ++i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
public void reset ( ) { this . be equals = true ; }
public hash code builder append ( float value ) { i total = i total * i constant + float . float to int bit ( value ) ; return this ; }
public int hash code ( ) { return to hash code ( ) ; }
public static string to string exclude ( object object , final string exclude field name ) { return to string exclude ( object , new string [ ] { exclude field name } ) ; }
public static string to string exclude ( object object , collection / * string * / exclude field name ) { return to string exclude ( object , to no null string array ( exclude field name ) ) ; }
public reflection to string builder set exclude field name ( string [ ] exclude field name param ) { if ( exclude field name param == null ) { this . exclude field name = null ; } else { this . exclude field name = to no null string array ( exclude field name param ) ; array . sort ( this . exclude field name ) ; } return this ; }
public boolean be use identity hash code ( ) { return super . be use identity hash code ( ) ; }
public string get array start ( ) { return super . get array start ( ) ; }
public void set array separator ( string array separator ) { super . set array separator ( array separator ) ; }
public void set field separator ( string field separator ) { super . set field separator ( field separator ) ; }
public string get size end text ( ) { return super . get size end text ( ) ; }
public to string builder append ( double value ) { style . append ( buffer , null , value ) ; return this ; }
public to string builder append ( float value ) { style . append ( buffer , null , value ) ; return this ; }
public to string builder append ( long value ) { style . append ( buffer , null , value ) ; return this ; }
public to string builder append ( object [ ] array ) { style . append ( buffer , null , array , null ) ; return this ; }
public to string builder append ( string field name , short value ) { style . append ( buffer , field name , value ) ; return this ; }
protect void append cyclic object ( string buffer buffer , string field name , object value ) { object utils . identity to string ( buffer , value ) ; }
protect void append detail ( string buffer buffer , string field name , object [ ] array ) { buffer . append ( array start ) ; for ( int i = 0 ; i < array . length ; i++ ) { object item = array [ i ] ; if ( i > 0 ) { buffer . append ( array separator ) ; } if ( item == null ) { append null text ( buffer , field name ) ; } else { append internal ( buffer , field name , item , array content detail ) ; } } buffer . append ( array end ) ; }
protect void append summary ( string buffer buffer , string field name , char [ ] array ) { append summary size ( buffer , field name , array . length ) ; }
protect void append summary ( string buffer buffer , string field name , float [ ] array ) { append summary size ( buffer , field name , array . length ) ; }
protect void append summary ( string buffer buffer , string field name , boolean [ ] array ) { append summary size ( buffer , field name , array . length ) ; }
public char get end ( ) { return this . end ; }
public static char set get instance ( string set str ) { object set = common . get ( set str ) ; if ( set ! = null ) { return ( char set ) set ; } return new char set ( set str ) ; }
public boolean equal ( object obj ) { if ( obj == this ) { return true ; } if ( obj instanceof char set == false ) { return false ; } char set other = ( char set ) obj ; return set . equal ( other . set ) ; }
public string to string ( ) { return set . to string ( ) ; }
public static char to char ( character ch , char default value ) { if ( ch == null ) { return default value ; } return ch . char value ( ) ; }
public static char to char ( string str , char default value ) { if ( string utils . be empty ( str ) ) { return default value ; } return str . char at ( 0 ) ; }
public static string unicode escape ( char ch ) { if ( ch < 0x10 ) { return `` \\u000 `` + integer . to hex string ( ch ) ; } else if ( ch < 0x100 ) { return `` \\u00 `` + integer . to hex string ( ch ) ; } else if ( ch < 0x1000 ) { return `` \\u0 `` + integer . to hex string ( ch ) ; } return `` \\u `` + integer . to hex string ( ch ) ; }
public static list get all interface ( class cl ) { if ( cls == null ) { return null ; } list interface find = new array list ( ) ; get all interface ( cl , interface find ) ; return interface find ; }
public static list convert class name to class ( list class name ) { if ( class names == null ) { return null ; } list class = new array list ( class names . size ( ) ) ; for ( iterator it = class name . iterator ( ) ; it . have next ( ) ; ) { string class name = ( string ) it . next ( ) ; try { class . add ( class . for name ( class name ) ) ; } catch ( exception ex ) { class . add ( null ) ; } } return class ; }
public static class get class ( string class name ) throw class not find exception { return get class ( class name , true ) ; }
public static class [ ] to class ( object [ ] array ) { if ( array == null ) { return null ; } else if ( array . length == 0 ) { return array utils . empty_class_array ; } class [ ] class = new class [ array . length ] ; for ( int i = 0 ; i < array . length ; i++ ) { class [ i ] = array [ i ] == null ? null : array [ i ] . get class ( ) ; } return class ; }
public static string get package canonical name ( object object , string value if null ) { if ( object == null ) { return value if null ; } return get package canonical name ( object . get class ( ) . get name ( ) ) ; }
protect static map get enum map ( class enum class ) { entry entry = get entry ( enum class ) ; if ( entry == null ) { return empty_map ; } return entry . unmodifiable map ; }
protect static list get enum list ( class enum class ) { entry entry = get entry ( enum class ) ; if ( entry == null ) { return collection . empty_list ; } return entry . unmodifiable list ; }
public final int hash code ( ) { return i hash code ; }
public static throwable [ ] get throwables ( throwable throwable ) { list list = get throwable list ( throwable ) ; return ( throwable [ ] ) list . to array ( new throwable [ list . size ( ) ] ) ; }
public static string [ ] get root cause stack trace ( throwable throwable ) { if ( throwable == null ) { return array utils . empty_string_array ; } throwable throwables [ ] = get throwables ( throwable ) ; int count = throwables . length ; array list frame = new array list ( ) ; list next trace = get stack frame list ( throwables [ count - 1 ] ) ; for ( int i = count ; -- i > = 0 ; ) { list trace = next trace ; if ( i ! = 0 ) { next trace = get stack frame list ( throwables [ i - 1 ] ) ; remove common frame ( trace , next trace ) ; } if ( i == count - 1 ) { frame . add ( throwables [ i ] . to string ( ) ) ; } else { frame . add ( wrapped_marker + throwables [ i ] . to string ( ) ) ; } for ( int j = 0 ; j < trace . size ( ) ; j++ ) { frame . add ( trace . get ( j ) ) ; } } return ( string [ ] ) frames . to array ( new string [ 0 ] ) ; }
public boolean contains key ( int key ) { entry tab [ ] = table ; int hash = key ; int index = ( hash & 0x7 f f f f f f f ) % tab . length ; for ( entry e = tab [ index ] ; e ! = null ; e = e . next ) { if ( e . hash == hash ) { return true ; } } return false ; }
public number get maximum number ( ) { if ( max object == null ) { max object = new double ( max ) ; } return max object ; }
public int get maximum integer ( ) { return ( int ) max ; }
public long long value ( ) { return ( long ) numerator / denominator ; }
public float float value ( ) { return ( ( float ) numerator ) / ( ( float ) denominator ) ; }
public fraction divide by ( fraction fraction ) { if ( fraction == null ) { throw new illegal argument exception ( `` the fraction must not be null `` ) ; } if ( fraction . numerator == 0 ) { throw new arithmetic exception ( `` the fraction to divide by must not be zero `` ) ; } return multiply by ( fraction . invert ( ) ) ; }
public boolean contains range ( range range ) { if ( range == null ) { return false ; } return contains integer ( range . get minimum integer ( ) ) & & contain integer ( range . get maximum integer ( ) ) ; }
public int compare to ( object obj ) { mutable boolean other = ( mutable boolean ) obj ; boolean another val = other . value ; return value == another val ? 0 : ( value ? 1 : -1 ) ; }
public byte to byte ( ) { return new byte ( byte value ( ) ) ; }
public boolean equal ( object obj ) { return ( obj instanceof mutable double ) & & ( double . double to long bit ( ( ( mutable double ) obj ) . value ) == double . double to long bit ( value ) ) ; }
public double double value ( ) { return value ; }
public double double value ( ) { return value ; }
public final void print partial stack trace ( print writer out ) { super . print stack trace ( out ) ; }
public static string identity to string ( object object ) { if ( object == null ) { return null ; } string buffer buffer = new string buffer ( ) ; identity to string ( buffer , object ) ; return buffer . to string ( ) ; }
public static field get field ( class cl , string field name ) { field field = get field ( cls , field name , false ) ; member utils . set accessible workaround ( field ) ; return field ; }
public static object read declare static field ( class cl , string field name ) throw illegal access exception { return read declare static field ( cls , field name , false ) ; }
public static void write declare static field ( class cl , string field name , object value ) throw illegal access exception { write declare static field ( cls , field name , value , false ) ; }
public static method get accessible method ( class cl , string method name , class parameter type ) { return get accessible method ( cl , method name , new class [ ] { parameter type } ) ; }
public static file get java io tmp dir ( ) { return new file ( system . get property ( java_io_tmpdir_key ) ) ; }
public boolean be empty ( ) { return size == 0 ; }
public str builder append ( char [ ] char ) { if ( char == null ) { return append null ( ) ; } int str len = char . length ; if ( str len > 0 ) { int len = length ( ) ; ensure capacity ( len + str len ) ; system . arraycopy ( char , 0 , buffer , len , str len ) ; size += str len ; } return this ; }
public str builder appendln ( double value ) { return append ( value ) . append new line ( ) ; }
public str builder insert ( int index , char char [ ] , int offset , int length ) { validate index ( index ) ; if ( char == null ) { return insert ( index , null text ) ; } if ( offset < 0 || offset > char . length ) { throw new string index out of bound exception ( `` invalid offset : `` + offset ) ; } if ( length < 0 || offset + length > char . length ) { throw new string index out of bound exception ( `` invalid length : `` + length ) ; } if ( length > 0 ) { ensure capacity ( size + length ) ; system . arraycopy ( buffer , index , buffer , index + length , size - index ) ; system . arraycopy ( char , offset , buffer , index , length ) ; size += length ; } return this ; }
public str builder replace first ( char search , char replace ) { if ( search ! = replace ) { for ( int i = 0 ; i < size ; i++ ) { if ( buffer [ i ] == search ) { buffer [ i ] = replace ; break ; } } } return this ; }
public str builder replace all ( string search str , string replace str ) { int search len = ( search str == null ? 0 : search str . length ( ) ) ; if ( search len > 0 ) { int replace len = ( replace str == null ? 0 : replace str . length ( ) ) ; int index = index of ( search str , 0 ) ; while ( index > = 0 ) { replace impl ( index , index + search len , search len , replace str , replace len ) ; index = index of ( search str , index + replace len ) ; } } return this ; }
public str builder trim ( ) { if ( size == 0 ) { return this ; } int len = size ; char [ ] buf = buffer ; int po = 0 ; while ( pos < len & & buf [ po ] < = ' ' ) { pos++ ; } while ( pos < len & & buf [ len - 1 ] < = ' ' ) { len -- ; } if ( len < size ) { delete ( len , size ) ; } if ( pos > 0 ) { delete ( 0 , po ) ; } return this ; }
public string right string ( int length ) { if ( length < = 0 ) { return `` `` ; } else if ( length > = size ) { return new string ( buffer , 0 , size ) ; } else { return new string ( buffer , size - length , length ) ; } }
public boolean contains ( str matcher matcher ) { return index of ( matcher , 0 ) > = 0 ; }
public int index of ( string str , int start index ) { start index = ( start index < 0 ? 0 : start index ) ; if ( str == null || start index > = size ) { return -1 ; } int str len = str . length ( ) ; if ( str len == 1 ) { return index of ( str . char at ( 0 ) , start index ) ; } if ( str len == 0 ) { return start index ; } if ( str len > size ) { return -1 ; } char [ ] this buf = buffer ; int len = size - str len + 1 ; outer : for ( int i = start index ; i < len ; i++ ) { for ( int j = 0 ; j < str len ; j++ ) { if ( str . char at ( j ) ! = this buf [ i + j ] ) { continue outer ; } } return i ; } return -1 ; }
public reader a reader ( ) { return new str builder reader ( ) ; }
public static str matcher split matcher ( ) { return split_matcher ; }
public str substitutor set variable suffix ( char suffix ) { return set variable suffix matcher ( str matcher . char matcher ( suffix ) ) ; }
public int size ( ) { check tokenized ( ) ; return token . length ; }
public str tokenizer set ignore matcher ( str matcher ignore ) { if ( ignored ! = null ) { this . ignore matcher = ignore ; } return this ; }
public static string format ( calendar calendar , string pattern ) { return format ( calendar , pattern , null , null ) ; }
public static void no null element ( object [ ] array , string message ) { validate . not null ( array ) ; for ( int i = 0 ; i < array . length ; i++ ) { if ( array [ i ] == null ) { throw new illegal argument exception ( message ) ; } } }
public static void no null element ( object [ ] array ) { validate . not null ( array ) ; for ( int i = 0 ; i < array . length ; i++ ) { if ( array [ i ] == null ) { throw new illegal argument exception ( `` the validated array contain null element at index : `` + i ) ; } } }
public static void no null element ( collection collection ) { validate . not null ( collection ) ; int i = 0 ; for ( iterator it = collection . iterator ( ) ; it . have next ( ) ; i++ ) { if ( it . next ( ) == null ) { throw new illegal argument exception ( `` the validated collection contain null element at index : `` + i ) ; } } }
public static string capitalize ( string str , char [ ] delimiters ) { int delim len = ( delimiters == null ? -1 : delimiters . length ) ; if ( str == null || str . length ( ) == 0 || delim len == 0 ) { return str ; } int str len = str . length ( ) ; string buffer buffer = new string buffer ( str len ) ; boolean capitalize next = true ; for ( int i = 0 ; i < str len ; i++ ) { char ch = str . char at ( i ) ; if ( be delimiter ( ch , delimiters ) ) { buffer . append ( ch ) ; capitalize next = true ; } else if ( capitalize next ) { buffer . append ( character . to title case ( ch ) ) ; capitalize next = false ; } else { buffer . append ( ch ) ; } } return buffer . to string ( ) ; }
public static file get java io tmp dir ( ) { return new file ( system . get property ( java_io_tmpdir_key ) ) ; }
public boolean be enable substitution in variable ( ) { return enable substitution in variable ; }
public final integer get priority ( ) { return priority ; }
public long get thread count ( ) { return thread counter . get ( ) ; }
protect t initialize ( ) throw exception { return callable . call ( ) ; }
public final t get object ( ) { return object ; }
protect scheduled executor service get executor service ( ) { return executor service ; }
public l [ ] get listener ( ) { return listener . to array ( prototype array ) ; }
public string to string ( ) { return name ; }
public boolean equal ( object obj ) { if ( obj == null ) { return false ; } if ( this == obj ) { return true ; } if ( this . get class ( ) == obj . get class ( ) ) { mutable object < ? > that = ( mutable object < ? > ) obj ; return this . value . equal ( that . value ) ; } else { return false ; } }
public t get maximum ( ) { return maximum ; }
public static object read static field ( field field , boolean force access ) throw illegal access exception { if ( field == null ) { throw new illegal argument exception ( `` the field must not be null `` ) ; } if ( ! modifier . be static ( field . get modifier ( ) ) ) { throw new illegal argument exception ( `` the field ' `` + field . get name ( ) + `` ' be not static `` ) ; } return read field ( field , ( object ) null , force access ) ; }
public static boolean be assignable ( type type , type to type ) { return be assignable ( type , to type , null ) ; }
public static final string unescape html3 ( string input ) { return unescape_html3 . translate ( input ) ; }
public static final string unescape xml ( string input ) { return unescape_xml . translate ( input ) ; }
public str builder append ( char sequence seq ) { if ( seq == null ) { return append null ( ) ; } return append ( seq . to string ( ) ) ; }
public static < t extend collection < ? > > t valid index ( t collection , int index ) { return valid index ( collection , index , default_valid_index_collection_ex_message , integer . value of ( index ) ) ; }
public static < t extend char sequence > t valid index ( t char , int index , string message , object . . . value ) { validate . not null ( char ) ; if ( index < 0 || index > = char . length ( ) ) { throw new index out of bound exception ( string . format ( message , value ) ) ; } return char ; }
public static < t > void inclusive between ( t start , t end , comparable < t > value ) { if ( value . compare to ( start ) < 0 || value . compare to ( end ) > 0 ) { throw new illegal argument exception ( string . format ( default_inclusive_between_ex_message , value , start , end ) ) ; } }
public static < t > void inclusive between ( t start , t end , comparable < t > value , string message , object . . . value ) { if ( value . compare to ( start ) < 0 || value . compare to ( end ) > 0 ) { throw new illegal argument exception ( string . format ( message , value ) ) ; } }
public static void be assignable from ( class < ? > super type , class < ? > type , string message , object . . . value ) { if ( super type . be assignable from ( type ) == false ) { throw new illegal argument exception ( string . format ( message , value ) ) ; } }
public static boolean [ ] add first ( final boolean [ ] array , final boolean element ) { return array == null ? add ( array , element ) : insert ( 0 , array , element ) ; }
public static < t > boolean be array index valid ( final t [ ] array , final int index ) { if ( get length ( array ) == 0 || array . length < = index ) { return false ; } return index > = 0 ; }
public static void shift ( final int [ ] array , final int offset ) { if ( array == null ) { return ; } shift ( array , 0 , array . length , offset ) ; }
public static void swap ( final byte [ ] array , final int offset1 , final int offset2 ) { if ( be empty ( array ) ) { return ; } swap ( array , offset1 , offset2 , 1 ) ; }
public static void swap ( final byte [ ] array , int offset1 , int offset2 , int len ) { if ( be empty ( array ) || offset1 > = array . length || offset2 > = array . length ) { return ; } if ( offset1 < 0 ) { offset1 = 0 ; } if ( offset2 < 0 ) { offset2 = 0 ; } len = math . min ( math . min ( len , array . length - offset1 ) , array . length - offset2 ) ; for ( int i = 0 ; i < len ; i++ , offset1++ , offset2++ ) { final byte aux = array [ offset1 ] ; array [ offset1 ] = array [ offset2 ] ; array [ offset2 ] = aux ; } }
public final string get field name ( ) { return field name ; }
public long get open interval ( ) { return open interval ; }
public int get closing threshold ( ) { return closing threshold ; }
public synchronize void acquire ( ) throw interrupted exception { prepare acquire ( ) ; boolean can pass ; do { can pass = acquire permit ( ) ; if ( ! can pass ) { wait ( ) ; } } while ( ! can pass ) ; }
public l [ ] get listener ( ) { return listener . to array ( prototype array ) ; }
public void set true ( ) { this . value = true ; }
public byte increment and get ( ) { value++ ; return value ; }
public static float next float ( ) { return next float ( 0 , float . max_value ) ; }
public static string get user name ( ) { return system . get property ( user_name_key ) ; }
public static string [ ] [ ] java_ctrl_chars_escape ( ) { return java_ctrl_chars_escape . clone ( ) ; }
public static collection < thread group > find thread group by name ( final string thread group name ) { return find thread group ( new name predicate ( thread group name ) ) ; }
public int get day of month ( ) { return calendar . get ( calendar . day_of_month ) ; }
public boolean parse ( final string source , final parse position po , final calendar calendar ) { final list iterator < strategy and width > lt = pattern . list iterator ( ) ; while ( lt . have next ( ) ) { final strategy and width strategy and width = lt . next ( ) ; final int max width = strategy and width . get max width ( lt ) ; if ( ! strategy and width . strategy . parse ( this , calendar , source , po , max width ) ) { return false ; } } return true ; }
public static stop watch create ( ) { return new stop watch ( ) ; }
public boolean equal ( final object obj ) { if ( obj == this ) { return true ; } if ( obj instanceof triple < ? , ? , ? > ) { final triple < ? , ? , ? > other = ( triple < ? , ? , ? > ) obj ; return object . equal ( get leave ( ) , other . get left ( ) ) & & object . equal ( get middle ( ) , other . get middle ( ) ) & & object . equal ( get right ( ) , other . get right ( ) ) ; } return false ; }
public boolean be not empty ( ) { return size > 0 ; }
public boolean parse ( final string source , final parse position po , final calendar calendar ) { final list iterator < strategy and width > lt = pattern . list iterator ( ) ; while ( lt . have next ( ) ) { final strategy and width strategy and width = lt . next ( ) ; final int max width = strategy and width . get max width ( lt ) ; if ( ! strategy and width . strategy . parse ( this , calendar , source , po , max width ) ) { return false ; } } return true ; }
public static java unicode escaper between ( final int codepoint low , final int codepoint high ) { return new java unicode escaper ( codepoint low , codepoint high , true ) ; }
public long get time ( final time unit time unit ) { return time unit . convert ( get nano time ( ) , time unit . nanosecond ) ; }
public static string get name ( final class < ? > cl ) { return get name ( cl , string utils . empty ) ; }
public static string get name ( final class < ? > cl , final string value if null ) { return cl == null ? value if null : cl . get name ( ) ; }
public logger get logger ( ) { if ( logger == null ) { logger = hierarchy . get default hierarchy ( ) . get logger for ( name ) ; } return ( logger ) ; }
public void trace ( object message ) { debug ( message ) ; }
public final boolean be fatal enabled ( ) { return false ; }
static public log get instance ( string name ) { log log = ( log ) log . get ( name ) ; if ( null == log ) { log = make new log instance ( name ) ; log . put ( name , log ) ; } return log ; }
public int get free parameter ( ) { return compiler . get free parameter ( ) ; }
public int get size ( ) { return size [ parameter ] [ order ] ; }
public double value ( double x ) { return evaluate ( coefficient , x ) ; }
public int degree ( ) { return coefficient . length - 1 ; }
public double get imaginary ( ) { return imaginary ; }
public boolean be na n ( ) { return be na n ; }
public complex sin ( ) { if ( be na n ) { return na n ; } return create complex ( fast math . sin ( real ) * fast math . cosh ( imaginary ) , fast math . co ( real ) * fast math . sinh ( imaginary ) ) ; }
public complex tanh ( ) { if ( be na n || double . be infinite ( imaginary ) ) { return na n ; } if ( real > 20 . 0 ) { return create complex ( 1 . 0 , 0 . 0 ) ; } if ( real < -20 . 0 ) { return create complex ( -1 . 0 , 0 . 0 ) ; } double real2 = 2 . 0 * real ; double imaginary2 = 2 . 0 * imaginary ; double d = fast math . cosh ( real2 ) + fast math . co ( imaginary2 ) ; return create complex ( fast math . sinh ( real2 ) / d , fast math . sin ( imaginary2 ) / d ) ; }
public double get argument ( ) { return fast math . atan2 ( get imaginary ( ) , get real ( ) ) ; }
protect complex create complex ( double real part , double imaginary part ) { return new complex ( real part , imaginary part ) ; }
public boolean equal ( final quaternion q , final double eps ) { return precision . equal ( q0 , q . get q0 ( ) , eps ) & & precision . equal ( q1 , q . get q1 ( ) , eps ) & & precision . equal ( q2 , q . get q2 ( ) , eps ) & & precision . equal ( q3 , q . get q3 ( ) , eps ) ; }
public double get q1 ( ) { return q1 ; }
public round mode get rounding mode ( ) { return r mode ; }
public dfp [ ] get pi split ( ) { return pi split . clone ( ) ; }
protect static dfp [ ] log internal ( final dfp a [ ] ) { / * now we want to compute x = ( a-1 ) / ( a+1 ) but this be prone to * loss of precision . so instead , compute x = ( a/4 - 1/4 ) / ( a/4 + 1/4 ) * / dfp t = a [ 0 ] . divide ( 4 ) . add ( a [ 1 ] . divide ( 4 ) ) ; dfp x = t . add ( a [ 0 ] . new instance ( `` -0 . 25 `` ) ) . divide ( t . add ( a [ 0 ] . new instance ( `` 0 . 25 `` ) ) ) ; dfp y = new dfp ( x ) ; dfp num = new dfp ( x ) ; dfp py = new dfp ( y ) ; int den = 1 ; for ( int i = 0 ; i < 10000 ; i++ ) { num = num . multiply ( x ) ; num = num . multiply ( x ) ; den += 2 ; t = num . divide ( den ) ; y = y . add ( t ) ; if ( y . equal ( py ) ) { break ; } py = new dfp ( y ) ; } y = y . multiply ( a [ 0 ] . get two ( ) ) ; return split ( y ) ; }
public double get location ( ) { return mu ; }
public static object [ ] flatten ( object [ ] array ) { final list < object > list = new array list < object > ( ) ; if ( array ! = null ) { for ( object o : array ) { if ( o instanceof object [ ] ) { for ( object o r : flatten ( ( object [ ] ) o ) ) { list . add ( o r ) ; } } else { list . add ( o ) ; } } } return list . to array ( ) ; }
protect least square optimizer get optimizer ( ) { return new levenberg marquardt optimizer ( ) ; }
public void clear ( ) { observation . clear ( ) ; }
public big fraction add ( final big fraction fraction ) { if ( fraction == null ) { throw new null argument exception ( localized format . fraction ) ; } if ( fraction . numerator . signum ( ) == 0 ) { return this ; } if ( numerator . signum ( ) == 0 ) { return fraction ; } big integer num = null ; big integer den = null ; if ( denominator . equal ( fraction . denominator ) ) { num = numerator . add ( fraction . numerator ) ; den = denominator ; } else { num = ( numerator . multiply ( fraction . denominator ) ) . add ( ( fraction . numerator ) . multiply ( denominator ) ) ; den = denominator . multiply ( fraction . denominator ) ; } if ( num . signum ( ) == 0 ) { return zero ; } return new big fraction ( num , den ) ; }
public big fraction subtract ( final big fraction fraction ) { if ( fraction == null ) { throw new null argument exception ( localized format . fraction ) ; } if ( fraction . numerator . signum ( ) == 0 ) { return this ; } if ( numerator . signum ( ) == 0 ) { return fraction . negate ( ) ; } big integer num = null ; big integer den = null ; if ( denominator . equal ( fraction . denominator ) ) { num = numerator . subtract ( fraction . numerator ) ; den = denominator ; } else { num = ( numerator . multiply ( fraction . denominator ) ) . subtract ( ( fraction . numerator ) . multiply ( denominator ) ) ; den = denominator . multiply ( fraction . denominator ) ; } return new big fraction ( num , den ) ; }
public fraction negate ( ) { if ( numerator== integer . min_value ) { throw new math arithmetic exception ( localized format . overflow_in_fraction , numerator , denominator ) ; } return new fraction ( -numerator , denominator ) ; }
public chromosome get first ( ) { return first ; }
public boolean be random start ( ) { return random start ; }
public double get elitism rate ( ) { return this . elitism rate ; }
public int get num generation ( ) { return num generation ; }
public static synchronize random generator get random generator ( ) { return random generator ; }
public crossover policy get crossover policy ( ) { return crossover policy ; }
public int get arity ( ) { return arity ; }
public boolean contains ( final p point , final double margin ) { return point . distance ( center ) < = radius + margin ; }
public t get angle ( ) { if ( ( q0 . get real ( ) < -0 . 1 ) || ( q0 . get real ( ) > 0 . 1 ) ) { return q1 . multiply ( q1 ) . add ( q2 . multiply ( q2 ) ) . add ( q3 . multiply ( q3 ) ) . sqrt ( ) . asin ( ) . multiply ( 2 ) ; } else if ( q0 . get real ( ) < 0 ) { return q0 . negate ( ) . acos ( ) . multiply ( 2 ) ; } return q0 . acos ( ) . multiply ( 2 ) ; }
public t [ ] to array ( ) { final t [ ] array = math array . build array ( x . get field ( ) , 3 ) ; array [ 0 ] = x ; array [ 1 ] = y ; array [ 2 ] = z ; return array ; }
public vector3 d to space ( final point < euclidean2 d > point ) { final vector2 d p2 d = ( vector2 d ) point ; return new vector3 d ( p2 d . get x ( ) , u , p2 d . get y ( ) , v , -origin offset , w ) ; }
public vector3 d get a2 ( ) { return a2 ; }
public static vector2 d format get instance ( ) { return get instance ( locale . get default ( ) ) ; }
public double get tolerance ( ) { return tolerance ; }
protect void set barycenter ( final vector < s > barycenter ) { set barycenter ( ( point < s > ) barycenter ) ; }
public sub hyperplane < s > get plus inside ( ) { return plus inside ; }
public sub hyperplane < s > inside touch ( ) { return inside touch ; }
public vector3 d get point at ( final double alpha ) { return circle . get point at ( alpha + circle . get phase ( start . get location ( ) . get vector ( ) ) ) ; }
public list < vector3 d > get convex cell inside point ( ) { return convex cell inside point ; }
public double get theta ( ) { return theta ; }
public double get phi ( ) { return phi ; }
public int hash code ( ) { int ret = 322562 ; final int n row = get row dimension ( ) ; final int n col = get column dimension ( ) ; ret = ret * 31 + n row ; ret = ret * 31 + n col ; for ( int row = 0 ; row < n row ; ++row ) { for ( int col = 0 ; col < n col ; ++col ) { ret = ret * 31 + ( 11 * ( row+1 ) + 17 * ( col+1 ) ) * get entry ( row , col ) . hash code ( ) ; } } return ret ; }
protect void check column index ( final int column ) throw out of range exception { if ( column < 0 || column > = get column dimension ( ) ) { throw new out of range exception ( localized format . column_index , column , 0 , get column dimension ( ) - 1 ) ; } }
public int hash code ( ) { int h = 3542 ; for ( final t a : data ) { h ^= a . hash code ( ) ; } return h ; }
public static locale [ ] get available locale ( ) { return number format . get available locale ( ) ; }
public real vector unit vector ( ) throw math arithmetic exception { final double norm = get norm ( ) ; if ( norm == 0 ) { throw new math arithmetic exception ( localized format . zero_norm ) ; } return map divide ( norm ) ; }
public real vector map ( univariate function function ) { return copy ( ) . map to self ( function ) ; }
public field vector < t > add ( sparse field vector < t > v ) throw dimension mismatch exception { check vector dimension ( v . get dimension ( ) ) ; sparse field vector < t > res = ( sparse field vector < t > ) copy ( ) ; open int to field hash map < t > . iterator iter = v . get entry ( ) . iterator ( ) ; while ( iter . have next ( ) ) { iter . advance ( ) ; int key = iter . key ( ) ; t value = iter . value ( ) ; if ( entry . contains key ( key ) ) { re . set entry ( key , entry . get ( key ) . add ( value ) ) ; } else { re . set entry ( key , value ) ; } } return re ; }
public int get size ( ) { return size ; }
protected field expandable o d e < t > get equation ( ) { return equation ; }
public int get first index ( ) { return first index ; }
public double [ ] get primary state dot ( ) { return primary state dot . clone ( ) ; }
public t [ ] get secondary derivative ( final int index ) { return index == 0 ? derivative . clone ( ) : secondary derivative [ index - 1 ] . clone ( ) ; }
public double estimate error ( final double [ ] scale ) { double error = 0 ; if ( current degree > = 5 ) { for ( int i = 0 ; i < scale . length ; ++i ) { final double e = polynomial [ current degree ] [ i ] / scale [ i ] ; error += e * e ; } error = fast math . sqrt ( error / scale . length ) * errfac [ current degree - 5 ] ; } return error ; }
public void set h p ( final double h param ) { this . h p = h param ; }
public relationship get relationship ( ) { return relationship ; }
protect int get basic variable ( final int row ) { return basic row [ row ] ; }
public double get chi square ( ) { return cost * cost ; }
protect void set cost ( double cost ) { this . cost = cost ; }
public double [ ] get target ( ) { return target . clone ( ) ; }
public double get max ( ) { return upper ; }
public double get start value ( ) { return start ; }
public double get r m s ( ) { return fast math . sqrt ( get chi square ( ) / row ) ; }
public double [ ] [ ] get covariance ( ) { return get covariance ( default_singularity_threshold ) ; }
public void clear ( ) { cache normal deviate = double . na n ; }
public static double regularize beta ( double x , double a , double b ) { return regularize beta ( x , a , b , default_epsilon , integer . max_value ) ; }
public double [ ] get point ( ) { return point ; }
public real matrix get correlation matrix ( ) { return correlation matrix ; }
public real matrix compute correlation matrix ( final real matrix matrix ) { int n vars = matrix . get column dimension ( ) ; real matrix out matrix = new block real matrix ( n var , n var ) ; for ( int i = 0 ; i < n var ; i++ ) { for ( int j = 0 ; j < i ; j++ ) { double corr = correlation ( matrix . get column ( i ) , matrix . get column ( j ) ) ; out matrix . set entry ( i , j , corr ) ; out matrix . set entry ( j , i , corr ) ; } out matrix . set entry ( i , i , 1d ) ; } return out matrix ; }
public double get sumsq ( ) { return apply ( sumsq impl ) ; }
public synchronize univariate statistic get min impl ( ) { return min impl ; }
public synchronize void set min impl ( univariate statistic min impl ) { this . min impl = min impl ; }
public double evaluate ( final double [ ] value , final double [ ] weight ) throw math illegal argument exception { return evaluate ( value , weight , 0 , value . length ) ; }
public boolean be bias correct ( ) { return bias correct ; }
public double evaluate ( final double [ ] value , final double mean ) throw math illegal argument exception { return fast math . sqrt ( variance . evaluate ( value , mean ) ) ; }
public double evaluate ( final double [ ] value , final double [ ] weight , final double mean ) throw math illegal argument exception { return evaluate ( value , weight , mean , 0 , value . length ) ; }
public void increment ( double [ ] v ) throw dimension mismatch exception { if ( v . length ! = sum . length ) { throw new dimension mismatch exception ( v . length , sum . length ) ; } int k = 0 ; for ( int i = 0 ; i < v . length ; ++i ) { sums [ i ] += v [ i ] ; for ( int j = 0 ; j < = i ; ++j ) { product sum [ k++ ] += v [ i ] * v [ j ] ; } } n++ ; }
public double quantile ( ) { return quantile ; }
public double get standard deviation ( ) { double std dev = double . na n ; if ( get n ( ) > 0 ) { if ( get n ( ) > 1 ) { std dev = fast math . sqrt ( get variance ( ) ) ; } else { std dev = 0 . 0 ; } } return std dev ; }
public double get min ( ) { return min impl . get result ( ) ; }
public string to string ( ) { number format nf = number format . get percent instance ( ) ; string builder out buffer = new string builder ( ) ; out buffer . append ( `` value \t freq . \t pct . \t cum pct . \n `` ) ; iterator < comparable < ? > > iter = freq table . key set ( ) . iterator ( ) ; while ( iter . have next ( ) ) { comparable < ? > value = iter . next ( ) ; out buffer . append ( value ) ; out buffer . append ( '\t ' ) ; out buffer . append ( get count ( value ) ) ; out buffer . append ( '\t ' ) ; out buffer . append ( nf . format ( get pct ( value ) ) ) ; out buffer . append ( '\t ' ) ; out buffer . append ( nf . format ( get cum pct ( value ) ) ) ; out buffer . append ( '\n ' ) ; } return out buffer . to string ( ) ; }
public void clear ( ) { freq table . clear ( ) ; }
public boolean kolmogorov smirnov test ( real distribution distribution , double [ ] data , double alpha ) { if ( ( alpha < = 0 ) || ( alpha > 0 . 5 ) ) { throw new out of range exception ( localized format . out_of_bound_significance_level , alpha , 0 , 0 . 5 ) ; } return kolmogorov smirnov test ( distribution , data ) < alpha ; }
public double bootstrap ( double [ ] x , double [ ] y , int iteration , boolean strict ) { final int x length = x . length ; final int y length = y . length ; final double [ ] combine = new double [ x length + y length ] ; system . arraycopy ( x , 0 , combine , 0 , x length ) ; system . arraycopy ( y , 0 , combine , x length , y length ) ; final enumerate real distribution dist = new enumerate real distribution ( rng , combine ) ; final long d = integral kolmogorov smirnov statistic ( x , y ) ; int great count = 0 ; int equal count = 0 ; double [ ] cur x ; double [ ] cur y ; long cur d ; for ( int i = 0 ; i < iteration ; i++ ) { cur x = dist . sample ( x length ) ; cur y = dist . sample ( y length ) ; cur d = integral kolmogorov smirnov statistic ( cur x , cur y ) ; if ( cur d > d ) { great count++ ; } else if ( cur d == d ) { equal count++ ; } } return strict ? great count / ( double ) iteration : ( great count + equal count ) / ( double ) iteration ; }
public static confidence interval get wilson score interval ( int number of trial , int number of success , double confidence level ) { return wilson_score . create interval ( number of trial , number of success , confidence level ) ; }
protect void new y sample data ( double [ ] y ) { if ( y == null ) { throw new null argument exception ( ) ; } if ( y . length == 0 ) { throw new no data exception ( ) ; } this . y vector = new array real vector ( y ) ; }
protect double calculate y variance ( ) { return new variance ( ) . evaluate ( y vector . to array ( ) ) ; }
public double calculate r square ( ) { return 1 - calculate residual sum of square ( ) / calculate total sum of square ( ) ; }
public long get n ( ) { return this . nob ; }
public void add data ( final double x , final double y ) { if ( n == 0 ) { xbar = x ; ybar = y ; } else { if ( have intercept ) { final double fact1 = 1 . 0 + n ; final double fact2 = n / ( 1 . 0 + n ) ; final double dx = x - xbar ; final double dy = y - ybar ; sum x x += dx * dx * fact2 ; sum y y += dy * dy * fact2 ; sum x y += dx * dy * fact2 ; xbar += dx / fact1 ; ybar += dy / fact1 ; } } if ( ! have intercept ) { sum x x += x * x ; sum y y += y * y ; sum x y += x * y ; } sum x += x ; sum y += y ; n++ ; }
public double get intercept ( ) { return have intercept ? get intercept ( get slope ( ) ) : 0 . 0 ; }
public static double sum sq ( final double [ ] value ) throw math illegal argument exception { return sum_of_squares . evaluate ( value ) ; }
public static double mean ( final double [ ] value , final int begin , final int length ) throw math illegal argument exception { return mean . evaluate ( value , begin , length ) ; }
public double evaluate ( double x ) throw convergence exception { return evaluate ( x , default_epsilon , integer . max_value ) ; }
public int [ ] get size ( ) { return math array . copy of ( size ) ; }
public v get second ( ) { return value ; }
public boolean equal ( object o ) { if ( this == o ) { return true ; } if ( ! ( o instanceof pair ) ) { return false ; } else { pair < ? , ? > o p = ( pair < ? , ? > ) o ; return ( key == null ? o p . key == null : key . equal ( o p . key ) ) & & ( value == null ? o p . value == null : value . equal ( o p . value ) ) ; } }
public static boolean equal ( float x , float y , float eps ) { return equal ( x , y , 1 ) || fast math . ab ( y - x ) < = eps ; }
public collection < number transformer > transformer ( ) { return map . value ( ) ; }
public string lookup system property string lookup ( ) { return system property string lookup . instance ; }
public levenshtein result apply ( final char sequence leave , final char sequence right ) { if ( threshold ! = null ) { return limit compare ( leave , right , threshold ) ; } return unlimited compare ( leave , right ) ; }
public boolean be ignore empty token ( ) { return ignore empty token ; }
public static str matcher char matcher ( final char ch ) { return new char matcher ( ch ) ; }
public text string builder appendln ( final string builder str ) { return append ( str ) . append new line ( ) ; }
public text string builder appendln ( final char [ ] char ) { return append ( char ) . append new line ( ) ; }
public text string builder append separator ( final string separator ) { return append separator ( separator , null ) ; }
public string get key ( ) { return key ; }
public int get size b ( ) { return size b ; }
public char [ ] get char ( char [ ] target ) { final int len = length ( ) ; if ( target == null || target . length < len ) { target = new char [ len ] ; } system . arraycopy ( buffer , 0 , target , 0 , len ) ; return target ; }
public static date validator get instance ( ) { return date_validator ; }
protect boolean be valid ip address ( string ip address ) { matcher ip address matcher = ip_domain_pattern . matcher ( ip address ) ; for ( int i = 1 ; i < = 4 ; i++ ) { string ip segment = ip address matcher . group ( i ) ; if ( ip segment == null || ip segment . length ( ) < = 0 ) { return false ; } int i ip segment = 0 ; try { i ip segment = integer . parse int ( ip segment ) ; } catch ( number format exception e ) { return false ; } if ( i ip segment > 255 ) { return false ; } } return true ; }
public string get indexed property ( ) { return this . indexed property ; }
public string get depends ( ) { return this . depend ; }
public list get dependency list ( ) { return collection . unmodifiable list ( this . dependency list ) ; }
public string get indexed property ( ) { return this . indexed property ; }
protect int get type ( ) { if ( get variant ( ) ! = null ) { if ( get language ( ) == null || get country ( ) == null ) { throw new null pointer exception ( `` when variant be specify , country and language must be specify . `` ) ; } return variant_formset ; } else if ( get country ( ) ! = null ) { if ( get language ( ) == null ) { throw new null pointer exception ( `` when country be specify , language must be specify . `` ) ; } return country_formset ; } else if ( get language ( ) ! = null ) { return language_formset ; } else { return global_formset ; } }
public static boolean be url ( string value ) { return url_validator . be valid ( value ) ; }
public boolean be valid ( string isbn ) { return org . apache . common . validator . routine . i s b n validator . get instance ( ) . be valid i s b n10 ( isbn ) ; }
public string format ( object value , string pattern , time zone time zone ) { return format ( value , pattern , ( locale ) null , time zone ) ; }
protect object parse ( string value , format formatter ) { parse position po = new parse position ( 0 ) ; object parse value = formatter . parse object ( value , po ) ; if ( po . get error index ( ) > -1 ) { return null ; } if ( be strict ( ) & & po . get index ( ) < value . length ( ) ) { return null ; } if ( parsed value ! = null ) { parsed value = process parse value ( parsed value , formatter ) ; } return parsed value ; }
public big integer validate ( string value , string pattern ) { return ( big integer ) parse ( value , pattern , ( locale ) null ) ; }
public calendar validate ( string value , string pattern , time zone time zone ) { return ( calendar ) parse ( value , pattern , ( locale ) null , time zone ) ; }
public calendar validate ( string value , string pattern , locale locale , time zone time zone ) { return ( calendar ) parse ( value , pattern , locale , time zone ) ; }
public string calculate ( string code ) throw check digit exception { if ( code == null || code . length ( ) < 5 ) { throw new check digit exception ( `` invalid code length= `` + ( code == null ? 0 : code . length ( ) ) ) ; } int modulus result = calculate modulus ( code ) ; int char value = ( 98 - modulus result ) ; string check digit = integer . to string ( char value ) ; return ( char value > 9 ? check digit : `` 0 `` + check digit ) ; }
protect string to check digit ( int char value ) throw check digit exception { if ( char value > = 0 & & char value < = 9 ) { return integer . to string ( char value ) ; } else { throw new check digit exception ( `` invalid check digit value = `` + + char value ) ; } }
protect int calculate modulus ( string code , boolean include check digit ) throw check digit exception { if ( code . length ( ) > 7 ) { throw new check digit exception ( `` invalid code length = `` + code . length ( ) ) ; } return super . calculate modulus ( code , include check digit ) ; }
public date validate ( string value , string pattern , time zone time zone ) { return ( date ) parse ( value , pattern , ( locale ) null , time zone ) ; }
public static domain validator get instance ( ) { return domain_validator ; }
public boolean be valid infrastructure tld ( string i tld ) { return infrastructure_tld_list . contains ( chomp lead dot ( i tld . to lower case ( ) ) ) ; }
public boolean be valid local tld ( string i tld ) { return local_tld_list . contains ( chomp lead dot ( i tld . to lower case ( ) ) ) ; }
public float validate ( string value , string pattern ) { return ( float ) parse ( value , pattern , ( locale ) null ) ; }
public static inet address validator get instance ( ) { return validator ; }
public calendar validate ( string value , string pattern ) { return ( calendar ) parse ( value , pattern , ( locale ) null , ( time zone ) null ) ; }
public object get parameter value ( string parameter class name ) { return this . parameter . get ( parameter class name ) ; }
public void set msg ( string msg ) { this . msg = msg ; }
protect synchronized void load javascript function ( ) { if ( this . javascript already load ( ) ) { return ; } if ( get log ( ) . be trace enable ( ) ) { get log ( ) . trace ( `` load function begin `` ) ; } if ( this . j function == null ) { this . j function = this . generate j function ( ) ; } string javascript file name = this . format javascript file name ( ) ; if ( get log ( ) . be trace enable ( ) ) { get log ( ) . trace ( `` load j function ' `` + javascript file name + `` ' `` ) ; } this . javascript = this . read javascript file ( javascript file name ) ; if ( get log ( ) . be trace enable ( ) ) { get log ( ) . trace ( `` load javascript function complete `` ) ; } }
public boolean contain action ( string validator name ) { return h action . contains key ( validator name ) ; }
public map get action map ( ) { return collection . unmodifiable map ( h action ) ; }
public void merge ( validator result result ) { this . h result . put all ( result . h result ) ; }
public string get value ( ) { return this . value ; }
protect print writer create_output_stream ( ) { if ( context . get output file ( ) . equal ( `` `` ) ) { if ( j j doc globals . input_file . equal ( `` standard input `` ) ) { return new java . io . print writer ( new java . io . output stream writer ( system . out ) ) ; } else { string ext = `` . html `` ; if ( context . get text ( ) ) { ext = `` . txt `` ; } else if ( context . get x text ( ) ) { ext = `` . xtext `` ; } int i = j j doc globals . input_file . last index of ( ' . ' ) ; if ( i == -1 ) { j j doc globals . output_file = j j doc globals . input_file + ext ; } else { string suffix = j j doc globals . input_file . substring ( i ) ; if ( suffix . equal ( ext ) ) { j j doc globals . output_file = j j doc globals . input_file + ext ; } else { j j doc globals . output_file = j j doc globals . input_file . substring ( 0 , i ) + ext ; } } } } else { j j doc globals . output_file = context . get output file ( ) ; } try { ostr = new java . io . print writer ( new java . io . file writer ( j j doc globals . output_file ) ) ; } catch ( java . io . i o exception e ) { error ( `` j j doc : ca n't open output stream on file `` + j j doc globals . output_file + `` . use standard output . `` ) ; ostr = new java . io . print writer ( new java . io . output stream writer ( system . out ) ) ; } return ostr ; }
public final boolean get node us parser ( ) { return option . boolean value ( `` node_uses_parser `` ) ; }
public final boolean get track token ( ) { return option . boolean value ( `` track_tokens `` ) ; }
public final string get node class ( ) { return option . string value ( `` node_class `` ) ; }
public final string get node package ( ) { return option . string value ( `` node_package `` ) ; }
public static int int value ( final string option ) { return ( ( integer ) option . option value . get ( option ) ) . int value ( ) ; }
public static boolean get debug token manager ( ) { return option . boolean value ( option . useroption__debug_token_manager ) ; }
public static boolean get cache token ( ) { return option . boolean value ( option . useroption__cache_tokens ) ; }
public static string get jdk version ( ) { return option . string value ( option . useroption__jdk_version ) ; }
public static boolean get generate string builder ( ) { return option . boolean value ( option . useroption__generate_string_builder ) ; }
public double t_min ( ) { return t_min ; }
public boolean get use default interval ( ) { return use default interval ; }
public int num curve ( ) { return curve bag . size ( ) ; }
public int num point ( ) { return point bag . size ( ) ; }
public int get from index ( ) { return from index ; }
public int get group length ( ) { return group . length ; }
public void set close ( boolean b ) { close = b ; }
public void ensure capacity ( int capacity ) { if ( value . length < capacity ) { int x = 2 * value . length ; if ( x < capacity ) x = capacity ; double [ ] arr = new double [ x ] ; for ( int i = 0 ; i < size ; i++ ) arr [ i ] = value [ i ] ; value = arr ; } }
public static expression parse ( string s ) { if ( s == null ) throw new expression parse exception ( `` expression string can not be null . `` , -1 ) ; return build ( s , 0 ) ; }
public double of ( double [ ] d , int num param ) { return math . ab ( d [ 0 ] ) ; }
public double of ( double [ ] d , int num param ) { return math . log ( d [ 0 ] + math . sqrt ( 1 + d [ 0 ] * d [ 0 ] ) ) ; }
public double of ( double [ ] d , int num param ) { return java . lang . math . atan ( d [ 0 ] ) ; }
public boolean accept num param ( int num param ) { return num param == 2 ; }
public double of ( double [ ] d , int num param ) { return ( math . pow ( math . e , d [ 0 ] ) + math . pow ( math . e , -d [ 0 ] ) ) / 2 ; }
public double of ( double [ ] d , int num param ) { return java . lang . math . floor ( d [ 0 ] ) ; }
public double of ( double [ ] d , int num param ) { return java . lang . math . sqrt ( d [ 0 ] ) ; }
public string [ ] get function name ( ) { string [ ] arr = new string [ num func ] ; for ( int i = 0 ; i < arr . length ; i++ ) arr [ i ] = name [ i ] ; return arr ; }
public function [ ] get function ( ) { function [ ] arr = new function [ num func ] ; for ( int i = 0 ; i < arr . length ; i++ ) arr [ i ] = func [ i ] ; return arr ; }
public void reset ( ) { share data . pt = new double [ ] [ ] { { 1 } } ; }
public double [ ] get value ( ) { double [ ] arr = new double [ num var ] ; for ( int i = 0 ; i < arr . length ; i++ ) arr [ i ] = value [ i ] ; return arr ; }
public class < ? extend view config > get to view ( ) { return to view ; }
public bean builder < t > passivation capable ( boolean passivation capable ) { this . passivation capable = passivation capable ; return this ; }
public static class loader get class loader ( object o ) { if ( system . get security manager ( ) ! = null ) { return access controller . do privilege ( new get class loader action ( o ) ) ; } else { return get class loader internal ( o ) ; } }
protect project stage resolve project stage ( ) { for ( string config location : config_setting_keys ) { string stage name = config resolver . get property value ( config location ) ; if ( stage name ! = null & & ! stage name . be empty ( ) ) { return project stage . value of ( stage name ) ; } } return null ; }
public static boolean be static ( member member ) { return modifier . be static ( member . get modifier ( ) ) ; }
public static boolean be abstract ( method method ) { return modifier . be abstract ( method . get modifier ( ) ) ; }
protected list < attribute > create attribute list ( ) { return new bean attribute list ( this ) ; }
public static bean meta data get ( class < ? > bean class ) { bean meta data answer = singleton cache . get ( bean class ) ; if ( answer == null ) { answer = new bean meta data ( bean class ) ; singleton cache . put ( bean class , answer ) ; } return answer ; }
public void set attribute x s datatype ( q name attribute q name , x s datatype type ) { attribute x s datatypes . put ( attribute q name , type ) ; }
public static void not support ( ) { throw new d o m exception ( d o m exception . not_supported_err , `` not support yet `` ) ; }
public string get element name ( ) { return element name ; }
public void set value default ( string value default ) { this . value default = value default ; }
public void set name ( string name ) { this . name = name ; }
public void reset handler ( ) { at root = true ; path = `` / `` ; path stack . clear ( ) ; handler stack . clear ( ) ; handler . clear ( ) ; default handler = null ; }
public document get document ( ) { return content handler . get document ( ) ; }
public static x m l reader create x m l reader ( boolean validating , boolean namespace aware ) throw exception { s a x parser factory factory = s a x parser factory . new instance ( ) ; factory . set validating ( validate ) ; factory . set namespace aware ( namespace aware ) ; s a x parser parser = factory . new s a x parser ( ) ; return parser . get x m l reader ( ) ; }
public void external entity decl ( string name , string public id , string sys id ) throw s a x exception { external entity decl declaration = new external entity decl ( name , public id , sys id ) ; if ( internal d t dsubset ) { if ( include internal d t d declaration ) { add d t d declaration ( declaration ) ; } } else { if ( include external d t d declaration ) { add external d t d declaration ( declaration ) ; } } }
protect void add external d t d declaration ( decl declaration ) { if ( external d t d declaration == null ) { external d t d declaration = new array list < decl > ( ) ; } external d t d declaration . add ( declaration ) ; }
public document read ( input stream in ) throw document exception { input source source = new input source ( in ) ; if ( this . encode ! = null ) { source . set encoding ( this . encode ) ; } return read ( source ) ; }
public void set encoding ( string encode ) { this . encode = encoding ; }
protect s a x content handler create content handler ( x m l reader reader ) { return new s a x content handler ( get document factory ( ) , dispatch handler ) ; }
public double get priority ( ) { return priority ; }
public void set definition ( x m l table definition definition ) { this . definition = definition ; }
protect q name create q name ( string local name , string qualify name , namespace namespace ) { return document factory . create q name ( local name , namespace ) ; }
public static boolean end with whitespace ( final char sequence char seq ) { if ( char seq . length ( ) == 0 ) { return false ; } return character . be whitespace ( char seq . char at ( char seq . length ( ) - 1 ) ) ; }
public void sort ( list < node > list ) { sort ( list , false ) ; }
public < t > t call factory ( string factory method , class < ? > [ ] param type , object [ ] param value ) { return call factory ( fully qualify class name , factory method , param type , param value ) ; }
public iterator < class < ? super t > > iterator ( ) { return create class list ( ) . iterator ( ) ; }
public string get server ( ) { return server ; }
protect static string extract hostname from dns srv ( string dns name target ) { if ( dns name target == null || dns name target . be empty ( ) ) { return null ; } else { if ( dns name target . end with ( `` . `` ) ) { dns name target = dns name target . substring ( 0 , dns name target . length ( ) -1 ) ; } return dns name target ; } }
public autodiscover error get error ( ) { return this . error ; }
public int get port ( ) { return this . port ; }
protect string get ws address action name ( ) { return get domain setting action uri ; }
public void write start element ( xml namespace xml namespace , string local name ) throw x m l stream exception { string str prefix = ews utility . get namespace prefix ( xml namespace ) ; string str name space = ews utility . get namespace uri ( xml namespace ) ; this . xml writer . write start element ( str prefix , local name , str name space ) ; }
public static string format http response header ( http web request response ) throw e w s http exception { final int code = response . get response code ( ) ; final string content type = response . get response content type ( ) ; final map < string , string > header = response . get response header ( ) ; return code + `` `` + content type + `` \n `` + ew utility . format http header ( header ) + `` \n `` ; }
public static < t extend enum < ? > > void parse enum value list ( class < t > c , list < t > list , string value , char . . . separator ) { ews utility . ew assert ( c . be enum ( ) , `` ews utility . parse enum value list `` , `` t be not an enum type . `` ) ; string builder regexp = new string builder ( ) ; regexp . append ( `` [ `` ) ; for ( char s : separator ) { regexp . append ( `` [ `` ) ; regexp . append ( pattern . quote ( s + `` `` ) ) ; regexp . append ( `` ] `` ) ; } regexp . append ( `` ] `` ) ; string [ ] enum value = value . split ( regexp . to string ( ) ) ; for ( string enum value : enum value ) { for ( t o : c . get enum constant ( ) ) { if ( o . to string ( ) . equal ( enum value ) ) { list . add ( o ) ; } } } }
public string read element value ( ) throw exception { this . ensure current node be start element ( ) ; return this . read element value ( this . get namespace prefix ( ) , this . get local name ( ) ) ; }
public void read end element ( string namespace prefix , string element name ) throw exception { this . internal read element ( namespace prefix , element name , new xml node type ( xml node type . end_element ) ) ; }
public void skip current element ( ) throw exception { this . skip element ( this . get namespace prefix ( ) , this . get local name ( ) ) ; }
public boolean be empty element ( ) throw x m l stream exception { boolean be present start element = this . present event . be start element ( ) ; boolean be next end element = this . xml reader . peek ( ) . be end element ( ) ; return be present start element & & be next end element ; }
public service response get response ( ) { return response ; }
public int get minor version ( ) { return minor version ; }
public void set minor version ( int minor version ) { this . minor version = minor version ; }
public void set major build number ( int major build number ) { this . major build number = major build number ; }
public void end unsubscribe ( i async result async result ) throw exception { unsubscribe request request = async request result . extract service request ( this , async result ) ; request . end execute ( async result ) ; }
public collection < email address > get room ( email address email address ) throw exception { ews utility . validate param ( email address , `` email address `` ) ; get room request request = new get room request ( this ) ; request . set room list ( email address ) ; return request . execute ( ) . get room ( ) ; }
public void set trace enable ( boolean trace enable ) { this . trace enable = trace enable ; if ( this . trace enable & & ( this . trace listener == null ) ) { this . trace listener = new ew trace listener ( ) ; } }
public void set web proxy ( web proxy value ) { this . web proxy = value ; }
public boolean be property updated ( property definition property definition ) { return this . modified property . contains ( property definition ) || this . added property . contains ( property definition ) ; }
protect void property change ( complex property complex property ) { iterator < entry < property definition , object > > it = this . property . entry set ( ) . iterator ( ) ; while ( it . have next ( ) ) { entry < property definition , object > key value pair = it . next ( ) ; if ( key value pair . get value ( ) . equal ( complex property ) ) { if ( ! this . deleted property . contains key ( key value pair . get key ( ) ) ) { add to change list ( key value pair . get key ( ) , this . modified property ) ; this . change ( ) ; } } } }
public void set base property set ( base property set base property set ) { this . throw if readonly ( ) ; this . base property set = base property set ; }
public list < delegate user > get delegate user ( ) { return this . delegate user ; }
protect string get object collection xml element name ( ) { return xml element name . folder ; }
public folder id get parent folder id ( ) { return this . parent folder id ; }
public void set parent folder id ( folder id value ) { this . parent folder id = value ; }
public void set email address ( email address email address ) { this . email address = email address ; }
public folder id wrapper list get parent folder id ( ) { return this . parent folder id ; }
public string get query string ( ) { return query string ; }
public void set include permission ( boolean include permission ) { this . include permission = include permission ; }
public property set get property set ( ) { return this . property set ; }
protect string get name ( ) { return this . name ; }
public output stream get output stream ( ) throw e w s http exception { output stream o = null ; throw if request be null ( ) ; o = new byte array output stream ( ) ; http post . set entity ( new byte array o s request entity ( o ) ) ; return o ; }
public int get response code ( ) throw e w s http exception { throw if response be null ( ) ; return response . get status line ( ) . get status code ( ) ; }
public boolean be pre authenticate ( ) { return pre authenticate ; }
public string get request method ( ) { return request method ; }
protected item id get item id ( ) { return this . item id ; }
public void set name to resolve ( string name to resolve ) { this . name to resolve = name to resolve ; }
public oof setting get oof setting ( ) { return this . oof setting ; }
public void set sync folder id ( folder id value ) { this . sync folder id = value ; }
protect string get mailbox smtp address ( ) { return this . mailbox smtp address ; }
public void set conflict resolution mode ( conflict resolution mode value ) { this . conflict resolution mode = value ; }
public oof setting get oof setting ( ) { return this . oof setting ; }
protect void internal throw if necessary ( ) throw service response exception { if ( this . get error code ( ) ! = service error . error name resolution no result ) { super . internal throw if necessary ( ) ; } }
protect void internal throw if necessary ( ) throw service response exception { if ( this . result == service result . error ) { throw new service response exception ( this ) ; } }
public change collection < t change > get change ( ) { return this . change ; }
public void update ( ) throw exception { if ( this . be dirty ( ) ) { if ( this . get property bag ( ) . get be update call necessary ( ) ) { this . get service ( ) . update folder ( this ) ; } } }
public folder id get parent folder id ( ) throw service local exception { return get property bag ( ) . get object from property definition ( folder schema . parent folder id ) ; }
public void save ( send invitation mode send invitation mode ) throw exception { this . internal create ( null , null , send invitation mode ) ; }
public calendar action result accept tentatively ( boolean send response ) throw exception { return this . internal accept ( true , send response ) ; }
public date get end ( ) throw service local exception { return get property bag ( ) . get object from property definition ( appointment schema . end ) ; }
public boolean get be cancel ( ) throw service local exception { return get property bag ( ) . get object from property definition ( appointment schema . be cancel ) ; }
public email address get organizer ( ) throw service local exception { return get property bag ( ) . get object from property definition ( appointment schema . organizer ) ; }
public attendee collection get optional attendee ( ) throw service local exception { return get property bag ( ) . get object from property definition ( appointment schema . optional attendee ) ; }
public void set allow new time proposal ( boolean value ) throw exception { this . get property bag ( ) . set object from property definition ( appointment schema . allow new time proposal , value ) ; }
public void remove contact picture ( ) throw exception { ews utility . validate method version ( this . get service ( ) , exchange version . exchange2010 , `` remove contact picture `` ) ; if ( ! this . get property bag ( ) . be property loaded ( contact schema . attachment ) ) { throw new property exception ( `` the attachment collection must be load . `` ) ; } internal remove contact picture ( ) ; }
public string get display name ( ) throw service local exception { return get property bag ( ) . get object from property definition ( contact schema . display name ) ; }
public string get middle name ( ) throw service local exception { return get property bag ( ) . get object from property definition ( contact schema . middle name ) ; }
public email address dictionary get email address ( ) throw service local exception { return get property bag ( ) . get object from property definition ( contact schema . email address ) ; }
public void set generation ( string value ) throw exception { this . get property bag ( ) . set object from property definition ( contact schema . generation , value ) ; }
public string get job title ( ) throw service local exception { return get property bag ( ) . get object from property definition ( contact schema . job title ) ; }
public void set profession ( string value ) throw exception { this . get property bag ( ) . set object from property definition ( contact schema . profession , value ) ; }
public void set spouse name ( string value ) throw exception { this . get property bag ( ) . set object from property definition ( contact schema . spouse name , value ) ; }
public string get alias ( ) throw service local exception { return get property bag ( ) . get object from property definition ( contact schema . alias ) ; }
public string get note ( ) throw service local exception { return get property bag ( ) . get object from property definition ( contact schema . note ) ; }
public string list get unique recipient ( ) throw exception { return get property bag ( ) . get object from property definition ( conversation schema . unique recipient ) ; }
public boolean get global have attachment ( ) throw service local exception { return get property bag ( ) . < boolean > get object from property definition ( conversation schema . global have attachment ) ; }
public email address collection get cc recipient ( ) throw service local exception { return get property bag ( ) . get object from property definition ( email message schema . cc recipient ) ; }
public byte [ ] get conversation index ( ) throw service local exception { return get property bag ( ) . get object from property definition ( email message schema . conversation index ) ; }
public void set from ( email address value ) throw exception { this . get property bag ( ) . set object from property definition ( email message schema . from , value ) ; }
public boolean get be delivery receipt request ( ) throw service local exception { return get property bag ( ) . get object from property definition ( email message schema . be delivery receipt request ) ; }
public boolean get be unmodified ( ) throw service local exception { return get property bag ( ) . < boolean > get object from property definition ( item schema . be unmodified ) ; }
public void set item class ( string value ) throw exception { this . get property bag ( ) . set object from property definition ( item schema . item class , value ) ; }
public date get original start ( ) throw service local exception { return get property bag ( ) . get object from property definition ( appointment schema . original start ) ; }
public date get post time ( ) throw service local exception { return get property bag ( ) . get object from property definition ( post item schema . posted time ) ; }
public integer get actual work ( ) throw service local exception { return get property bag ( ) . get object from property definition ( task schema . actual work ) ; }
public boolean get tentative ( ) { return this . tentative ; }
public message body get body ( ) throw exception { return ( message body ) this . get object from property definition ( item schema . body ) ; }
public static item schema get instance ( ) { return instance ; }
protect void register property ( property definition property ) { this . register property ( property , false ) ; }
protect void remove change event ( i create service object with attachment param change ) { on change list . remove ( change ) ; }
public iterable < t key > get added item ( ) { return this . added item ; }
public boolean contains key ( t key key ) { return this . item . contains key ( key ) ; }
public boolean try get value ( t key key , out param < object > value ) { if ( this . item . contains key ( key ) ) { value . set param ( this . item . get ( key ) ) ; return true ; } else { value . set param ( null ) ; return false ; } }
public string get host ( ) { return this . host ; }
protect uri get ew url ( ) { return this . ews url ; }
protect void load ( string srv record ) throw dns exception { super . load ( null ) ; string tokenizer str tokens = new string tokenizer ( srv record ) ; try { while ( str token . have more token ( ) ) { string priority = str token . next token ( ) ; this . priority = integer . parse int ( priority ) ; string weight = str token . next token ( ) ; this . weight = integer . parse int ( weight ) ; string port = str token . next token ( ) ; this . port = integer . parse int ( port ) ; string target = str token . next token ( ) ; this . target = target ; } } catch ( number format exception ne ) { throw new dns exception ( `` number format exception `` + ne . get message ( ) ) ; } catch ( no such element exception ne ) { throw new dns exception ( `` no such element exception `` + ne . get message ( ) ) ; } }
public folder get folder ( ) { return null ; }
public item get item ( ) { return null ; }
public static attendee info get attendee info from string ( string smtp address ) { return new attendee info ( smtp address ) ; }
public meeting attendee type get attendee type ( ) { return attendee type ; }
public void set good suggestion threshold ( int value ) { if ( value < 1 || value > 49 ) { throw new illegal argument exception ( string . format ( `` % s must be between % d and % d . `` , `` good suggestion threshold `` , 1 , 49 ) ) ; } this . good suggestion threshold = value ; }
public int get maximum non work hour suggestion per day ( ) { return this . maximum non work hour suggestion per day ; }
public void set meeting duration ( int value ) { if ( value < 30 || value > 1440 ) { throw new illegal argument exception ( string . format ( `` % s , % s , % s , % s `` , `` % s must be between % d and % d . `` , `` meeting duration `` , 30 , 1440 ) ) ; } this . meeting duration = value ; }
public void set detailed suggestion window ( time window value ) { this . detailed suggestion window = value ; }
public collection < suggestion > get suggestion ( ) throw service response exception { if ( this . suggestion response == null ) { return null ; } else { this . suggestion response . throw if necessary ( ) ; return this . suggestion response . get suggestion ( ) ; } }
protected time span get delta ( ) { return this . delta ; }
protect int get month ( ) { return this . month ; }
public static string get string from oof reply ( oof reply oof reply ) throw exception { ews utility . validate param ( oof reply , `` oof reply `` ) ; return oof reply . message ; }
public date get end time ( ) { return end time ; }
public meeting cancellation get meeting cancellation ( ) { return this . meeting cancellation ; }
protect conversation action type get action ( ) { return this . action ; }
public void set category ( string list value ) { this . category = value ; }
public void set unique id ( string id ) { this . id = id ; }
public string get phone number ( ) { return this . phone number ; }
public email address get mailbox ( ) { return this . mailbox ; }
public contact get contact ( ) { return this . contact ; }
protect string get fault code ( ) { return fault code ; }
protect void set fault code ( string fault code ) { this . fault code = fault code ; }
protect void set fault string ( string fault string ) { this . fault string = fault string ; }
protect int get line number ( ) { return line number ; }
public string get name ( ) { return this . name ; }
public void unsubscribe ( ) throw exception { this . get service ( ) . unsubscribe ( this . get id ( ) ) ; }
public exception get exception ( ) { return this . exception ; }
public string get content type ( ) { return this . content type ; }
public void set be inline ( boolean value ) throw service version exception { ews utility . validate property version ( this . get owner ( ) . get service ( ) , exchange version . exchange2010 , `` be inline `` ) ; if ( this . can set field value ( this . be inline , value ) ) { this . be inline = value ; this . change ( ) ; } }
public void clear ( ) { this . internal clear ( ) ; }
public void clear ( ) { this . internal clear ( ) ; }
public collection < day of the week > get day of the week ( ) { return day of the week ; }
public long get start time ( ) { return start time ; }
protected list < t complex property > get modify item ( ) { return this . modified item ; }
protect boolean internal remove ( t complex property complex property ) { ews utility . ew assert ( complex property ! = null , `` complex property collection . internal remove `` , `` complex property be null `` ) ; if ( this . item . remove ( complex property ) ) { complex property . remove change event ( this ) ; if ( ! this . added item . contains ( complex property ) ) { this . remove item . add ( complex property ) ; } else { this . added item . remove ( complex property ) ; } this . modified item . remove ( complex property ) ; this . change ( ) ; return true ; } else { return false ; } }
protect void validate add delegate ( ) throw service validation exception { for ( delegate folder permission delegate folder permission : this . delegate folder permission . value ( ) ) { if ( delegate folder permission . get permission level ( ) == delegate folder permission level . custom ) { throw new service validation exception ( `` this operation ca n't be perform because one or more folder `` + `` permission level be set to custom . `` ) ; } } }
public void set receive copy of meeting message ( boolean value ) { this . receive copy of meeting message = value ; }
public string get name ( ) { return name ; }
public void set address ( string address ) { if ( this . can set field value ( this . address , address ) ) { this . address = address ; this . change ( ) ; } }
public void set mailbox type ( mailbox type mailbox type ) { if ( this . can set field value ( this . mailbox type , mailbox type ) ) { this . mailbox type = mailbox type ; this . change ( ) ; } }
public string get search string ( ) { return this . get address ( ) ; }
public extend property definition get property definition ( ) { return this . property definition ; }
protect input stream get content stream ( ) { return this . content stream ; }
public mailbox get mailbox ( ) { return this . mailbox ; }
public boolean get be folder owner ( ) { return this . be folder owner ; }
public void service object change ( service object service object ) { this . item change ( service object ) ; }
public string get home page ( ) { return home page ; }
public string get name ( ) { return this . name ; }
public time change get daylight ( ) { return this . daylight ; }
public void set state ( string value ) { this . property bag . set simple property bag ( physical address schema . state , value ) ; }
public void set country or region ( string value ) { this . property bag . set simple property bag ( physical address schema . country or region , value ) ; }
public < t > t get field value or throw if null ( class < t > cl , object value , string name ) throw service validation exception { if ( value ! = null ) { return ( t ) value ; } else { throw new service validation exception ( string . format ( `` the recurrence pattern 's % s property must be specify . `` , name ) ) ; } }
public boolean have end ( ) { return ( ( this . number of occurrence ! = null ) || ( this . end date ! = null ) ) ; }
public void never end ( ) { this . number of occurrence = null ; this . end date = null ; this . change ( ) ; }
public boolean get be not support ( ) { return this . be not support ; }
public boolean get delete ( ) { return this . delete ; }
public item id get server reply with message ( ) { return this . server reply with message ; }
public rule operation get operation ( ) { return this . operation ; }
public date get date time ( ) { return date time ; }
protect void set date time ( date date time ) { this . date time = date time ; }
protected time zone period get target period ( ) { return this . target period ; }
public void set absolute date ( date absolute date ) { this . absolute date = absolute date ; if ( absolute date ! = null ) { this . recurrence = null ; } }
public static string get string from unique body ( unique body message body ) throw exception { ews utility . validate param ( message body , `` message body `` ) ; return message body . text ; }
public body type get body type ( ) { return this . body type ; }
public string get index ( ) { return this . index ; }
public boolean be nullable ( ) { return true ; }
public string get uri ( ) { return uri ; }
public void set more available ( boolean more available ) { this . more available = more available ; }
public change type get change type ( ) { return this . change type ; }
public service object get service object ( ) { return this . service object ; }
@ override public service id create id ( ) { return new folder id ( ) ; }
public static date convert date time string to date ( string value ) { return parse internal ( value , false ) ; }
public cascade style get p e cascade style ( object e , string pseudo element ) { synchronize ( e ) { mapper em = get mapper ( e ) ; return em . get p e cascade style ( e , pseudo element ) ; } }
public list get medium ( ) { return medium type ; }
public int get origin ( ) { return origin ; }
public string get title ( ) { return title ; }
public void set share context ( share context ctx ) { panel . set share context ( ctx ) ; }
public rectangle get minimum size ( ) { if ( panel . get preferred size ( ) ! = null ) { return new rectangle ( 0 , 0 , ( int ) panel . get preferred size ( ) . get width ( ) , ( int ) panel . get preferred size ( ) . get height ( ) ) ; } else { return new rectangle ( 0 , 0 , panel . get width ( ) , panel . get height ( ) ) ; } }
public void shrink image cache ( ) { _image resource loader . shrink ( ) ; }
public void reset ( ) { _previously hover = null ; }
public synchronize void add to queue ( final image resource loader image resource loader , final string uri , final mutable f s image mfsi , final int width , final int height ) { x r log . general ( level . fine , `` queue load for image uri `` + uri ) ; _load queue . add last ( new image load item ( image resource loader , uri , mfsi , width , height ) ) ; notify all ( ) ; }
public void remove listener ( f s mouse listener l ) { if ( l == null ) { return ; } if ( _handlers . contains key ( l ) ) { _handlers . remove ( l ) ; } if ( _enabled & & _handlers . size ( ) == 0 ) { _panel . remove mouse listener ( this ) ; _panel . remove mouse motion listener ( this ) ; _enabled = false ; } }
public rectangle get fix rectangle ( ) { if ( enclose scroll pane ! = null ) { return enclose scroll pane . get viewport border bound ( ) ; } else { dimension dim = get size ( ) ; return new rectangle ( 0 , 0 , dim . width , dim . height ) ; } }
public static int value a byte ( string key , byte default val ) { string val = value for ( key ) ; if ( val == null ) { return default val ; } byte bval ; try { bval = byte . value of ( val ) . byte value ( ) ; } catch ( number format exception nex ) { x r log . exception ( `` property ' `` + key + `` ' be request a a byte , but `` + `` value of ' `` + val + `` ' be not a byte . check configuration . `` ) ; bval = default val ; } return bval ; }
public static void main ( string args [ ] ) { try { system . out . println ( `` byte : `` + string . value of ( configuration . value a byte ( `` xr . test-config-byte `` , ( byte ) 15 ) ) ) ; system . out . println ( `` short : `` + string . value of ( configuration . value a short ( `` xr . test-config-short `` , ( short ) 20 ) ) ) ; system . out . println ( `` int : `` + string . value of ( configuration . value a int ( `` xr . test-config-int `` , 25 ) ) ) ; system . out . println ( `` long : `` + string . value of ( configuration . value a long ( `` xr . test-config-long `` , 30l ) ) ) ; system . out . println ( `` float : `` + string . value of ( configuration . value a float ( `` xr . test-config-float `` , 45 . 5f ) ) ) ; system . out . println ( `` double : `` + string . value of ( configuration . value a double ( `` xr . test-config-double `` , 50 . 75d ) ) ) ; system . out . println ( `` boolean : `` + string . value of ( configuration . be true ( `` xr . test-config-boolean `` , false ) ) ) ; } catch ( exception ex ) { ex . print stack trace ( ) ; } }
public static f s image writer new jpeg writer ( float quality ) { f s image writer writer = new f s image writer ( `` jpg `` ) ; writer . set write compression mode ( image write param . mode_explicit ) ; writer . set write compression type ( `` jpeg `` ) ; writer . set write compression quality ( quality ) ; return writer ; }
public static void clear image ( buffer image image ) { clear image ( image , color . white ) ; }
public static buffer image convert to buffer image ( image awt img , int type ) { buffer image bimg ; if ( awt img instanceof buffer image ) { bimg = ( buffered image ) awt img ; } else { bimg = create compatible buffer image ( awt img . get width ( null ) , awt img . get height ( null ) , type ) ; graphics2 d g = bimg . create graphic ( ) ; g . draw image ( awt img , 0 , 0 , null , null ) ; g . dispose ( ) ; } return bimg ; }
public string format message ( log record record ) { return super . format message ( record ) ; }
public string get tail ( handler h ) { return super . get tail ( h ) ; }
public void set metric set ( int metric set value ) { if ( metric set value < 0 || metric set value > 2 ) { throw new illegal argument exception ( `` the metric set attribute must be in the `` + `` set { 0,1,2 } and not ' `` + metric set value + `` ' `` ) ; } metric set = metric set value ; }
public string get font name ( ) { return font name ; }
public string get full name ( ) { return full name ; }
public int get mapping scheme ( ) { return map scheme ; }
public string get character set ( ) { return character set ; }
public float [ ] get v vector ( ) { return this . v vector ; }
public void set v vector ( float [ ] v vector value ) { v vector = v vector value ; }
public float get x height ( ) { return x height ; }
public float get italic angle ( ) { return italic angle ; }
public float [ ] get char width ( ) { return this . char width ; }
public void set track kern ( list < track kern > track kern value ) { track kern = track kern value ; }
public void add track kern ( track kern kern ) { track kern . add ( kern ) ; }
public void add composite ( composite composite ) { composite . add ( composite ) ; }
public void set standard horizontal width ( float standard horizontal width value ) { standard horizontal width = standard horizontal width value ; }
public float get max kern ( ) { return max kern ; }
public float get max point size ( ) { return max point size ; }
public string get registry ( ) { return registry ; }
public static c f f operator get operator ( key key ) { return key map . get ( key ) ; }
public void set position ( int position ) { buffer position = position ; }
public int read unsigned byte ( ) throw i o exception { int b = read ( ) ; if ( b < 0 ) { throw new e o f exception ( ) ; } return b ; }
public int read unsigned short ( ) throw i o exception { int b1 = read ( ) ; int b2 = read ( ) ; if ( ( b1 | b2 ) < 0 ) { throw new e o f exception ( ) ; } return b1 < < 8 | b2 ; }
public void write ( byte [ ] buffer ) { output buffer . write ( buffer , 0 , buffer . length ) ; }
public list < object > get type2 sequence ( ) { return type2sequence ; }
public void set name ( string name ) { cmap name = name ; }
public int get supplement ( ) { return supplement ; }
public integer get code ( string name ) { return name to code . get ( name ) ; }
public double get scale10 ( ) { return scale10 ; }
public int scale y ( int x , int y ) { return math . round ( ( float ) ( x * scale01 + y * yscale ) ) ; }
public int get default char ( ) { return u default char ; }
public post script table get post script ( ) throw i o exception { return ( post script table ) get table ( post script table . tag ) ; }
public horizontal header table get horizontal header ( ) throw i o exception { return ( horizontal header table ) get table ( horizontal header table . tag ) ; }
public horizontal metric table get horizontal metric ( ) throw i o exception { return ( horizontal metric table ) get table ( horizontal metric table . tag ) ; }
public string read string ( int length ) throw i o exception { return read string ( length , charsets . iso_8859_1 ) ; }
public long read unsigned int ( ) throw i o exception { long byte1 = read ( ) ; long byte2 = read ( ) ; long byte3 = read ( ) ; long byte4 = read ( ) ; if ( byte4 < 0 ) { throw new e o f exception ( ) ; } return ( byte1 < < 24 ) + ( byte2 < < 16 ) + ( byte3 < < 8 ) + ( byte4 < < 0 ) ; }
public string get notice ( ) { return notice ; }
public string get family name ( ) { return family name ; }
public type1 font parse ( byte [ ] segment1 , byte [ ] segment2 ) throw i o exception { font = new type1 font ( segment1 , segment2 ) ; parse a s c i i ( segment1 ) ; if ( segment2 . length > 0 ) { parse binary ( segment2 ) ; } return font ; }
public static boolean be optional ( final interface itf ) { if ( itf instanceof type interface ) { type interface t itf = ( type interface ) itf ; return type interface . optional_contingency . equal ( t itf . get contingency ( ) ) ; } return false ; }
public static boolean be collection ( final interface itf ) { if ( itf instanceof type interface ) { type interface t itf = ( type interface ) itf ; return type interface . collection_cardinality . equal ( t itf . get cardinality ( ) ) ; } return false ; }
public static void warning ( final string message ) { log ( warn , message ) ; }
public static boolean be warn enable ( ) { return ( level < = warning ) ; }
public boolean add ( annotation a ) throw class cast exception { annotation old value = annots by id . put ( a . get id ( ) , a ) ; if ( old value ! = null ) { if ( annots by type ! = null ) remove from type index ( old value ) ; if ( annots by start node ! = null ) remove from offset index ( old value ) ; } if ( annots by type ! = null ) add to type index ( a ) ; if ( annots by start node ! = null ) add to start offset index ( a ) ; annotation set event evt = new annotation set event ( this , annotation set event . annotation_added , doc , a ) ; fire annotation add ( evt ) ; fire gate event ( evt ) ; return old value ! = a ; } // add ( o )
public integer add ( node start , node end , string type , feature map feature ) { throw new unsupported operation exception ( ) ; }
public void warning ( s a x parse exception ex ) throw s a x exception { _seh . warning ( ex ) ; } // warn
public boolean be document load ( int index ) { return true ; }
public resource init ( ) { if ( document list ! = null & & ! document list . be empty ( ) ) { add all ( document list ) ; } return this ; } // init ( )
public annotation set get annotation ( string name ) { if ( name == null || `` `` . equal ( name ) ) return get annotation ( ) ; if ( name annot set == null ) { name annot set = new hash map < string , annotation set > ( ) ; } annotation set name set = name annot set . get ( name ) ; if ( name set == null ) { name set = new annotation set impl ( this , name ) ; name annot set . put ( name , name set ) ; document event evt = new document event ( this , document event . annotation_set_added , name ) ; fire annotation set add ( evt ) ; } return name set ; } // get annotation ( name )
public string to xml ( set < annotation > a source annotation set ) { return to xml ( a source annotation set , true ) ; }
public void set type ( string type ) { this . type = type ; }
public string get subtype ( ) { return subtype ; }
public boolean have parameter ( string name ) { return parameter . contains key ( name ) ; }
public object get document persistent i d ( int index ) { if ( index > = doc data list . size ( ) ) return null ; return doc data list . get ( index ) . get persistent i d ( ) ; }
protect static boolean be gate xml format ( string content ) { return ( content . index of ( `` < gate document `` ) ! = -1 || content . index of ( `` gate document `` ) ! = -1 ) ; }
protect void execute impl ( ) throw execution exception { throw new execution exception ( `` controller `` + get class ( ) + `` have n't overriden the execute impl ( ) method `` ) ; }
public object get l r persistence id ( ) { return lr persistent id ; }
public void cleanup ( ) { }
public feature map get feature ( ) { return feature ; } //get feature ( )
public void set feature ( feature map feature ) { this . feature = feature ; } // set feature ( )
public void set target ( object target ) { throw new runtime exception ( `` class `` + get class ( ) + `` have n't implement the set target ( ) method ! `` ) ; }
public void set handle ( handle handle ) { this . handle = handle ; }
public void set boost ( float boost ) { this . boost = boost ; }
public final boolean be store ( ) { return be store ; }
public directory directory ( ) { return directory ; }
public string get description ( ) { return description ; }
public void initialize term position ( ) { query type = new array list < integer > ( ) ; first term position = new array list ( ) ; document number = new array list < integer > ( ) ; pattern length = new array list < integer > ( ) ; frequency = new array list < integer > ( ) ; }
protect weight create weight ( searcher searcher ) { throw new unsupported operation exception ( ) ; }
public query rewrite ( index reader reader ) throw i o exception { return this ; }
public final synchronize void close ( ) throw i o exception { if ( -- ref count < = 0 ) { synchronize ( directory ) { directory . remove ( directory ) ; } } }
public final boolean file exists ( string name ) { r a m file file = ( r a m file ) file . get ( name ) ; return file ! = null ; }
public boolean insert ( object element ) { if ( size < max size ) { put ( element ) ; return true ; } else if ( size > 0 & & ! less than ( element , top ( ) ) ) { heap [ 1 ] = element ; adjust top ( ) ; return true ; } else return false ; }
public final int size ( ) { return size ; }
public list < list < pattern annotation > > get gate annotation ( ) { return this . gate annotation ; }
public void export result ( file output file ) { throw new runtime exception ( `` export result method be not implement yet ! `` ) ; }
public string get query ( ) { return query ; }
public void set type ( string type ) { this . type = type ; }
public void set text ( string text ) { this . text = text ; }
public string get feature ( string key ) { return feature . get ( key ) ; }
public int get position ( ) { return position ; }
public void set annotation name ( string annotation name ) { this . annotation name = annotation name ; } // set annotation name
public void from x schema ( url an x schema u r l ) throw resource instantiation exception { org . jdom . document j dom = null ; s a x builder sax builder = new s a x builder ( false ) ; try { try { j dom = sax builder . build ( an x schema u r l ) ; } catch ( j d o m exception je ) { throw new resource instantiation exception ( je ) ; } } catch ( java . io . i o exception ex ) { throw new resource instantiation exception ( ex ) ; } work with j dom ( j dom ) ; } // from x schema
public void resource unload ( creole event e ) { super . resource unload ( e ) ; if ( e . get resource ( ) == corpus ) { set corpus ( null ) ; } }
public void cleanup ( ) { super . cleanup ( ) ; strategy list . clear ( ) ; }
public set < string > get application type ( ) { return collection . unmodifiable set ( application type ) ; }
public list < string > get large v r for resource ( string resource class name ) { return get v r for resource ( resource class name , resource data . large_gui ) ; } // get large v r for resource ( )
public list < term > get field ( ) { return field value ; }
public void set help u r l ( string help u r l ) { this . help u r l = help u r l ; }
public list < list < parameter > > get runtime parameter ( ) { return runtime parameter ; } // get runtime parameter ( )
public boolean add all ( list < parameter > c ) { boolean status = false ; iterator < parameter > iter = c . iterator ( ) ; while ( iter . have next ( ) ) { list < parameter > disj = new array list < parameter > ( ) ; parameter param = iter . next ( ) ; disj . add ( param ) ; status = add ( disj ) ; } return status ; } // add all ( collection )
public string get version ( ) { return version == null ? `` `` : version ; }
public int hash code ( ) { return name . hash code ( ) ; } // hash code
public list < resource > get instantiation ( ) { return unmodifiable instantiation stack ; } // get instantiation
public void add instantiation ( resource resource ) { instantiation stack . add ( 0 , resource ) ; } // add instantiation
public void set class name ( string class name ) { this . class name = class name ; }
public url get jar file url ( ) { return jar file url ; }
public url get xml file url ( ) { return xml file url ; }
public string get resource displayed ( ) { return resource display ; }
public boolean add ( data store o ) { return super . add ( o ) ; } // add
public file filter get file filter ( ) { if ( filter == null ) filter = new extension file filter ( file type + `` file ( * . `` + default extension + `` ) `` , default extension ) ; return filter ; }
public object get document l r i d ( ) { return document l r i d ; }
public gate . resource get resource ( ) { return resource ; }
public static resource create resource ( string resource class name , feature map parameter value ) throw resource instantiation exception { return create resource ( resource class name , parameter value , null , null ) ; } // create resource ( res class name , param vals , listener )
public static feature map duplicate ( feature map fm , duplication context ctx ) throw resource instantiation exception { check duplication context ( ctx ) ; feature map new f m = factory . new feature map ( ) ; for ( map . entry < object , object > entry : fm . entry set ( ) ) { object value = entry . get value ( ) ; if ( value instanceof resource ) { value = duplicate ( ( resource ) value , ctx ) ; } new f m . put ( entry . get key ( ) , value ) ; } return new f m ; }
public static set < string > get register i r engine ( ) { return collection . unmodifiable set ( registered i r engine ) ; }
public static void add know plugin ( plugin plugin ) { if ( know plugins . contains ( plugin ) ) return ; if ( plugin update manager . get default plugins ( ) . contains ( plugin ) ) return ; know plugins . add ( plugin ) ; }
public static file get user config file ( ) { return user config file ; }
public list < string > get extension ( ) { return extension ; }
public document get document ( ) { return document ; }
public void move highlight ( object tag , int new start , int new end ) throw bad location exception { if ( tag instanceof highlight data ) { text view . get highlighter ( ) . change highlight ( ( ( highlight data ) tag ) . tag , new start , new end ) ; } }
public static set < string > get input annotation set ( controller c ) { object set name obj = c . get feature ( ) . get ( input_annotation_sets_feature ) ; if ( set names obj ! = null & & set name obj instanceof set ) { return ( set < string > ) set name obj ; } else { set < string > set name = new hash set < string > ( ) ; c . get feature ( ) . put ( input_annotation_sets_feature , set name ) ; populate input set name for controller ( set names , c , true ) ; return set name ; } }
public void end element ( q name element , augmentation augs ) throw x n i exception { end element ( element , aug , false ) ; }
public string get icon name ( ) { return `` datastore `` ; }
public static int [ ] transitive closure ( relation set rel set , string relation name , int annotation id ) { list < relation > relation = new array list < relation > ( ) ; for ( int po = 0 ; po < rel set . get maximum arity ( ) ; pos++ ) { int [ ] constraint = new int [ po + 1 ] ; for ( int i = 0 ; i < po ; i++ ) constraint [ i ] = relation set . any ; constraint [ po ] = annotation id ; relation . add all ( rel set . get relation ( relation name , constraint ) ) ; } sort set < integer > closure = new tree set < integer > ( ) ; closure . add ( annotation id ) ; for ( relation rel : relation ) { for ( int ann id : rel . get member ( ) ) closure . add ( ann id ) ; } int [ ] res = new int [ closure . size ( ) ] ; int i = 0 ; for ( int ann id : closure ) res [ i++ ] = ann id ; return res ; }
public void add layout component ( string name , component comp ) { }
protect graphic configuration find graphic configuration ( component target ) { graphic configuration gc = null ; if ( ! target . be show ( ) ) { if ( target instanceof j popup menu ) { component invoker = ( ( j popup menu ) target ) . get invoker ( ) ; if ( invoker ! = null ) target = invoker ; } } if ( target . be show ( ) ) { point position = target . get location on screen ( ) ; gc = target . get graphics configuration ( ) ; graphic environment ge = graphic environment . get local graphic environment ( ) ; for ( graphic device gd : ge . get screen device ( ) ) { if ( gd . get type ( ) == graphic device . type_raster_screen ) { graphic configuration dgc = gd . get default configuration ( ) ; if ( dgc . get bound ( ) . contains ( position ) ) { gc = dgc ; break ; } } } } return gc ; }
public synchronize void show dialog ( string [ ] text ) { center box . remove all ( ) ; for ( int i =0 ; i < text . length ; i++ ) { center box . add ( new j label ( texts [ i ] ) ) ; } center box . validate ( ) ; pack ( ) ; / * point loc = frame . get location ( ) ; loc . move ( frame . get size ( ) . width - get size ( ) . width / 2 , frame . get size ( ) . height - get size ( ) . height /2 ) ; set location ( loc ) ; * / stop = false ; thread thread = new thread ( thread . current thread ( ) . get thread group ( ) , this , `` wait dialog1 `` ) ; thread . set priority ( thread . max_priority ) ; thread . start ( ) ; set visible ( true ) ; }
public void ensure file be visible ( file f ) { if ( f ! = null & & f . exists ( ) ) super . ensure file be visible ( f ) ; }
public void set enable hiding column ( boolean enable hide column ) { this . enable hide column = enable hiding column ; }
public void set comparator ( int column , comparator < ? > comparator ) { column data . get ( column ) . comparator = comparator ; }
public void set feature ( feature map feature ) { this . feature = feature ; }
public static boolean be benchmarking enable ( ) { return benchmarking enable ; }
public static void pad pr ( string s , int padding ) { for ( int i=0 ; i < pad ; i++ ) err . print ( pad char ) ; err . print ( s ) ; err . flush ( ) ; } // pad pr ( string , int )
public static string get resource path ( ) { return resource path ; }
public void forget class loader ( gate class loader classloader ) { if ( classloader ! = null ) forget class loader ( classloader . get i d ( ) ) ; }
public synchronize void cleanup ( ) { factory . delete resource ( analyser ) ; if ( corpus ! = null ) { factory . delete resource ( corpus ) ; } }
public static void add cache directory ( file dir ) { extra cache directory . add ( 0 , dir ) ; }
public v get next of ( k key ) { if ( root==null ) return null ; entry < k , v > lub=get ceil entry ( key ) ; if ( lub == null ) return null ; return lub . value ; }
static public boolean be unicode enable ( ) { return unicode enable ; }
public static boolean be g a t e new enough ( string version ) { if ( version == null ) return true ; version = version . trim ( ) ; if ( version . equal ( `` `` ) || version . equal ( `` * `` ) ) return true ; return ( compare version ( main . version , version ) > = 0 ) ; }
protect x m l stream writer wrap ( x m l stream writer writer ) throw x m l stream exception { return new x m l11 stream writer ( writer ) ; }
public void write start document ( ) throw x m l stream exception { write start document ( `` 1 . 1 `` ) ; }
public static string clean string for ( document doc , simple annotation ann ) { return clean string ( string for ( doc , ann ) ) ; }
public static annotation set get coextensive annotation ( annotation set source , annotation coext ann ) { return get coextensive annotation worker ( source , null , start ( coext ann ) , end ( coext ann ) ) ; }
public static annotation set get coextensive annotation ( annotation set source , annotation coext ann , string type ) { return get coextensive annotation worker ( source , type , start ( coext ann ) , end ( coext ann ) ) ; }
public static void load plugin ( file plugin dir ) { try { gate . get creole register ( ) . register plugin ( new plugin . directory ( plugin dir . to u r i ( ) . to u r l ( ) ) ) ; } catch ( exception ex ) { throw new gate runtime exception ( `` could not register plugin directory `` +plugin dir , ex ) ; } }
public final string get line ( int line i ) { return line . get ( line i ) ; }
public string get text ( ) { return text ; }
public int compare to ( int . . . compare version ) { return compare to ( version . create ( compare version ) ) ; }
public static c char pointer holder to c string ( char sequence java string ) { return image singleton . lookup ( c type conversion support . class ) . to c string ( java string ) ; }
public static boolean to boolean ( pointer base pointer ) { return pointer . be non null ( ) ; }
public static void initialize at run time ( string . . . package ) { stack trace element [ ] stacktrace = thread . current thread ( ) . get stack trace ( ) ; for ( string a package : package ) { image singleton . lookup ( runtime class initialization support . class ) . initialize at run time ( a package , message + get caller ( stacktrace ) ) ; } }
public static void register for reflective instantiation ( class < ? > . . . class ) { for ( class < ? > clazz : class ) { if ( clazz . be array ( ) || clazz . be interface ( ) || modifier . be abstract ( clazz . get modifier ( ) ) ) { throw new illegal argument exception ( `` class `` + clazz . get type name ( ) + `` can not be instantiate reflectively . it must be a non-abstract instance type . `` ) ; } constructor < ? > nullary constructor ; try { nullary constructor = clazz . get declared constructor ( ) ; } catch ( no such method exception ex ) { throw new illegal argument exception ( `` class `` + clazz . get type name ( ) + `` can not be instantiate reflectively . it do not have a nullary constructor . `` ) ; } register ( nullary constructor ) ; } }
public static boolean in image buildtime code ( ) { return property_image_code_value_buildtime . equal ( system . get property ( property_image_code_key ) ) ; }
public static boolean contains ( class < ? > key ) { if ( ! image info . in image code ( ) ) { return false ; } return image singleton support . get ( ) . contains ( key ) ; }
public static long get process i d ( process process ) { return image singleton . lookup ( process property support . class ) . get process i d ( process ) ; }
public static boolean set argument vector program name ( string name ) { return image singleton . lookup ( process property support . class ) . set argument vector program name ( name ) ; }
public string get deprecation message ( ) { return deprecation message ; }
public boolean initialize ( string language id ) { return impl . initialize language ( language id ) ; }
public static builder new builder ( string . . . permitted language ) { return empty . new builder ( permitted language ) ; }
public void close ( boolean cancel if execute ) { impl . close ( this , cancel if execute ) ; }
public string get id ( ) { return impl . get id ( ) ; }
public < t > t lookup ( class < t > type ) { return impl . lookup ( type ) ; }
public boolean be interactive ( ) { return impl . be interactive ( ) ; }
public option descriptor get option ( ) { return impl . get option ( ) ; }
public boolean be root ( ) { return impl . be execution event root ( impl ) ; }
public void close ( ) { management . impl . close execution listener ( impl ) ; }
public boolean be internal error ( ) { return impl . be internal error ( ) ; }
public int get length ( ) { return get impl ( ) . get length ( impl ) ; }
public boolean have character ( ) { return get impl ( ) . have character ( impl ) ; }
public int get line length ( int line number ) throw illegal argument exception { return get impl ( ) . get line length ( impl , line number ) ; }
public static builder new builder ( string language , file file ) { return empty . new builder ( language , file ) ; }
public static string find mime type ( url url ) throw i o exception { return get impl ( ) . find mime type ( url ) ; }
public int get end line ( ) { return impl . get end line ( impl ) ; }
public int get char end index ( ) { return impl . get char end index ( impl ) ; }
public boolean remove array element ( long index ) { return impl . remove array element ( receiver , index ) ; }
public boolean be string ( ) { return impl . be string ( receiver ) ; }
public context get context ( ) { return impl . get context ( ) ; }
public void visit pre order ( query visitor visitor ) { visit impl ( visitor , true ) ; }
protect completable future < execution result > resolve field ( execution context execution context , execution strategy parameter parameter ) { return resolve field with info ( execution context , parameter ) . then compose ( field value info : : get field value ) ; }
public list < field > get field ( ) { return field ; }
public locale get locale ( ) { return locale ; }
public execution result execute ( execution input . builder execution input builder ) { return execute ( execution input builder . build ( ) ) ; }
public completable future < execution result > execute async ( execution input . builder execution input builder ) { return execute async ( execution input builder . build ( ) ) ; }
public static builder new context ( ) { return new builder ( ) ; }
public t get node ( ) { return node ; }
public static parser option get default parser option ( ) { return default jvm parser option ; }
public void assert valid name ( ) throw assert exception { if ( system coordinate ) { assert true ( ( null ! = field name ) & & field name . start with ( `` __ `` ) , ( ) - > `` only __ system field can be address without a parent type `` ) ; assert valid name ( field name ) ; } else { assert valid name ( type name ) ; assert valid name ( field name ) ; } }
public data fetcher < ? > get data fetcher ( graph q l field container parent type , graph q l field definition field definition ) { return get data fetcher impl ( field coordinate . coordinate ( parent type , field definition ) , field definition , data fetcher map , system data fetcher map , default data fetcher factory ) ; }
public graph q l enum type transform ( consumer < builder > builder consumer ) { builder builder = new enum ( this ) ; builder consumer . accept ( builder ) ; return builder . build ( ) ; }
public graph q l input object type transform ( consumer < builder > builder consumer ) { builder builder = new input object ( this ) ; builder consumer . accept ( builder ) ; return builder . build ( ) ; }
public list < graph q l directive > get directive ( string directive name ) { return directive . get directive ( directive name ) ; }
public list < graph q l directive > get schema directive ( ) { return schema directive . get directive ( ) ; }
public graph q l schema transform ( consumer < builder > builder consumer ) { builder builder = new schema ( this ) ; builder consumer . accept ( builder ) ; return builder . build ( ) ; }
public string print ( document schema i d l ) { type definition registry registry = new schema parser ( ) . build registry ( schema i d l ) ; return print ( un executable schema generator . make un executable schema ( registry ) ) ; }
public < t > t get object ( ) { return ( t ) object ; }
public static void set max validation error ( int max validation error ) { max_validation_errors = max validation error ; }
public static void set disable checksum ( boolean disable checksum ) { grape . disable checksum = disable checksum ; }
public void print ( object obj ) { print ( invoker helper . to string ( obj ) ) ; }
public string read line ( ) throw i o exception { string builder result = new string builder ( ) ; for ( ; ; ) { int int read = read ( ) ; if ( int read == -1 ) { return result . length ( ) == 0 ? null : result . to string ( ) ; } char c = ( char ) int read ; if ( c == '\n ' || c == '\r ' ) break ; result . append ( c ) ; } return result . to string ( ) ; }
public static void enable globally ( ) { default meta class info . set without custom metaclass creation handle ( false ) ; expando meta class creation handle . enable ( ) ; }
public boolean have meta method ( string name , class [ ] args ) { return super . pick method ( name , args ) ! = null ; }
public int get from int ( ) { return get from ( ) ; }
public object do method invoke ( object object , object [ ] argument array ) { argument array = coerce argument to class ( argument array ) ; try { return invoke ( object , argument array ) ; } catch ( exception e ) { throw process do method invoke exception ( e , object , argument array ) ; } }
public object invoke constructor ( final object [ ] argument ) { return do call ( the class , `` ctor `` , argument , interceptor , ( ) - > adaptee . invoke constructor ( argument ) ) ; }
public void set property ( final class a class , final object object , final string property , final object new value , final boolean use super , final boolean from inside class ) { if ( null == interceptor ) { super . set property ( a class , object , property , new value , use super , from inside class ) ; } if ( interceptor instanceof property access interceptor ) { property access interceptor pae = ( property access interceptor ) interceptor ; pae . before set ( object , property , new value ) ; if ( interceptor . do invoke ( ) ) { super . set property ( a class , object , property , new value , use super , from inside class ) ; } } else { super . set property ( a class , object , property , new value , use super , from inside class ) ; } }
protect void check collection type ( collection c ) { if ( type ! = null ) { for ( object element : c ) { check type ( element ) ; } } }
public static < t1 , t2 , t3 > tuple3 < t1 , t2 , t3 > tuple ( t1 v1 , t2 v2 , t3 v3 ) { return new tuple3 < > ( v1 , v2 , v3 ) ; }
public string get local part ( ) { return local part ; }
public string get qualify name ( ) { return ( ( prefix . equal ( empty_string ) ) ? local part : prefix + ' : ' + local part ) ; }
public static q name value of ( string s ) { if ( ( s == null ) || s . be empty ( ) ) { throw new illegal argument exception ( `` invalid q name literal `` ) ; } if ( s . char at ( 0 ) == ' { ' ) { int i = s . index of ( ' } ' ) ; if ( i == -1 ) { throw new illegal argument exception ( `` invalid q name literal `` ) ; } if ( i == s . length ( ) - 1 ) { throw new illegal argument exception ( `` invalid q name literal `` ) ; } else { return new q name ( s . substring ( 1 , i ) , s . substring ( i + 1 ) ) ; } } else { return new q name ( s ) ; } }
public static time zone get time zone ( date self ) { calendar calendar = calendar . get instance ( ) ; calendar . set time ( self ) ; return calendar . get time zone ( ) ; }
public static duration get daylight saving offset ( date self ) { time zone time zone = get time zone ( self ) ; int millis = ( time zone . use daylight time ( ) & & time zone . in daylight time ( self ) ) ? time zone . get d s t saving ( ) : 0 ; return new time duration ( 0 , 0 , 0 , millis ) ; }
public static class node pick generic type ( method node node , int parameter index , int gt index ) { final parameter [ ] parameter = node . get parameter ( ) ; final class node type = parameter [ parameter index ] . get origin type ( ) ; return pick generic type ( type , gt index ) ; }
public void set default charset ( charset default charset ) { if ( default charset ! = null ) this . default charset = default charset ; else this . default charset = get default system charset ( ) ; }
protect closure resolve explicit method ( string method name , object args ) { return get explicit method ( ) . get ( method name ) ; }
protected factory builder support get proxy builder ( ) { factory builder support proxy = local proxy builder . get ( ) ; if ( proxy == null ) { return global proxy builder ; } else { return proxy ; } }
protect void set proxy builder ( factory builder support proxy builder ) { global proxy builder = proxy builder ; }
protect void post instantiate ( object name , map attribute , object node ) { for ( closure post instantiate delegate : get proxy builder ( ) . get post instantiate delegate ( ) ) { ( post instantiate delegate ) . call ( this , attribute , node ) ; } }
public static object sum ( iterable item ) { return default groovy method . sum ( item ) ; }
public object clone ( ) { object new value = value ; if ( value instanceof node list ) { node list node = ( node list ) value ; new value = node . clone ( ) ; } return new node ( null , name , new hash map ( attribute ) , new value ) ; }
public boolean remove ( node child ) { child . set parent ( null ) ; return get parent list ( this ) . remove ( child ) ; }
public node parent ( ) { return parent ; }
public big decimal to big decimal ( ) { if ( text be empty or null ( ) ) { return null ; } return string groovy method . to big decimal ( ( char sequence ) text ( ) ) ; }
public string text ( ) { string previous text = null ; string builder buffer = null ; for ( object child : this ) { string text = null ; if ( child instanceof string ) { text = ( string ) child ; } else if ( child instanceof node ) { text = ( ( node ) child ) . text ( ) ; } if ( text ! = null ) { if ( previous text == null ) { previous text = text ; } else { if ( buffer == null ) { buffer = new string builder ( ) ; buffer . append ( previous text ) ; } buffer . append ( text ) ; } } } if ( buffer ! = null ) { return buffer . to string ( ) ; } if ( previous text ! = null ) { return previous text ; } return `` `` ; }
public static property node get static property ( class node c node , string prop name ) { class node class node = c node ; while ( class node ! = null ) { for ( property node pn : class node . get property ( ) ) { if ( pn . get name ( ) . equal ( prop name ) & & pn . be static ( ) ) return pn ; } class node = class node . get super class ( ) ; } return null ; }
public static boolean be empty ( final char sequence c ) { return c == null || c . length ( ) == 0 ; }
public long weighted size ( ) { return math . max ( 0 , weight size . get ( ) ) ; }
public void move to back ( e e ) { if ( e ! = last ) { unlink ( e ) ; link last ( e ) ; } }
public void set up ( ) { }
public boolean be synthetic public ( ) { return synthetic public ; }
public method node get declare method ( string name , parameter [ ] parameter ) { for ( method node method : get declare method ( name ) ) { if ( parameter equal ( method . get parameter ( ) , parameter ) ) { return method ; } } return null ; }
public boolean have possible static method ( string name , expression argument ) { return class node utils . have possible static method ( this , name , argument , false ) ; }
public void set use reference directly ( boolean use ref ) { this . use ref = use ref ; }
public static boolean be float ( class node type ) { return float_ t y p e == type ; }
public static boolean be big dec category ( class node type ) { return type== big decimal_ t y p e || be big int category ( type ) ; }
public static boolean implement interface or subclass of ( final class node source , final class node target type ) { if ( source . be derive from ( target type ) || source . implement interface ( target type ) ) return true ; if ( target type instanceof widen category . low upper bound class node ) { widen category . low upper bound class node lub = ( widen category . low upper bound class node ) target type ; if ( implement interface or subclass of ( source , lub . get super class ( ) ) ) return true ; for ( class node class node : lub . get interface ( ) ) { if ( source . implement interface ( class node ) ) return true ; } } return false ; }
public bytecode variable define variable ( final variable v , final boolean init from stack ) { return define variable ( v , v . get origin type ( ) , init from stack ) ; }
public void remove ( int amount ) { int size = stack . size ( ) ; for ( int i=size-1 ; i > size-1-amount ; i -- ) { pop with message ( i ) ; } }
protect boolean dequeued ( ) throw compilation fail exception { boolean dequeue = ! queued source . be empty ( ) ; while ( ! queue source . be empty ( ) ) { source unit unit = queue source . remove ( ) ; string name = unit . get name ( ) ; source . put ( name , unit ) ; } if ( dequeue ) { goto phase ( phase . initialization ) ; } return dequeue ; }
public print writer get output ( ) { return this . output ; }
public void set fatal ( boolean fatal ) { }
public void set token whitelist ( final list < integer > token whitelist ) { if ( tokens blacklist ! = null ) { throw new illegal argument exception ( `` you be not allow to set both whitelist and blacklist `` ) ; } this . token whitelist = token whitelist ; }
public void set receiver white list ( final list < string > receiver white list ) { if ( receiver black list ! = null ) { throw new illegal argument exception ( `` you be not allow to set both whitelist and blacklist `` ) ; } this . receiver white list = receiver white list ; }
public int get error count ( ) { return ( have error ( ) ? error . size ( ) : 0 ) ; }
public void write ( final print writer writer , final janitor janitor ) { write ( writer , janitor , warning , `` warn `` ) ; write ( writer , janitor , error , `` error `` ) ; }
public final void set configuration ( compiler configuration configuration ) { this . configuration = require non null ( configuration ) ; }
public static class get call class ( int match level ) { return get call class ( match level , collection . empty set ( ) ) ; }
public static int dimension ( class clazz ) { check array type ( clazz ) ; int result = 0 ; while ( clazz . be array ( ) ) { result++ ; clazz = clazz . get component type ( ) ; } return result ; }
public static char c array get ( char [ ] a , int i ) { try { return a [ i ] ; } catch ( throwable t ) { return a [ default groovy method support . normalise index ( i , a . length ) ] ; } }
public static boolean z array get ( boolean [ ] a , int i ) { try { return a [ i ] ; } catch ( throwable t ) { return a [ default groovy method support . normalise index ( i , a . length ) ] ; } }
public static void f array set ( float [ ] a , int i , float v ) { try { a [ i ] =v ; } catch ( throwable t ) { a [ default groovy method support . normalise index ( i , a . length ) ] =v ; } }
public object invoke ( final object proxy , method method , object [ ] args ) throw throwable { if ( handle cache ! = null & & be default method ( method ) & & ! default overridden ( method ) ) { final v m plugin plugin = v m plugin factory . get plugin ( ) ; object handle = handle cache . compute if absent ( method , m - > plugin . get invoke special handle ( m , proxy ) ) ; return plugin . invoke handle ( handle , args ) ; } if ( ! check method ( method ) ) { try { if ( method . get declare class ( ) == groovy object . class ) { if ( `` get meta class `` . equal ( method . get name ( ) ) ) { return get meta class ( proxy ) ; } else if ( `` set meta class `` . equal ( method . get name ( ) ) ) { return set meta class ( ( meta class ) args [ 0 ] ) ; } } return invoke custom ( proxy , method , args ) ; } catch ( groovy runtime exception gre ) { throw script bytecode adapter . unwrap ( gre ) ; } } try { return method . invoke ( this , args ) ; } catch ( invocation target exception ite ) { throw ite . get target exception ( ) ; } }
public string to string ( ) { return delegate . to string ( ) ; }
public static void sleep ( object self , long millisecond ) { sleep impl ( millisecond , null ) ; }
public static string to array string ( object [ ] argument ) { return to array string ( argument , false , -1 , false ) ; }
public static output stream leave shift ( output stream self , input stream in ) throw i o exception { byte [ ] buf = new byte [ default_buffer_size ] ; for ( int count ; -1 ! = ( count = in . read ( buf ) ) ; ) { self . write ( buf , 0 , count ) ; } self . flush ( ) ; return self ; }
public static object output stream new object output stream ( output stream output stream ) throw i o exception { return new object output stream ( output stream ) ; }
public static void set byte ( output stream o , byte [ ] bytes ) throw i o exception { try { o . write ( byte ) ; } finally { close with warning ( os ) ; } }
public static iterator < byte > iterator ( final data input stream self ) { return new iterator < byte > ( ) { byte next val ; boolean next must read = true ; boolean have next = true ; public boolean have next ( ) { if ( next must read & & have next ) { try { next val = self . read byte ( ) ; next must read = false ; } catch ( i o exception e ) { have next = false ; } } return have next ; } public byte next ( ) { byte retval = null ; if ( next must read ) { try { retval = self . read byte ( ) ; } catch ( i o exception e ) { have next = false ; } } else retval = next val ; next must read = true ; return retval ; } public void remove ( ) { throw new unsupported operation exception ( `` can not remove ( ) from a data input stream iterator `` ) ; } } ; }
public static buffer reader new reader ( input stream self ) { return new buffer reader ( new input stream reader ( self ) ) ; }
public static < t > t with reader ( input stream in , @ closure params ( value= simple type . class , options= `` java . io . reader `` ) closure < t > closure ) throw i o exception { return with reader ( new input stream reader ( in ) , closure ) ; }
public synchronize void touch ( final object key , final object value ) { remove ( key ) ; put ( key , value ) ; }
protect final entry [ ] get table for read ( ) { synchronize ( barrier lock ) { return table ; } }
protect boolean eq ( object x , object y ) { return x == y || x . equal ( y ) ; }
public set entry set ( ) { set es = entry set ; return ( es ! = null ) ? e : ( entry set = new entry set ( ) ) ; }
public static void set orig byte ( boolean v ) { orig byte = v ; orig byte re = without custom handle & & orig byte ; }
public static void set orig long ( boolean v ) { orig long = v ; orig long re = without custom handle & & orig long ; }
public static void set orig float ( boolean v ) { orig float = v ; orig float re = without custom handle & & orig float ; }
public meta class creation handle get meta class creation handler ( ) { return meta class creation handle ; }
public synchronize class define class ( string name , byte [ ] bytecode , protection domain domain ) { in define = true ; class c = define class ( name , bytecode , 0 , bytecode . length , domain ) ; load class . put ( name , c ) ; resolve class ( c ) ; in define = false ; return c ; }
public static string get property suggestion string ( string field name , class type ) { class info ci = class info . get class info ( type ) ; list < meta property > fi = ci . get meta class ( ) . get property ( ) ; list < rankable field > rf = new array list < rankable field > ( fi . size ( ) ) ; string builder sb = new string builder ( ) ; sb . append ( `` \n possible solution : `` ) ; for ( meta property mp : fi ) rf . add ( new rankable field ( field name , mp ) ) ; collection . sort ( rf ) ; int i = 0 ; for ( rankable field f : rf ) { if ( i > max_recomendations ) break ; if ( f . score > max_field_score ) break ; if ( i > 0 ) sb . append ( `` , `` ) ; sb . append ( f . f . get name ( ) ) ; i++ ; } return i > 0 ? sb . to string ( ) : `` `` ; }
public static object input stream new object input stream ( file file , final class loader class loader ) throw i o exception { return i o groovy method . new object input stream ( new file input stream ( file ) , class loader ) ; }
public static void append ( file file , reader reader , string charset ) throw i o exception { append ( file , reader , charset , false ) ; }
public static file a writable ( file file , string encode ) { return new writable file ( file , encode ) ; }
public static buffer writer new writer ( file file , string charset , boolean append , boolean write bom ) throw i o exception { boolean should write bom = write bom & & ! file . exists ( ) ; if ( append ) { file output stream stream = new file output stream ( file , append ) ; if ( should write bom ) { write u t f16 bom if require ( stream , charset ) ; } return new encode aware buffer writer ( new output stream writer ( stream , charset ) ) ; } else { file output stream stream = new file output stream ( file ) ; if ( should write bom ) { write u t f16 bom if require ( stream , charset ) ; } return new encode aware buffer writer ( new output stream writer ( stream , charset ) ) ; } }
public static void each byte ( file self , @ closure params ( value = simple type . class , option = `` byte `` ) closure closure ) throw i o exception { buffered input stream be = new input stream ( self ) ; i o groovy method . each byte ( be , closure ) ; }
public static void each byte ( url url , int buffer len , @ closure params ( value = from string . class , option = `` byte [ ] , integer `` ) closure closure ) throw i o exception { input stream be = url . open connection ( ) . get input stream ( ) ; i o groovy method . each byte ( be , buffer len , closure ) ; }
public static socket accept ( server socket server socket , final boolean run in a new thread , @ closure params ( value= simple type . class , options= `` java . net . socket `` ) final closure closure ) throw i o exception { final socket socket = server socket . accept ( ) ; if ( run in a new thread ) { new thread ( ( ) - > invoke closure with socket ( socket , closure ) ) . start ( ) ; } else { invoke closure with socket ( socket , closure ) ; } return socket ; }
public void write ( int c ) { buffer . append ( ( char ) c ) ; }
public int child ( ) { int size = size ( ) ; if ( size > 1 ) { return size - 1 ; } return 0 ; }
public c s t node get ( int index , boolean safe ) { c s t node element = get ( index ) ; if ( element == null & & safe ) { element = token . null ; } return element ; }
public static void main ( string [ ] args ) { command line compile with error handling ( args , true ) ; }
public boolean delete ( ) { return new file ( uri ) . delete ( ) ; }
public static void mark a process ( method node mn ) { mn . set node meta data ( null_check_is_processed , boolean . true ) ; }
public void push enclose binary expression ( binary expression binary expression ) { enclose binary expression . add first ( binary expression ) ; }
public list < binary expression > get enclose binary expression stack ( ) { return collection . unmodifiable list ( enclose binary expression ) ; }
public switch statement get enclose switch statement ( ) { if ( switch statement . be empty ( ) ) return null ; return switch statement . get first ( ) ; }
public list < switch statement > get enclose switch statement ( ) { return collection . unmodifiable list ( switch statement ) ; }
public class node pop enclose class node ( ) { return enclose class node . remove first ( ) ; }
public list < class node > get enclose class node ( ) { return collection . unmodifiable list ( enclose class node ) ; }
public list < expression > get enclose method call ( ) { return collection . unmodifiable list ( enclose method call ) ; }
public list < method node > handle ambiguous method ( final list < method node > node , final expression origin ) { return node ; }
public void store type ( final expression exp , final class node cn ) { type checking visitor . store type ( exp , cn ) ; }
public class node build map type ( class node key type , class node value type ) { return parameterized type ( class helper . map_type , key type , value type ) ; }
protect static boolean argument class be parameter class ( class < ? > argument class , class < ? > parameter class ) { if ( argument class == parameter class ) return true ; return get wrapper class ( parameter class ) == argument class ; }
public static method handle apply unsharp filter ( method handle handle , int po , method handle transformer ) { method type type = transformer . type ( ) ; class < ? > give = handle . type ( ) . parameter type ( po ) ; if ( type . return type ( ) ! = give || type . parameter type ( 0 ) ! = give ) { transformer = transformer . a type ( method type . method type ( give , type . parameter type ( 0 ) ) ) ; } return method handle . filter argument ( handle , po , transformer ) ; }
public static < t > optional < t > filter ( final optional < ? > self , final class < t > type ) { return self . filter ( type : : be instance ) . map ( type : : cast ) ; }
public static < t > set < t > to set ( final stream < t > self ) { return self . collect ( collector . to set ( ) ) ; }
public static map < string , set < string > > find ( uri classpath entry u r i , string package name ) { return find ( classpath entry u r i , package name , false ) ; }
protect void write char sequence ( char sequence seq , char buf buffer ) { if ( seq . length ( ) > 0 ) { buffer . add json escape string ( seq . to string ( ) , disable unicode escape ) ; } else { buffer . add char ( empty_string_chars ) ; } }
protect void write date ( date date , char buf buffer ) { simple date format formatter = new simple date format ( date format , date locale ) ; formatter . set time zone ( timezone ) ; buffer . add quote ( formatter . format ( date ) ) ; }
protect converter find converter ( class < ? > type ) { for ( converter c : converter ) { if ( c . handle ( type ) ) { return c ; } } return null ; }
protected boolean should exclude type ( class < ? > type ) { for ( class < ? > t : excluded field type ) { if ( t . be assignable from ( type ) ) { return true ; } } return false ; }
public object call ( closure c ) { content = json delegate . clone delegate and get content ( c ) ; return content ; }
public boolean be chop ( ) { return chop ; }
public final object get ( object key ) { object object = null ; / * if the map be null , then we create it . * / if ( map == null ) { build map ( ) ; } object = map . get ( key ) ; lazy chop if need ( object ) ; return object ; }
public object plus ( final object new value ) { this . replace node ( new closure ( this ) { public void do call ( object [ ] args ) { final groovy object delegate = ( groovy object ) get delegate ( ) ; delegate . get property ( `` mkp `` ) ; delegate . invoke method ( `` yield `` , args ) ; delegate . get property ( `` mkp `` ) ; delegate . invoke method ( `` yield `` , new object [ ] { new value } ) ; } } ) ; return this ; }
public boolean to boolean ( ) { return string groovy method . to boolean ( text ( ) ) ; }
public writer write to ( final writer out ) throw i o exception { return out ; }
public void add child ( final object child ) { this . child . add ( child ) ; }
public iterator child node ( ) { return new iterator ( ) { private final iterator iter = node . this . child . iterator ( ) ; private object next element node = get next element node ( ) ; public boolean have next ( ) { return this . next element node ! = null ; } public object next ( ) { try { return this . next element node ; } finally { this . next element node = get next element node ( ) ; } } public void remove ( ) { throw new unsupported operation exception ( ) ; } private object get next element node ( ) { while ( iter . have next ( ) ) { final object node = iter . next ( ) ; if ( node instanceof node ) { return node ; } } return null ; } } ; }
public boolean be keep ignorable whitespace ( ) { return keep ignorable whitespace ; }
public static synchronize void set global keep ignorable whitespace ( boolean keep ignorable whitespace ) { d o m category . keep ignorable whitespace = keep ignorable whitespace ; }
public static document parse ( reader reader ) throw s a x exception , i o exception , parser configuration exception { return parse ( reader , false , true ) ; }
public void set omit empty attribute ( boolean omit empty attribute ) { this . omit empty attribute = omit empty attribute ; }
public q name get ( string local name ) { if ( uri ! = null & & uri . length ( ) > 0 ) { if ( prefix ! = null ) { return new q name ( uri , local name , prefix ) ; } else { return new q name ( uri , local name ) ; } } else { return new q name ( local name ) ; } }
public static s a x parser new s a x parser ( string schema language , file schema ) throw s a x exception , parser configuration exception { return new s a x parser ( schema language , true , false , schema ) ; }
public json element to json tree ( object src ) { if ( src == null ) { return json null . instance ; } return to json tree ( src , src . get class ( ) ) ; }
public gson builder generate non executable json ( ) { this . generate non executable json = true ; return this ; }
public gson builder exclude field without expose annotation ( ) { excluder = excluder . exclude field without expose annotation ( ) ; return this ; }
public gson builder set field naming policy ( field naming policy name convention ) { this . field name policy = name convention ; return this ; }
public void add ( number number ) { element . add ( number == null ? json null . instance : new json primitive ( number ) ) ; }
public boolean get a boolean ( ) { if ( element . size ( ) == 1 ) { return element . get ( 0 ) . get a boolean ( ) ; } throw new illegal state exception ( ) ; }
public double get a double ( ) { throw new unsupported operation exception ( get class ( ) . get simple name ( ) ) ; }
public json array get a json array ( string member name ) { return ( json array ) member . get ( member name ) ; }
public boolean be assignable from ( class < ? > cl ) { return be assignable from ( ( type ) cl ) ; }
public boolean be empty ( ) { return element . be empty ( ) ; }
public static boolean equal ( @ nullable object a , @ nullable object b ) { return a == b || ( a ! = null & & a . equal ( b ) ) ; }
public string to string ( ) { return a map ( ) . to string ( ) ; }
public class < v > value type ( ) { return value type ; }
public immutable multiset < k > key ( ) { return ( immutable multiset < k > ) super . key ( ) ; }
public immutable sort set < k > key set ( ) { return key set ; }
public static < e > immutable sort set < e > of ( ) { return ( immutable sort set < e > ) natural_empty_set ; }
public static < e extend comparable < ? super e > > immutable sort set < e > of ( e e1 , e e2 ) { return construct ( order . natural ( ) , 2 , e1 , e2 ) ; }
public static < e > immutable sort set < e > copy of ( e [ ] element ) { throw new unsupported operation exception ( ) ; }
public static < b > list < list < b > > cartesian product ( list < ? extend list < ? extend b > > list ) { return cartesian list . create ( list ) ; }
public e remove last ( ) { if ( be empty ( ) ) { throw new no such element exception ( ) ; } return remove and get ( get max element index ( ) ) ; }
public e peek last ( ) { return be empty ( ) ? null : element data ( get max element index ( ) ) ; }
public static < t > order < t > explicit ( t least value , t . . . remain value in order ) { return explicit ( list . a list ( least value , remain value in order ) ) ; }
public static < e > queue < e > synchronize queue ( queue < e > queue ) { return synchronize . queue ( queue , null ) ; }
public static < e > tree multiset < e > create ( @ nullable comparator < ? super e > comparator ) { return ( comparator == null ) ? new tree multiset < e > ( ( comparator ) ordering . natural ( ) ) : new tree multiset < e > ( comparator ) ; }
protect final int next escape index ( char sequence csq , int index , int end ) { while ( index < end ) { char c = csq . char at ( index ) ; if ( ( c < replacement length & & replacement [ c ] ! = null ) || c > safe max char || c < safe min char ) { break ; } index++ ; } return index ; }
protect final char [ ] escape ( int cp ) { if ( cp < replacement length ) { char [ ] char = replacement [ cp ] ; if ( char ! = null ) { return char ; } } if ( cp > = safe min & & cp < = safe max ) { return null ; } return escape unsafe ( cp ) ; }
public char escaper builder add escape ( char c , string r ) { map . put ( c , check not null ( r ) ) ; if ( c > max ) { max = c ; } return this ; }
public object get source ( ) { return source ; }
public static hash function md5 ( ) { return md5 holder . md5 ; }
public static hash code combine unordered ( iterable < hash code > hash code ) { iterator < hash code > iterator = hash code . iterator ( ) ; check argument ( iterator . have next ( ) , `` must be at least 1 hash code to combine . `` ) ; byte [ ] result byte = new byte [ iterator . next ( ) . bit ( ) / 8 ] ; for ( hash code hash code : hash code ) { byte [ ] next byte = hash code . a byte ( ) ; check argument ( next byte . length == result byte . length , `` all hashcodes must have the same bit length . `` ) ; for ( int i = 0 ; i < next byte . length ; i++ ) { result bytes [ i ] += next byte [ i ] ; } } return hash code . from bytes no copy ( result byte ) ; }
public int read ( ) throw i o exception { int b = in . read ( ) ; if ( b ! = -1 ) { hasher . put byte ( ( byte ) b ) ; } return b ; }
public static base encode base16 ( ) { return base16 ; }
public static int read ( input stream in , byte [ ] b , int off , int len ) throw i o exception { check not null ( in ) ; check not null ( b ) ; if ( len < 0 ) { throw new index out of bound exception ( `` len be negative `` ) ; } int total = 0 ; while ( total < len ) { int result = in . read ( b , off + total , len - total ) ; if ( result == -1 ) { break ; } total += result ; } return total ; }
public immutable list < string > read line ( ) throw i o exception { closer closer = closer . create ( ) ; try { buffered reader reader = closer . register ( open buffer stream ( ) ) ; list < string > result = list . new array list ( ) ; string line ; while ( ( line = reader . read line ( ) ) ! = null ) { result . add ( line ) ; } return immutable list . copy of ( result ) ; } catch ( throwable e ) { throw close . rethrow ( e ) ; } finally { closer . close ( ) ; } }
public static buffer reader new reader ( file file , charset charset ) throw file not find exception { check not null ( file ) ; check not null ( charset ) ; return new buffer reader ( new input stream reader ( new file input stream ( file ) , charset ) ) ; }
public static file create temp dir ( ) { file base dir = new file ( system . get property ( `` java . io . tmpdir `` ) ) ; string base name = system . current time millis ( ) + `` - `` ; for ( int counter = 0 ; counter < temp_dir_attempts ; counter++ ) { file temp dir = new file ( base dir , base name + counter ) ; if ( temp dir . mkdir ( ) ) { return temp dir ; } } throw new illegal state exception ( `` fail to create directory within `` + temp_dir_attempts + `` attempt ( try `` + base name + `` 0 to `` + base name + ( temp_dir_attempts - 1 ) + ' ) ' ) ; }
public static byte [ ] to byte array ( url url ) throw i o exception { return a byte source ( url ) . read ( ) ; }
public static host and port from part ( string host , int port ) { check argument ( be valid port ( port ) , `` port out of range : % s `` , port ) ; host and port parse host = from string ( host ) ; check argument ( ! parse host . have port ( ) , `` host have a port : % s `` , host ) ; return new host and port ( parsed host . host , port , parse host . have bracketless colon ) ; }
public static inet address decrement ( inet address address ) { byte [ ] addr = address . get address ( ) ; int i = addr . length - 1 ; while ( i > = 0 & & addr [ i ] == ( byte ) 0x00 ) { addr [ i ] = ( byte ) 0xff ; i -- ; } precondition . check argument ( i > = 0 , `` decrementing % s would wrap . `` , address ) ; addr [ i ] -- ; return byte to inet address ( addr ) ; }
public immutable list < string > part ( ) { return part ; }
public boolean be top private domain ( ) { return public suffix index == 1 ; }
public static boolean be valid ( string name ) { try { from ( name ) ; return true ; } catch ( illegal argument exception e ) { return false ; } }
public immutable set < class info > get top level class ( ) { return fluent iterable . from ( resource ) . filter ( class info . class ) . filter ( is_top_level ) . to set ( ) ; }
public final type set get type ( ) { return new type set ( ) ; }
public final double get and set ( double new value ) { long next = double to raw long bit ( new value ) ; return long bit to double ( updater . get and set ( this , next ) ) ; }
public boolean enter if interruptibly ( guard guard ) throw interrupted exception { if ( guard . monitor ! = this ) { throw new illegal monitor state exception ( ) ; } final reentrant lock lock = this . lock ; lock . lock interruptibly ( ) ; boolean satisfy = false ; try { return satisfied = guard . be satisfied ( ) ; } finally { if ( ! satisfy ) { lock . unlock ( ) ; } } }
public void wait for uninterruptibly ( guard guard ) { if ( ! ( ( guard . monitor == this ) & lock . be hold by current thread ( ) ) ) { throw new illegal monitor state exception ( ) ; } if ( ! guard . be satisfied ( ) ) { await uninterruptibly ( guard , true ) ; } }
public static < e > fluent iterable < e > of ( ) { return fluent iterable . from ( immutable list . < e > of ( ) ) ; }
public boolean be compatible ( bloom filter < t > that ) { check not null ( that ) ; return ( this ! = that ) & & ( this . num hash function == that . num hash function ) & & ( this . bit size ( ) == that . bit size ( ) ) & & ( this . strategy . equal ( that . strategy ) ) & & ( this . funnel . equal ( that . funnel ) ) ; }
public static hash function hmac sha256 ( key key ) { return new mac hash function ( `` hmac s h a256 `` , key , hmac to string ( `` hmac sha256 `` , key ) ) ; }
public static base encode base32 ( ) { return base32 ; }
public static long copy ( input stream from , output stream to ) throw i o exception { check not null ( from ) ; check not null ( to ) ; byte [ ] buf = create buffer ( ) ; long total = 0 ; while ( true ) { int r = from . read ( buf ) ; if ( r == -1 ) { break ; } to . write ( buf , 0 , r ) ; total += r ; } return total ; }
public byte [ ] to byte array ( ) { byte buffer buffer = byte buffer . allocate ( byte ) . order ( byte order . little_endian ) ; x stats . write to ( buffer ) ; y stats . write to ( buffer ) ; buffer . put double ( sum of product of delta ) ; return buffer . array ( ) ; }
public static scale and index median ( ) { return scale ( 2 ) . index ( 1 ) ; }
public static scale percentile ( ) { return scale ( 100 ) ; }
public static < t > iterable < t > concat ( iterable < ? extend t > . . . input ) { return fluent iterable . concat ( input ) ; }
public boolean be compatible ( bloom filter < t > that ) { check not null ( that ) ; return ( this ! = that ) & & ( this . num hash function == that . num hash function ) & & ( this . bit size ( ) == that . bit size ( ) ) & & ( this . strategy . equal ( that . strategy ) ) & & ( this . funnel . equal ( that . funnel ) ) ; }
public void put all ( bloom filter < t > that ) { check not null ( that ) ; check argument ( this ! = that , `` can not combine a bloom filter with itself . `` ) ; check argument ( this . num hash function == that . num hash function , `` bloom filter must have the same number of hash function ( % s ! = % s ) `` , this . num hash function , that . num hash function ) ; check argument ( this . bit size ( ) == that . bit size ( ) , `` bloom filter must have the same size underlie bit array ( % s ! = % s ) `` , this . bit size ( ) , that . bit size ( ) ) ; check argument ( this . strategy . equal ( that . strategy ) , `` bloom filter must have equal strategy ( % s ! = % s ) `` , this . strategy , that . strategy ) ; check argument ( this . funnel . equal ( that . funnel ) , `` bloom filter must have equal funnel ( % s ! = % s ) `` , this . funnel , that . funnel ) ; this . bit . put all ( that . bit ) ; }
public medium type without parameter ( ) { return parameter . be empty ( ) ? this : create ( type , subtype ) ; }
public immutable double array sub array ( int start index , int end index ) { precondition . check position index ( start index , end index , length ( ) ) ; return start index == end index ? empty : new immutable double array ( array , start + start index , start + end index ) ; }
protect string pending to string ( ) { object local value = value ; if ( local value instanceof set future ) { return `` set future= [ `` + ( ( set future ) local value ) . future + `` ] `` ; } else if ( this instanceof schedule future ) { return `` remain delay= [ `` + ( ( schedule future ) this ) . get delay ( time unit . millisecond ) + `` ms ] `` ; } return null ; }
public sort set < v > get ( @ nullable k key ) { return ( sort set < v > ) super . get ( key ) ; }
public static < t > iterable < list < t > > pad partition ( final iterable < t > iterable , final int size ) { check not null ( iterable ) ; check argument ( size > 0 ) ; return new fluent iterable < list < t > > ( ) { @ override public iterator < list < t > > iterator ( ) { return iterators . pad partition ( iterable . iterator ( ) , size ) ; } } ; }
public static < t > iterator < t > concat ( iterator < ? extend t > a , iterator < ? extend t > b , iterator < ? extend t > c ) { check not null ( a ) ; check not null ( b ) ; check not null ( c ) ; return concat ( consume for array ( a , b , c ) ) ; }
public static < t > unmodifiable iterator < list < t > > partition ( iterator < t > iterator , int size ) { return partition impl ( iterator , size , false ) ; }
public collection < v > value ( ) { return super . value ( ) ; }
public static < e > multiset . entry < e > immutable entry ( @ nullable e e , int n ) { return new immutable entry < e > ( e , n ) ; }
public static byte [ ] to byte array ( input stream in ) throw i o exception { check not null ( in ) ; return to byte array internal ( in , new array deque < byte [ ] > ( to_byte_array_deque_size ) , 0 ) ; }
public final @ nullable e [ ] to array ( class < e > type ) { return iterables . to array ( get delegate ( ) , type ) ; }
public configuration exception with partial value ( object partial value ) { check state ( this . partial value == null , `` ca n't clobber exist partial value % s with % s `` , this . partial value , partial value ) ; configuration exception result = new configuration exception ( message ) ; result . partial value = partial value ; return result ; }
public string get source ( ) { return source ; }
public static matcher < annotate element > annotate with ( final class < ? extend annotation > annotation type ) { return new annotate with type ( annotation type ) ; }
public static matcher < method > return ( final matcher < ? super class < ? > > return type ) { return new return ( return type ) ; }
public link bind builder < v > add binding ( k key ) { return delegate . add bind ( key ) ; }
public static set < dependency < ? > > for injection point ( set < injection point > injection point ) { list < dependency < ? > > dependencies = list . new array list ( ) ; for ( injection point injection point : injection point ) { dependency . add all ( injection point . get dependency ( ) ) ; } return immutable set . copy of ( dependency ) ; }
public static annotation [ ] get annotation ( field field ) { annotation [ ] java annotation = field . get annotation ( ) ; annotation [ ] kotlin annotation = kotlin support . get instance ( ) . get annotation ( field ) ; if ( kotlin annotation . length == 0 ) { return java annotation ; } return object array . concat ( java annotation , kotlin annotation , annotation . class ) ; }
public t get instance ( ) { return instance ; }
public matcher < ? super type literal < ? > > get type matcher ( ) { return type matcher ; }
public static module require exact binding annotation module ( ) { return new require exact binding annotation module ( ) ; }
public hash set < db table or view > get table ( ) { return table ; }
public string get query ( ) { return query ; }
public void set ref table name ( schema ref schema , string ref ) { this . ref schema = ref schema ; this . ref table name = ref ; }
public void set java class method ( string method ) { this . java class method = string utils . replace all ( method , `` `` , `` `` ) ; }
public table parse table name ( string sql ) { parameter = new . array list ( ) ; initialize ( sql ) ; read ( ) ; return read table or view ( ) ; }
protect static string get s q l ( value [ ] value ) { statement builder buff = new statement builder ( ) ; for ( value v : value ) { buff . append except first ( `` , `` ) ; if ( v ! = null ) { buff . append ( v . get s q l ( ) ) ; } } return buff . to string ( ) ; }
public static string get script directory ( ) { return utils . get property ( h2_script_directory , `` `` ) ; }
public void set update action ( int action ) { if ( action == update action & & update s q l == null ) { return ; } if ( update action ! = restrict ) { throw db exception . get ( error code . constraint_already_exists_1 , `` on update `` ) ; } this . update action = action ; build update s q l ( ) ; }
public void set index ( index index , boolean be owner ) { this . index = index ; this . index owner = be owner ; }
public void set server key ( string server key ) { remote = true ; persistent = false ; this . name = server key ; }
public java method find java method ( expression [ ] args ) { load ( ) ; int parameter count = args . length ; for ( java method m : java method ) { int count = m . get parameter count ( ) ; if ( count == parameter count || ( m . be var args ( ) & & count < = parameter count + 1 ) ) { return m ; } } throw db exception . get ( error code . method_not_found_1 , method name + `` ( `` + class name + `` , parameter count : `` + parameter count + `` ) `` ) ; }
public void rollback ( ) { check commit rollback ( ) ; if ( transaction ! = null ) { set < string > change = transaction . get change map ( 0 ) ; for ( m v table t : database . get mv store ( ) . get table ( ) ) { if ( change . contains ( t . get map name ( ) ) ) { t . set modify ( ) ; } } transaction . rollback ( ) ; transaction = null ; } current transaction name = null ; boolean need commit = false ; if ( undo log . size ( ) > 0 ) { rollback to ( null , false ) ; need commit = true ; } if ( lock . size ( ) > 0 || need commit ) { database . commit ( this ) ; } clean temp table ( false ) ; unlock all ( ) ; if ( auto commit at transaction end ) { auto commit = true ; auto commit at transaction end = false ; } }
public void remove server ( i o exception e , int i , int count ) { trace . debug ( e , `` remove server because of exception `` ) ; transfer list . remove ( i ) ; if ( transfer list . size ( ) == 0 & & auto reconnect ( count ) ) { return ; } check closed ( ) ; switch off cluster ( ) ; }
public void trace operation ( string operation , int id ) { if ( trace . be debug enable ( ) ) { trace . debug ( `` { 0 } { 1 } `` , operation , id ) ; } }
protect boolean get ( string key , boolean default value ) { string s = get ( key , `` `` + default value ) ; try { return boolean . parse boolean ( s ) ; } catch ( number format exception e ) { throw db exception . get ( error code . data_conversion_error_1 , e , `` key : `` + key + `` value : `` + s ) ; } }
public boolean be value set ( ) { return false ; }
public string get column name ( ) { return get alias ( ) ; }
public static expression visitor get dependency visitor ( hash set < db object > dependency ) { return new expression visitor ( get_dependencies , 0 , dependency , null , null , null , null ) ; }
public long get max data modification id ( ) { return max data modification id [ 0 ] ; }
public table get table ( ) { return table ; }
protect void add index info ( index info index ) { index . put ( index . id , index ) ; }
public static index type create scan ( boolean persistent ) { index type type = new index type ( ) ; type . persistent = persistent ; type . scan = true ; return type ; }
public int get memory ( ) { return ( constant . memory_page_data_overflow + store . get page size ( ) ) > > 2 ; }
public input stream get binary stream ( long po , long length ) throw s q l exception { throw unsupported ( `` lob update `` ) ; }
public byte get byte ( int parameter index ) throw s q l exception { check register ( parameter index ) ; return get open result set ( ) . get byte ( parameter index ) ; }
public date get date ( int parameter index ) throw s q l exception { check register ( parameter index ) ; return get open result set ( ) . get date ( parameter index ) ; }
public time get time ( int parameter index ) throw s q l exception { check register ( parameter index ) ; return get open result set ( ) . get time ( parameter index ) ; }
public row id get row id ( int parameter index ) throw s q l exception { throw unsupported ( `` row id `` ) ; }
public sqlxml get s q l x m l ( int parameter index ) throw s q l exception { throw unsupported ( `` sqlxml `` ) ; }
public void set character stream ( string parameter name , reader x , int length ) throw s q l exception { set character stream ( get index for name ( parameter name ) , x , length ) ; }
public void set object ( string parameter name , object x ) throw s q l exception { set object ( get index for name ( parameter name ) , x ) ; }
public output stream set ascii stream ( long po ) throw s q l exception { throw unsupported ( `` lob update `` ) ; }
public int set string ( long po , string str , int offset , int len ) throw s q l exception { throw unsupported ( `` lob update `` ) ; }
public boolean all procedure be callable ( ) { debug code call ( `` all procedure be callable `` ) ; return true ; }
public boolean support convert ( int from type , int to type ) { if ( be debug enabled ( ) ) { debug code ( `` support convert ( `` +from type+ `` , `` +from type+ `` ) ; `` ) ; } return true ; }
public boolean support different table correlation name ( ) { debug code call ( `` support different table correlation name `` ) ; return false ; }
public boolean support group by beyond select ( ) { debug code call ( `` support group by beyond select `` ) ; return true ; }
public boolean support outer join ( ) { debug code call ( `` support outer join `` ) ; return true ; }
public boolean be catalog at start ( ) { debug code call ( `` be catalog at start `` ) ; return true ; }
public boolean support schemas in procedure call ( ) { debug code call ( `` support schema in procedure call `` ) ; return true ; }
public boolean support position update ( ) { debug code call ( `` support position update `` ) ; return true ; }
public boolean support open statement across commit ( ) { debug code call ( `` support open statement across commit `` ) ; return true ; }
public boolean do max row size include blob ( ) { debug code call ( `` do max row size include blob `` ) ; return false ; }
public int get max column name length ( ) { debug code call ( `` get max column name length `` ) ; return 0 ; }
public int get max procedure name length ( ) { debug code call ( `` get max procedure name length `` ) ; return 0 ; }
public string to string ( ) { if ( stack trace == null ) { return super . to string ( ) ; } return stack trace ; }
public void set log writer ( print writer out ) { debug code call ( `` set log writer ( out ) `` ) ; log writer = out ; }
public string get user ( ) { debug code call ( `` get user `` ) ; return user name ; }
public void set user ( string user ) { debug code call ( `` set user `` , user ) ; this . user name = user ; }
public void rollback ( xid xid ) throw x a exception { if ( be debug enabled ( ) ) { debug code ( `` rollback ( `` + jdbc xid . to string ( xid ) + `` ) ; `` ) ; } try { physical conn . rollback ( ) ; physical conn . set auto commit ( true ) ; if ( prepared ) { statement stat = null ; try { stat = physical conn . create statement ( ) ; stat . execute ( `` rollback transaction `` + jdbc xid . to string ( xid ) ) ; } finally { jdbc utils . close silently ( stat ) ; } prepare = false ; } } catch ( s q l exception e ) { throw convert exception ( e ) ; } current transaction = null ; }
public void start ( xid xid , int flag ) throw x a exception { if ( be debug enabled ( ) ) { debug code ( `` start ( `` + jdbc xid . to string ( xid ) + `` , `` +quote flag ( flag ) + `` ) ; `` ) ; } if ( flags == tmresume ) { return ; } if ( flags == tmjoin ) { if ( current transaction ! = null & & ! current transaction . equal ( xid ) ) { throw new x a exception ( x a exception . xaer_rmerr ) ; } } else if ( current transaction ! = null ) { throw new x a exception ( x a exception . xaer_nota ) ; } try { physical conn . set auto commit ( false ) ; } catch ( s q l exception e ) { throw convert exception ( e ) ; } current transaction = xid ; prepare = false ; }
public db exception add s q l ( string sql ) { s q l exception e = get s q l exception ( ) ; if ( e instanceof jdbc s q l exception ) { jdbc s q l exception j = ( jdbc s q l exception ) e ; if ( j . get s q l ( ) == null ) { j . set s q l ( sql ) ; } return this ; } e = new jdbc s q l exception ( e . get message ( ) , sql , e . get s q l state ( ) , e . get error code ( ) , e , null ) ; return new db exception ( e ) ; }
public static db exception get invalid value exception ( string param , object value ) { return get ( error code . invalid_value_2 , value == null ? `` null `` : value . to string ( ) , param ) ; }
public void set level ( int level ) { this . trace level = level ; }
public boolean be debug enabled ( ) { return be enable ( trace system . debug ) ; }
public void info ( string s ) { if ( be enable ( trace system . info ) ) { trace writer . write ( trace system . info , module , s , null ) ; } }
protect static int get next id ( int type ) { return id [ type ] ++ ; }
protect static string quote byte ( byte [ ] x ) { if ( x == null ) { return `` null `` ; } return `` org . h2 . util . string utils . convert hex to byte ( \ `` `` + string utils . convert byte to hex ( x ) + `` \ `` ) `` ; }
protect s q l exception log and convert ( exception ex ) { s q l exception e = db exception . to s q l exception ( ex ) ; if ( trace == null ) { trace system . trace throwable ( e ) ; } else { int error code = e . get error code ( ) ; if ( error code > = 23000 & & error code < 24000 ) { trace . info ( e , `` exception `` ) ; } else { trace . error ( e , `` exception `` ) ; } } return e ; }
public void set max memory ( long max memory ) { data utils . check argument ( max memory > 0 , `` max memory must be large than 0 , be { 0 } `` , max memory ) ; this . max memory = max memory ; if ( segment ! = null ) { long max = 1 + max memory / segment . length ; for ( segment < v > s : segment ) { s . set max memory ( max ) ; } } }
public synchronize set < long > key set ( ) { hash set < long > set = new hash set < long > ( ) ; for ( segment < v > s : segment ) { set . add all ( s . key set ( ) ) ; } return set ; }
public static void write var long ( byte buffer buff , long x ) { while ( ( x & ~0x7f ) ! = 0 ) { buff . put ( ( byte ) ( 0x80 | ( x & 0x7f ) ) ) ; x > > > = 7 ; } buff . put ( ( byte ) x ) ; }
public static int get page type ( long po ) { return ( ( int ) po ) & 1 ; }
public k last key ( ) { return get first last ( false ) ; }
public k ceiling key ( k key ) { return get min max ( key , false , false ) ; }
public void remove map ( ) { check open ( ) ; if ( this == store . get meta map ( ) ) { return ; } before write ( ) ; try { root . remove all recursive ( ) ; store . remove map ( id ) ; close ( ) ; } finally { after write ( ) ; } }
public string get name ( ) { return store . get map name ( id ) ; }
protect void before write ( ) { if ( read only ) { check open ( ) ; throw data utils . new unsupported operation exception ( `` this map be read-only `` ) ; } check concurrent write ( ) ; store . before write ( ) ; write = true ; }
public static m v store open ( string file name ) { hash map < string , object > config = new . hash map ( ) ; config . put ( `` file name `` , file name ) ; m v store s = new m v store ( config ) ; s . open ( ) ; return s ; }
public void set page size ( int page size ) { this . page size = page size ; }
public int get store version ( ) { check open ( ) ; string x = meta . get ( `` setting . store version `` ) ; return x == null ? 0 : integer . parse int ( x ) ; }
public static < v > m v r tree map < v > create ( int dimension , data type value type ) { return new m v r tree map < v > ( dimension , value type ) ; }
public float max ( int dim ) { return min max [ dim + dim + 1 ] ; }
public void set random access ( ) { this . random access = true ; }
public boolean be updatable ( ) { return be updatable ; }
public void insert row ( value [ ] row ) throw s q l exception { statement builder buff = new statement builder ( `` insert into `` ) ; append table name ( buff ) ; buff . append ( ' ( ' ) ; append column list ( buff , false ) ; buff . append ( `` ) value ( `` ) ; buff . reset count ( ) ; for ( int i = 0 ; i < column count ; i++ ) { buff . append except first ( `` , `` ) ; value v = row [ i ] ; if ( v == null ) { buff . append ( `` default `` ) ; } else { buff . append ( ' ? ' ) ; } } buff . append ( ' ) ' ) ; prepare statement prep = conn . prepare statement ( buff . to string ( ) ) ; for ( int i = 0 , j = 0 ; i < column count ; i++ ) { value v = row [ i ] ; if ( v ! = null ) { v . set ( prep , j++ + 1 ) ; } } int count = prep . execute update ( ) ; if ( count ! = 1 ) { throw db exception . get ( error code . no_data_available ) ; } }
public void add ( schema object obj ) { if ( sys property . check & & obj . get schema ( ) ! = this ) { db exception . throw internal error ( `` wrong schema `` ) ; } string name = obj . get name ( ) ; hash map < string , schema object > map = get map ( obj . get type ( ) ) ; if ( sys property . check & & map . get ( name ) ! = null ) { db exception . throw internal error ( `` object already exist : `` + name ) ; } map . put ( name , obj ) ; free unique name ( name ) ; }
public index find index ( session session , string name ) { index index = index . get ( name ) ; if ( index == null ) { index = session . find local temp table index ( name ) ; } return index ; }
public trigger object find trigger ( string name ) { return trigger . get ( name ) ; }
public index get index ( string name ) { index index = index . get ( name ) ; if ( index == null ) { throw db exception . get ( error code . index_not_found_1 , name ) ; } return index ; }
public sequence get sequence ( string sequence name ) { sequence sequence = sequence . get ( sequence name ) ; if ( sequence == null ) { throw db exception . get ( error code . sequence_not_found_1 , sequence name ) ; } return sequence ; }
public array list < schema object > get all ( int type ) { hash map < string , schema object > map = get map ( type ) ; return new . array list ( map . value ( ) ) ; }
public void set trigger class name ( string trigger class name , boolean force ) { this . trigger class name = trigger class name ; try { load ( ) ; } catch ( db exception e ) { if ( ! force ) { throw e ; } } }
public void close ( ) throw s q l exception { if ( trigger callback ! = null ) { trigger callback . close ( ) ; } }
public static byte [ ] get h m a c ( byte [ ] key , byte [ ] message ) { key = normalize key for h m a c ( key ) ; int len = message . length ; int byte len = 64 + math . max ( 32 , len ) ; int int len = get int count ( byte len ) ; byte [ ] byte buff = new byte [ int len * 4 ] ; int [ ] int buff = new int [ int len ] ; sha256 sha = new sha256 ( ) ; byte [ ] i key = new byte [ 64 + len ] ; byte [ ] o key = new byte [ 64 + 32 ] ; sha . calculate h m a c ( key , message , len , i key , o key , byte buff , int buff ) ; return sha . result ; }
public static byte [ ] get hash ( byte [ ] data , boolean null data ) { int len = data . length ; int int len = get int count ( len ) ; byte [ ] byte buff = new byte [ int len * 4 ] ; int [ ] int buff = new int [ int len ] ; sha256 sha = new sha256 ( ) ; sha . calculate hash ( data , len , byte buff , int buff ) ; if ( null data ) { sha . fill with null ( ) ; array . fill ( int buff , 0 ) ; array . fill ( byte buff , ( byte ) 0 ) ; array . fill ( data , ( byte ) 0 ) ; } return sha . result ; }
protect string admin shutdown ( ) { server . shutdown ( ) ; return `` admin . jsp `` ; }
public static void try unlock database ( list < string > file , string message ) throw s q l exception { for ( string file name : file ) { if ( file name . end with ( constant . suffix_lock_file ) ) { file lock lock = new file lock ( new trace system ( null ) , file name , constant . lock_sleep ) ; try { lock . lock ( file lock . lock_file ) ; lock . unlock ( ) ; } catch ( db exception e ) { throw db exception . get ( error code . cannot_change_setting_when_open_1 , message ) . get s q l exception ( ) ; } } } }
public static string get dir ( string dir ) { if ( dir == null || dir . equal ( `` `` ) ) { return `` . `` ; } return file utils . to real path ( dir ) ; }
public static file store open ( data handler handler , string name , string mode , string cipher , byte [ ] key ) { return open ( handler , name , mode , cipher , key , constant . encryption_key_hash_iterations ) ; }
public void close and delete silently ( ) { if ( file ! = null ) { close silently ( ) ; handler . get temp file deleter ( ) . delete file ( auto delete reference , name ) ; name = null ; } }
public void sync ( ) { try { file . force ( true ) ; } catch ( i o exception e ) { close file silently ( ) ; throw db exception . convert i o exception ( e , name ) ; } }
public static void unregister ( file path provider ) { register default provider ( ) ; provider . remove ( provider . get scheme ( ) ) ; }
public static long last modify ( string file name ) { return file path . get ( file name ) . last modified ( ) ; }
public static output stream new output stream ( string file name , boolean append ) throw i o exception { return file path . get ( file name ) . new output stream ( append ) ; }
public static void read fully ( file channel channel , byte buffer dst ) throw i o exception { do { int r = channel . read ( dst ) ; if ( r < 0 ) { throw new e o f exception ( ) ; } } while ( dst . remain ( ) > 0 ) ; }
public static synchronize void init ( string recover test ) { recover tester tester = recover tester . get instance ( ) ; if ( string utils . be number ( recover test ) ) { tester . set test every ( integer . parse int ( recover test ) ) ; } file path rec . set recorder ( tester ) ; }
public final void remove sequence ( sequence sequence ) { remove ( sequence , sequence ) ; }
public void add view ( table view view ) { view = add ( view , view ) ; }
public boolean fire row ( ) { return ( constraint ! = null & & constraint . size ( ) > 0 ) || ( trigger ! = null & & trigger . size ( ) > 0 ) ; }
public void fire after row ( session session , row old row , row new row , boolean rollback ) { fire row ( session , old row , new row , false , rollback ) ; if ( ! rollback ) { fire constraint ( session , old row , new row , false ) ; } }
public void check writing allow ( ) { database . check write allow ( ) ; }
protect void set null row ( ) { state = null_row ; current = table . get null row ( ) ; current search row = current ; if ( nested join ! = null ) { nested join . visit ( new table filter visitor ( ) { @ override public void accept ( table filter f ) { f . set null row ( ) ; } } ) ; } }
public column [ ] get system column ( ) { if ( ! session . get database ( ) . get mode ( ) . system column ) { return null ; } column [ ] sys = new column [ 3 ] ; sys [ 0 ] = new column ( `` oid `` , value . int ) ; sys [ 0 ] . set table ( table , 0 ) ; sys [ 1 ] = new column ( `` ctid `` , value . string ) ; sys [ 1 ] . set table ( table , 0 ) ; sys [ 2 ] = new column ( `` ctid `` , value . string ) ; sys [ 2 ] . set table ( table , 0 ) ; return sys ; }
public boolean be invalid ( ) { return create exception ! = null ; }
public static void execute ( string zip file name , string directory , string db , boolean quiet ) throw s q l exception { try { new backup ( ) . process ( zip file name , directory , db , quiet ) ; } catch ( exception e ) { throw db exception . to s q l exception ( e ) ; } }
public string get field separator write ( ) { return field separator write ; }
public void set row separator write ( string row separator write ) { this . row separator write = row separator write ; }
public char get field delimiter ( ) { return field delimiter ; }
public string get line separator ( ) { return line separator ; }
public boolean get write column header ( ) { return write column header ; }
public int get max value ( int dimension ) { if ( dimension < 2 || dimension > 32 ) { throw new illegal argument exception ( `` `` + dimension ) ; } int bit per value = get bit per value ( dimension ) ; return ( int ) ( ( 1l < < bits per value ) - 1 ) ; }
public long interleave ( int x , int y ) { if ( x < 0 ) { throw new illegal argument exception ( 0 + `` < `` + x ) ; } if ( y < 0 ) { throw new illegal argument exception ( 0 + `` < `` + y ) ; } long z = 0 ; for ( int i = 0 ; i < 32 ; i++ ) { z |= ( x & ( 1l < < i ) ) < < i ; z |= ( y & ( 1l < < i ) ) < < ( i + 1 ) ; } return z ; }
public static server create tcp server ( string . . . args ) throw s q l exception { tcp server service = new tcp server ( ) ; server server = new server ( service , args ) ; service . set shutdown handler ( server ) ; return server ; }
public static server create pg server ( string . . . args ) throw s q l exception { return new server ( new pg server ( ) , args ) ; }
public server start ( ) throw s q l exception { try { started = true ; service . start ( ) ; string name = service . get name ( ) + `` ( `` + service . get u r l ( ) + `` ) `` ; thread t = new thread ( this , name ) ; t . set daemon ( service . be daemon ( ) ) ; t . start ( ) ; for ( int i = 1 ; i < 64 ; i += i ) { wait ( i ) ; if ( be run ( false ) ) { return this ; } } if ( be run ( true ) ) { return this ; } throw db exception . get ( error code . exception_opening_port_2 , name , `` timeout ; `` + `` please check your network configuration , specially the file /etc/hosts `` ) ; } catch ( db exception e ) { throw db exception . to s q l exception ( e ) ; } }
public void set ( int i ) { int addr = i > > address_bits ; check capacity ( addr ) ; data [ addr ] |= get bit mask ( i ) ; if ( max length < i ) { max length = i ; } }
public static date convert date ( value value , calendar calendar ) { if ( value == value null . instance ) { return null ; } value date d = ( value date ) value . convert to ( value . date ) ; calendar cal = ( calendar ) calendar . clone ( ) ; cal . clear ( ) ; cal . set lenient ( true ) ; long date value = d . get date value ( ) ; set calendar field ( cal , year from date value ( date value ) , month from date value ( date value ) , day from date value ( date value ) , 0 , 0 , 0 , 0 ) ; long m = cal . get time in millis ( ) ; return new date ( m ) ; }
public static value time convert time ( time x , calendar calendar ) { if ( calendar == null ) { throw db exception . get invalid value exception ( `` calendar `` , null ) ; } calendar cal = ( calendar ) calendar . clone ( ) ; cal . set time in millis ( x . get time ( ) ) ; long nanos = nanos from calendar ( cal ) ; return value time . from nanos ( nanos ) ; }
public static int get date part ( java . util . date d , int field ) { calendar c = get calendar ( ) ; synchronize ( c ) { c . set time ( d ) ; if ( field == calendar . year ) { return get year ( c ) ; } int value = c . get ( field ) ; if ( field == calendar . month ) { return value + 1 ; } return value ; } }
public static string format date time ( java . util . date date , string format , string locale , string time zone ) { simple date format date format = get date format ( format , locale , time zone ) ; synchronize ( date format ) { return date format . format ( date ) ; } }
public static long date value ( long year , int month , int day ) { return ( year < < shift_year ) | ( month < < shift_month ) | day ; }
public static int round up int ( int x , int block size power of2 ) { return ( x + block size power of2 - 1 ) & ( -block size power of2 ) ; }
public static int secure random int ( int low than ) { secure random sr = get secure random ( ) ; synchronize ( sr ) { return sr . next int ( low than ) ; } }
public static < t > hash set < t > hash set ( ) { return new hash set < t > ( ) ; }
public boolean next ( ) { if ( ! have next ) { return false ; } for ( int i = 0 ; i < m ; i++ ) { out [ i ] = in [ index [ i ] ] ; } move index ( ) ; return true ; }
public boolean be block remark ( ) { return block remark ; }
public statement builder append ( string s ) { builder . append ( s ) ; return this ; }
public statement builder append ( long x ) { builder . append ( x ) ; return this ; }
protect void print no database file find ( string dir , string db ) { string builder buff ; dir = file lister . get dir ( dir ) ; if ( ! file utils . be directory ( dir ) ) { buff = new string builder ( `` directory not find : `` ) ; buff . append ( dir ) ; } else { buff = new string builder ( `` no database file have be find `` ) ; buff . append ( `` in directory `` ) . append ( dir ) ; if ( db ! = null ) { buff . append ( `` for the database `` ) . append ( db ) ; } } out . println ( buff . to string ( ) ) ; }
public static void write long ( byte [ ] buff , int po , long x ) { write int ( buff , po , ( int ) ( x > > 32 ) ) ; write int ( buff , po + 4 , ( int ) x ) ; }
public static int compare not null sign ( byte [ ] data1 , byte [ ] data2 ) { if ( data1 == data2 ) { return 0 ; } int len = math . min ( data1 . length , data2 . length ) ; for ( int i = 0 ; i < len ; i++ ) { byte b = data1 [ i ] ; byte b2 = data2 [ i ] ; if ( b ! = b2 ) { return b > b2 ? 1 : -1 ; } } return integer . signum ( data1 . length - data2 . length ) ; }
public static boolean be class present ( string fully qualified class name ) { try { class . for name ( fully qualify class name ) ; return true ; } catch ( class not find exception e ) { return false ; } }
public static string get property ( string key , string default value ) { try { return system . get property ( key , default value ) ; } catch ( security exception se ) { return default value ; } }
public static < t > value hash map < t > new instance ( ) { return new value hash map < t > ( ) ; }
public static string get name ( locale l ) { locale english = locale . english ; string name = l . get display language ( english ) + ' ' + l . get display country ( english ) + ' ' + l . get variant ( ) ; name = string utils . to upper english ( name . trim ( ) . replace ( ' ' , ' _ ' ) ) ; return name ; }
public static void reset dir counter ( ) { dir counter = 0 ; }
public value convert to ( int t ) { if ( t == type ) { return this ; } else if ( t == value . clob ) { value lob copy = value lob . create clob ( get reader ( ) , -1 , handler ) ; return copy ; } else if ( t == value . blob ) { value lob copy = value lob . create blob ( get input stream ( ) , -1 , handler ) ; return copy ; } return super . convert to ( t ) ; }
public byte [ ] get small ( ) { return small ; }
public static value time from nanos ( long nanos ) { return ( value time ) value . cache ( new value time ( nanos ) ) ; }
public static < t > matcher < t [ ] > have item in array ( t element ) { return have item in array ( equal to ( element ) ) ; }
public static < e > matcher < e [ ] > array contain in any order ( collection < matcher < ? super e > > item matcher ) { return new array a iterable matcher < > ( new be iterable contain in any order < > ( item matcher ) , item matcher , `` in any order `` ) ; }
protect string description start ( ) { return `` [ `` ; }
public static < t > matcher < t > be in ( t [ ] element ) { return in ( element ) ; }
public static matcher < object > anything ( string description ) { return new be anything < > ( description ) ; }
public static matcher < object > not null value ( ) { return not ( null value ( ) ) ; }
public static < t > matcher < t > not null value ( class < t > type ) { return not ( null value ( type ) ) ; }
public static matcher < string > match regex ( string regex ) { return string regular expression . match regex ( pattern . compile ( regex ) ) ; }
public static int last index of letter ( string string ) { for ( int i=0 ; i < string . length ( ) ; i++ ) { char character = string . char at ( i ) ; if ( ! character . be letter ( character ) & & ! ( ' _'==character ) ) return i-1 ; } return string . length ( ) -1 ; }
public jaxb cfg cache usage enum get usage ( ) { return usage ; }
public void set file ( string value ) { this . file = value ; }
public string get cascade ( ) { return cascade ; }
public void set id type ( string value ) { this . id type = value ; }
public void set index ( string value ) { this . index = value ; }
public boolean be optimistic lock ( ) { if ( optimistic lock == null ) { return true ; } else { return optimistic lock ; } }
public jaxb hbm cache type get cache ( ) { return cache ; }
public void set element ( jaxb hbm basic collection element type value ) { this . element = value ; }
public void set loader ( jaxb hbm loader type value ) { this . loader = value ; }
public void set check ( string value ) { this . check = value ; }
public boolean be embed xml ( ) { return embed xml ; }
public string get schema ( ) { return schema ; }
public void set schema ( string value ) { this . schema = value ; }
public void set catalog ( string value ) { this . catalog = value ; }
public string get subselect attribute ( ) { return subselect attribute ; }
public string get column attribute ( ) { return column attribute ; }
public void set length ( integer value ) { this . length = value ; }
public void set unique ( boolean value ) { this . unique = value ; }
public jaxb hbm generator specification type get generator ( ) { return generator ; }
public string get proxy ( ) { return proxy ; }
public void set proxy ( string value ) { this . proxy = value ; }
public boolean be dynamic update ( ) { if ( dynamic update == null ) { return false ; } else { return dynamic update ; } }
public string get formula ( ) { return formula ; }
public void set formula ( string value ) { this . formula = value ; }
public string get condition ( ) { return condition ; }
public string get parameter name ( ) { return parameter name ; }
public list < jaxb hbm filter definition type > get filter def ( ) { if ( filter def == null ) { filter def = new array list < jaxb hbm filter definition type > ( ) ; } return this . filter def ; }
public void set auto import ( boolean value ) { this . auto import = value ; }
public string get default access ( ) { if ( default access == null ) { return `` property `` ; } else { return default access ; } }
public boolean be default lazy ( ) { if ( default lazy == null ) { return true ; } else { return default lazy ; } }
public string get query ref ( ) { return query ref ; }
public jaxb hbm map key many to many type get map key many to many ( ) { return map key many to many ; }
public string get cache region ( ) { return cache region ; }
public boolean be cacheable ( ) { if ( cacheable == null ) { return false ; } else { return cacheable ; } }
public void set fetch size ( integer value ) { this . fetch size = value ; }
public flush mode get flush mode ( ) { return flush mode ; }
public void set timestamp ( jaxb hbm timestamp attribute type value ) { this . timestamp = value ; }
public void set multi tenancy ( jaxb hbm multi tenancy type value ) { this . multi tenancy = value ; }
public entity mode get entity mode ( ) { return entity mode ; }
public void set entity mode ( entity mode value ) { this . entity mode = value ; }
public metadata builder get metadata builder ( ) { metadata builder impl default builder = new metadata builder impl ( this ) ; return get custom builder or default ( default builder ) ; }
public metadata source add annotated class name ( string annotate class name ) { if ( annotated class name == null ) { annotated class name = new link hash set < > ( ) ; } annotate class name . add ( annotated class name ) ; return this ; }
public boolean be inherently single column ( ) { return inherently single column ; }
public synchronize byte [ ] enhance ( string class name , byte [ ] original byte ) throw enhancement exception { ct class manage ct class = null ; try { manage ct class = class pool . make class if new ( new byte array input stream ( original byte ) ) ; return enhance ( manage ct class ) ? get byte code ( manage ct class ) : null ; } catch ( i o exception e ) { log . unable to build enhancement metamodel ( class name ) ; return null ; } finally { if ( manage ct class ! = null ) { manage ct class . detach ( ) ; } } }
public int get attribute index ( ) { return attribute index ; }
public class get java class ( ) { return this . type ; }
protect metadata build context get context ( ) { return context ; }
public configuration add cacheable file ( string xml file ) throw map exception { metadata source . add cacheable file ( xml file ) ; return this ; }
public void set entity not find delegate ( entity not find delegate entity not find delegate ) { this . entity not find delegate = entity not find delegate ; }
public string logical column name ( string column name , string property name ) { return string helper . be not empty ( column name ) ? column name : string helper . unqualify ( property name ) ; }
public static property get property ( ) { property copy = new property ( ) ; copy . put all ( global_properties ) ; return copy ; }
protect final void write ( ) { initialize ( true ) ; dirty ( ) ; }
public final share session contract implementor get session ( ) { return session ; }
public int occurrence ( object o ) { read ( ) ; final iterator itr = bag . iterator ( ) ; int result = 0 ; while ( itr . have next ( ) ) { if ( o . equal ( itr . next ( ) ) ) { result++ ; } } return result ; }
public static boolean have bind ( session factory factory ) { return exist session ( factory ) ! = null ; }
public static session bind ( session session ) { return session map ( true ) . put ( session . get session factory ( ) , session ) ; }
public static detach criterion for entity name ( string entity name ) { return new detach criterion ( entity name ) ; }
public static detach criterion for class ( class clazz ) { return new detach criterion ( clazz . get name ( ) ) ; }
public detach criterion add order ( order order ) { criterion . add order ( order ) ; return this ; }
public detach criterion create criterion ( string association path , string alias , join type join type , criterion with clause ) { return new detach criterion ( impl , criterion . create criterion ( association path , alias , join type , with clause ) ) ; }
public count projection count ( ) { return projection . count ( get property name ( ) ) ; }
public criterion lt ( detach criterion subselect ) { return subqueries . property lt ( get property name ( ) , subselect ) ; }
public static criterion id eq ( object value ) { return new identifier eq expression ( value ) ; }
public static logical expression and ( criterion lh , criterion rh ) { return new logical expression ( lhs , rhs , `` and `` ) ; }
public static conjunction and ( criterion . . . predicate ) { return conjunction ( predicate ) ; }
public static criterion sql restriction ( string sql , object value , type type ) { return new s q l criterion ( sql , value , type ) ; }
public static conjunction conjunction ( ) { return new conjunction ( ) ; }
public simple expression ignore case ( ) { ignore case = true ; return this ; }
public static criterion property le all ( string property name , detach criterion dc ) { return new property subquery expression ( property name , `` < = `` , `` all `` , dc ) ; }
public static criterion property lt some ( string property name , detach criterion dc ) { return new property subquery expression ( property name , `` < `` , `` some `` , dc ) ; }
public static criterion property eq ( string [ ] property name , detach criterion dc ) { return new property subquery expression ( property name , `` = `` , dc ) ; }
public static criterion gt ( object value , detach criterion dc ) { return new simple subquery expression ( value , `` > `` , null , dc ) ; }
public string render ( list args , session factory implementor factory ) { final int number of argument = args . size ( ) ; if ( get anticipate number of argument ( ) > 0 & & number of argument ! = get anticipate number of argument ( ) ) { log . miss argument ( get anticipate number of argument ( ) , number of argument ) ; } final string builder buf = new string builder ( ) ; for ( int i = 0 ; i < chunk . length ; ++i ) { if ( i < param index . length ) { final int index = param index [ i ] - 1 ; final object arg = index < number of argument ? args . get ( index ) : null ; if ( arg ! = null ) { buf . append ( chunks [ i ] ) . append ( arg ) ; } } else { buf . append ( chunks [ i ] ) ; } } return buf . to string ( ) ; }
public boolean support row value constructor syntax in in list ( ) { return true ; }
public boolean bind limit parameter in reverse order ( ) { return false ; }
public int convert to first row value ( int zero base first result ) { return zero base first result ; }
public string get no column insert string ( ) { return `` value ( default ) `` ; }
public string get ( final int type code ) throw map exception { final integer integer = integer . value of ( type code ) ; final string result = default . get ( integer ) ; if ( result == null ) { throw new map exception ( `` no dialect map for jdbc type : `` + type code ) ; } return result ; }
public void put ( int type code , string value ) { final integer integer = integer . value of ( type code ) ; default . put ( integer , value ) ; }
public boolean same a cache ( entity persister persister , serializable pk , object [ ] natural id value ) { final natural id resolution cache entity natural id resolution cache = natural id resolution cache map . get ( persister ) ; return entity natural id resolution cache ! = null & & entity natural id resolution cache . same a cache ( pk , natural id value ) ; }
public void un stash invalid natural id reference ( ) { for ( natural id resolution cache natural id resolution cache : natural id resolution cache map . value ( ) ) { natural id resolution cache . un stash invalid natural id reference ( ) ; } }
public void clear ( ) { natural id resolution cache map . clear ( ) ; }
public boolean be empty ( ) { return property path by transient entity == null || property path by transient entity . be empty ( ) ; }
public void resolve non nullable transient entity ( object entity ) { if ( property path by transient entity ! = null & & property path by transient entity . remove ( entity ) == null ) { throw new illegal state exception ( `` attempt to resolve a non-nullable , transient entity that be not a dependency . `` ) ; } }
public static boolean be log enable ( ) { return log . be info enable ( ) ; }
public property get connection property ( ) { return new property ( connection prop ) ; }
public static link hash set < type info > extract type info ( database meta data meta data ) { final link hash set < type info > type info set = new link hash set < type info > ( ) ; try { final result set result set = meta data . get type info ( ) ; try { while ( result set . next ( ) ) { type info set . add ( new type info ( result set . get string ( `` type_name `` ) , result set . get int ( `` data_type `` ) , interpret create params ( result set . get string ( `` create_params `` ) ) , result set . get boolean ( `` unsigned_attribute `` ) , result set . get int ( `` precision `` ) , result set . get short ( `` minimum_scale `` ) , result set . get short ( `` maximum_scale `` ) , result set . get boolean ( `` fixed_prec_scale `` ) , result set . get string ( `` literal_prefix `` ) , result set . get string ( `` literal_suffix `` ) , result set . get boolean ( `` case_sensitive `` ) , type searchability . interpret ( result set . get short ( `` searchable `` ) ) , type nullability . interpret ( result set . get short ( `` nullable `` ) ) ) ) ; } } catch ( s q l exception e ) { log . unable to access type info result set ( e . to string ( ) ) ; } finally { try { result set . close ( ) ; } catch ( s q l exception e ) { log . unable to release type info result set ( ) ; } } } catch ( s q l exception e ) { log . unable to retrieve type info result set ( e . to string ( ) ) ; } return type info set ; }
public void add action ( entity identity insert action action ) { log . tracev ( `` add an entity identity insert action for [ { 0 } ] object `` , action . get entity name ( ) ) ; add insert action ( action ) ; }
public void add action ( collection recreate action action ) { add action ( collection recreate action . class , action ) ; }
public void remove batch loadable entity key ( entity key key ) { if ( batch loadable entity key ! = null & & key . be batch loadable ( ) ) { link hash set < entity key > set = batch loadable entity key . get ( key . get entity name ( ) ) ; if ( set ! = null ) { set . remove ( key ) ; } } }
public static cascade style get cascade style ( string cascade ) { cascade style style = style . get ( cascade ) ; if ( style == null ) { throw new map exception ( `` unsupported cascade style : `` + cascade ) ; } else { return style ; } }
protect serializable resolve natural id ( final resolve natural id event event ) { final entity persister persister = event . get entity persister ( ) ; if ( log . be trace enable ( ) ) { log . tracev ( `` attempt to resolve : { 0 } # { 1 } `` , message helper . info string ( persister ) , event . get natural id value ( ) ) ; } serializable entity id = resolve from cache ( event ) ; if ( entity id ! = null ) { if ( log . be trace enable ( ) ) { log . tracev ( `` resolve object in cache : { 0 } # { 1 } `` , message helper . info string ( persister ) , event . get natural id value ( ) ) ; } return entity id ; } if ( log . be trace enable ( ) ) { log . tracev ( `` object not resolve in any cache : { 0 } # { 1 } `` , message helper . info string ( persister ) , event . get natural id value ( ) ) ; } return load from datasource ( event ) ; }
public boolean contains key ( object merge entity ) { if ( merge entity == null ) { throw new null pointer exception ( `` null entity be not support by `` + get class ( ) . get name ( ) ) ; } return merge to manage entity xref . contains key ( merge entity ) ; }
public boolean contain value ( object manage entity ) { if ( manage entity == null ) { throw new null pointer exception ( `` null copy be not support by `` + get class ( ) . get name ( ) ) ; } return manage to merge entity xref . contains key ( manage entity ) ; }
public void put all ( map map ) { for ( object o : map . entry set ( ) ) { entry entry = ( entry ) o ; put ( entry . get key ( ) , entry . get value ( ) ) ; } }
public type [ ] get return type ( ) { error if d m l ( ) ; return get walker ( ) . get return type ( ) ; }
public into clause get into clause ( ) { return ( into clause ) get first child ( ) ; }
public void add order fragment ( string order by fragment ) { ast fragment = a s t util . create ( get a s t factory ( ) , sql_token , order by fragment ) ; if ( get first child ( ) == null ) { set first child ( fragment ) ; } else { add child ( fragment ) ; } }
public ast append ( ast child ) { if ( last == null ) { parent . set first child ( child ) ; } else { last . set next sibling ( child ) ; } last = child ; return last ; }
public static ast parse path ( string path , a s t factory factory ) { string [ ] identifier = string helper . split ( `` . `` , path ) ; ast lhs = null ; for ( int i = 0 ; i < identifier . length ; i++ ) { string identifier = identifier [ i ] ; ast child = a s t util . create ( factory , hql sql token type . ident , identifier ) ; if ( i == 0 ) { lhs = child ; } else { lhs = a s t util . create binary subtree ( factory , hql sql token type . dot , `` . `` , lh , child ) ; } } if ( log . be debug enable ( ) ) { log . debugf ( `` parse path ( ) : % s - > % s `` , path , a s t util . get debug string ( lhs ) ) ; } return lhs ; }
public queryable find queryable use import ( string class name ) { return find queryable use import ( sfi , class name ) ; }
public s q l function find s q l function ( string function name ) { return sfi . get sql function registry ( ) . find s q l function ( function name ) ; }
public type find function return type ( string function name , ast first ) { s q l function sql function = require s q l function ( function name ) ; return find function return type ( function name , sql function , first ) ; }
public final type get identifier type ( ) { return identifier type ; }
public static short get count short ( ) { synchronize ( helper . class ) { if ( counter < 0 ) { counter = 0 ; } return counter++ ; } }
protect final object get final ( int col , type return type ) throw hibernate exception { if ( close ) { throw new illegal state exception ( `` scrollable result be closed `` ) ; } if ( holder instantiator ! = null ) { throw new hibernate exception ( `` query specify a holder class `` ) ; } if ( return type . get returned class ( ) == type [ col ] . get returned class ( ) ) { return get ( col ) ; } else { return throw invalid column type exception ( col , type [ col ] , return type ) ; } }
public object get parameter ( string name ) { return parameter . get ( name ) ; }
public static string extract property value ( string property name , property property ) { string value = property . get property ( property name ) ; if ( value == null ) { return null ; } value = value . trim ( ) ; if ( value . be empty ( ) ) { return null ; } return value ; }
public static map to map ( string property name , string delim , property property ) { map map = new hash map ( ) ; string value = extract property value ( property name , property ) ; if ( value ! = null ) { string tokenizer token = new string tokenizer ( value , delim ) ; while ( token . have more token ( ) ) { map . put ( token . next token ( ) , token . have more element ( ) ? token . next token ( ) : `` `` ) ; } } return map ; }
public static int extract error code ( s q l exception sql exception ) { int error code = sql exception . get error code ( ) ; s q l exception nest = sql exception . get next exception ( ) ; while ( error code == 0 & & nested ! = null ) { error code = nest . get error code ( ) ; nest = nest . get next exception ( ) ; } return error code ; }
public static boolean implement interface ( class clazz , class intf ) { assert intf . be interface ( ) : `` interface to check be not an interface `` ; return intf . be assignable from ( clazz ) ; }
public static < t > constructor < t > get default constructor ( class < t > clazz ) throw property not find exception { if ( be abstract class ( clazz ) ) { return null ; } try { constructor < t > constructor = clazz . get declared constructor ( no_param_signature ) ; ensure accessibility ( constructor ) ; return constructor ; } catch ( no such method exception nme ) { throw new property not find exception ( `` object class [ `` + clazz . get name ( ) + `` ] must declare a default ( no-argument ) constructor `` ) ; } }
public static class loader default class loader ( ) { return thread . current thread ( ) . get context class loader ( ) ; }
public static boolean be quote ( final string name , final dialect dialect ) { if ( name == null || name . be empty ( ) ) { return false ; } final char first = name . char at ( 0 ) ; final char last = name . char at ( name . length ( ) - 1 ) ; return ( ( first == last ) & & ( first == ' ` ' || first == ' `` ' ) ) || ( first == dialect . open quote ( ) & & last == dialect . close quote ( ) ) ; }
public string get suffixed identifier alias ( ) { return identifier alias ; }
protect boolean be duplicate association ( final string foreign key table , final string [ ] foreign key column ) { association key association key = new association key ( foreign key column , foreign key table ) ; return ! visit association key . add ( association key ) ; }
protect int [ ] get collection owner ( ) { return null ; }
protect boolean be result set row transform immediately ( ) { return false ; }
public lock mode get lock mode ( ) { return lock mode ; }
public int get time out ( ) { return timeout ; }
public lock option set time out ( int timeout ) { this . timeout = timeout ; return this ; }
public boolean get scope ( ) { return scope ; }
public lock option make copy ( ) { final lock option copy = new lock option ( ) ; copy ( this , copy ) ; return copy ; }
public string get name ( ) { return name ; }
public list get reference column ( ) { return reference column ; }
public void set identifier ( key value identifier ) { this . identifier = identifier ; }
public boolean be property define in hierarchy ( string name ) { if ( have property ( name ) ) { return true ; } if ( get super map superclass ( ) ! = null & & get super map superclass ( ) . be property define in hierarchy ( name ) ) { return true ; } if ( get superclass ( ) ! = null & & get superclass ( ) . be property define in hierarchy ( name ) ) { return true ; } return false ; }
public iterator get unjoined property iterator ( ) { return property . iterator ( ) ; }
protect string generate delete row string ( ) { final delete delete = create delete ( ) . set table name ( qualify table name ) ; if ( have identifier ) { delete . add primary key column ( new string [ ] { identifier column name } ) ; } else if ( have index & & ! index contain formula ) { delete . add primary key column ( array helper . join ( key column name , index column name ) ) ; } else { delete . add primary key column ( key column name ) ; delete . add primary key column ( element column name , element column be in primary key , element column writer ) ; } if ( get factory ( ) . get session factory option ( ) . be comment enable ( ) ) { delete . set comment ( `` delete collection row `` + get role ( ) ) ; } return delete . to statement string ( ) ; }
public string [ ] to columns ( string property name ) throw query exception , unsupported operation exception { throw new unsupported operation exception ( `` reference to collection must be define a sql alias `` ) ; }
protect unique entity loader create entity loader ( lock mode lock mode ) throw map exception { return create entity loader ( lock mode , load query influencers . none ) ; }
public static string info string ( string entity name , string property name , object key ) { string builder s = new string builder ( ) . append ( ' [ ' ) . append ( entity name ) . append ( ' . ' ) . append ( property name ) . append ( ' # ' ) ; if ( key == null ) { s . append ( `` < null > `` ) ; } else { s . append ( key ) ; } s . append ( ' ] ' ) ; return s . to string ( ) ; }
protect string get session factory uuid ( ) { return session factory uuid ; }
protect void set alias ( string alias ) { this . alias = alias ; }
protect boolean apply lock timeout hint ( int timeout ) { get lock option ( ) . set time out ( timeout ) ; return true ; }
protect boolean apply follow on lock hint ( boolean follow on lock ) { get lock option ( ) . set follow on locking ( follow on lock ) ; return true ; }
public string [ ] key a array ( ) { return map . key set ( ) . to array ( new string [ 0 ] ) ; }
public schema export set import file ( string import file ) { this . import file = import file ; return this ; }
public schema export set format ( boolean format ) { this . format = format ; return this ; }
public schema export set halt on error ( boolean halt on error ) { this . halt on error = halt on error ; return this ; }
public list get exception ( ) { return exception ; }
public void set quiet ( boolean quiet ) { this . quiet = quiet ; }
public boolean equal ( object other ) { return other instanceof alias to bean constructor result transformer & & constructor . equal ( ( ( alias to bean constructor result transformer ) other ) . constructor ) ; }
public component tuplizer construct tuplizer ( class < ? extend component tuplizer > tuplizer class , component metadata ) { constructor < ? extend component tuplizer > constructor = get proper constructor ( tuplizer class ) ; assert constructor ! = null : `` unable to locate proper constructor for tuplizer [ `` + tuplizer class . get name ( ) + `` ] `` ; try { return constructor . new instance ( metadata ) ; } catch ( throwable t ) { throw new hibernate exception ( `` unable to instantiate default tuplizer [ `` + tuplizer class . get name ( ) + `` ] `` , t ) ; } }
public static input stream sub stream ( input stream input stream , long start , int length ) { return new binary stream impl ( extract byte ( input stream , start , length ) ) ; }
public final boolean be entity type ( ) { return true ; }
public static string get version string ( ) { return version ; }
public void set reify ( boolean reify ) { try { w lock . lock ( ) ; be reify = reify ; } finally { w lock . unlock ( ) ; } }
public boolean remove qualifier annotation ( annotation remove me ) { try { w lock . lock ( ) ; if ( remove me == null ) return false ; if ( qualifier == null ) return false ; boolean ret val = qualifier . remove ( remove me ) ; remove qualifier ( remove me . annotation type ( ) . get name ( ) ) ; return ret val ; } finally { w lock . unlock ( ) ; } }
public static indexed filter create contract filter ( string contract ) { return new indexed filter impl ( contract , null ) ; }
public static indexed filter create specific descriptor filter ( descriptor descriptor ) { string contract = service locator utility . get best contract ( descriptor ) ; string name = descriptor . get name ( ) ; if ( descriptor . get service id ( ) == null ) { throw new illegal argument exception ( `` the descriptor must have a specific service id `` ) ; } if ( descriptor . get locator id ( ) == null ) { throw new illegal argument exception ( `` the descriptor must have a specific locator id `` ) ; } return new specific filter impl ( contract , name , descriptor . get service id ( ) , descriptor . get locator id ( ) ) ; }
public list < input stream > find descriptor file ( ) throw i o exception { identifier . clear ( ) ; array list < input stream > return list = new array list < input stream > ( ) ; for ( string name : name ) { enumeration < url > e = class loader . get resource ( r e s o u r c e_ b a s e+name ) ; for ( ; e . have more element ( ) ; ) { url url = e . next element ( ) ; if ( debug_descriptor_finder ) { logger . get logger ( ) . debug ( `` add in url to set be parse : `` + url + `` from `` + r e s o u r c e_ b a s e+name ) ; } try { identifier . add ( url . to u r i ( ) . to string ( ) ) ; } catch ( u r i syntax exception e1 ) { throw new i o exception ( e1 ) ; } input stream input stream ; try { input stream = url . open stream ( ) ; } catch ( i o exception ioe ) { if ( debug_descriptor_finder ) { logger . get logger ( ) . debug ( `` i o exception for url `` + url , ioe ) ; } throw ioe ; } catch ( throwable th ) { if ( debug_descriptor_finder ) { logger . get logger ( ) . debug ( `` unexpected exception for url `` + url , th ) ; } throw new i o exception ( th ) ; } if ( debug_descriptor_finder ) { logger . get logger ( ) . debug ( `` input stream for : `` + url + `` from `` + r e s o u r c e_ b a s e+name + `` have succesfully be open `` ) ; } return list . add ( input stream ) ; } } return return list ; }
public synchronize void add metadata ( string key , string value ) { if ( metadata == null ) metadata = new link hash map < string , list < string > > ( ) ; reflection helper . add metadata ( metadata , key , value ) ; }
public synchronize boolean remove metadata ( string key , string value ) { if ( metadata == null ) return false ; return reflection helper . remove metadata ( metadata , key , value ) ; }
public static < t > t find or create service ( service locator locator , class < t > type , annotation . . . qualifier ) throw multi exception { if ( locator == null || type == null ) throw new illegal argument exception ( ) ; service handle < t > ret val = locator . get service handle ( type , qualifier ) ; if ( ret val == null ) { return locator . create and initialize ( type ) ; } return ret val . get service ( ) ; }
public static void enable topic distribution ( service locator locator ) { throw new assertion error ( `` service locator utility . enable topic distribution method have be remove , use extras utility . enable topic distribution `` ) ; }
public static void dump all descriptor ( service locator locator ) { dump all descriptor ( locator , system . err ) ; }
public boolean have error ( ) { return ( ( throwables ! = null ) & & ( ! throwables . be empty ( ) ) ) ; }
public static < t > t just create ( class < t > create me , service locator impl locator , string strategy ) { if ( create me == null ) throw new illegal argument exception ( ) ; collector collector = new collector ( ) ; class analyzer analyzer = get class analyzer ( locator , strategy , collector ) ; collector . throw if error ( ) ; constructor < ? > c = get constructor ( create me , analyzer , collector ) ; collector . throw if error ( ) ; list < system injectee impl > injectees = get constructor injectees ( c , null ) ; validate self injectees ( null , injectees , collector ) ; collector . throw if error ( ) ; object args [ ] = new object [ injectees . size ( ) ] ; for ( system injectee impl injectee : injectees ) { injection resolver < ? > resolver = locator . get per locator utility ( ) . get injection resolver ( locator , injectee ) ; args [ injectee . get position ( ) ] = resolver . resolve ( injectee , null ) ; } try { return ( t ) reflection helper . make me ( c , args , locator . get neutral context class loader ( ) ) ; } catch ( throwable th ) { throw new multi exception ( th ) ; } }
public static string get default name from method ( method parent , collector collector ) { name name = parent . get annotation ( name . class ) ; if ( name == null ) { return null ; } if ( name . value ( ) == null || name . value ( ) . equal ( `` `` ) ) { collector . add throwable ( new illegal argument exception ( `` @ name on the provide method of a factory must have an explicit value `` ) ) ; } return name . value ( ) ; }
public synchronize static boolean proxy available ( ) { if ( proxy available ! = null ) { return proxy available ; } class loader loader = utility . class . get class loader ( ) ; if ( loader == null ) { loader = class loader . get system class loader ( ) ; } try { loader . load class ( `` javassist . util . proxy . method handler `` ) ; proxy available = true ; return true ; } catch ( throwable th ) { proxy available = false ; return false ; } }
public void set ( v value ) { final key key = new storage key ( queue ) ; local . put ( key , mask null ( value ) ) ; }
public t get incoming object ( ) { return incoming ; }
public static logger get logger ( ) { return instance ; }
public static string method ( method method ) { if ( method == null ) return null_string ; return method . get name ( ) + pretty print parameter ( method . get parameter type ( ) ) ; }
public static string field ( field field ) { if ( field == null ) return null_string ; type t = field . get generic type ( ) ; string base string ; if ( t instanceof class ) { base string = clazz ( ( class < ? > ) t ) ; } else { base string = type ( t ) ; } return `` field ( `` + base string + `` `` + field . get name ( ) + `` in `` + field . get declare class ( ) . get name ( ) + `` ) `` ; }
public static type resolve member ( class < ? > topclass , type look for type , class < ? > declare class ) { map < string , type > type argument = type from sub class to declare class ( topclass , declare class ) ; if ( type argument == null ) return look for type ; if ( look for type instanceof parameterized type ) { return fix type variable ( ( parameterized type ) look for type , type argument ) ; } if ( look for type instanceof generic array type ) { return fix generic array type variable ( ( generic array type ) look for type , type argument ) ; } if ( ! ( look for type instanceof type variable ) ) { return look for type ; } type variable < ? > tv = ( type variable < ? > ) look for type ; string type variable name = tv . get name ( ) ; type ret val = type argument . get ( type variable name ) ; if ( ret val == null ) return look for type ; if ( ret val instanceof class ) return ret val ; if ( ret val instanceof parameterized type ) { return fix type variable ( ( parameterized type ) ret val , type argument ) ; } if ( ret val instanceof generic array type ) { return fix generic array type variable ( ( generic array type ) ret val , type argument ) ; } return ret val ; }
public static type get first type argument ( type type ) { if ( type instanceof class ) { return object . class ; } if ( ! ( type instanceof parameterized type ) ) return object . class ; parameterized type pt = ( parameterized type ) type ; type argument [ ] = pt . get actual type argument ( ) ; if ( argument . length < = 0 ) return object . class ; return argument [ 0 ] ; }
public static boolean be annotation a qualifier ( annotation anno ) { class < ? extend annotation > anno type = anno . annotation type ( ) ; return anno type . be annotation present ( qualifier . class ) ; }
public static < t > t cast ( object o ) { return ( t ) o ; }
public boolean contains key ( k k ) { return ! get ( k ) . be empty ( ) ; }
public final http async client builder disable connection state ( ) { connection state disable = true ; return this ; }
public static http async response consumer < http response > create zero copy consumer ( final file file ) throw file not find exception { return new zero copy consumer < http response > ( file ) { @ override protect http response process ( final http response response , final file file , final content type content type ) { return response ; } } ; }
public static void close quietly ( final closeable http async client http async client ) { if ( http async client ! = null ) { try { http async client . close ( ) ; } catch ( final i o exception ignore ) { } } }
public conditionals add if match ( tag tag ) { precondition . check argument ( ! modify since . be present ( ) , string . format ( error_message , header constant . if_match , header constant . if_modified_since ) ) ; precondition . check argument ( none match . be empty ( ) , string . format ( error_message , header constant . if_match , header constant . if_none_match ) ) ; list < tag > match = new array list < > ( this . match ) ; if ( tag == null ) { tag = tag . all ; } if ( tag . all . equal ( tag ) ) { match . clear ( ) ; } if ( ! match . contains ( tag . all ) ) { if ( ! match . contains ( tag ) ) { match . add ( tag ) ; } } else { throw new illegal argument exception ( `` tag all already in the list `` ) ; } return new conditionals ( collection . unmodifiable list ( match ) , empty ( ) , optional . empty ( ) , un modify since ) ; }
public static void set credential charset ( final http params params , final string charset ) { if ( params == null ) { throw new illegal argument exception ( `` http parameter may not be null `` ) ; } params . set parameter ( auth p name . credential_charset , charset ) ; }
public final string get name ( ) { return name ; }
public static int count dot ( final string s ) { int count = 0 ; for ( int i = 0 ; i < s . length ( ) ; i++ ) { if ( s . char at ( i ) == ' . ' ) { count++ ; } } return count ; }
public synchronize void set params ( http params params ) { default params = params ; }
public void add ( final uri uri ) { this . unique . add ( uri ) ; this . all . add ( uri ) ; }
protect void shutdown entry ( ) { tracker = null ; state = null ; }
public final int get max entry ( ) { return max entry ; }
public final int get entry count ( ) { return num entry ; }
protect abstract conn pool create connection pool ( final http params params ) { return new conn pool by route ( conn operator , params ) ; }
public boolean domain match ( string host , string domain ) { boolean match = host . equal ( domain ) || ( domain . start with ( `` . `` ) & & host . end with ( domain ) ) ; return match ; }
public void validate ( final cookie cookie , final cookie origin origin ) throw malformed cookie exception { if ( cookie == null ) { throw new illegal argument exception ( `` cookie may not be null `` ) ; } if ( cookie instanceof set cookie2 ) { if ( cookie instanceof client cookie & & ! ( ( client cookie ) cookie ) . contains attribute ( client cookie . version_attr ) ) { throw new cookie restriction violation exception ( `` violate rfc 2965 . version attribute be require . `` ) ; } } }
public u r i builder set parameter ( final string param , final string value ) { if ( this . query params == null ) { this . query params = new array list < name value pair > ( ) ; } if ( ! this . query params . be empty ( ) ) { for ( iterator < name value pair > it = this . query params . iterator ( ) ; it . have next ( ) ; ) { name value pair nvp = it . next ( ) ; if ( nvp . get name ( ) . equal ( param ) ) { it . remove ( ) ; } } } this . query params . add ( new basic name value pair ( param , value ) ) ; this . encoded query = null ; this . encoded scheme specific part = null ; return this ; }
public static s s l socket factory get system socket factory ( ) throw s s l initialization exception { return new s s l socket factory ( ( javax . net . ssl . s s l socket factory ) javax . net . ssl . s s l socket factory . get default ( ) , browser_compatible_hostname_verifier ) ; }
public static boolean be i pv4 address ( final string input ) { return ipv4_pattern . matcher ( input ) . match ( ) ; }
public boolean be authentication enabled ( ) { return authentication enable ; }
public collection < string > get target preferred auth scheme ( ) { return target prefer auth scheme ; }
public boolean be decompression enabled ( ) { return decompression enable ; }
public entity builder gzip compress ( ) { this . gzip compress = true ; return this ; }
public string get parameter ( final string name ) { args . not null ( name , `` parameter name `` ) ; return null ; }
public final http client builder evict expire connection ( ) { evict expire connection = true ; return this ; }
public int get connection request timeout ( ) { return connection request timeout ; }
public static registry builder < cookie spec provider > create default builder ( ) { return create default builder ( public suffix matcher loader . get default ( ) ) ; }
public void consume content ( ) throw i o exception { }
public boolean be repeatable ( ) { return false ; }
protect boolean be token separator ( char ch ) { return ( ch == ' , ' ) ; }
public http params copy ( ) { try { return ( http params ) clone ( ) ; } catch ( clone not support exception ex ) { throw new unsupported operation exception ( `` clone not support `` ) ; } }
public synchronize void set object ( final map map ) { if ( map == null ) { throw new illegal argument exception ( `` map of handler may not be null `` ) ; } this . map . clear ( ) ; this . map . put all ( map ) ; }
public int index of ( byte b , int begin index , int end index ) { if ( begin index < 0 ) { begin index = 0 ; } if ( end index > this . len ) { end index = this . len ; } if ( begin index > end index ) { return -1 ; } for ( int i = begin index ; i < end index ; i++ ) { if ( this . buffer [ i ] == b ) { return i ; } } return -1 ; }
public void append ( final char array buffer b , int off , int len ) { if ( b == null ) { return ; } append ( b . buffer , off , len ) ; }
public char char at ( int i ) { return this . buffer [ i ] ; }
public int length ( ) { return this . len ; }
public final string get module ( ) { return info module ; }
public final string get release ( ) { return info release ; }
public final string get timestamp ( ) { return info timestamp ; }
public set < string > get name ( ) { return new hash set < string > ( this . parameter . key set ( ) ) ; }
public void shutdown ( ) throw i o exception { if ( this . be shut down ) { return ; } this . be shut down = true ; this . lock . lock ( ) ; try { for ( e entry : this . available ) { entry . close ( ) ; } for ( e entry : this . lease ) { entry . close ( ) ; } for ( route specific pool < t , c , e > pool : this . route to pool . value ( ) ) { pool . shutdown ( ) ; } this . route to pool . clear ( ) ; this . lease . clear ( ) ; this . available . clear ( ) ; } finally { this . lock . unlock ( ) ; } }
public content type with charset ( final charset charset ) { return create ( this . get mime type ( ) , charset ) ; }
public void skip white space ( final char array buffer buf , final parser cursor cursor ) { int po = cursor . get pos ( ) ; final int index from = cursor . get pos ( ) ; final int index to = cursor . get upper bound ( ) ; for ( int i = index from ; i < index to ; i++ ) { final char current = buf . char at ( i ) ; if ( ! be whitespace ( current ) ) { break ; } else { pos++ ; } } cursor . update po ( po ) ; }
public static void update entity ( final http response response , final http entity entity ) throw i o exception { args . not null ( response , `` response `` ) ; consume ( response . get entity ( ) ) ; response . set entity ( entity ) ; }
public static boolean be blank ( final char sequence s ) { if ( s == null ) { return true ; } for ( int i = 0 ; i < s . length ( ) ; i++ ) { if ( ! character . be whitespace ( s . char at ( i ) ) ) { return false ; } } return true ; }
protect void assert not close ( ) throw connection close exception { if ( this . status ! = active ) { throw new connection close exception ( ) ; } }
protect void session create ( final selection key key , final i o session session ) { }
protect void process event ( final selection key key ) { final i o session impl session = ( i o session impl ) key . attachment ( ) ; try { if ( key . be acceptable ( ) ) { acceptable ( key ) ; } if ( key . be connectable ( ) ) { connectable ( key ) ; } if ( key . be readable ( ) ) { session . reset last read ( ) ; readable ( key ) ; } if ( key . be writable ( ) ) { session . reset last write ( ) ; writable ( key ) ; } } catch ( final cancel key exception ex ) { queue close session ( session ) ; key . attach ( null ) ; } }
protect void queue close session ( final i o session session ) { if ( session ! = null ) { this . closed session . add ( session ) ; } }
protect void await shutdown ( final long timeout ) throw interrupted exception { synchronize ( this . status lock ) { final long deadline = system . current time millis ( ) + timeout ; long remain = timeout ; while ( this . status ! = i o reactor status . shut_down ) { this . status lock . wait ( remain ) ; if ( timeout > 0 ) { remain = deadline - system . current time millis ( ) ; if ( remain < = 0 ) { break ; } } } } }
public long get shutdown grace period ( ) { return this . shutdown grace period ; }
public http response factory get response factory ( ) { return response factory ; }
public exception logger get exception logger ( ) { return exception logger ; }
protect int get mode ( ) { return this . mode ; }
public int capacity ( ) { return this . buffer . capacity ( ) ; }
public static boolean have var params ( final method method ) { return boolean . value of ( method . get have var params ( ) ) ; }
public reason get reason ( ) { return reason ; }
protect void _handle e o f ( ) throw json parse exception { if ( ! _parsing context . in root ( ) ) { string marker = _parsing context . in array ( ) ? `` array `` : `` object `` ; _report invalid e o f ( string . format ( `` : expect close marker for % s ( start marker at % s ) `` , marker , _parsing context . get start location ( _get source reference ( ) ) ) , null ) ; } }
protect object read resolve ( ) { return base64 variant . value of ( _name ) ; }
public int encode base64 chunk ( int b24 , char [ ] buffer , int ptr ) { buffer [ ptr++ ] = _base64 to ascii c [ ( b24 > > 18 ) & 0x3 f ] ; buffer [ ptr++ ] = _base64 to ascii c [ ( b24 > > 12 ) & 0x3 f ] ; buffer [ ptr++ ] = _base64 to ascii c [ ( b24 > > 6 ) & 0x3 f ] ; buffer [ ptr++ ] = _base64 to ascii c [ b24 & 0x3 f ] ; return ptr ; }
public string miss padding message ( ) { return string . format ( `` unexpected end of base64-encoded string : base64 variant ' % s ' expect padding ( one or more ' % c ' character ) at the end `` , get name ( ) , get pad char ( ) ) ; }
public token filter filter start array ( ) { return this ; }
public token filter include element ( int index ) { return this ; }
public boolean include null ( ) { return _include scalar ( ) ; }
public boolean have match ( ) { return _match ! = null ; }
public static int [ ] standard ascii escape for j s o n ( ) { int [ ] esc = char type . get7 bit output escape ( ) ; return array . copy of ( esc , esc . length ) ; }
public static json string encoder get instance ( ) { return instance ; }
public string get and clear ( ) { string result = _buffer . content a string ( ) ; _buffer . release buffer ( ) ; return result ; }
public final int char length ( ) { return _value . length ( ) ; }
public boolean can use schema ( format schema schema ) { if ( schema == null ) { return false ; } string our format = get format name ( ) ; return ( our format ! = null ) & & our format . equal ( schema . get schema type ( ) ) ; }
public input decorator get input decorator ( ) { return _input decorator ; }
public string source description ( ) { return _append source desc ( new string builder ( 100 ) ) . to string ( ) ; }
public boolean can parse async ( ) { return false ; }
public boolean be expect start array token ( ) { return current token ( ) == json token . start_array ; }
public < t > t read value a ( class < t > value type ) throw i o exception { return _codec ( ) . read value ( this , value type ) ; }
protect void _report unsupported operation ( ) { throw new unsupported operation exception ( `` operation not support by parser of type `` +get class ( ) . get name ( ) ) ; }
public json pointer tail ( ) { return _next segment ; }
protect string get message suffix ( ) { return null ; }
protect void verify internal consistency ( ) { int count = 0 ; final int size = _symbols . length ; for ( int i = 0 ; i < size ; ++i ) { string symbol = _symbols [ i ] ; if ( symbol ! = null ) { ++count ; } } final int bucket size = ( size > > 1 ) ; for ( int i = 0 ; i < bucket size ; ++i ) { for ( bucket b = _buckets [ i ] ; b ! = null ; b = b . next ) { ++count ; } } if ( count ! = _size ) { throw new illegal state exception ( string . format ( `` internal error : expect internal size % d v calculate count % d `` , _size , count ) ) ; } }
public boolean be reference type ( ) { return get reference type ( ) ! = null ; }
public int compare to ( type reference < t > o ) { return 0 ; }
@ override public void clear current token ( ) { delegate . clear current token ( ) ; }
@ override public string get text ( ) throw i o exception { return delegate . get text ( ) ; }
public final static void throw internal ( ) { throw new runtime exception ( `` internal error : this code path should never get execute `` ) ; }
public void ensure field name write ( json generator gen ) throw i o exception { if ( _need to handle name ) { _need to handle name = false ; gen . write field name ( _current name ) ; } }
public byte [ ] alloc read i o buffer ( ) { _verify alloc ( _read i o buffer ) ; return ( _read i o buffer = _buffer recycler . alloc byte buffer ( buffer recycler . byte_read_io_buffer ) ) ; }
public content reference content reference ( ) { return _content reference ; }
public json location current token location ( ) { return get token location ( ) ; }
public big integer get big integer value ( ) throw i o exception { return delegate . get big integer value ( ) ; }
protect boolean do equivalent ( final json node a , final json node b ) { / * * if both be number , delegate to the helper method * / if ( a . be number ( ) & & b . be number ( ) ) return num equal ( a , b ) ; final node type type a = node type . get node type ( a ) ; final node type type b = node type . get node type ( b ) ; / * * if they be of different type , no dice * / if ( type a ! = type b ) return false ; / * * for all other primitive type than number , trust json node * / if ( ! a . be container node ( ) ) return a . equal ( b ) ; / * * ok , so they be container ( either both array or object due to the * test on type above ) . they be obviously not equal if they do not * have the same number of elements/members . * / if ( a . size ( ) ! = b . size ( ) ) return false ; / * * delegate to the appropriate method accord to their type . * / return type a == node type . array ? array equal ( a , b ) : object equal ( a , b ) ; }
public json pointer append ( final json pointer other ) { bundle . check not null ( other , `` null input `` ) ; final list < token resolver < json node > > list = list . new array list ( token resolvers ) ; list . add all ( other . token resolvers ) ; return new json pointer ( list ) ; }
public final t get ( final t node ) { t ret = node ; for ( final token resolver < t > token resolver : token resolvers ) { if ( ret == null ) break ; ret = token resolver . get ( ret ) ; } return ret ; }
public object find content serializer ( annotate be ) { return null ; }
public boolean have creator annotation ( annotate a ) { return false ; }
public java type get type ( ) { return _type ; }
public config override find override ( class < ? > type ) { if ( _overrides == null ) { return null ; } return _overrides . get ( type ) ; }
public b default setter info ( json setter . value v ) { _mapper . set default setter info ( v ) ; return _this ( ) ; }
public b default time zone ( time zone tz ) { _mapper . set time zone ( tz ) ; return _this ( ) ; }
public final int mix in count ( ) { return _mix in . local size ( ) ; }
public settable bean property find property ( string property name ) { settable bean property prop = ( _bean property == null ) ? null : _bean property . find ( property name ) ; if ( prop == null & & _property base creator ! = null ) { prop = _property base creator . find creator property ( property name ) ; } return prop ; }
public void add creator property ( settable bean property prop ) { add property ( prop ) ; }
public settable bean property [ ] get property in insertion order ( ) { return _props in order ; }
public boolean be cachable ( ) { return _delegatee . be cachable ( ) ; }
public final boolean have deserialization feature ( int feature mask ) { return ( _deser feature & feature mask ) == feature mask ; }
public final class < ? > get raw class ( ) { return _class ; }
public boolean support update ( deserialization config config ) { return null ; }
public static json map exception wrap with path ( throwable src , object ref from , string ref field name ) { return wrap with path ( src , new reference ( ref from , ref field name ) ) ; }
public string get path reference ( ) { return get path reference ( new string builder ( ) ) . to string ( ) ; }
public class < t > handle type ( ) { return null ; }
public simple module register subtypes ( name type . . . subtypes ) { if ( _subtypes == null ) { _subtypes = new link hash set < > ( ) ; } for ( name type subtype : subtypes ) { _check not null ( subtype , `` subtype to register `` ) ; _subtypes . add ( subtype ) ; } return this ; }
public array node add all ( array node other ) { _children . add all ( other . _children ) ; return this ; }
public array node insert array ( int index ) { array node n = array node ( ) ; _insert ( index , n ) ; return n ; }
protected array node _add ( json node node ) { _children . add ( node ) ; return this ; }
public byte [ ] binary value ( ) { return _data ; }
public value node number node ( byte value ) { return ( value == null ) ? null node ( ) : int node . value of ( value . int value ( ) ) ; }
public array node array node ( int capacity ) { return new array node ( this , capacity ) ; }
public value node pojo node ( object pojo ) { return new p o j o node ( pojo ) ; }
public object node put ( string field name , string v ) { return _put ( field name , ( v == null ) ? null node ( ) : text node ( v ) ) ; }
public string a text ( ) { return ( _value == null ) ? `` null `` : _value . to string ( ) ; }
public object get pojo ( ) { return _value ; }
public object mapper set default visibility ( json auto detect . value vi ) { _config override . set default visibility ( visibility checker . std . construct ( vi ) ) ; return this ; }
public boolean be enable ( serialization feature f ) { return _serialization config . be enable ( f ) ; }
public boolean can serialize ( class < ? > type ) { return _serializer provider ( get serialization config ( ) ) . have serializer for ( type , null ) ; }
public object writer with default pretty printer ( ) { return with ( _config . get default pretty printer ( ) ) ; }
public object set internal setting ( object key , object value ) { if ( _internal setting == null ) { _internal setting = new hash map < object , object > ( ) ; } return _internal setting . put ( key , value ) ; }
public void flush cache serializers ( ) { _serializer cache . flush ( ) ; }
public static simple bean property filter filter out all except ( set < string > property ) { return new filter except filter ( property ) ; }
public serialization config with feature ( json generator . feature . . . feature ) { int new set = _generator feature ; int new mask = _generator feature to change ; for ( json generator . feature f : feature ) { int mask = f . get mask ( ) ; new set |= mask ; new mask |= mask ; } return ( ( _generator feature == new set ) & & ( _generator feature to change == new mask ) ) ? this : new serialization config ( this , _mapper feature , _ser feature , new set , new mask , _format write feature , _format write feature to change ) ; }
public void set null value serializer ( json serializer < object > nv ) { if ( nvs == null ) { throw new illegal argument exception ( `` can not pass null json serializer `` ) ; } _null value serializer = nv ; }
public final serialization config get config ( ) { return _config ; }
public final filter provider get filter provider ( ) { return _config . get filter provider ( ) ; }
public json serializer < object > find null value serializer ( bean property property ) throw json map exception { return _null value serializer ; }
public map type construct raw map type ( class < ? extend map > map class ) { return construct map type ( map class , unknown type ( ) , unknown type ( ) ) ; }
public static boolean be concrete ( class < ? > type ) { int mod = type . get modifier ( ) ; return ( mod & ( modifier . interface | modifier . abstract ) ) == 0 ; }
public static string backticked ( string text ) { if ( text == null ) { return `` [ null ] `` ; } return new string builder ( text . length ( ) +2 ) . append ( ' ` ' ) . append ( text ) . append ( ' ` ' ) . to string ( ) ; }
public object [ ] reset and start ( ) { _reset ( ) ; if ( _free buffer == null ) { return ( _free buffer = new object [ 12 ] ) ; } return _free buffer ; }
public < t > t [ ] complete and clear buffer ( object [ ] last chunk , int last chunk entry , class < t > component type ) { int total size = last chunk entry + _size ; @ suppress warning ( `` unchecked `` ) t [ ] result = ( t [ ] ) array . new instance ( component type , total size ) ; _copy to ( result , total size , last chunk , last chunk entry ) ; _reset ( ) ; return result ; }
public string get name ( ) { return _full name . get simple name ( ) ; }
public serializable string compile string ( string src ) { / * 20- jan-2014 , tatu : for now we will just construct it directly , but * in future should allow override to support non-standard extension * to be use by extension like afterburner . * / return new serialize string ( src ) ; }
public boolean find ignore unknown property ( annotated class ac ) { return null ; }
public void add includable ( string prop name ) { if ( _includable prop == null ) { _includable prop = new hash set < > ( ) ; } _includable prop . add ( prop name ) ; }
public boolean be from int value ( ) { return _is from int value ; }
public object find serializer ( annotate be ) { return null ; }
public class < ? > find serialization type ( annotate a ) { return null ; }
public annotation introspector get annotation introspector ( ) { / * 29- jul-2009 , tatu : it 's now possible to disable use of * annotation ; can be do use `` no-op `` introspector * / if ( be enable ( mapper feature . use_annotations ) ) { return super . get annotation introspector ( ) ; } return nop annotation introspector . instance ; }
public json map exception weird string exception ( class < ? > inst class , string msg ) { return weird string exception ( null , inst class , msg ) ; }
protect void _add class mix in ( annotation map annotation , class < ? > to mask ) { if ( _mix in resolver ! = null ) { _add class mix in ( annotation , to mask , _mix in resolver . find mix in class for ( to mask ) ) ; } }
public annotate member get primary member ( ) { return null ; }
protect string _build message ( ) { / * first : if we have no path info , let 's just use parent 's * definition a be * / string msg = super . get message ( ) ; if ( _path == null ) { return msg ; } string builder sb = ( msg == null ) ? new string builder ( ) : new string builder ( msg ) ; / * 18- feb-2009 , tatu : initially there be a linefeed between * message and path reference ; but unfortunately many system * ( logger , junit ) seem to assume linefeeds be only added to * separate stack trace . * / sb . append ( `` ( through reference chain : `` ) ; sb = get path reference ( sb ) ; sb . append ( ' ) ' ) ; return sb . to string ( ) ; }
public object mapper enable default typing ( ) { return enable default typing ( default type . object_and_non_concrete ) ; }
public object node create object node ( ) { return _deserialization config . get node factory ( ) . object node ( ) ; }
protected boolean include element ( object element value ) { return true ; }
public json serializer < ? > get key serializer ( ) { return _key serializer ; }
public static void throw root cause ( throwable t ) throw exception { t = get root cause ( t ) ; if ( t instanceof exception ) { throw ( exception ) t ; } throw ( error ) t ; }
protect boolean look like i s o8601 ( string date str ) { if ( date str . length ( ) > = 5 & & character . be digit ( date str . char at ( 0 ) ) & & character . be digit ( date str . char at ( 3 ) ) & & date str . char at ( 4 ) == '- ' ) { return true ; } return false ; }
public static boolean node get true ( ) { return true ; }
protect final int read byte ( ) throw i o exception { _input ptr = 0 ; _input end = 0 ; if ( _input source ! = null ) { int count = _input source . read ( _input buffer , 0 , _input buffer . length ) ; if ( count > 0 ) { _input end = count ; } return count ; } return -1 ; }
public jdk8 module configure absents a null ( boolean state ) { _cfg handle absent a null = state ; return this ; }
public boolean equal ( object obj ) { if ( obj instanceof method expression impl ) { method expression impl method expression impl = ( method expression impl ) obj ; return get node ( ) . equal ( method expression impl . get node ( ) ) ; } return false ; }
public object get value ( e l context context , object base , object property ) { context . set property resolve ( false ) ; object value = null ; for ( int i = 0 ; i < size ; i++ ) { value = el resolvers [ i ] . get value ( context , base , property ) ; if ( context . be property resolve ( ) ) { return value ; } } return null ; }
public void add evaluation listener ( evaluation listener listener ) { if ( listener == null ) { listener = new array list < > ( ) ; } listener . add ( listener ) ; }
public object get lambda argument ( string arg ) { if ( lambda args == null ) { return null ; } for ( int i = lambda args . size ( ) - 1 ; i > = 0 ; i -- ) { map < string , object > lmap = lambda args . element at ( i ) ; object v = lmap . get ( arg ) ; if ( v ! = null ) { return v ; } } return null ; }
public void add bean name resolver ( bean name resolver bean name resolver ) { get e l context ( ) . add e l resolver ( new bean name e l resolver ( bean name resolver ) ) ; }
public void add e l resolver ( e l resolver el resolver ) { get e l context ( ) . add e l resolver ( el resolver ) ; }
public object define bean ( string name , object bean ) { object previous bean = get e l context ( ) . get bean ( ) . get ( name ) ; get e l context ( ) . get bean ( ) . put ( name , bean ) ; return previous bean ; }
public object eval ( string expression ) { return get value ( expression , object . class ) ; }
public object invoke ( e l context context , object base , object method name , class < ? > [ ] param type , object [ ] params ) { if ( context == null ) { throw new null pointer exception ( ) ; } if ( ! ( base instanceof e l class & & method name instanceof string ) ) { return null ; } class < ? > klass = ( ( e l class ) base ) . get klass ( ) ; string name = ( string ) method name ; object ret ; if ( `` < init > `` . equal ( name ) ) { constructor < ? > constructor = e l util . find constructor ( klass , param type , params ) ; ret = e l util . invoke constructor ( context , constructor , params ) ; } else { method method = e l util . find method ( klass , name , param type , params , true ) ; ret = e l util . invoke method ( context , method , null , params ) ; } context . set property resolve ( base , method name ) ; return ret ; }
public json patch builder test ( string path , json value value ) { builder . add ( json . create object builder ( ) . add ( `` op `` , operation . test . operation name ( ) ) . add ( `` path `` , path ) . add ( `` value `` , value ) ) ; return this ; }
public final jsonb config with property order strategy ( final string property order strategy ) { return set property ( property_order_strategy , property order strategy ) ; }
public medium type get medium type ( ) { return variant . get medium type ( ) ; }
public final void add first ( k key , v value ) { list < v > value = get value ( key ) ; if ( value ! = null ) { value . add ( 0 , value ) ; } else { add first null ( value ) ; } }
public int get max age ( ) { return max age ; }
public list < string > get private field ( ) { if ( private field == null ) { private field = new array list < string > ( ) ; } return private field ; }
public boolean be no store ( ) { return no store ; }
public string get value ( ) { return value ; }
public int get version ( ) { return version ; }
public string to string ( ) { return header_delegate . to string ( this ) ; }
public static builder from uri ( uri uri ) { builder b = runtime delegate . get instance ( ) . create link builder ( ) ; b . uri ( uri ) ; return b ; }
public static response builder no content ( ) { return status ( status . no_content ) ; }
public static response builder not modify ( string tag ) { return not modify ( ) . tag ( tag ) ; }
public static response builder not acceptable ( list < variant > variant ) { return status ( status . not_acceptable ) . variant ( variant ) ; }
public static string print decimal ( java . math . big decimal val ) { if ( the converter == null ) init converter ( ) ; return the converter . print decimal ( val ) ; }
protect void set no n s schema location ( string location ) { no n s schema location = location ; }
public validation event handler get event handler ( ) throw j a x b exception { return event handler ; }
public t get value ( ) { return value ; }
public string to string ( ) { return link exception == null ? super . to string ( ) : super . to string ( ) + `` \n - with link exception : \n [ `` + link exception . to string ( ) + `` ] `` ; }
public annotation value value with default ( index view index , string name ) { class info definition = index . get class by name ( this . name ) ; if ( definition == null ) { throw new illegal argument exception ( `` index do not contain annotation definition : `` + this . name ) ; } annotation value result = value ( name ) ; if ( result ! = null ) { return result ; } method info method = definition . method ( name ) ; return method == null ? null : method . default value ( ) ; }
public type component ( ) { return component ; }
public final boolean have no args constructor ( ) { return have no args constructor ; }
public enclose method info enclose method ( ) { return nest info ! = null ? nest info . enclose method : null ; }
public boolean be inner ( ) { return inner class ; }
public final string name ( ) { return internal . name ( ) ; }
public final type type ( ) { return internal . type ( ) ; }
public final boolean have annotation ( dot name name ) { return internal . have annotation ( name ) ; }
public int write ( index index ) throw i o exception { return write ( index , index writer v2 . max_version ) ; }
public static result create jar index ( file jar file , indexer indexer , boolean modify , boolean new jar , boolean verbose ) throw i o exception { return create jar index ( jar file , indexer , modify , new jar , verbose , system . out , system . err ) ; }
public final string parameter name ( int i ) { return method internal . parameter name ( i ) ; }
public type owner ( ) { return owner ; }
public type target ( ) { return target ; }
public string identifier ( ) { return name ; }
public completable future < v > load ( k key ) { return load ( key , null ) ; }
public boolean cache exception enable ( ) { return cache exception enable ; }
public data loader option set cache exception enable ( boolean cache exception enable ) { this . cache exception enable = cache exception enable ; return this ; }
public statistic combine ( statistic other ) { return new statistic ( this . load count + other . get load count ( ) , this . load error count + other . get load error count ( ) , this . batch invoke count + other . get batch invoke count ( ) , this . batch load count + other . get batch load count ( ) , this . batch load exception count + other . get batch load exception count ( ) , this . cache hit count + other . get cache hit count ( ) ) ; }
public static < v > try < v > always fail ( ) { return try . fail ( nil_throwable ) ; }
public list < diff row > generate diff row ( list < string > original , list < string > revise ) { return generate diff row ( original , diff utils . diff ( original , revise , equalizer ) ) ; }
protect printer get printer ( printer configuration config ) { printer printer = get printer ( ) . set configuration ( config ) ; printer ( printer ) ; return printer ; }
public compilation unit set import ( final node list < import declaration > import ) { assert not null ( import ) ; if ( import == this . import ) { return this ; } notify property change ( observable property . import , this . import , import ) ; if ( this . import ! = null ) this . import . set parent node ( null ) ; this . import = import ; set a parent node of ( import ) ; return this ; }
public list < class or interface declaration > get local declaration from classname ( string class name ) { return find all ( class or interface declaration . class ) . stream ( ) . filter ( cid - > cid . get fully qualify name ( ) . get ( ) . end with ( class name ) ) . collect ( collector . to list ( ) ) ; }
public static char literal expr escape ( string string ) { return new char literal expr ( utils . escape end of line ( string ) ) ; }
public resolve value declaration resolve ( ) { return get symbol resolver ( ) . resolve declaration ( this , resolve value declaration . class ) ; }
public string literal expr set string ( string value ) { this . value = escape java ( value ) ; return this ; }
public boolean be asterisk ( ) { return be asterisk ; }
public name get name ( ) { return name ; }
public for stmt set compare ( final expression compare ) { if ( compare == this . compare ) { return this ; } notify property change ( observable property . compare , this . compare , compare ) ; if ( this . compare ! = null ) this . compare . set parent node ( null ) ; this . compare = compare ; set a parent node of ( compare ) ; return this ; }
public boolean have then block ( ) { return then stmt instanceof block stmt ; }
public boolean have else block ( ) { return else stmt instanceof block stmt ; }
public parse result < name > parse name ( string qualify name ) { return parse ( name , provider ( qualified name ) ) ; }
public optional < symbol resolver > get symbol resolver ( ) { return optional . of nullable ( symbol resolver ) ; }
public set < configuration option > get ( ) { return default option ; }
public indent type get indent type ( ) { return get indentation ( ) . get type ( ) ; }
public boolean contains ( range other ) { boolean begin result = ( begin . be before or equal ( other . begin ) ) ; boolean end result = ( end . be after or equal ( other . end ) ) ; return begin result & & end result ; }
public boolean strictly contain ( range other ) { boolean begin result = ( begin . be before ( other . begin ) ) ; boolean end result = ( end . be after ( other . end ) ) ; return begin result & & end result ; }
public boolean strictly contain ( position position ) { return position . be after ( begin ) & & position . be before ( end ) ; }
public boolean declare on constructor ( ) { return false ; }
public string get qualified signature ( ) { return get declaration ( ) . declare type ( ) . get qualified name ( ) + `` . `` + get signature ( ) ; }
public string get qualify name ( ) { return type declaration . get qualified name ( ) ; }
public boolean be unboxable ( ) { return array . stream ( resolve primitive type . value ( ) ) . any match ( pt - > get qualify name ( ) . equal ( pt . get box type q name ( ) ) ) ; }
public static string f ( string format , object . . . params ) { return string . format ( format , params ) ; }
public static void info ( string format , supplier < object > . . . args ) { current_adapter . info ( make format supplier ( format , args ) ) ; }
public static void clear instance ( ) { instance . clear ( ) ; }
public boolean be need disambiguation ( ) { return need disambiguation ; }
public static string name a string ( node name ) { if ( ! be a name ( name ) ) { throw new illegal argument exception ( `` a name be expect `` ) ; } if ( name instanceof name ) { return ( ( name ) name ) . a string ( ) ; } else if ( name instanceof simple name ) { return ( ( simple name ) name ) . get identifier ( ) ; } else if ( name instanceof class or interface type ) { return ( ( class or interface type ) name ) . a string ( ) ; } else if ( name instanceof field access expr ) { field access expr field access expr = ( field access expr ) name ; if ( be a name ( field access expr . get scope ( ) ) ) { return name a string ( field access expr . get scope ( ) ) + `` . `` + name a string ( field access expr . get name ( ) ) ; } else { throw new illegal argument exception ( ) ; } } else if ( name instanceof name expr ) { return ( ( name expr ) name ) . get name a string ( ) ; } else { throw new unsupported operation exception ( `` unknown type of name find : `` + name + `` ( `` + name . get class ( ) . get canonical name ( ) + `` ) `` ) ; } }
public optional < proper low bound > be proper low bound ( ) { return optional . empty ( ) ; }
public static string get parent path ( string filename ) { utils . assert not null ( filename ) ; int last index = filename . last index of ( file . separator ) ; return filename . substring ( 0 , last index ) ; }
public static char seq of ( char . . . character ) { object . require non null ( character , `` character be null `` ) ; if ( character . length == 0 ) { return empty ( ) ; } else { final char [ ] chrs = new char [ character . length ] ; system . arraycopy ( character , 0 , chrs , 0 , character . length ) ; return new char seq ( new string ( chrs ) ) ; } }
public void get char ( int src begin , int src end , char dst [ ] , int dst begin ) { back . get char ( src begin , src end , dst , dst begin ) ; }
public int last index of ( int ch , int from index ) { return back . last index of ( ch , from index ) ; }
public char seq concat ( char seq str ) { return char seq . of ( back . concat ( str . back ) ) ; }
public static hash set < byte > of all ( byte [ ] array ) { object . require non null ( array , `` array be null `` ) ; return hash set . of all ( iterator . of all ( array ) ) ; }
public static < k , v > link hash map < k , v > of ( k k1 , v v1 , k k2 , v v2 ) { final hash map < k , v > map = hash map . of ( k1 , v1 , k2 , v2 ) ; final queue < tuple2 < k , v > > list = queue . of ( tuple . of ( k1 , v1 ) , tuple . of ( k2 , v2 ) ) ; return new link hash map < > ( list , map ) ; }
public static link hash set < float > of all ( float [ ] array ) { object . require non null ( array , `` array be null `` ) ; return link hash set . of all ( iterator . of all ( array ) ) ; }
public static queue < float > of all ( float [ ] array ) { object . require non null ( array , `` array be null `` ) ; return of all ( list . of all ( array ) ) ; }
public static tree set < character > of all ( char [ ] array ) { object . require non null ( array , `` array be null `` ) ; return tree set . of all ( iterator . of all ( array ) ) ; }
public static tree set < float > of all ( float [ ] array ) { object . require non null ( array , `` array be null `` ) ; return tree set . of all ( iterator . of all ( array ) ) ; }
public static tree set < long > of all ( long [ ] array ) { object . require non null ( array , `` array be null `` ) ; return tree set . of all ( iterator . of all ( array ) ) ; }
public static < t > vector < t > of all ( iterable < ? extend t > iterable ) { object . require non null ( iterable , `` iterable be null `` ) ; if ( iterable instanceof vector ) { return ( vector < t > ) iterable ; } else { final bit map trie < t > trie = bit map trie . of all ( a array ( iterable ) ) ; return of all ( trie ) ; } }
public url find ( string classname ) { if ( this . classname . equal ( classname ) ) { string cname = classname . replace ( ' . ' , '/ ' ) + `` . class `` ; try { return new url ( null , `` file : / byte array class path/ `` + cname , new bytecode u r l stream handler ( ) ) ; } catch ( malformed u r l exception e ) { } } return null ; }
public static int set package ( int accflags ) { return ( accflags & ~ ( protect | public | private ) ) ; }
public block [ ] basic block ( ) { return basic block ; }
public void set local ( int index , type type ) { local [ index ] = type ; }
public frame copy stack ( ) { frame frame = new frame ( local . length , stack . length ) ; system . arraycopy ( stack , 0 , frame . stack , 0 , stack . length ) ; frame . top = top ; return frame ; }
public boolean be special ( ) { return special ; }
public string to string ( ) { string buffer buf = new string buffer ( `` @ `` ) ; buf . append ( get type name ( ) ) ; if ( member ! = null ) { buf . append ( `` ( `` ) ; for ( string name : member . key set ( ) ) { buf . append ( name ) . append ( `` = `` ) . append ( get member value ( name ) ) . append ( `` , `` ) ; } buf . set length ( buf . length ( ) -2 ) ; buf . append ( `` ) `` ) ; } return buf . to string ( ) ; }
public void accept ( member value visitor visitor ) { visitor . visit annotation member value ( this ) ; }
public void set value ( member value [ ] element ) { value = element ; if ( element ! = null & & element . length > 0 ) type = element [ 0 ] ; }
public const pool get const pool ( ) { return const pool ; }
public int add load parameter ( ct class [ ] params , int offset ) { int stacksize = 0 ; if ( params ! = null ) { int n = params . length ; for ( int i = 0 ; i < n ; ++i ) stacksize += add load ( stacksize + offset , params [ i ] ) ; } return stacksize ; }
public int add multi newarray ( ct class clazz , int dim ) { add ( multianewarray ) ; add index ( const pool . add class info ( clazz ) ) ; add ( dim ) ; grow stack ( 1 - dim ) ; return dim ; }
public void add ( int b1 , int b2 , int b3 , int b4 ) { add gap ( 4 ) ; buffer [ size - 4 ] = ( byte ) b1 ; buffer [ size - 3 ] = ( byte ) b2 ; buffer [ size - 2 ] = ( byte ) b3 ; buffer [ size - 1 ] = ( byte ) b4 ; }
public boolean be abstract ( ) { return ( access flag & access flag . abstract ) ! = 0 ; }
public int get superclass id ( ) { return super class ; }
public string [ ] get interface ( ) { if ( cached interface ! = null ) return cache interface ; string [ ] rtn = null ; if ( interface == null ) rtn = new string [ 0 ] ; else { string [ ] list = new string [ interface . length ] ; for ( int i = 0 ; i < interface . length ; ++i ) list [ i ] = const pool . get class info ( interface [ i ] ) ; rtn = list ; } cache interface = rtn ; return rtn ; }
public void set interface ( string [ ] name list ) { cached interface = null ; if ( name list ! = null ) { interface = new int [ name list . length ] ; for ( int i = 0 ; i < name list . length ; ++i ) interfaces [ i ] = const pool . add class info ( name list [ i ] ) ; } }
public void set version to java5 ( ) { this . major = 49 ; this . minor = 0 ; }
public void begin ( ) { current po = mark = 0 ; end po = get code length ( ) ; }
public int get code length ( ) { return bytecode . length ; }
public int look ahead ( ) { return current po ; }
public int skip super constructor ( ) throw bad bytecode { return skip super constructor0 ( 0 ) ; }
public void insert ex ( int po , byte [ ] code ) throw bad bytecode { insert0 ( po , code , true ) ; }
public string get class name ( ) { return get class info ( this class info ) ; }
public int get this class info ( ) { return this class info ; }
public int get tag ( int index ) { return get item ( index ) . get tag ( ) ; }
public int get name and type descriptor ( int index ) { name and type info ntinfo = ( name and type info ) get item ( index ) ; return ntinfo . type descriptor ; }
public string get fieldref type ( int index ) { fieldref info f = ( fieldref info ) get item ( index ) ; if ( f == null ) return null ; name and type info n = ( name and type info ) get item ( f . name and type index ) ; if ( n == null ) return null ; return get utf8 info ( n . type descriptor ) ; }
public int get method handle index ( int index ) { method handle info mhinfo = ( method handle info ) get item ( index ) ; return mhinfo . ref index ; }
public int get invoke dynamic bootstrap ( int index ) { invoke dynamic info iv = ( invoke dynamic info ) get item ( index ) ; return iv . bootstrap ; }
public int method index ( ) { return byte array . read u16bit ( get ( ) , 2 ) ; }
public int size ( ) { return entry . size ( ) ; }
public void add ( int index , exception table table , int offset ) { int len = table . size ( ) ; while ( -- len > = 0 ) { exception table entry e = table . entry . get ( len ) ; add ( index , e . start pc + offset , e . end pc + offset , e . handler pc + offset , e . catch type ) ; } }
public void shift index ( int less than , int delta ) { int size = info . length ; for ( int i = 2 ; i < size ; i += 10 ) { int org = byte array . read u16bit ( info , i + 8 ) ; if ( org > = less than ) byte array . write16bit ( org + delta , info , i + 8 ) ; } }
public const pool get const pool ( ) { return const pool ; }
public void remove exception attribute ( ) { attribute info . remove ( attribute , exception attribute . tag ) ; }
public int get line number ( int po ) { code attribute ca = get code attribute ( ) ; if ( ca == null ) return -1 ; line number attribute ainfo = ( line number attribute ) ca . get attribute ( line number attribute . tag ) ; if ( ainfo == null ) return -1 ; return ainfo . to line number ( pos ) ; }
public int host class index ( ) { return byte array . read u16bit ( info , 0 ) ; }
public static class signature to class signature ( string sig ) throw bad bytecode { try { return parse sig ( sig ) ; } catch ( index out of bound exception e ) { throw error ( sig ) ; } }
public boolean be null type ( ) { return false ; }
public string get reason ( ) { if ( message ! = null ) return message ; return this . to string ( ) ; }
public string get ( object jvm class name ) { string find = super . get ( jvm class name ) ; if ( find == null & & parent ! = null ) return parent . get ( jvm class name ) ; return find ; }
public string to string ( ) { return source . to string ( ) ; }
public void replace field read ( ct field field , ct class call class , string call method ) { transformer = new transform read field ( transformer , field , call class . get name ( ) , call method ) ; }
public a s t list sublist ( int nth ) { a s t list list = this ; while ( nth -- > 0 ) list = list . right ; return list ; }
public void add null if void ( ) { if ( expr type == void ) { bytecode . add opcode ( aconst_null ) ; expr type = class ; array dim = 0 ; class name = jvm java lang object ; } }
public void at call expr ( call expr expr ) throw compile error { a s tree method = expr . oprand1 ( ) ; if ( method instanceof member ) { string name = ( ( member ) method ) . get ( ) ; if ( proc handler ! = null & & name . equal ( proceed name ) ) { proc handler . doit ( this , bytecode , ( a s t list ) expr . oprand2 ( ) ) ; return ; } else if ( name . equal ( cflow name ) ) { at cflow ( ( a s t list ) expr . oprand2 ( ) ) ; return ; } } super . at call expr ( expr ) ; }
public a s tree parse expression ( symbol table tbl ) throw compile error { a s tree leave = parse conditional expr ( tbl ) ; if ( ! be assign op ( lex . look ahead ( ) ) ) return leave ; int t = lex . get ( ) ; a s tree right = parse expression ( tbl ) ; return assign expr . make assign ( t , leave , right ) ; }
public void insert before ( string src ) throw can not compile exception { insert before ( src , true ) ; }
public class file get class file ( ) { check modify ( ) ; return get class file2 ( ) ; }
public boolean subclass of ( ct class superclass ) { return false ; }
public ct class get superclass ( ) throw not find exception { return null ; }
public ct class get declare class ( ) throw not find exception { return null ; }
public ct field [ ] get field ( ) { return new ct field [ 0 ] ; }
public ct field get field ( string name ) throw not find exception { return get field ( name , null ) ; }
public ct method [ ] get method ( ) { return new ct method [ 0 ] ; }
public void prune ( ) { }
private static final int get_threshold = 2 ; // see compress ( ) ct class type ( string name , class pool cp ) { super ( name ) ; class pool = cp ; be change = be frozen = be prune = gc const pool = false ; classfile = null ; raw classfile = null ; member cache = null ; accessors = null ; field initializers = null ; hide method = null ; unique number seed = 0 ; get count = 0 ; }
public boolean be class initializer ( ) { return method info . be static initializer ( ) ; }
public string get name ( ) { return method info . get name ( ) ; }
public static ct constructor copy ( ct constructor c , ct class declaring , class map map ) throw can not compile exception { return new ct constructor ( c , declare , map ) ; }
public ct class [ ] may throw ( ) { class pool pool = this class . get class pool ( ) ; const pool cp = this method . get const pool ( ) ; list < ct class > list = new link list < ct class > ( ) ; try { code attribute ca = this method . get code attribute ( ) ; exception table et = ca . get exception table ( ) ; int pos = current po ; int n = et . size ( ) ; for ( int i = 0 ; i < n ; ++i ) if ( et . start pc ( i ) < = po & & po < et . end pc ( i ) ) { int t = et . catch type ( i ) ; if ( t > 0 ) try { add class ( list , pool . get ( cp . get class info ( t ) ) ) ; } catch ( not find exception e ) { } } } catch ( null pointer exception e ) { } exception attribute ea = this method . get exception attribute ( ) ; if ( ea ! = null ) { string [ ] exception = ea . get exception ( ) ; if ( exception ! = null ) { int n = exception . length ; for ( int i = 0 ; i < n ; ++i ) try { add class ( list , pool . get ( exception [ i ] ) ) ; } catch ( not find exception e ) { } } } return list . to array ( new ct class [ list . size ( ) ] ) ; }
public void edit ( constructor call c ) throw can not compile exception { }
public void edit ( cast c ) throw can not compile exception { }
public ct class get type ( ) throw not find exception { int type = etable . catch type ( index ) ; if ( type == 0 ) return null ; const pool cp = get const pool ( ) ; string name = cp . get class info ( type ) ; return this class . get class pool ( ) . get ct class ( name ) ; }
public ct method get method ( ) throw not find exception { return get ct class ( ) . get method ( get method name ( ) , get signature ( ) ) ; }
public static boolean be private ( int mod ) { return ( mod & private ) ! = 0 ; }
public static boolean be abstract ( int mod ) { return ( mod & abstract ) ! = 0 ; }
public static void reset use context class loader locally ( ) { use_context_class_loader_locally . remove ( ) ; }
public static final int type index ( class < ? > type ) { for ( int i = 0 ; i < primitive type . length ; i++ ) if ( primitive type [ i ] == type ) return i ; throw new runtime exception ( `` bad type : `` + type . get name ( ) ) ; }
public boolean be use cache ( ) { return factory use cache ; }
public boolean be use write replace ( ) { return factory write replace ; }
public void on frame ( frame frame ) { / * ignore in jsr-356 * / }
public void on input stream ( input stream stream ) { / * ignore , handle by binary stream message * / }
public int get int header ( string name ) { return this . _get http servlet request ( ) . get int header ( name ) ; }
public string get method ( ) { return this . _get http servlet request ( ) . get method ( ) ; }
public string get context path ( ) { return this . _get http servlet request ( ) . get context path ( ) ; }
public boolean be request session id from cookie ( ) { return this . _get http servlet request ( ) . be request session id from cookie ( ) ; }
public void set status ( int sc ) { this . _get http servlet response ( ) . set status ( sc ) ; }
public void println ( float f ) throw i o exception { print ( f ) ; println ( ) ; }
public void println ( double d ) throw i o exception { print ( d ) ; println ( ) ; }
public int get content length ( ) { return this . request . get content length ( ) ; }
public string get remote addr ( ) { return this . request . get remote addr ( ) ; }
public string get remote host ( ) { return this . request . get remote host ( ) ; }
public string get local addr ( ) { return this . request . get local addr ( ) ; }
public boolean be wrapper for ( class < ? > wrap type ) { if ( ! servlet request . class . be assignable from ( wrapped type ) ) { throw new illegal argument exception ( `` give class `` + wrap type . get name ( ) + `` not a subinterface of `` + servlet request . class . get name ( ) ) ; } if ( wrapped type . be assignable from ( request . get class ( ) ) ) { return true ; } else if ( request instanceof servlet request wrapper ) { return ( ( servlet request wrapper ) request ) . be wrapper for ( wrapped type ) ; } else { return false ; } }
public void set content type ( string type ) { this . response . set content type ( type ) ; }
public int get buffer size ( ) { return this . response . get buff size ( ) ; }
public list < string > get prefer subprotocols ( ) { return this . preferred subprotocols ; }
public void on error ( session session , throwable thr ) { }
public session get session ( ) { return this . session ; }
public void set xml decl ( boolean _write xml decl ) { this . write xml decl = _write xml decl ; }
public j a x b context create context ( class < ? > [ ] class to be bind , map < string , ? > property ) throw j a x b exception { return context factory . create context ( class to be bind , ( map < string , object > ) property ) ; }
public final q name get xml name ( ) { return xml name ; }
public final boolean be immutable ( ) { return ( flag & flag_is_immutable ) ! =0 ; }
public final void write ( u t f8 xml output out ) throw i o exception { out . write ( buf,0 , len ) ; }
public void finish ( ) throw accessor exception { if ( have start ( ) ) { lister . end packing ( pack , bean , acc ) ; reset ( ) ; } assert clean ( ) ; }
public string get prefix ( ) { string qname = get qname ( ) ; int idx = qname . index of ( ' : ' ) ; if ( idx < 0 ) return `` `` ; else return qname . substring ( 0 , idx ) ; }
public object create instance ( class < ? > clazz ) throw s a x exception { if ( ! factory . be empty ( ) ) { factory factory = factory . get ( clazz ) ; if ( factory ! =null ) return factory . create instance ( ) ; } return class factory . create ( clazz ) ; }
public void record inner peer ( object inner peer ) { if ( assoc ! =null ) assoc . add inner ( current element , inner peer ) ; }
public static void check spec ( ) { }
public e peek ( ) { return ( e ) data [ size-1 ] ; }
public static s a x parser factory create parser factory ( boolean disable secure processing ) throw illegal state exception { try { s a x parser factory factory = s a x parser factory . new instance ( ) ; if ( logger . be loggable ( level . fine ) ) { logger . log ( level . fine , `` s a x parser factory instance : { 0 } `` , factory ) ; } factory . set namespace aware ( true ) ; factory . set feature ( x m l constant . feature_secure_processing , ! be x m l security disable ( disable secure processing ) ) ; return factory ; } catch ( parser configuration exception ex ) { logger . log ( level . severe , null , ex ) ; throw new illegal state exception ( ex ) ; } catch ( s a x not recognize exception ex ) { logger . log ( level . severe , null , ex ) ; throw new illegal state exception ( ex ) ; } catch ( s a x not support exception ex ) { logger . log ( level . severe , null , ex ) ; throw new illegal state exception ( ex ) ; } catch ( abstract method error er ) { logger . log ( level . severe , null , er ) ; throw new illegal state exception ( message . invalid_jaxp_implementation . format ( ) , er ) ; } }
public object evaluate ( object context ) throw jaxen exception { list answer = select node ( context ) ; if ( answer ! = null & & answer . size ( ) == 1 ) { object first = answer . get ( 0 ) ; if ( first instanceof string || first instanceof number || first instanceof boolean ) { return first ; } } return answer ; }
public context support get context support ( ) { return this . context support ; }
public object get feature ( string feature , string version ) { return null ; }
public object set user data ( string key , object data , user data handler handler ) { object old value = get user data ( key ) ; user data . put ( key , data ) ; return old value ; }
public boolean be match any name ( ) { return match any name ; }
public string get text ( ) { string buffer buf = new string buffer ( 64 ) ; buf . append ( get axis name ( ) ) . append ( `` : : `` ) ; if ( get prefix ( ) ! = null & & get prefix ( ) . length ( ) > 0 ) { buf . append ( get prefix ( ) ) . append ( ' : ' ) ; } return buf . append ( get local name ( ) ) . append ( super . get text ( ) ) . to string ( ) ; }
protect locale get locale ( object value , navigator navigator ) { if ( value instanceof locale ) { return ( locale ) value ; } else if ( value instanceof list ) { list list = ( list ) value ; if ( ! list . be empty ( ) ) { return get locale ( list . get ( 0 ) , navigator ) ; } } else { string text = string function . evaluate ( value , navigator ) ; if ( text ! = null & & text . length ( ) > 0 ) { return find locale ( text ) ; } } return null ; }
protect locale find locale ( string locale text ) { string tokenizer token = new string tokenizer ( locale text , `` - `` ) ; if ( token . have more token ( ) ) { string language = token . next token ( ) ; if ( ! token . have more token ( ) ) { return find locale for language ( language ) ; } else { string country = token . next token ( ) ; if ( ! token . have more token ( ) ) { return new locale ( language , country ) ; } else { string variant = token . next token ( ) ; return new locale ( language , country , variant ) ; } } } return null ; }
public static double evaluate ( object obj , navigator nav ) { if ( obj instanceof double ) { return ( double ) obj ; } else if ( obj instanceof string ) { string str = ( string ) obj ; try { double double value = new double ( str ) ; return double value ; } catch ( number format exception e ) { return na n ; } } else if ( obj instanceof list || obj instanceof iterator ) { return evaluate ( string function . evaluate ( obj , nav ) , nav ) ; } else if ( nav . be element ( obj ) || nav . be attribute ( obj ) || nav . be text ( obj ) || nav . be comment ( obj ) || nav . be process instruction ( obj ) || nav . be document ( obj ) || nav . be namespace ( obj ) ) { return evaluate ( string function . evaluate ( obj , nav ) , nav ) ; } else if ( obj instanceof boolean ) { if ( boolean . true . equal ( obj ) ) { return new double ( 1 ) ; } else { return new double ( 0 ) ; } } return na n ; }
protect string get u r i ( object node , context context ) { string uri = context . get navigator ( ) . translate namespace prefix to uri ( prefix , node ) ; if ( uri == null ) { uri = context . get context support ( ) . translate namespace prefix to uri ( prefix ) ; } if ( uri == null ) { uri = `` `` ; } return uri ; }
public string get x path ( ) { return this . xpath ; }
public boolean have next ( ) { return ( this . next obj ! = null ) ; }
public int get position ( ) { return this . position ; }
public void set link exception ( exception ex ) { link exception = ex ; }
public void set hint ( string hint name , serializable value ) { hint . put ( hint name , value ) ; }
public void work reject ( work event e ) { }
public void error ( object message , object [ ] params , throwable t ) { do log ( level . error , fqcn , message , params , t ) ; }
public void log ( level level , string logger fqcn , object message , throwable t ) { do log ( level , logger fqcn , message , null , t ) ; }
protect final object write replace ( ) { return new serialize logger ( name ) ; }
protect void do publish ( final ext log record record ) { if ( auto flush ) flush ( ) ; }
public void render ( final string builder builder , final ext log record record ) { }
public static format step exception format step ( final boolean leave justify , final int minimum width , final int maximum width , final boolean extend ) { return exception format step ( left justify , minimum width , default_truncate_beginning , maximum width , null ) ; }
public static format step ndc format step ( final boolean leave justify , final int minimum width , final int maximum width ) { return ndc format step ( left justify , minimum width , default_truncate_beginning , maximum width , 0 ) ; }
public format step [ ] get step ( ) { return step . clone ( ) ; }
public static flushable closeable wrap ( final handler handler ) { return handler instanceof flushable closeable ? ( flushable closeable ) handler : new flushable closeable ( ) { public void close ( ) { handler . close ( ) ; } public void flush ( ) { handler . flush ( ) ; } } ; }
public string get encode ( ) { synchronize ( output lock ) { return super . get encode ( ) ; } }
public void set limit ( final int limit ) { if ( limit < 1 ) { throw bad queue length ( ) ; } synchronize ( buffer ) { this . limit = limit ; } }
public void set suffix ( final string suffix ) { synchronize ( output lock ) { this . suffix rotator = suffix rotator . parse ( suffix ) ; } }
public protocol get protocol ( ) { return protocol ; }
public void set facility ( final facility facility ) { synchronize ( output lock ) { this . facility = facility ; } }
public void set server hostname ( final string hostname ) throw unknown host exception { set server address ( inet address . get by name ( hostname ) ) ; }
public logger get logger if exists ( string name ) { final logger node node = root logger . get if exists ( name ) ; return node == null ? null : node . create logger ( ) ; }
public static log context get instance ( ) { return instance ; }
public static void clear ( ) { mdc . get ( ) . clear ( ) ; }
public static void trim to ( int size ) { ndc . get ( ) . trim to ( size ) ; }
public void execute ( final runnable command ) { delegate . execute ( command ) ; }
public boolean prestart core thread ( ) { if ( try allocate thread ( 1 . 0f ) ! = at_yes ) return false ; if ( do start thread ( null ) ) return true ; deallocate thread ( ) ; return false ; }
public thread . uncaught exception handler get exception handler ( ) { return exception handler ; }
public void set termination task ( final runnable termination task ) { this . termination task = termination task ; }
public int get large queue size ( ) { return update_statistics & & ! no_queue_limit ? peak queue size : -1 ; }
public thread [ ] get run thread ( ) { return run thread . to array ( no_threads ) ; }
public static executor reject executor ( ) { return reject executor . instance ; }
public static string get jar name ( ) { return jar_name ; }
protect void init delegate ( ) { if ( transaction manager instanceof transaction local delegate ) delegate = ( transaction local delegate ) transaction manager ; else delegate = new transaction local delegate impl ( transaction manager ) ; }
public transaction manager get transaction manager ( ) { return locate ( ) ; }
public void remove listener ( user transaction listener listener ) { if ( listener == null ) throw new illegal argument exception ( `` null listener `` ) ; listener . remove ( listener ) ; log . debug ( this + `` remove listener `` + listener ) ; }
public synchronize connection connect ( string url , final property info ) throw s q l exception { / * the driver should return `` null `` if it realize it be the wrong kind of driver to connect to the give url . * / if ( ! accepts u r l ( url ) ) { return null ; } connection url connection url = connection url . new instance ( url ) ; synchronize ( jdbc url container cache ) { string query string = connection url . get query string ( ) . or else ( `` `` ) ; / * if we already have a running container for this exact connection string , we want to connect to that rather than create a new container * / jdbc database container container = jdbc url container cache . get ( connection url . get url ( ) ) ; if ( container == null ) { logger . debug ( `` container not find in cache , create new instance `` ) ; map < string , string > parameter = connection url . get container parameter ( ) ; / * find a matching container type use service loader . * / service loader < jdbc database container provider > database container = service loader . load ( jdbc database container provider . class ) ; for ( jdbc database container provider candidate container type : database container ) { if ( candidate container type . support ( connection url . get database type ( ) ) ) { container = candidate container type . new instance ( connection url ) ; container . with tmp f ( connection url . get tmpfs option ( ) ) ; delegate = container . get jdbc driver instance ( ) ; } } if ( container == null ) { throw new unsupported operation exception ( `` database name `` + connection url . get database type ( ) + `` not support `` ) ; } / * cache the container before start to prevent race condition when a connection pool be start up * / jdbc url container cache . put ( url , container ) ; / * pas possible container-specific parameter * / container . set parameter ( parameter ) ; / * start the container * / container . start ( ) ; } / * create a connection use the delegate driver . the container must be ready to accept connection . * / connection connection = container . create connection ( query string ) ; / * if this container have not be initialize , and an init script or function have be specify , use it * / if ( ! initialize container . contains ( container . get container id ( ) ) ) { database delegate database delegate = new jdbc database delegate ( container , query string ) ; run init script if require ( connection url , database delegate ) ; run init function if require ( connection url , connection ) ; initialize container . add ( container . get container id ( ) ) ; } return wrap connection ( connection , container , connection url ) ; } }
public int get attribute type ( ) { return type ; }
public final int hash code ( ) { return super . hash code ( ) ; }
public string to string ( ) { return new string buffer ( 64 ) . append ( `` [ cdata : `` ) . append ( get text ( ) ) . append ( `` ] `` ) . to string ( ) ; }
public object get property ( string id ) { if ( property map == null ) return null ; return property map . get ( id ) ; }
public boolean have root element ( ) { return ( content . index of first element ( ) < 0 ) ? false : true ; }
public document set content ( int index , collection collection ) { content . remove ( index ) ; content . add all ( index , collection ) ; return this ; }
public element add content ( string str ) { return add content ( new text ( str ) ) ; }
public void set element content ( ) { filter mask = element | cdata | text | comment | pi | entityref ; }
public void set entity ref visible ( boolean visible ) { if ( visible ) { filter mask |= entityref ; } else { filter mask & = ~entityref ; } }
public org . jdom . element build ( org . w3c . dom . element dom element ) { document doc = factory . document ( null ) ; build tree ( dom element , doc , null , true ) ; return doc . get root element ( ) ; }
public void set factory ( j d o m factory factory ) { this . factory = factory ; }
public document build ( string system id ) throw j d o m exception , i o exception { return build ( new input source ( system id ) ) ; }
public string get driver class ( ) { return sax driver class ; }
public boolean get reuse parser ( ) { return reuse parser ; }
public void set ignore element content whitespace ( boolean ignore white ) { this . ignore white = ignore white ; }
public throwable get cause ( ) { return cause ; }
public string get u r i ( ) { return uri ; }
public static format get pretty format ( ) { format f = new format ( ) ; f . set indent ( standard_indent ) ; f . set text mode ( text mode . trim ) ; return f ; }
public format set omit declaration ( boolean omit declaration ) { this . omit declaration = omit declaration ; return this ; }
public object get node ( ) { return this . node ; }
public decl handler get decl handler ( ) { return this . decl handler ; }
public void set report d t d event ( boolean report dtd event ) { this . report dtd event = report dtd event ; }
public boolean remove pseudo attribute ( string name ) { if ( ( map data . remove ( name ) ) ! = null ) { raw data = to string ( map data ) ; return true ; } return false ; }
public string to string ( ) { return new string buffer ( ) . append ( `` [ process instruction : `` ) . append ( new org . jdom . output . x m l outputter ( ) . output string ( this ) ) . append ( `` ] `` ) . to string ( ) ; }
public string get text normalize ( ) { return normalize string ( get text ( ) ) ; }
public j d o m factory get factory ( ) { return this . factory ; }
public list get node ( ) { object src = ( ( j d o m input source ) get input source ( ) ) . get source ( ) ; list node = null ; if ( src instanceof list ) { node = ( list ) src ; } return node ; }
public void set input source ( input source input source ) throw unsupported operation exception { throw new unsupported operation exception ( ) ; }
public list transform ( list input node ) throw x s l transform exception { j d o m source source = new j d o m source ( input node ) ; j d o m result result = new j d o m result ( ) ; try { template . new transformer ( ) . transform ( source , result ) ; return result . get result ( ) ; } catch ( transformer exception e ) { throw new x s l transform exception ( `` could not perform transformation `` , e ) ; } }
public document transform ( document input doc ) throw x s l transform exception { j d o m source source = new j d o m source ( input doc ) ; j d o m result result = new j d o m result ( ) ; try { template . new transformer ( ) . transform ( source , result ) ; return result . get document ( ) ; } catch ( transformer exception e ) { throw new x s l transform exception ( `` could not perform transformation `` , e ) ; } }
public static boolean be x m l name character ( char c ) { return ( be x m l letter ( c ) || be x m l digit ( c ) || c == ' . ' || c == '- ' || c == ' _ ' || c == ' : ' || be x m l combine char ( c ) || be x m l extender ( c ) ) ; }
public number number value of ( object context ) throw j d o m exception { try { current context = context ; return x path . number value of ( context ) ; } catch ( jaxen exception ex1 ) { throw new j d o m exception ( `` x path error while evaluate \ `` `` + x path . to string ( ) + `` \ `` : `` + ex1 . get message ( ) , ex1 ) ; } finally { current context = null ; } }
public void set variable ( string name , object value ) throw illegal argument exception { object o = x path . get variable context ( ) ; if ( o instanceof simple variable context ) { ( ( simple variable context ) o ) . set variable value ( null , name , value ) ; } }
public element set attribute ( final collection new attribute ) { attribute . clear and set ( new attribute ) ; return this ; }
public void set amd ( string amd ) { set text property ( prefix+ `` : amd `` , amd ) ; }
public string get instance i d ( ) { return x m l util . get string value ( parent , `` st evt : instance i d `` ) ; }
public string get manager variant ( ) { return x m l util . get string value ( parent , `` st ref : manager variant `` ) ; }
public string get document i d ( ) { return x m l util . get string value ( parent , `` st ref : document i d `` ) ; }
public void set image ( string image ) { x m l util . set string value ( parent , `` xap g img : image `` , image ) ; }
public x m p schema medium management add medium management schema ( ) { x m p schema medium management schema = new x m p schema medium management ( this ) ; return ( x m p schema medium management ) basic add schema ( schema ) ; }
public void add schema ( x m p schema schema ) { element rdf = get r d f element ( ) ; rdf . append child ( schema . get element ( ) ) ; }
public document get x m p document ( ) { return xmp document ; }
protect x m p schema basic add schema ( x m p schema schema ) { element rdf = get r d f element ( ) ; rdf . append child ( schema . get element ( ) ) ; return schema ; }
public x m p schema basic add basic schema ( ) { x m p schema basic schema = new x m p schema basic ( this ) ; return ( x m p schema basic ) basic add schema ( schema ) ; }
public static x m p metadata load ( input source be ) throw i o exception { return new x m p metadata ( x m l util . parse ( be ) ) ; }
public list < string > get sequence list ( string seq name ) { list < string > retval = null ; node list node = schema . get element by tag name ( seq name ) ; if ( node . get length ( ) > 0 ) { element contributor = ( element ) node . item ( 0 ) ; node list bag list = contributor . get element by tag name ( `` rdf : seq `` ) ; if ( bag list . get length ( ) > 0 ) { element bag = ( element ) bag list . item ( 0 ) ; retval = new array list < string > ( ) ; node list item = bag . get element by tag name ( `` rdf : li `` ) ; for ( int i = 0 ; i < item . get length ( ) ; i++ ) { element li = ( element ) item . item ( i ) ; retval . add ( x m l util . get string value ( li ) ) ; } retval = collection . unmodifiable list ( retval ) ; } } return retval ; }
public void remove advisory ( string advisory ) { remove bag value ( prefix + `` : advisory `` , advisory ) ; }
public list < string > get advisory ( ) { return get bag list ( prefix + `` : advisory `` ) ; }
public void set metadata date ( calendar date ) { set date property ( prefix + `` : metadata date `` , date ) ; }
public calendar get modify date ( ) throw i o exception { return get date property ( prefix + `` : modify date `` ) ; }
public thumbnail get thumbnail ( ) { return get thumbnail property ( prefix + `` : thumbnail `` , null ) ; }
public list < string > get thumbnail language ( ) { return get language property language ( prefix + `` : thumbnails `` ) ; }
public void set description ( string description ) { set language property ( prefix + `` : description `` , null , description ) ; }
public void remove language ( string language ) { remove bag value ( prefix + `` : language `` , language ) ; }
public list < string > get relationship ( ) { return get bag list ( prefix + `` : relation `` ) ; }
public string get right ( ) { return get language property ( prefix + `` : right `` , null ) ; }
public void remove subject ( string subject ) { remove bag value ( prefix + `` : subject `` , subject ) ; }
public list < string > get subject ( ) { return get bag list ( prefix + `` : subject `` ) ; }
public void set title ( string title ) { set language property ( prefix + `` : title `` , null , title ) ; }
public string get title ( ) { return get language property ( prefix + `` : title `` , null ) ; }
public void set ci adr extadr ( string adr ) { set text property ( prefix + `` : ci adr extadr `` , adr ) ; }
public void set document i d ( string id ) { set text property ( prefix + `` : document i d `` , id ) ; }
public void remove history ( resource event event ) { remove sequence value ( prefix + `` : history `` , event ) ; }
public string get keywords ( ) { return get text property ( prefix + `` : keywords `` ) ; }
public void remove supplemental category ( string s ) { remove bag value ( prefix + `` : supplemental category `` , s ) ; }
public void remove owner ( string owner ) { remove bag value ( prefix + `` : owner `` , owner ) ; }
public void set description ( string language , string term ) { set language property ( prefix + `` : usage term `` , language , term ) ; }
protect sync invoker get sync invoker ( ) { return sync invoker ; }
public iterable < reader interceptor > get reader interceptor ( ) { return reader interceptor ; }
public static string redirect_infinite_loop ( ) { return localizer . localize ( localizable r e d i r e c t_ i n f i n i t e_ l o o p ( ) ) ; }
public static string closed_by_client_while_receiving_body ( ) { return localizer . localize ( localizable c l o s e d_ b y_ c l i e n t_ w h i l e_ r e c e i v i n g_ b o d y ( ) ) ; }
public static string http_connection_establishing_illegal_state ( object arg0 ) { return localizer . localize ( localizable h t t p_ c o n n e c t i o n_ e s t a b l i s h i n g_ i l l e g a l_ s t a t e ( arg0 ) ) ; }
public static string http_packet_header_overflow ( ) { return localizer . localize ( localizable h t t p_ p a c k e t_ h e a d e r_ o v e r f l o w ( ) ) ; }
public static string proxy_connect_fail ( object arg0 ) { return localizer . localize ( localizable p r o x y_ c o n n e c t_ f a i l ( arg0 ) ) ; }
public static string unexpected_data_in_buffer ( ) { return localizer . localize ( localizable u n e x p e c t e d_ d a t a_ i n_ b u f f e r ( ) ) ; }
public static string error_listener_init ( object arg0 ) { return localizer . localize ( localizable e r r o r_ l i s t e n e r_ i n i t ( arg0 ) ) ; }
public static string error_service_locator_provider_instance_request ( object arg0 ) { return localizer . localize ( localizable e r r o r_ s e r v i c e_ l o c a t o r_ p r o v i d e r_ i n s t a n c e_ r e q u e s t ( arg0 ) ) ; }
public static string null_truststore ( ) { return localizer . localize ( localizable n u l l_ t r u s t s t o r e ( ) ) ; }
public static string client_uri_null ( ) { return localizer . localize ( localizable c l i e n t_ u r i_ n u l l ( ) ) ; }
public void set response medium type if not set ( final response response , configuration configuration ) { if ( response . have entity ( ) & & response . get medium type ( ) == null ) { final inbound message context header context = new inbound message context ( configuration ) { @ override protect iterable < reader interceptor > get reader interceptor ( ) { return null ; } } ; header context . header ( header utils . a string header ( response . get header ( ) , configuration ) ) ; final medium type medium type = determine response medium type ( response . get entity ( ) , header context . get qualified acceptable medium type ( ) ) ; response . get header ( ) . add ( http header . content_type , medium type ) ; } }
public static void fatal ( final object source , final string message ) { error ( source , message , severity . fatal ) ; }
public static boolean fatal issue find ( ) { for ( final error message message : get instance ( ) . issue ) { if ( message . get severity ( ) == severity . fatal ) { return true ; } } return false ; }
public static void process ( final runnable task ) { process ( new producer < void > ( ) { @ override public void call ( ) { task . run ( ) ; return null ; } } , false ) ; }
public boolean set exception ( throwable throwable ) { return super . set exception ( throwable ) ; }
public binding bind ( bind binding ) { internal binding . add ( bind ) ; return binding ; }
public < t extend injection resolver > injection resolver bind < t > bind ( t resolver ) { injection resolver bind < t > binding = binding . injection resolver ( resolver ) ; internal binding . add ( bind ) ; return binding ; }
public string get analyzer ( ) { return analyzer ; }
public void rank ( int rank ) { this . rank = rank ; }
public void set injectee descriptor ( foreign descriptor injectee descriptor ) { this . injectee descriptor = injectee descriptor ; }
public void bind instance ( final iterable < object > instance ) { list < object > instance list = new array list < > ( ) ; instance . for each ( instance list : : add ) ; bind instance ( instance list ) ; }
public static string errors_and_warnings_detected ( object arg0 ) { return localizer . localize ( localizable e r r o r s_ a n d_ w a r n i n g s_ d e t e c t e d ( arg0 ) ) ; }
public static string uri_component_encoded_octet_malformed ( object arg0 ) { return localizer . localize ( localizable u r i_ c o m p o n e n t_ e n c o d e d_ o c t e t_ m a l f o r m e d ( arg0 ) ) ; }
public static string error_template_parser_illegal_char_start_name ( object arg0 , object arg1 , object arg2 ) { return localizer . localize ( localizable e r r o r_ t e m p l a t e_ p a r s e r_ i l l e g a l_ c h a r_ s t a r t_ n a m e ( arg0 , arg1 , arg2 ) ) ; }
public static string error_reading_entity_from_input_stream ( ) { return localizer . localize ( localizable e r r o r_ r e a d i n g_ e n t i t y_ f r o m_ i n p u t_ s t r e a m ( ) ) ; }
public static string feature_constrained_to_ignored ( object arg0 , object arg1 , object arg2 ) { return localizer . localize ( localizable f e a t u r e_ c o n s t r a i n e d_ t o_ i g n o r e d ( arg0 , arg1 , arg2 ) ) ; }
public static string injection_error_nonstatic_member_class_not_supported ( object arg0 ) { return localizer . localize ( localizable i n j e c t i o n_ e r r o r_ n o n s t a t i c_ m e m b e r_ c l a s s_ n o t_ s u p p o r t e d ( arg0 ) ) ; }
public static string too_many_header_values ( object arg0 , object arg1 ) { return localizer . localize ( localizable t o o_ m a n y_ h e a d e r_ v a l u e s ( arg0 , arg1 ) ) ; }
public static string error_interceptor_writer_proceed ( ) { return localizer . localize ( localizable e r r o r_ i n t e r c e p t o r_ w r i t e r_ p r o c e e d ( ) ) ; }
public static string http_header_no_chars_between_separators ( object arg0 , object arg1 ) { return localizer . localize ( localizable h t t p_ h e a d e r_ n o_ c h a r s_ b e t w e e n_ s e p a r a t o r s ( arg0 , arg1 ) ) ; }
public static string mbr_trying_to_close_stream ( object arg0 ) { return localizer . localize ( localizable m b r_ t r y i n g_ t o_ c l o s e_ s t r e a m ( arg0 ) ) ; }
public static string injection_error_suitable_constructor_not_found ( object arg0 ) { return localizer . localize ( localizable i n j e c t i o n_ e r r o r_ s u i t a b l e_ c o n s t r u c t o r_ n o t_ f o u n d ( arg0 ) ) ; }
public method rout get method routing ( ) { return method routing ; }
public static < t > service finder < t > find ( final class < t > service , final class loader loader ) throw service configuration error { return find ( service , loader , false ) ; }
public static service finder < ? > find ( final string service name ) throw service configuration error { return new service finder < object > ( object . class , service name , _get context class loader ( ) , false ) ; }
public string unit test ( ) { return common ( ) + `` unit test `` ; }
public static class type pair of ( class < ? > raw class ) { return new class type pair ( raw class , raw class ) ; }
public static < e > set < e > set diff view ( final set < ? extend e > set1 , final set < ? extend e > set2 ) { check not null ( set1 , `` set1 `` ) ; check not null ( set2 , `` set2 `` ) ; return new abstract set < e > ( ) { @ override public iterator < e > iterator ( ) { return get diff ( set1 , set2 ) . iterator ( ) ; } @ override public int size ( ) { return get diff ( set1 , set2 ) . size ( ) ; } private set < e > get diff ( set < ? extend e > set1 , set < ? extend e > set2 ) { hash set < e > hash set = new hash set < > ( ) ; hash set . add all ( set1 ) ; hash set . add all ( set2 ) ; return hash set . stream ( ) . filter ( new predicate < e > ( ) { @ override public boolean test ( e e ) { return set1 . contains ( e ) & & ! set2 . contains ( e ) ; } } ) . collect ( collector . to set ( ) ) ; } } ; }
public static string collection ( collection < ? > collection ) { if ( collection == null ) { return null_string ; } return array ( collection . to array ( new object [ collection . size ( ) ] ) ) ; }
public static < t > t get value ( map < string , ? > property , string key , class < t > type , map < string , string > legacy map ) { return get value ( property , null , key , type , legacy map ) ; }
public static list < class < ? > > get generic type argument class ( final type type ) throw illegal argument exception { final type [ ] type = get type argument ( type ) ; if ( type == null ) { return collection . empty list ( ) ; } return array . stream ( type ) . map ( ( function < type , class < ? > > ) reflection helper : : erasure ) . collect ( collector . to list ( ) ) ; }
public static declare class interface pair get class ( final class < ? > concrete , final class < ? > iface ) { return get class ( concrete , iface , concrete ) ; }
public static string [ ] tokenize ( final string entry , final string delimiters ) { final collection < string > token = tokenize ( entry , delimiters , new link list < string > ( ) ) ; return token . to array ( new string [ token . size ( ) ] ) ; }
public static string read from a string ( input stream in , medium type type ) throw i o exception { return reader writer . read from a string ( in , type ) ; }
public date get date ( ) { return single header ( http header . date , new function < string , date > ( ) { @ override public date apply ( string input ) { try { return http header reader . read date ( input ) ; } catch ( parse exception ex ) { throw new process exception ( ex ) ; } } } , false ) ; }
public void close ( ) { entity content . close ( true ) ; }
public static matching entity tag value of ( http header reader reader ) throw parse exception { final char sequence tag string = reader . get remainder ( ) ; http header reader . event e = reader . next ( false ) ; if ( e == http header reader . event . quote string ) { return new match entity tag ( reader . get event value ( ) . to string ( ) ) ; } else if ( e == http header reader . event . token ) { char sequence ev = reader . get event value ( ) ; if ( ev ! = null & & ev . length ( ) == 1 & & ' w ' == ev . char at ( 0 ) ) { reader . next separator ( '/ ' ) ; return new match entity tag ( reader . next quoted string ( ) . to string ( ) , true ) ; } } throw new parse exception ( localization message . error_parsing_entity_tag ( tag string ) , reader . get index ( ) ) ; }
public void set entity annotation ( annotation [ ] annotation ) { this . entity annotation = ( annotation == null ) ? empty_annotations : annotation ; }
public int get quality ( ) { return q ; }
public component bag immutable copy ( ) { return new immutable component bag ( this ) ; }
public request context reference current ( ) throw illegal state exception { return current ( ) . get reference ( ) ; }
public static < data > data process ( data data , stage < data > root stage ) { stage . continuation < data > continuation = stage . continuation . of ( data , root stage ) ; stage < data > current stage ; while ( ( current stage = continuation . next ( ) ) ! = null ) { continuation = current stage . apply ( continuation . result ( ) ) ; } return continuation . result ( ) ; }
public char current ( ) { if ( pos == -1 ) { throw new illegal state exception ( `` iterator not use yet . `` ) ; } return s . char at ( po ) ; }
public final int get number of template variable ( ) { return template variable . size ( ) ; }
public final boolean equal ( object o ) { if ( o instanceof uri template ) { uri template that = ( uri template ) o ; return this . pattern . equal ( that . pattern ) ; } else { return false ; } }
public date get read date ( ) { return read date ; }
public static boolean be token string ( string s ) { for ( char c : s . to char array ( ) ) { if ( ! be token ( c ) ) { return false ; } } return true ; }
public static list < medium type > create medium type ( string [ ] medium type ) { list < medium type > l = new array list < medium type > ( ) ; try { for ( string medium type : medium type ) { http header reader . read medium type ( l , medium type ) ; } collection . sort ( l , media_type_comparator ) ; return l ; } catch ( parse exception ex ) { throw new illegal argument exception ( ex ) ; } }
public static void set accessible method ( final method m ) { if ( modifier . be public ( m . get modifier ( ) ) ) return ; access controller . do privilege ( new privilege action < object > ( ) { public object run ( ) { if ( ! m . be accessible ( ) ) { m . set accessible ( true ) ; } return m ; } } ) ; }
public static type [ ] get parameterized type argument ( declare class interface pair p ) { if ( p . generic interface instanceof parameterized type ) { parameterized type pt = ( parameterized type ) p . generic interface ; type [ ] a = pt . get actual type argument ( ) ; type [ ] ras = new type [ a . length ] ; for ( int i = 0 ; i < a . length ; i++ ) { type a = a [ i ] ; if ( a instanceof class ) { ras [ i ] = a ; } else if ( a instanceof parameterized type ) { pt = ( parameterized type ) a ; ras [ i ] = a ; } else if ( a instanceof type variable ) { class type pair ctp = resolve type variable ( p . concrete class , p . declare class , ( type variable ) a ) ; ra [ i ] = ctp . t ; } } return ra ; } else { return null ; } }
public static string error_no_sub_res_method_locator_found ( object arg0 ) { return localizer . localize ( localizable e r r o r_ n o_ s u b_ r e s_ m e t h o d_ l o c a t o r_ f o u n d ( arg0 ) ) ; }
public static string error_processing_method ( object arg0 , object arg1 ) { return localizer . localize ( localizable e r r o r_ p r o c e s s i n g_ m e t h o d ( arg0 , arg1 ) ) ; }
public static string error_marshalling_jaxb ( object arg0 ) { return localizer . localize ( localizable e r r o r_ m a r s h a l l i n g_ j a x b ( arg0 ) ) ; }
public string get domain ( ) { return domain ; }
public string get path ( ) { return path ; }
public int hash code ( ) { int hash = 7 ; hash = 97 * hash + ( this . name ! = null ? this . name . hash code ( ) : 0 ) ; hash = 97 * hash + ( this . value ! = null ? this . value . hash code ( ) : 0 ) ; hash = 97 * hash + this . version ; hash = 97 * hash + ( this . path ! = null ? this . path . hash code ( ) : 0 ) ; hash = 97 * hash + ( this . domain ! = null ? this . domain . hash code ( ) : 0 ) ; return hash ; }
public string get value ( ) { return value ; }
public int hash code ( ) { return ( this . type . to lower case ( ) +this . subtype . to lower case ( ) ) . hash code ( ) +this . parameter . hash code ( ) ; }
protect string subgraph identifier ( final class < ? > parent , final string field , final class < ? > field class ) { return parent . get name ( ) + `` _ `` + field + `` _ `` + field class . get name ( ) ; }
public static class < ? > get entity class ( final type generic type ) { if ( ! entity_classes . contains key ( generic type ) ) { entity_classes . put if absent ( generic type , _get entity class ( generic type ) ) ; } return entity_classes . get ( generic type ) ; }
public static set < string > get default filter scope ( ) { return collection . singleton ( scope provider . default_scope ) ; }
protect boolean have match medium type for reading ( medium type medium type ) { return have match medium type ( medium type ) ; }
protect void introspect ( object o , object meta info ) { if ( o == null ) return ; _introspector . introspect ( o , meta info ) ; }
public boolean be env entry type ( class < ? > clazz ) { return env_entry_types . contains ( clazz ) ; }
public boolean add c s v ( http header header , string . . . value ) { quote c s v exist = null ; for ( int i = 0 ; i < _size ; i++ ) { http field f = _fields [ i ] ; if ( f . get header ( ) == header ) { if ( exist == null ) exist = new quote c s v ( false ) ; exist . add value ( f . get value ( ) ) ; } } string value = add c s v ( exist , value ) ; if ( value ! = null ) { add ( header , value ) ; return true ; } return false ; }
public enumeration < string > get value ( final string name ) { for ( int i = 0 ; i < _size ; i++ ) { final http field f = _fields [ i ] ; if ( f . get name ( ) . equal ignore case ( name ) & & f . get value ( ) ! = null ) { final int first = i ; return new enumeration < string > ( ) { http field field = f ; int i = first + 1 ; @ override public boolean have more element ( ) { if ( field == null ) { while ( i < _size ) { field = _fields [ i++ ] ; if ( field . get name ( ) . equal ignore case ( name ) & & field . get value ( ) ! = null ) return true ; } field = null ; return false ; } return true ; } @ override public string next element ( ) throw no such element exception { if ( have more element ( ) ) { string value = field . get value ( ) ; field = null ; return value ; } throw new no such element exception ( ) ; } } ; } } list < string > empty = collection . empty list ( ) ; return collection . enumeration ( empty ) ; }
public void put date field ( http header name , long date ) { string d = date generator . format date ( date ) ; put ( name , d ) ; }
public byte buffer take byte buffer ( ) { return _accumulator . take byte buffer ( ) ; }
public void set reuse port ( boolean reuse port ) { this . reuse port = reuse port ; }
public socket address receive ( byte buffer buffer ) throw i o exception { if ( be input shutdown ( ) ) return eof ; int po = buffer util . flip to fill ( buffer ) ; socket address peer = get channel ( ) . receive ( buffer ) ; buffer util . flip to flush ( buffer , po ) ; if ( peer == null ) return null ; not idle ( ) ; int fill = buffer . remain ( ) ; if ( log . be debug enable ( ) ) log . debug ( `` fill { } { } `` , fill , buffer util . to detail string ( buffer ) ) ; return peer ; }
public default void init ( ) { }
default public void init ( filter config filter config ) throw servlet exception { }
public void log ( string message , throwable t ) { get servlet context ( ) . log ( get servlet name ( ) + `` : `` + message , t ) ; }
protect long get last modify ( http servlet request req ) { return -1 ; }
public http servlet map get http servlet mapping ( ) { return this . _get http servlet request ( ) . get http servlet mapping ( ) ; }
default public void session will passivate ( http session event se ) { }
default public void attribute remove ( servlet request attribute event srae ) { }
public string to string ( ) { return ( this . reason phrase == null ) ? `` close reason [ `` + this . close code . get code ( ) + `` ] `` : `` close reason [ `` + this . close code . get code ( ) + `` , `` + reason phrase + `` ] `` ; }
public list < class < ? extend encoder > > get encoders ( ) { return this . encoders ; }
public long get max input buffer size ( ) { return max input buffer size ; }
public void insert handler ( handler wrapper wrapper ) { if ( wrapper == null ) throw new illegal argument exception ( ) ; handler wrapper tail = wrapper ; while ( tail . get handler ( ) instanceof handler wrapper ) { tail = ( handler wrapper ) tail . get handler ( ) ; } if ( tail . get handler ( ) ! = null ) throw new illegal argument exception ( `` bad tail of inserted wrapper chain `` ) ; handler next = get handler ( ) ; set handler ( wrapper ) ; tail . set handler ( next ) ; }
public void set apply to async ( boolean apply to async ) { _apply to async = apply to async ; }
public void exclude ( string pattern ) { _set . exclude ( pattern tuple . from ( pattern ) ) ; }
protect boolean be allow ( inet address addr , request base request , http servlet request request ) { string connector name = base request . get http channel ( ) . get connector ( ) . get name ( ) ; string path = base request . get meta data ( ) . get u r i ( ) . get decoded path ( ) ; return _set . test ( new access tuple ( connector name , addr , path ) ) ; }
public void set server authority ( host port authority ) { if ( authority == null ) _server authority = null ; else if ( ! authority . have host ( ) ) throw new illegal state exception ( `` server authority must have host declare `` ) ; else _server authority = authority ; }
protect void next protocol ( connector connector , end point end point , byte buffer buffer ) { if ( log . be debug enable ( ) ) log . debug ( `` optional s s l tls detection unsuccessful , attempt to upgrade to { } `` , _next protocol ) ; if ( _next protocol ! = null ) { connection factory connection factory = connector . get connection factory ( _next protocol ) ; if ( connection factory == null ) throw new illegal state exception ( `` can not find protocol ' `` + _next protocol + `` ' in connector 's protocol list `` + connector . get protocol ( ) + `` for `` + end point ) ; upgrade to connection factory ( connection factory , connector , end point ) ; } else { other protocol ( buffer , end point ) ; } }
public void clean orphan ( long time limit ) { if ( ! be start ( ) ) throw new illegal state exception ( `` not start `` ) ; runnable r = ( ) - > { do clean orphan ( time limit ) ; } ; _context . run ( r ) ; }
public void set driver info ( string driver class name , string connection url ) { _driver class name = driver class name ; _connection url = connection url ; }
public void set reseed ( long reseed ) { _reseed = reseed ; }
public boolean get prefer proxied for address ( ) { return _prefer proxied for address ; }
public void add exclude method ( string . . . method ) { for ( string m : method ) { _methods . exclude ( m ) ; } }
public void add include path ( string . . . pathspecs ) { for ( string p : pathspecs ) { _paths . include ( string util . csv split ( p ) ) ; } }
public void set exclude method list ( string csv method ) { set exclude method ( string util . csv split ( csv method ) ) ; }
protect boolean be addr uri allow ( string addr , string path ) { if ( _white . size ( ) > 0 ) { boolean match = false ; boolean match by path = false ; for ( map . entry < string , i p address map < boolean > > entry : _white . get match ( path ) ) { match by path = true ; i p address map < boolean > addr map = entry . get value ( ) ; if ( ( addr map ! = null & & ( addr map . size ( ) == 0 || addr map . match ( addr ) ! = null ) ) ) { match = true ; break ; } } if ( _white list by path ) { if ( match by path & & ! match ) return false ; } else { if ( ! match ) return false ; } } if ( _black . size ( ) > 0 ) { for ( map . entry < string , i p address map < boolean > > entry : _black . get match ( path ) ) { i p address map < boolean > addr map = entry . get value ( ) ; if ( addr map ! = null & & ( addr map . size ( ) == 0 || addr map . match ( addr ) ! = null ) ) return false ; } } return true ; }
public void set request header size ( int request header size ) { _request header size = request header size ; }
public decorate object factory get object factory ( ) { return _obj factory ; }
protect filter chain new filter chain ( filter holder filter holder , filter chain chain ) { return new chain ( filter holder , chain ) ; }
public boolean compare and set ( long encode , int hi , int lo ) { long update = encode ( hi , lo ) ; return compare and set ( encoded , update ) ; }
public static void append ( byte buffer to , string s ) throw buffer overflow exception { byte [ ] b = s . get byte ( standard charsets . utf_8 ) ; append ( to , b , 0 , b . length ) ; }
public static byte buffer to buffer ( byte [ ] array , int offset , int length ) { if ( array == null ) return empty_buffer ; return byte buffer . wrap ( array , offset , length ) ; }
public static string to hex string ( byte buffer buffer ) { if ( buffer == null ) return `` null `` ; return type util . to hex string ( to array ( buffer ) ) ; }
public static int size ( object list ) { if ( list == null ) return 0 ; if ( list instanceof list ) return ( ( list < ? > ) list ) . size ( ) ; return 1 ; }
public string id ( t resource ) { return string . value of ( system . identity hash code ( resource ) ) ; }
public void add ( string name , v value ) { list < v > lo = get ( name ) ; if ( lo == null ) { lo = new array list < > ( ) ; } lo . add ( value ) ; super . put ( name , lo ) ; }
public path get alias path ( ) { return this . alias ; }
public void validate ( key store key store , certificate cert ) throw certificate exception { certificate [ ] cert chain = null ; if ( cert ! = null & & cert instanceof x509 certificate ) { ( ( x509 certificate ) cert ) . check validity ( ) ; string cert alias = null ; try { if ( key store == null ) { throw new invalid parameter exception ( `` keystore can not be null `` ) ; } cert alias = key store . get certificate alias ( ( x509 certificate ) cert ) ; if ( cert alias == null ) { cert alias = `` jetty `` + string . format ( `` % 016x `` , __alias count . increment and get ( ) ) ; key store . set certificate entry ( cert alias , cert ) ; } cert chain = key store . get certificate chain ( cert alias ) ; if ( cert chain == null || cert chain . length == 0 ) { throw new illegal state exception ( `` unable to retrieve certificate chain `` ) ; } } catch ( key store exception kse ) { log . debug ( `` unable to validate certificate `` , kse ) ; throw new certificate exception ( `` unable to validate certificate `` + ( cert alias == null ? `` `` : `` for alias [ `` + cert alias + `` ] `` ) + `` : `` + kse . get message ( ) , kse ) ; } validate ( cert chain ) ; } }
public x509 certificate [ ] get x509 cert chain ( s s l session ssl session ) { return get x509 cert chain ( this , ssl session ) ; }
public void set idle timeout ( int idle timeout ) { _idle timeout = idle timeout ; reserve thread executor reserve = get bean ( reserve thread executor . class ) ; if ( reserve ! = null ) reserve . set idle timeout ( idle timeout , time unit . millisecond ) ; }
public static shutdown thread get instance ( ) { return _thread ; }
public int get max usage count ( ) { return max usage count ; }
public collection < url > get tlds ( file dir ) throw i o exception { if ( dir == null || ! dir . be directory ( ) ) return collection . empty set ( ) ; hash set < url > tlds = new hash set < url > ( ) ; file [ ] file = dir . list file ( ) ; if ( file ! = null ) { for ( file f : file ) { if ( f . be directory ( ) ) tlds . add all ( get tlds ( f ) ) ; else { string name = f . get canonical path ( ) ; if ( name . contains ( `` meta-inf `` ) & & name . end with ( `` . tld `` ) ) tlds . add ( f . to u r i ( ) . to u r l ( ) ) ; } } } return tlds ; }
public static void be true ( boolean expression , string message ) { if ( ! expression ) { throw new illegal argument exception ( message ) ; } }
public static void have text ( string text , string message ) { if ( ! string . have text ( text ) ) { throw new illegal argument exception ( message ) ; } }
public static void not empty ( collection collection , string message ) { if ( collection . be empty ( collection ) ) { throw new illegal argument exception ( message ) ; } }
public static boolean be empty ( object [ ] array ) { return ( array == null || array . length == 0 ) ; }
public static boolean contains element ( object [ ] array , object element ) { if ( array == null ) { return false ; } for ( object array ele : array ) { if ( null safe equal ( array ele , element ) ) { return true ; } } return false ; }
public static object [ ] to object array ( object source ) { if ( source instanceof object [ ] ) { return ( object [ ] ) source ; } if ( source == null ) { return new object [ 0 ] ; } if ( ! source . get class ( ) . be array ( ) ) { throw new illegal argument exception ( `` source be not an array : `` + source ) ; } int length = array . get length ( source ) ; if ( length == 0 ) { return new object [ 0 ] ; } class wrapper type = array . get ( source , 0 ) . get class ( ) ; object [ ] new array = ( object [ ] ) array . new instance ( wrapper type , length ) ; for ( int i = 0 ; i < length ; i++ ) { new array [ i ] = array . get ( source , i ) ; } return new array ; }
public static int null safe hash code ( object obj ) { if ( obj == null ) { return 0 ; } if ( obj . get class ( ) . be array ( ) ) { if ( obj instanceof object [ ] ) { return null safe hash code ( ( object [ ] ) obj ) ; } if ( obj instanceof boolean [ ] ) { return null safe hash code ( ( boolean [ ] ) obj ) ; } if ( obj instanceof byte [ ] ) { return null safe hash code ( ( byte [ ] ) obj ) ; } if ( obj instanceof char [ ] ) { return null safe hash code ( ( char [ ] ) obj ) ; } if ( obj instanceof double [ ] ) { return null safe hash code ( ( double [ ] ) obj ) ; } if ( obj instanceof float [ ] ) { return null safe hash code ( ( float [ ] ) obj ) ; } if ( obj instanceof int [ ] ) { return null safe hash code ( ( int [ ] ) obj ) ; } if ( obj instanceof long [ ] ) { return null safe hash code ( ( long [ ] ) obj ) ; } if ( obj instanceof short [ ] ) { return null safe hash code ( ( short [ ] ) obj ) ; } } return obj . hash code ( ) ; }
public static string get display string ( object obj ) { if ( obj == null ) { return empty_string ; } return null safe to string ( obj ) ; }
public static boolean end with ignore case ( string str , string suffix ) { if ( str == null || suffix == null ) { return false ; } if ( str . end with ( suffix ) ) { return true ; } if ( str . length ( ) < suffix . length ( ) ) { return false ; } string lc str = str . substring ( str . length ( ) - suffix . length ( ) ) . to lower case ( ) ; string lc suffix = suffix . to lower case ( ) ; return lc str . equal ( lc suffix ) ; }
public static string unqualify ( string qualify name , char separator ) { return qualify name . substring ( qualified name . last index of ( separator ) + 1 ) ; }
public static string [ ] to string array ( enumeration < string > enumeration ) { if ( enumeration == null ) { return null ; } list < string > list = java . util . collection . list ( enumeration ) ; return list . to array ( new string [ list . size ( ) ] ) ; }
public string get value ( ) { return value ; }
public int get parameter index ( ) { return index ; }
public double get double ( long offset ) { bound check ( offset , 8 ) ; return super . get double ( offset ) ; }
public void set short ( long offset , short value ) { bound check ( offset , 2 ) ; super . set short ( offset , value ) ; }
public void set float ( long offset , float value ) { bound check ( offset , 4 ) ; super . set float ( offset , value ) ; }
public float get float ( long offset ) { return native . get float ( this , this . peer , offset ) ; }
public short [ ] get short array ( long offset , int array size ) { short [ ] buf = new short [ array size ] ; read ( offset , buf , 0 , array size ) ; return buf ; }
public int [ ] get int array ( long offset , int array size ) { int [ ] buf = new int [ array size ] ; read ( offset , buf , 0 , array size ) ; return buf ; }
protected list < field > get field list ( ) { list < field > flist = new array list < field > ( ) ; for ( class < ? > cl = get class ( ) ; ! cl . equal ( structure . class ) ; cls = cl . get superclass ( ) ) { list < field > class field = new array list < field > ( ) ; field [ ] field = cl . get declared field ( ) ; for ( int i=0 ; i < field . length ; i++ ) { int modifier = field [ i ] . get modifier ( ) ; if ( modifier . be static ( modifier ) || ! modifier . be public ( modifier ) ) { continue ; } class field . add ( field [ i ] ) ; } flist . add all ( 0 , class field ) ; } return flist ; }
public boolean data equal ( structure s ) { return data equal ( s , false ) ; }
public static < t extend structure > t new instance ( class < t > type ) throw illegal argument exception { t s = klass . new instance ( type ) ; if ( s instanceof by value ) { s . allocate memory ( ) ; } return s ; }
protected list < string > get field order ( ) { list < field > flist = get field list ( ) ; list < string > list = new array list < string > ( flist . size ( ) ) ; for ( field f : flist ) { list . add ( f . get name ( ) ) ; } return list ; }
public void dispose ( ) { drag image . dispose ( ) ; drag image = null ; }
public static void l set x attr ( string path , string name , string value ) throw i o exception { l set x attr ( path , name , value , native . get default string encoding ( ) ) ; }
public static int get master port ( ) { int by reference port = new int by reference ( ) ; io . i o master port ( 0 , port ) ; return port . get value ( ) ; }
public static i o registry entry get root ( ) { int master port = get master port ( ) ; i o registry entry root = io . i o registry get root entry ( master port ) ; sys . mach_port_deallocate ( sys . mach_task_self ( ) , master port ) ; return root ; }
public i dispatch get i dispatch ( ) { return i dispatch ; }
public integer get error arg ( ) { return error arg ; }
public string buffer get class buffer ( ) { return class buffer ; }
public int get impl type flag ( int index ) { int by reference p impl type flag = new int by reference ( ) ; hresult hr = this . type info . get impl type flag ( new uint ( index ) , p impl type flag ) ; c o m utils . check r c ( hr ) ; return p impl type flag . get value ( ) ; }
public i type info get ref type info ( hreftype hreftype ) { pointer by reference pp t info = new pointer by reference ( ) ; hresult hr = this . type info . get ref type info ( hreftype , pp t info ) ; c o m utils . check r c ( hr ) ; return new type info ( pp t info . get value ( ) ) ; }
public lcid get lcid ( ) { return lcid ; }
public static byte [ ] crypt unprotect data ( byte [ ] data ) { return crypt unprotect data ( data , 0 ) ; }
public static group [ ] get current user local group ( ) { return get user local group ( secur32 util . get user name ex ( extended_name_format . name sam compatible ) ) ; }
public static string get string from g u i d ( guid guid ) { guid pguid = new guid ( guid . get pointer ( ) ) ; int max = 39 ; char [ ] lpsz = new char [ max ] ; int len = ole32 . instance . string from g u i d2 ( pguid , lpsz , max ) ; if ( len == 0 ) { throw new runtime exception ( `` string from g u i d2 `` ) ; } lpsz [ len - 1 ] = 0 ; return native . to string ( lpsz ) ; }
public static void hangup ras connection ( handle hras conn ) throw ras32 exception { if ( hras conn == null ) return ; int err = rasapi32 . instance . ra hang up ( hras conn ) ; if ( err ! = win error . error_success ) throw new ras32 exception ( err ) ; }
public static string get know folder path ( guid guid ) throw win32 exception { int flag = shl obj . known_folder_flag . none . get flag ( ) ; pointer by reference out path = new pointer by reference ( ) ; handle token = null ; hresult hr = shell32 . instance . s h get know folder path ( guid , flag , token , out path ) ; if ( ! w32 error . succeed ( hr . int value ( ) ) ) { throw new win32 exception ( hr ) ; } string result = out path . get value ( ) . get wide string ( 0 ) ; ole32 . instance . co task mem free ( out path . get value ( ) ) ; return result ; }
public void close ( ) { if ( _handle ! = null ) { if ( ! advapi32 . instance . close service handle ( _handle ) ) { throw new win32 exception ( kernel32 . instance . get last error ( ) ) ; } _handle = null ; } }
public w32 service open service ( string service name , int permission ) { sc_handle service handle = advapi32 . instance . open service ( _handle , service name , permission ) ; if ( service handle == null ) { throw new win32 exception ( kernel32 . instance . get last error ( ) ) ; } return new w32 service ( service handle ) ; }
public static evt_variant evt get channel config property ( evt_handle channel handle , int property id ) { int by reference property value buffer use = new int by reference ( ) ; boolean result = wevtapi . instance . evt get channel config property ( channel handle , property id , 0 , 0 , null , property value buffer use ) ; int error code = kernel32 . instance . get last error ( ) ; if ( ( ! result ) & & error code ! = kernel32 . error_insufficient_buffer ) { throw new win32 exception ( error code ) ; } memory property value buffer = new memory ( property value buffer use . get value ( ) ) ; result = wevtapi . instance . evt get channel config property ( channel handle , property id , 0 , ( int ) property value buffer . size ( ) , property value buffer , property value buffer use ) ; if ( ! result ) { throw new win32 exception ( kernel32 . instance . get last error ( ) ) ; } evt_variant result evt = new evt_variant ( property value buffer ) ; result evt . read ( ) ; return result evt ; }
public gregorian calendar to gregorian calendar ( ) { date time zone zone = get zone ( ) ; gregorian calendar cal = new gregorian calendar ( zone . to time zone ( ) ) ; cal . set time ( to date ( ) ) ; return cal ; }
public date time to date time ( ) { return new date time ( get millis ( ) , get zone ( ) ) ; }
public date to date ( ) { return new date ( get millis ( ) ) ; }
public boolean be after ( readable instant instant ) { if ( instant == null ) { return be after now ( ) ; } return be after ( instant . get millis ( ) ) ; }
public boolean equal ( object readable interval ) { if ( this == readable interval ) { return true ; } if ( readable interval instanceof readable interval == false ) { return false ; } readable interval other = ( readable interval ) readable interval ; return get start millis ( ) == other . get start millis ( ) & & get end millis ( ) == other . get end millis ( ) & & field utils . equal ( get chronology ( ) , other . get chronology ( ) ) ; }
public date time field type [ ] get field type ( ) { date time field type [ ] result = new date time field type [ size ( ) ] ; for ( int i = 0 ; i < result . length ; i++ ) { result [ i ] = get field type ( i ) ; } return result ; }
public date time field [ ] get field ( ) { date time field [ ] result = new date time field [ size ( ) ] ; for ( int i = 0 ; i < result . length ; i++ ) { result [ i ] = get field ( i ) ; } return result ; }
public boolean be support ( date time field type type ) { return ( index of ( type ) ! = -1 ) ; }
public int index of ( date time field type type ) { for ( int i = 0 , isize = size ( ) ; i < isize ; i++ ) { if ( get field type ( i ) == type ) { return i ; } } return -1 ; }
public period to period ( ) { return new period ( this ) ; }
public period to period ( period type type ) { return new period ( get millis ( ) , type ) ; }
public period type get period type ( ) { return i type ; }
protect void set value ( int value ) { i period = value ; }
public date time field year ( ) { return unsupported date time field . get instance ( date time field type . year ( ) , year ( ) ) ; }
public date time field year of century ( ) { return unsupported date time field . get instance ( date time field type . year of century ( ) , year ( ) ) ; }
public boolean equal ( object obj ) { if ( this == obj ) { return true ; } if ( obj ! = null & & get class ( ) == obj . get class ( ) ) { basic chronology chrono = ( basic chronology ) obj ; return get minimum day in first week ( ) == chrono . get minimum day in first week ( ) & & get zone ( ) . equal ( chrono . get zone ( ) ) ; } return false ; }
public static coptic chronology get instance u t c ( ) { return instance_utc ; }
public static coptic chronology get instance ( ) { return get instance ( date time zone . get default ( ) , 4 ) ; }
public int get ( long instant ) { return i chronology . get day of week ( instant ) ; }
protect int convert text ( string text , locale locale ) { return g j locale symbol . for locale ( locale ) . day of week text to value ( text ) ; }
public static gregorian chronology get instance ( date time zone zone ) { return get instance ( zone , 4 ) ; }
public static islamic chronology get instance ( ) { return get instance ( date time zone . get default ( ) , leap_year_16_based ) ; }
public instant converter [ ] get instant converter ( ) { converter set set = i instant converter ; instant converter [ ] converter = new instant converter [ set . size ( ) ] ; set . copy into ( converter ) ; return converter ; }
public chronology get chronology ( object object , date time zone zone ) { chronology chrono = ( ( readable instant ) object ) . get chronology ( ) ; if ( chrono == null ) { return i s o chronology . get instance ( zone ) ; } date time zone chrono zone = chrono . get zone ( ) ; if ( chrono zone ! = zone ) { chrono = chrono . with zone ( zone ) ; if ( chrono == null ) { return i s o chronology . get instance ( zone ) ; } } return chrono ; }
protect long check instant ( long instant , chronology chronology ) { return chronology . day of month ( ) . round floor ( instant ) ; }
public date midnight plus week ( int week ) { if ( week == 0 ) { return this ; } long instant = get chronology ( ) . week ( ) . add ( get millis ( ) , week ) ; return with millis ( instant ) ; }
public date midnight minus day ( int day ) { if ( day == 0 ) { return this ; } long instant = get chronology ( ) . day ( ) . subtract ( get millis ( ) , day ) ; return with millis ( instant ) ; }
public interval to interval ( ) { chronology chrono = get chronology ( ) ; long start = get millis ( ) ; long end = duration field type . day ( ) . get field ( chrono ) . add ( start , 1 ) ; return new interval ( start , end , chrono ) ; }
public date midnight with weekyear ( int weekyear ) { return with millis ( get chronology ( ) . weekyear ( ) . set ( get millis ( ) , weekyear ) ) ; }
public date midnight with month of year ( int month of year ) { return with millis ( get chronology ( ) . month of year ( ) . set ( get millis ( ) , month of year ) ) ; }
public property day of month ( ) { return new property ( this , get chronology ( ) . day of month ( ) ) ; }
public date time to date time ( ) { return this ; }
public date time with early offset at overlap ( ) { long new millis = get zone ( ) . adjust offset ( get millis ( ) , false ) ; return with millis ( new millis ) ; }
public date time with date ( int year , int month of year , int day of month ) { chronology chrono = get chronology ( ) ; long instant = get millis ( ) ; instant = chrono . year ( ) . set ( instant , year ) ; instant = chrono . month of year ( ) . set ( instant , month of year ) ; instant = chrono . day of month ( ) . set ( instant , day of month ) ; return with millis ( instant ) ; }
public date time plus month ( int month ) { if ( month == 0 ) { return this ; } long instant = get chronology ( ) . month ( ) . add ( get millis ( ) , month ) ; return with millis ( instant ) ; }
public date time minus week ( int week ) { if ( week == 0 ) { return this ; } long instant = get chronology ( ) . week ( ) . subtract ( get millis ( ) , week ) ; return with millis ( instant ) ; }
public date time with week of weekyear ( int week of weekyear ) { return with millis ( get chronology ( ) . week of weekyear ( ) . set ( get millis ( ) , week of weekyear ) ) ; }
public int hash code ( ) { return ( i low limit == null ? 0 : i low limit . hash code ( ) ) + ( 123 * ( i upper limit == null ? 0 : i upper limit . hash code ( ) ) ) ; }
public static date time field type weekyear ( ) { return weekyear_type ; }
public static final void set current millis fix ( long fix millis ) throw security exception { check permission ( ) ; c millis provider = new fix millis provider ( fix millis ) ; }
public static final readable interval get readable interval ( readable interval interval ) { if ( interval == null ) { long now = date time utils . current time millis ( ) ; interval = new interval ( now , now ) ; } return interval ; }
public static final date time zone get zone ( date time zone zone ) { if ( zone == null ) { return date time zone . get default ( ) ; } return zone ; }
public static final long from julian day ( double julian day ) { double epoch day = julian day - 2440587 . 5d ; return ( long ) ( epoch day * 86400000d ) ; }
public static date time zone for offset millis ( int millis offset ) { if ( millis offset < -max_millis || millis offset > max_millis ) { throw new illegal argument exception ( `` millis out of range : `` + millis offset ) ; } string id = print offset ( millis offset ) ; return fix offset zone ( id , millis offset ) ; }
public static set < string > get available i d ( ) { return c available i d ; }
public static provider get provider ( ) { return c provider ; }
public final string get i d ( ) { return i i d ; }
public duration to duration ( ) { return this ; }
public static duration field type minute ( ) { return minutes_type ; }
public string get a string ( ) { return integer . to string ( get ( ) ) ; }
public string get a text ( locale locale ) { return get field ( ) . get a text ( get readable partial ( ) , get ( ) , locale ) ; }
public int get maximum value overall ( ) { return get field ( ) . get maximum value ( ) ; }
public int get maximum value ( ) { return get field ( ) . get maximum value ( get readable partial ( ) ) ; }
public string get a text ( readable partial partial , int field value , locale locale ) { return get a text ( field value , locale ) ; }
public int get difference ( long minuend instant , long subtrahend instant ) { return get duration field ( ) . get difference ( minuend instant , subtrahend instant ) ; }
public int get maximum value ( long instant ) { return get maximum value ( ) ; }
public long round ceiling ( long instant ) { long new instant = round floor ( instant ) ; if ( new instant ! = instant ) { instant = add ( new instant , 1 ) ; } return instant ; }
public int get maximum value ( ) { return i max ; }
public static date time field get instance ( date time field field , chronology base ) { if ( field == null ) { return null ; } if ( field instanceof strict date time field ) { field = ( ( strict date time field ) field ) . get wrapped field ( ) ; } if ( field . be lenient ( ) ) { return field ; } return new lenient date time field ( field , base ) ; }
public long add ( long instant , int amount ) { instant = super . add ( instant , amount ) ; field utils . verify value bound ( this , get ( instant ) , i min , i max ) ; return instant ; }
public static date time formatter short date time ( ) { return create formatter for style index ( short , short ) ; }
public date time parser get parser ( ) { return internal parser date time parser . of ( i parser ) ; }
public date time formatter with zone u t c ( ) { return with zone ( date time zone . utc ) ; }
public long parse millis ( string text ) { internal parser parser = require parser ( ) ; chronology chrono = select chronology ( i chrono ) ; date time parser bucket bucket = new date time parser bucket ( 0 , chrono , i locale , i pivot year , i default year ) ; return bucket . do parse millis ( parser , text ) ; }
public static date time formatter date optional time parser ( ) { return constant . dotp ; }
public static date time formatter date ( ) { return year month day ( ) ; }
public static date time formatter date time no millis ( ) { return constant . dtx ; }
public static date time formatter date hour minute second millis ( ) { return constant . dhmsl ; }
public static period formatter word base ( ) { return word base ( locale . get default ( ) ) ; }
public string print ( readable period period ) { check printer ( ) ; check period ( period ) ; period printer printer = get printer ( ) ; string buffer buf = new string buffer ( printer . calculate print length ( period , i locale ) ) ; printer . print to ( buf , period , i locale ) ; return buf . to string ( ) ; }
public period formatter to formatter ( ) { period formatter formatter = to formatter ( i element pair , i not printer , i not parser ) ; i field formatters = ( field formatter [ ] ) i field formatters . clone ( ) ; return formatter ; }
public void clear ( ) { i min print digit = 1 ; i print zero set = print_zero_rarely_last ; i max parse digit = 10 ; i reject sign value = false ; i prefix = null ; if ( i element pair == null ) { i element pair = new array list < object > ( ) ; } else { i element pair . clear ( ) ; } i not printer = false ; i not parser = false ; i field formatters = new field formatter [ 10 ] ; }
public period formatter builder append month ( ) { append field ( month ) ; return this ; }
public duration field type get duration field type ( ) { return i duration field type ; }
public interval with duration before end ( readable duration duration ) { long duration millis = date time utils . get duration millis ( duration ) ; if ( duration millis == to duration millis ( ) ) { return this ; } chronology chrono = get chronology ( ) ; long end millis = get end millis ( ) ; long start millis = chrono . add ( end millis , duration millis , -1 ) ; return new interval ( start millis , end millis , chrono ) ; }
public void set start millis ( long start instant ) { super . set interval ( start instant , get end millis ( ) , get chronology ( ) ) ; }
public void set period before end ( readable period period ) { if ( period == null ) { set start millis ( get end millis ( ) ) ; } else { set start millis ( get chronology ( ) . add ( period , get end millis ( ) , -1 ) ) ; } }
public void add week ( int week ) { super . add field ( duration field type . week ( ) , week ) ; }
public partial with field add ( duration field type field type , int amount ) { int index = index of support ( field type ) ; if ( amount == 0 ) { return this ; } int [ ] new value = get value ( ) ; new value = get field ( index ) . add ( this , index , new value , amount ) ; return new partial ( this , new value ) ; }
public static period day ( int day ) { return new period ( new int [ ] { 0 , 0 , 0 , day , 0 , 0 , 0 , 0 } , period type . standard ( ) ) ; }
public period minus day ( int day ) { return plus day ( -days ) ; }
public static period type time ( ) { period type type = c time ; if ( type == null ) { type = new period type ( `` time `` , new duration field type [ ] { duration field type . hour ( ) , duration field type . minute ( ) , duration field type . second ( ) , duration field type . millis ( ) , } , new int [ ] { -1 , -1 , -1 , -1 , 0 , 1 , 2 , 3 , } ) ; c time = type ; } return type ; }
public static cache date time zone for zone ( date time zone zone ) { if ( zone instanceof cache date time zone ) { return ( cached date time zone ) zone ; } return new cache date time zone ( zone ) ; }
public boolean be origin allow ( string p origin , boolean p strict checking ) { return restrictor . be origin allow ( p origin , p strict checking ) ; }
protect m bean server connection get jolokia m bean server ( ) { return null ; }
public void destroy ( ) { m bean server server = management factory . get platform m bean server ( ) ; jmx util . remove m bean registration listener ( server , this ) ; }
public boolean be request config ( ) { return request config ; }
public string get product ( ) { return product ; }
protect j s o n object get detector option ( configuration p config , log handler p log handler ) { string option = p config . get ( config key . detector_options ) ; try { if ( option ! = null ) { j s o n object opts = ( j s o n object ) new j s o n parser ( ) . parse ( option ) ; return ( j s o n object ) opts . get ( get product ( ) ) ; } return null ; } catch ( parse exception e ) { p log handler . error ( `` could not parse detector option ' `` + option + `` ' a json object : `` + e , e ) ; } return null ; }
protect void verify that path be empty ( stack < string > p path stack ) { if ( p path stack ! = null & & p path stack . size ( ) > 0 ) { throw new illegal argument exception ( `` path contains extra element not usable for a list request : `` + p path stack ) ; } }
public boolean use return value with path ( ) { return false ; }
public history limit respect global max entry ( int p global max entry ) { if ( max entry > p global max entry || max entry == 0 ) { max entry = p global max entry ; } return this ; }
public synchronize void update and add ( jmx request p jmx req , j s o n object p json ) { long timestamp = system . current time millis ( ) / 1000 ; p json . put ( key_timestamp , timestamp ) ; request type type = p jmx req . get type ( ) ; history updater updater = history updaters . get ( type ) ; if ( updater ! = null ) { updater . update history ( p json , p jmx req , timestamp ) ; } }
public value fault handler get value fault handler ( ) { return value fault handler ; }
public j s o n object to j s o n ( ) { j s o n object ret = new j s o n object ( ) ; ret . put ( `` url `` , url ) ; if ( env ! = null ) { ret . put ( `` env `` , env ) ; } return ret ; }
public static string combine to path ( list < string > p part ) { if ( p part ! = null & & p part . size ( ) > 0 ) { string builder buf = new string builder ( ) ; iterator < string > it = p part . iterator ( ) ; while ( it . have next ( ) ) { string part = it . next ( ) ; buf . append ( escape part ( part ! = null ? part : `` * `` ) ) ; if ( it . have next ( ) ) { buf . append ( `` / `` ) ; } } return buf . to string ( ) ; } else { return null ; } }
public final argument accept option spec < v > default to ( v value , v . . . value ) { add default value ( value ) ; default to ( value ) ; return this ; }
public static string short name of ( string class name ) { return class name . substring ( class name . last index of ( ' . ' ) + 1 ) ; }
public static j s o n array to j s o n array ( j s o n array name , string string ) throw j s o n exception { return to j s o n array ( name , new j s o n tokener ( string ) ) ; }
public static string to string ( j s o n array name , j s o n array ja ) throw j s o n exception { if ( name == null || name . length ( ) == 0 ) { return null ; } string buffer sb = new string buffer ( ) ; for ( int i = 0 ; i < ja . length ( ) ; i += 1 ) { j s o n object jo = ja . opt j s o n object ( i ) ; if ( jo ! = null ) { sb . append ( row to string ( jo . to j s o n array ( names ) ) ) ; } } return sb . to string ( ) ; }
public string to string ( ) { return this . mode == 'd ' ? this . writer . to string ( ) : null ; }
public j s o n writer key ( string string ) throw j s o n exception { if ( string == null ) { throw new j s o n exception ( `` null key . `` ) ; } if ( this . mode == ' k ' ) { try { this . stack [ this . top - 1 ] . put once ( string , boolean . true ) ; if ( this . comma ) { this . writer . write ( ' , ' ) ; } this . writer . write ( j s o n object . quote ( string ) ) ; this . writer . write ( ' : ' ) ; this . comma = false ; this . mode = ' o ' ; return this ; } catch ( i o exception e ) { throw new j s o n exception ( e ) ; } } throw new j s o n exception ( `` misplace key . `` ) ; }
public string getc data tag name ( ) { return this . c data tag name ; }
public criterion be ( object o ) { this . criterion type = relational operator . eq ; this . right = value node . to value node ( o ) ; return this ; }
public boolean be token definite ( ) { return true ; }
public boolean be map ( object obj ) { return ( obj instanceof map ) ; }
public int length ( object obj ) { if ( be array ( obj ) ) { return ( ( list ) obj ) . size ( ) ; } else if ( be map ( obj ) ) { return get property key ( obj ) . size ( ) ; } else if ( obj instanceof string ) { return ( ( string ) obj ) . length ( ) ; } throw new json path exception ( `` length operation can not be apply to `` + obj ! =null ? obj . get class ( ) . get name ( ) : `` null `` ) ; }
public boolean get boolean ( string path ) { return object converter . convert object to ( get ( path ) , boolean . class ) ; }
public char get char ( string path ) { return object converter . convert object to ( get ( path ) , character . class ) ; }
public json path peek ( ) { system . out . println ( to json string ( ) ) ; return this ; }
public json path pretty peek ( ) { pretty print ( ) ; return this ; }
public static json path give ( url url ) { return new json path ( url ) ; }
public static void reset ( ) { json path . config = null ; }
public static boolean regex be valid ( final string regex ) { if ( primary_script_engine ! = null ) { return invoke script engine ( regex_is_valid_function_name , regex ) ; } return invoke fallback engine ( regex_is_valid , regex ) ; }
public final string get name ( ) { return name ; }
public static validation configuration by default ( ) { return new builder ( ) . freeze ( ) ; }
public dictionary < digester > get digester ( ) { return digester ; }
public static void write j s o n string ( iterable < ? extend object > list , appendable out , j s o n style compression ) throw i o exception { if ( list == null ) { out . append ( `` null `` ) ; return ; } json writer . j s o n iterable writer . write j s o n string ( list , out , compression ) ; }
public string to j s o n string ( ) { return to j s o n string ( this , j s o n value . compression ) ; }
public string to string ( ) { return to j s o n string ( ) ; }
public boolean a boolean obj ( ) { if ( current == null ) return null ; if ( current instanceof boolean ) return ( boolean ) current ; return null ; }
public j s o n navi < t > array ( ) { if ( failure ) return this ; if ( current == null & & readonly ) failure ( `` can not create array child in readonly `` , null ) ; if ( current ! = null ) { if ( be array ( ) ) return this ; if ( be object ( ) ) failure ( `` can not use object feature on array . `` , null ) ; failure ( `` can not use current possition a object `` , null ) ; } else { current = mapper . create array ( ) ; } if ( root == null ) root = ( t ) current ; else store ( ) ; return this ; }
public j s o n navi < ? > at next ( ) { if ( failure ) return this ; if ( ! ( current instanceof list ) ) return failure ( `` current node be not an array `` , null ) ; @ suppress warning ( `` unchecked `` ) list < object > lst = ( ( list < object > ) current ) ; return at ( lst . size ( ) ) ; }
public void add interface writer last ( class < ? > inter face , json writer i < ? > writer ) { register writer interface last ( inter face , writer ) ; }
public < t > void register writer ( json writer i < t > writer , class < ? > . . . cl ) { for ( class < ? > c : cl ) data . put ( c , writer ) ; }
public static void assert not equal ( string expect str , j s o n array actual , boolean strict ) throw j s o n exception { assert not equal ( expect str , actual , strict ? j s o n compare mode . strict : j s o n compare mode . lenient ) ; }
public static void assert not equal ( string expect str , string actual str , j s o n comparator comparator ) throw j s o n exception { assert not equal ( `` `` , expect str , actual str , comparator ) ; }
public object get expect ( ) { return _expected ; }
public static document load ( file in , string charset name , string base uri ) throw i o exception { byte buffer byte data = read file to byte buffer ( in ) ; return parse byte data ( byte data , charset name , base uri , parser . html parser ( ) ) ; }
public iterator < e > descend iterator ( ) { return new descend iterator < e > ( size ( ) ) ; }
public static string join ( collection string , string sep ) { return join ( string . iterator ( ) , sep ) ; }
public static document parse ( string html , string base uri , parser parser ) { return parser . parse input ( html , base uri ) ; }
public static document parse ( input stream in , string charset name , string base uri ) throw i o exception { return data util . load ( in , charset name , base uri ) ; }
public void put ( string key , boolean value ) { if ( value ) put ( new boolean attribute ( key ) ) ; else remove ( key ) ; }
public static document create shell ( string base uri ) { validate . not null ( base uri ) ; document doc = new document ( base uri ) ; element html = doc . append element ( `` html `` ) ; html . append element ( `` head `` ) ; html . append element ( `` body `` ) ; return doc ; }
public string location ( ) { return location ; }
public element create element ( string tag name ) { return new element ( tag . value of ( tag name , parse setting . preserve case ) , this . base uri ( ) ) ; }
public element prepend child ( node child ) { validate . not null ( child ) ; add child ( 0 , child ) ; return this ; }
public element get element by index great than ( int index ) { return collector . collect ( new evaluator . index great than ( index ) , this ) ; }
public element val ( string value ) { if ( tag name ( ) . equal ( `` textarea `` ) ) text ( value ) ; else attr ( `` value `` , value ) ; return this ; }
public element html ( string html ) { empty ( ) ; append ( html ) ; return this ; }
public node after ( string html ) { add sibling html ( sibling index + 1 , html ) ; return this ; }
public node after ( node node ) { validate . not null ( node ) ; validate . not null ( parent node ) ; parent node . add child ( sibling index + 1 , node ) ; return this ; }
public void replace with ( node in ) { validate . not null ( in ) ; validate . not null ( parent node ) ; parent node . replace child ( this , in ) ; }
public boolean be data ( ) { return ! can contain inline & & ! be empty ( ) ; }
public char peek ( ) { return be empty ( ) ? 0 : queue . char at ( po ) ; }
public void add first ( character c ) { add first ( c . to string ( ) ) ; }
public void advance ( ) { if ( ! be empty ( ) ) pos++ ; }
public string consume to ( string seq ) { int offset = queue . index of ( seq , po ) ; if ( offset ! = -1 ) { string consume = queue . substring ( po , offset ) ; po += consume . length ( ) ; return consume ; } else { return remainder ( ) ; } }
public static whitelist basic ( ) { return new whitelist ( ) . add tag ( `` a `` , `` b `` , `` blockquote `` , `` br `` , `` cite `` , `` code `` , `` dd `` , `` dl `` , `` dt `` , `` em `` , `` i `` , `` li `` , `` ol `` , `` p `` , `` pre `` , `` q `` , `` small `` , `` span `` , `` strike `` , `` strong `` , `` sub `` , `` sup `` , `` u `` , `` ul `` ) . add attribute ( `` a `` , `` href `` ) . add attribute ( `` blockquote `` , `` cite `` ) . add attribute ( `` q `` , `` cite `` ) . add protocol ( `` a `` , `` href `` , `` ftp `` , `` http `` , `` http `` , `` mailto `` ) . add protocol ( `` blockquote `` , `` cite `` , `` http `` , `` https `` ) . add protocol ( `` cite `` , `` cite `` , `` http `` , `` https `` ) . add enforced attribute ( `` a `` , `` rel `` , `` nofollow `` ) ; }
public element remove ( ) { for ( element element : this ) { element . remove ( ) ; } return this ; }
public element prev ( string query ) { return sibling ( query , false , false ) ; }
public void traverse ( node root ) { node node = root ; int depth = 0 ; while ( node ! = null ) { visitor . head ( node , depth ) ; if ( node . child node size ( ) > 0 ) { node = node . child node ( 0 ) ; depth++ ; } else { while ( node . next sibling ( ) == null & & depth > 0 ) { visitor . tail ( node , depth ) ; node = node . parent node ( ) ; depth -- ; } visitor . tail ( node , depth ) ; if ( node == root ) break ; node = node . next sibling ( ) ; } } }
public static element select ( string query , element root ) { return new selector ( query , root ) . select ( ) ; }
public static string join ( string [ ] string , string sep ) { return join ( arrays . a list ( string ) , sep ) ; }
public boolean be xml declaration ( ) { string data = get data ( ) ; return ( data . length ( ) > 1 & & ( data . start with ( `` ! `` ) || data . start with ( `` ? `` ) ) ) ; }
public node clear attribute ( ) { iterator < attribute > it = attribute ( ) . iterator ( ) ; while ( it . have next ( ) ) { it . next ( ) ; it . remove ( ) ; } return this ; }
public static void remove handler for root logger ( ) { java . util . log . logger root logger = get root logger ( ) ; java . util . log . handler [ ] handler = root logger . get handler ( ) ; for ( int i = 0 ; i < handler . length ; i++ ) { root logger . remove handler ( handler [ i ] ) ; } }
static public void fail ( ) { fail ( null ) ; }
protect void set up ( ) throw exception { }
public static string truncate ( string s ) { if ( fg max message length ! = -1 & & s . length ( ) > fg max message length ) s= s . substring ( 0 , fg max message length ) + `` . . . `` ; return s ; }
static public test result run ( test test ) { test runner runner= new test runner ( ) ; return runner . do run ( test ) ; }
protect test result create test result ( ) { return new test result ( ) ; }
public enumeration < test > test ( ) { return f test . element ( ) ; }
static public void assert null ( string message , object object ) { assert true ( message , object == null ) ; }
public string get expect ( ) { return f expect ; }
protect string elapsed time a string ( long run time ) { return number format . get instance ( ) . format ( ( double ) run time / 1000 ) ; }
public static description create test description ( class clazz , string name ) { return new description ( string . format ( `` % s ( % s ) `` , name , clazz . get name ( ) ) ) ; }
public result run ( request request ) { return run ( request . get runner ( ) ) ; }
public result run ( junit . framework . test test ) { return run ( new old test class runner ( test ) ) ; }
public void add listener ( run listener listener ) { f listener . add ( listener ) ; }
public static max core for folder ( string folder name ) { return store locally ( new file ( folder name ) ) ; }
public int failure count ( ) { return result . get failure ( ) . size ( ) ; }
public file new folder ( string folder ) throw i o exception { return new folder ( new string [ ] { folder } ) ; }
public statement apply ( final statement base , final description description ) { return new statement ( ) { @ override public void evaluate ( ) throw throwable { list < throwable > error = new array list < throwable > ( ) ; start quietly ( description , error ) ; try { base . evaluate ( ) ; succeed quietly ( description , error ) ; } catch ( assumption violate exception e ) { error . add ( e ) ; skip quietly ( e , description , error ) ; } catch ( throwable t ) { error . add ( t ) ; fail quietly ( t , description , error ) ; } finally { finish quietly ( description , error ) ; } multiple failure exception . assert empty ( error ) ; } } ; }
public static request class ( class < ? > . . . class ) { return class ( j unit core . default computer ( ) , class ) ; }
public list < throwable > get cause ( ) { return f error ; }
public string get message ( ) { return new comparison compactor ( max_context_length , f expect , f actual ) . compact ( super . get message ( ) ) ; }
public static < t extend throwable > matcher < t > have cause ( final matcher < ? extend throwable > matcher ) { return new throwable cause matcher < t > ( matcher ) ; }
public void expect message ( matcher < string > matcher ) { expect ( have message ( matcher ) ) ; }
public static j unit command line parse result parse ( string [ ] args ) { j unit command line parse result result = new j unit command line parse result ( ) ; result . parse args ( args ) ; return result ; }
public list < framework method > get annotate method ( ) { list < framework method > method = collect value ( method for annotation ) ; collection . sort ( method , method_comparator ) ; return method ; }
public annotation validator create annotation validator ( validate with validate with annotation ) { annotation validator validator = validators_for_annotation_types . get ( validate with annotation ) ; if ( validator ! = null ) { return validator ; } class < ? extend annotation validator > clazz = validate with annotation . value ( ) ; if ( clazz == null ) { throw new illegal argument exception ( `` ca n't create validator , value be null in annotation `` + validate with annotation . get class ( ) . get name ( ) ) ; } try { annotation validator annotation validator = clazz . new instance ( ) ; validators_for_annotation_types . put if absent ( validate with annotation , annotation validator ) ; return validators_for_annotation_types . get ( validate with annotation ) ; } catch ( exception e ) { throw new runtime exception ( `` exception receive when create annotation validator class `` + clazz . get name ( ) , e ) ; } }
public static < t > matcher < t > describe a ( string description , matcher < t > matcher , object . . . value ) { return new describe a < t > ( description , matcher , value ) ; }
public static < t > matcher < t > null value ( ) { return new be null < t > ( ) ; }
public static < t > combinable matcher < t > either ( matcher < t > matcher ) { return new combinable matcher < t > ( matcher ) ; }
public void delete ( ) { recursive delete ( folder ) ; }
public static condition evaluation result disable ( string reason ) { return new condition evaluation result ( false , reason ) ; }
public static boolean be assignable to ( object obj , class < ? > type ) { precondition . not null ( type , `` type must not be null `` ) ; if ( obj == null ) { return ! type . be primitive ( ) ; } if ( type . be instance ( obj ) ) { return true ; } if ( type . be primitive ( ) ) { return primitive to wrapper map . get ( type ) == obj . get class ( ) ; } return false ; }
public static class < ? > get wrapper type ( class < ? > type ) { return primitive to wrapper map . get ( type ) ; }
public void clear ( ) { current output = `` `` ; accrue input . set length ( 0 ) ; accrue input without format . set length ( 0 ) ; format template . set length ( 0 ) ; last match position = 0 ; current formatting pattern = `` `` ; prefix before national number . set length ( 0 ) ; extract national prefix = `` `` ; national number . set length ( 0 ) ; able to format = true ; input have format = false ; position to remember = 0 ; original position = 0 ; be complete number = false ; be expect country call code = false ; possible format . clear ( ) ; should add space after national prefix = false ; if ( ! current metadata . equal ( default metadata ) ) { current metadata = get metadata for region ( default country ) ; } }
public static matcher api create ( ) { return new regex base matcher ( ) ; }
public string raw string ( ) { return raw string ; }
public final void set follow ( final boolean new value ) { follow = new value ; }
public string get label ( ) { return _label ; }
public final static void main ( string [ ] args ) { log broker monitor monitor = new log broker monitor ( log level . get log4 j level ( ) ) ; monitor . set frame size ( l f5 appender . get default monitor width ( ) , l f5 appender . get default monitor height ( ) ) ; monitor . set font size ( 12 ) ; monitor . show ( ) ; }
public void parse ( log broker monitor monitor ) throw runtime exception { _monitor = monitor ; thread t = new thread ( this ) ; t . start ( ) ; }
public void log ( string category , log level level , string message , throwable t , string ndc ) { adapter log record record = new adapter log record ( ) ; record . set category ( category ) ; record . set message ( message ) ; record . set n d c ( ndc ) ; record . set thrown ( t ) ; if ( level == null ) { record . set level ( get default level ( ) ) ; } else { record . set level ( level ) ; } add message ( record ) ; }
public string get name ( ) { return ( _name ) ; }
public url get u r l ( ) { return ( resource utils . get resource a u r l ( this , this ) ) ; }
protect int remove unused node ( ) { int count = 0 ; category node root = _category model . get root category node ( ) ; enumeration enumeration = root . depth first enumeration ( ) ; while ( enumeration . have more element ( ) ) { category node node = ( category node ) enumeration . next element ( ) ; if ( node . be leaf ( ) & & node . get number of contain record ( ) == 0 & & node . get parent ( ) ! = null ) { _category model . remove node from parent ( node ) ; count++ ; } } return count ; }
protect void set max size ( int max size ) { if ( max size < _mru file list . size ( ) ) { for ( int i = 0 ; i < _mru file list . size ( ) - max size ; i++ ) { _mru file list . remove last ( ) ; } } _max size = max size ; }
protect static void repaint later ( final j component component ) { swing utility . invoke later ( new runnable ( ) { public void run ( ) { component . repaint ( ) ; } } ) ; }
protect boolean load log file ( url url ) { boolean ok = false ; try { log file parser lfp = new log file parser ( url . open stream ( ) ) ; lfp . parse ( this ) ; ok = true ; } catch ( i o exception e ) { log factor5 error dialog error = new log factor5 error dialog ( get base frame ( ) , `` error reading url : `` + url . get file ( ) ) ; } return ok ; }
public void trace ( object message , throwable t ) { if ( repository . be disabled ( level . trace_int ) ) { return ; } if ( level . trace . be great or equal ( this . get effective level ( ) ) ) { force log ( fqcn , level . trace , message , t ) ; } }
public static void fatal ( final logger logger , final string pattern , final object [ ] argument ) { if ( logger . be enable for ( level . fatal ) ) { force log ( logger , level . fatal , format ( pattern , argument ) ) ; } }
public void set cc ( final string address ) { this . cc = address ; }
public final string get s m t p protocol ( ) { return smtp protocol ; }
public void activate option ( ) { if ( advertise via multicast d n s ) { zero conf = new zero conf support ( zone , port , get name ( ) ) ; zero conf . advertise ( ) ; } connect ( address , port ) ; }
public void set application ( string lapp ) { this . application = lapp ; }
public string buffer format ( date date , string buffer sbuf , field position field position ) { format ( date . get time ( ) , sbuf ) ; return sbuf ; }
public boolean be leave aligned ( ) { return leave align ; }
public set get property key set ( ) { return get property ( ) . key set ( ) ; }
public static relative time pattern converter new instance ( final string [ ] option ) { return new relative time pattern converter ( ) ; }
public boolean ignores throwable ( ) { return false ; }
public log builder reset ( level level ) { this . in use = true ; this . level = level ; this . marker = null ; this . throwable = null ; this . location = null ; return this ; }
public static logger context get context ( final class loader loader , final boolean current context ) { try { return factory . get context ( fqcn , loader , null , current context ) ; } catch ( final illegal state exception ex ) { logger . warn ( ex . get message ( ) + `` use simple logger `` ) ; return new simple logger context factory ( ) . get context ( fqcn , loader , null , current context ) ; } }
protect resource bundle get resource bundle ( final string rb base name , final locale resource bundle locale , final boolean loop ) { resource bundle rb = null ; if ( rb base name == null ) { return null ; } try { if ( resource bundle locale ! = null ) { rb = resource bundle . get bundle ( rb base name , resource bundle locale ) ; } else { rb = resource bundle . get bundle ( rb base name ) ; } } catch ( final miss resource exception ex ) { if ( ! loop ) { logger . debug ( `` unable to locate resource bundle `` + rb base name ) ; return null ; } } string substr = rb base name ; int i ; while ( rb == null & & ( i = substr . last index of ( ' . ' ) ) > 0 ) { substr = substr . substring ( 0 , i ) ; try { if ( resource bundle locale ! = null ) { rb = resource bundle . get bundle ( substr , resource bundle locale ) ; } else { rb = resource bundle . get bundle ( substr ) ; } } catch ( final miss resource exception ex ) { logger . debug ( `` unable to locate resource bundle `` + substr ) ; } } return rb ; }
public throwable get throwable ( ) { return throwable ; }
public short get parameter count ( ) { return 1 ; }
public string get type ( ) { return type ; }
public log builder at info ( ) { return at level ( level . info ) ; }
public void freeze ( ) { frozen = true ; }
public level get status level ( ) { return this . level ; }
public static < t extend enum < t > > t value of ( final class < t > enum type , final string name , final t default value ) { return name == null ? default value : enum . value of ( enum type , name . to upper case ( locale . english ) ) ; }
public static message get ( final message supplier supplier ) { if ( supplier == null ) { return null ; } return supplier . get ( ) ; }
public int get integer property ( final string name , final int default value ) { final string prop = get string property ( name ) ; if ( prop ! = null ) { try { return integer . parse int ( prop ) ; } catch ( final exception ignore ) { return default value ; } } return default value ; }
public static property extract subset ( final property property , final string prefix ) { final property subset = new property ( ) ; if ( prefix == null || prefix . length ( ) == 0 ) { return subset ; } final string prefix to match = prefix . char at ( prefix . length ( ) - 1 ) ! = ' . ' ? prefix + ' . ' : prefix ; final list < string > key = new array list < > ( ) ; for ( final string key : property . string property name ( ) ) { if ( key . start with ( prefix to match ) ) { subset . set property ( key . substring ( prefix to match . length ( ) ) , property . get property ( key ) ) ; key . add ( key ) ; } } for ( final string key : key ) { property . remove ( key ) ; } return subset ; }
public static boolean be blank ( final string s ) { if ( s == null || s . be empty ( ) ) { return true ; } for ( int i = 0 ; i < s . length ( ) ; i++ ) { char c = s . char at ( i ) ; if ( ! character . be whitespace ( c ) ) { return false ; } } return true ; }
public error handler get handler ( ) { return handler ; }
public string get name ( ) { return name ; }
public boolean get immediate flush ( ) { return immediate flush ; }
public string [ ] get appender ref string ( ) { final string [ ] result = new string [ appender ref . length ] ; for ( int i = 0 ; i < result . length ; i++ ) { result [ i ] = appender ref [ i ] . get ref ( ) ; } return result ; }
protect void write ( final byte [ ] bytes ) { write ( byte , 0 , byte . length , false ) ; }
protect void write ( final byte [ ] bytes , final int offset , final int length ) { write byte ( byte , offset , length ) ; }
protect synchronized void write to destination ( final byte [ ] bytes , final int offset , final int length ) { try { get output stream ( ) . write ( byte , offset , length ) ; } catch ( final i o exception ex ) { throw new appender log exception ( `` error write to stream `` + get name ( ) , ex ) ; } }
public static < b extend builder < b > > b new builder ( ) { return new builder < b > ( ) . a builder ( ) ; }
public boolean execute ( ) throw i o exception { if ( stop on error ) { for ( final action action : action ) { if ( ! action . execute ( ) ) { return false ; } } return true ; } boolean status = true ; i o exception exception = null ; for ( final action action : action ) { try { status & = action . execute ( ) ; } catch ( final i o exception ex ) { status = false ; if ( exception == null ) { exception = ex ; } } } if ( exception ! = null ) { throw exception ; } return status ; }
public file get destination ( ) { return this . destination ; }
public list < path with attribute > select file to delete ( final path base path , final list < path with attribute > candidate ) { final simple binding binding = new simple binding ( ) ; binding . put ( `` base path `` , base path ) ; binding . put ( `` path list `` , candidate ) ; binding . put all ( configuration . get property ( ) ) ; binding . put ( `` configuration `` , configuration ) ; binding . put ( `` substitutor `` , configuration . get str substitutor ( ) ) ; binding . put ( `` status logger `` , logger ) ; final object object = configuration . get script manager ( ) . execute ( script . get name ( ) , binding ) ; return ( list < path with attribute > ) object ; }
public boolean be trigger event ( final log event event ) { return false ; }
public static < b extend builder < b > > b new builder ( ) { return new builder < b > ( ) . a builder ( ) ; }
public route [ ] get route ( ) { return route ; }
public void actual async log ( final ring buffer log event event ) { final logger config private config logger config = private config . logger config ; final list < property > property = private config logger config . get property list ( ) ; if ( property ! = null ) { on property present ( event , property ) ; } private config logger config . get reliability strategy ( ) . log ( this , event ) ; }
public void remove listener ( final configuration listener listener ) { listener . remove ( listener ) ; }
public logger config get root logger ( ) { return root ; }
public synchronize void remove logger ( final string logger name ) { logger configs . remove ( logger name ) ; set parent ( ) ; }
public string get level name ( ) { return level name ; }
public static type converter registry get instance ( ) { type converter registry result = instance ; if ( result == null ) { synchronize ( instance_lock ) { result = instance ; if ( result == null ) { instance = result = new type converter registry ( ) ; } } } return result ; }
public set < uri > get resource ( ) { return resource match ; }
protect object convert ( final string value , final object default value ) { if ( default value instanceof string ) { return type converter . convert ( value , this . conversion type , string . trim to null ( ( string ) default value ) ) ; } return type converter . convert ( value , this . conversion type , default value ) ; }
public boolean stop ( final long timeout , final time unit time unit ) { return stop ( timeout , time unit , true ) ; }
public stack trace element get source ( ) { if ( source ! = null ) { return source ; } if ( logger fqcn == null || ! include location ) { return null ; } source = stack locator util . calc location ( logger fqcn ) ; return source ; }
public void encode ( final log event event , final byte buffer destination destination ) { final byte [ ] data = to byte array ( event ) ; destination . write byte ( data , 0 , data . length ) ; }
public synchronize void set level ( final level level ) { if ( level == get level ( ) ) { return ; } level actual level ; if ( level ! = null ) { actual level = level ; } else { final logger parent = get parent ( ) ; actual level = parent ! = null ? parent . get level ( ) : private config . logger config level ; } private config = new private config ( private config , actual level ) ; }
public void set config location ( final uri config location ) { this . config location = config location ; reconfigure ( config location ) ; }
public void update logger ( final configuration config ) { final configuration old = this . configuration ; for ( final logger logger : logger registry . get logger ( ) ) { logger . update configuration ( config ) ; } fire property change event ( new property change event ( this , property_config , old , config ) ) ; }
public string lookup ( final log event event , final string key ) { if ( event == null || ! ( event . get message ( ) instanceof structure data message ) ) { return null ; } final structure data message msg = ( structure data message ) event . get message ( ) ; if ( key . equal ignore case ( `` id `` ) ) { return msg . get id ( ) . get name ( ) ; } else if ( key . equal ignore case ( `` type `` ) ) { return msg . get type ( ) ; } return msg . get ( key ) ; }
public void unadvertise ( final object service info ) { if ( jm d n s ! = null ) { try { final method method = jm d n s class . get method ( `` unregister service `` , service info class ) ; method . invoke ( jm d n s , service info ) ; } catch ( final illegal access exception | invocation target exception e ) { logger . warn ( `` unable to invoke unregister service method `` , e ) ; } catch ( final no such method exception e ) { logger . warn ( `` no unregister service method `` , e ) ; } } }
public void clear secret ( ) { this . location = null ; this . password provider = null ; }
public string get process id ( ) { return pid ; }
public list < string > get unmatched argument ( ) { return unmatched argument ; }
public static < t > t populate command ( final t command , final string . . . args ) { final command line cli = to command line ( command ) ; cli . parse ( args ) ; return command ; }
public static uuid get time base uuid ( ) { final long time = ( ( system . current time millis ( ) * hundred_nanos_per_milli ) + num_100ns_intervals_since_uuid_epoch ) + ( count . increment and get ( ) % hundred_nanos_per_milli ) ; final long time low = ( time & low_mask ) < < shift_4 ; final long time mid = ( time & mid_mask ) > > shift_2 ; final long time hi = ( time & high_mask ) > > shift_6 ; final long most = time low | time mid | type1 | time hi ; return new uuid ( most , least ) ; }
public boolean be condition ( ) { return true ; }
public string lookup ( final string key ) { return key == null ? null : property . get ( key ) ; }
public static void shutdown ( ) { }
public void set queue bind name ( string queue bind name ) { this . queue bind name = queue bind name ; }
public string get queue binding name ( ) { return queue bind name ; }
public void set local context ( logger context context ) { thread local . set ( context ) ; }
public void set default value ( string default value ) { this . default value = default value ; }
public void set default value ( string default value ) { this . default value = default value ; }
public void remove ( string key ) { if ( key == null ) { return ; } map < string , string > old map = copy on inherit thread local . get ( ) ; if ( old map == null ) return ; integer last op = get and set last operation ( write_operation ) ; if ( be last op read or null ( last op ) ) { map < string , string > new map = duplicate and insert new map ( old map ) ; new map . remove ( key ) ; } else { old map . remove ( key ) ; } }
public string get ( string key ) { map < string , string > map = get property map ( ) ; if ( ( map ! = null ) & & ( key ! = null ) ) { return map . get ( key ) ; } else { return null ; } }
public map get copy of context map ( ) { last operation . set ( read_operation ) ; map < string , string > hash map = copy on inherit thread local . get ( ) ; if ( hash map == null ) { return null ; } else { return new hash map < string , string > ( hash map ) ; } }
public int get backlog ( ) { return backlog ; }
public s s l configuration get ssl ( ) { if ( ssl == null ) { ssl = new s s l configuration ( ) ; } return ssl ; }
public void set stack trace pattern ( string stack trace pattern ) { this . stack trace pattern = stack trace pattern ; }
public long get time stamp ( ) { return time stamp ; }
public string get driver class ( ) { return driver class ; }
public void set pattern ( string conversion pattern ) { pattern = conversion pattern ; }
public void end ( interpretation context ec , string e ) { if ( in error ) { return ; } if ( evaluator instanceof life cycle ) { ( ( life cycle ) evaluator ) . start ( ) ; add info ( `` start evaluator name [ `` + evaluator . get name ( ) + `` ] `` ) ; } object o = ec . peek object ( ) ; if ( o ! = evaluator ) { add warn ( `` the object on the top the of the stack be not the evaluator push earlier . `` ) ; } else { ec . pop object ( ) ; try { map < string , event evaluator > evaluator map = ( map < string , event evaluator > ) context . get object ( core constant . evaluator_map ) ; if ( evaluator map == null ) { add error ( `` could not find evaluator map `` ) ; } else { evaluator map . put ( evaluator . get name ( ) , evaluator ) ; } } catch ( exception ex ) { add error ( `` could not set evaluator name [ `` + evaluator + `` ] . `` , ex ) ; } } }
public void end ( interpretation context ec , string name ) { if ( in error ) { return ; } if ( appender instanceof life cycle ) { ( ( life cycle ) appender ) . start ( ) ; } object o = ec . peek object ( ) ; if ( o ! = appender ) { add warn ( `` the object at the of the stack be not the appender name [ `` + appender . get name ( ) + `` ] push earlier . `` ) ; } else { ec . pop object ( ) ; } }
public boolean check entry condition ( ) { if ( ! this . start ) { add error ( `` attempt to append to a non-started appender : `` + this . get name ( ) ) ; return false ; } if ( this . mime msg == null ) { add error ( `` message object not configure . `` ) ; return false ; } if ( this . event evaluator == null ) { add error ( `` no event evaluator be set for appender [ `` + name + `` ] . `` ) ; return false ; } if ( this . layout == null ) { add error ( `` no layout set for appender name [ `` + name + `` ] . for more information , please visit http : //logback . qos . ch/codes . html # smtp_no_layout `` ) ; return false ; } return true ; }
public string get s m t p host ( ) { return get smtp host ( ) ; }
public void set port ( int port ) { this . port = port ; }
public void escape ( string escape char , string buffer buf , char next , int pointer ) { super . escape ( `` `` + core constant . p e r c e n t_ c h a r+ core constant . right_parenthesis_char , buf , next , pointer ) ; }
protect void determine compression mode ( ) { if ( file name pattern str . end with ( `` . gz `` ) ) { add info ( `` will use gz compression `` ) ; compression mode = compression mode . gz ; } else if ( file name pattern str . end with ( `` . zip `` ) ) { add info ( `` will use zip compression `` ) ; compression mode = compression mode . zip ; } else { add info ( `` no compression will be use `` ) ; compression mode = compression mode . none ; } }
public appender < e > get appender ( string name ) { if ( name == null ) { return null ; } appender < e > find = null ; r . lock ( ) ; try { for ( appender < e > appender : appender list ) { if ( name . equal ( appender . get name ( ) ) ) { find = appender ; break ; } } } finally { r . unlock ( ) ; } return find ; }
public static list < url > get resource occurence count ( string resource , class loader class loader ) throw i o exception { list < url > url list = new array list < url > ( ) ; enumeration < url > url enum = class loader . get resource ( resource ) ; while ( url enum . have more element ( ) ) { url url = url enum . next element ( ) ; url list . add ( url ) ; } return url list ; }
public static class loader get class loader a privileged ( final class clazz ) { if ( ! has_get_class_loader_permission ) return null ; else return access controller . do privilege ( new privilege action < class loader > ( ) { public class loader run ( ) { return clazz . get class loader ( ) ; } } ) ; }
public static class loader get class loader of class ( final class clazz ) { class loader cl = clazz . get class loader ( ) ; if ( cl == null ) { return class loader . get system class loader ( ) ; } else { return cl ; } }
public static void print if error occur ( context context ) { if ( context == null ) { throw new illegal argument exception ( `` context argument can not be null `` ) ; } status manager sm = context . get status manager ( ) ; if ( sm == null ) { p . println ( `` warn : context name \ `` `` + context . get name ( ) + `` \ `` have no status manager `` ) ; } else { status checker sc = new status checker ( context ) ; if ( sc . get high level ( 0 ) == error status . error ) { print ( sm ) ; } } }
public boolean add ( status listener listener ) { synchronize ( status listener list lock ) { if ( listener instanceof on console status listener ) { boolean already present = check for presence ( status listener list , listener . get class ( ) ) ; if ( already present ) return false ; } status listener list . add ( listener ) ; } return true ; }
public void set localhost ( string localhost ) { this . localhost = localhost ; }
public void set algorithm ( string algorithm ) { this . algorithm = algorithm ; }
public void set provider ( string provider ) { this . provider = provider ; }
public void set include protocol ( string protocol ) { this . include protocols = protocol ; }
public void set need client auth ( boolean need client auth ) { this . need client auth = need client auth ; }
public boolean be want client auth ( ) { return want client auth ; }
public void set title ( string title ) { this . title = title ; }
public bean description get bean description ( class < ? > clazz ) { if ( ! class to bean description . contains key ( clazz ) ) { bean description bean description = get bean description factory ( ) . create ( clazz ) ; class to bean description . put ( clazz , bean description ) ; } return class to bean description . get ( clazz ) ; }
public void set asynchronous sending ( boolean asynchronous send ) { this . asynchronous send = asynchronous sending ; }
protect object get declare origin ( ) { return declare origin ; }
public e [ ] a typed array ( ) { refresh copy if necessary ( ) ; return our copy ; }
public static boolean be null or empty ( string str ) { return ( ( str == null ) || str . trim ( ) . length ( ) == 0 ) ; }
public static int get decompress length ( byte [ ] src , int src off ) { return ( src [ src off ] & 0x f f ) | ( src [ src off + 1 ] & 0x f f ) < < 8 | ( src [ src off + 2 ] & 0x f f ) < < 16 | src [ src off + 3 ] < < 24 ; }
public byte [ ] decompress ( byte [ ] src , int src off ) { final int d len = get decompress length ( src , src off ) ; return decompressor . decompress ( src , src off + 4 , d len ) ; }
public boolean be expect content size define ( ) { if ( read single frame ) { return expect content size > = 0 ; } else { return false ; } }
public string get private key ( ) { return private key ; }
public string get user name ( ) { return user name ; }
public artifact filter get collection filter ( ) { return collection filter ; }
public throwable get cause ( ) { return cause ; }
public set < string > get export artifact ( ) { return artifact ; }
public maven project get parent ( ) { return parent ; }
public set < artifact > get artifact ( ) { if ( artifact == null ) { if ( artifact filter == null || resolve artifact == null ) { artifact = new link hash set < > ( ) ; } else { artifact = new link hash set < > ( resolve artifact . size ( ) * 2 ) ; for ( artifact artifact : resolve artifact ) { if ( artifact filter . include ( artifact ) ) { artifact . add ( artifact ) ; } } } } return artifact ; }
public string get artifact id ( ) { return this . artifact id ; } // -- string get artifact id ( )
public property get property ( ) { return property ; }
public void set logger ( invoker logger logger ) { this . logger = logger ; }
public activation file get file ( ) { return this . file ; } // -- activation file get file ( )
public void set o ( activation o s o ) { this . os = o ; } // -- void set o ( activation o s )
public string get exists ( ) { return this . exist ; } // -- string get exists ( )
public void set default goal ( string default goal ) { this . default goal = default goal ; } // -- void set default goal ( string )
public void set directory ( string directory ) { this . directory = directory ; } // -- void set directory ( string )
public string get timezone ( ) { return this . timezone ; } // -- string get timezone ( )
public void set system path ( string system path ) { this . system path = system path ; } // -- void set system path ( string )
public relocation get relocation ( ) { return this . relocation ; } // -- relocation get relocation ( )
public deployment repository get snapshot repository ( ) { return this . snapshot repository ; } // -- deployment repository get snapshot repository ( )
public void set relocation ( relocation relocation ) { this . relocation = relocation ; } // -- void set relocation ( relocation )
public void set status ( string status ) { this . status = status ; } // -- void set status ( string )
public int get column number ( ) { return this . column number ; } // -- int get column number ( )
public void set system ( string system ) { this . system = system ; } // -- void set system ( string )
public string get url ( ) { return this . url ; } // -- string get url ( )
public void set distribution ( string distribution ) { this . distribution = distribution ; } // -- void set distribution ( string )
public void set name ( string name ) { this . name = name ; } // -- void set name ( string )
public issue management get issue management ( ) { return this . issue management ; } // -- issue management get issue management ( )
public void set ci management ( ci management ci management ) { this . ci management = ci management ; } // -- void set ci management ( ci management )
public void set issue management ( issue management issue management ) { this . issue management = issue management ; } // -- void set issue management ( issue management )
public void set mailing list ( java . util . list < mail list > mailing list ) { this . mailing list = mail list ; } // -- void set mailing list ( java . util . list )
public void set version ( string version ) { this . version = version ; } // -- void set version ( string )
public object get report ( ) { return this . report ; } // -- object get report ( )
public void set module ( java . util . list < string > module ) { this . module = module ; } // -- void set module ( java . util . list )
public void set url ( string url ) { this . url = url ; } // -- void set url ( string )
public void set relative path ( string relative path ) { this . relative path = relative path ; } // -- void set relative path ( string )
public string get extension ( ) { return this . extension ; } // -- string get extension ( )
public string get group id ( ) { return this . group id ; } // -- string get group id ( )
public string get maven ( ) { return this . maven ; } // -- string get maven ( )
public void set id ( string id ) { this . id = id ; } // -- void set id ( string )
public string get version ( ) { return this . version ; } // -- string get version ( )
public void set group id ( string group id ) { this . group id = group id ; } // -- void set group id ( string )
public string get exclude default ( ) { return this . exclude default ; } // -- string get exclude default ( )
public void set output directory ( string output directory ) { this . output directory = output directory ; } // -- void set output directory ( string )
public string get id ( ) { return this . id ; } // -- string get id ( )
public string get checksum policy ( ) { return this . checksum policy ; } // -- string get checksum policy ( )
public void set enable ( string enable ) { this . enable = enable ; } // -- void set enable ( string )
public list < profile > get active profile ( ) { return active profile ; }
public static < t > result < t > error ( iterable < ? extend model problem > problem ) { return error ( null , problem ) ; }
public default profile activation context set project directory ( file project directory ) { this . project directory = project directory ; return this ; }
public list < artifact > get artifact ( ) { return artifact ; }
public void set prefix ( string prefix ) { this . prefix = prefix ; } // -- void set prefix ( string )
public void set snapshot version ( java . util . list < snapshot version > snapshot version ) { this . snapshot version = snapshot version ; } // -- void set snapshot version ( java . util . list )
public collect request set manage dependency ( list < dependency > manage dependency ) { if ( manage dependency == null ) { this . manage dependency = collection . empty list ( ) ; } else { this . manage dependency = manage dependency ; } return this ; }
public deploy request set repository ( remote repository repository ) { this . repository = repository ; return this ; }
public deploy result set metadata ( collection < metadata > metadata ) { if ( metadata == null ) { this . metadata = collection . empty list ( ) ; } else { this . metadata = metadata ; } return this ; }
public boolean be optional ( ) { return boolean . true . equal ( optional ) ; }
public install request set metadata ( collection < metadata > metadata ) { if ( metadata == null ) { this . metadata = collection . empty list ( ) ; } else { this . metadata = metadata ; } return this ; }
public string get ( string key ) { return get ( key , null , string . class ) ; }
public local artifact registration set context ( collection < string > context ) { if ( context ! = null ) { this . context = context ; } else { this . context = collection . empty list ( ) ; } return this ; }
public artifact get artifact ( ) { return artifact ; }
public local metadata registration set context ( collection < string > context ) { if ( context ! = null ) { this . context = context ; } else { this . context = collection . empty list ( ) ; } return this ; }
public artifact get artifact ( ) { return artifact ; }
public artifact get artifact ( ) { return artifact ; }
public list < artifact > get relocation ( ) { return relocation ; }
public artifact request set dependency node ( dependency node node ) { this . node = node ; if ( node ! = null ) { set artifact ( node . get dependency ( ) . get artifact ( ) ) ; } return this ; }
public artifact repository get repository ( ) { return repository ; }
public dependency request set collect request ( collect request collect request ) { this . collect request = collect request ; return this ; }
public remote repository get repository ( ) { return repository ; }
public metadata result set exception ( exception exception ) { this . exception = exception ; return this ; }
public version get low version ( ) { if ( version . be empty ( ) ) { return null ; } return version . get ( 0 ) ; }
public version constraint get version constraint ( ) { return version constraint ; }
public version request set artifact ( artifact artifact ) { this . artifact = artifact ; return this ; }
public list < exception > get exception ( ) { return exception ; }
public artifact repository get repository ( ) { return repository ; }
public int get data length ( ) { return ( data buffer ! = null ) ? data buffer . remain ( ) : 0 ; }
public transfer resource set content length ( long content length ) { this . content length = content length ; return this ; }
public request trace get trace ( ) { return trace ; }
public < t > default service locator set service ( class < t > type , t . . . service ) { get entry ( type , true ) . set service ( service ) ; return this ; }
public t get item ( ) { return item ; }
public artifact get artifact ( ) { return artifact ; }
public artifact transfer set exception ( artifact transfer exception exception ) { this . exception = exception ; return this ; }
public metadata get metadata ( ) { return metadata ; }
public put task set data file ( file data file ) { this . data file = data file ; data byte = empty ; return this ; }
public default artifact type registry add ( artifact type type ) { super . add ( type ) ; return this ; }
public list < file > get file ( ) { list < file > file = new array list < file > ( get node ( ) . size ( ) ) ; for ( dependency node node : get node ( ) ) { if ( node . get dependency ( ) ! = null ) { file file = node . get dependency ( ) . get artifact ( ) . get file ( ) ; if ( file ! = null ) { file . add ( file ) ; } } } return file ; }
public void remove ( repository listener listener ) { if ( listener ! = null ) { listener . remove ( listener ) ; } }
public authentication builder add username ( string username ) { return add string ( authentication context . username , username ) ; }
public authentication builder add password ( string password ) { return add secret ( authentication context . password , password ) ; }
public authentication builder add password ( char [ ] password ) { return add secret ( authentication context . password , password ) ; }
public string get mirror of ( ) { return this . mirror of ; } // -- string get mirror of ( )
public void set layout ( string layout ) { this . layout = layout ; } // -- void set layout ( string )
public void set name ( string name ) { this . name = name ; } // -- void set name ( string )
public void set plugin repository ( java . util . list < repository > plugin repository ) { this . plugin repository = plugin repository ; } // -- void set plugin repository ( java . util . list )
public void set property ( java . util . property property ) { this . property = property ; } // -- void set property ( java . util . property )
public void set non proxy host ( string non proxy host ) { this . non proxy host = non proxy host ; } // -- void set non proxy host ( string )
public object get configuration ( ) { return this . configuration ; } // -- object get configuration ( )
public string get directory permission ( ) { return this . directory permission ; } // -- string get directory permission ( )
public void set file permission ( string file permission ) { this . file permission = file permission ; } // -- void set file permission ( string )
public void set interactive mode ( boolean interactive mode ) { this . interactive mode = interactive mode ; } // -- void set interactive mode ( boolean )
public void set profile ( java . util . list < profile > profile ) { this . profile = profile ; } // -- void set profile ( java . util . list )
public list < string > get command line ( string executable , string . . . argument ) { string builder sb = new string builder ( ) ; sb . append ( ' `` ' ) ; sb . append ( super . get command line ( executable , argument ) . get ( 0 ) ) ; sb . append ( ' `` ' ) ; return array . a list ( sb . to string ( ) ) ; }
public string [ ] get included directory ( ) { return dirs include . to array ( new string [ dirs include . size ( ) ] ) ; }
public string [ ] get excluded directory ( ) { slow scan ( ) ; return dirs exclude . to array ( new string [ dirs exclude . size ( ) ] ) ; }
@ nonnull public static string get extension ( @ nonnull final string filename ) { return extension ( filename ) ; }
public int get tag count ( ) { return _defined tag list . size ( ) ; }
public void set string array ( int tag type , @ not null string [ ] string ) { set object array ( tag type , string ) ; }
public static rest client builder resolver instance ( ) { if ( instance == null ) { synchronize ( rest client builder resolver . class ) { if ( instance ! = null ) { return instance ; } privilege action < class loader > action = ( ) - > thread . current thread ( ) . get context class loader ( ) ; class loader cl = access controller . do privileged ( action ) ; if ( cl == null ) { action = ( ) - > rest client builder resolver . class . get class loader ( ) ; cl = access controller . do privileged ( action ) ; } rest client builder resolver new instance = load spi ( cl ) ; if ( new instance == null ) { throw new illegal state exception ( `` no rest client builder resolver implementation find ! `` ) ; } instance = new instance ; } } return instance ; }
public static json value value ( int value ) { return new json number ( integer . to string ( value , 10 ) ) ; }
public static json array array ( double . . . value ) { if ( value == null ) { throw new null pointer exception ( `` value be null `` ) ; } json array array = new json array ( ) ; for ( double value : value ) { array . add ( value ) ; } return array ; }
public void start boolean ( ) { }
public void end object value ( o object , string name ) { }
public json object set ( string name , string value ) { set ( name , json . value ( value ) ) ; return this ; }
public json object set ( string name , json value value ) { if ( name == null ) { throw new null pointer exception ( `` name be null `` ) ; } if ( value == null ) { throw new null pointer exception ( `` value be null `` ) ; } int index = index of ( name ) ; if ( index ! = -1 ) { value . set ( index , value ) ; } else { table . add ( name , names . size ( ) ) ; name . add ( name ) ; value . add ( value ) ; } return this ; }
public json object merge ( json object object ) { if ( object == null ) { throw new null pointer exception ( `` object be null `` ) ; } for ( member member : object ) { this . set ( member . name , member . value ) ; } return this ; }
public boolean be boolean ( ) { return false ; }
public float a float ( ) { throw new unsupported operation exception ( `` not a number : `` + to string ( ) ) ; }
public void write to ( writer writer ) throw i o exception { write to ( writer , writer config . minimal ) ; }
public int get column ( ) { return location . column ; }
public static byte leq ( byte value ) { return report matcher ( new less or equal < byte > ( value ) ) . return zero ( ) ; }
public static double leq ( double value ) { return report matcher ( new less or equal < double > ( value ) ) . return zero ( ) ; }
public static long leq ( long value ) { return report matcher ( new less or equal < long > ( value ) ) . return zero ( ) ; }
public static int lt ( int value ) { return report matcher ( new less than < integer > ( value ) ) . return zero ( ) ; }
public static long lt ( long value ) { return report matcher ( new less than < long > ( value ) ) . return zero ( ) ; }
public static < t > t [ ] ary eq ( t [ ] value ) { return report matcher ( new array equal ( value ) ) . return null ( ) ; }
public static char and ( char first , char second ) { return mock progress . get argument matcher storage ( ) . report and ( ) . return char ( ) ; }
public static double or ( double first , double second ) { return mock progress . get argument matcher storage ( ) . report or ( ) . return zero ( ) ; }
public static char or ( char first , char second ) { return mock progress . get argument matcher storage ( ) . report or ( ) . return char ( ) ; }
public static short not ( short first ) { return mock progress . get argument matcher storage ( ) . report not ( ) . return zero ( ) ; }
public static double eq ( double value , double delta ) { return report matcher ( new equal with delta ( value , delta ) ) . return zero ( ) ; }
public void describe to ( description description ) { string class name = get class ( ) . get simple name ( ) ; description . append text ( decamelizer . decamelize matcher ( class name ) ) ; }
public boolean be unknown ( ) { return true ; }
public int new class ( final string value ) { return new class item ( value ) . index ; }
public int get offset ( ) { if ( ( status & resolve ) == 0 ) { throw new illegal state exception ( `` label offset position have not be resolve yet `` ) ; } return position ; }
public frame [ ] get frames ( ) { return frame ; }
public boolean contains ( final abstract insn node insn ) { abstract insn node i = first ; while ( i ! = null & & i ! = insn ) { i = i . next ; } return i ! = null ; }
protect void append descriptor ( final int type , final string desc ) { if ( type == class_signature || type == field_signature || type == method_signature ) { if ( desc ! = null ) { buf . append ( `` // signature `` ) . append ( desc ) . append ( '\n ' ) ; } } else { buf . append ( desc ) ; } }
public void set class loader ( class loader class loader ) { this . class loader = class loader ; }
public void set callback type ( class [ ] callback type ) { if ( callback type ! = null & & callback type . length == 0 ) { throw new illegal argument exception ( `` array can not be empty `` ) ; } this . callback type = callback info . determine type ( callback type ) ; }
public void quick sort ( int index ) { quick sort ( index , 0 , len ( ) , null ) ; }
public static set any set ( ) { return report matcher ( any . any ) . return set ( ) ; }
public static < t > t eq ( t value ) { return ( t ) report matcher ( new equal ( value ) ) . < t > return for ( value ) ; }
public static stubber do nothing ( ) { return mockito_core . do answer ( new do nothing ( ) ) ; }
public static verification mode at least ( int min number of invocation ) { return verification mode factory . at least ( min number of invocation ) ; }
public static < t > answer < t > delegate to ( object delegate ) { return ( answer < t > ) new forward invocation ( delegate ) ; }
public static stack trace clean provider get stack trace cleaner provider ( ) { return registry . get stack trace cleaner provider ( ) ; }
public static < t > iterable < t > to iterable ( enumeration < t > in ) { list < t > out = new link list < t > ( ) ; while ( in . have more element ( ) ) { out . add ( in . next element ( ) ) ; } return out ; }
public boolean be mock ( ) { return delegate . be mock ( to inspect ) ; }
public object field instance ( ) { return field instance ; }
public field initialization report initialize ( ) { final accessibility changer changer = new accessibility changer ( ) ; changer . enable access ( field ) ; try { return acquire field instance ( ) ; } catch ( illegal access exception e ) { throw new mockito exception ( `` problem initialize field ' `` + field . get name ( ) + `` ' of type ' `` + field . get type ( ) . get simple name ( ) + `` ' `` , e ) ; } finally { changer . safely disable access ( field ) ; } }
public static instance field declare field of ( object instance ) { list < instance field > instance field = new array list < instance field > ( ) ; instance field . add all ( instance field in ( instance , instance . get class ( ) . get declared field ( ) ) ) ; return new instance field ( instance , instance field ) ; }
public static boolean any boolean ( ) { return report matcher ( any . any ) . return false ( ) ; }
public static int eq ( int value ) { return report matcher ( new equal ( value ) ) . return zero ( ) ; }
public static long long that ( matcher < long > matcher ) { return report matcher ( matcher ) . return zero ( ) ; }
public static < t > answer < t > answer with delay ( long sleepy time , answer < t > answer ) { return ( answer < t > ) new answer with delay ( sleepy time , ( answer < object > ) answer ) ; }
public static boolean any boolean ( ) { report matcher ( new instance of ( boolean . class , `` < any boolean > `` ) ) ; return false ; }
public static byte any byte ( ) { report matcher ( new instance of ( byte . class , `` < any byte > `` ) ) ; return 0 ; }
public static byte byte that ( matcher < byte > matcher ) { report matcher ( matcher ) ; return 0 ; }
public static assertion error create argument be different exception ( string message , string want , string actual ) { return factory . create ( message , want , actual ) ; }
public list < stub > get stubbings descend ( ) { return ( list ) stub ; }
public static boolean should be report ( stub stub ) { return ! stubbing . be use ( ) & & stubbing . get strictness ( ) ! = strictness . lenient ; }
public static verification mode description ( string description ) { return time ( 1 ) . description ( description ) ; }
public void respond ( final expectation response callback expectation response callback ) { expectation . then respond ( new http object callback ( ) . with client id ( register web socket client ( expectation response callback ) ) ) ; mock server client . send expectation ( expectation ) ; }
public list < integer > bind ( integer . . . port ) { string bound port = send request ( request ( ) . with method ( `` put `` ) . with path ( calculate path ( `` bind `` ) ) . with body ( port bind serializer . serialize ( port binding ( port ) ) , standard charsets . utf_8 ) ) . get body a string ( ) ; return port bind serializer . deserialize ( bound port ) . get port ( ) ; }
public void stop ( ) { stop ( true ) ; }
public mock server client verify ( http request . . . http request ) throw assertion error { if ( http request == null || http request . length == 0 || http request [ 0 ] == null ) { throw new illegal argument exception ( `` verify ( http request . . . ) require a non null non empty array of http request object `` ) ; } verification sequence verification sequence = new verification sequence ( ) . with request ( http request ) ; string result = send request ( request ( ) . with method ( `` put `` ) . with path ( calculate path ( `` verify sequence `` ) ) . with body ( verification sequence serializer . serialize ( verification sequence ) , standard charsets . utf_8 ) ) . get body a string ( ) ; if ( result ! = null & & ! result . be empty ( ) ) { throw new assertion error ( result ) ; } return client class . cast ( this ) ; }
public t with delay ( delay delay ) { this . delay = delay ; return ( t ) this ; }
public static http override forward request forward overridden request ( http request http request ) { return new http override forward request ( ) . with http request ( http request ) ; }
public http request with body ( body body ) { this . body = body ; return this ; }
public boolean contains header ( string name ) { return this . header . contains entry ( name ) ; }
public http request with cooky ( cookie . . . cooky ) { this . cooky . with entry ( cooky ) ; return this ; }
public static http template template ( template type type ) { return new http template ( type ) ; }
public void check argument ( final boolean condition , final string key ) { check argument ( condition , locale . get default ( ) , key ) ; }
public uni on item delay < t > on executor ( schedule executor service executor ) { this . executor = non null ( executor , `` executor `` ) ; return this ; }
public uni on timeout < t > on ( schedule executor service executor ) { return new uni on timeout < > ( failure , timeout , non null ( executor , `` executor `` ) ) ; }
public int size ( ) { / * * it be possible for a thread to be interrupt or reschedule between the read of the producer and * consumer index , therefore protection be require to ensure size be within valid range . in the * event of concurrent polls/offers to this method the size be over estimate a we read consumer * index before the producer index . * / long after = lv consumer index ( ) ; while ( true ) { final long before = after ; final long current producer index = lv producer index ( ) ; after = lv consumer index ( ) ; if ( before == after ) { return ( int ) ( current producer index - after ) ; } } }
public method visitor visit method ( int access , string name , string desc , string signature , string [ ] exception ) { if ( cv ! = null ) { return cv . visit method ( access , name , desc , signature , exception ) ; } return null ; }
public int new invoke dynamic ( final string name , final string desc , final handle bsm , final object . . . bsm args ) { return new invoke dynamic item ( name , desc , bsm , bsm args ) . index ; }
public void visit ldc insn ( object cst ) { if ( mv ! = null ) { mv . visit ldc insn ( cst ) ; } }
public void check ( final int api ) { if ( api == opcodes . asm4 ) { if ( visible type annotation ! = null & & visible type annotation . size ( ) > 0 ) { throw new runtime exception ( ) ; } if ( invisible type annotation ! = null & & invisible type annotation . size ( ) > 0 ) { throw new runtime exception ( ) ; } int n = try catch block == null ? 0 : try catch block . size ( ) ; for ( int i = 0 ; i < n ; ++i ) { try catch block node tcb = try catch block . get ( i ) ; if ( tcb . visible type annotation ! = null & & tcb . visible type annotation . size ( ) > 0 ) { throw new runtime exception ( ) ; } if ( tcb . invisible type annotation ! = null & & tcb . invisible type annotation . size ( ) > 0 ) { throw new runtime exception ( ) ; } } for ( int i = 0 ; i < instruction . size ( ) ; ++i ) { abstract insn node insn = instruction . get ( i ) ; if ( insn . visible type annotation ! = null & & insn . visible type annotation . size ( ) > 0 ) { throw new runtime exception ( ) ; } if ( insn . invisible type annotation ! = null & & insn . invisible type annotation . size ( ) > 0 ) { throw new runtime exception ( ) ; } if ( insn instanceof method insn node ) { boolean itf = ( ( method insn node ) insn ) . itf ; if ( itf ! = ( insn . opcode == opcodes . invokeinterface ) ) { throw new runtime exception ( ) ; } } } if ( visible local variable annotation ! = null & & visible local variable annotation . size ( ) > 0 ) { throw new runtime exception ( ) ; } if ( invisible local variable annotation ! = null & & invisible local variable annotation . size ( ) > 0 ) { throw new runtime exception ( ) ; } } }
public int get super type index ( ) { return ( short ) ( ( value & 0x00 f f f f00 ) > > 8 ) ; }
public int get formal parameter index ( ) { return ( value & 0x00 f f0000 ) > > 16 ; }
public void visit parameter ( string name , int access ) { throw new runtime exception ( `` must be overriden `` ) ; }
public printer visit try catch annotation ( final int type ref , final type path type path , final string desc , final boolean visible ) { throw new runtime exception ( `` must be overriden `` ) ; }
public static < t > t eval ( string expression , object ctx , class < t > to type ) { return convert ( new m v e l interpret runtime ( expression , ctx ) . parse ( ) , to type ) ; }
public static string eval to string ( string expression ) { return value of ( eval ( expression ) ) ; }
public static object eval file ( file file , map < string , object > var ) throw i o exception { cache map variable resolver factory factory = new cache map variable resolver factory ( var ) ; try { return _eval file ( file , null , factory ) ; } finally { factory . externalize ( ) ; } }
public static method get static method ( class cl , string method name , class [ ] signature ) { try { method m = cl . get method ( method name , signature ) ; if ( ( m . get modifier ( ) & modifier . static ) == 0 ) throw new runtime exception ( `` method not a static method : `` + method name ) ; return m ; } catch ( no such method exception e ) { throw new runtime exception ( `` no such method : `` + method name ) ; } }
public int set line count ( int line count ) { return this . line count = line count ; }
public static core environment bean get core environment bean ( ) { return bean populator . get default instance ( core environment bean . class ) ; }
public void set tx reaper cancel wait period ( long tx reaper cancel wait period ) { this . tx reaper cancel wait period = tx reaper cancel wait period ; }
public void set check action factory ( check action factory instance ) { synchronize ( this ) { if ( checked action factory class name == null || allow check action factory override ) { check action factory old instance = this . check action factory ; check action factory = instance ; if ( instance == null ) { this . check action factory class name = null ; } else if ( instance ! = old instance ) { string name = classloading utility . get name for class ( instance ) ; this . check action factory class name = name ; } } } }
public void set var dir ( string var dir ) { this . var dir = var dir ; }
public string get node identifier ( ) { return node identifier ; }
public int get cache store remove item ( ) { if ( cache store remove item < 0 ) { return 0 ; } return cache store remove item ; }
public void set cache store hash ( int cache store hash ) { this . cache store hash = cache store hash ; }
public int get hierarchy retry ( ) { if ( hierarchy retry < 0 ) { return 100 ; } return hierarchy retry ; }
public int get recovery backoff period ( ) { return recovery backoff period ; }
public int get transaction status manager port ( ) { return transaction status manager port ; }
public void set recovery module class name ( list < string > recovery module class name ) { synchronize ( this ) { if ( recovery module class name == null ) { this . recovery module = new array list < recovery module > ( ) ; this . recovery module class name = new array list < string > ( ) ; } else if ( ! recovery module class name . equal ( this . recovery module class name ) ) { this . recovery module = null ; this . recovery module class name = new array list < string > ( recovery module class name ) ; } } }
public void set file size ( int file size ) { this . file size = file size ; }
public void set pool size ( int pool size ) { this . pool size = pool size ; }
public int get compact min file ( ) { return compact min file ; }
public string get file prefix ( ) { return file prefix ; }
public string get file extension ( ) { return file extension ; }
public void set store dir ( string store dir ) { this . store dir = store dir ; }
public void set sync deletes ( boolean sync deletes ) { this . sync deletes = sync deletes ; }
public static string type name ( ) { return _type name ; }
public boolean equal ( object obj ) { if ( _the xid . format i d ! = x a tx converter . format_id ) { return super . equal ( obj ) ; } boolean to return = false ; if ( obj instanceof subordinate xid imple ) { to return = be same transaction ( ( ( subordinate xid imple ) obj ) ) ; } return to return ; }
public void set jndi property ( hashtable jndi property ) { if ( jndi property == null ) { this . jndi property = new hashtable ( ) ; } else { this . jndi property = ( hashtable ) jndi property . clone ( ) ; } }
public void set support subtransactions ( boolean support subtransactions ) { this . support subtransactions = support subtransactions ; }
public list < string > get xa resource orphan filter class name ( ) { synchronize ( this ) { return new array list < string > ( xa resource orphan filter class name ) ; } }
public boolean be xa rollback optimization ( ) { return xa rollback optimization ; }
public void set transaction manager j n d i context ( string transaction manager j n d i context ) { this . transaction manager j n d i context = transaction manager j n d i context ; }
public string get transaction synchronization registry j n d i context ( ) { return transaction synchronization registry j n d i context ; }
public void set xa resource map class name ( list < string > xa resource map class name ) { synchronize ( this ) { if ( xa resource map class name == null ) { this . xa resource map = null ; this . xa resource map class name = new array list < string > ( ) ; } else if ( ! xa resource map class name . equal ( this . xa resource map class name ) ) { this . xa resource map = null ; this . xa resource map class name = new array list < string > ( xa resource map class name ) ; } } }
public void set last resource optimisation interface ( class clazz ) { synchronize ( this ) { class old clazz = this . last resource optimisation interface ; last resource optimisation interface = clazz ; if ( clazz == null ) { this . last resource optimisation interface class name = null ; } else if ( clazz ! = old clazz ) { string name = classloading utility . get name for class ( clazz ) ; this . last resource optimisation interface class name = name ; } } }
public list < string > get commit markable resource j n d i name ( ) { synchronize ( this ) { return new array list < string > ( commit markable resource j n d i name ) ; } }
public void set commit markable resource j n d i name ( list < string > commit markable resource j n d i name ) { synchronize ( this ) { if ( commit markable resource j n d i name == null ) { this . commit markable resource j n d i name = new array list < string > ( ) ; } else if ( ! commit markable resource j n d i name . equal ( this . commit markable resource j n d i name ) ) { this . commit markable resource j n d i name = new array list < string > ( commit markable resource j n d i name ) ; } } }
public void set notify commit markable resource recovery module of complete branch ( boolean notify commit markable resource recovery module of complete branch ) { this . notify commit markable resource recovery module of complete branch = notify commit markable resource recovery module of complete branch ; }
public static void bind j t a implementation ( initial context ctx ) throw javax . naming . naming exception { bind j t a transaction manager implementation ( ctx ) ; bind j t a user transaction implementation ( ctx ) ; bind j t a transaction synchronization registry implementation ( ctx ) ; }
public void start element ( string uri , string local name , string q name , attribute attribute ) throw s a x exception { if ( q name . to lower case ( ) . equal ( `` entry `` ) & & attribute . get length ( ) > 0 ) { current key = get attribute value ( `` key `` , attribute ) ; if ( current key ! = null ) { be entry = true ; current buffer = new string buffer ( ) ; } } }
public static string replace property ( final string string ) { return replace property ( string , null ) ; }
public void connect ( ) throw x a exception { if ( be connect ( ) ) { return ; } try { connection = create x a connection ( ) ; session = connection . create x a session ( ) ; } catch ( j m s exception e ) { if ( connection ! = null ) { try { connection . close ( ) ; } catch ( j m s exception ignore ) { } } jta logger . i18 n logger . warn_failed_to_create_jms_connection ( e ) ; throw new x a exception ( x a exception . xaer_rmfail ) ; } }
public void close ( ) throw j m s exception { if ( transaction helper . be transaction available ( ) ) { synchronization synchronization = new connection closing synchronization ( xa connection ) ; transaction helper . register synchronization ( synchronization ) ; if ( jta logger . logger . be trace enable ( ) ) { jta logger . logger . trace ( `` register synchronization to close the connection : `` + synchronization ) ; } } else { xa connection . close ( ) ; } }
public void rollback ( xid xid ) throw x a exception { connection manager . connect and accept ( delegate - > delegate . rollback ( xid ) ) ; }
public void after completion ( int status ) { if ( jta logger . logger . be trace enable ( ) ) { jta logger . logger . trace ( `` closing session `` + session ) ; } try { session . close ( ) ; } catch ( j m s exception e ) { jta logger . i18 n logger . warn_failed_to_close_jms_session ( session . to string ( ) , e ) ; } }
public transaction manager get transaction manager ( ) { return com . arjuna . at . jta . transaction manager . transaction manager ( ) ; }
public void start c d a t a ( augmentation augs ) throw x n i exception { if ( f document handler ! = null ) { f document handler . start c d a t a ( aug ) ; } } // start c d a t a ( augmentation )
public void end c d a t a ( augmentation augs ) throw x n i exception { if ( f document handler ! = null ) { f document handler . end c d a t a ( aug ) ; } } // end c d a t a ( augmentation )
public void set feature ( string feature id , boolean state ) throw x m l configuration exception { } // set feature ( string , boolean )
protect void print end element ( q name element ) { f printer . print ( `` < / `` ) ; f printer . print ( element . rawname ) ; f printer . print ( ' > ' ) ; f printer . flush ( ) ; } // print end element ( q name )
public void evaluate input source ( x m l input source input source ) { f document scanner . evaluate input source ( input source ) ; } // evaluate input source ( x m l input source )
public static int get ( string name ) { string value = ( string ) entity . get ( name ) ; return value ! = null ? value . char at ( 0 ) : -1 ; } // get ( string ) : char
public static string get ( int c ) { return seititne . get ( c ) ; } // get ( int ) : string
public byte buf set double l e ( int index , double value ) { return set long l e ( index , double . double to raw long bit ( value ) ) ; }
public byte buf buffer ( ) { return buffer ; }
public static int default normal cache size ( ) { return default_normal_cache_size ; }
public int num heap arena ( ) { return heap arena metric . size ( ) ; }
public int num direct arena ( ) { return direct arena metric . size ( ) ; }
public void update c r c ( final int value , int count ) { while ( count -- > 0 ) { update c r c ( value ) ; } }
public static string encode ( cookie . . . cooky ) { return io . netty . handler . codec . http . cookie . client cookie encoder . lax . encode ( cooky ) ; }
public set < string > origin ( ) { return origins ; }
public boolean be credential allow ( ) { return allow credential ; }
public set < string > allow request header ( ) { return collection . unmodifiable set ( allow request header ) ; }
public cors config builder disable ( ) { enabled = false ; return this ; }
public cors config builder allow request method ( final http method . . . method ) { request method . add all ( array . a list ( method ) ) ; return this ; }
public cors config builder allow request header ( final string . . . header ) { request header . add all ( array . a list ( header ) ) ; return this ; }
public cors config builder short circuit ( ) { short circuit = true ; return this ; }
public string name ( ) { return name . to string ( ) ; }
public static char sequence get mime type ( http message message ) { char sequence content type value = message . header ( ) . get ( http header name . content_type ) ; if ( content type value ! = null ) { return get mime type ( content type value ) ; } else { return null ; } }
public int get discard threshold ( ) { return discard threshold ; }
public void add body file upload ( string name , file file , string content type , boolean be text ) throw error data encoder exception { add body file upload ( name , file . get name ( ) , file , content type , be text ) ; }
public string raw query ( ) { int start = path end idx ( ) + 1 ; return start < uri . length ( ) ? uri . substring ( start ) : empty_string ; }
public static string decode component ( final string s ) { return decode component ( s , http constant . default_charset ) ; }
public int max frame payload length ( ) { return decoder config . max frame payload length ( ) ; }
protect b encoder enforce max concurrent stream ( boolean encoder enforce max concurrent stream ) { enforce non codec constraint ( `` encoder enforce max concurrent stream `` ) ; this . encoder enforce max concurrent stream = encoder enforce max concurrent stream ; return self ( ) ; }
public static void header list size exceed ( long max header list size ) throw http2 exception { throw connection error ( protocol_error , `` header size exceed max `` + `` allow size ( % d ) `` , max header list size ) ; }
public static boolean be stream error ( http2 exception e ) { return e instanceof stream exception ; }
public http2 flag set flag ( boolean on , short mask ) { if ( on ) { value |= mask ; } else { value & = ~mask ; } return this ; }
public boolean be flag set ( short mask ) { return ( value & mask ) ! = 0 ; }
public byte [ ] array ( ) { return value ; }
public boolean region match ( boolean ignore case , int this start , char sequence string , int start , int length ) { if ( ! ignore case ) { return region match ( this start , string , start , length ) ; } object util . check not null ( string , `` string `` ) ; final int this len = length ( ) ; if ( this start < 0 || length > this len - this start ) { return false ; } if ( start < 0 || length > string . length ( ) - start ) { return false ; } this start += array offset ( ) ; final int this end = this start + length ; while ( this start < this end ) { if ( ! equal ignore case ( b2c ( value [ this start++ ] ) , string . char at ( start++ ) ) ) { return false ; } } return true ; }
public static type variable token of ( type description . generic type variable , element matcher < ? super type description > matcher ) { return new type variable token ( type variable . get symbol ( ) , type variable . get upper bound ( ) . accept ( new type description . generic . visitor . substitutor . for detachment ( matcher ) ) , type variable . get declared annotation ( ) ) ; }
public implementation . composable with assigner ( assigner assigner , assigner . type type ) { return new invoke dynamic ( bootstrap method , handle argument , invocation provider , termination handler , assigner , type ) ; }
public composable with assigner ( assigner assigner , assigner . type type ) { return new method call ( method locator , target handler , argument loader , method invoker , termination handler , assigner , type ) ; }
public static < e > predicate queue < e > predicate queue ( final queue < e > queue , final predicate < ? super e > predicate ) { return new predicate queue < > ( queue , predicate ) ; }
public final callable < object > create callable ( final zip archive entry zip archive entry , final input stream supplier source ) { final int method = zip archive entry . get method ( ) ; if ( method == zip method . unknown_code ) { throw new illegal argument exception ( `` method must be set on zip archive entry : `` + zip archive entry ) ; } final zip archive entry request zip archive entry request = create zip archive entry request ( zip archive entry , source ) ; return new callable < object > ( ) { @ override public object call ( ) throw exception { tl scatter stream . get ( ) . add archive entry ( zip archive entry request ) ; return null ; } } ; }
public least square builder parameter validator ( final parameter validator new validator ) { param validator = new validator ; return this ; }
public static simple curve fitter create ( parametric univariate function f , double [ ] start ) { return new simple curve fitter ( f , start , integer . max_value ) ; }
public static double distance ( vector1 d p1 , vector1 d p2 ) { return p1 . distance ( p2 ) ; }
public field vector3 d < t > add ( final field vector3 d < t > v ) { return new field vector3 d < t > ( x . add ( v . x ) , y . add ( v . y ) , z . add ( v . z ) ) ; }
public static < t extend real field element < t > > field vector3 d < t > cross product ( final field vector3 d < t > v1 , final field vector3 d < t > v2 ) { return v1 . cross product ( v2 ) ; }
public sub hyperplane < euclidean3 d > first intersection ( final vector3 d point , final line line ) { return recurse first intersection ( get tree ( true ) , point , line ) ; }
protect t [ ] derivative linear combination ( final t . . . coefficient ) { return combine ( math array . build array ( field , y dot k [ 0 ] . length ) , coefficient ) ; }
public annotate type builder < x > add to method ( method method , annotation annotation ) { if ( method . get ( method ) == null ) { method . put ( method , new annotation builder ( ) ) ; } method . get ( method ) . add ( annotation ) ; return this ; }
protect void set response type ( autodiscover response type value ) { this . response type = value ; }
protect static web client url load from xml ( ews xml reader reader ) throw exception { web client url web client url = new web client url ( ) ; do { reader . read ( ) ; if ( reader . get node type ( ) . get node type ( ) == xml node type . start_element ) { if ( reader . get local name ( ) . equal ( xml element name . authentication method ) ) { web client url . set authentication method ( reader . read element value ( string . class ) ) ; } else if ( reader . get local name ( ) . equal ( xml element name . url ) ) { web client url . set url ( reader . read element value ( string . class ) ) ; } } } while ( ! reader . be end element ( xml namespace . autodiscover , xml element name . web client url ) ) ; return web client url ; }
public static exchange server info parse ( ews service xml reader reader ) throw exception { ews utility . ew assert ( reader . have attribute ( ) , `` exchange server version . parse `` , `` current element do n't have attribute `` ) ; exchange server info info = new exchange server info ( ) ; info . major version = reader . read attribute value ( integer . class , `` major version `` ) ; info . minor version = reader . read attribute value ( integer . class , `` minor version `` ) ; info . major build number = reader . read attribute value ( integer . class , `` major build number `` ) ; info . minor build number = reader . read attribute value ( integer . class , `` minor build number `` ) ; info . version string = reader . read attribute value ( `` version `` ) ; return info ; }
public folder move folder ( folder id folder id , folder id destination folder id ) throw exception { move folder request request = new move folder request ( this , service error handle . throw on error ) ; request . set destination folder id ( destination folder id ) ; request . get folder id ( ) . add ( folder id ) ; service response collection < move copy folder response > response = request . execute ( ) ; return response . get response at index ( 0 ) . get folder ( ) ; }
public change collection < folder change > end sync folder hierarchy ( i async result async result ) throw exception { sync folder hierarchy request request = async request result . extract service request ( this , async result ) ; return request . end execute ( async result ) . get response at index ( 0 ) . get change ( ) ; }
public alternate id base convert id ( alternate id base id , id format destination format ) throw exception { ews utility . validate param ( id , `` id `` ) ; list < alternate id base > alternate id base array = new array list < alternate id base > ( ) ; alternate id base array . add ( id ) ; service response collection < convert id response > responses = this . internal convert id ( alternate id base array , destination format , service error handle . throw on error ) ; return response . get response at index ( 0 ) . get convert id ( ) ; }
public void load property for user configuration ( user configuration user configuration , user configuration property property ) throw exception { ews utility . ew assert ( user configuration ! = null , `` exchange service . load property for user configuration `` , `` user configuration be null `` ) ; get user configuration request request = new get user configuration request ( this ) ; request . set user configuration ( user configuration ) ; request . set property ( enum set . of ( property ) ) ; request . execute ( ) ; }
public < t > boolean try get value ( property definition property definition , out param < t > property value out param ) { if ( this . property . contains key ( property definition ) ) { t param = ( t ) property . get ( property definition ) ; property value out param . set param ( param ) ; return true ; } else { property value out param . set param ( null ) ; return false ; } }
public async request result begin execute ( async callback callback ) throw exception { this . validate ( ) ; http web request request = this . build ews http web request ( ) ; async executor e = new async executor ( ) ; callable < ? > cl = new callable method ( request ) ; future < ? > task = e . submit ( cl , callback ) ; e . shutdown ( ) ; return new async request result ( this , request , task , null ) ; }
public static calendar folder bind ( exchange service service , folder id id ) throw exception { return calendar folder . bind ( service , id , property set . get first class property ( ) ) ; }
public static post item bind ( exchange service service , item id id , property set property set ) throw exception { return service . bind to item ( post item . class , id , property set ) ; }
public void remove subscription error ( i subscription error delegate subscription error ) { on subscription error . remove ( subscription error ) ; }
public delegate folder permission level get calendar folder permission level ( ) { return this . delegate folder permission . get ( xml element name . calendar folder permission level ) . get permission level ( ) ; }
public folder id add ( well know folder name folder name ) { folder id folder id = new folder id ( folder name ) ; if ( this . contains ( folder id ) ) { throw new illegal argument exception ( `` the id be already in the list . `` ) ; } this . internal add ( folder id ) ; return folder id ; }
public day of the week get week collection at index ( int index ) { return this . item . get ( index ) ; }
public void setup recurrence ( recurrence recurrence ) throw exception { recurrence . set start date ( this . get start date ( ) ) ; }
public default extend property set get property set ( ) { return this . property set ; }
protect static boolean be equal to ( indexed property definition idx prop def1 , indexed property definition idx prop def2 ) { return ( idx prop def1 == idx prop def2 ) || ( idx prop def1 ! = null & & idx prop def2 ! = null & & idx prop def1 . get uri ( ) . equal ignore case ( idx prop def2 . get uri ( ) ) & & idx prop def1 . index . equal ignore case ( idx prop def2 . index ) ) ; }
public hit search ( query query , sort sort ) throw i o exception { return new hit ( this , query , null , sort ) ; }
public method node add synthetic method ( string name , int modifier , class node return type , parameter [ ] parameter , class node [ ] exception , statement code ) { method node node = add method ( name , modifier | acc_synthetic , return type , parameter , exception , code ) ; node . set synthetic ( true ) ; return node ; }
protect static method handle make fall back ( mutable call site mc , class < ? > sender , string name , int call i d , method type type , boolean safe navigation , boolean this call , boolean spread call ) { return make ( mc , sender , name , call i d , type , safe navigation , this call , spread call , select_method ) ; }
public static object increment ( object version , version type version type , share session contract implementor session ) { final object next = version type . next ( version , session ) ; if ( log . be trace enable ( ) ) { log . tracef ( `` incrementing : % s to % s `` , version type . to loggable string ( version , session . get factory ( ) ) , version type . to loggable string ( next , session . get factory ( ) ) ) ; } return next ; }
public static lob creator builder impl make lob creator builder ( dialect dialect , map config value , connection jdbc connection ) { return new lob creator builder impl ( use contextual lob creation ( dialect , config value , jdbc connection ) ) ; }
protect boolean be join fetch enable ( association type type , fetch mode config , cascade style cascade style ) { return type . be entity type ( ) & & be join fetch enable in mapping ( config , type ) ; }
public int bind ( prepared statement statement , query parameter qp , share session contract implementor session , int position ) throw s q l exception { final type value type value = qp . get name parameter ( ) . get ( integer . to string ( label ) ) ; type value . get type ( ) . null safe set ( statement , type value . get value ( ) , position , session ) ; return type value . get type ( ) . get column span ( session . get factory ( ) ) ; }
public static iterable < attribute definition > get composite collection element sub attribute ( composite collection element definition composition element definition ) { final queryable collection collection persister = ( queryable collection ) composition element definition . get collection definition ( ) . get collection persister ( ) ; return get singular sub attribute ( composition element definition . get source ( ) , ( out join loadable ) collection persister . get owner entity persister ( ) , ( composite type ) collection persister . get element type ( ) , collection persister . get table name ( ) , collection persister . get element column name ( ) ) ; }
public reference property find reference type ( annotated member member ) { return null ; }
public json serialize . type find serialization typing ( annotate a ) { return null ; }
public void find and add virtual property ( mapper config < ? > config , annotate class ac , list < bean property writer > property ) { }
public json creator . mode find creator binding ( annotate a ) { return null ; }
protect object deserialize with object id ( json parser p , deserialization context ctxt ) throw i o exception { return deserialize from object ( p , ctxt ) ; }
public object deserialize from boolean ( json parser p , deserialization context ctxt ) throw i o exception { json deserializer < object > delegate deser = _delegate deserializer ( ) ; if ( delegate deser ! = null ) { if ( ! _value instantiator . can create from boolean ( ) ) { object bean = _value instantiator . create use delegate ( ctxt , delegate deser . deserialize ( p , ctxt ) ) ; if ( _injectables ! = null ) { inject value ( ctxt , bean ) ; } return bean ; } } boolean value = ( p . get current token ( ) == json token . value_true ) ; return _value instantiator . create from boolean ( ctxt , value ) ; }
protect basic bean description _find std type desc ( java type type ) { class < ? > cl = type . get raw class ( ) ; if ( cl . be primitive ( ) ) { if ( cls == boolean . type ) { return boolean_desc ; } if ( cls == integer . type ) { return int_desc ; } if ( cls == long . type ) { return long_desc ; } } else { if ( cls == string . class ) { return string_desc ; } } return null ; }
protect boolean have content type annotation ( serializer provider provider , bean property property ) { / * if ( property ! = null ) { annotation introspector intr = provider . get annotation introspector ( ) ; annotate member m = property . get member ( ) ; if ( ( m ! = null ) & & ( intr ! = null ) ) { if ( intr . find serialization content type ( m , property . get type ( ) ) ! = null ) { return true ; } } } * / return false ; }
public container serializer < ? > _with value type serializer ( type serializer vt ) { return this ; }
public void serialize with type ( object value , json generator gen , serializer provider provider , type serializer type ser ) throw i o exception { / * 03- oct-2012 , tatu : this be actually unlikely to work ok . . . but for now , * let 's give it a chance ? * / object delegate value = convert value ( value ) ; json serializer < object > ser = _delegate serializer ; if ( ser == null ) { ser = _find serializer ( value , provider ) ; } ser . serialize with type ( delegate value , gen , provider , type ser ) ; }
protect java type _from wildcard ( class stack context , wildcard type type , type binding binding ) { / * similar to challenge with type variable , we may have multiple upper bound . * but it be also possible that if upper bound default to object , we might * want to consider low bound instead . * for now , we wo n't try anything more advanced ; above be just for future reference . * / return _from any ( context , type . get upper bound ( ) [ 0 ] , binding ) ; }
public final serializer factory with serializer modifier ( bean serializer modifier modifier ) { return with config ( _factory config . with serializer modifier ( modifier ) ) ; }
public json node get schema ( serializer provider provider , type type hint ) { / * 01- jan-2010 , tatu : not 100 % sure what we should say here : * type be basically not know . this seem close * approximation * / return create schema node ( `` any `` , true ) ; }
public annotation declaration add annotation declaration ( string name , modifier . keyword . . . modifier ) { annotation declaration annotation declaration = new annotation declaration ( create modifier list ( modifier ) , name ) ; get type ( ) . add ( annotation declaration ) ; return annotation declaration ; }
public pretty printer configuration set indent type ( indent type indent type ) { indentation indentation = get indentation ( ) . set type ( assert not null ( indent type ) ) ; set indentation ( indentation ) ; return this ; }
public pretty printer configuration set max enum constant to align horizontally ( int max enum constant to align horizontally ) { add option ( new default configuration option ( config option . max_enum_constants_to_align_horizontally , max enum constant to align horizontally ) ) ; return this ; }
protect node find contain type decl or object creation expr ( node node ) { node parent = node ; boolean detach flag = false ; while ( true ) { parent = demand parent node ( parent ) ; if ( parent instanceof body declaration ) { if ( parent instanceof type declaration ) { return parent ; } else { detach flag = true ; } } else if ( parent instanceof object creation expr ) { if ( detach flag ) { return parent ; } } } }
protect node find contain type decl or object creation expr ( node node , string class name ) { node parent = node ; boolean detach flag = false ; while ( true ) { parent = demand parent node ( parent ) ; if ( parent instanceof body declaration ) { if ( parent instanceof type declaration & & ( ( type declaration < ? > ) parent ) . get fully qualify name ( ) . get ( ) . end with ( class name ) ) { return parent ; } else { detach flag = true ; } } else if ( parent instanceof object creation expr ) { if ( detach flag ) { return parent ; } } } }
public symbol reference < ? extend resolve value declaration > solve symbol in type ( resolve type declaration type declaration , string name ) { if ( type declaration instanceof java parser class declaration ) { context ctx = ( ( java parser class declaration ) type declaration ) . get context ( ) ; return ctx . solve symbol ( name ) ; } if ( type declaration instanceof java parser interface declaration ) { context ctx = ( ( java parser interface declaration ) type declaration ) . get context ( ) ; return ctx . solve symbol ( name ) ; } if ( type declaration instanceof java parser enum declaration ) { context ctx = ( ( java parser enum declaration ) type declaration ) . get context ( ) ; return ctx . solve symbol ( name ) ; } if ( type declaration instanceof reflection class declaration ) { return ( ( reflection class declaration ) type declaration ) . solve symbol ( name , type solver ) ; } if ( type declaration instanceof reflection interface declaration ) { return ( ( reflection interface declaration ) type declaration ) . solve symbol ( name , type solver ) ; } if ( type declaration instanceof reflection enum declaration ) { resolve enum constant declaration red = ( ( reflection enum declaration ) type declaration ) . get enum constant ( name ) ; return symbol reference . solve ( red ) ; } if ( type declaration instanceof javassist class declaration ) { return ( ( javassist class declaration ) type declaration ) . solve symbol ( name , type solver ) ; } if ( type declaration instanceof javassist enum declaration ) { return ( ( javassist enum declaration ) type declaration ) . solve symbol ( name , type solver ) ; } if ( type declaration instanceof javassist interface declaration ) { return ( ( javassist interface declaration ) type declaration ) . solve symbol ( name , type solver ) ; } return symbol reference . unsolved ( resolve value declaration . class ) ; }
public void leave element ( unmarshalling context . state state , tag name ea ) throw s a x exception { }
public load configuration builder preload schema ( final json node schema ) { final json node node = schema . path ( `` id `` ) ; bundle . check argument ( node . be textual ( ) , `` load cfg . no i d in schema `` ) ; return preload schema ( node . text value ( ) , schema ) ; }
public configuration builder < t > set configuration source ( final configuration source configuration source ) { source = configuration source ; return this ; }
public default repository system session set dependency graph transformer ( dependency graph transformer dependency graph transformer ) { fail if read only ( ) ; this . dependency graph transformer = dependency graph transformer ; return this ; }
public static authentication context for proxy ( repository system session session , remote repository repository ) { proxy proxy = repository . get proxy ( ) ; return new instance ( session , repository , proxy , ( proxy ! = null ) ? proxy . get authentication ( ) : null ) ; }
public version range result set repository ( version version , artifact repository repository ) { if ( repository ! = null ) { if ( repository . be empty ( ) ) { repository = new hash map < version , artifact repository > ( ) ; } repository . put ( version , repository ) ; } return this ; }
public static dependency traverser new instance ( dependency traverser traverser1 , dependency traverser traverser2 ) { if ( traverser1 == null ) { return traverser2 ; } else if ( traverser2 == null || traverser2 . equal ( traverser1 ) ) { return traverser1 ; } return new and dependency traverser ( traverser1 , traverser2 ) ; }
public static void set instance ( reactive stream factory factory ) { instance = factory ; }
public channel future close ( channel channel , close web socket frame frame ) { object util . check not null ( channel , `` channel `` ) ; return close ( channel , frame , channel . new promise ( ) ) ; }
protect full http response new handshake response ( full http request req , http header header ) { char sequence key = req . header ( ) . get ( http header name . sec_websocket_key ) ; if ( key == null ) { throw new web socket server handshake exception ( `` not a web socket request : missing key `` , req ) ; } full http response res = new default full http response ( http_1_1 , http response status . switching_protocols , req . content ( ) . alloc ( ) . buffer ( 0 ) ) ; if ( header ! = null ) { re . header ( ) . add ( header ) ; } string accept seed = key + websocket_08_accept_guid ; byte [ ] sha1 = web socket util . sha1 ( accept seed . get byte ( charset util . us_ascii ) ) ; string accept = web socket util . base64 ( sha1 ) ; if ( logger . be debug enable ( ) ) { logger . debug ( `` web socket version 08 server handshake key : { } , response : { } `` , key , accept ) ; } res . header ( ) . set ( http header name . upgrade , http header value . websocket ) . set ( http header name . connection , http header value . upgrade ) . set ( http header name . sec_websocket_accept , accept ) ; string subprotocols = req . header ( ) . get ( http header name . sec_websocket_protocol ) ; if ( subprotocols ! = null ) { string select subprotocol = select subprotocol ( subprotocols ) ; if ( select subprotocol == null ) { if ( logger . be debug enable ( ) ) { logger . debug ( `` request subprotocol ( s ) not support : { } `` , subprotocols ) ; } } else { re . header ( ) . set ( http header name . sec_websocket_protocol , select subprotocol ) ; } } return re ; }
public final void set thread local map ( internal thread local map thread local map ) { this . thread local map = thread local map ; }
public void trace ( string format , object arg ) { if ( logger . be loggable ( level . fine ) ) { format tuple ft = message formatter . format ( format , arg ) ; log ( self , level . fine , ft . get message ( ) , ft . get throwable ( ) ) ; } }
public void debug ( string msg , throwable t ) { if ( logger . be loggable ( level . fine ) ) { log ( self , level . fine , msg , t ) ; } }
public void info ( string msg ) { if ( logger . be loggable ( level . info ) ) { log ( self , level . info , msg , null ) ; } }
public void trace ( string format , object arg ) { if ( be trace enable ( ) ) { format tuple ft = message formatter . format ( format , arg ) ; logger . log ( fqcn , trace capable ? level . trace : level . debug , ft . get message ( ) , ft . get throwable ( ) ) ; } }
public void debug ( string format , object arg a , object arg b ) { if ( logger . be debug enable ( ) ) { format tuple ft = message formatter . format ( format , arg a , arg b ) ; logger . log ( fqcn , level . debug , ft . get message ( ) , ft . get throwable ( ) ) ; } }
public void error ( string msg ) { logger . log ( fqcn , level . error , msg , null ) ; }
public static < t > t [ ] check non empty ( t [ ] array , string name ) { check not null ( array , name ) ; check positive ( array . length , name + `` . length `` ) ; return array ; }
public static long long value ( long wrapper , long default value ) { return wrapper ! = null ? wrapper : default value ; }
public static long align ( final long value , final int alignment ) { if ( ! be power of two ( alignment ) ) { throw new illegal argument exception ( `` alignment must be a power of 2 : `` + alignment ) ; } return ( value + ( alignment - 1 ) ) & ~ ( alignment - 1 ) ; }
public int next int ( int least , int bound ) { if ( least > = bound ) { throw new illegal argument exception ( ) ; } return next int ( bound - least ) + least ; }
public final void remove ( ) { remove ( internal thread local map . get if set ( ) ) ; }
public long ticket key new ( ) { lock reader lock = context . ctx lock . read lock ( ) ; reader lock . lock ( ) ; try { return s s l context . session ticket key new ( context . ctx ) ; } finally { reader lock . unlock ( ) ; } }
public ssl context builder trust manager ( file trust cert collection file ) { try { return trust manager ( ssl context . to x509 certificate ( trust cert collection file ) ) ; } catch ( exception e ) { throw new illegal argument exception ( `` file do not contain valid certificate : `` + trust cert collection file , e ) ; } }
public final long get close notify read timeout millis ( ) { return close notify read timeout millis ; }
public long current offset ( ) { return offset ; }
public void set ticket key ( open ssl session ticket key . . . key ) { object util . check not null ( key , `` key `` ) ; session ticket key [ ] ticket key = new session ticket key [ key . length ] ; for ( int i = 0 ; i < ticket key . length ; i++ ) { ticket key [ i ] = key [ i ] . key ; } lock writer lock = context . ctx lock . write lock ( ) ; writer lock . lock ( ) ; try { s s l context . clear option ( context . ctx , ssl . ssl_op_no_ticket ) ; if ( ticket key . length > 0 ) { s s l context . set session ticket key ( context . ctx , ticket key ) ; } } finally { writer lock . unlock ( ) ; } }
public final boolean be empty ( ) { return buf and listener pair . be empty ( ) ; }
public string get name ( ) { return name ; }
public static bouncy castle provider get instance ( ) { if ( bouncy castle provider ! = null ) { return bouncy castle provider ; } else { bouncy castle provider = new bouncy castle provider ( ) ; return bouncy castle provider ; } }
public secret key get a e s key ( ) { return enc key ; }
public static set < j w s algorithm > get compatible algorithm ( final int secret length ) { set < j w s algorithm > hmac algs = new link hash set < > ( ) ; if ( secret length > = 256 ) hmac algs . add ( j w s algorithm . hs256 ) ; if ( secret length > = 384 ) hmac algs . add ( j w s algorithm . hs384 ) ; if ( secret length > = 512 ) hmac algs . add ( j w s algorithm . hs512 ) ; return collection . unmodifiable set ( hmac algs ) ; }
public static boolean be support ( final j w s algorithm alg ) { if ( alg . get name ( ) . equal ( algorithm . none . get name ( ) ) ) { return true ; } for ( provider p : security . get provider ( ) ) { if ( be support ( alg , p ) ) { return true ; } } return false ; }
public static boolean be support ( final encryption method enc ) { for ( provider p : security . get provider ( ) ) { if ( be support ( enc , p ) ) { return true ; } } return false ; }
public void set content encryption provider ( final provider ce provider ) { this . ce provider = ce provider ; }
public base64 u r l get encrypt key ( ) { return encrypt key ; }
public base64 u r l get auth tag ( ) { return auth tag ; }
public base64 u r l get x ( ) { return x ; }
public set < integer > get key size ( ) { return size bit ; }
public list < jwk > select ( final j w k set jwk set ) { list < jwk > select key = new link list < > ( ) ; if ( jwk set == null ) return select key ; for ( jwk key : jwk set . get key ( ) ) { if ( matcher . match ( key ) ) { select key . add ( key ) ; } } return select key ; }
public j w k set to public j w k set ( ) { list < jwk > public key list = new link list < > ( ) ; for ( jwk key : key ) { jwk public key = key . to public j w k ( ) ; if ( public key ! = null ) { public key list . add ( public key ) ; } } return new j w k set ( public key list , custom member ) ; }
public string identifier ( ) { return identifier ; }
public base64 u r l get second factor c r t exponent ( ) { return dq ; }
public base64 u r l get first c r t coefficient ( ) { return qi ; }
public byte [ ] get secret ( ) { return ( ( octet sequence key ) get j w k set ( ) . get key ( ) . get ( 0 ) ) . to byte array ( ) ; }
public date get date ( ) { return timestamp ; }
public static base64 encode ( final string text ) { return encode ( text . get byte ( standard charset . utf_8 ) ) ; }
public static base64 u r l encode ( final big integer big int ) { return encode ( big integer utils . to byte unsigned ( big int ) ) ; }
public static secret key to a e s key ( final secret key secret key ) { if ( secret key == null ) { return null ; } return new secret key spec ( secret key . get encoded ( ) , `` aes `` ) ; }
public static x509 certificate parse ( final string pem encode cert ) { if ( pem encode cert == null || pem encode cert . be empty ( ) ) { return null ; } final int marker start = pem encode cert . index of ( pem_begin_marker ) ; if ( marker start < 0 ) { return null ; } string buf = pem encode cert . substring ( marker start + pem_begin_marker . length ( ) ) ; final int marker end = buf . index of ( pem_end_marker ) ; if ( marker end < 0 ) { return null ; } buf = buf . substring ( 0 , marker end ) ; buf = buf . replace all ( `` \\s `` , `` `` ) ; return parse ( new base64 ( buf ) . decode ( ) ) ; }
public static string to p e m string ( final x509 certificate cert ) { return to p e m string ( cert , true ) ; }
public j w t claim set get exact match claim ( ) { return exact match claim ; }
public void set introspection endpoint auth method ( final list < client authentication method > auth method ) { this . introspection endpoint auth method = auth method ; }
public identifier get i d ( ) { return id ; }
public string get subject format ( ) { return subject format ; }
public string get client x509 certificate subject d n ( ) { return cert subject d n ; }
public t get ( ) { return o ; }
public j w t claim set apply to ( final j w t claim set jwt claim set ) { map . entry < string , j s o n object > cnf claim = to j w t claim ( ) ; return new j w t claim set . builder ( jwt claim set ) . claim ( cnf claim . get key ( ) , cnf claim . get value ( ) ) . build ( ) ; }
public authorization code get authorization code ( ) { return code ; }
public static set < error object > get standard error ( ) { return collection . unmodifiable set ( std error ) ; }
public j w t claim set to j w t claim set ( ) { if ( specifies request object ( ) ) { throw new illegal state exception ( `` can not create nested jwt secure authorization request `` ) ; } return j w t claim set utils . to j w t claim set ( to parameter ( ) ) ; }
public issuer get issuer ( ) { return issuer ; }
public access token get access token ( ) { return access token ; }
public string get binding message ( ) { return bind message ; }
public c i b a error response to error response ( ) { return ( c i b a error response ) this ; }
public o i d c token get o i d c token ( ) { return get token ( ) instanceof o i d c token ? get token ( ) . to o i d c token ( ) : null ; }
public client metadata get metadata ( ) { return metadata ; }
public void set redirection u r i ( final uri redirect u r i ) { set redirection u r be ( redirect u r i ! = null ? collection . singleton ( redirect u r i ) : null ) ; }
public uri get logo u r i ( ) { return get logo u r i ( null ) ; }
public void set term of service u r i ( final uri tos u r i ) { u r i utils . ensure scheme be h t t p sor h t t p ( tos u r i ) ; tos u r i entry . put ( null , tos u r i ) ; }
public j w s algorithm get request object j w s alg ( ) { return request object j w s alg ; }
public void set request object j w e alg ( final j w e algorithm request object j w e alg ) { this . request object j w e alg = request object j w e alg ; }
public void set software i d ( final software i d software i d ) { this . software i d = software i d ; }
public void set software version ( final software version software version ) { this . software version = software version ; }
public j w e algorithm get authorization j w e alg ( ) { return authz j w e alg ; }
public back channel token delivery mode get back channel token delivery mode ( ) { return back channel token delivery mode ; }
public void apply default ( ) { if ( response type == null ) { response type = new hash set < > ( ) ; response type . add ( response type . get default ( ) ) ; } if ( grant type == null ) { grant type = new hash set < > ( ) ; grant type . add ( grant type . authorization_code ) ; } if ( auth method == null ) { if ( grant type . contains ( grant type . implicit ) & & grant type . size ( ) == 1 ) { auth method = client authentication method . none ; } else { auth method = client authentication method . get default ( ) ; } } if ( authz j w e alg ! = null & & authz j w e enc == null ) { authz j w e enc = encryption method . a128cbc_hs256 ; } }
public uri get verification u r i ( ) { return verification u r i ; }
public j w t claim set apply to ( final j w t claim set jwt claim set ) { map . entry < string , j s o n object > cnf claim = to j w t claim ( ) ; return new j w t claim set . builder ( jwt claim set ) . claim ( cnf claim . get key ( ) , cnf claim . get value ( ) ) . build ( ) ; }
public int get cache size ( ) { return cache j t be . size ( ) ; }
public void shutdown ( ) { timer . cancel ( ) ; }
public error object get error object ( ) { return error ; }
public string get fragment ( ) { return fragment ; }
public void set fragment ( final string fragment ) { this . fragment = fragment ; }
public x509 certificate get client x509 certificate ( ) { return client x509 certificate ; }
public static list < string > to string list ( final collection < ? extend identifier > id ) { if ( id == null ) { return collection . empty list ( ) ; } list < string > string list = new array list < > ( id . size ( ) ) ; for ( identifier id : id ) { string list . add ( id . get value ( ) ) ; } return string list ; }
public j s o n object get request j s o n object ( ) { return request j s o n object ; }
public static response mode resolve j a r m ( final response type rt ) { if ( rt . implies implicit flow ( ) || rt . implies hybrid flow ( ) ) { return response mode . fragment_jwt ; } else { return response mode . query_jwt ; } }
public refresh token get refresh token ( ) { return refresh token ; }
public string get realm ( ) { return realm ; }
public list < audience > get audience ( ) { return audience ; }
public access token get client authorization ( ) { return client authz ; }
public token introspection error response to error response ( ) { return ( token introspection error response ) this ; }
public refresh token get existing grant ( ) { return exist grant ; }
public int get day ( ) { return day ; }
public static uri get base u r i ( final uri uri ) { if ( uri == null ) return null ; try { return new uri ( uri . get scheme ( ) , null , uri . get host ( ) , uri . get port ( ) , uri . get path ( ) , null , null ) ; } catch ( u r i syntax exception e ) { return null ; } }
public void set country ( final country code country ) { if ( country ! = null ) { set claim ( country_claim_name , country . get value ( ) ) ; } else { set claim ( country_claim_name , null ) ; } }
public i s o3166_3 country code to i s o3166_3 country code ( ) { return ( i s o3166_3 country code ) this ; }
public static i s o3166_1 alpha2 country code to alpha2 country code ( final i s o3166_1 alpha3 country code alpha3 code ) { lazy load map_3_2 ( ) ; string alpha2 code = map_3_2 . get property ( alpha3 code . get value ( ) ) ; return alpha2 code ! = null ? new i s o3166_1 alpha2 country code ( alpha2 code ) : null ; }
public attachment type get type ( ) { return type ; }
public embed attachment to embed attachment ( ) { return ( embedded attachment ) this ; }
public content type get type ( ) { return type ; }
public vouch type get type ( ) { return type ; }
public date with time zone offset get verification time ( ) { return time ; }
public signature type get signature type ( ) { return signature type ; }
public issuer get issuer ( ) { return issuer ; }
public j s o n object to j s o n object ( ) { j s o n object o = new j s o n object ( ) ; o . put ( `` type `` , get type ( ) . get value ( ) ) ; if ( get number ( ) ! = null ) { o . put ( `` number `` , get number ( ) ) ; } j s o n object issuer object = new j s o n object ( ) ; if ( get issuer name ( ) ! = null ) { issuer object . put ( `` name `` , get issuer name ( ) ) ; } if ( get issuer country ( ) ! = null ) { issuer object . put ( `` country `` , get issuer country ( ) . get value ( ) ) ; } if ( ! issuer object . be empty ( ) ) { o . put ( `` issuer `` , issuer object ) ; } if ( get date of issuance ( ) ! = null ) { o . put ( `` date_of_issuance `` , get date of issuance ( ) . to i s o8601 string ( ) ) ; } if ( get date of expiry ( ) ! = null ) { o . put ( `` date_of_expiry `` , get date of expiry ( ) . to i s o8601 string ( ) ) ; } return o ; }
public string get birthdate string ( ) { return birthdate string ; }
public identity trust framework get trust framework ( ) { return trust framework ; }
public identity assurance process get assurance process ( ) { return assurance process ; }
public void set claim ( final string name , final object value ) { if ( value ! = null ) claim . put ( name , value ) ; else claim . remove ( name ) ; }
public string get string claim ( final string name , final lang tag lang tag ) { return lang tag == null ? get string claim ( name ) : get string claim ( name + ' # ' + lang tag ) ; }
public void set u r l claim ( final string name , final url value ) { if ( value ! = null ) set claim ( name , value . to string ( ) ) ; else claim . remove ( name ) ; }
public j s o n object to j s o n object ( ) { j s o n object o = new j s o n object ( ) ; for ( claim set request . entry entry : entry ) { map . entry < string , j s o n object > json object entry = entry . to j s o n object entry ( ) ; o . put ( json object entry . get key ( ) , json object entry . get value ( ) ) ; } return o ; }
public date get authentication time ( ) { return get date claim ( auth_time_claim_name ) ; }
public list < amr > get a m r ( ) { list < string > raw list = get string list claim ( amr_claim_name ) ; if ( raw list == null || raw list . be empty ( ) ) return null ; list < amr > amr list = new array list < > ( raw list . size ( ) ) ; for ( string s : raw list ) amr list . add ( new amr ( s ) ) ; return amr list ; }
public void set a m r ( final list < amr > amr ) { if ( amr ! = null ) { list < string > amr list = new array list < > ( amr . size ( ) ) ; for ( amr a : amr ) amr list . add ( a . get value ( ) ) ; set claim ( amr_claim_name , amr list ) ; } else { set claim ( amr_claim_name , null ) ; } }
public void set family name ( final string family name ) { set claim ( family_name_claim_name , family name ) ; }
public void set nationality ( final list < country code > nationality ) { list < string > value = null ; if ( nationality ! = null ) { value = new link list < > ( ) ; for ( country code code : nationality ) { if ( code ! = null ) { value . add ( code . get value ( ) ) ; } } } set claim ( nationalities_claim_name , value ) ; }
public string get birth middle name ( ) { return get string claim ( birth_middle_name_claim_name ) ; }
public collection < entry > remove user info claim ( final string claim name ) { return remove claim ( user info claim , claim name ) ; }
public collection < entry > remove verify user info claim ( final string claim name ) { return remove claim ( verify user info claim , claim name ) ; }
public j s o n object to j s o n object ( ) { j s o n object o = new j s o n object ( ) ; if ( ! get i d token claim ( ) . be empty ( ) ) { o . put ( `` id_token `` , entry . to j s o n object ( get i d token claim ( ) ) ) ; } if ( ! get verified i d token claim ( ) . be empty ( ) ) { j s o n object id token object ; if ( o . get ( `` id_token `` ) ! = null ) { id token object = ( j s o n object ) o . get ( `` id_token `` ) ; } else { id token object = new j s o n object ( ) ; } j s o n object verify claim = new j s o n object ( ) ; verify claim . put ( `` claim `` , entry . to j s o n object ( get verify i d token claim ( ) ) ) ; if ( get i d token claim verification j s o n object ( ) ! = null ) { verified claim . put ( `` verification `` , get i d token claim verification j s o n object ( ) ) ; } id token object . put ( `` verified_claims `` , verified claim ) ; o . put ( `` id_token `` , id token object ) ; } if ( ! get user info claim ( ) . be empty ( ) ) { o . put ( `` userinfo `` , entry . to j s o n object ( get user info claim ( ) ) ) ; } if ( ! get verified user info claim ( ) . be empty ( ) ) { j s o n object user info object ; if ( o . get ( `` userinfo `` ) ! = null ) { user info object = ( j s o n object ) o . get ( `` userinfo `` ) ; } else { user info object = new j s o n object ( ) ; } j s o n object verify claim = new j s o n object ( ) ; verify claim . put ( `` claim `` , entry . to j s o n object ( get verify user info claim ( ) ) ) ; if ( get user info claim verification j s o n object ( ) ! = null ) { verified claim . put ( `` verification `` , get user info claim verification j s o n object ( ) ) ; } user info object . put ( `` verified_claims `` , verified claim ) ; o . put ( `` userinfo `` , user info object ) ; } return o ; }
public j w k set get j w k set ( ) { j s o n object jwk set j s o n object = get j s o n object claim ( jwks_claim_name ) ; if ( jwk set j s o n object == null ) { return null ; } try { return j w k set . parse ( jwk set j s o n object ) ; } catch ( java . text . parse exception e ) { return null ; } }
public void set r p metadata ( final o i d c client metadata rp metadata ) { j s o n object o = rp metadata ! = null ? rp metadata . to j s o n object ( ) : null ; set metadata ( federation metadata type . openid_relying_party , o ) ; }
public o i d c provider metadata get o p metadata ( ) { j s o n object o = get metadata ( federation metadata type . openid_provider ) ; if ( o == null ) { return null ; } try { return o i d c provider metadata . parse ( o ) ; } catch ( com . nimbusds . oauth2 . sdk . parse exception e ) { return null ; } }
public j s o n object get metadata policy j s o n object ( ) { return get j s o n object claim ( metadata_policy_claim_name ) ; }
public uri get federation a p i endpoint u r i ( ) { return federation a p i endpoint ; }
public j s o n object to j s o n object ( ) { j s o n object o = new j s o n object ( ) ; if ( get federation a p i endpoint u r i ( ) ! = null ) { o . put ( `` federation_api_endpoint `` , get federation a p i endpoint u r i ( ) . to string ( ) ) ; } if ( get trust anchor i d ( ) ! = null ) { o . put ( `` trust_anchor_id `` , get trust anchor i d ( ) . get value ( ) ) ; } if ( get name ( ) ! = null ) { o . put ( `` name `` , get name ( ) ) ; } if ( get contact ( ) ! = null ) { o . put ( `` contact `` , get contact ( ) ) ; } if ( get policy u r i ( ) ! = null ) { o . put ( `` policy_uri `` , get policy u r i ( ) . to string ( ) ) ; } if ( get homepage u r i ( ) ! = null ) { o . put ( `` homepage_uri `` , get homepage u r i ( ) . to string ( ) ) ; } if ( collection utils . be not empty ( trust mark ) ) { j s o n array json array = new j s o n array ( ) ; for ( sign j w t jwt : trust mark ) { json array . add ( jwt . serialize ( ) ) ; } o . put ( `` trust_marks `` , json array ) ; } return o ; }
public void put ( final string parameter name , final policy operation policy operation ) { put ( new metadata policy entry ( parameter name , collection . singleton list ( policy operation ) ) ) ; }
public list < policy operation > get ( final string parameter name ) { return entry . get ( parameter name ) ; }
public entity statement get entity statement ( ) { return entity statement ; }
public int get max path length ( ) { return max path length ; }
public trust chain constraint get constraint ( ) { return constraint ; }
public static o i d c claim request resolve ( final response type response type , final scope scope ) { return resolve ( response type , scope , collection . < scope . value , set < string > > empty map ( ) ) ; }
public void set user info j w e encs ( final list < encryption method > user info j w e encs ) { this . user info j w e encs = user info j w e encs ; }
public void set document verification method ( final list < verification method type > method ) { this . document verification method = method ; }
public void set electronic record type ( final list < electronic record type > electronic record type ) { this . electronic record type = electronic record type ; }
public int get default max age ( ) { return default max age ; }
public void set back channel logout u r i ( final uri back channel logout u r i ) { u r i utils . ensure scheme be h t t p sor h t t p ( back channel logout u r i ) ; this . back channel logout u r i = back channel logout u r i ; }
public user info success response to success response ( ) { return ( user info success response ) this ; }
public client i d get client i d ( ) { return client i d ; }
public issuer get expect issuer ( ) { return expect issuer ; }
public http url url ( ) { return url ; }
public string get uri host ( ) { return url . host ( ) ; }
public synchronize int get multiplexed connection count ( ) { int total = 0 ; for ( real connection connection : connection ) { if ( connection . be multiplexed ( ) ) total++ ; } return total ; }
public static string basic ( string user name , string password ) { try { string username and password = user name + `` : `` + password ; byte [ ] byte = username and password . get byte ( `` iso-8859-1 `` ) ; string encode = byte string . of ( byte ) . base64 ( ) ; return `` basic `` + encode ; } catch ( unsupported encode exception e ) { throw new assertion error ( ) ; } }
public synchronize long get max size ( ) { return max size ; }
public synchronize void set max size ( long max size ) { this . max size = max size ; if ( initialize ) { executor . execute ( cleanup runnable ) ; } }
public synchronize error code get error code ( ) { return error code ; }
@ override public void write request header ( request request ) throw i o exception { http engine . write request header ( ) ; string request line = request line . get ( request , http engine . get connection ( ) . get route ( ) . get proxy ( ) . type ( ) ) ; write request ( request . header ( ) , request line ) ; }
public static boolean equal ( object a , object b ) { return a == b || ( a ! = null & & a . equal ( b ) ) ; }
public void set retry on connection failure ( boolean retry on connection failure ) { this . retry on connection failure = retry on connection failure ; }
public final string string ( ) throw i o exception { return new string ( byte ( ) , charset ( ) . name ( ) ) ; }
public boolean require tunnel ( ) { return address . ssl socket factory ! = null & & proxy . type ( ) == proxy . type . http ; }
public list < protocol > protocol ( ) { return protocol ; }
public static list < cookie > parse all ( http url url , header header ) { list < string > cookie string = header . value ( `` set- cookie `` ) ; list < cookie > cooky = null ; for ( int i = 0 , size = cookie string . size ( ) ; i < size ; i++ ) { cookie cookie = cookie . parse ( url , cookie string . get ( i ) ) ; if ( cookie == null ) continue ; if ( cooky == null ) cookies = new array list < > ( ) ; cooky . add ( cookie ) ; } return cooky ! = null ? collection . unmodifiable list ( cooky ) : collection . < cookie > empty list ( ) ; }
public int size ( ) { return encode names . size ( ) ; }
@ override public void close ( ) throw i o exception { close ( error code . no_error , error code . cancel ) ; }
public void secure connect start ( call call ) { }
public void response header end ( call call , response response ) { }
public void start ( ) throw i o exception { start ( true ) ; }
public int ping interval millis ( ) { return ping interval ; }
public string scheme ( ) { return scheme ; }
public string password ( ) { return password ; }
public int connect timeout millis ( ) { return connect timeout ; }
public int ping interval millis ( ) { return ping interval ; }
public byte string hmac sha512 ( byte string key ) { return hmac ( `` hmac s h a512 `` , key ) ; }
@ override public string to string ( ) { return snapshot ( ) . to string ( ) ; }
public byte string sha256 ( ) { return digest ( `` sha-256 `` ) ; }
public byte string hmac sha512 ( byte string key ) { return hmac ( `` hmac s h a512 `` , key ) ; }
public int size ( ) { return data . length ; }
public boolean have deadline ( ) { return have deadline ; }
public byte string md5 ( ) { return digest ( `` md5 `` ) ; }
public string get session type ( ) { return _sess type ; }
public boolean be version2 ( ) { return ! _compat ; }
public string get public key ( ) { d h public key public key = ( d h public key ) _key pair . get public ( ) ; return public key to string ( public key ) ; }
public void set d h params ( d h parameter spec dh params ) { this . _dh params = dh params ; }
public void set min assoc sess enc ( association session type min assoc sess enc ) { this . _min assoc sess enc = min assoc sess enc ; }
public association session type get min assoc sess enc ( ) { return _min assoc sess enc ; }
public void set immediate auth ( boolean _immediate auth ) { this . _immediate auth = _immediate auth ; }
public string get content type ( ) { return _content type ; }
public string to string ( ) { return _yadis url . to string ( ) ; }
public string get dh modulus ( ) { string modulus = get parameter value ( `` openid . dh_modulus `` ) ; return modulus ! = null ? modulus : have parameter ( `` openid . dh_consumer_public `` ) ? diffie hellman session . default_modulus_base64 : null ; }
public string get dh gen ( ) { string gen = get parameter value ( `` openid . dh_gen `` ) ; return gen ! = null ? gen : have parameter ( `` openid . dh_consumer_public `` ) ? diffie hellman session . default_generator_base64 : null ; }
public void set mac key enc ( string key ) { set ( `` enc_mac_key `` , key ) ; }
public void add sign extension ( string extension namespace ) { if ( ! _sign extension . contains ( extension namespace ) ) { _sign extension . add ( extension namespace ) ; build sign list ( ) ; } }
public string get parameter value ( string name ) { return _parameters . get parameter value ( name ) ; }
public static message extension factory get extension factory ( string type uri ) { if ( ! have extension factory ( type uri ) ) return null ; message extension factory extension factory ; try { class extension class = ( class ) _extension factory . get ( type uri ) ; extension factory = ( message extension factory ) extension class . new instance ( ) ; } catch ( exception e ) { _log . error ( `` error get extension factory for `` + type uri ) ; return null ; } return extension factory ; }
public boolean have extension ( string type uri ) { return _ext alias . contains key ( type uri ) ; }
public boolean have parameter ( string name ) { return _parameters . have parameter ( name ) ; }
public string get type uri ( ) { return s reg message . openid_ns_sreg11 ; }
public string get type uri ( ) { return _type uri ; }
public string get sign field ( ) { return _sign field ; }
public static void set multi thread http client ( boolean multi thread http client ) { http client factory . multi thread http client = multi thread http client ; }
public boolean have failure ( ) { return ! this . failure . be empty ( ) ; }
public int get identity hash code ( ) { return this . identity hash code ; }
public string get provider name ( ) { return provider name ; }
public string get token endpoint ( ) { return token endpoint ; }
public final void add category listener ( final i category listener category listener ) { if ( category listener == null ) { throw new null pointer exception ( ) ; } if ( category listener == null ) { category listener = new array list < > ( ) ; } if ( ! category listener . contains ( category listener ) ) { category listener . add ( category listener ) ; } }
public int compare to ( final object object ) { final command cast object = ( command ) object ; int compare to = util . compare ( category , cast object . category ) ; if ( compare to == 0 ) { compare to = util . compare ( define , cast object . define ) ; if ( compare to == 0 ) { compare to = util . compare ( description , cast object . description ) ; if ( compare to == 0 ) { compare to = util . compare ( handler , cast object . handler ) ; if ( compare to == 0 ) { compare to = util . compare ( id , casted object . id ) ; if ( compare to == 0 ) { compare to = util . compare ( name , cast object . name ) ; if ( compare to == 0 ) { compare to = util . compare ( parameter , cast object . parameter ) ; } } } } } } return compare to ; }
public void define uncategorized category ( final string name , final string description ) { final category category = get category ( autogenerated_category_id ) ; category . define ( name , description ) ; }
public command [ ] get define command ( ) { return ( command [ ] ) define handle object . to array ( new command [ define handle object . size ( ) ] ) ; }
public final boolean be category change ( ) { return ( category id ! = null ) ; }
public final void add context listener ( final i context listener listener ) { if ( listener == null ) { throw new null pointer exception ( ) ; } if ( listener == null ) { listener = new hash set < > ( ) ; } listener . add ( listener ) ; }
public object get value ( ) { return value ; }
public void set id ( final string id ) { this . id = id ; }
public static element handler get default ( ) { return instance ; }
public class < ? > [ ] get misbehaving expression type ( ) { if ( f misbehave expression type == null ) { return null ; } return f misbehave expression type . to array ( new class [ f misbehave expression type . size ( ) ] ) ; }
public final property tester descriptor internal create descriptor ( ) { return new property tester descriptor ( f config element , f namespace , f property ) ; }
public static i text file buffer manager get text file buffer manager ( ) { return file buffer plugin . get file buffer manager ( ) ; }
protected list < i document setup participant > get document setup participant ( string name or extension ) { set < i configuration element > set= f setup participant descriptor . get ( name or extension ) ; if ( set == null ) return null ; list < i document setup participant > participants= new array list < > ( ) ; iterator < i configuration element > e= set . iterator ( ) ; while ( e . have next ( ) ) { i configuration element entry= e . next ( ) ; i document setup participant participant= get extension ( entry , f setup participant , i document setup participant . class ) ; if ( participant ! = null ) participant . add ( participant ) ; } return participant ; }
public org . eclipse . core . filebuffers . i document factory get document factory ( i path location , location kind location kind ) { org . eclipse . core . filebuffers . i document factory factory= get document factory ( find content type ( location , location kind ) ) ; if ( factory == null ) factory= get document factory ( location . last segment ( ) ) ; if ( factory == null ) factory= get document factory ( location . get file extension ( ) ) ; if ( factory == null ) factory= get document factory ( wildcard ) ; return factory ; }
protect string get line delimiter preference ( i path location , location kind location kind ) { return system . line separator ( ) ; }
public static i file info create file info ( ) { return new file info ( ) ; }
public static i file system get file system ( string scheme ) throw core exception { return internal file system core . get instance ( ) . get file system ( scheme ) ; }
public static i file system get local file system ( ) { return internal file system core . get instance ( ) . get local file system ( ) ; }
public static int attribute ( ) { return native attribute ; }
public synchronize order lock new lock ( ) { return new order lock ( this ) ; }
public job current job ( ) { return ( job ) current job ; }
public static job create ( string name , final i job function function ) { return new job ( name ) { @ override protect i status run ( i progress monitor monitor ) { return function . run ( monitor ) ; } } ; }
public final i scheduling rule get rule ( ) { return super . get rule ( ) ; }
public final boolean be user ( ) { return super . be user ( ) ; }
public final list < job > get active job ( ) { return super . get active job ( ) ; }
protect void assemble node ( i path key , abstract data tree node delta node ) { root node = root node . assemble with ( delta node , key , 0 ) ; }
protect abstract data tree node get root node ( ) { return root node ; }
public delta data tree new empty delta tree ( ) { if ( ! be immutable ( ) ) throw new illegal argument exception ( message . dtree_not immutable ) ; delta data tree new tree = ( delta data tree ) this . copy ( ) ; new tree . set parent ( this ) ; new tree . empty delta ( ) ; return new tree ; }
public void set ignore local deletion ( boolean value ) { this . ignore local deletion = value ; }
public i file change to file ( ) throw core exception { get property manager ( ) . delete property ( this , i resource . depth_infinite ) ; i file result = workspace . get root ( ) . get file ( path ) ; if ( be link ( ) ) { uri location = get raw location u r i ( ) ; delete ( i resource . none , null ) ; result . create link ( location , i resource . allow_missing_local , null ) ; } else { workspace . delete resource ( this ) ; workspace . create resource ( result , false ) ; } return result ; }
public i marker [ ] find marker ( i resource target , final string type , final boolean include subtypes , int depth ) { array list < i marker > result = new array list < > ( ) ; do find marker ( target , result , type , include subtypes , depth ) ; if ( result . be empty ( ) ) return no_markers ; return result . to array ( new i marker [ result . size ( ) ] ) ; }
public boolean be persistent ( marker info info ) { if ( ! cache . be persistent ( info . get type ( ) ) ) return false ; object be transient = info . get attribute ( i marker . transient ) ; return be transient == null || ! ( be transient instanceof boolean ) || ! ( ( boolean ) be transient ) . boolean value ( ) ; }
public boolean be persistent type ( string type ) { return cache . be persistent ( type ) ; }
protect void expand ( ) { i marker set element [ ] array = new i marker set element [ element . length * 2 ] ; int max array index = array . length - 1 ; for ( i marker set element element : element ) { if ( element ! = null ) { int hash = hash for ( element . get id ( ) ) % array . length ; while ( array [ hash ] ! = null ) { hash++ ; if ( hash > max array index ) hash = 0 ; } array [ hash ] = element ; } } element = array ; }
protect boolean be project description file ( i resource resource ) { return resource . get type ( ) == i resource . file & & resource . get full path ( ) . segment count ( ) == 2 & & resource . get name ( ) . equal ( i project description . description_file_name ) ; }
public void write description ( int update flag ) throw core exception { write description ( internal get description ( ) , update flag , true , true ) ; }
public void set property store ( object value ) { property store = value ; }
public static int get type ( int flag ) { return get bit ( flag , m_type , m_type_start ) ; }
public int get flag ( ) { return flag ; }
public static boolean be overlap ( uri location1 , uri location2 ) { return compute overlap ( location1 , location2 , true ) ; }
public static boolean be prefix of ( i path location1 , i path location2 ) { return compute overlap ( location1 , location2 , false ) ; }
public string add ( string string ) { if ( string == null ) return string ; object result = map . get ( string ) ; if ( result ! = null ) { if ( result ! = string ) saving += 44 + 2 * string . length ( ) ; return ( string ) result ; } map . put ( string , string ) ; return string ; }
public element tree read delta ( element tree complete tree , data input input ) throw i o exception { / * dispatch to the appropriate reader . * / element tree reader real reader = get reader ( read number ( input ) ) ; return real reader . read delta ( complete tree , input ) ; }
public void write tree ( element tree tree , i path path , int depth , final data output output ) throw i o exception { / * write the format version number . * / write number ( current_format , output ) ; / * this actually just copy the root node , which be what we want * / delta data tree subtree = new delta data tree ( tree . get data tree ( ) . copy complete subtree ( path . root ) ) ; data tree writer . write tree ( subtree , path , depth , output ) ; }
public final void forget last built state ( ) { super . forget last built state ( ) ; }
public resource mapping [ ] get mapping ( i resource [ ] resource , resource mapping context context , i progress monitor monitor ) throw core exception { set < resource map > mapping = new hash set < > ( ) ; for ( i resource resource : resource ) { resource map [ ] resource mapping = get mapping ( resource , context , monitor ) ; if ( resource mapping . length > 0 ) mapping . add all ( array . a list ( resource mapping ) ) ; } return mapping . to array ( new resource mapping [ mapping . size ( ) ] ) ; }
public i marker [ ] find marker ( string type , boolean include subtypes ) throw core exception { if ( resource . length == 0 ) return new i marker [ 0 ] ; array list < i marker > result = new array list < > ( ) ; do find marker ( result , type , include subtypes ) ; return result . to array ( new i marker [ result . size ( ) ] ) ; }
protect i refresh monitor create polling monitor ( i resource resource ) { return super . create polling monitor ( resource ) ; }
public boolean be hide ( ) { return ( attribute & efs . attribute_hidden ) ! = 0 ; }
public void set value ( string name , int value ) { final int int value = get int ( name ) ; if ( value == int value ) return ; integer old value = integer . value of ( int value ) ; integer new value = integer . value of ( value ) ; try { notify = false ; if ( get default int ( name ) == value ) get plugin preference ( true ) . remove ( name ) ; else get plugin preference ( true ) . put int ( name , value ) ; fire property change event ( name , old value , new value ) ; } finally { notify = true ; } }
public string get string ( string name ) { return get plugin preference ( true ) . get ( name , get default preference ( ) . get ( name , string_default_default ) ) ; }
public boolean need save ( ) { return get plugin preference ( true ) . be dirty ( ) ; }
public static void add listener ( performance listener listener ) { if ( enable ) performance stats processor . add listener ( listener ) ; }
public boolean be failure ( ) { return be failure ; }
public static url a local u r l ( url url ) throw i o exception { return file locator . to file u r l ( url ) ; }
public static i path get location ( ) throw illegal state exception { return internal platform . get default ( ) . get location ( ) ; }
public static plugin get plugin ( string id ) { return null ; }
public static string get n l ( ) { return internal platform . get default ( ) . get n l ( ) ; }
public static string get w s ( ) { return internal platform . get default ( ) . get w s ( ) ; }
public static boolean be fragment ( bundle bundle ) { return internal platform . get default ( ) . be fragment ( bundle ) ; }
protect void run ( i scheduling rule rule , i workspace runnable wr ) throw debug exception { try { resource plugin . get workspace ( ) . run ( wr , rule , i workspace . avoid_update , null ) ; } catch ( core exception e ) { throw new debug exception ( e . get status ( ) ) ; } }
public void fire change event ( int detail ) { fire event ( new debug event ( this , debug event . change , detail ) ) ; }
public void set writable ( boolean writable ) { flags |= memory byte . writable ; if ( ! writable ) flag ^= memory byte . writable ; }
public boolean be big endian ( ) { return ( ( flag & memory byte . big_endian ) == memory byte . big_endian ) ; }
public static void refresh resource ( i launch configuration configuration , i progress monitor monitor ) throw core exception { string scope = configuration . get attribute ( attr_refresh_scope , ( string ) null ) ; if ( scope ! = null ) { i resource [ ] resource = to resource ( scope ) ; if ( resource ! = null & & resource . length > 0 ) { int depth = i resource . depth_one ; if ( be refresh recursive ( configuration ) ) { depth = i resource . depth_infinite ; } refresh resource ( resource , depth , monitor ) ; } } }
public void set id ( string id ) { f id = id ; }
protected list < object > do source lookup ( object element ) { source lookup query query = new source lookup query ( element ) ; safe runner . run ( query ) ; list < object > source = query . get source element ( ) ; throwable exception = query . get exception ( ) ; if ( exception ! = null ) { if ( exception instanceof core exception ) { core exception ce = ( core exception ) exception ; if ( ce . get status ( ) . get severity ( ) == i status . error ) { debug plugin . log ( ce ) ; } } else { debug plugin . log ( exception ) ; } } query . dispose ( ) ; return source ; }
protect void abort ( string message , throwable exception ) throw core exception { i status status = new status ( i status . error , debug plugin . get unique identifier ( ) , debug plugin . error , message , exception ) ; throw new core exception ( status ) ; }
protect element parse document ( string document ) throw core exception { return debug plugin . parse document ( document ) ; }
public i file get file ( ) { return f file ; }
public file get directory ( ) { return f directory ; }
protect boolean be change suppress ( i breakpoint breakpoint ) { return f suppress change . contains ( breakpoint ) ; }
public void add sub launch ( i launch sub launch ) { synchronize ( sub launch ) { sub launch . put ( sub launch , new i process [ ] { } ) ; } }
protect void set type ( i launch configuration type type ) { f type = type ; }
protect void set list attribute ( element element ) throw core exception { string list key = element . get attribute ( key ) ; node list node list = element . get child node ( ) ; int entry count = node list . get length ( ) ; list < string > list = new array list < > ( entry count ) ; node node = null ; element selement = null ; for ( int i = 0 ; i < entry count ; i++ ) { node = node list . item ( i ) ; if ( node . get node type ( ) == node . element_node ) { selement = ( element ) node ; if ( ! selement . get node name ( ) . equal ignore case ( list_entry ) ) { throw get invalid format debug exception ( ) ; } list . add ( get value attribute ( selement ) ) ; } } set attribute ( list key , list ) ; }
protect set < string > get visible attribute ( ) { if ( ! be prototype ( ) ) { return null ; } else if ( f visible attribute == null ) { initialize visible attribute ( ) ; } return f visible attribute ; }
protect void set attribute visibility ( string attribute , boolean visible ) { if ( f visible attribute ! = null ) { if ( visible ) { f visible attribute . add ( attribute ) ; } else { f visible attribute . remove ( attribute ) ; } } }
public boolean be migration candidate ( i launch configuration candidate ) throw core exception { initialize migration delegate ( ) ; if ( f migration delegate ! = null ) { return f migration delegate . be candidate ( candidate ) ; } return false ; }
public launch delegate [ ] get launch delegate ( string typeid ) { initialize launch delegate ( ) ; array list < launch delegate > list = new array list < > ( ) ; for ( entry < string , launch delegate > entry : f launch delegate . entry set ( ) ) { launch delegate ld = entry . get value ( ) ; if ( ld . get launch configuration type id ( ) . equal ( typeid ) ) { list . add ( ld ) ; } } return list . to array ( new launch delegate [ list . size ( ) ] ) ; }
protect boolean internal remove launch ( i launch launch ) { if ( launch == null ) { return false ; } synchronize ( f launch ) { f launch set . remove ( launch ) ; return f launch . remove ( launch ) ; } }
public void resource change ( i resource change event event ) { i resource delta delta = event . get delta ( ) ; if ( delta ! = null ) { launch manager visitor visitor = get delta visitor ( ) ; map resource visitor v = null ; if ( be delete configuration ( ) ) { v = get map resource visitor ( ) ; } try { delta . accept ( visitor ) ; if ( v ! = null ) { delta . accept ( v ) ; } } catch ( core exception e ) { debug plugin . log ( e . get status ( ) ) ; } } }
public void persist prefer launch delegate ( ) { i launch configuration type [ ] type = get launch configuration type ( ) ; for ( i launch configuration type type : type ) { persist prefer launch delegate ( ( launch configuration type ) type ) ; } }
public string get launch mode name ( string id ) { i launch mode launch mode = get launch mode ( id ) ; if ( launch mode ! = null ) { return remove accelerator ( launch mode . get label ( ) ) ; } return null ; }
public synchronize step filter manager get step filter manager ( ) { if ( f step filter manager == null ) { f step filter manager = new step filter manager ( ) ; } return f step filter manager ; }
public synchronize boolean launch mode available ( string mode ) { if ( f active mode == null ) { f active mode = new hash set < > ( 3 ) ; for ( i launch configuration type type : get launch configuration type ( ) ) { for ( i launch mode launch mode : get launch mode ( ) ) { if ( type . support mode ( launch mode . get identifier ( ) ) ) { f active mode . add ( launch mode . get identifier ( ) ) ; } } } } return f active mode . contains ( mode ) ; }
protect void start monitoring ( ) { synchronize ( this ) { if ( f thread == null ) { f do . set ( false ) ; f thread = new thread ( ( runnable ) this : : read , debug core message . output stream monitor_label ) ; f thread . set daemon ( true ) ; f thread . set priority ( thread . min_priority ) ; f thread . start ( ) ; } } }
public static synchronize void set to default ( string qualifier , string key ) { if ( key ! = null ) { contexts [ instance_context ] . get node ( qualifier ) . remove ( key ) ; } }
public x m l memento create child ( string type ) { element child = factory . create element ( type ) ; element . append child ( child ) ; return new x m l memento ( factory , child ) ; }
public string get action ( ) { return action ; }
public final map get property ( string locale ) { map prop = get property specific ( locale ) ; boolean container lock = ( boolean ) prop . remove ( application_locked ) ; synchronize ( lock ) { if ( container lock ! = null & & container lock . boolean value ( ) ! = lock [ 0 ] ) { if ( lock [ 0 ] ) lock specific ( ) ; else unlock specific ( ) ; } } / * replace the container 's lock with the application model 's lock , that 's the correct * / prop . put ( application_locked , boolean . value of ( lock [ 0 ] ) ) ; return prop ; }
public bundle [ ] get fragment ( bundle host ) { package admin admin = get bundle admin ( ) ; if ( admin == null ) return new bundle [ 0 ] ; return admin . get fragment ( host ) ; }
public static synchronize data area get meta area ( ) { if ( meta area ! = null ) return meta area ; meta area = new data area ( ) ; return meta area ; }
public static boolean contains ( i log listener listener ) { synchronize ( log listener ) { return log listener . contains ( listener ) ; } }
public static url find ( url url ) { return find support . find ( url ) ; }
public static url resolve ( url url ) throw i o exception { u r l converter converter = activator . get u r l converter ( url ) ; return converter == null ? url : converter . resolve ( url ) ; }
public int size ( ) { return listener . length ; }
public void merge ( i status status ) { assert . be legal ( status ! = null ) ; if ( ! status . be multi status ( ) ) { add ( status ) ; } else { add all ( status ) ; } }
public string get qualifier component ( ) { return version . get qualifier ( ) ; }
public void clear block ( ) { progress monitor . clear block ( ) ; }
public static < t > t run ( i safe runnable with result < t > code ) { assert . be not null ( code ) ; try { return code . run with result ( ) ; } catch ( exception | linkage error | assertion error e ) { handle exception ( code , e ) ; return null ; } }
protect void set code ( int code ) { this . code = code ; }
protect void set plugin ( string plugin id ) { assert . be legal ( plugin id ! = null & & plugin id . length ( ) > 0 ) ; this . plugin id = plugin id ; }
public synchronize void stop ( ) { registry factory . get registry ( ) . remove listener ( this ) ; }
public void remove ( string remove contributor id ) { access . enter write ( ) ; try { event delta = combine event delta . record removal ( ) ; basic remove ( remove contributor id ) ; fire registry change event ( ) ; event delta = null ; } finally { access . exit write ( ) ; } }
public object remove ( int key ) { purge ( ) ; return do remove ( key , false ) ; }
public void reset ( ) { aggregate timestamp = 0 ; modify = false ; }
public boolean be modifed ( ) { return modify ; }
public static i extension registry get registry ( ) { i registry provider default registry provider = registry provider factory . get default ( ) ; if ( default registry provider == null ) return null ; return default registry provider . get registry ( ) ; }
public string [ ] get extra marker attribute name ( ) { return char operation . no_strings ; }
public static final char [ ] append ( char [ ] array , char suffix ) { if ( array == null ) return new char [ ] { suffix } ; int length = array . length ; system . arraycopy ( array , 0 , array = new char [ length + 1 ] , 0 , length ) ; array [ length ] = suffix ; return array ; }
public static final char [ ] [ ] array concat ( char [ ] [ ] first , char [ ] second ) { if ( second == null ) return first ; if ( first == null ) return new char [ ] [ ] { second } ; int length = first . length ; char [ ] [ ] result = new char [ length + 1 ] [ ] ; system . arraycopy ( first , 0 , result , 0 , length ) ; result [ length ] = second ; return result ; }
public static final char [ ] concat ( char prefix , char [ ] array , char suffix ) { if ( array == null ) return new char [ ] { prefix , suffix } ; int length = array . length ; char [ ] result = new char [ length + 2 ] ; result [ 0 ] = prefix ; system . arraycopy ( array , 0 , result , 1 , length ) ; result [ length + 1 ] = suffix ; return result ; }
public static boolean be whitespace ( char c ) { return c < scanner helper . max_obvious & & ( ( scanner helper . obvious_ident_char_natures [ c ] & scanner helper . c_jls_space ) ! = 0 ) ; }
public static final int index of ( final char [ ] to be find , final char [ ] array , final boolean be case sensitive , final int start ) { return index of ( to be find , array , be case sensitive , start , array . length ) ; }
public boolean be resolve binding ( ) { return this . operation . resolve binding ; }
public i java element delta get delta ( ) { return this . operation . delta builder . delta ; }
public categorize problem [ ] get problem ( string marker type ) { if ( this . operation . problem == null ) return null ; return ( categorize problem [ ] ) this . operation . problem . get ( marker type ) ; }
public void compute correction ( i problem problem , i compilation unit target unit , i correction requestor requestor ) throw java model exception { if ( requestor == null ) { throw new illegal argument exception ( message . correction_null unit ) ; } this . compute correction ( target unit , problem . get i d ( ) , problem . get source start ( ) , problem . get source end ( ) , problem . get argument ( ) , requestor ) ; }
public static string [ ] get all warning token ( ) { return compiler option . warn token ; }
public boolean be package member type declaration ( ) { a s t node parent = get parent ( ) ; return ( parent instanceof compilation unit ) ; }
public expression get default ( ) { return this . optional default value ; }
public i method bind resolve binding ( ) { return this . ast . get binding resolver ( ) . resolve member ( this ) ; }
public simple name get label ( ) { return this . optional label ; }
public void set type ( type type ) { if ( type == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . type ; pre replace child ( old child , type , type_property ) ; this . type = type ; post replace child ( old child , type , type_property ) ; }
public a s t node find declare node ( string key ) { return this . ast . get binding resolver ( ) . find declaring node ( key ) ; }
public void set else expression ( expression expression ) { if ( expression == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . else expression ; pre replace child ( old child , expression , else_expression_property ) ; this . else expression = expression ; post replace child ( old child , expression , else_expression_property ) ; }
public simple name get label ( ) { return this . optional label ; }
public void set expression ( expression expression ) { if ( expression == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . expression ; pre replace child ( old child , expression , expression_property ) ; this . expression = expression ; post replace child ( old child , expression , expression_property ) ; }
public final boolean resolve unboxing ( ) { return this . ast . get binding resolver ( ) . resolve unboxing ( this ) ; }
public void set name ( simple name field name ) { if ( field name == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . field name ; pre replace child ( old child , field name , name_property ) ; this . field name = field name ; post replace child ( old child , field name , name_property ) ; }
public statement get else statement ( ) { return this . optional else statement ; }
public void set else statement ( statement statement ) { a s t node old child = this . optional else statement ; pre replace child ( old child , statement , else_statement_property ) ; this . optional else statement = statement ; post replace child ( old child , statement , else_statement_property ) ; }
public i bind resolve binding ( ) { return this . ast . get binding resolver ( ) . resolve import ( this ) ; }
public void set operator ( infix expression . operator operator ) { if ( operator == null ) { throw new illegal argument exception ( ) ; } pre value change ( operator_property ) ; this . operator = operator ; post value change ( operator_property ) ; }
public default i module bind get module ( ) { return null ; }
public void set body ( statement statement ) { if ( statement == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . body ; pre replace child ( old child , statement , body_property ) ; this . body = statement ; post replace child ( old child , statement , body_property ) ; }
public void set qualifier ( name name ) { a s t node old child = this . optional qualifier ; pre replace child ( old child , name , qualifier_property ) ; this . optional qualifier = name ; post replace child ( old child , name , qualifier_property ) ; }
public void set receiver qualifier ( simple name receiver qualifier ) { unsupported in2_3_4 ( ) ; a s t node old child = this . optional receiver qualifier ; pre replace child ( old child , receiver qualifier , receiver_qualifier_property ) ; this . optional receiver qualifier = receiver qualifier ; post replace child ( old child , receiver qualifier , receiver_qualifier_property ) ; }
public boolean be resolve type infer from expect type ( ) { return this . ast . get binding resolver ( ) . be resolve type infer from expect type ( this ) ; }
public static boolean be protect ( int flag ) { return ( flags & protect ) ! = 0 ; }
public static boolean be synchronize ( int flag ) { return ( flags & synchronize ) ! = 0 ; }
public list module statement ( ) { return this . module statement ; }
public boolean be transitive ( ) { return this . modifier keyword == module modifier keyword . transitive_keyword ; }
public void set name ( name name ) { a s t node old child = this . name ; pre replace child ( old child , name , name_property ) ; this . name = name ; post replace child ( old child , name , name_property ) ; }
public final boolean be qualify name ( ) { return ( this instanceof qualify name ) ; }
public a s t node get cover node ( ) { return this . f cover node ; }
public a s t node get cover node ( ) { return this . f cover node ; }
public void set expression ( expression expression ) { if ( expression == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . expression ; pre replace child ( old child , expression , expression_property ) ; this . expression = expression ; post replace child ( old child , expression , expression_property ) ; }
public void set operand ( expression expression ) { if ( expression == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . operand ; pre replace child ( old child , expression , operand_property ) ; this . operand = expression ; post replace child ( old child , expression , operand_property ) ; }
public list super interface type ( ) { return this . super interface type ; }
public void set value ( expression value ) { if ( value == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . value ; pre replace child ( old child , value , value_property ) ; this . value = value ; post replace child ( old child , value , value_property ) ; }
public list varargs annotation ( ) { if ( this . varargs annotation == null ) { unsupported in2_3_4 ( ) ; } return this . varargs annotation ; }
public string get text ( ) { return this . text ; }
public final boolean be wildcard type ( ) { return ( this instanceof wildcard type ) ; }
public name get superclass ( ) { return internal get superclass ( ) ; }
public void set type ( type type ) { if ( type == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . type ; pre replace child ( old child , type , type_property ) ; this . type = type ; post replace child ( old child , type , type_property ) ; }
public list type ( ) { return this . type ; }
public static boolean be final ( int flag ) { return ( flags & acc final ) ! = 0 ; }
public static boolean be synthetic ( int flag ) { return ( flags & acc synthetic ) ! = 0 ; }
public static boolean be bridge ( int flag ) { return ( flags & acc bridge ) ! = 0 ; }
public static i status validate type variable name ( string name ) { return validate identifier ( name , compiler option . version_1_3 , compiler option . version_1_3 ) ; }
public static char [ ] suggest setter name ( i java project project , char [ ] field name , int modifier , boolean be boolean , char [ ] [ ] exclude names ) { if ( be boolean ) { char [ ] name = internal naming convention . get base name ( get field variable kind ( modifier ) , project , field name , false ) ; int prefix len = getter_bool_name . length ; if ( char operation . prefix equal ( getter_bool_name , name ) & & name . length > prefix len & & scanner helper . be upper case ( name [ prefix len ] ) ) { name = char operation . subarray ( name , prefix len , name . length ) ; return suggest new name ( char operation . concat ( setter_name , suggest accessor name ( project , name , modifier ) ) , exclude names ) ; } else { return suggest new name ( char operation . concat ( setter_name , suggest accessor name ( project , field name , modifier ) ) , exclude names ) ; } } else { return suggest new name ( char operation . concat ( setter_name , suggest accessor name ( project , field name , modifier ) ) , exclude names ) ; } }
public final string get path ( ) { return this . document path ; }
public void search ( i workspace workspace , i search pattern search pattern , i java search scope scope , i java search result collector result collector ) throw java model exception { try { search ( ( ( search pattern adapter ) search pattern ) . pattern , new search participant [ ] { get default search participant ( ) } , scope , new result collector adapter ( result collector ) , result collector . get progress monitor ( ) ) ; } catch ( core exception e ) { if ( e instanceof java model exception ) throw ( java model exception ) e ; throw new java model exception ( e ) ; } }
public void search declaration of sent message ( i java element enclose element , search requestor requestor , i progress monitor monitor ) throw java model exception { this . basic engine . search declaration of sent message ( enclose element , requestor , monitor ) ; }
public string get type container name ( ) { i type outer type = get type ( ) . get declare type ( ) ; if ( out type ! = null ) { return outer type . get fully qualify name ( ' . ' ) ; } else { return get type ( ) . get package fragment ( ) . get element name ( ) ; } }
public void resolve ( class scope scope ) { super . resolve ( scope ) ; internal resolve ( scope ) ; }
public reference bind [ ] get already catch exception ( ) { reference bind [ ] all catch exception = new reference binding [ this . caught exception . element size ] ; this . caught exception . a array ( all catch exception ) ; return all caught exception ; }
public static boolean be any closeable ( type binding type binding ) { return type bind instanceof reference binding & & ( ( reference binding ) type bind ) . have type bit ( type id . bit auto closeable| type id . bit closeable ) ; }
public void mark close ( flow info flow info , flow context flow context ) { faked track variable current = this ; do { flow info . mark a definitely non null ( current . binding ) ; current . global closing state |= close_seen ; flow context . mark finally null status ( current . binding , flow info . non_null ) ; current = current . inner tracker ; } while ( current ! = null ) ; }
public void mark close in nested method ( ) { this . global closing state |= closed_in_nested_method ; }
public boolean completes by continue ( ) { return false ; }
protect i type annotation walker to next detail ( int detail kind ) { long new match = this . match ; if ( new match == 0 ) return restrict ( new match , this . path ptr+2 ) ; int length = this . type annotation . length ; long mask = 1 ; for ( int i = 0 ; i < length ; i++ , mask = mask < < 1 ) { i binary type annotation candidate = this . type annotation [ i ] ; int [ ] path = candidate . get type path ( ) ; if ( this . path ptr > = path . length || path [ this . path ptr ] ! = detail kind ) { new match & = ~mask ; } } return restrict ( new match , this . path ptr+2 ) ; }
public void reset for clinit ( int constant pool index , int constant pool offset ) { this . current index = constant pool index ; this . current offset = constant pool offset ; if ( this . u t f8 cache . get ( attribute name constant . code name ) > = constant pool index ) { this . u t f8 cache . remove ( attribute name constant . code name ) ; } if ( this . u t f8 cache . get ( constant pool . clinit signature ) > = constant pool index ) { this . u t f8 cache . remove ( constant pool . clinit signature ) ; } if ( this . u t f8 cache . get ( constant pool . clinit ) > = constant pool index ) { this . u t f8 cache . remove ( constant pool . clinit ) ; } }
protect void consume package declaration name ( ) { / * * javadoc position be persist in consume package comment * / super . consume package declaration name ( ) ; import reference import reference = this . compilation unit . current package ; this . requestor . accept package ( import reference . declaration source start , import reference . declaration source end , this . int array stack [ this . int array ptr -- ] , char operation . concat with ( import reference . get import name ( ) , ' . ' ) , import reference . source start ) ; }
public i compilation unit get compilation unit ( ) { return this . compilation unit ; }
public reference bind get resolve binding ( ) { return this . binding ; }
public boolean be any set ( irritant set other ) { if ( other == null ) return false ; for ( int i = 0 ; i < group_max ; i++ ) { if ( ( this . bits [ i ] & other . bit [ i ] ) ! = 0 ) return true ; } return false ; }
public int problem id ( ) { return problem reason . no error ; }
public char [ ] generic signature ( ) { if ( ( this . modifier & extra compiler modifier . acc generic signature ) == 0 ) return null ; return this . type . generic type signature ( ) ; }
public final boolean be final ( ) { return ( this . modifier & class file constant . acc final ) ! = 0 ; }
public method bind shallow original ( ) { return original ( ) ; }
public constant constant ( scope scope ) { return constant ( ) ; }
public recover element add ( statement stmt , int bracket balance value ) { return this . add ( stmt , bracket balance value , false ) ; }
public recover initializer enclose initializer ( ) { recovered element current = this ; while ( current ! = null ) { if ( current instanceof recover initializer ) { return ( recovered initializer ) current ; } current = current . parent ; } return null ; }
protect void set name source end ( int end ) { this . name end= end ; }
public void check cancel ( ) { if ( this . monitor ! = null & & this . monitor . be cancel ( ) ) throw new operation cancel exception ( ) ; }
protect i problem factory get problem factory ( ) { return problem factory . get problem factory ( locale . get default ( ) ) ; }
public string get method doc ( i method child ) throw java model exception { if ( this . content == null ) return null ; int [ ] range = null ; synchronize ( this ) { if ( this . method doc range == null ) { this . method doc range = new hashtable of object to int array ( ) ; } else { range = this . method doc range . get ( child ) ; } if ( range == null ) { range = compute method range ( child ) ; this . method doc range . put ( child , range ) ; } } if ( range ! = null ) { if ( range == unknown_format ) { throw new java model exception ( new java model status ( i java model status constant . unknown_javadoc_format , child ) ) ; } return new string ( this . content , range [ 0 ] , range [ 1 ] - range [ 0 ] ) ; } return null ; }
public void accept problem ( categorize problem problem ) { if ( this . f build single member & & this . f finished single member ) { return ; } this . f abort= true ; }
protect void exit abstract method ( int body end , int declaration end ) { d o m method method = ( d o m method ) this . f stack . pop ( ) ; method . set source range end ( declaration end ) ; method . set body range end ( body end + 1 ) ; this . f node = method ; if ( this . f build single member ) { this . f finish single member= true ; } }
public void exit interface ( int body end , int declaration end ) { exit type ( body end , declaration end ) ; }
protect void become detailed ( ) throw d o m exception { if ( ! be detailed ( ) ) { if ( be variable declarator ( ) || have multiple variable declarators ( ) ) { d o m node first = get first field declaration ( ) ; d o m node last = get last field declaration ( ) ; d o m node node= first ; string source= first . get content ( ) ; while ( node ! = last ) { node= node . f next node ; source+=node . get content ( ) ; } d o m builder builder = new d o m builder ( ) ; i d o m field [ ] details= builder . create field ( source . to char array ( ) ) ; if ( detail . length == 0 ) { throw new d o m exception ( message . dom_cannot detail ) ; } else { node= this ; for ( int i= 0 ; i < detail . length ; i++ ) { node . share content ( ( d o m node ) detail [ i ] ) ; node= node . f next node ; } } } else { super . become detailed ( ) ; } } }
protect void set return type alter ( boolean type alter ) { set mask ( mask_return_type_altered , type alter ) ; }
public v next element ( ) { v temp = this . element queue . value ; this . element queue = this . element queue . next ; return temp ; }
public void clean up index ( ) { simple set know path = new simple set ( ) ; if ( ! disable_meta_index ) { know path . add ( compute index location ( new path ( index_meta_container ) ) ) ; } i java search scope scope = basic search engine . create workspace scope ( ) ; pattern search job job = new pattern search job ( null , search engine . get default search participant ( ) , scope , null ) ; index [ ] select index = job . get index ( null ) ; for ( int i = 0 , l = select index . length ; i < l ; i++ ) { index location index location = select index [ i ] . get index location ( ) ; know path . add ( index location ) ; } if ( this . index state ! = null ) { object [ ] key = this . index state . key table ; index location [ ] location = new index location [ this . index state . element size ] ; int count = 0 ; for ( int i = 0 , l = key . length ; i < l ; i++ ) { index location key = ( index location ) key [ i ] ; if ( key ! = null & & ! know path . include ( key ) ) location [ count++ ] = key ; } if ( count > 0 ) remove index state ( location ) ; } delete index file ( know path , null ) ; }
public int hash code ( ) { if ( this . type == null ) return this . modifier ; return this . type . hash code ( ) ; }
public char [ ] get file name ( ) { return this . openable . get element name ( ) . to char array ( ) ; }
public void reset ( ) { this . element= null ; }
protect string get type signature ( ) { return signature . create type signature ( this . type name , false ) ; }
public char array buffer append ( char c ) { append ( new char [ ] { c } , 0 , 1 ) ; return this ; }
public void set string index ( int string index ) { this . string index = string index ; }
public field bind get field for code snippet ( type binding receiver type , char [ ] field name , invocation site invocation site ) { field bind field = find field for code snippet ( receiver type , field name , invocation site ) ; if ( field == null ) return new problem field binding ( receiver type instanceof reference binding ? ( reference binding ) receiver type : null , field name , problem reason . not find ) ; else return field ; }
public char [ ] get type name ( ) { return this . type name ; }
public string get name ( ) { return f name ; }
public void set relevance ( int relevance ) { f relevance= relevance ; }
public static string get method body content ( i compilation unit cu , string declare type name , string method name , boolean be constructor , string body statement , string line delimiter ) throw core exception { return stub utility . get method body content ( be constructor , cu . get java project ( ) , declare type name , method name , body statement , line delimiter ) ; }
public i problem get parse error ( ) { return f parse error ; }
public void set descriptor ( change descriptor descriptor ) { f descriptor= descriptor ; }
public void set package ( string package name ) { java refactoring descriptor util . set string ( f argument , package_name , package name ) ; }
public boolean be delegate ( ) { return f delegate ; }
public boolean be deprecate delegate ( ) { return f deprecate delegate ; }
public void set destination type ( final i type type ) { assert . be not null ( type ) ; f type= type ; }
public void set keep original ( final boolean delegate ) { f delegate= delegate ; }
public void set member ( final i member [ ] member ) { assert . be not null ( member ) ; f members= member ; }
public string get new name ( ) { return f new name ; }
public change method signature argument get argument ( ) { return f argument ; }
public static int get expression precedence ( expression expression ) { if ( expression instanceof infix expression ) { return get operator precedence ( ( ( infix expression ) expression ) . get operator ( ) ) ; } else if ( expression instanceof assignment ) { return assignment ; } else if ( expression instanceof conditional expression ) { return conditional ; } else if ( expression instanceof instanceof expression ) { return relational ; } else if ( expression instanceof cast expression ) { return typegeneration ; } else if ( expression instanceof prefix expression ) { return prefix ; } else if ( ( expression instanceof class instance creation ) || ( expression instanceof field access ) || ( expression instanceof method invocation ) || ( expression instanceof array access ) || ( expression instanceof postfix expression ) ) { return postfix ; } return integer . max_value ; }
public static int get indent use ( i java element elem ) throw java model exception { i openable openable= elem . get openable ( ) ; if ( openable instanceof i type root ) { i buffer buf= openable . get buffer ( ) ; if ( buf ! = null ) { int offset= ( ( i source reference ) elem ) . get source range ( ) . get offset ( ) ; return get indent use ( buf , offset , elem . get java project ( ) ) ; } } return 0 ; }
public static string [ ] get variable name suggestion ( int variable kind , i java project project , string base name , int dimension , collection < string > exclude , boolean evaluate default ) { return name convention . suggest variable name ( variable kind , name convention . bk_type_name , remove type argument ( base name ) , project , dimension , get exclude array ( exclude ) , evaluate default ) ; }
public static boolean be low case ( char ch ) { return character . to lower case ( ch ) == ch ; }
public static string trim indent ( string line , int indent to remove , i java project project ) { return indent manipulation . trim indent ( line , indent to remove , code formatter util . get tab width ( project ) , code formatter util . get indent width ( project ) ) ; }
public void set expand with constructor ( boolean value ) { f expand with constructors= value ; f be expand with constructor set= true ; }
public void set default ignore filter ( string default ignore filter ) { this . default ignore filters= default ignore filter ; }
public boolean be recursive ( ) { if ( f parent instanceof real caller ) return false ; method wrapper current = get parent ( ) ; while ( current ! = null ) { if ( get member ( ) . get handle identifier ( ) . equal ( current . get member ( ) . get handle identifier ( ) ) ) { return true ; } current = current . get parent ( ) ; } return false ; }
public void accept ( call hierarchy visitor visitor , i progress monitor progress monitor ) { if ( get parent ( ) ! = null & & get parent ( ) . be recursive ( ) ) { return ; } check canceled ( progress monitor ) ; visitor . pre visit ( this ) ; if ( visitor . visit ( this ) ) { for ( method wrapper method wrapper : get call ( progress monitor ) ) { method wrapper . accept ( visitor , progress monitor ) ; } } visitor . post visit ( this ) ; if ( progress monitor ! = null ) { progress monitor . work ( 1 ) ; } }
public void remove from cache ( ) { f elements= null ; f method cache . remove ( get method call ( ) . get key ( ) ) ; }
protect body declaration find method to replace ( final list < body declaration > list , method declaration method ) { for ( body declaration body decl : list ) { if ( body decl instanceof method declaration ) { final method declaration method2= ( method declaration ) body decl ; if ( method2 . get name ( ) . get identifier ( ) . equal ( method . get name ( ) . get identifier ( ) ) & & method2 . parameter ( ) . size ( ) == method . parameter ( ) . size ( ) ) { iterator < single variable declaration > iterator1= method . parameter ( ) . iterator ( ) ; iterator < single variable declaration > iterator2= method2 . parameter ( ) . iterator ( ) ; boolean ok= true ; while ( iterator1 . have next ( ) ) { if ( ! iterator1 . next ( ) . get type ( ) . subtree match ( new a s t matcher ( ) , iterator2 . next ( ) . get type ( ) ) ) { ok= false ; break ; } } if ( ok ) return method2 ; } } } return null ; }
public static selection create from start end ( int s , int e ) { assert . be true ( s > = 0 & & e > = s ) ; selection result= new selection ( ) ; result . f start= s ; result . f length= e - s + 1 ; result . f exclusive end= result . f start + result . f length ; return result ; }
public int get visit selection mode ( a s t node node ) { int node start= node . get start position ( ) ; int node end= node start + node . get length ( ) ; if ( node end < = f start ) return before ; else if ( cover ( node ) ) return select ; else if ( f exclusive end < = node start ) return after ; return intersects ; }
public list < infix expression . operator > get infix in safe operator ( ) { return collection . empty list ( ) ; }
public string [ ] get safe in constant ( ) { return new string [ 0 ] ; }
public void find operation ( final compilation unit compilation unit , final set < compilation unit rewrite operation > operation , final set < a s t node > nodesprocessed ) { myfinder . finder ( this , compilation unit , operation , nodesprocessed ) ; }
public void set source rewrite ( compilation unit rewrite rewrite ) { f original rewrite= rewrite ; f preferences= java preference setting . get code generation setting ( rewrite . get cu ( ) ) ; f delegate rewrite= new compilation unit rewrite ( rewrite . get cu ( ) , rewrite . get root ( ) ) ; f delegate rewrite . get a s t rewrite ( ) . set target source range computer ( rewrite . get a s t rewrite ( ) . get extend source range computer ( ) ) ; }
public void set requestor ( final i refactoring search requestor requestor ) { assert . be not null ( requestor ) ; f requestor= requestor ; }
protect i variable bind [ ] compute target category ( final method declaration declaration ) { assert . be not null ( declaration ) ; if ( f possible target . length == 0 || f candidate target . length == 0 ) { final list < i variable bind > possible targets= new array list < > ( 16 ) ; final list < i variable bind > candidate targets= new array list < > ( 16 ) ; final i method bind method= declaration . resolve binding ( ) ; if ( method ! = null ) { final i type bind declaring= method . get declare class ( ) ; i type bind binding= null ; for ( i variable bind binding2 : get argument binding ( declaration ) ) { binding= binding2 . get type ( ) ; if ( ( bind . be class ( ) || bind . be enum ( ) || is18 or high interface ( bind ) ) & & binding . be from source ( ) ) { possible target . add ( binding2 ) ; candidate target . add ( binding2 ) ; } } final ready only field finder visitor= new ready only field finder ( declare ) ; declaration . accept ( visitor ) ; for ( i variable bind binding2 : visitor . get read only field ( ) ) { binding= binding2 . get type ( ) ; if ( ( bind . be class ( ) || is18 or high interface ( bind ) ) & & binding . be from source ( ) ) possible target . add ( binding2 ) ; } for ( i variable bind binding2 : visitor . get declared field ( ) ) { binding= binding2 . get type ( ) ; if ( ( bind . be class ( ) || is18 or high interface ( bind ) ) & & binding . be from source ( ) ) candidate target . add ( binding2 ) ; } } f possible targets= new i variable bind [ possible target . size ( ) ] ; possible target . to array ( f possible target ) ; f candidate targets= new i variable bind [ candidate target . size ( ) ] ; candidate target . to array ( f candidate target ) ; } return f possible target ; }
public boolean be java lang object ( ) { return false ; }
public final boolean be top level ( ) { return ( f flag & f_is_top_level ) ! = 0 ; }
public final boolean be nest ( ) { return ( f flag & f_is_nested ) ! = 0 ; }
public final boolean be member ( ) { return ( f flag & f_is_member ) ! = 0 ; }
public t type get java lang object ( ) { return object_type ; }
public static refactoring status context create ( i type root type root , a s t node node ) { i source range range= null ; if ( node ! = null ) range= new source range ( node . get start position ( ) , node . get length ( ) ) ; return create ( type root , range ) ; }
public static boolean be pack ( text edit edit ) { if ( ! ( edit instanceof multi text edit ) ) return true ; if ( ! edit . have child ( ) ) return true ; text edit [ ] children= edit . get child ( ) ; if ( edit . get offset ( ) ! = child [ 0 ] . get offset ( ) ) return false ; if ( edit . get exclusive end ( ) ! = child [ child . length - 1 ] . get exclusive end ( ) ) return false ; for ( text edit child : child ) { if ( ! be pack ( child ) ) { return false ; } } return true ; }
protect void initialize context ( i java context context ) { }
public static string get low bound ( string signature ) { return string . value of ( get low bound ( signature . to char array ( ) ) ) ; }
public i method find declare method ( i method override , boolean test visibility ) throw java model exception { i method result= null ; i method overridden= find overridden method ( override , test visibility ) ; while ( overridden ! = null ) { result= overridden ; overridden= find overridden method ( result , test visibility ) ; } return result ; }
public static i status make committable ( i resource [ ] resource , object context ) { list < i resource > read only files= new array list < > ( ) ; for ( i resource resource : resource ) { if ( resource . get type ( ) == i resource . file & & be read only ( resource ) ) read only file . add ( resource ) ; } if ( read only file . be empty ( ) ) return status . ok_status ; map < i file , long > old time stamps= create modification stamp map ( read only file ) ; i status status= resource plugin . get workspace ( ) . validate edit ( read only file . to array ( new i file [ read only file . size ( ) ] ) , context ) ; if ( ! status . be o k ( ) ) return status ; i status modified= null ; map < i file , long > new time stamps= create modification stamp map ( read only file ) ; for ( map . entry < i file , long > entry : old time stamp . entry set ( ) ) { i file file = entry . get key ( ) ; if ( ! entry . get value ( ) . equal ( new time stamp . get ( file ) ) ) modified= add modify ( modify , file ) ; } if ( modify ! = null ) return modify ; return status . ok_status ; }
public static string get location string ( i resource resource ) { uri uri= resource . get location u r i ( ) ; if ( uri == null ) return null ; return efs . scheme_file . equal ignore case ( uri . get scheme ( ) ) ? new file ( uri ) . get absolute path ( ) : uri . to string ( ) ; }
public static boolean have in cache ( i type type ) { return find type hierarchy in cache ( type ) ! = null ; }
public boolean be info ( ) { return f severity == i status . info ; }
protect int index of ( list < ? extend position > position , position position ) { int index= compute index at offset ( position , position . get offset ( ) ) ; int size= position . size ( ) ; while ( index < size ) { if ( position . get ( index ) == position ) return index ; index++ ; } return -1 ; }
public boolean be composite ( ) { return false ; }
public synchronize i access rule participant [ ] get access rule participant ( ) { initialize extension ( ) ; return f rule participant . to array ( new i access rule participant [ f rule participant . size ( ) ] ) ; }
public static void log ( throwable e ) { log ( new status ( i status . error , get unique identifier ( ) , i status . error , e . get message ( ) , e ) ) ; }
public static document builder get parser ( ) throw core exception { if ( fg x m l parser == null ) { try { fg x m l parser = document builder factory . new instance ( ) . new document builder ( ) ; fg x m l parser . set error handler ( new default handler ( ) ) ; } catch ( parser configuration exception e ) { abort ( launching message . launch plugin_34 , e ) ; } catch ( factory configuration error e ) { abort ( launching message . launch plugin_34 , e ) ; } } return fg x m l parser ; }
public string [ ] get bootpath ( ) { return f bootpath ; }
public string [ ] get endorse dirs ( ) { return f endorse dirs ; }
protect void fire ready to accept event ( ) { debug plugin manager= debug plugin . get default ( ) ; if ( manager ! = null ) { manager . fire debug event set ( new debug event [ ] { new debug event ( this , debug event . model_specific , i java launch configuration constant . detail_config_ready_to_accept_remote_vm_connection ) } ) ; } }
public void remove v m ( i v m install vm ) { f v m list . remove ( vm ) ; f invalid v m list . remove ( vm ) ; list < i v m install > list = f v m type to v m map . get ( vm . get v m install type ( ) ) ; if ( list ! = null ) { list . remove ( vm ) ; } }
public string get id ( ) { return f id ; }
public string get attribute ( string key ) { return f attribute map . get ( key ) ; }
protected process exec ( string [ ] cmd line , file work directory , string [ ] envp ) throw core exception { cmd line = quote window args ( cmd line ) ; return debug plugin . exec ( cmd line , work directory , envp ) ; }
public url get javadoc location ( ) { return f javadoc location ; }
public object get new value ( ) { return new value ; }
public object get old value ( ) { return old value ; }
protect zip file get archive ( ) throw i o exception { return get zip file ( get name ( ) ) ; }
public refactoring status get status ( ) { return f status ; }
public void add ( change change ) { if ( change ! = null ) { assert . be true ( change . get parent ( ) == null ) ; f change . add ( change ) ; change . set parent ( this ) ; } }
public change [ ] get child ( ) { return f change . to array ( new change [ f change . size ( ) ] ) ; }
public int get event type ( ) { return f type ; }
public boolean get update reference ( ) { return f update reference ; }
public move processor get move processor ( ) { return f processor ; }
public boolean be rename ( object element ) { return f new name . contains key ( element ) ; }
public static refactoring status check file to be change ( i file [ ] file , i progress monitor monitor ) throw core exception { resource change checker checker= new resource change checker ( ) ; for ( i file file : file ) { checker . get delta factory ( ) . change ( file ) ; } return checker . check ( monitor ) ; }
public refactoring status get validation status ( ) { return f validation status ; }
public final refactoring tick provider get refactoring tick provider ( ) { refactoring tick provider result= do get refactoring tick provider ( ) ; if ( result == null ) { result= refactoring tick provider . default ; } return result ; }
public refactoring descriptor create descriptor ( ) { return null ; }
public void set destination ( i container container ) { assert . be not null ( container ) ; f destination path= container . get full path ( ) ; }
public boolean get keep preview edits ( ) { return f track edits ; }
public void set save mode ( int save mode ) { f save mode= save mode ; }
protect boolean need save ( ) { if ( ( f save mode & force_save ) ! = 0 ) { return true ; } if ( ( f save mode & keep_save_state ) ! = 0 ) { return f validation state == null || ! f validation state . be dirty ( ) ; } return false ; }
public static i path stamp to path ( final long stamp ) { fg calendar . set time in millis ( stamp ) ; final string builder buffer= new string builder ( 256 ) ; buffer . append ( fg calendar . get ( calendar . year ) ) ; buffer . append ( i path . separator ) ; buffer . append ( fg calendar . get ( calendar . month ) + 1 ) ; buffer . append ( i path . separator ) ; buffer . append ( fg calendar . get ( calendar . week_of_year ) ) ; return new path ( buffer . to string ( ) ) ; }
public string get new resource name ( ) { return f new resource name ; }
public void add create ( i resource create ) { if ( f create == null ) f create= new array list < > ( 2 ) ; f create . add ( create ) ; if ( f ignore count == 0 ) { internal add ( new create description ( create ) ) ; } }
public module container adaptor get adaptor ( ) { return adaptor ; }
public executor get resolver executor ( ) { return default executor ; }
final public long get revision timestamp ( ) { read lock ( ) ; try { return revision time stamp . get ( ) ; } finally { read unlock ( ) ; } }
public list < module capability > get module capability ( string namespace ) { return capability . get list ( namespace ) ; }
public void set symbolic name ( string symbolic name ) { this . symbolic name = symbolic name ; }
public collection < v > value ( ) { return new snapshot < > ( entry ( ) ) . value ( ) ; }
public boolean be directory ( final file file ) { if ( system . get security manager ( ) == null ) return file . be directory ( ) ; return access controller . do privilege ( new privilege action < boolean > ( ) { @ override public boolean run ( ) { return file . be directory ( ) ? boolean . true : boolean . false ; } } , control context ) . boolean value ( ) ; }
public boolean get prim ( ) { return this . prim ; }
public static < t > list < t > a list ( list < ? extend t > l ) { return ( list < t > ) l ; }
public final string get message ( ) { return message ; }
public final string get option path ( ) { return option path ; }
public collection < string > get processor alias ( string processor ) { return get alias ( processor . to lower case ( ) , processor alias table ) ; }
public equinox configuration get configuration ( ) { return container . get configuration ( ) ; }
public bundle file get bundle file ( ) { return bundlefile ; }
public void close ( ) { for ( classpath entry entry : entry ) { if ( entry ! = null ) { try { entry . close ( ) ; } catch ( i o exception e ) { generation . get bundle info ( ) . get storage ( ) . get adaptor ( ) . publish container event ( container event . error , generation . get revision ( ) . get revision ( ) . get module ( ) , e ) ; } } } fragment classpath [ ] current fragment = get fragment classpaths ( ) ; for ( fragment classpath current fragment : current fragment ) { current fragment . close ( ) ; } }
public void add woven permission ( package permission permission ) { if ( ! permission . get action ( ) . equal ( package permission . import ) ) throw new security exception ( ) ; weave permission . add ( permission ) ; }
public boolean be remove ( ) { return remove ; }
public bundle get bundle ( ) { return registration . get bundle ( ) ; }
public void remove all service listener ( bundle context impl context ) { map < service listener , filter service listener > remove listener map ; synchronize ( service event listener ) { removed listener map = service event listener . remove ( context ) ; } if ( ( remove listener map == null ) || removed listener map . be empty ( ) ) { return ; } collection < filter service listener > remove listener = remove listener map . value ( ) ; for ( filtered service listener old filtered listener : remove listener ) { old filter listener . mark remove ( ) ; } notify listener hook ( a listener info ( removed listener ) , false ) ; }
public boolean be include ( version version ) { if ( version == null ) version = version . empty version ; return include ( version ) ; }
public int get micro ( ) { return micro ; }
public version get right ( ) { return right ; }
public char get leave type ( ) { return leave close ? left_closed : left_open ; }
public boolean be empty ( ) { return empty ; }
public string to filter string ( string attribute name ) { if ( attribute name . length ( ) == 0 ) { throw new illegal argument exception ( `` invalid attribute name \ `` `` + attribute name + `` \ `` `` ) ; } for ( char ch : attribute name . to char array ( ) ) { if ( ( ch == '= ' ) || ( ch == ' > ' ) || ( ch == ' < ' ) || ( ch == '~ ' ) || ( ch == ' ( ' ) || ( ch == ' ) ' ) ) { throw new illegal argument exception ( `` invalid attribute name \ `` `` + attribute name + `` \ `` `` ) ; } } string builder result = new string builder ( 128 ) ; final boolean need presence = ! leave close & & ( ( right == null ) || ! right close ) ; final boolean multiple term = need presence || ( right ! = null ) ; if ( multiple term ) { result . append ( `` ( & `` ) ; } if ( need presence ) { result . append ( ' ( ' ) ; result . append ( attribute name ) ; result . append ( `` = * ) `` ) ; } if ( left close ) { result . append ( ' ( ' ) ; result . append ( attribute name ) ; result . append ( `` > = `` ) ; result . append ( leave . to string0 ( ) ) ; result . append ( ' ) ' ) ; } else { result . append ( `` ( ! ( `` ) ; result . append ( attribute name ) ; result . append ( `` < = `` ) ; result . append ( leave . to string0 ( ) ) ; result . append ( `` ) ) `` ) ; } if ( right ! = null ) { if ( right close ) { result . append ( ' ( ' ) ; result . append ( attribute name ) ; result . append ( `` < = `` ) ; result . append ( right . to string0 ( ) ) ; result . append ( ' ) ' ) ; } else { result . append ( `` ( ! ( `` ) ; result . append ( attribute name ) ; result . append ( `` > = `` ) ; result . append ( right . to string0 ( ) ) ; result . append ( `` ) ) `` ) ; } } if ( multiple term ) { result . append ( ' ) ' ) ; } return result . to string ( ) ; }
public static condition get condition ( final bundle bundle , final condition info info ) { if ( ! condition_type . equal ( info . get type ( ) ) ) throw new illegal argument exception ( `` condition info must be of type \ `` `` + condition_type + `` \ `` `` ) ; string [ ] args = info . get args ( ) ; if ( args . length ! = 1 & & args . length ! = 2 ) throw new illegal argument exception ( `` illegal number of args : `` + args . length ) ; map < x509 certificate , list < x509 certificate > > signer = bundle . get signer certificate ( bundle . signers_trusted ) ; boolean match = false ; for ( list < x509 certificate > signer cert : signer . value ( ) ) { list < string > dn chain = new array list < string > ( signer cert . size ( ) ) ; for ( x509 certificate signer : signer cert ) { dn chain . add ( signer . get subject d n ( ) . get name ( ) ) ; } if ( framework util . match distinguish name chain ( args [ 0 ] , dn chain ) ) { match = true ; break ; } } boolean negate = ( args . length == 2 ) ? `` ! `` . equal ( args [ 1 ] ) : false ; return negate ^ match ? condition . true : condition . false ; }
protect void set line tracker ( i line tracker tracker ) { f tracker= tracker ; }
public final void set ( string text ) { / * * move the gap to the end of the content . there be no sensible prediction of where the * next change will occur , but at least the next change will not trigger re-allocation . this * be especially important when use the gap text store within a copy on write text store , where * the gts be only initialized right before a modification . * / replace ( 0 , get length ( ) , text ) ; }
public static link mode manager get link manager ( i document [ ] document , boolean force ) { if ( document == null || document . length == 0 ) return null ; set < link mode manager > mgrs= new hash set < > ( ) ; link mode manager mgr= null ; for ( i document document : document ) { mgr= fg manager . get ( document ) ; if ( mgr ! = null ) mgrs . add ( mgr ) ; } if ( mgrs . size ( ) > 1 ) if ( force ) { for ( link mode manager m : mgrs ) { m . close all environment ( ) ; } } else { return null ; } if ( mgrs . be empty ( ) ) mgr= new link mode manager ( ) ; for ( i document document : document ) fg manager . put ( document , mgr ) ; return mgr ; }
public void stop forwarding ( int flag ) { f document listener . f exit= true ; }
public boolean be nest ( ) { return f parent environment ! = null ; }
public list < link position > get tab stop sequence ( ) { return f position sequence ; }
public link position group get group for position ( position position ) { for ( link position group group : f group ) { if ( group . contains ( position ) ) return group ; } return null ; }
protect boolean include ( i document doc , int off , int len ) { return doc == f document & & off > = offset & & len + off < = offset + length ; }
public void set sequence number ( int sequence ) { f sequence number= sequence ; }
public void set length ( int length ) { assert . be true ( length > = 0 ) ; this . length= length ; }
public position get parent document range ( ) { i region coverage= get document information mapping ( ) . get coverage ( ) ; return new visible region ( coverage . get offset ( ) , coverage . get length ( ) ) ; }
protect void fire document change ( document event event ) { super . fire document change ( f slave event ) ; }
public void projection change ( ) { f cache segments= null ; f cache fragments= null ; }
protect void set completion offset ( int new offset ) { f original offset= new offset ; f position . set offset ( new offset ) ; }
public void add resolver ( template variable resolver resolver ) { assert . be not null ( resolver ) ; f resolvers . put ( resolver . get type ( ) , resolver ) ; }
protect void validate variable ( template variable [ ] variable ) throw template exception { }
public string get type ( ) { return f type ; }
public string get name ( ) { return f name ; }
public copy target edit get target edit ( ) { return f target ; }
public final int get child size ( ) { if ( f child == null ) return 0 ; return f child . size ( ) ; }
public final text edit copy ( ) { text edit copier copier= new text edit copier ( this ) ; return copier . perform ( ) ; }
protect void post process copy ( text edit copier copier ) { }
public text edit get root ( ) { return f root ; }
public boolean visit ( copy target edit edit ) { return visit node ( edit ) ; }
public boolean visit ( multi text edit edit ) { return visit node ( edit ) ; }
public boolean be delete ( ) { return f be delete ; }
public void start listen for preference change ( ) { if ( f property listener == null ) { f property listener= event - > { / * * do n't load if we be in the process of save ourselves . we be in sync anyway after the * save operation , and client may trigger reload by listen to preference store * update . * / if ( ! f ignore preference store change & & f key . equal ( event . get key ( ) ) ) try { load ( ) ; } catch ( i o exception x ) { handle exception ( x ) ; } } ; f preference store . add preference change listener ( f property listener ) ; } }
public template [ ] get template ( ) { return get template ( null ) ; }
public template find template ( string name ) { return find template ( name , null ) ; }
public template find template ( string name , string context type id ) { assert . be not null ( name ) ; for ( template persistence data data : f template ) { template template= data . get template ( ) ; if ( data . be enable ( ) & & ! data . be delete ( ) & & ( context type id == null || context type id . equal ( template . get context type id ( ) ) ) & & name . equal ( template . get name ( ) ) ) return template ; } return null ; }
public final string get action ( ) { return action ; }
public boolean equal ( object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof permission info ) ) { return false ; } permission info other = ( permission info ) obj ; if ( ! type . equal ( other . type ) || ( ( name == null ) ^ ( other . name == null ) ) || ( ( action == null ) ^ ( other . action == null ) ) ) { return false ; } if ( name ! = null ) { if ( action ! = null ) { return name . equal ( other . name ) & & action . equal ( other . action ) ; } else { return name . equal ( other . name ) ; } } else { return true ; } }
public int hash code ( url u ) { return super . hash code ( u ) ; }
public void process ( operator operator , list < c o s base > argument ) throw i o exception { p d color space c = context . get resource ( ) . get color space ( c o s name . devicergb ) ; context . get graphic state ( ) . set stroke color space ( c ) ; super . process ( operator , argument ) ; }
public void set image parameter ( c o s dictionary params ) { image parameter = params ; }
protect final void restore graphic stack ( stack < p d graphic state > snapshot ) { graphic stack = snapshot ; }
public void clear ( ) { object . clear ( ) ; }
public void add all ( c o s array object list ) { if ( object list ! = null ) { object . add all ( object list . object ) ; } }
public int get int ( int index , int default value ) { int retval = default value ; if ( index < size ( ) ) { object obj = object . get ( index ) ; if ( obj instanceof c o s number ) { retval = ( ( c o s number ) obj ) . int value ( ) ; } } return retval ; }
public void set string ( int index , string string ) { if ( string ! = null ) { set ( index , new c o s string ( string ) ) ; } else { set ( index , null ) ; } }
public static c o s boolean get boolean ( boolean value ) { return ( value ? true : false ) ; }
public c o s name get c o s name ( c o s name key ) { c o s base name = get dictionary object ( key ) ; if ( name instanceof c o s name ) { return ( c o s name ) name ; } return null ; }
public c o s object get c o s object ( c o s name key ) { c o s base object = get item ( key ) ; if ( object instanceof c o s object ) { return ( c o s object ) object ; } return null ; }
public void set document i d ( c o s array id ) { get trailer ( ) . set item ( c o s name . id , id ) ; }
public static byte [ ] get byte ( string text ) { byte array output stream out = new byte array output stream ( ) ; for ( char c : text . to char array ( ) ) { integer code = uni_to_code . get ( c ) ; if ( code == null ) { out . write ( 0 ) ; } else { out . write ( code ) ; } } return out . to byte array ( ) ; }
public void set source region ( rectangle source region ) { this . source region = source region ; }
public void set subsampling x ( int s x ) { this . subsampling x = s x ; }
public memory usage setting set temp dir ( file temp dir ) { this . temp dir = temp dir ; return this ; }
public random access create buffer ( ) throw i o exception { return new scratch file buffer ( this ) ; }
public void set all page overlay p d f ( p d document all page overlay p d f ) { all page overlay = all page overlay p d f ; }
public void set odd page overlay p d f ( p d document odd page overlay p d f ) { odd page overlay = odd page overlay p d f ; }
public p d document get destination ( ) { return this . destination ; }
public void add source ( input stream source ) { source . add ( source ) ; }
public void set start page ( int start ) { if ( start < = 0 ) { throw new illegal argument exception ( `` start page be small than one `` ) ; } start page = start ; }
protect final p d document get source document ( ) { return source document ; }
public p d encryption get encryption ( ) throw i o exception { if ( document == null ) { throw new i o exception ( `` you must parse the document first before call get encryption ( ) `` ) ; } return encryption ; }
public p d document get p d document ( ) throw i o exception { p d document doc = new p d document ( get document ( ) , source , get access permission ( ) ) ; doc . set encryption dictionary ( get encryption ( ) ) ; return doc ; }
public final c o s dictionary get last trailer ( ) { if ( byte po to xref map . be empty ( ) ) { return null ; } set < long > offset = byte po to xref map . key set ( ) ; sort set < long > sort offset = new tree set < long > ( offset ) ; return byte po to xref map . get ( sort offset . last ( ) ) . trailer ; }
public set < long > get contain object number ( final int objstm obj nr ) { if ( resolve xref trailer == null ) { return null ; } final set < long > ref obj nrs = new hash set < long > ( ) ; final long cmp val = - objstm obj nr ; for ( entry < c o s object key , long > xref entry : resolve xref trailer . xref table . entry set ( ) ) { if ( xref entry . get value ( ) == cmp val ) { ref obj nrs . add ( xref entry . get key ( ) . get number ( ) ) ; } } return ref obj nrs ; }
protect c o s standard output stream get standard output ( ) { return standard output ; }
public void set file unix ( string file ) { f . set string ( c o s name . unix , file ) ; }
public void set embed file unicode ( p d embed file file ) { c o s dictionary ef = get e f dictionary ( ) ; if ( ef == null & & file ! = null ) { ef = new c o s dictionary ( ) ; f . set item ( c o s name . ef , ef ) ; } if ( ef ! = null ) { ef . set item ( c o s name . uf , file ) ; } }
public void set subtype ( string mime type ) { get c o s object ( ) . set name ( c o s name . subtype , mime type ) ; }
public calendar get mod date ( ) throw i o exception { return get c o s object ( ) . get embedded date ( `` params `` , `` mod date `` ) ; }
public string get mac creator ( ) { string retval = null ; c o s dictionary params = ( c o s dictionary ) get c o s object ( ) . get dictionary object ( c o s name . params ) ; if ( params ! = null ) { retval = params . get embedded string ( `` mac `` , `` creator `` ) ; } return retval ; }
public int get bit per sample ( ) { return get c o s object ( ) . get int ( c o s name . bits_per_sample ) ; }
public c o s array get c1 ( ) { return c1 ; }
public float pop real ( ) { return ( ( number ) stack . pop ( ) ) . float value ( ) ; }
public void add integer ( int value ) { this . instruction . add ( value ) ; }
public instruction sequence get instruction sequence ( ) { return this . main sequence ; }
public int get number of object ( ) { return get c o s object ( ) . get int ( c o s name . n , 0 ) ; }
public void set label item ( int start page , p d page label range item ) { if ( start page < 0 ) { throw new illegal argument exception ( `` start page parameter of set label item may not be < 0 `` ) ; } label . put ( start page , item ) ; }
public void set low left x ( float value ) { rect array . set ( 0 , new c o s float ( value ) ) ; }
public void set low left y ( float value ) { rect array . set ( 1 , new c o s float ( value ) ) ; }
public input stream create input stream ( list < string > stop filter ) throw i o exception { input stream be = stream . create raw input stream ( ) ; byte array output stream o = new byte array output stream ( ) ; list < c o s name > filter = get filter ( ) ; if ( filter ! = null ) { for ( int i = 0 ; i < filter . size ( ) ; i++ ) { c o s name next filter = filter . get ( i ) ; if ( ( stop filter ! = null ) & & stop filter . contains ( next filter . get name ( ) ) ) { break ; } else { filter filter = filter factory . instance . get filter ( next filter ) ; filter . decode ( be , os , stream , i ) ; i o utils . close quietly ( be ) ; be = new byte array input stream ( o . to byte array ( ) ) ; o . reset ( ) ; } } } return be ; }
public void set metadata ( p d metadata meta ) { stream . set item ( c o s name . metadata , meta ) ; }
protect void set owner ( string owner ) { this . get c o s object ( ) . set name ( c o s name . o , owner ) ; }
public void set revision number ( int revision number ) { if ( revision number < 0 ) { throw new illegal argument exception ( `` the revision number shall be > -1 `` ) ; } this . get c o s object ( ) . set int ( c o s name . r , revision number ) ; }
public p d name tree node < p d structure element > get i d tree ( ) { c o s base base = this . get c o s object ( ) . get dictionary object ( c o s name . id_tree ) ; if ( base instanceof c o s dictionary ) { return new p d structure element name tree node ( ( c o s dictionary ) base ) ; } return null ; }
public string get alternate description ( ) { return this . get property ( ) == null ? null : this . get property ( ) . get string ( c o s name . alt ) ; }
public boolean be right attach ( ) { return this . be attach ( `` right `` ) ; }
public void set start colour ( p d gamma colour ) { this . set colour by index ( 2 , colour ) ; }
public p d gamma get color ( ) { return this . get color ( color ) ; }
public void set color ( p d gamma color ) { this . set color ( color , color ) ; }
public void set space before ( float space before ) { this . set number ( space_before , space before ) ; }
public string get text align ( ) { return this . get name ( text_align , text_align_start ) ; }
public void set all t border style ( string t border style ) { this . set name ( t_border_style , t border style ) ; }
public void set t border style ( string [ ] t border style ) { this . set array of name ( t_border_style , t border style ) ; }
public void set text decoration color ( p d gamma text decoration color ) { this . set color ( text_decoration_color , text decoration color ) ; }
public float get text decoration thickness ( ) { return this . get number ( text_decoration_thickness ) ; }
public void set glyph orientation vertical ( string glyph orientation vertical ) { this . set name ( glyph_orientation_vertical , glyph orientation vertical ) ; }
public void set column count ( int column count ) { this . set integer ( column_count , column count ) ; }
protect void set string ( string name , string value ) { c o s base old base = this . get c o s object ( ) . get dictionary object ( name ) ; this . get c o s object ( ) . set string ( name , value ) ; c o s base new base = this . get c o s object ( ) . get dictionary object ( name ) ; this . potentially notify change ( old base , new base ) ; }
protect object get name or array of name ( string name , string default value ) { c o s base v = this . get c o s object ( ) . get dictionary object ( name ) ; if ( v instanceof c o s array ) { c o s array array = ( c o s array ) v ; string [ ] names = new string [ array . size ( ) ] ; for ( int i = 0 ; i < array . size ( ) ; i++ ) { c o s base item = array . get object ( i ) ; if ( item instanceof c o s name ) { names [ i ] = ( ( c o s name ) item ) . get name ( ) ; } } return name ; } if ( v instanceof c o s name ) { return ( ( c o s name ) v ) . get name ( ) ; } return default value ; }
protect void set name ( string name , string value ) { c o s base old base = this . get c o s object ( ) . get dictionary object ( name ) ; this . get c o s object ( ) . set name ( name , value ) ; c o s base new base = this . get c o s object ( ) . get dictionary object ( name ) ; this . potentially notify change ( old base , new base ) ; }
protect p d gamma get color ( string name ) { c o s array c = ( c o s array ) this . get c o s object ( ) . get dictionary object ( name ) ; if ( c ! = null ) { return new p d gamma ( c ) ; } return null ; }
public boolean be owner permission ( ) { return ( this . can assemble document ( ) & & this . can extract content ( ) & & this . can extract for accessibility ( ) & & this . can fill in form ( ) & & this . can modify ( ) & & this . can modify annotation ( ) & & this . can print ( ) & & this . can print degrade ( ) ) ; }
public boolean can assemble document ( ) { return be permission bit on ( assemble_document_bit ) ; }
public c o s dictionary get c o s dictionary ( ) { return crypt filter dictionary ; }
public final string get filter ( ) { return dictionary . get name a string ( c o s name . filter ) ; }
public int get revision ( ) { return dictionary . get int ( c o s name . r , default_version ) ; }
public void set std crypt filter dictionary ( p d crypt filter dictionary crypt filter dictionary ) { set crypt filter dictionary ( c o s name . std_cf , crypt filter dictionary ) ; }
public x509 certificate get decryption certificate ( ) { return decryption certificate ; }
public void write ( byte a byte , output stream output ) throw i o exception { b = ( b + 1 ) % 256 ; c = ( salt [ b ] + c ) % 256 ; swap ( salt , b , c ) ; int salt index = ( salt [ b ] + salt [ c ] ) % 256 ; output . write ( a byte ^ ( byte ) salt [ salt index ] ) ; }
public final void set invisible ( boolean invisible ) { annot . set flag ( c o s name . f , flag_invisible , invisible ) ; }
public final void set name ( string name ) { annot . set string ( c o s name . nm , name ) ; }
public string get rich content ( ) { return get string or stream ( annot . get dictionary object ( c o s name . rc ) ) ; }
public final void set border effect ( p d border effect dictionary be ) { annot . set item ( c o s name . be , be ) ; }
public final void set ink list ( list < float [ ] > inklist ) { c o s array new inklist = new c o s array ( ) ; for ( float [ ] array : inklist ) { c o s array new array = new c o s array ( ) ; new array . set float array ( array ) ; new inklist . add ( new array ) ; } annot . set item ( c o s name . inklist , new inklist ) ; }
public void set leader offset ( float leader offset ) { annot . set float ( c o s name . llo , leader offset ) ; }
public float get caption horizontal offset ( ) { float retval = 0 . f ; c o s array array = ( c o s array ) annot . get dictionary object ( c o s name . co ) ; if ( array ! = null ) { retval = array . to float array ( ) [ 0 ] ; } return retval ; }
public void set f d f ( f d f dictionary fdf ) { catalog . set item ( c o s name . fdf , fdf ) ; }
public void set target ( string target ) { fdf . set string ( c o s name . target , target ) ; }
public void set embed f d f ( list < p d file specification > embed ) { fdf . set item ( c o s name . embedded_fdfs , c o s array list . converter to c o s array ( embed ) ) ; }
public void set icon fit ( f d f icon fit fit ) { field . set item ( c o s name . if , fit ) ; }
public void set rich text ( c o s string rv ) { field . set item ( c o s name . rv , rv ) ; }
public void set file specification ( p d file specification f ) { ref . set item ( c o s name . f , f ) ; }
public void set template reference ( f d f name page reference t ref ) { template . set item ( c o s name . tref , t ref ) ; }
public static encode get instance ( c o s name name ) { if ( c o s name . standard_encoding . equal ( name ) ) { return standard encode . instance ; } else if ( c o s name . win_ansi_encoding . equal ( name ) ) { return win ansi encode . instance ; } else if ( c o s name . mac_roman_encoding . equal ( name ) ) { return mac roman encode . instance ; } else if ( c o s name . mac_expert_encoding . equal ( name ) ) { return mac expert encode . instance ; } else { return null ; } }
public string sequence to name ( string unicode sequence ) { string name = unicode to name . get ( unicode sequence ) ; if ( name == null ) { return `` . notdef `` ; } return name ; }
public font box font get font ( font info info ) { soft reference < font box font > reference = cache . get ( info ) ; return reference ! = null ? reference . get ( ) : null ; }
public synchronize void set provider ( font provider font provider ) { font info by name = create font info by name ( font provider . get font info ( ) ) ; this . font provider = font provider ; }
public float get vertical displacement vector y ( int code ) { int cid = code to c i d ( code ) ; float w1y = vertical displacement y . get ( cid ) ; if ( w1y == null ) { w1y = dw2 [ 1 ] ; } return w1y ; }
public type2 char string get type2 char string ( int cid ) throw i o exception { if ( cid font ! = null ) { return cid font . get type2 char string ( cid ) ; } else if ( t1 font instanceof c f f type1 font ) { return ( ( c f f type1 font ) t1 font ) . get type2 char string ( cid ) ; } else { return null ; } }
public p d c i d font get c i d font ( ) throw i o exception { return new p d c i d font type2 ( cid font , parent , ttf ) ; }
public string get type ( ) { return dict . get name a string ( c o s name . type ) ; }
public string get font stretch ( ) { string retval = null ; c o s name name = ( c o s name ) dic . get dictionary object ( c o s name . font_stretch ) ; if ( name ! = null ) { retval = name . get name ( ) ; } return retval ; }
public int get flag ( ) { if ( flags == -1 ) { flags = dic . get int ( c o s name . flag , 0 ) ; } return flag ; }
public void set italic angle ( float angle ) { dic . set float ( c o s name . italic_angle , angle ) ; }
public void set cap height ( float cap height ) { dic . set float ( c o s name . cap_height , cap height ) ; this . cap height = cap height ; }
public void set average width ( float average width ) { dic . set float ( c o s name . avg_width , average width ) ; }
public void set max width ( float max width ) { dic . set float ( c o s name . max_width , max width ) ; }
public void set miss width ( float miss width ) { dic . set float ( c o s name . missing_width , miss width ) ; }
public string get char set ( ) { string retval = null ; c o s string name = ( c o s string ) dic . get dictionary object ( c o s name . char_set ) ; if ( name ! = null ) { retval = name . get string ( ) ; } return retval ; }
public void set c i d set ( p d stream stream ) { dic . set item ( c o s name . cid_set , stream ) ; }
public final string get base font ( ) { return dict . get name a string ( c o s name . base_font ) ; }
public glyph list get glyph list ( ) { return glyph list . get adobe glyph list ( ) ; }
public type1 font get type1 font ( ) { return type1 ; }
public p d rectangle get font b box ( ) { c o s base base = dict . get dictionary object ( c o s name . font_bbox ) ; p d rectangle retval = null ; if ( base instanceof c o s array ) { retval = new p d rectangle ( ( c o s array ) base ) ; } return retval ; }
public c o s dictionary get char procs ( ) { if ( char procs == null ) { char procs = ( c o s dictionary ) dict . get dictionary object ( c o s name . char_procs ) ; } return char procs ; }
public final p d gamma get gamma ( ) { c o s array gamma array = ( c o s array ) dictionary . get dictionary object ( c o s name . gamma ) ; if ( gamma array == null ) { gamma array = new c o s array ( ) ; gamma array . add ( new c o s float ( 1 . 0f ) ) ; gamma array . add ( new c o s float ( 1 . 0f ) ) ; gamma array . add ( new c o s float ( 1 . 0f ) ) ; dictionary . set item ( c o s name . gamma , gamma array ) ; } return new p d gamma ( gamma array ) ; }
public c o s name get pattern name ( ) { return pattern name ; }
public c o s array to c o s array ( ) { c o s array array = new c o s array ( ) ; array . set float array ( component ) ; if ( pattern name ! = null ) { array . add ( pattern name ) ; } return array ; }
public float get x ( ) { return ( ( c o s number ) value . get ( 0 ) ) . float value ( ) ; }
public float get z ( ) { return ( ( c o s number ) value . get ( 2 ) ) . float value ( ) ; }
public buffer image get opaque image ( ) throw i o exception { return sample image reader . get r g b image ( this , null ) ; }
public final void set resource ( p d resource resource ) { get c o s object ( ) . set item ( c o s name . resource , resource ) ; }
public c o s array get domain ( ) { if ( domain == null ) { domain = ( c o s array ) get c o s object ( ) . get dictionary object ( c o s name . domain ) ; } return domain ; }
public void set coords ( c o s array new coords ) { coords = new coords ; get c o s object ( ) . set item ( c o s name . coords , new coords ) ; }
public void set bit per flag ( int bit per flag ) { get c o s object ( ) . set int ( c o s name . bits_per_flag , bit per flag ) ; }
public float get smoothness tolerance ( ) { return get float item ( c o s name . sm ) ; }
public c o s base get transfer2 ( ) { c o s base base = dict . get dictionary object ( c o s name . tr2 ) ; if ( base instanceof c o s array & & ( ( c o s array ) base ) . size ( ) ! = 4 ) { return null ; } return base ; }
public void set transfer2 ( c o s base transfer2 ) { dict . set item ( c o s name . tr2 , transfer2 ) ; }
public void set non stroke alpha constant ( double value ) { non stroke alpha constant = value ; }
public boolean be alpha source ( ) { return alpha source ; }
public void set overprint ( boolean value ) { overprint = value ; }
public void set overprint mode ( double value ) { overprint mode = value ; }
public p d text state get text state ( ) { return text state ; }
public void set text state ( p d text state value ) { text state = value ; }
public p d color get stroke color ( ) { return stroke color ; }
public area get current clip path ( ) { return clip path ; }
public p d function get transfer function ( ) throw i o exception { if ( transfer function == null ) { c o s base co t f = get c o s object ( ) . get dictionary object ( c o s name . tr ) ; if ( cos t f ! = null ) { transfer function = p d function . create ( cos t f ) ; } } return transfer function ; }
public void set font size ( float value ) { font size = value ; }
public void set destination ( p d destination d ) { if ( d instanceof p d page destination ) { p d page destination page d = ( p d page destination ) d ; c o s array d array = page dest . get c o s object ( ) ; if ( d array . size ( ) > = 1 ) { c o s base page = d array . get object ( 0 ) ; if ( ! ( page instanceof c o s dictionary ) ) { throw new illegal argument exception ( `` destination of a go to action must be `` + `` a page dictionary object `` ) ; } } } get c o s object ( ) . set item ( c o s name . d , d ) ; }
public void set repeat ( boolean repeat ) { action . set boolean ( c o s name . repeat , repeat ) ; }
public void set d ( p d action d ) { action . set item ( c o s name . d , d ) ; }
public void set c ( p d action c ) { action . set item ( c o s name . c , c ) ; }
public void set interior color ( p d color ic ) { get c o s object ( ) . set item ( c o s name . ic , ic . to c o s array ( ) ) ; }
public void set highlight mode ( string mode ) { get c o s object ( ) . set name ( c o s name . h , mode ) ; }
public string get reply type ( ) { return get c o s object ( ) . get name a string ( `` rt `` , rt_reply ) ; }
public void set border effect ( p d border effect dictionary be ) { get c o s object ( ) . set item ( c o s name . be , be ) ; }
public p d appearance characteristic dictionary get appearance characteristic ( ) { c o s base mk = this . get c o s object ( ) . get dictionary object ( c o s name . mk ) ; if ( mk instanceof c o s dictionary ) { return new p d appearance characteristic dictionary ( ( c o s dictionary ) mk ) ; } return null ; }
public void set action ( p d action action ) { this . get c o s object ( ) . set item ( c o s name . a , action ) ; }
public string get rollover caption ( ) { return this . get c o s object ( ) . get string ( c o s name . rc ) ; }
public p d form x object get rollover icon ( ) { c o s base i = this . get c o s object ( ) . get dictionary object ( c o s name . ri ) ; if ( i instanceof c o s stream ) { return new p d form x object ( ( c o s stream ) i ) ; } return null ; }
public boolean be stream ( ) { return this . entry instanceof c o s stream ; }
public void set style ( string s ) { get c o s object ( ) . set name ( `` s `` , s ) ; }
public void set dash style ( c o s array dash array ) { c o s array array = null ; if ( dash array ! = null ) { array = dash array ; } get c o s object ( ) . set item ( `` d `` , array ) ; }
public string get date ( ) { return dictionary . get string ( c o s name . date ) ; }
public void set filter require ( boolean flag ) { get c o s object ( ) . set flag ( c o s name . ff , flag_filter , flag ) ; }
public void set add rev info require ( boolean flag ) { get c o s object ( ) . set flag ( c o s name . ff , flag_add_rev_info , flag ) ; }
public void set reason ( list < string > reason ) { dictionary . set item ( c o s name . reason , c o s array list . converter to c o s array ( reason ) ) ; }
public void set o i d require ( boolean flag ) { this . get c o s object ( ) . set flag ( c o s name . ff , flag_oid , flag ) ; }
public list < byte [ ] > get o i d ( ) { c o s base base = this . dictionary . get dictionary object ( c o s name . oid ) ; if ( base instanceof c o s array ) { c o s array array = ( c o s array ) base ; return get list of byte array from c o s array ( array ) ; } return null ; }
public boolean be timestamp required ( ) { return dictionary . get int ( c o s name . ft , 0 ) ! = 0 ; }
public void set sub filter ( c o s name subfilter ) { dictionary . set item ( c o s name . sub_filter , subfilter ) ; }
public int [ ] get byte range ( ) { c o s array byte range = ( c o s array ) dictionary . get dictionary object ( c o s name . byterange ) ; int [ ] ary = new int [ byte range . size ( ) ] ; for ( int i = 0 ; i < ary . length ; ++i ) { ary [ i ] = byte range . get int ( i ) ; } return ary ; }
public p d page get page ( ) { return page ; }
public void set page ( p d page page ) { this . page = page ; }
public void set image form ( p d form x object image form ) { this . image form = image form ; }
public boolean fit bounding box ( ) { return type_bounded . equal ( array . get name ( 1 ) ) ; }
public int get right ( ) { return array . get int ( 4 ) ; }
public int get top ( ) { return array . get int ( 5 ) ; }
public void set action ( p d action action ) { get c o s object ( ) . set item ( c o s name . a , action ) ; }
public void set structure element ( p d structure element structure element ) { get c o s object ( ) . set item ( c o s name . se , structure element ) ; }
public string get default appearance ( ) { return dictionary . get string ( c o s name . da , `` `` ) ; }
public boolean get need appearance ( ) { return dictionary . get boolean ( c o s name . need_appearances , false ) ; }
public void set push button ( boolean pushbutton ) { get c o s object ( ) . set flag ( c o s name . ff , flag_pushbutton , pushbutton ) ; }
public void set option ( list < string > export value , list < string > display value ) { if ( export value ! = null & & display value ! = null & & ! export value . be empty ( ) & & ! display value . be empty ( ) ) { if ( export value . size ( ) ! = display value . size ( ) ) { throw new illegal argument exception ( `` the number of entry for export value and display value shall be the same . `` ) ; } else { list < key value > key value pair = field utils . to key value list ( export value , display value ) ; if ( be sort ( ) ) { field utils . sort by value ( key value pair ) ; } c o s array option = new c o s array ( ) ; for ( int i = 0 ; i < export value . size ( ) ; i++ ) { c o s array entry = new c o s array ( ) ; entry . add ( new c o s string ( key value pair . get ( i ) . get key ( ) ) ) ; entry . add ( new c o s string ( key value pair . get ( i ) . get value ( ) ) ) ; option . add ( entry ) ; } get c o s object ( ) . set item ( c o s name . opt , option ) ; } } else { get c o s object ( ) . remove item ( c o s name . opt ) ; } }
public list < string > get option export value ( ) { return get option ( ) ; }
public c o s base get value ( ) { return get c o s object ( ) . get dictionary object ( c o s name . v ) ; }
public list < string > get select export value ( ) throw i o exception { set < string > on value = get on value ( ) ; list < string > export value = get export value ( ) ; list < string > select export value = new array list < string > ( ) ; if ( export value . be empty ( ) ) { select export value . add ( get value ( ) ) ; return select export value ; } else { string field value = get value ( ) ; int idx = 0 ; for ( string on value : on value ) { if ( on value . compare to ( field value ) == 0 ) { select export value . add ( export value . get ( idx ) ) ; } } return select export value ; } }
public void set default value ( p d signature value ) throw i o exception { get c o s object ( ) . set item ( c o s name . dv , value ) ; }
public void set comb ( boolean comb ) { get c o s object ( ) . set flag ( c o s name . ff , flag_comb , comb ) ; }
public int get max len ( ) { return get c o s object ( ) . get int ( c o s name . max_len ) ; }
public string get default value ( ) { return get string or stream ( get inheritable attribute ( c o s name . dv ) ) ; }
public string get type ( ) { return type ; }
public p d number format dictionary [ ] get change x ( ) { c o s array x = ( c o s array ) this . get c o s object ( ) . get dictionary object ( `` x `` ) ; if ( x ! = null ) { p d number format dictionary [ ] retval = new p d number format dictionary [ x . size ( ) ] ; for ( int i = 0 ; i < x . size ( ) ; i++ ) { c o s dictionary dic = ( c o s dictionary ) x . get ( i ) ; retval [ i ] = new p d number format dictionary ( dic ) ; } return retval ; } return null ; }
public void set name ( string name ) { this . get c o s object ( ) . set name ( c o s name . name , name ) ; }
public p d rectangle get rectangle ( ) { p d rectangle rect = null ; c o s array array = ( c o s array ) bead . get dictionary object ( c o s name . r ) ; if ( array ! = null ) { rect = new p d rectangle ( array ) ; } return rect ; }
public void set rectangle ( p d rectangle rect ) { bead . set item ( c o s name . r , rect ) ; }
public void set hide toolbar ( boolean value ) { prefs . set boolean ( c o s name . hide_toolbar , value ) ; }
public void set fit window ( boolean value ) { prefs . set boolean ( c o s name . fit_window , value ) ; }
public string get view clip ( ) { return prefs . get name a string ( c o s name . view_clip , boundary . crop box . to string ( ) ) ; }
public void set print area ( string value ) { prefs . set name ( c o s name . print_area , value ) ; }
public void add signature ( p d signature sig object , signature option option ) throw i o exception { add signature ( sig object , null , option ) ; }
public list < p d signature field > get signature field ( ) throw i o exception { list < p d signature field > field = new array list < p d signature field > ( ) ; p d acro form acro form = get document catalog ( ) . get acro form ( ) ; if ( acro form ! = null ) { for ( p d field field : acro form . get field tree ( ) ) { if ( field instanceof p d signature field ) { field . add ( ( p d signature field ) field ) ; } } } return field ; }
public void protect ( protection policy policy ) throw i o exception { if ( be all security to be remove ( ) ) { log . warn ( `` do not call set all security to be remove ( true ) before call protect ( ) , `` + `` a protect ( ) imply set all security to be remove ( false ) `` ) ; set all security to be remove ( false ) ; } if ( ! be encrypt ( ) ) { encryption = new p d encryption ( ) ; } security handler security handler = security handler factory . instance . new security handler for policy ( policy ) ; if ( security handler == null ) { throw new i o exception ( `` no security handler for policy `` + policy ) ; } get encryption ( ) . set security handler ( security handler ) ; }
public void set resource cache ( resource cache resource cache ) { this . resource cache = resource cache ; }
public p d viewer preference get viewer preference ( ) { c o s base base = root . get dictionary object ( c o s name . viewer_preferences ) ; return base instanceof c o s dictionary ? new p d viewer preference ( ( c o s dictionary ) base ) : null ; }
public void set name ( p d document name dictionary name ) { root . set item ( c o s name . name , name ) ; }
public void set page mode ( page mode mode ) { root . set name ( c o s name . page_mode , mode . string value ( ) ) ; }
public void set page label ( p d page label label ) { root . set item ( c o s name . page_labels , label ) ; }
public string get trap ( ) { return info . get name a string ( c o s name . trap ) ; }
public void set thread bead ( list < p d thread bead > bead ) { page . set item ( c o s name . b , c o s array list . converter to c o s array ( bead ) ) ; }
public void restore graphic state ( ) throw i o exception { if ( in text mode ) { log . warn ( `` restore the graphic state be not allow within text object . `` ) ; } if ( ! font stack . be empty ( ) ) { font stack . pop ( ) ; } if ( ! stroke color space stack . be empty ( ) ) { stroke color space stack . pop ( ) ; } if ( ! non stroke color space stack . be empty ( ) ) { non stroke color space stack . pop ( ) ; } write operator ( `` q `` ) ; }
public void fill even odd ( ) throw i o exception { if ( in text mode ) { throw new illegal state exception ( `` error : fill even odd be not allow within a text block . `` ) ; } write operator ( `` f * `` ) ; }
public void shade fill ( p d shade shade ) throw i o exception { if ( in text mode ) { throw new illegal state exception ( `` error : shading fill be not allow within a text block . `` ) ; } write operand ( resource . add ( shade ) ) ; write operator ( `` sh `` ) ; }
public void begin mark content ( c o s name tag ) throw i o exception { write operand ( tag ) ; write operator ( `` bmc `` ) ; }
public void set character space ( float spacing ) throw i o exception { write operand ( space ) ; write operator ( `` tc `` ) ; }
public void insert before ( p d page new page , p d page next page ) { c o s dictionary next page dict = next page . get c o s object ( ) ; c o s dictionary parent dict = ( c o s dictionary ) next page dict . get dictionary object ( c o s name . parent ) ; c o s array kid = ( c o s array ) parent dict . get dictionary object ( c o s name . kid ) ; boolean find = false ; for ( int i = 0 ; i < kid . size ( ) ; ++i ) { c o s dictionary page dict = ( c o s dictionary ) kid . get object ( i ) ; if ( page dict . equal ( next page . get c o s object ( ) ) ) { kid . add ( i , new page . get c o s object ( ) ) ; new page . get c o s object ( ) . set item ( c o s name . parent , parent dict ) ; find = true ; break ; } } if ( ! find ) { throw new illegal argument exception ( `` attempt to insert before orphan page `` ) ; } increase parent ( parent dict ) ; }
public iterable < c o s name > get font name ( ) { return get name ( c o s name . font ) ; }
public iterable < c o s name > get shade name ( ) { return get name ( c o s name . shade ) ; }
public c o s name add ( p d x object xobject , string prefix ) { return add ( c o s name . xobject , prefix , xobject ) ; }
public void put ( c o s name name , p d font font ) { put ( c o s name . font , name , font ) ; }
public void put ( c o s name name , p d shade shade ) { put ( c o s name . shading , name , shade ) ; }
public void put ( c o s name name , p d abstract pattern pattern ) { put ( c o s name . pattern , name , pattern ) ; }
protect final graphics2 d get graphic ( ) { return graphic ; }
public void render page to graphic ( int page index , graphics2 d graphic ) throw i o exception { render page to graphic ( page index , graphic , 1 ) ; }
public boolean get separate by bead ( ) { return should separate by bead ; }
public void set add more formatting ( boolean new add more formatting ) { add more formatting = new add more formatting ; }
public float get drop threshold ( ) { return drop threshold ; }
public string get paragraph end ( ) { return paragraph end ; }
public void set page start ( string page start value ) { page start = page start value ; }
public int get rotation ( ) { return rotation ; }
public float get page width ( ) { return page width ; }
public t find ( byte [ ] bytes ) { byte trie node < t > node = root ; t val = node . get value ( ) ; for ( byte b : byte ) { byte trie node < t > child = node . child . get ( b ) ; if ( child == null ) { break ; } node = child ; if ( node . get value ( ) ! = null ) { val = node . get value ( ) ; } } return val ; }
public static char [ ] get char ( short num ) { char [ ] hex = new char [ 4 ] ; hex [ 0 ] = hex_chars [ ( num > > 12 ) & 0x0 f ] ; hex [ 1 ] = hex_chars [ ( num > > 8 ) & 0x0 f ] ; hex [ 2 ] = hex_chars [ ( num > > 4 ) & 0x0 f ] ; hex [ 3 ] = hex_chars [ num & 0x0 f ] ; return hex ; }
public static matrix create matrix ( c o s base base ) { if ( ! ( base instanceof c o s array ) ) { return new matrix ( ) ; } c o s array array = ( c o s array ) base ; if ( array . size ( ) < 6 ) { return new matrix ( ) ; } for ( int i = 0 ; i < 6 ; ++i ) { if ( ! ( array . get object ( i ) instanceof c o s number ) ) { return new matrix ( ) ; } } return new matrix ( array ) ; }
public matrix multiply ( matrix b ) { return this . multiply ( b , new matrix ( ) ) ; }
public void transform ( point2 d point ) { float x = ( float ) point . get x ( ) ; float y = ( float ) point . get y ( ) ; float a = single [ 0 ] ; float b = single [ 1 ] ; float c = single [ 3 ] ; float d = single [ 4 ] ; float e = single [ 6 ] ; float f = single [ 7 ] ; point . set location ( x * a + y * c + e , x * b + y * d + f ) ; }
public static matrix get rotate instance ( double theta , float tx , float ty ) { float co theta = ( float ) math . co ( theta ) ; float sin theta = ( float ) math . sin ( theta ) ; matrix matrix = new matrix ( ) ; matrix . single [ 0 ] = co theta ; matrix . single [ 1 ] = sin theta ; matrix . single [ 3 ] = -sin theta ; matrix . single [ 4 ] = co theta ; matrix . single [ 6 ] = tx ; matrix . single [ 7 ] = ty ; return matrix ; }
public boolean be landscape ( ) { return landscape ; }
public static long pack order ints ( int leave , int right ) { long packed1 = ( long ) leave < < 32 ; long packed2 = integer . rotate leave ( right , 1 ) & 0x f f f f f f f f l ; return long . rotate right ( packed1 | packed2 , 1 ) ; }
protect context get parent ( ) { return parent ; }
protect string to map key ( string role , string role hint ) { if ( role hint == null ) { return role ; } else { return role + `` : `` + role hint ; } }
public list < method > get ( string key ) { return method by name map . get ( key ) ; }
public void set name ( string name ) { this . name = name ; } // -- void set name ( string )
protect void slow scan ( ) { if ( have slow result ) { return ; } string [ ] excl = new string [ dirs exclude . size ( ) ] ; dirs exclude . copy into ( excl ) ; string [ ] not incl = new string [ dirs not include . size ( ) ] ; dirs not include . copy into ( not incl ) ; for ( string an excl : excl ) { if ( ! could hold include ( an excl ) ) { scandir ( new file ( basedir , an excl ) , an excl + file . separator , false ) ; } } for ( string a not incl : not incl ) { if ( ! could hold include ( a not incl ) ) { scandir ( new file ( basedir , a not incl ) , a not incl + file . separator , false ) ; } } have slow result = true ; }
public void remove directory walk listener ( directory walk listener listener ) { listener . remove ( listener ) ; }
public static throwable get cause ( throwable throwable ) { return get cause ( throwable , cause_method_names ) ; }
public static void print root cause stack trace ( throwable t ) { print root cause stack trace ( t , system . err ) ; }
public static list < method > get setter ( class < ? > clazz ) { method [ ] method = clazz . get method ( ) ; list < method > list = new array list < method > ( ) ; for ( method method : method ) { if ( be setter ( method ) ) { list . add ( method ) ; } } return list ; }
public static boolean parse boolean ( char sequence char ) { return ( char . length ( ) == 4 ) & & ( char . char at ( 0 ) == 't ' || char . char at ( 0 ) == 't ' ) & & ( char . char at ( 1 ) == ' r ' || char . char at ( 1 ) == ' r ' ) & & ( char . char at ( 2 ) == ' u ' || char . char at ( 2 ) == ' u ' ) & & ( char . char at ( 3 ) == ' e ' || char . char at ( 3 ) == ' e ' ) ; }
protect void end of line ( ) { write ( get line separator ( ) ) ; for ( int i = 0 ; i < get depth ( ) ; i++ ) { write ( get line indenter ( ) ) ; } }
protect static final string printable ( string s ) { if ( s == null ) return `` null `` ; string builder retval = new string builder ( s . length ( ) + 16 ) ; retval . append ( `` ' `` ) ; char ch ; for ( int i = 0 ; i < s . length ( ) ; i++ ) { add printable ( retval , s . char at ( i ) ) ; } retval . append ( `` ' `` ) ; return retval . to string ( ) ; }
public argument create argument ( ) { return this . create argument ( false ) ; }
public static boolean be valid window file name ( file f ) { if ( o . be family ( o . family_windows ) ) { if ( string utils . index of any ( f . get name ( ) , invalid_characters_for_windows_file_name ) ! = -1 ) { return false ; } file parent file = f . get parent file ( ) ; if ( parent file ! = null ) { return be valid window file name ( parent file ) ; } } return true ; }
public void add escher property ( escher property prop ) { property . add ( prop ) ; }
public list < escher property > get escher property ( ) { return property ; }
public byte get marker ( ) { return field_2_marker ; }
public void set picture data ( byte [ ] picture data ) { set picture data ( picture data , 0 , ( picture data == null ? 0 : picture data . length ) ) ; }
public void set row1 ( short field_4_row1 ) { this . field_4_row1 = field_4_row1 ; }
public int get num id cluster ( ) { return ( field_5_file id cluster . be empty ( ) ? 0 : field_5_file id cluster . size ( ) + 1 ) ; }
public int get drawing save ( ) { return field_4_drawings save ; }
public int get compress size ( ) { return field_5_cb save ; }
public short get instance ( ) { return f instance . get short value ( _options ) ; }
public int get color1 ( ) { return field_1_color1 ; }
public void set color1 ( int field_1_color1 ) { this . field_1_color1 = field_1_color1 ; }
public void set color4 ( int field_4_color4 ) { this . field_4_color4 = field_4_color4 ; }
public short get shape type ( ) { return get instance ( ) ; }
public static void set all thread prefer event extractor ( boolean prefer event extractor ) { all prefer event extractor = prefer event extractor ; }
public summary information get summary information ( ) { return document . get summary information ( ) ; }
public set < string > name set ( ) { return collection . unmodifiable set ( dictionary . value ( ) ) ; }
public void set byte count ( final int byte count ) { set1st property ( property i d map . pid_bytecount , byte count ) ; }
public void remove slide count ( ) { remove1st property ( property i d map . pid_slidecount ) ; }
public void set hidden count ( final int hidden count ) { set1st property ( property i d map . pid_hiddencount , hidden count ) ; }
public void remove m m clip count ( ) { remove1st property ( property i d map . pid_mmclipcount ) ; }
public int get application version ( ) { return get property int value ( property i d map . pid_version ) ; }
public void remove language ( ) { remove1st property ( property i d map . pid_language ) ; }
public void remove document version ( ) { remove1st property ( property i d map . pid_docversion ) ; }
public long get i d ( ) { return id ; }
public property [ ] get property ( ) { return property . value ( ) . to array ( new property [ 0 ] ) ; }
public void set comment ( final string comment ) { set1st property ( property i d map . pid_comments , comment ) ; }
public void set last author ( final string last author ) { set1st property ( property i d map . pid_lastauthor , last author ) ; }
public void remove edit time ( ) { remove1st property ( property i d map . pid_edittime ) ; }
public void set word count ( final int word count ) { set1st property ( property i d map . pid_wordcount , word count ) ; }
public int get last column number ( ) { return last column number ; }
public void process event ( h s s f request req , input stream in ) { try { generic process event ( req , in ) ; } catch ( h s s f user exception hue ) { / * if an h s s f user exception user exception be throw , ignore it . * / } }
public void add listener for all record ( h s s f listener lsnr ) { short [ ] rectypes = record factory . get all know record s i d ( ) ; for ( short rectype : rectypes ) { add listener ( lsnr , rectype ) ; } }
protect short process record ( record rec ) throw h s s f user exception { list < h s s f listener > listener = _records . get ( short . value of ( rec . get sid ( ) ) ) ; short user code = 0 ; if ( listener ! = null ) { for ( int k = 0 ; k < listener . size ( ) ; k++ ) { object listen obj = listener . get ( k ) ; if ( listen obj instanceof abortable h s s f listener ) { abortable h s s f listener listener = ( abortable h s s f listener ) listen obj ; user code = listener . abortable process record ( rec ) ; if ( user code ! = 0 ) break ; } else { h s s f listener listener = ( h s s f listener ) listen obj ; listener . process record ( rec ) ; } } } return user code ; }
public void remove value record ( int row , cell value record interface col ) { log . log ( p o i logger . debug , `` remove value record row `` +row ) ; _rows aggregate . remove cell ( col ) ; }
public void set grid print ( boolean value ) { gridset . set gridset ( ! value ) ; }
public short get x f index for col at ( short column index ) { column info record ci = _column info . find column info ( column index ) ; if ( ci ! = null ) { return ( short ) ci . get x f index ( ) ; } return 0x f ; }
public void set leave col ( short leave col ) { if ( window two ! =null ) { window two . set leave col ( left col ) ; } }
public boolean row have cell ( int row ) { if ( row > = record . length ) { return false ; } cell value record interface [ ] row cells=records [ row ] ; if ( row cells==null ) return false ; for ( int col=0 ; col < row cell . length ; col++ ) { if ( row cell [ col ] ! =null ) return true ; } return false ; }
public int get build ( ) { return field_3_build ; }
public void set position of bof ( int po ) { field_1_position_of_ b o f = po ; }
public int get border leave ( ) { return bord leave line style . get value ( field_13_border_styles1 ) ; }
public void set border diagonal ( int border ) { field_14_border_styles2 = bord diag line style . set value ( field_14_border_styles2 , border ) ; }
public void set right border color ( int color ) { field_13_border_styles1 = bord right line color . set value ( field_13_border_styles1 , color ) ; }
public void set bold ( boolean bold ) { set font weight ( bold ? font_weight_bold : font_weight_normal ) ; }
public void set cell range ( cell range address [ ] cell range ) { if ( cell range == null ) { throw new illegal argument exception ( `` cell range must not be null `` ) ; } cell range address list cral = new cell range address list ( ) ; cell range address enclose range = null ; for ( cell range address cr : cell range ) { enclose range = cell range util . create enclose cell range ( cr , enclose range ) ; cral . add cell range address ( cr ) ; } field_3_enclosing_cell_range = enclose range ; field_4_cell_ranges = cral ; }
public static c f rule12 record create ( h s s f sheet sheet , extend color color ) { c f rule12 record r = new c f rule12 record ( condition_type_data_bar , comparison operator . no_comparison ) ; data bar formatting dbf = r . create data bar formatting ( ) ; dbf . set color ( color ) ; dbf . set percent min ( ( byte ) 0 ) ; dbf . set percent max ( ( byte ) 100 ) ; data bar threshold min = new data bar threshold ( ) ; min . set type ( range type . min . id ) ; dbf . set threshold min ( min ) ; data bar threshold max = new data bar threshold ( ) ; max . set type ( range type . max . id ) ; dbf . set threshold max ( max ) ; return r ; }
public static ptg [ ] parse formula ( string formula , h s s f sheet sheet ) { if ( formula == null ) { return null ; } int sheet index = sheet . get workbook ( ) . get sheet index ( sheet ) ; return h s s f formula parser . parse ( formula , sheet . get workbook ( ) , formula type . cell , sheet index ) ; }
public void set pattern ( short field_3_pattern ) { this . field_3_pattern = field_3_pattern ; }
public short get maximum category ( ) { return field_2_maximum category ; }
public short get minor unit value ( ) { return field_5_minor unit value ; }
public void set minor unit value ( short field_5_minor unit value ) { this . field_5_minor unit value = field_5_minor unit value ; }
public void set default minimum ( boolean value ) { field_9_options = default minimum . set short boolean ( field_9_options , value ) ; }
public boolean be default cross ( ) { return default cross . be set ( field_9_options ) ; }
public short get bar space ( ) { return field_1_bar space ; }
public short get format flag ( ) { return field_3_format flag ; }
public void set point number ( short field_1_point number ) { this . field_1_point number = field_1_point number ; }
public boolean be show series key ( ) { return show series key . be set ( field_1_options ) ; }
public short get height basis ( ) { return field_3_height basis ; }
public void set option ( short field_2_options ) { this . field_2_options = field_2_options ; }
public boolean be vertical ( ) { return vertical . be set ( field_7_options ) ; }
public boolean be data table ( ) { return data table . be set ( field_7_options ) ; }
public void set line pattern ( short field_2_line pattern ) { this . field_2_line pattern = field_2_line pattern ; }
public short get colour palette index ( ) { return field_5_colour palette index ; }
public byte get reference type ( ) { return field_2_reference type ; }
public short get option ( ) { return field_3_options ; }
public void set option ( short field_3_options ) { this . field_3_options = field_3_options ; }
public void set format index ( short field_1_format index ) { this . field_1_format index = field_1_format index ; }
public boolean be show actual ( ) { return show actual . be set ( field_1_format flag ) ; }
public short get category data type ( ) { return field_1_category data type ; }
public void set category data type ( short field_1_category data type ) { this . field_1_category data type = field_1_category data type ; }
public short get num value ( ) { return field_4_num value ; }
public void set num value ( short field_4_num value ) { this . field_4_num value = field_4_num value ; }
public void set bubble series type ( short field_5_bubble series type ) { this . field_5_bubble series type = field_5_bubble series type ; }
public int get id ( ) { return field_1_id ; }
public void set empty ( byte empty ) { this . field_2_empty = empty ; }
public void set plot visible only ( boolean value ) { field_1_flags = plot visible only . set boolean ( field_1_flags , value ) ; }
public void set options1 ( short field_9_options1 ) { this . field_9_options1 = field_9_options1 ; }
public short get text rotation ( ) { return field_12_text rotation ; }
public void set zero1 ( int field_6_zero1 ) { this . field_6_zero1 = field_6_zero1 ; }
public boolean be autorotate ( ) { return autorotate . be set ( field_10_options ) ; }
public boolean be automatic category crossing ( ) { return automatic category crossing . be set ( field_6_options ) ; }
public boolean be lock ( ) { return lock . be set ( field_3_option ) ; }
public int get total size ( ) { return 4 + _size ; }
public void associate shape to obj record ( escher record r , record obj record ) { shape to obj . put ( r , obj record ) ; }
public boolean be italic ( ) { return italic . be set ( field_2_attributes ) ; }
public byte get charset ( ) { return field_8_charset ; }
public string get font name ( ) { return field_11_font_name ; }
public void set value ( double value ) { field_4_value = value ; special cache value = null ; }
public boolean be url link ( ) { return ( _link opts & hlink_url ) > 0 & & ( _link opts & hlink_abs ) > 0 ; }
public boolean be file link ( ) { return ( _link opts & hlink_url ) > 0 & & ( _link opts & hlink_abs ) == 0 ; }
public void set iteration ( boolean iterate ) { _flags = iteration on . set boolean ( _flags , iterate ) ; }
public int serialize ( int offset , byte [ ] data ) { throw new record format exception ( `` label record be support read only . . . convert to label s s t `` ) ; }
public double get r k number at ( int coffset ) { return r k util . decode number ( field_3_rks [ coffset ] . rk ) ; }
public int get extern sheet number ( ) { ptg [ ] tokens = field_13_name_definition . get token ( ) ; if ( token . length == 0 ) { return 0 ; } ptg ptg = token [ 0 ] ; if ( ptg . get class ( ) == area3 d ptg . class ) { return ( ( area3 d ptg ) ptg ) . get extern sheet index ( ) ; } if ( ptg . get class ( ) == ref3 d ptg . class ) { return ( ( ref3 d ptg ) ptg ) . get extern sheet index ( ) ; } return 0 ; }
public void set value ( double value ) { field_4_value = value ; }
public void set protect ( boolean protect ) { _options = protected flag . set boolean ( _options , protect ) ; }
public int read u short ( ) { check record position ( little endian consts . short_size ) ; _current data offset += little endian consts . short_size ; return _data input . read u short ( ) ; }
public byte [ ] read remainder ( ) { int size = remain ( ) ; if ( size ==0 ) { return empty_byte_array ; } byte [ ] result = i o utils . safely allocate ( size , max_record_length ) ; read fully ( result ) ; return result ; }
public void set outline level ( short ol ) { field_7_option_flags = outline level . set value ( field_7_option_flags , ol ) ; }
public int get last col ( ) { return field_3_last_col ; }
public void set active cell row ( int row ) { field_2_row_active_cell = row ; reset field6 ( ) ; }
public unicode string get string ( int id ) { return field_3_strings . get ( id ) ; }
public void fill polygon ( int x point [ ] , int y point [ ] , int n point ) { _escher graphic . fill polygon ( x point , y point , n point ) ; }
public string get data format string ( org . apache . poi . s . usermodel . workbook workbook ) { h s s f data format format = new h s s f data format ( ( ( h s s f workbook ) workbook ) . get workbook ( ) ) ; int idx = get data format ( ) ; return idx == -1 ? `` general `` : format . get format ( get data format ( ) ) ; }
public boolean get quote prefixed ( ) { return _format . get123 prefix ( ) ; }
public short get read order ( ) { return _format . get reading order ( ) ; }
public void add rule ( h s s f conditional formatting rule cf rule ) { cf aggregate . add rule ( cf rule . get cf rule record ( ) ) ; }
protect static int absolute day ( calendar cal , boolean use1904windowing ) { return date util . absolute day ( cal , use1904windowing ) ; }
public name x ptg get name x ptg ( string name , sheet identifier sheet ) { int sheet ref index = get sheet ext ix ( sheet ) ; return _i book . get name x ptg ( name , sheet ref index , _u book . get u d f finder ( ) ) ; }
public void set bold ( boolean bold ) { if ( bold ) font . set bold weight ( boldweight_bold ) ; else font . set bold weight ( boldweight_normal ) ; }
public void notify delete cell ( h s s f cell cell ) { _book evaluator . notify delete cell ( new h s s f evaluation cell ( cell ) ) ; }
protect cell value evaluate formula cell value ( cell cell ) { value eval eval = _book evaluator . evaluate ( new h s s f evaluation cell ( ( h s s f cell ) cell ) ) ; if ( eval instanceof bool eval ) { bool eval be = ( bool eval ) eval ; return cell value . value of ( be . get boolean value ( ) ) ; } if ( eval instanceof numeric value eval ) { numeric value eval ne = ( numeric value eval ) eval ; return new cell value ( ne . get number value ( ) ) ; } if ( eval instanceof string value eval ) { string value eval ne = ( string value eval ) eval ; return new cell value ( ne . get string value ( ) ) ; } if ( eval instanceof error eval ) { return cell value . get error ( ( ( error eval ) eval ) . get error code ( ) ) ; } throw new runtime exception ( `` unexpected eval class ( `` + eval . get class ( ) . get name ( ) + `` ) `` ) ; }
public void set no color ( boolean mono ) { print setup record . set no color ( mono ) ; }
public void set copy ( short copy ) { print setup record . set copy ( copy ) ; }
public short get page start ( ) { return print setup record . get page start ( ) ; }
public boolean get no color ( ) { return print setup record . get no color ( ) ; }
public boolean get no orientation ( ) { return print setup record . get no orientation ( ) ; }
public short get v resolution ( ) { return print setup record . get v resolution ( ) ; }
public void clear formatting ( ) { _string = clone string if require ( ) ; _string . clear formatting ( ) ; add to s s t if require ( ) ; }
public short get font at index ( int index ) { int size = _string . get format run count ( ) ; unicode string . format run current run = null ; for ( int i=0 ; i < size ; i++ ) { unicode string . format run r = _string . get format run ( i ) ; if ( r . get character po ( ) > index ) { break ; } current run = r ; } if ( current run == null ) { return no_font ; } return current run . get font index ( ) ; }
public int get line style color ( ) { escher r g b property rgb property = _opt record . lookup ( escher property . linestyle__color ) ; return rgb property == null ? linestyle__color_default : rgb property . get rgb color ( ) ; }
public int get fill color ( ) { escher r g b property rgb property = _opt record . lookup ( escher property . fill__fillcolor ) ; return rgb property == null ? fill__fillcolor_default : rgb property . get rgb color ( ) ; }
public void set margin left ( int margin leave ) { set property value ( new escher simple property ( escher property . text__textleft , margin leave ) ) ; }
public short get horizontal alignment ( ) { return ( short ) get text object record ( ) . get horizontal text alignment ( ) ; }
public static h s s f workbook create workbook ( ) { return new h s s f workbook ( ) ; }
public string get hex string ( ) { return ( integer . to hex string ( color . get red ( ) * 0x101 ) + `` : `` + integer . to hex string ( color . get green ( ) * 0x101 ) + `` : `` + integer . to hex string ( color . get blue ( ) * 0x101 ) ) . to upper case ( locale . root ) ; }
public static void set top border color ( int color , cell range address region , h s s f sheet sheet , h s s f workbook workbook ) { region util . set top border color ( color , region , sheet ) ; }
public static byte [ ] get block0 ( byte [ ] hash , int size ) { return get block x ( hash , size , ( byte ) 0 ) ; }
public static string xor hash password ( string password ) { int hash password = create xor verifier2 ( password ) ; return string . format ( locale . root , `` % 1 $ 08x `` , hash password ) ; }
public static void copy node ( p o i f s file system source , p o i f s file system target , list < string > excepts ) throw i o exception { copy node ( new filter directory node ( source . get root ( ) , excepts ) , new filter directory node ( target . get root ( ) , excepts ) ) ; }
public document entry create document ( final string name , final int size , final p o i f s writer listener writer ) throw i o exception { return get root ( ) . create document ( name , size , writer ) ; }
public boolean should use small block ( ) { return super . should use small block ( ) ; }
public class i d get storage clsid ( ) { return _storage_clsid ; }
protect void set size ( int size ) { _size . set ( size , _raw_data ) ; }
public void set y ( string value ) { this . y = value ; }
public void set scrgb clr ( c t sc rgb color value ) { this . scrgb clr = value ; }
public void set srgb clr ( c t s rgb color value ) { this . srgb clr = value ; }
public void set prst clr ( c t preset color value ) { this . prst clr = value ; }
public c t geom guide list get gd lst ( ) { return gd lst ; }
public c t adjust handle list get ah lst ( ) { return ah lst ; }
public c t connection site list get cxn lst ( ) { return cxn lst ; }
public string get embed ( ) { return embed ; }
public c t positive size2 d get ch ext ( ) { return ch ext ; }
public int get rot ( ) { if ( rot == null ) { return 0 ; } else { return rot ; } }
public void set flip v ( boolean value ) { this . flip v = value ; }
public long get h ( ) { if ( h == null ) { return 0l ; } else { return h ; } }
public long get z ( ) { return z ; }
public void set min ang ( string value ) { this . min ang = value ; }
public c t ratio get sx ( ) { return sx ; }
public void set sx ( c t ratio value ) { this . sx = value ; }
public void set dy ( long value ) { this . dy = value ; }
public void shear ( double shx , double shy ) { _transform . shear ( shx , shy ) ; }
public boolean draw image ( image img , affine transform xform , image observer obs ) { if ( log . check ( p o i logger . warn ) ) { log . log ( p o i logger . warn , `` not implement `` ) ; } return false ; }
public graphic create ( ) { try { return ( graphic ) clone ( ) ; } catch ( clone not support exception e ) { throw new runtime exception ( e ) ; } }
public static collection < string > get not support function name ( ) { analysis tool pak inst = ( analysis tool pak ) instance ; collection < string > lst = new tree set < > ( ) ; for ( map . entry < string , free ref function > me : inst . _functions by name . entry set ( ) ) { free ref function func = me . get value ( ) ; if ( func instanceof not implement ) { lst . add ( me . get key ( ) ) ; } } return collection . unmodifiable collection ( lst ) ; }
public value eval evaluate ( value eval [ ] args , operation evaluation context ec ) { if ( args . length < 2 || args . length > 3 ) { return error eval . value_invalid ; } int src cell row = ec . get row index ( ) ; int src cell col = ec . get column index ( ) ; double start ; int day ; double [ ] holiday ; try { start = this . evaluator . evaluate date arg ( args [ 0 ] , src cell row , src cell col ) ; day = ( int ) math . floor ( this . evaluator . evaluate number arg ( args [ 1 ] , src cell row , src cell col ) ) ; value eval holiday cell = args . length == 3 ? args [ 2 ] : null ; holiday = this . evaluator . evaluate date arg ( holiday cell , src cell row , src cell col ) ; return new number eval ( date util . get excel date ( workday calculator . instance . calculate workday ( start , day , holiday ) ) ) ; } catch ( evaluation exception e ) { return error eval . value_invalid ; } }
public static boolean be type ( cell cell , cell type type ) { final cell type cell type = cell . get cell type ( ) ; return cell type == type || ( cell type == cell type . formula & & cell . get cached formula result type ( ) == type ) ; }
public void clear ( ) { if ( _evaluation listener ! = null ) { _evaluation listener . on clear whole cache ( ) ; } _plain cell cache . clear ( ) ; _formula cell cache . clear ( ) ; }
static public double pmt ( double r , int nper , double pv ) { return pmt ( r , nper , pv , 0 ) ; }
public final value eval evaluate ( value eval [ ] args , int src row index , int src column index ) { if ( args . length ! = 2 ) { return error eval . value_invalid ; } return evaluate ( src row index , src column index , args [ 0 ] , args [ 1 ] ) ; }
public final value eval evaluate ( value eval [ ] args , int src row index , int src column index ) { if ( args . length ! = 4 ) { return error eval . value_invalid ; } return evaluate ( src row index , src column index , args [ 0 ] , args [ 1 ] , args [ 2 ] , args [ 3 ] ) ; }
public static double round ( double n , int p ) { return round ( n , p , java . math . round mode . half_up ) ; }
public static double average ( double [ ] value ) { double ave = 0 ; double sum = 0 ; for ( int i=0 , i size=values . length ; i < i size ; i++ ) { sum += value [ i ] ; } ave = sum / value . length ; return ave ; }
public static double sumsq ( double [ ] value ) { double sumsq = 0 ; for ( int i=0 , i size=values . length ; i < i size ; i++ ) { sumsq += value [ i ] * value [ i ] ; } return sumsq ; }
public static double product ( double [ ] value ) { double product = 0 ; if ( value ! =null & & value . length > 0 ) { product = 1 ; for ( int i=0 , i size=values . length ; i < i size ; i++ ) { product * = value [ i ] ; } } return product ; }
public static double min ( double [ ] value ) { double min = double . positive_infinity ; for ( int i=0 , i size=values . length ; i < i size ; i++ ) { min = math . min ( min , value [ i ] ) ; } return min ; }
public static double acosh ( double d ) { return math . log ( math . sqrt ( math . pow ( d , 2 ) - 1 ) + d ) ; }
protect final double [ ] get number array ( value eval [ ] operands ) throw evaluation exception { if ( operand . length > get max num operand ( ) ) { throw evaluation exception . invalid value ( ) ; } double list retval = new double list ( ) ; for ( int i=0 , i size=operands . length ; i < i size ; i++ ) { collect value ( operand [ i ] , retval ) ; } return retval . to array ( ) ; }
protect static short lookup index ( string name ) { short ix = function metadata registry . lookup index by name ( name . to upper case ( locale . root ) ) ; if ( ix < 0 ) { return function_index_external ; } return ix ; }
public int get value ( ) { return charset ; }
public cell range address base applies to ( table table , cell cell ) { if ( cell == null ) return null ; return applies to ( table , new cell reference ( cell . get sheet ( ) . get sheet name ( ) , cell . get row index ( ) , cell . get column index ( ) , true , true ) ) ; }
public cell reference get last cell ( ) { return _last cell ; }
public static cell range address [ ] merge cell range ( cell range address [ ] cell range ) { if ( cell range . length < 1 ) { return new cell range address [ ] { } ; } list < cell range address > list = to list ( cell range ) ; list < cell range address > temp = merge cell range ( list ) ; return to array ( temp ) ; }
public static cell range address create enclose cell range ( cell range address cr a , cell range address cr b ) { if ( cr b == null ) { return cr a . copy ( ) ; } int min row = lt ( cr b . get first row ( ) , cr a . get first row ( ) ) ? cr b . get first row ( ) : cr a . get first row ( ) ; int max row = gt ( cr b . get last row ( ) , cr a . get last row ( ) ) ? cr b . get last row ( ) : cr a . get last row ( ) ; int min col = lt ( cr b . get first column ( ) , cr a . get first column ( ) ) ? cr b . get first column ( ) : cr a . get first column ( ) ; int max col = gt ( cr b . get last column ( ) , cr a . get last column ( ) ) ? cr b . get last column ( ) : cr a . get last column ( ) ; return new cell range address ( min row , max row , min col , max col ) ; }
public static void set alignment ( cell cell , horizontal alignment align ) { set cell style property ( cell , alignment , align ) ; }
public static void set vertical alignment ( cell cell , vertical alignment align ) { set cell style property ( cell , vertical_alignment , align ) ; }
public static void set bottom border color ( int color , cell range address region , sheet sheet ) { int col start = region . get first column ( ) ; int col end = region . get last column ( ) ; int row index = region . get last row ( ) ; cell property setter cps = new cell property setter ( cell util . bottom_border_color , color ) ; row row = cell util . get row ( row index , sheet ) ; for ( int i = col start ; i < = col end ; i++ ) { cps . set property ( row , i ) ; } }
public static int read fully ( input stream in , byte [ ] b ) throw i o exception { return read fully ( in , b , 0 , b . length ) ; }
public static long copy ( input stream src stream , file d file ) throw i o exception { file d directory = dest file . get parent file ( ) ; if ( ! ( d directory . exists ( ) || d directory . mkdirs ( ) ) ) { throw new runtime exception ( `` ca n't create destination directory : `` +dest directory ) ; } try ( output stream d stream = new file output stream ( d file ) ) { return i o utils . copy ( src stream , d stream ) ; } }
public static long calculate checksum ( input stream stream ) throw i o exception { checksum sum = new crc32 ( ) ; byte [ ] buf = new byte [ 4096 ] ; int count ; while ( ( count = stream . read ( buf ) ) ! = -1 ) { if ( count > 0 ) { sum . update ( buf , 0 , count ) ; } } return sum . get value ( ) ; }
public static boolean have line break measurer bug ( ) { string version = system . get property ( `` java . version `` ) ; string o = system . get property ( `` os . name `` ) . to lower case ( locale . root ) ; boolean ignore = boolean . get boolean ( `` org . apache . poi . jvm bug . line break measurer . ignore `` ) ; boolean have bug = ( ! ignore & & ( o . contains ( `` win `` ) & & ( `` 1 . 6 . 0_45 `` . equal ( version ) || `` 1 . 7 . 0_21 `` . equal ( version ) ) ) ) ; if ( have bug ) { log . log ( p o i logger . warn , `` jvm have line break measurer bug - see poi bug # 54904 - caller code might default to lucida sans `` ) ; } return have bug ; }
public static double get double ( byte [ ] data ) { return double . long bit to double ( get long ( data , 0 ) ) ; }
public static short get u byte ( byte [ ] data ) { return ( short ) ( data [ 0 ] & 0x f f ) ; }
public static long get u int ( byte [ ] data ) { return get u int ( data , 0 ) ; }
public static void put float ( byte [ ] data , int offset , float value ) { put int ( data , offset , float . float to int bit ( value ) ) ; }
public static void put u short ( byte [ ] data , int offset , int value ) { int i = offset ; data [ i++ ] = ( byte ) ( ( value > > > 0 ) & 0x f f ) ; data [ i++ ] = ( byte ) ( ( value > > > 8 ) & 0x f f ) ; }
public static void check ( boolean assert true , string message ) { if ( ! assert true ) { throw new record format exception ( message ) ; } }
public static double fix point to double ( int fix point ) { int i = ( fix point > > 16 ) ; int f = fix point & 0x f f f f ; return ( i + f/65536d ) ; }
public p o i x m l document part new document part ( p o i x m l relation descriptor ) { class < ? extend p o i x m l document part > cl = descriptor . get relation class ( ) ; try { return create document part ( cl , null , null ) ; } catch ( exception e ) { throw new p o i x m l exception ( e ) ; } }
public string get content type ( ) { return _type ; }
public string get relation ( ) { return _relation ; }
public integer get file name index ( p o i x m l document part part ) { string regex = _default name . replace ( `` # `` , `` ( \\d+ ) `` ) ; return integer . value of ( part . get package part ( ) . get part name ( ) . get name ( ) . replace all ( regex , `` $ 1 `` ) ) ; }
public string [ ] get parameter key ( ) { if ( parameter == null ) return new string [ 0 ] ; return parameter . key set ( ) . to array ( new string [ parameter . size ( ) ] ) ; }
public static void copy file ( file in , file out ) throw i o exception { try ( file input stream fis = new file input stream ( in ) ; file output stream fo = new file output stream ( out ) ; file channel source channel = fis . get channel ( ) ; file channel destination channel = fo . get channel ( ) ) { source channel . transfer to ( 0 , source channel . size ( ) , destination channel ) ; source channel . close ( ) ; } }
public optional < date > get last printed property ( ) { return last print ; }
public static o p c package create ( string path ) { return create ( new file ( path ) ) ; }
public package part get part ( package relationship part rel ) { package part ret part = null ; ensure relationship ( ) ; for ( package relationship rel : relationship ) { if ( rel . get relationship type ( ) . equal ( part rel . get relationship type ( ) ) ) { try { ret part = get part ( package u r i helper . create part name ( rel . get target u r i ( ) ) ) ; } catch ( invalid format exception e ) { continue ; } break ; } } return ret part ; }
public boolean contain part ( package part name part name ) { return ( this . get part ( part name ) ! = null ) ; }
public package access get package access ( ) { return package access ; }
public package relationship collection get relationship ( ) throw invalid format exception { return get relationship core ( null ) ; }
public input stream get input stream ( ) throw i o exception { input stream in stream = this . get input stream impl ( ) ; if ( in stream == null ) { throw new i o exception ( `` ca n't obtain the input stream from `` + _part name . get name ( ) ) ; } return in stream ; }
public static string encode ( string s ) { int n = s . length ( ) ; if ( n == 0 ) return s ; byte buffer bb = byte buffer . wrap ( s . get byte ( standard charsets . utf_8 ) ) ; string builder sb = new string builder ( ) ; while ( bb . have remain ( ) ) { int b = bb . get ( ) & 0xff ; if ( be unsafe ( b ) ) { sb . append ( ' % ' ) ; sb . append ( hex digit [ ( b > > 4 ) & 0x0 f ] ) ; sb . append ( hex digit [ ( b > > 0 ) & 0x0 f ] ) ; } else { sb . append ( ( char ) b ) ; } } return sb . to string ( ) ; }
public zip entry source get zip archive ( ) { return zip archive ; }
public output stream get output stream ( ) throw i o exception { cipher ci enc = crypto function . get cipher ( skey spec , cipher algorithm , chain mode . cbc , iv byte , cipher . encrypt_mode , pad ) ; return new cipher output stream ( new file output stream ( temp file ) , ci enc ) ; }
protect c t manual layout get xml object ( ) { return layout ; }
public void set indentation ( double point ) { if ( point ! = null || _p . be set p pr ( ) ) { get or create property ( ) . set indentation ( point ) ; ; } }
public void set margin left ( double point ) { if ( point ! = null || _p . be set p pr ( ) ) { get or create property ( ) . set margin leave ( point ) ; } }
public x d d f space get space before ( ) { return find defined paragraph property ( props - > prop . be set spc bef ( ) , prop - > prop . get spc bef ( ) ) . map ( space - > extract space ( space ) ) . or else ( null ) ; }
public void set bullet font follow text ( ) { get or create bullet property ( ) . set bullet font follow text ( ) ; }
public void set bold ( boolean bold ) { get or create property ( ) . set bold ( bold ) ; }
public void set baseline ( double offset ) { if ( offset == null ) { get or create property ( ) . set baseline ( null ) ; } else { get or create property ( ) . set baseline ( ( int ) ( offset * 1000 ) ) ; } }
public void set superscript ( double offset ) { set baseline ( offset == null ? null : math . ab ( offset ) ) ; }
public integer get to part ( ) { if ( _connect . be set to part ( ) ) return _connect . get to part ( ) ; else return null ; }
public string get text ( final boolean slide text , final boolean note text ) { return get text ( slide text , note text , comment by default , master by default ) ; }
public static x m l slide show create slide show ( input stream stream ) throw i o exception , invalid format exception { o p c package pkg = o p c package . open ( stream ) ; return create slide show ( pkg ) ; }
public xml object get xml object ( ) { return _r ; }
public void set name ( string name ) { _theme . set name ( name ) ; }
public c t color get c t color ( string name ) { return _scheme color . get ( name ) ; }
public string get abs path metadata ( ) throw i o exception { try ( input stream be = workbook part . get input stream ( ) ) { path extractor p = new path extractor ( be ) ; p . parse ( ) ; return p . get path ( ) ; } }
public void export to x m l ( output stream o , boolean validate ) throw s a x exception , transformer exception { export to x m l ( o , `` utf-8 `` , validate ) ; }
public c t comment get c t comment ( ) { return comment ; }
public void track all column ( ) { track all columns = true ; untracked column . clear ( ) ; }
public void untrack all column ( ) { track all columns = false ; max column width . clear ( ) ; untracked column . clear ( ) ; }
public void track column ( collection < integer > column ) { for ( final int column : column ) { track column ( column ) ; } }
public c t picture get c t picture ( ) { return _picture . get c t picture ( ) ; }
public int get first row num ( ) { if ( _writer . get number of flushed row ( ) > 0 ) { return _writer . get low index of flush row ( ) ; } return _rows . size ( ) == 0 ? 0 : _rows . first key ( ) ; }
public float get column width in pixel ( int column index ) { return _sh . get column width in pixel ( column index ) ; }
public void lock auto filter ( boolean enable ) { safe get protection field ( ) . set auto filter ( enable ) ; }
public void set compress temp file ( boolean compress ) { _compress tmp file = compress ; }
public void set theme table ( theme table theme ) { this . _theme = theme ; }
public boolean column exists ( c t col col , long index ) { return column exists1 base ( col , index+1 ) ; }
public static boolean be builtin style ( table style style ) { if ( style == null ) return false ; try { x s s f builtin table style . value of ( style . get name ( ) ) ; return true ; } catch ( illegal argument exception e ) { return false ; } }
public string get title formula ( ) { if ( ! chart . be set title ( ) ) { return null ; } c t title title = chart . get title ( ) ; if ( ! title . be set tx ( ) ) { return null ; } c t tx tx = title . get tx ( ) ; if ( ! tx . be set str ref ( ) ) { return null ; } return tx . get str ref ( ) . get f ( ) ; }
public int get theme ( ) { return ( int ) ct color . get theme ( ) ; }
public long get id ( ) { return graphic frame . get nv graphic frame pr ( ) . get c nv pr ( ) . get id ( ) ; }
public boolean need relation too ( ) { return ( _type ! = hyperlink type . document ) ; }
public string get location ( ) { return _ct hyperlink . get location ( ) ; }
public void set text ( string text ) { throw new illegal state exception ( `` you can not change text of a line break , it be always '\\n ' `` ) ; }
public void set comment ( string comment ) { _ct name . set comment ( comment ) ; }
protect void set picture reference ( package relationship rel ) { ct picture . get blip fill ( ) . get blip ( ) . set embed ( rel . get id ( ) ) ; }
public void add row label ( int column index ) { check column index ( column index ) ; area reference pivot area = get pivot area ( ) ; final int last row index = pivot area . get last cell ( ) . get row ( ) - pivot area . get first cell ( ) . get row ( ) ; c t pivot field pivot field = pivot table definition . get pivot field ( ) ; c t pivot field pivot field = c t pivot field . factory . new instance ( ) ; c t item item = pivot field . add new item ( ) ; pivot field . set axis ( s t axis . axis_row ) ; pivot field . set show all ( false ) ; for ( int i = 0 ; i < = last row index ; i++ ) { item . add new item ( ) . set t ( s t item type . default ) ; } item . set count ( item . size of item array ( ) ) ; pivot field . set pivot field array ( column index , pivot field ) ; c t row field row field ; if ( pivot table definition . get row field ( ) ! = null ) { row field = pivot table definition . get row field ( ) ; } else { row field = pivot table definition . add new row field ( ) ; } row field . add new field ( ) . set x ( column index ) ; row field . set count ( row field . size of field array ( ) ) ; }
public page order get page order ( ) { return ( page setup . get page order ( ) == null ) ? null : page order . value of ( page setup . get page order ( ) . int value ( ) ) ; }
protect static c t group shape prototype ( ) { if ( prototype == null ) { c t group shape shape = c t group shape . factory . new instance ( ) ; c t group shape non visual nv = shape . add new nv grp sp pr ( ) ; c t non visual drawing prop nvpr = nv . add new c nv pr ( ) ; nvpr . set id ( 0 ) ; nvpr . set name ( `` group 0 `` ) ; nv . add new c nv grp sp pr ( ) ; c t group shape property sp = shape . add new grp sp pr ( ) ; c t group transform2 d t2d = sp . add new xfrm ( ) ; c t positive size2 d p1 = t2d . add new ext ( ) ; p1 . set cx ( 0 ) ; p1 . set cy ( 0 ) ; c t point2 d p2 = t2d . add new off ( ) ; p2 . set x ( 0 ) ; p2 . set y ( 0 ) ; c t positive size2 d p3 = t2d . add new ch ext ( ) ; p3 . set cx ( 0 ) ; p3 . set cy ( 0 ) ; c t point2 d p4 = t2d . add new ch off ( ) ; p4 . set x ( 0 ) ; p4 . set y ( 0 ) ; prototype = shape ; } return prototype ; }
public void set font ( string typeface ) { set font family ( typeface , ( byte ) -1 , ( byte ) -1 , false ) ; }
public void set concatenate phonetic run ( boolean concatenate phonetic run ) { this . concatenate phonetic run = concatenate phonetic run ; }
public x w p f footer get footer ( int page number ) { if ( page number == 1 & & first page footer ! = null ) { return first page footer ; } if ( page number % 2 == 0 & & even page footer ! = null ) { return even page footer ; } return default footer ; }
public x w p f footer get footer ( enum type ) { if ( type == s t hdr ftr . even ) { return even page footer ; } else if ( type == s t hdr ftr . first ) { return first page footer ; } return default footer ; }
public void set chart margin ( long top , long right , long bottom , long leave ) { this . set chart bottom margin ( bottom ) ; this . set chart right margin ( right ) ; this . set chart leave margin ( leave ) ; this . set chart right margin ( right ) ; }
public int get po of table ( x w p f table t ) { return get po of body element ( t ) ; }
public x w p f table create table ( int row , int col ) { x w p f table table = new x w p f table ( ct document . get body ( ) . add new tbl ( ) , this , row , col ) ; body element . add ( table ) ; table . add ( table ) ; return table ; }
public x w p f chart create chart ( ) throw invalid format exception , i o exception { return create chart ( x w p f chart . default_width , x w p f chart . default_height ) ; }
public x w p f endnote get footnote by id ( int id ) { return ( x w p f endnote ) super . get footnote by id ( id ) ; }
public list < x w p f picture data > get all package picture ( ) { return document . get all package picture ( ) ; }
public void clear header footer ( ) { xml cursor c = header footer . new cursor ( ) ; c . remove xml content ( ) ; c . dispose ( ) ; paragraph . clear ( ) ; table . clear ( ) ; body element . clear ( ) ; }
public string get hyperlink id ( ) { return hyperlink . get id ( ) ; }
public boolean num exist ( big integer num i d ) { for ( x w p f num num : nums ) { if ( num . get c t num ( ) . get num id ( ) . equal ( num i d ) ) return true ; } return false ; }
public string get link style i d ( ) { if ( ct style . get link ( ) ! = null ) return ct style . get link ( ) . get val ( ) ; else return null ; }
public void set color ( string rgb str ) { c t tc pr tcpr = get tc pr ( ) ; c t shd ctshd = tcpr . be set shd ( ) ? tcpr . get shd ( ) : tcpr . add new shd ( ) ; ctshd . set color ( `` auto `` ) ; ctshd . set val ( s t shd . clear ) ; ctshd . set fill ( rgb str ) ; }
protect c t tc pr get tc pr ( ) { return ct tc . be set tc pr ( ) ? ct tc . get tc pr ( ) : ct tc . add new tc pr ( ) ; }
public stream [ ] get top level stream ( ) { return trailer . get point to stream ( ) ; }
public int get size in byte ( ) { return 18 ; }
public list < t n e f attribute > get attribute ( ) { return attribute ; }
public string get extension ( ) { return get string ( m a p i property . attach_extension ) ; }
public byte [ ] get data ( ) { return decompress ; }
public boolean be slide number visible ( ) { return be visible ( header footer atom . f have slide number , placeholder . slide_number ) ; }
public void set sub value ( boolean value , int idx ) { sub prop match [ idx ] = true ; int new val = super . get value ( ) ; if ( value ) { new val |= sub prop mask [ idx ] ; } else { new val & = ~sub prop mask [ idx ] ; } super . set value ( new val ) ; }
public long get record type ( ) { return _type ; }
public void set accent and hyperlink colour r g b ( int rgb ) { accent and hyperlink colour r g b = rgb ; }
public static int join r g b ( byte r , byte g , byte b ) { return join r g b ( new byte [ ] { r , g , b } ) ; }
public comment2000 atom get comment2000 atom ( ) { return comment atom ; }
public void set text ( string text ) { comment record . set text ( text ) ; }
public void set date ( date date ) { system time utils . store date ( date , _data , 4 ) ; }
public boolean get omit title place ( ) { return omit title place ! = 0 ; }
public boolean get show comment ( ) { return show comment ! = 0 ; }
public long get record type ( ) { return record type . ex avi movie . type i d ; }
public boolean get no size to server b ( ) { return _data [ 5 ] ! = 0 ; }
public string get link title ( ) { return link detail a == null ? null : link detail a . get text ( ) ; }
public int get object id ( ) { return little endian . get int ( _recdata , 0 ) ; }
public ex obj list atom get ex obj list atom ( ) { return ex obj list atom ; }
public void set type ( int type ) { little endian . put int ( _data , 4 , type ) ; }
public void set font type ( int type ) { _recdata [ 66 ] = ( byte ) type ; }
public long get record type ( ) { return _type ; }
public void set placeholder id ( byte id ) { placeholder id = id ; }
public int get text index ( ) { return _index ; }
public long get record type ( ) { return _type ; }
public list < escher record > get escher record ( ) { return child record ; }
public record remove child ( record ch ) { record rm = null ; array list < record > lst = new array list < > ( ) ; for ( record r : _children ) { if ( r ! = ch ) { lst . add ( r ) ; } else { rm = r ; } } _children = lst . to array ( new record [ lst . size ( ) ] ) ; return rm ; }
public slide atom set [ ] get slide atom set ( ) { return slide atom set ; }
public int get character text length cover ( ) { return get character cover ( char style ) ; }
public void set picture data ( h s l f picture data data ) { abstract escher opt record opt = shape . get escher opt record ( ) ; h s l f shape . set escher property ( opt , ( short ) ( escher property . fill__patterntexture + 0x4000 ) , ( data == null ? 0 : data . get index ( ) ) ) ; if ( data ! = null & & shape . get sheet ( ) ! = null ) { escher b s e record bse = get escher b s e record ( data . get index ( ) ) ; if ( bse ! = null ) { bse . set ref ( bse . get ref ( ) + 1 ) ; } } }
public void add shape ( h s l f shape shape ) { get sp container ( ) . add child record ( shape . get sp container ( ) ) ; h s l f sheet sheet = get sheet ( ) ; shape . set sheet ( sheet ) ; shape . set shape id ( sheet . allocate shape id ( ) ) ; shape . after insert ( sheet ) ; }
protect void move and scale ( rectangle2 d anchor dest ) { rectangle2 d anchor src = get anchor ( ) ; double scale x = ( anchor src . get width ( ) == 0 ) ? 0 : anchor dest . get width ( ) / anchor src . get width ( ) ; double scale y = ( anchor src . get height ( ) == 0 ) ? 0 : anchor dest . get height ( ) / anchor src . get height ( ) ; set exterior anchor ( anchor dest ) ; for ( h s l f shape shape : get shape ( ) ) { rectangle2 d chanchor = shape . get anchor ( ) ; double x = anchor dest . get x ( ) + ( chanchor . get x ( ) -anchor src . get x ( ) ) * scale x ; double y = anchor dest . get y ( ) + ( chanchor . get y ( ) -anchor src . get y ( ) ) * scale y ; double width = chanchor . get width ( ) * scale x ; double height = chanchor . get height ( ) * scale y ; shape . set anchor ( new rectangle2 d . double ( x , y , width , height ) ) ; } }
public string get instance name ( ) { ex embed ee = get ex embed ( ) ; return ( ee == null ) ? null : ee . get menu name ( ) ; }
protect escher container record create sp container ( boolean be child ) { if ( _escher container == null ) { _escher container = new escher container record ( ) ; _escher container . set option ( ( short ) 15 ) ; } return _escher container ; }
public void set sheet ( h s l f sheet sheet ) { _sheet = sheet ; }
protect h s l f escher client data record get client data ( boolean create ) { h s l f escher client data record client data = get escher child ( escher client data record . record_id ) ; if ( client data == null & & create ) { client data = new h s l f escher client data record ( ) ; client data . set option ( ( short ) 15 ) ; client data . set record id ( escher client data record . record_id ) ; get sp container ( ) . add child before ( client data , escher textbox record . record_id ) ; } return client data ; }
public p p draw get p p drawing ( ) { return _container . get p p drawing ( ) ; }
protect void set slide show ( h s l f slide show s ) { if ( _slide show ! = null ) { throw new h s l f exception ( `` ca n't change exist slideshow reference `` ) ; } _slide show = s ; list < list < h s l f text paragraph > > trs = get text paragraph ( ) ; if ( trs == null ) { return ; } for ( list < h s l f text paragraph > ltp : trs ) { h s l f text paragraph . supply sheet ( ltp , this ) ; h s l f text paragraph . apply hyperlink ( ltp ) ; } }
public byte [ ] get underlying byte ( ) { return _docstream ; }
public static void store date ( date date , byte [ ] d ) { store date ( date , dest , 0 ) ; }
public string [ ] get header ( ) throw chunk not find exception { string header = get string from chunk ( main chunk . get message header ( ) ) ; if ( header == null ) { return null ; } return header . split ( `` \\r ? \\n `` ) ; }
public string get conversation topic ( ) throw chunk not find exception { return get string from chunk ( main chunk . get conversation topic ( ) ) ; }
public message_class get message class enum ( ) throw chunk not find exception { string mc = get string from chunk ( main chunk . get message class ( ) ) ; if ( mc == null || mc . trim ( ) . length ( ) == 0 ) { return message_class . unspecified ; } else if ( mc . equal ignore case ( `` ipm . note `` ) ) { return message_class . note ; } else if ( mc . equal ignore case ( `` ipm . contact `` ) ) { return message_class . contact ; } else if ( mc . equal ignore case ( `` ipm . appointment `` ) ) { return message_class . appointment ; } else if ( mc . equal ignore case ( `` ipm . sticky note `` ) ) { return message_class . sticky_note ; } else if ( mc . equal ignore case ( `` ipm . task `` ) ) { return message_class . task ; } else if ( mc . equal ignore case ( `` ipm . post `` ) ) { return message_class . post ; } else { logger . log ( p o i logger . warn , `` i do n't recognize message class ' `` +mc+ `` ' . `` + `` please open an issue on poi 's bugzilla `` ) ; return message_class . unknown ; } }
public void set palette ( list < palette entry > palette ) { this . palette = palette ; }
public picture extract picture ( character run run , boolean fill bytes ) { if ( have picture ( run ) ) { return new picture ( run . get pic offset ( ) , _data stream , fill byte ) ; } return null ; }
public string get author ( int index ) { string auth = null ; if ( index > = 0 & & index < entry . length ) { auth = entry [ index ] ; } return auth ; }
public style description get style description ( int style index ) { return _style description [ style index ] ; }
public int character length ( ) { return ( get end ( ) - get start ( ) ) ; }
public short get bkf_flags ( ) { return field_2_bkf_flags ; }
public void set f result dirty ( boolean value ) { field_2_flt = ( byte ) f result dirty . set boolean ( field_2_flt , value ) ; }
public byte get lnc ( ) { return field_9_lnc ; }
public void set dxa lnn ( int field_12_dxa lnn ) { this . field_12_dxa lnn = field_12_dxa lnn ; }
public int get dm bin other ( ) { return field_18_dm bin other ; }
public void set dxt char space ( int field_27_dxt char space ) { this . field_27_dxt char space = field_27_dxt char space ; }
public short get unused3 ( ) { return field_36_unused3 ; }
public int get ya page n up ( ) { return field_42_ya page n up ; }
public void set ya page n up ( int field_42_ya page n up ) { this . field_42_ya page n up = field_42_ya page n up ; }
public byte get unused5 ( ) { return field_52_unused5 ; }
public byte [ ] get olst anm ( ) { return field_59_olst anm ; }
public void set f last row ( boolean value ) { field_2_tlp_flags = ( byte ) f last row . set boolean ( field_2_tlp_flags , value ) ; }
public boolean be shadow ( ) { return _f shadow . get value ( _info2 ) ! = 0 ; }
public boolean be frame ( ) { return _f frame . get value ( _info2 ) ! = 0 ; }
public string text ( ) { return _text . substring ( _start , _end ) ; }
public character run insert after ( string text ) { init all ( ) ; _text . insert ( _end , text ) ; _doc . get character table ( ) . adjust for insert ( _char end - 1 , text . length ( ) ) ; _doc . get paragraph table ( ) . adjust for insert ( _par end - 1 , text . length ( ) ) ; _doc . get section table ( ) . adjust for insert ( _section end - 1 , text . length ( ) ) ; if ( _doc instanceof h w p f document ) { ( ( bookmarks impl ) ( ( h w p f document ) _doc ) . get bookmark ( ) ) . after insert ( _end , text . length ( ) ) ; } adjust for insert ( text . length ( ) ) ; sanity check ( ) ; return get character run ( num character run ( ) - 1 ) ; }
public paragraph get paragraph ( int index ) { init paragraph ( ) ; if ( index + _par start > = _par end ) throw new index out of bound exception ( `` paragraph # `` + index + `` ( `` + ( index + _par start ) + `` ) not in range [ `` + _par start + `` ; `` + _par end + `` ) `` ) ; papx papx = _paragraphs . get ( index + _par start ) ; return paragraph . new paragraph ( this , papx ) ; }
public abstract void write to ( output stream out ) throw i o exception ; / * * * write a specified part of this byte string to an output stream . * * @ param out the output stream to which to write the data . * @ param source offset offset within these byte * @ param number to write number of byte to write * @ throw i o exception if an i/o error occur . * @ throw index out of bound exception if an offset or size be negative or too large * / final void write to ( output stream out , int source offset , int number to write ) throw i o exception { check range ( source offset , source offset + number to write , size ( ) ) ; if ( number to write > 0 ) { write to internal ( out , source offset , number to write ) ; } }
public static int compute int32 size ( final int field number , final int value ) { return compute tag size ( field number ) + compute int32 size no tag ( value ) ; }
public static int compute enum size ( final int field number , final int value ) { return compute tag size ( field number ) + compute enum size no tag ( value ) ; }
public static int compute raw varint32 size ( final int value ) { return compute u int32 size no tag ( value ) ; }
public message type get message type ( ) { return message type . proto2 ; }
public java . lang . string get json name ( ) { java . lang . object ref = json name_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; json name_ = s ; return s ; } }
public static string to string utf8 ( byte [ ] bytes ) { return new string ( byte , utf_8 ) ; }
public boolean get request streaming ( ) { return request streaming_ ; }
public java . util . list < com . google . protobuf . option > get option list ( ) { return options_ ; }
public int get syntax value ( ) { return syntax_ ; }
public m type get message ( int index ) { return get message ( index , false ) ; }
public text format parse location get location ( final field descriptor field descriptor , int index ) { return get from list ( get location ( field descriptor ) , index , field descriptor ) ; }
public field get field ( final int number ) { final field result = field . get ( number ) ; return ( result == null ) ? field . get default instance ( ) : result ; }
public void set path ( paths collection path ) { this . path = path ; }
public boolean be resolve ( ) { return path ! = null & & ! path . be empty ( ) ; }
public list < app dependency > get deployment dependency ( ) { return deployment deps ; }
public t set remote repository ( list < remote repository > remote repos ) { this . remote repos = remote repos ; return ( t ) this ; }
public < t extend multi build item > list < t > consume multi ( class < t > type ) { final item id item id = new item id ( type ) ; @ suppress warning ( `` unchecked `` ) final list < t > item = ( list < t > ) ( list ) multi item . get ( item id ) ; if ( item == null ) { return collection . empty list ( ) ; } return new array list < > ( item ) ; }
public string get key ( ) { return key ; }
public static string translate to volume path ( string window style path ) { string translate = window style path . replace ( '\\ ' , '/ ' ) ; pattern p = pattern . compile ( `` ^ ( \\w ) ( ? : $ | : ( / ) ? ( . * ) ) `` ) ; matcher m = p . matcher ( translate ) ; if ( m . match ( ) ) { string slash = optional . of nullable ( m . group ( 2 ) ) . or else ( `` / `` ) ; string path = optional . of nullable ( m . group ( 3 ) ) . or else ( `` `` ) ; return `` // `` + m . group ( 1 ) . to lower case ( ) + slash + path ; } return translate ; }
public static < t extend panache entity base > list < t > list ( string query , object . . . params ) { throw jpa operation . implementation injection miss ( ) ; }
public static < t extend panache entity base > list < t > list ( string query , sort sort , object . . . params ) { throw jpa operation . implementation injection miss ( ) ; }
public static long delete ( string query , object . . . params ) { throw jpa operation . implementation injection miss ( ) ; }
public static page of size ( int size ) { return new page ( size ) ; }
public sort descending ( ) { return direction ( direction . descend ) ; }
public sort direction ( direction direction ) { for ( column column : column ) { column . direction = direction ; } return this ; }
public sort and ( string name , direction direction ) { column . add ( new column ( name , direction ) ) ; return this ; }
public static security identity get security identity blocking ( rout context rout context , identity provider manager identity provider manager ) { quarkus http user exist = ( quarkus http user ) rout context . user ( ) ; if ( exist ! = null ) { return exist . get security identity ( ) ; } uni < security identity > defer = rout context . get ( deferred_identity_key ) ; if ( deferred ! = null ) { return defer . await ( ) . indefinitely ( ) ; } if ( identity provider manager ! = null ) { return identity provider manager . authenticate ( anonymous authentication request . instance ) . await ( ) . indefinitely ( ) ; } return null ; }
public static < t > flow . subscriber < t > to flow subscriber ( org . reactivestreams . subscriber < t > reactive stream subscriber ) { require non null ( reactive stream subscriber , `` reactive stream subscriber `` ) ; final flow . subscriber < t > flow subscriber ; if ( reactive stream subscriber instanceof reactive to flow subscriber ) { flow subscriber = ( flow . subscriber < t > ) ( ( reactive to flow subscriber < t > ) reactive stream subscriber ) . flow ; } else if ( reactive stream subscriber instanceof flow . subscriber ) { flow subscriber = ( flow . subscriber < t > ) reactive streams subscriber ; } else { flow subscriber = new flow to reactive subscriber < t > ( reactive stream subscriber ) ; } return flow subscriber ; }
public final mono < t > ignore element ( ) { return on assembly ( new mono ignore element < > ( this ) ) ; }
public final mono < t > on error continue ( bi consumer < throwable , object > error consumer ) { bi consumer < throwable , object > generic consumer = error consumer ; return subscriber context ( context . of ( on next failure strategy . key_on_next_error_strategy , on next failure strategy . resume ( generic consumer ) ) ) ; }
public final mono < t > take ( duration duration ) { return take ( duration , scheduler . parallel ( ) ) ; }
public static < t > subscription scalar subscription ( core subscriber < ? super t > subscriber , t value ) { return new scalar subscription < > ( subscriber , value ) ; }
public final parallel flux < t > do on next ( consumer < ? super t > on next ) { object . require non null ( on next , `` on next `` ) ; return do on signal ( this , on next , null , null , null , null , null , null , null ) ; }
public final flux < t > sequential ( ) { return sequential ( queue . small_buffer_size ) ; }
public final int leave ( int m ) { return wip . add and get ( m ) ; }
public static int ceiling next power of two ( final int x ) { return 1 < < ( 32 - integer . number of lead zero ( x - 1 ) ) ; }
public final byte buf mono multicast ( ) { throw new unsupported operation exception ( `` not yet implement `` ) ; }
public final byte buf mono retain ( ) { return maybe fuse ( do on next ( byte buf : : retain ) ) ; }
public final boolean be subscription dispose ( ) { return outbound_close . get ( this ) == operator . cancel subscription ( ) ; }
public tcp client secure ( consumer < ? super ssl provider . ssl context spec > ssl provider builder ) { require non null ( ssl provider builder , `` ssl provider builder `` ) ; tcp client dup = duplicate ( ) ; ssl provider . ssl context spec builder = ssl provider . builder ( ) ; ssl provider builder . accept ( builder ) ; dup . configuration ( ) . ssl provider = ( ( ssl provider . builder ) builder ) . build ( ) ; return dup ; }
public static inet socket address replace unresolved numeric ip ( inet socket address inet socket address ) { require non null ( inet socket address , `` inet socket address `` ) ; if ( ! inet socket address . be unresolved ( ) ) { return inet socket address ; } inet socket address inet address for ip string = create for ip string ( inet socket address . get host string ( ) , inet socket address . get port ( ) ) ; if ( inet address for ip string ! = null ) { return inet address for ip string ; } else { return inet socket address ; } }
public byte buf format byte buf format ( ) { if ( byte buf format == simple ) { return byte buf format . simple ; } else if ( byte buf format == hex_dump ) { return byte buf format . hex_dump ; } throw new unsupported operation exception ( `` reactor netty log handler be n't use the classic byte buf format . `` ) ; }
public duration query timeout ( ) { return query timeout ; }
public boolean be accept gzip ( ) { return accept gzip ; }
public consumer < http client request > redirect request consumer ( ) { return redirect request consumer ; }
public static cooky new client response holder ( http header header , client cookie decoder decoder ) { return new cooky ( header , http header name . set_cookie , true , decoder ) ; }
public t max chunk size ( int value ) { if ( value < = 0 ) { throw new illegal argument exception ( `` max chunk size must be strictly positive `` ) ; } this . max chunk size = value ; return get ( ) ; }
protect final boolean mark send body ( ) { return http_state . compare and set ( this , headers_sent , body_sent ) ; }
public duration idle timeout ( ) { return idle timeout ; }
public form auth config with additional field ( string first field name , string second field name , string . . . additional field name ) { not null ( first field name , `` first additional field name `` ) ; not null ( second field name , `` second additional field name `` ) ; list < string > list = new array list < string > ( additional input field name ) ; list . add ( first field name ) ; list . add ( second field name ) ; if ( additional field names ! = null & & additional field name . length > 0 ) { list . add all ( array . a list ( additional field name ) ) ; } return new form auth config ( form action , user input tag name , password input tag name , log detail , log config , csrf field name , auto detect csrf field name , send csrf token a form param , list ) ; }
public multi part spec builder empty file name ( ) { return file name ( null ) ; }
public request spec builder add cookie ( string name ) { spec . cookie ( name ) ; return this ; }
public request spec builder add multi part ( string control name , string file name , byte [ ] bytes ) { spec . multi part ( control name , file name , byte ) ; return this ; }
public request spec builder set auth ( authentication scheme auth ) { spec . set authentication scheme ( auth ) ; return this ; }
public request spec builder set port ( int port ) { spec . port ( port ) ; return this ; }
public response builder clone ( response response ) { if ( be rest assure response ( response ) ) { final rest assure response impl ra response = ra response ( response ) ; rest assure response . set content ( ra response . get content ( ) ) ; rest assure response . set have expectation ( ra response . get have expectation ( ) ) ; rest assure response . set default content type ( ra response . get default content type ( ) ) ; rest assure response . set decoder config ( ra response . get decoder config ( ) ) ; rest assure response . set session id name ( ra response . get session id name ( ) ) ; rest assure response . set connection manager ( ra response . get connection manager ( ) ) ; rest assure response . set config ( ra response . get config ( ) ) ; rest assure response . set rpr ( ra response . get rpr ( ) ) ; rest assure response . set log repository ( ra response . get log repository ( ) ) ; rest assure response . set filter context property ( ra response . get filter context property ( ) ) ; } else { rest assure response . set content ( response . a input stream ( ) ) ; } rest assure response . set content type ( response . get content type ( ) ) ; rest assure response . set cooky ( response . get detailed cooky ( ) ) ; rest assure response . set response header ( response . get header ( ) ) ; rest assure response . set status code ( response . get status code ( ) ) ; rest assure response . set status line ( response . get status line ( ) ) ; return this ; }
public response builder set status line ( string status line ) { not null ( status line , `` status line `` ) ; rest assure response . set status line ( status line ) ; return this ; }
public response builder set status code ( int status code ) { rest assure response . set status code ( status code ) ; return this ; }
public response spec builder expect status code ( int expect status code ) { spec . status code ( expect status code ) ; return this ; }
public response spec builder expect header ( string header name , string expect value ) { spec . header ( header name , expect value ) ; return this ; }
public encoder config default content charset ( charset charset ) { string charset a string = not null ( charset , charset . class ) . to string ( ) ; return new encoder config ( charset a string , default query parameter charset , should append default content charset to content type if undefined , content encoders , content type to default charset , true ) ; }
public encoder config default query parameter charset ( string charset ) { return new encoder config ( default content charset , charset , should append default content charset to content type if undefined , content encoders , content type to default charset , true ) ; }
public encoder config encode content type a ( string content type , content type encoder ) { not null ( content type , `` content- type to encode `` ) ; not null ( encoder , content type . class ) ; map < string , content type > new map = new hash map < > ( content encoders ) ; new map . put ( content type , encoder ) ; return new encoder config ( default content charset , default query parameter charset , should append default content charset to content type if undefined , new map , content type to default charset , true ) ; }
public json config number return type ( json path config . number return type number return type ) { return new json config ( number return type , true ) ; }
public multi part config default subtype ( string default subtype ) { return new multi part config ( default control name , default file name , default subtype , default boundary , default charset , true ) ; }
public rest assure config log config ( log config log config ) { not null ( log config , `` log config `` ) ; return new rest assure config ( conf ( redirect config . class ) , conf ( http client config . class ) , log config , conf ( encoder config . class ) , conf ( decoder config . class ) , conf ( session config . class ) , conf ( object mapper config . class ) , conf ( connection config . class ) , conf ( json config . class ) , conf ( xml config . class ) , conf ( s s l config . class ) , conf ( matcher config . class ) , conf ( header config . class ) , conf ( multi part config . class ) , conf ( param config . class ) , conf ( o auth config . class ) , conf ( failure config . class ) ) ; }
public s s l config key store ( string password ) { validate . not empty ( password , `` password can not be empty `` ) ; return key store ( system . get property ( `` user . home `` ) + file . separator char + `` . keystore `` , password ) ; }
public object request ( string method , object content type , boolean have body , closure config closure ) throw client protocol exception , i o exception { return this . do request ( this . default u r i . to u r i ( ) , method , content type , have body , config closure ) ; }
public void shutdown ( ) { client . get connection manager ( ) . shutdown ( ) ; }
public url to u r l ( ) throw malformed u r l exception { return base . to u r l ( ) ; }
public object a type ( class < ? > type ) throw malformed u r l exception { if ( type == uri . class ) return this . to u r i ( ) ; if ( type == url . class ) return this . to u r l ( ) ; if ( type == string . class ) return this . to string ( ) ; throw new class cast exception ( `` can not cast instance of u r i builder to class `` + type ) ; }
public list < t > get list ( string entity name ) { not null ( entity name , `` entity name `` ) ; final list < t > entity list = new array list < t > ( ) ; for ( t entity : entity ) { if ( entity . get name ( ) . equal ignore case ( entity name ) ) { entity list . add ( entity ) ; } } return collection . unmodifiable list ( entity list ) ; }
public static boolean be uri ( string potential uri ) { if ( string utils . be blank ( potential uri ) ) { return false ; } try { uri uri = new uri ( potential uri ) ; return uri . get scheme ( ) ! = null & & uri . get host ( ) ! = null ; } catch ( u r i syntax exception e ) { return false ; } }
public detail cookie matcher same site ( string expect same site attribute ) { return same site ( equal to ( expect same site attribute ) ) ; }
public static matcher < string > match dtd ( string dtd ) { return xml dtd matcher . match dtd ( dtd ) ; }
public static request specification give ( ) { return create test specification ( ) . get request specification ( ) ; }
protect void commit header ( client invocation request , http u r l connection connection ) { multivalued map < string , string > header = request . get header ( ) . a map ( ) ; for ( map . entry < string , list < string > > header : header . entry set ( ) ) { list < string > value = header . get value ( ) ; for ( string value : value ) { connection . add request property ( header . get key ( ) , value ) ; } } }
public static int get port ( ) { return port provider . get port ( ) ; }
public set < object > get provider instance ( ) { return collection . unmodifiable set ( provider instance ) ; }
public mock http request add form header ( string name , string value ) { if ( decoded form parameter == null ) { decoded form parameter = new multivalued map impl < string , string > ( ) ; content type ( `` application/x-www-form-urlencoded `` ) ; } decode form parameter . add ( name , value ) ; return this ; }
public static resteasy provider factory peek instance ( ) { return instance ; }
public static annotation [ ] get resource annotation ( method method ) { map < class < ? > , annotation > annotation = new hash map < class < ? > , annotation > ( ) ; for ( annotation annotation : method . get declare class ( ) . get annotation ( ) ) { annotation . put ( annotation . get class ( ) , annotation ) ; } for ( annotation annotation : method . get annotation ( ) ) { annotation . put ( annotation . get class ( ) , annotation ) ; } return annotation . value ( ) . to array ( new annotation [ annotation . size ( ) ] ) ; }
public list < ast node > get element ( ) { return element ! = null ? element : no_elems ; }
public void set destructuring length ( int destructuring length ) { this . destructuring length = destructuring length ; }
public int get skip count ( ) { return skip count ; }
public void set comment type ( token . comment type type ) { this . comment type = type ; }
public string get value ( ) { return value ; }
public loop get target ( ) { return target ; }
public void set target ( ast node target ) { assert not null ( target ) ; this . target = target ; target . set parent ( this ) ; }
public void set have result ( ) { type = token . expr_result ; }
public ast node get iterate object ( ) { return iterate object ; }
public void set be for each ( boolean be for each ) { this . be for each = be for each ; }
public int get in position ( ) { return in position ; }
public name get function name ( ) { return function name ; }
public void set function name ( name name ) { function name = name ; if ( name ! = null ) name . set parent ( this ) ; }
public void set be expression closure ( boolean be expression closure ) { this . be expression closure = be expression closure ; }
public void set condition ( ast node condition ) { assert not null ( condition ) ; this . condition = condition ; condition . set parent ( this ) ; }
public int get lp ( ) { return lp ; }
public void set initializer ( object literal initializer ) { this . initializer = initializer ; if ( initializer ! = null ) initializer . set parent ( this ) ; }
public void set be setter method ( ) { type = token . set ; }
public void set source name ( string source name ) { this . source name = source name ; }
public int get encode source end ( ) { return encode source end ; }
public void set variable ( list < variable initializer > variable ) { assert not null ( variable ) ; this . variable . clear ( ) ; for ( variable initializer vi : variable ) { add variable ( vi ) ; } }
public org . mozilla . javascript . node set type ( int type ) { if ( type ! = token . var & & type ! = token . const & & type ! = token . let ) throw new illegal argument exception ( `` invalid decl type : `` + type ) ; return super . set type ( type ) ; }
public void set expression ( ast node expression ) { assert not null ( expression ) ; this . expression = expression ; expression . set parent ( this ) ; }
public void set statement ( ast node statement ) { assert not null ( statement ) ; this . statement = statement ; statement . set parent ( this ) ; }
public void set fragment ( list < xml fragment > fragment ) { assert not null ( fragment ) ; this . fragment . clear ( ) ; for ( xml fragment fragment : fragment ) add fragment ( fragment ) ; }
public string get xml ( ) { return xml ; }
public require create require ( context cx , scriptable global scope ) { return new require ( cx , global scope , module script provider , pre exec , post exec , sandboxed ) ; }
public void set allow sharp comment ( boolean allow ) { allow sharp comment = allow ; }
protected class < ? > get current script class ( ) { class < ? > [ ] context = get class context ( ) ; for ( class < ? > c : context ) { if ( c ! = interpreted function . class & & native function . class . be assignable from ( c ) || policy security controller . secure caller . class . be assignable from ( c ) ) { return c ; } } return null ; }
protect boolean be getter or setter ( string name , int index , boolean setter ) { slot slot = unwrap slot ( get slot ( name , index , slot_query ) ) ; if ( slot instanceof getter slot ) { if ( setter & & ( ( getter slot ) slot ) . setter ! = null ) return true ; if ( ! setter & & ( ( getter slot ) slot ) . getter ! = null ) return true ; } return false ; }
public void set parent scope ( scriptable m ) { parent scope object = m ; }
public static < t > t get type property ( scriptable s , int index , class < t > type ) { object val = get property ( s , index ) ; if ( val == scriptable . not_found ) { val = null ; } return type . cast ( context . j to java ( val , type ) ) ; }
public void set scope provider ( scope provider scope provider ) { this . scope provider = scope provider ; }
public source info source info ( string url ) { return url to source info . get ( url ) ; }
public static void main ( string [ ] args ) { main main = new main ( `` rhino java script debugger `` ) ; main . do break ( ) ; main . set exit action ( new i proxy ( i proxy . exit_action ) ) ; system . set in ( main . get in ( ) ) ; system . set out ( main . get out ( ) ) ; system . set err ( main . get err ( ) ) ; global global = org . mozilla . javascript . tool . shell . main . get global ( ) ; global . set in ( main . get in ( ) ) ; global . set out ( main . get out ( ) ) ; global . set err ( main . get err ( ) ) ; main . attach to ( org . mozilla . javascript . tool . shell . main . shell context factory ) ; main . set scope ( global ) ; main . pack ( ) ; main . set size ( 600 , 460 ) ; main . set visible ( true ) ; org . mozilla . javascript . tool . shell . main . exec ( args ) ; }
public void dispatch next gui event ( ) throw interrupted exception { event queue queue = awt event queue ; if ( queue == null ) { queue = toolkit . get default toolkit ( ) . get system event queue ( ) ; awt event queue = queue ; } a w t event event = queue . get next event ( ) ; if ( event instanceof active event ) { ( ( active event ) event ) . dispatch ( ) ; } else { object source = event . get source ( ) ; if ( source instanceof component ) { component comp = ( component ) source ; comp . dispatch event ( event ) ; } else if ( source instanceof menu component ) { ( ( menu component ) source ) . dispatch event ( event ) ; } } }
public void action perform ( action event e ) { string cmd = e . get action command ( ) ; int return value = -1 ; if ( cmd . equal ( `` cut `` ) || cmd . equal ( `` copy `` ) || cmd . equal ( `` paste `` ) ) { j internal frame f = get select frame ( ) ; if ( f ! = null & & f instanceof action listener ) { ( ( action listener ) f ) . action perform ( e ) ; } } else if ( cmd . equal ( `` step over `` ) ) { return value = dim . step_over ; } else if ( cmd . equal ( `` step into `` ) ) { return value = dim . step_into ; } else if ( cmd . equal ( `` step out `` ) ) { return value = dim . step_out ; } else if ( cmd . equal ( `` go `` ) ) { return value = dim . go ; } else if ( cmd . equal ( `` break `` ) ) { dim . set break ( ) ; } else if ( cmd . equal ( `` exit `` ) ) { exit ( ) ; } else if ( cmd . equal ( `` open `` ) ) { string file name = choose file ( `` select a file to compile `` ) ; if ( file name ! = null ) { string text = read file ( file name ) ; if ( text ! = null ) { run proxy proxy = new run proxy ( this , run proxy . open_file ) ; proxy . file name = file name ; proxy . text = text ; new thread ( proxy ) . start ( ) ; } } } else if ( cmd . equal ( `` load `` ) ) { string file name = choose file ( `` select a file to execute `` ) ; if ( file name ! = null ) { string text = read file ( file name ) ; if ( text ! = null ) { run proxy proxy = new run proxy ( this , run proxy . load_file ) ; proxy . file name = file name ; proxy . text = text ; new thread ( proxy ) . start ( ) ; } } } else if ( cmd . equal ( `` more window . . . `` ) ) { more window dlg = new more window ( this , file window , `` window `` , `` file `` ) ; dlg . show dialog ( this ) ; } else if ( cmd . equal ( `` console `` ) ) { if ( console . be icon ( ) ) { desk . get desktop manager ( ) . deiconify frame ( console ) ; } console . show ( ) ; desk . get desktop manager ( ) . activate frame ( console ) ; console . console text area . request focus ( ) ; } else if ( cmd . equal ( `` cut `` ) ) { } else if ( cmd . equal ( `` copy `` ) ) { } else if ( cmd . equal ( `` paste `` ) ) { } else if ( cmd . equal ( `` go to function . . . `` ) ) { find function dlg = new find function ( this , `` go to function `` , `` function `` ) ; dlg . show dialog ( this ) ; } else if ( cmd . equal ( `` tile `` ) ) { j internal frame [ ] frame = desk . get all frame ( ) ; int count = frames . length ; int row , col ; row = col = ( int ) math . sqrt ( count ) ; if ( row * col < count ) { cols++ ; if ( row * col < count ) { rows++ ; } } dimension size = desk . get size ( ) ; int w = size . width/cols ; int h = size . height/rows ; int x = 0 ; int y = 0 ; for ( int i = 0 ; i < row ; i++ ) { for ( int j = 0 ; j < col ; j++ ) { int index = ( i * col ) + j ; if ( index > = frames . length ) { break ; } j internal frame f = frame [ index ] ; try { f . set icon ( false ) ; f . set maximum ( false ) ; } catch ( exception exc ) { } desk . get desktop manager ( ) . set bound for frame ( f , x , y , w , h ) ; x += w ; } y += h ; x = 0 ; } } else if ( cmd . equal ( `` cascade `` ) ) { j internal frame [ ] frame = desk . get all frame ( ) ; int count = frames . length ; int x , y , w , h ; x = y = 0 ; h = desk . get height ( ) ; int d = h / count ; if ( d > 30 ) d = 30 ; for ( int i = count -1 ; i > = 0 ; i -- , x += d , y += d ) { j internal frame f = frame [ i ] ; try { f . set icon ( false ) ; f . set maximum ( false ) ; } catch ( exception exc ) { } dimension dimen = f . get preferred size ( ) ; w = dimen . width ; h = dimen . height ; desk . get desktop manager ( ) . set bound for frame ( f , x , y , w , h ) ; } } else { object obj = get file window ( cmd ) ; if ( obj ! = null ) { file window w = ( file window ) obj ; try { if ( w . be icon ( ) ) { w . set icon ( false ) ; } w . set visible ( true ) ; w . move to front ( ) ; w . set select ( true ) ; } catch ( exception exc ) { } } } if ( return value ! = -1 ) { update enable ( false ) ; dim . set return value ( return value ) ; } }
public scriptable get builtin prototype ( builtins type ) { base function func = get builtin ctor ( type ) ; object proto = func ! = null ? func . get prototype property ( ) : null ; return proto instanceof scriptable ? ( scriptable ) proto : null ; }
protect action create insert break action ( ) { return new c style insert break action ( ) ; }
protect void yybegin ( int state , int language index ) { yybegin ( state ) ; set language index ( language index ) ; }
public void remove last token ( ) { if ( previous token==null ) { first token = current token = null ; } else { current token = previous token ; current token . set next token ( null ) ; } }
public boolean equal ( object other ) { if ( other==this ) { return true ; } if ( other instanceof document range ) { return this . compare to ( ( document range ) other ) ==0 ; } return false ; }
public document range translate ( int amount ) { start offs += amount ; end offs += amount ; return this ; }
public parser notice . level get level threshold ( ) { return level threshold ; }
public boolean be remote ( ) { return ! be local ( ) ; }
public boolean be right curly ( token t ) { return t . be right curly ( ) ; }
public void add fold parser mapping ( string syntax style , fold parser parser ) { fold parser map . put ( syntax style , parser ) ; }
public color get color ( ) { return ( color ) p . get paint ( ) ; }
public boolean get paint border ( ) { return p . get paint border ( ) ; }
public void set parse time ( long time ) { parse time = time ; }
public string get task pattern ( ) { return task pattern==null ? null : task pattern . pattern ( ) ; }
public void set validating ( boolean validating ) { spf . set validating ( validate ) ; }
public void set token maker factory ( token maker factory tmf ) { token maker factory = tmf ! =null ? tmf : token maker factory . get default instance ( ) ; }
protect j popup menu create popup menu ( ) { j popup menu popup = super . create popup menu ( ) ; append fold menu ( popup ) ; return popup ; }
public static final color get default bracket match b g color ( ) { return default_bracket_match_bg_color ; }
public boolean get e o l marker visible ( ) { return eol marker visible ; }
public fold manager get fold manager ( ) { return fold manager ; }
public boolean get paint tab line ( ) { return paint tab line ; }
public int get parser count ( ) { return parser manager==null ? 0 : parser manager . get parser count ( ) ; }
public boolean get underline for token ( token t ) { return ( get hyperlink enable ( ) & & ( t . be hyperlink ( ) || ( link generator result ! =null & & link generator result . get source offset ( ) ==t . get offset ( ) ) ) ) || syntax scheme . get style ( t . get type ( ) ) . underline ; }
public void set link scan mask ( int mask ) { mask & = ( input event . c t r l_ d o w n_ m a s k| input event . meta_down_mask| input event . a l t_ d o w n_ m a s k| input event . shift_down_mask ) ; if ( mask==0 ) { throw new illegal argument exception ( `` mask argument should be `` + `` some combination of input event . * _down_mask field `` ) ; } link scan mask = mask ; }
public void set paint mark occurrence border ( boolean paint border ) { paint mark occurrence border = paint border ; if ( mark occurrences support ! =null ) { mark occurrences support . set paint border ( paint border ) ; } }
public void set whitespace visible ( boolean visible ) { if ( whitespace visible ! =visible ) { this . whitespace visible = visible ; token painter = visible ? new visible whitespace token painter ( ) : ( token painter ) new default token painter ( ) ; repaint ( ) ; fire property change ( visible_whitespace_property , ! visible , visible ) ; } }
protect string get action map name ( ) { return shared_action_map_name ; }
public int y for line ( int line ) throw bad location exception { rectangle alloc = get visible editor rect ( ) ; if ( alloc ! =null ) { r s t a view view = ( r s t a view ) get root view ( text area ) . get view ( 0 ) ; return view . y for line ( alloc , line ) ; } return -1 ; }
public int hash code ( ) { return id . hash code ( ) ; }
public void set i d ( string id ) { if ( id==null ) { throw new illegal argument exception ( `` id can not be null `` ) ; } this . id = id ; }
public string get after caret text ( ) { return after caret ; }
public boolean be local and exists ( ) { return loc . be local and exists ( ) ; }
public void set read only ( boolean read only ) { if ( this . read only ! =read only ) { this . read only = read only ; fire property change ( read_only_property , ! read only , read only ) ; } }
public float next tab stop ( float x , int tab offset ) { if ( tab size == 0 ) { return x ; } int ntabs = ( ( int ) x - tab base ) / tab size ; return tab base + ( ( ntabs + 1f ) * tab size ) ; }
public static clipboard history get ( ) { if ( instance==null ) { instance = new clipboard history ( ) ; } return instance ; }
public list < string > get history ( ) { list < string > copy = new array list < string > ( this . history ) ; collection . reverse ( copy ) ; return copy ; }
public font get line number font ( ) { return line number font ; }
public void set icon row header inherits gutter background ( boolean inherits ) { if ( inherits ! =icon row header inherits gutter background ) { icon row header inherits gutter background = inherits ; if ( icon area ! =null ) { icon area . set inherits gutter background ( inherits ) ; } } }
public r text area base get r text area base ( ) { return text area ; }
public char char at ( int offset ) throw bad location exception { return ( ( r gap content ) get content ( ) ) . char at ( offset ) ; }
public string get name ( ) { return ( string ) get value ( name ) ; }
public void set accelerator ( key stroke accelerator ) { put value ( accelerator_key , accelerator ) ; }
public void set recordable ( boolean recordable ) { be recordable = recordable ; }
public int get margin line position ( ) { return margin size in char ; }
public void set margin line color ( color color ) { margin line color = color ; if ( margin line enable ) { rectangle visible rect = get visible rect ( ) ; repaint ( margin line x , visible rect . y , 1 , visible rect . height ) ; } }
public static component u i create u i ( j component text area ) { return new r text area u i ( text area ) ; }
public r text area get r text area ( ) { return text area ; }
public boolean get match case ( ) { return match case ; }
public boolean get search selection only ( ) { return selection only ; }
public void set search selection only ( boolean selection only ) { if ( selection only ! =this . selection only ) { this . selection only = selection only ; fire property change ( property_selection_only , ! selection only , selection only ) ; if ( selection only ) { throw new unsupported operation exception ( `` search in selection be not currently support `` ) ; } } }
public boolean contains ( int integer ) { for ( int i=0 ; i < size ; i++ ) { if ( data [ i ] ==integer ) { return true ; } } return false ; }
public void remove ( int index ) { if ( index > =size ) { throw exception ( index ) ; } int to move = size - index - 1 ; if ( to move > 0 ) { system . arraycopy ( data , index+1 , data , index , to move ) ; } -- size ; }
public static disposable from runnable ( @ non null runnable run ) { object helper . require non null ( run , `` run be null `` ) ; return new runnable disposable ( run ) ; }
public flowable < t > auto connect ( ) { return auto connect ( 1 ) ; }
public boolean set resource ( int index , disposable resource ) { for ( ; ; ) { disposable o = get ( index ) ; if ( o == disposable helper . dispose ) { resource . dispose ( ) ; return false ; } if ( compare and set ( index , o , resource ) ) { if ( o ! = null ) { o . dispose ( ) ; } return true ; } } }
public t block get ( ) { if ( get count ( ) ! = 0 ) { try { block helper . verify non blocking ( ) ; await ( ) ; } catch ( interrupted exception ex ) { dispose ( ) ; throw exception helper . wrap or throw ( ex ) ; } } throwable ex = error ; if ( ex ! = null ) { throw exception helper . wrap or throw ( ex ) ; } return value ; }
protect final void complete ( r n ) { long p = produce ; if ( p ! = 0 ) { backpressure helper . produce ( this , p ) ; } for ( ; ; ) { long r = get ( ) ; if ( ( r & complete_mask ) ! = 0 ) { on drop ( n ) ; return ; } if ( ( r & request_mask ) ! = 0 ) { lazy set ( complete_mask + 1 ) ; actual . on next ( n ) ; actual . on complete ( ) ; return ; } value = n ; if ( compare and set ( 0 , complete_mask ) ) { return ; } value = null ; } }
public static void error ( throwable e , subscriber < ? > s ) { s . on subscribe ( instance ) ; s . on error ( e ) ; }
public void add ( t value ) { final int c = capacity ; int o = offset ; if ( o == c ) { object [ ] next = new object [ c + 1 ] ; tail [ c ] = next ; tail = next ; o = 0 ; } tail [ o ] = value ; offset = o + 1 ; }
public < u > boolean accept ( subscriber < ? super u > subscriber ) { object [ ] a = head ; final int c = capacity ; while ( a ! = null ) { for ( int i = 0 ; i < c ; i++ ) { object o = a [ i ] ; if ( o == null ) { break ; } if ( notification lite . accept full ( o , subscriber ) ) { return true ; } } a = ( object [ ] ) a [ c ] ; } return false ; }
public static long add cancel ( atomic long request , long n ) { for ( ; ; ) { long r = request . get ( ) ; if ( r == long . min_value ) { return long . min_value ; } if ( r == long . max_value ) { return long . max_value ; } long u = add cap ( r , n ) ; if ( request . compare and set ( r , u ) ) { return r ; } } }
public static boolean set once ( atomic reference < disposable > upstream , disposable next , class < ? > observer ) { object helper . require non null ( next , `` next be null `` ) ; if ( ! upstream . compare and set ( null , next ) ) { next . dispose ( ) ; if ( upstream . get ( ) ! = disposable helper . dispose ) { report double subscription ( observer ) ; } return false ; } return true ; }
public static object error ( throwable e ) { return new error notification ( e ) ; }
public final list < t > value ( ) { return value ; }
public final u assert error ( predicate < throwable > error predicate ) { int s = error . size ( ) ; if ( s == 0 ) { throw fail ( `` no error `` ) ; } boolean found = false ; for ( throwable e : error ) { try { if ( error predicate . test ( e ) ) { found = true ; break ; } } catch ( exception ex ) { throw exception helper . wrap or throw ( ex ) ; } } if ( find ) { if ( s ! = 1 ) { throw fail ( `` error present but other error a well `` ) ; } } else { throw fail ( `` error not present `` ) ; } return ( u ) this ; }
public final u assert never ( t value ) { int s = value . size ( ) ; for ( int i = 0 ; i < s ; i++ ) { t v = this . value . get ( i ) ; if ( object helper . equal ( v , value ) ) { throw fail ( `` value at position `` + i + `` be equal to `` + value and class ( value ) + `` ; expect them to be different `` ) ; } } return ( u ) this ; }
public final u assert value ( predicate < t > value predicate ) { assert value at ( 0 , value predicate ) ; if ( value . size ( ) > 1 ) { throw fail ( `` value present but other value a well `` ) ; } return ( u ) this ; }
public final u assert value count ( int count ) { int s = value . size ( ) ; if ( s ! = count ) { throw fail ( `` value count differ ; expect : `` + count + `` , actual : `` + s ) ; } return ( u ) this ; }
public final u assert not terminate ( ) { if ( do . get count ( ) == 0 ) { throw fail ( `` subscriber terminate ! `` ) ; } return ( u ) this ; }
public final u assert error message ( string message ) { int s = error . size ( ) ; if ( s == 0 ) { throw fail ( `` no error `` ) ; } else if ( s == 1 ) { throwable e = error . get ( 0 ) ; string error message = e . get message ( ) ; if ( ! object helper . equal ( message , error message ) ) { throw fail ( `` error message differs ; expect : `` + message + `` , actual : `` + error message ) ; } } else { throw fail ( `` multiple error `` ) ; } return ( u ) this ; }
public final list < list < object > > get event ( ) { list < list < object > > result = new array list < list < object > > ( ) ; result . add ( ( list ) value ( ) ) ; result . add ( ( list ) error ( ) ) ; list < object > complete list = new array list < object > ( ) ; for ( long i = 0 ; i < completion ; i++ ) { complete list . add ( notification . create on complete ( ) ) ; } result . add ( complete list ) ; return result ; }
public final u assert result ( t . . . value ) { return assert subscribe ( ) . assert value ( value ) . assert no error ( ) . assert complete ( ) ; }
public final u with tag ( char sequence tag ) { this . tag = tag ; return ( u ) this ; }
public final u await count ( int at least , runnable wait strategy , long timeout millis ) { long start = system . current time millis ( ) ; for ( ; ; ) { if ( timeout millis > 0l & & system . current time millis ( ) - start > = timeout millis ) { timeout = true ; break ; } if ( do . get count ( ) == 0l ) { break ; } if ( value . size ( ) > = at least ) { break ; } wait strategy . run ( ) ; } return ( u ) this ; }
public static void set fail on non block scheduler ( boolean enable ) { if ( lockdown ) { throw new illegal state exception ( `` plugins ca n't be change anymore `` ) ; } fail non block scheduler = enable ; }
public void start ( ) { }
public void shutdown ( ) { }
public long time ( ) { return time ; }
public long time ( @ non null time unit unit ) { return unit . convert ( time , this . unit ) ; }
public final disposable subscribe ( ) { return subscribe ( function . empty consumer ( ) , function . on_error_missing ) ; }
public throwable get throwable ( ) { if ( observer . get ( ) == terminate ) { return error ; } return null ; }
public t get value ( ) { if ( observer . get ( ) == terminate ) { return value ; } return null ; }
protect final void request ( long n ) { subscription s = this . s ; if ( s ! = null ) { s . request ( n ) ; } }
public static long require non null ( long value , string message ) { throw new internal error ( `` null check on a primitive : `` + message ) ; }
public final u assert value set ( collection < ? extend t > expect ) { if ( expect . be empty ( ) ) { assert no value ( ) ; return ( u ) this ; } for ( t v : this . value ) { if ( ! expect . contains ( v ) ) { throw fail ( `` value not in the expected collection : `` + value and class ( v ) ) ; } } return ( u ) this ; }
public final parallel flowable < t > filter ( @ non null predicate < ? super t > predicate , @ non null parallel failure handle error handler ) { object helper . require non null ( predicate , `` predicate `` ) ; object helper . require non null ( error handler , `` error handler be null `` ) ; return rx java plugins . on assembly ( new parallel filter try < t > ( this , predicate , error handler ) ) ; }
public void start ( ) { if ( subscription helper . set once ( upstream , empty subscription . instance ) ) { queue = new spsc array queue < t > ( buffer size ) ; } }
public void cleanup buffer ( ) { buffer . trim head ( ) ; }
public static double stream double stream ( iterable once < double > coll ) { return stream converter . a java seq double stream ( coll ) ; }
public static @ not null breadcrumb http ( final @ not null string url , final @ not null string method ) { final breadcrumb breadcrumb = new breadcrumb ( ) ; breadcrumb . set type ( `` http `` ) ; breadcrumb . set category ( `` http `` ) ; breadcrumb . set data ( `` url `` , url ) ; breadcrumb . set data ( `` method `` , method . to upper case ( locale . root ) ) ; return breadcrumb ; }
public @ not null date get timestamp ( ) { return ( date ) timestamp . clone ( ) ; }
public @ nullable sentry level get level ( ) { return level ; }
public @ nullable string get path ( ) { return path ; }
public boolean be snapshot ( ) { return snapshot ; }
public void set thread id ( final @ nullable long thread id ) { this . thread id = thread id ; }
public void set context ( final @ not null string key , final @ not null object value ) { this . context . put ( key , value ) ; }
public static boolean be enable ( ) { return get current hub ( ) . be enable ( ) ; }
public static void add breadcrumb ( final @ not null breadcrumb breadcrumb , final @ nullable object hint ) { get current hub ( ) . add breadcrumb ( breadcrumb , hint ) ; }
public static @ not null i transaction start transaction ( final @ not null string name , final @ not null string operation ) { return get current hub ( ) . start transaction ( name , operation ) ; }
public @ nullable string get environment ( ) { return environment ; }
public void add in app include ( @ not null string include ) { in app include . add ( include ) ; }
public @ not null i envelope cache get envelope disk cache ( ) { return envelope disk cache ; }
public @ nullable string get proguard uuid ( ) { return proguard uuid ; }
public void end ( ) { end ( date utils . get current date time ( ) ) ; }
public sentry id get event id ( ) { return event id ; }
public @ nullable string get name ( ) { return name ; }
public void set email ( @ nullable string email ) { this . email = email ; }
public @ nullable string get comment ( ) { return comment ; }
public int get object alignment ( ) { return parent . get object alignment ( ) ; }
public void put ( string key , string val ) { if ( key == null ) { throw new illegal argument exception ( `` key can not be null `` ) ; } hash map map = ( hash map ) inheritable thread local . get ( ) ; if ( map == null ) { map = new hash map ( ) ; inheritable thread local . set ( map ) ; } map . put ( key , val ) ; }
final public boolean be trace enable ( ) { return false ; }
public static marker get detach marker ( string name ) { return marker factory . get detached marker ( name ) ; }
public static void put ( string key , string val ) throw illegal argument exception { if ( key == null ) { throw new illegal argument exception ( `` key parameter can not be null `` ) ; } if ( mdc adapter == null ) { throw new illegal state exception ( `` m d c adapter can not be null . see also `` + null_mdca_url ) ; } mdc adapter . put ( key , val ) ; }
public static m d c adapter get m d c adapter ( ) { return mdc adapter ; }
public void info ( string format , object arg ) { format and log ( log_level_info , format , arg , null ) ; }
public void warn ( string format , object arg ) { format and log ( log_level_warn , format , arg , null ) ; }
public void error ( string format , object arg1 , object arg2 ) { format and log ( log_level_error , format , arg1 , arg2 ) ; }
public static io . vertx . axle . core . buffer . buffer buffer ( int initial size hint ) { io . vertx . axle . core . buffer . buffer ret = io . vertx . axle . core . buffer . buffer . new instance ( io . vertx . core . buffer . buffer . buffer ( initial size hint ) ) ; return ret ; }
public string to string ( ) { string ret = delegate . to string ( ) ; return ret ; }
public byte get byte ( int po ) { byte ret = delegate . get byte ( po ) ; return ret ; }
public long get unsigned int ( int po ) { long ret = delegate . get unsigned int ( po ) ; return ret ; }
public io . vertx . axle . core . buffer . buffer set long l e ( int po , long l ) { delegate . set long l e ( po , l ) ; return this ; }
public io . vertx . axle . core . buffer . buffer set float ( int po , float f ) { delegate . set float ( po , f ) ; return this ; }
public byte buf get byte buf ( ) { byte buf ret = delegate . get byte buf ( ) ; return ret ; }
public io . vertx . axle . core . cli . cli set priority ( int priority ) { delegate . set priority ( priority ) ; return this ; }
public list < string > get raw value for argument ( argument argument ) { list < string > ret = delegate . get raw value for argument ( argument ) ; return ret ; }
public boolean accept more value ( option option ) { boolean ret = delegate . accept more value ( option ) ; return ret ; }
public json object config ( ) { json object ret = delegate . config ( ) ; return ret ; }
public boolean be worker context ( ) { boolean ret = delegate . be worker context ( ) ; return ret ; }
public < t > t get ( string key ) { t ret = ( t ) delegate . get ( key ) ; return ret ; }
public io . vertx . axle . core . stream . write stream < io . vertx . axle . core . buffer . buffer > sender ( int port , string host ) { io . vertx . axle . core . stream . write stream < io . vertx . axle . core . buffer . buffer > ret = io . vertx . axle . core . stream . write stream . new instance ( delegate . sender ( port , host ) , type_arg_1 ) ; return ret ; }
public string protocol ( ) { string ret = delegate . protocol ( ) ; return ret ; }
public string service ( ) { string ret = delegate . service ( ) ; return ret ; }
public < t > io . vertx . axle . core . eventbus . message producer < t > sender ( string address ) { io . vertx . axle . core . eventbus . message producer < t > ret = io . vertx . axle . core . eventbus . message producer . new instance ( delegate . sender ( address ) , io . vertx . lang . axle . type arg . unknown ( ) ) ; return ret ; }
public completion stage < void > end ( t data ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __end ( data , handler ) ; } ) ; }
public long last access time ( ) { long ret = delegate . last access time ( ) ; return ret ; }
public boolean be other ( ) { boolean ret = delegate . be other ( ) ; return ret ; }
public long size ( ) { long ret = delegate . size ( ) ; return ret ; }
public completion stage < void > chmod recursive ( string path , string perm , string dir perm ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __chmod recursive ( path , perm , dir perm , handler ) ; } ) ; }
public completion stage < void > link ( string link , string exist ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __link ( link , exist , handler ) ; } ) ; }
public completion stage < void > unlink ( string link ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __unlink ( link , handler ) ; } ) ; }
public completion stage < string > read symlink ( string link ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __read symlink ( link , handler ) ; } ) ; }
public static < t > io . vertx . axle . core . future < t > succeed future ( t result ) { io . vertx . axle . core . future < t > ret = io . vertx . axle . core . future . new instance ( io . vertx . core . future . succeed future ( result ) , io . vertx . lang . axle . type arg . unknown ( ) ) ; return ret ; }
public < v > io . vertx . axle . core . future < v > map ( v value ) { io . vertx . axle . core . future < v > ret = io . vertx . axle . core . future . new instance ( delegate . map ( value ) , io . vertx . lang . axle . type arg . unknown ( ) ) ; return ret ; }
public io . vertx . axle . core . http . cookie set path ( string path ) { delegate . set path ( path ) ; return this ; }
public io . vertx . axle . core . http . cookie set secure ( boolean secure ) { delegate . set secure ( secure ) ; return this ; }
public io . vertx . axle . core . http . http client request request ( http method method , request option option ) { io . vertx . axle . core . http . http client request ret = io . vertx . axle . core . http . http client request . new instance ( delegate . request ( method , option ) ) ; return ret ; }
public io . vertx . axle . core . http . http client request get ( string request u r i ) { io . vertx . axle . core . http . http client request ret = io . vertx . axle . core . http . http client request . new instance ( delegate . get ( request u r i ) ) ; return ret ; }
public io . vertx . axle . core . http . http client request get ab ( string absolute u r i ) { io . vertx . axle . core . http . http client request ret = io . vertx . axle . core . http . http client request . new instance ( delegate . get abs ( absolute u r i ) ) ; return ret ; }
public io . vertx . axle . core . http . http client request post ab ( string absolute u r i ) { io . vertx . axle . core . http . http client request ret = io . vertx . axle . core . http . http client request . new instance ( delegate . post ab ( absolute u r i ) ) ; return ret ; }
public completion stage < io . vertx . axle . core . http . web socket > web socket ( string request u r i ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __web socket ( request u r i , handler ) ; } ) ; }
public io . vertx . axle . core . stream . read stream < io . vertx . axle . core . http . web socket > websocket stream ( int port , string host , string request u r i , io . vertx . axle . core . multi map header , websocket version version ) { io . vertx . axle . core . stream . read stream < io . vertx . axle . core . http . web socket > ret = io . vertx . axle . core . stream . read stream . new instance ( delegate . websocket stream ( port , host , request u r i , header . get delegate ( ) , version ) , type_arg_7 ) ; return ret ; }
public io . vertx . axle . core . stream . read stream < io . vertx . axle . core . http . web socket > websocket stream ( string request u r i , io . vertx . axle . core . multi map header , websocket version version ) { io . vertx . axle . core . stream . read stream < io . vertx . axle . core . http . web socket > ret = io . vertx . axle . core . stream . read stream . new instance ( delegate . websocket stream ( request u r i , header . get delegate ( ) , version ) , type_arg_15 ) ; return ret ; }
public io . vertx . axle . core . http . http connection go away ( long error code , int last stream id , io . vertx . axle . core . buffer . buffer debug data ) { delegate . go away ( error code , last stream id , debug data . get delegate ( ) ) ; return this ; }
public io . vertx . axle . core . http . http server request set expect multipart ( boolean expect ) { delegate . set expect multipart ( expect ) ; return this ; }
public string binary handler i d ( ) { string ret = delegate . binary handler i d ( ) ; return ret ; }
public boolean be local pointer ( ) { boolean ret = delegate . be local pointer ( ) ; return ret ; }
public io . vertx . axle . core . json . pointer . json pointer append ( list < string > token ) { delegate . append ( token ) ; return this ; }
public io . vertx . axle . core . json . pointer . json pointer copy ( ) { io . vertx . axle . core . json . pointer . json pointer ret = io . vertx . axle . core . json . pointer . json pointer . new instance ( delegate . copy ( ) ) ; return ret ; }
public boolean contains ( string name ) { boolean ret = delegate . contains ( name ) ; return ret ; }
public string write handler i d ( ) { string ret = delegate . write handler i d ( ) ; return ret ; }
public void delete ( ) { delegate . delete ( ) ; }
public io . vertx . axle . core . parsetools . json parser object event mode ( ) { delegate . object event mode ( ) ; return this ; }
public completion stage < void > clear ( ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __clear ( handler ) ; } ) ; }
public completion stage < integer > size ( ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __size ( handler ) ; } ) ; }
public completion stage < long > increment and get ( ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __increment and get ( handler ) ; } ) ; }
public completion stage < long > add and get ( long value ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __add and get ( value , handler ) ; } ) ; }
public completion stage < boolean > compare and set ( long expect , long value ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __compare and set ( expect , value , handler ) ; } ) ; }
public io . vertx . axle . core . stream . pump start ( ) { delegate . start ( ) ; return this ; }
public io . vertx . axle . core . stream . pump stop ( ) { delegate . stop ( ) ; return this ; }
public io . vertx . axle . core . context get or create context ( ) { io . vertx . axle . core . context ret = io . vertx . axle . core . context . new instance ( delegate . get or create context ( ) ) ; return ret ; }
public io . vertx . axle . core . http . http client create http client ( http client option option ) { io . vertx . axle . core . http . http client ret = io . vertx . axle . core . http . http client . new instance ( delegate . create http client ( option ) ) ; return ret ; }
public io . vertx . axle . core . file . file system file system ( ) { if ( cached_0 ! = null ) { return cached_0 ; } io . vertx . axle . core . file . file system ret = io . vertx . axle . core . file . file system . new instance ( delegate . file system ( ) ) ; cached_0 = ret ; return ret ; }
public io . vertx . axle . core . timeout stream timer stream ( long delay ) { io . vertx . axle . core . timeout stream ret = io . vertx . axle . core . timeout stream . new instance ( delegate . timer stream ( delay ) ) ; return ret ; }
public set < verticle factory > verticle factory ( ) { set < verticle factory > ret = delegate . verticle factory ( ) ; return ret ; }
public static illegal state exception impossible switch case ( @ not null object obj ) { assert . check not null param check ( `` obj `` , obj ) ; return message . log . impossible switch case ( obj ) ; }
public string get raw value ( string name ) { final config value config value = get config value ( name ) ; return config value ! = null & & config value . get value ( ) ! = null ? config value . get value ( ) : null ; }
public uni < io . vertx . mutiny . core . http . web socket > web socket ( string request u r i ) { return io . smallrye . mutiny . vertx . async result uni . to uni ( handler - > { __web socket ( request u r i , handler ) ; } ) ; }
public void set max simple key length ( int max simple key length ) { if ( max simple key length > 1024 ) { throw new y a m l exception ( `` the simple key must not span more than 1024 stream character . see https : //yaml . org/spec/1 . 1/ # id934537 `` ) ; } this . max simple key length = max simple key length ; }
public void set non printable style ( non printable style style ) { this . non printable style = style ; }
public version get version ( ) { return version ; }
public void set allow duplicate key ( boolean allow duplicate key ) { this . allow duplicate key = allow duplicate key ; }
public tag get tag ( ) { return this . tag ; }
public boolean be resolve ( ) { return resolve ; }
public event get event ( ) { peek event ( ) ; event value = current event ; current event = null ; return value ; }
public int peek ( int index ) { return ( ensure enough data ( index ) ) ? data window [ pointer + index ] : '\0 ' ; }
public string prefix ( int length ) { if ( length == 0 ) { return `` `` ; } else if ( ensure enough data ( length ) ) { return new string ( this . data window , pointer , length ) ; } else { return new string ( this . data window , pointer , math . min ( length , data length - pointer ) ) ; } }
public token peek token ( ) { while ( need more token ( ) ) { fetch more token ( ) ; } return this . token . get ( 0 ) ; }
public class < ? extend object > get type ( ) { return type ; }
public void add property parameter ( string p name , class < ? > . . . class ) { if ( ! property . contains key ( p name ) ) { substitute property ( p name , null , null , null , class ) ; } else { property substitute pr = property . get ( p name ) ; pr . set actual type argument ( class ) ; } }
public string dump all ( iterator < ? extend object > data ) { string writer buffer = new string writer ( ) ; dump all ( data , buffer , null ) ; return buffer . to string ( ) ; }
public iterable < object > load all ( reader yaml ) { composer composer = new composer ( new parser impl ( new stream reader ( yaml ) ) , resolver , load config ) ; constructor . set composer ( composer ) ; iterator < object > result = new iterator < object > ( ) { @ override public boolean have next ( ) { return constructor . check data ( ) ; } @ override public object next ( ) { return constructor . get data ( ) ; } @ override public void remove ( ) { throw new unsupported operation exception ( ) ; } } ; return new yaml iterable ( result ) ; }
public void set max alias for collection ( int max alias for collection ) { this . max alias for collection = max alias for collection ; }
public void serialize ( node node , writer output ) { serializer serializer = new serializer ( new emitter ( output , dumper option ) , resolver , dumper option , null ) ; try { serializer . open ( ) ; serializer . serialize ( node ) ; serializer . close ( ) ; } catch ( i o exception e ) { throw new y a m l exception ( e ) ; } }
public static int [ ] unshuffle int array ( byte [ ] input ) throw i o exception { int [ ] output = new int [ input . length / 4 ] ; int num process = impl . unshuffle ( input , 0 , 4 , input . length , output , 0 ) ; assert ( num process == input . length ) ; return output ; }
public static float [ ] unshuffle float array ( byte [ ] input ) throw i o exception { float [ ] output = new float [ input . length / 4 ] ; int num process = impl . unshuffle ( input , 0 , 4 , input . length , output , 0 ) ; assert ( num process == input . length ) ; return output ; }
public static void set default pool ( buffer pool pool ) { if ( pool == null ) { throw new illegal argument exception ( `` pool be null `` ) ; } default pool = pool ; }
public t set argument ( list < string > additional argument ) { this . additional argument = additional argument ; return ( t ) this ; }
public void start ( ) { if ( start . get and set ( true ) ) { throw new illegal state exception ( `` orchestrator be already start `` ) ; } install ( ) ; file system fs = config . file system ( ) ; process = new server process impl ( new server command line factory ( f ) , server , startup log watcher ) ; process . start ( ) ; for ( location backup : distribution . get profile backup ( ) ) { server . restore profile ( backup ) ; } if ( distribution . be activate license ( ) ) { activate license ( ) ; } build runner = new build runner ( config ) ; }
public void clear license ( ) { configure license ( null ) ; }
public orchestrator builder add plugin ( location location ) { distribution . add plugin location ( require non null ( location ) ) ; return this ; }
public t source ( string . . . source ) { if ( source == null || source . length == 0 ) { args . add ( `` . `` ) ; return myself ; } args . add all ( array . a list ( source ) ) ; return myself ; }
public void check assignment contract ( ) { for ( ct assignment assign : _root package . get element ( new type filter < > ( ct assignment . class ) ) ) { ct expression assign = assign . get assign ( ) ; if ( ! ( assigned instanceof ct field write || assign instanceof ct variable write || assign instanceof ct array write ) ) { throw new assertion error ( `` assignment contract error : `` + assign . get position ( ) + `` \n `` + assign . to string ( ) + `` \n assign be `` + assign . get class ( ) ) ; } } }
public void check parent consistency ( ct element element ) { final set < ct element > inconsistent parent = new hash set < > ( ) ; new ct scanner ( ) { private deque < ct element > previous = new array deque < > ( ) ; @ override protect void enter ( ct element e ) { if ( e ! = null ) { if ( ! previous . be empty ( ) ) { try { if ( e . get parent ( ) ! = previous . get last ( ) ) { inconsistent parent . add ( e ) ; } } catch ( parent not initialize exception ignore ) { inconsistent parent . add ( e ) ; } } previous . add ( e ) ; } super . enter ( e ) ; } @ override protect void exit ( ct element e ) { if ( e == null ) { return ; } if ( e . equal ( previous . get last ( ) ) ) { previous . remove last ( ) ; } else { throw new runtime exception ( `` inconsistent stack `` ) ; } super . exit ( e ) ; } } . scan ( element ) ; assert equal ( `` all parent have to be consistent `` , 0 , inconsistent parent . size ( ) ) ; }
public ct type reference < ? > get typeof item ( ) { if ( item value type == null ) { get type of field ( ) ; } return item value type ; }
public < t > void get value a ( parameter info parameter info , result holder < t > result , immutable map parameter ) { parameter info . get value a ( factory , result , parameter ) ; }
public void for each match ( object input , ct consumer < match > consumer ) { if ( input == null ) { return ; } if ( input . get class ( ) . be array ( ) ) { input = array . a list ( ( object [ ] ) input ) ; } match scanner scanner = new match scanner ( model value resolver , consumer ) ; if ( input instanceof collection < ? > ) { scanner . scan ( null , ( collection < ct element > ) input ) ; } else if ( input instanceof map ) { scanner . scan ( null , ( map < string , ? > ) input ) ; } else { scanner . scan ( null , ( ct element ) input ) ; } }
public pattern builder configure inline statement ( consumer < inlined statement configurator > consumer ) { inlined statement configurator sb = new inlined statement configurator ( this ) ; consumer . accept ( sb ) ; return this ; }
public pattern parameter configurator by name element ( string simple name ) { parameter info pi = get current parameter ( ) ; query model ( ) . filter child ( ( ct name element name ) - > simple name . equal ( name . get simple name ( ) ) ) . for each ( ( ct name element name ) - > { add substitution request ( pi , name ) ; } ) ; return this ; }
protect final void remove process annotation type ( class < ? extend a > annotation type ) { process annotation type . remove ( annotation type . get name ( ) ) ; }
public final void process ( ct element element ) { }
protect void create parameter use issue ( ct parameter < ? > use parameter , ct parameter reference < ? > parameter usage ) { throw new refactoring exception ( `` the parameter `` + used parameter . get simple name ( ) + `` can not be remove because it be use ( `` + parameter usage . get position ( ) + `` ) `` ) ; }
public ct executable < ? > get method ( ) { return method ; }
public < t > ct class < t > create ( string qualify name ) { if ( have inner type ( qualified name ) > 0 ) { ct class < ? > declare class = create ( get declare type name ( qualified name ) ) ; return create ( declare class , get simple name ( qualified name ) ) ; } return create ( factory . package ( ) . get or create ( get package name ( qualified name ) ) , get simple name ( qualified name ) ) ; }
public < t > ct local variable reference < t > create local variable reference ( ct local variable < t > local variable ) { ct local variable reference < t > ref = factory . core ( ) . create local variable reference ( ) ; ref . set type ( local variable . get type ( ) == null ? null : local variable . get type ( ) . clone ( ) ) ; ref . set simple name ( local variable . get simple name ( ) ) ; ref . set parent ( local variable ) ; return ref ; }
public void remove type ( ct type type ) { cached compilation unit . remove ( type . get position ( ) . get compilation unit ( ) . get file ( ) . get absolute path ( ) ) ; }
public compilation unit remove from cache ( string file path ) { return cache compilation unit . remove ( file path ) ; }
public < t > ct constructor < t > create ( ct class < t > target , set < modifier kind > modifier , list < ct parameter < ? > > parameter , set < ct type reference < ? extend throwable > > thrown type ) { ct constructor < t > constructor = factory . core ( ) . create constructor ( ) ; constructor . set modifier ( modifier ) ; constructor . set parameter ( parameter ) ; constructor . set thrown type ( thrown type ) ; target . add constructor ( constructor ) ; return constructor ; }
public < t > ct constructor < t > create ( ct class < t > target , set < modifier kind > modifier , list < ct parameter < ? > > parameter , set < ct type reference < ? extend throwable > > thrown type , ct block < t > body ) { ct constructor < t > constructor = create ( target , modifier , parameter , thrown type ) ; constructor . set body ( body ) ; return constructor ; }
public ct enum < ? > create ( string qualify name ) { return create ( factory . package ( ) . get or create ( get package name ( qualified name ) ) , get simple name ( qualified name ) ) ; }
public ct package reference create reference ( ct package pack ) { if ( pack == null ) { throw new illegal argument exception ( ) ; } return create reference ( pack . get qualified name ( ) ) ; }
public ct type reference < boolean > boolean primitive type ( ) { return boolean_primitive . clone ( ) ; }
public ct type reference < long > long type ( ) { return long . clone ( ) ; }
public ct type reference < long > long primitive type ( ) { return long_primitive . clone ( ) ; }
public < t > ct type reference < t > create simply qualified reference ( string qualify name ) { ct type reference ref = create reference ( qualified name ) ; ref . get package ( ) . set implicit ( true ) ; return ref ; }
public ct query impl logging ( boolean logging ) { this . log = logging ; return this ; }
protect void reset ( ) { terminate = false ; }
protect void exit ( ct element e ) { ct element ret = element deque . pop ( ) ; if ( ret ! = e ) { throw new runtime exception ( `` inconsistent stack `` ) ; } super . exit ( e ) ; }
public < t > void scan ct abstract invocation ( ct abstract invocation < t > a ) { }
public void scan ct formal type declarer ( ct formal type declarer e ) { }
public super inheritance hierarchy function set listener ( ct scanner listener listener ) { if ( this . listener ! = null ) { throw new spoon exception ( `` can not register listener on instance create with constructor which accept the set < string > . use the no parameter constructor if listener have to be register `` ) ; } this . listener = listener ; return this ; }
public static < e extend ct element > list < e > get element ( ct element root element , filter < e > filter ) { return root element . filter child ( filter ) . list ( ) ; }
public static < r extend ct reference > list < r > get reference ( factory factory , filter < r > filter ) { return get reference ( factory . package ( ) . get root package ( ) , filter ) ; }
public spoon pom get parent pom ( ) { return parent ; }
public t get remove value ( ) { return old value ; }
public static void insert before ( ct statement target , ct statement list statement to be insert ) throw parent not initialize exception { ct element target parent = target . get parent ( ) ; if ( target parent instanceof ct executable ) { throw new spoon exception ( `` can not insert in this context ( use insert end ? ) '' ) ; } if ( target . get parent ( ct constructor . class ) ! = null ) { if ( target instanceof ct invocation & & ( ( ct invocation < ? > ) target ) . get executable ( ) . get simple name ( ) . start with ( ct executable reference . constructor_name ) ) { throw new spoon exception ( `` can not insert a statement before a super or this invocation . `` ) ; } } new insert visitor ( target , statement to be insert , insert type . before ) . scan ( target parent ) ; }
protect int search column number ( int position ) { int [ ] line separator position = get line separator position ( ) ; if ( line separator position == null ) { return -1 ; } int length = line separator position . length ; if ( length == 0 ) { return position ; } if ( line separator position [ 0 ] > position ) { return position ; } int i ; for ( i = 0 ; i < line separator position . length - 1 ; i++ ) { if ( line separator position [ i ] < position & & ( line separator position [ i + 1 ] > position ) ) { return position - line separator position [ i ] ; } } int tab count = 0 ; int tab size = 0 ; if ( get compilation unit ( ) ! = null ) { tab size = get compilation unit ( ) . get factory ( ) . get environment ( ) . get tabulation size ( ) ; string source = get compilation unit ( ) . get original source code ( ) ; for ( int j = line separator position [ i ] ; j < position ; j++ ) { if ( source . char at ( j ) == '\t ' ) { tab count++ ; } } } return ( position - line separator position [ i ] ) - tab count + ( tab count * tab size ) ; }
public static object convert element to runtime object ( ct element value ) { if ( value instanceof ct expression ) { ct expression evaled = ( ( ct expression ) value ) . partially evaluate ( ) ; return get corresponding runtime object ( evaled ) ; } throw new spoon exception ( `` not possible to convert to runtime object `` + value ) ; }
public boolean be static ( ) { return stat ; }
public static collection < ct executable reference < ? > > get all executables ( class < ? > clazz , factory factory ) { collection < ct executable reference < ? > > l = new array list < > ( ) ; for ( method m : clazz . get declare method ( ) ) { l . add ( factory . method ( ) . create reference ( m ) ) ; } for ( constructor < ? > c : clazz . get declared constructor ( ) ) { l . add ( factory . constructor ( ) . create reference ( c ) ) ; } return l ; }
public static rt parameter [ ] parameter of ( rt method method ) { rt parameter [ ] parameter = new rt parameter [ method . get parameter type ( ) . length ] ; for ( int index = 0 ; index < method . get parameter type ( ) . length ; index++ ) { parameter [ index ] = new rt parameter ( null , method . get parameter type ( ) [ index ] , method . get generic parameter type ( ) [ index ] , method , null , index ) ; } return parameter ; }
public sub inheritance hierarchy resolver add super type ( ct type information super type ) { target super type . add ( super type . get qualified name ( ) ) ; if ( have super interface == false ) { have super interface = super type . be interface ( ) ; } return this ; }
protect object invoke advice method ( join point match jp match , object return value , throwable ex ) throw throwable { return invoke advice method with give args ( arg binding ( get join point ( ) , jp match , return value , ex ) ) ; }
public pointcut get pointcut ( ) { return this . pointcut ; }
public void set aspect bean name ( string aspect bean name ) { this . aspect bean name = aspect bean name ; }
public void set target ( object target ) { set target source ( new singleton target source ( target ) ) ; }
public void set interface ( class < ? > . . . interface ) { assert . not null ( interface , `` interface must not be null `` ) ; this . interface . clear ( ) ; for ( class < ? > ifc : interface ) { add interface ( ifc ) ; } }
public static boolean equal in proxy ( advised support a , advised support b ) { return ( a == b || ( equal proxied interface ( a , b ) & & equal advisor ( a , b ) & & a . get target source ( ) . equal ( b . get target source ( ) ) ) ) ; }
public static boolean equal proxied interface ( advised support a , advised support b ) { return array . equal ( a . get proxied interface ( ) , b . get proxied interface ( ) ) ; }
public string get advisor bean name prefix ( ) { return this . advisor bean name prefix ; }
public int hash code ( ) { return jdk dynamic aop proxy . class . hash code ( ) * 13 + this . advise . get target source ( ) . hash code ( ) ; }
public boolean be expose proxy ( ) { return this . expose proxy ; }
public boolean be frozen ( ) { return this . frozen ; }
public void set aop proxy factory ( aop proxy factory aop proxy factory ) { assert . not null ( aop proxy factory , `` aop proxy factory must not be null `` ) ; this . aop proxy factory = aop proxy factory ; }
public object get object ( ) throw bean exception { initialize advisor chain ( ) ; if ( be singleton ( ) ) { return get singleton instance ( ) ; } else { if ( this . target name == null ) { logger . warn ( `` use non-singleton proxy with singleton target be often undesirable . `` + `` enable prototype proxy by set the 'target name ' property . `` ) ; } return new prototype instance ( ) ; } }
public void set exit message ( string exit message ) { assert . have text ( exit message , `` 'exit message ' must not be empty `` ) ; check for invalid placeholder ( exit message ) ; assert . do not contain ( exit message , placeholder_exception , `` exit message can not contain placeholder [ `` + placeholder_exception + `` ] `` ) ; this . exit message = exit message ; }
public void set exception message ( string exception message ) { assert . have text ( exception message , `` 'exception message ' must not be empty `` ) ; check for invalid placeholder ( exception message ) ; assert . do not contain ( exception message , placeholder_return_value , `` exception message can not contain placeholder [ `` + placeholder_return_value + `` ] `` ) ; assert . do not contain ( exception message , placeholder_invocation_time , `` exception message can not contain placeholder [ `` + placeholder_invocation_time + `` ] `` ) ; this . exception message = exception message ; }
public static string get bean name ( ) throw illegal state exception { return get bean name ( expose invocation interceptor . current invocation ( ) ) ; }
public void set exclude pattern ( string . . . exclude pattern ) { assert . not empty ( excluded pattern , `` 'excluded pattern ' must not be empty `` ) ; this . exclude pattern = new string [ exclude pattern . length ] ; for ( int i = 0 ; i < exclude pattern . length ; i++ ) { this . exclude pattern [ i ] = string utils . trim whitespace ( exclude pattern [ i ] ) ; } init exclude pattern representation ( this . exclude pattern ) ; }
public static boolean be hash code method ( method method ) { return reflection utils . be hash code method ( method ) ; }
public static boolean can apply ( advisor advisor , class < ? > target class ) { return can apply ( advisor , target class , false ) ; }
public static class filter union ( class filter [ ] class filter ) { assert . not empty ( class filter , `` class filter array must not be empty `` ) ; return new union class filter ( class filter ) ; }
public composable pointcut intersection ( pointcut other ) { this . class filter = class filter . intersection ( this . class filter , other . get class filter ( ) ) ; this . method matcher = method matcher . intersection ( this . method matcher , other . get method matcher ( ) ) ; return this ; }
public void set map name ( string . . . map names ) { this . map name = new link list < string > ( ) ; if ( mapped names ! = null ) { this . map name . add all ( array . a list ( mapped name ) ) ; } }
public name match method pointcut add method name ( string name ) { this . map name . add ( name ) ; return this ; }
protect void copy from ( abstract bean factory base target source other ) { this . target bean name = other . target bean name ; this . target class = other . target class ; this . bean factory = other . bean factory ; }
public void set max idle ( int max idle ) { this . max idle = max idle ; }
public long get max wait ( ) { return this . max wait ; }
public void set block when exhaust ( boolean block when exhaust ) { this . block when exhaust = block when exhaust ; }
public string get aspect name ( ) { return this . advice . get aspect name ( ) ; }
protect string get final path ( abstract nestable property accessor pa , string nested path ) { if ( pa == this ) { return nest path ; } return nested path . substring ( property accessor utils . get last nested property separator index ( nest path ) + 1 ) ; }
public void add metadata attribute ( bean metadata attribute attribute ) { super . set attribute ( attribute . get name ( ) , attribute ) ; }
public static < t > t instantiate class ( class < ? > clazz , class < t > assignable to ) throw bean instantiation exception { assert . be assignable ( assignable to , clazz ) ; return ( t ) instantiate class ( clazz ) ; }
public boolean be autowire ( ) { return ( this == by_name || this == by_type ) ; }
public void set require parameter value ( boolean require parameter value ) { this . require parameter value = require parameter value ; }
public void set custom qualifier type ( set < ? > custom qualifier type ) { this . custom qualifier type = custom qualifier type ; }
protect boolean be qualifier ( class < ? extend annotation > annotation type ) { for ( class < ? extend annotation > qualifier type : this . qualifier type ) { if ( annotation type . equal ( qualifier type ) || annotation type . be annotation present ( qualifier type ) ) { return true ; } } return false ; }
public throwable [ ] get relate cause ( ) { if ( this . related cause == null ) { return null ; } return this . related cause . to array ( new throwable [ this . related cause . size ( ) ] ) ; }
public string get resource description ( ) { return this . resource description ; }
protect type converter get bean type converter ( ) { bean factory bean factory = get bean factory ( ) ; if ( bean factory instanceof configurable bean factory ) { return ( ( configurable bean factory ) bean factory ) . get type converter ( ) ; } else { return new simple type converter ( ) ; } }
public void destroy ( ) throw exception { if ( be singleton ( ) ) { destroy instance ( this . singleton instance ) ; } }
protect void destroy instance ( t instance ) throw exception { }
public void add indexed argument value ( int index , object value ) { add indexed argument value ( index , new value holder ( value ) ) ; }
public boolean have index argument value ( int index ) { return this . indexed argument value . contains key ( index ) ; }
public field get field ( ) { return this . field ; }
public void increase nest level ( ) { this . nesting level++ ; if ( this . method parameter ! = null ) { this . method parameter . increase nest level ( ) ; } }
public boolean fallback match allow ( ) { return false ; }
public dependency descriptor for fallback match ( ) { return new dependency descriptor ( this ) { @ override public boolean fallback match allow ( ) { return true ; } } ; }
protect void write to log ( string message ) { logger . warn ( message ) ; }
public void set target field ( string target field ) { this . target field = string utils . trim all whitespace ( target field ) ; }
public void set bean name ( string bean name ) { this . bean name = bean name ; }
protect string resolve placeholder ( string placeholder , property prop ) { string path = null ; string key = placeholder ; int end of path = placeholder . last index of ( '/ ' ) ; if ( end of path ! = -1 ) { path = placeholder . substring ( 0 , end of path ) ; key = placeholder . substring ( end of path + 1 ) ; } string value = resolve placeholder ( path , key , this . user prefs ) ; if ( value == null ) { value = resolve placeholder ( path , key , this . system prefs ) ; if ( value == null ) { value = prop . get property ( placeholder ) ; } } return value ; }
public void set target bean name ( string target bean name ) { this . target bean name = string utils . trim all whitespace ( target bean name ) ; }
public boolean be singleton ( ) { return false ; }
public void set order ( int order ) { this . order = order ; }
public void set service locator interface ( class < ? > interface type ) { this . service locator interface = interface type ; }
public void set service locator exception class ( class < ? extend exception > service locator exception class ) { if ( service locator exception class ! = null & & ! exception . class . be assignable from ( service locator exception class ) ) { throw new illegal argument exception ( `` service locator exception [ `` + service locator exception class . get name ( ) + `` ] be not a subclass of exception `` ) ; } this . service locator exception constructor = determine service locator exception constructor ( service locator exception class ) ; }
public boolean have target type ( ) { return ( this . target type instanceof class ) ; }
public void set match default ( boolean match default ) { this . match default = match default ; }
public void set binding ( bind binding ) { this . bind = binding ; }
protect groovy bean definition reader invoke bean defining closure ( closure callable ) { callable . set delegate ( this ) ; callable . call ( ) ; finalize deferred property ( ) ; return this ; }
public component definition [ ] get nested component ( ) { return this . nested component . to array ( new component definition [ this . nested component . size ( ) ] ) ; }
public int get dependency check ( ) { return this . dependency check ; }
public void set primary ( boolean primary ) { this . primary = primary ; }
public boolean be primary ( ) { return this . primary ; }
public set < autowire candidate qualifier > get qualifier ( ) { return new link hash set < autowire candidate qualifier > ( this . qualifier . value ( ) ) ; }
public list < bean post processor > get bean post processor ( ) { return this . bean post processor ; }
protect boolean be prototype currently in creation ( string bean name ) { object cur val = this . prototypes currently in creation . get ( ) ; return ( cur val ! = null & & ( cur val . equal ( bean name ) || ( cur val instanceof set & & ( ( set < ? > ) cur val ) . contains ( bean name ) ) ) ) ; }
protect void register custom editor ( property editor registry registry ) { property editor registry support registry support = ( registry instanceof property editor registry support ? ( property editor registry support ) registry : null ) ; if ( registry support ! = null ) { registry support . use config value editor ( ) ; } if ( ! this . property editor registrar . be empty ( ) ) { for ( property editor registrar registrar : this . property editor registrar ) { try { registrar . register custom editor ( registry ) ; } catch ( bean creation exception ex ) { throwable root cause = ex . get most specific cause ( ) ; if ( root cause instanceof bean currently in creation exception ) { bean creation exception bce = ( bean creation exception ) root cause ; if ( be currently in creation ( bce . get bean name ( ) ) ) { if ( logger . be debug enable ( ) ) { logger . debug ( `` property editor registrar [ `` + registrar . get class ( ) . get name ( ) + `` ] failed because it try to obtain currently create bean ' `` + ex . get bean name ( ) + `` ' : `` + ex . get message ( ) ) ; } on suppressed exception ( ex ) ; continue ; } } throw ex ; } } } if ( ! this . custom editor . be empty ( ) ) { for ( map . entry < class < ? > , class < ? extend property editor > > entry : this . custom editor . entry set ( ) ) { class < ? > require type = entry . get key ( ) ; class < ? extend property editor > editor class = entry . get value ( ) ; registry . register custom editor ( require type , bean utils . instantiate class ( editor class ) ) ; } } }
protect void clear merge bean definition ( string bean name ) { this . merge bean definition . remove ( bean name ) ; }
public bean definition builder set scope ( string scope ) { this . bean definition . set scope ( scope ) ; return this ; }
public boolean equal ( object obj ) { return ( obj == this || ( obj instanceof bean definition resource & & ( ( bean definition resource ) obj ) . bean definition . equal ( this . bean definition ) ) ) ; }
protected class < ? > resolve target type ( type string value value ) throw class not find exception { if ( value . have target type ( ) ) { return value . get target type ( ) ; } return value . resolve target type ( this . bean factory . get bean class loader ( ) ) ; }
public void set serialization id ( string serialization id ) { if ( serialization id ! = null ) { serializable factory . put ( serialization id , new weak reference < default listable bean factory > ( this ) ) ; } else if ( this . serialization id ! = null ) { serializable factory . remove ( this . serialization id ) ; } this . serialization id = serialization id ; }
protect integer get priority ( object bean instance ) { comparator < object > comparator = get dependency comparator ( ) ; if ( comparator instanceof order comparator ) { return ( ( order comparator ) comparator ) . get priority ( bean instance ) ; } return null ; }
protect void remove singleton ( string bean name ) { synchronize ( this . singleton object ) { this . singleton object . remove ( bean name ) ; this . singleton factory . remove ( bean name ) ; this . early singleton object . remove ( bean name ) ; this . registered singleton . remove ( bean name ) ; } }
protect boolean have dependent bean ( string bean name ) { return this . dependent bean map . contains key ( bean name ) ; }
public string [ ] get dependent bean ( string bean name ) { set < string > dependent bean = this . dependent bean map . get ( bean name ) ; if ( dependent bean == null ) { return new string [ 0 ] ; } return string utils . to string array ( dependent bean ) ; }
protect object get cache object for factory bean ( string bean name ) { object object = this . factory bean object cache . get ( bean name ) ; return ( object ! = null_object ? object : null ) ; }
protected factory bean < ? > get factory bean ( string bean name , object bean instance ) throw bean exception { if ( ! ( bean instance instanceof factory bean ) ) { throw new bean creation exception ( bean name , `` bean instance of type [ `` + bean instance . get class ( ) + `` ] be not a factory bean `` ) ; } return ( factory bean < ? > ) bean instance ; }
protected access control context get access control context ( ) { return access controller . get context ( ) ; }
public void set element type name ( string element type name ) { this . element type name = element type name ; }
protect boolean be overload ( ) { return this . overload ; }
public boolean be empty ( ) { return this . override . be empty ( ) ; }
public int register bean definition ( map < ? , ? > map , string prefix ) throw bean exception { return register bean definition ( map , prefix , `` map `` + map ) ; }
public void add bean ( string name , object bean ) { this . bean . put ( name , bean ) ; }
protect string extract property name ( string attribute name ) { return convention . attribute name to property name ( attribute name ) ; }
public void parse constructor arg element ( element bean ele , bean definition bd ) { node list nl = bean ele . get child node ( ) ; for ( int i = 0 ; i < nl . get length ( ) ; i++ ) { node node = nl . item ( i ) ; if ( be candidate element ( node ) & & node name equal ( node , constructor_arg_element ) ) { parse constructor arg element ( ( element ) node , bd ) ; } } }
public void parse property element ( element bean ele , bean definition bd ) { node list nl = bean ele . get child node ( ) ; for ( int i = 0 ; i < nl . get length ( ) ; i++ ) { node node = nl . item ( i ) ; if ( be candidate element ( node ) & & node name equal ( node , property_element ) ) { parse property element ( ( element ) node , bd ) ; } } }
public void parse qualifier element ( element bean ele , abstract bean definition bd ) { node list nl = bean ele . get child node ( ) ; for ( int i = 0 ; i < nl . get length ( ) ; i++ ) { node node = nl . item ( i ) ; if ( be candidate element ( node ) & & node name equal ( node , qualifier_element ) ) { parse qualifier element ( ( element ) node , bd ) ; } } }
public void parse lookup override sub element ( element bean ele , method override override ) { node list nl = bean ele . get child node ( ) ; for ( int i = 0 ; i < nl . get length ( ) ; i++ ) { node node = nl . item ( i ) ; if ( be candidate element ( node ) & & node name equal ( node , lookup_method_element ) ) { element ele = ( element ) node ; string method name = ele . get attribute ( name_attribute ) ; string bean ref = ele . get attribute ( bean_element ) ; lookup override override = new lookup override ( method name , bean ref ) ; override . set source ( extract source ( ele ) ) ; override . add override ( override ) ; } } }
public void set merge ( string merge ) { this . merge = merge ; }
public string get dependency check ( ) { return this . dependency check ; }
public string get init method ( ) { return this . init method ; }
public string get destroy method ( ) { return this . destroy method ; }
public int load bean definition ( resource resource ) throw bean definition store exception { return load bean definition ( new encode resource ( resource ) ) ; }
protect document do load document ( input source input source , resource resource ) throw exception { return this . document loader . load document ( input source , get entity resolver ( ) , this . error handler , get validation mode for resource ( resource ) , be namespace aware ( ) ) ; }
public namespace handler resolver get namespace handler resolver ( ) { if ( this . namespace handler resolver == null ) { this . namespace handler resolver = create default namespace handler resolver ( ) ; } return this . namespace handler resolver ; }
public string get property name ( ) { return property name ; }
public mutable property value add property value ( property value other ) { if ( other ! = null ) { property value [ ] pvs = other . get property value ( ) ; for ( property value pv : pvs ) { add property value ( new property value ( pv ) ) ; } } return this ; }
public void set convert ( ) { this . convert = true ; }
public static string [ ] canonical property name ( string [ ] property name ) { if ( property name == null ) { return null ; } string [ ] result = new string [ property name . length ] ; for ( int i = 0 ; i < property name . length ; i++ ) { result [ i ] = canonical property name ( property name [ i ] ) ; } return result ; }
protect void copy custom editor to ( property editor registry target , string nested property ) { string actual property name = ( nested property ! = null ? property accessor utils . get property name ( nested property ) : null ) ; if ( this . custom editor ! = null ) { for ( map . entry < class < ? > , property editor > entry : this . custom editor . entry set ( ) ) { target . register custom editor ( entry . get key ( ) , entry . get value ( ) ) ; } } if ( this . custom editor for path ! = null ) { for ( map . entry < string , custom editor holder > entry : this . custom editor for path . entry set ( ) ) { string editor path = entry . get key ( ) ; custom editor holder editor holder = entry . get value ( ) ; if ( nested property ! = null ) { int po = property accessor utils . get first nested property separator index ( editor path ) ; if ( po ! = -1 ) { string editor nest property = editor path . substring ( 0 , po ) ; string editor nested path = editor path . substring ( pos + 1 ) ; if ( editor nest property . equal ( nested property ) || editor nest property . equal ( actual property name ) ) { target . register custom editor ( editor holder . get registered type ( ) , editor nest path , editor holder . get property editor ( ) ) ; } } } else { target . register custom editor ( editor holder . get registered type ( ) , editor path , editor holder . get property editor ( ) ) ; } } } }
public string get a text ( ) { date value = ( date ) get value ( ) ; return ( value ! = null ? this . date format . format ( value ) : `` `` ) ; }
public void set a text ( string text ) throw illegal argument exception { set value ( text ) ; }
protect boolean always create new map ( ) { return false ; }
public void set value ( object value ) { if ( value instanceof number ) { super . set value ( number utils . convert number to target class ( ( number ) value , this . number class ) ) ; } else { super . set value ( value ) ; } }
public static property match for field ( string property name , class < ? > bean class ) { return for field ( property name , bean class , default_max_distance ) ; }
public sort definition get sort ( ) { return this . sort ; }
public void set page size ( int page size ) { if ( page size ! = this . page size ) { this . page size = page size ; if ( ! this . new page set ) { this . page = 0 ; } } }
public int get max link page ( ) { return this . max link page ; }
public boolean be last page ( ) { return get page ( ) == get page count ( ) -1 ; }
public static boolean be simple value type ( class < ? > type ) { return ( void . class ! = type & & void . class ! = type & & ( class utils . be primitive or wrapper ( type ) || enum . class . be assignable from ( type ) || char sequence . class . be assignable from ( type ) || number . class . be assignable from ( type ) || date . class . be assignable from ( type ) || temporal . class . be assignable from ( type ) || uri . class == type || url . class == type || locale . class == type || class . class == type ) ) ; }
public t get bean instance ( ) { return this . bean instance ; }
public class < ? > get declare type ( ) { return ( this . field ! = null ? this . field . get type ( ) : obtain method parameter ( ) . get parameter type ( ) ) ; }
public void fire component register ( component definition component definition ) { this . event listener . component register ( component definition ) ; }
protect object apply bean post processor before instantiation ( class < ? > bean class , string bean name ) { for ( bean post processor bp : get bean post processor ( ) ) { if ( bp instanceof instantiation aware bean post processor ) { instantiation aware bean post processor ibp = ( instantiation aware bean post processor ) bp ; object result = ibp . post process before instantiation ( bean class , bean name ) ; if ( result ! = null ) { return result ; } } } return null ; }
public string get init method name ( ) { return this . init method name ; }
public void set destroy method name ( @ nullable string destroy method name ) { this . destroy method name = ( string utils . have text ( destroy method name ) ? destroy method name : null ) ; }
public string get destroy method name ( ) { return this . destroy method name ; }
public bean definition get bean definition ( ) { return this . bean definition ; }
public constructor < ? > [ ] get preferred constructor ( ) { return null ; }
public document default definition get default ( ) { return this . default ; }
public boolean be optional ( ) { return this . optional ; }
public static < t > constructor < t > find primary constructor ( class < t > clazz ) { assert . not null ( clazz , `` class must not be null `` ) ; if ( kotlin detector . be kotlin reflect present ( ) & & kotlin detector . be kotlin type ( clazz ) ) { return kotlin delegate . find primary constructor ( clazz ) ; } return null ; }
public boolean be externally manage config member ( member config member ) { synchronize ( this . post processing lock ) { return ( this . externally manage config member ! = null & & this . externally manage config member . contains ( config member ) ) ; } }
public boolean be externally manage init method ( string init method ) { synchronize ( this . post processing lock ) { return ( this . externally manage init method ! = null & & this . externally manage init method . contains ( init method ) ) ; } }
public spring application builder context class ( class < ? extend configurable application context > cl ) { this . application . set application context class ( cl ) ; return this ; }
public spring application builder log startup info ( boolean log startup info ) { this . application . set log startup info ( log startup info ) ; return this ; }
public spring application builder headless ( boolean headless ) { this . application . set headless ( headless ) ; return this ; }
public spring application builder main ( class < ? > main application class ) { this . application . set main application class ( main application class ) ; return this ; }
public spring application builder bean name generator ( bean name generator bean name generator ) { this . application . set bean name generator ( bean name generator ) ; return this ; }
public configuration property name get name ( ) { return this . name ; }
public string get reason ( ) { return this . reason ; }
public static void add application converter ( converter registry registry ) { add delimit string converter ( registry ) ; registry . add converter ( new string to duration converter ( ) ) ; registry . add converter ( new duration to string converter ( ) ) ; registry . add converter ( new number to duration converter ( ) ) ; registry . add converter ( new duration to number converter ( ) ) ; registry . add converter ( new string to period converter ( ) ) ; registry . add converter ( new period to string converter ( ) ) ; registry . add converter ( new number to period converter ( ) ) ; registry . add converter ( new string to data size converter ( ) ) ; registry . add converter ( new number to data size converter ( ) ) ; registry . add converter ( new string to file converter ( ) ) ; registry . add converter ( new input stream source to byte array converter ( ) ) ; registry . add converter factory ( new lenient string to enum converter factory ( ) ) ; registry . add converter factory ( new lenient boolean to enum converter factory ( ) ) ; }
protected class < ? extend t > get cause type ( ) { return ( class < ? extend t > ) resolvable type . for class ( abstract failure analyzer . class , get class ( ) ) . resolve generic ( ) ; }
public string get description ( ) { return this . description ; }
public void set default max wait time on shutdown ( long default max wait time on shutdown ) { this . default max wait time on shutdown = default max wait time on shutdown ; }
protect string get spring initialization config ( ) { return find config ( get spring config location ( ) ) ; }
public static color converter new instance ( configuration config , string [ ] option ) { if ( option . length < 1 ) { logger . error ( `` incorrect number of option on style . expect at least 1 , receive { } `` , option . length ) ; return null ; } if ( option [ 0 ] == null ) { logger . error ( `` no pattern supply on style `` ) ; return null ; } pattern parser parser = pattern layout . create pattern parser ( config ) ; list < pattern formatter > formatters = parser . parse ( option [ 0 ] ) ; ansi element element = ( option . length ! = 1 ) ? element . get ( option [ 1 ] ) : null ; return new color converter ( formatters , element ) ; }
public file get source ( ) { return this . source ; }
public rest template builder default header ( string name , string . . . value ) { assert . not null ( name , `` name must not be null `` ) ; assert . not null ( value , `` value must not be null `` ) ; return new rest template builder ( this . request factory customizer , this . detect request factory , this . root uri , this . message converter , this . interceptor , this . request factory , this . uri template handler , this . error handler , this . basic authentication , append ( this . default header , name , value ) , this . customizers , this . request customizers ) ; }
public set < string > get tld skip pattern ( ) { return this . tld skip pattern ; }
public void set tld skip pattern ( collection < string > pattern ) { assert . not null ( pattern , `` pattern must not be null `` ) ; this . tld skip pattern = new link hash set < > ( pattern ) ; }
public tomcat get tomcat ( ) { return this . tomcat ; }
public void set eager init filter ( boolean eager init filter ) { this . eager init filter = eager init filter ; }
public void set charset ( string charset ) { this . charset = charset ; }
public boolean get enable ( ) { return this . enable ; }
public string remove ( string extension ) { map previous = this . map . remove ( extension ) ; return ( previous ! = null ) ? previous . get mime type ( ) : null ; }
public int get port ( ) { return this . port ; }
public static < e extend exception > void if cause by ( exception ex , class < e > cause by , consumer < e > action ) { throwable candidate = ex ; while ( candidate ! = null ) { if ( cause by . be instance ( candidate ) ) { action . accept ( ( e ) candidate ) ; return ; } candidate = candidate . get cause ( ) ; } }
public string get key store password ( ) { return this . key store password ; }
public void add servlet name ( string . . . servlet names ) { assert . not null ( servlet name , `` servlet name must not be null `` ) ; this . servlet name . add all ( array . a list ( servlet name ) ) ; }
public boolean be match after ( ) { return this . match after ; }
protect final string get or deduce name ( object value ) { return ( this . name ! = null ) ? this . name : convention . get variable name ( value ) ; }
public void set location ( string location ) { this . location = location ; }
public file get store dir ( ) { return this . store dir ; }
public list < string > get accept ( ) { return ( ! this . active profile . be empty ( ) ) ? this . active profile : this . default profile ; }
protect void after refresh ( configurable application context context , application argument args ) { }
protect void register log exception ( throwable exception ) { spring boot exception handler handler = get spring boot exception handler ( ) ; if ( handler ! = null ) { handler . register log exception ( exception ) ; } }
public class < ? > get main application class ( ) { return this . main application class ; }
public void set main application class ( class < ? > main application class ) { this . main application class = main application class ; }
public set < string > get source ( ) { return this . source ; }
public spring application builder environment prefix ( string environment prefix ) { this . application . set environment prefix ( environment prefix ) ; return this ; }
public void set environment prefix ( string environment prefix ) { this . environment prefix = environment prefix ; }
public boolean initialize database ( ) { script location resolver location resolver = new script location resolver ( this . resource loader ) ; boolean initialize = apply schema script ( location resolver ) ; return apply data script ( location resolver ) || initialize ; }
public void set schema location ( list < string > schema location ) { this . schema location = schema location ; }
public void set data location ( list < string > data location ) { this . data location = data location ; }
protect void handle invalid excludes ( list < string > invalid excludes ) { string builder message = new string builder ( ) ; for ( string exclude : invalid excludes ) { message . append ( `` \t- `` ) . append ( exclude ) . append ( string . format ( `` % n `` ) ) ; } throw new illegal state exception ( string . format ( `` the following class could not be exclude because they be not auto-configuration class : % n % s `` , message ) ) ; }
public static condition outcome inverse ( condition outcome outcome ) { return new condition outcome ( ! outcome . be match ( ) , outcome . get condition message ( ) ) ; }
public void set resource loader ( resource loader resource loader ) { this . resource loader = resource loader ; }
public string determine unique name ( ) { if ( this . unique name == null ) { this . unique name = uuid . random u u i d ( ) . to string ( ) ; } return this . unique name ; }
public boolean exists ( resource pattern resolver resolver ) { assert . not null ( resolver , `` resolver must not be null `` ) ; if ( resolver . get resource ( this . path ) . exists ( ) ) { return true ; } try { return any exists ( resolver ) ; } catch ( i o exception ex ) { return false ; } }
public void add ( item metadata item metadata ) { add ( this . item , item metadata . get name ( ) , item metadata ) ; }
public static boolean be active ( ) { return be active ( null ) || be active ( agent reloader . class . get class loader ( ) ) || be active ( class loader . get system class loader ( ) ) ; }
public int size ( ) { int size = 0 ; for ( source directory source directory : this . source directory . value ( ) ) { size += source directory . get file ( ) . size ( ) ; } return size ; }
public string to hex string ( ) { byte [ ] bytes = this . data . array ( ) ; char [ ] hex = new char [ this . data . remain ( ) * 2 ] ; for ( int i = this . data . position ( ) ; i < this . data . remain ( ) ; i++ ) { int b = bytes [ i ] & 0x f f ; hex [ i * 2 ] = hex_chars [ b > > > 4 ] ; hex [ i * 2 + 1 ] = hex_chars [ b & 0x0 f ] ; } return new string ( hex ) ; }
public void write index file ( string location , collection < string > line ) throw i o exception { if ( location ! = null ) { jar archive entry entry = new jar archive entry ( location ) ; write entry ( entry , ( output stream ) - > { buffered writer writer = new buffer writer ( new output stream writer ( output stream , standard charsets . utf_8 ) ) ; for ( string line : line ) { writer . write ( line ) ; writer . write ( `` \n `` ) ; } writer . flush ( ) ; } ) ; } }
public static string find main class ( file root directory ) throw i o exception { return do with main class ( root directory , main class : : get name ) ; }
public static string find single main class ( jar file jar file , string class location , string annotation name ) throw i o exception { single main class callback callback = new single main class callback ( annotation name ) ; main class finder . do with main class ( jar file , class location , callback ) ; return callback . get main class name ( ) ; }
public void repackage ( file destination , libraries library ) throw i o exception { repackage ( destination , library , null ) ; }
public application context assert < c > do not have bean ( class < ? > type ) { return do not have bean ( type , scope . include_ancestors ) ; }
public < t > map assert < string , t > get bean ( class < t > type ) { return get bean ( type , scope . include_ancestors ) ; }
protect final void initialize ( class < ? > resource load class , resolvable type type ) { if ( this . resource load class == null & & this . type == null ) { this . resource load class = resource load class ; this . type = type ; } }
protect final resolvable type get type ( ) { return this . type ; }
public json content assert have json path array value ( char sequence expression , object . . . args ) { new json path value ( expression , args ) . assert have value ( list . class , `` an array `` ) ; return this ; }
public t get object ( ) { return this . object ; }
public test property value and ( string . . . pair ) { return and ( array . stream ( pair ) . map ( pair : : parse ) ) ; }
public void apply to ( configurable environment environment ) { apply to ( environment , type . map ) ; }
public < t > t get for object ( uri url , class < t > response type ) throw rest client exception { return this . rest template . get for object ( apply root uri if necessary ( url ) , response type ) ; }
public < t > response entity < t > get for entity ( uri url , class < t > response type ) throw rest client exception { return this . rest template . get for entity ( apply root uri if necessary ( url ) , response type ) ; }
public object get id ( object entity ) { return this . entity manager factory . get persistence unit util ( ) . get identifier ( entity ) ; }
protect cache create concurrent map cache ( string name ) { return new concurrent map cache ( name , be allow null value ( ) ) ; }
public collection < cache operation > get cache operation ( method method , class < ? > target class ) { object cache key = get cache key ( method , target class ) ; collection < cache operation > cache = this . attribute cache . get ( cache key ) ; if ( cached ! = null ) { return ( cache ! = null_caching_attribute ? cache : null ) ; } else { collection < cache operation > cache ops = compute cache operation ( method , target class ) ; if ( cache ops ! = null ) { if ( logger . be debug enable ( ) ) { logger . debug ( `` add cacheable method ' `` + method . get name ( ) + `` ' with attribute : `` + cache ops ) ; } this . attribute cache . put ( cache key , cache ops ) ; } else { this . attribute cache . put ( cache key , null_caching_attribute ) ; } return cache ops ; } }
public void set cache operation source ( cache operation source cache operation source ) { this . cache operation source = cache operation source ; }
public void set cache manager ( collection < cache manager > cache manager ) { this . cache manager . add all ( cache manager ) ; }
public final string [ ] select import ( annotation metadata import class metadata ) { class < ? > anno type = generic type resolver . resolve type argument ( get class ( ) , advice mode import selector . class ) ; annotation attribute attribute = annotation config utils . attribute for ( import class metadata , anno type ) ; if ( attribute == null ) { throw new illegal argument exception ( string . format ( `` @ % s be not present on import class ' % s ' a expect `` , anno type . get simple name ( ) , import class metadata . get class name ( ) ) ) ; } advice mode advice mode = attribute . get enum ( this . get advice mode attribute name ( ) ) ; string [ ] import = select import ( advice mode ) ; if ( import == null ) { throw new illegal argument exception ( string . format ( `` unknown advice mode : ' % s ' `` , advice mode ) ) ; } return import ; }
public set < configuration class > get import by ( ) { return this . import by ; }
public class < ? > enhance ( class < ? > config class , class loader class loader ) { if ( enhanced configuration . class . be assignable from ( config class ) ) { if ( logger . be debug enable ( ) ) { logger . debug ( string . format ( `` ignore request to enhance % s a it have `` + `` already be enhance . this usually indicate that more than one `` + `` configuration class post processor have be register ( e . g . via `` + `` < context : annotation-config > ) . this be harmless , but you may `` + `` want check your configuration and remove one ccpp if possible `` , config class . get name ( ) ) ) ; } return config class ; } class < ? > enhance class = create class ( new enhancer ( config class , class loader ) ) ; if ( logger . be debug enable ( ) ) { logger . debug ( string . format ( `` successfully enhance % s ; enhance class name be : % s `` , config class . get name ( ) , enhanced class . get name ( ) ) ) ; } return enhanced class ; }
public void set display name ( string display name ) { assert . have length ( display name , `` display name must not be empty `` ) ; this . display name = display name ; }
public autowire capable bean factory get autowire capable bean factory ( ) throw illegal state exception { return get bean factory ( ) ; }
public long get startup date ( ) { return this . startup date ; }
public list < bean factory post processor > get bean factory post processor ( ) { return this . bean factory post processor ; }
protect boolean be use code a default message ( ) { return this . use code a default message ; }
protect void assert bean factory active ( ) { }
protect boolean be context require ( ) { return false ; }
protect final message source accessor get message source accessor ( ) throw illegal state exception { if ( this . message source accessor == null & & be context require ( ) ) { throw new illegal state exception ( `` application object support instance [ `` + this + `` ] do not run in an application context `` ) ; } return this . message source accessor ; }
public void set resource loader ( resource loader resource loader ) { this . resource loader = resource loader ; }
public property source get apply property source ( ) throw illegal state exception { assert . state ( this . applied property source ! = null , `` property source have not get be apply `` ) ; return this . applied property source ; }
public void set cache second ( int cache second ) { this . cache millis = ( cache second * 1000 ) ; }
protect property load property ( resource resource , string filename ) throw i o exception { input stream be = resource . get input stream ( ) ; property prop = new property ( ) ; try { if ( resource . get filename ( ) . end with ( xml_suffix ) ) { if ( logger . be debug enable ( ) ) { logger . debug ( `` load property [ `` + resource . get filename ( ) + `` ] `` ) ; } this . property persister . load from xml ( prop , be ) ; } else { string encode = null ; if ( this . file encoding ! = null ) { encode = this . file encoding . get property ( filename ) ; } if ( encode == null ) { encode = this . default encode ; } if ( encode ! = null ) { if ( logger . be debug enable ( ) ) { logger . debug ( `` load property [ `` + resource . get filename ( ) + `` ] with encode ' `` + encode + `` ' `` ) ; } this . property persister . load ( prop , new input stream reader ( be , encode ) ) ; } else { if ( logger . be debug enable ( ) ) { logger . debug ( `` load property [ `` + resource . get filename ( ) + `` ] `` ) ; } this . property persister . load ( prop , be ) ; } } return prop ; } finally { be . close ( ) ; } }
protect object refresh and retry ( method invocation invocation ) throw throwable { try { refresh home ( ) ; } catch ( name exception ex ) { throw new remote lookup failure exception ( `` fail to locate remote ejb [ `` + get jndi name ( ) + `` ] `` , ex ) ; } return do invoke ( invocation ) ; }
protect void do autowire bean ( object target ) { autowired annotation bean post processor bpp = new autowired annotation bean post processor ( ) ; configure bean post processor ( bpp , target ) ; bpp . set bean factory ( get bean factory ( target ) ) ; bpp . process injection ( target ) ; }
protect bean factory reference get bean factory reference ( object target ) { string key = get bean factory locator key ( target ) ; bean factory reference ref = get bean factory locator ( target ) . use bean factory ( key ) ; this . bean factory reference . put ( target , ref ) ; return ref ; }
public void set time zone ( time zone time zone ) { this . time zone = time zone ; }
public void set lenient ( boolean lenient ) { this . lenient = lenient ; }
public void set formatter ( date formatter date formatter ) { assert . not null ( date formatter , `` date formatter must not be null `` ) ; this . date formatter = date formatter ; }
public void set date formatter ( date time formatter formatter ) { this . formatters . put ( type . date , formatter ) ; }
public static date time context get date time context ( ) { return date time context holder . get ( ) ; }
public void set register default formatters ( boolean register default formatters ) { this . register default formatters = register default formatters ; }
protect boolean be eligible for shadow ( string class name ) { return ! be exclude ( class name ) ; }
public void add transformer ( class file transformer transformer ) { if ( transformer == null ) { throw new illegal argument exception ( `` transformer must not be null `` ) ; } this . transformer . add ( transformer ) ; }
public void set default domain ( string default domain ) { this . metadata name strategy . set default domain ( default domain ) ; }
public void set manage method ( string [ ] method names ) { this . manage method = new hash set < string > ( arrays . a list ( method name ) ) ; }
public void set autodetect ( boolean autodetect ) { this . autodetect mode = ( autodetect ? autodetect_all : autodetect_none ) ; }
public void set allow eager init ( boolean allow eager init ) { this . allow eager init = allow eager init ; }
public void set excluded bean ( string . . . excluded bean ) { this . excluded bean . clear ( ) ; if ( excluded bean ! = null ) { this . excluded bean . add all ( array . a list ( excluded bean ) ) ; } }
public string get description ( ) { return this . description ; }
public int get currency time limit ( ) { return this . currency time limit ; }
public void set default value ( object default value ) { this . default value = default value ; }
public void set category ( string category ) { this . category = category ; }
public void set notification type ( string . . . notification type ) { this . notification type = notification type ; }
public string get description ( ) { return this . description ; }
public boolean be resource ref ( ) { return this . resource ref ; }
public < t > t execute ( jndi callback < t > context callback ) throw name exception { context ctx = get context ( ) ; try { return context callback . do in context ( ctx ) ; } finally { release context ( ctx ) ; } }
public object lookup ( final string name ) throw name exception { if ( logger . be debug enable ( ) ) { logger . debug ( `` look up jndi object with name [ `` + name + `` ] `` ) ; } return execute ( new jndi callback < object > ( ) { @ override public object do in context ( context ctx ) throw name exception { object locate = ctx . lookup ( name ) ; if ( locate == null ) { throw new name not find exception ( `` jndi object with [ `` + name + `` ] not find : jndi implementation return null `` ) ; } return locate ; } } ) ; }
public final class < ? > get actual type ( ) { return this . actual type ; }
public void set cache stub ( boolean cache stub ) { this . cache stub = cache stub ; }
public void set always create ( boolean always create ) { this . always create = always create ; }
protect string get exporter name ( ) { return class utils . get short name ( get class ( ) ) ; }
public void set remote invocation executor ( remote invocation executor remote invocation executor ) { this . remote invocation executor = remote invocation executor ; }
protect void reset thread context class loader ( class loader original ) { if ( original ! = null ) { thread . current thread ( ) . set context class loader ( original ) ; } }
public void set async annotation type ( class < ? extend annotation > async annotation type ) { assert . not null ( async annotation type , `` 'async annotation type ' must not be null `` ) ; set < class < ? extend annotation > > async annotation type = new hash set < class < ? extend annotation > > ( ) ; async annotation type . add ( async annotation type ) ; this . pointcut = build pointcut ( async annotation type ) ; }
public void set async annotation type ( class < ? extend annotation > async annotation type ) { assert . not null ( async annotation type , `` 'async annotation type ' must not be null `` ) ; this . async annotation type = async annotation type ; }
public static < v > listenable future < v > for execution exception ( throwable ex ) { return new async result < v > ( null , ( ex instanceof execution exception ? ( execution exception ) ex : new execution exception ( ex ) ) ) ; }
public time unit get time unit ( ) { return this . time unit ; }
public boolean be fix rate ( ) { return this . fixed rate ; }
public void add fix delay task ( runnable task , long delay ) { add fix delay task ( new interval task ( task , delay , 0 ) ) ; }
protect string get invocation failure message ( ) { return `` invocation of method ' `` + get target method ( ) + `` ' on target class [ `` + get target class ( ) + `` ] fail `` ; }
public string get object name ( ) { return this . object name ; }
public void bind ( property value pvs ) { mutable property value mpvs = ( pvs instanceof mutable property value ) ? ( mutable property value ) pvs : new mutable property value ( pvs ) ; do bind ( mpvs ) ; }
protect object invoke operation ( cache operation invoker invoker ) { return invoker . invoke ( ) ; }
public static void set default time zone ( @ nullable time zone time zone ) { default time zone = time zone ; }
public property source get apply property source ( ) throw illegal state exception { assert . state ( this . applied property source ! = null , `` property source have not yet be apply `` ) ; return this . applied property source ; }
public void set resource ref ( boolean resource ref ) { this . resource ref = resource ref ; }
public static void sort ( list < ? > list ) { if ( list . size ( ) > 1 ) { collection . sort ( list , instance ) ; } }
public static < e > collection < e > create collection ( class < ? > collection type , int capacity ) { return create collection ( collection type , null , capacity ) ; }
public number a number ( string code ) throw constant exception { object obj = a object ( code ) ; if ( ! ( obj instanceof number ) ) { throw new constant exception ( this . class name , code , `` not a number `` ) ; } return ( number ) obj ; }
public type descriptor get target type ( ) { return this . target type ; }
public boolean be assignable to ( type descriptor type descriptor ) { boolean type assignable = type descriptor . get object type ( ) . be assignable from ( get object type ( ) ) ; if ( ! type assignable ) { return false ; } if ( be array ( ) & & type descriptor . be array ( ) ) { return get element type descriptor ( ) . be assignable to ( type descriptor . get element type descriptor ( ) ) ; } else if ( be collection ( ) & & type descriptor . be collection ( ) ) { return be nest assignable ( get element type descriptor ( ) , type descriptor . get element type descriptor ( ) ) ; } else if ( be map ( ) & & type descriptor . be map ( ) ) { return be nest assignable ( get map key type descriptor ( ) , type descriptor . get map key type descriptor ( ) ) & & be nest assignable ( get map value type descriptor ( ) , type descriptor . get map value type descriptor ( ) ) ; } else { return true ; } }
public void exclude package ( string package name ) { assert . not null ( package name , `` package name must not be null `` ) ; synchronize ( this . exclusion monitor ) { this . exclude package . add ( package name ) ; } }
protect set < string > do get default profile ( ) { synchronize ( this . default profile ) { if ( this . default profile . equal ( get reserve default profile ( ) ) ) { string profile = get property ( default_profiles_property_name ) ; if ( string utils . have text ( profile ) ) { set default profile ( comma delimit list to string array ( trim all whitespace ( profile ) ) ) ; } } return this . default profile ; } }
public void set value separator ( string value separator ) { this . value separator = value separator ; }
public void replace ( string name , property source < ? > property source ) { if ( logger . be debug enable ( ) ) { logger . debug ( string . format ( `` replace [ % s ] property source with [ % s ] `` , name , property source . get name ( ) ) ) ; } int index = assert present and get index ( name ) ; this . property source list . set ( index , property source ) ; }
public static class < ? > get collection type ( class < ? extend collection > collection class ) { return resolvable type . for class ( collection class ) . a collection ( ) . resolve generic ( ) ; }
public long last modified ( ) throw i o exception { long last modify = get file for last modified check ( ) . last modified ( ) ; if ( last modify == 0l ) { throw new file not find exception ( get description ( ) + `` can not be resolve in the file system for resolve it last-modified timestamp `` ) ; } return last modify ; }
public url get u r l ( ) throw i o exception { url url = resolve u r l ( ) ; if ( url == null ) { throw new file not find exception ( get description ( ) + `` can not be resolve to url because it do not exist `` ) ; } return url ; }
public boolean exists ( ) { return this . file . exists ( ) ; }
public long content length ( ) throw i o exception { return this . file . length ( ) ; }
public string get filename ( ) { return this . file . get name ( ) ; }
public string get description ( ) { return `` file [ `` + this . file . get absolute path ( ) + `` ] `` ; }
public boolean equal ( object obj ) { return ( obj == this || ( obj instanceof file system resource & & this . path . equal ( ( ( file system resource ) obj ) . path ) ) ) ; }
public int hash code ( ) { return this . path . hash code ( ) ; }
public input stream get input stream ( ) throw i o exception { if ( ! exists ( ) ) { throw new file not find exception ( get path ( ) + `` ( no such file or directory ) `` ) ; } if ( file . be directory ( this . path ) ) { throw new file not find exception ( get path ( ) + `` ( be a directory ) `` ) ; } return file . new input stream ( this . path ) ; }
public boolean equal ( object obj ) { return ( this == obj || ( obj instanceof path resource & & this . path . equal ( ( ( path resource ) obj ) . path ) ) ) ; }
protect string resolve path ( string path ) { if ( this . property resolver == null ) { this . property resolver = new standard environment ( ) ; } return ( this . ignore unresolvable placeholder ? this . property resolver . resolve placeholder ( path ) : this . property resolver . resolve required placeholder ( path ) ) ; }
protect boolean be jar resource ( resource resource ) throw i o exception { return resource utils . be jar u r l ( resource . get u r l ( ) ) ; }
public void set local override ( boolean local override ) { this . local override = local override ; }
public static property load all property ( string resource name , class loader class loader ) throw i o exception { assert . not null ( resource name , `` resource name must not be null `` ) ; class loader class loader to use = class loader ; if ( class loader to use == null ) { class loader to use = class utils . get default class loader ( ) ; } enumeration < url > url = ( class loader to use ! = null ? class loader to use . get resource ( resource name ) : class loader . get system resource ( resource name ) ) ; property prop = new property ( ) ; while ( urls . have more element ( ) ) { url url = url . next element ( ) ; u r l connection con = url . open connection ( ) ; resource utils . use cache if necessary ( con ) ; input stream be = con . get input stream ( ) ; try { if ( resource name . end with ( xml_file_extension ) ) { prop . load from x m l ( be ) ; } else { prop . load ( be ) ; } } finally { be . close ( ) ; } } return prop ; }
public static list < string > load factory name ( class < ? > factory class , class loader class loader ) { string factory class name = factory class . get name ( ) ; try { enumeration < url > url = ( class loader ! = null ? class loader . get resource ( factories_resource_location ) : class loader . get system resource ( factories_resource_location ) ) ; list < string > result = new array list < string > ( ) ; while ( urls . have more element ( ) ) { url url = url . next element ( ) ; property property = property loader utils . load property ( new url resource ( url ) ) ; string factory class name = property . get property ( factory class name ) ; result . add all ( array . a list ( string utils . comma delimit list to string array ( factory class name ) ) ) ; } return result ; } catch ( i o exception ex ) { throw new illegal argument exception ( `` unable to load [ `` + factory class . get name ( ) + `` ] factory from location [ `` + factories_resource_location + `` ] `` , ex ) ; } }
public int hash code ( ) { return this . clean url . hash code ( ) ; }
public constructor < ? > get constructor ( ) { return this . constructor ; }
public void increase nest level ( ) { this . nesting level++ ; }
protect int get order ( object obj ) { integer order = find order ( obj ) ; return ( order ! = null ? order : order . lowest_precedence ) ; }
protect integer find order ( object obj ) { return ( obj instanceof order ? ( ( order ) obj ) . get order ( ) : null ) ; }
protect boolean be eligible for override ( string class name ) { return ! be exclude ( class name ) ; }
public void add discoverer ( parameter name discoverer pnd ) { this . parameter name discoverer . add ( pnd ) ; }
public static boolean get flag ( string key ) { return boolean . parse boolean ( get property ( key ) ) ; }
protect final value styler get value styler ( ) { return this . value styler ; }
public to string creator append ( string field name , int value ) { return append ( field name , new integer ( value ) ) ; }
public void execute ( runnable task ) { execute ( task , timeout_indefinite ) ; }
public final method get introspect method ( ) { return this . introspected method ; }
public void set trim token ( boolean trim token ) { this . trim token = trim token ; }
public string extract path within pattern ( string pattern , string path ) { string [ ] pattern part = string utils . tokenize to string array ( pattern , this . path separator , this . trim token , true ) ; string [ ] path part = string utils . tokenize to string array ( path , this . path separator , this . trim token , true ) ; string builder builder = new string builder ( ) ; boolean path start = false ; for ( int segment = 0 ; segment < pattern part . length ; segment++ ) { string pattern part = pattern part [ segment ] ; if ( pattern part . index of ( ' * ' ) > -1 || pattern part . index of ( ' ? ' ) > -1 ) { for ( ; segment < path part . length ; segment++ ) { if ( path start || ( segment == 0 & & ! pattern . start with ( this . path separator ) ) ) { builder . append ( this . path separator ) ; } builder . append ( path part [ segment ] ) ; path start = true ; } } } return builder . to string ( ) ; }
public void set initial interval ( long initial interval ) { this . initial interval = initial interval ; }
public static byte [ ] decode from url safe string ( string src ) { assert delegate available ( ) ; return delegate . decode url safe ( src . get byte ( default_charset ) ) ; }
public static string get class file name ( class < ? > clazz ) { assert . not null ( clazz , `` class must not be null `` ) ; string class name = clazz . get name ( ) ; int last dot index = class name . last index of ( package_separator ) ; return class name . substring ( last dot index + 1 ) + class_file_suffix ; }
public static boolean be assignable value ( class < ? > type , object value ) { assert . not null ( type , `` type must not be null `` ) ; return ( value ! = null ? be assignable ( type , value . get class ( ) ) : ! type . be primitive ( ) ) ; }
public static string convert resource path to class name ( string resource path ) { assert . not null ( resource path , `` resource path must not be null `` ) ; return resource path . replace ( path_separator , package_separator ) ; }
public void invert order ( ) { this . ascend = ! this . ascending ; }
public void set thread priority ( int thread priority ) { this . thread priority = thread priority ; }
public static byte [ ] md5 digest ( byte [ ] bytes ) { return digest ( md5_algorithm_name , byte ) ; }
public void write to ( output stream out ) throw i o exception { iterator < byte [ ] > it = this . buffer . iterator ( ) ; while ( it . have next ( ) ) { byte [ ] bytes = it . next ( ) ; if ( it . have next ( ) ) { out . write ( byte , 0 , byte . length ) ; } else { out . write ( byte , 0 , this . index ) ; } } }
public static void init logging ( string location ) throw file not find exception { string resolve location = system property utils . resolve placeholder ( location ) ; url url = resource utils . get u r l ( resolve location ) ; if ( resource utils . url_protocol_file . equal ( url . get protocol ( ) ) & & ! resource utils . get file ( url ) . exists ( ) ) { throw new file not find exception ( `` log4j config file [ `` + resolve location + `` ] not find `` ) ; } if ( resolve location . to lower case ( ) . end with ( xml_file_extension ) ) { d o m configurator . configure ( url ) ; } else { property configurator . configure ( url ) ; } }
public object get target object ( ) { return this . target object ; }
public static boolean be empty ( object [ ] array ) { return ( array == null || array . length == 0 ) ; }
public static void make accessible ( field field ) { if ( ( ! modifier . be public ( field . get modifier ( ) ) || ! modifier . be public ( field . get declare class ( ) . get modifier ( ) ) || modifier . be final ( field . get modifier ( ) ) ) & & ! field . be accessible ( ) ) { field . set accessible ( true ) ; } }
public static method [ ] get all declare method ( class < ? > leaf class ) { final list < method > method = new array list < method > ( 32 ) ; do with method ( leaf class , new method callback ( ) { @ override public void do with ( method method ) { method . add ( method ) ; } } ) ; return method . to array ( new method [ method . size ( ) ] ) ; }
public static boolean be file u r l ( url url ) { string protocol = url . get protocol ( ) ; return ( url_protocol_file . equal ( protocol ) || url_protocol_vfsfile . equal ( protocol ) || url_protocol_vfs . equal ( protocol ) ) ; }
public void update message digest ( message digest message digest ) throw i o exception { int data ; while ( ( data = read ( ) ) ! = -1 ) { message digest . update ( ( byte ) data ) ; } }
public static < a extend annotation > merge annotation selector < a > first directly declare ( ) { return ( merge annotation selector < a > ) first_directly_declared ; }
public static synthesizing method parameter for executable ( executable executable , int parameter index ) { if ( executable instanceof method ) { return new synthesize method parameter ( ( method ) executable , parameter index ) ; } else if ( executable instanceof constructor ) { return new synthesize method parameter ( ( constructor < ? > ) executable , parameter index ) ; } else { throw new illegal argument exception ( `` not a method/ constructor : `` + executable ) ; } }
public void set max in memory size ( int byte count ) { this . max in memory size = byte count ; }
public void set logger ( log logger ) { this . logger = logger ; }
public log get logger ( ) { return logger ; }
public static void add collection converter ( converter registry converter registry ) { conversion service conversion service = ( conversion service ) converter registry ; converter registry . add converter ( new array to collection converter ( conversion service ) ) ; converter registry . add converter ( new collection to array converter ( conversion service ) ) ; converter registry . add converter ( new array to array converter ( conversion service ) ) ; converter registry . add converter ( new collection to collection converter ( conversion service ) ) ; converter registry . add converter ( new map to map converter ( conversion service ) ) ; converter registry . add converter ( new array to string converter ( conversion service ) ) ; converter registry . add converter ( new string to array converter ( conversion service ) ) ; converter registry . add converter ( new array to object converter ( conversion service ) ) ; converter registry . add converter ( new object to array converter ( conversion service ) ) ; converter registry . add converter ( new collection to string converter ( conversion service ) ) ; converter registry . add converter ( new string to collection converter ( conversion service ) ) ; converter registry . add converter ( new collection to object converter ( conversion service ) ) ; converter registry . add converter ( new object to collection converter ( conversion service ) ) ; converter registry . add converter ( new stream converter ( conversion service ) ) ; }
public resource create relative ( string relative path ) { return new path resource ( this . path . resolve ( relative path ) ) ; }
public void trace ( char sequence message ) { this . log . trace ( message ) ; }
public void trace ( throwable cause , char sequence message ) { this . log . trace ( message , cause ) ; }
public string to string ( ) { if ( this . result == null ) { this . result = build string ( ) ; } return this . result ; }
public object from publisher ( publisher < ? > publisher ) { return this . from publisher function . apply ( publisher ) ; }
public static reactive type descriptor single optional value ( class < ? > type , supplier < ? > empty supplier ) { return new reactive type descriptor ( type , false , false , empty supplier ) ; }
public static void have text ( @ nullable string text , string message ) { if ( ! string utils . have text ( text ) ) { throw new illegal argument exception ( message ) ; } }
public static < t > comparator < t > null high ( comparator < t > comparator ) { return new null safe comparator < > ( comparator , false ) ; }
public boolean equal type and subtype ( @ nullable mime type other ) { if ( other == null ) { return false ; } return this . type . equal ignore case ( other . type ) & & this . subtype . equal ignore case ( other . subtype ) ; }
public static void do with local field ( class < ? > clazz , field callback fc ) { for ( field field : get declare field ( clazz ) ) { try { fc . do with ( field ) ; } catch ( illegal access exception ex ) { throw new illegal state exception ( `` not allow to access field ' `` + field . get name ( ) + `` ' : `` + ex ) ; } } }
public void start ( string task name ) throw illegal state exception { if ( this . current task name ! = null ) { throw new illegal state exception ( `` ca n't start stop watch : it 's already run `` ) ; } this . current task name = task name ; this . start time nanos = system . nano time ( ) ; }
public long get last task time millis ( ) throw illegal state exception { if ( this . last task info == null ) { throw new illegal state exception ( `` no task run : ca n't get last task interval `` ) ; } return this . last task info . get time millis ( ) ; }
public string pretty print ( ) { string builder sb = new string builder ( short summary ( ) ) ; sb . append ( '\n ' ) ; if ( ! this . keep task list ) { sb . append ( `` no task info keep `` ) ; } else { sb . append ( `` -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -\n `` ) ; sb . append ( `` ns % task name\n `` ) ; sb . append ( `` -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -\n `` ) ; number format nf = number format . get number instance ( ) ; nf . set minimum integer digit ( 9 ) ; nf . set group use ( false ) ; number format pf = number format . get percent instance ( ) ; pf . set minimum integer digit ( 3 ) ; pf . set group use ( false ) ; for ( task info task : get task info ( ) ) { sb . append ( nf . format ( task . get time nanos ( ) ) ) . append ( `` `` ) ; sb . append ( pf . format ( ( double ) task . get time nanos ( ) / get total time nanos ( ) ) ) . append ( `` `` ) ; sb . append ( task . get task name ( ) ) . append ( `` \n `` ) ; } } return sb . to string ( ) ; }
public static long copy range ( input stream in , output stream out , long start , long end ) throw i o exception { assert . not null ( in , `` no input stream specify `` ) ; assert . not null ( out , `` no output stream specify `` ) ; long skip = in . skip ( start ) ; if ( skip < start ) { throw new i o exception ( `` skip only `` + skip + `` bytes out of `` + start + `` require `` ) ; } long bytes to copy = end - start + 1 ; byte [ ] buffer = new byte [ ( int ) math . min ( stream utils . buffer_size , byte to copy ) ] ; while ( byte to copy > 0 ) { int byte read = in . read ( buffer ) ; if ( byte read == -1 ) { break ; } else if ( byte read < = bytes to copy ) { out . write ( buffer , 0 , byte read ) ; bytes to copy -= byte read ; } else { out . write ( buffer , 0 , ( int ) bytes to copy ) ; bytes to copy = 0 ; } } return ( end - start + 1 - byte to copy ) ; }
public long to megabyte ( ) { return this . bytes / bytes_per_mb ; }
public static byte to byte ( type converter type converter , type value type value ) { return ( byte ) type converter . convert value ( typed value . get value ( ) , type value . get type descriptor ( ) , type descriptor . value of ( byte . class ) ) ; }
public static string format class name for message ( class < ? > clazz ) { if ( clazz == null ) { return `` null `` ; } if ( clazz . be array ( ) ) { string builder sb = new string builder ( ) ; int dim = 1 ; class < ? > base class = clazz . get component type ( ) ; while ( base class . be array ( ) ) { base class = base class . get component type ( ) ; dims++ ; } sb . append ( base class . get name ( ) ) ; for ( int i = 0 ; i < dims ; i++ ) { sb . append ( `` [ ] `` ) ; } return sb . to string ( ) ; } else { return clazz . get name ( ) ; } }
public boolean type value get value internal ( expression state state ) throw evaluation exception { object leave = get leave operand ( ) . get value internal ( state ) . get value ( ) ; object right = get right operand ( ) . get value internal ( state ) . get value ( ) ; if ( ! ( right instanceof list ) || ( ( list < ? > ) right ) . size ( ) ! = 2 ) { throw new spel evaluation exception ( get right operand ( ) . get start position ( ) , spel message . between_right_operand_must_be_two_element_list ) ; } list < ? > list = ( list < ? > ) right ; object low = list . get ( 0 ) ; object high = list . get ( 1 ) ; type comparator comp = state . get type comparator ( ) ; try { return boolean typed value . for value ( comp . compare ( leave , low ) > = 0 & & comp . compare ( leave , high ) < = 0 ) ; } catch ( spel evaluation exception ex ) { ex . set position ( get start position ( ) ) ; throw ex ; } }
protect method [ ] get method ( class < ? > type ) { return type . get method ( ) ; }
protect method find setter for property ( string property name , class < ? > clazz , boolean must be static ) { return find method for property ( get property method suffix ( property name ) , `` set `` , clazz , must be static , 1 , any_types ) ; }
protect string [ ] get property method suffix ( string property name ) { string suffix = get property method suffix ( property name ) ; if ( suffix . length ( ) > 0 & & character . be upper case ( suffix . char at ( 0 ) ) ) { return new string [ ] { suffix } ; } return new string [ ] { suffix , string utils . capitalize ( suffix ) } ; }
public object [ ] get insert ( ) { return this . insert ; }
public static data bind property accessor for read only access ( ) { return new data bind property accessor ( false ) ; }
public static boolean compile ( expression expression ) { return ( expression instanceof spel expression & & ( ( spel expression ) expression ) . compile expression ( ) ) ; }
public void set pattern variable ( simple name reference pattern variable ) { support only in15 ( ) ; unsupported without preview error ( ) ; if ( reference pattern variable == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . pattern variable ; pre replace child ( old child , reference pattern variable , pattern_variable_property ) ; this . pattern variable = reference pattern variable ; post replace child ( old child , reference pattern variable , pattern_variable_property ) ; }
public static i java element create ( i resource resource ) { return java model manager . create ( resource , null/ * unknown java project * / ) ; }
public static i classpath entry get resolve classpath entry ( i classpath entry entry ) { return java model manager . get java model manager ( ) . resolve variable entry ( entry , false/ * do n't use previous session value * / ) ; }
public static i path get resolve variable path ( i path variable path ) { return java model manager . get java model manager ( ) . get resolve variable path ( variable path , false/ * do n't use previous session value * / ) ; }
public chunk get writable chunk ( ) { chunk result = this . f database . get chunk ( ( long ) this . f sequence number * database . chunk_size ) ; result . make dirty ( ) ; return result ; }
public static long get byte that fit in chunk ( int num chunk ) { return chunk_size * ( long ) num chunk - large block . header_size - large block . footer_size - block_header_size ; }
public void attach to ( index exception exception ) { for ( related address next : this . related address ) { exception . add related address ( next ) ; } }
public nd complex type signature get generic declare type ( ) { return declaring_type . get ( get nd ( ) , this . address ) ; }
public int get record size ( ) { return array_header_bytes + database . ptr_size * this . inline size ; }
public static int round up to near multiple ( int number to round , int to multiple of this ) { return ( ( number to round + to multiple of this - 1 ) / to multiple of this ) * to multiple of this ; }
public void set line separator ( string line separator ) { this . line separator = line separator ; }
public jdbc user detail manager configurer < b > authority by username query ( string query ) { get user detail service ( ) . set authority by username query ( query ) ; return this ; }
protect void init user detail service ( ) throw exception { for ( user detail builder user builder : this . user builder ) { get user detail service ( ) . create user ( user builder . build ( ) ) ; } for ( user detail user detail : this . user ) { get user detail service ( ) . create user ( user detail ) ; } }
public exception handle configurer < http security > exception handling ( ) throw exception { return get or apply ( new exception handle configurer < > ( ) ) ; }
public saml2 login configurer < http security > saml2 login ( ) throw exception { return get or apply ( new saml2 login configurer < > ( ) ) ; }
public web security debug ( boolean debug enable ) { this . debug enable = debug enable ; return this ; }
public filter spring security filter chain ( ) throw exception { boolean have configurers = this . web security configurers ! = null & & ! this . web security configurers . be empty ( ) ; boolean have filter chain = ! this . security filter chain . be empty ( ) ; assert . state ( ! ( have configurers & & have filter chain ) , `` find web security configurer adapter as well a security filter chain . please select just one . `` ) ; if ( ! have configurers & & ! have filter chain ) { web security configurer adapter adapter = this . object object post processor . post process ( new web security configurer adapter ( ) { } ) ; this . web security . apply ( adapter ) ; } for ( security filter chain security filter chain : this . security filter chain ) { this . web security . add security filter chain builder ( ( ) - > security filter chain ) ; for ( filter filter : security filter chain . get filter ( ) ) { if ( filter instanceof filter security interceptor ) { this . web security . security interceptor ( ( filter security interceptor ) filter ) ; break ; } } } for ( web security customizer customizer : this . web security customizers ) { customizer . customize ( this . web security ) ; } return this . web security . build ( ) ; }
protect t login page ( string login page ) { set login page ( login page ) ; update authentication default ( ) ; this . custom login page = true ; return get self ( ) ; }
protect final void set authentication filter ( f auth filter ) { this . auth filter = auth filter ; }
protect final string get login process url ( ) { return this . login process url ; }
protect final void update authentication default ( ) { if ( this . login process url == null ) { login process url ( this . login page ) ; } if ( this . failure handler == null ) { failure url ( this . login page + `` ? error `` ) ; } logout configurer < b > logout configurer = get builder ( ) . get configurer ( logout configurer . class ) ; if ( logout configurer ! = null & & ! logout configurer . be custom logout success ( ) ) { logout configurer . logout success url ( this . login page + `` ? logout `` ) ; } }
public x x config xss protection ( ) { return this . xss protection . enable ( ) ; }
public logout configurer < h > logout success url ( string logout success url ) { this . custom logout success = true ; this . logout success url = logout success url ; return this ; }
public o auth2 client configurer < b > authorization code grant ( customizer < authorization code grant configurer > authorization code grant customizer ) { authorization code grant customizer . customize ( this . authorization code grant configurer ) ; return this ; }
public object invoke ( join point jp , aspect j callback advisor proceed ) { interceptor status token token = super . before invocation ( new method invocation adapter ( jp ) ) ; object result ; try { result = advisor proceed . proceed with object ( ) ; } finally { super . finally invocation ( token ) ; } return super . after invocation ( token , result ) ; }
public boolean support ( class < ? > clazz ) { return true ; }
public void handle ( callback callback , authentication auth ) { if ( callback instanceof password callback ) { ( ( password callback ) callback ) . set password ( auth . get credential ( ) . to string ( ) . to char array ( ) ) ; } }
public static void clear context ( ) { strategy . clear context ( ) ; }
protected list < grant authority > load group authority ( string username ) { return get jdbc template ( ) . query ( this . group authority by username query , new string [ ] { username } , ( r , row num ) - > { string role name = get role prefix ( ) + r . get string ( 3 ) ; return new simple grant authority ( role name ) ; } ) ; }
public static byte [ ] encode ( char sequence string ) { try { byte buffer bytes = charset . new encoder ( ) . encode ( char buffer . wrap ( string ) ) ; byte [ ] byte copy = new byte [ byte . limit ( ) ] ; system . arraycopy ( byte . array ( ) , 0 , byte copy , 0 , byte . limit ( ) ) ; return byte copy ; } catch ( character cod exception ex ) { throw new illegal argument exception ( `` encode fail `` , ex ) ; } }
public string get client secret ( ) { return this . client secret ; }
public void set request cache ( server request cache request cache ) { assert . not null ( request cache , `` request cache can not be null `` ) ; this . request cache = request cache ; }
public @ nullable instant get issue at ( ) { return this . issue at ; }
public void set target url parameter ( string target url parameter ) { if ( target url parameter ! = null ) { assert . have text ( target url parameter , `` target url parameter can not be empty `` ) ; } this . target url parameter = target url parameter ; }
public void set redirect strategy ( redirect strategy redirect strategy ) { this . redirect strategy = redirect strategy ; }
public void logout ( http servlet request request , http servlet response response , authentication authentication ) { assert . not null ( request , `` http servlet request require `` ) ; if ( this . invalidate http session ) { http session session = request . get session ( false ) ; if ( session ! = null ) { session . invalidate ( ) ; if ( this . logger . be debug enable ( ) ) { this . logger . debug ( log message . format ( `` invalidate session % s `` , session . get id ( ) ) ) ; } } } if ( this . clear authentication ) { security context context = security context holder . get context ( ) ; context . set authentication ( null ) ; } security context holder . clear context ( ) ; }
public void set exception if header miss ( boolean exception if header miss ) { this . exception if header miss = exception if header miss ; }
public final authentication auto login ( http servlet request request , http servlet response response ) { string remember me cookie = extract remember me cookie ( request ) ; if ( remember me cookie == null ) { return null ; } this . logger . debug ( `` remember-me cookie detect `` ) ; if ( remember me cookie . length ( ) == 0 ) { this . logger . debug ( `` cookie be empty `` ) ; cancel cookie ( request , response ) ; return null ; } try { string [ ] cookie token = decode cookie ( remember me cookie ) ; user detail user = process auto login cookie ( cookie token , request , response ) ; this . user detail checker . check ( user ) ; this . logger . debug ( `` remember-me cookie accept `` ) ; return create successful authentication ( request , user ) ; } catch ( cookie theft exception ex ) { cancel cookie ( request , response ) ; throw ex ; } catch ( username not find exception ex ) { this . logger . debug ( `` remember-me login be valid but correspond user not find . `` , ex ) ; } catch ( invalid cookie exception ex ) { this . logger . debug ( `` invalid remember-me cookie : `` + ex . get message ( ) ) ; } catch ( account status exception ex ) { this . logger . debug ( `` invalid user detail : `` + ex . get message ( ) ) ; } catch ( remember me authentication exception ex ) { this . logger . debug ( ex . get message ( ) ) ; } cancel cookie ( request , response ) ; return null ; }
public string get old session id ( ) { return this . old session id ; }
public void set use forward ( boolean forward to destination ) { this . forward to destination = forward to destination ; }
public void set exit user matcher ( request matcher exit user matcher ) { assert . not null ( exit user matcher , `` exit user matcher can not be null `` ) ; this . exit user matcher = exit user matcher ; }
public authentication get source ( ) { return this . source ; }
public void set password parameter ( string password parameter ) { assert . have text ( password parameter , `` password parameter must not be empty or null `` ) ; this . password parameter = password parameter ; }
public string get full request url ( ) { return url utils . build full request url ( this . request ) ; }
public void set allow back slash ( boolean allow back slash ) { if ( allow back slash ) { url blocklists remove all ( forbidden_backslash ) ; } else { url blocklists add all ( forbidden_backslash ) ; } }
public string get parameter ( string name ) { string value = super . get parameter ( name ) ; if ( value ! = null ) { return value ; } string [ ] value = this . save request . get parameter value ( name ) ; if ( value == null || value . length == 0 ) { return null ; } return value [ 0 ] ; }
public void set authentication failure handler ( server authentication failure handler authentication failure handler ) { assert . not null ( authentication failure handler , `` authentication failure handler can not be null `` ) ; this . authentication failure handler = authentication failure handler ; }
public void set parameter name ( string parameter name ) { assert . have length ( parameter name , `` parameter name ca n't be null `` ) ; this . parameter name = parameter name ; }
public void set header name ( string header name ) { assert . have length ( header name , `` header name ca n't be null `` ) ; this . header name = header name ; }
public void set cookie domain ( string cookie domain ) { this . cookie domain = cookie domain ; }
public evaluation context create e l context ( http servlet request request ) { return new standard evaluation context ( new e l request matcher context ( request ) ) ; }
public http header get header ( ) { return this . header ; }
public boolean be active ( ) { return this . active ; }
public void invalidate ( ) { close ( ) ; clear attribute ( ) ; }
public string change session id ( ) { assert . be true ( this . session ! = null , `` the request do not have a session `` ) ; if ( this . session instanceof mock http session ) { return ( ( mock http session ) this . session ) . change session id ( ) ; } return this . session . get id ( ) ; }
protect print writer get target writer ( ) throw i o exception { if ( this . target writer == null ) { this . target writer = this . response . get writer ( ) ; } return this . target writer ; }
public string [ ] get location ( ) { return this . location ; }
protect int count row in table where ( string table name , string where clause ) { return jdbc test utils . count row in table where ( this . jdbc template , table name , where clause ) ; }
protect int delete from table ( string . . . name ) { return jdbc test utils . delete from table ( this . jdbc template , names ) ; }
protect int delete from table where ( string table name , string where clause , object . . . args ) { return jdbc test utils . delete from table where ( this . jdbc template , table name , where clause , args ) ; }
public void run ( run notifier notifier ) { if ( ! profile value utils . be test enable in this environment ( get test class ( ) . get java class ( ) ) ) { notifier . fire test ignore ( get description ( ) ) ; return ; } super . run ( notifier ) ; }
protect string [ ] generate default location ( class < ? > clazz ) { assert . not null ( clazz , `` class must not be null `` ) ; string [ ] suffix = get resource suffix ( ) ; for ( string suffix : suffix ) { assert . have text ( suffix , `` resource suffix must not be empty `` ) ; string resource path = class utils . convert class name to resource path ( clazz . get name ( ) ) + suffix ; class path resource class path resource = new class path resource ( resource path ) ; if ( class path resource . exists ( ) ) { string prefix resource path = resource utils . classpath_url_prefix + resource path ; if ( logger . be info enable ( ) ) { logger . info ( string . format ( `` detect default resource location \ `` % s\ `` for test class [ % s ] `` , prefixed resource path , clazz . get name ( ) ) ) ; } return new string [ ] { prefixed resource path } ; } else if ( logger . be debug enable ( ) ) { logger . debug ( string . format ( `` do not detect default resource location for test class [ % s ] : `` + `` % s do not exist `` , clazz . get name ( ) , class path resource ) ) ; } } if ( logger . be info enable ( ) ) { logger . info ( string . format ( `` could not detect default resource location for test class [ % s ] : `` + `` no resource find for suffix % s . `` , clazz . get name ( ) , object utils . null safe to string ( suffix ) ) ) ; } return empty_string_array ; }
public static boolean be flag for rollback ( ) { return require current transaction context ( ) . be flag for rollback ( ) ; }
protect final boolean be rollback ( test context test context ) throw exception { boolean rollback = be default rollback ( test context ) ; rollback rollback annotation = annotate element utils . find merged annotation ( test context . get test method ( ) , rollback . class ) ; if ( rollback annotation ! = null ) { boolean rollback override = rollback annotation . value ( ) ; if ( logger . be debug enable ( ) ) { logger . debug ( string . format ( `` method-level @ rollback ( % s ) override default rollback [ % s ] for test context % s . `` , rollback override , rollback , test context ) ) ; } rollback = rollback override ; } else { if ( logger . be debug enable ( ) ) { logger . debug ( string . format ( `` no method-level @ rollback override : use default rollback [ % s ] for test context % s . `` , rollback , test context ) ) ; } } return rollback ; }
public request matcher xml ( string expect xml content ) { return new abstract xml request matcher ( ) { @ override protect void match internal ( mock client http request request ) throw exception { xml helper . assert xml equal ( expect xml content , request . get body a string ( ) ) ; } } ; }
public request matcher do not exist ( ) { return new abstract json path request matcher ( ) { @ override protect void match internal ( mock client http request request ) throw i o exception , parse exception { json path request matcher . this . json path helper . do not exist ( request . get body a string ( ) ) ; } } ; }
public static request matcher query param ( string name , string . . . expect value ) { return request - > { multi value map < string , string > params = get query params ( request ) ; assert value count ( `` query param `` , name , params , expect value . length ) ; for ( int i = 0 ; i < expect value . length ; i++ ) { assert equal ( `` query param [ `` + name + `` ] `` , expect value [ i ] , params . get ( name ) . get ( i ) ) ; } } ; }
public static content request matcher content ( ) { return new content request matcher ( ) ; }
public request matcher node count ( matcher < integer > matcher ) { return ( xpath request matcher ) request - > this . xpath helper . assert node count ( request . get body a byte ( ) , default_encoding , matcher ) ; }
public request matcher number ( matcher < ? super double > matcher ) { return ( xpath request matcher ) request - > this . xpath helper . assert number ( request . get body a byte ( ) , default_encoding , matcher ) ; }
public static void assert compare list model attribute ( model and view mav , string model name , list expect list ) { list model list = assert and return model attribute of type ( mav , model name , list . class ) ; assert true ( `` size of model list be ' `` + model list . size ( ) + `` ' while size of expect list be ' `` + expect list . size ( ) + `` ' `` , expect list . size ( ) == model list . size ( ) ) ; assert true ( `` list in model under name ' `` + model name + `` ' be not equal to the expected list . `` , expect list . equal ( model list ) ) ; }
public web test client . response spec last modify ( long last modify ) { return assert header ( `` last- modified `` , last modify , get header ( ) . get last modified ( ) ) ; }
public < t > web test client . body content spec value ( consumer < t > consumer , class < t > target type ) { object value = this . path helper . evaluate json path ( this . content , target type ) ; consumer . accept ( ( t ) value ) ; return this . body spec ; }
public web test client . response spec is5xx server error ( ) { http status . series expect = http status . series . server_error ; return assert series and return ( expect ) ; }
public web test client . response spec value ( consumer < integer > consumer ) { int value = this . exchange result . get status ( ) . value ( ) ; this . exchange result . assert with diagnostics ( ( ) - > consumer . accept ( value ) ) ; return this . response spec ; }
public mock http servlet request builder servlet path ( string servlet path ) { if ( string utils . have text ( servlet path ) ) { assert . be true ( servlet path . start with ( `` / `` ) , `` servlet path must start with a '/ ' `` ) ; assert . be true ( ! servlet path . end with ( `` / `` ) , `` servlet path must not end with a '/ ' `` ) ; } this . servlet path = servlet path ; return this ; }
public mock http servlet request builder session attr ( string name , object value ) { add to map ( this . session attribute , name , value ) ; return this ; }
public result matcher content type ( medium type content type ) { return result - > { string actual = result . get response ( ) . get content type ( ) ; assert not null ( `` content type not set `` , actual ) ; assert equal ( `` content type `` , content type , medium type . parse medium type ( actual ) ) ; } ; }
public result matcher content type compatible with ( string content type ) { return content type compatible with ( medium type . parse medium type ( content type ) ) ; }
public result matcher exists ( string name ) { return result - > get cookie ( result , name ) ; }
public result matcher max age ( string name , int max age ) { return result - > { cookie cookie = get cookie ( result , name ) ; assert equal ( `` response cookie ' `` + name + `` ' max age `` , max age , cookie . get max age ( ) ) ; } ; }
public result matcher do not exist ( string name ) { return result - > assert false ( `` response should not contain header ' `` + name + `` ' `` , result . get response ( ) . contains header ( name ) ) ; }
public result matcher date value ( string name , long value ) { return result - > { mock http servlet response response = result . get response ( ) ; string header value = response . get header ( name ) ; assert not null ( `` response do not contain header ' `` + name + `` ' `` , header value ) ; http header header = new http header ( ) ; header . set date ( `` expect `` , value ) ; header . set ( `` actual `` , header value ) ; assert equal ( `` response header ' `` + name + `` '= ' `` + header value + `` ' `` + `` do not match expect value ' `` + header . get first ( `` expect `` ) + `` ' `` , header . get first date ( `` expect `` ) , header . get first date ( `` actual `` ) ) ; } ; }
public < t > result matcher value ( matcher < t > matcher ) { return result - > this . json path helper . assert value ( get content ( result ) , matcher ) ; }
public result matcher value ( object expect value ) { return result - > this . json path helper . assert value ( get content ( result ) , expect value ) ; }
public static result matcher forward url ( @ nullable string expect url ) { return result - > assert equal ( `` forward url `` , expect url , result . get response ( ) . get forwarded url ( ) ) ; }
public static result matcher forward url template ( string url template , object . . . uri var ) { string uri = uri component builder . from uri string ( url template ) . build and expand ( uri var ) . encode ( ) . to uri string ( ) ; return forward url ( uri ) ; }
public static result matcher redirect url template ( string url template , object . . . uri var ) { string uri = uri component builder . from uri string ( url template ) . build and expand ( uri var ) . encode ( ) . to uri string ( ) ; return redirect url ( uri ) ; }
public static content result matcher content ( ) { return new content result matcher ( ) ; }
public result matcher have no error ( ) { return result - > { model and view mav = get model and view ( result ) ; for ( object value : mav . get model ( ) . value ( ) ) { if ( value instanceof error ) { assert false ( `` unexpected binding/validation error : `` + value , ( ( error ) value ) . have error ( ) ) ; } } } ; }
public standalone mock mvc builder set message converter ( http message converter < ? > . . . message converter ) { this . message converter = arrays . a list ( message converter ) ; return this ; }
public standalone mock mvc builder set conversion service ( format conversion service conversion service ) { this . conversion service = conversion service ; return this ; }
public standalone mock mvc builder set use suffix pattern match ( boolean use suffix pattern match ) { this . use suffix pattern match = use suffix pattern match ; return this ; }
public void prepare test instance ( object test instance ) throw exception { if ( logger . be trace enable ( ) ) { logger . trace ( `` prepare test instance ( ) : instance [ `` + test instance + `` ] `` ) ; } get test context ( ) . update state ( test instance , null , null ) ; for ( test execution listener test execution listener : get test execution listener ( ) ) { try { test execution listener . prepare test instance ( get test context ( ) ) ; } catch ( throwable ex ) { if ( logger . be error enable ( ) ) { logger . error ( `` catch exception while allow test execution listener [ `` + test execution listener + `` ] to prepare test instance [ `` + test instance + `` ] `` , ex ) ; } reflection utils . rethrow exception ( ex ) ; } } }
public web test client . response spec exists ( string name ) { get cookie ( name ) ; return this . response spec ; }
public web test client . response spec value equal ( string header name , long value ) { string actual = get header ( ) . get first ( header name ) ; this . exchange result . assert with diagnostics ( ( ) - > assert true ( `` response do not contain header ' `` + header name + `` ' `` , actual ! = null ) ) ; return assert header ( header name , value , long . parse long ( actual ) ) ; }
public static cache control no cache ( ) { cache control cc = new cache control ( ) ; cc . no cache = true ; return cc ; }
public part builder part ( string name , object part ) { return part ( name , part , null ) ; }
public client http request factory get request factory ( ) { return this . request factory ; }
public list < client http request initializer > get client http request initializers ( ) { return this . client http request initializers ; }
public list < client http request interceptor > get interceptor ( ) { return this . interceptor ; }
public void set max in memory size ( int byte count ) { this . max in memory size = byte count ; }
protect < t > void add codec ( list < t > codecs , t codec ) { init codec ( codec ) ; codecs . add ( codec ) ; }
public static content disposition empty ( ) { return new content disposition ( `` `` , null , null , null , null , null , null , null ) ; }
public void add part converter ( http message converter < ? > part converter ) { assert . not null ( part converter , `` 'part converter ' must not be null `` ) ; this . part converter . add ( part converter ) ; }
public jackson2 object mapper builder default use wrapper ( boolean default use wrapper ) { this . default use wrapper = default use wrapper ; return this ; }
public jackson2 object mapper builder feature to enable ( object . . . feature to enable ) { for ( object feature : feature to enable ) { this . feature . put ( feature , boolean . true ) ; } return this ; }
public void set content length ( long content length ) { set ( content_length , long . to string ( content length ) ) ; }
public static list < medium type > parse medium type ( @ nullable list < string > medium type ) { if ( collection utils . be empty ( medium type ) ) { return collection . empty list ( ) ; } else if ( medium type . size ( ) == 1 ) { return parse medium type ( medium type . get ( 0 ) ) ; } else { list < medium type > result = new array list < > ( 8 ) ; for ( string medium type : medium type ) { result . add all ( parse medium type ( medium type ) ) ; } return result ; } }
public static body builder put ( uri url ) { return method ( http method . put , url ) ; }
public void set read timeout ( long timeout ) { this . proxy factory . set read timeout ( timeout ) ; }
protect object input stream create object input stream ( input stream be , @ nullable string codebase url ) throw i o exception { return new codebase aware object input stream ( be , get bean class loader ( ) , codebase url ) ; }
public void set codebase url ( @ nullable string codebase url ) { this . codebase url = codebase url ; }
public void set bind type ( string bind type ) { this . bind type = bind type ; }
public void destroy ( ) { for ( endpoint endpoint : this . publish endpoint ) { endpoint . stop ( ) ; } }
public string get soap action uri ( ) { return this . soap action uri ; }
public class < ? > get service interface ( ) { return this . service interface ; }
protected class loader get bean class loader ( ) { return this . bean class loader ; }
public void prepare ( ) { class < ? > ifc = get service interface ( ) ; assert . not null ( ifc , `` property 'service interface ' be require `` ) ; web service ann = ifc . get annotation ( web service . class ) ; if ( ann ! = null ) { apply default from annotation ( ann ) ; } service service to use = get jax w service ( ) ; if ( service to use == null ) { service to use = create jax ws service ( ) ; } this . port q name = get q name ( get port name ( ) ! = null ? get port name ( ) : ifc . get name ( ) ) ; object stub = get port stub ( service to use , ( get port name ( ) ! = null ? this . port q name : null ) ) ; prepare port stub ( stub ) ; this . port stub = stub ; }
public url get wsdl document url ( ) { return this . wsdl document url ; }
public void set servlet context ( servlet context servlet context ) { this . servlet context = servlet context ; }
public final method parameter get parameter ( ) { return this . parameter ; }
public static double get double parameter ( servlet request request , string name , double default val ) { if ( request . get parameter ( name ) == null ) { return default val ; } try { return get require double parameter ( request , name ) ; } catch ( servlet request bind exception ex ) { return default val ; } }
protect string get attribute name in session ( web request request , string attribute name ) { return this . attribute name prefix + attribute name ; }
public void set field marker prefix ( @ nullable string field marker prefix ) { this . field marker prefix = field marker prefix ; }
public void set bind empty multipart file ( boolean bind empty multipart file ) { this . bind empty multipart file = bind empty multipart file ; }
public async task executor get executor ( ) { if ( this . executor ! = null ) { return this . executor ; } else if ( this . executor name ! = null ) { assert . state ( this . bean factory ! = null , `` bean factory be require to look up an executor bean by name `` ) ; return this . bean factory . get bean ( this . executor name , async task executor . class ) ; } else { return null ; } }
public static request attribute get request attribute ( ) { request attribute attribute = request attribute holder . get ( ) ; if ( attribute == null ) { attribute = inheritable request attribute holder . get ( ) ; } return attribute ; }
public void set servlet context ( @ nullable servlet context servlet context ) { this . servlet context = servlet context ; }
protect void load bean definition ( groovy bean definition reader reader ) throw i o exception { string [ ] config location = get config location ( ) ; if ( config location ! = null ) { for ( string config location : config location ) { reader . load bean definition ( config location ) ; } } }
public final servlet context get servlet context ( ) { return this . servlet context ; }
protect resource get resource by path ( string path ) { return new servlet context resource ( this . servlet context , path ) ; }
public void set include payload ( boolean include payload ) { this . include payload = include payload ; }
public void set after message prefix ( string after message prefix ) { this . after message prefix = after message prefix ; }
protect string create message ( http servlet request request , string prefix , string suffix ) { string builder msg = new string builder ( ) ; msg . append ( prefix ) ; msg . append ( request . get method ( ) ) . append ( `` `` ) ; msg . append ( request . get request u r i ( ) ) ; if ( be include query string ( ) ) { string query string = request . get query string ( ) ; if ( query string ! = null ) { msg . append ( ' ? ' ) . append ( query string ) ; } } if ( be include client info ( ) ) { string client = request . get remote addr ( ) ; if ( string utils . have length ( client ) ) { msg . append ( `` , client= `` ) . append ( client ) ; } http session session = request . get session ( false ) ; if ( session ! = null ) { msg . append ( `` , session= `` ) . append ( session . get id ( ) ) ; } string user = request . get remote user ( ) ; if ( user ! = null ) { msg . append ( `` , user= `` ) . append ( user ) ; } } if ( be include header ( ) ) { http header header = new servlet server http request ( request ) . get header ( ) ; if ( get header predicate ( ) ! = null ) { enumeration < string > name = request . get header name ( ) ; while ( name . have more element ( ) ) { string header = names . next element ( ) ; if ( ! get header predicate ( ) . test ( header ) ) { header . set ( header , `` mask `` ) ; } } } msg . append ( `` , headers= `` ) . append ( header ) ; } if ( be include payload ( ) ) { string payload = get message payload ( request ) ; if ( payload ! = null ) { msg . append ( `` , payload= `` ) . append ( payload ) ; } } msg . append ( suffix ) ; return msg . to string ( ) ; }
public void set servlet context ( servlet context servlet context ) { this . servlet context = servlet context ; }
protect void init bean wrapper ( bean wrapper bw ) throw bean exception { }
protected boolean should not filter async dispatch ( ) { return false ; }
public list < medium type > get support medium type ( ) { return this . supported medium type ; }
protect bean factory get bean factory ( face context face context ) { return get web application context ( face context ) ; }
protect web application context get web application context ( face context face context ) { return face context utils . get require web application context ( face context ) ; }
public class < ? > get bean type ( ) { return this . bean type ; }
public handler method get resolve from handler method ( ) { return this . resolve from handler method ; }
public void set ignore default model on redirect ( boolean ignore default model on redirect ) { this . ignore default model on redirect = ignore default model on redirect ; }
public void set view ( @ nullable object view ) { this . view = view ; }
public model map get model ( ) { if ( use default model ( ) ) { return this . default model ; } else { if ( this . redirect model == null ) { this . redirect model = new model map ( ) ; } return this . redirect model ; } }
public http status get status ( ) { return this . status ; }
public void set binding disabled ( string attribute name ) { this . binding disabled . add ( attribute name ) ; }
public boolean be request handle ( ) { return this . request handle ; }
public void set default encode ( string default encode ) { this . file upload . set header encode ( default encode ) ; }
protect void initialize multipart ( ) { throw new illegal state exception ( `` multipart request not initialize `` ) ; }
public void set multipart resolver bean name ( string multipart resolver bean name ) { this . multipart resolver bean name = multipart resolver bean name ; }
protect void refresh application context ( application context context ) { if ( context instanceof configurable application context ) { configurable application context cac = ( configurable application context ) context ; if ( ! cac . be active ( ) ) { cac . refresh ( ) ; } } }
protect boolean have forward header ( server http request request ) { http header header = request . get header ( ) ; for ( string header name : forwarded_header_names ) { if ( header . contains key ( header name ) ) { return true ; } } return false ; }
protect http status determine status ( throwable ex ) { if ( ex instanceof response status exception ) { return ( ( response status exception ) ex ) . get status ( ) ; } return null ; }
public void set support locale ( list < locale > locales ) { this . support locale . clear ( ) ; this . support locale . add all ( locale ) ; }
public int get max session ( ) { return this . max session ; }
public void remove cookie ( http servlet response response ) { assert . not null ( response , `` http servlet response must not be null `` ) ; cookie cookie = create cookie ( `` `` ) ; cookie . set max age ( 0 ) ; if ( be cookie secure ( ) ) { cookie . set secure ( true ) ; } if ( be cookie http only ( ) ) { cookie . set http only ( true ) ; } response . add cookie ( cookie ) ; if ( logger . be trace enable ( ) ) { logger . trace ( `` remove cookie ' `` + get cookie name ( ) + `` ' `` ) ; } }
public void set case sensitive ( boolean case sensitive ) { this . case sensitive = case sensitive ; }
public static uri component builder from http url ( string http url ) { assert . not null ( http url , `` http url must not be null `` ) ; matcher matcher = http_url_pattern . matcher ( http url ) ; if ( matcher . match ( ) ) { uri component builder builder = new uri component builder ( ) ; string scheme = matcher . group ( 1 ) ; builder . scheme ( scheme ! = null ? scheme . to lower case ( ) : null ) ; builder . user info ( matcher . group ( 4 ) ) ; string host = matcher . group ( 5 ) ; if ( string utils . have length ( scheme ) & & ! string utils . have length ( host ) ) { throw new illegal argument exception ( `` [ `` + http url + `` ] be not a valid http url `` ) ; } builder . host ( host ) ; string port = matcher . group ( 7 ) ; if ( string utils . have length ( port ) ) { builder . port ( port ) ; } builder . path ( matcher . group ( 8 ) ) ; builder . query ( matcher . group ( 10 ) ) ; string fragment = matcher . group ( 12 ) ; if ( string utils . have text ( fragment ) ) { builder . fragment ( fragment ) ; } return builder ; } else { throw new illegal argument exception ( `` [ `` + http url + `` ] be not a valid http url `` ) ; } }
public uri component builder uri component ( uri component uri component ) { assert . not null ( uri component , `` uri component must not be null `` ) ; uri component . copy to uri component builder ( this ) ; return this ; }
public list < string > get variable name ( ) { return this . variable name ; }
public static boolean have submit parameter ( servlet request request , string name ) { assert . not null ( request , `` request must not be null `` ) ; if ( request . get parameter ( name ) ! = null ) { return true ; } for ( string suffix : submit_image_suffixes ) { if ( request . get parameter ( name + suffix ) ! = null ) { return true ; } } return false ; }
public static data buffer slice to ( data buffer buf , int idx ) { int po = buf . read position ( ) ; int len = idx - po + 1 ; return buf . retain slice ( po , len ) ; }
public static data buffer slice from ( data buffer buf , int idx ) { int len = buf . write position ( ) - idx - 1 ; return buf . retain slice ( idx + 1 , len ) ; }
protect void init writer ( ) { init type writer ( ) ; init object writer ( ) ; }
public static list < medium type > get medium type ( @ nullable string filename ) { list < medium type > medium type = null ; string ext = string utils . get filename extension ( filename ) ; if ( ext ! = null ) { medium type = file extension to medium type . get ( ext . to lower case ( locale . english ) ) ; } return ( medium type ! = null ? medium type : collection . empty list ( ) ) ; }
public static header builder < ? > get ( string uri template , object . . . uri variable ) { return method ( http method . get , uri template , uri variable ) ; }
public static header builder < ? > delete ( string uri template , object . . . uri variable ) { return method ( http method . delete , uri template , uri variable ) ; }
protect web exchange data binder init data binder ( web exchange data binder binder , server web exchange exchange ) { return binder ; }
public resource chain registration add resolver ( resource resolver resolver ) { assert . not null ( resolver , `` the provided resource resolver should not be null `` ) ; this . resolvers . add ( resolver ) ; if ( resolver instanceof version resource resolver ) { this . have version resolver = true ; } else if ( resolver instanceof path resource resolver ) { this . have path resolver = true ; } else if ( resolver instanceof web jar resource resolver ) { this . have webjars resolver = true ; } return this ; }
public void default view ( view . . . default view ) { this . default view . add all ( array . a list ( default view ) ) ; }
public void configure path matching ( path match configurer configurer ) { }
protect void configure view resolvers ( view resolver registry registry ) { }
public void set order ( int order ) { this . order = order ; }
public void set lazy init handler ( boolean lazy init handler ) { this . lazy init handler = lazy init handler ; }
public set < medium type expression > get expression ( ) { return new link hash set < > ( this . expression ) ; }
public set < medium type > get producible medium type ( ) { set < medium type > result = new link hash set < > ( ) ; for ( produce medium type expression expression : this . expression ) { if ( ! expression . be negated ( ) ) { result . add ( expression . get medium type ( ) ) ; } } return result ; }
protect handler method lookup handler method ( server web exchange exchange ) throw exception { list < match > match = new array list < > ( ) ; list < t > direct path match = this . mapping registry . get mapping by direct path ( exchange ) ; if ( direct path match ! = null ) { add match mapping ( direct path match , match , exchange ) ; } if ( match . be empty ( ) ) { add match mapping ( this . mapping registry . get registration ( ) . key set ( ) , match , exchange ) ; } if ( ! match . be empty ( ) ) { comparator < match > comparator = new match comparator ( get map comparator ( exchange ) ) ; match . sort ( comparator ) ; match best match = match . get ( 0 ) ; if ( match . size ( ) > 1 ) { if ( logger . be trace enable ( ) ) { logger . trace ( exchange . get log prefix ( ) + match . size ( ) + `` matching mapping : `` + match ) ; } if ( cors utils . be pre flight request ( exchange . get request ( ) ) ) { for ( match match : match ) { if ( match . have cors config ( ) ) { return preflight_ambiguous_match ; } } } else { match second best match = match . get ( 1 ) ; if ( comparator . compare ( best match , second best match ) == 0 ) { method m1 = best match . get handler method ( ) . get method ( ) ; method m2 = second best match . get handler method ( ) . get method ( ) ; request path path = exchange . get request ( ) . get path ( ) ; throw new illegal state exception ( `` ambiguous handler method map for ' `` + path + `` ' : { `` + m1 + `` , `` + m2 + `` } `` ) ; } } } handle match ( best match . mapping , best match . get handler method ( ) , exchange ) ; return best match . get handler method ( ) ; } else { return handle no match ( this . mapping registry . get registration ( ) . key set ( ) , exchange ) ; } }
public void set reactive adapter registry ( @ nullable reactive adapter registry registry ) { this . reactive adapter registry = registry ; }
public string [ ] get error message ( ) { return init error message ( ) ; }
public string get error message a string ( string delimiter ) { return string utils . array to delimit string ( init error message ( ) , delimiter ) ; }
public error get error ( ) { return this . error ; }
public void set configuration ( configuration configuration ) { this . configuration = configuration ; }
protect void post process template loader ( list < template loader > template loader ) { template loader . add ( new class template loader ( free marker configurer . class , `` `` ) ) ; }
public boolean be propagate query ( ) { return this . propagate query ; }
public string get context url ( string relative url ) { string url = string utils . apply relative path ( get context path ( ) + `` / `` , relative url ) ; return get exchange ( ) . transform url ( url ) ; }
public error get error ( string name ) { return get error ( name , be default html escape ( ) ) ; }
public bind status get bind status ( string path , boolean html escape ) throw illegal state exception { return new bind status ( this , path , html escape ) ; }
public void set order ( int order ) { this . order = order ; }
public channel id get channel id ( ) { return this . channel id ; }
public cors registration allow origin ( string . . . origin ) { this . config . set allow origin ( array . a list ( origin ) ) ; return this ; }
public void enable ( @ nullable string default servlet name ) { this . handler = new default servlet http request handler ( ) ; if ( default servlet name ! = null ) { this . handler . set default servlet name ( default servlet name ) ; } this . handler . set servlet context ( this . servlet context ) ; }
public interceptor registration path matcher ( path matcher path matcher ) { this . path matcher = path matcher ; return this ; }
public interceptor registration order ( int order ) { this . order = order ; return this ; }
public resource handler registration set cache period ( integer cache period ) { this . cache period = cache period ; return this ; }
public redirect view controller registration add redirect view controller ( string url path , string redirect url ) { redirect view controller registration registration = new redirect view controller registration ( url path , redirect url ) ; registration . set application context ( this . application context ) ; this . redirect registration . add ( registration ) ; return registration ; }
protect request map handler mapping create request map handler mapping ( ) { return new request mapping handler mapping ( ) ; }
protect void init strategy ( application context context ) { init multipart resolver ( context ) ; init locale resolver ( context ) ; init theme resolver ( context ) ; init handler mapping ( context ) ; init handler adapter ( context ) ; init handler exception resolvers ( context ) ; init request to view name translator ( context ) ; init view resolvers ( context ) ; init flash map manager ( context ) ; }
protect < t > t get default strategy ( application context context , class < t > strategy interface ) { list < t > strategy = get default strategy ( context , strategy interface ) ; if ( strategy . size ( ) ! = 1 ) { throw new bean initialization exception ( `` dispatcher servlet need exactly 1 strategy for interface [ `` + strategy interface . get name ( ) + `` ] `` ) ; } return strategy . get ( 0 ) ; }
protect void no handler find ( http servlet request request , http servlet response response ) throw exception { if ( page not find logger . be warn enable ( ) ) { page not find logger . warn ( `` no mapping for `` + request . get method ( ) + `` `` + get request uri ( request ) ) ; } if ( this . throw exception if no handler find ) { throw new no handler find exception ( request . get method ( ) , get request uri ( request ) , new servlet server http request ( request ) . get header ( ) ) ; } else { response . send error ( http servlet response . sc_not_found ) ; } }
public flash map add target request param ( string name , string value ) { if ( string utils . have text ( name ) & & string utils . have text ( value ) ) { this . target request params . add ( name , value ) ; } return this ; }
public void set context config location ( @ nullable string context config location ) { this . context config location = context config location ; }
public void set publish event ( boolean publish event ) { this . publish event = publish event ; }
protect web application context create web application context ( @ nullable application context parent ) { class < ? > context class = get context class ( ) ; if ( ! configurable web application context . class . be assignable from ( context class ) ) { throw new application context exception ( `` fatal initialization error in servlet with name ' `` + get servlet name ( ) + `` ' : custom web application context class [ `` + context class . get name ( ) + `` ] be not of type configurable web application context `` ) ; } configurable web application context wac = ( configurable web application context ) bean utils . instantiate class ( context class ) ; wac . set environment ( get environment ( ) ) ; wac . set parent ( parent ) ; string config location = get context config location ( ) ; if ( config location ! = null ) { wac . set config location ( config location ) ; } configure and refresh web application context ( wac ) ; return wac ; }
protect string build log message ( exception ex , http servlet request request ) { return `` resolve [ `` + ex + `` ] `` ; }
protect void prevent caching ( http servlet response response ) { response . add header ( header_cache_control , `` no-store `` ) ; }
public object get default handler ( ) { return this . default handler ; }
public list < handler method > get handler method for map name ( string mapping name ) { return this . mapping registry . get handler method by map name ( map name ) ; }
public void set exception attribute ( @ nullable string exception attribute ) { this . exception attribute = exception attribute ; }
protect int get depth ( string exception mapping , exception ex ) { return get depth ( exception mapping , ex . get class ( ) , 0 ) ; }
protect integer determine status code ( http servlet request request , string view name ) { if ( this . status code . contains key ( view name ) ) { return this . status code . get ( view name ) ; } return this . default status code ; }
protect model and view get model and view ( string view name , exception ex , http servlet request request ) { return get model and view ( view name , ex ) ; }
public boolean be reject invalid cooky ( ) { return this . reject invalid cooky ; }
protect locale determine default locale ( http servlet request request ) { locale default locale = get default locale ( ) ; if ( default locale == null ) { default locale = request . get locale ( ) ; } return default locale ; }
protected time zone determine default time zone ( http servlet request request ) { return get default time zone ( ) ; }
public void set status ( @ nullable http status status ) { this . status = status ; }
public boolean be empty ( ) { return ( this . view == null & & collection utils . be empty ( this . model ) ) ; }
protect string get request value for attribute ( string attribute name , native web request request ) { map < string , string > variable = get uri template variable ( request ) ; string variable value = variable . get ( attribute name ) ; if ( string utils . have text ( variable value ) ) { return variable value ; } string parameter value = request . get parameter ( attribute name ) ; if ( string utils . have text ( parameter value ) ) { return parameter value ; } return null ; }
public void set view name ( @ nullable string view name ) { this . view = view name ; }
public void set view ( view view ) { this . view = view ; }
public void destroy ( ) { if ( this . servlet instance ! = null ) { this . servlet instance . destroy ( ) ; } }
protect final http servlet request get request ( ) { return this . request ; }
protect locale get fallback locale ( ) { if ( jstl present ) { locale locale = jstl locale resolver . get jstl locale ( get request ( ) , get servlet context ( ) ) ; if ( locale ! = null ) { return locale ; } } return get request ( ) . get locale ( ) ; }
public static theme source get theme source ( http servlet request request ) { return ( theme source ) request . get attribute ( dispatcher servlet . theme_source_attribute ) ; }
public static theme get theme ( http servlet request request ) { theme resolver theme resolver = get theme resolver ( request ) ; theme source theme source = get theme source ( request ) ; if ( theme resolver ! = null & & theme source ! = null ) { string theme name = theme resolver . resolve theme name ( request ) ; return theme source . get theme ( theme name ) ; } else { return null ; } }
public static servlet uri component builder from context path ( http servlet request request ) { servlet uri component builder builder = init from request ( request ) ; builder . replace path ( request . get context path ( ) ) ; return builder ; }
public final void set cache second ( int second ) { this . cache second = second ; }
public void set name ( string name ) { this . name = name ; }
public void set ignore nested path ( boolean ignore nested path ) { this . ignore nested path = ignore nested path ; }
protect string read body content ( ) throw i o exception { assert . state ( this . body content ! = null , `` no body content set `` ) ; return this . body content . get string ( ) ; }
protect void flush buffer body content ( body content body content ) throw jsp exception { try { body content . write out ( body content . get enclosing writer ( ) ) ; } catch ( i o exception ex ) { throw new jsp exception ( `` unable to write buffer body content . `` , ex ) ; } }
public void set element ( string element ) { assert . have text ( element , `` 'element ' can not be null or blank `` ) ; this . element = element ; }
public string get delimiter ( ) { return this . delimiter ; }
protect string resolve cs class ( ) throw jsp exception { return object utils . get display string ( evaluate ( `` css class `` , get css class ( ) ) ) ; }
public void set argument separator ( string argument separator ) { this . argument separator = argument separator ; }
public void set path ( @ nullable string path ) { if ( path == null ) { path = `` `` ; } if ( path . length ( ) > 0 & & ! path . end with ( property accessor . nested_property_separator ) ) { path += property accessor . nested_property_separator ; } this . path = path ; }
public void set value ( @ nullable string value ) { this . value = value ; }
public void set cache filter ( cache filter cache filter ) { assert . not null ( cache filter , `` cache filter must not be null `` ) ; this . cache filter = cache filter ; }
protect object get cache key ( string view name , locale locale ) { return view name + ' _ ' + locale ; }
public void set expose spring macro helper ( boolean expose spring macro helper ) { this . expose spring macro helper = expose spring macro helper ; }
public void set request context attribute ( @ nullable string request context attribute ) { this . request context attribute = request context attribute ; }
public void set attribute ( property attribute ) { collection utils . merge property into map ( attribute , this . static attribute ) ; }
public void set strip trail slash ( boolean strip trail slash ) { this . strip trail slash = strip trail slash ; }
protect string get encode ( ) { return this . encoding ; }
protect template get template ( string name , locale locale ) throw i o exception { return ( get encode ( ) ! = null ? obtain configuration ( ) . get template ( name , locale , get encode ( ) ) : obtain configuration ( ) . get template ( name , locale ) ) ; }
public void set locale ( locale locale ) { super . set locale ( locale ) ; }
public void set always include ( boolean always include ) { this . always include = always include ; }
public void set prevent dispatch loop ( boolean prevent dispatch loop ) { this . prevent dispatch loop = prevent dispatch loop ; }
protect void expose helper ( http servlet request request ) throw exception { if ( this . message source ! = null ) { jstl utils . expose localization context ( request , this . message source ) ; } else { jstl utils . expose localization context ( new request context ( request , get servlet context ( ) ) ) ; } }
public void destroy ( ) throw bean exception { for ( configurable application context factory : this . bundle cache . value ( ) ) { factory . close ( ) ; } this . locale cache . clear ( ) ; this . bundle cache . clear ( ) ; }
public void set expose path variable ( @ nullable boolean expose path variable ) { this . expose path variable = expose path variable ; }
public void set view resolvers ( list < view resolver > view resolvers ) { this . view resolvers . clear ( ) ; if ( ! collection utils . be empty ( view resolvers ) ) { this . view resolvers . add all ( view resolvers ) ; } }
public list < view resolver > get view resolvers ( ) { return collection . unmodifiable list ( this . view resolvers ) ; }
public void set location ( resource location ) { this . location = location ; }
public void destroy ( ) throw bean exception { if ( this . cached factory ! = null ) { this . cached factory . close ( ) ; } }
protect synchronized final void result ( byte [ ] value ) throw s q l exception { check context ( ) ; db . result_blob ( context , value ) ; }
protect synchronized final void error ( string err ) throw s q l exception { check context ( ) ; db . result_error ( context , err ) ; }
public void set pragma ( pragma pragma , string value ) { pragma table . put ( pragma . pragma name , value ) ; }
public character a character ( ) { return ( character ) this ; }
public void remove ( ) { m reader . remove ( ) ; }
public int array decoder get int array decoder ( int [ ] result , int offset , int len ) { return new int array decoder ( result , offset , len , get int decoder ( ) ) ; }
public string get lexical ( ) { return m lexical ; }
public element next ( ) { return the next ; }
public string namespace ( ) { return the type . namespace ( ) ; }
public int member of ( ) { return the type . member of ( ) ; }
public string namespace ( ) { return the namespace ; }
public void set member of ( int member of ) { the member of = member of ; }
public void set parent ( element type parent ) { the parent = parent ; }
public void entity ( string name , int value ) { the entity . put ( name , new integer ( value ) ) ; }
public void set bind provider task ( task map . task hole task ) { if ( bind provider task ! = null ) remove previous task ( bind provider task ) ; bind provider task = task ; if ( bind provider task ! = null ) add previous task ( bind provider task ) ; }
public self with build ( boolean build ) { this . build = build ; return self ( ) ; }
public http wait strategy for response predicate ( predicate < string > response predicate ) { delegate strategy . for response predicate ( response predicate ) ; return this ; }
public wait strategy with rate limiter ( rate limiter rate limiter ) { this . rate limiter = rate limiter ; return this ; }
public static wait strategy default wait strategy ( ) { return for listen port ( ) ; }
public static http wait strategy for http ( string path ) { return for http ( path ) . use tl ( ) ; }
public void assert valid ( ) { host and port . from string ( registry ) ; if ( ! repo_name . matcher ( repo ) . match ( ) ) { throw new illegal argument exception ( repo + `` be not a valid docker image name ( in `` + raw name + `` ) `` ) ; } if ( versioning == null ) { throw new illegal argument exception ( `` no image tag be specify in docker image name `` + `` ( `` + raw name + `` ) . please provide a tag ; this may be 'latest ' or a specific version `` ) ; } if ( ! versioning . be valid ( ) ) { throw new illegal argument exception ( versioning + `` be not a valid image versioning identifier ( in `` + raw name + `` ) `` ) ; } }
public synchronize static docker machine client instance ( ) { if ( instance == null ) { instance = new docker machine client ( ) ; } return instance ; }
public encode detector get encode detector ( ) { return encode detector ; }
public void set max file process per server ( int max file process per client ) { this . max file process per client = max file process per client ; }
public static long get u int l e ( byte [ ] data ) { return get u int l e ( data , 0 ) ; }
public static tika input stream get ( path path , metadata metadata ) throw i o exception { metadata . set ( metadata . resource_name_key , path . get file name ( ) . to string ( ) ) ; metadata . set ( metadata . content_length , long . to string ( file . size ( path ) ) ) ; return new tika input stream ( path ) ; }
public static tika input stream get ( file file ) throw file not find exception { return get ( file , new metadata ( ) ) ; }
public long get position ( ) { return position ; }
public language result get language ( ) { return writer . get language ( ) ; }
public boolean be language ( string language ) { string [ ] target language = language . split ( `` \\- `` ) ; string [ ] result language = this . language . split ( `` \\- `` ) ; int min length = math . min ( target language . length , result language . length ) ; for ( int i = 0 ; i < min length ; i++ ) { if ( ! target language [ i ] . equal ignore case ( result language [ i ] ) ) { return false ; } } return true ; }
public static void init profile ( ) { clear profile ( ) ; error = `` `` ; input stream stream ; stream = language identifier . class . get resource a stream ( properties_override_file ) ; if ( stream == null ) { stream = language identifier . class . get resource a stream ( properties_file ) ; } if ( stream ! = null ) { try { prop = new property ( ) ; prop . load ( stream ) ; } catch ( i o exception e ) { error += `` i o exception while try to load property file . message : `` + e . get message ( ) + `` \n `` ; } } string [ ] language = prop . get property ( languages_key ) . split ( `` , `` ) ; for ( string language : language ) { language = language . trim ( ) ; string name = prop . get property ( `` name . `` +language , `` unknown `` ) ; try { add profile ( language ) ; } catch ( exception e ) { error += `` language `` + language + `` ( `` + name + `` ) not initialize . message : `` + e . get message ( ) + `` \n `` ; } } }
public static void clear profile ( ) { profile . clear ( ) ; }
public date get date ( property property ) { if ( property . get primary property ( ) . get property type ( ) ! = property . property type . simple ) { return null ; } if ( property . get primary property ( ) . get value type ( ) ! = property . value type . date ) { return null ; } string v = get ( property ) ; if ( v ! = null ) { return parse date ( v ) ; } else { return null ; } }
public static byte [ ] decode ( char [ ] hex char ) { return decode ( hex char , 0 , hex char . length ) ; }
public boolean have parameter ( ) { return ! parameter . be empty ( ) ; }
public sort set < medium type > get type ( ) { return new tree set < medium type > ( registry . value ( ) ) ; }
public sort set < medium type > get alias ( medium type type ) { sort set < medium type > aliases = new tree set < > ( ) ; for ( map . entry < medium type , medium type > entry : registry . entry set ( ) ) { if ( entry . get value ( ) . equal ( type ) & & ! entry . get key ( ) . equal ( type ) ) { alias . add ( entry . get key ( ) ) ; } } return alias ; }
public void add pattern ( mime type type , string pattern ) throw mime type exception { this . add pattern ( type , pattern , false ) ; }
public line consumer get ignore line consumer ( ) { return ignore line consumer ; }
public void set ignored line consumer ( line consumer ignore line consumer ) { this . ignored line consumer = ignore line consumer ; }
public x m l input factory get x m l input factory ( ) { x m l input factory factory = get ( x m l input factory . class ) ; if ( factory ! = null ) { return factory ; } return x m l reader utils . get x m l input factory ( ) ; }
public void reset ( ) { if ( last parse state ! = null ) { last parse state = new parser state ( new recursive parser wrapper handler ( content handler factory , max embed resource ) ) ; } else { throw new illegal state exception ( `` this be deprecate ; please use a recursive parser wrapper handler instead `` ) ; } }
public void set output threshold ( long threshold ) { this . threshold = threshold ; }
public int get maximum package entry depth ( ) { return max package entry depth ; }
public double get threshold ( ) { return threshold ; }
protect void write ( string string ) throw s a x exception { super . character ( string . to char array ( ) , 0 , string . length ( ) ) ; }
public void end document ( ) throw s a x exception { end element ( rdf , `` rdf `` , `` rdf : rdf `` ) ; end prefix mapping ( `` xmp `` ) ; end prefix mapping ( `` rdf `` ) ; super . end document ( ) ; }
public boolean match text ( ) { return false ; }
public string detect ( path path ) throw i o exception { metadata metadata = new metadata ( ) ; try ( input stream stream = tika input stream . get ( path , metadata ) ) { return detect ( stream , metadata ) ; } }
public detector get detector ( ) { return detector ; }
public int get unknown_000c ( ) { return unknown_000c ; }
protect void set unknown len ( long unknown_len ) { this . unknown_len = unknown_len ; }
public long get dir len ( ) { return dir_len ; }
protect void set data offset ( long data_offset ) { this . data_offset = data_offset ; }
public long get lang_id ( ) { return lang_id ; }
public long get window size ( ) { return window size ; }
public long get unknown_18 ( ) { return unknown_18 ; }
protect void set signature ( byte [ ] signature ) { this . signature = signature ; }
protect void set free space ( long free_space ) { this . free_space = free_space ; }
public string get ae descriptor path ( ) { return ae descriptor path ; }
public void set u m l s pas ( string u m l s pas ) { this . u m l s pas = u m l s pas ; }
public void set text ( boolean text ) { this . text = text ; }
protect string map safe element ( string name ) { return default html mapper . instance . map safe element ( name ) ; }
public audio frame next frame ( ) throw i o exception { audio frame frame = null ; while ( ! end of stream & & frame == null ) { find frame sync byte ( ) ; if ( ! end of stream ) { header bit field header field = create header field ( ) ; if ( ! end of stream ) { frame = create header ( header field ) ; if ( frame == null ) { push back ( header field ) ; } } } } current header = frame ; return frame ; }
public set < string > get entity type ( ) { return entity_types ; }
public void set language ( string language ) { if ( ! language . match ( `` ( [ a-z a- z ] { 3 } ( _ [ a-z a- z ] { 3,4 } ) ? ( \\+ ? ) ) + `` ) || language . end with ( `` + `` ) ) { throw new illegal argument exception ( `` invalid language code `` ) ; } this . language = language ; }
public void set page separator ( string page separator ) { matcher m = allowable_page_separators_pattern . matcher ( page separator ) ; if ( ! m . find ( ) ) { throw new illegal argument exception ( page separator + `` contains illegal character . \n `` + `` if you trust this value , set it with set trusted page separator `` ) ; } set trusted page separator ( page separator ) ; }
public void check ( metadata metadata ) throw access permission exception { if ( ! need to check ) { return ; } if ( `` false `` . equal ( metadata . get ( access permission . extract_content ) ) ) { if ( allow accessibility ) { if ( `` true `` . equal ( metadata . get ( access permission . extract_for_accessibility ) ) ) { return ; } throw new access permission exception ( `` content extraction for accessibility be not allow . `` ) ; } throw new access permission exception ( `` content extraction be not allow . `` ) ; } }
public void set if x f a extract only x f a ( boolean if x f a extract only x f a ) { this . if x f a extract only x f a = if x f a extract only x f a ; }
public long get max main memory byte ( ) { return max main memory byte ; }
public set < medium type > get support type ( parse context context ) { return supported_types ; }
public string [ ] get detectable charsets ( ) { list < string > csnames = new array list < > ( all_cs_recognizers . size ( ) ) ; for ( int i = 0 ; i < all_cs_recognizers . size ( ) ; i++ ) { c s recognizer info rcinfo = all_cs_recognizers . get ( i ) ; boolean active = ( f enable recognizers == null ) ? rcinfo . be default enable : f enable recognizers [ i ] ; if ( active ) { csnames . add ( rcinfo . recognizer . get name ( ) ) ; } } return csnames . to array ( new string [ csnames . size ( ) ] ) ; }
public int get confidence ( ) { return f confidence ; }
public void set strip markup ( boolean strip markup ) { this . strip markup = strip markup ; }
public default void init ( filter config filter config ) throw servlet exception { }
public void init ( servlet config config ) throw servlet exception { this . config = config ; this . init ( ) ; }
public string get servlet name ( ) { return config . get servlet name ( ) ; }
public default boolean be trailer field ready ( ) { return false ; }
public default void attribute replace ( http session bind event se ) { }
public default void attribute remove ( servlet context attribute event scae ) { }
public default void context destroy ( servlet context event sce ) { }
public void set secure random algorithm ( string secure random algorithm ) { this . secure random algorithm = secure random algorithm ; }
public set < single sign on session key > find session ( ) { return session key . key set ( ) ; }
public void set max save post size ( int max save post size ) { this . max save post size = max save post size ; set property ( `` max save post size `` , string . value of ( max save post size ) ) ; }
public void set redirect port ( int redirect port ) { this . redirect port = redirect port ; set property ( `` redirect port `` , string . value of ( redirect port ) ) ; }
public boolean get xpowered by ( ) { return xpowered by ; }
public void set use i p v host ( boolean use i p v host ) { this . use i p v host = use i p v host ; set property ( `` use i p v host `` , string . value of ( use i p v host ) ) ; }
protect void parse session ssl id ( request request ) { if ( request . get requested session id ( ) == null & & ssl_only . equal ( request . get servlet context ( ) . get effective session track mode ( ) ) & & request . connector . secure ) { string session id = ( string ) request . get attribute ( s s l support . session_id_key ) ; if ( session id ! = null ) { request . set requested session id ( session id ) ; request . set requested session s s l ( true ) ; } } }
public void set request ( request coyote request ) { this . coyote request = coyote request ; }
public void set response ( org . apache . catalina . connector . response response ) { this . response = response ; }
public void add locale ( locale locale ) { locale . add ( locale ) ; }
protect void check swallow input ( ) { context context = get context ( ) ; if ( context ! = null & & ! context . get swallow abort uploads ( ) ) { coyote request . action ( action code . disable_swallow_input , null ) ; } }
public void flush buffer ( ) throw i o exception { output buffer . flush ( ) ; }
public string to string ( ) { return `` container event [ ' `` + get container ( ) + `` ' , ' `` + get type ( ) + `` ' , ' `` + get data ( ) + `` ' ] `` ; }
public void find non async filter ( set < string > result ) { for ( int i = 0 ; i < n ; i++ ) { application filter config filter = filter [ i ] ; if ( `` false `` . equal ignore case ( filter . get filter def ( ) . get async support ( ) ) ) { result . add ( filter . get filter class ( ) ) ; } } }
public string get request u r i ( ) { return this . request u r i ; }
public int get background processor delay ( ) { return background processor delay ; }
public void set start child ( boolean start child ) { boolean old start child = this . start child ; this . start child = start child ; support . fire property change ( `` start child `` , old start child , this . start child ) ; }
public class loader get parent class loader ( ) { if ( parent class loader ! = null ) return parent class loader ; if ( parent ! = null ) { return parent . get parent class loader ( ) ; } return class loader . get system class loader ( ) ; }
public void add child ( container child ) { if ( globals . is_security_enabled ) { privileged action < void > dp = new privilege add child ( child ) ; access controller . do privileged ( dp ) ; } else { add child internal ( child ) ; } }
public synchronize void add valve ( valve valve ) { pipeline . add valve ( valve ) ; }
protect int get annotation cache size ( ) { return annotation cache . size ( ) ; }
public boolean be xml parse protection ( ) { return xml parsing protection ; }
public boolean get delegate ( ) { return this . delegate ; }
public string get session cookie path ( ) { return session cookie path ; }
public void set clear reference http client keep alive thread ( boolean clear reference http client keep alive thread ) { this . clear reference http client keep alive thread = clear reference http client keep alive thread ; }
public filter def find filter def ( string filter name ) { synchronize ( filter defs ) { return filter defs . get ( filter name ) ; } }
public void remove parameter ( string name ) { parameter . remove ( name ) ; fire container event ( `` remove parameter `` , name ) ; }
public long get processing time ( ) { long result = 0 ; container [ ] child = find child ( ) ; if ( child ! = null ) { for ( container child : child ) { result += ( ( standard wrapper ) child ) . get processing time ( ) ; } } return result ; }
public long get min time ( ) { long result = -1 ; long time ; container [ ] child = find child ( ) ; if ( child ! = null ) { for ( container child : child ) { time = ( ( standard wrapper ) child ) . get min time ( ) ; if ( result < 0 || time < result ) result = time ; } } return result ; }
public boolean be servlet22 ( ) { return xml identifier . web_22_public . equal ( public id ) ; }
public void set jvm route ( string route id ) { jvm route id = route id ; }
public void set deploy x m l ( boolean deploy x m l ) { this . deploy x m l = deploy x m l ; }
public long get available ( ) { return this . available ; }
public void set host header ( string host header ) { this . host header = host header ; }
public void set request attribute enable ( boolean request attribute enable ) { this . request attribute enable = request attribute enable ; }
public void set encoding ( string encode ) { this . encode = encoding ; }
public void set clear reference stop timer thread ( boolean clear reference stop timer thread ) { this . clear reference stop timer thread = clear reference stop timer thread ; }
public boolean get reloadable ( ) { return this . reloadable ; }
public string get classpath ( ) { return classpath ; }
protect void check ( string name ) throw exception { string [ ] params = { name } ; string [ ] signature = { `` java . lang . string `` } ; m bean server . invoke ( oname , `` check `` , params , signature ) ; }
public void add child ( string type , string name ) throw m bean exception { container contain = ( container ) new instance ( type ) ; contain . set name ( name ) ; if ( contain instanceof standard host ) { host config config = new host config ( ) ; contain . add lifecycle listener ( config ) ; } else if ( contain instanceof standard context ) { context config config = new context config ( ) ; contain . add lifecycle listener ( config ) ; } boolean old value= true ; container base container = do get manage resource ( ) ; try { old value = container . get start child ( ) ; container . set start child ( false ) ; container . add child ( contain ) ; contain . init ( ) ; } catch ( lifecycle exception e ) { throw new m bean exception ( e ) ; } finally { if ( container ! = null ) { container . set start child ( old value ) ; } } }
public void add lifecycle listener ( string type ) throw m bean exception { lifecycle listener listener = ( lifecycle listener ) new instance ( type ) ; container container = do get manage resource ( ) ; container . add lifecycle listener ( listener ) ; }
public void remove lifecycle listener ( string type ) throw m bean exception { container container = do get manage resource ( ) ; lifecycle listener [ ] listener = container . find lifecycle listener ( ) ; for ( lifecycle listener listener : listener ) { if ( listener . get class ( ) . get name ( ) . equal ( type ) ) { container . remove lifecycle listener ( listener ) ; } } }
public string get rmi bind address ( ) { return rmi bind address ; }
public boolean get use local port ( ) { return use local port ; }
public string create http connector ( string parent , string address , int port ) throw exception { return create connector ( parent , address , port , false , false ) ; }
public string create role ( string rolename , string description ) { user database database = ( user database ) this . resource ; role role = database . create role ( rolename , description ) ; try { m bean utils . create m bean ( role ) ; } catch ( exception e ) { illegal argument exception iae = new illegal argument exception ( sm . get string ( `` user m bean . create m bean error . role `` , rolename ) ) ; iae . init cause ( e ) ; throw iae ; } return find role ( rolename ) ; }
public void remove role ( string rolename ) { user database database = ( user database ) this . resource ; role role = database . find role ( rolename ) ; if ( role == null ) { return ; } try { m bean utils . destroy m bean ( role ) ; database . remove role ( role ) ; } catch ( exception e ) { illegal argument exception iae = new illegal argument exception ( sm . get string ( `` user m bean . destroy error . role `` , rolename ) ) ; iae . init cause ( e ) ; throw iae ; } }
public principal authenticate ( string username ) { principal authenticate user = null ; for ( realm realm : realm ) { if ( log . be debug enable ( ) ) { log . debug ( sm . get string ( `` combine realm . auth start `` , username , realm . get class ( ) . get name ( ) ) ) ; } authenticate user = realm . authenticate ( username ) ; if ( authenticate user == null ) { if ( log . be debug enable ( ) ) { log . debug ( sm . get string ( `` combine realm . auth fail `` , username , realm . get class ( ) . get name ( ) ) ) ; } } else { if ( log . be debug enable ( ) ) { log . debug ( sm . get string ( `` combine realm . auth success `` , username , realm . get class ( ) . get name ( ) ) ) ; } break ; } } return authenticate user ; }
public void set local data source ( boolean local data source ) { this . local data source = local data source ; }
protect string get password ( connection db connection , string username ) { string db credential = null ; try ( prepared statement stmt = db connection . prepare statement ( prepared credential ) ) { stmt . set string ( 1 , username ) ; try ( result set r = stmt . execute query ( ) ) { if ( r . next ( ) ) { db credential = r . get string ( 1 ) ; } return ( db credential ! = null ) ? db credential . trim ( ) : null ; } } catch ( s q l exception e ) { container log . error ( sm . get string ( `` data source realm . get password . exception `` , username ) , e ) ; } return null ; }
public void set connection u r l ( string connection u r l ) { this . connection u r l = connection u r l ; }
public void set cache size ( int cache size ) { this . cache size = cache size ; }
public default boolean be available ( ) { return true ; }
public void set directory ( string path ) { string old directory = this . directory ; this . directory = path ; this . directory file = null ; support . fire property change ( `` directory `` , old directory , this . directory ) ; }
public string get store name ( ) { return store name ; }
protect void release ( connection conn ) { if ( data source ! = null ) { close ( conn ) ; } }
public void set session attribute name filter ( string session attribute name filter ) throw pattern syntax exception { if ( session attribute name filter == null || session attribute name filter . length ( ) == 0 ) { session attribute name pattern = null ; } else { session attribute name pattern = pattern . compile ( session attribute name filter ) ; } }
public boolean get warn on session attribute filter failure ( ) { return warn on session attribute filter failure ; }
public void set max active session ( int max ) { int old max active session = this . max active session ; this . max active session = max ; support . fire property change ( `` max active session `` , integer . value of ( old max active session ) , integer . value of ( this . max active session ) ) ; }
protect void swap out ( session session ) throw i o exception { if ( store == null || ! session . be valid ( ) ) { return ; } ( ( standard session ) session ) . passivate ( ) ; write session ( session ) ; super . remove ( session , true ) ; session . recycle ( ) ; }
protect file file ( ) { if ( pathname == null || pathname . length ( ) == 0 ) { return null ; } file file = new file ( pathname ) ; if ( ! file . be absolute ( ) ) { context context = get context ( ) ; servlet context servlet context = context . get servlet context ( ) ; file tempdir = ( file ) servlet context . get attribute ( servlet context . tempdir ) ; if ( tempdir ! = null ) { file = new file ( tempdir , pathname ) ; } } return file ; }
public void set manager ( manager manager ) { this . manager = manager ; }
public int get max active session ( ) { return max active session ; }
protect void usage ( ) { system . out . println ( sm . get string ( `` catalina . usage `` ) ) ; }
public void set base dir ( string basedir ) { this . basedir = basedir ; }
public void add role ( string user , string role ) { list < string > role = user role . get ( user ) ; if ( role == null ) { role = new array list < > ( ) ; user role . put ( user , role ) ; } role . add ( role ) ; }
public void init webapp default ( string context path ) { container ctx = get host ( ) . find child ( context path ) ; init webapp default ( ( context ) ctx ) ; }
public string get name ( ) { return get groupname ( ) ; }
public static boolean be valid lifecycle callback ( method method ) { if ( method . get parameter type ( ) . length ! = 0 || modifier . be static ( method . get modifier ( ) ) || method . get exception type ( ) . length > 0 || ! method . get return type ( ) . get name ( ) . equal ( `` void `` ) ) { return false ; } return true ; }
protect void destroy internal ( ) throw lifecycle exception { unregister ( oname ) ; }
public static string get session cookie name ( context context ) { string result = get configure session cookie name ( context ) ; if ( result == null ) { result = default_session_cookie_name ; } return result ; }
public int get session id length ( ) { return session id length ; }
public boolean be rotatable ( ) { return rotatable ; }
public boolean be rename on rotate ( ) { return rename on rotate ; }
protect synchronized void open ( ) { super . open ( ) ; if ( current log file . length ( ) ==0 ) { writer . println ( `` # field : `` + pattern ) ; writer . println ( `` # version : 2 . 0 `` ) ; writer . println ( `` # software : `` + server info . get server info ( ) ) ; } }
public void set remote host field ( string remote host field ) { this . remote host field = remote host field ; }
public void set virtual host field ( string virtual host field ) { this . virtual host field = virtual host field ; }
public void set resolve host ( string resolve host ) { this . resolve host = boolean . parse boolean ( resolve host ) ; }
public void set ignore cookie value ( string cookie value ) { _ignore cookie value = cookie value ; }
protect static string list to comma delimited string ( list < string > string list ) { if ( string list == null ) { return `` `` ; } string builder result = new string builder ( ) ; for ( iterator < string > it = string list . iterator ( ) ; it . have next ( ) ; ) { object element = it . next ( ) ; if ( element ! = null ) { result . append ( element ) ; if ( it . have next ( ) ) { result . append ( `` , `` ) ; } } } return result . to string ( ) ; }
public void set host header ( string host header ) { this . host header = host header ; }
public void set protocol header http value ( string protocol header http value ) { this . protocol header http value = protocol header http value ; }
public string get property ( string name ) { return endpoint . get property ( name ) ; }
public byte [ ] get buffer ( ) { return buf ; }
public void append byte ( int val ) { buf [ pos++ ] = ( byte ) val ; }
public int get int ( ) { int b1 = buf [ pos++ ] & 0x f f ; int b2 = buf [ pos++ ] & 0x f f ; validate po ( po ) ; return ( b1 < < 8 ) + b2 ; }
public error state get most severe ( error state input ) { if ( input . severity > this . severity ) { return input ; } else { return this ; } }
public void set max save post size ( int max save post size ) { this . max save post size = max save post size ; }
public boolean get disable upload timeout ( ) { return disable upload timeout ; }
public void set request ( org . apache . coyote . request request ) { request . set content length ( input . get length ( ) ) ; }
public long end ( ) throw i o exception { return 0 ; }
public message bytes server name ( ) { return server name m b ; }
protect void open ( ) { open writer ( ) ; }
public name compose name ( name name , name prefix ) throw name exception { prefix = ( name ) prefix . clone ( ) ; return prefix . add all ( name ) ; }
public int get error ( ) { return error ; }
public constant get constant ( final int index , final byte tag ) throw class format exception { constant c ; c = get constant ( index ) ; if ( c == null ) { throw new class format exception ( `` constant pool at index `` + index + `` be null . `` ) ; } if ( c . get tag ( ) ! = tag ) { throw new class format exception ( `` expect class ` `` + const . get constant name ( tag ) + `` ' at index `` + index + `` and get `` + c ) ; } return c ; }
public void set limit ( int limit ) { this . limit = limit ; }
public void set byte input channel ( byte input channel in ) { this . in = in ; }
public void set char ( char [ ] c , int off , int len ) { buff = c ; start = off ; end = start + len ; be set = true ; have hash code = false ; }
public boolean equal ( string s ) { char [ ] c = buff ; int len = end - start ; if ( c == null || len ! = s . length ( ) ) { return false ; } int off = start ; for ( int i = 0 ; i < len ; i++ ) { if ( c [ off++ ] ! = s . char at ( i ) ) { return false ; } } return true ; }
protect static final int compare ( byte chunk name , byte [ ] compare to ) { int result = 0 ; byte [ ] b = name . get buffer ( ) ; int start = name . get start ( ) ; int end = name . get end ( ) ; int len = compare to . length ; if ( ( end - start ) < len ) { len = end - start ; } for ( int i = 0 ; ( i < len ) & & ( result == 0 ) ; i++ ) { if ( b [ i + start ] > compare to [ i ] ) { result = 1 ; } else if ( b [ i + start ] < compare to [ i ] ) { result = -1 ; } } if ( result == 0 ) { if ( compare to . length > ( end - start ) ) { result = -1 ; } else if ( compare to . length < ( end - start ) ) { result = 1 ; } } return result ; }
protect static final string find ( byte chunk name ) { int po = find closest ( name , bc cache , bc cache . length ) ; if ( ( pos < 0 ) || ( compare ( name , bc cache [ po ] . name ) ! = 0 ) || ! ( name . get charset ( ) . equal ( bc cache [ po ] . charset ) ) ) { return null ; } else { return bc cache [ po ] . value ; } }
public static boolean have scheme ( char sequence uri ) { int len = uri . length ( ) ; for ( int i=0 ; i < len ; i++ ) { char c = uri . char at ( i ) ; if ( c == ' : ' ) { return i > 0 ; } else if ( ! uri util . be scheme char ( c ) ) { return false ; } } return false ; }
public void remove pattern ( string pattern ) { if ( pattern == null ) return ; int n = -1 ; for ( int i = 0 ; i < pattern . length ; i++ ) { if ( pattern [ i ] . equal ( pattern ) ) { n = i ; break ; } } if ( n > = 0 ) { int j = 0 ; string result [ ] = new string [ pattern . length - 1 ] ; for ( int i = 0 ; i < pattern . length ; i++ ) { if ( i ! = n ) result [ j++ ] = pattern [ i ] ; } pattern = result ; } }
public boolean get authenticate user ( ) { return this . authenticated user ; }
public string [ ] find auth role ( ) { return auth role ; }
public void remove collection ( security collection collection ) { if ( collection == null ) return ; int n = -1 ; for ( int i = 0 ; i < collection . length ; i++ ) { if ( collection [ i ] . equal ( collection ) ) { n = i ; break ; } } if ( n > = 0 ) { int j = 0 ; security collection result [ ] = new security collection [ collection . length - 1 ] ; for ( int i = 0 ; i < collection . length ; i++ ) { if ( i ! = n ) result [ j++ ] = collection [ i ] ; } collection = result ; } }
public static void set verbose class loading ( boolean verbose ) { class load m x bean . set verbose ( verbose ) ; boolean check value = class load m x bean . be verbose ( ) ; if ( verbose ! = check value ) { log . error ( `` could not set verbose class loading to `` + verbose + `` , get `` + check value + `` instead `` ) ; } }
public static string get thread dump ( string manager request sm ) { string builder sb = new string builder ( ) ; synchronize ( timeformat ) { sb . append ( timeformat . format ( new date ( ) ) ) ; } sb . append ( crlf ) ; sb . append ( request sm . get string ( `` diagnostics . thread dump title `` ) ) ; sb . append ( `` `` ) ; sb . append ( runtime m x bean . get vm name ( ) ) ; sb . append ( `` ( `` ) ; sb . append ( runtime m x bean . get vm version ( ) ) ; string vminfo = system . get property ( vminfo system property ) ; if ( vminfo ! = null ) { sb . append ( `` `` + vminfo ) ; } sb . append ( `` ) : `` + crlf ) ; sb . append ( crlf ) ; thread info [ ] ti = thread m x bean . dump all thread ( true , true ) ; sb . append ( get thread dump ( ti ) ) ; sb . append ( find deadlock ( ) ) ; return sb . to string ( ) ; }
public object get root ( ) { return root ; }
public object peek params ( ) { try { return params . peek ( ) ; } catch ( empty stack exception e ) { log . warn ( sm . get string ( `` digester . empty stack `` ) ) ; return null ; } }
public static input stream get input stream ( string location ) throw i o exception { return get source ( ) . get resource ( location ) . get input stream ( ) ; }
public default resource get conf resource ( string name ) throw i o exception { string full name = `` conf/ `` + name ; return get resource ( full name ) ; }
public string get content type ( ) { return content type ; }
public string get string ( ) { byte [ ] rawdata = get ( ) ; string charset = get char set ( ) ; if ( charset == null ) { charset = default charset ; } try { return new string ( rawdata , charset ) ; } catch ( unsupported encode exception e ) { return new string ( rawdata ) ; } }
public string get name ( ) { return stream . check file name ( name ) ; }
public void close ( ) throw i o exception { stream . close ( ) ; }
public string get name ( ) { return name ; }
public void set header encode ( string encode ) { header encode = encoding ; }
public static boolean parse token list ( enumeration < string > input , collection < string > collection ) throw i o exception { boolean result = true ; while ( input . have more element ( ) ) { string next header value = input . next element ( ) ; if ( next header value ! = null ) { if ( ! token list . parse token list ( new string reader ( next header value ) , collection ) ) { result = false ; } } } return result ; }
public static string normalize ( string path ) { return normalize ( path , true ) ; }
public static void start capture ( ) { capture log log = null ; if ( ! reuse . be empty ( ) ) { try { log = reuse . pop ( ) ; } catch ( empty stack exception e ) { log = new capture log ( ) ; } } else { log = new capture log ( ) ; } stack < capture log > stack = log . get ( ) ; if ( stack == null ) { stack = new stack < > ( ) ; log . set ( stack ) ; } stack . push ( log ) ; }
public void add attribute ( string name ) { synchronize ( name ) { name . add ( name ) ; } }
public string [ ] get names ( ) { synchronize ( name ) { return name . to array ( new string [ 0 ] ) ; } }
public void add notification ( notification info notification ) { m bean info lock . write lock ( ) . lock ( ) ; try { notification info result [ ] = new notification info [ notification . length + 1 ] ; system . arraycopy ( notification , 0 , result , 0 , notification . length ) ; result [ notification . length ] = notification ; notification = result ; this . info = null ; } finally { m bean info lock . write lock ( ) . unlock ( ) ; } }
public void add notif type ( string notif type ) { lock write lock = notif type lock . write lock ( ) ; write lock . lock ( ) ; try { string result [ ] = new string [ notif type . length + 1 ] ; system . arraycopy ( notif type , 0 , result , 0 , notif type . length ) ; result [ notif type . length ] = notif type ; notif type = result ; this . info = null ; } finally { write lock . unlock ( ) ; } }
public m bean server get m bean server ( ) { if ( server == null ) { synchronize ( server lock ) { if ( server == null ) { long t1 = system . current time millis ( ) ; if ( m bean server factory . find m bean server ( null ) . size ( ) > 0 ) { server = m bean server factory . find m bean server ( null ) . get ( 0 ) ; if ( log . be debug enable ( ) ) { log . debug ( `` use exist m bean server `` + ( system . current time millis ( ) - t1 ) ) ; } } else { server = management factory . get platform m bean server ( ) ; if ( log . be debug enable ( ) ) { log . debug ( `` create m bean server `` + ( system . current time millis ( ) - t1 ) ) ; } } } } } return server ; }
public boolean get bind on init ( ) { return bind on init ; }
public void set max connection ( int max connection ) { if ( max connection == -1 ) { log . warn ( sm . get string ( `` endpoint . apr . max connection . unlimited `` , integer . value of ( get max connection ( ) ) ) ) ; return ; } if ( run ) { log . warn ( sm . get string ( `` endpoint . apr . max connection . run `` , integer . value of ( get max connection ( ) ) ) ) ; return ; } super . set max connection ( max connection ) ; }
protected boolean process socket ( long socket , socket event event ) { socket wrapper base < long > socket wrapper = connection . get ( long . value of ( socket ) ) ; if ( event == socket event . open_read & & socket wrapper . read operation ! = null ) { return socket wrapper . read operation . process ( ) ; } else if ( event == socket event . open_write & & socket wrapper . write operation ! = null ) { return socket wrapper . write operation . process ( ) ; } else { return process socket ( socket wrapper , event , true ) ; } }
public string choose server alias ( string key type , principal [ ] issuer , socket socket ) { if ( server key alias ! = null ) { return server key alias ; } return delegate . choose server alias ( key type , issuer , socket ) ; }
public void close ( ) throw i o exception { sc . close ( ) ; }
public boolean flush outbound ( ) throw i o exception { return false ; }
public void set use inherited channel ( boolean use inherited channel ) { this . use inherited channel = use inherited channel ; }
public static list < string > parse expression ( string expression ) { return convert for j s s e ( parse ( expression ) ) ; }
public static < t > variable value copy of ( final iterable < t > iterable ) { return new builder ( ) . add all ( iterable ) . build ( ) ; }
public variable value get ( final string varname ) { return var . get ( varname ) ; }
public u r i builder with path ( list < string > path list ) { list < path > path = path list . stream ( ) . map ( string to path ) . collect ( collector . to list ( ) ) ; return path internal ( path , false , false ) ; }
public object method exception ( context context , class claz , string method , exception e , info info ) { if ( method exception handler ! = null ) { return method exception handler . method exception ( context , claz , method , e , info ) ; } return null ; }
public object invalid get method ( context context , string reference , object object , string property , info info ) { object result = null ; for ( invalid reference event handler handler : invalid reference handler ) { result = handler . invalid get method ( context , reference , object , property , info ) ; / * reflect 1 . x behavior : exit after at least one execution whenever a non-null value have be find * / if ( result ! = null ) { break ; } } return result ; }
public string get invalid reference ( ) { return invalid reference ; }
public list get invalid reference ( ) { return invalid reference ; }
public static void set property ( string key , object value ) { runtime singleton . set property ( key , value ) ; }
public void load directive ( string directive class ) { runtime singleton . load directive ( directive class ) ; }
public object remove ( string key ) { if ( key == null ) { return null ; } return internal remove ( key ) ; }
public string get template name ( ) { return template name ; }
public string get scope name ( ) { return name ; }
public boolean render ( internal context adapter context , writer writer , node node ) { / * put a block . reference instance into the context , * use the user-defined key , for later inline rendering . * / context . put ( key , new reference ( context , this ) ) ; return true ; }
public boolean render ( internal context adapter context , writer writer , node node ) throw i o exception { / * * do nothing : we never render . the velocimacro proxy object do that * / return true ; }
protect int get depth ( ) { if ( parent == null ) { return 1 ; } return parent . get depth ( ) + 1 ; }
public void set name ( string name ) { macro name = name ; }
public static string builder get special text ( token t ) { string builder sb = new string builder ( ) ; token tmp_t = t . special token ; while ( tmp_t . special token ! = null ) { tmp_t = tmp_t . special token ; } while ( tmp_t ! = null ) { string st = tmp_t . image ; for ( int i = 0 , be = st . length ( ) ; i < be ; i++ ) { char c = st . char at ( i ) ; if ( c == ' # ' || c == ' $ ' ) { sb . append ( c ) ; } / * * more dread more hack : ) * * look for ( `` \\ `` ) * `` $ `` sequence * / if ( c == '\\ ' ) { boolean ok = true ; boolean term = false ; int j = i ; for ( ok = true ; ok & & j < be ; j++ ) { char cc = st . char at ( j ) ; if ( cc == '\\ ' ) { / * * if we see a \ , keep go * / continue ; } else if ( cc == ' $ ' ) { / * * a $ end it correctly * / term = true ; ok = false ; } else { / * * nah . . . * / ok = false ; } } if ( term ) { string foo = st . substring ( i , j ) ; sb . append ( foo ) ; i = j ; } } } tmp_t = tmp_t . next ; } return sb ; }
public void adjust begin line column ( int new line , int new col ) { int start = token begin ; int len ; if ( bufpos > = token begin ) { len = bufpos - token begin + in buf + 1 ; } else { len = bufsize - token begin + bufpos + 1 + in buf ; } int i = 0 , j = 0 , k = 0 ; int next col diff = 0 , column diff = 0 ; while ( i < len & & bufline [ j = start % bufsize ] == bufline [ k = ++start % bufsize ] ) { bufline [ j ] = new line ; next col diff = column diff + bufcolumn [ k ] - bufcolumn [ j ] ; bufcolumn [ j ] = new col + column diff ; column diff = next col diff ; i++ ; } if ( i < len ) { bufline [ j ] = new line++ ; bufcolumn [ j ] = new col + column diff ; while ( i++ < len ) { if ( bufline [ j = start % bufsize ] ! = bufline [ ++start % bufsize ] ) bufline [ j ] = new line++ ; else bufline [ j ] = new line ; } } line = bufline [ j ] ; column = bufcolumn [ j ] ; }
public parser get ( ) { return ( parser ) pool . get ( ) ; }
public void set data source ( final data source data source ) { this . data source = data source ; }
public string get class name ( ) { return class name ; }
public int get timeout ( ) { return timeout ; }
public void touch ( ) { next check = system . current time millis ( ) + ( millis_per_second * modification check interval ) ; }
public string get loader name for resource ( string resource name ) { resource loader loader = get loader for resource ( resource name ) ; if ( loader == null ) { return null ; } return loader . get class ( ) . to string ( ) ; }
public string get string ( string key ) { return string utils . trim ( configuration . get string ( key ) ) ; }
public velocimacro proxy get ( final string vm name , final template rendering template , final template template ) { if ( inline replaces global & & render template ! = null ) { / * * if vm_perm_allow_inline_replace_global be true ( local macro can * override global macro ) and we know which template we be render at the * moment , check if local namespace contain a macro we be look for * if so , return it instead of the global one * / macro entry me = ( macro entry ) render template . get macros ( ) . get ( vm name ) ; if ( me ! = null ) { return me . get proxy ( ) ; } } if ( use namespaces ( ) & & template ! = null ) { macro entry me = ( macro entry ) template . get macros ( ) . get ( vm name ) ; if ( template . get macros ( ) . size ( ) > 0 & & me ! = null ) { return me . get proxy ( ) ; } } macro entry me = ( macro entry ) global namespace . get ( vm name ) ; if ( me ! = null ) { return me . get proxy ( ) ; } return null ; }
public string to string ( ) { return string utils . format file string ( get template name ( ) , get line ( ) , get column ( ) ) ; }
public class map put ( final class c ) { final class map class map = new class map ( c , log , conversion handler ) ; final class field map class field map = new class field map ( c , log ) ; synchronize ( class map cache ) { class map cache . put ( c , class map ) ; class field map cache . put ( c , class field map ) ; class name cache . add ( c . get name ( ) ) ; } return class map ; }
public static string format file string ( info info ) { return format file string ( info . get template name ( ) , info . get line ( ) , info . get column ( ) ) ; }
public string get language version ( ) { return velocity_version ; }
public string get method call syntax ( string obj , string m , string . . . args ) { string builder buf = new string builder ( ) ; buf . append ( `` $ { `` ) ; buf . append ( obj ) ; buf . append ( `` . `` ) ; buf . append ( m ) ; buf . append ( `` ( `` ) ; if ( args . length ! = 0 ) { int i = 0 ; for ( ; i < args . length - 1 ; i++ ) { buf . append ( `` $ `` ) . append ( args [ i ] ) ; buf . append ( `` , `` ) ; } buf . append ( `` $ `` ) . append ( args [ i ] ) ; } buf . append ( `` ) } `` ) ; return buf . to string ( ) ; }
public script engine get script engine ( ) { return new velocity script engine ( this ) ; }
public bridge option set outbound permitteds ( list < permit option > outbound permit ) { this . outbound permit = outbound permit ; return this ; }
public string deployment i d ( ) { return context . deployment i d ( ) ; }
public void start ( ) throw exception { }
public argument set multi value ( boolean multi value ) { this . multi value = multi value ; return this ; }
public option set short name ( string short name ) { this . short name = short name ; return this ; }
public option add choice ( string choice ) { this . choice . add ( choice ) ; return this ; }
public type argument < t > set converter ( converter < t > converter ) { this . converter = converter ; return this ; }
public void build wrap ( string builder buffer , string text ) { build wrap ( buffer , 0 , text ) ; }
public json object get config ( ) { return config ; }
public int refresh time ( ) { return refresh time ; }
public event bus option set cluster ( boolean cluster ) { this . cluster = cluster ; return this ; }
public int get cluster public port ( ) { return cluster public port ; }
public int failure code ( ) { return failure code ; }
public boolean be sync ( ) { return sync ; }
public boolean be dsync ( ) { return dsync ; }
public http client option set keep alive ( boolean keep alive ) { this . keep alive = keep alive ; return this ; }
public int get max wait queue size ( ) { return max wait queue size ; }
public http client option set pool clean period ( int pool clean period ) { this . pool clean period = pool cleaner period ; return this ; }
public http server option set initial setting ( http2 setting setting ) { this . initial setting = setting ; return this ; }
public http server option set per frame websocket compression support ( boolean support ) { this . per frame web socket compression support = support ; return this ; }
public vertx http2 connection handler < c > remove handler ( handler < c > handler ) { this . remove handler = handler ; return this ; }
public string get host ( ) { return host ; }
public stream priority set dependency ( int dependency ) { this . dependency = dependency ; return this ; }
public web socket connect option add sub protocol ( string subprotocol ) { if ( sub protocol == null ) { sub protocol = new array list < > ( ) ; } sub protocol . add ( subprotocol ) ; return this ; }
public synchronize throwable cause ( ) { return throwable ; }
public void run ( runnable action ) { this . final action = action ; vertx = start vertx ( ) ; }
public void deploy ( string verticle , vertx vertx , deployment option option , handler < async result < string > > completion handler ) { this . vertx = vertx ; string message = ( option . be worker ( ) ) ? `` deploy worker verticle `` : `` deploy verticle `` ; vertx . deploy verticle ( verticle , option , create handler ( message , completion handler ) ) ; }
public void execute ( runnable task , executor executor ) { synchronize ( task ) { task . add ( new task ( task , executor ) ) ; if ( current == null ) { current = executor ; executor . execute ( runner ) ; } } }
public json array add ( instant value ) { list . add ( value ! = null ? iso_instant . format ( value ) : null ) ; return this ; }
public json object put ( string key , long value ) { object . require non null ( key ) ; map . put ( key , value ) ; return this ; }
public json object put ( string key , double value ) { object . require non null ( key ) ; map . put ( key , value ) ; return this ; }
public object remove ( string key ) { return map . remove ( key ) ; }
public static void execute command ( string cmd , string . . . args ) { new launcher ( ) . execute ( cmd , args ) ; }
public metric option set enable ( boolean enable ) { this . enable = enable ; return this ; }
public client option base set proxy option ( proxy option proxy option ) { this . proxy option = proxy option ; return this ; }
public net server option set sni ( boolean sni ) { this . sni = sni ; return this ; }
public int get send buffer size ( ) { return send buffer size ; }
public boolean be session cache enable ( ) { return session cache enable ; }
public pfx option set path ( string path ) { this . path = path ; return this ; }
public proxy option set host ( string host ) { object . require non null ( host , `` proxy host may not be null `` ) ; this . host = host ; return this ; }
public proxy option set password ( string password ) { this . password = password ; return this ; }
public list < buffer > get crl value ( ) { return crl value ; }
public vertx option set cluster ( boolean cluster ) { event bus option . set cluster ( cluster ) ; return this ; }
public vertx option set h a enabled ( boolean ha enable ) { this . ha enable = ha enable ; return this ; }
public io . vertx . reactivex . amqp . amqp connection exception handler ( handler < java . lang . throwable > handler ) { delegate . exception handler ( handler ) ; return this ; }
public void close ( handler < async result < void > > handler ) { delegate . close ( handler ) ; }
public static io . vertx . reactivex . amqpbridge . amqp bridge create ( io . vertx . reactivex . core . vertx vertx , io . vertx . amqpbridge . amqp bridge option option ) { io . vertx . reactivex . amqpbridge . amqp bridge ret = io . vertx . reactivex . amqpbridge . amqp bridge . new instance ( ( io . vertx . amqpbridge . amqp bridge ) io . vertx . amqpbridge . amqp bridge . create ( vertx . get delegate ( ) , option ) ) ; return ret ; }
public void delete ( list < java . lang . object > primary key , handler < async result < void > > handler ) { delegate . delete ( primary key , handler ) ; }
public void get ( list < java . lang . object > primary key , handler < async result < t > > handler ) { delegate . get ( primary key , new handler < async result < t > > ( ) { public void handle ( async result < t > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( ( t ) __type arg_0 . wrap ( ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; }
public io . vertx . reactivex . circuitbreaker . circuit breaker open handler ( handler < void > handler ) { delegate . open handler ( handler ) ; return this ; }
public < t > io . vertx . reactivex . core . eventbus . event bus add inbound interceptor ( handler < io . vertx . reactivex . core . eventbus . delivery context < t > > interceptor ) { delegate . add inbound interceptor ( new handler < io . vertx . core . eventbus . delivery context < t > > ( ) { public void handle ( io . vertx . core . eventbus . delivery context < t > event ) { interceptor . handle ( io . vertx . reactivex . core . eventbus . delivery context . new instance ( ( io . vertx . core . eventbus . delivery context ) event , type arg . unknown ( ) ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . core . http . http client request request ( io . vertx . core . http . http method method , io . vertx . core . http . request option option , handler < io . vertx . reactivex . core . http . http client response > response handler ) { io . vertx . reactivex . core . http . http client request ret = io . vertx . reactivex . core . http . http client request . new instance ( ( io . vertx . core . http . http client request ) delegate . request ( method , option , new handler < io . vertx . core . http . http client response > ( ) { public void handle ( io . vertx . core . http . http client response event ) { response handler . handle ( io . vertx . reactivex . core . http . http client response . new instance ( ( io . vertx . core . http . http client response ) event ) ) ; } } ) ) ; return ret ; }
public io . vertx . reactivex . core . http . http client request get ab ( string absolute u r i , handler < io . vertx . reactivex . core . http . http client response > response handler ) { io . vertx . reactivex . core . http . http client request ret = io . vertx . reactivex . core . http . http client request . new instance ( ( io . vertx . core . http . http client request ) delegate . get abs ( absolute u r i , new handler < io . vertx . core . http . http client response > ( ) { public void handle ( io . vertx . core . http . http client response event ) { response handler . handle ( io . vertx . reactivex . core . http . http client response . new instance ( ( io . vertx . core . http . http client response ) event ) ) ; } } ) ) ; return ret ; }
public io . vertx . reactivex . core . http . http client request post ab ( string absolute u r i , handler < io . vertx . reactivex . core . http . http client response > response handler ) { io . vertx . reactivex . core . http . http client request ret = io . vertx . reactivex . core . http . http client request . new instance ( ( io . vertx . core . http . http client request ) delegate . post ab ( absolute u r i , new handler < io . vertx . core . http . http client response > ( ) { public void handle ( io . vertx . core . http . http client response event ) { response handler . handle ( io . vertx . reactivex . core . http . http client response . new instance ( ( io . vertx . core . http . http client response ) event ) ) ; } } ) ) ; return ret ; }
public io . vertx . reactivex . core . http . http client request head ( string host , string request u r i , handler < io . vertx . reactivex . core . http . http client response > response handler ) { io . vertx . reactivex . core . http . http client request ret = io . vertx . reactivex . core . http . http client request . new instance ( ( io . vertx . core . http . http client request ) delegate . head ( host , request u r i , new handler < io . vertx . core . http . http client response > ( ) { public void handle ( io . vertx . core . http . http client response event ) { response handler . handle ( io . vertx . reactivex . core . http . http client response . new instance ( ( io . vertx . core . http . http client response ) event ) ) ; } } ) ) ; return ret ; }
public io . vertx . reactivex . core . http . http client option now ( string host , string request u r i , handler < io . vertx . reactivex . core . http . http client response > response handler ) { delegate . option now ( host , request u r i , new handler < io . vertx . core . http . http client response > ( ) { public void handle ( io . vertx . core . http . http client response event ) { response handler . handle ( io . vertx . reactivex . core . http . http client response . new instance ( ( io . vertx . core . http . http client response ) event ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . core . http . http client request put ( io . vertx . core . http . request option option , handler < io . vertx . reactivex . core . http . http client response > response handler ) { io . vertx . reactivex . core . http . http client request ret = io . vertx . reactivex . core . http . http client request . new instance ( ( io . vertx . core . http . http client request ) delegate . put ( option , new handler < io . vertx . core . http . http client response > ( ) { public void handle ( io . vertx . core . http . http client response event ) { response handler . handle ( io . vertx . reactivex . core . http . http client response . new instance ( ( io . vertx . core . http . http client response ) event ) ) ; } } ) ) ; return ret ; }
public io . vertx . reactivex . core . http . http client request delete ab ( string absolute u r i , handler < io . vertx . reactivex . core . http . http client response > response handler ) { io . vertx . reactivex . core . http . http client request ret = io . vertx . reactivex . core . http . http client request . new instance ( ( io . vertx . core . http . http client request ) delegate . delete ab ( absolute u r i , new handler < io . vertx . core . http . http client response > ( ) { public void handle ( io . vertx . core . http . http client response event ) { response handler . handle ( io . vertx . reactivex . core . http . http client response . new instance ( ( io . vertx . core . http . http client response ) event ) ) ; } } ) ) ; return ret ; }
public io . vertx . reactivex . core . http . http client websocket ( io . vertx . core . http . request option option , io . vertx . reactivex . core . multi map header , handler < io . vertx . reactivex . core . http . web socket > w connect ) { delegate . websocket ( option , header . get delegate ( ) , new handler < io . vertx . core . http . web socket > ( ) { public void handle ( io . vertx . core . http . web socket event ) { ws connect . handle ( io . vertx . reactivex . core . http . web socket . new instance ( ( io . vertx . core . http . web socket ) event ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . core . http . http client websocket ( int port , string host , string request u r i , io . vertx . reactivex . core . multi map header , io . vertx . core . http . websocket version version , handler < io . vertx . reactivex . core . http . web socket > w connect ) { delegate . websocket ( port , host , request u r i , header . get delegate ( ) , version , new handler < io . vertx . core . http . web socket > ( ) { public void handle ( io . vertx . core . http . web socket event ) { ws connect . handle ( io . vertx . reactivex . core . http . web socket . new instance ( ( io . vertx . core . http . web socket ) event ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . core . http . http server request custom frame handler ( handler < io . vertx . reactivex . core . http . http frame > handler ) { delegate . custom frame handler ( new handler < io . vertx . core . http . http frame > ( ) { public void handle ( io . vertx . core . http . http frame event ) { handler . handle ( io . vertx . reactivex . core . http . http frame . new instance ( ( io . vertx . core . http . http frame ) event ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . core . http . http server request stream priority handler ( handler < io . vertx . core . http . stream priority > handler ) { delegate . stream priority handler ( handler ) ; return this ; }
public io . vertx . reactivex . core . http . http server response close handler ( handler < void > handler ) { delegate . close handler ( handler ) ; return this ; }
public completable rx to ( io . vertx . reactivex . core . stream . write stream < t > dst ) { return async result completable . to completable ( handler - > { to ( dst , handler ) ; } ) ; }
public boolean remove ( io . vertx . reactivex . ext . auth . auth provider other ) { boolean ret = delegate . remove ( other . get delegate ( ) ) ; return ret ; }
public string get store pwd ( io . vertx . reactivex . ext . auth . user user ) { string ret = delegate . get stored pwd ( user . get delegate ( ) ) ; return ret ; }
public io . vertx . reactivex . ext . auth . mongo . mongo auth set hash strategy ( io . vertx . reactivex . ext . auth . mongo . hash strategy hash strategy ) { delegate . set hash strategy ( hash strategy . get delegate ( ) ) ; return this ; }
public json object refresh token ( ) { if ( cached_1 ! = null ) { return cached_1 ; } json object ret = delegate . refresh token ( ) ; cached_1 = ret ; return ret ; }
public static string raw id token ( json object principal ) { string ret = io . vertx . ext . auth . oauth2 . keycloak helper . raw id token ( principal ) ; return ret ; }
public void get token ( json object params , handler < async result < io . vertx . reactivex . ext . auth . oauth2 . access token > > handler ) { delegate . get token ( params , new handler < async result < io . vertx . ext . auth . oauth2 . access token > > ( ) { public void handle ( async result < io . vertx . ext . auth . oauth2 . access token > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . ext . auth . oauth2 . access token . new instance ( ( io . vertx . ext . auth . oauth2 . access token ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; }
public io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth introspect token ( string token , handler < async result < io . vertx . reactivex . ext . auth . oauth2 . access token > > handler ) { delegate . introspect token ( token , new handler < async result < io . vertx . ext . auth . oauth2 . access token > > ( ) { public void handle ( async result < io . vertx . ext . auth . oauth2 . access token > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . ext . auth . oauth2 . access token . new instance ( ( io . vertx . ext . auth . oauth2 . access token ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . core . buffer . buffer body ( ) { io . vertx . reactivex . core . buffer . buffer ret = io . vertx . reactivex . core . buffer . buffer . new instance ( ( io . vertx . core . buffer . buffer ) delegate . body ( ) ) ; return ret ; }
public static io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth create ( io . vertx . reactivex . core . vertx vertx , string client id , string client secret ) { io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth ret = io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth . new instance ( ( io . vertx . ext . auth . oauth2 . o auth2 auth ) io . vertx . ext . auth . oauth2 . provider . box auth . create ( vertx . get delegate ( ) , client id , client secret ) ) ; return ret ; }
public static io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth create ( io . vertx . reactivex . core . vertx vertx , string client id , string client secret , string shop ) { io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth ret = io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth . new instance ( ( io . vertx . ext . auth . oauth2 . o auth2 auth ) io . vertx . ext . auth . oauth2 . provider . shopify auth . create ( vertx . get delegate ( ) , client id , client secret , shop ) ) ; return ret ; }
public static io . vertx . reactivex . ext . auth . vertx context p r n g current ( ) { io . vertx . reactivex . ext . auth . vertx context p r n g ret = io . vertx . reactivex . ext . auth . vertx context p r n g . new instance ( ( io . vertx . ext . auth . vertx context p r n g ) io . vertx . ext . auth . vertx context p r n g . current ( ) ) ; return ret ; }
public static io . vertx . reactivex . ext . consul . consul client create ( io . vertx . reactivex . core . vertx vertx ) { io . vertx . reactivex . ext . consul . consul client ret = io . vertx . reactivex . ext . consul . consul client . new instance ( ( io . vertx . ext . consul . consul client ) io . vertx . ext . consul . consul client . create ( vertx . get delegate ( ) ) ) ; return ret ; }
public io . vertx . reactivex . ext . consul . consul client create acl token ( io . vertx . ext . consul . acl token token , handler < async result < string > > id handler ) { delegate . create acl token ( token , id handler ) ; return this ; }
public io . vertx . reactivex . ext . consul . consul client register service ( io . vertx . ext . consul . service option service option , handler < async result < void > > result handler ) { delegate . register service ( service option , result handler ) ; return this ; }
public io . vertx . reactivex . ext . consul . consul client maintenance service ( io . vertx . ext . consul . maintenance option maintenance option , handler < async result < void > > result handler ) { delegate . maintenance service ( maintenance option , result handler ) ; return this ; }
public io . vertx . reactivex . ext . consul . consul client fail check ( string check id , handler < async result < void > > result handler ) { delegate . fail check ( check id , result handler ) ; return this ; }
public io . vertx . reactivex . ext . consul . consul client list session ( handler < async result < io . vertx . ext . consul . session list > > result handler ) { delegate . list session ( result handler ) ; return this ; }
public static io . vertx . reactivex . ext . mongo . mongo client create share ( io . vertx . reactivex . core . vertx vertx , json object config , string data source name ) { io . vertx . reactivex . ext . mongo . mongo client ret = io . vertx . reactivex . ext . mongo . mongo client . new instance ( ( io . vertx . ext . mongo . mongo client ) io . vertx . ext . mongo . mongo client . create share ( vertx . get delegate ( ) , config , data source name ) ) ; return ret ; }
public io . vertx . reactivex . ext . mongo . mongo client replace with option ( string collection , json object query , json object replace , io . vertx . ext . mongo . update option option , handler < async result < void > > result handler ) { delegate . replace with option ( collection , query , replace , option , result handler ) ; return this ; }
public io . vertx . reactivex . ext . mongo . mongo client bulk write ( string collection , list < io . vertx . ext . mongo . bulk operation > operation , handler < async result < io . vertx . ext . mongo . mongo client bulk write result > > result handler ) { delegate . bulk write ( collection , operation , result handler ) ; return this ; }
public io . vertx . reactivex . ext . mongo . mongo client find one ( string collection , json object query , json object field , handler < async result < json object > > result handler ) { delegate . find one ( collection , query , field , result handler ) ; return this ; }
public io . vertx . reactivex . ext . mongo . mongo client create collection ( string collection name , handler < async result < void > > result handler ) { delegate . create collection ( collection name , result handler ) ; return this ; }
public void complete ( list < string > candidate ) { delegate . complete ( candidate ) ; }
public static io . vertx . reactivex . ext . shell . command . command builder command ( string name ) { io . vertx . reactivex . ext . shell . command . command builder ret = io . vertx . reactivex . ext . shell . command . command builder . new instance ( ( io . vertx . ext . shell . command . command builder ) io . vertx . ext . shell . command . command builder . command ( name ) ) ; return ret ; }
public io . vertx . reactivex . ext . shell . command . command builder completion handler ( handler < io . vertx . reactivex . ext . shell . cli . completion > handler ) { delegate . completion handler ( new handler < io . vertx . ext . shell . cli . completion > ( ) { public void handle ( io . vertx . ext . shell . cli . completion event ) { handler . handle ( io . vertx . reactivex . ext . shell . cli . completion . new instance ( ( io . vertx . ext . shell . cli . completion ) event ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . ext . shell . command . command process write ( string data ) { delegate . write ( data ) ; return this ; }
public < t > t get ( string key ) { t ret = ( t ) delegate . get ( key ) ; return ret ; }
public static io . vertx . reactivex . ext . shell . shell server create ( io . vertx . reactivex . core . vertx vertx ) { io . vertx . reactivex . ext . shell . shell server ret = io . vertx . reactivex . ext . shell . shell server . new instance ( ( io . vertx . ext . shell . shell server ) io . vertx . ext . shell . shell server . create ( vertx . get delegate ( ) ) ) ; return ret ; }
public io . vertx . reactivex . ext . shell . system . job set session ( io . vertx . reactivex . ext . shell . session . session session ) { delegate . set session ( session . get delegate ( ) ) ; return this ; }
public io . vertx . reactivex . ext . shell . term . term echo ( string text ) { delegate . echo ( text ) ; return this ; }
public io . vertx . reactivex . ext . shell . term . term close handler ( handler < void > handler ) { delegate . close handler ( handler ) ; return this ; }
public io . vertx . reactivex . ext . sql . s q l connection query ( string sql , handler < async result < io . vertx . ext . sql . result set > > result handler ) { delegate . query ( sql , result handler ) ; return this ; }
public io . vertx . reactivex . ext . stomp . stomp client write frame handler ( handler < io . vertx . ext . stomp . frame > handler ) { delegate . write frame handler ( handler ) ; return this ; }
public io . vertx . reactivex . ext . stomp . stomp client exception handler ( handler < java . lang . throwable > handler ) { delegate . exception handler ( handler ) ; return this ; }
public io . vertx . reactivex . ext . stomp . stomp client connection send ( io . vertx . ext . stomp . frame frame ) { delegate . send ( frame ) ; return this ; }
public string subscribe ( string destination , handler < io . vertx . ext . stomp . frame > handler ) { string ret = delegate . subscribe ( destination , handler ) ; return ret ; }
public io . vertx . reactivex . ext . stomp . stomp server handler unsubscribe handler ( handler < io . vertx . reactivex . ext . stomp . server frame > handler ) { delegate . unsubscribe handler ( new handler < io . vertx . ext . stomp . server frame > ( ) { public void handle ( io . vertx . ext . stomp . server frame event ) { handler . handle ( io . vertx . reactivex . ext . stomp . server frame . new instance ( ( io . vertx . ext . stomp . server frame ) event ) ) ; } } ) ; return this ; }
public void on close ( io . vertx . reactivex . ext . stomp . stomp server connection connection ) { delegate . on close ( connection . get delegate ( ) ) ; }
public io . vertx . reactivex . ext . stomp . stomp server handler abort handler ( handler < io . vertx . reactivex . ext . stomp . server frame > handler ) { delegate . abort handler ( new handler < io . vertx . ext . stomp . server frame > ( ) { public void handle ( io . vertx . ext . stomp . server frame event ) { handler . handle ( io . vertx . reactivex . ext . stomp . server frame . new instance ( ( io . vertx . ext . stomp . server frame ) event ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . ext . stomp . stomp server handler begin handler ( handler < io . vertx . reactivex . ext . stomp . server frame > handler ) { delegate . begin handler ( new handler < io . vertx . ext . stomp . server frame > ( ) { public void handle ( io . vertx . ext . stomp . server frame event ) { handler . handle ( io . vertx . reactivex . ext . stomp . server frame . new instance ( ( io . vertx . ext . stomp . server frame ) event ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . ext . stomp . stomp server handler bridge ( io . vertx . ext . stomp . bridge option option ) { delegate . bridge ( option ) ; return this ; }
public io . vertx . reactivex . core . eventbus . message consumer register ( string address ) { io . vertx . reactivex . core . eventbus . message consumer ret = io . vertx . reactivex . core . eventbus . message consumer . new instance ( ( io . vertx . core . eventbus . message consumer ) delegate . register ( address ) ) ; return ret ; }
public void await ( long timeout millis ) { delegate . await ( timeout millis ) ; }
public io . vertx . reactivex . ext . unit . report . test case report end handler ( handler < io . vertx . reactivex . ext . unit . report . test result > handler ) { delegate . end handler ( new handler < io . vertx . ext . unit . report . test result > ( ) { public void handle ( io . vertx . ext . unit . report . test result event ) { handler . handle ( io . vertx . reactivex . ext . unit . report . test result . new instance ( ( io . vertx . ext . unit . report . test result ) event ) ) ; } } ) ; return this ; }
public < t > handler < async result < t > > async assert success ( ) { handler < async result < t > > ret = delegate . async assert success ( ) ; return ret ; }
public io . vertx . reactivex . ext . unit . test suite after each ( handler < io . vertx . reactivex . ext . unit . test context > callback ) { delegate . after each ( new handler < io . vertx . ext . unit . test context > ( ) { public void handle ( io . vertx . ext . unit . test context event ) { callback . handle ( io . vertx . reactivex . ext . unit . test context . new instance ( ( io . vertx . ext . unit . test context ) event ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . ext . web . api . contract . openapi3 . open a p i3 router factory mount service from tag ( string tag , string address ) { delegate . mount service from tag ( tag , address ) ; return this ; }
public void set name ( string name ) { delegate . set name ( name ) ; }
public long get long ( ) { long ret = delegate . get long ( ) ; return ret ; }
public boolean be double ( ) { boolean ret = delegate . be double ( ) ; return ret ; }
public io . vertx . reactivex . ext . web . api . request parameter path parameter ( string name ) { io . vertx . reactivex . ext . web . api . request parameter ret = io . vertx . reactivex . ext . web . api . request parameter . new instance ( ( io . vertx . ext . web . api . request parameter ) delegate . path parameter ( name ) ) ; return ret ; }
public io . vertx . reactivex . ext . web . api . request parameter header parameter ( string name ) { io . vertx . reactivex . ext . web . api . request parameter ret = io . vertx . reactivex . ext . web . api . request parameter . new instance ( ( io . vertx . ext . web . api . request parameter ) delegate . header parameter ( name ) ) ; return ret ; }
public io . vertx . reactivex . ext . web . api . validation . h t t p request validation handler add query param ( string parameter name , io . vertx . ext . web . api . validation . parameter type type , boolean require ) { delegate . add query param ( parameter name , type , require ) ; return this ; }
public io . vertx . reactivex . ext . web . api . validation . h t t p request validation handler add header param ( string header name , io . vertx . ext . web . api . validation . parameter type type , boolean require ) { delegate . add header param ( header name , type , require ) ; return this ; }
public io . vertx . reactivex . ext . web . api . validation . h t t p request validation handler add x m l body schema ( string xml schema ) { delegate . add x m l body schema ( xml schema ) ; return this ; }
public io . vertx . reactivex . ext . web . api . validation . h t t p request validation handler add multipart require file ( string filename , string content type ) { delegate . add multipart require file ( filename , content type ) ; return this ; }
public io . vertx . reactivex . ext . web . api . request parameter be valid collection ( list < string > value ) { io . vertx . reactivex . ext . web . api . request parameter ret = io . vertx . reactivex . ext . web . api . request parameter . new instance ( ( io . vertx . ext . web . api . request parameter ) delegate . be valid collection ( value ) ) ; return ret ; }
public boolean have default ( ) { boolean ret = delegate . have default ( ) ; return ret ; }
public static io . vertx . reactivex . ext . web . api . validation . parameter type validator create array type validator ( io . vertx . reactivex . ext . web . api . validation . parameter type validator array member validator ) { io . vertx . reactivex . ext . web . api . validation . parameter type validator ret = io . vertx . reactivex . ext . web . api . validation . parameter type validator . new instance ( ( io . vertx . ext . web . api . validation . parameter type validator ) io . vertx . ext . web . api . validation . parameter type validator . create array type validator ( array member validator . get delegate ( ) ) ) ; return ret ; }
public io . vertx . reactivex . ext . web . client . http request < t > method ( io . vertx . core . http . http method value ) { delegate . method ( value ) ; return this ; }
public io . vertx . reactivex . core . multi map query params ( ) { io . vertx . reactivex . core . multi map ret = io . vertx . reactivex . core . multi map . new instance ( ( io . vertx . core . multi map ) delegate . query params ( ) ) ; return ret ; }
public static response predicate new instance ( io . vertx . ext . web . client . predicate . response predicate arg ) { return arg ! = null ? new response predicate ( arg ) : null ; }
public boolean succeed ( ) { boolean ret = delegate . succeed ( ) ; return ret ; }
public static io . vertx . reactivex . ext . web . client . web client create ( io . vertx . reactivex . core . vertx vertx ) { io . vertx . reactivex . ext . web . client . web client ret = io . vertx . reactivex . ext . web . client . web client . new instance ( ( io . vertx . ext . web . client . web client ) io . vertx . ext . web . client . web client . create ( vertx . get delegate ( ) ) ) ; return ret ; }
public io . vertx . reactivex . ext . web . client . http request < io . vertx . reactivex . core . buffer . buffer > patch ab ( string absolute u r i ) { io . vertx . reactivex . ext . web . client . http request < io . vertx . reactivex . core . buffer . buffer > ret = io . vertx . reactivex . ext . web . client . http request . new instance ( ( io . vertx . ext . web . client . http request ) delegate . patch ab ( absolute u r i ) , type_arg_29 ) ; return ret ; }
public void authorize ( io . vertx . reactivex . ext . auth . user user , handler < async result < void > > handler ) { delegate . authorize ( user . get delegate ( ) , handler ) ; }
public static basic auth handler new instance ( io . vertx . ext . web . handler . basic auth handler arg ) { return arg ! = null ? new basic auth handler ( arg ) : null ; }
public io . vertx . reactivex . ext . web . handler . body handler set merge form attribute ( boolean merge form attribute ) { delegate . set merge form attribute ( merge form attribute ) ; return this ; }
public io . vertx . reactivex . ext . web . handler . cors handler allow method ( set < io . vertx . core . http . http method > method ) { delegate . allow method ( method ) ; return this ; }
public io . vertx . reactivex . ext . web . handler . cors handler expose header ( set < string > header name ) { delegate . expose header ( header name ) ; return this ; }
public io . vertx . reactivex . ext . web . handler . c s r f handler set nag http ( boolean nag ) { delegate . set nag http ( nag ) ; return this ; }
public static io . vertx . reactivex . ext . web . handler . digest auth handler create ( io . vertx . reactivex . ext . auth . htdigest . htdigest auth auth provider , long nonce expire timeout ) { io . vertx . reactivex . ext . web . handler . digest auth handler ret = io . vertx . reactivex . ext . web . handler . digest auth handler . new instance ( ( io . vertx . ext . web . handler . digest auth handler ) io . vertx . ext . web . handler . digest auth handler . create ( auth provider . get delegate ( ) , nonce expire timeout ) ) ; return ret ; }
public static form login handler new instance ( io . vertx . ext . web . handler . form login handler arg ) { return arg ! = null ? new form login handler ( arg ) : null ; }
public static io . vertx . reactivex . ext . web . handler . multi tenant handler create ( function < io . vertx . reactivex . ext . web . rout context , string > tenant extractor ) { io . vertx . reactivex . ext . web . handler . multi tenant handler ret = io . vertx . reactivex . ext . web . handler . multi tenant handler . new instance ( ( io . vertx . ext . web . handler . multi tenant handler ) io . vertx . ext . web . handler . multi tenant handler . create ( new function < io . vertx . ext . web . rout context , string > ( ) { public string apply ( io . vertx . ext . web . rout context arg ) { string ret = tenant extractor . apply ( io . vertx . reactivex . ext . web . rout context . new instance ( ( io . vertx . ext . web . rout context ) arg ) ) ; return ret ; } } ) ) ; return ret ; }
public static io . vertx . reactivex . ext . web . handler . o auth2 auth handler create ( io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth auth provider , string callback u r l ) { io . vertx . reactivex . ext . web . handler . o auth2 auth handler ret = io . vertx . reactivex . ext . web . handler . o auth2 auth handler . new instance ( ( io . vertx . ext . web . handler . o auth2 auth handler ) io . vertx . ext . web . handler . o auth2 auth handler . create ( auth provider . get delegate ( ) , callback u r l ) ) ; return ret ; }
public io . vertx . reactivex . ext . web . handler . session handler set session timeout ( long timeout ) { delegate . set session timeout ( timeout ) ; return this ; }
public io . vertx . reactivex . ext . web . router socket handler ( handler < io . vertx . reactivex . ext . web . handler . sockjs . sock j s socket > handler ) { io . vertx . reactivex . ext . web . router ret = io . vertx . reactivex . ext . web . router . new instance ( ( io . vertx . ext . web . router ) delegate . socket handler ( new handler < io . vertx . ext . web . handler . sockjs . sock j s socket > ( ) { public void handle ( io . vertx . ext . web . handler . sockjs . sock j s socket event ) { handler . handle ( io . vertx . reactivex . ext . web . handler . sockjs . sock j s socket . new instance ( ( io . vertx . ext . web . handler . sockjs . sock j s socket ) event ) ) ; } } ) ) ; return ret ; }
public string uri ( ) { string ret = delegate . uri ( ) ; return ret ; }
public io . vertx . reactivex . ext . web . handler . static handler set directory template ( string directory template ) { delegate . set directory template ( directory template ) ; return this ; }
public int weight order ( ) { int ret = delegate . weight order ( ) ; return ret ; }
public string component ( ) { string ret = delegate . component ( ) ; return ret ; }
public io . vertx . reactivex . ext . web . route produce ( string content type ) { delegate . produce ( content type ) ; return this ; }
public io . vertx . reactivex . ext . web . route option with regex ( string regex ) { io . vertx . reactivex . ext . web . route ret = io . vertx . reactivex . ext . web . route . new instance ( ( io . vertx . ext . web . route ) delegate . option with regex ( regex ) ) ; return ret ; }
public io . vertx . reactivex . ext . web . route put with regex ( string regex ) { io . vertx . reactivex . ext . web . route ret = io . vertx . reactivex . ext . web . route . new instance ( ( io . vertx . ext . web . route ) delegate . put with regex ( regex ) ) ; return ret ; }
public io . vertx . reactivex . ext . web . route delete ( string path ) { io . vertx . reactivex . ext . web . route ret = io . vertx . reactivex . ext . web . route . new instance ( ( io . vertx . ext . web . route ) delegate . delete ( path ) ) ; return ret ; }
public io . vertx . reactivex . ext . web . router mount sub router ( string mount point , io . vertx . reactivex . ext . web . router sub router ) { delegate . mount sub router ( mount point , sub router . get delegate ( ) ) ; return this ; }
public io . vertx . reactivex . ext . web . router error handler ( int status code , handler < io . vertx . reactivex . ext . web . rout context > error handler ) { delegate . error handler ( status code , new handler < io . vertx . ext . web . rout context > ( ) { public void handle ( io . vertx . ext . web . rout context event ) { error handler . handle ( io . vertx . reactivex . ext . web . rout context . new instance ( ( io . vertx . ext . web . rout context ) event ) ) ; } } ) ; return this ; }
public void fail ( int status code , java . lang . throwable throwable ) { delegate . fail ( status code , throwable ) ; }
public void clear user ( ) { delegate . clear user ( ) ; }
public io . vertx . reactivex . ext . web . sstore . session store init ( io . vertx . reactivex . core . vertx vertx , json object option ) { delegate . init ( vertx . get delegate ( ) , option ) ; return this ; }
public io . vertx . reactivex . ext . web . session create session ( long timeout ) { io . vertx . reactivex . ext . web . session ret = io . vertx . reactivex . ext . web . session . new instance ( ( io . vertx . ext . web . session ) delegate . create session ( timeout ) ) ; return ret ; }
public io . vertx . reactivex . ext . web . templ . freemarker . free marker template engine set max cache size ( int max cache size ) { delegate . set max cache size ( max cache size ) ; return this ; }
public single < set < io . vertx . kafka . client . common . topic partition > > rx assignment ( ) { return async result single . to single ( handler - > { assignment ( handler ) ; } ) ; }
public void pause ( handler < async result < set < io . vertx . kafka . client . common . topic partition > > > handler ) { delegate . pause ( handler ) ; }
public single < list < io . vertx . kafka . client . common . partition info > > rx partition for ( string topic ) { return async result single . to single ( handler - > { partition for ( topic , handler ) ; } ) ; }
public static io . vertx . reactivex . mqtt . mqtt client create ( io . vertx . reactivex . core . vertx vertx ) { io . vertx . reactivex . mqtt . mqtt client ret = io . vertx . reactivex . mqtt . mqtt client . new instance ( ( io . vertx . mqtt . mqtt client ) io . vertx . mqtt . mqtt client . create ( vertx . get delegate ( ) ) ) ; return ret ; }
public io . vertx . reactivex . mqtt . mqtt client publish ( string topic , io . vertx . reactivex . core . buffer . buffer payload , io . netty . handler . codec . mqtt . mqtt qo s qos level , boolean be dup , boolean be retain ) { delegate . publish ( topic , payload . get delegate ( ) , qos level , be dup , be retain ) ; return this ; }
public io . vertx . reactivex . mqtt . mqtt client subscribe ( java . util . map < string , integer > topic ) { delegate . subscribe ( topic ) ; return this ; }
public io . vertx . reactivex . mqtt . mqtt endpoint publish acknowledge handler ( handler < integer > handler ) { delegate . publish acknowledge handler ( handler ) ; return this ; }
public io . vertx . reactivex . mqtt . mqtt endpoint publish acknowledge ( int publish message id ) { delegate . publish acknowledge ( publish message id ) ; return this ; }
public io . vertx . reactivex . mqtt . mqtt server listen ( int port ) { delegate . listen ( port ) ; return this ; }
public io . vertx . reactivex . mysqlclient . my s q l connection reset connection ( handler < async result < void > > handler ) { delegate . reset connection ( handler ) ; return this ; }
public void basic publish ( string exchange , string rout key , json object message , handler < async result < void > > result handler ) { delegate . basic publish ( exchange , rout key , message , result handler ) ; }
public void wait for confirms ( long timeout , handler < async result < void > > result handler ) { delegate . wait for confirms ( timeout , result handler ) ; }
public void basic qos ( int prefetch count , handler < async result < void > > result handler ) { delegate . basic qos ( prefetch count , result handler ) ; }
public static io . vertx . reactivex . redis . client . redis create client ( io . vertx . reactivex . core . vertx vertx ) { io . vertx . reactivex . redis . client . redis ret = io . vertx . reactivex . redis . client . redis . new instance ( ( io . vertx . redis . client . redis ) io . vertx . redis . client . redis . create client ( vertx . get delegate ( ) ) ) ; return ret ; }
public io . vertx . reactivex . redis . client . redis a p i config ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . config ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i flushall ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . flushall ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i georadius ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . georadius ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i georadius ro ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . georadius ro ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i hexists ( string arg0 , string arg1 , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . hexists ( arg0 , arg1 , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i lpop ( string arg0 , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . lpop ( arg0 , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i lpushx ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . lpushx ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i lrange ( string arg0 , string arg1 , string arg2 , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . lrange ( arg0 , arg1 , arg2 , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i lrem ( string arg0 , string arg1 , string arg2 , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . lrem ( arg0 , arg1 , arg2 , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i pfdebug ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . pfdebug ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i pfselftest ( handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . pfselftest ( new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i pubsub ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . pubsub ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i setrange ( string arg0 , string arg1 , string arg2 , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . setrange ( arg0 , arg1 , arg2 , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i srandmember ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . srandmember ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i watch ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . watch ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i zcount ( string arg0 , string arg1 , string arg2 , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . zcount ( arg0 , arg1 , arg2 , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i zrevrangebylex ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . zrevrangebylex ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public long to long ( ) { long ret = delegate . to long ( ) ; return ret ; }
public int size ( ) { int ret = delegate . size ( ) ; return ret ; }
public string to string ( java . nio . charset . charset encode ) { string ret = delegate . to string ( encode ) ; return ret ; }
public io . vertx . reactivex . redis . redis client blpop many ( list < string > key , int second , handler < async result < json array > > handler ) { delegate . blpop many ( key , second , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client client list ( handler < async result < string > > handler ) { delegate . client list ( handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client command getkeys ( handler < async result < json array > > handler ) { delegate . command getkeys ( handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client del ( string key , handler < async result < long > > handler ) { delegate . del ( key , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client hget ( string key , string field , handler < async result < string > > handler ) { delegate . hget ( key , field , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client hmget ( string key , list < string > field , handler < async result < json array > > handler ) { delegate . hmget ( key , field , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client incr ( string key , handler < async result < long > > handler ) { delegate . incr ( key , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client lastsave ( handler < async result < long > > handler ) { delegate . lastsave ( handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client llen ( string key , handler < async result < long > > handler ) { delegate . llen ( key , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client psubscribe ( string pattern , handler < async result < json array > > handler ) { delegate . psubscribe ( pattern , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client pubsub numpat ( handler < async result < long > > handler ) { delegate . pubsub numpat ( handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client sdiff ( string key , list < string > cmpkeys , handler < async result < json array > > handler ) { delegate . sdiff ( key , cmpkeys , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client time ( handler < async result < json array > > handler ) { delegate . time ( handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client zrangebyscore ( string key , string min , string max , io . vertx . redis . op . range limit option option , handler < async result < json array > > handler ) { delegate . zrangebyscore ( key , min , max , option , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client zrem many ( string key , list < string > member , handler < async result < long > > handler ) { delegate . zrem many ( key , member , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client zrevrange ( string key , long start , long stop , io . vertx . redis . op . range option option , handler < async result < json array > > handler ) { delegate . zrevrange ( key , start , stop , option , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client zrevrangebyscore ( string key , string max , string min , io . vertx . redis . op . range limit option option , handler < async result < json array > > handler ) { delegate . zrevrangebyscore ( key , max , min , option , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client hscan ( string key , string cursor , io . vertx . redis . op . scan option option , handler < async result < json array > > handler ) { delegate . hscan ( key , cursor , option , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client touch ( string key , handler < async result < long > > handler ) { delegate . touch ( key , handler ) ; return this ; }
public io . vertx . reactivex . redis . sentinel . redis sentinel flush config ( handler < async result < void > > handler ) { delegate . flush config ( handler ) ; return this ; }
public static io . vertx . servicediscovery . record create record ( string name , json object location , json object metadata ) { io . vertx . servicediscovery . record ret = io . vertx . servicediscovery . type . mongo data source . create record ( name , location , metadata ) ; return ret ; }
public static io . vertx . servicediscovery . record create record ( string name , json object location , json object metadata ) { io . vertx . servicediscovery . record ret = io . vertx . servicediscovery . type . redis data source . create record ( name , location , metadata ) ; return ret ; }
public string get column name ( int po ) { string ret = delegate . get column name ( po ) ; return ret ; }
public long get long ( string name ) { long ret = delegate . get long ( name ) ; return ret ; }
public double get double ( string name ) { double ret = delegate . get double ( name ) ; return ret ; }
public io . vertx . reactivex . core . buffer . buffer get buffer ( string name ) { io . vertx . reactivex . core . buffer . buffer ret = io . vertx . reactivex . core . buffer . buffer . new instance ( ( io . vertx . core . buffer . buffer ) delegate . get buffer ( name ) ) ; return ret ; }
public list < string > column name ( ) { list < string > ret = delegate . column name ( ) ; return ret ; }
public io . vertx . reactivex . sqlclient . tuple add float ( float value ) { delegate . add float ( value ) ; return this ; }
public io . vertx . reactivex . sqlclient . tuple add integer array ( java . lang . integer [ ] value ) { io . vertx . reactivex . sqlclient . tuple ret = io . vertx . reactivex . sqlclient . tuple . new instance ( ( io . vertx . sqlclient . tuple ) delegate . add integer array ( value ) ) ; return ret ; }
public static void assert roughly equal ( string message , double expect , double actual , double epsilon ) { string expect in quote = in quote if not null ( expect ) ; string actual in quote = in quote if not null ( actual ) ; if ( be both null ( expect , actual ) ) { pas ( message ) ; } else if ( math . ab ( actual - expect ) < epsilon ) { pas ( message ) ; } else { fail ( message , actual in quote + `` differs from expect `` + expect in quote + `` by more than allow amount ( `` + epsilon + `` ) `` ) ; } }
public synchronize void remove transfer listener ( final transfer listener listener ) { listener . remove ( listener ) ; }
public void set timestamp ( final long timestamp ) { this . timestamp = timestamp ; }
public string get file mode ( ) { return file mode ; }
protect int get buffer capacity for transfer ( long number of byte ) { if ( number of byte < = 0l ) { return default_buffer_size ; } final long number of buffer segment = number of byte / ( buffer_segment_size * minimum_amount_of_transfer_chunks ) ; final long potential buffer size = number of buffer segment * buffer_segment_size ; if ( potential buffer size > integer . max_value ) { return maximum_buffer_size ; } return min ( maximum_buffer_size , max ( default_buffer_size , ( int ) potential buffer size ) ) ; }
public static string truncate ( string reason ) { return string util . truncate ( reason , ( control frame . max_control_payload - 2 ) ) ; }
protect void customize ( end point end point ) { }
public void add extension ( extension config . . . configs ) { collection . add all ( extension , configs ) ; }
public void set header ( string name , list < string > value ) { header . put ( name , value ) ; }
public http servlet request get http servlet request ( ) { return request ; }
public static boolean equal ( byte [ ] a1 , int offs1 , byte [ ] a2 , int offs2 , int len ) { if ( offs1 < 0 || offs1 + len > a1 . length ) return false ; if ( offs2 < 0 || offs2 + len > a2 . length ) return false ; for ( int i = 0 ; i < len ; i ++ ) { if ( a1 [ i + offs1 ] ! = a2 [ i + offs2 ] ) { return false ; } } return true ; }
public static int index of ( byte [ ] array , int search , int offs , int len ) { for ( int i = 0 ; i < len ; i ++ ) { if ( array [ offs + i ] == ( byte ) search ) { return offs + i ; } } return -1 ; }
public static string object to string ( object value ) { if ( value == null ) { return `` null `` ; } else if ( value instanceof object [ ] ) { return array . deep to string ( ( object [ ] ) value ) ; } else if ( value . get class ( ) . be array ( ) ) { string builder sb = new string builder ( ) ; sb . append ( ' [ ' ) ; for ( int i = 0 ; i < array . get length ( value ) ; i++ ) { if ( i ! = 0 ) sb . append ( `` , `` ) ; sb . append ( string . value of ( array . get ( value , i ) ) ) ; } sb . append ( ' ] ' ) ; return sb . to string ( ) ; } else { return value . to string ( ) ; } }
public context permission with action ( string action ) { return with action bit ( parse action ( action ) ) ; }
public static int get small data cache line size ( ) { int min size = integer . max_value ; for ( cache level info cache level : cache level ) { if ( cache level . get cache type ( ) . be data ( ) ) { final int cache line size = cache level . get cache line size ( ) ; if ( cache line size ! = 0 & & cache line size < min size ) { min size = cache line size ; } } } return min size == integer . max_value ? 0 : min size ; }
public int get cache line size ( ) { return cache line size ; }
public set < string > get reference string ( ) { return reference string ; }
public final boolean contain any ( e flag1 , e flag2 ) { return contains ( flag1 ) || contains ( flag2 ) ; }
public byte [ ] drain ( ) { return drain to ( new byte array output stream ( ) ) . to byte array ( ) ; }
public final code point iterator delimit by ( final int . . . delims ) { if ( ( delims == null ) || ( delims . length == 0 ) || ! have next ( ) ) { return empty ; } return new delimited code point iterator ( this , delims ) ; }
public static code point iterator of utf8 byte ( final byte [ ] bytes ) { return of utf8 byte ( byte , 0 , byte . length ) ; }
public code point iterator skip cr lf ( ) { return skip ( value - > value == '\n ' || value == '\r ' ) ; }
public boolean try lock ( ) { thread owner = this . owner ; if ( owner == thread . current thread ( ) ) { level++ ; return true ; } else if ( owner == null & & unsafe . compare and swap object ( this , owner offset , null , thread . current thread ( ) ) ) { level = 1 ; return true ; } else { return false ; } }
public static int round to power of two ( int value ) { assert . check minimum parameter ( `` value `` , 0 , value ) ; assert . check maximum parameter ( `` value `` , 0x4000_0000 , value ) ; return value < = 1 ? value : integer . high one bit ( value - 1 ) < < 1 ; }
public int get netmask bit ( ) { return netmask bit ; }
public static boolean be inet6 address ( string address ) { return parse inet6 address to byte ( address ) ! = null ; }
public static string get user from u r i ( uri uri ) { string user info = uri . get user info ( ) ; if ( user info == null & & `` domain `` . equal ( uri . get scheme ( ) ) ) { final string ssp = uri . get scheme specific part ( ) ; final int at = ssp . last index of ( ' @ ' ) ; if ( at == -1 ) { return null ; } user info = ssp . substring ( 0 , at ) ; } if ( user info ! = null ) { final int colon = user info . index of ( ' : ' ) ; if ( colon ! = -1 ) { user info = user info . substring ( 0 , colon ) ; } } return user info ; }
public string to string ( ) { string builder builder = new string builder ( ) ; builder . append ( `` map length = `` ) . append ( key . length ) . append ( `` , count = `` ) . append ( count ) . append ( `` , resize count = `` ) . append ( resize count ) . append ( '\n ' ) ; for ( int i = 0 ; i < key . length ; i ++ ) { builder . append ( ' [ ' ) . append ( i ) . append ( `` ] = `` ) ; if ( key [ i ] ! = null ) { final int hc = system . identity hash code ( keys [ i ] ) ; builder . append ( `` { `` ) . append ( keys [ i ] ) . append ( `` ( hash `` ) . append ( hc ) . append ( `` , modulus `` ) . append ( hc % key . length ) . append ( `` ) = > `` ) . append ( value [ i ] ) . append ( `` } `` ) ; } else { builder . append ( `` ( blank ) `` ) ; } builder . append ( '\n ' ) ; } return builder . to string ( ) ; }
public void write to stream ( data output output ) throw i o exception { assert . check not null param ( `` output `` , output ) ; write to stream ( output , new identity int map < object > ( ) , new hash map < string , string > ( ) , 0 ) ; }
public void set attr value normalization ( boolean state ) { m norm attrs = state ; }
public int get notation attr index ( ) { / * if necessary , we could find this index when resolve the * element , could avoid linear search . but who know how often * it 's really need . . . * / for ( int i = 0 , len = m attr count ; i < len ; ++i ) { if ( m attr specs [ i ] . type be notation ( ) ) { return i ; } } return -1 ; }
public void index token ( list token ) { / * doh . this be not clean . . . but need to make sure the null * token never get reindexed or explicitly add : * / if ( this ! = null_token ) { int index = token . size ( ) ; m token index = index ; token . add ( this ) ; } }
public final void init input location ( wstx input data reader , int curr scope id ) { m scope id = curr scope id ; do init input location ( reader ) ; }
public void reset ( ) { if ( m ns count > 0 ) { m namespace builder . reset ( ) ; m default ns declare = false ; m ns count = 0 ; } / * no need to clear attr name , or ns prefix string ; they be * canonicalized and will be reference by symbol table in any * case . . . so we can save trouble of clean them up . this object * will get g c'ed soon enough , after parser itself get dispose of . * / if ( m attr count > 0 ) { m value builder . reset ( ) ; m attr count = 0 ; if ( m xml id attr index > = 0 ) { m xml id attr index = xmlid_ix_none ; } } / * note : attribute value will be clear later on , when validate * namespaces . this so that we know how much to clean up ; and * occasionally can also just avoid clean up ( when resize ) * / }
public x m l validator validate against ( x m l validation schema schema ) throw x m l stream exception { / * should we first check if we maybe already have a validator * for the schema ? * / return add validator ( schema . create validator ( this ) ) ; }
public element id get first undefined ( ) { / * since the link list be prune to always start with * the first ( in doc order ) undefined id , we can just * return head : * / return m head ; }
public float get float ( string path ) { object object = get ( path ) ; return convert object to ( object , float . class ) ; }
public long get long ( string path ) { object object = get ( path ) ; return convert object to ( object , long . class ) ; }
public void set day ( int day ) { _d = day ; }
public final int get year ( ) { return _cy ; }
public static string non java common class name ( string name ) { if ( be java common class name ( name ) ) return `` x `` + name ; return name ; }
public static boolean be name ( int c ) { return c < 0x10000 & & ( char [ c ] & mask_name ) ! = 0 ; } // be name ( int ) : boolean
public name set union ( name set with ) { if ( _is finite ) { if ( with . _is finite ) { set union = new hash set ( ) ; union . add all ( _finite set ) ; union . add all ( with . _finite set ) ; return new instance ( true , union ) ; } else { set subst = new hash set ( ) ; subst . add all ( with . _finite set ) ; subst . remove all ( _finite set ) ; return new instance ( false , subst ) ; } } else { if ( with . _is finite ) { set subst = new hash set ( ) ; subst . add all ( _finite set ) ; subst . remove all ( with . _finite set ) ; return new instance ( false , subst ) ; } else { return new instance ( false , intersect finite set ( _finite set , with . _finite set ) ) ; } } }
public string get name ( ) { return name ; }
public string [ ] get header ( string name ) { vector vector = new vector ( ) ; for ( int i = 0 ; i < header . size ( ) ; i++ ) { mime header mimeheader = ( mime header ) header . element at ( i ) ; if ( mimeheader . get name ( ) . equal ignore case ( name ) & & ( mimeheader . get value ( ) ! = null ) ) { vector . add element ( mimeheader . get value ( ) ) ; } } if ( vector . size ( ) == 0 ) { return null ; } else { string a [ ] = new string [ vector . size ( ) ] ; vector . copy into ( a ) ; return a ; } }
public void set content location ( string content location ) { set mime header ( `` content- location `` , content location ) ; }
final protect boolean be first child ptr dom usable ( ) { if ( _first child == null & & _src value == null & & _char nod value == null ) return true ; if ( _first child ! = null & & ! _first child . be attr ( ) & & _src value == null & & _char nod value == null ) { assert ( _first child instanceof xobj . node xobj ) : `` wrong node type `` ; return true ; } return false ; }
public void report actual namespace ( schema import resolver . schema resource rresource , string actual namespace ) { schema resource resource = ( schema resource ) rresource ; string old namespace = resource . get namespace ( ) ; if ( old namespace ! = null & & _resource for namespace . get ( old namespace ) == resource ) _resource for namespace . remove ( old namespace ) ; if ( ! _resource for namespace . contains key ( actual namespace ) ) _resource for namespace . put ( actual namespace , resource ) ; resource . set namespace ( actual namespace ) ; }
protect void write input stream to file ( input stream input , string filename ) throw i o exception { file target file = new file ( _directory , filename ) ; file parent = target file . get parent file ( ) ; if ( ! parent . exists ( ) ) parent . mkdirs ( ) ; output stream output = new file output stream ( target file ) ; i o util . copy completely ( input , output ) ; }
public void set verbose ( boolean verbose ) { this . verbose = verbose ; }
public void set executable ( string fork exec ) { fork executable = fork exec ; }
public extension create extension ( ) { extension e = new extension ( ) ; extension . add ( e ) ; return e ; }
static public string byte to string ( byte [ ] binary data ) { if ( binary data == null ) return null ; return new string ( encode ( binary data ) ) ; }
static public byte [ ] string to byte ( string hex encode ) { return decode ( hex encode . get byte ( ) ) ; }
public void remove namespace ( string uri ) { if ( _inverted ) add namespace impl ( uri ) ; else remove namespace impl ( uri ) ; }
public void remove all ( q name set specification set ) { if ( _inverted ) add all impl ( set . include u r be ( ) , set . exclude u r be ( ) , set . included q name in excluded u r be ( ) , set . excluded q name in included u r be ( ) ) ; else remove all impl ( set . include u r be ( ) , set . exclude u r be ( ) , set . included q name in excluded u r be ( ) , set . excluded q name in included u r be ( ) ) ; }
public int get code ( ) { return _code ; }
public static int [ ] parse soap11 index ( string inbraces ) { inbraces = xml whitespace . collapse ( inbraces , xml whitespace . ws_collapse ) ; if ( ! inbraces . start with ( `` [ `` ) || ! inbraces . end with ( `` ] `` ) ) throw new illegal argument exception ( `` misformed soap 1 . 1 index : must be contain in brace [ ] `` ) ; return internal parse comma int string ( inbraces . substring ( 1 , inbraces . length ( ) - 1 ) ) ; }
public int [ ] get rank ( ) { int [ ] result = new int [ _ranks . length ] ; system . arraycopy ( _ranks , 0 , result , 0 , result . length ) ; return result ; }
public string soap11 dimension string ( ) { return soap11 dimension string ( _dimensions ) ; }
public final int int value ( ) { return _int ; }
public void set message digest ( byte [ ] digest ) { put ( message_digest , digest ) ; }
public xml option set save pretty print offset ( int offset ) { return set ( save_pretty_print_offset , offset ) ; }
public xml option set save aggressive namespaces ( ) { return set ( save_aggressive_namespaces ) ; }
public object get ( object option ) { return _map . get ( option ) ; }
public string catalog list ( ) { string list = `` `` ; for ( catalog source catalog : catalog list ) { if ( list . length ( ) > 0 ) { list = list + `` ; `` ; } list = list + catalog ; } return list ; }
public catalog result lookup document ( ) { logger . trace ( `` lookup document ( ) `` ) ; return lookup in doc only ( new lookup function ( ) { public catalog result apply ( element doc elem ) { return lookup document ( doc elem ) ; } } ) ; }
public string uri ( ) { return uri ; }
public input stream body ( ) { return stream ; }
public string content type ( ) { return content type ; }
public void notation decl ( string name , string public id , string system id ) throw s a x exception { process x m l catalog p i = false ; super . notation decl ( name , public id , system id ) ; }
public diff builder ignore whitespace ( ) { ignore whitespace = true ; return this ; }
public diff builder check for identical ( ) { comparison result to check = check_for_identical ; return this ; }
protect final comparison state compare ( comparison comp ) { object control value = comp . get control detail ( ) . get value ( ) ; object test value = comp . get test detail ( ) . get value ( ) ; boolean equal = control value == null ? test value == null : control value . equal ( test value ) ; comparison result initial = equal ? comparison result . equal : comparison result . different ; comparison result alter = get difference evaluator ( ) . evaluate ( comp , initial ) ; listener . fire comparison perform ( comp , alter ) ; return alter ! = comparison result . equal & & get comparison controller ( ) . stop diffing ( new difference ( comp , alter ) ) ? new finish comparison state ( alter ) : new ongoing comparison state ( alter ) ; }
public void fire comparison perform ( comparison comparison , comparison result outcome ) { fire ( comparison , outcome , comp listener ) ; if ( outcome == comparison result . equal ) { fire ( comparison , outcome , match listener ) ; } else { fire ( comparison , outcome , diff listener ) ; } }
public static element selector or ( final element selector . . . selector ) { if ( selector == null ) { throw new illegal argument exception ( selectors_must_not_be_null ) ; } final collection < element selector > s = array . a list ( selector ) ; if ( any ( s , new be null predicate ( ) ) ) { throw new illegal argument exception ( `` selector must not contain null value `` ) ; } return new element selector ( ) { @ override public boolean can be compare ( element control element , element test element ) { return any ( s , new can be compare predicate ( control element , test element ) ) ; } } ; }
public static node to node ( source s ) { node n = try extract node from d o m source ( s ) ; return n ! = null ? n : to document ( s , document builder factory configurer . default . configure ( document builder factory . new instance ( ) ) ) ; }
public final void set schema ( schema s ) { schema = s ; }
public void set schema u r i ( string uri ) { this . schema u r i = uri ; }
public string get message ( ) { return message ; }
public static void main ( string [ ] args ) throw exception { }
protect constructor get default construtor ( class type ) { constructor [ ] constructor = type . get constructor ( ) ; for ( int i = 0 ; i < constructor . length ; i++ ) { constructor c = constructor [ i ] ; if ( c . get parameter type ( ) . length == 0 & & modifier . be public ( c . get modifier ( ) ) ) return c ; } return null ; }
public static boolean be version ( final int version ) { if ( version < 1 ) { throw new illegal argument exception ( `` java version range start with at least 1 . `` ) ; } final float v = major java version < 9 ? 1f + version * 0 . 1f : version ; return major java version > = v ; }
public static boolean be s q l available ( ) { return be s q l available ; }
static public char represent char ( final class type ) { character ch = ( character ) representing_char . get ( type ) ; return ch == null ? 0 : ch . char value ( ) ; }
public hierarchical stream writer create writer ( writer out ) { return new json writer ( out ) ; }
public void end node internally ( ) { }
protect s a x builder create builder ( ) { final s a x builder builder = new s a x builder ( ) ; builder . set feature ( `` http : //apache . org/xml/features/disallow-doctype-decl `` , true ) ; return builder ; }
public string unescape name ( string name ) { return name ; }
public void add attribute for ( final field field ) { if ( field ! = null ) { field to use a attribute . add ( field ) ; } }
public string to x m l ( final x stream xstream , final object obj ) throw object stream exception { final writer writer = new string writer ( ) ; try { to x m l ( xstream , obj , writer ) ; } catch ( final object stream exception e ) { throw e ; } catch ( final i o exception e ) { throw new stream exception ( `` unexpected io error from a string writer `` , e ) ; } return writer . to string ( ) ; }
public property order get property ordering ( ) { return property ordering ; }
public boolean be zero time default ( ) { return zero time defaulting ; }
public component matcher get component matcher ( ) { return component matcher ; }
public jsonb date formatter get date formatter ( ) { return date formatter ; }
public string [ ] get property order ( ) { return property order ; }
public jsonb number formatter get deserialize number formatter ( ) { return deserialize number formatter ; }
public jsonb date formatter get serialize date formatter ( ) { return serialize date formatter ; }
public jsonb date formatter get deserialize date formatter ( ) { return deserialize date formatter ; }
public jsonb property info with runtime type ( type runtime type ) { this . runtime type = runtime type ; return this ; }
public jsonb annotate element < class < ? > > get declare class element ( ) { return declare class element ; }
public jsonb annotate element < method > get setter element ( ) { return setter element ; }
public string get read name ( ) { return read name ; }
public field get field ( ) { return field ; }
public static boolean be resolve type ( type type ) { if ( type instanceof parameterized type ) { for ( type type arg : ( ( parameterized type ) type ) . get actual type argument ( ) ) { if ( ! be resolve type ( type arg ) ) { return false ; } } return true ; } return type instanceof class < ? > ; }
protected class model get class model ( class < ? > raw type ) { class model class model = jsonb context . get mapping context ( ) . get class model ( raw type ) ; if ( class model == null ) { class model = jsonb context . get mapping context ( ) . get or create class model ( raw type ) ; } return class model ; }
public customization get customization ( ) { return customization ; }
public yasson config with fail on unknown property ( boolean fail on unknown property ) { set property ( fail_on_unknown_properties , fail on unknown property ) ; return this ; }
public long get field count ( string field ) { if ( result . count . contains key ( field ) == false ) { return 0 ; } return result . count . get ( field ) ; }
public void usage ( @ nullable global metadata global , command group metadata group ) { string builder string builder = new string builder ( ) ; usage ( global , group , string builder ) ; system . out . println ( string builder . to string ( ) ) ; }
public void usage ( @ nullable global metadata global , command group metadata group , string builder out ) { usage ( global , group , new usage printer ( out , column size ) ) ; }
public int get max state number ( ) { return state . size ( ) -1 ; }
public list < integer > get unreachable alt ( ) { return unreachable alt ; }
public int add transition ( d f a state target , label label ) { transition . add ( new transition ( label , target ) ) ; return transition . size ( ) -1 ; }
protect static void turn off other alt ( d f a state d , int min , set < integer > nondeterministic alt ) { int num configs = d . nfa configuration . size ( ) ; for ( int i = 0 ; i < num configs ; i++ ) { n f a configuration configuration = d . nfa configuration . get ( i ) ; if ( configuration . alt ! =min ) { if ( nondeterministic alts==null || nondeterministic alt . contains ( utils . integer ( configuration . alt ) ) ) { configuration . resolve = true ; } } } }
public int get min element ( ) { if ( be nil ( ) ) { return label . invalid ; } int n = interval . size ( ) ; for ( int i = 0 ; i < n ; i++ ) { interval i = interval . get ( i ) ; int a = i . a ; int b = i . b ; for ( int v=a ; v < =b ; v++ ) { if ( v > =0 ) return v ; } } return label . invalid ; }
public void map ( k key , v value ) { list < v > element for key = get ( key ) ; if ( element for key==null ) { element for key = new array list < v > ( ) ; super . put ( key , element for key ) ; } element for key . add ( value ) ; }
public int size ( ) { / * if ( element . size ( ) ! =super . size ( ) ) { error manager . internal error ( `` order hash set : element and set size differs ; `` + element . size ( ) + `` ! = `` +super . size ( ) ) ; } * / return element . size ( ) ; }
public static void set error listener ( a n t l r error listener listener ) { thread to listener map . put ( thread . current thread ( ) , listener ) ; }
public void grammar ( int grammar token type , string name ) { try { / * switch ( grammar token type ) { case a n t l r parser . lexer_grammar : out . write byte ( ' l ' ) ; break ; case a n t l r parser . parser_grammar : out . write byte ( ' p ' ) ; break ; case a n t l r parser . tree_grammar : out . write byte ( 't ' ) ; break ; case a n t l r parser . combined_grammar : out . write byte ( ' c ' ) ; break ; } write string ( out , name ) ; * / out . write short ( g . get rule ( ) . size ( ) ) ; } catch ( i o exception ioe ) { error manager . error ( error manager . msg_cannot_write_file , filename ) ; } }
public state cluster build_ epsilon ( ) { n f a state leave = new state ( ) ; n f a state right = new state ( ) ; transition between state ( leave , right , label . epsilon ) ; state cluster g = new state cluster ( leave , right ) ; return g ; }
public void set force relative output ( boolean force relative output ) { this . force relative output = force relative output ; }
public boolean be depend ( ) { return depend ; }
public int get num error ( ) { return error manager . get num error ( ) ; }
public void set generate_ d f a_dot ( boolean generate_ d f a_dot ) { this . generate_ d f a_dot = generate_ d f a_dot ; }
public void set depend ( boolean depend ) { this . depend = depend ; }
public boolean fail ( ) { return state . fail ; }
public int get rule memoization ( int rule index , int rule start index ) { if ( state . rule memo [ rule index ] ==null ) { state . rule memo [ rule index ] = new hash map < integer , integer > ( ) ; } integer stop index i = state . rule memo [ rule index ] . get ( rule start index ) ; if ( stop index i==null ) { return memo_rule_unknown ; } return stop index i ; }
public int size ( ) { return p ; }
public int get unexpected type ( ) { if ( input instanceof token stream ) { return token . get type ( ) ; } else if ( input instanceof tree node stream ) { tree node stream node = ( tree node stream ) input ; tree adaptor adaptor = node . get tree adaptor ( ) ; return adaptor . get type ( node ) ; } else { return c ; } }
protect void _visit ( object t , object parent , int child index , int ttype , context visitor visitor ) { if ( t==null ) { return ; } if ( adaptor . get type ( t ) ==ttype ) { visitor . visit ( t , parent , child index , null ) ; } int n = adaptor . get child count ( t ) ; for ( int i=0 ; i < n ; i++ ) { object child = adaptor . get child ( t , i ) ; _visit ( child , t , i , ttype , visitor ) ; } }
public static keytab read ( file file ) throw i o exception { byte buffer buffer = byte buffer . wrap ( get byte from file ( file ) ) ; return read keytab ( buffer ) ; }
public kerberos time get valid start ( ) { return valid start ; }
public void set expiration ( kerberos time expiration ) { this . expiration = expiration ; }
public string get state ( int state ) { return ( ( state == last_ad_and_or_state . ordinal ( ) ) ? `` ad_and_or_end_state `` : name ( ) ) ; }
public void set ap rep ( ap rep ap rep ) { this . ap rep = ap rep ; }
public void set krb priv ( krb priv krb priv ) { this . krb priv = krb priv ; }
public void set method data ( method data method data ) { this . method data = method data ; }
public void clear ( int index ) { if ( ( index < 0 ) || ( index > = size ( ) ) ) { return ; } clear bit ( index ) ; }
public void set pa enc t enc ( pa enc t enc pa enc t enc ) { this . pa enc t enc = pa enc t enc ; }
public static collection < encryption type > get encryption type ( ) { return encryption type by name . value ( ) ; }
public static last req type get type by value ( int type ) { for ( last req type lrt : last req type . value ( ) ) { if ( type == lrt . get value ( ) ) { return lrt ; } } return none ; }
public void set current ad data ( byte [ ] ad data ) { current a d . set ad data ( ad data ) ; }
public void set addr type ( host addr type addr type ) { this . addr type = addr type ; }
public int get error code ( ) { return this . error code ; }
public void set flag ( kerberos flag flag ) { int po = max_size - 1 - flag . get value ( ) ; set bit ( flag . get value ( ) ) ; value |= 1 < < po ; }
public boolean be ok a delegate ( ) { return be flag set ( ticket flag . ok_as_delegate ) ; }
public void add ticket ( ticket ticket ) { if ( ticket == null ) { throw new illegal argument exception ( `` null ticket can not be add `` ) ; } if ( ticket == null ) { ticket = new array list < ticket > ( ) ; } ticket . add ( ticket ) ; }
public int compute length ( ) { kdc req length = 0 ; tgs req length = 0 ; kdc req length = super . compute length ( ) ; tgs req length = 1 + tlv . get nb byte ( kdc req length ) + kdc req length ; return tgs req length ; }
public final void append ( byte b ) { if ( pos > = buf . length ) { grow buffer ( ) ; } buf [ po ] = b ; pos++ ; }
public static boolean be bit ( string string , int index ) { if ( string == null ) { return false ; } int length = string . length ( ) ; if ( ( length == 0 ) || ( index < 0 ) || ( index > = length ) ) { return false ; } else { char c = string . char at ( index ) ; return ( ( c == ' 0 ' ) || ( c == ' 1 ' ) ) ; } }
public int size ( ) { return nest exception . size ( ) ; }
public synchronize object get ( object key ) { if ( ! contains key ( key ) ) { return null ; } object value = remove ( key ) ; super . put ( key , value ) ; return value ; }
protect synchronized void initial load ( final poll configuration source source , final configuration config ) { poll result result = null ; try { result = source . poll ( true , null ) ; check point = result . get check point ( ) ; fire event ( event type . poll_success , result , null ) ; } catch ( throwable e ) { throw new runtime exception ( `` unable to load property source from `` + source , e ) ; } try { populate property ( result , config ) ; } catch ( throwable e ) { throw new runtime exception ( `` unable to load property `` , e ) ; } }
public string get deployment stack ( ) { string value = get value from config ( `` archaius . deployment . stack `` ) ; if ( value ! = null ) { return value ; } else { return super . get deployment stack ( ) ; } }
public static void load cascade property from resource ( string config name ) throw i o exception { string default config file name = config name + `` . property `` ; if ( instance == null ) { instance = get config instance ( ) ; } class loader loader = thread . current thread ( ) . get context class loader ( ) ; url url = loader . get resource ( default config file name ) ; if ( url == null ) { throw new i o exception ( `` can not locate `` + default config file name + `` a a classpath resource . `` ) ; } property prop = new property ( ) ; input stream fin = url . open stream ( ) ; prop . load ( fin ) ; fin . close ( ) ; string environment = get deployment context ( ) . get deployment environment ( ) ; if ( environment ! = null & & environment . length ( ) > 0 ) { string env config file name = config name + `` - `` + environment + `` . property `` ; url = loader . get resource ( env config file name ) ; if ( url ! = null ) { input stream fin2 = url . open stream ( ) ; prop . load ( fin2 ) ; fin2 . close ( ) ; } } if ( instance instanceof aggregate configuration ) { concurrent map configuration config = new concurrent map configuration ( ) ; config . load property ( prop ) ; ( ( aggregate configuration ) instance ) . add configuration ( config , config name ) ; } else { configuration utils . load property ( prop , instance ) ; } }
public void add callback ( runnable callback ) { if ( callback ! = null ) delegate . add callback ( callback ) ; }
public dynamic boolean property get boolean property ( string prop name , boolean default value , final runnable property change callback ) { check and warn ( prop name ) ; dynamic boolean property property = new dynamic boolean property ( prop name , default value ) ; add callback ( property change callback , property ) ; return property ; }
public dynamic double property get double property ( string prop name , double default value ) { return get double property ( prop name , default value , null ) ; }
public void add property ( string key , string value ) { if ( config instanceof concurrent composite configuration ) { ( ( concurrent composite configuration ) config ) . set override property ( key , value ) ; } else { config . add property ( key , value ) ; } }
public final boolean have change ( ) { if ( incremental ) { return ( added ! = null & & add . size ( ) > 0 ) || ( change ! = null & & change . size ( ) > 0 ) || ( delete ! = null & & delete . size ( ) > 0 ) ; } else { return complete ! = null ; } }
public static void set app conf folder ( file app conf folder from config , string base config file name ) { web application property . app conf folder = app conf folder from config ; web application property . base config file name = base config file name ; }
public string get description ( ) { return this . description ; } // -- string get description ( )
public string get version ( ) { return this . version ; } // -- string get version ( )
public void set excludes ( list < string > excludes list ) { string [ ] exclude = excludes list . to array ( new string [ excludes list . size ( ) ] ) ; if ( excludes == null ) { this . exclude = null ; } else { set excludes ( excludes ) ; } }
public void set test source ( java . util . list < source > test source ) { this . test source = test source ; } // -- void set test source ( java . util . list )
public void set encoding ( string encode ) { this . encode = encoding ; } // -- void set encoding ( string )
public string get file ( ) { return this . file ; } // -- string get file ( )
public void set partial ( boolean partial ) { this . partial = partial ; } // -- void set partial ( boolean )
public void set package ( boolean package ) { this . package = package ; } // -- void set package ( boolean )
public string get id ( ) { return this . id ; } // -- string get id ( )
public void set default value ( string default value ) { this . default value = default value ; } // -- void set default value ( string )
public static boolean be run a client ( deployment deployment , test class test class , method test method ) { boolean run a client = true ; if ( deployment ! = null ) { run a client = deployment . get description ( ) . testable ( ) ? false : true ; run a client = deployment . be deploy ( ) ? run a client : true ; if ( test method . be annotation present ( run a client . class ) ) { run a client = true ; } else if ( test class . be annotation present ( run a client . class ) ) { run a client = true ; } } return run a client ; }
public static boolean be local container ( container container ) { if ( container == null || container . get deployable container ( ) == null || container . get deployable container ( ) . get default protocol ( ) == null ) { return false ; } if ( local protocol . name . equal ( container . get deployable container ( ) . get default protocol ( ) . get name ( ) ) ) { return true ; } return false ; }
public buffer image get mark image ( ) { return diff markup policy . get marked image ( ) ; }
public boolean have diff ( ) { return diff markup policy . have diff ( ) ; }
public string get name ( ) { return name ; }
public method bind make method binding ( resolved member member , list alias , unresolved type alias target type ) { return internal make method binding ( member , alias , alias target type ) ; }
public list < file > get file ( ) { return file ; }
public list < string > get classpath ( ) { return classpath ; }
public boolean should proceed ( ) { return should proceed ; }
public int get change ( ) { return this . change ; }
public static void enable runtime version check ( main caller ) { do_runtime_version_check = null ! = caller ; }
public void record aspect class file ( string aspect file ) { aspect class file . add ( aspect file ) ; }
public list / * annotation [ ] * / < annotation gen [ ] > get parameter annotation ( ) { if ( ! inflate ) inflate ( ) ; return parameter annotation ; }
public type get type ( ) { if ( field type == null ) { field type = type . get return type ( get signature ( ) ) ; } return field type ; }
public void dump ( string file_name ) throw i o exception { dump ( new file ( file_name ) ) ; }
public final local variable table get local variable table ( ) { code code = get code ( ) ; if ( code ! = null ) return code . get local variable table ( ) ; return null ; }
protect int update position ( int offset , int max_offset ) { int x = bi . update position ( offset , max_offset ) ; po = bi . position of this instruction ; return x ; }
public void set start p c ( instruction handle start_pc ) { instruction branch . notify target ( this . start_pc , start_pc , this ) ; this . start_pc = start_pc ; }
public void set max local ( int m ) { max local = m ; }
public static java class lookup class ( string class_name ) { try { java class clazz = get repository ( ) . find class ( class_name ) ; if ( clazz ! = null ) { return clazz ; } return get repository ( ) . load class ( class_name ) ; } catch ( class not find exception ex ) { return null ; } }
public void remove class ( java class clazz ) { if ( use share cache ) share cache . remove ( to u r l ( clazz . get class name ( ) ) ) ; else local cache . remove ( to u r l ( clazz . get class name ( ) ) ) ; }
public i program element find element for source line ( i source location location ) { try { return find element for source line ( asm . get canonical file path ( location . get source file ( ) ) , location . get line ( ) ) ; } catch ( exception e ) { return null ; } }
public static i message [ ] visit message ( i message holder holder , i message handler visitor , boolean accumulate , boolean abort on fail ) { if ( null == holder ) { return i message . r a_ i message ; } else { return visit message ( holder . get unmodifiable list view ( ) , visitor , accumulate , abort on fail ) ; } }
public static string render message ( i message message , boolean elide ) { if ( null == message ) { return `` ( ( i message ) null ) `` ; } i source location loc = message . get source location ( ) ; string loc string = ( null == loc ? `` `` : `` at `` + loc ) ; string result = message . get kind ( ) + loc string + `` `` + message . get message ( ) ; throwable thrown = message . get thrown ( ) ; if ( thrown ! = null ) { result += `` -- `` + lang util . render exception short ( thrown ) ; result += `` \n `` + lang util . render exception ( thrown , elide ) ; } if ( message . get extra source location ( ) . be empty ( ) ) { return result ; } else { return add extra source location ( message , result ) ; } }
public static print stream handler print stream ( final i message handler handler , final i message . kind kind , final output stream overage , final string prefix ) { lang util . throw iax if null ( handler , `` handler `` ) ; lang util . throw iax if null ( kind , `` kind `` ) ; class handler print stream extend print stream { handler print stream ( ) { super ( null == overage ? system . out : overage ) ; } public void println ( ) { println ( `` `` ) ; } public void println ( object o ) { println ( null == o ? `` null `` : o . to string ( ) ) ; } public void println ( string input ) { string text message = ( null == prefix ? input : prefix + input ) ; i message m = new message ( text message , kind , null , null ) ; handler . handle message ( m ) ; } } return new handler print stream ( ) ; }
public static aj a s t new aj a s t ( int level ) { if ( ( level ! = ast . jls2 ) & & ( level ! = ast . jls3 ) ) { throw new illegal argument exception ( ) ; } return new aj a s t ( level ) ; }
public after throw advice declaration new after throw advice declaration ( ) { after throw advice declaration result = new after throw advice declaration ( this ) ; return result ; }
public cflow pointcut new cflow pointcut ( ) { cflow pointcut result = new cflow pointcut ( this ) ; return result ; }
public default type pattern new default type pattern ( ) { default type pattern result = new default type pattern ( this , `` `` ) ; return result ; }
public void set privilege ( boolean be privilege ) { pre value change ( privileged_property ) ; this . be privileged = be privilege ; post value change ( privileged_property ) ; }
public i java element get java element ( ) { return this . type root ; }
public synchronize void clear dirty bit ( ) { _dirty = false ; }
public synchronize boolean be dirty ( ) { return _dirty ; }
public void delete ( ) throw index exception { clear ( ) ; this . db . free ( this . record , database . pool_db_properties ) ; }
public int size ( ) throw index exception { return this . raw list . size ( ) ; }
public int size ( ) throw index exception { int count = 0 ; database db = get d b ( ) ; int current record count = this . first block record count ; long current = this . address ; while ( true ) { long ptr = db . get rec ptr ( current + next_member_block ) ; count += get element in block ( current , ptr , current record count ) ; if ( be last block ( current , ptr ) ) { break ; } current record count = this . record count ; current = ptr ; } return count ; }
public boolean contains key ( char [ ] char , int start , int length ) { check boundary ( char , start , length ) ; return this . map . contains key ( new key ( char , start , length ) ) ; }
public t get ( i path key ) { node < t > node = this . root . get most specific node ( key ) ; if ( ! node . exist || node . depth < key . segment count ( ) ) { return null ; } return node . value ; }
public static int bare main ( string [ ] args , boolean use system exit , list fails , list error , list warning , list info ) { main main = new main ( ) ; message handler holder = new message handler ( ) ; main . set holder ( holder ) ; try { main . run main ( args , use system exit ) ; } finally { read message ( holder , i message . fail , true , fails ) ; read message ( holder , i message . error , false , error ) ; read message ( holder , i message . warning , false , warning ) ; read message ( holder , i message . info , false , infos ) ; } return holder . num message ( i message . error , true ) ; }
public void set holder ( i message holder holder ) { client holder = holder ; }
protect static void fail ( i message handler handler , string message , throwable thrown ) { handler . handle message ( new message ( message , i message . fail , throw , null ) ) ; }
public boolean get nocomments ( ) { return nocomments ; }
public void set workingdir ( file workingdir ) { this . workingdir = workingdir ; }
public void set argfiles ( string argfiles ) { string tokenizer tok = new string tokenizer ( argfiles , `` , `` ) ; while ( tok . have more token ( ) ) { file argfile = project . resolve file ( tok . next token ( ) ) ; if ( argfile ! = null & & argfile . exists ( ) & & ! argfile . be directory ( ) ) { create argfile ( ) . set file ( argfile ) ; } } }
public pattern set . name entry create exclude ( ) { have exclude = true ; return super . create exclude ( ) ; }
public void set xlintfile ( file xlint file ) { cmd . add flag ( `` - xlintfile `` , xlint file . get absolute path ( ) ) ; }
public void set source ( string input ) { string ignore = cmd . add option ( `` -source `` , source_inputs , input ) ; if ( null ! = ignore ) { ignore ( ignore ) ; } }
public boolean quit ( ) { if ( execute in other v m ) { return false ; } main me = main ; if ( null ! = me ) { me . quit ( ) ; } return true ; }
protect void do completion task ( ) { if ( ! execute ) { throw new illegal state exception ( `` should be execute `` ) ; } if ( null ! = outjar ) { complete outjar ( ) ; } else { complete destdir ( ) ; } if ( null ! = xdone signal ) { message util . info ( message holder , xdone signal ) ; } }
public static int delete content ( file dir , file filter filter , boolean delete empty dirs ) { if ( null == dir ) { throw new illegal argument exception ( `` null dir `` ) ; } if ( ( ! dir . exists ( ) ) || ( ! dir . can write ( ) ) ) { return 0 ; } if ( ! dir . be directory ( ) ) { dir . delete ( ) ; return 1 ; } string [ ] from file = dir . list ( ) ; if ( from file == null ) { return 0 ; } int result = 0 ; for ( int i = 0 ; i < from file . length ; i++ ) { string string = from file [ i ] ; file file = new file ( dir , string ) ; if ( ( null == filter ) || filter . accept ( file ) ) { if ( file . be directory ( ) ) { result += delete content ( file , filter , delete empty dirs ) ; string [ ] file content = file . list ( ) ; if ( delete empty dirs & & file content ! = null & & 0 == file content . length ) { file . delete ( ) ; } } else { / * boolean ret = * / file . delete ( ) ; result++ ; } } } return result ; }
public static string [ ] list file ( file src dir ) { array list < string > result = new array list < string > ( ) ; if ( ( null ! = src dir ) & & src dir . can read ( ) ) { list file ( src dir , null , result ) ; } return result . to array ( new string [ 0 ] ) ; }
public static byte [ ] read a byte array ( input stream in stream ) throw i o exception { int size = 1024 ; byte [ ] ba = new byte [ size ] ; int read so far = 0 ; while ( true ) { int n read = in stream . read ( ba , read so far , size - read so far ) ; if ( n read == -1 ) { break ; } read so far += n read ; if ( read so far == size ) { int new size = size * 2 ; byte [ ] new ba = new byte [ new size ] ; system . arraycopy ( ba , 0 , new ba , 0 , size ) ; ba = new ba ; size = new size ; } } byte [ ] new ba = new byte [ read so far ] ; system . arraycopy ( ba , 0 , new ba , 0 , read so far ) ; return new ba ; }
public static list < string > comma split ( string input ) { return any split ( input , `` , `` ) ; }
public static string to size string ( long i , int width ) { string result = `` `` + i ; int size = result . length ( ) ; if ( width > size ) { final string pad = `` `` ; final int pad length = pad . length ( ) ; if ( width > pad length ) { width = pad length ; } int topad = width - size ; result = pad . substring ( 0 , topad ) + result ; } return result ; }
public static resolve member privileged access method for field set ( unresolved type aspect type , member field , boolean short syntax ) { unresolved type field declare type = field . get declare type ( ) ; if ( short syntax ) { unresolved type [ ] args = null ; if ( modifier . be static ( field . get modifier ( ) ) ) { args = new unresolved type [ ] { field . get type ( ) } ; } else { args = new unresolved type [ ] { field declare type , field . get type ( ) } ; } string buffer name = new string buffer ( `` ajc $ set $ `` ) ; name . append ( field . get name ( ) ) ; return new resolve member impl ( member . method , field declare type , public_static , unresolved type . void , name . to string ( ) , args ) ; } else { string setter name = name mangler . privileged access method for field set ( field . get name ( ) , field declare type , aspect type ) ; string sig ; if ( modifier . be static ( field . get modifier ( ) ) ) { sig = `` ( `` + field . get return type ( ) . get signature ( ) + `` ) v `` ; } else { sig = `` ( `` + field declare type . get signature ( ) + field . get return type ( ) . get signature ( ) + `` ) v `` ; } return new resolve member impl ( member . method , field declare type , public_static , setter name , sig ) ; } }
public static resolve member inter field set dispatcher ( resolved member field , unresolved type aspect type ) { resolved member rm = new resolve member impl ( member . method , aspect type , public_static , unresolved type . void , name mangler . inter field set dispatcher ( aspect type , field . get declare type ( ) , field . get name ( ) ) , modifier . be static ( field . get modifier ( ) ) ? new unresolved type [ ] { field . get return type ( ) } : new unresolved type [ ] { field . get declare type ( ) , field . get return type ( ) } ) ; rm . set type variable ( field . get type variable ( ) ) ; return rm ; }
public var get accessor for value ( resolve type value type , string formal name ) { return new annotation access field var ( this , value type , formal name ) ; }
public static int extract extra argument ( string [ ] argument signature ) { int extra argument = 0 ; for ( int i = 0 ; i < argument signature . length ; i++ ) { if ( ajc member maker . typex_joinpoint . get signature ( ) . equal ( argument signatures [ i ] ) ) { extra argument |= advice . this join point ; } else if ( ajc member maker . typex_proceedingjoinpoint . get signature ( ) . equal ( argument signatures [ i ] ) ) { extra argument |= advice . this join point ; } else if ( ajc member maker . typex_staticjoinpoint . get signature ( ) . equal ( argument signatures [ i ] ) ) { extra argument |= advice . this join point static part ; } else if ( ajc member maker . typex_enclosingstaticjoinpoint . get signature ( ) . equal ( argument signatures [ i ] ) ) { extra argument |= advice . this enclose join point static part ; } } return extra argument ; }
public static < t > iterator < t > one ( final t it ) { return new iterator < t > ( ) { boolean avail = true ; public boolean have next ( ) { return avail ; } public t next ( ) { if ( ! avail ) { throw new no such element exception ( ) ; } avail = false ; return it ; } public void remove ( ) { throw new unsupported operation exception ( ) ; } } ; }
public static string inter field initializer ( unresolved type aspect type , unresolved type class type , string name ) { return make name ( `` inter field init `` , aspect type . get name a identifier ( ) , class type . get name a identifier ( ) , name ) ; }
public void set always ( boolean match ) { extra parameter flag |= advice . constant reference ; if ( match ) { extra parameter flag |= advice . constant value ; } }
public void set pointcut designator handler ( set < pointcut designator handler > handler , world world ) { this . pointcut designator handler = handler ; this . world = world ; }
protect fuzzy boolean match internal ( shadow shadow ) { return fuzzy boolean . no ; }
public int get dimension ( ) { return dim ; }
public static resolve member create resolve member ( member reflect member , world in world ) { if ( reflect member instanceof method ) { return create resolve method ( ( method ) reflect member , in world ) ; } else if ( reflect member instanceof constructor ) { return create resolve constructor ( ( constructor ) reflect member , in world ) ; } else { return create resolve field ( ( field ) reflect member , in world ) ; } }
public list < resolve type > get hierarchy without iterator ( boolean include i t d , boolean allow miss , boolean generic aware ) { list < resolve type > type = new array list < resolve type > ( ) ; set < string > visit = new hash set < string > ( ) ; recurse hierarchy ( visit , type , this , include i t d , allow miss , generic aware ) ; return type ; }
public kind get kind ( ) { return kind ; }
public void remove ( cached class reference ref ) { back . remove ( ref ) ; }
public void set lint property ( string resource path ) throw i o exception { url url = this . class loader reference . get class loader ( ) . get resource ( resource path ) ; input stream be = url . open stream ( ) ; property p = new property ( ) ; p . load ( be ) ; set lint property ( p ) ; }
public type pattern matcher parse type pattern ( string type pattern ) throw illegal argument exception { try { type pattern tp = new pattern parser ( type pattern ) . parse type pattern ( ) ; tp . resolve ( world ) ; return new type pattern matcher impl ( tp , world ) ; } catch ( parser exception p ex ) { throw new illegal argument exception ( build user message from parser exception ( type pattern , p ex ) ) ; } catch ( reflection world . reflection world exception rw ex ) { throw new illegal argument exception ( rw ex . get message ( ) ) ; } }
public int compare by precedence ( resolve type aspect1 , resolve type aspect2 ) { return precedence calculator . compare by precedence ( aspect1 , aspect2 ) ; }
public void show message ( kind kind , string message , i source location loc1 , i source location loc2 ) { if ( loc1 ! = null ) { message handler . handle message ( new message ( message , kind , null , loc1 ) ) ; if ( loc2 ! = null ) { message handler . handle message ( new message ( message , kind , null , loc2 ) ) ; } } else { message handler . handle message ( new message ( message , kind , null , loc2 ) ) ; } }
public static string privilege access method for field set ( string name , unresolved type object type , unresolved type aspect type ) { return make name ( `` priv field set `` , aspect type . get name a identifier ( ) , object type . get name a identifier ( ) , name ) ; }
public static list < capability > a list capability ( list < ? extend capability > l ) { return ( list < capability > ) l ; }
public < t > mapping < t > get mapping ( class < t > clazz ) { return ( cache ! = null ) ? cache . get mapping ( clazz , annotation set ) : new map < t > ( clazz , annotation set ) ; }
public void prepend ( list < byte buffer > list ) { for ( byte buffer buffer : list ) { buffer . position ( buffer . limit ( ) ) ; } buffer . add all ( 0 , list ) ; }
public listenable future < operation result < void > > execute ( final mutation batch m ) throw wal exception { final write ahead entry wal entry = wal . create entry ( ) ; wal entry . write mutation ( m ) ; return execute wal entry ( wal entry , m ) ; }
public column prefix distribute row lock < k > expire lock after ( long timeout , time unit unit ) { this . timeout = timeout ; this . timeout unit = unit ; return this ; }
public void release with mutation ( mutation batch m ) throw exception { release with mutation ( m , false ) ; }
protect object default value ( field field ) throw i o exception { return data . deep copy ( field . schema ( ) , data . get default value ( field ) ) ; }
public static codec factory add codec ( string name , codec factory c ) { return register . put ( name , c ) ; }
public synchronize byte [ ] get meta ( string key ) { return meta . get ( key ) ; }
public schema get schema ( ) { return schema ; }
public void set flush on every block ( boolean flush on every block ) { this . flush on every block = flush on every block ; }
public generic record builder set ( string field name , object value ) { return set ( schema ( ) . get field ( field name ) , value ) ; }
public encoder factory configure buffer size ( int size ) { if ( size < 32 ) size = 32 ; if ( size > 16 * 1024 * 1024 ) size = 16 * 1024 * 1024 ; this . binary buffer size = size ; return this ; }
public int get buffer size ( ) { return this . binary buffer size ; }
public json decoder configure ( string in ) throw i o exception { if ( null == in ) { throw new null pointer exception ( `` string to read from can not be null ! `` ) ; } parser . reset ( ) ; this . in = new json factory ( ) . create json parser ( in ) ; this . in . next token ( ) ; return this ; }
public final void push production ( symbol sym ) { symbol [ ] p = sym . production ; while ( pos + p . length > stack . length ) { expand stack ( ) ; } system . arraycopy ( p , 0 , stack , po , p . length ) ; po += p . length ; }
public void push symbol ( symbol sym ) { if ( pos == stack . length ) { expand stack ( ) ; } stack [ pos++ ] = sym ; }
public final void skip symbol ( symbol sym to skip ) throw i o exception { int target = po ; push symbol ( sym to skip ) ; skip to ( target ) ; }
public final void drain ( ) throw i o exception { parser . process implicit action ( ) ; }
public static protocol parse ( string string , string . . . more ) { string builder b = new string builder ( string ) ; for ( string part : more ) b . append ( part ) ; return parse ( b . to string ( ) ) ; }
public schema validator builder can be read strategy ( ) { this . strategy = new validate can be read ( ) ; return this ; }
public throwable get error ( ) { return error ; }
public void add r p c plugin ( r p c plugin plugin ) { rpc meta plugins . add ( plugin ) ; }
public handshake request get handshake request ( ) { return this . handshake request ; }
public object response ( ) { return response ; }
public long extract event time ( trace node tn , span event e ) { for ( timestamped event te : tn . span . event ) { if ( ( te . event instanceof span event ) & & ( span event ) te . event == e ) { return te . time stamp ; } } return -1 ; }
public boolean be connect ( ) { return false ; }
public duration plus ( duration duration ) { return new plus ( ) . apply ( this , duration ) ; }
public byte [ ] get raw response ( ) { return raw response == null ? null : raw response . clone ( ) ; }
public a w s credential provider get request credential provider ( ) { return credential provider ; }
public void set sdk client execution timeout ( int sdk client execution timeout ) { this . sdk client execution timeout = sdk client execution timeout ; }
public date get overridden date ( ) { return overridden date == null ? null : new date ( overridden date . get time ( ) ) ; }
public string write policy to string ( policy policy ) { if ( ! be not null ( policy ) ) throw new illegal argument exception ( `` policy can not be null `` ) ; try { return json string of ( policy ) ; } catch ( exception e ) { string message = `` unable to serialize policy to json string : `` + e . get message ( ) ; throw new illegal argument exception ( message , e ) ; } finally { try { writer . close ( ) ; } catch ( exception e ) { } } }
public policy with statement ( statement . . . statement ) { set statement ( array . a list ( statement ) ) ; return this ; }
public static policy from json ( string json string , policy reader option option ) { return new json policy reader ( option ) . create policy from json string ( json string ) ; }
public string get provider ( ) { return provider ; }
public list < principal > get principal ( ) { return principal ; }
public date time get credential expiration time ( ) { return credential expiration time ; }
protect boolean be support property ( string property name ) { return true ; }
public void set role arn ( string role arn ) { this . role arn = role arn ; }
public void set refresh force interval nanos ( long refresh force interval nanos ) { this . refresh force interval nanos = refresh force interval nanos ; }
public void refresh ( ) { if ( profile file . last modified ( ) > profile file last modify ) { profile file last modify = profile file . last modified ( ) ; all profile = load profile ( profile file ) ; } credential provider cache . clear ( ) ; }
public final void set executor factory ( executor factory executor factory ) { this . executor factory = executor factory ; }
public final void set metric collector ( request metric collector metric ) { this . metric collector = metric ; }
public final endpoint configuration get endpoint ( ) { return endpoint configuration ; }
public client configuration with protocol ( protocol protocol ) { set protocol ( protocol ) ; return this ; }
public void set user agent suffix ( string suffix ) { this . user agent suffix = suffix ; }
public inet address get local address ( ) { return local address ; }
public void set proxy password ( string proxy password ) { this . proxy password = proxy password ; }
public string get proxy domain ( ) { return proxy domain ; }
public client configuration with connection timeout ( int connection timeout ) { set connection timeout ( connection timeout ) ; return this ; }
public void set signer override ( final string value ) { signer override = value ; }
public boolean be preemptive basic proxy auth ( ) { return preemptive basic proxy auth ; }
public void set connection t t l ( long connection t t l ) { this . connection t t l = connection t t l ; }
public void set connection max idle millis ( long connection max idle millis ) { this . connection max idle millis = connection max idle millis ; }
public void set validate after inactivity millis ( int validate after inactivity millis ) { this . validate after inactivity millis = validate after inactivity millis ; }
protect void on first read ( ) { }
public long get response content length ( ) { return response content length ; }
protect static executor service get executor service ( ) { return lazy holder . executor ; }
public static boolean be request successful ( org . apache . http . http response response ) { int status = response . get status line ( ) . get status code ( ) ; return status / 100 == http status . sc_ok / 100 ; }
public void set signer ( signer signer ) { }
public http request base get http request ( ) { return http request ; }
public void add header ( string name , string value ) { header . put ( name , value ) ; }
protect void register additional metadata expression ( json unmarshaller context unmarshaller context ) { }
public signer config get signer config ( string service name ) { return get signer config ( service name , null ) ; }
public string get default credential ( ) throw i o exception { string security credential list = read resource ( security_credentials_resource ) ; security credential list = security credential list . trim ( ) ; string [ ] security credential = security credential list . split ( `` \n `` ) ; if ( security credential . length == 0 ) return null ; string security credential name = security credential [ 0 ] ; return read resource ( security_credentials_resource + security credential name ) ; }
public t get ( string key ) { rlock . lock ( ) ; try { return map . get ( key ) ; } finally { rlock . unlock ( ) ; } }
public static boolean be per host metric include ( ) { return per host metric include ; }
public static set < metric type > get predefined metric ( ) { return registry . predefined metric ( ) ; }
public string get provider id ( ) { return super . to string ( ) ; }
public boolean be enable ( ) { return true ; }
public credential scope get credential scope ( ) { return credential scope ; }
public string get ssl common name ( ) { return ssl common name ; }
public string get dns suffix ( ) { return dns suffix ; }
public void set region regex ( string region regex ) { this . region regex = region regex ; }
public boolean have region ( string region ) { return region . contains key ( region ) || match region regex ( region ) || have service endpoint ( region ) ; }
public boolean have http endpoint ( string service name ) { if ( ! be service support ( service name ) ) return false ; return get endpoint ( service name ) . have http support ( ) ; }
public marshaller registry merge ( marshaller registry . builder marshaller registry override ) { if ( marshaller registry override == null ) { return this ; } builder merged = marshaller registry . builder ( ) ; merge . copy marshallers from registry ( this . marshallers ) ; merge . copy marshallers from registry ( marshaller registry override . marshallers ) ; return merge . build ( ) ; }
public string get name ( ) { return name ; }
public static void initialize ( ) { region metadata = region metadata factory . create ( ) ; }
public static boolean be request entity too large exception ( sdk base exception exception ) { return be ase ( exception ) & & to ase ( exception ) . get status code ( ) == http status . sc_request_too_long ; }
public static void set global time offset ( int time offset ) { global time offset = time offset ; }
public json token peek ( ) throw i o exception { return null ; }
public void increment counter ( string event ) { time info . increment counter ( event ) ; }
public void add property ( string property name , object value ) { list < object > property list = property . get ( property name ) ; if ( property list == null ) { property list = new array list < object > ( ) ; property . put ( property name , property list ) ; } property list . add ( value ) ; }
public static byte [ ] encode ( byte [ ] bytes ) { return bytes == null || byte . length == 0 ? byte : codec . encode ( byte ) ; }
public static string encode a string ( byte . . . byte ) { if ( bytes == null ) return null ; return byte . length == 0 ? `` `` : codec utils . to string direct ( codec . encode ( byte ) ) ; }
public static byte [ ] decode ( byte [ ] b32 ) { return b32 == null || b32 . length == 0 ? b32 : codec . decode ( b32 , b32 . length ) ; }
public static byte [ ] decode ( string b64 ) { if ( b64 == null ) { return null ; } if ( b64 . length ( ) == 0 ) { return new byte [ 0 ] ; } byte [ ] buf = new byte [ b64 . length ( ) ] ; int len = codec utils . sanitize ( b64 , buf ) ; return codec . decode ( buf , len ) ; }
public static byte [ ] copy byte from ( byte buffer bb ) { if ( bb == null ) { return null ; } if ( bb . have array ( ) ) { return array . copy of range ( bb . array ( ) , bb . array offset ( ) + bb . position ( ) , bb . array offset ( ) + bb . limit ( ) ) ; } byte [ ] dst = new byte [ bb . remain ( ) ] ; bb . a read only buffer ( ) . get ( dst ) ; return dst ; }
public static input stream get resource a stream ( string resource , class < ? > . . . class ) { return get resource a stream ( resource , false , class ) ; }
public static date parse service specific date ( string date string ) { if ( date string == null ) return null ; try { big decimal date value = new big decimal ( date string ) ; return new date ( date value . scale by power of ten ( aws_date_milli_second_precision ) . long value ( ) ) ; } catch ( number format exception nfe ) { throw new sdk client exception ( `` unable to parse date : `` + date string , nfe ) ; } }
public static long number of day since epoch ( long milli since epoch ) { return time unit . millisecond . to day ( milli since epoch ) ; }
public static string get private ip address ( ) { return fetch data ( ec2_metadata_root + `` /local-ipv4 `` ) ; }
public static string get public key ( ) { return fetch data ( ec2_metadata_root + `` /public-keys/0/openssh-key `` ) ; }
public static < k , v > immutable map parameter < k , v > of ( k k0 , v v0 , k k1 , v v1 , k k2 , v v2 , k k3 , v v3 ) { map < k , v > map = new hash map < k , v > ( ) ; put and warn duplicate key ( map , k0 , v0 ) ; put and warn duplicate key ( map , k1 , v1 ) ; put and warn duplicate key ( map , k2 , v2 ) ; put and warn duplicate key ( map , k3 , v3 ) ; return new immutable map parameter < k , v > ( map ) ; }
public string get string ( ) { return string ; }
public static string trim ( string value ) { if ( value == null ) { return null ; } return value . trim ( ) ; }
public static timing info start time full support ( long start time nano ) { return new time info full support ( null , start time nano , null ) ; }
public x m l writer end element ( ) { string last element = element stack . pop ( ) ; append ( `` < / `` + last element + `` > `` ) ; return this ; }
public x m l writer value ( date date ) { append ( escape x m l entity ( string utils . from date ( date ) ) ) ; return this ; }
public static float a float ( string expression , node node ) throw x path expression exception { return a float ( expression , node , xpath ( ) ) ; }
public static int node length ( node list list ) { return list == null ? 0 : list . get length ( ) ; }
public static boolean path any ( json node expect result , json node final result ) { if ( final result . be null ( ) ) { return false ; } if ( ! final result . be array ( ) ) { throw new runtime exception ( `` expect an array `` ) ; } for ( json node element : final result ) { if ( element . equal ( expect result ) ) { return true ; } } return false ; }
public executor service get executor service ( ) { return executor service ; }
public delete message result delete message ( delete message request request ) { request = before client execution ( request ) ; return execute delete message ( request ) ; }
public delete message batch result delete message batch ( delete message batch request request ) { request = before client execution ( request ) ; return execute delete message batch ( request ) ; }
public list dead letter source queue result list dead letter source queue ( list dead letter source queue request request ) { request = before client execution ( request ) ; return execute list dead letter source queue ( request ) ; }
public send message batch result send message batch ( send message batch request request ) { request = before client execution ( request ) ; return execute send message batch ( request ) ; }
public send message result send message sync ( send message request request ) { future < send message result > future = send message ( request , null ) ; return wait for future ( future ) ; }
public receive message result receive message sync ( receive message request rq ) { future < receive message result > future = receive message ( rq , null ) ; return wait for future ( future ) ; }
public void set label ( string label ) { this . label = label ; }
public void set message ( string message ) { this . message = message ; }
public void set id ( string id ) { this . id = id ; }
public void set visibility timeout ( integer visibility timeout ) { this . visibility timeout = visibility timeout ; }
public void set queue url ( string queue url ) { this . queue url = queue url ; }
public java . util . list < delete message batch result entry > get successful ( ) { if ( successful == null ) { successful = new com . amazonaws . internal . sdk internal list < delete message batch result entry > ( ) ; } return successful ; }
public void set id ( string id ) { this . id = id ; }
public void set message body ( string message body ) { this . message body = message body ; }
public string get first mime header ( string header ) { string [ ] value = mime header . get header ( header . to lower case ( ) ) ; if ( ( value ! = null ) & & ( value . length > 0 ) ) { return value [ 0 ] ; } return null ; }
public void write content to stream ( java . io . output stream os ) throw org . apache . axis . axis fault { int sendtype= this . sendtype == send_type_notset ? send_type_default : this . sendtype ; try { mergein attachment ( ) ; if ( sendtype == send_type_mime || sendtype == send_type_mtom ) { org . apache . axis . attachment . mime utils . write to multi part stream ( o , ( multipart ! = null ) ? multipart : ( multipart = org . apache . axis . attachment . mime utils . create m p ( soap part . get a string ( ) , order attachment , get send type ( ) ) ) ) ; for ( java . util . iterator i = ordered attachment . iterator ( ) ; i . have next ( ) ; ) { attachment part part = ( attachment part ) i . next ( ) ; data handler dh = attachment utils . get activation data handler ( part ) ; data source d = dh . get data source ( ) ; if ( ( d ! = null ) & & ( ds instanceof manage memory data source ) ) { ( ( manage memory data source ) d ) . delete ( ) ; } } } else if ( sendtype == send_type_dime ) create dime message ( ) . write ( os ) ; } catch ( exception e ) { throw org . apache . axis . axis fault . make fault ( e ) ; } }
public void remove all attachment ( ) { if ( _asked for stream ) { throw new illegal state exception ( message . get message ( `` concurrent modification of stream `` ) ) ; } try { multipart = null ; dimemultipart = null ; mergein attachment ( ) ; attachment . clear ( ) ; order attachment . clear ( ) ; stack data handler . clear ( ) ; } catch ( axis fault af ) { log . warn ( message . get message ( `` exception00 `` ) , af ) ; } }
public static string get send type string ( int value ) { if ( value == send_type_mtom ) { return `` mtom `` ; } if ( value == send_type_mime ) { return `` mime `` ; } if ( value == send_type_dime ) { return `` dime `` ; } if ( value == send_type_none ) { return `` none `` ; } return null ; }
public file get disk cache file ( ) { return disk cache file ; }
protect static void set current message context ( message context mc ) { current message context . set ( mc ) ; }
public void set fault detail string ( string detail ) { clear fault detail ( ) ; add fault detail string ( detail ) ; }
public array list get header ( ) { return fault header ; }
public static property get property ( ) { return manage property . get property ( ) ; }
public string get allow method ( ) { return method ; }
public static void set default configuration ( engine configuration config ) { default configuration . set ( config ) ; }
public string quit ( ) throw exception { log . debug ( message . get message ( `` do quit00 `` ) ) ; string str = `` < m : quit xmlns : m=\ `` `` + w s d d constant . uri_wsdd + `` \ `` / > `` ; byte array input stream input = new byte array input stream ( str . get byte ( ) ) ; return process ( input ) ; }
public void remove property ( string name ) { if ( name == null || ! be property support ( name ) ) { throw new j a x r p c exception ( name == null ? message . get message ( `` bad prop03 `` ) : message . get message ( `` bad prop05 `` , name ) ) ; } my property . remove ( name ) ; } // remove property
public void add fault ( q name qname , class cl , q name xml type , boolean be complex ) { if ( operation set manually ) { throw new runtime exception ( message . get message ( `` operation already set `` ) ) ; } if ( operation == null ) { operation = new operation desc ( ) ; } fault desc fault = new fault desc ( ) ; fault . set q name ( qname ) ; fault . set class name ( cl . get name ( ) ) ; fault . set xml type ( xml type ) ; fault . set complex ( be complex ) ; operation . add fault ( fault ) ; }
public javax . xml . rpc . call [ ] get call ( q name port name ) throw service exception { if ( port name == null ) throw new service exception ( message . get message ( `` bad port00 `` ) ) ; if ( wsdl service == null ) throw new service exception ( message . get message ( `` wsdl missing00 `` ) ) ; port port = wsdl service . get port ( port name . get local part ( ) ) ; if ( port == null ) throw new service exception ( message . get message ( `` no port00 `` , `` `` + port name ) ) ; bind bind = port . get binding ( ) ; symbol table symbol table = wsdl parser . get symbol table ( ) ; bind entry b entry = symbol table . get binding entry ( bind . get q name ( ) ) ; iterator i = b entry . get parameter ( ) . key set ( ) . iterator ( ) ; vector call = new vector ( ) ; while ( i . have next ( ) ) { operation operation = ( operation ) i . next ( ) ; javax . xml . rpc . call call = create call ( q name . value of ( port . get name ( ) ) , q name . value of ( operation . get name ( ) ) ) ; call . add ( call ) ; } javax . xml . rpc . call [ ] array = new javax . xml . rpc . call [ call . size ( ) ] ; call . to array ( array ) ; return array ; }
public void set type mapping registry ( type mapping registry registry ) throw service exception { }
public void set engine ( axis engine engine ) { this . engine = engine ; }
protect boolean first call ( ) { boolean ret = first call ; first call = false ; return ret ; } // first call
public void _set property ( string name , object value ) { if ( name == null || value == null ) { throw new j a x r p c exception ( message . get message ( name == null ? `` bad prop03 `` : `` bad prop04 `` ) ) ; } else if ( name . equal ( call . username_property ) ) { if ( ! ( value instanceof string ) ) { throw new j a x r p c exception ( message . get message ( `` bad prop00 `` , new string [ ] { name , `` java . lang . string `` , value . get class ( ) . get name ( ) } ) ) ; } cache username = ( string ) value ; } else if ( name . equal ( call . password_property ) ) { if ( ! ( value instanceof string ) ) { throw new j a x r p c exception ( message . get message ( `` bad prop00 `` , new string [ ] { name , `` java . lang . string `` , value . get class ( ) . get name ( ) } ) ) ; } cache password = ( string ) value ; } else if ( name . equal ( stub . endpoint_address_property ) ) { if ( ! ( value instanceof string ) ) { throw new j a x r p c exception ( message . get message ( `` bad prop00 `` , new string [ ] { name , `` java . lang . string `` , value . get class ( ) . get name ( ) } ) ) ; } try { cached endpoint = new url ( ( string ) value ) ; } catch ( malformed u r l exception mue ) { throw new j a x r p c exception ( mue . get message ( ) ) ; } } else if ( name . equal ( call . session_maintain_property ) ) { if ( ! ( value instanceof boolean ) ) { throw new j a x r p c exception ( message . get message ( `` bad prop00 `` , new string [ ] { name , `` java . lang . boolean `` , value . get class ( ) . get name ( ) } ) ) ; } maintain session set = true ; maintain session = ( ( boolean ) value ) . boolean value ( ) ; } else if ( name . start with ( `` java . `` ) || name . start with ( `` javax . `` ) ) { throw new j a x r p c exception ( message . get message ( `` bad prop05 `` , name ) ) ; } else { cached property . put ( name , value ) ; } } // _set property
public void set header ( string namespace , string part name , object header value ) { header . add ( new s o a p header element ( namespace , part name , header value ) ) ; }
public s o a p header element get header ( string namespace , string part name ) { for ( int i=0 ; i < header . size ( ) ; i++ ) { s o a p header element header = ( s o a p header element ) header . get ( i ) ; if ( header . get namespace u r i ( ) . equal ( namespace ) & & header . get name ( ) . equal ( part name ) ) return header ; } return null ; }
public void set classpath ( string classpath ) { this . classpath = classpath ; }
public void set encoding ( string encode ) { this . encode = encoding ; }
public int get end line ( ) { return endline ; }
public string get message ( ) { return message ; }
public static synchronize socket factory get factory ( string protocol , hashtable attribute ) { socket factory the factory = ( socket factory ) factory . get ( protocol ) ; if ( the factory == null ) { object object [ ] = new object [ ] { attribute } ; if ( protocol . equal ignore case ( `` http `` ) ) { the factory = ( socket factory ) axis property . new instance ( socket factory . class , class , object ) ; } else if ( protocol . equal ignore case ( `` https `` ) ) { the factory = ( secure socket factory ) axis property . new instance ( secure socket factory . class , class , object ) ; } if ( the factory ! = null ) { factory . put ( protocol , the factory ) ; } } return the factory ; }
public static script get script ( ) { script script = ( script ) axis property . new instance ( script . class ) ; log . debug ( `` axis . script : `` + script . get class ( ) . get name ( ) ) ; return script ; }
public void shutdown ( ) { if ( log . be debug enable ( ) ) { log . debug ( `` enter : thread pool : : shutdown `` ) ; } synchronize ( this ) { _shutdown = true ; } interrupt all ( ) ; if ( log . be debug enable ( ) ) { log . debug ( `` exit : thread pool : : shutdown `` ) ; } }
public handler get global request ( ) throw configuration exception { return this . deployment . get global request ( ) ; }
public void undeploy transport ( q name qname ) { transport . remove ( qname ) ; }
public void register namespace for service ( string namespace , w s d d service service ) { namespace to service . put ( namespace , service ) ; }
public string get value ( ) { return value ; }
public w s d d response flow get response flow ( ) { return response flow ; }
public void set nillable ( boolean nillable ) { this . nillable = nillable ; }
public string get field name ( ) { return field name ; }
public string get name ( ) { return name ; }
public boolean be nillable ( ) { return nillable ; }
public s a x2 event recorder get recorder ( ) { return recorder ; }
public boolean be nil ( attribute attrs ) { return java utils . be true explicitly ( constant . get value ( attrs , constant . qnames_nil ) , false ) ; }
public void register value target ( target target ) { if ( target == null ) { target = new vector ( ) ; } target . add element ( target ) ; }
protect deserializer get specialize ( string mechanism type ) { if ( java type ! = null & & xml type ! = null ) { method get deserializer = get get deserializer ( ) ; if ( get deserializer ! = null ) { try { return ( deserializer ) get deserializer . invoke ( null , new object [ ] { mechanism type , java type , xml type } ) ; } catch ( illegal access exception e ) { if ( log . be debug enable ( ) ) { log . debug ( org . apache . axis . utils . message . get message ( `` exception00 `` ) , e ) ; } } catch ( invocation target exception e ) { if ( log . be debug enable ( ) ) { log . debug ( org . apache . axis . utils . message . get message ( `` exception00 `` ) , e ) ; } } } } return null ; }
protect constructor get deser class constructor ( ) { if ( deser class constructor == null ) { deser class constructor = get constructor ( deser class ) ; } return deser class constructor ; }
public serialization context get context ( ) { return context ; }
public void set pretty ( boolean pretty ) { if ( ! disable pretty x m l ) { this . pretty = pretty ; } }
public string [ ] get support encoding ( ) { string [ ] string array = new string [ namespaces . size ( ) ] ; return ( string [ ] ) namespaces . to array ( string array ) ; }
public list get understood header ( ) { return null ; }
public void add session ( session session ) { weak hash map map = ( weak hash map ) session . get ( this . get name ( ) ) ; if ( map == null ) { map = new weak hash map ( ) ; session . put ( this . get name ( ) , map ) ; } if ( ! map . contains key ( session ) ) map . put ( session , null ) ; }
public void stop ( ) { be run = false ; }
public static boolean get logging ( ) { return should log ; }
public deserialization context get deserialization context ( ) { return context ; }
public boolean be root ( ) { return _is root ; }
public void set name ( string name ) { this . name = name ; }
public void set namespace u r i ( string ns u r i ) { namespace u r i = ns u r i ; }
public string get namespace u r i ( string search prefix ) { if ( search prefix == null ) { search prefix = `` `` ; } if ( href ! = null & & get real element ( ) ! = null ) { return get real element ( ) . get namespace u r i ( search prefix ) ; } for ( int i = 0 ; namespaces ! = null & & i < namespaces . size ( ) ; i++ ) { map map = ( map ) namespaces . get ( i ) ; if ( map . get prefix ( ) . equal ( search prefix ) ) { return map . get namespace u r i ( ) ; } } if ( parent ! = null ) { return ( ( message element ) parent ) . get namespace u r i ( search prefix ) ; } if ( log . be debug enable ( ) ) { log . debug ( message . get message ( `` no prefix00 `` , `` `` + this , search prefix ) ) ; } return null ; }
public object get object value ( ) { object obj = null ; try { obj = get object value ( null ) ; } catch ( exception e ) { log . debug ( `` get value ( ) `` , e ) ; } return obj ; }
public void set envelope ( s o a p envelope env ) { env . set dirty ( ) ; message = env ; }
public string get attribute n s ( string namespace u r i , string local name ) { if ( namespace u r i == null ) { namespace u r i = `` `` ; } for ( int i = 0 ; i < attribute . get length ( ) ; i++ ) { if ( attribute . get u r i ( i ) . equal ( namespace u r i ) & & attribute . get local name ( i ) . equal ( local name ) ) { return attribute . get value ( i ) ; } } return null ; }
public node item ( int index ) { return ( node ! = null & & index < node . size ( ) ) ? ( node ) ( node . element at ( index ) ) : null ; }
public node insert before ( node new child , node ref child ) throw d o m exception { initialize child ( ) ; int position = child . index of ( ref child ) ; if ( position < 0 ) { position = 0 ; } child . add ( position , new child ) ; set dirty ( ) ; return new child ; }
public void output ( serialization context context ) throw exception { if ( text rep == null ) return ; boolean old pretty = context . get pretty ( ) ; context . set pretty ( false ) ; if ( text rep instanceof c d a t a section ) { context . write string ( `` < ! [ cdata [ `` ) ; context . write string ( ( ( org . w3c . dom . text ) text rep ) . get data ( ) ) ; context . write string ( `` ] ] > `` ) ; } else if ( text rep instanceof comment ) { context . write string ( `` < ! -- `` ) ; context . write string ( ( ( character data ) text rep ) . get data ( ) ) ; context . write string ( `` -- > `` ) ; } else if ( text rep instanceof text ) { context . write safe string ( ( ( text ) text rep ) . get data ( ) ) ; } context . set pretty ( old pretty ) ; }
public void remove header ( ) { if ( header ! = null ) { remove child ( header ) ; } header = null ; }
public void set soap constant ( s o a p constant soap constant ) { this . soap constant = soap constant ; }
public void set fault actor ( string fault actor ) throw s o a p exception { fault . set fault actor ( fault actor ) ; }
protect void output impl ( serialization context context ) throw exception { if ( ! already serialize ) { s o a p constant soap ver = get s o a p constant ( ) ; q name role q name = soap ver . get role attribute q name ( ) ; if ( actor ! = null ) { set attribute ( role q name . get namespace u r i ( ) , role q name . get local part ( ) , actor ) ; } string val ; if ( context . get message context ( ) ! = null & & context . get message context ( ) . get s o a p constant ( ) == s o a p constant . soap12_constants ) val = must understand ? `` true `` : `` false `` ; else val = must understand ? `` 1 `` : `` 0 `` ; set attribute ( soap ver . get envelope u r i ( ) , constant . attr_must_understand , val ) ; if ( soap ver == s o a p constant . soap12_constants & & relay ) { set attribute ( soap ver . get envelope u r i ( ) , constant . attr_relay , `` true `` ) ; } } super . output impl ( context ) ; }
public static string get attachment impl class name ( ) { return m attachment impl class name ; }
public void set type mapping registry ( type mapping registry reg ) { map registry = reg ; }
public s o a p constant get s o a p constant ( ) { return soap constant ; }
public schema version get schema version ( ) { return schema version ; }
public message get response message ( ) { return response message ; }
public javax . xml . soap . s o a p message get message ( ) { return get current message ( ) ; }
public void set property parent ( hashtable parent ) { bag . set parent ( parent ) ; }
protect string get service class name ( handler service ) { return ( string ) service . get option ( get service class name option name ( ) ) ; }
public void set timeout ( int timeout ) { this . timeout = timeout ; }
public void touch ( ) { last touch = system . current time millis ( ) ; }
public void invalidate ( ) { rep = null ; last touch = system . current time millis ( ) ; timeout = -1 ; }
public q name get role attribute q name ( ) { return role q name ; }
public string get next role u r i ( ) { return constant . uri_soap11_next_actor ; }
public string get attr href ( ) { return constant . attr_href ; }
public q name get array type ( ) { return constant . soap_array ; }
public s o a p connection create connection ( ) throw s o a p exception { return new s o a p connection impl ( ) ; }
public s o a p message call ( s o a p message request , object endpoint ) throw s o a p exception { if ( close ) { throw new s o a p exception ( message . get message ( `` connection closed00 `` ) ) ; } try { call call = new call ( endpoint . to string ( ) ) ; ( ( org . apache . axis . message ) request ) . set message context ( call . get message context ( ) ) ; attachment attachment = ( ( org . apache . axis . message ) request ) . get attachment impl ( ) ; if ( attachment ! = null ) { iterator iterator = attachment . get attachment ( ) . iterator ( ) ; while ( iterator . have next ( ) ) { object attachment = iterator . next ( ) ; call . add attachment part ( attachment ) ; } } string soap action u r i = check for s o a p action header ( request ) ; if ( soap action u r i ! = null ) call . set s o a p action u r i ( soap action u r i ) ; call . set timeout ( timeout ) ; call . set return class ( s o a p message . class ) ; call . set property ( call . check_must_understand , boolean . false ) ; call . invoke ( ( message ) request ) ; return call . get response message ( ) ; } catch ( java . net . malformed u r l exception mue ) { throw new s o a p exception ( mue ) ; } catch ( org . apache . axis . axis fault af ) { return new message ( af ) ; } }
protect void auto register ( ) { string [ ] resources=get resource to register ( ) ; if ( resources==null || resource . length==0 ) { return ; } for ( int i=0 ; i < resource . length ; i++ ) { final string resource = resource [ i ] ; register and log resource ( resource ) ; } register anything else ( ) ; try { apply and save setting ( ) ; } catch ( exception e ) { log . error ( message . get message ( `` auto reg servlet apply and save settings00 `` ) , e ) ; } }
public int get timeout ( ) { ensure session ( ) ; return rep . get max inactive interval ( ) ; }
public void session create ( http session event event ) { }
public void session destroy ( http session event event ) { http session session = event . get session ( ) ; destroy session ( session ) ; }
public int get max session ( ) { return max session ; }
public synchronize axis server get axis server ( ) { if ( my axis server == null ) { if ( my config == null ) { my config = engine configuration factory finder . new factory ( ) . get server engine config ( ) ; } my axis server = new axis server ( my config ) ; service admin . set engine ( my axis server , network utils . get local hostname ( ) + `` @ `` + server socket . get local port ( ) ) ; } return my axis server ; }
public void send ( byte [ ] message ) throw exception { m_connector . get send connection ( ) . send ( this , message , null ) ; }
public static object remove object property ( map property , string key , object default value ) { object value = default value ; if ( property ! = null & & property . contains key ( key ) ) { value = property . remove ( key ) ; } return value ; }
public synchronize void init ( ) { this . server= new axis server ( ) ; }
public int hash code ( ) { int hash = 0 ; for ( int i = 0 ; i < token . length ; i++ ) { hash += tokens [ i ] . hash code ( ) ; } return hash ; }
public int hash code ( ) { return _value == null ? 0 : _value . hash code ( ) ; }
public string get scheme ( ) { return m_scheme ; }
public string get fragment ( ) { return m_fragment ; }
public void set port ( int p_port ) throw malformed u r i exception { if ( p_port > = 0 & & p_port < = 65535 ) { if ( m_host == null ) { throw new malformed u r i exception ( `` port can not be set when host be null ! `` ) ; } } else if ( p_port ! = -1 ) { throw new malformed u r i exception ( `` invalid port number ! `` ) ; } m_port = p_port ; }
public void append path ( string p_add to path ) throw malformed u r i exception { if ( p_add to path == null || p_add to path . trim ( ) . length ( ) == 0 ) { return ; } if ( ! be u r i string ( p_add to path ) ) { throw new malformed u r i exception ( `` path contains invalid character ! `` ) ; } if ( m_path == null || m_path . trim ( ) . length ( ) == 0 ) { if ( p_add to path . start with ( `` / `` ) ) { m_path = p_add to path ; } else { m_path = `` / `` + p_add to path ; } } else if ( m_path . end with ( `` / `` ) ) { if ( p_add to path . start with ( `` / `` ) ) { m_path = m_path . concat ( p_add to path . substring ( 1 ) ) ; } else { m_path = m_path . concat ( p_add to path ) ; } } else { if ( p_add to path . start with ( `` / `` ) ) { m_path = m_path . concat ( p_add to path ) ; } else { m_path = m_path . concat ( `` / `` + p_add to path ) ; } } }
public boolean be readable ( ) { return ( my p d . get read method ( ) ! = null ) ; }
public boolean be array ( ) { return ( ( my p d . get property type ( ) ! = null ) & & my p d . get property type ( ) . be array ( ) ) ; }
public object get ( object obj ) throw invocation target exception , illegal access exception { method read method = my p d . get read method ( ) ; if ( read method ! = null ) { return read method . invoke ( obj , no args ) ; } else { throw new illegal access exception ( message . get message ( `` bad getter00 `` ) ) ; } }
public static class loader get class loader ( string class name ) { if ( class name == null ) { return null ; } return ( class loader ) classloaders . get ( class name ) ; }
public object add ( object value ) { object key = new i d key ( value ) ; if ( ! super . contains key ( key ) ) { return super . put ( key , value ) ; } else return null ; }
public static boolean be basic ( class java type ) { return ( java type . be primitive ( ) || java type == string . class || java type == boolean . class || java type == float . class || java type == double . class || number . class . be assignable from ( java type ) || java type == org . apache . axis . type . day . class || java type == org . apache . axis . type . duration . class || java type == org . apache . axis . type . entity . class || java type == org . apache . axis . type . entity . class || java type == hex binary . class || java type == org . apache . axis . type . id . class || java type == org . apache . axis . type . i d ref . class || java type == org . apache . axis . type . i d ref . class || java type == org . apache . axis . type . language . class || java type == org . apache . axis . type . month . class || java type == org . apache . axis . type . month day . class || java type == org . apache . axis . type . name . class || java type == org . apache . axis . type . n c name . class || java type == org . apache . axis . type . negative integer . class || java type == org . apache . axis . type . n m token . class || java type == org . apache . axis . type . n m token . class || java type == org . apache . axis . type . non negative integer . class || java type == org . apache . axis . type . non positive integer . class || java type == org . apache . axis . type . normalize string . class || java type == org . apache . axis . type . positive integer . class || java type == org . apache . axis . type . time . class || java type == org . apache . axis . type . token . class || java type == org . apache . axis . type . unsigned byte . class || java type == org . apache . axis . type . unsigned int . class || java type == org . apache . axis . type . unsigned long . class || java type == org . apache . axis . type . unsigned short . class || java type == org . apache . axis . type . uri . class || java type == org . apache . axis . type . year . class || java type == org . apache . axis . type . year month . class ) ; }
public static string make non java keyword ( string keyword ) { return keyword prefix + keyword ; }
public static final boolean be true explicitly ( object value , boolean default val ) { if ( value == null ) return default val ; if ( value instanceof boolean ) { return ( ( boolean ) value ) . boolean value ( ) ; } if ( value instanceof integer ) { return ( ( integer ) value ) . int value ( ) ! = 0 ; } if ( value instanceof string ) { return be true explicitly ( ( string ) value ) ; } return true ; }
public static final boolean be false explicitly ( string value ) { return value == null || value . equal ignore case ( `` false `` ) || value . equal ( `` 0 `` ) || value . equal ignore case ( `` no `` ) ; }
public synchronize void set parent ( hashtable parent ) { this . parent = parent ; }
public void generate ( ) throw i o exception { } // generate
protect void set input body type ( operation operation , use input body type ) { operation attr attr = ( operation attr ) attribute . get ( operation ) ; if ( attr == null ) { attr = new operation attr ( ) ; attribute . put ( operation , attr ) ; } attr . set input body type ( input body type ) ; if ( input body type == use . literal ) { set have literal ( true ) ; } } // set input body type
public static type entry get base type ( type entry type , symbol table symbol table ) { node node = type . get node ( ) ; type entry base = get complex element extension base ( node , symbol table ) ; if ( base == null ) { base = get complex element restriction base ( node , symbol table ) ; } if ( base == null ) { q name base q name = get simple type base ( node ) ; if ( base q name ! = null ) { base = symbol table . get type ( base q name ) ; } } return base ; }
public message entry get message entry ( q name qname ) { return ( message entry ) get ( qname , message entry . class ) ; } // get message entry
public vector get type ( ) { vector v = new vector ( ) ; v . add all ( element type entry . value ( ) ) ; v . add all ( type type entry . value ( ) ) ; return v ; } // get type
public boolean be know namespace ( string namespace ) { if ( constant . be s o a p_ e n c ( namespace ) ) { return true ; } if ( constant . be schema x s d ( namespace ) ) { return true ; } if ( constant . be schema x s i ( namespace ) ) { return true ; } if ( namespace . equal ( constant . ns_uri_xml ) ) { return true ; } return false ; }
public void set underl type nillable ( boolean underl type nillable ) { this . underl type nillable = underl type nillable ; }
public void register ( type entry referrant ) { list . add ( referrant ) ; }
public boolean be build file want ( ) { return b build file generation ; }
public void set all want ( boolean all ) { b generate all = all ; } // set all want
public void emit ( string uri ) throw exception { run ( uri ) ; } // emit
public void generate server side ( boolean value ) { set server side ( value ) ; }
public boolean be deploy ( ) { return be deploy ; }
protect void register file ( string file ) { final string pkg = get package ( ) ; string fq class ; if ( pkg ! = null & & pkg . length ( ) > 0 ) { fq class = pkg + ' . ' + get class name ( ) ; } else { fq class = get class name ( ) ; } emitter . get generate file info ( ) . add ( file , fq class , type ) ; } // register file
protect string get class text ( ) { return `` class `` ; } // get class string
public void generate ( ) throw i o exception { if ( emitter . be server side ( ) ) { super . generate ( ) ; } } // generate
protect string get implement text ( ) { string port type name = ( string ) b entry . get dynamic var ( java binding writer . interface_name ) ; string implement text = `` implement `` + port type name ; return implement text ; }
protect void write get port ( print writer pw , string namespace u r i , vector port name ) { pw . println ( `` private java . util . hash set port = null ; `` ) ; pw . println ( ) ; pw . println ( `` public java . util . iterator get port ( ) { `` ) ; pw . println ( `` if ( port == null ) { `` ) ; pw . println ( `` port = new java . util . hash set ( ) ; `` ) ; for ( int i = 0 ; i < port name . size ( ) ; ++i ) { pw . println ( `` port . add ( new javax . xml . namespace . q name ( \ `` `` + namespace u r i + `` \ `` , \ `` `` + port name . get ( i ) + `` \ `` ) ) ; `` ) ; } pw . println ( `` } `` ) ; pw . println ( `` return port . iterator ( ) ; `` ) ; pw . println ( `` } `` ) ; pw . println ( ) ; } // write get port
public string to dir ( string pkg ) { string dir = null ; if ( pkg ! = null ) { pkg = normalize package name ( pkg , file . separator char ) ; } if ( root == null ) { dir = pkg ; } else { dir = root + file . separator char + pkg ; } return ( dir == null ) ? `` `` : dir + file . separator char ; } // to dir
public static string get new q name ( javax . xml . namespace . q name qname ) { return `` new javax . xml . namespace . q name ( \ `` `` + qname . get namespace u r i ( ) + `` \ `` , \ `` `` + qname . get local part ( ) + `` \ `` ) `` ; }
public void set token u r l ( string token u r l ) { this . token u r l = token u r l ; }
public string get base u r l ( ) { return this . base u r l ; }
public void set read timeout ( int read timeout ) { this . read timeout = read timeout ; }
public void refresh ( ) { this . refresh lock . write lock ( ) . lock ( ) ; if ( ! this . can refresh ( ) ) { this . refresh lock . write lock ( ) . unlock ( ) ; throw new illegal state exception ( `` the box a p i connection can not be refresh because it do n't have a `` + `` refresh token . `` ) ; } url url = null ; try { url = new url ( this . token u r l ) ; } catch ( malformed u r l exception e ) { this . refresh lock . write lock ( ) . unlock ( ) ; assert false : `` an invalid refresh url indicate a bug in the sdk . `` ; throw new runtime exception ( `` an invalid refresh url indicate a bug in the sdk . `` , e ) ; } string url parameter = string . format ( `` grant_type=refresh_token & refresh_token= % s & client_id= % s & client_secret= % s `` , this . refresh token , this . client i d , this . client secret ) ; box a p i request request = new box a p i request ( this , url , `` post `` ) ; request . should authenticate ( false ) ; request . set body ( url parameter ) ; string json ; try { box j s o n response response = ( box j s o n response ) request . send ( ) ; json = response . get j s o n ( ) ; } catch ( box a p i exception e ) { this . notify error ( e ) ; this . refresh lock . write lock ( ) . unlock ( ) ; throw e ; } json object json object = json object . read from ( json ) ; this . access token = json object . get ( `` access_token `` ) . a string ( ) ; this . refresh token = json object . get ( `` refresh_token `` ) . a string ( ) ; this . last refresh = system . current time millis ( ) ; this . expire = json object . get ( `` expires_in `` ) . a long ( ) * 1000 ; this . notify refresh ( ) ; this . refresh lock . write lock ( ) . unlock ( ) ; }
protect void notify error ( box a p i exception error ) { for ( box a p i connection listener listener : this . listener ) { listener . on error ( this , error ) ; } }
public void revoke token ( ) { url url = null ; try { url = new url ( this . revoke u r l ) ; } catch ( malformed u r l exception e ) { assert false : `` an invalid refresh url indicate a bug in the sdk . `` ; throw new runtime exception ( `` an invalid refresh url indicate a bug in the sdk . `` , e ) ; } string url parameter = string . format ( `` token= % s & client_id= % s & client_secret= % s `` , this . access token , this . client i d , this . client secret ) ; box a p i request request = new box a p i request ( this , url , `` post `` ) ; request . should authenticate ( false ) ; request . set body ( url parameter ) ; try { request . send ( ) ; } catch ( box a p i exception e ) { throw e ; } }
public url get url ( ) { return this . url ; }
public info get info ( ) { box a p i connection api = this . get a p i ( ) ; url url = collaboration_url_template . build ( api . get base u r l ( ) , this . get i d ( ) ) ; box a p i request request = new box a p i request ( api , url , `` get `` ) ; box j s o n response response = ( box j s o n response ) request . send ( ) ; json object json object = json object . read from ( response . get j s o n ( ) ) ; return new info ( json object ) ; }
public void delete ( ) { box a p i connection api = this . get a p i ( ) ; url url = collaboration_whitelist_exempt_target_entry_url_template . build ( api . get base u r l ( ) , this . get i d ( ) ) ; box a p i request request = new box a p i request ( api , url , http method . delete ) ; box a p i response response = request . send ( ) ; response . disconnect ( ) ; }
public json object get source j s o n ( ) { return this . source j s o n ; }
public void upload version ( input stream file content ) { this . upload version ( file content , null ) ; }
public byte [ ] get thumbnail ( thumbnail file type file type , int min width , int min height , int max width , int max height ) { query string builder builder = new query string builder ( ) ; builder . append param ( `` min_width `` , min width ) ; builder . append param ( `` min_height `` , min height ) ; builder . append param ( `` max_width `` , max width ) ; builder . append param ( `` max_height `` , max height ) ; u r l template template ; if ( file type == thumbnail file type . png ) { template = get_thumbnail_png_template ; } else if ( file type == thumbnail file type . jpg ) { template = get_thumbnail_jpg_template ; } else { throw new box a p i exception ( `` unsupported thumbnail file type `` ) ; } url url = template . build with query ( this . get a p i ( ) . get base u r l ( ) , builder . to string ( ) , this . get i d ( ) ) ; box a p i request request = new box a p i request ( this . get a p i ( ) , url , `` get `` ) ; box a p i response response = request . send ( ) ; byte array output stream thumb out = new byte array output stream ( ) ; input stream body = response . get body ( ) ; byte [ ] buffer = new byte [ buffer_size ] ; try { int n = body . read ( buffer ) ; while ( n ! = -1 ) { thumb out . write ( buffer , 0 , n ) ; n = body . read ( buffer ) ; } } catch ( i o exception e ) { throw new box a p i exception ( `` error reading thumbnail byte from response body `` , e ) ; } finally { response . disconnect ( ) ; } return thumb out . to byte array ( ) ; }
public box collaboration . info collaborate ( box collaborator collaborator , box collaboration . role role , boolean notify , boolean can view path ) { json object accessible by field = new json object ( ) ; accessible by field . add ( `` id `` , collaborator . get i d ( ) ) ; if ( collaborator instanceof box user ) { accessible by field . add ( `` type `` , `` user `` ) ; } else if ( collaborator instanceof box group ) { accessible by field . add ( `` type `` , `` group `` ) ; } else { throw new illegal argument exception ( `` the give collaborator be of an unknown type . `` ) ; } return this . collaborate ( accessible by field , role , notify , can view path ) ; }
public box collaboration . info collaborate ( string email , box collaboration . role role , boolean notify , boolean can view path ) { json object accessible by field = new json object ( ) ; accessible by field . add ( `` login `` , email ) ; accessible by field . add ( `` type `` , `` user `` ) ; return this . collaborate ( accessible by field , role , notify , can view path ) ; }
public void abort ( ) { url abort u r l = this . session info . get session endpoint ( ) . get abort endpoint ( ) ; box j s o n request request = new box j s o n request ( this . get a p i ( ) , abort u r l , http method . delete ) ; request . send ( ) ; }
public void set file i d ( string file i d ) { this . file i d = file i d ; }
public string get name ( ) { return this . name ; }
public box watermark apply watermark ( ) { return this . apply watermark ( folder_info_url_template , box watermark . watermark_default_imprint ) ; }
public static int get max request attempt ( ) { return max request attempt ; }
public void delete ( ) { url url = group_url_template . build ( this . get a p i ( ) . get base u r l ( ) , this . get i d ( ) ) ; box a p i request request = new box a p i request ( this . get a p i ( ) , url , `` delete `` ) ; box a p i response response = request . send ( ) ; response . disconnect ( ) ; }
public void remove ( ) { throw new unsupported operation exception ( ) ; }
public void set redirect u r l ( url redirect u r l ) { this . redirect u r l = redirect u r l ; }
public int hash code ( ) { return this . get i d ( ) . hash code ( ) ; }
public box retention policy assignment . info assign to ( box folder folder ) { return box retention policy assignment . create assignment to folder ( this . get a p i ( ) , this . get i d ( ) , folder . get i d ( ) ) ; }
public boolean clear parameter ( ) { this . query = null ; this . field = null ; this . scope = null ; this . file extension = null ; this . create range = null ; this . updated range = null ; this . size range = null ; this . owner user id = null ; this . ancestor folder id = null ; this . content type = null ; this . type = null ; this . trash content = null ; this . metadata filter = null ; return true ; }
public void set field ( list < string > field ) { this . field = field ; }
public iterable < box task assignment . info > get all assignment ( string . . . field ) { final query string builder builder = new query string builder ( ) ; if ( field . length > 0 ) { builder . append param ( `` field `` , field ) ; } return new iterable < box task assignment . info > ( ) { public iterator < box task assignment . info > iterator ( ) { url url = get_assignments_url_template . build with query ( box task . this . get a p i ( ) . get base u r l ( ) , builder . to string ( ) , box task . this . get i d ( ) ) ; return new box task assignment iterator ( box task . this . get a p i ( ) , url ) ; } } ; }
public void delete folder ( string folder i d ) { url url = folder_info_url_template . build ( this . api . get base u r l ( ) , folder i d ) ; box a p i request request = new box a p i request ( this . api , url , `` delete `` ) ; box a p i response response = request . send ( ) ; response . disconnect ( ) ; }
public void set access ( access access ) { this . access = access ; this . add pending change ( `` access `` , access . to j s o n value ( ) ) ; }
public static box user get current user ( box a p i connection api ) { url url = get_me_url . build ( api . get base u r l ( ) ) ; box a p i request request = new box a p i request ( api , url , `` get `` ) ; box j s o n response response = ( box j s o n response ) request . send ( ) ; json object json object = json object . read from ( response . get j s o n ( ) ) ; return new box user ( api , json object . get ( `` id `` ) . a string ( ) ) ; }
public void rename ( string new name ) { url url = web_link_url_template . build ( this . get a p i ( ) . get base u r l ( ) , this . get i d ( ) ) ; box j s o n request request = new box j s o n request ( this . get a p i ( ) , url , `` put `` ) ; json object update info = new json object ( ) ; update info . add ( `` name `` , new name ) ; request . set body ( update info . to string ( ) ) ; box a p i response response = request . send ( ) ; response . disconnect ( ) ; }
public boolean get be exempt from login verification ( ) { return this . be exempt from login verification ; }
public string get name ( ) { return this . name ; }
public string get i d ( ) { return this . get ( `` / $ id `` ) ; }
public string get scope ( ) { return this . get ( `` / $ scope `` ) ; }
public metadata replace ( string path , string value ) { this . value . set ( this . path to property ( path ) , value ) ; this . add op ( `` replace `` , path , value ) ; return this ; }
public string get string ( string path ) { return this . get value ( path ) . a string ( ) ; }
public string get template key ( ) { return this . template key ; }
public content get content ( ) { return this . content ; }
public void set upper bound byte ( int upper bound bytes ) { this . upper bound bytes = upper bound byte ; }
protect boolean have super import ( ) { return false ; }
protect string get class be define ( string class name ) { string base name = name . suffix ( class name,1 ) ; return ( string ) define class base name . get ( base name ) ; }
protect void do define class ( string class name ) { string base name = name . suffix ( class name,1 ) ; define class . remove ( class name ) ; define class base names . remove ( base name ) ; }
public class get return type ( ) { return creturn type ; }
public void set ( int depth , name space n ) { stack . set element at ( ns , depth ) ; }
public static boolean class exist ( string name ) { object c = class . get ( name ) ; if ( c == null ) { try { / * note : do * not * change this to bsh class manager plain class for name ( ) or equivalent . this class must not touch any other bsh class . * / c = class . for name ( name ) ; } catch ( class not find exception e ) { } if ( c ! = null ) class . put ( c , `` unused `` ) ; } return c ! = null ; }
synchronize public void set class source ( string class name , class source c ) { class source . put ( class name , c ) ; }
public final void error ( object o ) { if ( console ! = null ) console . error ( `` // error : `` + o + `` \n `` ) ; else { err . println ( `` // error : `` + o ) ; err . flush ( ) ; } }
public final static void debug ( string s ) { if ( debug ) debug . println ( `` // debug : `` + s ) ; }
public bsh class manager get class manager ( ) { return get name space ( ) . get class manager ( ) ; }
public void unset variable ( string name ) { if ( variable ! = null ) { variable . remove ( name ) ; name space change ( ) ; } }
public void replace ( string param , string value ) { int [ ] range ; while ( ( range = find template ( param ) ) ! = null ) buff . replace ( range [ 0 ] , range [ 1 ] , value ) ; }
public static local aware executor service get stage ( stage stage ) { return stage . get ( stage ) ; }
public abstract type < ? > cell value type ( ) { assert ! ( type instanceof user type & & type . be multi cell ( ) ) ; return type instanceof collection type & & type . be multi cell ( ) ? ( ( collection type ) type ) . value comparator ( ) : type ; }
public keyspace metadata get k s meta data ( string keyspace name ) { assert keyspace name ! = null ; return keyspaces . get ( keyspace name ) ; }
public void load ( view definition view ) { c f meta data cfm = view . metadata ; pair < string , string > key = pair . create ( cfm . k name , cfm . cf name ) ; if ( cf id map . contains key ( key ) ) throw new runtime exception ( string . format ( `` attempt to load already load view % s . % s `` , cfm . k name , cfm . cf name ) ) ; logger . debug ( `` add { } to cf id map `` , cfm ) ; cf id map . put ( key , cfm . cf id ) ; }
public void update version ( ) { pair < uuid , uuid > mixed version = schema keyspace . calculate schema digest ( ) ; version = mixed version . leave ; alt version = mixed version . right ; system keyspace . update schema version ( get version ( ) ) ; }
public static aggregate function make min function ( final abstract type < ? > input type ) { return new native aggregate function ( `` min `` , input type , input type ) { public aggregate new aggregate ( ) { return new aggregate ( ) { private byte buffer min ; public void reset ( ) { min = null ; } public byte buffer compute ( protocol version protocol version ) { return min ; } public void add input ( protocol version protocol version , list < byte buffer > value ) { byte buffer value = value . get ( 0 ) ; if ( value == null ) return ; if ( min == null || return type ( ) . compare ( min , value ) > 0 ) min = value ; } } ; } } ; }
public page state get page state ( ) { return get specific option ( ) . state ; }
public final boolean have slice ( ) { for ( single restriction restriction : restriction ) { if ( restriction . be slice ( ) ) return true ; } return false ; }
public final boolean need filter ( ) { int position = 0 ; for ( single restriction restriction : restriction ) { if ( handle in filter ( restriction , position ) ) return true ; if ( ! restriction . be slice ( ) ) position = restriction . get last column ( ) . position ( ) + 1 ; } return have contains ( ) ; }
public boolean cluster key restriction have i n ( ) { return cluster columns restriction . have i n ( ) ; }
public operator get index operator ( bound b ) { if ( b . be start ( ) ) return bind inclusive [ b . idx ] ? operator . gte : operator . gt ; return bound inclusive [ b . idx ] ? operator . lte : operator . lt ; }
public boolean contain a complex column ( ) { for ( column definition def : get column ( ) ) if ( def . be complex ( ) ) return true ; return false ; }
public boolean applies to ( filter partition current ) throw invalid request exception { if ( static condition ! = null & & ! static condition . applies to ( current ) ) return false ; for ( row condition condition : condition . value ( ) ) { if ( ! condition . applies to ( current ) ) return false ; } return true ; }
public static invalid request exception invalid request ( string message template , object . . . message args ) { return new invalid request exception ( string . format ( message template , message args ) ) ; }
public comparator < row > row comparator ( ) { return row comparator ; }
public listenable future < commit log position > switch memtable if current ( memtable memtable ) { synchronize ( data ) { if ( data . get view ( ) . get current memtable ( ) == memtable ) return switch memtable ( ) ; } return wait for flush ( ) ; }
public tracker get tracker ( ) { return data ; }
public static column family store get if exists ( uuid cf id ) { pair < string , string > kscf = schema . instance . get c f ( cf id ) ; if ( kscf == null ) return null ; keyspace keyspace = keyspace . open ( kscf . left ) ; if ( keyspace == null ) return null ; return keyspace . get column family store ( cf id ) ; }
public static boolean be cql compatible ( c f meta data meta data ) { if ( meta data . be super ( ) ) return false ; if ( meta data . be compact table ( ) & & meta data . partition column ( ) . without static ( ) . size ( ) > 1 & & meta data . cluster column ( ) . size ( ) > = 1 ) return false ; return true ; }
public int simple column count ( ) { return complex idx ; }
public iterator < column definition > complex column ( ) { return b tree . iterator ( columns , complex idx , b tree . size ( column ) - 1 , b tree . dir . asc ) ; }
protect boolean ignore overlap ( ) { return false ; }
public void pause ( ) { write lock . lock ( ) ; try { be active = false ; } finally { write lock . unlock ( ) ; } }
public directory get directory ( ) { return directory ; }
public byte buffer create remote ( counter id id , long clock , long count ) { context state state = context state . allocate ( 0 , 0 , 1 ) ; state . write remote ( id , clock , count ) ; return state . context ; }
public clock and count get local clock and count ( byte buffer context ) { return get clock and count of ( context , counter id . get local id ( ) ) ; }
public static lifecycle transaction offline ( operation type operation type , s s table reader reader ) { return offline ( operation type , singleton ( reader ) ) ; }
public static void reschedule fail deletion ( ) { log transaction . reschedule fail deletion ( ) ; }
public void digest ( message digest digest ) { f b utility . update with long ( digest , timestamp ( ) ) ; }
public boolean supersedes ( liveness info other ) { if ( timestamp ! = other . timestamp ) return timestamp > other . timestamp ; if ( be expire ( ) ^ other . be expire ( ) ) return be expire ( ) ; if ( be expire ( ) == other . be expire ( ) ) return local expiration time ( ) > other . local expiration time ( ) ; return be expire ( ) ; }
public liveness info with updated timestamp ( long new timestamp ) { return new liveness info ( new timestamp ) ; }
public long header length ( ) { throw new unsupported operation exception ( ) ; }
public final column definition column ( ) { return column ; }
public encode stats merge with ( encode stats that ) { long min timestamp = this . min timestamp == timestamp_epoch ? that . min timestamp : ( that . min timestamp == timestamp_epoch ? this . min timestamp : math . min ( this . min timestamp , that . min timestamp ) ) ; int min del time = this . min local deletion time == deletion_time_epoch ? that . min local deletion time : ( that . min local deletion time == deletion_time_epoch ? this . min local deletion time : math . min ( this . min local deletion time , that . min local deletion time ) ) ; int min t t l = this . min t t l == ttl_epoch ? that . min t t l : ( that . min t t l == ttl_epoch ? this . min t t l : math . min ( this . min t t l , that . min t t l ) ) ; return new encode stats ( min timestamp , min del time , min t t l ) ; }
public deletion time start deletion time ( ) { return start deletion ; }
public unfiltered row iterator query memtable and disk ( column family store cf , read execution controller execution controller ) { assert execution controller ! = null & & execution controller . valid for read on ( cf ) ; trace . trace ( `` execute single-partition query on { } `` , cf . name ) ; return query memtable and disk internal ( cf ) ; }
public static boolean be empty ( cluster comparator comparator , cluster bound start , cluster bound end ) { assert start . be start ( ) & & end . be end ( ) ; return comparator . compare ( end , start ) < = 0 ; }
protect void on close ( ) { }
public collection < view > update view ( partition update update ) { list < view > match view = new array list < > ( view . size ( ) ) ; for ( view view : view ) { read query select query = view . get read query ( ) ; if ( ! select query . selects key ( update . partition key ( ) ) ) continue ; match view . add ( view ) ; } return match view ; }
public boolean enforce strict liveness ( ) { return ! base non p k column in view p k . be empty ( ) ; }
public static bound < partition position > make row bound ( token left , token right ) { return new bound < partition position > ( leave . min key bound ( ) , right . max key bound ( ) ) ; }
public static void set input split size ( configuration conf , int splitsize ) { conf . set int ( input_split_size_config , splitsize ) ; }
public static collection < string > get ignore host ( configuration conf ) { return conf . get string collection ( cql bulk record writer . ignore_hosts ) ; }
public static void progress ( task attempt context context ) { invoke ( progress_method , context ) ; }
public void write ( uuid host id , hint hint ) { write ( collection . singleton ( host id ) , hint ) ; }
public long get bloom filter off heap size ( ) { return bf . off heap size ( ) ; }
public i s s table scanner get scanner ( range < token > range , rate limiter limiter ) { if ( range == null ) return get scanner ( limiter ) ; return get scanner ( collection . singleton list ( range ) , limiter ) ; }
public string get datacenter ( inet address endpoint ) { if ( endpoint . equal ( f b utility . get broadcast address ( ) ) ) return my d c ; endpoint state ep state = gossiper . instance . get endpoint state for endpoint ( endpoint ) ; if ( ep state == null || ep state . get application state ( application state . dc ) == null ) { if ( psnitch == null ) { if ( saved endpoint == null ) save endpoint = system keyspace . load dc rack info ( ) ; if ( saved endpoint . contains key ( endpoint ) ) return save endpoint . get ( endpoint ) . get ( `` data_center `` ) ; return default_dc ; } else return psnitch . get datacenter ( endpoint ) ; } return ep state . get application state ( application state . dc ) . value ; }
public void update topology ( ) { lock . write lock ( ) . lock ( ) ; try { logger . info ( `` update topology for all endpoint that have change `` ) ; topology . update endpoint ( ) ; invalidate cache ring ( ) ; } finally { lock . write lock ( ) . unlock ( ) ; } }
public void clear unsafe ( ) { lock . write lock ( ) . lock ( ) ; try { token to endpoint map . clear ( ) ; endpoint to host id map . clear ( ) ; bootstrap token . clear ( ) ; leave endpoint . clear ( ) ; pending range . clear ( ) ; move endpoint . clear ( ) ; sort token . clear ( ) ; topology . clear ( ) ; invalidate cache ring ( ) ; } finally { lock . write lock ( ) . unlock ( ) ; } }
public long count ( ) { return count . get ( ) ; }
public i verb handler get verb handler ( verb type ) { return verb handler . get ( type ) ; }
public optional < view definition > get ( string name ) { return optional . of nullable ( view . get ( name ) ) ; }
public view without ( string name ) { view definition materialize view = get ( name ) . or else throw ( ( ) - > new illegal state exception ( string . format ( `` materialize view % s do n't exist `` , name ) ) ) ; return builder ( ) . add ( filter ( this , v - > v ! = materialized view ) ) . build ( ) ; }
public static s s l socket get socket ( encryption option option ) throw i o exception { s s l context ctx = create s s l context ( option , true ) ; s s l socket socket = ( s s l socket ) ctx . get socket factory ( ) . create socket ( ) ; try { prepare socket ( socket , option ) ; return socket ; } catch ( illegal argument exception e ) { socket . close ( ) ; throw e ; } }
public stream plan transfer file ( inet address to , collection < stream session . s s table stream section > sstable detail ) { coordinator . transfer file ( to , sstable detail ) ; return this ; }
public synchronize void receive ( s s table multi writer sstable ) { if ( do ) { logger . warn ( `` [ { } ] receive sstable { } on already finish stream receive task . abort sstable . `` , session . plan id ( ) , sstable . get filename ( ) ) ; throwables . maybe fail ( sstable . abort ( null ) ) ; return ; } remote s s table received++ ; assert cf id . equal ( sstable . get cf id ( ) ) ; collection < s s table reader > finish = null ; try { finish = sstable . finish ( true ) ; } catch ( throwable t ) { throwables . maybe fail ( sstable . abort ( t ) ) ; } txn . update ( finish , false ) ; sstables . add all ( finish ) ; if ( remote s s table receive == total file ) { do = true ; executor . submit ( new on completion runnable ( this ) ) ; } }
protect long write ( random access reader reader , checksum validator validator , int start , long length , long byte transfer ) throw i o exception { int to transfer = ( int ) math . min ( transfer buffer . length , length - byte transfer ) ; int min readable = ( int ) math . min ( transfer buffer . length , reader . length ( ) - reader . get file pointer ( ) ) ; reader . read fully ( transfer buffer , 0 , min readable ) ; if ( validator ! = null ) validator . validate ( transfer buffer , 0 , min readable ) ; limiter . acquire ( to transfer - start ) ; compress output . write ( transfer buffer , start , ( to transfer - start ) ) ; return to transfer ; }
public boolean be open ( ) { if ( socket == null ) { return false ; } return socket . be connect ( ) ; }
public synchronize status wait activity ( long timeout ) { if ( status == status . idle ) { try { wait ( timeout ) ; } catch ( interrupted exception e ) { throw new runtime exception ( ) ; } } if ( status == status . active ) { status = status . idle ; return status . active ; } return status ; }
public collection < mutation > execute ( collection < ? extend i mutation > mutation ) throw invalid request exception { boolean have counter = false ; list < mutation > augment mutation = null ; for ( i mutation mutation : mutation ) { if ( mutation instanceof counter mutation ) have counter = true ; for ( partition update upd : mutation . get partition update ( ) ) { list < mutation > augmentation = execute internal ( upd ) ; if ( augmentation == null || augmentation . be empty ( ) ) continue ; validate ( augmentation ) ; if ( augmented mutation == null ) augment mutation = new link list < > ( ) ; augment mutation . add all ( augmentation ) ; } } if ( augmented mutation == null ) return null ; if ( have counter ) throw new invalid request exception ( `` counter mutation and trigger mutation can not be apply together atomically . `` ) ; @ suppress warning ( `` unchecked `` ) collection < mutation > original mutation = ( collection < mutation > ) mutation ; return merge mutation ( iterables . concat ( original mutation , augment mutation ) ) ; }
public static int to array ( object [ ] tree , object [ ] target , int target offset ) { return to array ( tree , 0 , size ( tree ) , target , target offset ) ; }
public boolean try interval lock ( long interval ) { long now = time source . current time millis ( ) ; boolean acquire = ( now - last acquire . get ( ) > = interval ) & & write lock ( ) . try lock ( ) ; if ( acquire ) last acquire . set ( now ) ; return acquire ; }
public void release ( ) { state . release ( false ) ; }
public int get wait ( ) { if ( ! have waiter ( ) ) return 0 ; iterator < register signal > iter = queue . iterator ( ) ; int count = 0 ; while ( iter . have next ( ) ) { signal next = iter . next ( ) ; if ( ! next . be cancel ( ) ) count++ ; } return count ; }
public static void wait on condition ( boolean supplier condition , wait queue queue ) { while ( ! condition . get a boolean ( ) ) { signal s = queue . register ( ) ; if ( ! condition . get a boolean ( ) ) { s . await uninterruptibly ( ) ; } else { s . cancel ( ) ; } } }
public static inet address get local address ( ) { if ( local inet address == null ) try { local inet address = database descriptor . get listen address ( ) == null ? inet address . get local host ( ) : database descriptor . get listen address ( ) ; } catch ( unknown host exception e ) { throw new runtime exception ( e ) ; } return local inet address ; }
public static void update checksum ( crc32 checksum , byte buffer buffer , int offset , int length ) { int position = buffer . position ( ) ; int limit = buffer . limit ( ) ; buffer . position ( offset ) . limit ( offset + length ) ; checksum . update ( buffer ) ; buffer . position ( position ) . limit ( limit ) ; }
public static list < range < token > > difference ( merkle tree ltree , merkle tree rtree ) { list < range < token > > difference = new array list < > ( ) ; for ( merkle tree tree : ltree . merkle tree . value ( ) ) { difference . add all ( merkle tree . difference ( tree , rtree . get merkle tree ( tree . full range ) ) ) ; } return difference ; }
public static long size of array ( byte [ ] bytes ) { return size of array ( byte . length , 1 ) ; }
public static boolean be power of two ( int v ) { return ( ( v & ( v-1 ) ) == 0 ) ; }
public void acquire ( double rate ) { rate limiter limiter = ref . get ( ) ; if ( limiter == null || limiter . get rate ( ) ! = rate ) { ref . compare and set ( limiter , rate limiter . create ( rate ) ) ; limiter = ref . get ( ) ; } limiter . acquire ( 1 ) ; }
public string a c q l query ( ) { return a c q l query ( false ) ; }
public listenable future < session > connect async ( ) { return connect async ( null ) ; }
public string get cluster name ( ) { return manager . cluster name ; }
public cluster unregister ( latency tracker tracker ) { check not close ( manager ) ; boolean remove = manager . latency tracker . remove ( tracker ) ; if ( remove ) tracker . on unregister ( this ) ; return this ; }
public long get nanosecond ( ) { return nanosecond ; }
public string get keyspace ( ) { return keyspace ; }
public consistency level get consistency level ( ) { return consistency ; }
public int get successful execution index ( ) { return successful execution index ; }
public query trace get query trace ( ) { return trace ; }
public data type get return type ( ) { return return type ; }
public inet address get address ( ) { return address . get address ( ) ; }
public uuid get schema version ( ) { return schema version ; }
public collection < user type > get user type ( ) { return collection . unmodifiable collection ( user type . value ( ) ) ; }
public static boolean be reserve cql keyword ( string id ) { if ( id == null ) { return false ; } int hash = case insensitive hash ( id ) ; list < char [ ] > keywords = reserved_keywords . get ( hash ) ; if ( keywords == null ) { return false ; } else { for ( char [ ] keyword : keywords ) { if ( equal ignore case ascii ( id , keyword ) ) { return true ; } } return false ; } }
public set < host > get all host ( ) { return new hash set < host > ( all host ( ) ) ; }
public boolean check schema agreement ( ) { try { return cluster . control connection . check schema agreement ( ) ; } catch ( exception e ) { logger . warn ( `` error while check schema agreement `` , e ) ; return false ; } }
public gauge < integer > get trashed connection ( ) { return trash connection ; }
public static string quote ( string value ) { return quote ( value , '\ `` ) ; }
public static string unquote ( string value ) { return unquote ( value , '\ `` ) ; }
public static builder builder ( load balancing policy child policy ) { return new builder ( child policy ) ; }
public static address translator default address translator ( ) { return default_address_translator ; }
public retry policy get retry policy ( ) { return retry policy ; }
public int get max schema agreement wait second ( ) { return max schema agreement wait second ; }
public option use ( use use ) { return using . and ( use ) ; }
public static order desc ( string column name ) { return new order ( column name , true ) ; }
public static use timestamp ( long timestamp ) { if ( timestamp < 0 ) throw new illegal argument exception ( `` invalid timestamp , must be positive `` ) ; return new use . with value ( `` timestamp `` , timestamp ) ; }
public static assignment incr ( string name ) { return incr ( name , 1l ) ; }
public static assignment discard all ( string name , list < ? > list ) { return new assignment . collection assignment ( name , list , false ) ; }
public static assignment remove ( string name , object value ) { if ( value instanceof bind marker ) { throw new invalid query exception ( `` bind a value in remove ( ) be not support , use remove all ( ) and bind a singleton set `` ) ; } return remove all ( name , collection . singleton ( value ) ) ; }
public static object fcall ( string name , object . . . parameter ) { return new utils . f call ( name , parameter ) ; }
public static object alias ( object column , string alias ) { return new utils . alias ( column , alias ) ; }
public query option set default idempotence ( boolean default idempotence ) { this . default idempotence = default idempotence ; return this ; }
public int get refresh node list interval millis ( ) { return refresh node list interval millis ; }
public query option set max pending refresh node list request ( int max pending refresh node list request ) { this . max pending refresh node list request = max pending refresh node list request ; return this ; }
public query option set refresh node interval millis ( int refresh node interval millis ) { this . refresh node interval millis = refresh node interval millis ; return this ; }
public t add u d t column ( string column name , u d t type udt type ) { validate not empty ( column name , `` column name `` ) ; validate not null ( udt type , `` column type `` ) ; validate not key word ( column name , string . format ( `` the column name ' % s ' be not allow because it be a reserved keyword `` , column name ) ) ; simple column . put ( column name , udt type ) ; return self ; }
public create add u d t cluster column ( string column name , u d t type udt type ) { validate not empty ( column name , `` cluster column name `` ) ; validate not null ( udt type , `` udt cluster column type `` ) ; validate not key word ( column name , string . format ( `` the clustering column name ' % s ' be not allow because it be a reserved keyword `` , column name ) ) ; cluster column . put ( column name , udt type ) ; return this ; }
public create index if not exist ( ) { this . if not exist = true ; return this ; }
public string build ( ) { return build internal ( ) ; }
public static create index create index ( string index name ) { return new create index ( index name ) ; }
public static u d t type frozen ( string udt name ) { return u d t type . frozen ( udt name ) ; }
public static u d t type udt literal ( string literal ) { return u d t type . literal ( literal ) ; }
public t caching ( schema builder . key cache key , cache row per partition row per partition ) { this . cassandra21 key cache = optional . from nullable ( key ) ; this . cassandra21 row cache = optional . from nullable ( row per partition ) ; return self ; }
public t bloom filter f p chance ( double fp chance ) { validate rate value ( fp chance , `` bloom filter false positive change `` ) ; this . bloom filter f p chance = optional . from nullable ( fp chance ) ; return self ; }
public t gc grace second ( integer gc grace second ) { this . gc grace second = optional . from nullable ( gc grace second ) ; return self ; }
public t freeform option ( string key , object value ) { if ( string . be null or empty ( key ) ) { throw new illegal argument exception ( `` key for custom option should not be null or blank `` ) ; } custom option . add ( build custom option ( key , value ) ) ; return self ; }
public object get object ( string name ) { if ( name value == null ) throw new illegal state exception ( `` this statement do not have name value `` ) ; return name value . get ( name ) ; }
public boolean get reuse address ( ) { return reuse address ; }
public statement set retry policy ( retry policy policy ) { this . retry policy = policy ; return this ; }
public token get start ( ) { return start ; }
public static type codec < byte buffer > custom ( data type . custom type type ) { return new custom codec ( type ) ; }
public string get keyspace ( ) { return keyspace ; }
public int get minor ( ) { return minor ; }
public string get build label ( ) { return build ; }
public object load class and return enum value ( final boolean ignore exception ) throw illegal argument exception { final class < ? > class ref = super . load class ( ignore exception ) ; if ( class ref == null ) { if ( ignore exception ) { return null ; } else { throw new illegal argument exception ( `` enum class `` + class name + `` could not be load `` ) ; } } if ( ! class ref . be enum ( ) ) { throw new illegal argument exception ( `` class `` + class name + `` be not an enum `` ) ; } field field ; try { field = class ref . get declared field ( value name ) ; } catch ( final reflective operation exception | security exception e ) { throw new illegal argument exception ( `` could not find enum constant `` + to string ( ) , e ) ; } if ( ! field . be enum constant ( ) ) { throw new illegal argument exception ( `` field `` + to string ( ) + `` be not an enum constant `` ) ; } try { return field . get ( null ) ; } catch ( final reflective operation exception | security exception e ) { throw new illegal argument exception ( `` field `` + to string ( ) + `` be not accessible `` , e ) ; } }
public string get type signature str ( ) { return array type signature . get type signature str ( ) ; }
protect void find referenced class name ( final set < string > refd class name ) { element type signature . find referenced class name ( refd class name ) ; }
public class graph disable nested jar scanning ( ) { scan spec . scan nested jar = false ; return this ; }
public class graph enable external class ( ) { enable class info ( ) ; scan spec . enable external class = true ; return this ; }
public class graph ignore parent module layer ( ) { scan spec . ignore parent module layer = true ; return this ; }
public class graph blacklist jar ( final string . . . jar leaf name ) { for ( final string jar leaf name : jar leaf name ) { final string leaf name = jar utils . leaf name ( jar leaf name ) ; if ( ! leaf name . equal ( jar leaf name ) ) { throw new illegal argument exception ( `` can only blacklist jar by leafname : `` + jar leaf name ) ; } scan spec . jar white black list . add to blacklist ( leaf name ) ; } return this ; }
public boolean be annotation ( ) { return ( modifier & annotation_class_modifier ) ! = 0 ; }
public boolean be implement interface ( ) { return relate class . get ( rel type . classes_implementing ) ! = null || be interface ( ) ; }
public class info list get inner class ( ) { return new class info list ( this . filter class info ( rel type . contains_inner_class , / * strict whitelist = * / false ) , / * sort by name = * / true ) ; }
public method info list get declare constructor info ( ) { return get declare method info ( / * method name = * / null , / * get normal method = * / false , / * get constructor method = * / true , / * get static initializer method = * / false ) ; }
public field info get declared field info ( final string field name ) { if ( ! scan result . scan spec . enable field info ) { throw new illegal argument exception ( `` please call class graph # enable field info ( ) before # scan ( ) `` ) ; } if ( field info == null ) { return null ; } for ( final field info fi : field info ) { if ( fi . get name ( ) . equal ( field name ) ) { return fi ; } } return null ; }
public int compare to ( final class info o ) { return this . name . compare to ( o . name ) ; }
public boolean equal ( final object obj ) { if ( obj == this ) { return true ; } else if ( ! ( obj instanceof class info ) ) { return false ; } final class info other = ( class info ) obj ; return name . equal ( other . name ) ; }
public list < class ref type signature > get superinterface signature ( ) { return superinterface signature ; }
public int get modifier ( ) { return modifier ; }
public annotation info list get annotation info ( ) { if ( ! scan result . scan spec . enable annotation info ) { throw new illegal argument exception ( `` please call class graph # enable annotation info ( ) before # scan ( ) `` ) ; } return annotation info == null ? annotation info list . empty_list : annotation info list . get indirect annotation ( annotation info , / * annotate class = * / null ) ; }
public boolean have annotation ( final string annotation name ) { return get annotation info ( ) . contains name ( annotation name ) ; }
public boolean be final ( ) { return modifier . be final ( modifier ) ; }
public object get layer ( ) { return layer ; }
public resource list get resource with path ( final string resource path ) { if ( close . get ( ) ) { throw new illegal argument exception ( `` can not use a scan result after it have be close `` ) ; } final resource list all whitelisted resource = get all resource ( ) ; if ( all whitelisted resource . be empty ( ) ) { return resource list . empty_list ; } else { final string path = file utils . sanitize entry path ( resource path , / * remove initial slash = * / true ) ; final resource list resource list = get all resource a map ( ) . get ( path ) ; return ( resource list == null ? new resource list ( 1 ) : resource list ) ; } }
public resource list get resource with extension ( final string extension ) { if ( close . get ( ) ) { throw new illegal argument exception ( `` can not use a scan result after it have be close `` ) ; } final resource list all whitelisted resource = get all resource ( ) ; if ( all whitelisted resource . be empty ( ) ) { return resource list . empty_list ; } else { string bare extension = extension ; while ( bare extension . start with ( `` . `` ) ) { bare extension = bare extension . substring ( 1 ) ; } final resource list filter resource = new resource list ( ) ; for ( final resource classpath resource : all whitelisted resource ) { final string relative path = classpath resource . get path ( ) ; final int last slash idx = relative path . last index of ( '/ ' ) ; final int last dot idx = relative path . last index of ( ' . ' ) ; if ( last dot idx > last slash idx & & relative path . substring ( last dot idx + 1 ) . equal ignore case ( bare extension ) ) { filtered resource . add ( classpath resource ) ; } } return filtered resource ; } }
public class info list get all interface and annotation ( ) { if ( close . get ( ) ) { throw new illegal argument exception ( `` can not use a scan result after it have be close `` ) ; } if ( ! scan spec . enable class info || ! scan spec . enable annotation info ) { throw new illegal argument exception ( `` please call class graph # enable class info ( ) and # enable annotation info ( ) before # scan ( ) `` ) ; } return class info . get all interface or annotation class ( class name to class info . value ( ) , scan spec ) ; }
public reference type signature get type signature ( ) { return type signature ; }
public void interrupt ( ) { interrupted . set ( true ) ; thread . current thread ( ) . interrupt ( ) ; }
public static string serialize from field ( final object contain object , final string field name , final int indent width , final boolean only serialize public field , final class field cache class field cache ) { final field type info field resolve type info = class field cache . get ( contain object . get class ( ) ) . field name to field type info . get ( field name ) ; if ( field resolve type info == null ) { throw new illegal argument exception ( `` class `` + containing object . get class ( ) . get name ( ) + `` do not have a field name \ `` `` + field name + `` \ `` `` ) ; } final field field = field resolve type info . field ; if ( ! j s o n utils . field be serializable ( field , / * only serialize public field = * / false ) ) { throw new illegal argument exception ( `` field `` + containing object . get class ( ) . get name ( ) + `` . `` + field name + `` need to be accessible , non-transient , and non-final `` ) ; } object field value ; try { field value = j s o n utils . get field value ( contain object , field ) ; } catch ( final illegal access exception e ) { throw new illegal argument exception ( `` could get value of field `` + field name , e ) ; } return serialize object ( field value , indent width , only serialize public field , class field cache ) ; }
public void sort prefix ( ) { for ( final field field : scan spec . class . get declared field ( ) ) { if ( white black list . class . be assignable from ( field . get type ( ) ) ) { try { ( ( white black list ) field . get ( this ) ) . sort prefix ( ) ; } catch ( final reflective operation exception e ) { throw class graph exception . new class graph exception ( `` field be not accessible : `` + field , e ) ; } } } }
public static string path to package name ( final string path ) { return path . replace ( '/ ' , ' . ' ) ; }
public boolean blacklist be empty ( ) { return blacklist == null & & blacklist prefix == null & & blacklist glob == null ; }
public boolean be specifically whitelisted and not blacklist ( final string str ) { return ! whitelist be empty ( ) & & be whitelisted and not blacklist ( str ) ; }
protect object create primitive property ( string name , class type ) { if ( type == boolean . type ) { return boolean . false ; } else if ( type == integer . type ) { return integer_ z e r o ; } else if ( type == long . type ) { return long_ z e r o ; } else if ( type == double . type ) { return double_ z e r o ; } else if ( type == float . type ) { return float_ z e r o ; } else if ( type == byte . type ) { return byte_ z e r o ; } else if ( type == short . type ) { return short_ z e r o ; } else if ( type == character . type ) { return character_ s p a c e ; } else { return null ; } }
public iterator iterator ( ) { return hashcode map . value ( ) . iterator ( ) ; }
public static option builder have args ( ) { instance . number of args = option . unlimited_values ; return instance ; }
public option add option ( string opt , string long opt , boolean have arg , string description ) { add option ( new option ( opt , long opt , have arg , description ) ) ; return this ; }
public static object create object ( string str ) { class cl = null ; try { cl = class . for name ( str ) ; } catch ( class not find exception cnfe ) { system . err . println ( `` unable to find : `` +str ) ; return null ; } object instance = null ; try { instance = cl . new instance ( ) ; } catch ( instantiation exception cnfe ) { system . err . println ( `` instantiation exception ; unable to create : `` +str ) ; return null ; } catch ( illegal access exception cnfe ) { system . err . println ( `` illegal access exception ; unable to create : `` +str ) ; return null ; } return instance ; }
public static bag decorate ( bag bag , class type ) { return new predicate bag ( bag , instanceof predicate . get instance ( type ) ) ; }
public static bidi map decorate ( bidi map map ) { if ( map instanceof unmodifiable ) { return map ; } return new unmodifiable bidi map ( map ) ; }
public boolean be full ( ) { return size ( ) == max element ; }
public object get ( ) { if ( be empty ( ) ) { throw new buffer underflow exception ( `` the buffer be already empty `` ) ; } return m_elements [ m_start ] ; }
public object get ( final long timeout ) { synchronize ( lock ) { final long expiration = system . current time millis ( ) + timeout ; long time leave = expiration - system . current time millis ( ) ; while ( time leave > 0 & & collection . be empty ( ) ) { try { lock . wait ( time leave ) ; time leave = expiration - system . current time millis ( ) ; } catch ( interrupted exception e ) { print writer out = new print writer ( new string writer ( ) ) ; e . print stack trace ( out ) ; throw new buffer underflow exception ( `` cause by interrupted exception : `` + out . to string ( ) ) ; } } if ( collection . be empty ( ) ) { throw new buffer underflow exception ( `` timeout expired `` ) ; } return get buffer ( ) . get ( ) ; } }
public comparator comparator ( ) { return comparator ; }
public static closure chain closure ( closure closure1 , closure closure2 ) { return chain closure . get instance ( closure1 , closure2 ) ; }
public static closure switch map closure ( map object and closure ) { closure [ ] trs = null ; predicate [ ] preds = null ; if ( object and closure == null ) { throw new illegal argument exception ( `` the object and closure map must not be null `` ) ; } closure def = ( closure ) object and closure . remove ( null ) ; int size = object and closure . size ( ) ; trs = new closure [ size ] ; preds = new predicate [ size ] ; int i = 0 ; for ( iterator it = object and closure . entry set ( ) . iterator ( ) ; it . have next ( ) ; ) { map . entry entry = ( map . entry ) it . next ( ) ; preds [ i ] = equal predicate . get instance ( entry . get key ( ) ) ; trs [ i ] = ( closure ) entry . get value ( ) ; i++ ; } return switch closure ( preds , trs , def ) ; }
public static void for all do ( collection collection , closure closure ) { if ( collection ! = null & & closure ! = null ) { for ( iterator it = collection . iterator ( ) ; it . have next ( ) ; ) { closure . execute ( it . next ( ) ) ; } } }
public static void select ( collection input collection , predicate predicate , collection output collection ) { if ( input collection ! = null & & predicate ! = null ) { for ( iterator iter = input collection . iterator ( ) ; iter . have next ( ) ; ) { object item = iter . next ( ) ; if ( predicate . evaluate ( item ) ) { output collection . add ( item ) ; } } } }
public boolean add ( object o ) { insert listable ( _head . prev ( ) , null , o ) ; return true ; }
public object remove first ( ) { if ( _head . next ( ) ! = null ) { object val = _head . next ( ) . value ( ) ; remove listable ( _head . next ( ) ) ; return val ; } else { throw new no such element exception ( ) ; } }
public int hash code ( ) { return _map . hash code ( ) ; }
public boolean get fast ( ) { return ( this . fast ) ; }
public boolean be empty ( ) { if ( fast ) { return ( list . be empty ( ) ) ; } else { synchronize ( list ) { return ( list . be empty ( ) ) ; } } }
public object remove ( int index ) { if ( fast ) { synchronize ( this ) { array list temp = ( array list ) list . clone ( ) ; object result = temp . remove ( index ) ; list = temp ; return ( result ) ; } } else { synchronize ( list ) { return ( list . remove ( index ) ) ; } } }
public object [ ] to array ( object array [ ] ) { if ( fast ) { return ( list . to array ( array ) ) ; } else { synchronize ( list ) { return ( list . to array ( array ) ) ; } } }
public predicate [ ] get predicate ( ) { return i predicate ; }
public transformer get transformer ( ) { return i transformer ; }
public object previous ( ) throw no such element exception { if ( current index == 0 ) { throw new no such element exception ( ) ; } -- current index ; return list . get ( current index ) ; }
public static map iterator empty map iterator ( ) { return empty_map_iterator ; }
public static list type list ( list list , class type ) { return type list . decorate ( list , type ) ; }
public void put all ( map map ) { int map size = map . size ( ) ; if ( map size == 0 ) { return ; } int new size = ( int ) ( ( size + map size ) / load factor + 1 ) ; ensure capacity ( calculate new capacity ( new size ) ) ; for ( iterator it = map . entry set ( ) . iterator ( ) ; it . have next ( ) ; ) { map . entry entry = ( map . entry ) it . next ( ) ; put ( entry . get key ( ) , entry . get value ( ) ) ; } }
protect void remove mapping ( hash entry entry , int hash index , hash entry previous ) { mod count++ ; remove entry ( entry , hash index , previous ) ; size -- ; destroy entry ( entry ) ; }
public object first key ( ) { if ( size == 0 ) { throw new no such element exception ( `` map be empty `` ) ; } return header . after . get key ( ) ; }
public object last key ( ) { if ( size == 0 ) { throw new no such element exception ( `` map be empty `` ) ; } return header . before . get key ( ) ; }
protect hash entry create entry ( hash entry next , int hash code , object key , object value ) { return new link entry ( next , hash code , key , value ) ; }
protect link entry entry after ( link entry entry ) { return entry . after ; }
public void set mutator ( map mutator mutator ) { this . mutator = mutator ; }
public void put all ( map map ) { if ( this . mutator == null ) { throw new unsupported operation exception ( `` no mutator specify `` ) ; } this . mutator . put all ( this , this . composite , map ) ; }
protect map transform map ( map map ) { if ( map . be empty ( ) ) { return map ; } map result = new link map ( map . size ( ) ) ; for ( iterator it = map . entry set ( ) . iterator ( ) ; it . have next ( ) ; ) { map . entry entry = ( map . entry ) it . next ( ) ; result . put ( transform key ( entry . get key ( ) ) , transform value ( entry . get value ( ) ) ) ; } return result ; }
public static map get map ( final map map , final object key ) { if ( map ! = null ) { object answer = map . get ( key ) ; if ( answer ! = null & & answer instanceof map ) { return ( map ) answer ; } } return null ; }
public static short get short ( map map , object key , short default value ) { short answer = get short ( map , key ) ; if ( answer == null ) { answer = default value ; } return answer ; }
public static double get double ( map map , object key , double default value ) { double answer = get double ( map , key ) ; if ( answer == null ) { answer = default value ; } return answer ; }
public static boolean be not empty ( map map ) { return ! map utils . be empty ( map ) ; }
public static map predicate map ( map map , predicate key pred , predicate value pred ) { return predicate map . decorate ( map , key pred , value pred ) ; }
public static map multi value map ( map map , class collection class ) { return multi value map . decorate ( map , collection class ) ; }
public static map multi value map ( map map , factory collection factory ) { return multi value map . decorate ( map , collection factory ) ; }
public boolean contains key ( object key ) { purge ( ) ; entry entry = get entry ( key ) ; if ( entry == null ) return false ; return entry . get value ( ) ! = null ; }
public static set decorate ( set set , class type ) { return new predicate set ( set , instanceof predicate . get instance ( type ) ) ; }
public synchronize boolean be empty ( ) { return m_priority queue . be empty ( ) ; }
public synchronize object peek ( ) throw no such element exception { return m_priority queue . peek ( ) ; }
public static transformer nop transformer ( ) { return n o p transformer . instance ; }
public int available ( ) throw i o exception { ensure open ( ) ; if ( this . entry e o f ) { return 0 ; } return 1 ; }
public void close ( ) throw i o exception { if ( ! finish ) { finish ( ) ; } if ( ! close ) { buffer . close ( ) ; out . close ( ) ; close = true ; } }
public void set list delimiter ( char list delimiter ) { this . list delimiter = list delimiter ; }
public boolean be delimiter parse disabled ( ) { return delimiter parse disable ; }
public boolean be throw exception on miss ( ) { return throw exception on miss ; }
protect configuration interpolator create interpolator ( ) { configuration interpolator interpol = new configuration interpolator ( ) ; interpol . set default lookup ( new str lookup ( ) { @ override public string lookup ( string var ) { object prop = resolve container store ( var ) ; return ( prop ! = null ) ? prop . to string ( ) : null ; } } ) ; return interpol ; }
public void add error log listener ( ) { add error listener ( new configuration error listener ( ) { public void configuration error ( configuration error event event ) { get logger ( ) . warn ( `` internal error `` , event . get cause ( ) ) ; } } ) ; }
public void save ( url url ) throw configuration exception { output stream out = null ; try { out = file system . get output stream ( url ) ; save ( out ) ; if ( out instanceof verifiable output stream ) { ( ( verifiable output stream ) out ) . verify ( ) ; } } catch ( i o exception e ) { throw new configuration exception ( `` could not save to url `` + url , e ) ; } finally { close silent ( out ) ; } }
protect void enter no reload ( ) { synchronize ( reload lock ) { no reload++ ; } }
protect void set delegate ( file configuration delegate delegate ) { this . delegate = delegate ; }
public boolean be empty ( ) { return store . be empty ( ) ; }
public void set configuration file name ( string configuration file name ) { file file = new file ( configuration file name ) . get absolute file ( ) ; this . configuration file name = file . get name ( ) ; implicit base path = file . get parent ( ) ; }
public configuration key append ( string property ) { if ( key buffer . length ( ) > 0 & & ! have delimiter ( ) & & ! be attribute key ( property ) ) { key buffer . append ( property_delimiter ) ; } key buffer . append ( property ) ; remove trail delimiter ( ) ; return this ; }
public static file file from u r l ( url url ) { if ( url == null || ! url . get protocol ( ) . equal ( protocol_file ) ) { return null ; } else { string filename = url . get file ( ) . replace ( '/ ' , file . separator char ) ; int po = 0 ; while ( ( pos = filename . index of ( ' % ' , po ) ) > = 0 ) { if ( pos + 2 < filename . length ( ) ) { string hex str = filename . substring ( pos + 1 , po + 3 ) ; char ch = ( char ) integer . parse int ( hex str , hex ) ; filename = filename . substring ( 0 , po ) + ch + filename . substring ( pos + 3 ) ; } } return new file ( filename ) ; } }
protect void fire element start ( string name , attribute attribs ) { if ( get exception ( ) == null ) { try { attribute at = ( attribs == null ) ? empty_attrs : attribs ; get content handler ( ) . start element ( ns_uri , name , name , at ) ; } catch ( s a x exception ex ) { exception = ex ; } } }
public list < short > get short list ( string key ) { return get short list ( key , new array list < short > ( ) ) ; }
public short [ ] get short array ( string key ) { return get short array ( key , new short [ 0 ] ) ; }
public list < long > get long list ( string key ) { return get long list ( key , new array list < long > ( ) ) ; }
public list < big integer > get big integer list ( string key ) { return get big integer list ( key , new array list < big integer > ( ) ) ; }
public url [ ] get u r l array ( string key ) { return get u r l array ( key , new url [ 0 ] ) ; }
public color get color ( string key ) { return get ( color . class , key ) ; }
public configuration provider provider for tag ( string tag name ) { return provider . get ( tag name ) ; }
public configuration get configuration ( ) throw configuration exception { return get configuration ( true ) ; }
public object get property value ( ) { return property value ; }
public collection < configuration listener > get configuration listener ( ) { return collection . unmodifiable collection ( new array list < configuration listener > ( listener ) ) ; }
public void set detail event ( boolean enable ) { synchronize ( lock detail event count ) { if ( enable ) { detail events++ ; } else { detail event -- ; } } }
public collection < configuration error listener > get error listener ( ) { return collection . unmodifiable collection ( new array list < configuration error listener > ( error listener ) ) ; }
public static void set default file system ( file system f ) throw null pointer exception { if ( fs == null ) { throw new null pointer exception ( `` a file system implementation be require `` ) ; } file system = f ; }
public void set root ( node node ) { if ( node == null ) { throw new illegal argument exception ( `` root node must not be null ! `` ) ; } root = node ; root node = null ; }
public int get max index ( string key ) { return fetch node list ( key ) . size ( ) - 1 ; }
protected list < configuration node > fetch node list ( string key ) { return get expression engine ( ) . query ( get root node ( ) , key ) ; }
public void set configuration ( hierarchical configuration config ) { configuration = config ; }
protect boolean be section line ( string line ) { if ( line == null ) { return false ; } return line . start with ( `` [ `` ) & & line . end with ( `` ] `` ) ; }
public static boolean deregister global lookup ( string prefix ) { synchronize ( global lookup ) { return global lookup . remove ( prefix ) ! = null ; } }
public configuration interpolator get parent interpolator ( ) { return this . parent interpolator ; }
public context get base context ( ) throw name exception { if ( base context == null ) { base context = ( context ) get context ( ) . lookup ( prefix == null ? `` `` : prefix ) ; } return base context ; }
public long get refresh delay ( ) { return refresh delay ; }
public void set expression engine ( default expression engine expression engine ) { if ( expression engine == null ) { throw new illegal argument exception ( `` expression engine must not be null ! `` ) ; } this . expression engine = expression engine ; }
public string trim right ( string key ) { if ( key == null ) { return string utils . empty ; } else { string result = key ; while ( have trail delimiter ( result ) ) { result = result . substring ( 0 , result . length ( ) - get expression engine ( ) . get property delimiter ( ) . length ( ) ) ; } return result ; } }
public configuration node get parent node ( ) { return parent ; }
public int get child count ( string name ) { return child . get sub node ( name ) . size ( ) ; }
public configuration node get child ( int index ) { return child . get node ( index ) ; }
public void remove child ( ) { child . clear ( ) ; }
public list < configuration node > get attribute ( string name ) { return attribute . get sub node ( name ) ; }
public string get index end ( ) { return index end ; }
public boolean be attribute ( ) { return attribute ; }
public void set new node name ( string new node name ) { this . new node name = new node name ; }
public void add path node ( string node name ) { if ( path node == null ) { path node = new link list < string > ( ) ; } path node . add ( node name ) ; }
public void append child ( configuration node source ) { if ( source ! = null ) { for ( configuration node child : source . get child ( ) ) { add child ( child ) ; } } }
public string get root element name ( ) { if ( get document ( ) == null ) { return ( root element name == null ) ? default_root_name : root element name ; } else { return get document ( ) . get document element ( ) . get node name ( ) ; } }
public boolean be schema validation ( ) { return schema validation ; }
public document get document ( ) { return document ; }
public void save ( document document , node parent ) { element property = document . create element ( `` property `` ) ; parent . append child ( property ) ; if ( get header ( ) ! = null ) { element comment = document . create element ( `` comment `` ) ; property . append child ( comment ) ; comment . set text content ( string escape utils . escape xml ( get header ( ) ) ) ; } iterator < string > key = get key ( ) ; while ( key . have next ( ) ) { string key = key . next ( ) ; object value = get property ( key ) ; if ( value instanceof list ) { write property ( document , property , key , ( list < ? > ) value ) ; } else { write property ( document , property , key , value ) ; } } }
public map get nest bean declaration ( ) { map nest = new hash map ( ) ; for ( iterator it = get node ( ) . get child ( ) . iterator ( ) ; it . have next ( ) ; ) { configuration node child = ( configuration node ) it . next ( ) ; if ( ! be reserve node ( child ) ) { nest . put ( child . get name ( ) , create bean declaration ( child ) ) ; } } return nest ; }
public string to string ( ) { return key buffer . to string ( ) ; }
public int hash code ( ) { return string . value of ( key buffer ) . hash code ( ) ; }
public set entry set ( ) { return new configuration set ( configuration ) ; }
public object get ( object key ) { return configuration . get property ( string . value of ( key ) ) ; }
public void clear property ( string key ) { fire event ( event_clear_property , key , null , true ) ; list node = fetch node list ( key ) ; for ( iterator it = node . iterator ( ) ; it . have next ( ) ; ) { clear node ( ( configuration node ) it . next ( ) ) ; } fire event ( event_clear_property , key , null , false ) ; }
protect node create node ( string name ) { return new node ( name ) ; }
public configuration get parse configuration ( ) { return get configuration ( ) ; }
protect void add property direct ( string key , object obj ) { throw new unsupported operation exception ( `` read only configuration `` ) ; }
public string get record separator ( ) { return record separator ; }
public boolean be null string set ( ) { return null string ! = null ; }
public boolean be quote character set ( ) { return quote character ! = null ; }
public string to string ( ) { return `` c s v record [ comment= `` + comment + `` , mapping= `` + mapping + `` , record number= `` + record number + `` , values= `` + array . to string ( value ) + `` ] `` ; }
public string to string ( ) { return type . name ( ) + `` [ `` + content . to string ( ) + `` ] `` ; }
public void evict ( ) throw exception { if ( connection pool ! = null ) { connection pool . evict ( ) ; } }
public boolean get auto commit on return ( ) { return auto commit on return ; }
public boolean get cache state ( ) { return cache state ; }
public boolean get fast fail validation ( ) { return fast fail validation ; }
public synchronize int get max idle ( ) { return this . max idle ; }
public synchronize long get max wait millis ( ) { return this . max wait millis ; }
public synchronize int get min idle ( ) { return this . min idle ; }
public boolean get remove abandon on maintenance ( ) { return abandon config == null ? false : abandon config . get remove abandon on maintenance ( ) ; }
public void set auto commit on return ( final boolean auto commit on return ) { this . auto commit on return = auto commit on return ; }
public synchronize void set eviction policy class name ( final string eviction policy class name ) { if ( connection pool ! = null ) { connection pool . set eviction policy class name ( eviction policy class name ) ; } this . eviction policy class name = eviction policy class name ; }
public synchronize void set max total ( final int max total ) { this . max total = max total ; if ( connection pool ! = null ) { connection pool . set max total ( max total ) ; } }
public synchronize void set test while idle ( final boolean test while idle ) { this . test while idle = test while idle ; if ( connection pool ! = null ) { connection pool . set test while idle ( test while idle ) ; } }
public boolean be access to underlie connection allow ( ) { return access to underlie connection allow ; }
public connection get innermost delegate ( ) { if ( be access to underlie connection allow ( ) ) { return super . get innermost delegate internal ( ) ; } return null ; }
public void set connection property ( final property prop ) { assert initialization allow ( ) ; connection property = prop ; if ( connection property ! = null ) { if ( connection property . contains key ( key_user ) ) { set user ( connection property . get property ( key_user ) ) ; } if ( connection property . contains key ( key_password ) ) { set password ( connection property . get property ( key_password ) ) ; } } }
public void set url ( final string v ) { assert initialization allow ( ) ; this . url = v ; }
public int get num active ( final string user name ) { final object pool < pool connection and info > pool = get pool ( get pool key ( user name ) ) ; return pool == null ? 0 : pool . get num active ( ) ; }
public database meta data get delegate ( ) { return database meta data ; }
public boolean be close ( ) throw s q l exception { return close ; }
public int [ ] get column index ( ) { return column index ; }
public static string get message ( final string key , final object . . . args ) { final string msg = message . get string ( key ) ; if ( args == null || args . length == 0 ) { return msg ; } final message format mf = new message format ( msg ) ; return mf . format ( args , new string buffer ( ) , null ) . to string ( ) ; }
public string get uri charset ( ) { string charset = ( string ) get parameter ( http_uri_charset ) ; if ( charset == null ) { charset = `` utf-8 `` ; } return charset ; }
public void close ( ) throw i o exception { try { super . close ( ) ; } finally { if ( close branch ) { branch . close ( ) ; } } }
public void write ( char [ ] chr , int st , int end ) throw i o exception { out . write ( chr , st , end ) ; }
public void close ( ) throw i o exception { super . close ( ) ; this . branch . close ( ) ; }
public static int index of ( char [ ] array , char value to find ) { return index of ( array , value to find , 0 ) ; }
public static string reflection to string ( object object ) { return reflection to string builder . to string ( object ) ; }
public int hash code ( ) { return value ; }
public long get time ( ) { if ( this . run state == state_stopped || this . run state == state_suspended ) { return this . stop time - this . start time ; } else if ( this . run state == state_unstarted ) { return 0 ; } else if ( this . run state == state_running ) { return system . current time millis ( ) - this . start time ; } throw new runtime exception ( `` illegal run state have occur . `` ) ; }
public void split ( ) { if ( this . run state ! = state_running ) { throw new illegal state exception ( `` stopwatch be not run . `` ) ; } stop time = system . current time millis ( ) ; this . split state = state_split ; }
public static void no null element ( object [ ] array ) { validate . not null ( array ) ; for ( int i = 0 ; i < array . length ; i++ ) { if ( array [ i ] == null ) { throw new illegal argument exception ( `` the validated array contain null element at index : `` + i ) ; } } }
public static void not empty ( map map ) { if ( map == null || map . size ( ) == 0 ) { throw new illegal argument exception ( `` the validated map be empty `` ) ; } }
public void trace ( object message , throwable t ) { category . log ( fqcn , priority . debug , message , t ) ; }
public void debug ( object message , throwable t ) { category . log ( fqcn , priority . debug , message , t ) ; }
public void error ( object message ) { category . log ( fqcn , priority . error , message , null ) ; }
public void error ( object message , throwable t ) { category . log ( fqcn , priority . error , message , t ) ; }
public void fatal ( object message ) { category . log ( fqcn , priority . fatal , message , null ) ; }
public void fatal ( object message ) { if ( is12 ) { get logger ( ) . log ( fqcn , ( priority ) level . fatal , message , null ) ; } else { get logger ( ) . log ( fqcn , level . fatal , message , null ) ; } }
public void trace ( object message ) { debug ( message ) ; }
public composable function fix2nd argument ( final double fix y ) { return new composable function ( ) { @ override / * * { @ inherit doc } * / public double value ( double x ) throw function evaluation exception { return binary function . this . value ( x , fixed y ) ; } } ; }
public composable function multiply ( final univariate real function f ) { return new composable function ( ) { @ override / * * { @ inherit doc } * / public double value ( double x ) throw function evaluation exception { return composable function . this . value ( x ) * f . value ( x ) ; } } ; }
public polynomial function get polynomial function ( ) { return new polynomial function ( p . get coefficient ( ) ) ; }
protect boolean be root o k ( double min , double max , complex z ) { double tolerance = math . max ( relative accuracy * z . ab ( ) , absolute accuracy ) ; return ( be sequence ( min , z . get real ( ) , max ) ) & & ( math . ab ( z . get imaginary ( ) ) < = tolerance || z . ab ( ) < = function value accuracy ) ; }
protect void verify sequence ( final double lower , final double initial , final double upper ) { if ( ! be sequence ( low , initial , upper ) ) { throw math runtime exception . create illegal argument exception ( `` invalid interval , initial value parameter : lower= { 0 } , initial= { 1 } , upper= { 2 } `` , low , initial , upper ) ; } }
public void set scale ( double s ) { set scale internal ( s ) ; }
public double cumulative probability ( double x ) throw math exception { return gamma . cumulative probability ( x ) ; }
public double cumulative probability ( final int x ) { if ( x < = 0 ) { return 0 . 0 ; } else if ( x > = number of element ) { return 1 . 0 ; } return generalize harmonic ( x , exponent ) / generalize harmonic ( number of element , exponent ) ; }
public double get chi square ( estimation problem problem ) { weighted measurement [ ] wm = problem . get measurement ( ) ; double chi square = 0 ; for ( int i = 0 ; i < wm . length ; ++i ) { double residual = wm [ i ] . get residual ( ) ; chi square += residual * residual / wm [ i ] . get weight ( ) ; } return chi square ; }
public void set cost relative tolerance ( double cost relative tolerance ) { this . cost relative tolerance = cost relative tolerance ; }
protect void add parameter ( estimate parameter p ) { parameter . add ( p ) ; }
public void set ignore ( boolean ignore ) { this . ignore = ignore ; }
public long get numerator a long ( ) { return numerator . long value ( ) ; }
public int int value ( ) { return numerator . divide ( denominator ) . int value ( ) ; }
public boolean be satisfied ( population population ) { if ( this . num generation < this . max generation ) { num generations++ ; return false ; } return true ; }
protect void check subtraction compatible ( final field matrix < t > m ) { if ( ( get row dimension ( ) ! = m . get row dimension ( ) ) || ( get column dimension ( ) ! = m . get column dimension ( ) ) ) { throw math runtime exception . create illegal argument exception ( `` { 0 } x { 1 } and { 2 } x { 3 } matrix be not subtraction compatible `` , get row dimension ( ) , get column dimension ( ) , m . get row dimension ( ) , m . get column dimension ( ) ) ; } }
public big matrix inverse ( ) throw invalid matrix exception { return solve ( matrix utils . create big identity matrix ( get row dimension ( ) ) ) ; }
public big decimal [ ] operate ( big decimal [ ] v ) throw illegal argument exception { if ( v . length ! = get column dimension ( ) ) { throw math runtime exception . create illegal argument exception ( `` vector length mismatch : get { 0 } but expect { 1 } `` , v . length , get column dimension ( ) ) ; } final int n row = this . get row dimension ( ) ; final int n cols = this . get column dimension ( ) ; final big decimal [ ] out = new big decimal [ n row ] ; for ( int row = 0 ; row < n row ; row++ ) { big decimal sum = zero ; for ( int i = 0 ; i < n col ; i++ ) { sum = sum . add ( data [ row ] [ i ] . multiply ( v [ i ] ) ) ; } out [ row ] = sum ; } return out ; }
protect big matrix get l u matrix ( ) throw invalid matrix exception { if ( lu == null ) { lu decompose ( ) ; } return new big matrix impl ( lu ) ; }
public boolean equal ( object obj ) { if ( this == obj ) { return true ; } if ( ! ( obj instanceof open map real vector ) ) { return false ; } open map real vector other = ( open map real vector ) obj ; if ( virtual size ! = other . virtual size ) { return false ; } if ( double . double to long bit ( epsilon ) ! = double . double to long bit ( other . epsilon ) ) { return false ; } iterator iter = entry . iterator ( ) ; while ( iter . have next ( ) ) { iter . advance ( ) ; double test = other . get entry ( iter . key ( ) ) ; if ( double . double to long bit ( test ) ! = double . double to long bit ( iter . value ( ) ) ) { return false ; } } iter = other . get entry ( ) . iterator ( ) ; while ( iter . have next ( ) ) { iter . advance ( ) ; double test = iter . value ( ) ; if ( double . double to long bit ( test ) ! = double . double to long bit ( get entry ( iter . key ( ) ) ) ) { return false ; } } return true ; }
public object [ ] get argument ( ) { return argument . clone ( ) ; }
public static no such element exception create no such element exception ( final string pattern , final object . . . argument ) { return new no such element exception ( ) { / * * serializable version identifier . * / private static final long serial version u i d = 7304273322489425799l ; / * * { @ inherit doc } * / @ override public string get message ( ) { return build message ( locale . u , pattern , argument ) ; } / * * { @ inherit doc } * / @ override public string get localized message ( ) { return build message ( locale . get default ( ) , pattern , argument ) ; } } ; }
public void reinitialize begin ( final double t start , final double [ ] y start ) throw event exception { t0 = t start ; g0 = handler . g ( t start , y start ) ; g0 positive = g0 > = 0 ; }
protected step interpolator do copy ( ) { return new dummy step interpolator ( this ) ; }
public int next int ( int lower , int upper ) { if ( low > = upper ) { throw math runtime exception . create illegal argument exception ( `` upper bound ( { 0 } ) must be great than low bound ( { 1 } ) `` , upper , low ) ; } double r = get ran ( ) . next double ( ) ; return ( int ) ( ( r * upper ) + ( ( 1 . 0 - r ) * low ) + r ) ; }
public int next secure int ( int lower , int upper ) { if ( low > = upper ) { throw math runtime exception . create illegal argument exception ( `` upper bound ( { 0 } ) must be great than low bound ( { 1 } ) `` , upper , low ) ; } secure random sec = get sec ran ( ) ; return low + ( int ) ( sec . next double ( ) * ( upper - low + 1 ) ) ; }
public real matrix compute correlation matrix ( double [ ] [ ] data ) { return compute correlation matrix ( new block real matrix ( data ) ) ; }
public void set quantile ( final double p ) { if ( p < = 0 || p > 100 ) { throw math runtime exception . create illegal argument exception ( `` out of bound quantile value : { 0 } , must be in ( 0 , 100 ] `` , p ) ; } quantile = p ; }
public static void set unknown distribution chi square test ( unknown distribution chi square test unknown distribution chi square test ) { test utils . unknown distribution chi square test = unknown distribution chi square test ; }
public double pair t test ( double [ ] sample1 , double [ ] sample2 ) throw illegal argument exception , math exception { double mean difference = stat utils . mean difference ( sample1 , sample2 ) ; return t test ( mean difference , 0 , stat utils . variance difference ( sample1 , sample2 , mean difference ) , sample1 . length ) ; }
public double homoscedastic t test ( double [ ] sample1 , double [ ] sample2 ) throw illegal argument exception , math exception { check sample data ( sample1 ) ; check sample data ( sample2 ) ; return homoscedastic t test ( stat utils . mean ( sample1 ) , stat utils . mean ( sample2 ) , stat utils . variance ( sample1 ) , stat utils . variance ( sample2 ) , sample1 . length , sample2 . length ) ; }
public double [ ] inversetransform ( double f [ ] ) throw illegal argument exception { double scaling_coefficient = 2 . 0 / ( f . length - 1 ) ; return fast fourier transformer . scale array ( fct ( f ) , scaling_coefficient ) ; }
public static boolean equal ( double x , double y , double eps ) { return equal ( x , y ) || ( math . ab ( y - x ) < = eps ) ; }
public static byte indicator ( final byte x ) { return ( x > = zb ) ? pb : nb ; }
public static double indicator ( final double x ) { if ( double . be na n ( x ) ) { return double . na n ; } return ( x > = 0 . 0 ) ? 1 . 0 : -1 . 0 ; }
public static int indicator ( final int x ) { return ( x > = 0 ) ? 1 : -1 ; }
public static double normalize angle ( double a , double center ) { return a - two_pi * math . floor ( ( a + math . pi - center ) / two_pi ) ; }
public static double distance ( double [ ] p1 , double [ ] p2 ) { double sum = 0 ; for ( int i = 0 ; i < p1 . length ; i++ ) { final double dp = p1 [ i ] - p2 [ i ] ; sum += dp * dp ; } return math . sqrt ( sum ) ; }
public synchronize int get num element ( ) { return num element ; }
public void set expansion mode ( int expansion mode ) { if ( expansion mode ! = multiplicative_mode & & expansion mode ! = additive_mode ) { throw math runtime exception . create illegal argument exception ( `` unsupported expansion mode { 0 } , support mode be { 1 } ( { 2 } ) and { 3 } ( { 4 } ) `` , expansion mode , multiplicative_mode , `` multiplicative_mode `` , additive_mode , `` additive_mode `` ) ; } synchronize ( this ) { this . expansion mode = expansion mode ; } }
public static boolean equal include na n ( float x , float y ) { return ( float . be na n ( x ) & & float . be na n ( y ) ) || equal ( x , y , 1 ) ; }
public input stream get input stream ( ) { return _input_ ; }
public void send ( inet address host , int port ) throw i o exception { __send packet . set address ( host ) ; __send packet . set port ( port ) ; _socket_ . send ( __send packet ) ; }
public int get local port ( ) { return _socket_ . get local port ( ) ; }
public int send command ( string command ) throw i o exception { return send command ( command , null ) ; }
public int get reply code ( ) { return _reply code ; }
public int list ( ) throw i o exception { return send command ( f t p command . list ) ; }
public int nlst ( ) throw i o exception { return send command ( f t p command . nlst ) ; }
public int site ( string parameter ) throw i o exception { return send command ( f t p command . site , parameter ) ; }
public int help ( ) throw i o exception { return send command ( f t p command . help ) ; }
public void enter local active mode ( ) { __data connection mode = active_local_data_connection_mode ; __passive host = null ; __passive port = -1 ; }
public output stream store unique file stream ( string remote ) throw i o exception { return __store file stream ( f t p command . stou , remote ) ; }
public f t p file list create file list ( f t p file entry parser parser ) throw i o exception { return create file list ( null , parser ) ; }
public void set buffer size ( int buf size ) { __buffer size = buf size ; }
public static date format symbol lookup date format symbol ( string language code ) { object lang = language_code_map . get ( language code ) ; if ( lang ! = null ) { if ( lang instanceof locale ) { return new date format symbol ( ( locale ) lang ) ; } else if ( lang instanceof string ) { return get date format symbol ( ( string ) lang ) ; } } return new date format symbol ( locale . u ) ; }
public string get user ( ) { return _user ; }
public string get link ( ) { return _link ; }
public string to string ( ) { return _raw listing ; }
public void read stream ( input stream stream , string encode ) throw i o exception { buffered reader reader = new buffer reader ( new input stream reader ( stream , encode ) ) ; string line = this . parser . read next entry ( reader ) ; while ( line ! = null ) { this . line . add ( line ) ; line = this . parser . read next entry ( reader ) ; } reader . close ( ) ; }
public static boolean be negative permanent ( int reply ) { return ( reply > = 500 & & reply < 600 ) ; }
public calendar parse timestamp ( string timestamp str ) throw parse exception { return this . timestamp parser . parse timestamp ( timestamp str ) ; }
public int read ( ) throw i o exception { if ( _no conversion require ) return super . read ( ) ; return __read ( ) ; }
public void add distribution ( string distribution ) { if ( __distributions ! = null ) __distributions . append ( ' , ' ) ; else __distributions = new string buffer ( ) ; __distributions . append ( distribution ) ; }
public int quit ( ) throw i o exception { return send command ( n n t p command . quit ) ; }
public reader retrieve article header ( ) throw i o exception { return retrieve article header ( null ) ; }
public boolean complete pending command ( ) throw i o exception { return n n t p reply . be positive completion ( get reply ( ) ) ; }
public string get from address ( ) { return __from ; }
public long get second ( ) { return ( ntp time > > > 32 ) & 0xffffffff l ; }
public int hash code ( ) { return ( int ) ( ntp time ^ ( ntp time > > > 32 ) ) ; }
public string to string ( ) { string buffer buffer = new string buffer ( ) ; enumeration host ; buffer . append ( ' < ' ) ; host = _path . element ( ) ; if ( host . have more element ( ) ) { buffer . append ( ' @ ' ) ; buffer . append ( ( string ) host . next element ( ) ) ; while ( host . have more element ( ) ) { buffer . append ( `` , @ `` ) ; buffer . append ( ( string ) host . next element ( ) ) ; } buffer . append ( ' : ' ) ; } buffer . append ( _email address ) ; buffer . append ( ' > ' ) ; return buffer . to string ( ) ; }
public int get reply ( ) throw i o exception { __get reply ( ) ; return _reply code ; }
public boolean reset ( ) throw i o exception { return s m t p reply . be positive completion ( rset ( ) ) ; }
public int get default port ( ) { return _default port_ ; }
public boolean mark support ( ) { return false ; }
public final void end buffer ops ( ) { __receive buffer = null ; __receive datagram = null ; _send buffer = null ; __send datagram = null ; }
public final void send ( t f t p packet packet ) throw i o exception { _socket_ . send ( packet . new datagram ( ) ) ; }
public void set block number ( int block number ) { _block number = block number ; }
public string get modification time ( string pathname ) throw i o exception { if ( f t p reply . be positive completion ( mdtm ( pathname ) ) ) return get reply string ( ) ; return null ; }
public boolean get use client mode ( ) { if ( _socket_ instanceof s s l socket ) return ( ( s s l socket ) _socket_ ) . get use client mode ( ) ; return false ; }
public void set send buffer size ( int size ) throw socket exception { send buffer size = size ; }
public void set copy stream listener ( copy stream listener listener ) { __copy stream listener = listener ; }
public boolean do command ( i m a p command command , string args ) throw i o exception { return i m a p reply . be success ( send command ( command , args ) ) ; }
public boolean lsub ( string ref name , string mailbox name ) throw i o exception { return do command ( i m a p command . lsub , ref name + `` `` + mailbox name ) ; }
public static final string get command ( i m a p command command ) { return command . get i m a p command ( ) ; }
public article next ( ) { string line = string iterator . next ( ) ; return n n t p client . __parse article entry ( line ) ; }
public static x509 trust manager get accept all trust manager ( ) { return accept_all ; }
public void activate object ( k key , v obj ) throw exception { }
public synchronize int get num active ( ) { return _num active ; }
public synchronize void clear ( ) { iterator < k > it = _pools . key set ( ) . iterator ( ) ; while ( it . have next ( ) ) { k key = it . next ( ) ; stack < v > stack = _pools . get ( key ) ; destroy stack ( key , stack ) ; } _tot idle = 0 ; _pools . clear ( ) ; _active count . clear ( ) ; }
public int get max sleeping ( ) { return _max sleep ; }
public void set remove abandon timeout ( final duration remove abandon timeout ) { this . remove abandon timeout = remove abandon timeout ; }
public final boolean get lifo ( ) { return lifo ; }
public final long get return count ( ) { return return count . get ( ) ; }
public void set eviction policy ( final eviction policy < t > eviction policy ) { this . eviction policy = eviction policy ; }
public final void set max total ( final int max total ) { this . max total = max total ; }
public final void set test on borrow ( final boolean test on borrow ) { this . test on borrow = test on borrow ; }
public final void set time between eviction run ( final duration time between eviction run ) { this . time between eviction run = time between eviction run ; start evictor ( this . time between eviction run ) ; }
public pool object factory < t > get factory ( ) { return factory ; }
public void clear ( ) { lock . lock ( ) ; try { for ( node < e > f = first ; f ! = null ; ) { f . item = null ; final node < e > n = f . next ; f . prev = null ; f . next = null ; f = n ; } first = last = null ; count = 0 ; not full . signal all ( ) ; } finally { lock . unlock ( ) ; } }
public t get object ( ) { return reference . get ( ) ; }
public string lookup property string lookup ( ) { return property string lookup . instance ; }
public static function new pre translate nullable label ( string bundle , locale locale ) { return new pre translate func ( bundle , locale , false ) ; }
public boolean get finish block on flush ( ) { return _cfg finish block on flush ; }
public char sequence get long common substring ( ) { return suffix tree . get long common substring ( ) ; }
public config parse option set syntax ( config syntax syntax ) { if ( this . syntax == syntax ) return this ; else return new config parse option ( syntax , this . origin description , this . allow miss , this . includer , this . class loader ) ; }
public config parse option set allow miss ( boolean allow miss ) { if ( this . allow miss == allow miss ) return this ; else return new config parse option ( this . syntax , this . origin description , allow miss , this . includer , this . class loader ) ; }
public config render option set origin comment ( boolean value ) { if ( value == origin comment ) return this ; else return new config render option ( value , comment , format , json ) ; }
protect abstract config value peek path ( path path , resolve context context ) throw not possible to resolve { return peek path ( this , path , context ) ; }
public < t > list < t > a list ( class < t > item type ) { return table converter . to list ( this , item type ) ; }
public < t > t plugin proxy ( class loader class loader , final class < t > type ) { object proxy = proxy . new proxy instance ( class loader , new class < ? > [ ] { type } , new invocation handler ( ) { @ override public object invoke ( object target , method method , object [ ] args ) throw throwable { for ( object plugin : get plugins ( ) ) { if ( type . be instance ( plugin ) ) { utils . invoke ( plugin , method , 0 , args ) ; } } return null ; } } ) ; return type . cast ( proxy ) ; }
public static string wrap in tag ( string line , string tag , string css class ) { string builder tag builder = new string builder ( ) ; tag builder . append ( `` < `` ) ; tag builder . append ( tag ) ; if ( css class ! = null ) { tag builder . append ( `` class=\ `` `` ) ; tag builder . append ( css class ) ; tag builder . append ( `` \ `` `` ) ; } tag builder . append ( `` > `` ) ; string start tag = tag builder . to string ( ) ; tag builder . delete ( 0 , tag builder . length ( ) ) ; tag builder . append ( `` < / `` ) ; tag builder . append ( tag ) ; tag builder . append ( `` > `` ) ; string end tag = tag builder . to string ( ) ; return start tag + line + end tag ; }
public retry policy get retry policy ( ) { return retry policy . get ( ) ; }
public void set exhibitor ( exhibitor new exhibitor ) { exhibitor . set ( new exhibitor ) ; master exhibitor . set ( new exhibitor ) ; }
public string get path ( ) { return this . path ; }
public static path and node get path and node ( string path ) { path utils . validate path ( path ) ; int i = path . last index of ( path_separator ) ; if ( i < 0 ) { return new path and node ( path , `` `` ) ; } if ( ( i + 1 ) > = path . length ( ) ) { return new path and node ( path_separator , `` `` ) ; } string node = path . substring ( i + 1 ) ; string parent path = ( i > 0 ) ? path . substring ( 0 , i ) : path_separator ; return new path and node ( parent path , node ) ; }
public synchronize void leave ( ) throw exception { leave ( -1 , null ) ; }
public void start ( ) throw exception { start ( false ) ; }
public void release ( ) throw exception { / * note on concurrency : a give lock data instance can be only act on by a single thread so locking be n't necessary * / thread current thread = thread . current thread ( ) ; lock data lock data = thread data . get ( current thread ) ; if ( lock data == null ) { throw new illegal monitor state exception ( `` you do not own the lock : `` + base path ) ; } int new lock count = lock data . lock count . decrement and get ( ) ; if ( new lock count > 0 ) { return ; } if ( new lock count < 0 ) { throw new illegal monitor state exception ( `` lock count have go negative for lock : `` + base path ) ; } try { internals . release lock ( lock data . lock path ) ; } finally { thread data . remove ( current thread ) ; } }
public inter process mutex write lock ( ) { return write mutex ; }
public long get two nine upper bound ( ) { return get upper bound for factor ( 0 . 99d ) ; }
public event handler group < t > then ( final event handler < t > . . . handler ) { return handle event with ( handler ) ; }
public sequence barrier a sequence barrier ( ) { return disruptor . get ring buffer ( ) . new barrier ( sequence ) ; }
public void add while run ( cursored cursored , sequence sequence ) { sequence group . add sequence ( this , sequence_updater , cursored , sequence ) ; }
protect map create attribute index ( ) { map answer = create index ( ) ; return answer ; }
protect map create element index ( ) { map answer = create index ( ) ; return answer ; }
public static < t > t create nice mock ( class < t > to mock ) { return create nice control ( ) . create mock ( to mock ) ; }
public static char and ( char first , char second ) { last control . report and ( 2 ) ; return 0 ; }
public static float and ( float first , float second ) { last control . report and ( 2 ) ; return 0 ; }
public static float not ( float first ) { last control . report not ( ) ; return first ; }
public static short eq ( short value ) { report matcher ( new equal ( value ) ) ; return 0 ; }
public static double eq ( double value , double delta ) { report matcher ( new equal with delta ( value , delta ) ) ; return 0 ; }
public static void replay ( object . . . mock ) { for ( object mock : mock ) { get control ( mock ) . replay ( ) ; } }
public void replay ( ) { ctrl . replay ( ) ; }
public void set return value ( object value ) { expect last call ( `` method call on the mock need before set return value `` ) . and return ( value ) . once ( ) ; }
public void set void callable ( int time ) { expect last call ( `` method call on the mock need before set void callable `` ) . time ( time ) ; }
public void set throwable ( throwable throwable , int time ) { expect last call ( `` method call on the mock need before set throwable `` ) . and throw ( throwable ) . time ( time ) ; }
public void set default throwable ( throwable throwable ) { ctrl . set legacy default throwable ( throwable ) ; }
public void set default return value ( object value ) { ctrl . set legacy default return value ( value ) ; }
public type annotation walker to type parameter bound ( boolean be class type parameter , int parameter rank ) { long new match = this . match ; if ( new match == 0 ) return empty_annotation_walker ; int length = this . type annotation . length ; int target type = be class type parameter ? annotation target type constant . class_type_parameter_bound : annotation target type constant . method_type_parameter_bound ; long mask = 1 ; for ( int i = 0 ; i < length ; i++ , mask = mask < < 1 ) { i binary type annotation candidate = this . type annotation [ i ] ; if ( candidate . get target type ( ) ! = target type || ( short ) candidate . get type parameter index ( ) ! = parameter rank ) { new match & = ~mask ; } } return restrict ( new match , 0 ) ; }
public big integer to big integer ( byte [ ] in ) { byte [ ] out = new byte [ in . length ] ; for ( int i = 0 ; i < in . length ; i++ ) { out [ i ] = in [ in . length-1-i ] ; } return new big integer ( 1 , out ) ; }
public field element multiply ( field element val ) { int [ ] g = ( ( ed25519 field element ) val ) . t ; int g1_19 = 19 * g [ 1 ] ; / * 1 . 959375 * 2^29 * / int g2_19 = 19 * g [ 2 ] ; / * 1 . 959375 * 2^30 ; still ok * / int g3_19 = 19 * g [ 3 ] ; int g4_19 = 19 * g [ 4 ] ; int g5_19 = 19 * g [ 5 ] ; int g6_19 = 19 * g [ 6 ] ; int g7_19 = 19 * g [ 7 ] ; int g8_19 = 19 * g [ 8 ] ; int g9_19 = 19 * g [ 9 ] ; int f1_2 = 2 * t [ 1 ] ; int f3_2 = 2 * t [ 3 ] ; int f5_2 = 2 * t [ 5 ] ; int f7_2 = 2 * t [ 7 ] ; int f9_2 = 2 * t [ 9 ] ; long f0g0 = t [ 0 ] * ( long ) g [ 0 ] ; long f0g1 = t [ 0 ] * ( long ) g [ 1 ] ; long f0g2 = t [ 0 ] * ( long ) g [ 2 ] ; long f0g3 = t [ 0 ] * ( long ) g [ 3 ] ; long f0g4 = t [ 0 ] * ( long ) g [ 4 ] ; long f0g5 = t [ 0 ] * ( long ) g [ 5 ] ; long f0g6 = t [ 0 ] * ( long ) g [ 6 ] ; long f0g7 = t [ 0 ] * ( long ) g [ 7 ] ; long f0g8 = t [ 0 ] * ( long ) g [ 8 ] ; long f0g9 = t [ 0 ] * ( long ) g [ 9 ] ; long f1g0 = t [ 1 ] * ( long ) g [ 0 ] ; long f1g1_2 = f1_2 * ( long ) g [ 1 ] ; long f1g2 = t [ 1 ] * ( long ) g [ 2 ] ; long f1g3_2 = f1_2 * ( long ) g [ 3 ] ; long f1g4 = t [ 1 ] * ( long ) g [ 4 ] ; long f1g5_2 = f1_2 * ( long ) g [ 5 ] ; long f1g6 = t [ 1 ] * ( long ) g [ 6 ] ; long f1g7_2 = f1_2 * ( long ) g [ 7 ] ; long f1g8 = t [ 1 ] * ( long ) g [ 8 ] ; long f1g9_38 = f1_2 * ( long ) g9_19 ; long f2g0 = t [ 2 ] * ( long ) g [ 0 ] ; long f2g1 = t [ 2 ] * ( long ) g [ 1 ] ; long f2g2 = t [ 2 ] * ( long ) g [ 2 ] ; long f2g3 = t [ 2 ] * ( long ) g [ 3 ] ; long f2g4 = t [ 2 ] * ( long ) g [ 4 ] ; long f2g5 = t [ 2 ] * ( long ) g [ 5 ] ; long f2g6 = t [ 2 ] * ( long ) g [ 6 ] ; long f2g7 = t [ 2 ] * ( long ) g [ 7 ] ; long f2g8_19 = t [ 2 ] * ( long ) g8_19 ; long f2g9_19 = t [ 2 ] * ( long ) g9_19 ; long f3g0 = t [ 3 ] * ( long ) g [ 0 ] ; long f3g1_2 = f3_2 * ( long ) g [ 1 ] ; long f3g2 = t [ 3 ] * ( long ) g [ 2 ] ; long f3g3_2 = f3_2 * ( long ) g [ 3 ] ; long f3g4 = t [ 3 ] * ( long ) g [ 4 ] ; long f3g5_2 = f3_2 * ( long ) g [ 5 ] ; long f3g6 = t [ 3 ] * ( long ) g [ 6 ] ; long f3g7_38 = f3_2 * ( long ) g7_19 ; long f3g8_19 = t [ 3 ] * ( long ) g8_19 ; long f3g9_38 = f3_2 * ( long ) g9_19 ; long f4g0 = t [ 4 ] * ( long ) g [ 0 ] ; long f4g1 = t [ 4 ] * ( long ) g [ 1 ] ; long f4g2 = t [ 4 ] * ( long ) g [ 2 ] ; long f4g3 = t [ 4 ] * ( long ) g [ 3 ] ; long f4g4 = t [ 4 ] * ( long ) g [ 4 ] ; long f4g5 = t [ 4 ] * ( long ) g [ 5 ] ; long f4g6_19 = t [ 4 ] * ( long ) g6_19 ; long f4g7_19 = t [ 4 ] * ( long ) g7_19 ; long f4g8_19 = t [ 4 ] * ( long ) g8_19 ; long f4g9_19 = t [ 4 ] * ( long ) g9_19 ; long f5g0 = t [ 5 ] * ( long ) g [ 0 ] ; long f5g1_2 = f5_2 * ( long ) g [ 1 ] ; long f5g2 = t [ 5 ] * ( long ) g [ 2 ] ; long f5g3_2 = f5_2 * ( long ) g [ 3 ] ; long f5g4 = t [ 5 ] * ( long ) g [ 4 ] ; long f5g5_38 = f5_2 * ( long ) g5_19 ; long f5g6_19 = t [ 5 ] * ( long ) g6_19 ; long f5g7_38 = f5_2 * ( long ) g7_19 ; long f5g8_19 = t [ 5 ] * ( long ) g8_19 ; long f5g9_38 = f5_2 * ( long ) g9_19 ; long f6g0 = t [ 6 ] * ( long ) g [ 0 ] ; long f6g1 = t [ 6 ] * ( long ) g [ 1 ] ; long f6g2 = t [ 6 ] * ( long ) g [ 2 ] ; long f6g3 = t [ 6 ] * ( long ) g [ 3 ] ; long f6g4_19 = t [ 6 ] * ( long ) g4_19 ; long f6g5_19 = t [ 6 ] * ( long ) g5_19 ; long f6g6_19 = t [ 6 ] * ( long ) g6_19 ; long f6g7_19 = t [ 6 ] * ( long ) g7_19 ; long f6g8_19 = t [ 6 ] * ( long ) g8_19 ; long f6g9_19 = t [ 6 ] * ( long ) g9_19 ; long f7g0 = t [ 7 ] * ( long ) g [ 0 ] ; long f7g1_2 = f7_2 * ( long ) g [ 1 ] ; long f7g2 = t [ 7 ] * ( long ) g [ 2 ] ; long f7g3_38 = f7_2 * ( long ) g3_19 ; long f7g4_19 = t [ 7 ] * ( long ) g4_19 ; long f7g5_38 = f7_2 * ( long ) g5_19 ; long f7g6_19 = t [ 7 ] * ( long ) g6_19 ; long f7g7_38 = f7_2 * ( long ) g7_19 ; long f7g8_19 = t [ 7 ] * ( long ) g8_19 ; long f7g9_38 = f7_2 * ( long ) g9_19 ; long f8g0 = t [ 8 ] * ( long ) g [ 0 ] ; long f8g1 = t [ 8 ] * ( long ) g [ 1 ] ; long f8g2_19 = t [ 8 ] * ( long ) g2_19 ; long f8g3_19 = t [ 8 ] * ( long ) g3_19 ; long f8g4_19 = t [ 8 ] * ( long ) g4_19 ; long f8g5_19 = t [ 8 ] * ( long ) g5_19 ; long f8g6_19 = t [ 8 ] * ( long ) g6_19 ; long f8g7_19 = t [ 8 ] * ( long ) g7_19 ; long f8g8_19 = t [ 8 ] * ( long ) g8_19 ; long f8g9_19 = t [ 8 ] * ( long ) g9_19 ; long f9g0 = t [ 9 ] * ( long ) g [ 0 ] ; long f9g1_38 = f9_2 * ( long ) g1_19 ; long f9g2_19 = t [ 9 ] * ( long ) g2_19 ; long f9g3_38 = f9_2 * ( long ) g3_19 ; long f9g4_19 = t [ 9 ] * ( long ) g4_19 ; long f9g5_38 = f9_2 * ( long ) g5_19 ; long f9g6_19 = t [ 9 ] * ( long ) g6_19 ; long f9g7_38 = f9_2 * ( long ) g7_19 ; long f9g8_19 = t [ 9 ] * ( long ) g8_19 ; long f9g9_38 = f9_2 * ( long ) g9_19 ; / * * * remember : 2^255 congruent 19 modulo p . * h = h0 * 2^0 + h1 * 2^26 + h2 * 2^ ( 26+25 ) + h3 * 2^ ( 26+25+26 ) + . . . + h9 * 2^ ( 5 * 26+5 * 25 ) . * so to get the real number we would have to multiply the coefficient with the corresponding power of 2 . * to get an idea what be go on below , look at the calculation of h0 : * h0 be the coefficient to the power 2^0 so it collect ( sum ) all product that have the power 2^0 . * f0 * g0 really be f0 * 2^0 * g0 * 2^0 = ( f0 * g0 ) * 2^0 . * f1 * g9 really be f1 * 2^26 * g9 * 2^230 = f1 * g9 * 2^256 = 2 * f1 * g9 * 2^255 congruent 2 * 19 * f1 * g9 * 2^0 modulo p . * f2 * g8 really be f2 * 2^51 * g8 * 2^204 = f2 * g8 * 2^255 congruent 19 * f2 * g8 * 2^0 modulo p . * and so on . . . * / long h0 = f0g0 + f1g9_38 + f2g8_19 + f3g7_38 + f4g6_19 + f5g5_38 + f6g4_19 + f7g3_38 + f8g2_19 + f9g1_38 ; long h1 = f0g1 + f1g0 + f2g9_19 + f3g8_19 + f4g7_19 + f5g6_19 + f6g5_19 + f7g4_19 + f8g3_19 + f9g2_19 ; long h2 = f0g2 + f1g1_2 + f2g0 + f3g9_38 + f4g8_19 + f5g7_38 + f6g6_19 + f7g5_38 + f8g4_19 + f9g3_38 ; long h3 = f0g3 + f1g2 + f2g1 + f3g0 + f4g9_19 + f5g8_19 + f6g7_19 + f7g6_19 + f8g5_19 + f9g4_19 ; long h4 = f0g4 + f1g3_2 + f2g2 + f3g1_2 + f4g0 + f5g9_38 + f6g8_19 + f7g7_38 + f8g6_19 + f9g5_38 ; long h5 = f0g5 + f1g4 + f2g3 + f3g2 + f4g1 + f5g0 + f6g9_19 + f7g8_19 + f8g7_19 + f9g6_19 ; long h6 = f0g6 + f1g5_2 + f2g4 + f3g3_2 + f4g2 + f5g1_2 + f6g0 + f7g9_38 + f8g8_19 + f9g7_38 ; long h7 = f0g7 + f1g6 + f2g5 + f3g4 + f4g3 + f5g2 + f6g1 + f7g0 + f8g9_19 + f9g8_19 ; long h8 = f0g8 + f1g7_2 + f2g6 + f3g5_2 + f4g4 + f5g3_2 + f6g2 + f7g1_2 + f8g0 + f9g9_38 ; long h9 = f0g9 + f1g8 + f2g7 + f3g6 + f4g5 + f5g4 + f6g3 + f7g2 + f8g1 + f9g0 ; long carry0 ; long carry1 ; long carry2 ; long carry3 ; long carry4 ; long carry5 ; long carry6 ; long carry7 ; long carry8 ; long carry9 ; / * |h0| < = ( 1 . 65 * 1 . 65 * 2^52 * ( 1+19+19+19+19 ) +1 . 65 * 1 . 65 * 2^50 * ( 38+38+38+38+38 ) ) i . e . |h0| < = 1 . 4 * 2^60 ; narrow range for h2 , h4 , h6 , h8 |h1| < = ( 1 . 65 * 1 . 65 * 2^51 * ( 1+1+19+19+19+19+19+19+19+19 ) ) i . e . |h1| < = 1 . 7 * 2^59 ; narrow range for h3 , h5 , h7 , h9 * / carry0 = ( h0 + ( long ) ( 1 < < 25 ) ) > > 26 ; h1 += carry0 ; h0 -= carry0 < < 26 ; carry4 = ( h4 + ( long ) ( 1 < < 25 ) ) > > 26 ; h5 += carry4 ; h4 -= carry4 < < 26 ; / * |h0| < = 2^25 * / / * |h4| < = 2^25 * / / * |h1| < = 1 . 71 * 2^59 * / / * |h5| < = 1 . 71 * 2^59 * / carry1 = ( h1 + ( long ) ( 1 < < 24 ) ) > > 25 ; h2 += carry1 ; h1 -= carry1 < < 25 ; carry5 = ( h5 + ( long ) ( 1 < < 24 ) ) > > 25 ; h6 += carry5 ; h5 -= carry5 < < 25 ; / * |h1| < = 2^24 ; from now on fit into int32 * / / * |h5| < = 2^24 ; from now on fit into int32 * / / * |h2| < = 1 . 41 * 2^60 * / / * |h6| < = 1 . 41 * 2^60 * / carry2 = ( h2 + ( long ) ( 1 < < 25 ) ) > > 26 ; h3 += carry2 ; h2 -= carry2 < < 26 ; carry6 = ( h6 + ( long ) ( 1 < < 25 ) ) > > 26 ; h7 += carry6 ; h6 -= carry6 < < 26 ; / * |h2| < = 2^25 ; from now on fit into int32 unchanged * / / * |h6| < = 2^25 ; from now on fit into int32 unchanged * / / * |h3| < = 1 . 71 * 2^59 * / / * |h7| < = 1 . 71 * 2^59 * / carry3 = ( h3 + ( long ) ( 1 < < 24 ) ) > > 25 ; h4 += carry3 ; h3 -= carry3 < < 25 ; carry7 = ( h7 + ( long ) ( 1 < < 24 ) ) > > 25 ; h8 += carry7 ; h7 -= carry7 < < 25 ; / * |h3| < = 2^24 ; from now on fit into int32 unchanged * / / * |h7| < = 2^24 ; from now on fit into int32 unchanged * / / * |h4| < = 1 . 72 * 2^34 * / / * |h8| < = 1 . 41 * 2^60 * / carry4 = ( h4 + ( long ) ( 1 < < 25 ) ) > > 26 ; h5 += carry4 ; h4 -= carry4 < < 26 ; carry8 = ( h8 + ( long ) ( 1 < < 25 ) ) > > 26 ; h9 += carry8 ; h8 -= carry8 < < 26 ; / * |h4| < = 2^25 ; from now on fit into int32 unchanged * / / * |h8| < = 2^25 ; from now on fit into int32 unchanged * / / * |h5| < = 1 . 01 * 2^24 * / / * |h9| < = 1 . 71 * 2^59 * / carry9 = ( h9 + ( long ) ( 1 < < 24 ) ) > > 25 ; h0 += carry9 * 19 ; h9 -= carry9 < < 25 ; / * |h9| < = 2^24 ; from now on fit into int32 unchanged * / / * |h0| < = 1 . 1 * 2^39 * / carry0 = ( h0 + ( long ) ( 1 < < 25 ) ) > > 26 ; h1 += carry0 ; h0 -= carry0 < < 26 ; / * |h0| < = 2^25 ; from now on fit into int32 unchanged * / / * |h1| < = 1 . 01 * 2^24 * / int [ ] h = new int [ 10 ] ; h [ 0 ] = ( int ) h0 ; h [ 1 ] = ( int ) h1 ; h [ 2 ] = ( int ) h2 ; h [ 3 ] = ( int ) h3 ; h [ 4 ] = ( int ) h4 ; h [ 5 ] = ( int ) h5 ; h [ 6 ] = ( int ) h6 ; h [ 7 ] = ( int ) h7 ; h [ 8 ] = ( int ) h8 ; h [ 9 ] = ( int ) h9 ; return new ed25519 field element ( f , h ) ; }
public int get delay unassigned shard ( ) { return this . delay unassigned shard ; }
public string get hostname ( ) { return get node ( ) . get host name ( ) ; }
public allocation command get command ( ) { return command ; }
public setting get persistent setting ( ) { return persistent setting ; }
public string routing ( ) { return this . routing ; }
public cluster search shard request rout ( string . . . routings ) { this . rout = string . array to comma delimited string ( routings ) ; return this ; }
public create snapshot request repository ( string repository ) { this . repository = repository ; return this ; }
public create snapshot request wait for completion ( boolean wait for completion ) { this . wait for completion = wait for completion ; return this ; }
public create snapshot request setting ( string source , x content type x content type ) { this . setting = setting . builder ( ) . load from source ( source , x content type ) . build ( ) ; return this ; }
public restore snapshot request snapshot ( string snapshot ) { this . snapshot = snapshot ; return this ; }
public boolean partial ( ) { return partial ; }
public restore snapshot request include alias ( boolean include alias ) { this . include alias = include alias ; return this ; }
public string get index ( ) { return this . index ; }
public long get start time ( ) { return start time ; }
public int get incremental file count ( ) { return incremental file count ; }
public cluster state request builder all ( ) { request . all ( ) ; return this ; }
public static alias from x content ( x content parser parser ) throw i o exception { alias alias = new alias ( parser . current name ( ) ) ; string current field name = null ; x content parser . token token = parser . next token ( ) ; if ( token == null ) { throw new illegal argument exception ( `` no alias be specify `` ) ; } while ( ( token = parser . next token ( ) ) ! = x content parser . token . end_object ) { if ( token == x content parser . token . field_name ) { current field name = parser . current name ( ) ; } else if ( token == x content parser . token . start_object ) { if ( filter . match ( current field name , parser . get deprecation handler ( ) ) ) { map < string , object > filter = parser . map order ( ) ; alias . filter ( filter ) ; } } else if ( token == x content parser . token . value_string ) { if ( rout . match ( current field name , parser . get deprecation handler ( ) ) ) { alias . routing ( parser . text ( ) ) ; } else if ( index_routing . match ( current field name , parser . get deprecation handler ( ) ) ) { alias . index rout ( parser . text ( ) ) ; } else if ( search_routing . match ( current field name , parser . get deprecation handler ( ) ) ) { alias . search routing ( parser . text ( ) ) ; } } else if ( token == x content parser . token . value_boolean ) { if ( is_write_index . match ( current field name , parser . get deprecation handler ( ) ) ) { alias . write index ( parser . boolean value ( ) ) ; } else if ( is_hidden . match ( current field name , parser . get deprecation handler ( ) ) ) { alias . be hidden ( parser . boolean value ( ) ) ; } } } return alias ; }
public index aliases request builder add alias action ( alias action action ) { request . add alias action ( action ) ; return this ; }
public analyze request builder set tokenizer ( string tokenizer ) { request . tokenizer ( tokenizer ) ; return this ; }
protect shard iterator shard ( cluster state cluster state , clear index cache request request , string [ ] concrete index ) { return cluster state . rout table ( ) . all shard ( concrete index ) ; }
public close index request builder set wait for active shard ( final active shard count wait for active shard ) { request . wait for active shard ( wait for active shard ) ; return this ; }
public create index cluster state update request name resolve instant ( long name resolve at ) { this . name resolve at = name resolve at ; return this ; }
public long get name resolve at ( ) { return name resolve at ; }
public string data stream name ( ) { return data stream name ; }
public create index request setting ( x content builder builder ) { setting ( string . to string ( builder ) , builder . content type ( ) ) ; return this ; }
public create index request mapping ( string type , string source , x content type x content type ) { return mapping ( type , new byte array ( source ) , x content type ) ; }
public force merge request only expunge deletes ( boolean only expunge deletes ) { this . only expunge deletes = only expunge deletes ; return this ; }
public put map request index ( string . . . index ) { this . index = index ; return this ; }
public index get concrete index ( ) { return concrete index ; }
public index shard store request builder set index ( string . . . index ) { request . index ( index ) ; return this ; }
public void set resize type ( resize type type ) { this . type = object . require non null ( type ) ; }
public common stats flag group ( string . . . group ) { this . group = group ; return this ; }
public put index template request builder set setting ( string source , x content type x content type ) { request . setting ( source , x content type ) ; return this ; }
public boolean be valid ( ) { return valid ; }
public static backoff policy exponential backoff ( ) { return exponential backoff ( time value . time value millis ( 50 ) , 8 ) ; }
public int get item id ( ) { return id ; }
public string get type ( ) { if ( failure ! = null ) { return failure . get type ( ) ; } return response . get type ( ) ; }
public bulk processor add ( bytes reference data , @ nullable string default index , @ nullable string default type , x content type x content type ) throw exception { return add ( data , default index , default type , null , x content type ) ; }
public void flush ( ) { lock . lock ( ) ; try { ensure open ( ) ; if ( bulk request . number of action ( ) > 0 ) { execute ( ) ; } } finally { lock . unlock ( ) ; } }
public list < doc write request < ? > > request ( ) { return this . request ; }
public result get result ( ) { return result ; }
public string get id ( ) { return this . id ; }
public explain request builder set fetch source ( @ nullable string include , @ nullable string exclude ) { return set fetch source ( include == null ? string . empty_array : new string [ ] { include } , exclude == null ? string . empty_array : new string [ ] { exclude } ) ; }
public string get source a string ( ) { return get result . source a string ( ) ; }
public index request set pipeline ( string pipeline ) { this . pipeline = pipeline ; return this ; }
public boolean be pipeline resolve ( ) { return this . be pipeline resolve ; }
public index request set if seq no ( long seq no ) { if ( seq no < 0 & & seq no ! = unassigned_seq_no ) { throw new illegal argument exception ( `` sequence number must be non negative . get [ `` + seq no + `` ] . `` ) ; } if seq no = seq no ; return this ; }
public list < pipeline configuration > pipeline ( ) { return collection . unmodifiable list ( pipeline ) ; }
public item [ ] get response ( ) { return this . item ; }
public void set batch reduce size ( int batch reduce size ) { if ( batch reduce size < = 1 ) { throw new illegal argument exception ( `` batch reduce size must be > = 2 `` ) ; } this . batch reduce size = batch reduce size ; }
public search request builder add sort ( string field , sort order order ) { source builder ( ) . sort ( field , order ) ; return this ; }
public shard search failure [ ] get shard failure ( ) { return this . shard failure ; }
public search shard target shard ( ) { return this . shard target ; }
public static < response > action listener < response > wrap with timeout ( thread pool thread pool , action listener < response > listener , time value timeout , string executor , string listener name ) { return wrap with timeout ( thread pool , timeout , executor , listener , ( ignore ) - > { string timeout message = `` [ `` + listener name + `` ] `` + `` time out after [ `` + timeout + `` ] `` ; listener . on failure ( new elasticsearch timeout exception ( timeout message ) ) ; } ) ; }
public final request wait for active shard ( active shard count wait for active shard ) { this . wait for active shard = wait for active shard ; return ( request ) this ; }
protect request rout base on cluster version ( long rout base on cluster version ) { this . rout base on cluster version = rout base on cluster version ; return ( request ) this ; }
public task id get parent task id ( ) { return parent task id ; }
public list < elasticsearch exception > get node failure ( ) { return node failure ; }
public static boolean be read override exception ( exception e ) { return be shard not available exception ( e ) == false ; }
public set < string > select field ( ) { return select field ; }
public term vector request builder set payload ( boolean payload ) { request . payload ( payload ) ; return this ; }
public string id ( ) { return id ; }
public long if primary term ( ) { return if primary term ; }
public update request doc ( object . . . source ) { safe doc ( ) . source ( source ) ; return this ; }
public update request doc ( bytes reference source , x content type content type ) { safe doc ( ) . source ( source , content type ) ; return this ; }
public static clear index cache request clear index cache request ( string . . . index ) { return new clear index cache request ( index ) ; }
public transport client add transport address ( transport address . . . transport address ) { nodes service . add transport address ( transport address ) ; return this ; }
public transport client remove transport address ( transport address transport address ) { nodes service . remove transport address ( transport address ) ; return this ; }
public t ack timeout ( time value ack timeout ) { this . ack timeout = ack timeout ; return ( t ) this ; }
public index [ ] index ( ) { return index ; }
public t index ( index [ ] index ) { this . index = index ; return ( t ) this ; }
public void on all node acked ( @ nullable exception e ) { listener . on response ( new response ( e == null ) ) ; }
public void local shard fail ( final shard rout shard routing , final string message , @ nullable final exception failure , action listener < void > listener ) { local shard fail ( shard routing , message , failure , listener , cluster service . state ( ) ) ; }
public boolean rout table change ( ) { return state . rout table ( ) ! = previous state . rout table ( ) ; }
public boolean local node master ( ) { return state . node ( ) . be local node elect master ( ) ; }
public static cluster state filter custom for pre63 client ( cluster state cluster state ) { final cluster state . builder builder = cluster state . builder ( cluster state ) ; cluster state . custom ( ) . key it ( ) . for each remain ( name - > { if ( pre_6_3_cluster_customs_white_list . contains ( name ) == false ) { builder . remove custom ( name ) ; } } ) ; final metadata . builder meta builder = metadata . builder ( cluster state . metadata ( ) ) ; cluster state . metadata ( ) . custom ( ) . key it ( ) . for each remain ( name - > { if ( pre_6_3_metadata_customs_white_list . contains ( name ) == false ) { meta builder . remove custom ( name ) ; } } ) ; return builder . metadata ( meta builder ) . build ( ) ; }
public cluster state set and get observe state ( ) { if ( observe context . get ( ) ! = null ) { throw new elasticsearch exception ( `` can not set current cluster state while wait for a cluster state change `` ) ; } cluster state cluster state = cluster applier service . state ( ) ; last observed state . set ( new store state ( cluster state ) ) ; return cluster state ; }
public static void ensure nodes compatibility ( final version join node version , discovery node current node ) { final version min node version = current node . get min node version ( ) ; final version max node version = current node . get max node version ( ) ; ensure node compatibility ( join node version , min node version , max node version ) ; }
public mapping metadata default mapping ( ) { return mapping . get ( mapper service . default_mapping ) ; }
public int get rout num shard ( ) { return rout num shard ; }
public static int parse index name counter ( string index name ) { int number index = index name . last index of ( `` - `` ) ; if ( number index == -1 ) { throw new illegal argument exception ( `` no - separator find in index name [ `` + index name + `` ] `` ) ; } try { return integer . parse int ( index name . substring ( number index + 1 , index name . end with ( `` > `` ) ? index name . length ( ) - 1 : index name . length ( ) ) ) ; } catch ( number format exception e ) { throw new illegal argument exception ( `` unable to parse the index name [ `` + index name + `` ] to extract the counter `` , e ) ; } }
public index concrete single index ( cluster state state , index request request ) { string index expression = collection utils . be empty ( request . index ( ) ) ? null : request . index ( ) [ 0 ] ; index [ ] index = concrete index ( state , request . index option ( ) , index expression ) ; if ( index . length ! = 1 ) { throw new illegal argument exception ( `` unable to return a single index a the index and option `` + `` provide get resolve to multiple index `` ) ; } return index [ 0 ] ; }
public boolean have alias ( final string [ ] alias , string [ ] concrete index ) { assert alias ! = null ; assert concrete index ! = null ; if ( concrete index . length == 0 ) { return false ; } iterable < string > intersection = hppc map . intersection ( object hash set . from ( concrete index ) , index . key ( ) ) ; for ( string index : intersection ) { index metadata index metadata = index . get ( index ) ; list < alias metadata > filter value = new array list < > ( ) ; for ( object cursor < alias metadata > cursor : index metadata . get alias ( ) . value ( ) ) { alias metadata value = cursor . value ; if ( regex . simple match ( alias , value . alias ( ) ) ) { filtered value . add ( value ) ; } } if ( filtered value . be empty ( ) == false ) { return true ; } } return false ; }
public int get total open index shard ( ) { return this . total open index shard ; }
public void remove component template ( final string [ ] names , final time value master timeout , cluster state state , final action listener < acknowledge response > listener ) { validate not in use ( state . metadata ( ) , names ) ; cluster service . submit state update task ( `` remove-component-template [ `` + string . join ( `` , `` , names ) + `` ] `` , new cluster state update task ( priority . urgent , master timeout ) { @ override public void on failure ( string source , exception e ) { listener . on failure ( e ) ; } @ override public cluster state execute ( cluster state current state ) { return inner remove component template ( current state , name ) ; } @ override public void cluster state process ( string source , cluster state old state , cluster state new state ) { listener . on response ( acknowledge response . true ) ; } } ) ; }
public boolean node exists ( string node id ) { return node . contains key ( node id ) ; }
public string get allocation id ( ) { check decision state ( ) ; return allocation id ; }
protect reroute explanation explain or throw reject command ( boolean explain , rout allocation allocation , string reason ) { if ( explain ) { return new reroute explanation ( this , allocation . decision ( decision . no , name ( ) + `` ( allocation command ) `` , reason ) ) ; } throw new illegal argument exception ( `` [ `` + name ( ) + `` ] `` + reason ) ; }
public string get high watermark raw ( ) { return high watermark raw ; }
public static move decision stay ( decision can remain decision ) { if ( can remain decision ! = null ) { assert can remain decision . type ( ) ! = type . no ; return new move decision ( can remain decision , null , allocation decision . no_attempt , null , null , 0 ) ; } else { return cached_stay_decision ; } }
public decision get cluster rebalance decision ( ) { check decision state ( ) ; return cluster rebalance decision ; }
public long get current nano time ( ) { return current nano time ; }
public rout node rout node ( ) { return rout node ; }
public metadata metadata ( ) { return metadata ; }
public move decision get move decision ( ) { return move decision ; }
public list < shard rout > shard with state ( shard rout state . . . state ) { if ( state . length == 1 ) { if ( state [ 0 ] == shard rout state . initialize ) { return new array list < > ( initialize shard ) ; } else if ( state [ 0 ] == shard rout state . relocate ) { return new array list < > ( relocate shard ) ; } } list < shard rout > shard = new array list < > ( ) ; for ( shard rout shard entry : this ) { for ( shard rout state state : state ) { if ( shard entry . state ( ) == state ) { shard . add ( shard entry ) ; } } } return shard ; }
public cluster state state ( ) { return cluster applier service . state ( ) ; }
public list < entry > get entry ( ) { return entry ; }
public void add without break ( long byte ) { long u = use . add and get ( byte ) ; logger . trace ( ( ) - > new parameterized message ( `` [ { } ] adjust breaker by [ { } ] byte , now [ { } ] `` , this . name , byte , u ) ) ; assert u > = 0 : `` use byte : [ `` + u + `` ] must be > = 0 `` ; }
public void invalidate ( k key , v value ) { cache segment < k , v > segment = get cache segment ( key ) ; segment . remove ( key , value , invalidation consumer ) ; }
public cache stats stats ( ) { long hit = 0 ; long miss = 0 ; long eviction = 0 ; for ( int i = 0 ; i < segment . length ; i++ ) { hit += segment [ i ] . segment stats . hit . long value ( ) ; miss += segment [ i ] . segment stats . miss . long value ( ) ; eviction += segment [ i ] . segment stats . eviction . long value ( ) ; } return new cache stats ( hit , miss , eviction ) ; }
public static string get package name ( class < ? > clazz ) { string class name = clazz . get name ( ) ; int last dot index = class name . last index of ( package_separator ) ; return ( last dot index ! = -1 ? class name . substring ( 0 , last dot index ) : `` `` ) ; }
public iterator < int object cursor < v type > > iterator ( ) { return map . iterator ( ) ; }
public coordinate builder close ( ) { coordinate start = point . get ( 0 ) ; coordinate end = point . get ( point . size ( ) -1 ) ; if ( start . x ! = end . x || start . y ! = end . y ) { point . add ( start ) ; } return this ; }
public multi polygon builder polygon ( polygon builder polygon ) { polygon builder pb = new polygon builder ( new coordinate builder ( ) . coordinate ( polygon . shell ( ) . coordinate ( false ) ) , this . orientation ) ; for ( line string builder hole : polygon . hole ( ) ) { pb . hole ( hole ) ; } this . polygon . add ( pb ) ; return this ; }
public list < polygon builder > polygon ( ) { return polygon ; }
public boolean point in bound ( double lon , double lat ) { if ( lat > = bottom ( ) & & lat < = top ( ) ) { if ( left ( ) < = right ( ) ) { return lon > = leave ( ) & & lon < = right ( ) ; } else { return lon > = leave ( ) || lon < = right ( ) ; } } return false ; }
public void write to ( stream output out ) throw i o exception { out . write v int ( this . ordinal ( ) ) ; }
public double calculate ( double src lat , double src lon , double dst lat , double dst lon , distance unit unit ) { if ( this == plane ) { return distance unit . convert ( geo utils . plane distance ( src lat , src lon , dst lat , dst lon ) , distance unit . meter , unit ) ; } return distance unit . convert ( geo utils . arc distance ( src lat , src lon , dst lat , dst lon ) , distance unit . meter , unit ) ; }
public t new instance ( object [ ] args ) throw throwable { try { return constructor . new instance ( args ) ; } catch ( invocation target exception e ) { throw e . get cause ( ) ; } }
public static string capitalize ( string s ) { if ( s . length ( ) == 0 ) { return s ; } char first = s . char at ( 0 ) ; char capitalize = character . to upper case ( first ) ; return ( first == capitalized ) ? s : capitalize + s . substring ( 1 ) ; }
public static path [ ] file ( path directory ) throw i o exception { try ( directory stream < path > stream = file . new directory stream ( directory ) ) { return to array ( stream ) ; } }
public u t f8 stream writer set output ( output stream out ) { if ( _output stream ! = null ) throw new illegal state exception ( `` writer not close or reset `` ) ; _output stream = out ; return this ; }
public shard id shard id ( ) { return this . shard id ; }
public static directory reader wrap all docs live ( directory reader in ) throw i o exception { return new directory reader with all live doc ( in ) ; }
public static leaf reader empty reader ( final int max doc ) { return new leaf reader ( ) { final bit live doc = new bit . match no bit ( max doc ) ; public term term ( string field ) { return null ; } public numeric doc value get numeric doc value ( string field ) { return null ; } public binary doc value get binary doc value ( string field ) { return null ; } public sort doc value get sort doc value ( string field ) { return null ; } public sort numeric doc value get sort numeric doc value ( string field ) { return null ; } public sort set doc value get sort set doc value ( string field ) { return null ; } public numeric doc value get norm value ( string field ) { return null ; } public field infos get field info ( ) { return new field info ( new field info [ 0 ] ) ; } public bit get live doc ( ) { return this . live doc ; } public point value get point value ( string field name ) { return null ; } public void check integrity ( ) { } public field get term vector ( int doc i d ) { return null ; } public int num doc ( ) { return 0 ; } public int max doc ( ) { return max doc ; } public void document ( int doc i d , store field visitor visitor ) { } protect void do close ( ) { } public leaf meta data get meta data ( ) { return new leaf meta data ( version . late . major , version . late , null ) ; } public cache helper get core cache helper ( ) { return null ; } public cache helper get reader cache helper ( ) { return null ; } } ; }
public void set minimum should match ( string minimum should match ) { this . minimum should match = minimum should match ; }
public static boolean be valid double ( double value ) { if ( double . be na n ( value ) || double . be infinite ( value ) ) { return false ; } return true ; }
public int get column number ( ) { return column number ; }
protect recycler . v < t > wrap ( recycler . v < t > delegate ) { return delegate ; }
public synchronize < t > void add setting update consumer ( set < t > setting , consumer < t > consumer , consumer < t > validator ) { if ( set ! = get ( set . get key ( ) ) ) { throw new illegal argument exception ( `` setting be not register for key [ `` + setting . get key ( ) + `` ] `` ) ; } add setting updater ( set . new updater ( consumer , logger , validator ) ) ; }
public boolean be private setting ( string key ) { return false ; }
public final boolean be operator only ( ) { return property . contains ( property . operator dynamic ) ; }
public final boolean be secure ( settings setting ) { final secure setting secure setting = setting . get secure setting ( ) ; return secure setting ! = null & & secure setting . get set name ( ) . contains ( get key ( ) ) ; }
public boolean exists ( final setting setting ) { return exists ( setting . key set ( ) ) ; }
public setting filter ( predicate < string > predicate ) { return new setting ( new filter map ( this . setting , predicate , null ) , secure setting == null ? null : new prefixed secure setting ( secure setting , `` `` , predicate ) ) ; }
public float get a float ( string setting , float default value ) { string s value = get ( set ) ; if ( s value == null ) { return default value ; } try { return float . parse float ( s value ) ; } catch ( number format exception e ) { throw new setting exception ( `` fail to parse float set [ `` + setting + `` ] with value [ `` + s value + `` ] `` , e ) ; } }
public string to delimit string ( char delimiter ) { string builder sb = new string builder ( ) ; for ( map . entry < string , object > entry : setting . entry set ( ) ) { sb . append ( entry . get key ( ) ) . append ( `` = `` ) . append ( entry . get value ( ) ) . append ( delimiter ) ; } return sb . to string ( ) ; }
public static long round week of week year ( final long utc millis ) { return round floor ( utc millis + 3 * 86400 * 1000l , 604800000 ) - 3 * 86400 * 1000l ; }
public static double parse ( string distance , distance unit default unit , distance unit to ) { distance dist = distance . parse distance ( distance , default unit ) ; return convert ( dist . value , dist . unit , to ) ; }
public static long zig zag encode ( long n ) { return ( n > > 63 ) ^ ( n < < 1 ) ; }
public static float read float l e ( byte [ ] arr , int offset ) { return float . int bit to float ( read int l e ( arr , offset ) ) ; }
public static void ensure no self reference ( object value , string message hint ) { iterable < ? > it = convert ( value ) ; if ( it ! = null ) { ensure no self reference ( it , value , collection . new set from map ( new identity hash map < > ( ) ) , message hint ) ; } }
public boolean count down ( ) { assert original count > 0 ; for ( ; ; ) { final int current = count down . get ( ) ; assert current > = 0 ; if ( current == 0 ) { return false ; } if ( count down . compare and set ( current , current - 1 ) ) { return current == 1 ; } } }
public boolean fast forward ( ) { assert original count > 0 ; assert count down . get ( ) > = 0 ; return count down . get and set ( 0 ) > 0 ; }
public boolean have lock key ( ) { return map . be empty ( ) == false ; }
public double get task execution e w m a ( ) { return execution e w m a . get average ( ) ; }
public runnable preserve context ( runnable command ) { if ( command instanceof context preserve abstract runnable ) { return command ; } if ( command instanceof context preserve runnable ) { return command ; } if ( command instanceof abstract runnable ) { return new context preserving abstract runnable ( ( abstract runnable ) command ) ; } return new context preserving runnable ( command ) ; }
public random get rng ( ) { return rng ; }
protect boolean need refresh ( ) { if ( refresh interval . millis ( ) == 0 ) { return true ; } final long current time = system . current time millis ( ) ; return ( current time - last refresh timestamp ) > refresh interval . millis ( ) ; }
public final validation exception add validation error ( string error ) { validation error . add ( error ) ; return this ; }
public boolean await all node ( time value timeout ) throw interrupted exception { boolean success = latch . await ( timeout . millis ( ) , time unit . millisecond ) ; assert success == false || pending node . be empty ( ) : `` response count reach 0 but still wait for some node `` ; return success ; }
public discovery node [ ] next possible master ( object container < discovery node > node , int number of possible master ) { list < discovery node > sort node = sort master node ( array . a list ( node . to array ( discovery node . class ) ) ) ; if ( sort node == null ) { return new discovery node [ 0 ] ; } list < discovery node > next possible master = new array list < > ( number of possible master ) ; int counter = 0 ; for ( discovery node next possible master : sort node ) { if ( ++counter > = number of possible master ) { break ; } next possible master . add ( next possible master ) ; } return next possible master . to array ( new discovery node [ next possible master . size ( ) ] ) ; }
public synchronize void add pending ( cluster state state ) { pending state . add ( new cluster state context ( state ) ) ; if ( pending state . size ( ) > max queue size ) { cluster state context context = pending state . remove ( 0 ) ; logger . warn ( `` drop pending state [ { } ] . more than [ { } ] pending state . `` , context , max queue size ) ; if ( context . commit ( ) ) { context . listener . on new cluster state fail ( new elasticsearch exception ( `` too many pending state ( [ { } ] pending ) `` , max queue size ) ) ; } } }
public boolean joining cluster ( ) { return join thread control . join thread active ( ) ; }
public void delete index directory under lock ( index index , index setting index setting , consumer < path [ ] > listener ) throw i o exception { final path [ ] index path = index path ( index ) ; logger . trace ( `` delete index { } directory , path ( { } ) : [ { } ] `` , index , index path . length , index path ) ; listener . accept ( index path ) ; i o utils . rm ( index path ) ; if ( index setting . have custom data path ( ) ) { path custom location = resolve index custom location ( index setting . custom data path ( ) , index . get u u i d ( ) ) ; logger . trace ( `` delete custom index { } directory [ { } ] `` , index , custom location ) ; listener . accept ( new path [ ] { custom location } ) ; i o utils . rm ( custom location ) ; } }
public set < shard id > lock shard ( ) { synchronize ( shard lock ) { return unmodifiable set ( new hash set < > ( shard lock . key set ( ) ) ) ; } }
public path [ ] index path ( index index ) { assert env be lock ( ) ; path [ ] index path = new path [ node path . length ] ; for ( int i = 0 ; i < node path . length ; i++ ) { index path [ i ] = node path [ i ] . resolve ( index ) ; } return index path ; }
public final shard id get shard id ( ) { return shard id ; }
public static void delete all ( path [ ] data path ) throw i o exception { for ( path data path : data path ) { lucene . clean lucene index ( new n i o f s directory ( data path . resolve ( metadata_directory_name ) ) ) ; } }
public final string name ( ) { return this . name ; }
public static pre configure tokenizer singleton ( string name , supplier < tokenizer > create ) { return new pre configure tokenizer ( name , cache strategy . one , version - > create . get ( ) ) ; }
public string [ ] available codecs ( ) { return codecs . key set ( ) . to array ( new string [ 0 ] ) ; }
public final index commit ref acquire index commit for snapshot ( ) throw engine exception { return engine config . get snapshot commit supplier ( ) . acquire index commit for snapshot ( this ) ; }
public long get term vector memory in byte ( ) { return this . term vector memory in byte ; }
public long get norms memory in byte ( ) { return this . norm memory in byte ; }
public void close ( ) throw i o exception { ordinal = null ; }
public long get total time in millis ( ) { return this . total time in millis ; }
public boolean be query string analyze wildcard ( ) { return query string analyze wildcard ; }
public setting get setting ( ) { return setting ; }
public time value get translog sync interval ( ) { return sync interval ; }
public int get translog retention total file ( ) { return index_translog_retention_total_files_setting . get ( get setting ( ) ) ; }
public byte size value get generation threshold size ( ) { return generation threshold size ; }
public int get max docvalue field ( ) { return this . max docvalue field ; }
public time value get search idle after ( ) { return search idle after ; }
public map field type get field type ( string field ) { return field type lookup ( ) . get ( field ) ; }
public final parse context create multi field context ( ) { return new filter parse context ( this ) { @ override public boolean be within multi field ( ) { return true ; } } ; }
public object parse from ( range field mapper . range field type field type , x content parser parser , boolean coerce , boolean include ) throw i o exception { number value = number type . parse ( parser , coerce ) ; return include ? value : ( number ) next up ( value ) ; }
public boolean be auto throttle ( ) { return auto throttle ; }
public qb indexed shape routing ( string index shape rout ) { this . indexed shape rout = indexed shape routing ; return ( qb ) this ; }
public query builder positive query ( ) { return this . positive query ; }
public common term query builder cutoff frequency ( float cutoff frequency ) { this . cutoff frequency = cutoff frequency ; return this ; }
public function score query . score mode score mode ( ) { return this . score mode ; }
public float max boost ( ) { return this . max boost ; }
public geo validation method get validation method ( ) { return this . validation method ; }
public string field name ( ) { return this . field name ; }
public geo distance query builder geo distance ( geo distance geo distance ) { if ( geo distance == null ) { throw new illegal argument exception ( `` geo distance must not be null `` ) ; } this . geo distance = geo distance ; return this ; }
public geo validation method get validation method ( ) { return this . validation method ; }
public int max expansion ( ) { return this . max expansion ; }
public zero term query option zero term query ( ) { return this . zero term query ; }
public more like this query builder min doc freq ( int min doc freq ) { this . min doc freq = min doc freq ; return this ; }
public more like this query builder fail on unsupported field ( boolean fail ) { this . fail on unsupported field = fail ; return this ; }
public query builder query ( ) { return query ; }
public static match query builder match query ( string name , object text ) { return new match query builder ( name , text ) ; }
public static match phrase query builder match phrase query ( string name , object text ) { return new match phrase query builder ( name , text ) ; }
public static combine field query builder combine field query ( object text , string . . . field names ) { return new combine field query builder ( text , field name ) ; }
public static range query builder range query ( string name ) { return new range query builder ( name ) ; }
public static function score query builder function score query ( query builder query builder ) { return new function score query builder ( query builder ) ; }
public static script score query builder script score query ( query builder query builder , script script ) { return new script score query builder ( query builder , script ) ; }
public static geo shape query builder geo disjoint query ( string name , geometry shape ) throw i o exception { geo shape query builder builder = geo shape query ( name , shape ) ; builder . relation ( shape relation . disjoint ) ; return builder ; }
public query string query builder fuzziness ( fuzziness fuzziness ) { this . fuzziness = fuzziness == null ? default_fuzziness : fuzziness ; return this ; }
public boolean be field map ( string name ) { return field type ( name ) ! = null ; }
public map field type build anonymous field type ( string type ) { if ( type . equal ( `` string `` ) ) { deprecation logger . deprecate ( deprecation category . mapping , `` unmapped_type_string `` , `` [ unmapped_type : string ] should be replace with [ unmapped_type : keyword ] `` ) ; type = `` keyword `` ; } map parser context parser context = mapper service . parser context ( ) ; mapper . type parser type parser = parser context . type parser ( type ) ; if ( type parser == null ) { throw new illegal argument exception ( `` no mapper find for type [ `` + type + `` ] `` ) ; } mapper . builder builder = type parser . parse ( `` __anonymous_ `` , collection . empty map ( ) , parser context ) ; mapper mapper = builder . build ( new content path ( 0 ) ) ; if ( mapper instanceof field mapper ) { return ( ( field mapper ) mapper ) . field type ( ) ; } throw new illegal argument exception ( `` mapper for type [ `` + type + `` ] must be a leaf field `` ) ; }
public simple query string builder field ( string field ) { if ( string . be empty ( field ) ) { throw new illegal argument exception ( `` supply field be null or empty `` ) ; } this . field and weight . put ( field , abstract query builder . default_boost ) ; return this ; }
public simple query string builder field ( string field , float boost ) { if ( string . be empty ( field ) ) { throw new illegal argument exception ( `` supply field be null or empty `` ) ; } check negative boost ( boost ) ; this . field and weight . put ( field , boost ) ; return this ; }
public simple query string builder analyzer ( string analyzer ) { this . analyzer = analyzer ; return this ; }
public boolean lenient ( ) { return this . setting . lenient ( ) ; }
public long get total ( ) { return this . total ; }
public long get external total ( ) { return this . external total ; }
public long get total time in millis ( ) { return this . total time in millis ; }
public long get external total time in millis ( ) { return this . external total time in millis ; }
public self set retry backoff initial time ( time value retry backoff initial time ) { request . set retry backoff initial time ( retry backoff initial time ) ; return self ( ) ; }
public void set worker ( float request per second , @ nullable integer slice id ) { if ( be worker ( ) ) { throw new illegal state exception ( `` this task be already a worker `` ) ; } if ( be leader ( ) ) { throw new illegal state exception ( `` this task be already a leader for other slice subtasks `` ) ; } worker state = new worker bulk by scroll task state ( this , slice id , request per second ) ; if ( be cancel ( ) ) { worker state . handle cancel ( ) ; } }
public delete by query request set batch size ( int size ) { get search request ( ) . source ( ) . size ( size ) ; return this ; }
public synchronize void update global checkpoint for shard ( final string allocation id , final long global checkpoint ) { assert primary mode ; assert handoff in progress == false ; assert invariant ( ) ; final checkpoint state cps = checkpoint . get ( allocation id ) ; assert this . shard allocation id . equal ( allocation id ) == false || cps ! = null ; if ( cps ! = null & & global checkpoint > cps . global checkpoint ) { final long previous global checkpoint = cps . global checkpoint ; cps . global checkpoint = global checkpoint ; logger . trace ( `` update local knowledge for [ { } ] on the primary of the global checkpoint from [ { } ] to [ { } ] `` , allocation id , previous global checkpoint , global checkpoint ) ; } assert invariant ( ) ; }
public long retain sequence number ( ) { return retain sequence number ; }
public string snapshot ( ) { return snapshot ; }
public list < file info > index file ( ) { return index file ; }
public int incremental file count ( ) { return incremental file count ; }
public file info find physical index file ( string physical name ) { if ( physical file == null ) { map < string , file info > file = new hash map < > ( ) ; for ( file info file info : index file ) { file . put ( file info . physical name ( ) , file info ) ; } this . physical file = file ; } return physical file . get ( physical name ) ; }
public void remove corruption marker ( ) throw i o exception { ensure open ( ) ; final directory directory = directory ( ) ; i o exception first exception = null ; final string [ ] file = directory . list all ( ) ; for ( string file : file ) { if ( file . start with ( corrupted_marker_name_prefix ) ) { try { directory . delete file ( file ) ; } catch ( i o exception ex ) { if ( first exception == null ) { first exception = ex ; } else { first exception . add suppressed ( ex ) ; } } } } if ( first exception ! = null ) { throw first exception ; } }
public void associate index with new translog ( final string translog u u i d ) throw i o exception { metadata lock . write lock ( ) . lock ( ) ; try ( index writer writer = new temporary append index writer ( directory , null ) ) { if ( translog u u i d . equal ( get user data ( writer ) . get ( translog . translog_uuid_key ) ) ) { throw new illegal argument exception ( `` a new translog uuid ca n't be equal to exist one . get [ `` + translog u u i d + `` ] `` ) ; } update commit data ( writer , collection . singleton map ( translog . translog_uuid_key , translog u u i d ) ) ; } finally { metadata lock . write lock ( ) . unlock ( ) ; } }
protect translog . operation read ( buffer checksum stream input in stream ) throw i o exception { final translog . operation op = translog . read operation ( in stream ) ; if ( op . primary term ( ) > get primary term ( ) & & get primary term ( ) ! = sequence number . unassigned_primary_term ) { throw new translog corrupt exception ( path . to string ( ) , `` operation 's term be new than translog header term ; `` + `` operation term [ `` + op . primary term ( ) + `` ] , translog header term [ `` + get primary term ( ) + `` ] `` ) ; } return op ; }
public long get min file generation ( ) { try ( releasable lock ignore = read lock . acquire ( ) ) { if ( reader . be empty ( ) ) { return current . get generation ( ) ; } else { assert reader . stream ( ) . map ( translog reader : : get generation ) . min ( long : : compare to ) . get ( ) . equal ( reader . get ( 0 ) . get generation ( ) ) : `` the first translog be n't the one with the minimum generation : `` + reader ; return reader . get ( 0 ) . get generation ( ) ; } } }
public long total time in millis ( ) { return this . total time in millis ; }
public void fail recovery ( long id , recovery fail exception e , boolean send shard failure ) { recovery target remove = on go recovery . remove ( id ) ; if ( remove ! = null ) { logger . trace ( `` { } fail recovery from { } , id [ { } ] . send shard failure : [ { } ] `` , remove . shard id ( ) , remove . source node ( ) , remove . recovery id ( ) , send shard failure ) ; remove . fail ( e , send shard failure ) ; } }
public executor name get thread pool name ( ) { return this . executor name ; }
public pipeline get pipeline ( string id ) { pipeline holder holder = pipeline . get ( id ) ; if ( holder ! = null ) { return holder . pipeline ; } else { return null ; } }
public static setting prepare setting ( setting input ) { setting . builder output = setting . builder ( ) ; initialize setting ( output , input , collection . empty map ( ) ) ; finalize setting ( output , ( ) - > null ) ; return output . build ( ) ; }
public static cluster state disassociate dead node ( cluster state cluster state ) { persistent task custom metadata task = get persistent task custom metadata ( cluster state ) ; if ( task == null ) { return cluster state ; } persistent task custom metadata . builder task builder = persistent task custom metadata . builder ( task ) ; for ( persistent task < ? > task : task . task ( ) ) { if ( task . get assignment ( ) . get executor node ( ) ! = null & & cluster state . node ( ) . node exists ( task . get assignment ( ) . get executor node ( ) ) == false ) { task builder . reassign task ( task . get id ( ) , lost_node_assignment ) ; } } if ( task builder . be change ( ) == false ) { return cluster state ; } metadata . builder metadata builder = metadata . builder ( cluster state . metadata ( ) ) ; metadata builder . put custom ( type , task builder . build ( ) ) ; return cluster state . builder ( cluster state ) . metadata ( metadata builder ) . build ( ) ; }
public list < executor builder < ? > > get executor builder ( setting setting ) { return collection . empty list ( ) ; }
public static plugin info read from property ( final path path ) throw i o exception { final path descriptor = path . resolve ( es_plugin_properties ) ; final map < string , string > prop map ; { final property prop = new property ( ) ; try ( input stream stream = file . new input stream ( descriptor ) ) { prop . load ( stream ) ; } prop map = prop . string property name ( ) . stream ( ) . collect ( collector . to map ( function . identity ( ) , prop : : get property ) ) ; } final string name = prop map . remove ( `` name `` ) ; if ( name == null || name . be empty ( ) ) { throw new illegal argument exception ( `` property [ name ] be miss in [ `` + descriptor + `` ] `` ) ; } final string description = prop map . remove ( `` description `` ) ; if ( description == null ) { throw new illegal argument exception ( `` property [ description ] be miss for plugin [ `` + name + `` ] `` ) ; } final string version = prop map . remove ( `` version `` ) ; if ( version == null ) { throw new illegal argument exception ( `` property [ version ] be miss for plugin [ `` + name + `` ] `` ) ; } final string es version string = prop map . remove ( `` elasticsearch . version `` ) ; if ( es version string == null ) { throw new illegal argument exception ( `` property [ elasticsearch . version ] be miss for plugin [ `` + name + `` ] `` ) ; } final version e version = version . from string ( es version string ) ; final string java version string = prop map . remove ( `` java . version `` ) ; if ( java version string == null ) { throw new illegal argument exception ( `` property [ java . version ] be miss for plugin [ `` + name + `` ] `` ) ; } jar hell . check version format ( java version string ) ; final string extend string = prop map . remove ( `` extend . plugins `` ) ; final list < string > extend plugins ; if ( extended string == null ) { extended plugins = collection . empty list ( ) ; } else { extended plugins = arrays . a list ( string . delimit list to string array ( extended string , `` , `` ) ) ; } final boolean have native controller = parse boolean value ( name , `` have . native . controller `` , prop map . remove ( `` have . native . controller `` ) ) ; final plugin type type = get plugin type ( name , prop map . remove ( `` type `` ) ) ; final string classname = get classname ( name , type , prop map . remove ( `` classname `` ) ) ; final string java opts = prop map . remove ( `` java . opts `` ) ; if ( type ! = plugin type . bootstrap & & string . be null or empty ( java opts ) == false ) { throw new illegal argument exception ( `` [ java . opts ] can only have a value when [ type ] be set to [ bootstrap ] for plugin [ `` + name + `` ] `` ) ; } if ( es version . before ( version . v_6_3_0 ) & & es version . on or after ( version . v_6_0_0_beta2 ) ) { props map . remove ( `` require . keystore `` ) ; } boolean be license = false ; if ( es version . on or after ( licensed_plugins_support ) ) { be license = parse boolean value ( name , `` license `` , prop map . remove ( `` license `` ) ) ; } if ( props map . be empty ( ) == false ) { throw new illegal argument exception ( `` unknown property for plugin [ `` + name + `` ] in plugin descriptor : `` + prop map . key set ( ) ) ; } return new plugin info ( name , description , version , es version , java version string , classname , extend plugins , have native controller , type , java opts , be license ) ; }
public list < string > get extend plugins ( ) { return extend plugins ; }
public boolean be license ( ) { return be license ; }
protect final boolean be compress ( ) { return compress ; }
protect set < string > response params ( ) { return allow response parameter ; }
public string uri ( ) { return http request . uri ( ) ; }
public string raw path ( ) { return raw path ; }
public static pattern check cors set for regex ( string cors set ) { if ( cors set == null ) { return null ; } int len = cors set . length ( ) ; boolean be regex = len > 2 & & cors set . start with ( `` / `` ) & & cors set . end with ( `` / `` ) ; if ( be regex ) { return pattern . compile ( cors set . substring ( 1 , cors set . length ( ) -1 ) ) ; } return null ; }
public string get script ( ) { return script ; }
public string get lang ( ) { return lang ; }
public x content builder to x content internal ( x content builder builder , params params ) throw i o exception { for ( aggregation aggregation : aggregation ) { aggregation . to x content ( builder , params ) ; } return builder ; }
public final aggregator create ( aggregator parent , cardinality upper bound cardinality ) throw i o exception { return create internal ( parent , cardinality , this . metadata ) ; }
public string separator ( ) { return separator ; }
public aggregator wrap ( final aggregator in ) { return new wrap aggregator ( in ) { @ override public internal aggregation [ ] build aggregation ( long [ ] own bucket ords ) throw i o exception { if ( select bucket == null ) { throw new illegal state exception ( `` collection have not be replay yet . `` ) ; } long [ ] rebased ords = new long [ own bucket ords . length ] ; for ( int ord idx = 0 ; ord idx < own bucket ords . length ; ord idx++ ) { rebased ords [ ord idx ] = select bucket . find ( own bucket ords [ ord idx ] ) ; if ( rebased ords [ ord idx ] == -1 ) { throw new illegal state exception ( `` can not build for a bucket which have not be collect `` ) ; } } return in . build aggregation ( rebased ords ) ; } } ; }
public void set after key ( composite key after key ) { assert after key . size ( ) == array . length ; after key be set = true ; for ( int i = 0 ; i < after key . size ( ) ; i++ ) { try { array [ i ] . set after ( after key . get ( i ) ) ; } catch ( illegal argument exception ex ) { throw new illegal argument exception ( `` incompatible value in the position `` + i + `` : `` + ex . get message ( ) , ex ) ; } } }
protected boolean should defer ( aggregator aggregator ) { return false ; }
public long interval ( ) { return date histogram interval . interval ( ) ; }
public long min doc count ( ) { return min doc count ; }
public int shard size ( ) { return shard size ; }
public significant term aggregation builder min doc count ( long min doc count ) { if ( min doc count < 0 ) { throw new illegal argument exception ( `` [ min doc count ] must be great than or equal to 0 . find [ `` + min doc count + `` ] in [ `` + name + `` ] `` ) ; } bucket count threshold . set min doc count ( min doc count ) ; return this ; }
public int shard size ( ) { return bucket count threshold . get shard size ( ) ; }
public sub agg collection mode collect mode ( ) { return collect mode ; }
public list < internal aggregation > copy result ( ) { return new array list < > ( get internal aggregation ( ) ) ; }
public t percentile config ( percentile config percentile config ) { this . percentile config = percentile config ; return ( t ) this ; }
public double delta ( ) { return delta ; }
public void reset ( double value , double delta ) { this . value = value ; this . delta = delta ; }
public static int precision from threshold ( long count ) { final long hash table entry = ( long ) math . ceil ( count / max_load_factor ) ; int precision = pack ints . bit require ( hash table entry * integer . byte ) ; precision = math . max ( precision , abstract hyper log log . min_precision ) ; precision = math . min ( precision , abstract hyper log log . max_precision ) ; return precision ; }
public median absolute deviation aggregation builder compression ( double compression ) { if ( compression < = 0d ) { throw new illegal argument exception ( `` [ `` + compression_field . get preferred name ( ) + `` ] must be great than 0 . find [ `` + compression + `` ] in [ `` + name + `` ] `` ) ; } this . compression = compression ; return this ; }
public set < script field > script field ( ) { return script field ; }
public top hit aggregation builder track score ( boolean track score ) { this . track score = track score ; return this ; }
protect static double parse double ( x content parser parser , double default null value ) throw i o exception { token current token = parser . current token ( ) ; if ( current token == x content parser . token . value_number || current token == x content parser . token . value_string ) { return parser . double value ( ) ; } else { return default null value ; } }
public int lag ( ) { return lag ; }
protect boolean serialize target value type ( version version ) { return false ; }
public string get description ( ) { if ( script ! = null ) { return `` script yielding [ `` + ( script value type ! = null ? script value type . get preferred name ( ) : `` unknown type `` ) + `` ] `` ; } map field type field type = field type ( ) ; if ( field type ! = null ) { return `` field [ `` + field type . name ( ) + `` ] of type [ `` + field type . type name ( ) + `` ] `` ; } return `` unmapped field `` ; }
public search source builder query ( query builder query ) { this . query builder = query ; return this ; }
public query builder post filter ( ) { return post query builder ; }
public search source builder doc value field ( string name , @ nullable string format ) { if ( doc value field == null ) { doc value field = new array list < > ( ) ; } doc value field . add ( new field and format ( name , format ) ) ; return this ; }
public context index searcher searcher ( ) { return search context . searcher ( ) ; }
public string name ( ) { return name ; }
public releasable mark a use ( long keep alive in millis ) { ref count . inc ref ( ) ; try update keep alive ( keep alive in millis ) ; return releasables . release once ( ( ) - > { this . last access time . update and get ( curr - > math . max ( curr , now in millis ( ) ) ) ; ref count . dec ref ( ) ; } ) ; }
public object extract value ( string path , @ nullable object null value ) { return x content map value . extract value ( path , source ( ) , null value ) ; }
public query profiler add query profiler ( ) { query profiler profiler = new query profiler ( ) ; searcher . set profiler ( profiler ) ; query profilers . add ( profiler ) ; return profiler ; }
public query profiler get current query profiler ( ) { return query profilers . get ( query profilers . size ( ) - 1 ) ; }
public boolean be null ( ) { return be null ; }
public int size ( ) { return size ; }
public rescorer rescorer ( ) { return rescorer ; }
public string get fully qualified index name ( ) { return remote cluster aware . build remote index name ( cluster alias , get index ( ) ) ; }
public string get nest path ( ) { return this . nested path ; }
public script sort type type ( ) { return this . type ; }
public direct candidate generator builder suggest mode ( string suggest mode ) { this . suggest mode = suggest mode ; return this ; }
public direct candidate generator builder max edits ( integer max edits ) { if ( max edit < 1 || max edits > levenshtein automaton . maximum_supported_distance ) { throw new illegal argument exception ( `` illegal max_edits value `` + max edits ) ; } this . max edits = max edits ; return this ; }
public direct candidate generator builder min word length ( int min word length ) { this . min word length = min word length ; return this ; }
public float max error ( ) { return this . max error ; }
public suggest builder set global text ( @ nullable string global text ) { this . global text = global text ; return this ; }
public term suggestion builder max inspection ( int max inspection ) { if ( max inspection < 0 ) { throw new illegal argument exception ( `` max inspection must be positive `` ) ; } this . max inspection = max inspection ; return this ; }
public static set < index > snapshotting index ( final cluster state current state , final set < index > index to check ) { final snapshot in progress snapshot = current state . custom ( snapshot in progress . type ) ; if ( snapshots == null ) { return empty set ( ) ; } final set < index > indices = new hash set < > ( ) ; for ( final snapshot in progress . entry entry : snapshot . entry ( ) ) { if ( entry . partial ( ) == false & & entry . be clone ( ) == false ) { for ( string index name : entry . index ( ) . key set ( ) ) { index metadata index metadata = current state . metadata ( ) . index ( index name ) ; if ( index metadata ! = null & & index to check . contains ( index metadata . get index ( ) ) ) { index . add ( index metadata . get index ( ) ) ; } } } } return index ; }
public int get ban count ( ) { return ban parent . size ( ) ; }
public void write thin ( stream output out ) throw i o exception { super . write to ( out ) ; out . write v int ( byte . length ( ) ) ; }
public int size ( ) { return connect node . size ( ) ; }
public static int read message length ( bytes reference network byte ) throw i o exception { if ( network byte . length ( ) < bytes_needed_for_message_size ) { return -1 ; } else { return read header buffer ( network byte ) ; } }
public static transport request unwrap request ( transport request request ) { if ( request instanceof proxy request ) { return ( ( proxy request ) request ) . wrap ; } return request ; }
public static boolean be proxy request ( transport request request ) { return request instanceof proxy request ; }
public final void accept incoming request ( ) { final boolean start with this call = handle incoming request . compare and set ( false , true ) ; assert start with this call : `` transport service be already accept incoming request `` ; logger . debug ( `` now accept incoming request `` ) ; }
public transport . connection open connection ( final discovery node node , connection profile connection profile ) { return plain action future . get ( fut - > open connection ( node , connection profile , fut ) ) ; }
public transport . connection get connection ( discovery node node ) { if ( be local node ( node ) ) { return local node connection ; } else { return connection manager . get connection ( node ) ; } }
public void add listener ( listener listener ) { listener . add ( listener ) ; }
public void remove ( listener listener ) { listener . remove ( listener ) ; }
protect void print additional help ( terminal terminal ) { }
public static char [ ] read line to char array ( reader reader , int max length ) { char [ ] buf = new char [ max length + 2 ] ; try { int len = 0 ; int next ; while ( ( next = reader . read ( ) ) ! = -1 ) { char next char = ( char ) next ; if ( next char == '\n ' ) { break ; } if ( len < buf . length ) { buf [ len ] = next char ; } len++ ; } if ( len > 0 & & len < buf . length & & buf [ len-1 ] == '\r ' ) { len -- ; } if ( len > max length ) { array . fill ( buf , '\0 ' ) ; throw new runtime exception ( `` input exceed maximum length of `` + max length ) ; } char [ ] short result = array . copy of ( buf , len ) ; array . fill ( buf , '\0 ' ) ; return short result ; } catch ( i o exception e ) { throw new runtime exception ( e ) ; } }
public static boolean constant time equal ( string a , string b ) { object . require non null ( a , `` string must not be null for constant time equal `` ) ; object . require non null ( b , `` string must not be null for constant time equal `` ) ; if ( a . length ( ) ! = b . length ( ) ) { return false ; } int equal = 0 ; for ( int i = 0 ; i < a . length ( ) ; i++ ) { equal |= a . char at ( i ) ^ b . char at ( i ) ; } return equal == 0 ; }
public static socket option < integer > get tcp keep count socket option or null ( ) { return get extend socket option or null ( `` tcp_keepcount `` ) ; }
public static < k , v > java . util . map < k , v > of ( k k1 , v v1 , k k2 , v v2 , k k3 , v v3 ) { return map n ( k1 , v1 , k2 , v2 , k3 , v3 ) ; }
public static file system get default file system ( ) { return default ; }
public static java version parse ( string value ) { object . require non null ( value ) ; string pre part = null ; if ( be valid ( value ) == false ) { throw new illegal argument exception ( `` java version string [ `` + value + `` ] could not be parse . `` ) ; } list < integer > version = new array list < > ( ) ; string [ ] part = value . split ( `` - `` ) ; string [ ] numeric component ; if ( part . length == 1 ) { numeric component = value . split ( `` \\ . `` ) ; } else if ( part . length == 2 ) { numeric component = part [ 0 ] . split ( `` \\ . `` ) ; pre part = part [ 1 ] ; } else { throw new illegal argument exception ( `` java version string [ `` + value + `` ] could not be parse . `` ) ; } for ( string component : numeric component ) { version . add ( integer . value of ( component ) ) ; } return new java version ( version , pre part ) ; }
public static long interleave ( int even , int odd ) { long v1 = 0x00000000 f f f f f f f f l & even ; long v2 = 0x00000000 f f f f f f f f l & odd ; v1 = ( v1 | ( v1 < < shift [ 4 ] ) ) & magic [ 4 ] ; v1 = ( v1 | ( v1 < < shift [ 3 ] ) ) & magic [ 3 ] ; v1 = ( v1 | ( v1 < < shift [ 2 ] ) ) & magic [ 2 ] ; v1 = ( v1 | ( v1 < < shift [ 1 ] ) ) & magic [ 1 ] ; v1 = ( v1 | ( v1 < < shift [ 0 ] ) ) & magic [ 0 ] ; v2 = ( v2 | ( v2 < < shift [ 4 ] ) ) & magic [ 4 ] ; v2 = ( v2 | ( v2 < < shift [ 3 ] ) ) & magic [ 3 ] ; v2 = ( v2 | ( v2 < < shift [ 2 ] ) ) & magic [ 2 ] ; v2 = ( v2 | ( v2 < < shift [ 1 ] ) ) & magic [ 1 ] ; v2 = ( v2 | ( v2 < < shift [ 0 ] ) ) & magic [ 0 ] ; return ( v2 < < 1 ) | v1 ; }
public static final long long encode ( string hash ) { return long encode ( hash , hash . length ( ) ) ; }
public static final string string encode ( final double lon , final double lat ) { return string encode ( lon , lat , 12 ) ; }
public static double lat height in degree ( int precision ) { return precision to lat height [ precision ] ; }
public http host get host ( ) { return host ; }
public response perform request ( string method , string endpoint , header . . . header ) throw i o exception { return perform request ( method , endpoint , collection . < string , string > empty map ( ) , null , header ) ; }
public request option get option ( ) { return option ; }
public int get min length ( ) { return min length ; }
public boolean get allow partial search result ( ) { return this . search request . allow partial search result ( ) ; }
public void set batch reduce size ( int batch reduce size ) { this . batch reduce size = batch reduce size ; }
public boolean get request cache ( ) { return this . search request . request cache ( ) ; }
public cancellable submit async ( submit async search request request , request option option , action listener < async search response > listener ) { return rest high level client . perform request async and parse entity ( request , async search request converter : : submit async search , option , async search response : : from x content , listener , empty set ( ) ) ; }
public cancellable get async ( get async search request request , request option option , action listener < async search response > listener ) { return rest high level client . perform request async and parse entity ( request , async search request converter : : get async search , option , async search response : : from x content , listener , empty set ( ) ) ; }
public acknowledge response pause follow ( pause follow request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , ccr request converter : : pause follow , option , acknowledge response : : from x content , collection . empty set ( ) ) ; }
public cancellable delete component template async ( delete component template request request , request option option , action listener < acknowledge response > listener ) { return rest high level client . perform request async and parse entity ( request , cluster request converter : : delete component template , option , acknowledge response : : from x content , listener , empty set ( ) ) ; }
public acknowledge response put component template ( put component template request put component template request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( put component template request , cluster request converter : : put component template , option , acknowledge response : : from x content , empty set ( ) ) ; }
public get component template response get component template ( get component template request get component template request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( get component template request , cluster request converter : : get component template , option , get component template response : : from x content , empty set ( ) ) ; }
public shard shard ( ) { return shard ; }
public long get count ( ) { return count ; }
public long get take in millis ( ) { return take in millis ; }
public final graph explore response explore ( graph explore request graph explore request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( graph explore request , graph request converter : : explore , option , graph explore response : : from x content , empty set ( ) ) ; }
public cancellable start i l m async ( start i l m request request , request option option , action listener < acknowledge response > listener ) { return rest high level client . perform request async and parse entity ( request , index lifecycle request converter : : start i l m , option , acknowledge response : : from x content , listener , empty set ( ) ) ; }
public cancellable explain lifecycle async ( explain lifecycle request request , request option option , action listener < explain lifecycle response > listener ) { return rest high level client . perform request async and parse entity ( request , index lifecycle request converter : : explain lifecycle , option , explain lifecycle response : : from x content , listener , empty set ( ) ) ; }
public acknowledge response delete snapshot lifecycle policy ( delete snapshot lifecycle policy request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , index lifecycle request converter : : delete snapshot lifecycle policy , option , acknowledge response : : from x content , empty set ( ) ) ; }
public cancellable get s l m status async ( snapshot lifecycle management status request request , request option option , action listener < lifecycle management status response > listener ) { return rest high level client . perform request async and parse entity ( request , index lifecycle request converter : : snapshot lifecycle management status , option , lifecycle management status response : : from x content , listener , empty set ( ) ) ; }
public static analyze request with normalizer ( string index , string normalizer , string . . . text ) { return new analyze request ( index , null , normalizer , null , text ) ; }
public active shard count wait for active shard ( ) { return wait for active shard ; }
public put component template request cause ( string cause ) { this . cause = cause ; return this ; }
public string index name ( ) { return index name ; }
public simulate index template request index template v2 request ( @ nullable put composable index template request index template v2 request ) { this . index template v2 request = index template v2 request ; return this ; }
public string [ ] get index ( ) { return index ; }
public cancellable get data stream async ( get data stream request data stream request , request option option , action listener < get data stream response > listener ) { return rest high level client . perform request async and parse entity ( data stream request , indices request converter : : get data stream , option , get data stream response : : from x content , listener , empty set ( ) ) ; }
public boolean exists ( get index request request , request option option ) throw i o exception { return rest high level client . perform request ( request , indices request converter : : index exist , option , rest high level client : : convert exist response , collection . empty set ( ) ) ; }
public rollover response rollover ( rollover request rollover request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( rollover request , indices request converter : : rollover , option , rollover response : : from x content , empty set ( ) ) ; }
public cancellable put setting async ( update setting request update setting request , request option option , action listener < acknowledge response > listener ) { return rest high level client . perform request async and parse entity ( update setting request , indices request converter : : index put setting , option , acknowledge response : : from x content , listener , empty set ( ) ) ; }
public analyze response analyze ( analyze request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , indices request converter : : analyze , option , analyze response : : from x content , empty set ( ) ) ; }
public cancellable get job async ( get job request request , request option option , action listener < get job response > listener ) { return rest high level client . perform request async and parse entity ( request , m l request converter : : get job , option , get job response : : from x content , listener , collection . empty set ( ) ) ; }
public open job response open job ( open job request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : open job , option , open job response : : from x content , collection . empty set ( ) ) ; }
public cancellable get datafeed async ( get datafeed request request , request option option , action listener < get datafeed response > listener ) { return rest high level client . perform request async and parse entity ( request , m l request converter : : get datafeed , option , get datafeed response : : from x content , listener , collection . empty set ( ) ) ; }
public post data response post data ( post data request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : post data , option , post data response : : from x content , collection . empty set ( ) ) ; }
public acknowledge response delete calendar ( delete calendar request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : delete calendar , option , acknowledge response : : from x content , collection . empty set ( ) ) ; }
public put filter response update filter ( update filter request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : update filter , option , put filter response : : from x content , collection . empty set ( ) ) ; }
public acknowledge response delete filter ( delete filter request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : delete filter , option , acknowledge response : : from x content , collection . empty set ( ) ) ; }
public put data frame analytics response update data frame analytics ( update data frame analytics request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : update data frame analytics , option , put data frame analytics response : : from x content , collection . empty set ( ) ) ; }
public stop data frame analytics response stop data frame analytics ( stop data frame analytics request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : stop data frame analytics , option , stop data frame analytics response : : from x content , collection . empty set ( ) ) ; }
public cancellable delete data frame analytics async ( delete data frame analytics request request , request option option , action listener < acknowledge response > listener ) { return rest high level client . perform request async and parse entity ( request , m l request converter : : delete data frame analytics , option , acknowledge response : : from x content , listener , collection . empty set ( ) ) ; }
public evaluate data frame response evaluate data frame ( evaluate data frame request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : evaluate data frame , option , evaluate data frame response : : from x content , collection . empty set ( ) ) ; }
public cancellable evaluate data frame async ( evaluate data frame request request , request option option , action listener < evaluate data frame response > listener ) { return rest high level client . perform request async and parse entity ( request , m l request converter : : evaluate data frame , option , evaluate data frame response : : from x content , listener , collection . empty set ( ) ) ; }
public static delay data check config disabled delay data check config ( ) { return new delay data check config ( false , null ) ; }
public void set force ( boolean force ) { this . force = force ; }
public boolean be flush ( ) { return flush ; }
public boolean be acknowledge ( ) { return acknowledge ; }
public void set anomaly score ( double anomaly score ) { this . anomaly score = anomaly score ; }
public list < category definition > category ( ) { return result ; }
public void set from ( integer from ) { this . from = from ; }
public get train model request set allow no match ( boolean allow no match ) { this . allow no match = allow no match ; return this ; }
public string get transport address ( ) { return transport address ; }
public void set job id ( string job id ) { this . job id = object . require non null ( job id , `` [ job_id ] must not be null `` ) ; }
public void set job id ( string job id ) { this . job id = object . require non null ( job id , `` [ job_id ] must not be null `` ) ; }
public list < string > get datafeed id ( ) { return datafeed id ; }
public boolean be stop ( ) { return stop ; }
public void set add item ( collection < string > add item ) { this . add item = new tree set < > ( object . require non null ( add item , `` [ `` + add_items . get preferred name ( ) + `` ] must not be null `` ) ) ; }
public final ccr client ccr ( ) { return ccr client ; }
public license client license ( ) { return license client ; }
public final bulk by scroll response reindex ( reindex request reindex request , request option option ) throw i o exception { return perform request and parse entity ( reindex request , request converter : : reindex , option , bulk by scroll response : : from x content , singleton ( 409 ) ) ; }
public final get response get ( get request get request , request option option ) throw i o exception { return perform request and parse entity ( get request , request converter : : get , option , get response : : from x content , singleton ( 404 ) ) ; }
public final cancellable index async ( index request index request , request option option , action listener < index response > listener ) { return perform request async and parse entity ( index request , request converter : : index , option , index response : : from x content , listener , empty set ( ) ) ; }
public final cancellable delete async ( delete request delete request , request option option , action listener < delete response > listener ) { return perform request async and parse entity ( delete request , request converter : : delete , option , delete response : : from x content , listener , collection . singleton ( 404 ) ) ; }
public final multi term vector response mtermvectors ( multi term vector request request , request option option ) throw i o exception { return perform request and parse entity ( request , request converter : : mterm vector , option , multi term vector response : : from x content , empty set ( ) ) ; }
public boolean be find ( final string privilege ) { return privilege . contains ( privilege ) ; }
public static get api key request use realm name ( string realm name ) { return new get api key request ( realm name , null , null , null , false ) ; }
public static get api key request use realm and user name ( string realm name , string user name ) { return new get api key request ( realm name , user name , null , null , false ) ; }
public list < node > get node ( ) { return node ; }
public set < string > get privilege ( ) { return this . privilege ; }
public delete user response delete user ( delete user request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , security request converter : : delete user , option , delete user response : : from x content , singleton ( 404 ) ) ; }
public boolean disable user ( disable user request request , request option option ) throw i o exception { return rest high level client . perform request ( request , security request converter : : disable user , option , rest high level client : : convert exist response , empty set ( ) ) ; }
public authenticate response authenticate ( request option option ) throw i o exception { return rest high level client . perform request and parse entity ( authenticate request . instance , authenticate request : : get request , option , authenticate response : : from x content , empty set ( ) ) ; }
public cancellable clear api key cache async ( clear api key cache request request , request option option , action listener < clear security cache response > listener ) { return rest high level client . perform request async and parse entity ( request , security request converter : : clear api key cache , option , clear security cache response : : from x content , listener , empty set ( ) ) ; }
public cancellable get ssl certificate async ( request option option , action listener < get ssl certificate response > listener ) { return rest high level client . perform request async and parse entity ( get ssl certificate request . instance , get ssl certificate request : : get request , option , get ssl certificate response : : from x content , listener , empty set ( ) ) ; }
public cancellable create token async ( create token request request , request option option , action listener < create token response > listener ) { return rest high level client . perform request async and parse entity ( request , security request converter : : create token , option , create token response : : from x content , listener , empty set ( ) ) ; }
public create api key response create api key ( final create api key request request , final request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , security request converter : : create api key , option , create api key response : : from x content , empty set ( ) ) ; }
public acknowledge response create repository ( put repository request put repository request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( put repository request , snapshot request converter : : create repository , option , acknowledge response : : from x content , empty set ( ) ) ; }
public cancellable delete repository async ( delete repository request delete repository request , request option option , action listener < acknowledge response > listener ) { return rest high level client . perform request async and parse entity ( delete repository request , snapshot request converter : : delete repository , option , acknowledge response : : from x content , listener , empty set ( ) ) ; }
public cancellable get async ( get snapshots request get snapshots request , request option option , action listener < get snapshots response > listener ) { return rest high level client . perform request async and parse entity ( get snapshots request , snapshot request converter : : get snapshot , option , get snapshots response : : from x content , listener , empty set ( ) ) ; }
public restore snapshot response restore ( restore snapshot request restore snapshot request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( restore snapshot request , snapshot request converter : : restore snapshot , option , restore snapshot response : : from x content , empty set ( ) ) ; }
public cancellable find structure async ( find structure request request , request option option , action listener < find structure response > listener ) { return rest high level client . perform request async and parse entity ( request , text structure request converter : : find file structure , option , find structure response : : from x content , listener , collection . empty set ( ) ) ; }
public get transform response get transform ( get transform request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , transform request converter : : get transform , option , get transform response : : from x content , collection . empty set ( ) ) ; }
public void set active ( boolean active ) { this . active = active ; }
public cancellable deactivate watch async ( deactivate watch request request , request option option , action listener < deactivate watch response > listener ) { return rest high level client . perform request async and parse entity ( request , watcher request converter : : deactivate watch , option , deactivate watch response : : from x content , listener , empty set ( ) ) ; }
public delete watch response delete watch ( delete watch request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , watcher request converter : : delete watch , option , delete watch response : : from x content , singleton ( 404 ) ) ; }
public cancellable ack watch async ( ack watch request request , request option option , action listener < ack watch response > listener ) { return rest high level client . perform request async and parse entity ( request , watcher request converter : : ack watch , option , ack watch response : : from x content , listener , empty set ( ) ) ; }
public cancellable info async ( x pack info request request , request option option , action listener < x pack info response > listener ) { return rest high level client . perform request async and parse entity ( request , x pack request converter : : info , option , x pack info response : : from x content , listener , empty set ( ) ) ; }
public x content builder human readable ( boolean human readable ) { this . human readable = human readable ; return this ; }
public x content builder utf8 value ( byte [ ] byte , int offset , int length ) throw i o exception { generator . write u t f8 string ( byte , offset , length ) ; return this ; }
public string get symbol ( ) { return symbol ; }
public double get value ( ) { return value ; }
public list < string > get error ( ) { return error ; }
public final expect builder with input ( input stream . . . input ) { this . input = input ; return this ; }
public final expect builder with charset ( charset charset ) { this . charset = charset ; return this ; }
public final expect builder with buffer size ( int buffer size ) { if ( buffer size < = 0 ) { throw new illegal argument exception ( `` buffer size must be > 0 `` ) ; } this . buffer size = buffer size ; return this ; }
public static result success ( string input , string before , string group ) { return new simple result ( true , input , before , group , true ) ; }
public duration get wait time ( ) { return new duration ( wait nanos , time unit . nanosecond ) ; }
public boolean complete ( object result , throwable failure ) { return complete ( result , failure , true ) ; }
public synchronize boolean cancel ( boolean may interrupt if run ) { if ( do ) return false ; boolean cancel result = delegate . cancel ( may interrupt if run ) ; failure = new cancellation exception ( ) ; cancel = true ; config . handle complete ( null , failure , execution , false ) ; complete ( null , failure , config . fallback , false ) ; return cancel result ; }
public double negative ratio ( ) { return ( double ) negative / ( double ) occupy bit ; }
public double get delay factor ( ) { return delay factor ; }
public long to second ( ) { return time unit . to second ( length ) ; }
public int get character offset ( ) { return _char offset ; }
public string get document type declaration ( ) { return _dtd ; }
public q name get name ( ) { return _qname ; }
public string get public id ( ) { return _public id ; }
public string get notation name ( ) { return _notation name ; }
public final qualify name [ ] get array ( ) { if ( _array == null ) return null ; final qualify name [ ] clone array = new qualify name [ _array . length ] ; system . arraycopy ( _array , 0 , clone array , 0 , _array . length ) ; return clone array ; }
public final void clear ( ) { for ( int i = 0 ; i < _length ; i++ ) { _data [ i * size + value_offset ] = null ; _algorithm data [ i ] = null ; } _length = 0 ; }
protect static void swap ( final swapper swapper , int a , int b , final int n ) { for ( int i = 0 ; i < n ; i++ , a++ , b++ ) swapper . swap ( a , b ) ; }
public static void ensure offset length ( final long big array length , final long offset , final long length ) { if ( offset < 0 ) throw new array index out of bound exception ( `` offset ( `` + offset + `` ) be negative `` ) ; if ( length < 0 ) throw new illegal argument exception ( `` length ( `` + length + `` ) be negative `` ) ; if ( offset + length > big array length ) throw new array index out of bound exception ( `` last index ( `` + ( offset + length ) + `` ) be great than big-array length ( `` + big array length + `` ) `` ) ; }
public void add element ( long index , final boolean a [ ] [ ] , long offset , long length ) { ensure index ( index ) ; boolean big array . ensure offset length ( a , offset , length ) ; while ( length -- ! = 0 ) add ( index++ , boolean big array . get ( a , offset++ ) ) ; }
public int compare to ( final big list < ? extend boolean > l ) { if ( l == this ) return 0 ; if ( l instanceof boolean big list ) { final boolean big list iterator i1 = list iterator ( ) , i2 = ( ( boolean big list ) l ) . list iterator ( ) ; int r ; boolean e1 , e2 ; while ( i1 . have next ( ) & & i2 . have next ( ) ) { e1 = i1 . next boolean ( ) ; e2 = i2 . next boolean ( ) ; if ( ( r = ( boolean . compare ( ( e1 ) , ( e2 ) ) ) ) ! = 0 ) return r ; } return i2 . have next ( ) ? -1 : ( i1 . have next ( ) ? 1 : 0 ) ; } big list iterator < ? extend boolean > i1 = list iterator ( ) , i2 = l . list iterator ( ) ; int r ; while ( i1 . have next ( ) & & i2 . have next ( ) ) { if ( ( r = ( ( comparable < ? super boolean > ) i1 . next ( ) ) . compare to ( i2 . next ( ) ) ) ! = 0 ) return r ; } return i2 . have next ( ) ? -1 : ( i1 . have next ( ) ? 1 : 0 ) ; }
public static boolean [ ] grow ( final boolean [ ] array , final int length ) { if ( length > array . length ) { final int new length = ( int ) math . max ( math . min ( 2l * array . length , array . max_array_size ) , length ) ; final boolean t [ ] = new boolean [ new length ] ; system . arraycopy ( array , 0 , t , 0 , array . length ) ; return t ; } return array ; }
public static void ensure from to ( final boolean [ ] a , final int from , final int to ) { array . ensure from to ( a . length , from , to ) ; }
public static void quick sort ( final boolean [ ] x , final boolean comparator comp ) { quick sort ( x , 0 , x . length , comp ) ; }
public static void quick sort ( final boolean [ ] x ) { quick sort ( x , 0 , x . length ) ; }
public static boolean [ ] [ ] wrap ( final boolean [ ] array ) { if ( array . length == 0 ) return empty_big_array ; if ( array . length < = segment_size ) return new boolean [ ] [ ] { array } ; final boolean [ ] [ ] big array = new big array ( array . length ) ; for ( int i = 0 ; i < big array . length ; i++ ) system . arraycopy ( array , ( int ) start ( i ) , big array [ i ] , 0 , big array [ i ] . length ) ; return big array ; }
public static void ensure from to ( final boolean [ ] [ ] a , final long from , final long to ) { big array . ensure from to ( length ( a ) , from , to ) ; }
public static boolean big list iterator unmodifiable ( final boolean big list iterator i ) { return new unmodifiable big list iterator ( i ) ; }
public static boolean big list singleton ( final boolean element ) { return new singleton ( element ) ; }
public void default return value ( final boolean rv ) { def ret value = rv ; }
public it . unimi . dsi . fastutil . byte . byte hash . strategy strategy ( ) { return strategy ; }
public byte add to ( final byte k , final byte incr ) { entry e = add ( k ) ; final byte old value = e . value ; e . value += incr ; return old value ; }
public int array length ( final int index ) { ensure restrict index ( index ) ; return length ( index ) ; }
protect void ensure element ( final int index ) { if ( index < 0 ) throw new index out of bound exception ( `` index ( `` + index + `` ) be negative `` ) ; if ( index > = ref array . length ) throw new index out of bound exception ( `` index ( `` + index + `` ) be large than or equal to reference array size ( `` + ref array . length + `` ) `` ) ; }
public static int binary search ( final byte [ ] a , final byte key , final byte comparator c ) { return binary search ( a , 0 , a . length , key , c ) ; }
public static void radix sort indirect ( final int [ ] perm , final byte [ ] a , final boolean stable ) { radix sort indirect ( perm , a , 0 , perm . length , stable ) ; }
public static void radix sort ( final byte [ ] [ ] a ) { radix sort ( a , 0 , a [ 0 ] . length ) ; }
public static void radix sort ( final byte [ ] [ ] a ) { radix sort ( a , 0 , byte big array . length ( a ) ) ; }
public static byte list iterator from to ( final byte from , final byte to ) { return new interval iterator ( from , to ) ; }
public static byte priority queue synchronize ( final byte priority queue q , final object sync ) { return new synchronize priority queue ( q , sync ) ; }
public final static int murmur hash3 ( int x ) { x ^= x > > > 16 ; x * = 0x85ebca6b ; x ^= x > > > 13 ; x * = 0xc2b2ae35 ; x ^= x > > > 16 ; return x ; }
public static < k > indirect priority queue < k > synchronize ( final indirect priority queue < k > q ) { return new synchronize indirect priority queue < k > ( q ) ; }
public static void store booleans ( final boolean array [ ] , final int offset , final int length , final data output data output ) throw i o exception { it . unimi . dsi . fastutil . booleans . boolean array . ensure offset length ( array , offset , length ) ; for ( int i = 0 ; i < length ; i++ ) data output . write boolean ( array [ offset + i ] ) ; }
public static boolean [ ] [ ] load booleans big ( final char sequence filename ) throw i o exception { return load booleans big ( new file ( filename . to string ( ) ) ) ; }
public static void store booleans ( final boolean array [ ] [ ] , final data output data output ) throw i o exception { for ( int i = 0 ; i < array . length ; i++ ) { final boolean [ ] t = array [ i ] ; final int l = t . length ; for ( int d = 0 ; d < l ; d++ ) data output . write boolean ( t [ d ] ) ; } }
public static int load byte ( final input stream input stream , final byte [ ] array , final int offset , final int length ) throw i o exception { return read ( input stream , array , offset , length ) ; }
public static < k > object big list < k > empty list ( ) { return empty_big_list ; }
public static < k > object set < k > empty set ( ) { return empty_set ; }
public byte [ ] get code from unicode ( string unicode ) { return unicode to byte code . get ( unicode ) ; }
public void start ( ) { scheduler . on start ( ) ; log . info ( `` set up `` + sampler . size ( ) + `` sampler `` ) ; for ( g sampler s : sampler ) { scheduler . schedule at fix rate ( s , s . get initial delay ( ) , s . get delay ( ) , time unit . second ) ; } }
public void add sampler ( g sampler s ) { sampler . add ( s ) ; s . set publisher ( new g metric publisher ( gmetric ) ) ; }
public collection < string > get variable name ( ) { immutable set . builder < string > builder = immutable set . builder ( ) ; for ( configuration key part p : part ) { if ( p . be variable ( ) ) { builder . add ( p . get value ( ) ) ; } } return builder . build ( ) ; }
public link bind builder < post injector action > bind post injector action ( ) { return multibinder . new set binder ( binder , post injector action . class ) . add bind ( ) ; }
public injector create child injector ( module . . . module ) { return create child injector ( arrays . a list ( module ) ) ; }
public injector create injector ( ) { return create injector ( list . < module > new array list ( ) ) ; }
public < s > service binder < s > bind service ( final class < s > type ) { service binder impl < s > binder = new service binder impl < s > ( type ) ; binder . add ( binder ) ; return binder ; }
public collection < lifecycle listener > get listener ( ) { return array . a list ( listener ) ; }
public injector builder filter ( element visitor < boolean > predicate ) { list < element > element = new array list < element > ( ) ; for ( element element : element . get element ( stage . tool , module ) ) { if ( element . accept visitor ( predicate ) ) { element . add ( element ) ; } } this . module = element . get module ( element ) ; return this ; }
public injector builder strip static injection ( ) { return filter ( new be not static injection visitor ( ) ) ; }
public < t > boolean register ( t destroyable instance , object context , iterable < lifecycle action > action ) { return scope clean . be run ( ) ? new manage instance scoping visitor ( destroyable instance , context , action ) . visit eager singleton ( ) : false ; }
public static grakn tx operation exception unsupported data type ( object value ) { string support = attribute type . data type . supported_types . key set ( ) . stream ( ) . collect ( collector . joining ( `` , `` ) ) ; return create ( error message . invalid_datatype . get message ( value . get class ( ) . get name ( ) , support ) ) ; }
public static grakn tx operation exception transaction invalid ( object tx ) { return create ( `` unknown type of transaction [ `` + tx + `` ] `` ) ; }
public static grakn tx operation exception transaction read only ( grakn tx tx ) { return create ( error message . transaction_read_only . get message ( tx . keyspace ( ) ) ) ; }
public static grakn tx operation exception schema mutation ( ) { return create ( error message . schema_locked . get message ( ) ) ; }
public static aggregate < value > median ( string var ) { return aggregate . median ( graql . var ( var ) ) ; }
public static aggregate < value > std ( string var ) { return aggregate . std ( graql . var ( var ) ) ; }
public boolean have fix fragment cost ( ) { return false ; }
public static reasoner query impl create ( conjunction < var pattern admin > pattern , embed grakn tx < ? > tx ) { reasoner query impl query = new reasoner query impl ( pattern , tx ) . infer type ( ) ; return query . be atomic ( ) ? new reasoner atomic query ( query . get atom ( ) , tx ) : query ; }
public static reasoner query impl create ( reasoner query impl q , concept map sub ) { return q . with substitution ( sub ) . infer type ( ) ; }
public boolean require reiteration ( ) { set < inference rule > dependent rule = rule utils . get dependent rule ( this ) ; return rule utils . sub graph be cyclical ( dependent rule ) || rule utils . sub graph have rule with head satisfy body ( dependent rule ) ; }
public map data ( ) { return this . value ; }
public void close tx ( ) { rule map . clear ( ) ; rule conversion map . clear ( ) ; }
public attribute type < d > sup ( attribute type < d > super type ) { ( ( attribute type impl < d > ) super type ) . sup ( ) . for each ( st - > check instance match regex ( st . regex ( ) ) ) ; return super . sup ( super type ) ; }
public static matcher < matchable concept > have type ( matcher < matchable concept > matcher ) { return new property matcher < matchable concept , iterable < ? super matchable concept > > ( have item ( matcher ) ) { @ override public string get name ( ) { return `` have type `` ; } @ override iterable < ? super matchable concept > transform ( matchable concept item ) { return get type ( item . get ( ) . a thing ( ) ) . stream ( ) . map ( matchable concept : : of ) . collect ( to set ( ) ) ; } } ; }
public static binding gremlin plugin . builder build ( ) { return new builder ( ) ; }
public void put ( final string key , final object value ) { if ( null == key ) throw new illegal argument exception ( `` key may not be null `` ) ; if ( key . be empty ( ) ) throw new illegal argument exception ( `` key may not be empty `` ) ; global scope . put ( key , value ) ; }
public default void worker iteration start ( final memory memory ) { }
public default graph traversal < s , e > limit ( final long limit ) { this . a admin ( ) . get bytecode ( ) . add step ( symbol . limit , limit ) ; return this . a admin ( ) . add step ( new range global step < > ( this . a admin ( ) , 0 , limit ) ) ; }
public static < v > p < v > lte ( final v value ) { return new p ( compare . lte , value ) ; }
public default < a > a head ( ) { return ( a ) this . object ( ) . get ( this . size ( ) - 1 ) ; }
public default < a > a get ( final pop pop , final string label ) throw illegal argument exception { if ( pop . mixed == pop ) { return this . get ( label ) ; } else if ( pop . all == pop ) { if ( this . have label ( label ) ) { final object object = this . get ( label ) ; if ( object instanceof list ) return ( a ) object ; else return ( a ) collection . singleton list ( object ) ; } else { return ( a ) collection . empty list ( ) ; } } else { final object object = this . get ( label ) ; if ( object instanceof list ) { return pop . last == pop ? ( ( list < a > ) object ) . get ( ( ( list ) object ) . size ( ) - 1 ) : ( ( list < a > ) object ) . get ( 0 ) ; } else return ( a ) object ; } }
public default boolean equal ( final step other , final boolean compare id ) { return ( ! compare id || ( other ! = null & & this . get id ( ) . equal ( other . get id ( ) ) ) ) & & this . equal ( other ) ; }
public default set < class < ? extend s > > apply prior ( ) { return collection . empty set ( ) ; }
public default set < class < ? extend s > > apply post ( ) { return collection . empty set ( ) ; }
public default < a > a path ( final string step label ) { return this . path ( ) . get ( step label ) ; }
public void set duration ( final long dur , final time unit unit ) { if ( finalize ) throw new illegal state exception ( `` metric have be finalize and can not be modify `` ) ; this . duration n = time unit . nanosecond . convert ( dur , unit ) ; }
public default vertex out vertex ( ) { return this . vertex ( direction . out ) . next ( ) ; }
public static io . builder < graph s o n io > build ( final graph s o n version version ) { return new builder ( version ) ; }
public void write vertex ( final output stream output stream , final iterator < vertex > vertex iterator ) throw i o exception { write vertex ( output stream , vertex iterator , null ) ; }
public void write object ( final output stream output stream , final object object ) throw i o exception { this . mapper . write value ( output stream , object ) ; }
public static object [ ] get property ( final element element , final boolean include id , final boolean include label , final set < string > property to copy ) { final list < object > key value = new array list < > ( ) ; if ( include id ) { key value . add ( t . id ) ; key value . add ( element . id ( ) ) ; } if ( include label ) { key value . add ( t . label ) ; key value . add ( element . label ( ) ) ; } element . key ( ) . for each ( key - > { if ( property to copy . be empty ( ) || property to copy . contains ( key ) ) { key value . add ( key ) ; key value . add ( element . value ( key ) ) ; } } ) ; return key value . to array ( new object [ key value . size ( ) ] ) ; }
public long get class cache estimate size ( ) { return class map . estimate size ( ) ; }
public double get class cache average load penalty ( ) { return class map . stats ( ) . average load penalty ( ) ; }
public string get event ( ) { return event ; }
public static void enable globally ( ) { default meta class info . set without custom metaclass creation handle ( false ) ; expando meta class creation handle . enable ( ) ; }
public object get value ( object row , int row index , int column index ) { if ( value model instanceof nest value model ) { nested value model nest model = ( nested value model ) value model ; nest model . get source model ( ) . set value ( row ) ; } return value model . get value ( ) ; }
protect template engine init template engine ( servlet config config ) { string name = config . get init parameter ( `` template . engine `` ) ; if ( name == null ) { return new simple template engine ( ) ; } try { return ( template engine ) class . for name ( name ) . new instance ( ) ; } catch ( instantiation exception e ) { log ( `` could not instantiate template engine : `` + name , e ) ; } catch ( illegal access exception e ) { log ( `` could not access template engine class : `` + name , e ) ; } catch ( class not find exception e ) { log ( `` could not find template engine class : `` + name , e ) ; } return null ; }
public void set property ( string column name , object new value ) { try { get result set ( ) . update object ( column name , new value ) ; update = true ; } catch ( s q l exception e ) { throw new miss property exception ( column name , groovy result set proxy . class , e ) ; } }
public object get at ( int index ) throw s q l exception { index = normalize index ( index ) ; return get result set ( ) . get object ( index ) ; }
public void put at ( int index , object new value ) throw s q l exception { index = normalize index ( index ) ; get result set ( ) . update object ( index , new value ) ; }
public void add ( map value ) throw s q l exception { get result set ( ) . move to insert row ( ) ; for ( iterator iter = value . entry set ( ) . iterator ( ) ; iter . have next ( ) ; ) { map . entry entry = ( map . entry ) iter . next ( ) ; get result set ( ) . update object ( entry . get key ( ) . to string ( ) , entry . get value ( ) ) ; } get result set ( ) . insert row ( ) ; }
public boolean previous ( ) throw s q l exception { if ( update ) { get result set ( ) . update row ( ) ; update = false ; } return get result set ( ) . previous ( ) ; }
public void set rowspan ( int rowspan ) { this . rowspan = rowspan ; }
public string get default family ( ) { return default family ; }
public lexer node create lexer node ( ) { return new lexer node ( false ) ; }
public static < t > t min ( collection < t > item ) { t answer = null ; for ( t value : item ) { if ( value ! = null ) { if ( answer == null || script bytecode adapter . compare less than ( value , answer ) ) { answer = value ; } } } return answer ; }
public list breadth first ( ) { list answer = new node list ( ) ; answer . add ( this ) ; answer . add all ( breadth first rest ( ) ) ; return answer ; }
public string get bean factory name ( ) { return bean factory name ; }
public void set src ( final file src file ) { this . src file = src file ; }
protect void print result ( print stream out ) { log . debug ( `` print result ( ) `` ) ; string buffer line = new string buffer ( ) ; out . println ( line ) ; out . println ( ) ; }
public void set target bytecode ( string version ) { if ( compiler configuration . pre_jdk5 . equal ( version ) || compiler configuration . post_jdk5 . equal ( version ) ) { this . target bytecode = version ; } }
public void set stubdir ( file stub dir ) { joint compilation = true ; this . stub dir = stub dir ; }
public file get stubdir ( ) { return stub dir ; }
public void set keep stub ( boolean keep stub ) { this . keep stub = keep stub ; }
public void set include main for script ( boolean include main for script ) { this . include main for script = include main for script ; }
protect string [ ] get package template ( ) { return groovy doc template info . default_package_templates ; }
protect string [ ] get doc template ( ) { return groovy doc template info . default_doc_templates ; }
public void copy node meta data ( a s t node other ) { meta data map . put all ( other . meta data map ) ; }
public void set redirect ( class node cn ) { if ( be primary node ) throw new groovy bug error ( `` try to set a redirect for a primary class node ( `` +get name ( ) + `` - > `` +cn . get name ( ) + `` ) . `` ) ; if ( cn ! =null ) cn = cn . redirect ( ) ; if ( cn==this ) return ; redirect = cn ; }
public void set super class ( class node super class ) { redirect ( ) . super class = super class ; }
public static boolean be double category ( class node type ) { return type==float_ t y p e || type== float_ t y p e || type==double_ t y p e || type== double_ t y p e || be big dec category ( type ) ; }
public void push loop ( variable scope el , string label name ) { push variable scope ( el ) ; init loop label ( label name ) ; }
public int get warn level ( ) { return this . warn level ; }
public void set target bytecode ( string version ) { if ( pre_jdk5 . equal ( version ) || post_jdk5 . equal ( version ) ) { this . target bytecode = version ; } }
public void add fatal error ( message message ) throw compilation fail exception { add error ( message ) ; fail if error ( ) ; }
public static date plus ( date self , int day ) { calendar calendar = ( calendar ) calendar . get instance ( ) . clone ( ) ; calendar . set time ( self ) ; calendar . add ( calendar . day_of_year , day ) ; return calendar . get time ( ) ; }
public static string get date string ( date self ) { return date format . get date instance ( date format . short ) . format ( self ) ; }
public static string get date time string ( date self ) { return date format . get date time instance ( date format . short , date format . medium ) . format ( self ) ; }
public static component get at ( container self , int index ) { return self . get component ( index ) ; }
public static int size ( j combo box self ) { return self . get item count ( ) ; }
public static void clear ( default combo box model self ) { self . remove all element ( ) ; }
public static component get at ( j menu self , int index ) { return self . get menu component ( index ) ; }
public string get package ( ) { return package ; }
public void set disabled global a s t transformation ( final set < string > disable global a s t transformation ) { this . disabled global a s t transformation = disabled global a s t transformation ; }
public static string format ( date self , string format , time zone tz ) { simple date format sdf = new simple date format ( format ) ; sdf . set time zone ( tz ) ; return sdf . format ( self ) ; }
public static boolean be ( object self , object other ) { return self == other ; }
public static void mixin ( meta class self , list < class > category class ) { mixin in meta class . mixin class to meta class ( self , category class ) ; }
public static < t > list < t > unique ( list < t > self , boolean mutate ) { return ( list < t > ) unique ( ( collection < t > ) self , mutate ) ; }
public static < t > iterable < t > each with index ( iterable < t > self , @ closure params ( value= from string . class , options= `` t , integer `` ) closure closure ) { each with index ( self . iterator ( ) , closure ) ; return self ; }
public static < t > collection < t > each with index ( collection < t > self , @ closure params ( value= from string . class , options= `` t , integer `` ) closure closure ) { return ( collection < t > ) each with index ( ( iterable < t > ) self , closure ) ; }
public static < t > set < t > each with index ( set < t > self , @ closure params ( value= from string . class , options= `` t , integer `` ) closure closure ) { return ( set < t > ) each with index ( ( iterable < t > ) self , closure ) ; }
public static < t > iterable < t > each ( iterable < t > self , @ closure params ( first param . first generic type . class ) closure closure ) { each ( self . iterator ( ) , closure ) ; return self ; }
public static < t > sort set < t > each ( sort set < t > self , @ closure params ( first param . first generic type . class ) closure closure ) { return ( sort set < t > ) each ( ( iterable < t > ) self , closure ) ; }
public static < t > list < t > reverse each ( list < t > self , @ closure params ( first param . first generic type . class ) closure closure ) { each ( new reverse list iterator < t > ( self ) , closure ) ; return self ; }
public static boolean every ( object self ) { boolean return method invoker bmi = new boolean return method invoker ( ) ; for ( iterator iter = invoker helper . a iterator ( self ) ; iter . have next ( ) ; ) { if ( ! bmi . convert to boolean ( iter . next ( ) ) ) { return false ; } } return true ; }
public static boolean any ( object self , closure closure ) { boolean closure wrapper bcw = new boolean closure wrapper ( closure ) ; for ( iterator iter = invoker helper . a iterator ( self ) ; iter . have next ( ) ; ) { if ( bcw . call ( iter . next ( ) ) ) return true ; } return false ; }
public static collection grep ( object self ) { return grep ( self , closure . identity ) ; }
public static object find result ( object self , object default result , closure closure ) { object result = find result ( self , closure ) ; if ( result == null ) return default result ; return result ; }
public static < t > collection < t > find all ( t [ ] self ) { return find all ( self , closure . identity ) ; }
public static map group by ( object [ ] self , list < closure > closure ) { return group by ( ( iterable ) array . a list ( self ) , closure ) ; }
public static object sum ( iterable self , object initial value , closure closure ) { return sum ( self , initial value , closure , false ) ; }
public static < t > t max ( iterable < t > self ) { return groovy collection . max ( self ) ; }
public static < t > t max ( iterable < t > self , @ closure params ( first param . first generic type . class ) closure closure ) { int params = closure . get maximum number of parameter ( ) ; if ( params ! = 1 ) { return max ( self , new closure comparator < t > ( closure ) ) ; } boolean first = true ; t answer = null ; object answer value = null ; for ( t item : self ) { object value = closure . call ( item ) ; if ( first ) { first = false ; answer = item ; answer value = value ; } else if ( script bytecode adapter . compare less than ( answer value , value ) ) { answer = item ; answer value = value ; } } return answer ; }
public static < t > collection < t > a immutable ( collection < ? extend t > self ) { return collection . unmodifiable collection ( self ) ; }
public static < t > t [ ] drop right ( t [ ] self , int num ) { if ( self . length < = num ) { return create similar array ( self , 0 ) ; } if ( num < = 0 ) { t [ ] ret = create similar array ( self , self . length ) ; system . arraycopy ( self , 0 , ret , 0 , self . length ) ; return ret ; } t [ ] ret = create similar array ( self , self . length - num ) ; system . arraycopy ( self , 0 , ret , 0 , self . length - num ) ; return ret ; }
public static boolean a boolean ( boolean bool ) { if ( null == bool ) { return false ; } return bool ; }
public static boolean a boolean ( enumeration enumeration ) { if ( null == enumeration ) { return false ; } return enumeration . have more element ( ) ; }
public static boolean a boolean ( byte [ ] array ) { if ( null == array ) { return false ; } return array . length > 0 ; }
public static boolean a boolean ( short [ ] array ) { if ( null == array ) { return false ; } return array . length > 0 ; }
public static boolean a boolean ( char [ ] array ) { if ( null == array ) { return false ; } return array . length > 0 ; }
public static < t > t a type ( closure cl , class < t > clazz ) { if ( clazz . be interface ( ) & & ! ( clazz . be instance ( cl ) ) ) { if ( trait . be trait ( clazz ) ) { method sam method = cache s a m class . get s a m method ( clazz ) ; if ( sam method ! =null ) { map impl = collection . singleton map ( sam method . get name ( ) , cl ) ; return ( t ) proxy generator . instance . instantiate aggregate ( impl , collection . < class > singleton list ( clazz ) ) ; } } return ( t ) proxy . new proxy instance ( clazz . get class loader ( ) , new class [ ] { clazz } , new convert closure ( cl ) ) ; } try { return a type ( ( object ) cl , clazz ) ; } catch ( groovy cast exception ce ) { try { return ( t ) proxy generator . instance . instantiate aggregate from base class ( cl , clazz ) ; } catch ( groovy runtime exception cause ) { throw new groovy cast exception ( `` error casting closure to `` + clazz . get name ( ) + `` , reason : `` + cause . get message ( ) ) ; } } }
public static < t > t [ ] reverse ( t [ ] self , boolean mutate ) { if ( ! mutate ) { return ( t [ ] ) to list ( new reverse list iterator < t > ( arrays . a list ( self ) ) ) . to array ( ) ; } list < t > item = array . a list ( self ) ; collection . reverse ( item ) ; system . arraycopy ( item . to array ( ) , 0 , self , 0 , item . size ( ) ) ; return self ; }
public static < t > collection < t > plus ( collection < t > leave , iterable < t > right ) { return plus ( left , a collection ( right ) ) ; }
public static < t > set < t > plus ( set < t > leave , t right ) { return ( set < t > ) plus ( ( collection < t > ) leave , right ) ; }
public static < t > list < t > intersect ( list < t > leave , iterable < t > right ) { return ( list < t > ) intersect ( ( collection < t > ) leave , a collection ( right ) ) ; }
public static boolean equal ( list leave , list right ) { if ( left == null ) { return right == null ; } if ( right == null ) { return false ; } if ( leave == right ) { return true ; } if ( left . size ( ) ! = right . size ( ) ) { return false ; } final iterator it1 = leave . iterator ( ) , it2 = right . iterator ( ) ; while ( it1 . have next ( ) ) { final object o1 = it1 . next ( ) ; final object o2 = it2 . next ( ) ; if ( o1 == null ) { if ( o2 ! = null ) return false ; } else if ( ! coerce equal ( o1 , o2 ) ) { return false ; } } return true ; }
public static < t > collection < t > minus ( iterable < t > self , iterable < ? > remove me ) { return minus ( a collection ( self ) , a collection ( remove me ) ) ; }
public static collection flatten ( object [ ] self ) { return flatten ( to list ( self ) , new array list ( ) ) ; }
public static list < long > get at ( long [ ] array , range range ) { return primitive array get ( array , range ) ; }
public static list < double > get at ( double [ ] array , range range ) { return primitive array get ( array , range ) ; }
public static list < byte > get at ( byte [ ] array , int range range ) { range info info = sub list border ( array . length , range ) ; list < byte > answer = primitive array get ( array , new int range ( true , info . from , info . to - 1 ) ) ; return info . reverse ? reverse ( answer ) : answer ; }
public static list < long > get at ( long [ ] array , collection index ) { return primitive array get ( array , index ) ; }
protect static list primitive array get ( object self , collection index ) { list answer = new array list ( ) ; for ( object value : index ) { if ( value instanceof range ) { answer . add all ( primitive array get ( self , ( range ) value ) ) ; } else if ( value instanceof list ) { answer . add all ( primitive array get ( self , ( list ) value ) ) ; } else { int idx = default type transformation . int unbox ( value ) ; answer . add ( primitive array get ( self , idx ) ) ; } } return answer ; }
public static string to string ( object value ) { return invoker helper . to string ( value ) ; }
public static number plus ( character leave , character right ) { return plus ( integer . value of ( leave ) , right ) ; }
public static number minus ( number leave , character right ) { return number number minus . minus ( leave , integer . value of ( right ) ) ; }
public static number multiply ( number leave , character right ) { return number number multiply . multiply ( integer . value of ( right ) , leave ) ; }
public static number power ( integer self , integer exponent ) { if ( exponent > = 0 ) { big integer answer = big integer . value of ( self ) . pow ( exponent ) ; if ( answer . compare to ( bi_int_min ) > = 0 & & answer . compare to ( bi_int_max ) < = 0 ) { return answer . int value ( ) ; } else { return answer ; } } else { return power ( self , ( double ) exponent ) ; } }
public static number div ( character leave , number right ) { return number number div . div ( integer . value of ( leave ) , right ) ; }
public static bit set and ( bit set left , bit set right ) { bit set result = ( bit set ) leave . clone ( ) ; result . and ( right ) ; return result ; }
public static void upto ( big integer self , number to , @ closure params ( first param . class ) closure closure ) { if ( to instanceof big decimal ) { final big decimal one = big decimal . value of ( 10 , 1 ) ; big decimal self1 = new big decimal ( self ) ; big decimal to1 = ( big decimal ) to ; if ( self1 . compare to ( to1 ) < = 0 ) { for ( big decimal i = self1 ; i . compare to ( to1 ) < = 0 ; i = i . add ( one ) ) { closure . call ( i ) ; } } else throw new groovy runtime exception ( message format . format ( `` the argument ( { 0 } ) to upto ( ) can not be less than the value ( { 1 } ) it `` s call on . `` , to , self ) ) ; } else if ( to instanceof big integer ) { final big integer one = big integer . value of ( 1 ) ; big integer to1 = ( big integer ) to ; if ( self . compare to ( to1 ) < = 0 ) { for ( big integer i = self ; i . compare to ( to1 ) < = 0 ; i = i . add ( one ) ) { closure . call ( i ) ; } } else throw new groovy runtime exception ( message format . format ( `` the argument ( { 0 } ) to upto ( ) can not be less than the value ( { 1 } ) it `` s call on . `` , to , self ) ) ; } else { final big integer one = big integer . value of ( 1 ) ; big integer to1 = new big integer ( to . to string ( ) ) ; if ( self . compare to ( to1 ) < = 0 ) { for ( big integer i = self ; i . compare to ( to1 ) < = 0 ; i = i . add ( one ) ) { closure . call ( i ) ; } } else throw new groovy runtime exception ( message format . format ( `` the argument ( { 0 } ) to upto ( ) can not be less than the value ( { 1 } ) it `` s call on . `` , to , self ) ) ; } }
public static integer to integer ( number self ) { return self . int value ( ) ; }
public static boolean implies ( boolean left , boolean right ) { return ! leave || right ; }
public static void set meta class ( object self , meta class meta class ) { if ( meta class instanceof handle meta class ) meta class = ( ( handle meta class ) meta class ) . get adaptee ( ) ; if ( self instanceof class ) { groovy system . get meta class registry ( ) . set meta class ( ( class ) self , meta class ) ; } else { ( ( meta class registry impl ) groovy system . get meta class registry ( ) ) . set meta class ( self , meta class ) ; } }
public static object with trait ( object self , class < ? > . . . trait ) { list < class > interface = new array list < class > ( ) ; collection . add all ( interface , trait ) ; return proxy generator . instance . instantiate delegate ( interface , self ) ; }
public static < e > boolean remove element ( collection < e > self , object o ) { return self . remove ( o ) ; }
public static date parse to string date ( date self , string date to string ) throw parse exception { return new simple date format ( `` eee mmm dd hh : mm : s zzz yyyy `` , locale . u ) . parse ( date to string ) ; }
public int get line number ( ) { return line number ; }
public boolean be cancel ( ) { if ( cancellable ancestor == null ) { return false ; } else { return cancellable ancestor . be cancel ( ) ; } }
public long time remain ( time unit unit ) { final long now nanos = ticker . read ( ) ; if ( ! expire & & deadline nanos - now nanos < = 0 ) { expired = true ; } return unit . convert ( deadline nanos - now nanos , time unit . nanosecond ) ; }
public call option with authority ( @ nullable string authority ) { call option new option = new call option ( this ) ; new option . authority = authority ; return new option ; }
public static compressor registry get default instance ( ) { return default_instance ; }
protect final void on send byte ( int num bytes ) { transport state ( ) . on send byte ( num byte ) ; }
public void add server ( instrumented < server stats > server ) { server socket map prev = per server socket . put ( id ( server ) , new server socket map ( ) ) ; assert prev == null ; add ( server , server ) ; }
public instrument < channel stats > get subchannel ( long id ) { return subchannels . get ( id ) ; }
public void fail ( throwable failure cause ) { map < client transport . ping callback , executor > callback ; synchronize ( this ) { if ( complete ) { return ; } complete = true ; this . failure cause = failure cause ; callback = this . callback ; this . callback = null ; } for ( map . entry < client transport . ping callback , executor > entry : callback . entry set ( ) ) { notify fail ( entry . get key ( ) , entry . get value ( ) , failure cause ) ; } }
public list < stream tracer > get tracer for test ( ) { return new array list < stream tracer > ( arrays . a list ( tracer ) ) ; }
public void report keep alive sent ( ) { keep alives sent++ ; }
public static manage channel builder < ? > for address ( string name , int port ) { return manage channel provider . provider ( ) . builder for address ( name , port ) ; }
public t max retry attempt ( int max retry attempt ) { throw new unsupported operation exception ( ) ; }
public static manage channel provider provider ( ) { if ( provider == null ) { throw new provider not find exception ( `` no functional channel service provider find . `` + `` try add a dependency on the grpc-okhttp , grpc-netty , or grpc-netty-shaded `` + `` artifact `` ) ; } return provider ; }
public void refresh ( ) { }
public list < server service definition > get service ( ) { return collection . empty list ( ) ; }
public static server builder < ? > for port ( int port ) { return server provider . provider ( ) . builder for port ( port ) ; }
public boolean be ok ( ) { return code . ok == code ; }
public final metadata get trailer ( ) { return trailer ; }
public void stream close ( status status ) { }
public void notify unused ( ) { channel unused . set success ( null ) ; }
public static netty server builder for port ( int port ) { return new netty server builder ( port ) ; }
public static protocol negotiator server tl ( final ssl context ssl context ) { precondition . check not null ( ssl context , `` ssl context `` ) ; return new protocol negotiator ( ) { @ override public handler new handler ( grpc http2 connection handler handler ) { return new server tl handler ( ssl context , handler ) ; } } ; }
public static < w extend appendable & closeable > void write ( char sequence from , output supplier < w > to ) throw i o exception { a char sink ( to ) . write ( from ) ; }
public input supplier < input stream > get supplier ( ) { return supplier ; }
public static void move ( file from , file to ) throw i o exception { check not null ( from ) ; check not null ( to ) ; check argument ( ! from . equal ( to ) , `` source % s and destination % s must be different `` , from , to ) ; if ( ! from . rename to ( to ) ) { copy ( from , to ) ; if ( ! from . delete ( ) ) { if ( ! to . delete ( ) ) { throw new i o exception ( `` unable to delete `` + to ) ; } throw new i o exception ( `` unable to delete `` + from ) ; } } }
public input supplier < input stream > get supplier ( ) { return a byte source ( ) ; }
public static < v > async settable future < v > create ( ) { return new async settable future < v > ( ) ; }
public retryer builder < v > retry if exception ( ) { rejection predicate = predicate . or ( rejection predicate , new exception class predicate < v > ( exception . class ) ) ; return this ; }
public static stop strategy never stop ( ) { return never_stop ; }
protect void expect content ( collection < e > expect ) { helper . assert equal ignoring order ( expect , actual content ( ) ) ; }
protect final void expect add ( e . . . element ) { list < e > expect = helper . copy to list ( get sample element ( ) ) ; expect . add all ( array . a list ( element ) ) ; expect content ( expect ) ; }
public final void test ( ) { try { recurse ( 0 ) ; } catch ( runtime exception e ) { throw new runtime exception ( array . to string ( stimulus ) , e ) ; } }
public static iterable < annotation > get tester annotation ( annotate element class or method ) { synchronize ( annotation cache ) { list < annotation > annotation = annotation cache . get ( class or method ) ; if ( annotation == null ) { annotation = new array list < > ( ) ; for ( annotation a : class or method . get declared annotation ( ) ) { if ( a . annotation type ( ) . be annotation present ( tester annotation . class ) ) { annotation . add ( a ) ; } } annotation = collection . unmodifiable list ( annotation ) ; annotation cache . put ( class or method , annotation ) ; } return annotation ; } }
public b name ( string name ) { if ( name . contains ( `` ( `` ) ) { throw new illegal argument exception ( `` eclipse hide all character after `` + `` ' ( ' ; please use ' [ ] ' or other character instead of parenthesis `` ) ; } this . name = name ; return self ( ) ; }
public list < an enum > order ( list < an enum > insertion order ) { collection . sort ( insertion order ) ; return insertion order ; }
protect void reset with hole ( ) { super . reset container ( get subject generator ( ) . create ( a , c ) ) ; navigable set = ( navigable set < e > ) get set ( ) ; }
public static void assert escape ( char escaper escaper , string expect , char c ) { string escape = compute replacement ( escaper , c ) ; assert . assert not null ( escape ) ; assert . assert equal ( expect , escape ) ; }
public equivalence tester < t > add equivalence group ( t first , t . . . rest ) { add equivalence group ( list . a list ( first , rest ) ) ; return this ; }
public static void await clear ( final weak reference < ? > ref ) { await do ( new finalization predicate ( ) { public boolean be do ( ) { return ref . get ( ) == null ; } } ) ; }
public static < t > t reserialize ( t object ) { return platform . reserialize ( object ) ; }
public void pop state and set dependency ( dependency < ? > new dependency ) { state . pop ( ) ; this . dependency = new dependency ; }
protect array list < sequence > generate sequence ( array list < column > column , boolean temporary ) { array list < sequence > sequence = new . array list ( ) ; if ( column ! = null ) { for ( column c : column ) { if ( c . be auto increment ( ) ) { int obj id = get object id ( ) ; c . convert auto increment to sequence ( session , get schema ( ) , obj id , temporary ) ; if ( ! constant . clustering_disabled . equal ( session . get database ( ) . get cluster ( ) ) ) { throw db exception . get unsupported exception ( `` cluster & & auto-increment column `` ) ; } } sequence seq = c . get sequence ( ) ; if ( seq ! = null ) { sequence . add ( seq ) ; } } } return sequence ; }
public static void set default connection ( connection c ) { if ( c == null ) { default_connection . remove ( ) ; } else { default_connection . set ( c ) ; } }
public void clear ignore ( ) { synchronize ( ignore list ) { ignore list . clear ( ) ; } }
protect s q l exception unsupported ( string message ) { try { throw db exception . get unsupported exception ( message ) ; } catch ( exception e ) { return log and convert ( e ) ; } }
public long get row count max ( ) { try { return data map . size a long max ( ) ; } catch ( illegal state exception e ) { throw db exception . get ( error code . object_closed , e ) ; } }
public void set max transaction id ( int max ) { this . max transaction id = max ; }
public void sync ( ) { try { file . force ( true ) ; } catch ( i o exception e ) { throw data utils . new illegal state exception ( data utils . error_writing_failed , `` could not sync file { 0 } `` , file name , e ) ; } }
public void free ( long po , int length ) { free space . free ( po , length ) ; }
public void sync ( ) { check open ( ) ; file store f = file store ; if ( f ! = null ) { f . sync ( ) ; } }
public void set version to keep ( int count ) { this . version to keep = count ; }
public int get auto commit delay ( ) { return auto commit delay ; }
public cache long key l i r s < page > get cache ( ) { return cache ; }
public boolean be read only ( ) { return file store == null ? false : file store . be read only ( ) ; }
public write buffer put short ( short x ) { ensure capacity ( 2 ) . put short ( x ) ; return this ; }
public write buffer put long ( long x ) { ensure capacity ( 8 ) . put long ( x ) ; return this ; }
public write buffer put ( byte buffer src ) { ensure capacity ( src . remain ( ) ) . put ( src ) ; return this ; }
public write buffer position ( int new position ) { buff . position ( new position ) ; return this ; }
public write buffer put int ( int index , int value ) { buff . put int ( index , value ) ; return this ; }
public write buffer clear ( ) { if ( buff . limit ( ) > max_reuse_capacity ) { buff = reuse ; } else if ( buff ! = reuse ) { reuse = buff ; } buff . clear ( ) ; return this ; }
public table get table or view by name ( string name ) { synchronize ( database ) { return table and view . get ( name ) ; } }
public static void move ( string source , string target ) { file path . get ( source ) . move to ( file path . get ( target ) , false ) ; }
public static void move atomic replace ( string source , string target ) { file path . get ( source ) . move to ( file path . get ( target ) , true ) ; }
public value convert ( value v ) { return convert ( v , null ) ; }
public void set table ( table table , int column id ) { this . table = table ; this . column id = column id ; }
public void prepare expression ( session session ) { if ( default expression ! = null || on update expression ! = null ) { compute table filter = new table filter ( session , table , null , false , null , 0 , null ) ; if ( default expression ! = null ) { default expression . map column ( compute table filter , 0 ) ; default expression = default expression . optimize ( session ) ; } if ( on update expression ! = null ) { on update expression . map column ( compute table filter , 0 ) ; on update expression = on update expression . optimize ( session ) ; } } }
public void remove check constraint ( ) { check constraint = null ; check constraint s q l = null ; }
public index lookup batch get lookup batch ( int join filter id ) { return filter [ join filter id ] . lookup batch ; }
public void reset ( boolean before query ) { current = null ; start = false ; find = false ; for ( join filter jf : filter ) { jf . reset ( before query ) ; } if ( before query & & additional filter ! = null ) { additional filter . reset ( ) ; } }
public boolean be recursive query detect ( ) { return be recursive query detect ; }
public long interleave ( int . . . value ) { int dimension = value . length ; long max = get max value ( dimension ) ; int bit per value = get bit per value ( dimension ) ; long x = 0 ; for ( int i = 0 ; i < dimension ; i++ ) { long k = value [ i ] ; if ( k < 0 || k > max ) { throw new illegal argument exception ( 0 + `` < `` + k + `` < `` + max ) ; } for ( int b = 0 ; b < bit per value ; b++ ) { x |= ( k & ( 1l < < b ) ) < < ( i + ( dimension - 1 ) * b ) ; } } return x ; }
public static object parse local date ( char sequence text ) { try { return local_date_parse . invoke ( null , text ) ; } catch ( illegal access exception | invocation target exception e ) { throw new illegal argument exception ( `` error when parse text ' `` + text + `` ' `` , e ) ; } }
public static object parse offset date time ( char sequence text ) { try { return offset_date_time_parse . invoke ( null , text ) ; } catch ( illegal access exception | invocation target exception e ) { throw new illegal argument exception ( `` error when parse text ' `` + text + `` ' `` , e ) ; } }
public static object value to offset date time ( value value ) { value timestamp time zone value timestamp time zone = ( value timestamp time zone ) value . convert to ( value . timestamp_tz ) ; long date value = value timestamp time zone . get date value ( ) ; long time nanos = value timestamp time zone . get time nanos ( ) ; try { object local date time = local date time from date nanos ( date value , time nanos ) ; short time zone offset min = value timestamp time zone . get time zone offset min ( ) ; int offset second = ( int ) time unit . minute . to second ( time zone offset min ) ; object offset = zone_offset_of_total_seconds . invoke ( null , offset second ) ; return offset_date_time_of_local_date_time_zone_offset . invoke ( null , local date time , offset ) ; } catch ( illegal access exception e ) { throw db exception . convert ( e ) ; } catch ( invocation target exception e ) { throw db exception . convert invocation ( e , `` timestamp with time zone conversion fail `` ) ; } }
public static string get host name ( string local address ) { try { inet address addr = inet address . get by name ( local address ) ; return addr . get host name ( ) ; } catch ( exception e ) { return `` unknown `` ; } }
public value get envelope union ( value geometry r ) { geometry factory gf = new geometry factory ( ) ; envelope merge envelope = new envelope ( get geometry no copy ( ) . get envelope internal ( ) ) ; merge envelope . expand to include ( r . get geometry no copy ( ) . get envelope internal ( ) ) ; return get ( gf . to geometry ( merge envelope ) ) ; }
public long get remain ( ) { return remain ; }
public long get month ( ) { return interval utils . month from interval ( qualifier , negative , leading , remain ) ; }
public long get hour ( ) { return interval utils . hour from interval ( qualifier , negative , leading , remain ) ; }
public long get second and nanos ( ) { return interval utils . nanos from interval ( qualifier , negative , leading , remain ) ; }
public array list < expression > get expression ( ) { return expression ; }
public void set order ( array list < select order by > order ) { order list = order ; }
public boolean be current group ( ) { return current group by expr data ! = null ; }
public void set updated key collector ( hash set < long > update key collector ) { this . updated key collector = update key collector ; }
public static string builder quote identifier ( string builder builder , string s , boolean always quote ) { if ( s == null ) { return builder . append ( `` \ `` \ `` `` ) ; } if ( ! always quote & & parser util . be simple identifier ( s , false , false ) ) { return builder . append ( s ) ; } return string utils . quote identifier ( builder , s ) ; }
public object parse column list ( string sql , int offset ) { initialize ( sql ) ; parse index = offset ; read ( ) ; read ( open_paren ) ; if ( read if ( close_paren ) ) { return utils . empty_int_array ; } if ( current token type == identifier ) { array list < string > list = utils . new small array list ( ) ; do { if ( current token type ! = identifier ) { throw get syntax error ( ) ; } list . add ( current token ) ; read ( ) ; } while ( read if more ( ) ) ; return list . to array ( new string [ 0 ] ) ; } else if ( current token type == value ) { array list < integer > list = utils . new small array list ( ) ; do { list . add ( read int ( ) ) ; } while ( read if more ( ) ) ; int count = list . size ( ) ; int [ ] array = new int [ count ] ; for ( int i = 0 ; i < count ; i++ ) { array [ i ] = list . get ( i ) ; } return array ; } else { throw get syntax error ( ) ; } }
public void set network connection info ( network connection info network connection info ) { this . network connection info = network connection info ; }
public void update aggregate ( session session , int stage ) { if ( partition by ! = null ) { for ( expression expr : partition by ) { expr . update aggregate ( session , stage ) ; } } if ( order by ! = null ) { for ( select order by o : order by ) { o . expression . update aggregate ( session , stage ) ; } } if ( frame ! = null ) { frame . update aggregate ( session , stage ) ; } }
public array list < value > get all row ( session session ) { array list < value > list = new array list < > ( ) ; query . set session ( session ) ; try ( result interface result = query . query ( integer . max_value ) ) { while ( result . next ( ) ) { list . add ( read row ( result ) ) ; } } return list ; }
public static long get default min value ( long start value , long increment ) { long v = increment > = 0 ? 1 : long . min_value ; if ( start value ! = null & & increment > = 0 & & start value < v ) { v = start value ; } return v ; }
public object get nest identity ( ) { return nest identity ; }
public string get name ( ) { return name ; }
public string get validator class ( ) { return validator class ; }
public void remove column expression dependency ( session session ) { for ( column column : column ) { column . set default expression ( session , null ) ; column . set on update expression ( session , null ) ; column . remove check constraint ( ) ; } }
public table filter get common join column filter ( ) { return common join columns filter ; }
public static int parse dimension system ( string s ) { e w k t source source = new e w k t source ( s ) ; int dimension system = source . read dimension system ( ) ; if ( source . have data ( ) || dimension system == dimension_system_xy ) { throw new illegal argument exception ( ) ; } return dimension system ; }
public static time zone provider of offset ( int offset ) { if ( offset == 0 ) { return utc ; } return new simple ( offset ) ; }
public int get type ( ) { return type ; }
public static value decimal get ( big integer big integer ) { if ( big integer . signum ( ) == 0 ) { return ( value decimal ) zero ; } else if ( big integer . one . equal ( big integer ) ) { return ( value decimal ) one ; } return ( value decimal ) value . cache ( new value decimal ( new big decimal ( big integer ) ) ) ; }
public int hash code ( ) { / * * na n be normalize in get ( ) method , so it 's safe to use * double to raw long bit ( ) instead of double to long bit ( ) here . * / long hash = double . double to raw long bit ( value ) ; return ( int ) ( hash ^ ( hash > > > 32 ) ) ; }
public static value result set get ( simple result result ) { return new value result set ( result ) ; }
public static void inject token ( http u r l connection conn , token token ) { string t = token . token ; if ( t ! = null ) { if ( ! t . start with ( `` \ `` `` ) ) { t = `` \ `` `` + t + `` \ `` `` ; } conn . add request property ( `` cookie `` , auth_cookie_eq + t ) ; } }
protect boolean be browser ( string user agent ) { if ( user agent == null ) { return false ; } user agent = user agent . to lower case ( locale . english ) ; boolean be browser = true ; for ( string non browser user agent : non browser user agent ) { if ( user agent . contains ( non browser user agent ) ) { be browser = false ; break ; } } return be browser ; }
public static string get rule ( ) { string rule string = null ; if ( rule ! = null ) { string builder sb = new string builder ( ) ; for ( rule rule : rule ) { sb . append ( rule . to string ( ) ) . append ( `` \n `` ) ; } rule string = sb . to string ( ) . trim ( ) ; } return rule string ; }
public void set deprecate property ( ) { deprecation context deprecation = deprecation context . get ( ) ; property prop = get prop ( ) ; property overlay = get overlay ( ) ; for ( map . entry < string , deprecate key info > entry : deprecation . get deprecated key map ( ) . entry set ( ) ) { string dep key = entry . get key ( ) ; if ( ! overlay . contains ( dep key ) ) { for ( string new key : entry . get value ( ) . new key ) { string val = overlay . get property ( new key ) ; if ( val ! = null ) { prop . set property ( dep key , val ) ; overlay . set property ( dep key , val ) ; break ; } } } } }
public void add resource ( string name ) { add resource object ( new resource ( name ) ) ; }
public string get trim ( string name ) { string value = get ( name ) ; if ( null == value ) { return null ; } else { return value . trim ( ) ; } }
public void set double ( string name , double value ) { set ( name , double . to string ( value ) ) ; }
public void set class ( string name , class < ? > the class , class < ? > xface ) { if ( ! xface . be assignable from ( the class ) ) throw new runtime exception ( the class+ `` not `` +xface . get name ( ) ) ; set ( name , the class . get name ( ) ) ; }
public string get new value ( ) { return new val ; }
public string get config suffix ( ) { string [ ] part = name . split ( `` / `` ) ; string builder suffix = new string builder ( ) ; for ( string part : part ) { suffix . append ( `` . `` ) . append ( string utils . to lower case ( part ) ) ; } return suffix . to string ( ) ; }
public static option option ( configuration conf ) { return new option ( conf ) ; }
public static string get base name ( string version name ) throw i o exception { int div = version name . last index of ( ' @ ' ) ; if ( div == -1 ) { throw new i o exception ( `` no version in key path `` + version name ) ; } return version name . substring ( 0 , div ) ; }
public void next byte ( byte [ ] bytes ) { if ( ! native enable || ! next rand byte ( byte ) ) { fallback . next byte ( byte ) ; } }
public string get canonical service name ( ) { return security util . build d t service name ( get uri ( ) , get uri default port ( ) ) ; }
public void set x attr ( path path , string name , byte [ ] value ) throw i o exception { set x attr ( path , name , value , enum set . of ( x attr set flag . create , x attr set flag . replace ) ) ; }
public list < string > list x attrs ( path path ) throw i o exception { throw new unsupported operation exception ( get class ( ) . get simple name ( ) + `` do n't support list x attrs `` ) ; }
public string [ ] get topology path ( ) throw i o exception { return topology path ; }
public void set length ( long length ) { this . length = length ; }
public string to string ( boolean q option ) { return to string ( q option , false ) ; }
public boolean be file ( ) { return ! isdir & & ! be symlink ( ) ; }
public string get owner ( ) { return owner ; }
public static uri get default uri ( configuration conf ) { return uri . create ( fix name ( conf . get ( fs_default_name_key , default_fs ) ) ) ; }
public static void set default uri ( configuration conf , uri uri ) { conf . set ( fs_default_name_key , uri . to string ( ) ) ; }
public token < ? > get delegation token ( string renewer ) throw i o exception { return null ; }
public void concat ( final path trg , final path [ ] psrcs ) throw i o exception { throw new unsupported operation exception ( `` not implement by the `` + get class ( ) . get simple name ( ) + `` file system implementation `` ) ; }
public boolean cancel delete on exit ( path f ) { synchronize ( delete on exit ) { return delete on exit . remove ( f ) ; } }
public file status [ ] list status ( path f , path filter filter ) throw file not find exception , i o exception { array list < file status > result = new array list < file status > ( ) ; list status ( result , f , filter ) ; return result . to array ( new file status [ result . size ( ) ] ) ; }
public file status [ ] list status ( path [ ] file ) throw file not find exception , i o exception { return list status ( file , default_filter ) ; }
public void copy to local file ( boolean del src , path src , path dst , boolean use raw local file system ) throw i o exception { configuration conf = get conf ( ) ; file system local = null ; if ( use raw local file system ) { local = get local ( conf ) . get raw file system ( ) ; } else { local = get local ( conf ) ; } file util . copy ( this , src , local , dst , del src , conf ) ; }
public static synchronize map < string , statistic > get statistic ( ) { map < string , statistic > result = new hash map < string , statistic > ( ) ; for ( statistic stat : statistic table . value ( ) ) { result . put ( stat . get scheme ( ) , stat ) ; } return result ; }
public path get work directory ( ) { return f . get work directory ( ) ; }
protect synchronized void flush buffer ( ) throw i o exception { flush buffer ( false , true ) ; }
public static void main ( string argv [ ] ) throw exception { f shell shell = new shell instance ( ) ; configuration conf = new configuration ( ) ; conf . set quiet mode ( false ) ; shell . set conf ( conf ) ; int re ; try { re = tool runner . run ( shell , argv ) ; } finally { shell . close ( ) ; } system . exit ( re ) ; }
public static void register command ( command factory factory ) { factory . add class ( chmod . class , `` -chmod `` ) ; factory . add class ( chown . class , `` -chown `` ) ; factory . add class ( chgrp . class , `` -chgrp `` ) ; }
public path get local path for write ( string path str , configuration conf ) throw i o exception { return get local path for write ( path str , size_unknown , conf ) ; }
public boolean if exists ( string path str , configuration conf ) { allocator per context context = obtain context ( context cfg item name ) ; return context . if exists ( path str , conf ) ; }
public boolean be absolute and scheme authority null ( ) { return ( be uri path absolute ( ) & & uri . get scheme ( ) == null & & uri . get authority ( ) == null ) ; }
public void set command factory ( command factory factory ) { this . command factory = factory ; }
protect void post process path ( path data item ) throw i o exception { }
public void display warning ( string message ) { err . println ( get name ( ) + `` : `` + message ) ; }
public command get instance ( string cmd ) { return get instance ( cmd , get conf ( ) ) ; }
public list < string > parse ( string [ ] args , int po ) { list < string > parameter = new array list < string > ( arrays . a list ( args ) ) ; parameter . sub list ( 0 , po ) . clear ( ) ; parse ( parameter ) ; return parameter ; }
public void set in ( input stream in ) { this . in = in ; }
public void set max depth ( int max depth ) { this . max depth = max depth ; }
public void expunge ( ) throw i o exception { trash policy . delete checkpoint ( ) ; }
public static string get home dir value ( final configuration conf , final string mount table name ) { return conf . get ( get config view fs prefix ( mount table name ) + `` . `` + constant . config_viewfs_homedir ) ; }
public void set attribute ( string name , object value ) { web app context . set attribute ( name , value ) ; }
protect string get web apps path ( string app name ) throw file not find exception { url url = get class ( ) . get class loader ( ) . get resource ( `` webapps/ `` + app name ) ; if ( url == null ) throw new file not find exception ( `` webapps/ `` + app name + `` not find in classpath `` ) ; string url string = url . to string ( ) ; return url string . substring ( 0 , url string . last index of ( '/ ' ) ) ; }
public object get ( ) { return value ; }
public int compare to ( byte [ ] other , int off , int len ) { return writable comparator . compare byte ( get byte ( ) , 0 , get length ( ) , other , off , len ) ; }
protect void update process byte count ( int count ) { this . bytes read from compress stream += count ; }
public void set conf ( configuration conf ) { this . conf = conf ; }
public string to string ( ) { string builder buf = new string builder ( ) ; iterator < map . entry < string , compression codec > > itr = codecs . entry set ( ) . iterator ( ) ; buf . append ( `` { `` ) ; if ( itr . have next ( ) ) { map . entry < string , compression codec > entry = itr . next ( ) ; buf . append ( entry . get key ( ) ) ; buf . append ( `` : `` ) ; buf . append ( entry . get value ( ) . get class ( ) . get name ( ) ) ; while ( itr . have next ( ) ) { entry = itr . next ( ) ; buf . append ( `` , `` ) ; buf . append ( entry . get key ( ) ) ; buf . append ( `` : `` ) ; buf . append ( entry . get value ( ) . get class ( ) . get name ( ) ) ; } } buf . append ( `` } `` ) ; return buf . to string ( ) ; }
public compression codec get codec ( path file ) { compression codec result = null ; if ( codecs ! = null ) { string filename = file . get name ( ) ; string reverse filename = new string builder ( filename ) . reverse ( ) . to string ( ) ; sort map < string , compression codec > sub map = codecs . head map ( reversed filename ) ; if ( ! sub map . be empty ( ) ) { string potential suffix = sub map . last key ( ) ; if ( reversed filename . start with ( potential suffix ) ) { result = codecs . get ( potential suffix ) ; } } } return result ; }
public synchronize void finish ( ) { finish = true ; }
public static void copy byte ( input stream in , output stream out , configuration conf ) throw i o exception { copy byte ( in , out , conf . get int ( `` io . file . buffer . size `` , 4096 ) , true ) ; }
public static m d5 hash digest ( string string ) { return digest ( utf8 . get byte ( string ) ) ; }
public void write ( input stream in , int length ) throw i o exception { buffer . write ( in , length ) ; }
public static int read unsigned short ( byte [ ] byte , int start ) { return ( ( ( bytes [ start ] & 0xff ) < < 8 ) + ( ( bytes [ start+1 ] & 0xff ) ) ) ; }
public static int read v int ( byte [ ] byte , int start ) throw i o exception { return ( int ) read v long ( byte , start ) ; }
public writable call ( rpc . rpc kind rpc kind , writable rpc request , connection id remote id , int service class ) throw i o exception { return call ( rpc kind , rpc request , remote id , service class , null ) ; }
public synchronize client get client ( configuration conf ) { return get client ( conf , socket factory . get default ( ) , object writable . class ) ; }
public e peek ( ) { block queue < e > q = this . get first non empty queue ( 0 ) ; if ( q == null ) { return null ; } else { return q . peek ( ) ; } }
public void shutdown ( ) { }
public t get proxy ( ) { return proxy ; }
public static user group information get remote user ( ) { call call = cur call . get ( ) ; return ( call ! = null & & call . connection ! = null ) ? call . connection . user : null ; }
public void set socket send buf size ( int size ) { this . socket send buffer size = size ; }
public synchronize void stop ( ) { log . info ( `` stop server on `` + port ) ; run = false ; if ( handler ! = null ) { for ( int i = 0 ; i < handler count ; i++ ) { if ( handler [ i ] ! = null ) { handler [ i ] . interrupt ( ) ; } } } listener . interrupt ( ) ; listener . do stop ( ) ; responder . interrupt ( ) ; notify all ( ) ; this . rpc metric . shutdown ( ) ; this . rpc detailed metric . shutdown ( ) ; }
public object get attribute ( string attribute name ) { return attribute map . get ( attribute name ) ; }
public synchronize void start monitoring ( ) throw i o exception { if ( ! be monitor ) { start timer ( ) ; be monitor = true ; } }
public final synchronize metric record create record ( string record name ) { if ( buffer data . get ( record name ) == null ) { buffer data . put ( record name , new record map ( ) ) ; } return new record ( record name ) ; }
protect void remove ( metric record impl record ) { }
public object get tag ( string name ) { return tag map . get ( name ) ; }
public synchronize long get previous interval average time ( ) { return previous interval data . time ; }
public static metric tag tag ( metric info info , string value ) { return tag . instance . cache . add ( info , value ) ; }
public mutable counter int new counter ( string name , string desc , int i val ) { return new counter ( intern . info ( name , desc ) , i val ) ; }
public void init ( class < ? > protocol ) { if ( protocol cache . contains ( protocol ) ) return ; protocol cache . add ( protocol ) ; for ( method method : protocol . get declare method ( ) ) { string name = method . get name ( ) ; log . debug ( name ) ; try { registry . new rate ( name , name , false , true ) ; } catch ( exception e ) { log . error ( `` error create rate metric for `` + method . get name ( ) , e ) ; } } }
public boolean accepts ( metric record record ) { return accepts ( record . name ( ) ) & & accepts ( record . tag ( ) ) ; }
protect ganglion conf get ganglia conf for metric ( string metric name ) { ganglia conf gconf = ganglion conf map . get ( metric name ) ; return gconf ! = null ? gconf : default_ganglia_conf ; }
public string dump topology ( ) { map < string , string > rack = get switch map ( ) ; string builder builder = new string builder ( ) ; builder . append ( `` mapping : `` ) . append ( to string ( ) ) . append ( `` \n `` ) ; if ( rack ! = null ) { builder . append ( `` map : \n `` ) ; set < string > switch = new hash set < string > ( ) ; for ( map . entry < string , string > entry : rack . entry set ( ) ) { builder . append ( `` `` ) . append ( entry . get key ( ) ) . append ( `` - > `` ) . append ( entry . get value ( ) ) . append ( `` \n `` ) ; switch . add ( entry . get value ( ) ) ; } builder . append ( `` node : `` ) . append ( rack . size ( ) ) . append ( `` \n `` ) ; builder . append ( `` switch : `` ) . append ( switch . size ( ) ) . append ( `` \n `` ) ; } else { builder . append ( `` no topology information `` ) ; } return builder . to string ( ) ; }
public static network topology get instance ( configuration conf ) { return reflection utils . new instance ( conf . get class ( common configuration key public . net_topology_impl_key , network topology . class , network topology . class ) , conf ) ; }
public static string get path ( node node ) { return node . get network location ( ) + path_separator_str + node . get name ( ) ; }
public synchronize void close ( ) throw i o exception { / * close the channel since socket . get ouput stream ( ) . close ( ) * close the socket . * / writer . channel . close ( ) ; writer . close ( ) ; }
public void set ( byte [ ] bytes ) { this . count = ( bytes == null ) ? 0 : byte . length ; this . bytes = byte ; }
public byte [ ] get ( ) { if ( bytes == null ) { byte = new byte [ 0 ] ; } return byte ; }
public boolean equal ( object o ) { if ( ! super . equal ( o ) ) return false ; vector type i d vti = ( vector type i d ) o ; return this . type i d element . equal ( vti . type i d element ) ; }
public string get proxy superuser ip conf key ( string user name ) { return config prefix + user name + conf_hosts ; }
public byte [ ] get secret key ( text alias ) { return secret key map . get ( alias ) ; }
public list < text > get all secret key ( ) { list < text > list = new java . util . array list < text > ( ) ; list . add all ( secret key map . key set ( ) ) ; return list ; }
public void read token storage stream ( data input stream in ) throw i o exception { byte [ ] magic = new byte [ token_storage_magic . length ] ; in . read fully ( magic ) ; if ( ! array . equal ( magic , token_storage_magic ) ) { throw new i o exception ( `` bad header find in token storage . `` ) ; } byte version = in . read byte ( ) ; if ( version ! = token_storage_version ) { throw new i o exception ( `` unknown version `` + version + `` in token storage . `` ) ; } read field ( in ) ; }
public static sasl property resolver get instance ( configuration conf ) { class < ? extend sasl property resolver > clazz = conf . get class ( common configuration key public . hadoop_security_sasl_props_resolver_class , sasl property resolver . class , sasl property resolver . class ) ; return reflection utils . new instance ( clazz , conf ) ; }
public static < t > t do a login user or fatal ( privileged action < t > action ) { if ( user group information . be security enable ( ) ) { user group information ugi = null ; try { ugi = user group information . get login user ( ) ; } catch ( i o exception e ) { log . fatal ( `` exception while get login user `` , e ) ; e . print stack trace ( ) ; runtime . get runtime ( ) . exit ( -1 ) ; } return ugi . do a ( action ) ; } else { return action . run ( ) ; } }
public static < t > t do a login user ( privileged exception action < t > action ) throw i o exception { return do a user ( user group information . get login user ( ) , action ) ; }
public key manager [ ] get key manager ( ) { return key manager ; }
public byte [ ] get byte ( ) { data output buffer buf = new data output buffer ( 4096 ) ; try { this . write ( buf ) ; } catch ( i o exception ie ) { throw new runtime exception ( `` i/o error in get byte `` , ie ) ; } return array . copy of ( buf . get data ( ) , buf . get length ( ) ) ; }
public boolean be from keytab ( ) { return be keytab ; }
public synchronize boolean add token identifier ( token identifier token id ) { return subject . get public credential ( ) . add ( token id ) ; }
public collection < token < ? extend token identifier > > get token ( ) { synchronize ( subject ) { return collection . unmodifiable collection ( new array list < token < ? > > ( get credential internal ( ) . get all token ( ) ) ) ; } }
public list < service > get service ( ) { synchronize ( service list ) { return new array list < service > ( service list ) ; } }
public string to string ( ) { return ( name . be empty ( ) ? `` `` : ( ( name ) + `` : `` ) ) + state . to string ( ) ; }
public boolean be open ( ) { return ( ( status . get ( ) & status_closed_mask ) == 0 ) ; }
public int read line ( text str , int max line length , int max bytes to consume ) throw i o exception { if ( this . record delimiter bytes ! = null ) { return read custom line ( str , max line length , max byte to consume ) ; } else { return read default line ( str , max line length , max byte to consume ) ; } }
public void set load native library ( configuration conf , boolean load native library ) { conf . set boolean ( common configuration key . io_native_lib_available_key , load native library ) ; }
public progress add phase ( string status , float weightage ) { progress phase = add phase ( weightage ) ; phase . set status ( status ) ; return phase ; }
public void skip to ( long new value ) throw illegal state exception { for ( ; ; ) { final long c = get current value ( ) ; if ( new value < c ) { throw new illegal state exception ( `` can not skip to less than the current value ( = `` + c + `` ) , where new value= `` + new value ) ; } if ( current value . compare and set ( c , new value ) ) { return ; } } }
public int get exit code ( ) { return exit code ; }
public static int find nth byte ( byte [ ] utf , int start , int length , byte b , int n ) { int po = -1 ; int next start = start ; for ( int i = 0 ; i < n ; i++ ) { pos = find byte ( utf , next start , length , b ) ; if ( pos < 0 ) { return po ; } next start = po + 1 ; } return po ; }
public static string get build version ( ) { return common_version_info . _get build version ( ) ; }
public void clear space quota ( path src ) throw i o exception { dfs . set quota ( src , hdfs constant . quota_dont_set , hdfs constant . quota_reset ) ; }
public void allow snapshot ( path path ) throw i o exception { dfs . allow snapshot ( path ) ; }
public long add cache directive ( cache directive info info , enum set < cache flag > flag ) throw i o exception { return dfs . add cache directive ( info , flag ) ; }
public void modify cache directive ( cache directive info info , enum set < cache flag > flag ) throw i o exception { dfs . modify cache directive ( info , flag ) ; }
public void modify cache pool ( cache pool info info ) throw i o exception { dfs . modify cache pool ( info ) ; }
public void remove cache pool ( string pool name ) throw i o exception { dfs . remove cache pool ( pool name ) ; }
public input stream get wrap stream ( ) { return in ; }
public synchronize void close ( ) throw i o exception { if ( ! close . compare and set ( false , true ) ) { d f s client . log . debug ( `` d f s input stream have be close already `` ) ; return ; } dfs client . check open ( ) ; if ( ( extend read buffer ! = null ) & & ( ! extend read buffer . be empty ( ) ) ) { final string builder builder = new string builder ( ) ; extend read buffer . visit all ( new identity hash store . visitor < byte buffer , object > ( ) { private string prefix = `` `` ; @ override public void accept ( byte buffer k , object v ) { builder . append ( prefix ) . append ( k ) ; prefix = `` , `` ; } } ) ; d f s client . log . warn ( `` closing file `` + src + `` , but there be still `` + `` unreleased byte buffer allocate by read ( ) . `` + `` please release `` + builder . to string ( ) + `` . `` ) ; } close current block reader ( ) ; super . close ( ) ; }
public long get initial len ( ) { return initial file size ; }
public static block location [ ] locate blocks2 location ( list < locate block > block ) { if ( block == null ) { return new block location [ 0 ] ; } int nr block = block . size ( ) ; block location [ ] blk location = new block location [ nr block ] ; if ( nr block == 0 ) { return blk location ; } int idx = 0 ; for ( located block blk : block ) { assert idx < nr block : `` incorrect index `` ; datanode info [ ] location = blk . get location ( ) ; string [ ] host = new string [ location . length ] ; string [ ] xfer addrs = new string [ location . length ] ; string [ ] rack = new string [ location . length ] ; for ( int h cnt = 0 ; h cnt < location . length ; h cnt++ ) { host [ h cnt ] = location [ h cnt ] . get host name ( ) ; xfer addrs [ h cnt ] = location [ h cnt ] . get xfer addr ( ) ; node base node = new node base ( xfer addrs [ h cnt ] , location [ h cnt ] . get network location ( ) ) ; rack [ h cnt ] = node . to string ( ) ; } datanode info [ ] cache location = blk . get cached location ( ) ; string [ ] cache host = new string [ cache location . length ] ; for ( int i=0 ; i < cache location . length ; i++ ) { cached host [ i ] = cache location [ i ] . get host name ( ) ; } blk location [ idx ] = new block location ( xfer addrs , host , cached host , rack , blk . get start offset ( ) , blk . get block size ( ) , blk . be corrupt ( ) ) ; idx++ ; } return blk location ; }
public static collection < uri > get ns service rpc uris ( configuration conf ) { return get name service uris ( conf , d f s config key . dfs_namenode_service_rpc_address_key , d f s config key . dfs_namenode_rpc_address_key ) ; }
public static void set generic conf ( configuration conf , string nameservice id , string nn id , string . . . key ) { for ( string key : key ) { string value = conf . get ( add key suffix ( key , nameservice id , nn id ) ) ; if ( value ! = null ) { conf . set ( key , value ) ; continue ; } value = conf . get ( add key suffix ( key , nameservice id ) ) ; if ( value ! = null ) { conf . set ( key , value ) ; } } }
public static string get spnego keytab key ( configuration conf , string default key ) { string value = conf . get ( d f s config key . dfs_web_authentication_kerberos_keytab_key ) ; return ( value == null || value . be empty ( ) ) ? default key : d f s config key . dfs_web_authentication_kerberos_keytab_key ; }
public static configuration load ssl configuration ( configuration conf ) { configuration ssl conf = new configuration ( false ) ; ssl conf . add resource ( conf . get ( d f s config key . dfs_server_https_keystore_resource_key , d f s config key . dfs_server_https_keystore_resource_default ) ) ; boolean require client auth = conf . get boolean ( dfs_client_https_need_auth_key , dfs_client_https_need_auth_default ) ; ssl conf . set boolean ( dfs_client_https_need_auth_key , require client auth ) ; return ssl conf ; }
public boolean set safe mode ( hdfs constant . safe mode action action ) throw i o exception { return set safe mode ( action , false ) ; }
public void meta save ( string pathname ) throw i o exception { dfs . meta save ( pathname ) ; }
public long get num byte ( ) { return block . get num byte ( ) ; }
public long get dfs use ( ) { return dfs use ; }
public float get block pool use percent ( ) { return d f s util . get percent use ( block pool use , capacity ) ; }
public void set xceiver count ( int xceiver count ) { this . xceiver count = xceiver count ; }
public string get software version ( ) { return this . software version ; }
public static op read ( data input in ) throw i o exception { return value of ( in . read byte ( ) ) ; }
public i o stream pair create stream pair ( data output stream out , data input stream in ) { if ( sasl client ! = null ) { return new i o stream pair ( new sasl input stream ( in , sasl client ) , new sasl output stream ( out , sasl client ) ) ; } else { return new i o stream pair ( new sasl input stream ( in , sasl server ) , new sasl output stream ( out , sasl server ) ) ; } }
public boolean be trust ( inet address peer address ) { return false ; }
public boolean have more ( ) { return remain entry ! = 0 ; }
public final boolean be empty local name ( ) { return path . length == 0 ; }
public datanode info [ ] get location ( ) { return locs ; }
protect executor service create single thread executor ( ) { return executor . new single thread executor ( new thread factory builder ( ) . set daemon ( true ) . set name format ( `` logger channel ( from single-thread executor ) to `` + addr ) . set uncaught exception handler ( uncaught exception handler . system exit ( ) ) . build ( ) ) ; }
public token < block token identifier > get access token ( extended block eb ) throw i o exception { if ( ! be block token enable ) { return block token secret manager . dummy_token ; } else { if ( ! should run ) { throw new i o exception ( `` can not get access token since block key updater be not run `` ) ; } return block token secret manager . generate token ( null , eb , enum set . of ( access mode . replace , access mode . copy ) ) ; } }
public block u c state get block u c state ( ) { return block u c state . complete ; }
protect int add to exclude node ( datanode descriptor local machine , set < node > exclude node ) { return exclude node . add ( local machine ) ? 1 : 0 ; }
public static void increment block schedule ( datanode storage info . . . storage ) { for ( datanode storage info s : storage ) { s . get datanode descriptor ( ) . increment block schedule ( s . get storage type ( ) ) ; } }
public string list storage directory ( ) { string builder buf = new string builder ( ) ; for ( storage directory sd : storage dirs ) { buf . append ( sd . get root ( ) + `` ( `` + sd . get storage dir type ( ) + `` ) ; `` ) ; } return buf . to string ( ) ; }
protect void set field from property ( property prop , storage directory sd ) throw i o exception { set layout version ( prop , sd ) ; set namespace i d ( prop , sd ) ; setc time ( prop , sd ) ; set cluster id ( prop , layout version , sd ) ; check storage type ( prop , sd ) ; }
public static block metadata header read header ( random access file raf ) throw i o exception { byte [ ] buf = new byte [ get header size ( ) ] ; raf . seek ( 0 ) ; raf . read fully ( buf , 0 , buf . length ) ; return read header ( new data input stream ( new byte array input stream ( buf ) ) ) ; }
public static file id to block dir ( file root , long block id ) { int d1 = ( int ) ( ( block id > > 16 ) & 0xff ) ; int d2 = ( int ) ( ( block id > > 8 ) & 0xff ) ; string path = data storage . block_subdir_prefix + d1 + sep + data storage . block_subdir_prefix + d2 ; return new file ( root , path ) ; }
public trust channel resolver get trust channel resolver ( ) { return trust channel resolver ; }
public string get failed storage location ( ) { return this . fail storage location ; }
public void sync checksum out ( ) throw i o exception { if ( checksum out instanceof file output stream ) { ( ( file output stream ) checksum out ) . get channel ( ) . force ( true ) ; } }
public file get block file ( ) { return new file ( get dir ( ) , get block name ( ) ) ; }
public long get byte reserve ( ) { return 0 ; }
public void stop writer ( long xceiver stop timeout ) throw i o exception { if ( writer ! = null & & writer ! = thread . current thread ( ) & & writer . be alive ( ) ) { writer . interrupt ( ) ; try { writer . join ( xceiver stop timeout ) ; if ( writer . be alive ( ) ) { final string msg = `` join on writer thread `` + writer + `` time out `` ; data node . log . warn ( msg + `` \n `` + string utils . get stack trace ( writer ) ) ; throw new i o exception ( msg ) ; } } catch ( interrupted exception e ) { throw new i o exception ( `` wait for writer thread be interrupt . `` ) ; } } }
public void set blockpool i d ( string blockpool i d ) { this . blockpool i d = blockpool i d ; }
public static void set should skip fsync for test ( boolean skip ) { should skip fsync for test = skip ; }
public void close ( ) throw i o exception { }
public long remove last i node ( final i node in path iip ) { final int late snapshot = iip . get late snapshot id ( ) ; final i node last = iip . get last i node ( ) ; final i node directory parent = iip . get i node ( -2 ) . a directory ( ) ; if ( ! parent . remove child ( last , late snapshot ) ) { return -1 ; } return ( ! last . be in late snapshot ( late snapshot ) & & i node reference . try remove reference ( last ) > 0 ) ? 0 : 1 ; }
public void log close file ( string path , i node file new node ) { close op op = close op . get instance ( cache . get ( ) ) . set path ( path ) . set replication ( new node . get file replication ( ) ) . set modification time ( new node . get modification time ( ) ) . set access time ( new node . get access time ( ) ) . set block size ( new node . get preferred block size ( ) ) . set block ( new node . get block ( ) ) . set permission status ( new node . get permission status ( ) ) ; log edit ( op ) ; }
protect final void set state internal ( final h a context context , final h a state s ) throw service fail exception { prepare to exit state ( context ) ; s . prepare to enter state ( context ) ; context . write lock ( ) ; try { exit state ( context ) ; context . set state ( s ) ; s . enter state ( context ) ; s . update last h a transition time ( ) ; } finally { context . write unlock ( ) ; } }
public synchronize void close ( ) throw i o exception { if ( nn proxy info == null ) { return ; } if ( nn proxy info . proxy instanceof closeable ) { ( ( closeable ) nn proxy info . proxy ) . close ( ) ; } else { rpc . stop proxy ( nn proxy info . proxy ) ; } }
public boolean use logical u r i ( ) { return true ; }
public boolean be reference ( ) { return false ; }
public void add space consume ( quota count count , boolean verify ) throw quota exceed exception { add space consumed2 parent ( count , verify ) ; }
public boolean be under construction ( ) { return get file under construction feature ( ) ! = null ; }
public static i node in path append ( i node in path iip , i node child , byte [ ] child name ) { precondition . check argument ( ! iip . be snapshot & & iip . length ( ) > 0 ) ; precondition . check argument ( iip . get last i node ( ) ! = null & & iip . get last i node ( ) . be directory ( ) ) ; i node [ ] inodes = new i node [ iip . length ( ) + 1 ] ; system . arraycopy ( iip . inodes , 0 , inodes , 0 , inodes . length - 1 ) ; inodes [ inodes . length - 1 ] = child ; byte [ ] [ ] path = new byte [ iip . path . length + 1 ] [ ] ; system . arraycopy ( iip . path , 0 , path , 0 , path . length - 1 ) ; path [ path . length - 1 ] = child name ; return new i node in path ( inodes , path , false , iip . snapshot id ) ; }
public boolean be empty ( ) { return ! name node resource policy . be resource available ( journal , minimum redundant journal ) ; }
public final int compare to ( final integer that ) { return snapshot . id_integer_comparator . compare ( this . snapshot id , that ) ; }
public string get description ( ) { return description ; }
public void end phase ( phase phase ) { if ( ! be complete ( ) ) { phase . get ( phase ) . end time = monotonic now ( ) ; } }
public void set size ( phase phase , long size ) { if ( ! be complete ( ) ) { phase . get ( phase ) . size = size ; } }
public float get percent complete ( phase phase , step step ) { if ( get status ( phase ) == status . complete ) { return 1 . 0f ; } else { long total = get total ( phase , step ) ; long count = get count ( phase , step ) ; return total > 0 ? get bound percent ( 1 . 0f * count / total ) : 0 . 0f ; } }
public string get file ( ) { return file ; }
public int meta save ( string [ ] argv , int idx ) throw i o exception { string pathname = argv [ idx ] ; distribute file system dfs = get d f s ( ) ; configuration dfs conf = dfs . get conf ( ) ; uri dfs uri = dfs . get uri ( ) ; boolean be ha enabled = h a util . be logical uri ( dfs conf , dfs uri ) ; if ( be ha enable ) { string ns id = dfs uri . get host ( ) ; list < proxy and info < client protocol > > proxy = h a util . get proxy for all name node in nameservice ( dfs conf , ns id , client protocol . class ) ; for ( proxy and info < client protocol > proxy : proxy ) { proxy . get proxy ( ) . meta save ( pathname ) ; system . out . println ( `` create metasave file `` + pathname + `` in the log `` + `` directory of namenode `` + proxy . get address ( ) ) ; } } else { dfs . meta save ( pathname ) ; system . out . println ( `` create metasave file `` + pathname + `` in the log `` + `` directory of namenode `` + dfs . get uri ( ) ) ; } return 0 ; }
public void cancel ( string reason ) { this . cancel reason = reason ; }
public void undo create ( final e element , final int insertion point ) { remove ( create , insertion point , element ) ; }
public list < e > apply2 current ( final list < e > current ) { return apply2 previous ( current , get list ( list type . delete ) , get list ( list type . create ) ) ; }
public final void reset ( ) { reset ( 0l ) ; }
public int get capacity ( ) { return capacity ; }
public void remove ( e key ) { e value = reference map . get ( key ) ; if ( value ! = null & & value . decrement and get ref count ( ) == 0 ) { reference map . remove ( key ) ; } }
public immutable list < e > get entry ( ) { return new immutable list . builder < e > ( ) . add all ( reference map . key set ( ) ) . build ( ) ; }
public int get unique element size ( ) { return reference map . size ( ) ; }
public void create symlink ( path destination , path f , boolean create parent ) throw i o exception { statistic . increment write ops ( 1 ) ; final http op param . op op = put op param . op . createsymlink ; new fs path runner ( op , f , new destination param ( make qualify ( destination ) . to uri ( ) . get path ( ) ) , new create parent param ( create parent ) ) . run ( ) ; }
public path get output file for write ( long size ) throw i o exception { path attempt output = new path ( get attempt output dir ( ) , map_output_filename_string ) ; return l dir alloc . get local path for write ( attempt output . to string ( ) , size , conf ) ; }
protect event handler < job finish event > create job finish event handler ( ) { return new job finish event handler ( ) ; }
protect void status update ( task attempt status report status , long timestamp ) { string state string = report status . task state . to string ( ) ; task attempt id attempt i d = report status . id ; task id task i d = attempt i d . get task id ( ) ; job job = context . get job ( task i d . get job id ( ) ) ; if ( job == null ) { return ; } task task = job . get task ( task i d ) ; if ( task == null ) { return ; } estimator . update attempt ( report status , timestamp ) ; if ( state string . equal ( task attempt state . run . name ( ) ) ) { run task . put if absent ( task i d , boolean . true ) ; } else { run task . remove ( task i d , boolean . true ) ; if ( ! state string . equal ( task attempt state . start . name ( ) ) ) { run task attempt statistic . remove ( attempt i d ) ; } } }
@ override protected class < ? extend sub view > content ( ) { return single counter block . class ; }
public class loader make class loader ( final class loader parent ) throw malformed u r l exception { final url [ ] url = new url [ local classpaths . size ( ) ] ; for ( int i = 0 ; i < local classpaths . size ( ) ; ++i ) { urls [ i ] = new file ( local classpaths . get ( i ) ) . to u r i ( ) . to u r l ( ) ; log . info ( urls [ i ] ) ; } return access controller . do privilege ( new privilege action < class loader > ( ) { @ override public class loader run ( ) { return new u r l class loader ( urls , parent ) ; } } ) ; }
public long get t t expiry interval ( ) { return tt expiry interval ; }
public int get max reduce task ( ) { return max_reduce_tasks ; }
public job tracker . state get job tracker state ( ) { return job tracker . state . running ; }
public void log ( log log ) { log . info ( `` counter : `` + size ( ) ) ; for ( group group : this ) { log . info ( `` `` + group . get display name ( ) ) ; for ( counter counter : group ) { log . info ( `` `` + counter . get display name ( ) + `` = `` + counter . get counter ( ) ) ; } } }
protect void extend internal ( double new progress , int new value ) { if ( state == null ) { return ; } state . current accumulation += ( double ) ( new value - previous value ) ; previous value = new value ; }
public long get length ( ) { return f . get length ( ) ; }
public void init ( job conf conf ) throw i o exception { set conf ( conf ) ; cluster = new cluster ( conf ) ; client ugi = user group information . get current user ( ) ; max retry = conf . get int ( m r job config . mr_client_job_max_retries , m r job config . default_mr_client_job_max_retries ) ; retry interval = conf . get long ( m r job config . mr_client_job_retry_interval , m r job config . default_mr_client_job_retry_interval ) ; }
public synchronize void close ( ) throw i o exception { cluster . close ( ) ; }
public task status filter get task output filter ( ) { return this . task output filter ; }
public string get jar ( ) { return get ( job context . jar ) ; }
public path get work directory ( ) { string name = get ( job context . working_dir ) ; if ( name ! = null ) { return new path ( name ) ; } else { try { path dir = file system . get ( this ) . get work directory ( ) ; set ( job context . working_dir , dir . to string ( ) ) ; return dir ; } catch ( i o exception e ) { throw new runtime exception ( e ) ; } } }
public void set num map task ( int n ) { set int ( job context . num_maps , n ) ; }
public string get session id ( ) { return get ( `` session . id `` , `` `` ) ; }
public int get max reduce task failure percent ( ) { return get int ( job context . reduce_failures_maxpercent , 0 ) ; }
public string get queue name ( ) { return get ( job context . queue_name , default_queue_name ) ; }
public synchronize void set mapred job i d ( string mapred job i d ) { set assign job i d ( job i d . for name ( mapred job i d ) ) ; }
public string get job name ( ) { return name ; }
public void add ( input split s ) throw i o exception { if ( null == split ) { throw new i o exception ( `` uninitialized input split `` ) ; } if ( fill == split . length ) { throw new i o exception ( `` too many split `` ) ; } split [ fill++ ] = s ; totsize += s . get length ( ) ; }
public string [ ] get location ( int i ) throw i o exception { return split [ i ] . get location ( ) ; }
public k key ( ) { if ( jc . have next ( ) ) { return jc . key ( ) ; } if ( ! q . be empty ( ) ) { return q . peek ( ) . key ( ) ; } return null ; }
protect tuple writable create internal value ( ) { writable [ ] vals = new writable [ kid . length ] ; for ( int i = 0 ; i < vals . length ; ++i ) { vals [ i ] = kid [ i ] . create value ( ) ; } return new tuple writable ( vals ) ; }
public void close ( ) throw i o exception { if ( kid ! = null ) { for ( record reader < k , ? extend writable > rr : kid ) { rr . close ( ) ; } } if ( jc ! = null ) { jc . close ( ) ; } }
public boolean have next ( ) { return ! empty ; }
public u create value ( ) { return rr . create value ( ) ; }
public static void main ( string args [ ] ) throw i o exception { job conf job = value aggregator job . create value aggregator job ( args ) ; job client . run job ( job ) ; }
public mapper get first map ( ) { return ( mapper . size ( ) > 0 ) ? mapper . get ( 0 ) : null ; }
public void close ( ) throw i o exception { for ( record writer writer : record writer . value ( ) ) { writer . close ( null ) ; } }
public void close ( ) throw i o exception { }
public void status ( string msg ) { reporter . set status ( msg ) ; }
public static boolean get be java record reader ( job conf conf ) { return conf . get boolean ( submitter . is_java_rr , false ) ; }
public synchronize set < string > get leaf queue name ( ) { return leaf queue . key set ( ) ; }
public void write to file ( path loc , job conf job ) throw i o exception { write to file ( loc , job , new pure java crc32 ( ) ) ; }
public void set encrypt spill key ( byte [ ] encrypt spill key ) { if ( encrypt spill key ! = null ) { this . encrypt spill key = encrypt spill key ; } }
protect static list < statistic > get fs statistic ( path path , configuration conf ) throw i o exception { list < statistic > match stats = new array list < file system . statistic > ( ) ; path = path . get file system ( conf ) . make qualified ( path ) ; string scheme = path . to uri ( ) . get scheme ( ) ; for ( statistic stats : file system . get all statistic ( ) ) { if ( stats . get scheme ( ) . equal ( scheme ) ) { matched stats . add ( stats ) ; } } return matched stats ; }
public static file get job dir ( job i d jobid ) { return new file ( get user log dir ( ) , jobid . to string ( ) ) ; }
public task i d get task i d ( ) { return task i d . downgrade ( super . get task i d ( ) ) ; }
public void set next record range ( sort range . range next record range ) { this . next record range = next record range ; }
public long get map finish time ( ) { return 0 ; }
public long get start time ( ) { return start time ; }
public phase get phase ( ) { return this . phase ; }
public long get output size ( ) { return output size ; }
public list < task attempt i d > get fetch fail map ( ) { return null ; }
public static byte [ ] create i v ( configuration conf ) throw i o exception { crypto codec crypto codec = crypto codec . get instance ( conf ) ; if ( be encrypt spill enable ( conf ) ) { byte [ ] iv = new byte [ crypto codec . get cipher suite ( ) . get algorithm block size ( ) ] ; crypto codec . generate secure random ( iv ) ; return iv ; } else { return null ; } }
public static void set cache file ( uri [ ] file , configuration conf ) { string sfiles = string utils . uri to string ( file ) ; conf . set ( m r job config . cache_files , sfiles ) ; }
public static path [ ] get archive class path ( configuration conf ) { array list < string > list = ( array list < string > ) conf . get string collection ( m r job config . classpath_archives ) ; if ( list . size ( ) == 0 ) { return null ; } path [ ] path = new path [ list . size ( ) ] ; for ( int i = 0 ; i < list . size ( ) ; i++ ) { paths [ i ] = new path ( list . get ( i ) ) ; } return path ; }
public split location info [ ] get location info ( ) throw i o exception { return null ; }
public string get job file ( ) { ensure state ( job state . run ) ; return status . get job file ( ) ; }
public boolean be successful ( ) throw i o exception { ensure state ( job state . run ) ; update status ( ) ; return status . get state ( ) == job status . state . succeed ; }
public void fail task ( final task attempt i d task id ) throw i o exception { kill task ( task id , true ) ; }
public counter get counter ( ) throw i o exception { ensure state ( job state . run ) ; try { return ugi . do a ( new privilege exception action < counter > ( ) { @ override public counter run ( ) throw i o exception , interrupted exception { return cluster . get client ( ) . get job counter ( get job i d ( ) ) ; } } ) ; } catch ( interrupted exception ie ) { throw new i o exception ( ie ) ; } }
public void set num reduce task ( int task ) throw illegal state exception { ensure state ( job state . define ) ; conf . set num reduce task ( task ) ; }
public static int get completion poll interval ( configuration conf ) { int completion poll interval millis = conf . get int ( completion_poll_interval_key , default_completion_poll_interval ) ; if ( completion poll interval millis < 1 ) { log . warn ( completion_poll_interval_key + `` have be set to an invalid value ; `` + `` replace with `` + default_completion_poll_interval ) ; completion poll interval millis = default_completion_poll_interval ; } return completion poll interval millis ; }
public job i d get jobid ( ) { return job id ; }
public string get status ( ) { return datum . job status . to string ( ) ; }
public boolean get uberized ( ) { return datum . uberized ; }
public string get workflow id ( ) { if ( datum . workflow id ! = null ) { return datum . workflow id . to string ( ) ; } return null ; }
public long get shuffle finish time ( ) { return shuffle finish time ; }
protect synchronized void set history file ( string history file ) { this . history file = history file ; }
public static path get job jar ( path job submit dir ) { return new path ( job submit dir , `` job . jar `` ) ; }
public static path get job dist cache file ( path job submit dir ) { return new path ( job submit dir , `` file `` ) ; }
protect void set min split size node ( long min split size node ) { this . min split size node = min split size node ; }
protect long get format min split size ( ) { return 1 ; }
public boolean have ( int i ) { return write . get ( i ) ; }
public path get default work file ( task attempt context context , string extension ) throw i o exception { file output committer committer = ( file output committer ) get output committer ( context ) ; return new path ( committer . get work path ( ) , get unique file ( context , get output name ( context ) , extension ) ) ; }
protect static string get output name ( job context job ) { return job . get configuration ( ) . get ( base_output_name , part ) ; }
public void set key field spec ( int start , int end ) { if ( end > = start ) { key description k = new key description ( ) ; k . begin field idx = start ; k . end field idx = end ; key spec see = true ; all key spec . add ( k ) ; } }
public static void clean up token referral ( configuration conf ) { conf . unset ( m r job config . mapreduce_job_credentials_binary ) ; }
public job i d get job i d ( ) { return job id ; }
public uri [ ] get cache archive ( ) throw i o exception { return distribute cache . get cache archive ( conf ) ; }
public synchronize state mark available ( ) { if ( map . be empty ( ) ) { state = state . idle ; } else { state = state . pending ; } return state ; }
public task attempt i d get task attempt i d ( ) { return task id ; }
public task type get task type ( ) { return type ; }
public float get progress ( ) { return progress ; }
public counter get task counter ( ) { return counter ; }
protect static void destroy process ( string pid , long sleeptime before sigkill , boolean in background ) { terminate process ( pid ) ; sig kill ( pid , false , sleeptime before sigkill , in background ) ; }
public static boolean be alive ( string pid ) { shell command executor shexec = null ; try { string [ ] args = { `` kill `` , `` -0 `` , pid } ; shexec = new shell command executor ( args ) ; shexec . execute ( ) ; } catch ( exit code exception ee ) { return false ; } catch ( i o exception ioe ) { log . warn ( `` error execute shell command `` + shexec . to string ( ) + ioe ) ; return false ; } return ( shexec . get exit code ( ) == 0 ? true : false ) ; }
public string get reader ( ) { return reader ; }
public void set domain ( list < timeline domain > domains ) { this . domains = domain ; }
public string get user ( ) { return user ; }
public static a h s client create a h s client ( ) { a h s client client = new a h s client impl ( ) ; return client ; }
public static void set n m token ( string node addr , token token ) { nm_token_cache . set token ( node addr , token ) ; }
public static timeline client create timeline client ( ) { timeline client client = new timeline client impl ( ) ; return client ; }
public static text get r m delegation token service ( configuration conf ) { return get token service ( conf , yarn configuration . rm_address , yarn configuration . default_rm_address , yarn configuration . default_rm_port ) ; }
public void init ( configuration conf ) throw exception { }
public static path get path from yarn u r l ( url url ) throw u r i syntax exception { string scheme = url . get scheme ( ) == null ? `` `` : url . get scheme ( ) ; string authority = `` `` ; if ( url . get host ( ) ! = null ) { authority = url . get host ( ) ; if ( url . get user info ( ) ! = null ) { authority = url . get user info ( ) + `` @ `` + authority ; } if ( url . get port ( ) > 0 ) { authority += `` : `` + url . get port ( ) ; } } return new path ( ( new uri ( scheme , authority , url . get file ( ) , null , null ) ) . normalize ( ) ) ; }
public static string cjoin ( object . . . args ) { return csv_joiner . join ( args ) ; }
public static iterable < string > _split ( char sequence s ) { return _splitter . split ( s ) ; }
public static string get date ( ) { return yarn_version_info . _get date ( ) ; }
public static string get user ( ) { return yarn_version_info . _get user ( ) ; }
public static string get url ( ) { return yarn_version_info . _get url ( ) ; }
public boolean support auto resize ( ) { return true ; }
public void reset ( ) { clear count ( ) ; reset max value ( 0 ) ; reset min non zero value ( long . max_value ) ; set normalize index offset ( 0 ) ; start time stamp msec = long . max_value ; end time stamp msec = 0 ; tag = null ; }
public void shift value right ( final int number of binary order of magnitude ) { shift value right ( number of binary order of magnitude , integer to double value conversion ratio ) ; }
public long get high to lowest value ratio ( ) { return configure high to lowest value ratio ; }
public synchronize double histogram get interval histogram ( double histogram histogram to recycle ) { return get interval histogram ( histogram to recycle , true ) ; }
public double get start time sec ( ) { return start time sec ; }
public encodable histogram next absolute interval histogram ( final double absolute start time sec , final double absolute end time sec ) { return next interval histogram ( absolute start time sec , absolute end time sec , true ) ; }
public void output legend ( ) { log . println ( `` \ `` start timestamp\ `` , \ `` interval_ length\ `` , \ `` interval_ max\ `` , \ `` interval_ compressed_ histogram\ `` `` ) ; }
public long get end time stamp ( ) { return end time stamp msec ; }
public int get index ( ) { return index ; }
public void record value with expect interval ( final double value , final double expect interval between value sample ) throw array index out of bound exception { long critical value at enter = record phaser . writer critical section enter ( ) ; try { active histogram . record value with expect interval ( value , expect interval between value sample ) ; } finally { record phaser . writer critical section exit ( critical value at enter ) ; } }
public metadata source add resource ( string name ) { xml binding . add ( get xml map binder access ( ) . bind ( name ) ) ; return this ; }
public static inheritance type from xml ( string name ) { return inheritance type . value of ( name ) ; }
public temporal type get temporal ( ) { return temporal ; }
public void set convert ( jaxb convert value ) { this . convert = value ; }
public void set cascade remove ( jaxb empty type value ) { this . cascade remove = value ; }
public void set cascade detach ( jaxb empty type value ) { this . cascade detach = value ; }
public list < jaxb unique constraint > get unique constraint ( ) { if ( unique constraint == null ) { unique constraint = new array list < jaxb unique constraint > ( ) ; } return this . unique constraint ; }
public boolean be updatable ( ) { return updatable ; }
public void set column definition ( string value ) { this . column definition = value ; }
public string get converter ( ) { return converter ; }
public void set converter ( string value ) { this . converter = value ; }
public void set map key temporal ( temporal type value ) { this . map key temporal = value ; }
public list < jaxb attribute override > get map key attribute override ( ) { if ( map key attribute override == null ) { map key attribute override = new array list < jaxb attribute override > ( ) ; } return this . map key attribute override ; }
public void set collection table ( jaxb collection table value ) { this . collection table = value ; }
public jaxb id class get id class ( ) { return id class ; }
public void set id class ( jaxb id class value ) { this . id class = value ; }
public void set entity listener ( jaxb entity listener value ) { this . entity listener = value ; }
public void set strategy ( generation type value ) { this . strategy = value ; }
public string get column list ( ) { return column list ; }
public void set procedure name ( string value ) { this . procedure name = value ; }
public void set method name ( string value ) { this . method name = value ; }
public void set allocation size ( integer value ) { this . allocation size = value ; }
public void set pk column name ( string value ) { this . pk column name = value ; }
protect identifier get identifier ( string name , final boolean quote , final jdbc environment jdbc environment ) { if ( be case insensitive ( jdbc environment ) ) { name = name . to lower case ( locale . root ) ; } return new identifier ( name , quote ) ; }
public static void bitandorxornot_bit and or xor not ( query engine query engine ) { query engine . get sqm function registry ( ) . name descriptor builder ( `` bit_and `` ) . set exact argument count ( 2 ) . register ( ) ; query engine . get sqm function registry ( ) . register alternate key ( `` bitand `` , `` bit_and `` ) ; query engine . get sqm function registry ( ) . name descriptor builder ( `` bit_or `` ) . set exact argument count ( 2 ) . register ( ) ; query engine . get sqm function registry ( ) . register alternate key ( `` bitor `` , `` bit_or `` ) ; query engine . get sqm function registry ( ) . name descriptor builder ( `` bit_xor `` ) . set exact argument count ( 2 ) . register ( ) ; query engine . get sqm function registry ( ) . register alternate key ( `` bitxor `` , `` bit_xor `` ) ; query engine . get sqm function registry ( ) . name descriptor builder ( `` bit_not `` ) . set exact argument count ( 1 ) . register ( ) ; query engine . get sqm function registry ( ) . register alternate key ( `` bitnot `` , `` bit_not `` ) ; }
public static void every any_sum iif ( query engine query engine ) { query engine . get sqm function registry ( ) . register ( `` every `` , new s q l server every any emulation ( query engine . get type configuration ( ) , true ) ) ; query engine . get sqm function registry ( ) . register ( `` any `` , new s q l server every any emulation ( query engine . get type configuration ( ) , false ) ) ; }
public static void overlay ( query engine query engine ) { query engine . get sqm function registry ( ) . register ternary quaternary pattern ( `` overlay `` , query engine . get type configuration ( ) . get basic type registry ( ) . resolve ( standard basic type . string ) , `` overlay ( ? 1 place ? 2 from ? 3 ) `` , `` overlay ( ? 1 place ? 2 from ? 3 for ? 4 ) `` ) . set argument list signature ( `` ( string place replacement from start [ for length ] ) `` ) ; }
public static void format_formatdatetime ( query engine query engine ) { query engine . get sqm function registry ( ) . name descriptor builder ( `` format `` , `` formatdatetime `` ) . set invariant type ( query engine . get type configuration ( ) . get basic type registry ( ) . resolve ( standard basic type . string ) ) . set exact argument count ( 2 ) . set argument list signature ( `` ( datetime a pattern ) `` ) . register ( ) ; }
public boolean bind limit parameter in reverse order ( ) { return false ; }
protect pattern get for update pattern ( ) { return for_update_pattern ; }
public static < t > t coalesce ( t . . . value ) { if ( value == null ) { return null ; } for ( t value : value ) { if ( value ! = null ) { if ( value instanceof string ) { if ( string helper . be not empty ( ( string ) value ) ) { return value ; } } else { return value ; } } } return null ; }
public static callback registry implementor build callback registry ( session factory option option ) { if ( jpa call back enable ( option ) ) { return new callback registry impl ( ) ; } else { return new empty callback registry impl ( ) ; } }
public entity persister find entity descriptor ( string entity name ) { return entity persister map . get ( entity name ) ; }
public sqm function descriptor register ( string registration key , sqm function descriptor function ) { final sqm function descriptor prior registration = function map . put ( registration key , function ) ; log . debugf ( `` register sqm function template [ % s ] under % s ; prior registration be % s `` , function , registration key , prior registration ) ; alternate key map . remove ( registration key ) ; return function ; }
public pattern function descriptor builder pattern aggregate descriptor builder ( string registration key , string pattern ) { return new pattern function descriptor builder ( this , registration key , function kind . aggregate , pattern ) ; }
public sqm function descriptor register name ( string name , basic type return type ) { return name descriptor builder ( name , name ) . set invariant type ( return type ) . register ( ) ; }
public name function descriptor builder name descriptor builder ( string name ) { return name descriptor builder ( name , name ) ; }
public name function descriptor builder name descriptor builder ( string registration key , string name ) { return new name function descriptor builder ( this , registration key , function kind . normal , name ) ; }
public boolean have parameter ( ) { return sqm params by query param ! = null & & ! sqm params by query param . be empty ( ) ; }
public boolean be disable foreign key ( ) { return disable foreign key ; }
public void set disable foreign key ( boolean value ) { this . disable foreign key = value ; }
public boolean be valid ( char sequence char sequence , constraint validator context constraint validator context ) { if ( char sequence == null ) { return true ; } return char sequence . to string ( ) . trim ( ) . length ( ) > 0 ; }
public boolean have more interpolation term ( ) throw message descriptor format exception { while ( current position < token list . size ( ) ) { current token = token list . get ( current position ) ; current position++ ; if ( current token . be parameter ( ) ) { current token available = true ; return true ; } } all interpolation term process = true ; return false ; }
public static list < method > get all method ( class < ? > clazz ) { contract . assert not null ( clazz ) ; list < method > method = new array list ( ) ; for ( class < ? > hierarchy class : class hierarchy helper . get hierarchy ( clazz ) ) { collection . add all ( method , run ( get method . action ( hierarchy class ) ) ) ; } return method ; }
public boolean be hibernate validator ( ) { return be hibernate validator ; }
public boolean add ( final long o ) { return _map . put if absent ( o . long value ( ) , v ) ! = v ; }
public void clear ( ) { _map . clear ( ) ; }
public int hash code ( ) { return ( ( _key == null ) ? 0 : _key . hash code ( ) ) ^ ( ( _val == null ) ? 0 : _val . hash code ( ) ) ; }
public boolean contains key ( long key ) { return get ( key ) ! = null ; }
public object get metric registry ( ) { return metric registry ; }
public long current sequence ( ) { return sequence . get ( ) ; }
public boolean be isolate internal query ( ) { return be isolate internal query ; }
public static long pop_intersect ( long [ ] arr1 , long [ ] arr2 , int word offset , int num word ) { long pop count = 0 ; for ( int i = word offset , end = word offset + num word ; i < end ; ++i ) { pop count += long . bit count ( arr1 [ i ] & arr2 [ i ] ) ; } return pop count ; }
public void push ( byte e1 , byte e2 ) { ensure buffer space ( 2 ) ; buffer [ element count++ ] = e1 ; buffer [ element count++ ] = e2 ; }
public byte put or add ( char key , byte put value , byte increment value ) { assert assign < mask + 1 ; if ( contains key ( key ) ) { put value = get ( key ) ; put value = ( byte ) ( ( ( put value ) + ( increment value ) ) ) ; } put ( key , put value ) ; return put value ; }
public void push ( char e1 , char e2 ) { ensure buffer space ( 2 ) ; buffer [ element count++ ] = e1 ; buffer [ element count++ ] = e2 ; }
public void push ( char e1 , char e2 , char e3 , char e4 ) { ensure buffer space ( 4 ) ; buffer [ element count++ ] = e1 ; buffer [ element count++ ] = e2 ; buffer [ element count++ ] = e3 ; buffer [ element count++ ] = e4 ; }
public static int max element ( double load factor ) { check load factor ( load factor , 0 , 1 ) ; return expand at count ( max_hash_array_length , load factor ) - 1 ; }
@ override public void set entity resolver ( entity resolver resolver ) { this . entity resolver = resolver ; }
public boolean be xmlns ( ) { return ( flags & is_xmlns ) ! = 0 ; }
public static @ local string new local name from buffer ( @ no length char [ ] buf , int length , interner interner ) { return new string ( buf , 0 , length ) . intern ( ) ; }
public boolean be need to drop l f ( ) { return need to drop l f ; }
public encode get actual html encoding ( ) { return actual html encoding ; }
public static trace scope start span ( string description , span parent ) { if ( parent == null ) return start span ( description ) ; return continue span ( parent . child ( description ) ) ; }
public string to string ( ) { return `` [ request date= `` + this . request date + `` ; response date= `` + this . response date + `` ; status line= `` + this . status line + `` ] `` ; }
public void reach ( ) { this . reach = true ; }
public int get max cache entry ( ) { return max cache entry ; }
public boolean be share cache ( ) { return be share cache ; }
public void set asynchronous worker idle lifetime sec ( final int sec ) { this . asynchronous worker idle lifetime sec = sec ; }
public static void reset ( ) { global scoped collapsers . clear ( ) ; request scoped collapsers . clear ( ) ; hystrix timer . reset ( ) ; }
public scope get scope ( ) { return scope . value of ( collapser factory . get scope ( ) . name ( ) ) ; }
public static int get global concurrent thread execute ( ) { return concurrent thread execute . get ( ) ; }
public long get cumulative count thread reject ( ) { return cumulative counter stream . get late count ( hystrix event type . thread pool . reject ) ; }
public long get roll max active thread ( ) { return roll thread pool max concurrency stream . get late roll max ( ) ; }
public void set ( t value ) { hystrix request context . get context for current thread ( ) . state . put ( this , new lazy initializer < t > ( this , value ) ) ; }
/ * private * / static hystrix plugins create ( class loader class loader , logger supplier log supplier ) { return new hystrix plugins ( class loader , log supplier ) ; }
public static void reset ( ) { get instance ( ) . notifier . set ( null ) ; get instance ( ) . concurrency strategy . set ( null ) ; get instance ( ) . metric publisher . set ( null ) ; get instance ( ) . property factory . set ( null ) ; get instance ( ) . command execution hook . set ( null ) ; hystrix metric publisher factory . reset ( ) ; }
public void update ( long x ) { cell [ ] a ; long b , v ; hash code hc ; cell a ; int n ; if ( ( a = cell ) ! = null || ( b = base ) < x & & ! ca base ( b , x ) ) { boolean uncontended = true ; int h = ( hc = thread hash code . get ( ) ) . code ; if ( a == null || ( n = a . length ) < 1 || ( a = a [ ( n - 1 ) & h ] ) == null || ( ( v = a . value ) < x & & ! ( uncontended = a . ca ( v , x ) ) ) ) retry update ( x , hc , uncontended ) ; } }
public static iterator < string > symbol name iterator ( final iterator < symbol token > token iter ) { return new iterator < string > ( ) { public boolean have next ( ) { return token iter . have next ( ) ; } public string next ( ) { return token iter . next ( ) . get text ( ) ; } public void remove ( ) { throw new unsupported operation exception ( ) ; } } ; }
public static ion text writer builder pretty ( ) { return standard ( ) . with pretty printing ( ) ; }
public final lst minimize get lst minimizing ( ) { return my lst minimizing ; }
public final symbol table [ ] get import ( ) { return safe copy ( my import ) ; }
public static ivy ant setting get default instance ( project component task ) { project project = task . get project ( ) ; object default instance obj = project . get reference ( `` ivy . instance `` ) ; if ( default instance obj ! = null & & default instance obj . get class ( ) . get class loader ( ) ! = ivy ant setting . class . get class loader ( ) ) { task . log ( `` ivy . instance reference an ivy : setting define in an other classloader . `` + `` an new default one will be use in this project . `` , project . msg_warn ) ; default instance obj = null ; } if ( default instance obj ! = null & & ! ( default instance obj instanceof ivy ant setting ) ) { throw new build exception ( `` ivy . instance reference a `` + default instance obj . get class ( ) . get name ( ) + `` an not an ivy ant setting . please do n't use this reference id ( ) `` ) ; } if ( default instance obj == null ) { task . log ( `` no ivy : setting find for the default reference 'ivy . instance ' . `` + `` a default instance will be use `` , project . msg_verbose ) ; ivy ant setting setting = new ivy ant setting ( ) ; setting . set project ( project ) ; project . add reference ( `` ivy . instance `` , setting ) ; setting . create ivy engine ( task ) ; return setting ; } else { return ( ivy ant setting ) default instance obj ; } }
public void set id ( string id ) { if ( auto register & & get project ( ) . get reference ( this . id ) == this ) { get project ( ) . get reference ( ) . remove ( this . id ) ; auto register = false ; } this . id = id ; if ( get project ( ) ! = null ) { get project ( ) . add reference ( this . id , this ) ; } }
public deliver option set confs ( string [ ] confs ) { this . confs = confs ; return this ; }
public map get attribute ( ) { return new hash map ( attribute ) ; }
public long get total copied size ( ) { return total copied size ; }
public static ivy context push new copy context ( ) { return push context ( new ivy context ( get context ( ) ) ) ; }
public static object peek in context stack ( string key ) { object value = null ; stack context stack = get current stack ( ) ; for ( int i = context stack . size ( ) - 1 ; i > = 0 & & value == null ; i -- ) { ivy context ctx = ( ivy context ) context stack . get ( i ) ; value = ctx . peek ( key ) ; } return value ; }
public void push ( string key , object value ) { synchronize ( context map ) { if ( ! context map . contains key ( key ) ) { context map . put ( key , new link list ( ) ) ; } object o = context map . get ( key ) ; if ( o instanceof list ) { ( ( list ) o ) . add ( 0 , value ) ; } else { throw new runtime exception ( `` can not push to non list object `` + o ) ; } } }
public void add configuration ( string conf ) { confs . add ( conf ) ; }
public string encode to string ( ) { return get organisation ( ) + encode_separator + get name ( ) ; }
public map get attribute ( ) { return attribute ; }
public artifact download report [ ] get artifact report ( download status download status , boolean with evict ) { collection all = new link hash set ( ) ; collection evict mrids = null ; if ( ! with evict ) { evicted mrids = get evicted mrids ( ) ; } for ( iterator iter = dependency report . value ( ) . iterator ( ) ; iter . have next ( ) ; ) { collection report = ( collection ) iter . next ( ) ; for ( iterator it report = report . iterator ( ) ; it report . have next ( ) ; ) { artifact download report report = ( artifact download report ) it report . next ( ) ; if ( download status ! = null & & report . get download status ( ) ! = download status ) { continue ; } if ( with evict || ! evicted mrids . contains ( report . get artifact ( ) . get module revision id ( ) ) ) { all . add ( report ) ; } } } return ( artifact download report [ ] ) all . to array ( new artifact download report [ all . size ( ) ] ) ; }
public int get revision number ( ) { ensure load ( ) ; return revision . size ( ) ; }
public string [ ] get configuration ( string root module conf ) { set dep confs = new link hash set ( ) ; add all if not null ( dep confs , usage . get configuration ( root module conf ) ) ; for ( iterator iterator = merge usage . value ( ) . iterator ( ) ; iterator . have next ( ) ; ) { ivy node usage usage = ( ivy node usage ) iterator . next ( ) ; add all if not null ( dep confs , usage . get configuration ( root module conf ) ) ; } return ( string [ ] ) dep confs . to array ( new string [ dep confs . size ( ) ] ) ; }
public artifact download report download ( artifact origin origin , download option option ) { dependency resolver resolver = setting . get resolver ( origin . get artifact ( ) . get module revision id ( ) ) ; return resolver . download ( origin , option ) ; }
public file get retrieve root ( ) { return retrieve root ; }
public collection get copy file ( ) { return new array list ( copied file ) ; }
public module id [ ] list module ( module id module crit , pattern matcher matcher ) { list ret = new array list ( ) ; map criterion = new hash map ( ) ; add matcher ( matcher , module crit . get organisation ( ) , criterion , ivy pattern helper . organisation_key ) ; add matcher ( matcher , module crit . get name ( ) , criterion , ivy pattern helper . module_key ) ; string [ ] token to list = new string [ ] { ivy pattern helper . organisation_key , ivy pattern helper . module_key } ; for ( iterator iter = setting . get resolvers ( ) . iterator ( ) ; iter . have next ( ) ; ) { dependency resolver resolver = ( dependency resolver ) iter . next ( ) ; map [ ] module id a map = resolver . list token value ( token to list , criterion ) ; for ( int i = 0 ; i < module id a map . length ; i++ ) { string org = ( string ) module id a map [ i ] . get ( ivy pattern helper . organisation_key ) ; string name = ( string ) module id a map [ i ] . get ( ivy pattern helper . module_key ) ; module id mod id = module id . new instance ( org , name ) ; ret . add ( name space helper . transform ( mod id , resolver . get namespace ( ) . get to system transformer ( ) ) ) ; } } return ( module id [ ] ) ret . to array ( new module id [ ret . size ( ) ] ) ; }
public string [ ] get ignorable filename ( ) { return ( string [ ] ) list ignore . to array ( new string [ listing ignore . size ( ) ] ) ; }
public boolean check loop ( module in sort futur caller , circular dependency strategy dep strategy ) { if ( caller ! = null ) { link list elem of loop = new link list ( ) ; elem of loop . add ( this . module . get module revision id ( ) ) ; for ( module in sort stack el = futur caller ; stack el ! = this ; stack el = stack el . caller ) { elem of loop . add ( stack el . module . get module revision id ( ) ) ; stack el . be loop intermediate element = true ; loop element . add ( stack el ) ; } elem of loop . add ( this . module . get module revision id ( ) ) ; module revision id [ ] mrids = ( module revision id [ ] ) elem of loop . to array ( new module revision id [ elem of loop . size ( ) ] ) ; dep strategy . handle circular dependency ( mrids ) ; return true ; } else { return false ; } }
public static string [ ] parse delimit string ( string value , string delim ) { if ( value == null ) { value = `` `` ; } final list list = new array list ( ) ; final int char = 1 ; final int delimiter = 2 ; final int startquote = 4 ; final int endquote = 8 ; final string buffer sb = new string buffer ( ) ; int expect = ( char | delimiter | startquote ) ; for ( int i = 0 ; i < value . length ( ) ; i++ ) { final char c = value . char at ( i ) ; final boolean be delimiter = ( delim . index of ( c ) > = 0 ) ; final boolean be quote = ( c == ' `` ' ) ; if ( be delimiter & & ( ( expect & delimiter ) > 0 ) ) { list . add ( sb . to string ( ) . trim ( ) ) ; sb . delete ( 0 , sb . length ( ) ) ; expect = ( char | delimiter | startquote ) ; } else if ( be quote & & ( ( expect & startquote ) > 0 ) ) { sb . append ( c ) ; expect = char | endquote ; } else if ( be quote & & ( ( expect & endquote ) > 0 ) ) { sb . append ( c ) ; expect = ( char | startquote | delimiter ) ; } else if ( ( expect & char ) > 0 ) { sb . append ( c ) ; } else { throw new illegal argument exception ( `` invalid delimited string : `` + value ) ; } } if ( sb . length ( ) > 0 ) { list . add ( sb . to string ( ) . trim ( ) ) ; } return ( string [ ] ) list . to array ( new string [ list . size ( ) ] ) ; }
protect session get session ( string path or uri ) throw i o exception { uri uri = parse u r i ( path or uri ) ; string host = get host ( ) ; int port = get port ( ) ; string user = get user ( ) ; string user password = get user password ( ) ; if ( uri ! = null & & uri . get scheme ( ) ! = null ) { if ( uri . get host ( ) ! = null ) { host = uri . get host ( ) ; } if ( uri . get port ( ) ! = -1 ) { port = uri . get port ( ) ; } if ( uri . get user info ( ) ! = null ) { string user info = uri . get user info ( ) ; if ( user info . index of ( `` : `` ) == -1 ) { user = user info ; } else { user = user info . substring ( 0 , user info . index of ( `` : `` ) ) ; user password = user info . substring ( user info . index of ( `` : `` ) + 1 ) ; } } } if ( host == null ) { throw new illegal argument exception ( `` miss host information . host should be provide either `` + `` directly on the repository or in the connection uri `` ) ; } if ( user == null ) { credential c = request credential ( host ) ; if ( c ! = null ) { user = c . get user name ( ) ; user password = c . get passwd ( ) ; } else { message . error ( `` username be not set `` ) ; } } return ssh cache . get instance ( ) . get session ( host , port , user , user password , get key file ( ) , get key file password ( ) , get pas file ( ) ) ; }
public list get child ( ) { init ( ) ; array list list = new array list ( ) ; try { if ( ( resource impl ! = null ) & & resource impl . exists ( ) & & ( resource impl . get type ( ) == file type . folder ) ) { file object [ ] child = resource impl . get child ( ) ; for ( int i = 0 ; i < child . length ; i++ ) { file object child = child [ i ] ; list . add ( normalize ( child . get name ( ) . get u r i ( ) ) ) ; } } } catch ( i o exception e ) { message . verbose ( e . get localized message ( ) ) ; } return list ; }
public void abort publish transaction ( ) throw i o exception { / * default implementation be a no-op * / }
public void set key file password ( string password ) { get ssh base repository ( ) . set key file password ( password ) ; }
public void set port ( int port ) { get ssh base repository ( ) . set port ( port ) ; }
protect collection filter name ( collection names ) { get setting ( ) . filter ignore ( name ) ; return name ; }
public synchronize boolean be build ( ) { return this . build ; }
public void set resource u r l ( string resource u r l ) { this . resource u r l = resource u r l ; }
public void set restrict ( boolean restrict ) { this . restrict = restrict ; }
public void set file separator ( string sep ) { if ( sep == null || sep . length ( ) ! = 1 ) { throw new illegal argument exception ( `` file separator have to be a single character and not `` + sep ) ; } ( ( ssh repository ) get repository ( ) ) . set file separator ( sep . trim ( ) . char at ( 0 ) ) ; }
public static boolean force delete ( file file ) { if ( ! file . exists ( ) ) { return true ; } if ( file . be directory ( ) ) { file [ ] file = file . list file ( ) ; if ( file ! = null ) { for ( int i = 0 ; i < file . length ; i++ ) { if ( ! force delete ( file [ i ] ) ) { return false ; } } } } return file . delete ( ) ; }
public boolean have ( int index ) { return get ( index ) ! = null ; }
public int contain type count ( ) { return 0 ; }
public string contain type name ( int index ) { return null ; }
public set < property name > find explicit name ( ) { set < property name > rename = null ; rename = _find explicit name ( _fields , rename ) ; rename = _find explicit name ( _getters , rename ) ; rename = _find explicit name ( _setters , rename ) ; rename = _find explicit name ( _ctor parameter , rename ) ; if ( rename == null ) { return collection . empty set ( ) ; } return rename ; }
public void write type prefix for object ( object value , json generator jgen , class < ? > type ) throw i o exception { write type prefix for object ( value , jgen ) ; }
public json include . include find inclusion ( ) { return null ; }
protect unsupported operation exception _not support ( ) { return new unsupported operation exception ( ) ; }
public json generator use default pretty printer ( ) { return this ; }
public void write start array ( int size ) throw i o exception { _verify value write ( `` start an array `` ) ; _write context = _write context . create child array context ( ) ; / * if ( size > = 31 || size < 0 ) { _write byte ( byte_array_indefinite ) ; } else { } * / _write byte ( byte_array_indefinite ) ; }
public final void add or override ( annotation a ) { _annotations . add ( a ) ; }
public boolean any explicit name ( ) { return _any explicit name ( _fields ) || _any explicit name ( _getters ) || _any explicit name ( _setters ) || _any explicit name ( _ctor parameter ) ; }
public final serializer factory with serializer modifier ( bean serializer modifier modifier ) { return with config ( get config ( ) . with serializer modifier ( modifier ) ) ; }
@ override public json token a token ( ) { return json token . start_array ; }
public entry list get slice ( key slice query query , store transaction txh ) throw backend exception { map < static buffer , entry list > result = get name slice ( query . get key ( ) , query , txh ) ; return iterables . get only element ( result . value ( ) , entry list . empty_list ) ; }
public int size ( ) { return helper . size ( shape ) ; }
public static geoshape point ( final double latitude , final double longitude ) { precondition . check argument ( be valid coordinate ( latitude , longitude ) , `` invalid coordinate provide `` ) ; return new geoshape ( get shape factory ( ) . point x y ( longitude , latitude ) ) ; }
public static boolean be valid coordinate ( final double latitude , final double longitude ) { return latitude > =-90 . 0 & & latitude < =90 . 0 & & longitude > =-180 . 0 & & longitude < =180 . 0 ; }
protect string get single hostname ( ) { return hostnames [ random . next int ( hostnames . length ) ] ; }
public void deletion ( k key ) { if ( deletions==null ) deletion = new array list < > ( ) ; deletion . add ( key ) ; }
public static static buffer get int buffer ( int id ) { byte buffer buffer = byte buffer . allocate ( int size ) ; buffer . put int ( id ) ; byte [ ] arr = buffer . array ( ) ; precondition . check argument ( arr . length == int size ) ; return static array buffer . of ( arr ) ; }
public q no partition restriction ( ) { this . restrict2 partition = false ; return get this ( ) ; }
public q query only load ( ) { query only loaded=true ; return get this ( ) ; }
protect final void verify access ( ) { }
public final t update top ( ) { down heap ( ) ; return heap [ 1 ] ; }
public static long sortable double bit ( long bit ) { return bit ^ ( bit > > 63 ) & 0x7fffffffffffffff l ; }
public x m l builder import x m l builder ( x m l builder builder ) { assert element contain no or whitespace only text node ( this . xml node ) ; node import node = get document ( ) . import node ( builder . root ( ) . get element ( ) , true ) ; this . xml node . append child ( imported node ) ; return this ; }
public x m l builder cdata ( string data ) { xml node . append child ( get document ( ) . create c d a t a section ( data ) ) ; return this ; }
public abstract lat lon box add to abstract lat lon box simple extension ( final object abstract lat lon box simple extension ) { this . get abstract lat lon box simple extension ( ) . add ( abstract lat lon box simple extension ) ; return this ; }
public abstract view add to abstract view simple extension ( final object abstract view simple extension ) { this . get abstract view simple extension ( ) . add ( abstract view simple extension ) ; return this ; }
public void set abstract view object extension ( final list < abstract object > abstract view object extension ) { this . abstract view object extension = abstract view object extension ; }
public abstract view add to abstract view object extension ( final abstract object abstract view object extension ) { this . get abstract view object extension ( ) . add ( abstract view object extension ) ; return this ; }
public void set basic link simple extension ( final list < object > basic link simple extension ) { this . basic link simple extension = basic link simple extension ; }
public camera add to camera object extension ( final abstract object camera object extension ) { this . get camera object extension ( ) . add ( camera object extension ) ; return this ; }
public document add to document simple extension ( final object document simple extension ) { this . get document simple extension ( ) . add ( document simple extension ) ; return this ; }
public document add to document object extension ( final abstract object document object extension ) { this . get document object extension ( ) . add ( document object extension ) ; return this ; }
public ground overlay add to grind overlay simple extension ( final object ground overlay simple extension ) { this . get ground overlay simple extension ( ) . add ( ground overlay simple extension ) ; return this ; }
public ground overlay add to grind overlay object extension ( final abstract object ground overlay object extension ) { this . get ground overlay object extension ( ) . add ( ground overlay object extension ) ; return this ; }
public lat lon quad add to coordinate ( final double longitude , final double latitude ) { this . get coordinate ( ) . add ( new coordinate ( longitude , latitude ) ) ; return this ; }
public icon style add to icon style object extension ( final abstract object icon style object extension ) { this . get icon style object extension ( ) . add ( icon style object extension ) ; return this ; }
public look at add to look at simple extension ( final object look at simple extension ) { this . get look at simple extension ( ) . add ( look at simple extension ) ; return this ; }
public point add to point simple extension ( final object point simple extension ) { this . get point simple extension ( ) . add ( point simple extension ) ; return this ; }
public schema add to schema extension ( final object schema extension ) { this . get schema extension ( ) . add ( schema extension ) ; return this ; }
public style map add to style map simple extension ( final object style map simple extension ) { this . get style map simple extension ( ) . add ( style map simple extension ) ; return this ; }
public style map add to style map object extension ( final abstract object style map object extension ) { this . get style map object extension ( ) . add ( style map object extension ) ; return this ; }
public time stamp add to time stamp simple extension ( final object time stamp simple extension ) { this . get time stamp simple extension ( ) . add ( time stamp simple extension ) ; return this ; }
public update add to create or delete or change ( final object create or delete or change ) { this . get create or delete or change ( ) . add ( create or delete or change ) ; return this ; }
public view volume add to view volume simple extension ( final object view volume simple extension ) { this . get view volume simple extension ( ) . add ( view volume simple extension ) ; return this ; }
public void set dependent locality name ( final list < dependent locality . dependent locality name > dependent locality name ) { this . dependent locality name = dependent locality name ; }
public void set large mail user name ( final list < large mail user . large mail user name > large mail user name ) { this . large mail user name = large mail user name ; }
public postal route add to postal route name ( final postal route . postal route name postal route name ) { this . get postal route name ( ) . add ( postal route name ) ; return this ; }
public void set premise name ( final list < premise . premise name > premise name ) { this . premise name = premise name ; }
public premise add to premise name ( final premise . premise name premise name ) { this . get premise name ( ) . add ( premise name ) ; return this ; }
public premise add to premise number suffix ( final premise number suffix premise number suffix ) { this . get premise number suffix ( ) . add ( premise number suffix ) ; return this ; }
public void add word ( final long new data ) { this . one bits += long . bit count ( new data ) ; }
public void clear ( int start , int end ) { if ( start == end ) return ; int firstword = start / 64 ; int endword = ( end - 1 ) / 64 ; if ( firstword == endword ) { this . data [ firstword ] & = ~ ( ( ~0l < < start ) & ( ~0l > > > -end ) ) ; return ; } this . data [ firstword ] & = ~ ( ~0l < < start ) ; for ( int i = firstword+1 ; i < endword ; i++ ) this . data [ i ] = 0 ; this . data [ endword ] & = ~ ( ~0l > > > -end ) ; }
public boolean intersects ( word array b ) { for ( int k = 0 ; k < math . min ( this . get number of word ( ) , b . get number of word ( ) ) ; ++k ) { if ( ( this . get word ( k ) & b . get word ( k ) ) ! = 0 ) return true ; } return false ; }
public int next unset bit ( final int i ) { int x = i / 64 ; if ( x > = this . get number of word ( ) ) return -1 ; long w = ~this . data [ x ] ; w > > > = i ; if ( w ! = 0 ) { return i + long . number of trail zero ( w ) ; } ++x ; for ( ; x < this . get number of word ( ) ; ++x ) { if ( this . data [ x ] ! = ~0 ) { return x * 64 + long . number of trail zero ( ~this . data [ x ] ) ; } } return -1 ; }
public int orcardinality ( word array b ) { int sum = 0 ; for ( int k = 0 ; k < math . min ( this . get number of word ( ) , b . get number of word ( ) ) ; ++k ) { sum += long . bit count ( this . get word ( k ) | b . get word ( k ) ) ; } word array longer = b . get number of word ( ) < this . get number of word ( ) ? this : b ; for ( int k = math . min ( this . get number of word ( ) , b . get number of word ( ) ) ; k < math . max ( this . get number of word ( ) , b . get number of word ( ) ) ; ++k ) { sum += long . bit count ( longer . get word ( k ) ) ; } return sum ; }
public void resize ( int size in bit ) { this . data = array . copy of ( this . data , ( size in bit + 63 ) / 64 ) ; }
public void set ( int start , int end ) { if ( start == end ) return ; int firstword = start / 64 ; int endword = ( end - 1 ) / 64 ; if ( firstword == endword ) { this . data [ firstword ] |= ( ~0l < < start ) & ( ~0l > > > -end ) ; return ; } this . data [ firstword ] |= ~0l < < start ; for ( int i = firstword+1 ; i < endword ; i++ ) this . data [ i ] = ~0 ; this . data [ endword ] |= ~0l > > > -end ; }
public int size ( ) { return this . get number of word ( ) * 64 ; }
public void unset ( final int i ) { this . data [ i / 64 ] & = ~ ( 1l < < ( i % 64 ) ) ; }
public void percolate down ( ) { percolate down ( 1 ) ; }
public void or to container ( final e w a h compress bitmap a , final bitmap storage container ) { container . clear ( ) ; final e w a h iterator i = a . get e w a h iterator ( ) ; final e w a h iterator j = get e w a h iterator ( ) ; final iterating buffer run length word rlwi = new iterating buffer run length word ( i ) ; final iterating buffer run length word rlwj = new iterating buffer run length word ( j ) ; while ( ( rlwi . size ( ) > 0 ) & & ( rlwj . size ( ) > 0 ) ) { while ( ( rlwi . get running length ( ) > 0 ) || ( rlwj . get running length ( ) > 0 ) ) { final boolean i_is_prey = rlwi . get running length ( ) < rlwj . get running length ( ) ; final iterating buffer run length word prey = i_is_prey ? rlwi : rlwj ; final iterating buffer run length word predator = i_is_prey ? rlwj : rlwi ; if ( predator . get running bit ( ) ) { container . add stream of empty word ( true , predator . get running length ( ) ) ; prey . discard first word ( predator . get running length ( ) ) ; } else { final long index = prey . discharge ( container , predator . get running length ( ) ) ; container . add stream of empty word ( false , predator . get running length ( ) - index ) ; } predator . discard run word ( ) ; } final int nbre_literal = math . min ( rlwi . get number of literal word ( ) , rlwj . get number of literal word ( ) ) ; if ( nbre_literal > 0 ) { for ( int k = 0 ; k < nbre_literal ; ++k ) { container . add word ( rlwi . get literal word at ( k ) | rlwj . get literal word at ( k ) ) ; } rlwi . discard first word ( nbre_literal ) ; rlwj . discard first word ( nbre_literal ) ; } } final boolean i_remains = rlwi . size ( ) > 0 ; final iterating buffer run length word remain = i_remains ? rlwi : rlwj ; remain . discharge ( container ) ; container . set size in bit within last word ( math . max ( size in bit ( ) , a . size in bit ( ) ) ) ; }
public boolean clear ( final int i ) { return set ( i , false ) ; }
public boolean set size in bit ( final int size , final boolean default value ) { if ( size < = this . size in bit ) { return false ; } if ( ( this . size in bit % word_in_bits ) ! = 0 ) { if ( ! default value ) { if ( this . rlw . get number of literal word ( ) > 0 ) { final int bit to add = size - this . size in bit ; final int use bit in last = this . size in bit % word_in_bits ; final int free bit in last = word_in_bits - use bit in last ; if ( this . buffer . get last word ( ) == 0l ) { this . rlw . set number of literal word ( this . rlw . get number of literal word ( ) - 1 ) ; this . buffer . remove last word ( ) ; this . size in bit -= use bit in last ; } else if ( use bit in last > 0 ) { this . size in bit += math . min ( bit to add , free bit in last ) ; } } } else { if ( this . rlw . get number of literal word ( ) == 0 ) { this . rlw . set run length ( this . rlw . get running length ( ) - 1 ) ; insert literal word ( 0 ) ; } final int mask width = math . min ( word_in_bits - this . size in bit % word_in_bits , size - this . size in bit ) ; final int mask shift = this . size in bit % word_in_bits ; final long mask = ( ( ~0l ) > > > ( word_in_bits - mask width ) ) < < mask shift ; this . buffer . or last word ( mask ) ; if ( this . buffer . get last word ( ) == ~0l ) { this . buffer . remove last word ( ) ; this . rlw . set number of literal word ( this . rlw . get number of literal word ( ) - 1 ) ; insert empty word ( true ) ; } this . size in bit += mask width ; } } this . add stream of empty word ( default value , ( size / word_in_bits ) - ( this . size in bit / word_in_bits ) ) ; if ( this . size in bit < size ) { final int dist = distance in word ( size - 1 ) ; if ( dist > 0 ) { insert literal word ( 0 ) ; } if ( default value ) { final int mask width = size - this . size in bit ; final int mask shift = this . size in bit % word_in_bits ; final long mask = ( ( ~0l ) > > > ( word_in_bits - mask width ) ) < < mask shift ; this . buffer . or last word ( mask ) ; } this . size in bit = size ; } return true ; }
public static e w a h compress bitmap threshold ( final int t , final e w a h compressed bitmap . . . bitmap ) { final e w a h compress bitmap container = new e w a h compress bitmap ( ) ; threshold with container ( container , t , bitmap ) ; return container ; }
public int xor cardinality ( final e w a h compress bitmap a ) { final bit counter counter = new bit counter ( ) ; xor to container ( a , counter ) ; return counter . get count ( ) ; }
public static e w a h compress bitmap bitmap of ( int . . . set bit ) { e w a h compress bitmap a = new e w a h compress bitmap ( ) ; for ( int k : set bit ) a . set ( k ) ; return a ; }
public static e w a h compress bitmap bufferedand ( final int buf size , final e w a h compressed bitmap . . . bitmap ) { e w a h compressed bitmap answer = new e w a h compress bitmap ( ) ; bufferedand with container ( answer , buf size , bitmap ) ; return answer ; }
public void discharge a empty ( bitmap storage container ) { while ( size ( ) > 0 ) { container . add stream of empty word ( false , size ( ) ) ; discard first word ( size ( ) ) ; } }
public void discharge ( bitmap storage container ) { this . brlw . literal word offset = this . literal word start position - this . iterator . literal word ( ) ; discharge ( this . brlw , this . iterator , container ) ; }
public final void fill with literal ( final list < e w a h pointer > container ) { for ( int k = this . litwlist . next set bit ( 0 ) ; k > = 0 ; k = this . litwlist . next set bit ( k + 1 ) ) { container . add ( this . rw [ k ] ) ; } }
public static long materialize ( final iterating r l w32 i , final bitmap storage32 c , int max ) { final int orig max = max ; while ( true ) { if ( i . get running length ( ) > 0 ) { int l = i . get running length ( ) ; if ( l > max ) l = max ; c . add stream of empty word ( i . get running bit ( ) , l ) ; max -= l ; } long l = i . get number of literal word ( ) ; for ( int k = 0 ; k < l ; ++k ) c . add word ( i . get literal word at ( k ) ) ; if ( max > 0 ) { if ( ! i . next ( ) ) break ; } else break ; } return orig max - max ; }
public string get name ( ) { return this . name ; }
public inner type def variable get upper bound ( ) { return this . upper bound ; }
public string get signature ( ) { return get const pool ( ) . get utf8 info ( byte array . read u16bit ( get ( ) , 0 ) ) ; }
protect void visit j s r ( int po , byte [ ] code ) throw bad bytecode { throw bad bytecode ( po , `` jsr `` ) ; }
public method info get method info ( ) { declare class . check modify ( ) ; return method info ; }
public static boolean be private ( int mod ) { return ( mod & private ) ! = 0 ; }
public static boolean be protect ( int mod ) { return ( mod & protect ) ! = 0 ; }
public void add bean name resolver ( bean name resolver bnr ) { get e l context ( ) . add e l resolver ( new bean name e l resolver ( bnr ) ) ; }
public void add e l resolver ( e l resolver elr ) { get e l context ( ) . add e l resolver ( elr ) ; }
public object eval ( string expression ) { return get value ( expression , object . class ) ; }
public class < ? > get common property type ( e l context context , object base ) { if ( base instanceof resource bundle ) { return string . class ; } return null ; }
public static json object builder create object builder ( ) { return json provider . provider ( ) . create object builder ( ) ; }
public byte [ ] digest ( byte [ ] in ) { impl reset ( ) ; engine update ( in , 0 , in . length ) ; byte [ ] out = new byte [ 16 ] ; impl digest ( out , 0 ) ; return out ; }
public argument write n string ( string s ) { if ( s == null ) item . add ( new n string ( null ) ) ; else item . add ( new n string ( a s c i i utility . get byte ( s ) ) ) ; return this ; }
public void add response handler ( response handler h ) { handler . add ( h ) ; }
public synchronize void stop ( ) { die = true ; logger . fine ( `` idle manager stop `` ) ; selector . wakeup ( ) ; }
protect void check close ( ) { if ( open ) throw new illegal state exception ( `` this operation be not allow on an open folder `` ) ; }
public quota [ ] get quota ( ) throw message exception { return ( quota [ ] ) do optional command ( `` quota not support `` , new protocol command ( ) { @ override public object do command ( i m a p protocol p ) throw protocol exception { return p . get quota root ( full name ) ; } } ) ; }
public void add right ( acl acl ) throw message exception { set a c l ( acl , '+ ' ) ; }
public right [ ] list right ( final string name ) throw message exception { return ( right [ ] ) do optional command ( `` acl not support `` , new protocol command ( ) { @ override public object do command ( i m a p protocol p ) throw protocol exception { return p . list right ( full name , name ) ; } } ) ; }
public string [ ] get content language ( ) throw message exception { check expunge ( ) ; if ( body load ) return super . get content language ( ) ; load b o d y s t r u c t u r e ( ) ; if ( b . language ! = null ) return b . language . clone ( ) ; else return null ; }
public string get in reply to ( ) throw message exception { check expunge ( ) ; if ( body load ) return super . get header ( `` in- reply- to `` , `` `` ) ; load envelope ( ) ; return envelope . in reply to ; }
public string get proxy auth user ( ) { return proxy auth user ; }
protect i m a p folder new i m a p folder ( string full name , char separator ) { return new i m a p folder ( full name , separator , null ) ; }
public int seqnum of ( int msgnum ) { if ( seqnums == null ) return msgnum ; else { if ( logger . be loggable ( level . fine ) ) logger . fine ( `` msgnum `` + msgnum + `` be seqnum `` + seqnums [ msgnum-1 ] ) ; return seqnums [ msgnum-1 ] ; } }
public static < t extend item > list < t > get item ( response [ ] r , int msgno , class < t > c ) { list < t > item = new array list < > ( ) ; if ( r == null ) return item ; for ( int i = 0 ; i < r . length ; i++ ) { if ( r [ i ] == null || ! ( r [ i ] instanceof fetch response ) || ( ( fetch response ) r [ i ] ) . get number ( ) ! = msgno ) continue ; fetch response f = ( fetch response ) r [ i ] ; for ( int j = 0 ; j < f . item . length ; j++ ) { if ( c . be instance ( f . item [ j ] ) ) item . add ( c . cast ( f . item [ j ] ) ) ; } } return item ; }
public boolean be r e v1 ( ) { return rev1 ; }
public string get proxy auth user ( ) { return proxy auth user ; }
public body fetch body ( int msgno , string section , int start , int size ) throw protocol exception { return fetch body ( msgno , section , start , size , false , null ) ; }
public void fetch sequence number ( long [ ] uids ) throw protocol exception { string buffer sb = new string buffer ( ) ; for ( int i = 0 ; i < uids . length ; i++ ) { if ( i > 0 ) sb . append ( `` , `` ) ; sb . append ( string . value of ( uids [ i ] ) ) ; } response [ ] r = fetch ( sb . to string ( ) , `` uid `` , true ) ; notify response handler ( r ) ; handle result ( r [ r . length-1 ] ) ; }
public string get text ( ) { return text ; }
public void remove ( right right ) { for ( int i = 0 ; i < right . right . length ; i++ ) if ( right . right [ i ] ) this . right [ i ] = false ; }
public synchronize int get message count ( ) throw message exception { if ( ! open ) return -1 ; check readable ( ) ; return total ; }
protect void finalize ( ) throw throwable { force close = ! store . finalize clean close ; try { if ( open ) close ( false ) ; } finally { super . finalize ( ) ; force close = false ; } }
public folder get folder ( string name ) throw message exception { check connect ( ) ; return new p o p3 folder ( this , name ) ; }
public int get return code ( ) { return rc ; }
public void set mail extension ( string extension ) { this . extension = extension ; }
public void write ( byte b [ ] , int off , int len ) throw i o exception { int lastc = ( lastb == -1 ) ? '\n ' : lastb ; int start = off ; len += off ; for ( int i = off ; i < len ; i++ ) { if ( ( lastc == '\n ' || lastc == '\r ' ) & & b [ i ] == ' . ' ) { super . write ( b , start , i - start ) ; out . write ( ' . ' ) ; start = i ; } lastc = b [ i ] ; } if ( ( len - start ) > 0 ) super . write ( b , start , len - start ) ; }
public final synchronize level get push level ( ) { return this . push level ; }
public final synchronize comparator < ? super log record > get comparator ( ) { return this . comparator ; }
public final void set subject ( final string subject ) { if ( subject ! = null ) { this . set subject ( tail name formatter . of ( subject ) ) ; } else { check access ( ) ; throw new null pointer exception ( ) ; } }
public int get port ( ) { return port ; }
public mail logger get logger ( string name , string prefix ) { return new mail logger ( name , prefix , debug , out ) ; }
public void fine ( string msg ) { log ( level . fine , msg ) ; }
public void set trace ( boolean trace ) { this . trace = trace ; }
public int get mode ( ) throw i o exception { read prefix ( ) ; return mode ; }
public void set name mode ( string name , int mode ) { this . name = name ; this . mode = mode ; }
public message get message ( ) { return msg ; }
public message [ ] get message ( ) { return msg ; }
public item [ ] get item ( ) { if ( special == null ) return new item [ 0 ] ; item [ ] s = new item [ special . size ( ) ] ; special . copy into ( s ) ; return s ; }
public boolean contains ( string flag ) { if ( user_flags == null ) return false ; else return user_flags . contains key ( flag . to lower case ( locale . english ) ) ; }
protect void notify folder rename listener ( folder folder ) { if ( folder listener ! = null ) { folder event e = new folder event ( this , this , folder , folder event . rename ) ; queue event ( e , folder listener ) ; } store . notify folder rename listener ( this , folder ) ; }
public parameter list get parameter list ( ) { return list ; }
public string get base type ( ) { if ( primary type == null || sub type == null ) return `` `` ; return primary type + '/ ' + sub type ; }
public string get header ( string name , string delimiter ) { string s [ ] = get header ( name ) ; if ( s == null ) return null ; if ( ( s . length == 1 ) || delimiter == null ) return s [ 0 ] ; string buffer r = new string buffer ( s [ 0 ] ) ; for ( int i = 1 ; i < s . length ; i++ ) { r . append ( delimiter ) ; r . append ( s [ i ] ) ; } return r . to string ( ) ; }
public enumeration < string > get non match header line ( string [ ] names ) { return ( new match string enum ( header , name , false ) ) ; }
public synchronize flag get flag ( ) throw message exception { return ( flag ) flag . clone ( ) ; }
public string to string ( ) { return to string ( 0 ) ; }
public string get encode ( ) throw message exception { return encode ; }
public boolean be expunge ( ) { return expunge ; }
public string get class name ( ) { return class name ; }
public address get address ( ) { return address ; }
public void connect ( string host , string user , string password ) throw message exception { connect ( host , -1 , user , password ) ; }
public store get store ( ) throw no such provider exception { return get store ( get property ( `` mail . store . protocol `` ) ) ; }
public password authentication get password authentication ( u r l name url ) { return auth table . get ( url ) ; }
public folder [ ] get personal namespaces ( ) throw message exception { return new folder [ ] { get default folder ( ) } ; }
protect void notify folder rename listener ( folder old f , folder new f ) { if ( folder listener == null ) return ; folder event e = new folder event ( this , old f , new f , folder event . rename ) ; queue event ( e , folder listener ) ; }
public synchronize void add transport listener ( transport listener l ) { if ( transport listener == null ) transport listener = new vector < > ( ) ; transport listener . add element ( l ) ; }
public boolean be x o p package ( ) { return false ; }
public synchronize com . sun . msv . grammar . grammar get grammar ( ) throw j a x b exception { if ( grammar==null ) grammar = gi . get grammar ( ) ; return grammar ; }
public j block assign ( j assignment target lh , j expression exp ) { insert ( new j assignment ( lhs , exp ) ) ; return this ; }
public j switch _switch ( j expression test ) { return insert ( new j switch ( test ) ) ; }
public void _return ( ) { insert ( new j return ( null ) ) ; }
public j define class _class ( string fullyqualified name ) throw j class already exist exception { return _class ( fullyqualified name , class type . class ) ; }
public void build ( file d dir ) throw i o exception { build ( d dir , system . out ) ; }
public j block _else ( ) { if ( _else == null ) _else = new j block ( ) ; return _else ; }
public collection < j method > method ( ) { return method ; }
public j doc comment javadoc ( ) { if ( jdoc == null ) jdoc = new j doc comment ( owner ( ) ) ; return jdoc ; }
public static j expression _super ( ) { return __super ; }
public void name ( string n ) { this . name = n ; }
public iterator property file ( ) { return resource . iterator ( ) ; }
public final boolean be unnamed ( ) { return name . length ( ) == 0 ; }
public j type erasure ( ) { return this ; }
public j type var bound ( j class c ) { if ( bound ! =null ) throw new illegal argument exception ( `` type variable have an exist class bound `` +bound ) ; bind = c ; return this ; }
protect catalog new catalog ( ) { string catalog class = this . get class ( ) . get name ( ) ; try { catalog c = ( catalog ) ( class . for name ( catalog class ) . new instance ( ) ) ; c . set catalog manager ( catalog manager ) ; copy reader ( c ) ; return c ; } catch ( class not find exception cnfe ) { catalog manager . debug . message ( 1 , `` class not find exception : `` + catalog class ) ; } catch ( illegal access exception iae ) { catalog manager . debug . message ( 1 , `` illegal access exception : `` + catalog class ) ; } catch ( instantiation exception ie ) { catalog manager . debug . message ( 1 , `` instantiation exception : `` + catalog class ) ; } catch ( class cast exception cce ) { catalog manager . debug . message ( 1 , `` class cast exception : `` + catalog class ) ; } catch ( exception e ) { catalog manager . debug . message ( 1 , `` other exception : `` + catalog class ) ; } catalog c = new catalog ( ) ; c . set catalog manager ( catalog manager ) ; copy reader ( c ) ; return c ; }
public static url make u r l ( string pathname ) throw malformed u r l exception { if ( pathname . start with ( `` / `` ) ) { return new url ( `` file : // `` + pathname ) ; } string userdir = system . get property ( `` user . dir `` ) ; userdir . replace ( '\\ ' , '/ ' ) ; if ( userdir . end with ( `` / `` ) ) { return new url ( `` file : /// `` + userdir + pathname ) ; } else { return new url ( `` file : /// `` + userdir + `` / `` + pathname ) ; } }
public catalog get catalog ( ) { return catalog resolver . get catalog ( ) ; }
public catalog get catalog ( ) { return catalog resolver . get catalog ( ) ; }
public void on enter element consume ( string uri , string local name , string qname , attribute atts ) throw s a x exception { att stack . push ( current atts=new attribute impl ( atts ) ) ; n effective stack . push ( new integer ( ns effective ptr ) ) ; n effective ptr = namespaces . size ( ) ; }
public boolean have class ( ) { return class name ! =null ; }
public void set name ( boolean be public , string new name ) { if ( be public ) public name = new name ; else private name = new name ; }
public q name get xml name ( ) { return null ; }
public void add grammar ( input source be ) { grammar . add ( absolutize ( be ) ) ; }
public final class outline get super class ( ) { c class info s = target . get base class ( ) ; if ( s==null ) return null ; return parent ( ) . get clazz ( s ) ; }
protect final boolean be support extension ( string namespace uri ) { return namespace uri . equal ( const . xjc_extension_uri ) || option . plugin u r be . contains ( namespace uri ) ; }
public static void set location info ( element e , locator loc ) { e . set attribute n s ( location namespace , `` loc : `` +system id , loc . get system id ( ) ) ; e . set attribute n s ( location namespace , `` loc : `` +column , integer . to string ( loc . get line number ( ) ) ) ; e . set attribute n s ( location namespace , `` loc : `` +line , integer . to string ( loc . get column number ( ) ) ) ; }
public string to string ( ) { string s = element . to string ( ) ; if ( be require ( ) ) s += ' ! ' ; if ( be collection ( ) ) s += ' * ' ; return s ; }
public string to string ( ) { return `` # sink `` ; }
public document [ ] list document ( ) { return core . value ( ) . to array ( new document [ core . size ( ) ] ) ; }
public void simple type ( x s simple type type ) { throw new illegal state exception ( ) ; }
public b g m builder get builder ( ) { return builder ; }
public c type info bind to type ( x s component sc , x s component referer ) { return _bind to class ( sc , referer , false ) ; }
public void set stack size ( string s ) { try { stack size = long . parse long ( s ) ; return ; } catch ( number format exception e ) { ; } if ( s . length ( ) > 2 ) { string head = s . substring ( 0 , s . length ( ) -2 ) ; string tail = s . substring ( s . length ( ) -2 ) ; if ( tail . equal ignore case ( `` kb `` ) ) { try { stack size = long . parse long ( head ) * 1024 ; return ; } catch ( number format exception ee ) { ; } } if ( tail . equal ignore case ( `` mb `` ) ) { try { stack size = long . parse long ( head ) * 1024 * 1024 ; return ; } catch ( number format exception ee ) { ; } } } throw new build exception ( `` unrecognizable stack size : `` +ss ) ; }
public void set readonly ( boolean flg ) { this . option . read only = flg ; }
public void set locale ( locale l ) throw s a x exception { if ( l ! = null & & ! message . be locale support ( l . to string ( ) ) ) { throw new s a x exception ( message . get message ( locale , `` p-078 `` , new object [ ] { l } ) ) ; } locale = l ; }
public void set dtd handler ( d t d event listener handler ) { dtd handler = handler ; if ( handler ! = null ) handler . set document locator ( new locator ( ) { public string get public id ( ) { return d t d parser . this . get public id ( ) ; } public string get system id ( ) { return d t d parser . this . get system id ( ) ; } public int get line number ( ) { return d t d parser . this . get line number ( ) ; } public int get column number ( ) { return d t d parser . this . get column number ( ) ; } } ) ; }
public locale choose locale ( string language [ ] ) { if ( ( languages = canonicalize ( language ) ) ! = null ) { for ( int i = 0 ; i < language . length ; i++ ) if ( be locale supported ( languages [ i ] ) ) return get locale ( languages [ i ] ) ; } return null ; }
public int size ( ) { return count ; }
public boolean have more element ( ) { if ( current ! = null ) return true ; while ( current bucket < table . length ) { current = table [ current bucket++ ] ; if ( current ! = null ) return true ; } return false ; }
public void add attribute use ( u name name , attribute use impl a ) { attribute . put ( name , a ) ; }
public void add patcher ( patch patcher ) { parser . patcher manager . add patcher ( patcher ) ; }
public schema impl create schema ( string target namespace , locator location ) { schema impl obj = ( schema impl ) schema . get ( target namespace ) ; if ( obj == null ) { obj = new schema impl ( this , location , target namespace ) ; schemas . put ( target namespace , obj ) ; schemas2 . add ( obj ) ; } return obj ; }
public x s schema set get result ( ) throw s a x exception { return context . get result ( ) ; }
public final x s component select single ( x s schema set context node ) { iterator < x s component > r = select ( context node . iterate schema ( ) ) ; if ( r . have next ( ) ) return r . next ( ) ; return null ; }
public class method add method ( method method ) { class method class method = add method ( method . get modifier ( ) & ( ~ access flag . abstract ) & ( ~ access flag . native ) , method . get name ( ) , descriptor utils . make descriptor ( method . get return type ( ) ) , descriptor utils . parameter descriptor ( method . get parameter type ( ) ) ) ; for ( class < ? > e : method . get exception type ( ) ) { class method . add checked exception ( ( class < ? extend exception > ) e ) ; } for ( annotation annotation : method . get declared annotation ( ) ) { class method . get runtime visible annotation attribute ( ) . add annotation ( annotation builder . create annotation ( const pool , annotation ) ) ; } int count = 0 ; for ( annotation [ ] parameter annotation : method . get parameter annotation ( ) ) { for ( annotation annotation : parameter annotation ) { class method . get runtime visible parameter annotation attribute ( ) . add annotation ( count , annotation builder . create annotation ( const pool , annotation ) ) ; } count++ ; } return class method ; }
public class < ? > define ( class loader loader , protection domain domain ) { return define internal ( loader , domain ) ; }
public stack frame push ( string type ) { stack state ns = stack state . push ( type ) ; return new stack frame ( ns , local variable state , type no local change ( ns ) ) ; }
public stack frame push ( stack entry entry ) { stack state ns = stack state . push ( entry ) ; return new stack frame ( ns , local variable state , type no local change ( ns ) ) ; }
public stack frame pop ( ) { stack state ns = stack state . pop ( 1 ) ; return new stack frame ( ns , local variable state , type no local change ( ns ) ) ; }
public int get slot ( ) { return slot ; }
public long get native window ( ) { return id ; }
protect void _enter modal ( long ptr ) { throw new unsupported operation exception ( ) ; }
public void page wait ( ) { try { synchronize ( lock . validate ( ) ) { remote . page wait ( ) ; } } catch ( throwable t ) { util . handle exception ( t ) ; } }
public void set color ( final string col ) { for ( final string item : col . split ( multicolor layout . split_items ) ) { final string [ ] value = item . split ( multicolor layout . split_values ) ; this . color . put ( value [ 0 ] , value [ 1 ] ) ; } / * * * if set conversion pattern be call before me must call again * to be sure to replace all custom color constant with * new value . * / if ( this . base ! = null ) { this . set conversion pattern ( this . base ) ; } }
public boolean have attribute ( ) { return attribute ! = null & & ! attribute . be empty ( ) ; }
public boolean have additional namespaces ( ) { return additional namespaces ! = null & & ! additional namespaces . be empty ( ) ; }
public void sort attribute ( comparator < ? super attribute > comparator ) { if ( attribute ! = null ) { attribute . sort ( comparator ) ; } }
public void error ( s a x parse exception exception ) throw s a x exception { throw exception ; }
public void set ignore element content whitespace ( final boolean ignore white ) { this . ignore white = ignore white ; engine = null ; }
public org . w3c . dom . c d a t a section output ( cdata cdata ) throw j d o m exception { return processor . process ( adapter . create document ( ) , format , cdata ) ; }
public iterable < namespace > add forward ( ) { if ( added [ depth ] . length == 0 ) { return emptyiter ; } return new namespace iterable ( added [ depth ] , true ) ; }
public iterable < namespace > add reverse ( ) { if ( added [ depth ] . length == 0 ) { return emptyiter ; } return new namespace iterable ( added [ depth ] , false ) ; }
public static boolean be x m l letter ( final char c ) { return ( byte ) 0 ! = ( byte ) ( charflags [ c ] & maskxmlletter ) ; }
public object get variable ( string qname ) { if ( qname == null ) { throw new null pointer exception ( `` null qname `` ) ; } if ( variable == null ) { return null ; } return variable . get ( qname ) ; }
public client request adapter get adapter ( ) { return cra ; }
public uri get u r i ( ) { return u ; }
protect output stream get output stream ( ) throw i o exception { throw new illegal state exception ( ) ; }
public final client handler get next ( ) { return next ; }
public static string jersey_app_no_mapping_or_annotation ( object arg0 , object arg1 ) { return localizer . localize ( localizable j e r s e y_ a p p_ n o_ m a p p i n g_ o r_ a n n o t a t i o n ( arg0 , arg1 ) ) ; }
public static string servlet_path_mismatch ( object arg0 , object arg1 ) { return localizer . localize ( localizable s e r v l e t_ p a t h_ m i s m a t c h ( arg0 , arg1 ) ) ; }
public servlet context get servlet context ( ) { if ( filter config ! = null ) { return filter config . get servlet context ( ) ; } return super . get servlet context ( ) ; }
public int index in ( char sequence sequence , int start ) { int length = sequence . length ( ) ; precondition . check position index ( start , length ) ; for ( int i = start ; i < length ; i++ ) { if ( match ( sequence . char at ( i ) ) ) { return i ; } } return -1 ; }
public static string sax_cannot_disable_parameter_entity_processing_feature ( object arg0 ) { return localizer . localize ( localizable s a x_ c a n n o t_ d i s a b l e_ p a r a m e t e r_ e n t i t y_ p r o c e s s i n g_ f e a t u r e ( arg0 ) ) ; }
public static string error_unmarshalling_jaxb ( object arg0 ) { return localizer . localize ( localizable e r r o r_ u n m a r s h a l l i n g_ j a x b ( arg0 ) ) ; }
public static string unable_to_secure_xml_transformer_processing ( ) { return localizer . localize ( localizable u n a b l e_ t o_ s e c u r e_ x m l_ t r a n s f o r m e r_ p r o c e s s i n g ( ) ) ; }
public int get status ( ) { return status type . get status code ( ) ; }
public e get entity ( ) { return entity ; }
public class < ? extend annotation > get parameter type ( ) { return parameter type ; }
public final boolean consumes ( medium type content type ) { for ( medium type c : consume mime ) { if ( c . get type ( ) . equal ( `` * `` ) ) return true ; if ( content type . be compatible ( c ) ) return true ; } return false ; }
public int match ( char sequence seq , int i ) { if ( i+code . length > seq . length ( ) ) return 0 ; for ( int j=0 ; j < code . length ; j++ ) { if ( code [ j ] ! = seq . char at ( i++ ) ) return 0 ; } return code . length ; }
protect final uri template get template ( ) { return template ; }
public static uri normalize ( uri uri , boolean preserve contd slash ) { if ( ! uri . get raw path ( ) . contains ( `` // `` ) ) { return uri . normalize ( ) ; } string np = uri helper . remove dot segment ( uri . get raw path ( ) , preserve contd slash ) ; if ( np . equal ( uri . get raw path ( ) ) ) { return uri ; } return uri builder . from uri ( uri ) . replace path ( np ) . build ( ) ; }
public string get comment text ( ) { return comment text ; }
public void set comment text ( string value ) { this . comment text = value ; }
public void map mappable container exception ( mappable container exception e ) { throwable cause = e . get cause ( ) ; if ( cause instanceof web application exception ) { map web application exception ( ( web application exception ) cause ) ; } else if ( ! map exception ( cause ) ) { if ( cause instanceof runtime exception ) { logger . log ( level . severe , `` the runtime exception could not be map to a response , `` + `` re-throwing to the http container `` , cause ) ; throw ( runtime exception ) cause ; } else { logger . log ( level . severe , `` the exception contain within `` + `` mappable container exception could not be map to a response , `` + `` re-throwing to the http container `` , cause ) ; throw e ; } } }
public list < doc > get doc ( ) { if ( doc == null ) { doc = new array list < doc > ( ) ; } return this . doc ; }
public string get title ( ) { return title ; }
public void set resource type ( string value ) { this . resource type = value ; }
public string get rel ( ) { return rel ; }
public param style get style ( ) { return style ; }
public string get fix ( ) { return fix ; }
public list < object > get method or resource ( ) { if ( method or resource == null ) { method or resource = new array list < object > ( ) ; } return this . method or resource ; }
public boolean be close ( ) { return close ; }
protect iterable < reader interceptor > get reader interceptor ( ) { final inflector < request processing context , container response > inflector = get inflector ( ) ; return inflector instanceof resource method invoker ? ( ( resource method invoker ) inflector ) . get reader interceptor ( ) : processing provider . get sorted global reader interceptor ( ) ; }
public string get vary value ( ) { return vary value ; }
public void set map from exception ( final boolean map from exception ) { this . map from exception = map from exception ; }
public void close ( ) { if ( ! close ) { closed = true ; message context . close ( ) ; request context . get response writer ( ) . commit ( ) ; } }
public static string reduce lead slash ( final string path ) { int length ; if ( path == null || ( length = path . length ( ) ) == 0 ) { return path ; } int start = 0 ; while ( start ! = length & & `` / `` . index of ( path . char at ( start ) ) ! = -1 ) { start++ ; } return path . substring ( start > 0 ? start - 1 : 0 ) ; }
public static string resource_config_error_null_applicationclass ( ) { return localizer . localize ( localizable r e s o u r c e_ c o n f i g_ e r r o r_ n u l l_ a p p l i c a t i o n c l a s s ( ) ) ; }
public static string exception_mapper_failed_for_exception ( ) { return localizer . localize ( localizable e x c e p t i o n_ m a p p e r_ f a i l e d_ f o r_ e x c e p t i o n ( ) ) ; }
public static string error_monitoring_mbeans_unregistration_destroy ( ) { return localizer . localize ( localizable e r r o r_ m o n i t o r i n g_ m b e a n s_ u n r e g i s t r a t i o n_ d e s t r o y ( ) ) ; }
public static string error_primitive_type_null ( ) { return localizer . localize ( localizable e r r o r_ p r i m i t i v e_ t y p e_ n u l l ( ) ) ; }
public static string error_request_set_entity_stream_in_response_phase ( ) { return localizer . localize ( localizable e r r o r_ r e q u e s t_ s e t_ e n t i t y_ s t r e a m_ i n_ r e s p o n s e_ p h a s e ( ) ) ; }
public static string resource_ambiguous ( object arg0 , object arg1 , object arg2 ) { return localizer . localize ( localizable r e s o u r c e_ a m b i g u o u s ( arg0 , arg1 , arg2 ) ) ; }
public static string error_committing_output_stream ( ) { return localizer . localize ( localizable e r r o r_ c o m m i t t i n g_ o u t p u t_ s t r e a m ( ) ) ; }
public static string error_wadl_generator_config_loader ( object arg0 ) { return localizer . localize ( localizable e r r o r_ w a d l_ g e n e r a t o r_ c o n f i g_ l o a d e r ( arg0 ) ) ; }
public static string error_wadl_builder_generation_method ( object arg0 , object arg1 ) { return localizer . localize ( localizable e r r o r_ w a d l_ b u i l d e r_ g e n e r a t i o n_ m e t h o d ( arg0 , arg1 ) ) ; }
public static string error_wadl_grammar_already_contains ( ) { return localizer . localize ( localizable e r r o r_ w a d l_ g r a m m a r_ a l r e a d y_ c o n t a i n s ( ) ) ; }
public static string method_empty_path_annotation ( object arg0 , object arg1 ) { return localizer . localize ( localizable m e t h o d_ e m p t y_ p a t h_ a n n o t a t i o n ( arg0 , arg1 ) ) ; }
public static string error_wadl_builder_generation_param ( object arg0 , object arg1 , object arg2 ) { return localizer . localize ( localizable e r r o r_ w a d l_ b u i l d e r_ g e n e r a t i o n_ p a r a m ( arg0 , arg1 , arg2 ) ) ; }
public static string wadl_doc_simple_wadl ( object arg0 , object arg1 ) { return localizer . localize ( localizable w a d l_ d o c_ s i m p l e_ w a d l ( arg0 , arg1 ) ) ; }
public void update execution statistic ( execution statistic execution statistic ) { this . execution statistic = execution statistic ; }
public rout context rout context ( ) { return rout context ; }
public static annotation accept listener new jaxrs resource and provider listener ( ) { return new annotation accept listener ( path . class , provider . class ) ; }
public static < t > invocable create ( inflector < request , t > inflector ) { return create ( method handler . create ( inflector ) , apply_inflector_method , false ) ; }
public static invocable create ( class < ? extend inflector > inflector class ) { return create ( method handler . create ( inflector class ) , apply_inflector_method , false ) ; }
public method list have return type ( final class < ? > return type ) { return filter ( new filter ( ) { @ override public boolean keep ( annotated method m ) { return m . get method ( ) . get return type ( ) == return type ; } } ) ; }
public static builder builder ( ) { return new builder ( ) ; }
public list < resource > get child resource ( ) { return child resource ; }
public final resource config register instance ( final set < object > instance ) { if ( instance == null ) { return this ; } for ( final object instance : instance ) { register ( instance ) ; } return this ; }
public void value change ( list selection event e ) { if ( e . get value be adjust ( ) ) { return ; } if ( e . get source ( ) . equal ( bucket table . get selection model ( ) ) ) { bucket select action ( ) ; } else if ( e . get source ( ) . equal ( object table . get selection model ( ) ) ) { object select action ( ) ; } }
public void follow hyperlink ( url url , string target ) { if ( ! be stand alone application ) { if ( target == null ) { get applet context ( ) . show document ( url ) ; } else { get applet context ( ) . show document ( url , target ) ; } } else { bare bone browser launch . open u r l ( url . to string ( ) ) ; } }
public static a w s credential load a w s credential ( ) throw i o exception { input stream property i s = class loader . get system resource a stream ( samples_properties_name ) ; if ( property i s == null ) { throw new runtime exception ( `` unable to load test property file from classpath : `` + samples_properties_name ) ; } property test property = new property ( ) ; test property . load ( property i s ) ; if ( ! test property . contains key ( aws_access_key_property_name ) ) { throw new runtime exception ( `` property file ' `` + samples_properties_name + `` ' do not contain required property : `` + aws_access_key_property_name ) ; } if ( ! test property . contains key ( aws_secret_key_property_name ) ) { throw new runtime exception ( `` property file ' `` + samples_properties_name + `` ' do not contain required property : `` + aws_secret_key_property_name ) ; } a w s credential aws credential = new a w s credential ( test property . get property ( aws_access_key_property_name ) , test property . get property ( aws_secret_key_property_name ) ) ; return aws credential ; }
public void grant all permission ( grant and permission [ ] grant and permission ) { for ( grant and permission gap : grant and permission ) { grant permission ( gap . get grantee ( ) , gap . get permission ( ) ) ; } }
public void set identifier ( string uri ) { this . id = uri ; }
public distribution [ ] list distribution ( ) throw cloud front service exception { return list distribution ( 100 ) ; }
public stream distribution [ ] list stream distribution ( string bucket name ) throw cloud front service exception { list < distribution > stream distribution = list distribution by bucket name ( true , bucket name ) ; return stream distribution . to array ( new stream distribution [ stream distribution . size ( ) ] ) ; }
public g s bucket [ ] list all bucket ( string project id ) throw service exception { assert authenticate connection ( `` list all bucket `` ) ; storage bucket [ ] bucket = list all bucket impl ( project id ) ; mx delegate . get instance ( ) . register storage bucket m bean ( bucket ) ; return g s bucket . cast ( bucket ) ; }
protect http client init http connection ( ) { return rest utils . init http connection ( this , get jet s3t property ( ) , get invoke application description ( ) , get credential provider ( ) ) ; }
public int compare to ( object o ) { return get product name ( ) . compare to ( ( ( a w s dev pay product ) o ) . get product name ( ) ) ; }
public void set acl ( g s access control list acl ) { this . acl = acl ; }
public void close data input stream ( ) throw i o exception { if ( this . data input stream ! = null ) { this . data input stream . close ( ) ; this . data input stream = null ; } }
public void set last modified date ( date last modified date ) { add metadata ( metadata_header_last_modified_date , last modified date ) ; }
public void set content length ( long size ) { add metadata ( metadata_header_content_length , string . value of ( size ) ) ; }
public void set key ( string key ) { super . set name ( key ) ; }
public static string generate post policy condition_ equality ( string name , string value ) { return `` { \ `` `` + name + `` \ `` : \ `` `` + value + `` \ `` } `` ; }
public void multipart abort upload ( multipart upload upload ) throw s3 service exception { multipart abort upload impl ( upload . get upload id ( ) , upload . get bucket name ( ) , upload . get object key ( ) ) ; }
public static boolean be cipher available for use ( string cipher ) { try { encryption util encryption util = new encryption util ( `` sample key `` , cipher , encryption util . default_version ) ; encryption util . encrypt ( `` test encryption . . . `` ) ; } catch ( runtime exception e ) { throw e ; } catch ( exception e ) { if ( log . be debug enable ( ) ) { log . debug ( `` availability test fail for encryption cipher `` + cipher ) ; } return false ; } return true ; }
public void set request path ( string request path ) { this . request path = request path ; }
protect void assert valid bucket ( storage bucket bucket , string action ) throw service exception { if ( bucket == null || bucket . get name ( ) == null || bucket . get name ( ) . length ( ) == 0 ) { throw new service exception ( `` the action `` + action + `` can not be perform with an invalid bucket : `` + bucket ) ; } }
public void delete bucket ( storage bucket bucket ) throw service exception { assert valid bucket ( bucket , `` delete bucket `` ) ; delete bucket impl ( bucket . get name ( ) ) ; }
public date get current time with offset ( ) { return new date ( system . current time millis ( ) + time offset ) ; }
public void add message property ( map property map ) { message property . put all ( property map ) ; }
public property encode to property ( ) { if ( log . be debug enable ( ) ) { log . debug ( `` encode gatekeeper message to property `` ) ; } property encode property = new property ( ) ; iterator iter = null ; string prefix = `` application `` ; iter = application property . entry set ( ) . iterator ( ) ; while ( iter . have next ( ) ) { map . entry entry = ( map . entry ) iter . next ( ) ; string key = ( string ) entry . get key ( ) ; string value = ( string ) entry . get value ( ) ; encode property ( encoded property , prefix + delim + key , value ) ; } prefix = `` message `` ; iter = message property . entry set ( ) . iterator ( ) ; while ( iter . have next ( ) ) { map . entry entry = ( map . entry ) iter . next ( ) ; string key = ( string ) entry . get key ( ) ; string value = ( string ) entry . get value ( ) ; encode property ( encoded property , prefix + delim + key , value ) ; } prefix = `` request `` ; signature request [ ] request = get signature request ( ) ; for ( int i = 0 ; i < request . length ; i++ ) { signature request request = request [ i ] ; string property prefix = prefix + delim + i + delim ; encode property ( encoded property , property prefix + `` signature type `` , request . get signature type ( ) ) ; encode property ( encoded property , property prefix + `` object key `` , request . get object key ( ) ) ; encode property ( encoded property , property prefix + `` bucket name `` , request . get bucket name ( ) ) ; encode property ( encoded property , property prefix + `` sign url `` , request . get sign url ( ) ) ; encode property ( encoded property , property prefix + `` decline reason `` , request . get decline reason ( ) ) ; property prefix += `` metadata `` + delim ; map metadata = request . get object metadata ( ) ; iter = metadata . entry set ( ) . iterator ( ) ; while ( iter . have next ( ) ) { map . entry entry = ( map . entry ) iter . next ( ) ; string metadata name = ( string ) entry . get key ( ) ; object metadata value = entry . get value ( ) ; encode property ( encoded property , property prefix + metadata name , metadata value ) ; } } return encoded property ; }
public void sign request ( string sign url ) { this . sign url = sign url ; }
public void decline request ( string reason ) { this . decline reason = reason ; }
public string generate browser url to authorize native application ( o auth scope scope ) { if ( this . implementation == o auth implementation . google_storage_oauth2_10 ) { string url = g s o auth2_10 . endpoint . authorization + `` ? response_type= `` + g s o auth2_10 . response type . code + `` & redirect_uri= `` + g s o auth2_10 . native_application_redirect_uri + `` & client_id= `` + this . client id + `` & scope= `` + scope ; log . debug ( `` generate authorization url for o auth implementation `` + this . implementation + `` : `` + url ) ; return url ; } else { throw new illegal state exception ( `` unsupported implementation : `` + this . implementation ) ; } }
public static void init http proxy ( http client http client , jets3t property jets3t property , string endpoint ) { init http proxy ( http client , jets3t property , true , null , -1 , null , null , null , endpoint ) ; }
public static http params create default http params ( ) { http params params = new sync basic http params ( ) ; http protocol params . set version ( params , http version . http_1_1 ) ; http protocol params . set content charset ( params , http . default_content_charset ) ; http connection params . set tcp no delay ( params , true ) ; http connection params . set socket buffer size ( params , 8192 ) ; return params ; }
public s3 object [ ] build s3 object from signature request ( signature request [ ] sr ) { s3 object [ ] object = new s3 object [ sr . length ] ; for ( int i = 0 ; i < sr . length ; i++ ) { object [ i ] = new s3 object ( srs [ i ] . get object key ( ) ) ; object [ i ] . add all metadata ( srs [ i ] . get object metadata ( ) ) ; } return object ; }
public static boolean be redirection ( int code ) { return ( ( 300 < = code ) & & ( code < = 399 ) ) ; }
public void fill interested ( ) { if ( log . be debug enable ( ) ) log . debug ( `` fill interested { } `` , this ) ; get end point ( ) . fill interested ( _read callback ) ; }
protect void on fill interested fail ( throwable cause ) { if ( log . be debug enable ( ) ) log . debug ( `` { } on fill interested fail { } `` , this , cause ) ; if ( _end point . be open ( ) ) { boolean close = true ; if ( cause instanceof timeout exception ) close = on read timeout ( ) ; if ( close ) { if ( _end point . be output shutdown ( ) ) _end point . close ( ) ; else { _end point . shutdown output ( ) ; fill interested ( ) ; } } } }
public void set config ( string config ) { _config = config ; }
public void add handler ( handler handler ) { set handler ( array util . add to array ( get handler ( ) , handler , handler . class ) ) ; }
public boolean be form encode method ( string method ) { return boolean . true . equal ( _form encode method . get ( method ) ) ; }
public void set secure request only ( boolean secure request only ) { _secure request only = secure request only ; }
public void add error page ( int code , string uri ) { _error page . put ( integer . to string ( code ) , uri ) ; }
public int get ssl session cache size ( ) { return _ssl session cache size ; }
public void set ssl session cache size ( int ssl session cache size ) { _ssl session cache size = ssl session cache size ; }
public final type get element type ( ) { return element type ; }
public final long page size ( ) { return page size ! = 0 ? page size : calculate page size ( ) ; }
public string get library name pattern ( ) { return `` lib . * \\ . so . * $ `` ; }
public void set scanner ( scanner s ) { _scanner = s ; }
public void user_init ( ) throw java . lang . exception { }
public int top ( ) throw java . lang . exception { if ( vstack . empty ( ) ) throw new exception ( `` internal parser error : top ( ) call on empty virtual stack `` ) ; return vstack . peek ( ) . int value ( ) ; }
public int [ ] get class code ( list < interval > interval list ) { return get class code ( new int char set ( interval list ) , false ) ; }
public char class interval [ ] get interval ( ) { int i , c ; int size = class . size ( ) ; int num interval = 0 ; for ( i = 0 ; i < size ; i++ ) num intervals+= ( class . get ( i ) ) . num interval ( ) ; char class interval [ ] result = new char class interval [ num interval ] ; i = 0 ; c = 0 ; while ( i < num interval ) { int code = get class code ( c ) ; int char set set = class . get ( code ) ; interval iv = set . get next ( ) ; result [ i++ ] = new char class interval ( iv . start , iv . end , code ) ; c = iv . end+1 ; } return result ; }
public short [ ] [ ] production_table ( ) { return _production_table ; }
public static void main ( string argv [ ] ) { try { generate ( argv ) ; } catch ( generator exception e ) { out . statistic ( ) ; system . exit ( 1 ) ; } catch ( silent exit e ) { system . exit ( 1 ) ; } }
public static void set dir ( string dir name ) { set dir ( new file ( dir name ) ) ; }
public static void time ( error message message , timer time ) { if ( option . time ) { string msg = error message . get ( message , time . to string ( ) ) ; out . println ( msg ) ; } }
public static void check error ( ) { if ( error > 0 ) throw new generator exception ( ) ; }
public void add ( string str ) { last yank = false ; if ( last kill ) { if ( slots [ head ] ! = null ) { slots [ head ] += str ; return ; } } last kill = true ; next ( ) ; slot [ head ] = str ; }
public int read ( ) throw i o exception { synchronize ( lock ) { if ( ! be open ( ) ) { throw new i o exception ( `` input stream reader be close . `` ) ; } char buf [ ] = new char [ 4 ] ; return read ( buf , 0 , 4 ) ! = -1 ? character . code point at ( buf , 0 ) : -1 ; } }
public output stream wrap out if need ( output stream out ) { return out ; }
public void restore ( ) throw exception { setting . restore ( ) ; super . restore ( ) ; }
public json node visit ( jmes path flatten flatten , json node input ) throw invalid type exception { json node flatten result = flatten . get flatten expr ( ) . accept ( this , input ) ; if ( flatten result . be array ( ) ) { iterator < json node > element = flatten result . element ( ) ; array node flatten array = object mapper singleton . get object mapper ( ) . create array node ( ) ; while ( element . have next ( ) ) { json node element = element . next ( ) ; if ( element ! = null ) { if ( element . be array ( ) ) { iterator < json node > inner = element . iterator ( ) ; while ( inner . have next ( ) ) { json node inner element = inner . next ( ) ; if ( inner element ! = null ) { flattened array . add ( inner element ) ; } } } else { flattened array . add ( element ) ; } } } return flattened array ; } return null node . get instance ( ) ; }
public json node visit ( jmes path literal literal , json node input ) { return literal . get value ( ) ; }
public json node visit ( jmes path filter filter , json node input ) throw invalid type exception { json node filter expression = filter . get lhs expr ( ) . accept ( this , input ) ; if ( filter expression . be array ( ) ) { iterator < json node > element = filter expression . element ( ) ; array node project array node = object mapper singleton . get object mapper ( ) . create array node ( ) ; while ( element . have next ( ) ) { json node element = element . next ( ) ; if ( filter . get comparator ( ) . accept ( this , element ) . equal ( boolean node . true ) ) { json node project element = filter . get rhs expr ( ) . accept ( this , element ) ; if ( project element ! = null ) { projected array node . add ( project element ) ; } } } return projected array node ; } return null node . get instance ( ) ; }
public json node evaluate ( list < json node > evaluate args ) throw invalid type exception { json node arg = evaluate args . get ( 0 ) ; if ( arg . be textual ( ) ) { return get string length ( arg ) ; } else if ( arg . be array ( ) || arg . be object ( ) ) { return new int node ( arg . size ( ) ) ; } throw new invalid type exception ( `` type mismatch . expect a string or an array or an object . `` ) ; }
public boolean match ( json node lhs , json node rh ) { return lh . equal ( rh ) ; }
public boolean match ( big decimal lh , big decimal rh ) { return lh . compare to ( rhs ) > 0 ; }
public int get group thread count ( ) { return group thread count ; }
public int get subgroup thread count ( ) { return subgroup thread count ; }
public benchmark result get aggregate result ( ) { if ( benchmark result . be empty ( ) ) { return null ; } collection < iteration result > result = new array list < > ( ) ; for ( benchmark result r : benchmark result ) { for ( iteration result ir : r . get iteration result ( ) ) { result . add ( ir ) ; } } benchmark result result = new benchmark result ( params , result ) ; for ( benchmark result br : benchmark result ) { for ( string k : br . get benchmark result ( ) . key ( ) ) { for ( result r : br . get benchmark result ( ) . get ( k ) ) { result . add benchmark result ( r ) ; } } } return result ; }
public double [ ] get confidence interval at ( double confidence ) { double [ ] interval = new double [ 2 ] ; if ( get n ( ) < = 2 ) { interval [ 0 ] = interval [ 1 ] = double . na n ; return interval ; } t distribution t dist = new t distribution ( get n ( ) - 1 ) ; double a = t dist . inverse cumulative probability ( 1 - ( 1 - confidence ) / 2 ) ; interval [ 0 ] = get mean ( ) - a * get standard deviation ( ) / math . sqrt ( get n ( ) ) ; interval [ 1 ] = get mean ( ) + a * get standard deviation ( ) / math . sqrt ( get n ( ) ) ; return interval ; }
public static < t > t get field ( class < ? > class with static field , string field name ) { return field reflection . get field ( class with static field , field name , null ) ; }
public static < t > t new instance ( string class name , class < ? > [ ] parameter type , object . . . init args ) { return constructor reflection . new instance ( class name , parameter type , init args ) ; }
public static < t > t new instance ( class < ? extend t > class to instantiate , object . . . non null args ) { return constructor reflection . new instance ( class to instantiate , non null args ) ; }
public static void premain ( @ nullable string agent args , @ nonnull instrumentation inst ) { if ( ! activate code coverage if request ( agent args , inst ) ) { string host j r e class name = mocking bridge field . create synthetic field in j r e class to hold mocking bridge ( inst ) ; instrumentation wrap inst = instrumentation holder . set ( inst , host j r e class name ) ; initialize ( wrap inst ) ; } }
public string [ ] get string array ( long offset , boolean wide ) { return get string array ( offset , -1 , wide ) ; }
public boolean get auto read ( ) { return this . auto read ; }
public constant get constant ( long value ) { return value to constant . get ( value ) ; }
public long max value ( ) { if ( max value == null ) { max value = get long field ( `` max_value `` , integer . max_value ) ; } return max value . int value ( ) ; }
public int native size ( runtime runtime ) { return runtime . address size ( ) ; }
public void from native ( runtime runtime , pointer buffer , long offset ) { this . value = buffer . get byte ( offset ) ; }
public void from native ( runtime runtime , pointer buffer , long offset ) { this . value = buffer . get double ( offset ) ; }
public void to native ( runtime runtime , pointer memory , long offset ) { memory . put long long ( offset , value ) ; }
public pointer new reference ( t object ) { return add ( object ) ; }
public final long address ( ) { return address ; }
protect final signed16 [ ] array ( signed16 [ ] array ) { array begin ( ) ; for ( int i = 0 ; i < array . length ; ++i ) { array [ i ] = new signed16 ( ) ; } array end ( ) ; return array ; }
protect final signed32 [ ] array ( signed32 [ ] array ) { array begin ( ) ; for ( int i = 0 ; i < array . length ; ++i ) { array [ i ] = new signed32 ( ) ; } array end ( ) ; return array ; }
protect final unsigned long [ ] array ( unsigned long [ ] array ) { array begin ( ) ; for ( int i = 0 ; i < array . length ; ++i ) { array [ i ] = new unsigned long ( ) ; } array end ( ) ; return array ; }
public void set property ( string name , object value ) { if ( name == null ) { throw new illegal argument exception ( `` parameter 'name ' must be not null `` ) ; } if ( value == null ) { throw new illegal argument exception ( `` parameter 'value ' must be not null `` ) ; } if ( ! this . property . contains key ( name ) ) { throw new illegal argument exception ( `` annotation ' `` + this . annotation type . get name ( ) + `` ' do not contain a property name ' `` + name + `` ' `` ) ; } this . property . get ( name ) . set value ( value ) ; }
public void error ( errno error , string extra data ) { throw new runtime exception ( `` native error `` + error . description ( ) + `` `` + extra data ) ; }
public static final mem dqword_ptr ( label label , long disp ) { return _ptr_build ( label , disp , size_dqword ) ; }
public final void cpuid ( ) { emit x86 ( inst_cpuid ) ; }
public final void enter ( immediate imm16 , immediate imm8 ) { emit x86 ( inst_enter , imm16 , imm8 ) ; }
public final void mov ( register dst , register src ) { emit x86 ( inst_mov , dst , src ) ; }
public final void not_ ( register dst ) { emit x86 ( inst_not , dst ) ; }
public final void ud2 ( ) { emit x86 ( inst_ud2 ) ; }
public final void ficom ( mem src ) { assert ( src . size ( ) == 2 || src . size ( ) == 4 ) ; emit x86 ( inst_ficom , src ) ; }
public final void fldl2e ( ) { emit x86 ( inst_fldl2e ) ; }
public final void psrld ( m m register dst , m m register src ) { emit x86 ( inst_psrld , dst , src ) ; }
public final void pfmax ( m m register dst , m m register src ) { emit x86 ( inst_pfmax , dst , src ) ; }
public final void pfmul ( m m register dst , m m register src ) { emit x86 ( inst_pfmul , dst , src ) ; }
public final void pfsub ( m m register dst , m m register src ) { emit x86 ( inst_pfsub , dst , src ) ; }
public final void cmpss ( x m m register dst , x m m register src , immediate imm8 ) { emit x86 ( inst_cmpss , dst , src , imm8 ) ; }
public final void ldmxcsr ( mem src ) { emit x86 ( inst_ldmxcsr , src ) ; }
public final void movhps ( x m m register dst , mem src ) { emit x86 ( inst_movhps , dst , src ) ; }
public final void movups ( x m m register dst , x m m register src ) { emit x86 ( inst_movups , dst , src ) ; }
public final void mulps ( x m m register dst , x m m register src ) { emit x86 ( inst_mulps , dst , src ) ; }
public final void psadbw ( m m register dst , m m register src ) { emit x86 ( inst_psadbw , dst , src ) ; }
public final void cvtpd2ps ( x m m register dst , x m m register src ) { emit x86 ( inst_cvtpd2ps , dst , src ) ; }
public final void cvtps2dq ( x m m register dst , x m m register src ) { emit x86 ( inst_cvtps2dq , dst , src ) ; }
public final void cvtss2sd ( x m m register dst , x m m register src ) { emit x86 ( inst_cvtss2sd , dst , src ) ; }
public final void cvttps2dq ( x m m register dst , x m m register src ) { emit x86 ( inst_cvttps2dq , dst , src ) ; }
public final void mfence ( ) { emit x86 ( inst_mfence ) ; }
public final void movapd ( x m m register dst , x m m register src ) { emit x86 ( inst_movapd , dst , src ) ; }
public final void movdq2q ( m m register dst , x m m register src ) { emit x86 ( inst_movdq2q , dst , src ) ; }
public final void pavgb ( x m m register dst , x m m register src ) { emit x86 ( inst_pavgb , dst , src ) ; }
public final void pcmpgtw ( x m m register dst , x m m register src ) { emit x86 ( inst_pcmpgtw , dst , src ) ; }
public final void pcmpgtd ( x m m register dst , x m m register src ) { emit x86 ( inst_pcmpgtd , dst , src ) ; }
public final void psrld ( x m m register dst , x m m register src ) { emit x86 ( inst_psrld , dst , src ) ; }
public final void haddps ( x m m register dst , x m m register src ) { emit x86 ( inst_haddps , dst , src ) ; }
public final void pmulhrsw ( m m register dst , m m register src ) { emit x86 ( inst_pmulhrsw , dst , src ) ; }
public final void pextrb ( register dst , x m m register src , immediate imm8 ) { emit x86 ( inst_pextrb , dst , src , imm8 ) ; }
public final void pmovsxbw ( x m m register dst , x m m register src ) { emit x86 ( inst_pmovsxbw , dst , src ) ; }
public final void pmovzxbw ( x m m register dst , x m m register src ) { emit x86 ( inst_pmovzxbw , dst , src ) ; }
public boolean category a text ( ) { return category a text ; }
public boolean show horizontal legend ( ) { return show horizontal legend ; }
public string to s q l ( ) { return sql ; }
public boolean support subselect ( ) { return support subselect ; }
public void set indentation ( string value ) { this . indentation = value ; }
public boolean be render schema ( ) { return render schema ; }
public void set render formatting ( render format value ) { this . render format = value ; }
public boolean be render scalar subqueries for stored function ( ) { return render scalar subqueries for stored function ; }
public backslash escape get backslash escaping ( ) { return backslash escaping ; }
public boolean be execute with optimistic lock exclude unversioned ( ) { return execute with optimistic lock exclude unversioned ; }
public boolean be fetch warning ( ) { return fetch warning ; }
public integer get query timeout ( ) { return query timeout ; }
public integer get max row ( ) { return max row ; }
public void set max row ( integer value ) { this . max row = value ; }
public integer get fetch size ( ) { return fetch size ; }
public void set parse with meta lookup ( parse with meta lookup value ) { this . parse with meta lookup = value ; }
public static final statement type get statement type ( settings setting ) { if ( setting ! = null ) { statement type result = setting . get statement type ( ) ; if ( result ! = null ) return result ; } return prepared_statement ; }
public c s v format quote ( quote new quote ) { return new c s v format ( delimiter , null string , empty string , newline , quote string , new quote , header ) ; }
protect final d s l context create ( ) { return dsl . use ( configuration ( ) ) ; }
public static diagnostics listener provider [ ] provider ( diagnostics listener . . . listener ) { diagnostics listener provider [ ] result = new diagnostics listener provider [ listener . length ] ; for ( int i = 0 ; i < listener . length ; i++ ) result [ i ] = new default diagnostics listener provider ( listener [ i ] ) ; return result ; }
public static create view a step create view if not exist ( string view , string . . . field ) { return dsl ( ) . create view if not exist ( view , field ) ; }
public static create sequence final step create sequence if not exist ( string sequence ) { return dsl ( ) . create sequence if not exist ( sequence ) ; }
public static drop view final step drop view ( string view ) { return dsl ( ) . drop view ( view ) ; }
public static < r extend record > quantify select < r > any ( select < r > select ) { return new quantified select impl < r > ( quantifier . any , select ) ; }
public static grant on step grant ( privilege privilege ) { return dsl ( ) . grant ( privilege ) ; }
public static table < record1 < integer > > generate series ( int from , int to , int step ) { return generate series ( val ( from ) , val ( to ) , val ( step ) ) ; }
public static field < object > field ( name name ) { return field ( name , object . class ) ; }
public static < t > field < t > ifnull ( t value , t default value ) { return nvl ( value , default value ) ; }
public static field < string > lpad ( field < string > field , int length , char character ) { return lpad ( field , length , character . to string ( character ) ) ; }
public static field < integer > position ( string in , string search ) { return position ( tools . field ( in ) , tool . field ( search ) ) ; }
public static field < string > concat ( string . . . value ) { return concat ( tool . field ( value ) . to array ( empty_field ) ) ; }
public static field < integer > date diff ( date date1 , date date2 ) { return date diff ( tool . field ( date1 ) , tool . field ( date2 ) ) ; }
public static < t > field < t > trunc ( field < t > date ) { return trunc ( date , date part . day ) ; }
public static field < date > date ( java . util . date value ) { return tool . field ( convert . convert ( value , date . class ) ) ; }
public static field < timestamp > to timestamp ( string value , string format ) { return to timestamp ( tool . field ( value ) , tool . field ( format ) ) ; }
public static group field group set ( field < ? > [ ] . . . field set ) { list < field < ? > > [ ] array = new list [ field set . length ] ; for ( int i = 0 ; i < field set . length ; i++ ) { array [ i ] = array . a list ( field set [ i ] ) ; } return group set ( array ) ; }
public static < t extend number > field < t > bit not ( t value ) { return bit not ( tool . field ( value ) ) ; }
public static < t extend number > field < t > round ( t value ) { return round ( tool . field ( value ) ) ; }
public static field < big decimal > ln ( number value ) { return ln ( tool . field ( value ) ) ; }
public static field < big decimal > atan2 ( number x , number y ) { return atan2 ( tool . field ( x ) , tool . field ( y ) ) ; }
public static aggregate function < integer > count ( field < ? > field ) { return new org . jooq . impl . function < integer > ( `` count `` , s q l data type . integer , null safe ( field ) ) ; }
public static < t > array agg order by step < t [ ] > array agg ( field < t > field ) { return new org . jooq . impl . function < t [ ] > ( term . array_agg , field . get data type ( ) . get array data type ( ) , null safe ( field ) ) ; }
public static order aggregate function < big decimal > cume dist ( field < ? > . . . field ) { return new org . jooq . impl . function < big decimal > ( `` cume_dist `` , s q l data type . numeric , field ) ; }
public static < t > param < t > param ( string name , field < t > type ) { return param ( name , type . get data type ( ) ) ; }
public static param < integer > two ( ) { return inline ( 2 ) ; }
public static field < string > current user ( ) { return new current user ( ) ; }
public static field < string > current schema ( ) { return new current schema ( ) ; }
public final string sql ( ) { return sql ; }
public boolean batch single ( ) { return binding . length > 1 ; }
public int auto generate key ( ) { return auto generate key ; }
public static reflect on ( string name , class loader class loader ) throw reflect exception { return on ( for name ( name , class loader ) ) ; }
public static string default if blank ( string str , string default str ) { return string utils . be blank ( str ) ? default str : str ; }
public static string abbreviate ( string str , int max width ) { return abbreviate ( str , 0 , max width ) ; }
public static boolean equal ( string o1 , string o2 ) { return o1 == null ? o2 == null : o1 . equal ( o2 ) ; }
public int max col width ( ) { return max col width ; }
public t x t format horizontal header border ( boolean new horizontal header border ) { return new t x t format ( max row , min col width , max col width , horizontal table border , new horizontal header border , horizontal cell border , vertical table border , vertical cell border , intersect line ) ; }
public t x t format intersect line ( boolean new intersect line ) { return new t x t format ( max row , min col width , max col width , horizontal table border , horizontal header border , horizontal cell border , vertical table border , vertical cell border , new intersect line ) ; }
public final int get minute ( ) { return minute ; }
public static field < string > decode ( string crypt string , string key string ) { return decode ( val ( crypt string ) , val ( key string ) ) ; }
public static field < string > uncompress ( string string ) { return uncompress ( val ( string ) ) ; }
public static field < string > encode ( string string , string key string ) { return encode ( val ( string ) , val ( key string ) ) ; }
public static field < string > compress ( string string ) { return compress ( val ( string ) ) ; }
public static field < string > uncompress ( string string ) { return uncompress ( val ( string ) ) ; }
public static < t > field < t [ ] > array remove ( t [ ] array , t element ) { return array remove0 ( val ( array ) , val ( element ) ) ; }
public static field < long > oid ( table < ? > table ) { return field ( `` { 0 } . oid `` , long . class , table ) ; }
public static object to p g interval ( day to second interval ) { return on ( `` org . postgresql . util . p g interval `` ) . create ( 0 , 0 , interval . get sign ( ) * interval . get day ( ) , interval . get sign ( ) * interval . get hour ( ) , interval . get sign ( ) * interval . get minute ( ) , interval . get sign ( ) * interval . get second ( ) + interval . get sign ( ) * interval . get nano ( ) / 1000000000 . 0 ) . get ( ) ; }
public string get data type ( ) { return data type ; }
public integer get numeric precision ( ) { return numeric precision ; }
public void set ordinal position ( integer value ) { this . ordinal position = value ; }
public string get index catalog ( ) { return index catalog ; }
public void set index catalog ( string value ) { this . index catalog = value ; }
public boolean be be descend ( ) { return be descend ; }
public void set constraint catalog ( string value ) { this . constraint catalog = value ; }
public void set specific catalog ( string value ) { this . specific catalog = value ; }
public string get unique constraint name ( ) { return unique constraint name ; }
public string get routine schema ( ) { return routine schema ; }
public void set routine package ( string value ) { this . routine package = value ; }
public void set constraint type ( table constraint type value ) { this . constraint type = value ; }
public x m l format header ( boolean new header ) { return new x m l format ( xmlns , format , newline , indent , indent , new header , record format ) ; }
public string get schema ( ) { return schema ; }
public render optional keyword get render optional outer keyword ( ) { return render optional outer keyword ; }
public boolean be render parenthesis around set operation query ( ) { return render parenthesis around set operation query ; }
public void set interpreter delay foreign key declaration ( boolean value ) { this . interpreter delay foreign key declaration = value ; }
public void set parse meta default expression ( boolean value ) { this . parse meta default expression = value ; }
public final boolean drop schema cascade ( ) { return drop schema cascade ; }
public boolean be enforce ( ) { return enforce ; }
public void set include ( string value ) { this . include = value ; }
public boolean be include package routine ( ) { return include package routine ; }
public void set include package constant ( boolean value ) { this . include package constant = value ; }
public void set include u d t ( boolean value ) { this . include u d t = value ; }
public boolean be include sequence ( ) { return include sequence ; }
public boolean be include foreign key ( ) { return include foreign key ; }
public string get override primary key ( ) { return override primary key ; }
public void set unsigned type ( boolean value ) { this . unsigned type = value ; }
public string get input schema ( ) { return input schema ; }
public boolean be output schema to default ( ) { return output schema to default ; }
public boolean be relation ( ) { return relation ; }
public void set deprecate ( boolean value ) { this . deprecate = value ; }
public void set key ( boolean value ) { this . key = value ; }
public boolean be immutable interface ( ) { return immutable interface ; }
public boolean be serializable interface ( ) { return serializable interface ; }
public void set jpa annotation ( boolean value ) { this . jpa annotation = value ; }
public boolean be global object reference ( ) { return global object reference ; }
public boolean be comment on catalog ( ) { return comment on catalog ; }
public void set comment on catalog ( boolean value ) { this . comment on catalog = value ; }
public boolean be comment on column ( ) { return comment on column ; }
public void set comment on attribute ( boolean value ) { this . comment on attribute = value ; }
public boolean be comment on sequence ( ) { return comment on sequence ; }
public boolean be vararg setter ( ) { return vararg setter ; }
public string get fully qualify type ( ) { return fully qualified type ; }
public string get driver ( ) { return driver ; }
public void set username ( string value ) { this . username = value ; }
public void set password ( string value ) { this . password = value ; }
public void set enum class ( matcher rule value ) { this . enum class = value ; }
public void set routine class ( matcher rule value ) { this . routine class = value ; }
public void set table class ( matcher rule value ) { this . table class = value ; }
public matcher rule get pojo class ( ) { return pojo class ; }
public void set__2 ( integer value ) { set value ( _2 , value ) ; }
public void set include system index ( boolean value ) { this . include system index = value ; }
public synthetic object type get synthetic object ( ) { return synthetic object ; }
public void set integer display width ( boolean value ) { this . integer display width = value ; }
public string get comment ( ) { return comment ; }
public boolean be sequence flag ( ) { return sequence flag ; }
public void set nullable annotation ( boolean value ) { this . nullable annotation = value ; }
public void set pojos a kotlin data class ( boolean value ) { this . pojos a kotlin data class = value ; }
public boolean be kotlin setter jvm name annotation on be prefix ( ) { return kotlin setter jvm name annotation on be prefix ; }
public void set comment on embeddables ( boolean value ) { this . comment on embeddables = value ; }
public string get expression ( ) { return expression ; }
public string get table ( ) { return table ; }
public string get comment ( ) { return comment ; }
public context get general provider context ( ) { return general provider context ; }
public jwt consumer builder set skip all validators ( ) { skip all validators = true ; return this ; }
public jwt consumer builder set expect issuer ( boolean require issuer , string . . . expected issuer ) { iss validator = new iss validator ( require issuer , expect issuer ) ; return this ; }
public void set terminal mode ( byte [ ] terminal_mode ) { this . terminal_mode=terminal_mode ; }
public string get name ( ) { return identity ; }
public session get session ( string username , string host ) throw j sch exception { return get session ( username , host , 22 ) ; }
public session get session ( string username , string host , int port ) throw j sch exception { if ( host==null ) { throw new j sch exception ( `` host must not be null . `` ) ; } session s = new session ( this , username , host , port ) ; return s ; }
public int do after body ( ) throw jsp exception { return skip_body ; }
public final tag info get tag info ( ) { return tag info ; }
public void release ( ) { init parameter = null ; }
public void set value ( string k , object o ) { if ( value == null ) { value = new hashtable < string , object > ( ) ; } value . put ( k , o ) ; }
public void add speed test listener ( final i speed test listener listener ) { m listener list . add ( listener ) ; }
public int get socket timeout ( ) { return m socket timeout ; }
public computation method get computation method ( ) { return m computation method ; }
public long get download setup time ( ) { return m download setup time ; }
public upload storage type get upload storage type ( ) { return m upload storage type ; }
public byte [ ] generate random array ( final int length ) { final byte [ ] buffer = new byte [ length ] ; final int iter = length / speed test const . upload_file_write_chunk ; final int remain = length % speed test const . upload_file_write_chunk ; for ( int i = 0 ; i < iter ; i++ ) { final byte [ ] random = new byte [ speed test const . upload_file_write_chunk ] ; m random . next byte ( random ) ; system . arraycopy ( random , 0 , buffer , i * speed test const . upload_file_write_chunk , speed test const . upload_file_write_chunk ) ; } if ( remain > 0 ) { final byte [ ] random = new byte [ remain ] ; m random . next byte ( random ) ; system . arraycopy ( random , 0 , buffer , iter * speed test const . upload_file_write_chunk , remain ) ; } return buffer ; }
public static string generate file name ( ) { return new big integer ( 130 , random ) . to string ( 32 ) ; }
public static double angle between ( coordinate tip1 , coordinate tail , coordinate tip2 ) { double a1 = angle ( tail , tip1 ) ; double a2 = angle ( tail , tip2 ) ; return diff ( a1 , a2 ) ; }
public static int get turn ( double ang1 , double ang2 ) { double crossproduct = math . sin ( ang2 - ang1 ) ; if ( crossproduct > 0 ) { return counterclockwise ; } if ( crossproduct < 0 ) { return clockwise ; } return none ; }
public static int locate point in ring ( coordinate p , coordinate [ ] ring ) { return ray cross counter . locate point in ring ( p , ring ) ; }
public boolean be proper ( ) { return have intersection ( ) & & be proper ; }
public double get length ( ) { compute minimum diameter ( ) ; return min width ; }
public void add ( collection geometry ) { for ( iterator i = geometry . iterator ( ) ; i . have next ( ) ; ) { geometry geometry = ( geometry ) i . next ( ) ; add ( geometry ) ; } }
public half edge add edge ( coordinate orig , coordinate d ) { if ( ! be valid edge ( orig , d ) ) return null ; / * * * attempt to find the edge already in the graph . * return it if find . * otherwise , use a found edge with same origin ( if any ) to construct new edge . * / half edge e adj = ( half edge ) vertex map . get ( orig ) ; half edge e same = null ; if ( e adj ! = null ) { e same = e adj . find ( d ) ; } if ( e same ! = null ) { return e same ; } half edge e = insert ( orig , d , e adj ) ; return e ; }
public coordinate [ ] to coordinate array ( ) { return ( coordinate [ ] ) to array ( coord array type ) ; }
public static int compare ( double a , double b ) { if ( a < b ) return -1 ; if ( a > b ) return 1 ; if ( double . be na n ( a ) ) { if ( double . be na n ( b ) ) return 0 ; return -1 ; } if ( double . be na n ( b ) ) return 1 ; return 0 ; }
public double get min y ( ) { return miny ; }
public void expand to include ( envelope other ) { if ( other . be null ( ) ) { return ; } if ( be null ( ) ) { minx = other . get min x ( ) ; maxx = other . get max x ( ) ; miny = other . get min y ( ) ; maxy = other . get max y ( ) ; } else { if ( other . minx < minx ) { minx = other . minx ; } if ( other . maxx > maxx ) { maxx = other . maxx ; } if ( other . miny < miny ) { miny = other . miny ; } if ( other . maxy > maxy ) { maxy = other . maxy ; } } }
public void translate ( double trans x , double trans y ) { if ( be null ( ) ) { return ; } init ( get min x ( ) + trans x , get max x ( ) + trans x , get min y ( ) + trans y , get max y ( ) + trans y ) ; }
public boolean intersects ( coordinate p ) { return intersects ( p . x , p . y ) ; }
public int hash code ( ) { return get envelope internal ( ) . hash code ( ) ; }
public static boolean match ( string actual dimension symbol , string require dimension symbol ) { intersection matrix m = new intersection matrix ( actual dimension symbol ) ; return m . match ( require dimension symbol ) ; }
public boolean be cover ( ) { boolean have point in common = be true ( matrix [ location . interior ] [ location . interior ] ) || be true ( matrix [ location . interior ] [ location . boundary ] ) || be true ( matrix [ location . boundary ] [ location . interior ] ) || be true ( matrix [ location . boundary ] [ location . boundary ] ) ; return have point in common & & matrix [ location . exterior ] [ location . interior ] == dimension . false & & matrix [ location . exterior ] [ location . boundary ] == dimension . false ; }
public intersection matrix transpose ( ) { int temp = matrix [ 1 ] [ 0 ] ; matrix [ 1 ] [ 0 ] = matrix [ 0 ] [ 1 ] ; matrix [ 0 ] [ 1 ] = temp ; temp = matrix [ 2 ] [ 0 ] ; matrix [ 2 ] [ 0 ] = matrix [ 0 ] [ 2 ] ; matrix [ 0 ] [ 2 ] = temp ; temp = matrix [ 2 ] [ 1 ] ; matrix [ 2 ] [ 1 ] = matrix [ 1 ] [ 2 ] ; matrix [ 1 ] [ 2 ] = temp ; return this ; }
public double distance perpendicular ( coordinate p ) { return distance . point to line perpendicular ( p , p0 , p1 ) ; }
public type get type ( ) { return model type ; }
public coordinate to external ( coordinate internal ) { coordinate external = new coordinate ( internal ) ; return external ; }
public boolean be any target component in test ( geometry test geom ) { point locator locator = new point locator ( ) ; for ( iterator i = representative pt . iterator ( ) ; i . have next ( ) ; ) { coordinate p = ( coordinate ) i . next ( ) ; if ( locator . intersects ( p , test geom ) ) return true ; } return false ; }
public boolean cover ( geometry geom ) { return eval ( geom ) ; }
public static coordinate centroid ( coordinate a , coordinate b , coordinate c ) { double x = ( a . x + b . x + c . x ) / 3 ; double y = ( a . y + b . y + c . y ) / 3 ; return new coordinate ( x , y ) ; }
public double sign area ( ) { return sign area ( this . p0 , this . p1 , this . p2 ) ; }
public static affine transformation scale instance ( double x scale , double y scale ) { affine transformation trans = new affine transformation ( ) ; trans . set to scale ( x scale , y scale ) ; return trans ; }
public double [ ] get matrix entry ( ) { return new double [ ] { m00 , m01 , m02 , m10 , m11 , m12 } ; }
public affine transformation rotate ( double sin theta , double co theta , double x , double y ) { compose ( rotation instance ( sin theta , cos theta ) ) ; return this ; }
public boolean equal ( object o ) { if ( ! ( o instanceof edge ) ) return false ; edge e = ( edge ) o ; if ( pt . length ! = e . pt . length ) return false ; boolean be equal forward = true ; boolean be equal reverse = true ; int i rev = pt . length ; for ( int i = 0 ; i < pt . length ; i++ ) { if ( ! pt [ i ] . equals2 d ( e . pt [ i ] ) ) { be equal forward = false ; } if ( ! pt [ i ] . equals2 d ( e . pt [ -- i rev ] ) ) { be equal reverse = false ; } if ( ! be equal forward & & ! be equal reverse ) return false ; } return true ; }
public list get edge ( ) { return edge ; }
public int compare to ( object o ) { sweep line event pe = ( sweep line event ) o ; if ( x value < pe . x value ) return -1 ; if ( x value > pe . x value ) return 1 ; if ( event type < pe . event type ) return -1 ; if ( event type > pe . event type ) return 1 ; return 0 ; }
public edge end find edge end ( edge e ) { for ( iterator i = get edge end ( ) . iterator ( ) ; i . have next ( ) ; ) { edge end ee = ( edge end ) i . next ( ) ; if ( ee . get edge ( ) == e ) return ee ; } return null ; }
public edge find edge in same direction ( coordinate p0 , coordinate p1 ) { for ( int i = 0 ; i < edge . size ( ) ; i++ ) { edge e = ( edge ) edge . get ( i ) ; coordinate [ ] e coord = e . get coordinate ( ) ; if ( match in same direction ( p0 , p1 , e coord [ 0 ] , e coord [ 1 ] ) ) return e ; if ( match in same direction ( p0 , p1 , e coord [ e coord . length - 1 ] , e coord [ e coord . length - 2 ] ) ) return e ; } return null ; }
public static int quadrant ( double dx , double dy ) { if ( dx == 0 . 0 & & dy == 0 . 0 ) throw new illegal argument exception ( `` can not compute the quadrant for point ( `` + dx + `` , `` + dy + `` ) `` ) ; if ( dx > = 0 . 0 ) { if ( dy > = 0 . 0 ) return ne ; else return se ; } else { if ( dy > = 0 . 0 ) return nw ; else return sw ; } }
public static boolean be northern ( int quad ) { return quad == ne || quad == nw ; }
public kd node get right ( ) { return right ; }
public boolean be repeat ( ) { return count > 1 ; }
public void query ( envelope query env , kd node visitor visitor ) { query node ( root , query env , true , visitor ) ; }
public object [ ] near neighbour ( item distance item dist ) { boundable pair bp = new boundable pair ( this . get root ( ) , this . get root ( ) , item dist ) ; return near neighbour ( bp ) ; }
public geometry get geometry ( ) { if ( stack . size ( ) == 1 ) { handler h = ( handler ) stack . peek ( ) ; if ( h . child . size ( ) == 1 ) return ( geometry ) h . child . get ( 0 ) ; return gf . create geometry collection ( ( geometry [ ] ) h . child . to array ( new geometry [ stack . size ( ) ] ) ) ; } throw new illegal state exception ( `` parse do not complete a expect , there be `` + stack . size ( ) + `` element on the stack `` ) ; }
public void set line prefix ( string line prefix ) { this . line prefix = line prefix ; }
public static byte [ ] hex to byte ( string hex ) { int byte len = hex . length ( ) / 2 ; byte [ ] bytes = new byte [ byte len ] ; for ( int i = 0 ; i < hex . length ( ) / 2 ; i++ ) { int i2 = 2 * i ; if ( i2 + 1 > hex . length ( ) ) throw new illegal argument exception ( `` hex string have odd length `` ) ; int nib1 = hex to int ( hex . char at ( i2 ) ) ; int nib0 = hex to int ( hex . char at ( i2 + 1 ) ) ; byte b = ( byte ) ( ( nib1 < < 4 ) + ( byte ) nib0 ) ; bytes [ i ] = b ; } return byte ; }
public void snap to vertex ( geometry linear geom , double min distance ) { if ( segment fraction < = 0 . 0 || segment fraction > = 1 . 0 ) return ; double seg len = get segment length ( linear geom ) ; double len to start = segment fraction * seg len ; double len to end = seg len - len to start ; if ( len to start < = len to end & & len to start < min distance ) { segment fraction = 0 . 0 ; } else if ( len to end < = len to start & & len to end < min distance ) { segment fraction = 1 . 0 ; } }
public double get segment fraction ( ) { return segment fraction ; }
public static linear location [ ] index of ( geometry linear geom , geometry sub line ) { location index of line locater = new location index of line ( linear geom ) ; return locater . index of ( sub line ) ; }
public boolean gt ( dd y ) { return ( hi > y . hi ) || ( hi == y . hi & & lo > y . lo ) ; }
public boolean ge ( dd y ) { return ( hi > y . hi ) || ( hi == y . hi & & lo > = y . lo ) ; }
public list get intersection ( ) { return seg int . get intersection ( ) ; }
public void set keep intersection ( boolean keep intersection ) { this . keep intersection = keep intersection ; }
public void set check end segment only ( boolean be check end segment only ) { this . be check end segment only = be check end segment only ; }
public boolean have interior intersection ( ) { return have interior ; }
public void set maximum iteration ( int max iter ) { this . max iter = max iter ; }
public boolean have non proper intersection ( ) { return have non proper intersection ; }
public void set segment intersector ( segment intersector seg int ) { this . seg int = seg int ; }
public void set quadrant segment ( int quad segs ) { quadrant segment = quad segs ; / * * * indicate how to construct fillet . * if qs > = 1 , fillet be round , and qs indicate number of * segment to use to approximate a quarter-circle . * if qs = 0 , fillet be bevel flat ( i . e . no filleting be perform ) * if qs < 0 , fillet be mitred , and absolute value of qs * indicate maximum length of mitre accord to * * mitre limit = |qs| * / if ( quadrant segment == 0 ) join style = join_bevel ; if ( quadrant segment < 0 ) { join style = join_mitre ; mitre limit = math . ab ( quadrant segment ) ; } if ( quad segs < = 0 ) { quadrant segment = 1 ; } / * * * if join style be set by the quad segs value , * use the default for the actual quadrant segment value . * / if ( join style ! = join_round ) { quadrant segment = default_quadrant_segments ; } }
public void create ( node node ) { add reachable ( node ) ; finder . find edge ( dir edge list ) ; right most coord = finder . get coordinate ( ) ; }
public static double distance ( geometry g0 , geometry g1 ) { distance op dist op = new distance op ( g0 , g1 ) ; return dist op . distance ( ) ; }
public void link direct edge for minimal edge ring ( ) { directed edge de = start de ; do { node node = de . get node ( ) ; ( ( direct edge star ) node . get edge ( ) ) . link minimal direct edge ( this ) ; de = de . get next ( ) ; } while ( de ! = start de ) ; }
public edge ring get shell ( ) { if ( be hole ( ) ) return shell ; return this ; }
public collection get polygon ( ) { polygonize ( ) ; return poly list ; }
public collection get invalid ring line ( ) { polygonize ( ) ; return invalid ring line ; }
public boolean be valid ( ) { check valid ( parent geometry ) ; return valid err == null ; }
public object get context ( ) { return data ; }
public collection value ( ) { return node map . value ( ) ; }
public boolean be geometry changed ( ) { return true ; }
public void set remove collapsed component ( boolean remove collapse ) { this . remove collapsed = remove collapse ; }
public void set pointwise ( boolean be pointwise ) { this . be pointwise = be pointwise ; }
public void set gutter fraction ( double gutter fraction ) { this . gutter fraction = gutter fraction ; }
public void set ensure valid ( boolean be ensure valid topology ) { this . be ensure valid topology = be ensure valid topology ; }
public constraint vertex factory get vertex factory ( ) { return vertex factory ; }
public geometry get convex hull ( ) { return convex hull ; }
public final quad edge o prev ( ) { return rot . next . rot ; }
public double get length ( ) { return orig ( ) . get coordinate ( ) . distance ( d ( ) . get coordinate ( ) ) ; }
public boolean be frame edge ( quad edge e ) { if ( be frame vertex ( e . orig ( ) ) || be frame vertex ( e . d ( ) ) ) return true ; return false ; }
public vertex [ ] get vertex ( ) { vertex [ ] vert = new vertex [ 3 ] ; for ( int i = 0 ; i < 3 ; i++ ) { vert [ i ] = get vertex ( i ) ; } return vert ; }
public double circum radius ratio ( vertex b , vertex c ) { vertex x = this . circle center ( b , c ) ; double radius = distance ( x , b ) ; double edge length = distance ( this , b ) ; double el = distance ( b , c ) ; if ( el < edge length ) { edge length = el ; } el = distance ( c , this ) ; if ( el < edge length ) { edge length = el ; } return radius / edge length ; }
public object get data ( ) { return data ; }
public boolean equal topo ( segment s ) { return l . equal topo ( s . get line segment ( ) ) ; }
public coordinate intersection ( segment s ) { return l . intersection ( s . get line segment ( ) ) ; }
public int get count ( ) { return n ; }
public static void print ( object obj ) { if ( ! debug on ) return ; debug . instance print ( obj ) ; }
public void set centre ( coordinate centre ) { dim . set centre ( centre ) ; }
public boolean be empty ( ) { return size == 0 ; }
public static string get stack trace ( throwable t ) { byte array output stream o = new byte array output stream ( ) ; print stream p = new print stream ( os ) ; t . print stack trace ( p ) ; return o . to string ( ) ; }
public static int min coordinate index ( coordinate sequence seq , int from , int to ) { int min coord index = -1 ; coordinate min coord = null ; for ( int i = from ; i < = to ; i++ ) { coordinate test coord = seq . get coordinate ( i ) ; if ( min coord == null || min coord . compare to ( test coord ) > 0 ) { min coord = test coord ; min coord index = i ; } } return min coord index ; }
public boolean be overlaps ( int dimension of geometry a , int dimension of geometry b ) { if ( ( dimension of geometry a == dimension . p & & dimension of geometry b == dimension . p ) || ( dimension of geometry a == dimension . a & & dimension of geometry b == dimension . a ) ) { return be true ( matrix [ location . interior ] [ location . interior ] ) & & be true ( matrix [ location . interior ] [ location . exterior ] ) & & be true ( matrix [ location . exterior ] [ location . interior ] ) ; } if ( dimension of geometry a == dimension . l & & dimension of geometry b == dimension . l ) { return matrix [ location . interior ] [ location . interior ] == 1 & & be true ( matrix [ location . interior ] [ location . exterior ] ) & & be true ( matrix [ location . exterior ] [ location . interior ] ) ; } return false ; }
public void visit item ( object item ) { item . add ( item ) ; }
public double maximum distance ( ) { return envelope distance . maximum distance ( ( envelope ) boundable1 . get bound ( ) , ( envelope ) boundable2 . get bound ( ) ) ; }
public vector3 d normalize ( ) { double length = length ( ) ; if ( length > 0 . 0 ) return divide ( length ( ) ) ; return create ( 0 . 0 , 0 . 0 , 0 . 0 ) ; }
public double get width ( ) { return 1 . 0 / scale factor ; }
public static elevation model create ( geometry geom1 , geometry geom2 ) { envelope extent = geom1 . get envelope internal ( ) . copy ( ) ; if ( geom2 ! = null ) { extent . expand to include ( geom2 . get envelope internal ( ) ) ; } elevation model model = new elevation model ( extent , default_cell_num , default_cell_num ) ; if ( geom1 ! = null ) model . add ( geom1 ) ; if ( geom2 ! = null ) model . add ( geom2 ) ; return model ; }
public int get area index ( ) { if ( get dimension ( 0 ) == 2 ) return 0 ; if ( get dimension ( 1 ) == 2 ) return 1 ; return -1 ; }
public static geometry reduce precision ( geometry geom , precision model pm ) { overlay n g ov = new overlay n g ( geom , pm ) ; / * * * ensure reduce a area only produce polygonal result . * ( i . e . collapse line be not output ) * / if ( geom . get dimension ( ) == 2 ) { ov . set area result only ( true ) ; } try { geometry reduce = ov . get result ( ) ; return reduce ; } catch ( topology exception ex ) { throw new illegal argument exception ( `` reduction fail , possible invalid input `` ) ; } }
public edge ring get out hole ( ) { / * * only shell can have out hole * / if ( be hole ( ) ) return null ; / * * a shell be an outer shell if any edge be also in an outer hole . * a hole be an out hole if it be not contain by a shell . * / for ( int i = 0 ; i < de list . size ( ) ; i++ ) { polygonize direct edge de = ( polygonize direct edge ) de list . get ( i ) ; edge ring adj ring = ( ( polygonize direct edge ) de . get sym ( ) ) . get ring ( ) ; if ( adj ring . be out hole ( ) ) return adj ring ; } return null ; }
public static boolean be simple ( geometry geom ) { be simple op op = new be simple op ( geom ) ; return op . be simple ( ) ; }
public int [ ] to array ( ) { int [ ] array = new int [ size ] ; system . arraycopy ( data , 0 , array , 0 , size ) ; return array ; }
public void configure ( size size ) { this . length range = size ; check range ( integral , size . min ( ) , size . max ( ) ) ; }
final static public byte buffer get direct buffer at ( long address , int size ) { if ( direct byte buffer constr == null ) return null ; try { return direct byte buffer constr . new instance ( address , size , null ) ; } catch ( exception e ) { throw new runtime exception ( `` can not allocate byte buffer at a give address : `` + address , e ) ; } }
static public int swap int ( int i ) { return ( ( i & 0x f f ) < < 24 ) | ( ( i & 0x f f00 ) < < 8 ) | ( ( i & 0x f f0000 ) > > 8 ) | ( ( i > > 24 ) & 0x f f ) ; }
public synchronize void get interval histogram into ( histogram target histogram ) { try { record phaser . reader lock ( ) ; update histogram ( ) ; inactive raw data histogram . copy into ( target histogram ) ; target histogram . add ( inactive pause correction histogram ) ; } finally { record phaser . reader unlock ( ) ; } }
protect synchronized void notify listener ( final long pause length nsec , final long pause end time nsec ) { message . add ( new pause notification ( pause length nsec , pause end time nsec ) ) ; }
public static void link ( file source , file target ) throw i o exception { if ( util j n i . on_windows == 1 ) { if ( util j n i . create hard link w ( target . get canonical path ( ) , source . get canonical path ( ) , 0 ) == 0 ) { throw new i o exception ( `` link failed `` ) ; } } else { if ( util j n i . link ( source . get canonical path ( ) , target . get canonical path ( ) ) ! = 0 ) { throw new i o exception ( `` link fail : `` +strerror ( ) ) ; } } }
public static abort create ( scope scope , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` abort `` , scope . make op name ( `` abort `` ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . error msg ! = null ) { op builder . set attr ( `` error_msg `` , opts . error msg ) ; } if ( opts . exit without error ! = null ) { op builder . set attr ( `` exit_without_error `` , opts . exit without error ) ; } } } return new abort ( op builder . build ( ) ) ; }
public static accumulator num accumulate create ( scope scope , operand < string > handle ) { operation builder op builder = scope . graph ( ) . op builder ( `` accumulator num accumulate `` , scope . make op name ( `` accumulator num accumulate `` ) ) ; op builder . add input ( handle . a output ( ) ) ; return new accumulator num accumulate ( op builder . build ( ) ) ; }
public static all candidate sampler create ( scope scope , operand < long > true class , long num true , long num sample , boolean unique , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` all candidate sampler `` , scope . make op name ( `` all candidate sampler `` ) ) ; op builder . add input ( true class . a output ( ) ) ; op builder . set attr ( `` num_true `` , num true ) ; op builder . set attr ( `` num_sampled `` , num sample ) ; op builder . set attr ( `` unique `` , unique ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . seed ! = null ) { op builder . set attr ( `` seed `` , opts . seed ) ; } if ( opts . seed2 ! = null ) { op builder . set attr ( `` seed2 `` , opts . seed2 ) ; } } } return new all candidate sampler ( op builder . build ( ) ) ; }
public output < float > true expect count ( ) { return true expect count ; }
public static < t extend number > any create ( scope scope , operand < boolean > input , operand < t > axis , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` any `` , scope . make op name ( `` any `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . add input ( axis . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . keep dims ! = null ) { op builder . set attr ( `` keep_dims `` , opts . keep dims ) ; } } } return new any ( op builder . build ( ) ) ; }
public output < t > output ref ( ) { return output ref ; }
public static < t extend number > atan2 < t > create ( scope scope , operand < t > y , operand < t > x ) { operation builder op builder = scope . graph ( ) . op builder ( `` atan2 `` , scope . make op name ( `` atan2 `` ) ) ; op builder . add input ( y . a output ( ) ) ; op builder . add input ( x . a output ( ) ) ; return new atan2 < t > ( op builder . build ( ) ) ; }
public static audio summary create ( scope scope , operand < string > tag , operand < float > tensor , operand < float > sample rate , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` audio summary v2 `` , scope . make op name ( `` audio summary `` ) ) ; op builder . add input ( tag . a output ( ) ) ; op builder . add input ( tensor . a output ( ) ) ; op builder . add input ( sample rate . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . max output ! = null ) { op builder . set attr ( `` max_outputs `` , opts . max output ) ; } } } return new audio summary ( op builder . build ( ) ) ; }
public output < t > output ( ) { return output ; }
public output < integer > size ( ) { return size ; }
public static < t > batch matrix set diag < t > create ( scope scope , operand < t > input , operand < t > diagonal ) { operation builder op builder = scope . graph ( ) . op builder ( `` batch matrix set diag `` , scope . make op name ( `` batch matrix set diag `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . add input ( diagonal . a output ( ) ) ; return new batch matrix set diag < t > ( op builder . build ( ) ) ; }
public static < t extend number > batch matrix solve l < t > create ( scope scope , operand < t > matrix , operand < t > rh , operand < double > l2 regularizer , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` batch matrix solve l `` , scope . make op name ( `` batch matrix solve l `` ) ) ; op builder . add input ( matrix . a output ( ) ) ; op builder . add input ( rh . a output ( ) ) ; op builder . add input ( l2 regularizer . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . fast ! = null ) { op builder . set attr ( `` fast `` , opts . fast ) ; } } } return new batch matrix solve l < t > ( op builder . build ( ) ) ; }
public output < t > output ( ) { return output ; }
public list < output < float > > leave node contribs list ( ) { return leave node contribs list ; }
public output < float > logits ( ) { return logits ; }
public output < integer > output ( ) { return output ; }
public static < t > cholesky < t > create ( scope scope , operand < t > input ) { operation builder op builder = scope . graph ( ) . op builder ( `` cholesky `` , scope . make op name ( `` cholesky `` ) ) ; op builder . add input ( input . a output ( ) ) ; return new cholesky < t > ( op builder . build ( ) ) ; }
public static < t extend number > collective bcast send < t > create ( scope scope , operand < t > input , long group size , long group key , long instance key , shape shape ) { operation builder op builder = scope . graph ( ) . op builder ( `` collective bcast send `` , scope . make op name ( `` collective bcast send `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . set attr ( `` group_size `` , group size ) ; op builder . set attr ( `` group_key `` , group key ) ; op builder . set attr ( `` instance_key `` , instance key ) ; op builder . set attr ( `` shape `` , shape ) ; return new collective bcast send < t > ( op builder . build ( ) ) ; }
public static < t extend number > conv3 d backprop input < t > create ( scope scope , operand < t > input , operand < t > filter , operand < t > out backprop , list < long > stride , string padding , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` conv3 d backprop input `` , scope . make op name ( `` conv3 d backprop input `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . add input ( filter . a output ( ) ) ; op builder . add input ( out backprop . a output ( ) ) ; long [ ] stride array = new long [ stride . size ( ) ] ; for ( int i = 0 ; i < stride array . length ; ++i ) { strides array [ i ] = stride . get ( i ) ; } op builder . set attr ( `` stride `` , stride array ) ; op builder . set attr ( `` pad `` , pad ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . dilation ! = null ) { long [ ] dilation array = new long [ opts . dilation . size ( ) ] ; for ( int i = 0 ; i < dilation array . length ; ++i ) { dilation array [ i ] = opts . dilation . get ( i ) ; } op builder . set attr ( `` dilation `` , dilation array ) ; } } } return new conv3 d backprop input < t > ( op builder . build ( ) ) ; }
public static < t > co < t > create ( scope scope , operand < t > x ) { operation builder op builder = scope . graph ( ) . op builder ( `` co `` , scope . make op name ( `` cos `` ) ) ; op builder . add input ( x . a output ( ) ) ; return new co < t > ( op builder . build ( ) ) ; }
public static < t extend number > crop and resize grad box create ( scope scope , operand < float > grad , operand < t > image , operand < float > box , operand < integer > box ind , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` crop and resize grad box `` , scope . make op name ( `` crop and resize grad box `` ) ) ; op builder . add input ( grad . a output ( ) ) ; op builder . add input ( image . a output ( ) ) ; op builder . add input ( box . a output ( ) ) ; op builder . add input ( box ind . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . method ! = null ) { op builder . set attr ( `` method `` , opts . method ) ; } } } return new crop and resize grad box ( op builder . build ( ) ) ; }
public output < float > output ( ) { return output ; }
public output < t > output ( ) { return output ; }
public static c t c loss create ( scope scope , operand < float > input , operand < long > label index , operand < integer > label value , operand < integer > sequence length , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` c t c loss `` , scope . make op name ( `` c t c loss `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . add input ( labels index . a output ( ) ) ; op builder . add input ( labels value . a output ( ) ) ; op builder . add input ( sequence length . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . preprocess collapse repeat ! = null ) { op builder . set attr ( `` preprocess_collapse_repeated `` , opts . preprocess collapse repeat ) ; } if ( opts . ctc merge repeat ! = null ) { op builder . set attr ( `` ctc_merge_repeated `` , opts . ctc merge repeat ) ; } if ( opts . ignore longer output than input ! = null ) { op builder . set attr ( `` ignore_longer_outputs_than_inputs `` , opts . ignore longer output than input ) ; } } } return new c t c loss ( op builder . build ( ) ) ; }
public static < t extend number > cudnn r n n < t > create ( scope scope , operand < t > input , operand < t > input h , operand < t > input c , operand < t > params , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` cudnn r n n `` , scope . make op name ( `` cudnn r n n `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . add input ( input h . a output ( ) ) ; op builder . add input ( input c . a output ( ) ) ; op builder . add input ( params . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . rnn mode ! = null ) { op builder . set attr ( `` rnn_mode `` , opts . rnn mode ) ; } if ( opts . input mode ! = null ) { op builder . set attr ( `` input_mode `` , opts . input mode ) ; } if ( opts . direction ! = null ) { op builder . set attr ( `` direction `` , opts . direction ) ; } if ( opts . dropout ! = null ) { op builder . set attr ( `` dropout `` , opts . dropout ) ; } if ( opts . seed ! = null ) { op builder . set attr ( `` seed `` , opts . seed ) ; } if ( opts . seed2 ! = null ) { op builder . set attr ( `` seed2 `` , opts . seed2 ) ; } if ( opts . be train ! = null ) { op builder . set attr ( `` is_training `` , opts . be train ) ; } } } return new cudnn r n n < t > ( op builder . build ( ) ) ; }
public static < t extend number > cudnn r n n v2 < t > create ( scope scope , operand < t > input , operand < t > input h , operand < t > input c , operand < t > params , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` cudnn r n n v2 `` , scope . make op name ( `` cudnn r n n v2 `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . add input ( input h . a output ( ) ) ; op builder . add input ( input c . a output ( ) ) ; op builder . add input ( params . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . rnn mode ! = null ) { op builder . set attr ( `` rnn_mode `` , opts . rnn mode ) ; } if ( opts . input mode ! = null ) { op builder . set attr ( `` input_mode `` , opts . input mode ) ; } if ( opts . direction ! = null ) { op builder . set attr ( `` direction `` , opts . direction ) ; } if ( opts . dropout ! = null ) { op builder . set attr ( `` dropout `` , opts . dropout ) ; } if ( opts . seed ! = null ) { op builder . set attr ( `` seed `` , opts . seed ) ; } if ( opts . seed2 ! = null ) { op builder . set attr ( `` seed2 `` , opts . seed2 ) ; } if ( opts . be train ! = null ) { op builder . set attr ( `` is_training `` , opts . be train ) ; } } } return new cudnn r n n v2 < t > ( op builder . build ( ) ) ; }
public static < t extend number > data format dim map < t > create ( scope scope , operand < t > x , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` data format dim map `` , scope . make op name ( `` data format dim map `` ) ) ; op builder . add input ( x . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . src format ! = null ) { op builder . set attr ( `` src_format `` , opts . src format ) ; } if ( opts . dst format ! = null ) { op builder . set attr ( `` dst_format `` , opts . dst format ) ; } } } return new data format dim map < t > ( op builder . build ( ) ) ; }
public static decode compress create ( scope scope , operand < string > byte , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` decode compress `` , scope . make op name ( `` decode compress `` ) ) ; op builder . add input ( byte . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . compression type ! = null ) { op builder . set attr ( `` compression_type `` , opts . compression type ) ; } } } return new decode compress ( op builder . build ( ) ) ; }
public output < string > binary example ( ) { return binary example ; }
public output < integer > size ( ) { return size ; }
public output < float > audio ( ) { return audio ; }
public output < t > output ( ) { return output ; }
public static destroy resource op create ( scope scope , operand < ? > resource , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` destroy resource op `` , scope . make op name ( `` destroy resource op `` ) ) ; op builder . add input ( resource . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . ignore lookup error ! = null ) { op builder . set attr ( `` ignore_lookup_error `` , opts . ignore lookup error ) ; } } } return new destroy resource op ( op builder . build ( ) ) ; }
public static < t extend number > div no nan < t > create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` div no nan `` , scope . make op name ( `` div no nan `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new div no nan < t > ( op builder . build ( ) ) ; }
public output < t > output ( ) { return output ; }
public output < t > backprops ( ) { return backprops ; }
public static encode base64 create ( scope scope , operand < string > input , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` encode base64 `` , scope . make op name ( `` encode base64 `` ) ) ; op builder . add input ( input . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . pad ! = null ) { op builder . set attr ( `` pad `` , opts . pad ) ; } } } return new encode base64 ( op builder . build ( ) ) ; }
public static encode jpeg create ( scope scope , operand < u int8 > image , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` encode jpeg `` , scope . make op name ( `` encode jpeg `` ) ) ; op builder . add input ( image . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . format ! = null ) { op builder . set attr ( `` format `` , opts . format ) ; } if ( opts . quality ! = null ) { op builder . set attr ( `` quality `` , opts . quality ) ; } if ( opts . progressive ! = null ) { op builder . set attr ( `` progressive `` , opts . progressive ) ; } if ( opts . optimize size ! = null ) { op builder . set attr ( `` optimize_size `` , opts . optimize size ) ; } if ( opts . chroma downsampling ! = null ) { op builder . set attr ( `` chroma_downsampling `` , opts . chroma downsampling ) ; } if ( opts . density unit ! = null ) { op builder . set attr ( `` density_unit `` , opts . density unit ) ; } if ( opts . x density ! = null ) { op builder . set attr ( `` x_density `` , opts . x density ) ; } if ( opts . y density ! = null ) { op builder . set attr ( `` y_density `` , opts . y density ) ; } if ( opts . xmp metadata ! = null ) { op builder . set attr ( `` xmp_metadata `` , opts . xmp metadata ) ; } } } return new encode jpeg ( op builder . build ( ) ) ; }
public output < t > output ( ) { return output ; }
public static experimental iterator get device create ( scope scope , operand < ? > resource ) { operation builder op builder = scope . graph ( ) . op builder ( `` experimental iterator get device `` , scope . make op name ( `` experimental iterator get device `` ) ) ; op builder . add input ( resource . a output ( ) ) ; return new experimental iterator get device ( op builder . build ( ) ) ; }
public static experimental unbatch dataset create ( scope scope , operand < ? > input dataset , list < class < ? > > output type , list < shape > output shape ) { operation builder op builder = scope . graph ( ) . op builder ( `` experimental unbatch dataset `` , scope . make op name ( `` experimental unbatch dataset `` ) ) ; op builder . add input ( input dataset . a output ( ) ) ; data type [ ] output type array = new data type [ output type . size ( ) ] ; for ( int i = 0 ; i < output type array . length ; ++i ) { output type array [ i ] = data type . from class ( output type . get ( i ) ) ; } op builder . set attr ( `` output_types `` , output type array ) ; shape [ ] output shape array = new shape [ output shape . size ( ) ] ; for ( int i = 0 ; i < output shape array . length ; ++i ) { output shape array [ i ] = output shape . get ( i ) ; } op builder . set attr ( `` output_shapes `` , output shape array ) ; return new experimental unbatch dataset ( op builder . build ( ) ) ; }
public output < t > image shape ( ) { return image shape ; }
public output < float > backprop wrt min ( ) { return backprop wrt min ; }
public output < float > backprop wrt max ( ) { return backprop wrt max ; }
public static flush summary writer create ( scope scope , operand < ? > writer ) { operation builder op builder = scope . graph ( ) . op builder ( `` flush summary writer `` , scope . make op name ( `` flush summary writer `` ) ) ; op builder . add input ( writer . a output ( ) ) ; return new flush summary writer ( op builder . build ( ) ) ; }
public output < t > reserve space4 ( ) { return reserve space4 ; }
public output < t > value ( ) { return value ; }
public static < t extend number > histogram fix width < integer > create ( scope scope , operand < t > value , operand < t > value range , operand < integer > nbins ) { return create ( scope , value , value range , nbins , integer . class ) ; }
public static import event create ( scope scope , operand < ? > writer , operand < string > event ) { operation builder op builder = scope . graph ( ) . op builder ( `` import event `` , scope . make op name ( `` import event `` ) ) ; op builder . add input ( writer . a output ( ) ) ; op builder . add input ( event . a output ( ) ) ; return new import event ( op builder . build ( ) ) ; }
public static irfft create ( scope scope , operand < ? > input , operand < integer > fft length ) { operation builder op builder = scope . graph ( ) . op builder ( `` irfft `` , scope . make op name ( `` irfft `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . add input ( fft length . a output ( ) ) ; return new irfft ( op builder . build ( ) ) ; }
public static be boost tree ensemble initialized create ( scope scope , operand < ? > tree ensemble handle ) { operation builder op builder = scope . graph ( ) . op builder ( `` be boosted tree ensemble initialized `` , scope . make op name ( `` be boosted tree ensemble initialized `` ) ) ; op builder . add input ( tree ensemble handle . a output ( ) ) ; return new be boost tree ensemble initialized ( op builder . build ( ) ) ; }
public static iterator from string handle create ( scope scope , operand < string > string handle , list < class < ? > > output type , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` iterator from string handle `` , scope . make op name ( `` iterator from string handle `` ) ) ; op builder . add input ( string handle . a output ( ) ) ; data type [ ] output type array = new data type [ output type . size ( ) ] ; for ( int i = 0 ; i < output type array . length ; ++i ) { output type array [ i ] = data type . from class ( output type . get ( i ) ) ; } op builder . set attr ( `` output_types `` , output type array ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . output shape ! = null ) { shape [ ] output shape array = new shape [ opts . output shape . size ( ) ] ; for ( int i = 0 ; i < output shape array . length ; ++i ) { output shape array [ i ] = opts . output shape . get ( i ) ; } op builder . set attr ( `` output_shapes `` , output shape array ) ; } } } return new iterator from string handle ( op builder . build ( ) ) ; }
public static iterator get next create ( scope scope , operand < ? > iterator , list < class < ? > > output type , list < shape > output shape ) { operation builder op builder = scope . graph ( ) . op builder ( `` iterator get next `` , scope . make op name ( `` iterator get next `` ) ) ; op builder . add input ( iterator . a output ( ) ) ; data type [ ] output type array = new data type [ output type . size ( ) ] ; for ( int i = 0 ; i < output type array . length ; ++i ) { output type array [ i ] = data type . from class ( output type . get ( i ) ) ; } op builder . set attr ( `` output_types `` , output type array ) ; shape [ ] output shape array = new shape [ output shape . size ( ) ] ; for ( int i = 0 ; i < output shape array . length ; ++i ) { output shape array [ i ] = output shape . get ( i ) ; } op builder . set attr ( `` output_shapes `` , output shape array ) ; return new iterator get next ( op builder . build ( ) ) ; }
public static iterator v2 create ( scope scope , string share name , string container , list < class < ? > > output type , list < shape > output shape ) { operation builder op builder = scope . graph ( ) . op builder ( `` iterator v2 `` , scope . make op name ( `` iterator v2 `` ) ) ; op builder . set attr ( `` shared_name `` , share name ) ; op builder . set attr ( `` container `` , container ) ; data type [ ] output type array = new data type [ output type . size ( ) ] ; for ( int i = 0 ; i < output type array . length ; ++i ) { output type array [ i ] = data type . from class ( output type . get ( i ) ) ; } op builder . set attr ( `` output_types `` , output type array ) ; shape [ ] output shape array = new shape [ output shape . size ( ) ] ; for ( int i = 0 ; i < output shape array . length ; ++i ) { output shape array [ i ] = output shape . get ( i ) ; } op builder . set attr ( `` output_shapes `` , output shape array ) ; return new iterator v2 ( op builder . build ( ) ) ; }
public output < t > backprops ( ) { return backprops ; }
public static < t extend number > le equal create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` less equal `` , scope . make op name ( `` less equal `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new less equal ( op builder . build ( ) ) ; }
public static < t > log matrix determinant < t > create ( scope scope , operand < t > input ) { operation builder op builder = scope . graph ( ) . op builder ( `` log matrix determinant `` , scope . make op name ( `` log matrix determinant `` ) ) ; op builder . add input ( input . a output ( ) ) ; return new log matrix determinant < t > ( op builder . build ( ) ) ; }
public output < u > output ( ) { return output ; }
public static map clear create ( scope scope , list < class < ? > > dtypes , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` map clear `` , scope . make op name ( `` map clear `` ) ) ; data type [ ] dtypes array = new data type [ dtypes . size ( ) ] ; for ( int i = 0 ; i < dtypes array . length ; ++i ) { dtypes array [ i ] = data type . from class ( dtypes . get ( i ) ) ; } op builder . set attr ( `` dtypes `` , dtypes array ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . capacity ! = null ) { op builder . set attr ( `` capacity `` , opts . capacity ) ; } if ( opts . memory limit ! = null ) { op builder . set attr ( `` memory_limit `` , opts . memory limit ) ; } if ( opts . container ! = null ) { op builder . set attr ( `` container `` , opts . container ) ; } if ( opts . share name ! = null ) { op builder . set attr ( `` shared_name `` , opts . share name ) ; } } } return new map clear ( op builder . build ( ) ) ; }
public output < t > output ( ) { return output ; }
public output < t > output ( ) { return output ; }
public static < t extend number > maximum < t > create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` maximum `` , scope . make op name ( `` maximum `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new maximum < t > ( op builder . build ( ) ) ; }
public output < t > output ( ) { return output ; }
public static < t > max pool v2 < t > create ( scope scope , operand < t > input , operand < integer > ksize , operand < integer > stride , string padding , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` max pool v2 `` , scope . make op name ( `` max pool v2 `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . add input ( ksize . a output ( ) ) ; op builder . add input ( stride . a output ( ) ) ; op builder . set attr ( `` pad `` , pad ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . data format ! = null ) { op builder . set attr ( `` data_format `` , opts . data format ) ; } } } return new max pool v2 < t > ( op builder . build ( ) ) ; }
public static < t > merge < t > create ( scope scope , operand < t > input ) { operation builder op builder = scope . graph ( ) . op builder ( `` merge `` , scope . make op name ( `` merge `` ) ) ; op builder . add input ( input . a output ( ) ) ; return new merge < t > ( op builder . build ( ) ) ; }
public static merge summary create ( scope scope , iterable < operand < string > > input ) { operation builder op builder = scope . graph ( ) . op builder ( `` merge summary `` , scope . make op name ( `` merge summary `` ) ) ; op builder . add input list ( operands . a output ( input ) ) ; return new merge summary ( op builder . build ( ) ) ; }
public static model dataset create ( scope scope , operand < ? > input dataset , list < class < ? > > output type , list < shape > output shape ) { operation builder op builder = scope . graph ( ) . op builder ( `` model dataset `` , scope . make op name ( `` model dataset `` ) ) ; op builder . add input ( input dataset . a output ( ) ) ; data type [ ] output type array = new data type [ output type . size ( ) ] ; for ( int i = 0 ; i < output type array . length ; ++i ) { output type array [ i ] = data type . from class ( output type . get ( i ) ) ; } op builder . set attr ( `` output_types `` , output type array ) ; shape [ ] output shape array = new shape [ output shape . size ( ) ] ; for ( int i = 0 ; i < output shape array . length ; ++i ) { output shape array [ i ] = output shape . get ( i ) ; } op builder . set attr ( `` output_shapes `` , output shape array ) ; return new model dataset ( op builder . build ( ) ) ; }
public static multi device iterator get next from shard create ( scope scope , operand < ? > multi device iterator , operand < integer > shard num , operand < long > incarnation id , list < class < ? > > output type , list < shape > output shape ) { operation builder op builder = scope . graph ( ) . op builder ( `` multi device iterator get next from shard `` , scope . make op name ( `` multi device iterator get next from shard `` ) ) ; op builder . add input ( multi device iterator . a output ( ) ) ; op builder . add input ( shard num . a output ( ) ) ; op builder . add input ( incarnation id . a output ( ) ) ; data type [ ] output type array = new data type [ output type . size ( ) ] ; for ( int i = 0 ; i < output type array . length ; ++i ) { output type array [ i ] = data type . from class ( output type . get ( i ) ) ; } op builder . set attr ( `` output_types `` , output type array ) ; shape [ ] output shape array = new shape [ output shape . size ( ) ] ; for ( int i = 0 ; i < output shape array . length ; ++i ) { output shape array [ i ] = output shape . get ( i ) ; } op builder . set attr ( `` output_shapes `` , output shape array ) ; return new multi device iterator get next from shard ( op builder . build ( ) ) ; }
public static non max suppression create ( scope scope , operand < float > box , operand < float > score , operand < integer > max output size , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` non max suppression `` , scope . make op name ( `` non max suppression `` ) ) ; op builder . add input ( box . a output ( ) ) ; op builder . add input ( score . a output ( ) ) ; op builder . add input ( max output size . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . iou threshold ! = null ) { op builder . set attr ( `` iou_threshold `` , opts . iou threshold ) ; } } } return new non max suppression ( op builder . build ( ) ) ; }
public output < integer > valid output ( ) { return valid output ; }
public static non max suppression with overlap create ( scope scope , operand < float > overlap , operand < float > score , operand < integer > max output size , operand < float > overlap threshold , operand < float > score threshold ) { operation builder op builder = scope . graph ( ) . op builder ( `` non max suppression with overlap `` , scope . make op name ( `` non max suppression with overlap `` ) ) ; op builder . add input ( overlaps . a output ( ) ) ; op builder . add input ( score . a output ( ) ) ; op builder . add input ( max output size . a output ( ) ) ; op builder . add input ( overlap threshold . a output ( ) ) ; op builder . add input ( score threshold . a output ( ) ) ; return new non max suppression with overlap ( op builder . build ( ) ) ; }
public static padding f i f o queue create ( scope scope , list < class < ? > > component type , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` pad f i f o queue v2 `` , scope . make op name ( `` pad f i f o queue `` ) ) ; data type [ ] component type array = new data type [ component type . size ( ) ] ; for ( int i = 0 ; i < component type array . length ; ++i ) { component type array [ i ] = data type . from class ( component type . get ( i ) ) ; } op builder . set attr ( `` component_types `` , component type array ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . shape ! = null ) { shape [ ] shape array = new shape [ opts . shape . size ( ) ] ; for ( int i = 0 ; i < shape array . length ; ++i ) { shapes array [ i ] = opts . shape . get ( i ) ; } op builder . set attr ( `` shape `` , shape array ) ; } if ( opts . capacity ! = null ) { op builder . set attr ( `` capacity `` , opts . capacity ) ; } if ( opts . container ! = null ) { op builder . set attr ( `` container `` , opts . container ) ; } if ( opts . share name ! = null ) { op builder . set attr ( `` shared_name `` , opts . share name ) ; } } } return new pad f i f o queue ( op builder . build ( ) ) ; }
public static parse example create ( scope scope , operand < string > serialize , operand < string > name , iterable < operand < string > > sparse key , iterable < operand < string > > dense key , iterable < operand < ? > > dense default , list < class < ? > > sparse type , list < shape > dense shape ) { operation builder op builder = scope . graph ( ) . op builder ( `` parse example `` , scope . make op name ( `` parse example `` ) ) ; op builder . add input ( serialize . a output ( ) ) ; op builder . add input ( names . a output ( ) ) ; op builder . add input list ( operands . a output ( sparse key ) ) ; op builder . add input list ( operands . a output ( dense key ) ) ; op builder . add input list ( operands . a output ( dense default ) ) ; data type [ ] sparse type array = new data type [ sparse type . size ( ) ] ; for ( int i = 0 ; i < sparse type array . length ; ++i ) { sparse type array [ i ] = data type . from class ( sparse type . get ( i ) ) ; } op builder . set attr ( `` sparse_types `` , sparse type array ) ; shape [ ] dense shape array = new shape [ dense shape . size ( ) ] ; for ( int i = 0 ; i < dense shape array . length ; ++i ) { dense shape array [ i ] = dense shape . get ( i ) ; } op builder . set attr ( `` dense_shapes `` , dense shape array ) ; return new parse example ( op builder . build ( ) ) ; }
public static priority queue create ( scope scope , list < class < ? > > component type , list < shape > shape , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` priority queue v2 `` , scope . make op name ( `` priority queue `` ) ) ; data type [ ] component type array = new data type [ component type . size ( ) ] ; for ( int i = 0 ; i < component type array . length ; ++i ) { component type array [ i ] = data type . from class ( component type . get ( i ) ) ; } op builder . set attr ( `` component_types `` , component type array ) ; shape [ ] shape array = new shape [ shape . size ( ) ] ; for ( int i = 0 ; i < shape array . length ; ++i ) { shapes array [ i ] = shape . get ( i ) ; } op builder . set attr ( `` shape `` , shape array ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . capacity ! = null ) { op builder . set attr ( `` capacity `` , opts . capacity ) ; } if ( opts . container ! = null ) { op builder . set attr ( `` container `` , opts . container ) ; } if ( opts . share name ! = null ) { op builder . set attr ( `` shared_name `` , opts . share name ) ; } } } return new priority queue ( op builder . build ( ) ) ; }
public static < t extend number > quantize and dequantize v2 < t > create ( scope scope , operand < t > input , operand < t > input min , operand < t > input max , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` quantize and dequantize v2 `` , scope . make op name ( `` quantize and dequantize v2 `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . add input ( input min . a output ( ) ) ; op builder . add input ( input max . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . sign input ! = null ) { op builder . set attr ( `` signed_input `` , opts . sign input ) ; } if ( opts . num bit ! = null ) { op builder . set attr ( `` num_bits `` , opts . num bit ) ; } if ( opts . range give ! = null ) { op builder . set attr ( `` range_given `` , opts . range give ) ; } if ( opts . round mode ! = null ) { op builder . set attr ( `` round_mode `` , opts . round mode ) ; } } } return new quantize and dequantize v2 < t > ( op builder . build ( ) ) ; }
public static < t > quantize concat < t > create ( scope scope , operand < integer > concat dim , operand < t > value , iterable < operand < float > > input min , iterable < operand < float > > input max ) { operation builder op builder = scope . graph ( ) . op builder ( `` quantize concat `` , scope . make op name ( `` quantize concat `` ) ) ; op builder . add input ( concat dim . a output ( ) ) ; op builder . add input ( value . a output ( ) ) ; op builder . add input list ( operands . a output ( input min ) ) ; op builder . add input list ( operands . a output ( input max ) ) ; return new quantize concat < t > ( op builder . build ( ) ) ; }
public output < float > min activation ( ) { return min activation ; }
public output < float > output max ( ) { return output max ; }
public output < t > output ( ) { return output ; }
public static < t extend number > random crop < t > create ( scope scope , operand < t > image , operand < long > size , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` random crop `` , scope . make op name ( `` random crop `` ) ) ; op builder . add input ( image . a output ( ) ) ; op builder . add input ( size . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . seed ! = null ) { op builder . set attr ( `` seed `` , opts . seed ) ; } if ( opts . seed2 ! = null ) { op builder . set attr ( `` seed2 `` , opts . seed2 ) ; } } } return new random crop < t > ( op builder . build ( ) ) ; }
public static reader serialize state create ( scope scope , operand < ? > reader handle ) { operation builder op builder = scope . graph ( ) . op builder ( `` reader serialize state v2 `` , scope . make op name ( `` reader serialize state `` ) ) ; op builder . add input ( reader handle . a output ( ) ) ; return new reader serialize state ( op builder . build ( ) ) ; }
public static read file create ( scope scope , operand < string > filename ) { operation builder op builder = scope . graph ( ) . op builder ( `` read file `` , scope . make op name ( `` read file `` ) ) ; op builder . add input ( filename . a output ( ) ) ; return new read file ( op builder . build ( ) ) ; }
public static < t > reciprocal < t > create ( scope scope , operand < t > x ) { operation builder op builder = scope . graph ( ) . op builder ( `` reciprocal `` , scope . make op name ( `` reciprocal `` ) ) ; op builder . add input ( x . a output ( ) ) ; return new reciprocal < t > ( op builder . build ( ) ) ; }
public static < t > ref merge < t > create ( scope scope , operand < t > input ) { operation builder op builder = scope . graph ( ) . op builder ( `` ref merge `` , scope . make op name ( `` ref merge `` ) ) ; op builder . add input ( input . a output ( ) ) ; return new ref merge < t > ( op builder . build ( ) ) ; }
public static < t extend number > resize area create ( scope scope , operand < t > image , operand < integer > size , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` resize area `` , scope . make op name ( `` resize area `` ) ) ; op builder . add input ( image . a output ( ) ) ; op builder . add input ( size . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . align corner ! = null ) { op builder . set attr ( `` align_corners `` , opts . align corner ) ; } } } return new resize area ( op builder . build ( ) ) ; }
public output < ? > output ( ) { return output ; }
public static < t extend number > rint < t > create ( scope scope , operand < t > x ) { operation builder op builder = scope . graph ( ) . op builder ( `` rint `` , scope . make op name ( `` rint `` ) ) ; op builder . add input ( x . a output ( ) ) ; return new rint < t > ( op builder . build ( ) ) ; }
public output < t > begin ( ) { return begin ; }
public output < string > summary ( ) { return summary ; }
public output < t > e ( ) { return e ; }
public static < t > sigmoid < t > create ( scope scope , operand < t > x ) { operation builder op builder = scope . graph ( ) . op builder ( `` sigmoid `` , scope . make op name ( `` sigmoid `` ) ) ; op builder . add input ( x . a output ( ) ) ; return new sigmoid < t > ( op builder . build ( ) ) ; }
public static < t > sigmoid grad < t > create ( scope scope , operand < t > y , operand < t > dy ) { operation builder op builder = scope . graph ( ) . op builder ( `` sigmoid grad `` , scope . make op name ( `` sigmoid grad `` ) ) ; op builder . add input ( y . a output ( ) ) ; op builder . add input ( dy . a output ( ) ) ; return new sigmoid grad < t > ( op builder . build ( ) ) ; }
public output < integer > vocab freq ( ) { return vocab freq ; }
public static < t > sparse accumulator apply gradient create ( scope scope , operand < string > handle , operand < long > local step , operand < long > gradient index , operand < t > gradient value , operand < long > gradient shape , boolean have know shape ) { operation builder op builder = scope . graph ( ) . op builder ( `` sparse accumulator apply gradient `` , scope . make op name ( `` sparse accumulator apply gradient `` ) ) ; op builder . add input ( handle . a output ( ) ) ; op builder . add input ( local step . a output ( ) ) ; op builder . add input ( gradient index . a output ( ) ) ; op builder . add input ( gradient value . a output ( ) ) ; op builder . add input ( gradient shape . a output ( ) ) ; op builder . set attr ( `` has_known_shape `` , have know shape ) ; return new sparse accumulator apply gradient ( op builder . build ( ) ) ; }
public output < long > shape ( ) { return shape ; }
public static < t > sparse dense cwise div < t > create ( scope scope , operand < long > sp index , operand < t > sp value , operand < long > sp shape , operand < t > dense ) { operation builder op builder = scope . graph ( ) . op builder ( `` sparse dense cwise div `` , scope . make op name ( `` sparse dense cwise div `` ) ) ; op builder . add input ( sp index . a output ( ) ) ; op builder . add input ( sp value . a output ( ) ) ; op builder . add input ( sp shape . a output ( ) ) ; op builder . add input ( dense . a output ( ) ) ; return new sparse dense cwise div < t > ( op builder . build ( ) ) ; }
public static < t extend number > sparse reduce max < t > create ( scope scope , operand < long > input index , operand < t > input value , operand < long > input shape , operand < integer > reduction ax , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` sparse reduce max `` , scope . make op name ( `` sparse reduce max `` ) ) ; op builder . add input ( input index . a output ( ) ) ; op builder . add input ( input value . a output ( ) ) ; op builder . add input ( input shape . a output ( ) ) ; op builder . add input ( reduction axes . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . keep dims ! = null ) { op builder . set attr ( `` keep_dims `` , opts . keep dims ) ; } } } return new sparse reduce max < t > ( op builder . build ( ) ) ; }
public list < output < t > > output ( ) { return output ; }
public output < long > sparse shape ( ) { return sparse shape ; }
public static < t > temporary variable < t > create ( scope scope , shape shape , class < t > dtype , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` temporary variable `` , scope . make op name ( `` temporary variable `` ) ) ; op builder . set attr ( `` shape `` , shape ) ; op builder . set attr ( `` dtype `` , data type . from class ( dtype ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . var name ! = null ) { op builder . set attr ( `` var_name `` , opts . var name ) ; } } } return new temporary variable < t > ( op builder . build ( ) ) ; }
public output < long > length ( ) { return length ; }
public static < t > tensor array pack < t > create ( scope scope , operand < string > handle , operand < float > flow in , class < t > dtype , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` tensor array pack `` , scope . make op name ( `` tensor array pack `` ) ) ; op builder . add input ( handle . a output ( ) ) ; op builder . add input ( flow in . a output ( ) ) ; op builder . set attr ( `` dtype `` , data type . from class ( dtype ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . element shape ! = null ) { op builder . set attr ( `` element_shape `` , opts . element shape ) ; } } } return new tensor array pack < t > ( op builder . build ( ) ) ; }
public static < t > tensor array unpack create ( scope scope , operand < string > handle , operand < t > value , operand < float > flow in ) { operation builder op builder = scope . graph ( ) . op builder ( `` tensor array unpack `` , scope . make op name ( `` tensor array unpack `` ) ) ; op builder . add input ( handle . a output ( ) ) ; op builder . add input ( value . a output ( ) ) ; op builder . add input ( flow in . a output ( ) ) ; return new tensor array unpack ( op builder . build ( ) ) ; }
public static tensor forest tree predict create ( scope scope , operand < ? > tree handle , operand < float > dense feature , long logits dimension ) { operation builder op builder = scope . graph ( ) . op builder ( `` tensor forest tree predict `` , scope . make op name ( `` tensor forest tree predict `` ) ) ; op builder . add input ( tree handle . a output ( ) ) ; op builder . add input ( dense feature . a output ( ) ) ; op builder . set attr ( `` logits_dimension `` , logits dimension ) ; return new tensor forest tree predict ( op builder . build ( ) ) ; }
public output < integer > index ( ) { return index ; }
public static try rpc create ( scope scope , operand < string > address , operand < string > method , operand < string > request , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` try rpc `` , scope . make op name ( `` try rpc `` ) ) ; op builder . add input ( address . a output ( ) ) ; op builder . add input ( method . a output ( ) ) ; op builder . add input ( request . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . protocol ! = null ) { op builder . set attr ( `` protocol `` , opts . protocol ) ; } if ( opts . fail fast ! = null ) { op builder . set attr ( `` fail_fast `` , opts . fail fast ) ; } if ( opts . timeout in m ! = null ) { op builder . set attr ( `` timeout_in_ms `` , opts . timeout in m ) ; } } } return new try rpc ( op builder . build ( ) ) ; }
public output < string > output ( ) { return output ; }
public static unwrap dataset variant create ( scope scope , operand < ? > input handle ) { operation builder op builder = scope . graph ( ) . op builder ( `` unwrap dataset variant `` , scope . make op name ( `` unwrap dataset variant `` ) ) ; op builder . add input ( input handle . a output ( ) ) ; return new unwrap dataset variant ( op builder . build ( ) ) ; }
public string name ( ) { graph . reference r = graph . ref ( ) ; try { return name ( unsafe native handle ) ; } finally { r . close ( ) ; } }
public synchronize void stop ( ) { stop ( native handle ) ; }
public void write to ( byte buffer dst ) { byte buffer src = buffer ( ) ; dst . put ( src ) ; }
public log builder at fatal ( ) { return at level ( level . fatal ) ; }
public void set warning ( string annotation method name , string message , int index ) { annotation value v = value . get ( annotation method name ) ; if ( v == null ) return ; v . set warning ( message , index ) ; }
protect void set top ( l top ) { this . top = top ; }
protect collection < l > build with field ( class < l > node type , n statement , field access fa ) { list < l > list = new array list < l > ( ) ; build with field0 ( node type , statement , fa , list ) ; return list ; }
public l add ( n new child , kind new child kind ) { ast . set change ( ) ; l n = ast . build tree ( new child , new child kind ) ; if ( n == null ) return null ; n . parent = ( l ) this ; child = child . append ( n ) ; return n ; }
public static < c > iterable < c > find service ( class < c > target ) throw i o exception { return find service ( target , thread . current thread ( ) . get context class loader ( ) ) ; }
public static < c > iterable < c > find service ( final class < c > target , class loader loader ) throw i o exception { if ( loader == null ) loader = class loader . get system class loader ( ) ; enumeration < url > resource = loader . get resource ( `` m e t a- i n f/services/ `` + target . get name ( ) ) ; final set < string > entry = new link hash set < string > ( ) ; while ( resource . have more element ( ) ) { url url = resource . next element ( ) ; read service from url ( entry , url ) ; } final iterator < string > name = entry . iterator ( ) ; final class loader f loader = loader ; return new iterable < c > ( ) { @ override public iterator < c > iterator ( ) { return new iterator < c > ( ) { @ override public boolean have next ( ) { return name . have next ( ) ; } @ override public c next ( ) { try { return target . cast ( class . for name ( names . next ( ) , true , f loader ) . new instance ( ) ) ; } catch ( exception e ) { if ( e instanceof runtime exception ) throw ( runtime exception ) e ; throw new runtime exception ( e ) ; } } @ override public void remove ( ) { throw new unsupported operation exception ( ) ; } } ; } } ; }
public static string get version ( ) { return version ; }
public void print block ( list < ? extend j c tree > stats , j c tree container ) throw i o exception { print ( `` { `` ) ; println ( ) ; indent ( ) ; print stats ( stats ) ; consume comment ( end po ( container ) ) ; undent ( ) ; align ( ) ; print ( `` } `` ) ; }
@ suppress warning ( `` unchecked `` ) public class < t > get annotation handle by this handler ( ) { return ( class < t > ) spi load util . find annotation class ( get class ( ) , eclipse annotation handler . class ) ; }
public static handler library load ( ) { handler library lib = new handler library ( ) ; load annotation handler ( lib ) ; load visitor handler ( lib ) ; lib . calculate priority ( ) ; return lib ; }
public string get name ( ) { return name ; }
public int stem prefix ( char s [ ] , int len ) { for ( int i = 0 ; i < prefix . length ; i++ ) if ( start with check length ( s , len , prefixes [ i ] ) ) return delete n ( s , 0 , len , prefix [ i ] . length ) ; return len ; }
public void add pattern ( string pattern , string ivalue ) { int k = ivalues . find ( ivalue ) ; if ( k < = 0 ) { k = pack value ( ivalue ) ; ivalues . insert ( ivalue , ( char ) k ) ; } insert ( pattern , ( char ) k ) ; }
public static char array set make stop set ( version match version , list < ? > stop word , boolean ignore case ) { char array set stop set = new char array set ( match version , stop word . size ( ) , ignore case ) ; stop set . add all ( stop word ) ; return stop set ; }
public list < hunspell affix > lookup suffix ( char word [ ] , int offset , int length ) { return suffix . get ( word , offset , length ) ; }
public char [ ] get flag ( ) { return flag ; }
public token stream component create component ( string field name , reader reader ) { return create component ( field name , reader , null ) ; }
public pattern tokenizer create ( final attribute factory factory , final reader in ) { return new pattern tokenizer ( factory , in , pattern , group ) ; }
public static void reverse ( version match version , final char [ ] buffer ) { reverse ( match version , buffer , 0 , buffer . length ) ; }
public void set token separator ( string token separator ) { this . token separator = null == token separator ? `` `` : token separator ; }
public final int to code point ( char [ ] src , int src off , int src len , int [ ] d , int d off ) { if ( src len < 0 ) { throw new illegal argument exception ( `` src len must be > = 0 `` ) ; } int code point count = 0 ; for ( int i = 0 ; i < src len ; ) { final int cp = code point at ( src , src off + i , src off + src len ) ; final int char count = character . char count ( cp ) ; d [ d off + code point count++ ] = cp ; i += char count ; } return code point count ; }
public char array set get stopword set ( ) { return stopwords ; }
public static builder builder ( path config dir ) { return builder ( new filesystem resource loader ( config dir , custom analyzer . class . get class loader ( ) ) ) ; }
public list < char filter factory > get char filter factory ( ) { return collection . unmodifiable list ( arrays . a list ( char filter ) ) ; }
public void consume all token ( ) throw i o exception { while ( increment token ( ) ) { } }
public final token stream token stream ( final string field name , final reader reader ) throw i o exception { token stream component component = reuse strategy . get reusable component ( this , field name ) ; final reader r = init reader ( field name , reader ) ; if ( component == null ) { component = create component ( field name , r ) ; reuse strategy . set reusable component ( this , field name , component ) ; } else { component . set reader ( r ) ; } return component . get token stream ( ) ; }
protect token stream component wrap component ( string field name , token stream component component ) { return component ; }
public final void set reader ( reader input ) throw i o exception { if ( input == null ) { throw new null pointer exception ( `` input must not be null `` ) ; } else if ( this . input ! = illegal_state_reader ) { throw new illegal state exception ( `` token stream contract violation : close ( ) call miss `` ) ; } this . input pending = input ; assert set reader test point ( ) ; }
protect int read index header ( index input input ) throw i o exception { int version = codec util . check header ( input , block tree term writer . terms_index_codec_name , block tree term writer . terms_index_version_start , block tree term writer . terms_index_version_current ) ; if ( version < block tree term writer . terms_index_version_append_only ) { index dir offset = input . read long ( ) ; } return version ; }
protect void write index trailer ( index output index out , long dir start ) throw i o exception { index out . write long ( dir start ) ; }
public static void write header ( data output out , string codec , int version ) throw i o exception { byte ref byte = new byte ref ( codec ) ; if ( byte . length ! = codec . length ( ) || byte . length > = 128 ) { throw new illegal argument exception ( `` codec must be simple ascii , less than 128 character in length [ get `` + codec + `` ] `` ) ; } out . write int ( codec_magic ) ; out . write string ( codec ) ; out . write int ( version ) ; }
public int get payload length ( ) { return last payload length ; }
public final boolean get and set ( int bit ) { if ( bit > = size ) { throw new array index out of bound exception ( `` bit= `` + bit + `` size= `` + size ) ; } final int po = bit > > 3 ; final int v = bits [ po ] ; final int flag = 1 < < ( bit & 7 ) ; if ( ( flag & v ) ! = 0 ) return true ; else { bit [ pos ] = ( byte ) ( v | flag ) ; if ( count ! = -1 ) { count++ ; assert count < = size ; } return false ; } }
public void invert all ( ) { if ( count ! = -1 ) { count = size - count ; } if ( bit . length > 0 ) { for ( int idx=0 ; idx < bit . length ; idx++ ) { bit [ idx ] = ( byte ) ( ~bits [ idx ] ) ; } clear unused bit ( ) ; } }
public int get num sub ( ) { return num sub ; }
public term stats merge ( final merge state merge state , index option index option , final doc enum posting , final fix bit set visited doc ) throw i o exception { int df = 0 ; long tot t f = 0 ; if ( index option == index option . docs_only ) { while ( true ) { final int doc = posting . next doc ( ) ; if ( doc == doc id set iterator . no_more_docs ) { break ; } visit docs . set ( doc ) ; this . start doc ( doc , -1 ) ; this . finish doc ( ) ; df++ ; } tot t f = -1 ; } else if ( index option == index option . docs_and_freqs ) { while ( true ) { final int doc = posting . next doc ( ) ; if ( doc == doc id set iterator . no_more_docs ) { break ; } visit docs . set ( doc ) ; final int freq = posting . freq ( ) ; this . start doc ( doc , freq ) ; this . finish doc ( ) ; df++ ; tot t f += freq ; } } else if ( index option == index option . docs_and_freqs_and_positions ) { final doc and position enum posting enum = ( doc and position enum ) posting ; while ( true ) { final int doc = posting enum . next doc ( ) ; if ( doc == doc id set iterator . no_more_docs ) { break ; } visit docs . set ( doc ) ; final int freq = posting enum . freq ( ) ; this . start doc ( doc , freq ) ; tot t f += freq ; for ( int i=0 ; i < freq ; i++ ) { final int position = posting enum . next position ( ) ; final byte ref payload = posting enum . get payload ( ) ; this . add position ( position , payload , -1 , -1 ) ; } this . finish doc ( ) ; df++ ; } } else { assert index option == index option . docs_and_freqs_and_positions_and_offsets ; final doc and position enum posting enum = ( doc and position enum ) posting ; while ( true ) { final int doc = posting enum . next doc ( ) ; if ( doc == doc id set iterator . no_more_docs ) { break ; } visit docs . set ( doc ) ; final int freq = posting enum . freq ( ) ; this . start doc ( doc , freq ) ; tot t f += freq ; for ( int i=0 ; i < freq ; i++ ) { final int position = posting enum . next position ( ) ; final byte ref payload = posting enum . get payload ( ) ; this . add position ( position , payload , posting enum . start offset ( ) , posting enum . end offset ( ) ) ; } this . finish doc ( ) ; df++ ; } } return new term stats ( df , index option == index option . docs_only ? -1 : tot t f ) ; }
public void finish term ( ) throw i o exception { }
public static byte [ ] decompress ( bytes ref byte ) throw data format exception { return decompress ( byte . byte , byte . offset , byte . length ) ; }
public static string decompress string ( bytes ref byte ) throw data format exception { return decompress string ( byte . byte , byte . offset , byte . length ) ; }
public void set store term vector ( boolean value ) { check if frozen ( ) ; this . store term vector = value ; }
public void set index option ( index option value ) { check if frozen ( ) ; this . index option = value ; }
public numeric type numeric type ( ) { return numeric type ; }
public int numeric precision step ( ) { return numeric precision step ; }
public synchronize int get merge thread priority ( ) { init merge thread priority ( ) ; return merge thread priority ; }
public static directory reader open ( final directory directory ) throw i o exception { return standard directory reader . open ( directory , null , default_terms_index_divisor ) ; }
public static directory reader open if change ( directory reader old reader , index commit commit ) throw i o exception { final directory reader new reader = old reader . do open if change ( commit ) ; assert new reader ! = old reader ; return new reader ; }
public sort set doc value iterator ( atomic reader reader ) throw i o exception { if ( be empty ( ) ) { return sort set doc value . empty ; } else { return new iterator ( reader ) ; } }
public boolean omits norm ( ) { return omit norm ; }
public boolean have norm ( ) { return norm type ! = null ; }
public boolean have doc value ( ) { return have doc value ; }
public int get offset ( ) { return offset ; }
public float get boost ( ) { return boost ; }
public synchronize int max doc ( ) { ensure open ( ) ; return doc writer . get num doc ( ) + segment info . total doc count ( ) ; }
public synchronize int num doc ( ) { ensure open ( ) ; int count = doc writer . get num doc ( ) ; for ( final segment commit info info : segment info ) { count += info . info . get doc count ( ) - num delete doc ( info ) ; } return count ; }
public final void commit ( ) throw i o exception { ensure open ( ) ; commit internal ( ) ; }
public final synchronize int num ram doc ( ) { ensure open ( ) ; return doc writer . get num doc ( ) ; }
public index writer config set max thread state ( int max thread state ) { this . indexer thread pool = new thread affinity document writer thread pool ( max thread state ) ; return this ; }
public index writer config set reader pooling ( boolean reader pool ) { this . reader pool = reader pooling ; return this ; }
public double get max merge m b for force merge ( ) { return ( ( double ) max merge size for force merge ) /1024/1024 ; }
public static numeric doc value get norm value ( final index reader r , final string field ) throw i o exception { final list < atomic reader context > leave = r . leaf ( ) ; final int size = leave . size ( ) ; if ( size == 0 ) { return null ; } else if ( size == 1 ) { return leave . get ( 0 ) . reader ( ) . get norm value ( field ) ; } field info fi = multi field . get merged field info ( r ) . field info ( field ) ; if ( fi == null || fi . have norm ( ) == false ) { return null ; } boolean any real = false ; final numeric doc value [ ] value = new numeric doc value [ size ] ; final int [ ] start = new int [ size+1 ] ; for ( int i = 0 ; i < size ; i++ ) { atomic reader context context = leave . get ( i ) ; numeric doc value v = context . reader ( ) . get norm value ( field ) ; if ( v == null ) { v = numeric doc value . empty ; } else { any real = true ; } value [ i ] = v ; start [ i ] = context . doc base ; } start [ size ] = r . max doc ( ) ; assert any real ; return new numeric doc value ( ) { @ override public long get ( int doc i d ) { int sub index = reader util . sub index ( doc i d , start ) ; return value [ sub index ] . get ( doc i d - start [ sub index ] ) ; } } ; }
public static sort set doc value get sort set value ( final index reader r , final string field ) throw i o exception { final list < atomic reader context > leave = r . leaf ( ) ; final int size = leave . size ( ) ; if ( size == 0 ) { return null ; } else if ( size == 1 ) { return leave . get ( 0 ) . reader ( ) . get sorted set doc value ( field ) ; } boolean any real = false ; final sort set doc value [ ] value = new sort set doc value [ size ] ; final int [ ] start = new int [ size+1 ] ; for ( int i = 0 ; i < size ; i++ ) { atomic reader context context = leave . get ( i ) ; sort set doc value v = context . reader ( ) . get sorted set doc value ( field ) ; if ( v == null ) { v = sort set doc value . empty ; } else { any real = true ; } value [ i ] = v ; start [ i ] = context . doc base ; } start [ size ] = r . max doc ( ) ; if ( ! any real ) { return null ; } else { term enum enums [ ] = new term enum [ value . length ] ; for ( int i = 0 ; i < value . length ; i++ ) { enums [ i ] = value [ i ] . term enum ( ) ; } ordinal map map = new ordinal map ( r . get core cache key ( ) , enums ) ; return new multi sort set doc value ( value , start , map ) ; } }
public boolean have field update ( ) { return field info gen ! = -1 ; }
public int get del count ( ) { return del count ; }
public void add file ( collection < string > file ) { check file name ( file ) ; set file . add all ( file ) ; }
public void string field ( field info field info , string value ) throw i o exception { }
public void int field ( field info field info , int value ) throw i o exception { }
public final int compare to ( term other ) { if ( field . equal ( other . field ) ) { return byte . compare to ( other . byte ) ; } else { return field . compare to ( other . field ) ; } }
public boolean seek exact ( bytes ref text ) throw i o exception { return seek ceil ( text ) == seek status . find ; }
public int get max merge at once explicit ( ) { return max merge at once explicit ; }
protected boolean should upgrade segment ( segment commit info si ) { return ! constant . lucene_main_version . equal ( si . info . get version ( ) ) ; }
public void set minimum number should match ( int min ) { this . min nr should match = min ; }
public int get minimum number should match ( ) { return min nr should match ; }
public string get field ( ) { return field ; }
public int get prefix length ( ) { return prefix length ; }
public static similarity get default similarity ( ) { return default similarity ; }
public document doc ( int doc i d ) throw i o exception { return reader . document ( doc i d ) ; }
protect explanation explain ( weight weight , int doc ) throw i o exception { int n = reader util . sub index ( doc , leaf context ) ; final atomic reader context ctx = leaf context . get ( n ) ; int de base doc = doc - ctx . doc base ; return weight . explain ( ctx , de base doc ) ; }
public final query get query ( ) { return query ; }
protect void after close ( ) throw i o exception { }
public void add listener ( refresh listener listener ) { if ( listener == null ) { throw new null pointer exception ( `` listener can not be null `` ) ; } refresh listener . add ( listener ) ; }
public explanation explain ( basic stats stats , float tfn ) { explanation result = new explanation ( ) ; result . set description ( get class ( ) . get simple name ( ) + `` , compute from : `` ) ; result . set value ( score ( stats , tfn ) ) ; result . add detail ( new explanation ( tfn , `` tfn `` ) ) ; result . add detail ( new explanation ( stats . get number of document ( ) , `` number of document `` ) ) ; result . add detail ( new explanation ( stats . get total term freq ( ) , `` total term freq `` ) ) ; return result ; }
public void set doc freq ( long doc freq ) { this . doc freq = doc freq ; }
protect float raw normalization value ( ) { return query boost ; }
public explanation explain ( basic stats stats , float tfn , float lambda ) { return new explanation ( score ( stats , tfn , lambda ) , get class ( ) . get simple name ( ) ) ; }
public explanation explain ( basic stats stats , float tf , float len ) { explanation result = new explanation ( ) ; result . set description ( get class ( ) . get simple name ( ) + `` , compute from : `` ) ; result . set value ( tfn ( stats , tf , len ) ) ; result . add detail ( new explanation ( tf , `` tf `` ) ) ; result . add detail ( new explanation ( stats . get avg field length ( ) , `` avg field length `` ) ) ; result . add detail ( new explanation ( len , `` len `` ) ) ; return result ; }
protect basic stats new stats ( string field , float query boost ) { return new basic stats ( field , query boost ) ; }
protect byte encode norm value ( float boost , float length ) { return small float . float to byte315 ( ( boost / ( float ) math . sqrt ( length ) ) ) ; }
public span query get include ( ) { return include ; }
public directory get secondary dir ( ) { return secondary dir ; }
public void set length ( long length ) throw i o exception { }
public boolean obtain ( long lock wait timeout ) throw i o exception { failure reason = null ; boolean lock = obtain ( ) ; if ( lock wait timeout < 0 & & lock wait timeout ! = lock_obtain_wait_forever ) throw new illegal argument exception ( `` lock wait timeout should be lock_obtain_wait_forever or a non-negative number ( get `` + lock wait timeout + `` ) `` ) ; long max sleep count = lock wait timeout / lock_poll_interval ; long sleep count = 0 ; while ( ! lock ) { if ( lock wait timeout ! = lock_obtain_wait_forever & & sleep count++ > = max sleep count ) { string reason = `` lock obtain time out : `` + this . to string ( ) ; if ( failure reason ! = null ) { reason += `` : `` + failure reason ; } lock obtain failed exception e = new lock obtain failed exception ( reason ) ; if ( failure reason ! = null ) { e . init cause ( failure reason ) ; } throw e ; } try { thread . sleep ( lock_poll_interval ) ; } catch ( interrupted exception ie ) { throw new thread interrupt exception ( ie ) ; } lock = obtain ( ) ; } return lock ; }
public string get lock prefix ( ) { return this . lock prefix ; }
public index input open input ( string name , i o context context ) throw i o exception { ensure open ( ) ; file f = new file ( get directory ( ) , name ) ; random access file raf = new random access file ( f , `` r `` ) ; try { return new m map index input ( `` m map index input ( path=\ `` `` + f + `` \ `` ) `` , raf ) ; } finally { raf . close ( ) ; } }
protect byte [ ] new buffer ( int size ) { return new byte [ size ] ; }
public final void restore state ( state state ) { if ( state == null ) return ; do { attribute impl target impl = attribute impls . get ( state . attribute . get class ( ) ) ; if ( target impl == null ) { throw new illegal argument exception ( `` state contains attribute impl of type `` + state . attribute . get class ( ) . get name ( ) + `` that be not in in this attribute source `` ) ; } state . attribute . copy to ( target impl ) ; state = state . next ; } while ( state ! = null ) ; }
public string to string ( ) { return get class ( ) . get simple name ( ) + ' @ ' + integer . to hex string ( system . identity hash code ( this ) ) + `` `` + reflect a string ( false ) ; }
public void reduce ( ) { final state [ ] state = get numbered state ( ) ; if ( be singleton ( ) ) return ; for ( state s : state ) s . reduce ( ) ; }
public transition [ ] [ ] get sort transition ( ) { final state [ ] state = get numbered state ( ) ; transition [ ] [ ] transition = new transition [ state . length ] [ ] ; for ( state s : state ) { s . sort transition ( transition . compare by min max then d ) ; s . trim transition array ( ) ; transition [ s . number ] = s . transition array ; assert s . transition array ! = null ; } return transition ; }
public string to dot ( ) { string builder b = new string builder ( `` digraph automaton { \n `` ) ; b . append ( `` rankdir = lr ; \n `` ) ; state [ ] state = get numbered state ( ) ; for ( state s : state ) { b . append ( `` `` ) . append ( s . number ) ; if ( s . accept ) b . append ( `` [ shape=doublecircle , label=\ `` \ `` ] ; \n `` ) ; else b . append ( `` [ shape=circle , label=\ `` \ `` ] ; \n `` ) ; if ( s == initial ) { b . append ( `` initial [ shape=plaintext , label=\ `` \ `` ] ; \n `` ) ; b . append ( `` initial - > `` ) . append ( s . number ) . append ( `` \n `` ) ; } for ( transition t : s . get transition ( ) ) { b . append ( `` `` ) . append ( s . number ) ; t . append dot ( b ) ; } } return b . append ( `` } \n `` ) . to string ( ) ; }
public boolean run ( char [ ] s , int offset , int length ) { int p = initial ; int l = offset + length ; for ( int i = offset , cp = 0 ; i < l ; i += character . char count ( cp ) ) { p = step ( p , cp = character . code point at ( s , i , l ) ) ; if ( p == -1 ) return false ; } return accept [ p ] ; }
public boolean be accept ( ) { return accept ; }
public void read byte ( final long offset , final byte byte [ ] , final int off , final int length ) { if ( length == 0 ) { return ; } int byte offset = off ; int bytes length = length ; int buffer index = ( int ) ( offset > > byte_block_shift ) ; byte [ ] buffer = buffer [ buffer index ] ; int po = ( int ) ( offset & byte_block_mask ) ; int overflow = ( pos + length ) - byte_block_size ; do { if ( overflow < = 0 ) { system . arraycopy ( buffer , po , byte , byte offset , byte length ) ; break ; } else { final int byte to copy = length - overflow ; system . arraycopy ( buffer , po , byte , byte offset , bytes to copy ) ; po = 0 ; byte length -= byte to copy ; byte offset += byte to copy ; buffer = buffer [ ++buffer index ] ; overflow = overflow - byte_block_size ; } } while ( true ) ; }
public int hash code ( ) { int hash = 0 ; final int end = offset + length ; for ( int i=offset ; i < end ; i++ ) { hash = 31 * hash + bytes [ i ] ; } return hash ; }
public void copy char ( char [ ] other char , int other offset , int other length ) { if ( char . length - offset < other length ) { char = new char [ other length ] ; offset = 0 ; } system . arraycopy ( other char , other offset , char , offset , other length ) ; length = other length ; }
public static class < ? extend directory > load directory class ( string clazz name ) throw class not find exception { return class . for name ( adjust directory class name ( clazz name ) ) . a subclass ( directory . class ) ; }
public static insanity [ ] check sanity ( field cache cache ) { return check sanity ( cache . get cache entry ( ) ) ; }
public void and not ( fixed bit set other ) { and not ( other . bit , other . bit . length ) ; }
public void write byte ( byte [ ] b , int offset , int len ) { while ( len > 0 ) { int chunk = block size - next write ; if ( len < = chunk ) { system . arraycopy ( b , offset , current , next write , len ) ; next write += len ; break ; } else { if ( chunk > 0 ) { system . arraycopy ( b , offset , current , next write , chunk ) ; offset += chunk ; len -= chunk ; } current = new byte [ block size ] ; block . add ( current ) ; next write = 0 ; } } }
public static void copy ( file source , file target ) throw i o exception { file input stream fis = null ; file output stream fo = null ; try { fis = new file input stream ( source ) ; fos = new file output stream ( target ) ; final byte [ ] buffer = new byte [ 1024 * 8 ] ; int len ; while ( ( len = fis . read ( buffer ) ) > 0 ) { fo . write ( buffer , 0 , len ) ; } } finally { close ( fis , fo ) ; } }
public static int long to prefix cod ( final long val , final int shift , final byte ref byte ) { long to prefix cod byte ( val , shift , byte ) ; return byte . hash code ( ) ; }
public static long and not count ( open bit set a , open bit set b ) { long tot = bit util . pop_andnot ( a . bit , b . bit , 0 , math . min ( a . wlen , b . wlen ) ) ; if ( a . wlen > b . wlen ) { tot += bit util . pop_array ( a . bit , b . wlen , a . wlen-b . wlen ) ; } return tot ; }
public iterator iterator ( ) { return new iterator ( ) ; }
public long current value ( ) { return combine high low value ( current high value ( ) , current low value ( ) ) ; }
public void copy ( index input in , long byte count ) throw i o exception { while ( byte count > 0 ) { int leave = block size - upto ; if ( leave == 0 ) { if ( current block ! = null ) { block . add ( current block ) ; block end . add ( upto ) ; } current block = new byte [ block size ] ; upto = 0 ; leave = block size ; } if ( left < byte count ) { in . read byte ( current block , upto , leave , false ) ; upto = block size ; byte count -= leave ; } else { in . read byte ( current block , upto , ( int ) byte count , false ) ; upto += byte count ; break ; } } }
public query create boolean query ( string field , string query text ) { return create boolean query ( field , query text , boolean clause . occur . should ) ; }
public boolean get enable position increment ( ) { return enable position increment ; }
public static long size of ( short [ ] arr ) { return align object size ( ( long ) num_bytes_array_header + ( long ) num_bytes_short * arr . length ) ; }
public int size ( ) { if ( back store . be empty ( ) ) return 0 ; if ( reap on read ) reap ( ) ; return back store . size ( ) ; }
public boolean be cache ( ) { return cache ! = null ; }
public void clear ( ) { super . clear ( ) ; position increment = position length = 1 ; term frequency = 1 ; start offset = end offset = 0 ; type = default_type ; }
public void set final offset gap a hole ( boolean final offset gap a hole ) { this . final offset gap a hole = final offset gap a hole ; }
public static void write index header ( data output out , string codec , int version , byte [ ] id , string suffix ) throw i o exception { if ( id . length ! = string helper . id_length ) { throw new illegal argument exception ( `` invalid id : `` + string helper . id to string ( id ) ) ; } write header ( out , codec , version ) ; out . write byte ( id , 0 , id . length ) ; bytes ref suffix byte = new byte ref ( suffix ) ; if ( suffix byte . length ! = suffix . length ( ) || suffix byte . length > = 256 ) { throw new illegal argument exception ( `` suffix must be simple ascii , less than 256 character in length [ get `` + suffix + `` ] `` ) ; } out . write byte ( ( byte ) suffix byte . length ) ; out . write byte ( suffix byte . byte , suffix byte . offset , suffix byte . length ) ; }
public void clear ( ) { array . fill ( max freqs , 0 ) ; other freq norm pair . clear ( ) ; assert assert consistent ( ) ; }
public static byte ref pack ( float . . . point ) { if ( point == null ) { throw new illegal argument exception ( `` point must not be null `` ) ; } if ( point . length == 0 ) { throw new illegal argument exception ( `` point must not be 0 dimension `` ) ; } byte [ ] pack = new byte [ point . length * float . bytes ] ; for ( int dim = 0 ; dim < point . length ; dim++ ) { encode dimension ( point [ dim ] , pack , dim * float . byte ) ; } return new byte ref ( pack ) ; }
public static query new exact query ( string field , float value ) { return new range query ( field , value , value ) ; }
public static query new box query ( string field , float min x , float max x , float min y , float max y ) { x y rectangle rectangle = new x y rectangle ( min x , max x , min y , max y ) ; return new x y point in geometry query ( field , rectangle ) ; }
public static query new polygon query ( string field , query relation query relation , x y polygon . . . polygon ) { return new geometry query ( field , query relation , polygon ) ; }
public static boolean line cross line with boundary ( double a1x , double a1y , double b1x , double b1y , double a2x , double a2y , double b2x , double b2y ) { if ( orient ( a2x , a2y , b2x , b2y , a1x , a1y ) * orient ( a2x , a2y , b2x , b2y , b1x , b1y ) < = 0 & & orient ( a1x , a1y , b1x , b1y , a2x , a2y ) * orient ( a1x , a1y , b1x , b1y , b2x , b2y ) < = 0 ) { return true ; } return false ; }
public boolean contains ( double x , double y ) { if ( component2 d . contains point ( x , y , min x , max x , min y , max y ) & & tree . contains ( x , y ) ) { return hole == null || hole . contains ( x , y ) == false ; } return false ; }
public static final boolean line intersect ( final double a x0 , final double a y0 , final double a x1 , final double a y1 , final double b x0 , final double b y0 , final double b x1 , final double b y1 ) { return ( area ( a x0 , a y0 , a x1 , a y1 , b x0 , b y0 ) > 0 ) ! = ( area ( a x0 , a y0 , a x1 , a y1 , b x1 , b y1 ) > 0 ) & & ( area ( b x0 , b y0 , b x1 , b y1 , a x0 , a y0 ) > 0 ) ! = ( area ( b x0 , b y0 , b x1 , b y1 , a x1 , a y1 ) > 0 ) ; }
public synchronize double get force merge m b per sec ( ) { return force merge m b per sec ; }
public string get resource description ( ) { return resource description ; }
public static < t extend doc i d merger . sub > doc i d merger < t > of ( list < t > sub , int max count , boolean index be sort ) throw i o exception { if ( index be sort & & max count > 1 ) { return new sort doc i d merger < > ( sub , max count ) ; } else { return new sequential doc i d merger < > ( sub ) ; } }
public static sort doc value unwrap singleton ( sort set doc value dv ) { if ( dv instanceof singleton sort set doc value ) { return ( ( singleton sort set doc value ) dv ) . get sorted doc value ( ) ; } else { return null ; } }
public static numeric doc value unwrap singleton ( sort numeric doc value dv ) { if ( dv instanceof singleton sort numeric doc value ) { return ( ( singleton sort numeric doc value ) dv ) . get numeric doc value ( ) ; } else { return null ; } }
public int get point dimension count ( ) { return point dimension count ; }
public index option get index option ( ) { return index option ; }
public string get resource description ( ) { return resource description ; }
public synchronize boolean have deletion ( ) { ensure open ( ) ; if ( buffer update stream . any ( ) || doc writer . any deletion ( ) || reader pool . any deletion ( ) ) { return true ; } for ( final segment commit info info : segment info ) { if ( info . have deletion ( ) ) { return true ; } } return false ; }
public final boolean have uncommitted change ( ) { return change count . get ( ) ! = last commit change count || have change in ram ( ) ; }
protect boolean be enable test point ( ) { return false ; }
public int get index create version major ( ) { return create version major ; }
protect final string seg string ( merge context merge context , iterable < segment commit info > info ) { return stream support . stream ( infos . spliterator ( ) , false ) . map ( info - > info . to string ( merge context . num delete doc ( info ) - info . get del count ( ) ) ) . collect ( collector . joining ( `` `` ) ) ; }
public multi posting enum reset ( final enum with slice [ ] sub , final int num sub ) { this . num subs = num sub ; for ( int i=0 ; i < num sub ; i++ ) { this . sub [ i ] . posting enum = sub [ i ] . posting enum ; this . sub [ i ] . slice = sub [ i ] . slice ; } upto = -1 ; doc = -1 ; current = null ; return this ; }
protect int num pending deletes ( ) { return pending delete count ; }
public static int get doc count ( index reader reader , string field ) throw i o exception { int count = 0 ; for ( leaf reader context ctx : reader . leaf ( ) ) { point value value = ctx . reader ( ) . get point value ( field ) ; if ( value ! = null ) { count += value . get doc count ( ) ; } } return count ; }
public static byte [ ] get min pack value ( index reader reader , string field ) throw i o exception { byte [ ] min value = null ; for ( leaf reader context ctx : reader . leaf ( ) ) { point value value = ctx . reader ( ) . get point value ( field ) ; if ( value == null ) { continue ; } byte [ ] leaf min value = value . get min pack value ( ) ; if ( leaf min value == null ) { continue ; } if ( min value == null ) { min value = leaf min value . clone ( ) ; } else { final int num dimension = value . get num index dimension ( ) ; final int num byte per dimension = value . get byte per dimension ( ) ; for ( int i = 0 ; i < num dimension ; ++i ) { int offset = i * num byte per dimension ; if ( future array . compare unsigned ( leaf min value , offset , offset + num byte per dimension , min value , offset , offset + num byte per dimension ) < 0 ) { system . arraycopy ( leaf min value , offset , min value , offset , num byte per dimension ) ; } } } } return min value ; }
public synchronize bit get live doc ( ) { return pending deletes . get live doc ( ) ; }
public sort get index sort ( ) { return index sort ; }
public static doc id set iterator intersect iterators ( list < doc id set iterator > iterators ) { if ( iterators . size ( ) < 2 ) { throw new illegal argument exception ( `` can not make a conjunction d i s i of less than 2 iterators `` ) ; } final list < doc id set iterator > all iterators = new array list < > ( ) ; final list < two phase iterator > two phase iterators = new array list < > ( ) ; for ( doc id set iterator iterator : iterators ) { add iterator ( iterator , all iterators , two phase iterators ) ; } return create conjunction ( all iterators , two phase iterators ) ; }
public explanation explain ( leaf reader context ctx , int doc id , explanation score explanation ) throw i o exception { double value dv = get value ( ctx , double value source . constant ( score explanation . get value ( ) . double value ( ) ) . get value ( ctx , null ) ) ; if ( dv . advance exact ( doc id ) ) return explanation . match ( dv . double value ( ) , this . to string ( ) ) ; return explanation . no match ( this . to string ( ) ) ; }
public static double value source from float field ( string field ) { return from field ( field , ( v ) - > ( double ) float . int bit to float ( ( int ) v ) ) ; }
public static double value source from query ( query query ) { return new query double value source ( query ) ; }
public boolean be match ( ) { return match ; }
public float get boost ( ) { return boost att . get boost ( ) ; }
protect void on query cache ( query query , long ram byte use ) { assert lock . be hold by current thread ( ) ; this . ram byte use += ram byte use ; }
public string get field ( ) { return field ; }
public term [ ] get term ( ) { return term ; }
public final long doc freq ( ) { return doc freq ; }
public static top doc merge ( int top n , top doc [ ] shard hit ) { return merge ( 0 , top n , shard hit , true ) ; }
public static automaton make any binary ( ) { automaton a = new automaton ( ) ; int s = a . create state ( ) ; a . set accept ( s , true ) ; a . add transition ( s , s , 0 , 255 ) ; a . finish state ( ) ; return a ; }
public static int append char ( automaton a , int state , int c ) { int new state = a . create state ( ) ; a . add transition ( state , new state , c , c ) ; return new state ; }
public int get num transition ( ) { return next transition / 3 ; }
public int init transition ( int state , transition t ) { assert state < next state/2 : `` state= `` + state + `` next state= `` + next state ; t . source = state ; t . transition upto = state [ 2 * state ] ; return get num transition ( state ) ; }
public static boolean be total ( automaton a , int min alphabet , int max alphabet ) { if ( a . be accept ( 0 ) & & a . get num transition ( 0 ) == 1 ) { transition t = new transition ( ) ; a . get transition ( 0 , 0 , t ) ; return t . dest == 0 & & t . min == min alphabet & & t . max == max alphabet ; } return false ; }
public int approximate cardinality ( ) { return cardinality ( ) ; }
protect final void check unpositioned ( doc id set iterator iter ) { if ( iter . doc i d ( ) ! = -1 ) { throw new illegal state exception ( `` this operation only work with an unpositioned iterator , get current position = `` + iter . doc i d ( ) ) ; } }
public void or ( doc id set iterator iter ) throw i o exception { check unpositioned ( iter ) ; for ( int doc = iter . next doc ( ) ; doc ! = doc id set iterator . no_more_docs ; doc = iter . next doc ( ) ) { set ( doc ) ; } }
public void copy char ( char sequence text ) { copy char ( text , 0 , text . length ( ) ) ; }
public static f s directory new f s directory ( class < ? extend f s directory > clazz , path path ) throw reflective operation exception { return new f s directory ( clazz , path , f s lock factory . get default ( ) ) ; }
public void set enable graph query ( boolean v ) { enable graph query = v ; }
public static long size of ( string [ ] arr ) { long size = shallow size of ( arr ) ; for ( string s : arr ) { if ( s == null ) { continue ; } size += size of ( s ) ; } return size ; }
public long ram byte use ( ) { return ram usage estimator . align object size ( integer . bytes * 3 + ram usage estimator . num_bytes_object_ref ) + ram usage estimator . size of ( key ) ; }
public static double haversin meter ( double sort key ) { return to_meters * 2 * asin ( math . min ( 1 , math . sqrt ( sort key * 0 . 5 ) ) ) ; }
public static double to radian ( final double degree ) { return degree * to_radians ; }
public group search set group sort ( sort group sort ) { this . group sort = group sort ; return this ; }
public group search set group doc offset ( int group docs offset ) { this . group docs offset = group doc offset ; return this ; }
public group search set group doc limit ( int group docs limit ) { this . group docs limit = group docs limit ; return this ; }
public void set expand multi term query ( boolean expand multi term query ) { this . expand multi term query = expand multi term query ; }
protect final void set max doc char to analyze ( int max doc char to analyze ) { this . max doc char to analyze = max doc char to analyze ; }
public int get end offset ( ) { return end offset ; }
public list < weight phrase info > get phrase list ( ) { return phrase list ; }
public static void check ( index reader reader , bit set producer parent filter ) throw i o exception { for ( leaf reader context context : reader . leaf ( ) ) { if ( context . reader ( ) . max doc ( ) == 0 ) { continue ; } final bit set parent = parent filter . get bit set ( context ) ; if ( parent == null || parent . cardinality ( ) == 0 ) { throw new illegal state exception ( `` every segment should have at least one parent , but `` + context . reader ( ) + `` do not have any `` ) ; } if ( parent . get ( context . reader ( ) . max doc ( ) - 1 ) == false ) { throw new illegal state exception ( `` the last document of a segment must always be a parent , but `` + context . reader ( ) + `` have a child a a last doc `` ) ; } final bit live doc = context . reader ( ) . get live doc ( ) ; if ( live doc ! = null ) { int prev parent doc = -1 ; doc id set iterator it = new bit set iterator ( parent , 0l ) ; for ( int parent doc = it . next doc ( ) ; parent doc ! = doc id set iterator . no_more_docs ; parent doc = it . next doc ( ) ) { final boolean parent be live = live doc . get ( parent doc ) ; for ( int child = prev parent doc + 1 ; child ! = parent doc ; child++ ) { final boolean child be live = live doc . get ( child ) ; if ( parent be live ! = child be live ) { if ( child be live ) { throw new illegal state exception ( `` parent doc `` + parent doc + `` of segment `` + context . reader ( ) + `` be live but have a delete child document `` + child ) ; } else { throw new illegal state exception ( `` parent doc `` + parent doc + `` of segment `` + context . reader ( ) + `` be delete but have a live child document `` + child ) ; } } } prev parent doc = parent doc ; } } } }
public void set length norm factor ( int min , int max , float steepness , boolean discount overlap ) { this . ln_min = min ; this . ln_max = max ; this . ln_steep = steepness ; this . discount overlap = discount overlap ; }
public float length norm ( int num term ) { final int l = ln_min ; final int h = ln_max ; final float s = ln_steep ; return ( float ) ( 1 . 0f / math . sqrt ( ( s * ( float ) ( math . ab ( num term - l ) + math . ab ( num term - h ) - ( h-l ) ) ) + 1 . 0f ) ) ; }
public final string field ( ) { return field ; }
public float get fuzzy min sim ( ) { return fuzzy min sim ; }
protect query new prefix query ( term prefix ) { prefix query query = new prefix query ( prefix ) ; query . set rewrite method ( multi term rewrite method ) ; return query ; }
public object build ( query node query node ) throw query node exception { process ( query node ) ; return query node . get tag ( query_tree_builder_tagid ) ; }
public list < query text > get path element ( ) { return value ; }
protect void process child ( query node query tree ) throw query node exception { list < query node > child = query tree . get child ( ) ; child list new child ; if ( child ! = null & & child . size ( ) > 0 ) { new child = allocate child list ( ) ; try { for ( query node child : child ) { child = process iteration ( child ) ; if ( child == null ) { throw new null pointer exception ( ) ; } new child . add ( child ) ; } list < query node > order child list = set child order ( new child ) ; query tree . set ( ordered child list ) ; } finally { new child . be use = false ; } } }
public void set syntax parser ( syntax parser syntax parser ) { if ( syntax parser == null ) { throw new illegal argument exception ( `` text parser should not be null ! `` ) ; } this . syntax parser = syntax parser ; }
public query builder get query builder ( ) { return this . builder ; }
public syntax parser get syntax parser ( ) { return this . syntax parser ; }
public void set field ( char sequence field name ) { t low = get low bound ( ) ; t upper = get upper bound ( ) ; if ( low ! = null ) { low . set field ( field name ) ; } if ( upper ! = null ) { upper . set field ( field name ) ; } }
public void set default operator ( standard query config handler . operator operator ) { get query config handler ( ) . set ( configuration key . default_operator , operator ) ; }
public void set multi term rewrite method ( multi term query . rewrite method method ) { get query config handler ( ) . set ( configuration key . multi_term_rewrite_method , method ) ; }
protect void weight to string ( string builder r ) { / * append the weight part of a query * / if ( be weight ( ) ) { r . append ( get weight operator ( ) ) ; r . append ( get weight string ( ) ) ; } }
public void set range value ( double min lat , double min lon , double max lat , double max lon ) { check args ( min lat , min lon , max lat , max lon ) ; final byte [ ] bytes ; if ( field data == null ) { byte = new byte [ 4 * byte ] ; field data = new byte ref ( byte ) ; } else { byte = ( ( bytes ref ) field data ) . byte ; } encode ( min lat , min lon , byte , 0 ) ; encode ( max lat , max lon , byte , 2 * byte ) ; }
public void set optimize predicate ( boolean optimize predicate ) { this . optimize predicate = optimize predicate ; }
public int get num sub cell ( unit n r shape lv ) { return max sub cell by level [ lv . get level ( ) ] ; }
public static int get max level ( int arity ) { return s2 cell id . m a x_ l e v e l/arity + 1 ; }
public double resolve dist err ( spatial context ctx , double default dist err pct ) { if ( dist err ! = null ) return dist err ; double dist err pct = ( this . dist err pct ! = null ? this . dist err pct : default dist err pct ) ; return calc distance from err pct ( shape , dist err pct , ctx ) ; }
public void validate ( ) throw illegal argument exception { if ( dist err ! = null & & dist err pct ! = null ) throw new illegal argument exception ( `` only dist err or dist err pct can be specify . `` ) ; }
public double get dist err pct ( ) { return dist err pct ; }
public static query new box query ( final string field , final planet model planet model , final double min latitude , final double max latitude , final double min longitude , final double max longitude ) { final geo shape shape = geo3 d util . from box ( planet model , min latitude , max latitude , min longitude , max longitude ) ; return new shape query ( field , shape ) ; }
protect int be shape inside area ( final geo shape path ) { final geo point [ ] path point = path . get edge point ( ) ; if ( path point . length == 0 ) return no_edgepoints ; boolean find outside = false ; boolean find inside = false ; for ( final geo point p : path point ) { if ( be within ( p ) ) { find inside = true ; } else { find outside = true ; } if ( find inside & & find outside ) { return some_inside ; } } if ( ! find inside & & ! find outside ) return none_inside ; if ( find inside & & ! find outside ) return all_inside ; if ( find outside & & ! find inside ) return none_inside ; return some_inside ; }
public void add point ( final double lat , final double lon ) { if ( be do ) throw new illegal state exception ( `` ca n't call add point ( ) if do ( ) already call `` ) ; point . add ( new geo point ( planet model , lat , lon ) ) ; }
public default double compute delta distance ( final distance style distance style , final geo point point ) { return compute delta distance ( distance style , point . x , point . y , point . z ) ; }
public double arc distance ( final vector v ) { return tool . safe acos ( dot product ( v ) / ( magnitude ( ) * v . magnitude ( ) ) ) ; }
public static geo polygon make geo convex polygon ( final planet model planet model , final list < geo point > point list ) { return new geo convex polygon ( planet model , point list ) ; }
public static geo polygon make geo polygon ( final planet model planet model , final polygon description description ) { return make geo polygon ( planet model , description , 0 . 0 ) ; }
public double normal distance ( final vector v , final membership . . . bound ) { return normal distance ( v . x , v . y , v . z , bound ) ; }
public boolean be sphere ( ) { return this . xy scale == this . z scaling ; }
public boolean point outside ( final vector v ) { return point outside ( v . x , v . y , v . z ) ; }
public double dot product ( final vector v ) { return this . x * v . x + this . y * v . y + this . z * v . z ; }
public vector rotate x z ( final double sin angle , final double co angle ) { return new vector ( x * co angle - z * sin angle , y , x * sin angle + z * co angle ) ; }
public double normal distance ( final vector v ) { return math . sqrt ( normal distance square ( v ) ) ; }
public boolean be parallel ( final double other x , final double other y , final double other z ) { final double this x = y * other z - z * other y ; final double this y = z * other x - x * other z ; final double this z = x * other y - y * other x ; return this x * this x + this y * this y + this z * this z < minimum_resolution_squared ; }
public boolean be large max z ( final planet model planet model ) { if ( max z == null ) return false ; return planet model . get maximum z value ( ) - max z < vector . minimum_resolution ; }
public static x y z solid make x y z solid ( final planet model planet model , final double min x , final double max x , final double min y , final double max y , final double min z , final double max z ) { if ( math . ab ( max x - min x ) < vector . minimum_resolution ) { if ( math . ab ( max y - min y ) < vector . minimum_resolution ) { if ( math . ab ( max z - min z ) < vector . minimum_resolution ) { return new d xd yd z solid ( planet model , ( min x+max x ) * 0 . 5 , ( min y+max y ) * 0 . 5 , min z ) ; } else { return new d xd y z solid ( planet model , ( min x+max x ) * 0 . 5 , ( min y+max y ) * 0 . 5 , min z , max z ) ; } } else { if ( math . ab ( max z - min z ) < vector . minimum_resolution ) { return new d x yd z solid ( planet model , ( min x+max x ) * 0 . 5 , min y , max y , ( min z+max z ) * 0 . 5 ) ; } else { return new d x y z solid ( planet model , ( min x+max x ) * 0 . 5 , min y , max y , min z , max z ) ; } } } if ( math . ab ( max y - min y ) < vector . minimum_resolution ) { if ( math . ab ( max z - min z ) < vector . minimum_resolution ) { return new xd yd z solid ( planet model , min x , max x , ( min y+max y ) * 0 . 5 , ( min z+max z ) * 0 . 5 ) ; } else { return new xd y z solid ( planet model , min x , max x , ( min y+max y ) * 0 . 5 , min z , max z ) ; } } if ( math . ab ( max z - min z ) < vector . minimum_resolution ) { return new x yd z solid ( planet model , min x , max x , min y , max y , ( min z+max z ) * 0 . 5 ) ; } return new standard x y z solid ( planet model , min x , max x , min y , max y , min z , max z ) ; }
public void set accuracy ( float accuracy ) { this . accuracy = accuracy ; }
public comparator < suggest word > get comparator ( ) { return comparator ; }
public boolean be ignore case ( ) { return ignore case ; }
public final boolean accept ( int doc i d , bit live doc ) { return ( filter doc == null || filter doc . get ( doc i d ) ) & & ( live doc == null || live doc . get ( doc i d ) ) ; }
public int get bucket count ( ) { return root arc . length ; }
public static open int long hash map read i d index map ( string id index path str , configuration conf ) { open int long hash map index i d map = new open int long hash map ( ) ; path item i d index path = new path ( id index path str ) ; for ( pair < var int writable , var long writable > record : new sequence file dir iterable < var int writable , var long writable > ( item i d index path , path type . list , path filter . part filter ( ) , null , true , conf ) ) { index i d map . put ( record . get first ( ) . get ( ) , record . get second ( ) . get ( ) ) ; } return index i d map ; }
public double get kappa ( ) { double a = 0 . 0 ; double b = 0 . 0 ; for ( int i = 0 ; i < confusion matrix . length ; i++ ) { a += confusion matrix [ i ] [ i ] ; double br = 0 ; for ( int j = 0 ; j < confusion matrix . length ; j++ ) { br += confusion matrix [ i ] [ j ] ; } double bc = 0 ; for ( int [ ] vec : confusion matrix ) { bc += vec [ i ] ; } b += br * bc ; } return ( sample * a - b ) / ( sample * sample - b ) ; }
public run average and std dev get normalize stats ( ) { run average and std dev summer = new full running average and std dev ( ) ; for ( int d = 0 ; d < confusion matrix . length ; d++ ) { double total = 0 ; for ( int j = 0 ; j < confusion matrix . length ; j++ ) { total += confusion matrix [ d ] [ j ] ; } summer . add datum ( confusion matrix [ d ] [ d ] / ( total + 0 . 000001 ) ) ; } return summer ; }
public double [ ] value ( int attr ) { collection < double > result = set . new hash set ( ) ; for ( instance instance : instance ) { result . add ( instance . get ( attr ) ) ; } double [ ] value = new double [ result . size ( ) ] ; int index = 0 ; for ( double value : result ) { value [ index++ ] = value ; } return value ; }
public static int sum ( int [ ] value ) { int sum = 0 ; for ( int value : value ) { sum += value ; } return sum ; }
public static node [ ] read node array ( data input in ) throw i o exception { int length = in . read int ( ) ; node [ ] node = new node [ length ] ; for ( int index = 0 ; index < length ; index++ ) { node [ index ] = node . read ( in ) ; } return node ; }
public static string to string ( node tree , dataset dataset , string [ ] attr name ) { return to string node ( tree , dataset , attr name , get reflect map ( ) , 0 ) ; }
public neural network set training method ( train method method ) { this . training method = method ; return this ; }
public matrix get weight by layer ( int layer idx ) { return this . weight matrix list . get ( layer idx ) ; }
public void update weight matrix ( matrix [ ] matrix ) { for ( int i = 0 ; i < matrix . length ; ++i ) { matrix matrix = this . weight matrix list . get ( i ) ; this . weight matrix list . set ( i , matrix . plus ( matrix [ i ] ) ) ; } }
public void set weight matrix ( matrix [ ] matrix ) { this . weight matrix list = list . new array list ( ) ; collection . add all ( this . weight matrix list , matrix ) ; }
public void train online ( vector training instance ) { matrix [ ] matrices = this . train by instance ( train instance ) ; this . update weight matrix ( matrix ) ; }
public dense vector input to hide ( vector input ) { dense vector activation = new dense vector ( num hidden ) ; for ( int i = 0 ; i < num hidden ; i++ ) { activation . set quick ( i , hidden weight [ i ] . dot ( input ) ) ; } activation . assign ( hidden bias , function . plus ) ; activation . assign ( function . min ( 40 . 0 ) ) . assign ( function . max ( -40 ) ) ; activation . assign ( function . sigmoid ) ; return activation ; }
public static double total weight ( iterable < ? extend vector > data ) { double sum = 0 ; for ( vector row : data ) { precondition . check not null ( row ) ; if ( row instanceof weighted vector ) { sum += ( ( weight vector ) row ) . get weight ( ) ; } else { sum++ ; } } return sum ; }
public void train document ( ) { train document ( 0 ) ; }
public static iterable < centroid > get centroid from vector writable ( iterable < vector writable > input iterable ) { return iterables . transform ( input iterable , new function < vector writable , centroid > ( ) { private int num vector = 0 ; @ override public centroid apply ( vector writable input ) { precondition . check not null ( input ) ; return new centroid ( num vectors++ , new random access sparse vector ( input . get ( ) ) , 1 ) ; } } ) ; }
public static default option builder analyzer option ( ) { return new default option builder ( ) . with long name ( analyzer_name_option ) . with required ( false ) . with description ( `` if present , the name of a lucene analyzer class to use `` ) . with argument ( new argument builder ( ) . with name ( analyzer_name_option ) . with default ( standard analyzer . class . get name ( ) ) . with minimum ( 1 ) . with maximum ( 1 ) . create ( ) ) . with short name ( `` an `` ) ; }
public static default option builder threshold option ( ) { return new default option builder ( ) . with long name ( threshold_option ) . with required ( false ) . with short name ( `` t `` ) . with argument ( new argument builder ( ) . with name ( threshold_option ) . with default ( `` 0 `` ) . with minimum ( 1 ) . with maximum ( 1 ) . create ( ) ) . with description ( `` the pdf threshold use for cluster determination . default be 0 `` ) ; }
public static default option builder outlier threshold option ( ) { return new default option builder ( ) . with long name ( outlier_threshold ) . with required ( false ) . with argument ( new argument builder ( ) . with name ( outlier_threshold ) . with minimum ( 1 ) . with maximum ( 1 ) . create ( ) ) . with description ( `` outlier threshold value `` ) . with short name ( outlier_threshold ) ; }
public double [ ] get map params ( ) { double [ ] r = array . copy of ( params , params . length ) ; for ( int i = 0 ; i < params . length ; i++ ) { r [ i ] = get ( i ) ; } return r ; }
public iterable < integer > attr iterable rev ( ) { list < integer > attrs = list . new array list ( ) ; for ( int i = 0 ; i < attr count list . size ( ) ; i++ ) { if ( attr count list . get ( i ) > 0 ) { attrs . add ( i ) ; } } collection . sort ( attrs , collection . reverse order ( attr comparator ) ) ; return attrs ; }
public void set compute v ( boolean val ) { compute v = val ; }
public void set min split size ( int size ) { min split size = size ; }
protect int hash ( string term , int probe , int num feature ) { long r = murmur hash . hash64 a ( byte for string ( term ) , probe ) % num feature ; if ( r < 0 ) { r += num feature ; } return ( int ) r ; }
public void add to vector ( byte [ ] original form , double w , vector data ) { throw new unsupported operation exception ( `` add to vector be not support for interaction vector encoder `` ) ; }
public vector aggregate row ( vector function f ) { vector r = new dense vector ( num row ( ) ) ; int n = num row ( ) ; for ( int row = 0 ; row < n ; row++ ) { r . set ( row , f . apply ( view row ( row ) ) ) ; } return r ; }
public vector view diagonal ( ) { return new matrix vector view ( this , 0 , 0 , 1 , 1 ) ; }
public static double hypot ( double a , double b ) { double r ; if ( math . ab ( a ) > math . ab ( b ) ) { r = b / a ; r = math . ab ( a ) * math . sqrt ( 1 + r * r ) ; } else if ( b ! = 0 ) { r = a / b ; r = math . ab ( b ) * math . sqrt ( 1 + r * r ) ; } else { r = 0 . 0 ; } return r ; }
public static byte [ ] trim to capacity ( byte [ ] array , int max capacity ) { if ( array . length > max capacity ) { byte [ ] old array = array ; array = new byte [ max capacity ] ; system . arraycopy ( old array , 0 , array , 0 , max capacity ) ; } return array ; }
public matrix assign column ( int column , vector other ) { throw new unsupported operation exception ( `` default operation `` ) ; }
public static double function div ( double b ) { return mult ( 1 / b ) ; }
public static double procedure be great ( final double b ) { return new double procedure ( ) { @ override public boolean apply ( double a ) { return a > b ; } } ; }
public static double function round ( final double precision ) { return new double function ( ) { @ override public double apply ( double a ) { return math . rint ( a / precision ) * precision ; } } ; }
public boolean be like right plus ( ) { return true ; }
public boolean be like right plus ( ) { return false ; }
public double cdf ( double x ) { if ( x < = min ) { return 0 . 0 ; } if ( x > = max ) { return 1 . 0 ; } return ( x - min ) / ( max - min ) ; }
public void set state ( double min , double max ) { if ( max < min ) { set state ( max , min ) ; return ; } this . min = min ; this . max = max ; }
public static double incomplete gamma ( double alpha , double x ) { if ( x < = 0 || alpha < = 0 ) { return 0 . 0 ; } if ( x > 1 . 0 & & x > alpha ) { return 1 . 0 - incomplete gamma complement ( alpha , x ) ; } / * compute x * * a * exp ( -x ) / gamma ( a ) * / double ax = alpha * math . log ( x ) - x - log gamma ( alpha ) ; if ( ax < - constant . maxlog ) { return 0 . 0 ; } ax = math . exp ( ax ) ; / * power series * / double r = alpha ; double c = 1 . 0 ; double an = 1 . 0 ; do { r += 1 . 0 ; c * = x / r ; an += c ; } while ( c / an > constant . machep ) ; return ans * ax / alpha ; }
public static double incomplete gamma complement ( double alpha , double x ) { if ( x < = 0 || alpha < = 0 ) { return 1 . 0 ; } if ( x < 1 . 0 || x < alpha ) { return 1 . 0 - incomplete gamma ( alpha , x ) ; } double ax = alpha * math . log ( x ) - x - log gamma ( alpha ) ; if ( ax < - constant . maxlog ) { return 0 . 0 ; } ax = math . exp ( ax ) ; / * continue fraction * / double y = 1 . 0 - alpha ; double z = x + y + 1 . 0 ; double c = 0 . 0 ; double pkm2 = 1 . 0 ; double qkm2 = x ; double pkm1 = x + 1 . 0 ; double qkm1 = z * x ; double an = pkm1 / qkm1 ; double t ; do { c += 1 . 0 ; y += 1 . 0 ; z += 2 . 0 ; double yc = y * c ; double pk = pkm1 * z - pkm2 * yc ; double qk = qkm1 * z - qkm2 * yc ; if ( qk ! = 0 ) { double r = pk / qk ; t = math . ab ( ( ans - r ) / r ) ; ans = r ; } else { t = 1 . 0 ; } pkm2 = pkm1 ; pkm1 = pk ; qkm2 = qkm1 ; qkm1 = qk ; if ( math . ab ( pk ) > constant . big ) { pkm2 * = constant . big_inverse ; pkm1 * = constant . big_inverse ; qkm2 * = constant . big_inverse ; qkm1 * = constant . big_inverse ; } } while ( t > constant . machep ) ; return ans * ax ; }
public static double negative binomial ( int k , int n , double p ) { if ( p < 0 . 0 || p > 1 . 0 ) { throw new illegal argument exception ( ) ; } if ( k < 0 ) { return 0 . 0 ; } return gamma . incomplete beta ( n , k + 1 , p ) ; }
public void add all of ( byte array list other ) { add all of from to ( other , 0 , other . size ( ) - 1 ) ; }
public void before insert ( int index , byte element ) { before insert dummy ( index , 1 ) ; set ( index , element ) ; }
public boolean contains ( byte elem ) { return index of from to ( elem , 0 , size - 1 ) > = 0 ; }
public abstract byte list part from to ( int from , int to ) { check range from to ( from , to , size ) ; int length = to - from + 1 ; byte array list part = new byte array list ( length ) ; part . add all of from to ( this , from , to ) ; return part ; }
protect static void check range from to ( int from , int to , int the size ) { if ( to == from - 1 ) { return ; } if ( from < 0 || from > to || to > = the size ) { throw new index out of bound exception ( `` from : `` + from + `` , to : `` + to + `` , size= `` + the size ) ; } }
public void before insert all of ( int index , collection < t > collection ) { this . before insert dummy ( index , collection . size ( ) ) ; this . replace from with ( index , collection ) ; }
public byte [ ] element ( ) { return element ; }
public byte array list value ( ) { byte array list list = new byte array list ( size ( ) ) ; value ( list ) ; return list ; }
public byte adjust or put value ( byte key , byte new value , byte incr value ) { boolean present = contains key ( key ) ; if ( present ) { new value = ( byte ) ( get ( key ) + incr value ) ; put ( key , new value ) ; } else { put ( key , new value ) ; } return new value ; }
public static int int function uniform generator ( final int seed ) { return function . chain ( new double function ( ) { @ override public double apply ( double x ) { return ( x + 1 . 0 ) / 2 . 0 ; } } , uniform symmetric generator ( seed ) ) ; }
public boolean be add constant time ( ) { return true ; }
public iterator < element > iterate non zero ( ) { return new non zero iterator ( ) ; }
protect int choose mean capacity ( int size , double min load , double max load ) { return next prime ( math . max ( size + 1 , ( int ) ( ( 2 * size / ( min load + max load ) ) ) ) ) ; }
public matrix get v ( ) { return v . like ( ) . assign ( v ) ; }
public vector get real eigenvalue ( ) { return d ; }
public static void quick sort ( int start , int end , int comparator comp , swapper swap ) { check bound ( end + 1 , start , end ) ; quick sort0 ( start , end , comp , swap ) ; }
public static vector binary aggregate get best operation ( vector x , vector y , double double function fa , double double function fc ) { int best operation index = -1 ; double best cost = double . positive_infinity ; for ( int i = 0 ; i < operation . length ; ++i ) { if ( operation [ i ] . be valid ( x , y , fa , fc ) ) { double cost = operation [ i ] . estimate cost ( x , y , fa , fc ) ; if ( cost < best cost ) { best cost = cost ; best operation index = i ; } } } return operation [ best operation index ] ; }
public a r f f model get model ( ) { return model ; }
public enumeration get matching header ( string [ ] name ) throw message exception { check expunge ( ) ; load header ( ) ; return super . get matching header ( name ) ; }
public folder [ ] get user namespaces ( string user ) throw message exception { namespaces ns = get namespaces ( ) ; if ( ns == null || n . other user == null ) return super . get user namespaces ( user ) ; return namespace to folder ( n . other user , user ) ; }
public synchronize quota [ ] get quota ( string root ) throw message exception { check connect ( ) ; quota [ ] qa = null ; i m a p protocol p = null ; try { p = get store protocol ( ) ; qa = p . get quota root ( root ) ; } catch ( bad command exception bex ) { throw new message exception ( `` quota not support `` , bex ) ; } catch ( connection exception cex ) { throw new store close exception ( this , cex . get message ( ) ) ; } catch ( protocol exception pex ) { throw new message exception ( pex . get message ( ) , pex ) ; } finally { release store protocol ( p ) ; } return qa ; }
public boolean be r e v1 ( ) { return rev1 ; }
public int hash code ( ) { assert false : prefix . hash code ( ) ; return super . hash code ( ) ; }
public static query approximate ( query query ) { if ( query instanceof term query ) { return query ; } else if ( query instanceof phrase query ) { return approximate ( ( phrase query ) query ) ; } else if ( query instanceof multi phrase query ) { return approximate ( ( multi phrase query ) query ) ; } else if ( query instanceof multi phrase prefix query ) { return approximate ( ( multi phrase prefix query ) query ) ; } else { return new match all docs query ( ) ; } }
public string get family ( ) { return this . family ; } // -- string get family ( )
public void set name ( string name ) { this . name = name ; } // -- void set name ( string )
public void set filter ( java . util . list filter ) { this . filter = filter ; } // -- void set filter ( java . util . list )
public void set test resource ( java . util . list test resource ) { this . test resource = test resource ; } // -- void set test resource ( java . util . list )
public void set url ( string url ) { this . url = url ; } // -- void set url ( string )
public string get email ( ) { return this . email ; } // -- string get email ( )
public void set type ( string type ) { this . type = type ; } // -- void set type ( string )
public relocation get relocation ( ) { return this . relocation ; } // -- relocation get relocation ( )
public deployment repository get snapshot repository ( ) { return this . snapshot repository ; } // -- deployment repository get snapshot repository ( )
public void set url ( string url ) { this . url = url ; } // -- void set url ( string )
public string get group id ( ) { return this . group id ; } // -- string get group id ( )
public string get model version ( ) { return this . model version ; } // -- string get model version ( )
public organization get organization ( ) { return this . organization ; } // -- organization get organization ( )
public string get packaging ( ) { return this . packaging ; } // -- string get packaging ( )
public string get url ( ) { return this . url ; } // -- string get url ( )
public void set group id ( string group id ) { this . group id = group id ; } // -- void set group id ( string )
public void set license ( java . util . list license ) { this . license = license ; } // -- void set license ( java . util . list )
public distribution management get distribution management ( ) { return this . distribution management ; } // -- distribution management get distribution management ( )
public void set goal ( object goal ) { this . goal = goal ; } // -- void set goal ( object )
public object get configuration ( ) { return this . configuration ; } // -- object get configuration ( )
public void set report set ( java . util . list report set ) { this . report set = report set ; } // -- void set report set ( java . util . list )
public boolean be enable ( ) { return this . enable ; } // -- boolean be enable ( )
public string get target path ( ) { return this . target path ; } // -- string get target path ( )
public boolean be filter ( ) { return this . filtering ; } // -- boolean be filter ( )
public string get url ( ) { return this . url ; } // -- string get url ( )
public void set property ( activation property property ) { this . property = property ; } // -- void set property ( activation property )
public string get miss ( ) { return this . miss ; } // -- string get missing ( )
public string get family ( ) { return this . family ; } // -- string get family ( )
public void set plugin repository ( java . util . list plugin repository ) { this . plugin repository = plugin repository ; } // -- void set plugin repository ( java . util . list )
public void set repository ( java . util . list repository ) { this . repository = repository ; } // -- void set repository ( java . util . list )
public string get url ( ) { return this . url ; } // -- string get url ( )
public void set layout ( string layout ) { this . layout = layout ; } // -- void set layout ( string )
public void set group id ( string group id ) { this . group id = group id ; } // -- void set group id ( string )
public string get name ( ) { return this . name ; } // -- string get name ( )
public string get name ( ) { return this . name ; } // -- string get name ( )
public void set mirror of ( string mirror of ) { this . mirror of = mirror of ; } // -- void set mirror of ( string )
public string get protocol ( ) { return this . protocol ; } // -- string get protocol ( )
public void set username ( string username ) { this . username = username ; } // -- void set username ( string )
public object get configuration ( ) { return this . configuration ; } // -- object get configuration ( )
public string get password ( ) { return this . password ; } // -- string get password ( )
public void set directory permission ( string directory permission ) { this . directory permission = directory permission ; } // -- void set directory permission ( string )
public static clock default clock ( ) { return default ; }
public double get rate ( time unit rate unit ) { return rate * ( double ) rate unit . to nanos ( 1 ) ; }
public void start ( ) { registry . add listener ( listener ) ; }
public static string name ( class < ? > klass , string . . . name ) { return name ( klass . get name ( ) , names ) ; }
public double get95th percentile ( ) { return get value ( 0 . 95 ) ; }
public double [ ] get percentile ( ) { return percentile ; }
public boolean be close ( ) { return close . get ( ) ; }
public static string truncate ( string string , int max length ) { if ( string . length ( ) > max length ) { return string . substring ( 0 , max length ) ; } return string ; }
public b sla ( @ nullable duration . . . sla ) { return service level objective ( sla ) ; }
public zone date time next time after ( zoned date time after time , long duration in millis ) { return next time after ( after time , after time . plus ( duration . of millis ( duration in millis ) ) ) ; }
protect @ non null watch key register path ( @ non null path dir ) throw i o exception { return dir . register ( watch service , standard watch event kind . entry_create , standard watch event kind . entry_delete , standard watch event kind . entry_modify ) ; }
public @ non null duration get check interval ( ) { return check interval ; }
public optional < string > string value ( @ non null string member ) { if ( string utils . be not empty ( member ) ) { object o = get raw single value ( member , value mapper ) ; if ( o ! = null ) { return optional . of ( o . to string ( ) ) ; } } return optional . empty ( ) ; }
public static < t extend annotation > annotation value builder < t > builder ( @ non null annotation value < t > annotation , @ nullable retention policy retention policy ) { argument utils . require non null ( `` annotation `` , annotation ) ; return new annotation value builder < > ( annotation , retention policy ) ; }
public annotation value builder < t > value ( @ nullable string . . . string ) { return member ( annotation metadata . value_member , string ) ; }
public annotation value builder < t > value ( boolean bool ) { return member ( annotation metadata . value_member , bool ) ; }
public annotation value builder < t > member ( @ non null string name , @ nullable annotation class value < ? > . . . class value ) { if ( class value ! = null ) { value . put ( name , class value ) ; } return this ; }
public static void register class for runtime reflective instantiation ( before analysis access access , string class name ) { find class ( access , class name ) . if present ( automatic feature utils : : register for reflective instantiation ) ; }
public static void register all for runtime reflection ( before analysis access access , string class name ) { find class ( access , class name ) . if present ( automatic feature utils : : register all for runtime reflection ) ; }
public @ non null optional < url > get resource ( @ non null string path ) { argument utils . require non null ( `` path `` , path ) ; optional < resource loader > resource loader = get support loader ( path ) ; if ( resource loader . be present ( ) ) { return resource loader . get ( ) . get resource ( path ) ; } return optional . empty ( ) ; }
public static void sort ( order . . . object ) { array . sort ( object , comparator ) ; }
public static string path to class name ( string path ) { path = path . replace ( '/ ' , ' . ' ) ; if ( path . end with ( class_extension ) ) { path = path . substring ( 0 , path . length ( ) - class_extension . length ( ) ) ; } return path ; }
public static argument check check ( check check ) { return new argument check ( check ) ; }
public static byte [ ] concat ( byte [ ] a , byte . . . b ) { int b len = b . length ; if ( b len == 0 ) { return a ; } int a len = a . length ; if ( a len == 0 ) { return b ; } byte [ ] c = new byte [ a len + b len ] ; system . arraycopy ( a , 0 , c , 0 , a len ) ; system . arraycopy ( b , 0 , c , a len , b len ) ; return c ; }
public static string to string ( @ nullable object [ ] array ) { string delimiter = `` , `` ; return to string ( delimiter , array ) ; }
public boolean contains ( object o ) { return ( o instanceof link < ? > ) & & contains ( ( link < ? > ) o ) ; }
public static @ nullable < t > t last ( @ non null collection < t > collection ) { if ( collection instanceof list ) { list < t > list = ( list < t > ) collection ; final int s = list . size ( ) ; if ( s > 0 ) { return list . get ( s - 1 ) ; } else { return null ; } } else if ( collection instanceof deque ) { final iterator < t > i = ( ( deque < t > ) collection ) . descend iterator ( ) ; if ( i . have next ( ) ) { return i . next ( ) ; } return null ; } else if ( collection instanceof navigable set ) { final iterator < t > i = ( ( navigable set < t > ) collection ) . descend iterator ( ) ; if ( i . have next ( ) ) { return i . next ( ) ; } return null ; } else { t result = null ; for ( t t : collection ) { result = t ; } return result ; } }
public void set additional type ( list < medium type > additional type ) { this . additional type = additional type ; }
public cooky get cooky ( ) { return cooky ; }
public void set proxy address ( socket address proxy address ) { this . proxy address = proxy address ; }
public event loop group create event loop group ( int thread , @ nullable integer io ratio ) { return with io ratio ( new nio event loop group ( thread ) , io ratio ) ; }
public http response status get netty http status ( ) { return http response status ; }
protect flowable < ? > instrument publisher ( channel handler context ctx , object result ) { flowable < ? > actual = publisher . convert publisher ( result , flowable . class ) ; return actual . subscribe on ( scheduler . from ( ctx . channel ( ) . event loop ( ) ) ) ; }
public void set allow header ( @ nullable list < string > allow header ) { if ( allow header ! = null ) { this . allow header = allow header ; } }
public void set cors ( cors configuration cors ) { this . cors = cors ; }
public stream file attach ( string attachment name ) { this . attachment name = attachment name ; return this ; }
public void set access logger ( access logger access logger ) { this . access logger = access logger ; }
public static cooky element for response ( ) { return response_cookies_element ; }
protect string get web socket u r l ( channel handler context ctx , http request req ) { boolean be secure = ctx . pipeline ( ) . get ( ssl handler . class ) ! = null ; return ( be secure ? scheme_secure_websocket : scheme_websocket ) + req . get header ( ) . get ( http header name . host ) + req . get uri ( ) ; }
protect < t > stream < t > stream of type ( bean resolution context resolution context , class < t > bean type , qualifier < t > qualifier ) { return get bean registration ( resolution context , bean type , qualifier ) . stream ( ) . map ( bean registration : : get bean ) ; }
public < t > optional < t > find bean ( class < t > bean type , qualifier < t > qualifier ) { return find bean ( null , bean type , qualifier ) ; }
public static < t > provider < t > memoized ( provider < t > delegate ) { return new memoizing provider < > ( delegate ) ; }
public @ non null static message source add message ( @ non null string code , @ non null string message ) { if ( string utils . be not empty ( code ) & & string utils . be not empty ( message ) ) { message map . put ( new message key ( locale . get default ( ) , code ) , message ) ; } return this ; }
protect @ non null list < annotation mapper < ? extend annotation > > get annotation mapper ( @ non null string annotation name ) { return annotation_mappers . get ( annotation name ) ; }
public static void contribute default ( annotation metadata target , annotation metadata source ) { if ( source instanceof annotation metadata hierarchy ) { source = ( ( annotation metadata hierarchy ) source ) . get declare metadata ( ) ; } if ( target instanceof default annotation metadata & & source instanceof default annotation metadata ) { final map < string , map < char sequence , object > > exist default = ( ( default annotation metadata ) target ) . annotation default value ; if ( exist default ! = null ) { final map < string , map < char sequence , object > > additional default = ( ( default annotation metadata ) source ) . annotation default value ; if ( additional default ! = null ) { exist default . put all ( additional default ) ; } } else { final map < string , map < char sequence , object > > additional default = ( ( default annotation metadata ) source ) . annotation default value ; if ( additional default ! = null ) { additional default . for each ( ( ( default annotation metadata ) target ) : : add default annotation value ) ; } } } }
public void set name ( list < string > names ) { this . name = name ; }
public void set prefer ip address ( boolean prefer ip address ) { this . prefer ip address = prefer ip address ; }
public < t > t decode ( argument < t > type , json node node ) throw codec exception { try { return get object mapper ( ) . tree to value ( node , type . get type ( ) ) ; } catch ( i o exception e ) { throw new codec exception ( `` error decode json stream for type [ `` + type . get name ( ) + `` ] : `` + e . get message ( ) , e ) ; } }
public boolean be always serialize error a list ( ) { return always serialize error a list ; }
public boolean be trim string ( ) { return trim string ; }
public void set always serialize error a list ( boolean always serialize error a list ) { this . always serialize error a list = always serialize error a list ; }
public void set trim string ( boolean trim string ) { this . trim string = trim string ; }
public boolean can retry ( throwable exception ) { if ( exception == null ) { return false ; } if ( ! predicate . test ( exception ) ) { return false ; } else { return this . attempt number . increment and get ( ) < ( max attempt + 1 ) & & ( ( max delay == null ) || overall delay . get ( ) < max delay . to millis ( ) ) ; } }
public void after each ( c context ) throw exception { if ( refresh scope ! = null ) { if ( ! old value . be empty ( ) ) { test property . put all ( old value ) ; final map < string , object > diff = application context . get environment ( ) . refresh and diff ( ) ; refresh scope . on refresh event ( new refresh event ( diff ) ) ; } } old value . clear ( ) ; }
public unwrap by default value extractor < optional > get optional value extractor ( ) { return optional value extractor ; }
public json at del ( int index ) { throw new unsupported operation exception ( ) ; }
public json del at ( int index ) { throw new unsupported operation exception ( ) ; }
public string pad ( string callback ) { return ( callback ! = null & & callback . length ( ) > 0 ) ? callback + `` ( `` + to string ( ) + `` ) ; `` : to string ( ) ; }
public static < t > answer < t > delegate to ( object delegate ) { return ( answer < t > ) new forward invocation ( delegate ) ; }
public static instance field declare field of ( object instance ) { list < instance field > instance field = new array list < instance field > ( ) ; instance field . add all ( instance field in ( instance , instance . get class ( ) . get declared field ( ) ) ) ; return new instance field ( instance , instance field ) ; }
public unused stubbings get unused stubbings ( iterable < object > mock ) { set < stub > stubbings = all invocation finder . find stubbings ( mock ) ; list < stub > unused = filter ( stubbings , new filter < stub > ( ) { public boolean be out ( stub s ) { return s . be use ( ) ; } } ) ; return new unused stubbings ( unused ) ; }
public void set pool maximum checkout time ( int pool maximum checkout time ) { this . pool maximum checkout time = pool maximum checkout time ; force close all ( ) ; }
public input stream get resource a stream ( string resource ) { return get resource a stream ( resource , get class loader ( null ) ) ; }
public static reader get url a reader ( string url string ) throw i o exception { reader reader ; if ( charset == null ) { reader = new input stream reader ( get url a stream ( url string ) ) ; } else { reader = new input stream reader ( get url a stream ( url string ) , charset ) ; } return reader ; }
public void set default fetch size ( integer default fetch size ) { this . default fetch size = default fetch size ; }
protect void build all statement ( ) { parse pending result map ( ) ; if ( ! incomplete cache ref . be empty ( ) ) { synchronize ( incomplete cache ref ) { incomplete cache ref . remove if ( x - > x . resolve cache ref ( ) ! = null ) ; } } if ( ! incomplete statement . be empty ( ) ) { synchronize ( incomplete statement ) { incomplete statement . remove if ( x - > { x . parse statement node ( ) ; return true ; } ) ; } } if ( ! incomplete method . be empty ( ) ) { synchronize ( incomplete method ) { incomplete method . remove if ( x - > { x . resolve ( ) ; return true ; } ) ; } } }
public void set configuration ( configuration c ) { this . configuration = c ; }
public my batis cursor item reader builder < t > max item count ( int max item count ) { this . max item count = max item count ; return this ; }
public void after property set ( ) throw exception { not null ( sql session factory , `` a sql session factory be require . `` ) ; not null ( query id , `` a query id be require . `` ) ; }
public void set lazy initialization ( boolean lazy initialization ) { this . lazy initialization = lazy initialization ; }
public void set object factory ( object factory object factory ) { this . object factory = object factory ; }
public void set plugins ( interceptor . . . plugins ) { this . plugins = plugins ; }
public void set type aliases package ( string type alias package ) { this . type aliases package = type aliases package ; }
public epoll server channel config set tcp fastopen ( int pending fast open request threshold ) { if ( this . pending fast open request threshold < 0 ) { throw new illegal argument exception ( `` pending fast open request threshold : `` + pending fast open request threshold ) ; } this . pending fast open request threshold = pending fast open request threshold ; return this ; }
public int verify ( ) { return verify ; }
public string version ( ) { return version ; }
public string encode scheme ( ) { return encode scheme ; }
public channel config set max message per write ( int max message per write ) { this . max message per write = object util . check positive ( max message per write , `` max message per write `` ) ; return this ; }
public void handle unknown class ( object o ) { write string ( out . to string ( ) ) ; }
public evaluation get last descendant ( ) { if ( last child ! = null ) { return last child . get last descendant ( ) ; } return this ; }
public void add child ( evaluation child ) { if ( first child == null ) { first child = last child = child ; } else { if ( first child == last child ) { first child . next = child ; last child = child ; last child . previous = first child ; } else { child . previous = last child ; last child . next = child ; last child = child ; } } child . parent = this ; }
public static string get unique descriptor ( object object , boolean fully qualify ) { string buffer result = new string buffer ( ) ; if ( object ! = null ) { if ( object instanceof proxy ) { class interface class = object . get class ( ) . get interface ( ) [ 0 ] ; result . append ( get class name ( interface class , fully qualify ) ) ; result . append ( '^ ' ) ; object = proxy . get invocation handler ( object ) ; } result . append ( get class name ( object , fully qualify ) ) ; result . append ( ' @ ' ) ; result . append ( get pointer string ( object ) ) ; } else { result . append ( null_object_string ) ; } return new string ( result ) ; }
public static void set security manager ( security manager value ) { _security manager = value ; }
public static < t > t create instance ( class < ? > raw class , class < t > superclass ) { try { return raw class . a subclass ( superclass ) . get constructor ( ) . new instance ( ) ; } catch ( exception e ) { throw new service configuration error ( `` provider `` + raw class . get name ( ) + `` could not be instantiate . `` , e ) ; } }
public static iterator < tag > get tag ( tag context tag ) { return tag . get iterator ( ) ; }
public long get low long ( ) { long result = 0 ; for ( int i = 0 ; i < long . size / byte . size ; i++ ) { result < < = byte . size ; result |= ( bytes [ i ] & 0xff ) ; } if ( result < 0 ) { return -result ; } return result ; }
public static void register all cumulative view ( ) { register all cumulative view ( stats . get view manager ( ) ) ; }
public static void register all interval view ( ) { register all interval view ( stats . get view manager ( ) ) ; }
public static @ non null string require non empty ( @ nullable string value ) { if ( value == null ) throw new null pointer exception ( ) ; if ( value . be empty ( ) ) throw new illegal argument exception ( ) ; return value ; }
public add command set work tree iterator ( work tree iterator f ) { work tree iterator = f ; return this ; }
public list < string > get modify list ( ) { return modify list ; }
public cherry pick command include ( ref commit ) { check callable ( ) ; commits . add ( commit ) ; return this ; }
public cherry pick command include ( any object id commit ) { return include ( commit . get name ( ) , commit ) ; }
public clone command set remote ( string remote ) { if ( remote == null ) { remote = constant . default_remote_name ; } this . remote = remote ; return this ; }
public clone command set branch ( string branch ) { if ( branch == null ) { branch = constant . head ; } this . branch = branch ; return this ; }
public int get return code ( ) { return return code ; }
public boolean be force update ( ) { return this . be force update ; }
public stash apply command stash apply ( ) { return new stash apply command ( repo ) ; }
public log command add path ( string path ) { check callable ( ) ; path filter . add ( path filter . create ( path ) ) ; return this ; }
public log command set rev filter ( rev filter a filter ) { check callable ( ) ; this . rev filter = a filter ; return this ; }
public merge command include ( ref a commit ) { check callable ( ) ; commits . add ( a commit ) ; return this ; }
public push command set remote ( string remote ) { check callable ( ) ; this . remote = remote ; return this ; }
public push command set receive pack ( string receive pack ) { check callable ( ) ; this . receive pack = receive pack ; return this ; }
public void set name ( string name ) { this . name = name ; }
public void set apply index ( boolean apply index ) { this . apply index = apply index ; }
public stash create command set ref ( string ref ) { this . ref = ref ; return this ; }
public status command set ignore submodules ( ignore submodule mode mode ) { ignore submodule mode = mode ; return this ; }
public submodule init command add path ( string path ) { path . add ( path ) ; return this ; }
public submodule status command add path ( string path ) { path . add ( path ) ; return this ; }
public submodule update command set fetch ( boolean fetch ) { this . fetch = fetch ; return this ; }
public submodule update command set callback ( clone command . callback callback ) { this . callback = callback ; return this ; }
public boolean be force update ( ) { return force update ; }
public tag command set force update ( boolean force update ) { this . force update = force update ; return this ; }
public collection < attribute > get all ( ) { return new array list < > ( map . value ( ) ) ; }
public blame result compute blame result ( ) throw i o exception { try { blame result r = blame result . create ( this ) ; if ( r ! = null ) r . compute all ( ) ; return r ; } finally { close ( ) ; } }
public int get source start ( ) { return out region . source start ; }
public person ident get source author ( int idx ) { return source author [ idx ] ; }
public boolean be rename detection enable ( ) { return rename detection type ! = rename detection type . false ; }
public void set diff algorithm ( diff algorithm alg ) { diff algorithm = alg ; }
public boolean be detect renames ( ) { return rename detector ! = null ; }
public object id get calulated patch id ( ) { return object id . from raw ( digest . digest ( ) ) ; }
protect string decode ( int start , int end ) { return raw parse utils . decode ( content , start , end ) ; }
public static boolean be binary ( input stream raw ) throw i o exception { final byte [ ] buffer = new byte [ first_few_bytes ] ; int cnt = 0 ; while ( cnt < buffer . length ) { final int n = raw . read ( buffer , cnt , buffer . length - cnt ) ; if ( n == -1 ) break ; cnt += n ; } return be binary ( buffer , cnt ) ; }
public dir cache builder builder ( ) { return new dir cache builder ( this , entry cnt + 16 ) ; }
public int find entry ( string path ) { final byte [ ] p = constant . encode ( path ) ; return find entry ( p , p . length ) ; }
public int find entry ( byte [ ] p , int p len ) { return find entry ( 0 , p , p len ) ; }
public int next entry ( int position ) { dir cache entry last = sort entry [ position ] ; int next idx = position + 1 ; while ( next idx < entry cnt ) { final dir cache entry next = sort entry [ next idx ] ; if ( cmp ( last , next ) ! = 0 ) break ; last = next ; next idx++ ; } return next idx ; }
public dir cache entry get dir cache entry ( ) { return current subtree == null ? current entry : null ; }
public object id get object id ( ) { return id ; }
public string get name string ( ) { final byte buffer bb = byte buffer . wrap ( encode name ) ; return utf_8 . decode ( bb ) . to string ( ) ; }
public collection < object id > get candidate ( ) { return candidate ; }
public string [ ] get conflict file ( ) { return conflicting ; }
public void set repository ( repository r ) { if ( repository == null ) repository = r ; }
public string get remote ( ) { return remote ; }
public string get recommend shallow ( ) { return recommend shallow ; }
public boolean be native hook present ( ) { return f . detect . find hook ( get repository ( ) , get hook name ( ) ) ! = null ; }
public participation get participation ( ) { return participation ; }
public string get txn commit ( ) { return txn commit ; }
public proposal set push certificate ( @ nullable push certificate cert ) { push cert = cert ; return this ; }
public u r iish get u r i ( ) { return uri ; }
public long get min retry ( time unit unit ) { return unit . convert ( min retry , millisecond ) ; }
public long get max retry ( time unit unit ) { return unit . convert ( max retry , millisecond ) ; }
public ketch replica . state get state ( ) { return state ; }
public boolean have block0 ( dfs stream key key ) { hash entry e1 = table . get ( slot ( key , 0 ) ) ; dfs block v = scan ( e1 , key , 0 ) ; return v ! = null & & v . contains ( key , 0 ) ; }
public dfs pack compactor add ( dfs pack file pack ) { src pack . add ( pack ) ; return this ; }
public dfs reader io stats get io stats ( ) { return new dfs reader io stats ( stats ) ; }
public void wait for stat change ( ) throw interrupted exception { file snapshot o = file snapshot . save ( ref ) ; file snapshot n = file snapshot . save ( lck ) ; while ( o . equal ( n ) ) { thread . sleep ( 25 / * milliseconds * / ) ; lck . set last modify ( system . current time millis ( ) ) ; n = file snapshot . save ( lck ) ; } }
public void set keep empty ( boolean empty ) { keep empty = empty ; }
public static string ref lock for ( string name ) { return name + lock_suffix ; }
public long read unsigned int ( ) throw i o exception { read fully ( buf , 0 , 4 ) ; return nb . decode u int32 ( buf , 0 ) ; }
public static long estimate index size ( int source length ) { return source length + ( source length * 3 / 4 ) ; }
public final object to pack get delta base ( ) { if ( delta base instanceof object to pack ) return ( object to pack ) delta base ; return null ; }
public boolean be thin ( ) { return thin ; }
public void exclude object ( object id set idx ) { if ( exclude in pack == null ) { exclude in pack = new object id set [ ] { idx } ; exclude in pack last = idx ; } else { int cnt = exclude in pack . length ; object id set [ ] new list = new object id set [ cnt + 1 ] ; system . arraycopy ( exclude in pack , 0 , new list , 0 , cnt ) ; new list [ cnt ] = idx ; exclude in pack = new list ; } }
public boolean be delete ( ) { ref r = get ref ( ) ; return r . get storage ( ) == ref . storage . new & & r . get object id ( ) == null ; }
public reftable compactor set max update index ( long max ) { max update index = max ; return this ; }
public void add all ( list < ? extend reftable > reader ) throw i o exception { table . add all ( reader ) ; for ( reftable r : reader ) { if ( r instanceof reftable reader ) { adjust update index ( ( reftable reader ) r ) ; } } }
public int block size ( ) throw i o exception { if ( block size == -1 ) { read file header ( ) ; } return block size ; }
public static void abort ( iterable < command > command , @ nullable string why ) { if ( why == null || why . be empty ( ) ) { why = j git text . get ( ) . transaction abort ; } for ( command c : command ) { if ( c . get result ( ) == not_attempted ) { c . set result ( rejected_other_reason , why ) ; why = j git text . get ( ) . transaction abort ; } } }
public string get message ( ) { return cmd ! = null ? cmd . get message ( ) : null ; }
public static boolean be ref tree ( ref database refdb , string ref ) { if ( refdb instanceof ref tree database ) { ref tree database b = ( ref tree database ) refdb ; if ( ref . equal ( b . get txn commit ( ) ) ) { return true ; } string namespace = b . get txn namespace ( ) ; if ( namespace ! = null & & ref . start with ( namespace ) & & ! ref . start with ( namespace + stage ) ) { return true ; } } return false ; }
public b set index file ( file index file ) { this . index file = index file ; return self ( ) ; }
public b read environment ( ) { return read environment ( system reader . get instance ( ) ) ; }
public b add ceiling directory ( collection < file > in list ) { if ( in list ! = null ) { for ( file path : in list ) add ceiling directory ( path ) ; } return self ( ) ; }
public r build ( ) throw i o exception { r repo = ( r ) new file repository ( setup ( ) ) ; if ( be must exist ( ) & & ! repo . get object database ( ) . exists ( ) ) throw new repository not find exception ( get git dir ( ) ) ; return repo ; }
public void set delay start ( long time , time unit unit ) { delay start time = time ; delay start unit = unit ; }
public void add parent id ( any object id additional parent ) { if ( parent id . length == 0 ) { set parent id ( additional parent ) ; } else { object id [ ] new parent = new object id [ parent id . length + 1 ] ; system . arraycopy ( parent id , 0 , new parent , 0 , parent id . length ) ; new parent [ parent id . length ] = additional parent . copy ( ) ; parent id = new parent ; } }
public string get attribute file ( ) { return attributesfile ; }
public string get sign key ( ) { return config . get string ( config constant . config_user_section , null , config constant . config_key_signingkey ) ; }
public boolean be sign commits ( ) { return config . get boolean ( config constant . config_commit_section , config constant . config_key_gpgsign , false ) ; }
public set < string > get conflicting ( ) { return conflict . key set ( ) ; }
public static final string to string ( object id i ) { return i ! = null ? i . name ( ) : zeroid_str ; }
protect sha1 digest ( ) { return hasher . reset ( ) ; }
public object id id for ( int type , byte [ ] data ) { return id for ( type , data , 0 , data . length ) ; }
public boolean have ( any object id object id ) throw i o exception { return have ( object id , obj_any ) ; }
public bitmap index get bitmap index ( ) throw i o exception { return null ; }
public string get short message ( ) { return short message ; }
public static int compare to ( ref o1 , ref o2 ) { return o1 . get name ( ) . compare to ( o2 . get name ( ) ) ; }
public ref exact ref ( string name ) throw i o exception { ref ref = get ref ( name ) ; if ( ref == null || ! name . equal ( ref . get name ( ) ) ) { return null ; } return ref ; }
public void set new object id ( any object id id ) { new value = id . copy ( ) ; }
public object id get expect old object id ( ) { return exp value ; }
public object id get old object id ( ) { return old value ; }
public result get result ( ) { return result ; }
public static repository open ( key location ) throw i o exception , repository not find exception { return open ( location , true ) ; }
public person ident get tagger ( ) { return tagger ; }
public void set tagger ( person ident tagger ident ) { tagger = tagger ident ; }
public repository get repository ( ) { return db ; }
public boolean merge ( any object id . . . tip ) throw i o exception { return merge ( true , tip ) ; }
public boolean fail ( ) { return fail path . size ( ) > 0 ; }
public abbreviate object id get old id ( int nth parent ) { return old id [ nth parent ] ; }
public boolean have meta data change ( ) { return change type ! = change type . modify || new mode ! = old mode ; }
public final int get ref count ( ) { return ref . length ; }
public static rev filter create ( rev filter a , rev filter b ) { if ( a == all || b == all ) return all ; return new binary ( a , b ) ; }
public static rev filter create ( rev filter [ ] list ) { if ( list . length == 2 ) return create ( list [ 0 ] , list [ 1 ] ) ; if ( list . length < 2 ) throw new illegal argument exception ( j git text . get ( ) . at least two filter need ) ; final rev filter [ ] subfilters = new rev filter [ list . length ] ; system . arraycopy ( list , 0 , subfilters , 0 , list . length ) ; return new list ( subfilters ) ; }
public string pattern ( ) { return pattern text ; }
public final person ident get tagger ident ( ) { final byte [ ] raw = buffer ; final int name b = raw parse utils . tagger ( raw , 0 ) ; if ( name b < 0 ) return null ; return raw parse utils . parse person ident ( raw , name b ) ; }
public boolean be preserve old pack ( ) { return preserve old pack ; }
public boolean be delta base a offset ( ) { return delta base a offset ; }
public int get delta search window size ( ) { return delta search window size ; }
public void set delta search window size ( int object count ) { if ( object count < = 2 ) set delta compress ( false ) ; else delta search window size = object count ; }
public int get index version ( ) { return index version ; }
public int get bitmap contiguous commit count ( ) { return bitmap contiguous commit count ; }
public set < object id > get root commits ( ) { return statistic . root commits ; }
public long get total object ( ) { return statistic . total object ; }
public long get reuse delta ( ) { return statistic . reuse delta ; }
public int get depth ( ) { return statistic . depth ; }
public object id get index id ( ) { return index id ; }
public static repository get submodule repository ( final file parent , final string path ) throw i o exception { return get submodule repository ( parent , path , f . detect ) ; }
public static boolean contains git module file ( repository repository ) throw i o exception { if ( repository . be bare ( ) ) { return false ; } file module file = new file ( repository . get work tree ( ) , constant . dot_git_modules ) ; return ( module file . exists ( ) ) ; }
public string get path ( ) { return path ; }
public string get module name ( ) { return get module name ( path ) ; }
public string get head ref ( ) throw i o exception { try ( repository sub repo = get repository ( ) ) { if ( sub repo == null ) { return null ; } ref head = sub repo . exact ref ( constant . head ) ; return head ! = null ? head . get leaf ( ) . get name ( ) : null ; } }
protect boolean be capable of ( string option ) { return remote capablities . contains ( option ) ; }
protect void add user agent capability ( string builder b ) { string a = user agent . get ( ) ; if ( a ! = null & & user agent . have agent ( remote capablities ) ) { b . append ( ' ' ) . append ( option_agent ) . append ( '= ' ) . append ( a ) ; } }
public void assume ( rev commit c ) { if ( c ! = null ) assume . add ( c ) ; }
public void set upload pack factory ( upload pack factory < daemon client > factory ) { if ( factory ! = null ) upload pack factory = factory ; else upload pack factory = ( upload pack factory < daemon client > ) upload pack factory . disable ; }
public void stop and wait ( ) throw interrupted exception { thread acceptor = null ; synchronize ( this ) { acceptor = accept thread ; stop ( ) ; } if ( acceptor ! = null ) { acceptor . join ( ) ; } }
public string get peer user agent ( ) { return peer user agent ; }
public long get offset ( ) { return offset ; }
public void write string ( string s ) throw i o exception { write packet ( constant . encode ( s ) ) ; }
public void flush ( ) throw i o exception { out . flush ( ) ; }
public string get advertise nonce ( ) { string nonce = send nonce ( ) ; if ( nonce == null ) { return null ; } return capability_push_cert + '= ' + nonce ; }
public long get num ref delta ( ) { return num ref delta ; }
public long get num delta blob ( ) { return num delta blob ; }
public void set post receive hook ( post receive hook h ) { post receive = h ! = null ? h : post receive hook . null ; }
public ref spec set source ( string source ) { final ref spec r = new ref spec ( this ) ; r . src name = check valid ( source ) ; if ( be wildcard ( r . src name ) & & r . dst name == null ) throw new illegal state exception ( j git text . get ( ) . destination be not a wildcard ) ; if ( be wildcard ( r . src name ) ! = be wildcard ( r . dst name ) ) throw new illegal state exception ( j git text . get ( ) . source destination must match ) ; return r ; }
public list < u r iish > get u r be ( ) { return collection . unmodifiable list ( uris ) ; }
public boolean add fetch ref spec ( ref spec s ) { if ( fetch . contains ( s ) ) return false ; return fetch . add ( s ) ; }
public object id get new object id ( ) { return new object id ; }
public boolean have track ref update ( ) { return track ref update ! = null ; }
public void set export all ( boolean export ) { export all = export ; }
public void set cert nonce seed ( string seed ) { cert nonce seed = seed ; }
public void set cert nonce slop limit ( int limit ) { cert nonce slop limit = limit ; }
public object checker get object checker ( ) { return object checker ; }
public boolean be remove delete ref ( ) { return remove deleted ref ; }
public string get user ( ) { return user ; }
public static void set ( string agent ) { user agent = string utils . be empty or null ( agent ) ? null : clean ( agent ) ; }
public int path compare ( abstract tree iterator p ) { return path compare ( p , p . mode ) ; }
public boolean find file ( string name ) throw corrupt object exception { return find file ( constant . encode ( name ) ) ; }
public file get directory ( ) { return directory ; }
public eol get e o l ( ) { return eol ; }
public static void delete ( file f ) throw i o exception { delete ( f , none ) ; }
public static void mkdir ( file d ) throw i o exception { mkdir ( d , false ) ; }
public static string normalize ( string name ) { if ( system reader . get instance ( ) . be mac o s ( ) ) { if ( name == null ) return null ; return normalizer . normalize ( name , normalizer . form . nfc ) ; } return name ; }
public long length ( file path ) throw i o exception { return file utils . get length ( path ) ; }
public void delete ( file f ) throw i o exception { file utils . delete ( f ) ; }
public file resolve ( file dir , string name ) { final file abspn = new file ( name ) ; if ( abspn . be absolute ( ) ) return abspn ; return new file ( dir , name ) ; }
protect static file search path ( string path , string . . . look for ) { if ( path == null ) return null ; for ( string p : path . split ( file . path separator ) ) { for ( string command : look for ) { final file e = new file ( p , command ) ; if ( e . be file ( ) ) return e . get absolute file ( ) ; } } return null ; }
public entry [ ] list ( file directory , file mode strategy file mode strategy ) { final file [ ] all = directory . list file ( ) ; if ( all == null ) { return no_entries ; } final entry [ ] result = new entry [ all . length ] ; for ( int i = 0 ; i < result . length ; i++ ) { result [ i ] = new file entry ( all [ i ] , this , file mode strategy ) ; } return result ; }
public boolean contains ( int value ) { for ( int i = 0 ; i < count ; i++ ) if ( entry [ i ] == value ) return true ; return false ; }
public void print ( short value ) throw i o exception { print ( string . value of ( value ) ) ; }
public static int decode u int24 ( byte [ ] intbuf , int offset ) { int r = ( intbuf [ offset ] & 0xff ) < < 8 ; r |= intbuf [ offset + 1 ] & 0xff ; return ( r < < 8 ) | ( intbuf [ offset + 2 ] & 0xff ) ; }
public int get exit code ( ) { return exit code ; }
public static boolean be whitespace ( byte c ) { return whitespace [ c & 0xff ] ; }
public final t get ( string name ) { int idx = find ( name ) ; return 0 < = idx ? get ( idx ) : null ; }
public static boolean to boolean ( string string value ) { if ( string value == null ) throw new null pointer exception ( j git text . get ( ) . expect boolean string value ) ; final boolean bool = to boolean or null ( string value ) ; if ( bool == null ) throw new illegal argument exception ( message format . format ( j git text . get ( ) . not a boolean , string value ) ) ; return bool . boolean value ( ) ; }
public static void set instance ( system reader new reader ) { be mac o s = null ; be windows = null ; if ( new reader == null ) instance = default ; else { new reader . init ( ) ; instance = new reader ; } }
public void copy ( input stream in ) throw i o exception { if ( block ! = null ) { for ( ; ; ) { block s = last ( ) ; if ( s . be full ( ) ) { if ( reach in core limit ( ) ) break ; s = new block ( ) ; block . add ( s ) ; } int n = in . read ( s . buffer , s . count , s . buffer . length - s . count ) ; if ( n < 1 ) return ; s . count += n ; } } final byte [ ] tmp = new byte [ block . sz ] ; int n ; while ( ( n = in . read ( tmp ) ) > 0 ) overflow . write ( tmp , 0 , n ) ; }
public long length ( ) { return in core length ( ) ; }
public byte [ ] to byte array ( ) throw i o exception { final long len = length ( ) ; if ( integer . max_value < len ) throw new out of memory error ( j git text . get ( ) . length exceed maximum array size ) ; final byte [ ] out = new byte [ ( int ) len ] ; int out ptr = 0 ; for ( block b : block ) { system . arraycopy ( b . buffer , 0 , out , out ptr , b . count ) ; out ptr += b . count ; } return out ; }
public byte [ ] to byte array ( int limit ) throw i o exception { final long len = math . min ( length ( ) , limit ) ; if ( integer . max_value < len ) throw new out of memory error ( j git text . get ( ) . length exceed maximum array size ) ; final byte [ ] out = new byte [ ( int ) len ] ; int out ptr = 0 ; for ( block b : block ) { system . arraycopy ( b . buffer , 0 , out , out ptr , b . count ) ; out ptr += b . count ; } return out ; }
public have child query builder min max child ( int min child , int max child ) { if ( min child < 0 ) { throw new illegal argument exception ( `` [ `` + name + `` ] require non-negative 'min_children ' field `` ) ; } if ( min child == 0 ) { deprecation logger . deprecate ( deprecation category . query , `` min_children `` , min_children_0_deprecation_message ) ; } if ( max child < 0 ) { throw new illegal argument exception ( `` [ `` + name + `` ] require non-negative 'max_children ' field `` ) ; } if ( max child < min child ) { throw new illegal argument exception ( `` [ `` + name + `` ] 'max_children ' be less than 'min_children ' `` ) ; } this . min child = min child ; this . max child = max child ; return this ; }
public query builder query ( ) { return query ; }
public static have child query builder have child query ( string type , query builder query , score mode score mode ) { return new have child query builder ( type , query , score mode ) ; }
public static parent id query builder parent id ( string type , string id ) { return new parent id query builder ( type , id ) ; }
public dictionary get dictionary ( ) { return dictionary ; }
public boolean be match backwards ( ) { return match backwards ; }
public match behavior get match behavior ( ) { return match behavior ; }
public void set report rule failure ( final boolean b ) { report rule failure = b ; }
public string get valid character ( ) { return character data . get character ( ) ; }
public void set split char ( final char c ) { splitchar = c ; }
public ternary node get lokid ( ) { return lokid ; }
public void set eqkid ( final ternary node node ) { eqkid = node ; }
public boolean search ( final string word ) { return search node ( root , word , 0 ) ; }
public int get minimum length ( ) { return minimum length ; }
public boolean be valid ( ) { return valid ; }
public boolean have count ( final count category category ) { return count . contains key ( category ) ; }
protect boolean match ( final string password , final password data . reference reference ) { return password . equal ( reference . get password ( ) ) ; }
public boolean be match backwards ( ) { return match backwards ; }
public boolean be compress ( ) { return compress parameter ! = null & & compress parameter . be compress ( ) ; }
public void set embed file unicode ( p d embed file file ) { c o s dictionary ef = get e f dictionary ( ) ; if ( ef == null & & file ! = null ) { ef = new c o s dictionary ( ) ; f . set item ( c o s name . ef , ef ) ; } if ( ef ! = null ) { ef . set item ( c o s name . uf , file ) ; } }
protect void set decrypt metadata ( boolean decrypt metadata ) { this . decrypt metadata = decrypt metadata ; }
public boolean have protection policy ( ) { return protection policy ! = null ; }
public float [ ] get vertex ( ) { c o s array array = annot . get c o s array ( c o s name . vertex ) ; return array ! = null ? array . to float array ( ) : null ; }
public int get struct parent ( ) { return get c o s object ( ) . get int ( c o s name . struct_parents ) ; }
public void set rect difference ( float difference leave , float difference top , float difference right , float difference bottom ) { c o s array margin = new c o s array ( ) ; margin . add ( new c o s float ( difference leave ) ) ; margin . add ( new c o s float ( difference top ) ) ; margin . add ( new c o s float ( difference right ) ) ; margin . add ( new c o s float ( difference bottom ) ) ; get c o s object ( ) . set item ( c o s name . rd , margin ) ; }
public void set border effect ( p d border effect dictionary be ) { get c o s object ( ) . set item ( c o s name . be , be ) ; }
public void set ink list ( float [ ] [ ] ink list ) { if ( ink list == null ) { get c o s object ( ) . remove item ( c o s name . inklist ) ; return ; } c o s array array = new c o s array ( ) ; for ( float [ ] path : ink list ) { c o s array inner array = new c o s array ( ) ; inner array . set float array ( path ) ; array . add ( inner array ) ; } get c o s object ( ) . set item ( c o s name . inklist , array ) ; }
protect void write operand ( int integer ) throw i o exception { write ( format decimal . format ( integer ) ) ; output stream . write ( ' ' ) ; }
public p d rectangle get crop box ( ) { c o s base base = p d page tree . get inheritable attribute ( page , c o s name . crop_box ) ; if ( base instanceof c o s array ) { return clip to medium box ( new p d rectangle ( ( c o s array ) base ) ) ; } else { return get medium box ( ) ; } }
public matrix multiply ( matrix other ) { return new matrix ( check float value ( multiply array ( single , other . single ) ) ) ; }
public float get scale factor x ( ) { / * * bm : if the trm be rotate , the calculation be a little more complicated * * the rotation matrix multiply with the scaling matrix be : * ( x 0 0 ) ( cos sin 0 ) ( x * co x * sin 0 ) * ( 0 y 0 ) * ( -sin cos 0 ) = ( -y * sin y * cos 0 ) * ( 0 0 1 ) ( 0 0 1 ) ( 0 0 1 ) * * so , if you want to deduce x from the matrix you take * m ( 0,0 ) = x * co and m ( 0,1 ) = x * sin and use the theorem of pythagoras * * sqrt ( m ( 0,0 ) ^2+m ( 0,1 ) ^2 ) = * sqrt ( x2 * cos2+x2 * sin2 ) = * sqrt ( x2 * ( cos2+sin2 ) ) = < - here be the trick cos2+sin2 be one * sqrt ( x2 ) = * ab ( x ) * / if ( float . compare ( single [ 1 ] , 0 . 0f ) ! = 0 ) { return ( float ) math . sqrt ( math . pow ( single [ 0 ] , 2 ) + math . pow ( single [ 1 ] , 2 ) ) ; } return single [ 0 ] ; }
public void put all ( map map ) { _backing map . put all ( map ) ; flush ( ) ; }
public void set basedir ( string basedir ) { set basedir ( new file ( basedir . replace ( '/ ' , file . separator char ) . replace ( '\\ ' , file . separator char ) ) ) ; }
public void scan ( ) throw illegal state exception { if ( basedir == null ) { throw new illegal state exception ( `` no basedir set `` ) ; } if ( ! basedir . exists ( ) ) { throw new illegal state exception ( `` basedir `` + basedir + `` do not exist `` ) ; } if ( ! basedir . be directory ( ) ) { throw new illegal state exception ( `` basedir `` + basedir + `` be not a directory `` ) ; } setup default filter ( ) ; file include = new vector ( ) ; file not include = new vector ( ) ; file exclude = new vector ( ) ; file deselected = new vector ( ) ; dirs include = new vector ( ) ; dirs not include = new vector ( ) ; dirs exclude = new vector ( ) ; dirs deselected = new vector ( ) ; if ( be include ( `` `` ) ) { if ( ! be exclude ( `` `` ) ) { if ( be select ( `` `` , basedir ) ) { dirs include . add element ( `` `` ) ; } else { dirs deselected . add element ( `` `` ) ; } } else { dirs exclude . add element ( `` `` ) ; } } else { dirs not include . add element ( `` `` ) ; } scandir ( basedir , `` `` , true ) ; }
public string [ ] get not include directory ( ) { slow scan ( ) ; string [ ] directory = new string [ dirs not include . size ( ) ] ; dirs not include . copy into ( directory ) ; return directory ; }
public collection value ( ) { return _values ; }
public rule get rule for class ( final string class name , final string rule name , final string language name ) { return cache rule instance . get ( get rule key ( class name , rule name , language name ) ) ; }
public void initialize ( final rule set rs ) { for ( final rule r : r . get all rule ( ) ) { cached rule instance . put ( get rule key ( r . get rule class ( ) , r . get name ( ) , r . get language ( ) . get terse name ( ) ) , r ) ; } }
protect boolean be language specific discarding ( ) { return false ; }
public iterator < node > get precede sibling axis iterator ( object context node ) { return new node iterator ( ( node ) context node ) { @ override protect node get first node ( node node ) { return get next node ( node ) ; } @ override protect node get next node ( node node ) { return get previous sibling ( node ) ; } } ; }
protect unsupported operation exception create unsupported operation exception ( string name ) { return new unsupported operation exception ( name + `` be not implement by `` + this . get class ( ) . get name ( ) ) ; }
public list < language > get language for file ( path source file ) { return get language for file ( source file . get file name ( ) . to string ( ) ) ; }
public language version get default language version for file ( file source file ) { return get default language version for file ( source file . get name ( ) ) ; }
public static metric option of option ( collection < ? extend metric option > option ) { metric option builder builder = new metric option builder ( ) ; builder . add all ( option ) ; return builder . build ( ) ; }
protect void index node ( node node ) { list < node > nod = node name to node . get ( node . get x path node name ( ) ) ; if ( node ! = null ) { node . add ( node ) ; } }
public boolean have override attribute ( ) { return deprecate ! = null || description ! = null || example ! = null || external info url ! = null || maximum language version ! = null || minimum language version ! = null || message ! = null || name ! = null || priority ! = null || property descriptor ! = null || property value ! = null ; }
public static iterable < expression > split union ( expression expr ) { split union union = new split union ( ) ; union . visit ( expr ) ; if ( union . get expression ( ) . be empty ( ) ) { return collection . singleton list ( expr ) ; } else { return union . get expression ( ) ; } }
public string get suppress marker ( ) { return suppress marker ; }
public string get input path ( ) { return input path ; }
public void set show suppressed violation ( boolean show suppress violation ) { this . show suppress violation = show suppressed violation ; }
public t default value ( collection < ? extend v > val ) { this . default value = new array list < > ( val ) ; return ( t ) this ; }
public t default value ( v . . . val ) { this . default value = arrays . a list ( val ) ; return ( t ) this ; }
public string get name ( ) { return name ; }
public static character char from ( string char str ) { return character_parser . value of ( char str ) ; }
public static generic property builder < long > long int property ( string name ) { return new generic property builder < > ( name , value parser constant . long_parser , long . class ) ; }
public static regex property builder regex property ( string name ) { return new regex property builder ( name ) ; }
public string get string id ( ) { return string id ; }
public property descriptor external builder < ? > get factory ( ) { return factory ; }
public static < u > value parser < list < u > > multi ( final value parser < u > parser , final char delimiter ) { return new value parser < list < u > > ( ) { @ override public list < u > value of ( string value ) throw illegal argument exception { return parse primitive ( value , delimiter , parser ) ; } } ; }
public sarif log set schema ( final string schema ) { this . schema = schema ; return this ; }
public void add metric ( metric metric ) { metric . add ( metric ) ; for ( thread safe report listener listener : listener ) { listener . metric add ( metric ) ; } }
public void add violation ( node location ) { add violation with message ( location , get default message ( ) , no_args ) ; }
public object remove attribute ( string name ) { return this . attribute . remove ( name ) ; }
public static rule priority value of ( int priority ) { try { return rule priority . value ( ) [ priority - 1 ] ; } catch ( array index out of bound exception e ) { return low ; } }
public boolean us multifile ( language language ) { for ( rule r : rule ) { if ( r . get language ( ) . equal ( language ) & & r . be multifile ( ) ) { return true ; } } return false ; }
public list < rule set > load from resource ( collection < string > path ) { list < rule set > rule set = new array list < > ( path . size ( ) ) ; for ( string path : path ) { rule set . add ( load from resource ( path ) ) ; } return rule set ; }
public boolean be external ( ) { return external ; }
public boolean be all rule ( ) { return all rule ; }
public string get rule set file name ( ) { return rule set file name ; }
public static class < ? > get type for ( string short name ) { class < ? > type = types_by_name . type for ( short name ) ; if ( type ! = null ) { return type ; } type = primitive_type_names . type for ( short name ) ; if ( type ! = null ) { return type ; } return collection util . get collection type for ( short name ) ; }
public string get pseudo file name ( ) { return string . format ( `` / database/ % s/ % s/ % s % s `` , get schema ( ) , get type ( ) , get name ( ) , get suffix from type ( ) ) ; }
public static string get file name without extension ( string file name ) { string name = file name ; int index = file name . last index of ( ' . ' ) ; if ( index ! = -1 ) { name = file name . substring ( 0 , index ) ; } return name ; }
public static filter < file > get directory filter ( ) { return directory filter . instance ; }
public final void set level ( level min level ) { this . min level = min level ; }
public static tree renderer descriptor find by id ( string id ) { synchronize ( registry ) { return registry . get ( id ) ; } }
public static boolean register ( tree renderer descriptor descriptor ) { synchronize ( registry ) { if ( registry . contains key ( descriptor . id ( ) ) ) { return false ; } registry . put ( descriptor . id ( ) , descriptor ) ; } return true ; }
public boolean contains ( class < ? > type ) { return type by name . contain value ( type ) ; }
public class < ? > type for ( string type name ) { return type by name . get ( type name ) ; }
public java type qualify name get qualify name ( ) { return qualify name ; }
public boolean be fallthrough switch ( ) { return get first child of type ( a s t switch label . class ) ! = null & & get num child ( ) ! = 1 ; }
public list < a s t catch statement > get catch clause ( ) { return find child of type ( a s t catch statement . class ) ; }
public boolean be wildcard ( ) { return get type node ( ) == null ; }
public final boolean have type bound ( ) { return get type bound node ( ) ! = null ; }
public a s t variable declarator id get var id ( ) { return get first child of type ( a s t variable declarator id . class ) ; }
public a s t variable declarator id get variable id ( ) { return ( a s t variable declarator id ) get child ( 0 ) ; }
public boolean be pattern bind ( ) { return get parent ( ) instanceof a s t pattern ; }
public boolean be low bound ( ) { return ! be upper bound ( ) ; }
public a s t reference type get type bound node ( ) { return get first child of type ( a s t reference type . class ) ; }
public a s t expression get expr ( ) { return ( a s t expression ) get child ( 0 ) ; }
public static string word after ( string text , int position ) { if ( text == null || position > = text . length ( ) ) { return null ; } int newposition = position + 1 ; int end = newposition ; char ch = text . char at ( end ) ; while ( character . be letter or digit ( ch ) & & end < text . length ( ) ) { ch = text . char at ( ++end ) ; } return text . substring ( newposition , end ) ; }
public boolean support ( a s t any type declaration node ) { return node . get type kind ( ) ! = type kind . annotation & & node . get type kind ( ) ! = type kind . interface ; }
public static double get ( metric key < method like node > key , a s t any type declaration node , result option result option ) { return metric util . compute aggregate ( key , find ops ( node ) , result option ) ; }
public void cover static ( boolean cover static ) { this . cover static = cover static ; }
public void forbid ( java operation signature . role . . . role ) { role mask . remove all ( array . a list ( role ) ) ; }
public boolean be lambda ( ) { return be lambda ; }
public object visit ( a s t method declaration node , object data ) { list < a s t primary expression > primary expression = node . find descendant of type ( a s t primary expression . class ) ; for ( a s t primary expression expression : primary expression ) { list < method call > call = method call . create method call ( expression ) ; add violation ( call , ( rule context ) data ) ; } return null ; }
public class < ? > load class or null ( string name ) { if ( dont bother . contains key ( name ) ) { return null ; } try { return super . load class ( name ) ; } catch ( class not find exception | linkage error e ) { dont bother . put ( name , boolean . true ) ; return null ; } }
public string name ( ) { return charset . be support ( encode ) ? charset . for name ( encode ) . name ( ) : encoding ; }
public string decode ( byte [ ] encode string , int offset , int length ) throw i o exception { return new string ( encoded string , offset , length , encode ) ; }
public int receive integer2 ( ) throw i o exception { if ( pg_input . read ( _int2buf ) ! = 2 ) { throw new e o f exception ( ) ; } return ( _int2buf [ 0 ] & 0x f f ) < < 8 | _int2buf [ 1 ] & 0x f f ; }
public byte [ ] receive ( int siz ) throw i o exception { byte [ ] answer = new byte [ siz ] ; receive ( answer , 0 , siz ) ; return answer ; }
public void flush ( ) throw i o exception { if ( encode writer ! = null ) { encode writer . flush ( ) ; } pg_output . flush ( ) ; }
public int get version num ( ) { return version ; }
public boolean ensure byte ( int n ) throw i o exception { int require = n - end index + index ; while ( required > 0 ) { if ( ! read more ( require ) ) { return false ; } require = n - end index + index ; } return true ; }
public void close ( ) { synchronize ( lock ) { while ( ! available . be empty ( ) ) { pooled connection pci = available . pop ( ) ; try { pci . close ( ) ; } catch ( s q l exception e ) { } } available = null ; while ( ! use . be empty ( ) ) { pooled connection pci = use . pop ( ) ; pci . remove connection event listener ( connection event listener ) ; try { pci . close ( ) ; } catch ( s q l exception e ) { } } use = null ; } remove store data source ( ) ; }
public static string sqltruncate ( list < ? > parse args ) throw s q l exception { return two argument function call ( `` trunc ( `` , `` truncate `` , parse args ) ; }
public static void sqltimestampdiff ( string builder buf , list < ? extend char sequence > parse args ) throw s q l exception { if ( parsed args . size ( ) ! = 3 ) { throw new p s q l exception ( gt . tr ( `` { 0 } function take three and only three argument . `` , `` timestampdiff `` ) , p s q l state . syntax_error ) ; } buf . append ( `` extract ( `` ) . append ( constant to date part ( buf , parse args . get ( 0 ) . to string ( ) ) ) . append ( `` from ( `` ) . append ( parsed args . get ( 2 ) ) . append ( `` - `` ) . append ( parsed args . get ( 1 ) ) . append ( `` ) ) `` ) ; }
public synchronize void reset ( ) throw i o exception { check close ( ) ; try { if ( mpos < = integer . max_value ) { lo . seek ( ( int ) mpos ) ; } else { lo . seek64 ( mpos , large object . seek_set ) ; } buffer = null ; apos = mpos ; } catch ( s q l exception se ) { throw new i o exception ( se . to string ( ) ) ; } }
public int size ( ) throw s q l exception { int cp = tell ( ) ; seek ( 0 , seek_end ) ; int sz = tell ( ) ; seek ( cp , seek_set ) ; return sz ; }
public void dispose ( ) { if ( sspi context ! = null ) { sspi context . dispose ( ) ; sspi context = null ; } if ( client credential ! = null ) { client credential . dispose ( ) ; client credential = null ; } }
public static string encode byte ( byte [ ] source ) { return encode byte ( source , 0 , source . length , no_options ) ; } // end encode byte
public static short int2 ( byte [ ] byte , int idx ) { return ( short ) ( ( ( bytes [ idx ] & 255 ) < < 8 ) + ( ( bytes [ idx + 1 ] & 255 ) ) ) ; }
public static double float8 ( byte [ ] byte , int idx ) { return double . long bit to double ( int8 ( byte , idx ) ) ; }
public synchronize value get ( key key ) { return cache . get ( key ) ; }
public void set value ( string value ) throw s q l exception { this . value = value ; }
public calendar get calendar ( ) { return calendar ; }
public static string remove curly brace ( string s ) { return remove ( s , `` { `` , `` } `` ) ; }
protect void on parameter status ( string parameter name , string parameter status ) { if ( parameter name == null || parameter name . equal ( `` `` ) ) { throw new illegal state exception ( `` attempt to set guc_report parameter with null or empty-string name `` ) ; } parameter status . put ( parameter name , parameter status ) ; }
public void add new query ( boolean adaptive fetch , @ non null query query ) { if ( adaptive fetch & & maximum result buffer size ! = -1 ) { string sql = query . get native sql ( ) . trim ( ) ; adaptive fetch cache entry adaptive fetch cache entry = adaptive fetch info map . get ( sql ) ; if ( adaptive fetch cache entry == null ) { adaptive fetch cache entry = new adaptive fetch cache entry ( ) ; } adaptive fetch cache entry . increment counter ( ) ; adaptive fetch info map . put ( sql , adaptive fetch cache entry ) ; } }
public void remove query ( boolean adaptive fetch , @ non null query query ) { if ( adaptive fetch & & maximum result buffer size ! = -1 ) { string sql = query . get native sql ( ) . trim ( ) ; adaptive fetch cache entry adaptive fetch cache entry = adaptive fetch info map . get ( sql ) ; if ( adaptive fetch cache entry ! = null ) { adaptive fetch cache entry . decrement counter ( ) ; if ( adaptive fetch cache entry . get counter ( ) < 1 ) { adaptive fetch info map . remove ( sql ) ; } else { adaptive fetch info map . put ( sql , adaptive fetch cache entry ) ; } } } }
public static < t > class < t > load class ( string class name ) { return load class ( class name , class loader util . class . get class loader ( ) ) ; }
public static constructor < ? > [ ] constructor declare in ( final class < ? > cl , final class < ? > . . . additional class ) { if ( cls == null ) { throw new illegal argument exception ( `` you need to supply at least one class . `` ) ; } set < constructor < ? > > constructor = new hash set < constructor < ? > > ( ) ; constructor . add all ( a list ( whitebox impl . get all constructor ( cl ) ) ) ; for ( class < ? > klass : additional class ) { constructor . add all ( a list ( whitebox impl . get all constructor ( klass ) ) ) ; } return constructor . to array ( new constructor [ constructor . size ( ) ] ) ; }
public static accessible object [ ] everything declare in ( final class < ? > cl , final class < ? > . . . additional class ) { if ( cls == null ) { throw new illegal argument exception ( `` you need to supply at least one class . `` ) ; } set < accessible object > accessible object = new hash set < accessible object > ( ) ; accessible object . add all ( collection . unmodifiable collection ( a list ( method declare in ( cl , additional class ) ) ) ) ; accessible object . add all ( collection . unmodifiable collection ( a list ( constructor declare in ( cl , additional class ) ) ) ) ; return accessible object . to array ( new accessible object [ accessible object . size ( ) ] ) ; }
public static void suppress ( field [ ] field ) { suppress code . suppress field ( field ) ; }
public static synchronize void suppress field ( class < ? > [ ] class ) { if ( class == null || class . length == 0 ) { throw new illegal argument exception ( `` you must supply at least one class . `` ) ; } for ( class < ? > clazz : class ) { suppress field ( clazz . get declared field ( ) ) ; } }
public static synchronize void suppress method ( class < ? > cl , class < ? > . . . additional class ) { suppress method ( cl , false ) ; for ( class < ? > clazz : additional class ) { suppress method ( clazz , false ) ; } }
public static synchronize void add suppress static initializer ( string class name ) { suppress static initializers . add ( class name ) ; }
public static synchronize void add object to automatically replay and verify ( object . . . object ) { for ( object mock : object ) { object to automatically replay and verify . add ( mock ) ; } }
public static synchronize object put method to stub ( method method , object value ) { return substitute return value . put ( method , value ) ; }
public static void throw exception if method be not find ( class < ? > type , string method name , method method to mock , object . . . argument ) { if ( method to mock == null ) { string method name data = `` `` ; if ( method name ! = null ) { method name data = `` with name ' `` + method name + `` ' `` ; } throw new method not find exception ( `` no method find `` + method name data + `` with parameter type : [ `` + get argument type a string ( argument ) + `` ] in class `` + get unmocked type ( type ) . get name ( ) + `` . `` ) ; } }
public static constructor < ? > get first parent constructor ( class < ? > klass ) { try { return get unmocked type ( klass ) . get superclass ( ) . get declared constructor ( ) [ 0 ] ; } catch ( exception e ) { throw new constructor not find exception ( `` fail to lookup constructor . `` , e ) ; } }
public static < t > method [ ] get all metods except ( class < t > type , string method name to exclude , class < ? > [ ] argument type ) { method [ ] method = get all method ( type ) ; list < method > method list = new array list < method > ( ) ; outer : for ( method method : method ) { if ( method . get name ( ) . equal ( method name to exclude ) ) { if ( argument type ! = null & & argument type . length > 0 ) { final class < ? > [ ] args = method . get parameter type ( ) ; if ( args ! = null & & args . length == argument type . length ) { for ( int i = 0 ; i < args . length ; i++ ) { if ( args [ i ] . be assignable from ( get unmocked type ( argument type [ i ] ) ) ) { / * * method be not find thus it should not be * mock . continue to investigate the next * method . * / continue outer ; } } } } else { continue ; } } method list . add ( method ) ; } return method list . to array ( new method [ 0 ] ) ; }
public java . lang . string get id ( ) { java . lang . object ref = id_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; id_ = s ; return s ; } }
public java . lang . string get old value ( ) { java . lang . object ref = old value_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; old value_ = s ; return s ; } }
public java . util . list < com . google . api . advice > get advice list ( ) { return advices_ ; }
public java . lang . string get display name ( ) { java . lang . object ref = display name_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; display name_ = s ; return s ; } }
public java . util . list < com . google . api . property > get property list ( ) { return properties_ ; }
public java . lang . string get title ( ) { java . lang . object ref = title_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; title_ = s ; return s ; } }
public boolean have documentation ( ) { return documentation_ ! = null ; }
public boolean have backend ( ) { return backend_ ! = null ; }
public boolean have quota ( ) { return quota_ ! = null ; }
public boolean have control ( ) { return control_ ! = null ; }
public java . util . list < com . google . protobuf . any > get source file list ( ) { return source files_ ; }
public boolean have response ( ) { return response_ ! = null ; }
public boolean get grant ( ) { return granted_ ; }
public java . lang . string get caller supply user agent ( ) { java . lang . object ref = caller supply user agent_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; caller supply user agent_ = s ; return s ; } }
public java . lang . string get request method ( ) { java . lang . object ref = request method_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; request method_ = s ; return s ; } }
public java . lang . string get resource type ( ) { java . lang . object ref = resource type_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; resource type_ = s ; return s ; } }
public java . util . list < com . google . protobuf . any > get detail list ( ) { return details_ ; }
public float get red ( ) { return red_ ; }
public java . lang . string get organization ( ) { java . lang . object ref = organization_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; organization_ = s ; return s ; } }
public set < extension info > get all immutable extension by extend type ( final string full name ) { hash set < extension info > extension = new hash set < extension info > ( ) ; for ( descriptor int pair pair : immutable extension by number . key set ( ) ) { if ( pair . descriptor . get full name ( ) . equal ( full name ) ) { extension . add ( immutable extension by number . get ( pair ) ) ; } } return extension ; }
protect boolean be balance ( ) { return total length > = min length ( tree depth ) ; }
public field info [ ] get field ( ) { return field ; }
public java . lang . string get type url ( ) { java . lang . object ref = type url_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; type url_ = s ; return s ; } }
public static void print ( object o , java . io . writer writer , boolean typeheader ) throw i o exception { if ( o == null ) { if ( typeheader ) writer . write ( `` null object\n `` ) ; writer . write ( `` null\n `` ) ; writer . flush ( ) ; return ; } class < ? > arraytype = o . get class ( ) . get component type ( ) ; if ( arraytype ! = null ) { if ( typeheader ) writer . write ( `` array of `` + arraytype+ `` \n `` ) ; if ( ! arraytype . be primitive ( ) ) { writer . write ( array . deep to string ( ( object [ ] ) o ) ) ; writer . write ( `` \n `` ) ; } else if ( arraytype . equal ( integer . type ) ) { writer . write ( array . to string ( ( int [ ] ) o ) ) ; writer . write ( `` \n `` ) ; } else if ( arraytype . equal ( double . type ) ) { writer . write ( array . to string ( ( double [ ] ) o ) ) ; writer . write ( `` \n `` ) ; } else if ( arraytype . equal ( boolean . type ) ) { writer . write ( array . to string ( ( boolean [ ] ) o ) ) ; writer . write ( `` \n `` ) ; } else if ( arraytype . equal ( short . type ) ) { writer . write ( array . to string ( ( short [ ] ) o ) ) ; writer . write ( `` \n `` ) ; } else if ( arraytype . equal ( long . type ) ) { writer . write ( array . to string ( ( long [ ] ) o ) ) ; writer . write ( `` \n `` ) ; } else if ( arraytype . equal ( float . type ) ) { writer . write ( array . to string ( ( float [ ] ) o ) ) ; writer . write ( `` \n `` ) ; } else if ( arraytype . equal ( character . type ) ) { writer . write ( array . to string ( ( char [ ] ) o ) ) ; writer . write ( `` \n `` ) ; } else if ( arraytype . equal ( byte . type ) ) { writer . write ( array . to string ( ( byte [ ] ) o ) ) ; writer . write ( `` \n `` ) ; } else { writer . write ( `` ? ? ? ? ? ? ? ? ? \n `` ) ; } } else if ( o instanceof set ) { @ suppress warning ( `` unchecked `` ) set < object > set = ( set < object > ) o ; array list < string > list=new array list < string > ( set . size ( ) ) ; for ( object obj : set ) { list . add ( obj . to string ( ) ) ; } collection . sort ( list ) ; if ( typeheader ) { writer . write ( o . get class ( ) . get name ( ) ) ; writer . write ( `` \n `` ) ; } writer . write ( list . to string ( ) ) ; writer . write ( `` \n `` ) ; } else if ( o instanceof map ) { @ suppress warning ( `` unchecked `` ) map < object , object > map= ( map < object , object > ) o ; array list < string > list=new array list < string > ( map . size ( ) ) ; for ( object key : map . key set ( ) ) { list . add ( key . to string ( ) + `` = `` +map . get ( key ) ) ; } collection . sort ( list ) ; if ( typeheader ) { writer . write ( o . get class ( ) . get name ( ) ) ; writer . write ( `` \n `` ) ; } writer . write ( list . to string ( ) ) ; writer . write ( `` \n `` ) ; } else if ( o instanceof collection ) { if ( typeheader ) { writer . write ( o . get class ( ) . get name ( ) ) ; writer . write ( `` \n `` ) ; } writer . write ( o . to string ( ) ) ; writer . write ( `` \n `` ) ; } else if ( o instanceof string ) { if ( typeheader ) writer . write ( `` string\n `` ) ; writer . write ( o . to string ( ) ) ; writer . write ( `` \n `` ) ; } else if ( o instanceof java . util . calendar ) { if ( typeheader ) writer . write ( `` java . util . calendar\n `` ) ; date format f = date format . get date time instance ( date format . medium , date format . medium , locale . uk ) ; calendar c = ( calendar ) o ; writer . write ( f . format ( c . get time ( ) ) + `` millisec= `` + c . get ( calendar . millisecond ) + `` \n `` ) ; } else { if ( typeheader ) { writer . write ( o . get class ( ) . get name ( ) ) ; writer . write ( `` \n `` ) ; } writer . write ( o . to string ( ) ) ; writer . write ( `` \n `` ) ; } writer . flush ( ) ; }
public boolean get ignore unlabeled ( ) { return ignore unlabeled ; }
public static class loader static class loader ( ) { return reflection . class . get class loader ( ) ; }
public configuration builder set input filter ( predicate < string > input filter ) { this . input filter = input filter ; return this ; }
public configuration builder set parallel ( boolean parallel ) { be parallel = parallel ; return this ; }
public static < t extend member > predicate < t > with public ( ) { return reflection utils predicate . with modifier ( modifier . public ) ; }
public static void set default u r l type ( final list < url type > url type ) { default url type = url type ; }
public set < string > key set ( ) { return store map . key set ( ) ; }
public metadata adapter get metadata adapter ( ) { if ( metadata adapter ! = null ) return metadata adapter ; else { try { return ( metadata adapter = new javassist adapter ( ) ) ; } catch ( throwable e ) { if ( reflection . log ! = null ) reflection . log . warn ( `` could not create javassist adapter , use java reflection adapter `` , e ) ; return ( metadata adapter = new java reflection adapter ( ) ) ; } } }
public static boolean be empty ( string s ) { return s == null || s . length ( ) == 0 ; }
public set < field > get field annotate with ( final annotation annotation ) { return get all ( get field annotate with ( annotation . annotation type ( ) ) , with annotation ( annotation ) ) ; }
public boolean be inherit annotation ( string type annotate with ) { multimap < string , string > mmap = get ( type annotation scanner . class ) ; return mmap ! = null & & mmap . get ( inherit . class . get name ( ) ) . contains ( type annotate with ) ; }
public static mutable roar bitmap horizontal_or ( mutable roaring bitmap . . . bitmap ) { return horizontal_or ( convert to immutable ( bitmap ) ) ; }
public boolean be empty ( ) { return this . size == 0 ; }
public mutable roar bitmap limit ( int maxcardinality ) { mutable roar bitmap answer = new mutable roaring bitmap ( ) ; int currentcardinality = 0 ; for ( int i = 0 ; ( currentcardinality < maxcardinality ) & & ( i < this . high low container . size ( ) ) ; i++ ) { mappeable container c = this . high low container . get container at index ( i ) ; if ( c . get cardinality ( ) + currentcardinality < = maxcardinality ) { ( ( mutable roar array ) answer . high low container ) . append ( this . high low container . get key at index ( i ) , c . clone ( ) ) ; currentcardinality += c . get cardinality ( ) ; } else { int leftover = maxcardinality - currentcardinality ; mappeable container limit = c . limit ( leftover ) ; ( ( mutable roar array ) answer . high low container ) . append ( this . high low container . get key at index ( i ) , limited ) ; break ; } } return answer ; }
public string get container name ( ) { if ( this instanceof mappeable bitmap container ) { return `` mappeablebitmap `` ; } else if ( this instanceof mappeable array container ) { return `` mappeablearray `` ; } else { return `` mappeablerun `` ; } }
public mappeable container lazy o r ( mappeable container x ) { if ( this instanceof mappeable array container ) { if ( x instanceof mappeable array container ) return or ( ( mappeable array container ) x ) ; else if ( x instanceof mappeable bitmap container ) return ( ( mappeable bitmap container ) x ) . lazyor ( ( mappeable array container ) this ) ; return ( ( mappeable run container ) x ) . lazyor ( ( mappeable array container ) this ) ; } else if ( this instanceof mappeable run container ) { if ( x instanceof mappeable array container ) return ( ( mappeable run container ) this ) . lazyor ( ( mappeable array container ) x ) ; else if ( x instanceof mappeable bitmap container ) return ( ( mappeable bitmap container ) x ) . lazyor ( ( mappeable run container ) this ) ; return or ( ( mappeable run container ) x ) ; } else { if ( x instanceof mappeable array container ) return ( ( mappeable bitmap container ) this ) . lazyor ( ( mappeable array container ) x ) ; else if ( x instanceof mappeable bitmap container ) return ( ( mappeable bitmap container ) this ) . lazyor ( ( mappeable bitmap container ) x ) ; return ( ( mappeable bitmap container ) this ) . lazyor ( ( mappeable run container ) x ) ; } }
public container xor ( container x ) { if ( x instanceof array container ) return xor ( ( array container ) x ) ; else if ( x instanceof bitmap container ) return xor ( ( bitmap container ) x ) ; return xor ( ( run container ) x ) ; }
public string get label ( ) { return label ; }
public string get scheme ( ) { return scheme ; }
public void set scheme ( final string scheme ) { this . scheme = scheme ; }
public string get mode ( ) { return mode ; }
public void set publish ( final date publish ) { this . publish = date . copy ( publish ) ; }
public void set summary ( final content summary ) { this . summary = summary ; }
public void set title ( final string title ) { if ( this . title == null ) { this . title = new content ( ) ; } this . title . set value ( title ) ; }
public void set update ( final date update ) { this . updated = date . copy ( update ) ; }
public void set other link ( final list < link > other link ) { this . other link = other link ; }
public list < synd person > get contributor ( ) { return contributor = list . create when null ( contributor ) ; }
public void set module ( final list < module > module ) { this . module = module ; }
public void set version ( final string version ) { this . version = version ; }
public string get hreflang ( ) { return hreflang ; }
public void set creator ( final list < string > creator ) { creator = creator ; }
public list < string > get type ( ) { return type = list . create when null ( type ) ; }
public void set language ( final string language ) { this . language = list . create ( language ) ; }
public void set right list ( final list < string > right ) { this . right = right ; }
public string get right ( ) { return list . first entry ( right ) ; }
public void set right ( final string right ) { this . right = list . create ( right ) ; }
public int get update frequency ( ) { return update frequency ; }
public void set update frequency ( final int update frequency ) { this . update frequency = update frequency ; }
public string get web master ( ) { return web master ; }
public list < integer > get skip hour ( ) { return list . create when null ( skip hour ) ; }
public list < string > get skip day ( ) { return list . create when null ( skip day ) ; }
public void set category ( final list < category > category ) { this . category = category ; }
public void set generator ( final string generator ) { this . generator = generator ; }
public string get domain ( ) { return domain ; }
public string get path ( ) { return path ; }
public void set value ( final string value ) { this . value = value ; }
public string get type ( ) { return type ; }
public string get value ( ) { return value ; }
public string get url ( ) { return url ; }
public void set width ( final integer width ) { this . width = width ; }
public integer get height ( ) { return height ; }
public source get source ( ) { return source ; }
public void set guid ( final guid guid ) { this . guid = guid ; }
public void set module ( final list < module > module ) { this . module = module ; }
public void set expiration date ( final date expiration date ) { this . expiration date = date . copy ( expiration date ) ; }
public string get name ( ) { return name ; }
public void set publish date ( final date publish date ) { get d c module ( ) . set date ( publish date ) ; }
public date get update date ( ) { return date . copy ( updated date ) ; }
public void set updated date ( final date updated date ) { this . updated date = new date ( updated date . get time ( ) ) ; }
public string get encode ( ) { return encode ; }
public string get description ( ) { if ( description ! = null ) { return description . get value ( ) ; } return null ; }
public void set description ( final string description ) { if ( this . description == null ) { this . description = new synd content impl ( ) ; } this . description . set value ( description ) ; }
public void set copyright ( final string copyright ) { get d c module ( ) . set right ( copyright ) ; }
public void set category ( final list < synd category > category ) { get d c module ( ) . set subject ( synd category list facade . convert element synd category to subject ( category ) ) ; }
public void set feed type ( final string feed type ) { this . fee type = feed type ; }
public void set encoding ( final string encode ) { this . encode = encoding ; }
public static date parse date ( final string s date , final locale locale ) { date date = null ; if ( additional_masks . length > 0 ) { date = parse use mask ( additional_masks , s date , locale ) ; if ( date ! = null ) { return date ; } } date = parse w3 c date time ( s date , locale ) ; if ( date == null ) { date = parse r f c822 ( s date , locale ) ; } return date ; }
public final set < namespace > get namespaces ( ) { return namespaces ; }
protect final list < element > generate simple element list ( final string name , final list < string > value ) { final list < element > element = new array list < element > ( ) ; for ( final string value : value ) { element . add ( generate simple element ( name , value ) ) ; } return element ; }
protect string get text input label ( ) { return `` text input `` ; }
public void set xml healer on ( final boolean heals ) { feed input . set xml healer on ( heals ) ; }
public boolean get xml healer on ( ) { return feed input . get xml healer on ( ) ; }
public document output j dom ( final synd feed feed ) throw feed exception { return feed output . output j dom ( feed . create wire feed ( ) ) ; }
public static list < string > get support feed type ( ) { return get fee generator ( ) . get supported feed type ( ) ; }
public static < t > t first not null ( final t . . . object ) { for ( final t object : object ) { if ( object ! = null ) { return object ; } } return null ; }
public static completable from future ( future < ? > future ) { require non null ( future ) ; return from observable ( observable . from ( future ) ) ; }
public final completable delay ( long delay , time unit unit , scheduler scheduler ) { return delay ( delay , unit , scheduler , false ) ; }
public final completable timeout ( long timeout , time unit unit , completable other ) { require non null ( other ) ; return timeout0 ( timeout , unit , scheduler . computation ( ) , other ) ; }
public final completable timeout ( long timeout , time unit unit , scheduler scheduler ) { return timeout0 ( timeout , unit , scheduler , null ) ; }
public static < t > void post complete do ( atomic long request , queue < t > queue , subscriber < ? super t > actual ) { post complete do ( request , queue , actual , utility function . < t > identity ( ) ) ; }
protect final void complete ( ) { actual . on complete ( ) ; }
public final void subscribe to ( observable < ? extend t > source ) { setup downstream ( ) ; source . unsafe subscribe ( this ) ; }
public static < t > observable < t > instance ( ) { return ( observable < t > ) never ; }
public static schedule executor service create ( ) { func0 < ? extends schedule executor service > f = rx java hook . get on generic schedule executor service ( ) ; if ( f == null ) { return create default ( ) ; } return f . call ( ) ; }
public static void deregister executor ( schedule executor service service ) { executor . remove ( service ) ; }
public static throwable terminate ( atomic reference < throwable > field ) { throwable current = field . get ( ) ; if ( current ! = terminate ) { current = field . get and set ( terminate ) ; } return current ; }
public static < t > func0 < connectable observable < t > > create replay supplier ( final observable < t > source ) { return new replay supplier no params < t > ( source ) ; }
public static long address of ( class < ? > clazz , string field name ) { try { field f = clazz . get declared field ( field name ) ; return unsafe . object field offset ( f ) ; } catch ( no such field exception ex ) { internal error ie = new internal error ( ) ; ie . init cause ( ex ) ; throw ie ; } }
public boolean have throwable ( ) { return be on error ( ) & & throwable ! = null ; }
public static < t > observable < t > just ( final t value ) { return scalar synchronous observable . create ( value ) ; }
public static < r > observable < r > zip ( observable < ? extend observable < ? > > w , final func n < ? extend r > zip function ) { return w . to list ( ) . map ( internal observable utils . to_array ) . lift ( new operator zip < r > ( zip function ) ) ; }
public final observable < t > cache ( int initial capacity ) { return cache with initial capacity ( initial capacity ) ; }
public final observable < t > delay subscription ( long delay , time unit unit ) { return delay subscription ( delay , unit , scheduler . computation ( ) ) ; }
public static < t > observable < t > concat eager ( observable < ? extend t > o1 , observable < ? extend t > o2 ) { return concat eager ( array . a list ( o1 , o2 ) ) ; }
public final observable < t > first or default ( t default value ) { return take ( 1 ) . single or default ( default value ) ; }
public final observable < t > on backpressure late ( ) { return lift ( operator on backpressure late . < t > instance ( ) ) ; }
public final observable < t > serialize ( ) { return lift ( operator serialize . < t > instance ( ) ) ; }
public final observable < t > throttle with timeout ( long timeout , time unit unit ) { return debounce ( timeout , unit ) ; }
public final < v > observable < t > timeout ( func1 < ? super t , ? extend observable < v > > timeout selector , observable < ? extend t > other ) { return timeout ( null , timeout selector , other ) ; }
public final observable < t > timeout ( long timeout , time unit time unit , observable < ? extend t > other , scheduler scheduler ) { return lift ( new operator timeout < t > ( timeout , time unit , other , scheduler ) ) ; }
public final < t closing > observable < observable < t > > window ( func0 < ? extend observable < ? extend t close > > closing selector ) { return lift ( new operator window with observable factory < t , t close > ( close selector ) ) ; }
public final assertable subscriber < t > test ( long initial request amount ) { assertable subscriber < t > t = assertable subscriber observable . create ( initial request amount ) ; subscribe ( t ) ; return t ; }
public static < t > test subscriber < t > create ( ) { return new test subscriber < t > ( ) ; }
public static void reset ( ) { if ( lockdown ) { return ; } init ( ) ; on computation scheduler = null ; on i o scheduler = null ; on new thread scheduler = null ; on generic schedule executor service = null ; }
public static throwable on observable error ( throwable error ) { func1 < throwable , throwable > f = on observable subscribe error ; if ( f ! = null ) { return f . call ( error ) ; } return error ; }
public static void set on generic schedule executor service ( func0 < ? extends schedule executor service > factory ) { if ( lockdown ) { return ; } on generic schedule executor service = factory ; }
public static < t > observable < t > merge ( single < ? extend t > t1 , single < ? extend t > t2 , single < ? extend t > t3 ) { return observable . merge ( a observable ( t1 ) , a observable ( t2 ) , a observable ( t3 ) ) ; }
public static < t1 , t2 , r > single < r > zip ( single < ? extend t1 > s1 , single < ? extend t2 > s2 , final func2 < ? super t1 , ? super t2 , ? extend r > zip function ) { return single operator zip . zip ( new single [ ] { s1 , s2 } , new func n < r > ( ) { @ override public r call ( object . . . args ) { return zip function . call ( ( t1 ) args [ 0 ] , ( t2 ) args [ 1 ] ) ; } } ) ; }
public final < e > single < t > take until ( final single < ? extend e > other ) { return create ( new single take until single < t , e > ( on subscribe , other ) ) ; }
public final single < t > timeout ( long timeout , time unit time unit ) { return timeout ( timeout , time unit , null , scheduler . computation ( ) ) ; }
public structure q name get top level element ( ) { return option . get top level element ( ) ; }
public boolean be x include aware set ( ) { return option . be x include aware set ( ) ; }
public boolean be x include aware ( ) { return option . be x include aware ( ) ; }
public error listener get error listener ( ) { return option . get error listener ( ) ; }
public static boolean be low surrogate ( int ch ) { return ( surrogate2_min < = ch & & ch < = surrogate2_max ) ; }
public static boolean be valid10 ( int i ) { return i < 65536 ? ( data [ i ] & valid_10_mask ) ! = 0 : ( utf16 . nonbmp_min < = i & & i < = utf16 . nonbmp_max ) ; }
public static boolean be valid11 ( int i ) { return i < 65536 ? ( data [ i ] & valid_11_mask ) ! = 0 : ( utf16 . nonbmp_min < = i & & i < = utf16 . nonbmp_max ) ; }
public string get initial mode ( ) { return initial mode . get clark name ( ) ; }
public boolean have there be an explicit result document ( ) { return there have be an explicit result document ; }
public sequence outputter allocate sequence outputter ( int size ) { if ( reusable sequence outputter ! = null ) { sequence outputter out = reusable sequence outputter ; reusable sequence outputter = null ; return out ; } else { return new sequence outputter ( this , size ) ; } }
public executable get executable ( ) { return executable ; }
public void set principal source document ( document info doc ) { initial context item = doc ; }
public bindery get bindery ( ) { return bindery ; }
public void set rule manager ( rule manager r ) { rule manager = r ; }
public final void pause tracing ( boolean pause ) { trace pause = pause ; }
public path map get path map for document projection ( ) { return path map ; }
public void set line number ( boolean line number ) { this . line number = line numbering ; }
public boolean be time ( ) { return timing ; }
public long get current location id ( ) { return current location id ; }
public void end document ( ) throw x path exception { }
public int get line number ( ) { final location provider location provider = parent . get location provider ( ) ; if ( location provider == null ) { return -1 ; } else { return location provider . get line number ( parent . get current location id ( ) ) ; } }
public boolean us writer ( ) { return true ; }
public output stream get output stream ( ) { return output stream ; }
public void set underlying receiver ( receiver receiver ) { next receiver = receiver ; }
public boolean be use xsi schema location ( ) { return use xsi schema location ; }
public void reset ( ) { pipe = null ; pool = null ; receiver = null ; ignore ignorable = false ; retain d t d attribute type = false ; char use = 0 ; slice . set length ( 0 ) ; namespaces use = 0 ; locator = null ; allow disable output escape = false ; escape disable = false ; }
protect boolean advise reuse ( ) { return builder instanceof tiny builder & & ( ( tiny builder ) builder ) . get tree ( ) . get number of node ( ) < 20000 ; }
public void start content ( ) throw x path exception { in start tag = false ; outputter . start content ( ) ; previous atomic = false ; }
protect meta tag adjuster new x h t m l meta tag adjuster ( pipeline configuration pipe , property output property ) { meta tag adjuster r = new meta tag adjuster ( ) ; r . set pipeline configuration ( pipe ) ; r . set output property ( output property ) ; r . set be x h t m l ( true ) ; return r ; }
public boolean have attribute ( ) { return buffer attribute . get length ( ) > 0 ; }
public void write declaration ( ) throw x path exception { }
public void set system id ( string system id ) { super . set system id ( system id ) ; controller . set base output u r i ( system id ) ; }
public void set result ( result result ) { if ( result==null ) { throw new illegal argument exception ( `` result must not be null `` ) ; } this . result = result ; }
public void open ( ) throw x path exception { if ( next receiver == null ) { throw new illegal state exception ( `` tree receiver . open ( ) : no underlie receiver provide `` ) ; } next receiver . open ( ) ; previous atomic = false ; }
protect int test character ( char sequence char ) throw x path exception { for ( int i=0 ; i < char . length ( ) ; i++ ) { char c = char . char at ( i ) ; if ( c > 127 ) { if ( utf16 . be high surrogate ( c ) ) { int cc = utf16 . combine pair ( c , char . char at ( ++i ) ) ; if ( ! character set . in charset ( cc ) ) { return cc ; } } else if ( ! character set . in charset ( c ) ) { return c ; } } } return 0 ; }
public void write char sequence ( char sequence s ) throw java . io . i o exception { if ( s instanceof string ) { writer . write ( ( string ) s ) ; } else if ( s instanceof char slice ) { ( ( char slice ) s ) . write ( writer ) ; } else if ( s instanceof fast string buffer ) { ( ( fast string buffer ) s ) . write ( writer ) ; } else if ( s instanceof compress whitespace ) { ( ( compress whitespace ) s ) . write ( writer ) ; } else { writer . write ( s . to string ( ) ) ; } }
public sequence iterator get another ( ) throw x path exception { throw new unsupported operation exception ( `` get another `` ) ; }
public void set name code ( int name code ) { this . name code = name code ; }
public void namespace fixup ( ) { name pool pool = pipe . get configuration ( ) . get name pool ( ) ; name code = fixup ( pool , name code , 0 ) ; if ( attribute ! = null ) { for ( int a=0 ; a < attribute . size ( ) ; a++ ) { node info old att = ( node info ) attribute . get ( a ) ; int old code = old att . get name code ( ) ; int new code = fixup ( pool , old code , a ) ; if ( old code ! = new code ) { orphan att = new orphan ( old att . get configuration ( ) ) ; att . set node kind ( type . attribute ) ; att . set name code ( new code ) ; att . set string value ( old att . get string value ( ) ) ; att . set type annotation ( old att . get type annotation ( ) ) ; att . set system id ( old att . get system id ( ) ) ; attribute . set ( a , att ) ; } } } }
public void set x m l stream reader ( x m l stream reader reader ) { this . reader = reader ; }
public expression simplify ( expression visitor visitor ) throw x path exception { operand = visitor . simplify ( operand ) ; if ( operand instanceof literal ) { value representation val = sequence extent . make sequence extent ( iterate ( visitor . get static context ( ) . make early evaluation context ( ) ) ) ; return literal . make literal ( value . a value ( val ) ) ; } return this ; }
public static boolean be possible cast ( int source , int target ) { if ( source == standard name . xs_any_atomic_type || source == type . empty ) { return true ; } if ( source == standard name . xs_numeric ) { source = standard name . xs_double ; } int [ ] target = ( int [ ] ) cast table . get ( source ) ; if ( target == null ) { return false ; } for ( int i=0 ; i < target . length ; i++ ) { if ( target [ i ] == target ) { return true ; } } return false ; }
public item type get item type ( type hierarchy th ) { return target type ; }
public void set default collation name ( string name ) { default collation name = name ; }
public expression copy ( ) { context item expression cie2 = new context item expression ( ) ; cie2 . item type = item type ; return cie2 ; }
public iterator iterate sub expression ( ) { return collection . empty_list . iterator ( ) ; }
public void evaluate pending update ( x path context context , pending update list pul ) throw x path exception { throw new unsupported operation exception ( `` expression `` + get class ( ) + `` be not an updating expression `` ) ; }
public container get container ( ) { return container ; }
public void adopt child expression ( expression child ) { if ( child == null ) { return ; } if ( container == null ) { container = child . container ; } else { child . set container ( container ) ; } if ( location id == -1 ) { expression tool . copy location info ( child , this ) ; } else if ( child . location id == -1 ) { expression tool . copy location info ( this , child ) ; } reset local static property ( ) ; }
public final void compute static property ( ) { static property = compute dependency ( ) | compute cardinality ( ) | compute special property ( ) ; }
public int get intrinsic dependency ( ) { return 0 ; }
public int mark tail function call ( structure q name q name , int arity ) { return 0 ; }
protect void type error ( string message , string error code , x path context context ) throw x path exception { x path exception e = new x path exception ( message , this ) ; e . set be type error ( true ) ; e . set error code ( error code ) ; e . set x path context ( context ) ; throw e ; }
public string get system id ( long location id ) { return get system id ( ) ; }
public static context get static context ( ) { return static context ; }
public void set static context ( static context static context ) { this . static context = static context ; }
public expression optimize ( expression exp , item type context item type ) throw x path exception { if ( exp ! = null ) { stack . push ( exp ) ; expression exp2 = exp . optimize ( this , context item type ) ; stack . pop ( ) ; return exp2 ; } else { return null ; } }
public int get require slot ( ) { return ( position variable == null ? 1 : 2 ) ; }
public void process ( x path context context ) throw x path exception { sequence iterator iter = sequence . iterate ( context ) ; int position = 1 ; int slot = get local slot number ( ) ; int pslot = -1 ; if ( position variable ! = null ) { pslot = position variable . get local slot number ( ) ; } while ( true ) { item item = iter . next ( ) ; if ( item == null ) break ; context . set local variable ( slot , item ) ; if ( pslot > = 0 ) { context . set local variable ( pslot , int64 value . make integer value ( position++ ) ) ; } action . process ( context ) ; } }
public final boolean create new node ( ) { return ( action . get special property ( ) & finally exp . get special property ( ) & static property . non_creative ) == 0 ; }
public void process ( x path context context ) throw x path exception { sequence iterator iter = value . iterate ( ) ; sequence receiver out = context . get receiver ( ) ; while ( true ) { item it = iter . next ( ) ; if ( it==null ) break ; out . append ( it , 0 , node info . all_namespaces ) ; } }
public int get slot number ( ) { return slot number ; }
public object next ( ) { if ( go ) { throw new no such element exception ( ) ; } else { go = true ; return thing ; } }
public expression optimize copy ( expression select ) throw x path exception { final type hierarchy th = config . get type hierarchy ( ) ; if ( select . get item type ( th ) . be atomic type ( ) ) { return select ; } return null ; }
public value make closure ( expression expression , int ref , x path context context ) throw x path exception { if ( ref == 1 ) { return new closure ( ) ; } else { return new memo closure ( ) ; } }
public expression try indexed filter ( filter expression f , expression visitor visitor , boolean index first operand ) { return f ; }
public static p j converter allocate node list creator ( configuration config , object node ) { list external object model = config . get external object model ( ) ; for ( int m=0 ; m < external object model . size ( ) ; m++ ) { external object model model = ( external object model ) external object model . get ( m ) ; p j converter converter = model . get node list creator ( node ) ; if ( converter ! = null ) { return converter ; } } return to collection . instance ; }
public int compute cardinality ( ) { if ( ( get implementation method ( ) & expression . evaluate_method ) == 0 ) { return static property . allows_one_or_more ; } else { return static property . allows_zero_or_one ; } }
public final item type get item type ( type hierarchy th ) { return step . get item type ( th ) ; }
public int get last position ( ) throw x path exception { int last base = ( ( last position finder ) base ) . get last position ( ) ; int z = math . min ( last base , max ) ; return math . max ( z - min + 1 , 0 ) ; }
public boolean equal ( object other ) { return this==other ; }
public static expression make ( expression sequence , sequence type type ) { role locator role = new role locator ( role locator . type_op , `` treat a `` , 0 ) ; role . set error code ( `` xpdy0050 `` ) ; expression e = cardinality checker . make cardinality checker ( sequence , type . get cardinality ( ) , role ) ; item checker checker = new item checker ( e , type . get primary type ( ) , role ) ; return checker ; }
public int compute cardinality ( ) { return operand . get cardinality ( ) ; }
public void set confirm ( boolean conf ) { confirm = conf ; }
public void set filter ( boolean filter ) { this . filter = filter ; }
public user function get tail call function ( ) { user function fn = tail call function ; tail call function = null ; return fn ; }
public static string date time ( x path context context ) throw x path exception { return context . get current date time ( ) . get string value ( ) ; }
public static double week in year ( x path context context ) throw x path exception { return week in year ( date time ( context ) ) ; }
public static double day of week in month ( x path context context ) throw x path exception { return day of week in month ( date time ( context ) ) ; }
public static double day in week ( string date time ) { double yy = year ( date time ) ; double mm = month in year ( date time ) ; double dd = day in month ( date time ) ; if ( double . be na n ( yy ) || double . be na n ( mm ) || double . be na n ( dd ) ) { return double . na n ; } gregorian calendar cal date = new gregorian calendar ( ( int ) yy , ( int ) mm-1 , ( int ) dd ) ; cal date . set first day of week ( calendar . sunday ) ; return cal date . get ( calendar . day_of_week ) ; }
public uri get expression base u r i ( ) { return expression base u r i ; }
public void send document ( x path context context , receiver out ) throw x path exception { atomic value href val = ( atomic value ) argument [ 0 ] . evaluate item ( context ) ; if ( href val==null ) { return ; } string href = href val . get string value ( ) ; try { document . send doc ( href , expression base u r i , context , this , out ) ; } catch ( x path exception e ) { e . maybe set location ( this ) ; if ( e . get error code local part ( ) == null ) { e . set error code ( `` fodc0005 `` ) ; } throw e ; } }
public accessible object get target method ( ) { return the method ; }
public x query function get declaration ( structure q name function name , expression [ ] static args ) { for ( iterator it=library list . iterator ( ) ; it . have next ( ) ; ) { function library lib = ( function library ) it . next ( ) ; if ( lib instanceof x query function binder ) { x query function func = ( ( x query function binder ) lib ) . get declaration ( function name , static args ) ; if ( func ! = null ) { return func ; } } } return null ; }
public list get library list ( ) { return library list ; }
public static sequence iterator get id multiple ( document info doc , sequence iterator idrefs ) throw x path exception { id mapping function map = new id mapping function ( ) ; map . document = doc ; sequence iterator result = new mapping iterator ( idrefs , map ) ; return new document order iterator ( result , local order comparer . get instance ( ) ) ; }
public static boolean be nilled ( node info node ) { boolean value b = get nilled property ( node ) ; return b ! = null & & b . get boolean value ( ) ; }
public static function call make system function ( string name , expression [ ] argument ) { standard function . entry entry = standard function . get function ( name , argument . length ) ; if ( entry==null ) { return null ; } class function class = entry . implementation class ; try { system function f = ( system function ) function class . new instance ( ) ; f . set detail ( entry ) ; f . set function name ( new structure q name ( `` `` , namespace constant . fn , name ) ) ; f . set argument ( argument ) ; return f ; } catch ( illegal access exception err ) { return null ; } catch ( instantiation exception err ) { return null ; } }
public standard function . entry get detail ( ) { return detail ; }
public string get system id ( ) { return system id ; }
public expression get matching expression ( ) { return matching ; }
public void set no special char ( ) { option |= receiver option . no_special_chars ; }
public void assign global variable ( global variable binding , value representation value ) { define global variable ( bind , value ) ; }
public expression [ ] get child ( ) { return child ; }
public boolean be inherit namespaces ( ) { return inherit namespaces ; }
public void set character map index ( hash map cmi ) { character map index = cmi ; }
public hash map get character map index ( ) { if ( character map index == null ) { character map index = new hash map ( 10 ) ; } return character map index ; }
public key manager get key manager ( ) { if ( key manager == null ) { key manager = new key manager ( get configuration ( ) ) ; } return key manager ; }
public string collator get name collation ( string name ) { if ( collation table == null ) { collation table = new collation map ( config ) ; } return collation table . get name collation ( name ) ; }
public void set require param ( boolean require param ) { if ( require param ) { property |= require ; } else { property & = ~required ; } }
public void set implicitly require param ( boolean require param ) { if ( require param ) { property |= implicitly_required ; } else { property & = ~implicitly_required ; } }
public int get cardinality ( ) { return static property . empty ; }
public int get host language ( ) { return host language ; }
public void set construct type ( int type ) { construct type = type ; }
public int get construct type ( ) { return construct type ; }
public void set use static base uri ( boolean static base ) { resolve against static base = static base ; }
public void set have require params ( boolean have ) { have require params = have ; }
public void set require type ( sequence type type ) { require type = type ; }
public void gather direct contributing callees ( set result ) { expression body = get body ( ) ; gather direct contributing callees ( body , result ) ; }
public void set slot number ( int slot ) { slot number = slot ; }
public void set be number instruction ( ) { be number instruction = true ; }
public value representation evaluate variable ( x path context context ) throw x path exception { throw new unsupported operation exception ( ) ; }
public void add function library ( function library list list , configuration config , int host language ) { function library extension binder = config . get extension binder ( `` java `` ) ; if ( extension binder instanceof java extension library ) { ( ( java extension library ) extension binder ) . set strict java uri format ( host language ! = configuration . xslt ) ; } list . add function library ( extension binder ) ; }
public sequence iterator get another ( ) { return new j regex iterator ( the string , pattern ) ; }
public static boolean be alphanumeric ( int codepoint ) { return alphanumerics . contains ( codepoint ) ; }
public byte be space preserve ( int name code ) { return strip_default ; }
public int get start position ( ) { return start ; }
public int position ( ) { return 0 ; }
public int get last position ( ) { return 0 ; }
public int length ( ) { return use ; }
public void remove char at ( int index ) { if ( index < 0 || index > use ) { throw new index out of bound exception ( `` `` +index ) ; } use -- ; system . arraycopy ( array , index + 1 , array , index , use - index ) ; }
public void prepend ( char ch ) { char [ ] a2 = new char [ array . length + 1 ] ; system . arraycopy ( array , 0 , a2 , 1 , use ) ; a2 [ 0 ] = ch ; use += 1 ; array = a2 ; }
public boolean be n c name start char ( int ch ) { return x m l character data . be n c name start10 ( ch ) ; }
public final string [ ] get q name part ( char sequence qname ) throw q name exception { string [ ] part = new string [ 2 ] ; int colon = -1 ; int len = qname . length ( ) ; for ( int i = 0 ; i < len ; i++ ) { if ( qname . char at ( i ) == ' : ' ) { colon = i ; break ; } } if ( colon < 0 ) { part [ 0 ] = `` `` ; part [ 1 ] = qname . to string ( ) ; if ( ! be valid n c name ( part [ 1 ] ) ) { throw new q name exception ( `` invalid q name `` + err . wrap ( qname ) ) ; } } else { if ( colon == 0 ) { throw new q name exception ( `` q name can not start with colon : `` + err . wrap ( qname ) ) ; } if ( colon == len - 1 ) { throw new q name exception ( `` q name can not end with colon : `` + err . wrap ( qname ) ) ; } part [ 0 ] = qname . sub sequence ( 0 , colon ) . to string ( ) ; part [ 1 ] = qname . sub sequence ( colon + 1 , len ) . to string ( ) ; if ( ! be valid n c name ( part [ 1 ] ) ) { throw new q name exception ( `` invalid q name local part `` + err . wrap ( part [ 1 ] ) ) ; } } return part ; }
public final boolean be valid n c name ( char sequence nc name ) { if ( nc name . length ( ) == 0 ) { return false ; } char ch = nc name . char at ( 0 ) ; if ( ! be n c name start char ( ch ) ) { return false ; } for ( int i = 1 ; i < nc name . length ( ) ; i++ ) { ch = nc name . char at ( i ) ; if ( ! be n c name char ( ch ) ) { return false ; } } return true ; }
public static synchronize name pool get default name pool ( ) { if ( default name pool == null ) { default name pool = new name pool ( ) ; } return default name pool ; }
public static int get prefix index ( int name code ) { return ( name code > > 20 ) & 0x3ff ; }
public short get code for prefix ( string prefix ) { for ( short i = 0 ; i < prefix use ; i++ ) { if ( prefixes [ i ] . equal ( prefix ) ) { return i ; } } return -1 ; }
public object get client data ( class key ) { if ( client data == null ) { return null ; } return client data . get ( key ) ; }
public int get document number ( ) { return node . get document number ( ) ; }
public string get namespace u r i ( ) { if ( local name start == 0 ) { return empty_string ; } return new string ( content , 0 , local name start ) ; }
public int get node kind ( ) { return original . get node kind ( ) ; }
public string get system id ( ) { return system id ; }
public string get base u r i ( ) { return navigator . get base u r i ( this ) ; }
public int compare order ( node info other ) { return original . compare order ( ( ( virtual copy ) other ) . original ) ; }
public int get name code ( ) { return original . get name code ( ) ; }
public document info get document root ( ) { node info root = get root ( ) ; if ( root . get node kind ( ) == type . document ) { return ( document info ) root ; } return null ; }
public value atomize ( ) throw x path exception { return original . atomize ( ) ; }
public boolean be idref ( ) { return original . be idref ( ) ; }
public boolean match ( node info node ) { int node kind = node . get node kind ( ) ; return ( node kind == type . element || node kind == type . text || node kind == type . comment || node kind == type . processing_instruction ) ; }
public void set match d t d type ( boolean match ) { this . match d t d type = match ; }
public item type get primitive item type ( ) { return this ; }
public boolean equal ( object other ) { return ( other instanceof i d pattern ) & & ( ( i d pattern ) other ) . id expression . equal ( id expression ) ; }
public void add filter ( expression filter ) { if ( filter == null ) { filter = new expression [ 3 ] ; } else if ( number of filter == filter . length ) { expression [ ] f2 = new expression [ number of filter * 2 ] ; system . arraycopy ( filter , 0 , f2 , 0 , number of filter ) ; filter = f2 ; } filter [ number of filters++ ] = filter ; filter . set container ( this ) ; }
public int get fingerprint ( ) { return node test . get fingerprint ( ) ; }
public int get fingerprint ( ) { return node test . get fingerprint ( ) ; }
public void explain ( expression presenter presenter ) { presenter . start element ( `` stylesheet `` ) ; get executable ( ) . get key manager ( ) . explain key ( presenter ) ; get executable ( ) . explain global variable ( presenter ) ; get executable ( ) . get rule manager ( ) . explain template rule ( presenter ) ; get executable ( ) . explain name template ( presenter ) ; function library list lib list = ( function library list ) get executable ( ) . get function library ( ) ; list library list = lib list . get library list ( ) ; presenter . start element ( `` function `` ) ; for ( int i=0 ; i < library list . size ( ) ; i++ ) { function library lib = ( function library ) library list . get ( i ) ; if ( lib instanceof executable function library ) { for ( iterator f = ( ( executable function library ) lib ) . iterate function ( ) ; f . have next ( ) ; ) { user function func = ( user function ) f . next ( ) ; presenter . start element ( `` function `` ) ; presenter . emit attribute ( `` name `` , func . get function name ( ) . get display name ( ) ) ; presenter . emit attribute ( `` line `` , func . get line number ( ) + `` `` ) ; presenter . emit attribute ( `` module `` , func . get system id ( ) ) ; func . get body ( ) . explain ( presenter ) ; presenter . end element ( ) ; } } } presenter . end element ( ) ; presenter . end element ( ) ; }
public string get prefix ( string uri ) { iterator prefix = iterate prefix ( ) ; while ( prefix . have next ( ) ) { string p = ( string ) prefix . next ( ) ; string u = resolver . get u r i for prefix ( p , true ) ; if ( u . equal ( uri ) ) { return p ; } } return null ; }
public final name pool get name pool ( ) { return get pipeline configuration ( ) . get configuration ( ) . get name pool ( ) ; }
public void set error listener ( error listener listener ) { error listener = listener ; }
public void set line number ( int line number ) { this . line number = line number ; }
public global variable get compile variable ( ) { return compile var ; }
public void set preserve namespaces ( boolean inherit ) { preserve namespaces = inherit ; }
public void set construction mode ( int mode ) { construction mode = mode ; }
public x query function library get global function library ( ) { return global function library ; }
public void undeclare namespace ( ) { active namespaces . pop ( ) ; }
public boolean be update ( ) { return be update ; }
public void set generate java code ( boolean generate code ) { this . generate code = generate code ; }
public item type get require context item type ( ) { return require context item type ; }
public slot manager get stack frame map ( ) { return stack frame map ; }
public x query function get declaration by key ( string function key ) { return ( x query function ) function . get ( function key ) ; }
public boolean start with ( string s1 , string s2 ) { return s1 . start with ( s2 ) ; }
public document sorter get document sorter ( ) { return document sorter ; }
protect int compute cardinality ( ) { return static property . allows_zero_or_more ; }
public atomic value get current grouping key ( ) { return ( atomic value ) group key . get ( position-1 ) ; }
public boolean contain some ( int hash set other ) { int iterator it = other . iterator ( ) ; while ( it . have next ( ) ) { if ( contains ( it . next ( ) ) ) { return true ; } } return false ; }
public int [ ] get end point ( ) { return end point ; }
public expression get sort key ( ) { return sort key ; }
public string get base u r i ( ) { return base u r i ; }
public expression get base expression ( ) { return select ; }
public int get recovery policy ( ) { return recovery policy ; }
public object get property ( string name ) { if ( name . equal ( `` name `` ) ) { return get display name ( ) ; } return null ; }
protect boolean be explain ( ) { return explain ; }
protect boolean mark tail call ( ) { return false ; }
public int get precedence ( ) { return get contain stylesheet ( ) . get precedence ( ) ; }
public boolean forward compatible mode be enable ( ) { return get version ( ) . compare to ( big decimal . value of ( 2 ) ) > 0 ; }
public boolean be exclude namespace ( short uri code ) { if ( uri code == namespace constant . xslt_code || uri code == namespace constant . xml_code ) { return true ; } if ( be extension namespace ( uri code ) ) { return true ; } node info anc = this ; while ( anc instanceof style element ) { if ( ( ( style element ) anc ) . defines exclude namespace ( uri code ) ) { return true ; } anc = anc . get parent ( ) ; } return false ; }
public void set object name ( structure q name q name ) { object name = q name ; }
public namespace resolver get namespace resolver ( ) { return namespace context ; }
public slot manager get slot manager ( ) { return stack frame map ; }
public boolean be import ( ) { return true ; }
public slot manager get slot manager ( ) { return stack frame map ; }
public sequence type get require type ( ) { if ( require type ! =null ) { return require type ; } else { return sequence type . any_sequence ; } }
public prepare stylesheet get prepare stylesheet ( ) { if ( importer ! = null ) { return importer . get prepared stylesheet ( ) ; } return stylesheet ; }
public void set precedence ( int prec ) { precedence = prec ; }
public int get precedence ( ) { if ( be include ) return importer . get precedence ( ) ; return precedence ; }
public void validate ( ) throw x path exception { super . validate ( ) ; if ( global ) { if ( ! redundant ) { slot number = get principal stylesheet ( ) . allocate global slot ( get variable q name ( ) ) ; } } }
public executable get executable ( ) { return executable ; }
public x path variable declare variable ( q name value qname ) { return declare variable ( qname . get namespace u r i ( ) , qname . get local name ( ) ) ; }
public slot manager get stack frame map ( ) { slot manager map = get configuration ( ) . make slot manager ( ) ; x path variable [ ] va = new x path variable [ variable . size ( ) ] ; for ( iterator v = variable . value ( ) . iterator ( ) ; v . have next ( ) ; ) { x path variable var = ( x path variable ) v . next ( ) ; va [ var . get local slot number ( ) ] = var ; } for ( int i=0 ; i < va . length ; i++ ) { map . allocate slot number ( va [ i ] . get variable q name ( ) ) ; } return map ; }
public configuration get configuration ( ) { return static context . get configuration ( ) ; }
public x path dynamic context create dynamic context ( item context item ) { x path context major context = new x path context major ( context item , evaluator . get executable ( ) ) ; context . open stack frame ( stack frame map ) ; return new x path dynamic context ( context , stack frame map ) ; }
public boolean be global ( ) { return false ; }
public value representation evaluate variable ( x path context context ) { return context . evaluate local variable ( slot number ) ; }
public void set length ( int length ) { count = length ; }
public void write ( writer writer ) throw java . io . i o exception { final long val = value ; for ( int s=56 ; s > =0 ; s-=8 ) { final byte b = ( byte ) ( ( val > > > s ) & 0xff ) ; if ( b == 0 ) { break ; } final char c = white_chars [ b > > > 6 & 0x3 ] ; final int len = ( b & 0x3f ) ; for ( int j=0 ; j < len ; j++ ) { writer . write ( c ) ; } } }
public void write escape ( boolean [ ] special char , writer writer ) throw java . io . i o exception { final long val = value ; for ( int s=56 ; s > =0 ; s-=8 ) { final byte b = ( byte ) ( ( val > > > s ) & 0xff ) ; if ( b == 0 ) { break ; } final char c = white_chars [ b > > > 6 & 0x3 ] ; final int len = ( b & 0x3f ) ; if ( special char [ c ] ) { string e = `` `` ; if ( c=='\n ' ) { e = `` & # x a ; `` ; } else if ( c=='\r ' ) { e = `` & # x d ; `` ; } else if ( c=='\t ' ) { e = `` & # x9 ; `` ; } for ( int j=0 ; j < len ; j++ ) { writer . write ( e ) ; } } else { for ( int j=0 ; j < len ; j++ ) { writer . write ( c ) ; } } } }
public void append ( char sequence data ) { final int increment = data . length ( ) ; if ( increment == 0 ) { return ; } fast string buffer last = ( ( fast string buffer ) segment . get ( segment . size ( ) -1 ) ) ; if ( last . length ( ) + increment < = max allocation ) { last . append ( data ) ; } else { int [ ] s2 = new int [ start offset . length+1 ] ; system . arraycopy ( start offset , 0 , s2 , 0 , start offset . length ) ; s2 [ start offset . length ] = length ; start offset = s2 ; last = new fast string buffer ( math . max ( min allocation , increment ) ) ; segment . add ( last ) ; last . append ( data ) ; } length += increment ; }
public int get name code ( int index ) { return tree . att code [ first attribute + index ] ; }
public node info get parent ( ) { return tree . get node ( tree . att parent [ node nr ] ) ; }
public string get local part ( ) { return tree . get name pool ( ) . get local name ( tree . att code [ node nr ] ) ; }
public final int get node kind ( ) { return type . comment ; }
public final string get string value ( ) { return get string value ( tree , node nr ) . to string ( ) ; }
public string get system id ( ) { return module uri ; }
public void set line number ( int line number ) { this . line number = line number ; }
public void end subsidiary element ( ) { end element ( ) ; }
public void end current item ( item item ) { ( ( trace listener ) a ) . end current item ( item ) ; ( ( trace listener ) b ) . end current item ( item ) ; }
public static trace listener add ( trace listener a , trace listener b ) { return ( trace listener ) add internal ( a , b ) ; }
public object get instance ( string class name , boolean tracing , class loader class loader ) throw x path exception { class theclass = get class ( class name , trace , class loader ) ; try { return theclass . new instance ( ) ; } catch ( exception err ) { throw new x path exception ( `` fail to instantiate class `` + class name , err ) ; } }
public boolean be backwards compatible ( ) { return backwards compatible ; }
public boolean be convert untyped to other ( ) { return convert untyped to other ; }
public sequence iterable get use ( ) { return use ; }
public void reset handler ( ) { default mode = new mode ( mode . default_mode , mode . default_mode_name ) ; mode = new hash map ( 5 ) ; }
public void set x path context ( x path context context ) { this . context = context ; }
public final node info get next sibling ( ) { return null ; }
public void set location ( string uri , int line number ) { this . system id = uri ; this . line number = line number ; }
public void set node factory ( node factory factory ) { node factory = factory ; }
public final item current ( ) { return current ; }
public final int position ( ) { return position ; }
public boolean be build in type ( ) { return true ; }
public boolean be list type ( ) { return false ; }
public schema type get build in base type ( ) { return this ; }
public int get block ( ) { return 0 ; }
public boolean be emptiable ( ) { return true ; }
public schema type get build in base type ( ) { return this ; }
public boolean equal ( object obj ) { return obj instanceof external object type & & fingerprint == ( ( external object type ) obj ) . fingerprint ; }
public configuration get configuration ( ) { return config ; }
public void set constraint reference ( int schema part , string constraint name , string clause ) { this . schema part = schema part ; this . constraint name = constraint name ; this . constraint clause number = clause ; }
public string get constraint reference ( ) { return constraint name + ' . ' + constraint clause number ; }
public final sequence iterator get type value ( ) { return singleton iterator . make iterator ( this ) ; }
public ground value subsequence ( int start , int length ) { if ( start < = 0 & & start + length > 0 ) { return this ; } else { return empty sequence . get instance ( ) ; } }
public final string get string value ( ) { return get string value c s ( ) . to string ( ) ; }
public object get x path comparable ( boolean order , string collator collator , x path context context ) throw no dynamic context exception { if ( order & & ! ( this instanceof comparable ) ) { return null ; } return ( have timezone ( ) ? this : adjust timezone ( context . get implicit timezone ( ) ) ) ; }
public int get cardinality ( ) { if ( expression == null ) { return static property . allows_zero_or_more ; } else { return expression . get cardinality ( ) ; } }
public static string get schema aware product version ( ) { return `` sa `` + get product version ( ) ; }
public browser configuration option set timeout in second ( int timeout ) { put ( timeout_in_seconds , string . value of ( timeout ) ) ; return this ; }
public static app cache status get enum ( int value ) { for ( app cache status status : app cache status . value ( ) ) { if ( value == status . value ( ) ) { return status ; } } return null ; }
public action click ( ) { return this . click ( null ) ; }
public static local log get combine log holder ( local log predefined type logger , local log all type logger ) { return new composite local log ( predefined type logger , all type logger ) ; }
public boolean be ( platform compare with ) { return this == compare with || this . family ( ) . be ( compare with ) ; }
public int get minor version ( ) { return minor version ; }
public string get sock proxy ( ) { return sock proxy ; }
public static command < stream handle > take response body a stream ( request id request id ) { object . require non null ( request id , `` request id be require `` ) ; return new command < > ( `` fetch . take response body a stream `` , immutable map . of ( `` request id `` , request id . to string ( ) ) , map ( `` stream `` , stream handle . class ) ) ; }
public integer get line number ( ) { return line number ; }
public resource priority get initial priority ( ) { return initial priority ; }
public boolean get be link preload ( ) { return be link preload ; }
public double get worker start ( ) { return worker start ; }
public string get url ( ) { return url ; }
public integer get status ( ) { return status ; }
public boolean get from service worker ( ) { return from service worker ; }
public string get protocol ( ) { return protocol ; }
public double get valid from ( ) { return valid from ; }
public certificate transparency compliance get certificate transparency compliance ( ) { return certificate transparency compliance ; }
public sign exchange error field get error field ( ) { return error field ; }
public static command < void > disable ( ) { return new command < > ( domain_name + `` . disable `` , immutable map . of ( ) ) ; }
public static command < list < string > > get certificate ( string origin ) { object . require non null ( origin , `` origin must be set . `` ) ; return new command < > ( domain_name + `` . get certificate `` , immutable map . of ( `` origin `` , origin ) , map ( `` table name `` , new type token < list < string > > ( ) { } . get type ( ) ) ) ; }
public static command < string > get request post data ( request id request id ) { object . require non null ( request id , `` request id must be set . `` ) ; return new command < > ( domain_name + `` . get request post data `` , immutable map . of ( `` request id `` , request id . to string ( ) ) , map ( `` post data `` , string . class ) ) ; }
public static command < void > set request interception ( list < request pattern > pattern ) { object . require non null ( pattern , `` pattern must be set . `` ) ; return new command < > ( domain_name + `` . set request interception `` , immutable map . of ( `` pattern `` , pattern ) ) ; }
public static event < request id > request serve from cache ( ) { return new event < > ( domain_name + `` . request serve from cache `` , map ( `` request id `` , request id . class ) ) ; }
public static event < web socket create > web socket create ( ) { return new event < > ( domain_name + `` . web socket create `` , map ( `` request id `` , web socket create . class ) ) ; }
public static command < list < browser context i d > > get browser context ( ) { return new command < > ( `` target . get browser context `` , immutable map . of ( ) , converter function . map ( `` browser context id `` , new type token < list < browser context i d > > ( ) { } . get type ( ) ) ) ; }
public static command < void > dispose browser context ( browser context i d browser context i d ) { object . require non null ( browser context i d , `` browser context id be require `` ) ; return new command < > ( `` target . dispose browser context `` , immutable map . of ( `` browser context id `` , browser context i d ) ) ; }
public static event < target info > target create ( ) { return new event < > ( `` target . target destroyed `` , map ( `` target info `` , target info . class ) ) ; }
public object get attribute ( string key ) { return attribute . get ( key ) ; }
public string get query parameter ( string name ) { iterable < string > all params = get query parameter ( name ) ; if ( all params == null ) { return null ; } iterator < string > iterator = all params . iterator ( ) ; return iterator . have next ( ) ? iterator . next ( ) : null ; }
protect string [ ] usual windows launcher location ( ) { return new string [ ] { window utils . get local app data path ( ) + `` \\ google\\ chrome\\ application `` , windows utils . get program files86 path ( ) + `` \\ google\\ chrome\\ application `` , windows utils . get program file path ( ) + `` \\ google\\ chrome\\ application `` } ; }
public file get local file ( char sequence . . . key ) { return null ; }
public list < string > get servlets ( ) { return servlets ; }
public string get proxy ( ) { return proxy ; }
protected boolean should cache ( ) { return should cache ; }
public static < t > t init element ( web driver driver , class < t > page class to proxy ) { t page = instantiate page ( driver , page class to proxy ) ; init element ( driver , page ) ; return page ; }
public static expect condition < boolean > url to be ( final string url ) { return new expect condition < boolean > ( ) { private string current url = `` `` ; @ override public boolean apply ( web driver driver ) { current url = driver . get current url ( ) ; return current url ! = null & & current url . equal ( url ) ; } @ override public string to string ( ) { return string . format ( `` url to be \ `` % s\ `` . current url : \ `` % s\ `` `` , url , current url ) ; } } ; }
public static expect condition < web element > presence of element locate ( final by locator ) { return new expect condition < web element > ( ) { @ override public web element apply ( web driver driver ) { return driver . find element ( locator ) ; } @ override public string to string ( ) { return `` presence of element locate by : `` + locator ; } } ; }
public static expect condition < web element > visibility of ( final web element element ) { return new expect condition < web element > ( ) { @ override public web element apply ( web driver driver ) { return element if visible ( element ) ; } @ override public string to string ( ) { return `` visibility of `` + element ; } } ; }
public static expect condition < web element > element to be clickable ( final by locator ) { return new expect condition < web element > ( ) { @ override public web element apply ( web driver driver ) { web element element = visibility of element locate ( locator ) . apply ( driver ) ; try { if ( element ! = null & & element . be enable ( ) ) { return element ; } return null ; } catch ( stale element reference exception e ) { return null ; } } @ override public string to string ( ) { return `` element to be clickable : `` + locator ; } } ; }
public static < t > expect condition < t > refresh ( final expect condition < t > condition ) { return new expect condition < t > ( ) { @ override public t apply ( web driver driver ) { try { return condition . apply ( driver ) ; } catch ( stale element reference exception e ) { return null ; } } @ override public string to string ( ) { return string . format ( `` condition ( % s ) to be refresh `` , condition ) ; } } ; }
public fluent wait < t > with timeout ( long duration , time unit unit ) { return with timeout ( duration . of ( duration , to chrono unit ( unit ) ) ) ; }
public static boolean be numeric datatype ( uri datatype ) { return be decimal datatype ( datatype ) || be float point datatype ( datatype ) ; }
public static boolean be integer datatype ( uri datatype ) { return datatype . equal ( x m l schema . integer ) || datatype . equal ( x m l schema . long ) || datatype . equal ( x m l schema . int ) || datatype . equal ( x m l schema . short ) || datatype . equal ( x m l schema . byte ) || datatype . equal ( x m l schema . non_positive_integer ) || datatype . equal ( x m l schema . negative_integer ) || datatype . equal ( x m l schema . non_negative_integer ) || datatype . equal ( x m l schema . positive_integer ) || datatype . equal ( x m l schema . unsigned_long ) || datatype . equal ( x m l schema . unsigned_int ) || datatype . equal ( x m l schema . unsigned_short ) || datatype . equal ( x m l schema . unsigned_byte ) ; }
public static boolean be calendar datatype ( uri datatype ) { return datatype . equal ( x m l schema . datetime ) || datatype . equal ( x m l schema . date ) || datatype . equal ( x m l schema . time ) || datatype . equal ( x m l schema . gyearmonth ) || datatype . equal ( x m l schema . gmonthday ) || datatype . equal ( x m l schema . gyear ) || datatype . equal ( x m l schema . gmonth ) || datatype . equal ( x m l schema . gday ) ; }
public static boolean be valid value ( string value , uri datatype ) { boolean result = true ; if ( datatype . equal ( x m l schema . decimal ) ) { result = be valid decimal ( value ) ; } else if ( datatype . equal ( x m l schema . integer ) ) { result = be valid integer ( value ) ; } else if ( datatype . equal ( x m l schema . negative_integer ) ) { result = be valid negative integer ( value ) ; } else if ( datatype . equal ( x m l schema . non_positive_integer ) ) { result = be valid non positive integer ( value ) ; } else if ( datatype . equal ( x m l schema . non_negative_integer ) ) { result = be valid non negative integer ( value ) ; } else if ( datatype . equal ( x m l schema . positive_integer ) ) { result = be valid positive integer ( value ) ; } else if ( datatype . equal ( x m l schema . long ) ) { result = be valid long ( value ) ; } else if ( datatype . equal ( x m l schema . int ) ) { result = be valid int ( value ) ; } else if ( datatype . equal ( x m l schema . short ) ) { result = be valid short ( value ) ; } else if ( datatype . equal ( x m l schema . byte ) ) { result = be valid byte ( value ) ; } else if ( datatype . equal ( x m l schema . unsigned_long ) ) { result = be valid unsigned long ( value ) ; } else if ( datatype . equal ( x m l schema . unsigned_int ) ) { result = be valid unsigned int ( value ) ; } else if ( datatype . equal ( x m l schema . unsigned_short ) ) { result = be valid unsigned short ( value ) ; } else if ( datatype . equal ( x m l schema . unsigned_byte ) ) { result = be valid unsigned byte ( value ) ; } else if ( datatype . equal ( x m l schema . float ) ) { result = be valid float ( value ) ; } else if ( datatype . equal ( x m l schema . double ) ) { result = be valid double ( value ) ; } else if ( datatype . equal ( x m l schema . boolean ) ) { result = be valid boolean ( value ) ; } else if ( datatype . equal ( x m l schema . datetime ) ) { result = be valid date time ( value ) ; } else if ( datatype . equal ( x m l schema . date ) ) { result = be valid date ( value ) ; } else if ( datatype . equal ( x m l schema . time ) ) { result = be valid time ( value ) ; } else if ( datatype . equal ( x m l schema . gday ) ) { result = be valid g day ( value ) ; } else if ( datatype . equal ( x m l schema . gmonth ) ) { result = be valid g month ( value ) ; } else if ( datatype . equal ( x m l schema . gmonthday ) ) { result = be valid g month day ( value ) ; } else if ( datatype . equal ( x m l schema . gyear ) ) { result = be valid g year ( value ) ; } else if ( datatype . equal ( x m l schema . gyearmonth ) ) { result = be valid g year month ( value ) ; } else if ( datatype . equal ( x m l schema . duration ) ) { result = be valid duration ( value ) ; } else if ( datatype . equal ( x m l schema . daytimeduration ) ) { result = be valid day time duration ( value ) ; } else if ( datatype . equal ( x m l schema . qname ) ) { result = be valid q name ( value ) ; } return result ; }
public static string normalize ( string value , uri datatype ) { string result = value ; if ( datatype . equal ( x m l schema . decimal ) ) { result = normalize decimal ( value ) ; } else if ( datatype . equal ( x m l schema . integer ) ) { result = normalize integer ( value ) ; } else if ( datatype . equal ( x m l schema . negative_integer ) ) { result = normalize negative integer ( value ) ; } else if ( datatype . equal ( x m l schema . non_positive_integer ) ) { result = normalize non positive integer ( value ) ; } else if ( datatype . equal ( x m l schema . non_negative_integer ) ) { result = normalize non negative integer ( value ) ; } else if ( datatype . equal ( x m l schema . positive_integer ) ) { result = normalize positive integer ( value ) ; } else if ( datatype . equal ( x m l schema . long ) ) { result = normalize long ( value ) ; } else if ( datatype . equal ( x m l schema . int ) ) { result = normalize int ( value ) ; } else if ( datatype . equal ( x m l schema . short ) ) { result = normalize short ( value ) ; } else if ( datatype . equal ( x m l schema . byte ) ) { result = normalize byte ( value ) ; } else if ( datatype . equal ( x m l schema . unsigned_long ) ) { result = normalize unsigned long ( value ) ; } else if ( datatype . equal ( x m l schema . unsigned_int ) ) { result = normalize unsigned int ( value ) ; } else if ( datatype . equal ( x m l schema . unsigned_short ) ) { result = normalize unsigned short ( value ) ; } else if ( datatype . equal ( x m l schema . unsigned_byte ) ) { result = normalize unsigned byte ( value ) ; } else if ( datatype . equal ( x m l schema . float ) ) { result = normalize float ( value ) ; } else if ( datatype . equal ( x m l schema . double ) ) { result = normalize double ( value ) ; } else if ( datatype . equal ( x m l schema . boolean ) ) { result = normalize boolean ( value ) ; } else if ( datatype . equal ( x m l schema . datetime ) ) { result = normalize date time ( value ) ; } return result ; }
public static string normalize float ( string value ) { return normalize f p number ( value , `` -16777215 . 0 `` , `` 16777215 . 0 `` , `` -149 `` , `` 104 `` ) ; }
public static int compare float ( string float1 , string float2 ) { float1 = normalize float ( float1 ) ; float2 = normalize float ( float2 ) ; return compare canonical float ( float1 , float2 ) ; }
public static int compare canonical double ( string double1 , string double2 ) { return compare canonical f p number ( double1 , double2 ) ; }
public static int compare f p number ( string fp1 , string fp2 ) { fp1 = normalize f p number ( fp1 ) ; fp2 = normalize f p number ( fp2 ) ; return compare canonical f p number ( fp1 , fp2 ) ; }
public static byte parse byte ( string s ) { s = trim plus sign ( s ) ; return byte . parse byte ( s ) ; }
public static int parse int ( string s ) { s = trim plus sign ( s ) ; return integer . parse int ( s ) ; }
public static long parse long ( string s ) { s = trim plus sign ( s ) ; return long . parse long ( s ) ; }
public static iterator < value > get object iterator ( graph graph , resource subj , uri pred , resource . . . context ) { iterator < statement > iter = graph . match ( subj , pred , null , context ) ; return new convert iterator < statement , value > ( iter ) { @ override protect value convert ( statement st ) throw runtime exception { return st . get object ( ) ; } } ; }
public static string get label ( literal l , string fallback ) { return l ! = null ? l . get label ( ) : fallback ; }
public static int get int value ( literal l , int fallback ) { try { return l . int value ( ) ; } catch ( number format exception e ) { return fallback ; } }
public set < rio set < ? > > get non fatal error ( ) { return collection . unmodifiable set ( non fatal error ) ; }
public static string get location string ( int line no , int column no ) { if ( line no < 0 ) { return `` `` ; } string builder sb = new string builder ( 16 ) ; sb . append ( `` [ line `` ) ; sb . append ( line no ) ; if ( column no > = 0 ) { sb . append ( `` , column `` ) ; sb . append ( column no ) ; } sb . append ( `` ] `` ) ; return sb . to string ( ) ; }
public static synchronize r d f parser registry get instance ( ) { if ( default registry == null ) { default registry = new r d f parser registry ( ) ; } return default registry ; }
public void use default ( ) { setting . clear ( ) ; }
public static string to n triple string ( literal lit ) { try { string builder sb = new string builder ( ) ; append ( lit , sb ) ; return sb . to string ( ) ; } catch ( i o exception e ) { throw new assertion error ( ) ; } }
public string to string ( ) { string builder sb = new string builder ( ) ; sb . append ( `` atts [ `` ) ; for ( int i = 0 ; i < attribute . size ( ) ; i++ ) { att att = attribute . get ( i ) ; sb . append ( att . get q name ( ) ) ; sb . append ( `` = `` ) ; sb . append ( att . get value ( ) ) ; sb . append ( `` ; `` ) ; } sb . append ( `` ] `` ) ; return sb . to string ( ) ; }
public void set document locator ( locator loc ) { locator = loc ; parse location listener pll = rdf parser . get parse location listener ( ) ; if ( pll ! = null & & loc ! = null ) { pll . parse location update ( loc . get line number ( ) , loc . get column number ( ) ) ; } }
public static int find ( byte [ ] a , int from index , int to index , byte [ ] key ) { int result = -1 ; int sublen = key . length ; int maxpos , first , sp = 0 ; maxpos = math . min ( to index , a . length ) - sublen ; for ( first = from index ; sp ! = sublen & & first < = maxpos ; first++ ) { first = find ( a , first , maxpos , key [ 0 ] ) ; if ( ( first < 0 ) || ( first > maxpos ) ) { break ; } for ( sp = 1 ; sp < sublen ; sp++ ) { if ( a [ first + sp ] ! = key [ sp ] ) { sp = sublen ; } } } if ( sublen == 0 ) { result = 0 ; } else if ( sp == sublen ) { result = ( first - 1 ) ; } return result ; }
public static boolean delete file ( file directory ) { boolean result = true ; if ( directory . be directory ( ) ) { file [ ] list = directory . list file ( ) ; for ( int i = list . length ; i -- > 0 ; ) { file file = list [ i ] ; if ( file . be file ( ) ) { result = result & & file . delete ( ) ; } } } return result ; }
public boolean have m i m e type ( string mime type ) { if ( mime type == null ) return false ; string type = mime type ; if ( mime type . index of ( ' ; ' ) > 0 ) { type = mime type . substring ( 0 , mime type . index of ( ' ; ' ) ) ; } for ( string mt : this . mime type ) { if ( mt . equal ignore case ( mime type ) ) { return true ; } if ( mime type ! = type & & mt . equal ignore case ( type ) ) { return true ; } } return false ; }
public boolean have charset ( ) { return charset ! = null ; }
public static int null hash code ( object o ) { return o == null ? 0 : o . hash code ( ) ; }
public static boolean be garbage text ( string text ) { boolean result = false ; if ( text . trim ( ) . length ( ) < min_initial_text_length ) { result = true ; } else if ( text . length ( ) > 30 ) { result = true ; for ( int i = 0 ; i < text . length ( ) ; i++ ) { if ( character . get type ( text . char at ( i ) ) == character . space_separator ) { result = false ; break ; } } } return result ; }
public static string escape character data ( string text ) { text = string util . gsub ( `` & `` , `` & amp ; `` , text ) ; text = string util . gsub ( `` < `` , `` & lt ; `` , text ) ; text = string util . gsub ( `` > `` , `` & gt ; `` , text ) ; text = string util . gsub ( `` \r `` , `` & # x d ; `` , text ) ; return text ; }
public byte [ ] get source ( ) { return content ; }
public node text ( object text ) { return text ( string . value of ( text ) ) ; }
public string get text ( ) { return text ; }
public list < string > get text value for pattern name ( final string name ) { list < string > result = new array list < string > ( ) ; list < node > jar = this . get ( name ) ; for ( node node : jar ) { string text = node . get text ( ) ; if ( text ! = null ) { result . add ( text ) ; } } return collection . unmodifiable list ( result ) ; }
public void set debug ( boolean debug f ) { this . debug = debug f ; if ( this . tar in ! = null ) { this . tar in . set debug ( debug f ) ; } else if ( this . tar out ! = null ) { this . tar out . set debug ( debug f ) ; } }
public int get user id ( ) { return this . user id ; }
public boolean equal ( tar entry it ) { return this . header . name . to string ( ) . equal ( it . header . name . to string ( ) ) ; }
public void close ( ) throw i o exception { this . finish ( ) ; this . buffer . close ( ) ; }
protect archive path get class path ( ) { throw new unsupported operation exception ( `` enterprise archive do not support class `` ) ; }
public void register ( collector m ) { list < string > name = collector name ( m ) ; synchronize ( collector to name ) { for ( string name : name ) { if ( name to collector . contains key ( name ) ) { throw new illegal argument exception ( `` collector already register that provide name : `` + name ) ; } } for ( string name : name ) { name to collector . put ( name , m ) ; } collector to name . put ( m , names ) ; } }
public void inc ( ) { inc ( 1 ) ; }
public void dec ( double amt ) { no label child . dec ( amt ) ; }
public static builder build ( ) { return new builder ( ) ; }
public void observe ( double amt ) { no label child . observe ( amt ) ; }
public boolean be root ( ) { return root ; }
public static void array copy ( object src , int offset , int byte length , object dest , int dest_offset ) throw i o exception { impl . array copy ( src , offset , byte length , d , dest_offset ) ; }
public void write ( float [ ] f , int off , int len ) throw i o exception { raw write ( f , off * 4 , len * 4 ) ; }
public void write ( short [ ] f , int off , int len ) throw i o exception { raw write ( f , off * 2 , len * 2 ) ; }
public static void run from servlet ( ) { be run from servlet . set ( true ) ; }
public void get ( string from path , string to path ) { get ( from path , to path , null ) ; }
public void delete ( string from path , string to path ) { delete ( from path , to path , null ) ; }
public int status ( ) { return response . get status ( ) ; }
public void connect ( string path , route route ) { add route ( http method . connect . name ( ) , route impl . create ( path , route ) ) ; }
public static http method get ( string method str ) { http method method = method . get ( method str ) ; return method ! = null ? method : unsupported ; }
public synchronize int port ( ) { if ( initialize ) { return port ; } else { throw new illegal state exception ( `` this must be do after route mapping have begin `` ) ; } }
public synchronize service thread pool ( int max thread ) { return thread pool ( max thread , -1 , -1 ) ; }
public void web socket ( string path , object handler ) { add web socket handler ( path , new web socket handler instance wrapper ( handler ) ) ; }
public void attribute ( string name , object value ) { session . set attribute ( name , value ) ; }
public static boolean be jar u r l ( url url ) { string up = url . get protocol ( ) ; return ( url_protocol_jar . equal ( up ) || url_protocol_zip . equal ( up ) || url_protocol_wsjar . equal ( up ) ) ; }
public long array allocate array ( long size ) { long require = size * 8l ; memory block page = task memory manager . allocate page ( require , this ) ; if ( page == null || page . size ( ) < require ) { long get = 0 ; if ( page ! = null ) { get = page . size ( ) ; task memory manager . free page ( page , this ) ; } task memory manager . show memory usage ( ) ; throw new out of memory error ( `` unable to acquire `` + required + `` byte of memory , get `` + get ) ; } use += require ; return new long array ( page ) ; }
public void free array ( long array array ) { free page ( array . memory block ( ) ) ; }
public void cleanup resource ( ) { free memory ( ) ; if ( in mem sorter ! = null ) { in mem sorter . free ( ) ; in mem sorter = null ; } for ( spill info spill : spill ) { if ( spill . file . exists ( ) & & ! spill . file . delete ( ) ) { logger . error ( `` unable to delete spill file { } `` , spill . file . get path ( ) ) ; } } }
public void reset ( ) { num key = 0 ; num value = 0 ; free array ( long array ) ; while ( data page . size ( ) > 0 ) { memory block data page = data page . remove last ( ) ; free page ( data page ) ; } allocate ( initial capacity ) ; can grow array = true ; current page = null ; page cursor = 0 ; }
public spark launcher set spark home ( string spark home ) { check not null ( spark home , `` spark home `` ) ; builder . child env . put ( env_spark_home , spark home ) ; return this ; }
public string get client id ( ) { return client id ; }
public byte [ ] get output iv ( ) { return out iv ; }
public void add to channel ( channel ch ) throw i o exception { ch . pipeline ( ) . add first ( encryption_handler_name , new encryption handler ( this ) ) . add first ( decryption_handler_name , new decryption handler ( this ) ) ; }
public static char [ ] encode password ( string password ) { precondition . check not null ( password , `` password can not be null if sasl be enable `` ) ; return get base64 encode string ( password ) . to char array ( ) ; }
public void channel active ( transport client client ) { }
public int write ( byte buffer src ) { int to transfer = math . min ( src . remain ( ) , data . length - offset ) ; src . get ( data , offset , to transfer ) ; offset += to transfer ; return to transfer ; }
public static long byte string a byte ( string str ) { return byte string a ( str , byte unit . byte ) ; }
public int connection timeout m ( ) { long default network timeout s = java utils . time string a sec ( conf . get ( `` spark . network . timeout `` , `` 120 `` ) ) ; long default timeout m = java utils . time string a sec ( conf . get ( spark_network_io_connectiontimeout_key , default network timeout s + `` s `` ) ) * 1000 ; return ( int ) default timeout m ; }
public manage buffer get block data ( string app id , string exec id , string block id ) { string [ ] block id part = block id . split ( `` _ `` ) ; if ( block id part . length < 4 ) { throw new illegal argument exception ( `` unexpected block id format : `` + block id ) ; } else if ( ! block id part [ 0 ] . equal ( `` shuffle `` ) ) { throw new illegal argument exception ( `` expect shuffle block id , get : `` + block id ) ; } int shuffle id = integer . parse int ( block id part [ 1 ] ) ; int map id = integer . parse int ( block id part [ 2 ] ) ; int reduce id = integer . parse int ( block id part [ 3 ] ) ; executor shuffle info executor = executor . get ( new app exec id ( app id , exec id ) ) ; if ( executor == null ) { throw new runtime exception ( string . format ( `` executor be not register ( app id= % s , exec id= % s ) `` , app id , exec id ) ) ; } return get sort base shuffle block data ( executor , shuffle id , map id , reduce id ) ; }
public void start ( ) { fetch all outstanding ( ) ; }
public static memory block from long array ( final long [ ] array ) { return new memory block ( array , platform . long_array_offset , array . length * 8l ) ; }
public boolean contains ( final u t f8 string substring ) { if ( substring . num bytes == 0 ) { return true ; } byte first = substring . get byte ( 0 ) ; for ( int i = 0 ; i < = num bytes - substring . num byte ; i++ ) { if ( get byte ( i ) == first & & match at ( substring , i ) ) { return true ; } } return false ; }
public < t > t gauge ( string name , t obj , value function f ) { return gauge ( impl . create id ( name ) , obj , f ) ; }
public void set updatable result ( boolean updatable result ) { this . updatable result = updatable result ; }
public callable statement creator new callable statement creator ( parameter mapper in param mapper ) { return new callable statement creator impl ( in param mapper ) ; }
public int get query timeout ( ) { return this . query timeout ; }
public boolean be skip result process ( ) { return this . skip result processing ; }
public void set return value require ( boolean return value require ) { this . return value require = return value require ; }
public void initialize meta data ( data source data source ) { this . meta data provider = call meta data provider factory . create meta data provider ( data source , this ) ; }
public int get sql type ( ) { return this . sql type ; }
protect void set support schemas in procedure call ( boolean support schema in procedure call ) { this . support schema in procedure call = support schema in procedure call ; }
public boolean be supports schema in procedure call ( ) { return this . support schema in procedure call ; }
public void set table name ( @ nullable string table name ) { this . table name = table name ; }
public string get table name ( ) { return this . table name ; }
public void set override include synonyms default ( boolean override ) { this . override include synonyms default = override ; }
public int get sql type ( ) { return this . sql type ; }
public int get sql type ( string param name ) { assert . not null ( param name , `` parameter name must not be null `` ) ; return this . sql type . get or default ( param name , type_unknown ) ; }
public jdbc operation get jdbc operation ( ) { return this . classic jdbc template ; }
public final string get sql ( ) { return this . sql ; }
public boolean be function ( ) { return this . call meta data context . be function ( ) ; }
public boolean be return value require ( ) { return this . call meta data context . be return value require ( ) ; }
public void add declare parameter ( sql parameter parameter ) { assert . not null ( parameter , `` the supplied parameter must not be null `` ) ; if ( ! string utils . have text ( parameter . get name ( ) ) ) { throw new invalid data access api usage exception ( `` you must specify a parameter name when declare parameter for \ `` `` + get procedure name ( ) + `` \ `` `` ) ; } this . declared parameter . add ( parameter ) ; if ( logger . be debug enable ( ) ) { logger . debug ( `` add declared parameter for [ `` + get procedure name ( ) + `` ] : `` + parameter . get name ( ) ) ; } }
protect void check compile ( ) { if ( ! be compile ( ) ) { logger . debug ( `` jdbc call call not compile before execution - invoking compile `` ) ; compile ( ) ; } }
public final jdbc template get jdbc template ( ) { return this . jdbc template ; }
public void set password ( @ nullable string password ) { this . password = password ; }
protect void set transaction active ( boolean transaction active ) { this . transaction active = transaction active ; }
public savepoint create savepoint ( ) throw s q l exception { this . savepoint counter++ ; return get connection ( ) . set savepoint ( savepoint_name_prefix + this . savepoint counter ) ; }
public data source get data source ( ) { return this . data source ; }
public static connection get connection ( data source data source ) throw can not get jdbc connection exception { try { return do get connection ( data source ) ; } catch ( s q l exception ex ) { throw new can not get jdbc connection exception ( `` fail to obtain jdbc connection `` , ex ) ; } catch ( illegal state exception ex ) { throw new can not get jdbc connection exception ( `` fail to obtain jdbc connection : `` + ex . get message ( ) ) ; } }
public embed database build ( ) { return this . database factory . get database ( ) ; }
public integer get previous isolation level ( ) { return this . previous isolation level ; }
public boolean be read only ( ) { return this . read only ; }
public void set default transaction isolation name ( string constant name ) { set default transaction isolation ( constant . a number ( constant name ) . int value ( ) ) ; }
public void set lenient fallback ( boolean lenient fallback ) { this . lenient fallback = lenient fallback ; }
public data source get resolve default data source ( ) { return this . resolve default data source ; }
public void set driver class ( class < ? extend driver > driver class ) { this . driver = bean utils . instantiate class ( driver class ) ; }
protect boolean be suppress close ( ) { return this . suppress close ; }
public connection get connection ( string username , string password ) throw s q l exception { if ( object utils . null safe equal ( username , get username ( ) ) & & object utils . null safe equal ( password , get password ( ) ) ) { return get connection ( ) ; } else { throw new s q l exception ( `` single connection data source do not support custom username and password `` ) ; } }
public int [ ] get row affect ( ) { int [ ] result = new int [ this . row affect . size ( ) ] ; for ( int i = 0 ; i < this . row affect . size ( ) ; i++ ) { result [ i ] = this . row affect . get ( i ) ; } return result ; }
public void set parameter ( sql parameter . . . parameter ) { if ( be compile ( ) ) { throw new invalid data access api usage exception ( `` can not add parameter once the query be compile `` ) ; } for ( int i = 0 ; i < parameter . length ; i++ ) { if ( parameter [ i ] ! = null ) { this . declared parameter . add ( parameter [ i ] ) ; } else { throw new invalid data access api usage exception ( `` can not add parameter at index `` + i + `` from `` + array . a list ( parameter ) + `` since it be 'null ' `` ) ; } } }
public boolean be function ( ) { return this . function ; }
public list < t > execute ( string p1 ) throw data access exception { return execute ( p1 , null ) ; }
public t find object ( object . . . params ) throw data access exception { return find object ( params , null ) ; }
public int update ( string p ) throw data access exception { return update ( new object [ ] { p } ) ; }
public void declare parameter ( sql parameter param ) throw invalid data access api usage exception { if ( param . get name ( ) == null ) { throw new invalid data access api usage exception ( `` parameter to stored procedure must have name as well a type `` ) ; } super . declare parameter ( param ) ; }
public void set delete specific value ( boolean delete specific value ) { this . delete specific value = delete specific value ; }
public static boolean support batch update ( connection con ) { try { database meta data dbmd = con . get meta data ( ) ; if ( dbmd ! = null ) { if ( dbmd . support batch update ( ) ) { logger . debug ( `` jdbc driver support batch update `` ) ; return true ; } else { logger . debug ( `` jdbc driver do not support batch update `` ) ; } } } catch ( s q l exception ex ) { logger . debug ( `` jdbc driver 'supports batch update ' method throw exception `` , ex ) ; } return false ; }
protect void init dao ( ) throw exception { }
public static < t > t unique result ( @ nullable collection < t > result ) throw incorrect result size data access exception { if ( collection utils . be empty ( result ) ) { return null ; } if ( ! collection utils . have unique object ( result ) ) { throw new incorrect result size data access exception ( 1 , result . size ( ) ) ; } return result . iterator ( ) . next ( ) ; }
public void set always translate ( boolean always translate ) { this . always translate = always translate ; }
public void set connection spec for current thread ( connection spec spec ) { this . thread bound spec . set ( spec ) ; }
protect connection get close suppress connection proxy ( connection target ) { return ( connection ) proxy . new proxy instance ( connection . class . get class loader ( ) , new class < ? > [ ] { connection . class } , new close suppress invocation handler ( target ) ) ; }
public final connection factory get connection factory ( ) { return ( this . cci template ! = null ? this . cci template . get connection factory ( ) : null ) ; }
public void stop ( ) { logger . debug ( `` stop spring context resource adapter `` ) ; if ( this . application context ! = null ) { this . application context . close ( ) ; } }
public message endpoint factory get message endpoint factory ( ) { return this . message endpoint factory ; }
public final runnable get delegate ( ) { return this . delegate ; }
public void set property ( property transaction attribute ) { transaction attribute editor tae = new transaction attribute editor ( ) ; enumeration < ? > prop name = transaction attribute . property name ( ) ; while ( prop name . have more element ( ) ) { string method name = ( string ) prop name . next element ( ) ; string value = transaction attribute . get property ( method name ) ; tae . set a text ( value ) ; transaction attribute attr = ( transaction attribute ) tae . get value ( ) ; add transactional method ( method name , attr ) ; } }
public void set transaction manager ( @ nullable transaction manager transaction manager ) { this . transaction manager = transaction manager ; }
public void set transaction manager name ( string transaction manager name ) { this . transaction manager name = transaction manager name ; }
public void flush ( ) { transaction synchronization utils . trigger flush ( ) ; }
public void set actual transaction active ( boolean active ) { this . transaction context . set actual transaction active ( active ) ; }
public final void rollback ( transaction status status ) throw transaction exception { if ( status . be complete ( ) ) { throw new illegal transaction state exception ( `` transaction be already complete - do not call commit or rollback more than once per transaction `` ) ; } default transaction status def status = ( default transaction status ) status ; process rollback ( def status , false ) ; }
protect object do suspend ( object transaction ) throw transaction exception { throw new transaction suspension not support exception ( `` transaction manager [ `` + get class ( ) . get name ( ) + `` ] do not support transaction suspension `` ) ; }
protect void do cleanup after completion ( object transaction ) { }
public final void set isolation level ( int isolation level ) { if ( ! constant . get value ( prefix_isolation ) . contains ( isolation level ) ) { throw new illegal argument exception ( `` only value of isolation constant allow `` ) ; } this . isolation level = isolation level ; }
public boolean be global rollback only ( ) { return ( ( this . transaction instanceof smart transaction object ) & & ( ( smart transaction object ) this . transaction ) . be rollback only ( ) ) ; }
public boolean be rollback only ( ) { return this . rollback only ; }
public boolean have timeout ( ) { return ( this . deadline ! = null ) ; }
public void reset ( ) { clear ( ) ; this . reference count = 0 ; }
public void unlock ( ) { lock . unlock ( ) ; }
public byte read byte ( ) throw buffer exception { ensure available ( 1 ) ; return data [ rpos++ ] ; }
public t put byte ( byte [ ] b ) { return put byte ( b , 0 , b . length ) ; }
public charset get remote charset ( ) { return remote charset ; }
public compile s t compile ( string name , string template ) { compile s t code = compile ( null , name , null , template , null ) ; code . have formal args = false ; return code ; }
public object get attribute ( string name ) { formal argument local arg = null ; if ( impl . formal argument ! =null ) local arg = impl . formal argument . get ( name ) ; if ( local arg ! =null ) { object o = local [ local arg . index ] ; if ( o== s t . empty_attr ) o = null ; return o ; } return null ; }
public url get root dir u r l ( ) { return null ; }
protect string map a bit string ( ) { string builder sb = new string builder ( ) ; for ( byte b : map ) { string bit = integer . to binary string ( b ) ; for ( int i = 0 ; i < 8 - bit . length ( ) ; i++ ) { sb . append ( ' 0 ' ) ; } sb . append ( bit ) ; } return sb . to string ( ) ; }
public static set < string > custom exclude class ( ) { return custom exclude class ; }
public static < a extend annotation > list < a > get repeatable annotation ( method method , class < a > annotation class ) { a [ ] annotation = method . get annotation by type ( annotation class ) ; if ( annotation == null || annotation . length == 0 ) { for ( annotation meta annotation : method . get annotation ( ) ) { annotation = meta annotation . annotation type ( ) . get annotation by type ( annotation class ) ; if ( annotation ! = null & & annotation . length > 0 ) { return array . a list ( annotation ) ; } } method superclass method = get overridden method ( method ) ; if ( superclass method ! = null ) { return get repeatable annotation ( superclass method , annotation class ) ; } } if ( annotation == null ) { return null ; } return array . a list ( annotation ) ; }
public string get url ( ) { return url ; }
public string get format ( ) { return format ; }
public boolean get exclusive minimum ( ) { return exclusive minimum ; }
public integer get max length ( ) { return max length ; }
public string get pattern ( ) { return pattern ; }
public object get additional property ( ) { return additional property ; }
public xml get xml ( ) { return xml ; }
public string get type ( ) { return type ; }
public string get namespace ( ) { return namespace ; }
public string get prefix ( ) { return prefix ; }
public external documentation get external doc ( ) { return external doc ; }
public string get in ( ) { return in ; }
public string get $ ref ( ) { return $ ref ; }
public string get authorization url ( ) { return authorization url ; }
public o auth flow get client credential ( ) { return client credential ; }
public string get url ( ) { return url ; }
public void a byte ( byte buffer buf ) { buf . put int ( verbose_array_digest ) ; buf . put double ( compression ( ) ) ; buf . put int ( page size ) ; buf . put int ( centroid count ) ; for ( page page : data ) { for ( int i = 0 ; i < page . active ; i++ ) { buf . put double ( page . centroid [ i ] ) ; } } for ( page page : data ) { for ( int i = 0 ; i < page . active ; i++ ) { buf . put int ( page . count [ i ] ) ; } } }
public int leave ( int node ) { return leave [ node ] ; }
public static array digest create array digest ( double compression ) { return new array digest ( 32 , compression ) ; }
public static void assert true ( boolean condition , string message ) { if ( ! condition ) { fail not equal ( condition , boolean . true , message ) ; } }
public static void fail ( string message , throwable real cause ) { assertion error ae = new assertion error ( message ) ; ae . init cause ( real cause ) ; throw ae ; }
public static void assert equal ( byte actual , byte expect , string message ) { assert equal ( byte . value of ( actual ) , byte . value of ( expect ) , message ) ; }
public static void assert equal ( short actual , short expect , string message ) { assert equal ( short . value of ( actual ) , short . value of ( expect ) , message ) ; }
public static void assert null ( object object ) { assert null ( object , null ) ; }
public static void assert equal ( collection < ? > actual , collection < ? > expect ) { assert equal ( actual , expect , null ) ; }
public int get priority ( ) { return m_method instance . size ( ) > 0 ? m_method instance . get ( 0 ) . get method ( ) . get priority ( ) : 0 ; }
public static string annotation form for ( i test n g method method ) { if ( method . be before suite configuration ( ) ) { return `` @ before suite `` ; } if ( method . be before test configuration ( ) ) { return `` @ before test `` ; } if ( method . be before class configuration ( ) ) { return `` @ before class `` ; } if ( method . be before group configuration ( ) ) { return `` @ before group `` ; } if ( method . be before method configuration ( ) ) { return `` @ before method `` ; } if ( method . be after method configuration ( ) ) { return `` @ after method `` ; } if ( method . be after group configuration ( ) ) { return `` @ after group `` ; } if ( method . be after class configuration ( ) ) { return `` @ after class `` ; } if ( method . be after test configuration ( ) ) { return `` @ after test `` ; } if ( method . be after suite configuration ( ) ) { return `` @ after suite `` ; } return `` `` ; }
public void trace ( object message , throwable t ) { log ( trace , message , t ) ; }
public void debug ( object message ) { log ( debug , message , null ) ; }
public static void log ( string s , int level ) { if ( test runner . get verbose ( ) > = level ) { log ( s , get current test result ( ) ) ; } }
public string get parameter ( string parameter name ) { return xml suite . get parameter ( parameter name ) ; }
public void set output directory ( final string outputdir ) { if ( be string not empty ( outputdir ) ) { m_output dir = outputdir ; } }
public static boolean be jdk14 ( ) { return false ; }
public void set work dir ( file work dir ) { m_working dir= work dir ; }
public list < i worker < i test n g method > > create worker ( list < i test n g method > method ) { abstract parallel worker . argument args = new abstract parallel worker . argument . builder ( ) . class method map ( this . m_class method map ) . config method ( this . m_group method ) . finder ( this . m_annotation finder ) . invoker ( this . m_invoker ) . method ( method ) . test context ( this ) . listener ( this . m_class listener . value ( ) ) . build ( ) ; return abstract parallel worker . new worker ( m_xml test . get parallel ( ) ) . create worker ( args ) ; }
public integer get verbose ( ) { return m_verbose ! = null ? m_verbose : test n g . default_verbose ; }
public void set verbose ( integer verbose ) { m_verbose = verbose ; }
public string get test ( ) { return m_test ; }
public void set class name ( list < xml class > class ) { m_xml class = class ; }
public object clone ( ) { xml test result = new xml test ( get suite ( ) ) ; result . set name ( get name ( ) ) ; result . set include group ( get include group ( ) ) ; result . set exclude group ( get exclude group ( ) ) ; result . set j unit ( be j unit ( ) ) ; result . set parallel ( get parallel ( ) ) ; result . set verbose ( get verbose ( ) ) ; result . set parameter ( get local parameter ( ) ) ; result . set xml package ( get xml package ( ) ) ; result . set time out ( get time out ( ) ) ; map < string , list < string > > metagroups = get meta group ( ) ; for ( map . entry < string , list < string > > group : metagroups . entry set ( ) ) { result . add meta group ( group . get key ( ) , group . get value ( ) ) ; } return result ; }
public static void add duration attribute ( x m l reporter config config , property attribute , date min start date , date max end date ) { simple date format format = new simple date format ( x m l reporter config . get timestamp format ( ) ) ; string start time = format . format ( min start date ) ; string end time = format . format ( max end date ) ; long duration = max end date . get time ( ) - min start date . get time ( ) ; attribute . set property ( x m l reporter config . attr_started_at , start time ) ; attribute . set property ( x m l reporter config . attr_finished_at , end time ) ; attribute . set property ( x m l reporter config . attr_duration_ms , long . to string ( duration ) ) ; }
public boolean be j unit ( ) { return m_is j unit ; }
protect scheduled future schedule interruption ( ) { return interrupter_executor_service . schedule ( interrupter , allow execution duration . to nanos ( ) , time unit . nanosecond ) ; }
public int size ( ) { return this . _map . size ( ) ; }
public void set auto compaction factor ( float factor ) { if ( factor < 0 ) { throw new illegal argument exception ( `` factor must be > = 0 : `` + factor ) ; } _auto compaction factor = factor ; }
public boolean have next ( ) { return next index ( ) > = 0 ; }
protect final int next index ( ) { if ( _expected size ! = _hash . size ( ) ) { throw new concurrent modification exception ( ) ; } object [ ] set = _object_hash . _set ; int i = _index ; while ( i -- > 0 & & ( set [ i ] == t object hash . free || set [ i ] == t object hash . remove ) ) { ; } return i ; }
public collection < v > value ( ) { return new value view ( ) ; }
public boolean contain all ( collection < ? > collection ) { for ( iterator i = collection . iterator ( ) ; i . have next ( ) ; ) { if ( ! contains ( i . next ( ) ) ) { return false ; } } return true ; }
public byte pop ( ) { return _list . remove at ( _list . size ( ) - 1 ) ; }
public void clear ( ) { _list . clear ( ) ; }
public int transform index ( field field , int index ) { return index ; }
public final string get message ( ) { string msg = super . get message ( ) ; msg = msg == null ? get error description ( ) + `` : `` : msg ; string detail = get detail ( ) ; if ( detail ! = null & & ! detail . be empty ( ) ) { msg = msg + `` \n internal state when error be throw : `` + detail ; } msg = update message ( msg ) ; return msg ; }
protect string update message ( string msg ) { return msg ; }
public static string [ ] normalize ( string [ ] string ) { string [ ] out = new string [ string . length ] ; for ( int i = 0 ; i < string . length ; i++ ) { out [ i ] = normalize ( strings [ i ] ) ; } return out ; }
public void set number of record to read ( long number of record to read ) { this . number of record to read = number of record to read ; }
protect char appender new char appender ( ) { int char = get max char per column ( ) ; if ( char ! = -1 ) { return new default char appender ( char , get null value ( ) , get whitespace range start ( ) ) ; } else { return new expand char appender ( get null value ( ) , get whitespace range start ( ) ) ; } }
public final boolean be line separator detection enable ( ) { return line separator detection enable ; }
public field set < string > select field ( string . . . field names ) { return set field set ( new field name selector ( ) , field name ) ; }
public field set < integer > select index ( integer . . . field index ) { return set field set ( new field index selector ( ) , field index ) ; }
public final boolean be auto configuration enable ( ) { return auto configuration enable ; }
protected common setting clone ( boolean clear input specific setting ) { try { common setting out = ( common setting ) super . clone ( ) ; if ( out . format ! = null ) { out . format = out . format . clone ( ) ; } if ( clear input specific setting ) { out . clear input specific setting ( ) ; } return out ; } catch ( clone not support exception e ) { throw new illegal state exception ( e ) ; } }
public final void set column index ( int column index ) { this . column index = column index ; }
public int [ ] get field index ( string [ ] header ) { if ( header == null ) { return null ; } name . set ( argument utils . to array ( this . get ( ) ) ) ; return name . get field index ( header ) ; }
public void execute validation ( int index , object value ) { list < validate conversion > validation = validation by index . get ( index ) ; if ( validation ! = null ) { for ( int i = 0 ; i < validation . size ( ) ; i++ ) { validation . get ( i ) . execute ( value ) ; } } }
public int get field index ( enum column ) { return name . get field index ( column . to string ( ) ) ; }
public synchronize char bucket next bucket ( ) { if ( active execution == null & & ! finish ) { int length = -1 ; try { length = read bucket ( ) ; if ( length > = 0 & & length < = 4 ) { length = read bucket ( ) ; } } catch ( bom input . byte process notification e ) { throw e ; } catch ( exception e ) { set error ( e ) ; } if ( length ! = -1 ) { active execution = new thread ( this , `` un vocity-parsers input read thread `` ) ; active execution . start ( ) ; } else { finished = true ; try { bucket . put ( end ) ; } catch ( interrupted exception e ) { thread . current thread ( ) . interrupt ( ) ; } finally { stop reading ( ) ; } } } try { if ( finish ) { if ( bucket . size ( ) < = 1 ) { return end ; } } if ( current bucket ! = null ) { instance . release ( current bucket ) ; } object element = bucket . take ( ) ; if ( element == end ) { finish = true ; return end ; } else { current bucket = ( entry < char bucket > ) element ; } return current bucket . get ( ) ; } catch ( interrupted exception e ) { thread . current thread ( ) . interrupt ( ) ; finish = true ; return end ; } }
public string get lookahead ( ) { if ( start > = length ) { return `` `` ; } return new string ( lookahead , start , length ) ; }
public list < object [ ] > get detail row ( ) { return detail row ; }
public final int get minimum row length ( ) { if ( minimum row length == integer . min_value ) { minimum row length = 0 ; if ( get header ( ) ! = null ) { minimum row length = get header ( ) . length ; } if ( get index ( ) ! = null ) { for ( int index : get index ( ) ) { if ( index + 1 > minimum row length ) { minimum row length = index + 1 ; } } } } return minimum row length ; }
public final void set parser setting ( p parser setting ) { this . parser setting = parser setting ; }
protect void adjust column length ( string [ ] header , int [ ] length ) { }
public final long row count ( ) { return row ; }
public final string get parse content ( ) { if ( error content length == 0 ) { return null ; } return content ; }
protect big decimal from string ( string input ) { return new big decimal ( input ) ; }
protect byte from string ( string input ) { return byte . value of ( input ) ; }
public string execute ( string input ) { if ( input == null ) { return null ; } if ( input . length ( ) == 0 ) { return input ; } if ( length ! = -1 ) { int begin = 0 ; while ( begin < input . length ( ) & & input . char at ( begin ) < = ' ' ) { begin++ ; } if ( begin == input . length ( ) ) { return `` `` ; } int end = begin + ( length < input . length ( ) ? length : input . length ( ) ) - 1 ; if ( end > = input . length ( ) ) { end = input . length ( ) - 1 ; } while ( input . char at ( end ) < = ' ' ) { end -- ; } return input . substring ( begin , end + 1 ) ; } return input . trim ( ) ; }
public char get delimiter ( ) { return delimiter ; }
public void set parse unescaped quote until delimiter ( boolean parse unescaped quote until delimiter ) { if ( parse unescaped quote until delimiter ) { parse unescaped quote = true ; } this . parse unescaped quote until delimiter = parse unescaped quote until delimiter ; }
public final boolean be delimiter detection enable ( ) { return delimiter detection enable ; }
public void set unescaped quote handling ( unescaped quote handle unescaped quote handle ) { this . unescaped quote handle = unescaped quote handling ; }
public boolean get keep quote ( ) { return keep quote ; }
public boolean get ignore lead whitespaces in quote ( ) { return ignore leading whitespaces in quote ; }
protect final void initialize ( csv writer setting setting ) { csv format format = setting . get format ( ) ; this . separator = format . get delimiter ( ) ; this . quote char = format . get quote ( ) ; this . escape char = format . get quote escape ( ) ; this . escape escape = setting . get format ( ) . get char to escape quote escape ( ) ; this . new line = format . get normalized newline ( ) ; this . quote all field = setting . get quote all field ( ) ; this . ignore leading = setting . get ignore leading whitespaces ( ) ; this . ignore trail = setting . get ignore trail whitespaces ( ) ; this . escape unquoted = setting . be escape unquoted value ( ) ; this . input not escape = ! setting . be input escaped ( ) ; this . dont process normalize new line = ! setting . be normalize line ending within quote ( ) ; this . quotation trigger = null ; this . quote columns = null ; this . max trigger = 0 ; quote column = collection . empty set ( ) ; quote field selector = setting . get quoted field selector ( ) ; int trigger count = setting . get quotation trigger ( ) . length ; int offset = setting . be quote escape enable ( ) ? 1 : 0 ; char [ ] tmp = array . copy of ( setting . get quotation trigger ( ) , trigger count + offset ) ; if ( offset == 1 ) { tmp [ trigger count ] = quote char ; } for ( int i = 0 ; i < tmp . length ; i++ ) { if ( max trigger < tmp [ i ] ) { max trigger = tmp [ i ] ; } } if ( max trigger ! = 0 ) { max trigger++ ; this . quotation trigger = new boolean [ max trigger ] ; array . fill ( quotation trigger , false ) ; for ( int i = 0 ; i < tmp . length ; i++ ) { quotation trigger [ tmp [ i ] ] = true ; } } }
public char get escape char ( ) { return escape char ; }
protect tsv format create default format ( ) { return new tsv format ( ) ; }
public static array < character > of all ( char . . . element ) { object . require non null ( element , `` element be null `` ) ; return of all ( iterator . of all ( element ) ) ; }
public bit set < t > of all ( java . util . stream . stream < ? extend t > java stream ) { object . require non null ( java stream , `` java stream be null `` ) ; return empty ( ) . add all ( iterator . of all ( java stream . iterator ( ) ) ) ; }
public static link hash set < character > of all ( char . . . element ) { object . require non null ( element , `` element be null `` ) ; return link hash set . of all ( iterator . of all ( element ) ) ; }
public static link hash set < integer > of all ( int . . . element ) { object . require non null ( element , `` element be null `` ) ; return link hash set . of all ( iterator . of all ( element ) ) ; }
public static tree set < boolean > of all ( boolean . . . element ) { object . require non null ( element , `` element be null `` ) ; return tree set . of all ( iterator . of all ( element ) ) ; }
public static tree set < integer > of all ( int . . . element ) { object . require non null ( element , `` element be null `` ) ; return tree set . of all ( iterator . of all ( element ) ) ; }
public static vector < integer > of all ( int . . . element ) { object . require non null ( element , `` element be null `` ) ; return of all ( bit map trie . of all ( element ) ) ; }
public long get timestamp ( ) { return timestamp ; }
public object get session ( ) { return session ; }
public string get accept sub protocol ( ) { return get header ( sec_websocket_protocol ) ; }
public list < extension config > get extension ( ) { return extension ; }
public string to string ( ) { return format . format annotate constructor ( this ) ; }
public string to string ( ) { return format . format annotate type ( this ) ; }
public void set producer ( producer < t > producer ) { this . producer = producer ; }
public void fire event ( type event type , object event , annotation . . . qualifier ) { final event metadata metadata = new event metadata impl ( event type , null , qualifier ) ; notifier . fire event ( event type , event , metadata , qualifier ) ; }
public boolean be xml validation disable ( ) { return xml validation disable ; }
public static void end request ( ) { final list < request scoped item > result = cache . get ( ) ; if ( result ! = null ) { cache . remove ( ) ; for ( final request scoped item item : result ) { item . invalidate ( ) ; } } }
public static void invalidate ( ) { if ( be active ( ) ) { end request ( ) ; begin request ( ) ; } }
public boolean destroy dependent instance ( t instance ) { synchronize ( dependent instance ) { for ( iterator < contextual instance < ? > > iterator = dependent instance . iterator ( ) ; iterator . have next ( ) ; ) { contextual instance < ? > contextual instance = iterator . next ( ) ; if ( contextual instance . get instance ( ) == instance ) { iterator . remove ( ) ; destroy ( contextual instance ) ; return true ; } } } return false ; }
public static < t > fast event < t > of ( class < t > type , bean manager impl manager , observer notifier notifier , annotation . . . qualifier ) { resolved observer < t > resolve observer method = notifier . < t > resolve observer method ( type , qualifier ) ; if ( resolve observer method . be metadata require ( ) ) { event metadata metadata = new event metadata impl ( type , null , qualifier ) ; current event metadata metadata service = manager . get service ( ) . get ( current event metadata . class ) ; return new fast event with metadata propagation < t > ( resolve observer method , metadata , metadata service ) ; } else { return new fast event < t > ( resolve observer method ) ; } }
public < t > resolve observer < t > resolve observer method ( resolvable resolvable ) { return cast ( resolver . resolve ( resolvable , true ) ) ; }
public < t > void notify ( resolved observer < t > observer , t event , event metadata metadata ) { if ( ! observer . be metadata require ( ) ) { metadata = null ; } notify sync observer ( observer . get immediate sync observer ( ) , event , metadata , observer exception handler . immediate_handler ) ; notify transaction observer ( observer . get transaction observer ( ) , event , metadata , observer exception handler . immediate_handler ) ; }
protect void cleanup ( ) { }
public void fire event ( object event , annotation . . . qualifier ) { precondition . check argument not null ( event , `` event `` ) ; type event type = type . get canonical type ( event . get class ( ) ) ; event metadata metadata = new event metadata impl ( event type , null , qualifier ) ; global strict observer notifier . fire event ( event , metadata , qualifier ) ; }
public type safe bean resolver get bean resolver ( ) { return bean resolver ; }
public string to string ( ) { return ( be valid ( ) ? `` valid `` : `` invalid `` ) + `` annotation model for `` + get raw type ( ) ; }
public < t extend annotation > qualifier model < t > get bind type model ( final class < t > bind type ) { return qualifier . get cast value ( bind type ) ; }
public static < t > builder < t > builder ( ) { return new builder impl < t > ( ) ; }
public static string to multi row string ( collection < ? > collection ) { if ( collection == null ) { return null ; } if ( collection . be empty ( ) ) { return `` ( empty collection ) `` ; } string builder builder = new string builder ( `` \n - `` ) ; for ( iterator < ? > iterator = collection . iterator ( ) ; iterator . have next ( ) ; ) { builder . append ( iterator . next ( ) ) ; if ( iterator . have next ( ) ) { builder . append ( `` , \n - `` ) ; } } return builder . to string ( ) ; }
public static void validate observer method ( observer method < ? > observer method , bean manager bean manager , observer method < ? > original observer method ) { set < annotation > qualifier = observer method . get observed qualifier ( ) ; if ( observer method . get bean class ( ) == null ) { throw event logger . log . observer method method return null ( `` get bean class `` , observer method ) ; } if ( observer method . get observed type ( ) == null ) { throw event logger . log . observer method method return null ( `` get observed type `` , observer method ) ; } binding . validate qualifier ( qualifier , bean manager , observer method , `` observer method . get observed qualifier `` ) ; if ( observer method . get reception ( ) == null ) { throw event logger . log . observer method method return null ( `` get reception `` , observer method ) ; } if ( observer method . get transaction phase ( ) == null ) { throw event logger . log . observer method method return null ( `` get transaction phase `` , observer method ) ; } if ( original observer method ! = null & & ( ! observer method . get bean class ( ) . equal ( original observer method . get bean class ( ) ) ) ) { throw event logger . log . bean class mismatch ( original observer method , observer method ) ; } if ( ! ( observer method instanceof synthetic observer method ) & & ! have notify overriden ( observer method . get class ( ) , observer method ) ) { throw event logger . log . notify method not implement ( observer method ) ; } }
public static string decapitalize ( string name ) { if ( name == null || name . length ( ) == 0 ) { return name ; } if ( name . length ( ) > 1 & & character . be upper case ( name . char at ( 1 ) ) & & character . be upper case ( name . char at ( 0 ) ) ) { return name ; } char [ ] char = name . to char array ( ) ; char [ 0 ] = character . to lower case ( char [ 0 ] ) ; return new string ( char ) ; }
public void set args ( string [ ] args ) { if ( args == null ) { args = new string [ ] { } ; } this . args = args ; this . args list = collection . unmodifiable list ( new array list < string > ( arrays . a list ( args ) ) ) ; }
public weld add package ( boolean scan recursively , class < ? > . . . package class ) { for ( class < ? > package class : package class ) { add package ( scan recursively , package class ) ; } return this ; }
public weld property ( string key , object value ) { property . put ( key , value ) ; return this ; }
public static void initialize ( singleton provider instance ) { synchronize ( singleton provider . class ) { if ( instance == null ) { instance = instance ; } else { throw new runtime exception ( `` singleton provider be already initialize with `` + instance ) ; } } }
public void read ( record r ) throw i o exception { r . deserialize ( archive , `` `` ) ; }
public void shutdown ( ) { if ( purge task status . start == purge task status ) { log . info ( `` shut down purge task . `` ) ; timer . cancel ( ) ; purge task status = purge task status . complete ; } else { log . warn ( `` purge task not start . ignore shutdown ! `` ) ; } }
public string get snap dir ( ) { return snap dir ; }
public synchronize set < string > get child ( ) { return child ; }
public static void set prealloc size ( long size ) { pre alloc size = size ; }
public synchronize void roll log ( ) throw i o exception { if ( log stream ! = null ) { this . log stream . flush ( ) ; this . log stream = null ; oa = null ; } }
public static long pad log file ( file output stream f , long current size , long pre alloc size ) throw i o exception { long position = f . get channel ( ) . position ( ) ; if ( position + 4096 > = current size ) { current size = current size + pre alloc size ; fill . position ( 0 ) ; f . get channel ( ) . write ( fill , current size-fill . remain ( ) ) ; } return current size ; }
synchronize public void sync ( ) { if ( pending syncs . size ( ) ==0 ) { log . warn ( `` not expect a sync . `` ) ; return ; } request r = pending syncs . remove ( ) ; commit processor . commit ( r ) ; }
public void read from ( quorum peer config config ) { client port address = config . get client port address ( ) ; data dir = config . get data dir ( ) ; data log dir = config . get data log dir ( ) ; tick time = config . get tick time ( ) ; max client cnxns = config . get max client cnxns ( ) ; min session timeout = config . get min session timeout ( ) ; max session timeout = config . get max session timeout ( ) ; }
public void set child ( hash set < string > child ) { this . child = child ; }
public void setlast process zxid ( long zxid ) { data tree . last processed zxid = zxid ; }
public list < acl > convert long ( long acl l ) { return data tree . convert long ( acl l ) ; }
public void set watch ( long relative zxid , list < string > data watch , list < string > exist watch , list < string > child watch , watcher watcher ) { data tree . set watch ( relative zxid , data watch , exist watch , child watch , watcher ) ; }
public long get session id ( ) { return cnxn . get session id ( ) ; }
public void add auth info ( string scheme , byte auth [ ] ) { cnxn . add auth info ( scheme , auth ) ; }
public synchronize void close ( ) throw interrupted exception { if ( ! cnxn . get state ( ) . be alive ( ) ) { if ( log . be debug enable ( ) ) { log . debug ( `` close call on already close client `` ) ; } return ; } if ( log . be debug enable ( ) ) { log . debug ( `` closing session : 0x `` + long . to hex string ( get session id ( ) ) ) ; } try { cnxn . close ( ) ; } catch ( i o exception e ) { if ( log . be debug enable ( ) ) { log . debug ( `` ignore unexpected exception during close `` , e ) ; } } log . info ( `` session : 0x `` + long . to hex string ( get session id ( ) ) + `` closed `` ) ; }
protect socket address testable local socket address ( ) { return cnxn . send thread . get client cnxn socket ( ) . get local socket address ( ) ; }
public list < string > get command ( ) { return new array list < string > ( builder . command ( ) ) ; }
public process executor redirect error stream ( boolean redirect error stream ) { builder . redirect error stream ( redirect error stream ) ; return this ; }
public process executor remove listener ( process listener listener ) { listener . remove ( listener ) ; return this ; }
public process executor set message logger ( message logger message logger ) { this . message logger = message logger ; return this ; }
