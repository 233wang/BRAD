public static void add type mapper ( class < ? > clz , class < ? > mapper ) { synchronize ( class mapper ) { link hash set < class < ? > > h = class mapper . get ( clz ) ; if ( h == null ) { h = new link hash set < class < ? > > ( ) ; class mapper . put ( clz , h ) ; } h . add ( mapper ) ; } }
public boolean be mime type equal ( string mime type ) { mime type mt = null ; try { if ( mime object == null ) mime object = new mime type ( this . mime type ) ; mt = new mime type ( mime type ) ; } catch ( mime type parse exception e ) { } return mime object . match ( mt ) ; }
protect string normalize mime type ( string mime type ) { return mime type ; }
public string get command name ( ) { return verb ; }
public command info get command ( string mime type , string cmd name , data source d ) { return get command ( mime type , cmd name ) ; }
public file get file ( ) { return _file ; }
public string get sub type ( ) { return sub type ; }
public boolean match ( string rawdata ) throw mime type parse exception { return match ( new mime type ( rawdata ) ) ; }
public int size ( ) { return parameter . size ( ) ; }
public enumeration get name ( ) { return parameter . key ( ) ; }
public string get content type ( ) { string type = null ; try { if ( url_conn == null ) url_conn = url . open connection ( ) ; } catch ( i o exception e ) { } if ( url_conn ! = null ) type = url_conn . get content type ( ) ; if ( type == null ) type = `` application/octet-stream `` ; return type ; }
public input stream get input stream ( ) throw i o exception { return url . open stream ( ) ; }
public agroal connection pool configuration supplier initial size ( int size ) { check lock ( ) ; initial size = size ; return this ; }
public agroal data source configuration supplier connection pool configuration ( agroal connection pool configuration configuration ) { check lock ( ) ; connection pool configuration supplier = new agroal connection pool configuration supplier ( configuration ) ; return this ; }
public void add path element ( string path element ) throw build exception { file path component = project ! = null ? project . resolve file ( path element ) : new file ( path element ) ; try { add path file ( path component ) ; } catch ( i o exception e ) { throw new build exception ( e ) ; } }
public class force load class ( string classname ) throw class not find exception { log ( `` force load `` + classname , project . msg_debug ) ; class the class = find loaded class ( classname ) ; if ( the class == null ) { the class = find class ( classname ) ; } return the class ; }
public class force load system class ( string classname ) throw class not find exception { log ( `` force system load `` + classname , project . msg_debug ) ; class the class = find loaded class ( classname ) ; if ( the class == null ) { the class = find base class ( classname ) ; } return the class ; }
public void set class ( class clazz ) { this . clazz = clazz ; if ( clazz == null ) { return ; } this . class loader = ( class loader == null ) ? clazz . get class loader ( ) : class loader ; this . class name = ( class name == null ) ? clazz . get name ( ) : class name ; }
public throwable get exception ( ) { return exception ; }
public object create component ( string component name ) { ant type definition def = get definition ( component name ) ; return ( def == null ) ? null : def . create ( project ) ; }
public hashtable get task definition ( ) { synchronize ( task class definition ) { synchronize ( ant type table ) { if ( rebuild task class definition ) { task class definition . clear ( ) ; for ( iterator i = ant type table . key set ( ) . iterator ( ) ; i . have next ( ) ; ) { string name = ( string ) i . next ( ) ; class clazz = ant type table . get exposed class ( name ) ; if ( clazz == null ) { continue ; } if ( task . class . be assignable from ( clazz ) ) { task class definition . put ( name , ant type table . get type class ( name ) ) ; } } rebuild task class definition = false ; } } } return task class definition ; }
public void set output print stream ( print stream output ) { this . out = new print stream ( output , true ) ; }
public void build finish ( build event event ) { throwable error = event . get exception ( ) ; string buffer message = new string buffer ( ) ; if ( error == null ) { message . append ( string utils . line_sep ) ; message . append ( get build successful message ( ) ) ; } else { message . append ( string utils . line_sep ) ; message . append ( get build failed message ( ) ) ; message . append ( string utils . line_sep ) ; if ( project . msg_verbose < = msg output level || ! ( error instanceof build exception ) ) { message . append ( string utils . get stack trace ( error ) ) ; } else { message . append ( error . to string ( ) ) . append ( l sep ) ; } } message . append ( string utils . line_sep ) ; message . append ( `` total time : `` ) ; message . append ( format time ( system . current time millis ( ) - start time ) ) ; string msg = message . to string ( ) ; if ( error == null ) { print message ( msg , out , project . msg_verbose ) ; } else { print message ( msg , err , project . msg_err ) ; } log ( msg ) ; }
public static file [ ] list library ( ) { string home = system . get property ( magic name . ant_home ) ; if ( home == null ) { return null ; } file lib dir = new file ( home , `` lib `` ) ; return list jar file ( lib dir ) ; }
public static string [ ] get default excludes ( ) { return ( string [ ] ) default excludes . to array ( new string [ default excludes . size ( ) ] ) ; }
public synchronize boolean be case sensitive ( ) { return be case sensitive ; }
public synchronize void set excludes ( string [ ] exclude ) { if ( excludes == null ) { this . exclude = null ; } else { this . exclude = new string [ excludes . length ] ; for ( int i = 0 ; i < excludes . length ; i++ ) { this . exclude [ i ] = normalize pattern ( excludes [ i ] ) ; } } }
public synchronize boolean be everything include ( ) { return everything include ; }
protect boolean could hold include ( string name ) { for ( int i = 0 ; i < include . length ; i++ ) { if ( match pattern start ( include [ i ] , name , be case sensitive ( ) ) & & be more powerful than excludes ( name , include [ i ] ) & & be deep ( include [ i ] , name ) ) { return true ; } } return false ; }
public synchronize string [ ] get not include file ( ) { slow scan ( ) ; string [ ] file = new string [ file not include . size ( ) ] ; file not include . copy into ( file ) ; return file ; }
public void set action ( string action ) { this . action = action ; }
protect final string read fully ( ) throw i o exception { return file utils . read fully ( in , buffer_size ) ; }
public final void set parameter ( final parameter [ ] parameter ) { this . parameter = parameter ; set initialize ( false ) ; }
public reader chain ( final reader rdr ) { expand property new filter = new expand property ( rdr ) ; new filter . set project ( get project ( ) ) ; return new filter ; }
public int get tablength ( ) { return tab length ; }
public reader chain ( final reader rdr ) { prefix line new filter = new prefix line ( rdr ) ; new filter . set prefix ( get prefix ( ) ) ; new filter . set initialized ( true ) ; return new filter ; }
public reader chain ( final reader rdr ) { strip java comment new filter = new strip java comment ( rdr ) ; return new filter ; }
public void add contain regex ( contains regex filter ) { filter . add element ( filter ) ; }
public void pop wrapper ( ) { if ( w stack . size ( ) > 0 ) { w stack . remove element at ( w stack . size ( ) - 1 ) ; } }
public target get implicit target ( ) { return implicit target ; }
public vector get target ( ) { return target vector ; }
protect string get prompt ( input request request ) { string prompt = request . get prompt ( ) ; string def = request . get default value ( ) ; if ( request instanceof multiple choice input request ) { string buffer sb = new string buffer ( prompt ) ; sb . append ( `` ( `` ) ; enumeration e = ( ( multiple choice input request ) request ) . get choice ( ) . element ( ) ; boolean first = true ; while ( e . have more element ( ) ) { if ( ! first ) { sb . append ( `` , `` ) ; } string next = ( string ) e . next element ( ) ; if ( next . equal ( def ) ) { sb . append ( ' [ ' ) ; } sb . append ( next ) ; if ( next . equal ( def ) ) { sb . append ( ' ] ' ) ; } first = false ; } sb . append ( `` ) `` ) ; return sb . to string ( ) ; } else if ( def ! = null ) { return prompt + `` [ `` + def + `` ] `` ; } else { return prompt ; } }
protect string get timestamp ( ) { date date = new date ( system . current time millis ( ) ) ; date format formatter = date format . get date time instance ( date format . short , date format . short ) ; string finish time = formatter . format ( date ) ; return finish time ; }
public void init ( ) throw build exception { init property ( ) ; component helper . get component helper ( this ) . init default definition ( ) ; }
public void log ( string message ) { log ( message , msg_info ) ; }
public void log ( task task , string message , int msg level ) { fire message log ( task , message , null , msg level ) ; }
public string replace property ( string value ) throw build exception { property helper ph = property helper . get property helper ( this ) ; return ph . replace property ( null , value , null ) ; }
public void set basedir ( string base d ) throw build exception { set base dir ( new file ( base d ) ) ; }
public int demux input ( byte [ ] buffer , int offset , int length ) throw i o exception { task task = get thread task ( thread . current thread ( ) ) ; if ( task == null ) { return default input ( buffer , offset , length ) ; } else { return task . handle input ( buffer , offset , length ) ; } }
public void copy file ( string source file , string d file , boolean filtering , boolean overwrite ) throw i o exception { file_utils . copy file ( source file , d file , filter ? global filter : null , overwrite ) ; }
public hashtable get reference ( ) { return reference ; }
public synchronize void register thread task ( thread thread , task task ) { if ( task ! = null ) { thread task . put ( thread , task ) ; thread group task . put ( thread . get thread group ( ) , task ) ; } else { thread task . remove ( thread ) ; thread group task . remove ( thread . get thread group ( ) ) ; } }
public void set project ( project project ) { this . project = project ; }
public project get project ( ) { return project ; }
public vector get import stack ( ) { return import stack ; }
public static string replace property ( project project , string value , hashtable key ) throw build exception { property helper ph = property helper . get property helper ( project ) ; return ph . replace property ( null , value , key ) ; }
public synchronize object get user property ( string ns , string name ) { if ( name == null ) { return null ; } object o = get property hook ( ns , name , true ) ; if ( o ! = null ) { return o ; } return user property . get ( name ) ; }
public synchronize void add child ( runtime configurable child ) { child = ( child == null ) ? new array list ( ) : child ; child . add ( child ) ; }
public void add data type ( runtime configurable r ) { child . add ( r ) ; }
public string get if ( ) { return ( `` `` . equal ( if condition ) ? null : if condition ) ; }
public string get description ( ) { return description ; }
public object get proxy ( ) { return proxy ; }
public void set port ( int port ) { this . port = port ; }
public file get pas file ( ) { return this . pas file ; }
public file get d ( ) { return this . dest ; }
public void set package ( string p ) { this . cvs package = p ; }
public void set target ( string target to add ) { if ( target to add . equal ( `` `` ) ) { throw new build exception ( `` target attribute must not be empty `` ) ; } target . add ( target to add ) ; target attribute set = true ; }
public void add propertyset ( property set p ) { property set . add element ( p ) ; }
public path create filepath ( ) { if ( this . filepath == null ) { this . filepath = new path ( get project ( ) ) ; } return this . filepath . create path ( ) ; }
public void set file ( file file ) { this . file = file ; this . filename = file_utils . remove lead path ( get project ( ) . get base dir ( ) , file ) ; }
public void set format ( format element e ) { format = e . get format ( ) ; }
public void set skip empty filesets ( boolean skip ) { throw new build exception ( get task type ( ) + `` doesn\'t support the skipemptyfileset attribute `` , get location ( ) ) ; }
protect boolean assume java12 ( ) { return `` javac1 . 2 `` . equal ( attribute . get compiler version ( ) ) || ( `` classic `` . equal ( attribute . get compiler version ( ) ) & & java env utils . be java version ( java env utils . java_1_2 ) ) || ( `` ext javac `` . equal ( attribute . get compiler version ( ) ) & & java env utils . be java version ( java env utils . java_1_2 ) ) ; }
public boolean be native build ( ) { boolean native build = false ; string [ ] additional argument = get javac ( ) . get current compiler args ( ) ; int args length = 0 ; while ( ! native build & & args length < additional argument . length ) { int conflict length = 0 ; while ( ! native build & & conflict length < conflict_with_dash_c . length ) { native build = ( additional argument [ args length ] . start with ( conflict_with_dash_c [ conflict length ] ) ) ; conflict length++ ; } args length++ ; } return native build ; }
public void set destfile ( file destination file ) { this . destination file = destination file ; }
public void add available ( available a ) { condition . add element ( a ) ; }
public string get partition ( ) { return partition ; }
public void set ignore system class ( boolean ignore system class ) { this . ignore system class = ignore system class ; }
public void set name ( string name ) { this . name = name . to lower case ( locale . u ) ; }
public void set property ( string property ) { this . property = property ; }
public boolean eval feature ( ) { x m l reader reader = get reader ( ) ; if ( value == null ) { value = `` true `` ; } boolean v = project . to boolean ( value ) ; try { reader . set feature ( feature , v ) ; } catch ( s a x not recognize exception e ) { log ( feature + not_recognized + feature , project . msg_verbose ) ; return false ; } catch ( s a x not support exception e ) { log ( feature + not_supported + feature , project . msg_verbose ) ; return false ; } return true ; }
public void set tofile ( file d file ) { this . d file = d file ; }
public filter set create filter set ( ) { filter set filter set = new filter set ( ) ; filter set . add element ( filter set ) ; return filter set ; }
public mapper create mapper ( ) throw build exception { if ( mapper element ! = null ) { throw new build exception ( `` can not define more than one mapper `` , get location ( ) ) ; } mapper element = new mapper ( get project ( ) ) ; return mapper element ; }
public string get encode ( ) { return input encode ; }
public void set d ( file dest ) { d dir = dest ; }
public void set d dir ( file d dir ) { this . d dir = d dir ; }
public path create path ( ) { if ( path == null ) { path = new path ( get project ( ) ) ; } return path ; }
public vector get file ( ) { return file ; }
public string get user i d ( ) { return user i d ; }
public void add fileset ( file set set ) { filesets . add element ( set ) ; }
public void set property ( string property ) { this . property = property ; }
public void set message mime type ( string type ) { this . message mime type = type ; }
public path create attachment ( ) { if ( attachment == null ) { attachment = new path ( get project ( ) ) ; } return attachment . create path ( ) ; }
public void set includefilenames ( boolean include file name ) { this . include file name = include file name ; }
public void set subject ( string subject ) { this . subject = subject ; }
public string get charset ( ) { return charset ; }
public void set dir ( string d ) { this . dir = get project ( ) . resolve file ( d ) ; }
public void set o ( string os ) { this . os = o ; }
public void set outputproperty ( string output prop ) { redirector . set output property ( output prop ) ; incompatible with spawn = true ; }
public void set failonerror ( boolean fail ) { fail on error = fail ; incompatible with spawn |= fail ; }
public boolean kill process ( ) { return watchdog ! = null & & watchdog . kill process ( ) ; }
public void set output ( print stream out ) { }
public void set type ( file dir both type ) { this . type = type . get value ( ) ; }
public void set skip empty filesets ( boolean skip ) { skip empty = skip ; }
public void set forwardslash ( boolean forward slash ) { this . forward slash = forward slash ; }
public void set overwrite ( boolean b ) { overwrite = b ; }
public void set keypass ( final string keypass ) { this . keypass = keypass ; }
public void set keysize ( final string keysize ) throw build exception { try { this . keysize = integer . parse int ( keysize ) ; } catch ( final number format exception nfe ) { throw new build exception ( `` key size attribute should be a integer `` ) ; } }
public void set use timestamp ( boolean v ) { use timestamp = v ; }
public void set filesetmanifest ( fileset manifest config config ) { fileset manifest config = config ; merge manifest main = `` merge `` . equal ( config . get value ( ) ) ; if ( fileset manifest config ! = null & & ! fileset manifest config . get value ( ) . equal ( `` skip `` ) ) { double file pas = true ; } }
public path create classpath ( ) { return get command line ( ) . create classpath ( get project ( ) ) . create path ( ) ; }
public permission create permission ( ) { perm = ( perm == null ) ? new permission ( ) : perm ; return perm ; }
public void set jar ( file jarfile ) throw build exception { if ( get command line ( ) . get classname ( ) ! = null ) { throw new build exception ( `` can not use 'jar ' and 'classname ' `` + `` attribute in same command . `` ) ; } get command line ( ) . set jar ( jarfile . get absolute path ( ) ) ; }
public void set jvmargs ( string s ) { log ( `` the jvmargs attribute be deprecate . `` + `` please use nest jvmarg element . `` , project . msg_warn ) ; get command line ( ) . create vm argument ( ) . set line ( s ) ; }
public void set error ( file error ) { this . error = error ; incompatible with spawn = true ; }
protect void run ( string classname , vector args ) throw build exception { commandline java cmdj = new commandline java ( ) ; cmdj . set classname ( classname ) ; for ( int i = 0 ; i < args . size ( ) ; i++ ) { cmdj . create argument ( ) . set value ( ( string ) args . element at ( i ) ) ; } run ( cmdj ) ; }
public commandline java . sys property get sys property ( ) { return get command line ( ) . get system property ( ) ; }
public path create sourcepath ( ) { if ( compile sourcepath == null ) { compile sourcepath = new path ( get project ( ) ) ; } return compile sourcepath . create path ( ) ; }
public void set bootclasspath ( path bootclasspath ) { if ( this . bootclasspath == null ) { this . bootclasspath = bootclasspath ; } else { this . bootclasspath . append ( bootclasspath ) ; } }
public void set includejavaruntime ( boolean include ) { include java runtime = include ; }
public void set tempdir ( file tmp dir ) { this . tmp dir = tmp dir ; }
protect void scan dir ( file src dir , file d dir , string [ ] file ) { glob pattern mapper m = new glob pattern mapper ( ) ; m . set from ( `` * . java `` ) ; m . set to ( `` * . class `` ) ; source file scanner sfs = new source file scanner ( this ) ; file [ ] new file = sfs . restrict a file ( file , src dir , d dir , m ) ; if ( new file . length > 0 ) { file [ ] new compile list = new file [ compile list . length + new file . length ] ; system . arraycopy ( compile list , 0 , new compile list , 0 , compile list . length ) ; system . arraycopy ( new file , 0 , new compile list , compile list . length , new file . length ) ; compile list = new compile list ; } }
public string get compiler ( ) { string compiler impl = get compiler version ( ) ; if ( fork ) { if ( be jdk compiler ( compiler impl ) ) { compiler impl = `` ext javac `` ; } else { log ( `` since compiler setting be n't classic or modern , `` + `` ignoring fork setting . `` , project . msg_warn ) ; } } return compiler impl ; }
protect void check parameter ( ) throw build exception { if ( src == null ) { throw new build exception ( `` srcdir attribute must be set ! `` , get location ( ) ) ; } if ( src . size ( ) == 0 ) { throw new build exception ( `` srcdir attribute must be set ! `` , get location ( ) ) ; } if ( d dir ! = null & & ! d dir . be directory ( ) ) { throw new build exception ( `` destination directory \ `` `` + d dir + `` \ `` do not exist `` + `` or be not a directory `` , get location ( ) ) ; } }
public void set access ( access type at ) { cmd . create argument ( ) . set value ( `` - `` + at . get value ( ) ) ; }
public void set bottom ( string bottom ) { html h = new html ( ) ; h . add text ( bottom ) ; add bottom ( h ) ; }
public void set nohelp ( boolean b ) { add arg if ( b , `` -nohelp `` ) ; }
public void set nonavbar ( boolean b ) { add arg if ( b , `` -nonavbar `` ) ; }
public void set docencoding ( string enc ) { cmd . create argument ( ) . set value ( `` -docencoding `` ) ; cmd . create argument ( ) . set value ( enc ) ; }
public void set password ( string password ) { this . password = password ; }
public boolean eval ( ) { validate ( ) ; if ( length == null ) { throw new build exception ( length_required ) ; } long ell = null ; if ( string . equal ( mode ) ) { ell = new long ( get length ( string , get trim ( ) ) ) ; } else { condition handler h = new condition handler ( ) ; handle resource ( h ) ; ell = new long ( h . get length ( ) ) ; } return when . evaluate ( ell . compare to ( length ) ) ; }
public void set classpath ( path classpath ) { assert src be java resource ( ) ; ( ( java resource ) src ) . set classpath ( classpath ) ; }
public void set name ( string name ) { this . name = name ; }
public list get attribute ( ) { return attribute ; }
public boolean similar ( object obj ) { return same or similar ( obj , false ) ; }
public void set property ( string property ) { this . property = property ; }
public void add ( file selector selector ) { fileset . add ( selector ) ; }
public void set src ( file src ) { set src resource ( new file resource ( src ) ) ; }
public void set poll interval ( int poll interval ) { }
public void add task ( task nest task ) { nested task . add element ( nested task ) ; }
public void set backup ( boolean backup ) { if ( backup ) { cmd . create argument ( ) . set value ( `` -b `` ) ; } }
public void set dir ( file directory ) { this . directory = directory ; }
public void add mapper ( mapper mapper ) { if ( this . mapper ! = null ) { throw new build exception ( `` can not define more than one mapper `` ) ; } this . mapper = mapper ; }
public void set file ( file file ) { this . file = file ; }
public url get url ( ) { return url ; }
public void set refid ( reference ref ) { this . ref = ref ; }
public void set classpath ref ( reference r ) { create classpath ( ) . set refid ( r ) ; }
protect void load url ( url url ) throw build exception { property prop = new property ( ) ; log ( `` load `` + url , project . msg_verbose ) ; try { input stream be = url . open stream ( ) ; try { prop . load ( be ) ; } finally { if ( be ! = null ) { be . close ( ) ; } } add property ( prop ) ; } catch ( i o exception ex ) { throw new build exception ( ex , get location ( ) ) ; } }
public void sub build finish ( build event event ) { if ( event . get project ( ) == get project ( ) ) { cleanup ( ) ; } }
public synchronize void set log error ( boolean log error ) { this . log error = log error ; }
protect synchronized void handle error output ( string output ) { if ( error print stream == null ) { error print stream = new print stream ( error stream ) ; } error print stream . print ( output ) ; }
public void set replace ( string replace ) { this . replace = project . to boolean ( replace ) ; }
public void validate replacefilters ( ) throw build exception { for ( int i = 0 ; i < replacefilters . size ( ) ; i++ ) { replacefilter element = ( replacefilter ) replacefilters . element at ( i ) ; element . validate ( ) ; } }
public void set replace filter file ( file replace filter file ) { this . replace filter file = replace filter file ; }
public void set rmic ( final rmic attribute ) { this . attribute = attribute ; mapper = new rmic file name mapper ( ) ; }
public static boolean be available ( ) { return get rmic class ( ) ! = null ; }
public string get compiler ( ) { facade . set magic value ( get project ( ) . get property ( `` build . rmic `` ) ) ; return facade . get implementation ( ) ; }
public void set sigfile ( final string sigfile ) { this . sigfile = sigfile ; }
public void set lazy ( final boolean lazy ) { this . lazy = lazy ; }
public void set fail on error ( boolean fail on error ) { this . fail on error = fail on error ; }
public void set expand property ( boolean expand property ) { this . expand property = expand property ; }
public void set escape processing ( boolean enable ) { escape processing = enable ; }
public void add propertyset ( property set p ) { property set . add element ( p ) ; }
public void add ( resource collection rc ) { get buildpath ( ) . add ( rc ) ; }
public void set overwrite ( boolean overwrite ) { my copy . set overwrite ( overwrite ) ; }
public void set longfile ( string mode ) { log ( `` deprecate - the set longfile ( string ) method have be deprecate . `` + `` use set longfile ( tar . tar long file mode ) instead . `` ) ; this . long file mode = new tar long file mode ( ) ; long file mode . set value ( mode ) ; }
public void execute ( ) throw build exception { if ( property == null || property . length ( ) == 0 ) { throw new build exception ( `` no property specify `` ) ; } if ( d dir == null ) { d dir = get project ( ) . resolve file ( `` . `` ) ; } file tfile = file_utils . create temp file ( prefix , suffix , d dir , delete on exit ) ; get project ( ) . set new property ( property , tfile . to string ( ) ) ; }
public void add ( resource collection rc ) { resource . add ( rc ) ; }
public void add srcfiles ( final file set f ) { source file set . add element ( f ) ; }
public void set max wait ( long time ) { max wait millis = time ; }
protect void clean up ( ) { if ( added web xml file == null & & deployment descriptor == null & & needxmlfile & & ! be in update mode ( ) ) { throw new build exception ( `` no w e b- i n f/web . xml file be add . \n `` + `` if this be your intent , set needxml='false ' `` ) ; } add web xml file = null ; super . clean up ( ) ; }
public void set root directory ( file root directory ) { this . root directory = root directory ; }
public void set file name parameter ( string file name parameter ) { this . file name parameter = file name parameter ; }
public x m l catalog get x m l catalog ( ) { xml catalog . set project ( get project ( ) ) ; return xml catalog ; }
public enumeration get output property ( ) { return output property . element ( ) ; }
public boolean be compress ( ) { return do compress ; }
protect static final boolean be empty ( resource [ ] [ ] r ) { for ( int i = 0 ; i < r . length ; i++ ) { if ( r [ i ] . length > 0 ) { return false ; } } return true ; }
public synchronize void set include ( string include ) { if ( be reference ( ) ) { throw too many attribute ( ) ; } default pattern . set include ( include ) ; directory scanner = null ; }
public synchronize void set excludes ( string excludes ) { if ( be reference ( ) ) { throw too many attribute ( ) ; } default pattern . set excludes ( excludes ) ; directory scanner = null ; }
public synchronize void set excludesfile ( file excl ) throw build exception { if ( be reference ( ) ) { throw too many attribute ( ) ; } default pattern . set excludesfile ( excl ) ; directory scanner = null ; }
public synchronize boolean be case sensitive ( ) { return ( be reference ( ) ) ? get ref ( get project ( ) ) . be case sensitive ( ) : case sensitive ; }
public void add and ( and selector selector ) { append selector ( selector ) ; }
public synchronize object clone ( ) { if ( be reference ( ) ) { return ( get ref ( get project ( ) ) ) . clone ( ) ; } else { try { abstract file set fs = ( abstract file set ) super . clone ( ) ; f . default pattern = ( pattern set ) default pattern . clone ( ) ; fs . additional pattern = new vector ( additional pattern . size ( ) ) ; enumeration e = additional pattern . element ( ) ; while ( e . have more element ( ) ) { f . additional pattern . add element ( ( ( pattern set ) e . next element ( ) ) . clone ( ) ) ; } f . selector = new vector ( selector ) ; return f ; } catch ( clone not support exception e ) { throw new build exception ( e ) ; } } }
public path get classpath ( ) { return classpath ; }
public parameter [ ] get params ( ) { parameter [ ] params = new parameter [ parameter . size ( ) ] ; parameter . copy into ( params ) ; return params ; }
public void integer set file mode ( int mode ) { file mode have be set = true ; this . file mode = unix stat . file_flag | mode ; }
public int get file mode ( project p ) { if ( be reference ( ) ) { return ( ( archive file set ) get ref ( p ) ) . get file mode ( p ) ; } return file mode ; }
public int get dir mode ( project p ) { if ( be reference ( ) ) { return ( ( archive file set ) get ref ( p ) ) . get dir mode ( p ) ; } return dir mode ; }
public string to string ( ) { if ( have dir & & get project ( ) ! = null ) { return super . to string ( ) ; } else if ( src ! = null ) { return src . get name ( ) ; } else { return null ; } }
public int size ( ) { assertion clause = get final reference ( ) ; return clause . get final size ( ) ; }
public sys property get system property ( ) { return sys property ; }
protect void set check ( final boolean check ) { this . check = check ; }
public string to string ( ) { string d = get description ( ) ; return d == null ? get data type name ( ) : get data type name ( ) + `` `` + d ; }
public void add configure file ( file name name ) { if ( name . get name ( ) == null ) { throw new build exception ( `` no name specify in nested file element `` ) ; } filename . add element ( name . get name ( ) ) ; }
public void add delete character ( token filter . delete character filter ) { filter reader . add element ( filter ) ; }
public synchronize void read filter from file ( file filter file ) throw build exception { if ( be reference ( ) ) { throw too many attribute ( ) ; } if ( ! filter file . exists ( ) ) { handle miss file ( `` could not read filter from file `` + filter file + `` a it do n't exist . `` ) ; } if ( filter file . be file ( ) ) { log ( `` read filter from `` + filter file , project . msg_verbose ) ; file input stream in = null ; try { property prop = new property ( ) ; in = new file input stream ( filter file ) ; prop . load ( in ) ; enumeration e = prop . property name ( ) ; vector filts = get filter ( ) ; while ( e . have more element ( ) ) { string str prop name = ( string ) e . next element ( ) ; string str value = prop . get property ( str prop name ) ; filts . add element ( new filter ( str prop name , str value ) ) ; } } catch ( exception ex ) { throw new build exception ( `` could not read filter from file : `` + filter file ) ; } finally { file utils . close ( in ) ; } } else { handle miss file ( `` must specify a file rather than a directory in `` + `` the filtersfile attribute : `` + filter file ) ; } filter hash = null ; }
public synchronize string replace token ( string line ) { return i replace token ( line ) ; }
public void add filter set ( filter set filter set ) { filter set . add element ( filter set ) ; }
public void add ( file name mapper file name mapper ) { if ( be reference ( ) ) { throw no child allow ( ) ; } if ( container == null ) { if ( type == null & & classname == null ) { container = new composite mapper ( ) ; } else { file name mapper m = get implementation ( ) ; if ( m instanceof container mapper ) { container = ( container mapper ) m ; } else { throw new build exception ( string . value of ( m ) + `` mapper implementation do not support nested mapper ! `` ) ; } } } container . add ( file name mapper ) ; }
public void set classpath ref ( reference ref ) { if ( be reference ( ) ) { throw too many attribute ( ) ; } create classpath ( ) . set refid ( ref ) ; }
public void set refid ( reference r ) throw build exception { if ( union ! = null ) { throw too many attribute ( ) ; } super . set refid ( r ) ; }
public void append prefix ( string prefix ) { property ref r = new property ref ( ) ; r . set prefix ( prefix ) ; add propertyref ( r ) ; }
protected property set get ref ( ) { return ( property set ) get check ref ( property set . class , `` propertyset `` ) ; }
public string get pattern ( project p ) { init ( p ) ; if ( be reference ( ) ) { return get ref ( p ) . get pattern ( p ) ; } set pattern ( ) ; return regexp . get pattern ( ) ; }
public int hash code ( ) { if ( be reference ( ) ) { return get check ref ( ) . hash code ( ) ; } string name = get name ( ) ; return magic * ( name == null ? null_name : name . hash code ( ) ) ; }
public void set mode ( int mode ) { check attribute allow ( ) ; this . mode = mode ; mode set = true ; }
public resource get archive ( ) { return be reference ( ) ? ( ( archive resource ) get check ref ( ) ) . get archive ( ) : archive ; }
public boolean be directory ( ) { if ( be reference ( ) ) { return ( ( resource ) get check ref ( ) ) . be directory ( ) ; } check entry ( ) ; return super . be directory ( ) ; }
public void add configure ( resource collection a ) { check child allow ( ) ; if ( resource ! = null ) { throw new build exception ( `` you must not specify more than one `` + `` resource `` ) ; } if ( a . size ( ) ! = 1 ) { throw new build exception ( `` only single argument resource collection `` + `` be support `` ) ; } resource = ( resource ) a . iterator ( ) . next ( ) ; }
public boolean be exists ( ) { return be reference ( ) ? ( ( resource ) get check ref ( ) ) . be exists ( ) : get not null file ( ) . exists ( ) ; }
public synchronize void set include ( string include ) { check attribute allow ( ) ; default pattern . set include ( include ) ; ds = null ; }
public synchronize void set includesfile ( file incl ) throw build exception { check attribute allow ( ) ; default pattern . set includesfile ( incl ) ; ds = null ; }
public synchronize boolean get defaultexcludes ( ) { return ( be reference ( ) ) ? get ref ( ) . get defaultexcludes ( ) : use default excludes ; }
public string [ ] merge include ( project p ) { return merge pattern ( p ) . get include pattern ( p ) ; }
public synchronize void add ( resource collection c ) { if ( be reference ( ) ) { throw no child allow ( ) ; } if ( c == null ) { return ; } w . add ( c ) ; }
protect synchronized void die on circular reference ( stack stk , project p ) throw build exception { if ( be check ( ) ) { return ; } if ( be reference ( ) ) { super . die on circular reference ( stk , p ) ; } else { if ( control ! = null ) { data type . invoke circular reference check ( control , stk , p ) ; } data type . invoke circular reference check ( comp , stk , p ) ; set check ( true ) ; } }
public void set size ( long l ) { size = l ; }
public long get size ( ) { return size ; }
protect synchronize string get content ( ) { if ( be reference ( ) ) { return ( ( string resource ) get check ref ( ) ) . get content ( ) ; } string value = get value ( ) ; if ( value == null ) { return value ; } return get project ( ) == null ? value : get project ( ) . replace property ( value ) ; }
public string [ ] list ( ) { if ( be reference ( ) ) { return ( ( union ) get check ref ( ) ) . list ( ) ; } collection result = get collection ( true ) ; return ( string [ ] ) ( result . to array ( new string [ result . size ( ) ] ) ) ; }
public synchronize url get u r l ( ) { if ( be reference ( ) ) { return ( ( u r l resource ) get check ref ( ) ) . get u r l ( ) ; } return url ; }
public file get zipfile ( ) { file resource r = ( file resource ) get archive ( ) ; return r . get file ( ) ; }
public boolean be select ( file basedir , string filename , file file ) { validate ( ) ; enumeration e = selector element ( ) ; boolean result ; while ( e . have more element ( ) ) { result = ( ( file selector ) e . next element ( ) ) . be select ( basedir , filename , file ) ; if ( ! result ) { return false ; } } return true ; }
public void set expression ( string theexpression ) { this . user provide expression = theexpression ; }
public void verify setting ( ) { if ( user provide expression == null ) { set error ( `` the expression attribute be require `` ) ; } }
public void verify setting ( ) { if ( contain == null ) { set error ( `` the text attribute be require `` ) ; } }
public long get millis ( ) { if ( date time ! = null ) { validate ( ) ; } return millis ; }
public void set classname ( string classname ) { this . classname = classname ; }
public void set targetdir ( file targetdir ) { this . targetdir = targetdir ; }
public boolean be valid ( ) { return `` sha `` . equal ignore case ( algorithm ) || `` md5 `` . equal ignore case ( algorithm ) ; }
public boolean be select ( file basedir , string filename , file file ) { return be select ( basedir , filename , file . get absolute path ( ) ) ; }
public void set selres ( boolean new value ) { this . select resource without input stream = new value ; }
public void set parameter ( parameter [ ] parameter ) { if ( parameter ! = null ) { for ( int i = 0 ; i < parameter . length ; i++ ) { config parameter . add ( parameter [ i ] ) ; } } }
public void target finish ( build event event ) { if ( get delay update ( ) ) { save cache ( ) ; } }
public algorithm get algorithm ( ) { return algorithm ; }
public boolean be valid ( ) { return ( cachefile ! = null ) ; }
public void put ( object key , object value ) { cache . put ( string . value of ( key ) , string . value of ( value ) ) ; cache dirty = true ; }
public void check ( ) { if ( type == null ) { throw new build exception ( `` classname attribute must be set for provider element `` , get location ( ) ) ; } if ( type . length ( ) == 0 ) { throw new build exception ( `` invalid empty classname `` , get location ( ) ) ; } }
public void set user name ( string user name ) { check tar file set attribute allow ( ) ; user name set = true ; this . user name = user name ; }
public boolean evaluate ( long t1 , long t2 ) { return evaluate ( t1 , t2 , file_utils . get file timestamp granularity ( ) ) ; }
public string get tag ( ) { return element name ; }
public void add child ( unknown element child ) { if ( child == null ) { child = new array list ( ) ; } child . add ( child ) ; }
public void set manage task ( task task ) { set manage component ( task ) ; }
public boolean be ignore error ( ) { return ignore error ; }
protect synchronized boolean contains ( file name mapper file name mapper ) { boolean foundit = false ; for ( iterator iter = mapper . iterator ( ) ; iter . have next ( ) & & ! foundit ; ) { file name mapper next = ( file name mapper ) ( iter . next ( ) ) ; foundit |= ( next == file name mapper || ( next instanceof container mapper & & ( ( container mapper ) next ) . contains ( file name mapper ) ) ) ; } return foundit ; }
public static string format elapse time ( long millis ) { long second = millis / 1000 ; long minute = second / 60 ; object [ ] args = { new long ( minute ) , new long ( second % 60 ) } ; return minute_seconds . format ( args ) ; }
public static int get phase of moon ( calendar cal ) { int day of the year = cal . get ( calendar . day_of_year ) ; int year in metonic cycle = ( ( cal . get ( calendar . year ) - 1900 ) % 19 ) + 1 ; int epact = ( 11 * year in metonic cycle + 18 ) % 30 ; if ( ( epact == 25 & & year in metonic cycle > 11 ) || epact == 24 ) { epact++ ; } return ( ( ( ( ( day of the year + epact ) * 6 ) + 11 ) % 177 ) / 22 ) & 7 ; }
public url get file u r l ( file file ) throw malformed u r l exception { return new url ( to u r i ( file . get absolute path ( ) ) ) ; }
public void copy file ( string source file , string d file , filter set collection filter , boolean overwrite ) throw i o exception { copy file ( new file ( source file ) , new file ( d file ) , filter , overwrite , false ) ; }
public boolean be symbolic link ( file parent , string name ) throw i o exception { if ( parent == null ) { file f = new file ( name ) ; parent = f . get parent file ( ) ; name = f . get name ( ) ; } file to test = new file ( parent . get canonical path ( ) , name ) ; return ! to test . get absolute path ( ) . equal ( to test . get canonical path ( ) ) ; }
public boolean be up to date ( long source time , long d time , long granularity ) { if ( d time == -1 ) { return false ; } return d time > = source time + granularity ; }
public string get default encode ( ) { input stream reader be = new input stream reader ( new input stream ( ) { public int read ( ) { return -1 ; } } ) ; try { return be . get encode ( ) ; } finally { close ( be ) ; } }
public void set handle dir sep ( boolean handle dir sep ) { this . handle dir sep = handle dir sep ; }
public static string get system id ( file file ) { return file_utils . to u r i ( file . get absolute path ( ) ) ; }
public void set manage component ( project component pc ) { this . manage pc = pc ; }
public static void set context class loader ( class loader loader ) { thread current thread = thread . current thread ( ) ; current thread . set context class loader ( loader ) ; }
public synchronize void close ( ) throw i o exception { if ( in ! = null ) { in . close ( ) ; slack = null ; in = null ; } }
public static boolean have flag ( int option , int flag ) { return ( ( option & flag ) > 0 ) ; }
public string get language ( ) { return language ; }
public string get script ( ) { return script ; }
protected class loader replace context loader ( ) { class loader orig context class loader = thread . current thread ( ) . get context class loader ( ) ; if ( get script class loader ( ) == null ) { set script class loader ( get class ( ) . get class loader ( ) ) ; } thread . current thread ( ) . set context class loader ( get script class loader ( ) ) ; return orig context class loader ; }
public void set manager ( string manager ) { this . manager = manager ; }
public void set delims be token ( boolean delims be token ) { this . delims be tokens = delims be token ; }
protect boolean have more line ( string line ) { return line . length ( ) > 3 & & line . char at ( 3 ) == '- ' ; }
public void write record ( byte [ ] buf , int offset ) throw i o exception { if ( this . debug ) { system . err . println ( `` write record : rec idx = `` + this . curr rec idx + `` blk idx = `` + this . curr blk idx ) ; } if ( this . out stream == null ) { throw new i o exception ( `` write to an input buffer `` ) ; } if ( ( offset + this . record size ) > buf . length ) { throw new i o exception ( `` record have length ' `` + buf . length + `` ' with offset ' `` + offset + `` ' which be less than the record size of ' `` + this . record size + `` ' `` ) ; } if ( this . curr rec idx > = this . recs per block ) { this . write block ( ) ; } system . arraycopy ( buf , offset , this . block buffer , ( this . curr rec idx * this . record size ) , this . record size ) ; this . curr rec idx++ ; }
public void close ( ) throw i o exception { if ( this . debug ) { system . err . println ( `` tar buffer . close buffer ( ) . `` ) ; } if ( this . out stream ! = null ) { this . flush block ( ) ; if ( this . out stream ! = system . out & & this . out stream ! = system . err ) { this . out stream . close ( ) ; this . out stream = null ; } } else if ( this . in stream ! = null ) { if ( this . in stream ! = system . in ) { this . in stream . close ( ) ; this . in stream = null ; } } }
public boolean equal ( tar entry it ) { return this . get name ( ) . equal ( it . get name ( ) ) ; }
public void set group id ( int group id ) { this . group id = group id ; }
public long get size ( ) { return this . size ; }
public void parse tar header ( byte [ ] header ) { int offset = 0 ; this . name = tar utils . parse name ( header , offset , namelen ) ; offset += namelen ; this . mode = ( int ) tar utils . parse octal ( header , offset , modelen ) ; offset += modelen ; this . user id = ( int ) tar utils . parse octal ( header , offset , uidlen ) ; offset += uidlen ; this . group id = ( int ) tar utils . parse octal ( header , offset , gidlen ) ; offset += gidlen ; this . size = tar utils . parse octal ( header , offset , sizelen ) ; offset += sizelen ; this . mod time = tar utils . parse octal ( header , offset , modtimelen ) ; offset += modtimelen ; offset += chksumlen ; this . link flag = header [ offset++ ] ; this . link name = tar utils . parse name ( header , offset , namelen ) ; offset += namelen ; this . magic = tar utils . parse name ( header , offset , magiclen ) ; offset += magiclen ; this . user name = tar utils . parse name ( header , offset , unamelen ) ; offset += unamelen ; this . group name = tar utils . parse name ( header , offset , gnamelen ) ; offset += gnamelen ; this . dev major = ( int ) tar utils . parse octal ( header , offset , devlen ) ; offset += devlen ; this . dev minor = ( int ) tar utils . parse octal ( header , offset , devlen ) ; }
public int available ( ) throw i o exception { if ( this . entry size - this . entry offset > integer . max_value ) { return integer . max_value ; } return ( int ) ( this . entry size - this . entry offset ) ; }
public void mark ( int mark limit ) { }
public void set buffer debug ( boolean debug ) { this . buffer . set debug ( debug ) ; }
public static long compute check sum ( byte [ ] buf ) { long sum = 0 ; for ( int i = 0 ; i < buf . length ; ++i ) { sum += 255 & buf [ i ] ; } return sum ; }
public static byte [ ] merge central directory data ( zip extra field [ ] data ) { int sum = 4 * data . length ; for ( int i = 0 ; i < data . length ; i++ ) { sum += data [ i ] . get central directory length ( ) . get value ( ) ; } byte [ ] result = new byte [ sum ] ; int start = 0 ; for ( int i = 0 ; i < data . length ; i++ ) { system . arraycopy ( data [ i ] . get header id ( ) . get byte ( ) , 0 , result , start , 2 ) ; system . arraycopy ( data [ i ] . get central directory length ( ) . get byte ( ) , 0 , result , start + 2 , 2 ) ; byte [ ] local = data [ i ] . get central directory data ( ) ; system . arraycopy ( local , 0 , result , start + 4 , local . length ) ; start += ( local . length + 4 ) ; } return result ; }
public int get platform ( ) { return platform ; }
public boolean equal ( object o ) { if ( o == null || ! ( o instanceof zip long ) ) { return false ; } return value == ( ( zip long ) o ) . get value ( ) ; }
public void write ( int b ) throw i o exception { byte [ ] buff = new byte [ 1 ] ; buff [ 0 ] = ( byte ) ( b & 0xff ) ; write ( buff , 0 , 1 ) ; }
public object create component ( unknown element ue , string n , string component type ) throw build exception { object component = create component ( component type ) ; if ( component instanceof task ) { task task = ( task ) component ; task . set location ( ue . get location ( ) ) ; task . set task type ( component type ) ; task . set task name ( ue . get task name ( ) ) ; task . set own target ( ue . get owning target ( ) ) ; task . init ( ) ; } return component ; }
public void add ( property set property set ) { if ( this . property set ! = null ) { throw new build exception ( `` expandproperties filter accept only one propertyset `` ) ; } this . property set = property set ; }
public static string get current prefix separator ( ) { return prefix separator . get ( ) ; }
public static string n to component name ( string ns ) { return `` attribute namespace : `` + n ; }
public void register project helper ( string helper class name ) throw build exception { register project helper ( get helper constructor ( helper class name ) ) ; }
public void copy ( ) { set ( current ( ) . copy ( ) ) ; }
public static boolean to boolean ( object value ) { if ( value instanceof boolean ) { return ( boolean ) value ; } if ( value instanceof string ) { string s = ( string ) value ; if ( project . to boolean ( s ) ) { return boolean . true ; } if ( `` off `` . equal ignore case ( s ) || `` false `` . equal ignore case ( s ) || `` no `` . equal ignore case ( s ) ) { return boolean . false ; } } return null ; }
public void set executable ( string executable ) { this . executable = executable ; }
public void set arg2 ( object arg2 ) { if ( arg2 instanceof string ) { set arg2 ( ( string ) arg2 ) ; } else { set arg2 internal ( arg2 ) ; } }
public void set output ( resource output ) { if ( this . output ! = null ) { throw new build exception ( `` can not set > 1 output target `` ) ; } this . output = output ; file provider fp = output . a ( file provider . class ) ; this . file = fp ! = null ? fp . get file ( ) : null ; }
public void set ignore invalid recipient ( boolean b ) { ignore invalid recipient = b ; }
public void set unless ( object c ) { unless condition = c ; }
public path create compiler classpath ( ) { return facade . get implementation classpath ( get project ( ) ) ; }
public void set exclude doc file sub dir ( string s ) { exclude doc file sub dir = s ; }
public process exec ( project project , string [ ] cmd , string [ ] env , file work dir ) throw i o exception { if ( work dir == null ) { return exec ( project , cmd , env ) ; } throw new i o exception ( `` can not execute a process in different `` + `` directory under this jvm `` ) ; }
public void set compress ( boolean compress ) { do compress = compress ; }
protect void append file ( vector file , directory scanner d ) { string [ ] dsfiles = d . get included file ( ) ; for ( int i = 0 ; i < dsfiles . length ; i++ ) { file . add element ( dsfiles [ i ] ) ; } }
public boolean be recurse ( ) { return recurse ; }
public boolean be verbose ( ) { return verbose ; }
public void set comment file ( string cfile ) { m cfile = cfile ; }
public boolean get notco ( ) { return m notco ; }
public void set branch ( string branch ) { m branch = branch ; }
public void set nusers ( string nusers ) { m nusers = nusers ; }
public void set no warn ( boolean nwarn ) { m nwarn = nwarn ; }
public void set master ( boolean master ) { m master = master ; }
public void set ordinary ( boolean ordinary ) { m ordinary = ordinary ; }
public void set rm all ( boolean rmall ) { m rmall = rmall ; }
public boolean get overwrite ( ) { return m overwrite ; }
public boolean get rename ( ) { return m rename ; }
public string get obj select ( ) { return mobj select ; }
public int get method ref entry ( string method class name , string method name , string method type ) { int index = -1 ; final int size = entry . size ( ) ; for ( int i = 0 ; i < size & & index == -1 ; ++i ) { object element = entry . get ( i ) ; if ( element instanceof method ref c p info ) { method ref c p info method ref entry = ( method ref c p info ) element ; if ( method ref entry . get method class name ( ) . equal ( method class name ) & & method ref entry . get method name ( ) . equal ( method name ) & & method ref entry . get method type ( ) . equal ( method type ) ) { index = i ; } } } return index ; }
public string get interface method type ( ) { return interface method type ; }
public void set classpath ( path classpath ) { if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } }
public d t d location create d t d ( ) { d t d location dtd location = new d t d location ( ) ; config . dtd location . add ( dtd location ) ; return dtd location ; }
public void set generic jar suffix ( string in string ) { this . generic jar suffix = in string ; }
protect void add vendor file ( hashtable ejb file , string dd prefix ) { ejb file . put ( meta_dir + ias_dd , new file ( get config ( ) . descriptor dir , get ias descriptor name ( ) ) ) ; }
public string get display name ( ) { return display name ; }
public void set javac ( string a string ) { javac = a string ; }
public void set orb ( string a string ) { orb = a string ; }
public void add sysproperty ( environment . variable sysp ) { sysprops . add ( sysp ) ; }
public void set w ldtd ( string in string ) { this . weblogic d t d = in string ; }
public void set quiet ( boolean quiet ) { this . quiet = quiet ; }
public void set noinform ( boolean noinform ) { this . noinform = noinform ; }
public void set rebuild ( boolean rebuild ) { this . always rebuild = rebuild ; }
public void set new c m p ( boolean new c m p ) { this . new c m p = new c m p ; }
public string to string ( ) { return name ; }
public string get extension name ( ) { return extension name ; }
public void add extension ( final extension adapter extension adapter ) { if ( be reference ( ) ) { throw no child allow ( ) ; } set checked ( false ) ; extension . add ( extension adapter ) ; }
public void set file ( final file file ) { this . library file = file ; }
public void set antfile ( final file antfile ) { this . antfile = antfile ; }
public void set destfile ( final file destfile ) { this . destfile = destfile ; }
public void set url ( final url url ) { this . url = url ; }
public void set bundle country ( string bundle country ) { this . bundle country = bundle country ; }
public void set server ( string server ) { this . server = server ; }
public void add generic ( generic hot deployment tool tool ) { tool . set task ( this ) ; vendor tool . add element ( tool ) ; }
public file get source ( ) { return source ; }
protect boolean be action valid ( ) { boolean valid = false ; string action = get task ( ) . get action ( ) ; for ( int i = 0 ; i < valid_actions . length ; i++ ) { if ( action . equal ( valid_actions [ i ] ) ) { valid = true ; break ; } } return valid ; }
public void set javacchome ( file javacc home ) { this . javacc home = javacc home ; }
public void set nodefactory ( boolean node factory ) { optional attrs . put ( node_factory , node factory ? boolean . true : boolean . false ) ; }
public void set visitor ( boolean visitor ) { optional attrs . put ( visitor , visitor ? boolean . true : boolean . false ) ; }
public class argument create class ( ) { class argument ga = new class argument ( ) ; class . add element ( ga ) ; return ga ; }
public string [ ] get class ( ) { array list al = new array list ( ) ; if ( cl ! = null ) { string tokenizer tok = new string tokenizer ( cl , `` , `` , false ) ; while ( tok . have more token ( ) ) { al . add ( tok . next token ( ) . trim ( ) ) ; } } if ( file . size ( ) > 0 ) { for ( enumeration e = file . element ( ) ; e . have more element ( ) ; ) { file set fs = ( file set ) e . next element ( ) ; string [ ] include class = f . get directory scanner ( get project ( ) ) . get included file ( ) ; for ( int i = 0 ; i < include class . length ; i++ ) { string class name = include class [ i ] . replace ( '\\ ' , ' . ' ) . replace ( '/ ' , ' . ' ) . substring ( 0 , include class [ i ] . length ( ) - 6 ) ; al . add ( class name ) ; } } } enumeration e = class . element ( ) ; while ( e . have more element ( ) ) { class argument arg = ( class argument ) e . next element ( ) ; al . add ( arg . get name ( ) ) ; } return ( string [ ] ) al . to array ( new string [ al . size ( ) ] ) ; }
public path get classpath ( ) { return classpath ; }
public path get bootclasspath ( ) { return bootclasspath ; }
protect void add arg ( commandline java cmd , string argument ) { if ( argument ! = null & & argument . length ( ) ! = 0 ) { cmd . create argument ( ) . set value ( argument ) ; } }
public boolean implement own dependency checking ( ) { return false ; }
public int get verbose ( ) { return verbose ; }
public void set uribase ( file uribase ) { log ( `` uribase be currently an unused parameter `` , project . msg_warn ) ; }
public path create compilerclasspath ( ) { if ( compiler classpath == null ) { compiler classpath = new path ( get project ( ) ) ; } return compiler classpath . create path ( ) ; }
public web app parameter get web app ( ) { return web app ; }
public void delete empty java file ( ) { if ( java file ! = null ) { enumeration e = java file . element ( ) ; while ( e . have more element ( ) ) { file file = ( file ) e . next element ( ) ; if ( file . exists ( ) & & file . length ( ) == 0 ) { log ( `` delete empty output file `` + file ) ; file . delete ( ) ; } } } }
public string get encode ( ) { return encode ; }
public void set non proxy host ( string non proxy host ) { this . non proxy host = non proxy host ; }
public string get revision ( ) { return revision ; }
public void add pvcsproject ( pvcs project p ) { pvcs project . add element ( p ) ; }
public void set to extension ( string to ) { to extension = to ; }
protect execute get execute ( commandline to execute , execute stream handler streamhandler ) { execute exe = new execute ( streamhandler , null ) ; exe . set ant run ( get project ( ) ) ; if ( top dir == null ) { top dir = get project ( ) . get base dir ( ) ; } exe . set work directory ( top dir ) ; exe . set commandline ( to execute . get commandline ( ) ) ; return exe ; }
protect void set feature if support ( string feature , boolean value ) { try { get xml reader ( ) . set feature ( feature , value ) ; } catch ( s a x not recognize exception e ) { log ( `` not recognizied : `` + feature , project . msg_verbose ) ; } catch ( s a x not support exception e ) { log ( `` not support : `` + feature , project . msg_verbose ) ; } }
public void execute ( ) { get script ( ) . execute script ( attribute , nested element map , this ) ; }
public void set verbose ( boolean verbose ) { this . verbose = verbose ; }
protect void set internal comment ( string text ) { comment = text ; }
protect string get no compress ( ) { return no compress ? flag_no_compression : `` `` ; }
public void set recursive ( boolean recursive ) { super . set internal recursive ( recursive ) ; }
public void add application ( sequential sequence ) { log override ( `` application `` , application ) ; application = sequence ; }
public void add teardown ( sequential sequence ) { log override ( `` teardown `` , teardown ) ; teardown = sequence ; }
public void set fail on teardown error ( boolean fail on teardown error ) { this . fail on teardown error = fail on teardown error ; }
public void set factory ( string name ) { factory name = name ; }
public void add param ( string name , string value ) { params . put ( name , value ) ; }
public void warning ( transformer exception e ) { if ( ! suppress warning ) { log error ( e , `` warn `` ) ; } }
public void set addsourcefile ( boolean b ) { throw new build exception ( get task type ( ) + `` doesn\'t support the addsourcefile attribute `` , get location ( ) ) ; }
public void execute ( ) throw build exception { int result = 0 ; commandline command line = build cmd line ( ) ; result = run ( command line ) ; if ( execute . be failure ( result ) & & get fail on error ( ) ) { string msg = `` fail executing : `` + format command line ( command line ) + `` with a return code of `` + result ; throw new build exception ( msg , get location ( ) ) ; } }
protect void set internal date ( final string date ) { this . date = date ; }
protect void set internal from date ( final string from date ) { this . from date = from date ; }
public void set get local copy ( boolean get ) { super . set internal get local copy ( get ) ; }
public void set label ( string label ) { super . set internal label ( label ) ; }
public void set user ( string user ) { super . set internal user ( user ) ; }
public void set date format ( string date format ) { super . set internal date format ( new simple date format ( date format ) ) ; }
public void set version ( string version ) { super . set internal version ( version ) ; }
public void set comment ( string comment ) { super . set internal comment ( comment ) ; }
public void set readonly ( boolean value ) { add arg ( value , attr_readonly ) ; }
public void set class name ( string class name ) { reader class name = class name ; }
public void set file ( file file ) { this . file = file ; }
public property create property ( ) { final property prop = new property ( ) ; property list . add element ( prop ) ; return prop ; }
protect string [ ] preprocess compiler args ( string [ ] compiler args ) { return filter jvm compiler args ( compiler args ) ; }
public file get output dir ( ) { if ( get destdir ( ) ! = null ) { return get destdir ( ) ; } return get base ( ) ; }
public boolean be force ( ) { return force ; }
public void set error property ( string error property ) { this . error property = error property ; }
public long calculate check every millis ( ) { return check every * check every multiplier ; }
public void add sysproperty ( environment . variable sysp ) { sys property . add variable ( sysp ) ; }
public void set create unicode extra field ( unicode extra field b ) { create unicode extra field = b ; }
public object clone ( ) { return new classfile set ( be reference ( ) ? ( classfile set ) ( get ref ( get project ( ) ) ) : this ) ; }
public void add map name ( string mapping ) { file . add ( map ) ; }
public string get filename ( ) { return filename ; }
public file get file ( ) { return file ; }
public < t > t a ( class < t > clazz ) { if ( appendable . class . be assignable from ( clazz ) ) { if ( be append support ( ) ) { final appendable a = get resource ( ) . a ( appendable . class ) ; if ( a ! = null ) { return clazz . cast ( new appendable ( ) { public output stream get append output stream ( ) throw i o exception { output stream out = a . get append output stream ( ) ; if ( out ! = null ) { out = wrap stream ( out ) ; } return out ; } } ) ; } } return null ; } return file provider . class . be assignable from ( clazz ) ? null : get resource ( ) . a ( clazz ) ; }
protect boolean filter resource ( resource r ) { return false ; }
public synchronize void add ( resource collection c ) throw build exception { if ( be reference ( ) ) { throw no child allow ( ) ; } if ( nested ! = null ) { throw new build exception ( `` only one resource collection can be `` + `` nest into mappedresources `` , get location ( ) ) ; } set checked ( false ) ; cache coll = null ; nest = c ; }
public void add ( resource collection rc ) { if ( be reference ( ) ) { throw no child allow ( ) ; } text document . add ( rc ) ; set check ( false ) ; }
public string get regex ( ) { return regex ; }
public synchronize int size ( ) { int sz = get resource collection ( ) . size ( ) ; int ct = get valid count ( ) ; return sz < ct ? sz : ct ; }
protect int get valid count ( ) { int ct = get count ( ) ; if ( ct < 0 ) { throw new build exception ( bad_count ) ; } return ct ; }
public void set unless ( object unless property ) { this . unless condition = unless property ; }
public tokenized path rtrim wildcard token ( ) { string builder sb = new string builder ( ) ; int new len = 0 ; for ( ; new len < tokenized pattern . length ; new len++ ) { if ( selector utils . have wildcards ( tokenized pattern [ new len ] ) ) { break ; } if ( new len > 0 & & sb . char at ( sb . length ( ) - 1 ) ! = file . separator char ) { sb . append ( file . separator ) ; } sb . append ( tokenized pattern [ new len ] ) ; } if ( new len == 0 ) { return tokenized path . empty_path ; } string [ ] new pat = new string [ new len ] ; system . arraycopy ( tokenized pattern , 0 , new pat , 0 , new len ) ; return new tokenized path ( sb . to string ( ) , new pat ) ; }
public static string flatten to string ( collection < ? > c ) { final string builder sb = new string builder ( ) ; for ( object o : c ) { if ( sb . length ( ) ! = 0 ) { sb . append ( `` , `` ) ; } sb . append ( o ) ; } return sb . to string ( ) ; }
public void add root class ( string class name ) { if ( class name == null ) { return ; } if ( ! root class . contains ( class name ) ) { root class . add element ( class name ) ; } }
public static string safe read fully ( reader reader ) throw i o exception { string ret = read fully ( reader ) ; return ret == null ? `` `` : ret ; }
public static print stream wrap system err ( ) { return wrap ( system . err ) ; }
public string get manager name ( ) { return `` javax `` ; }
public static int a option ( boolean case sensitive ) { return a option ( case sensitive , false , false ) ; }
public static file resource a file resource ( file provider file provider ) { if ( file provider instanceof file resource || file provider == null ) { return ( file resource ) file provider ; } file resource result = new file resource ( file provider . get file ( ) ) ; result . set project ( project . get project ( file provider ) ) ; return result ; }
public void add text ( string text ) { this . text = text ; }
public boolean be dangle symbolic link ( string name ) throw i o exception { return be dangle symbolic link ( new file ( name ) ) ; }
public synchronize build exception get build exception ( ) { return build exception ; }
public boolean be extend ( ) { return be extend ; }
public boolean be character device ( ) { return link flag == lf_chr ; }
public boolean be block device ( ) { return link flag == lf_blk ; }
public boolean push encode char ( byte buffer bb , char c ) { if ( c > = 0 & & c < 128 ) { bb . put ( ( byte ) c ) ; return true ; } simple8 bit char r = this . encode high char ( c ) ; if ( r == null ) { return false ; } bb . put ( r . code ) ; return true ; }
public void remove extra field ( zip short type ) { if ( extra field == null ) { throw new java . util . no such element exception ( ) ; } if ( extra field . remove ( type ) == null ) { throw new java . util . no such element exception ( ) ; } set extra ( ) ; }
public lexer action get action ( ) { return action ; }
public final void set precedence dfa ( boolean precedence dfa ) { if ( precedence dfa ! = be precedence dfa ( ) ) { throw new unsupported operation exception ( `` the precedence dfa field can not change after a dfa be construct . `` ) ; } }
public boolean equal ( object o ) { if ( o == this ) { return true ; } if ( ! ( o instanceof integer list ) ) { return false ; } integer list other = ( integer list ) o ; if ( _size ! = other . _size ) { return false ; } for ( int i = 0 ; i < _size ; i++ ) { if ( _data [ i ] ! = other . _data [ i ] ) { return false ; } } return true ; }
public boolean start before disjoint ( interval other ) { return this . a < other . a & & this . b < other . a ; }
public static int initialize ( ) { return initialize ( default_seed ) ; }
public static < t > int hash code ( t [ ] data , int seed ) { int hash = initialize ( seed ) ; for ( t value : data ) { hash = update ( hash , value ) ; } hash = finish ( hash , data . length ) ; return hash ; }
public void set token stream ( token stream input ) { this . _input = null ; reset ( ) ; this . _input = input ; }
public void enter rule ( parser rule context localctx , int state , int rule index ) { set state ( state ) ; _ctx = localctx ; _ctx . start = _input . lt ( 1 ) ; if ( _build parse tree ) add context to parse tree ( ) ; if ( _parse listener ! = null ) trigger enter rule event ( ) ; }
protect t default result ( ) { return null ; }
protected boolean should visit next child ( rule node node , t current result ) { return true ; }
public static tree find node such that ( tree t , predicate < tree > pred ) { if ( pred . test ( t ) ) return t ; if ( t==null ) return null ; int n = t . get child count ( ) ; for ( int i = 0 ; i < n ; i++ ) { tree u = find node such that ( t . get child ( i ) , pred ) ; if ( u ! =null ) return u ; } return null ; }
public static annotation instance get parameter annotation ( method info method , dot name annotation ) { for ( annotation instance annotation instance : method . annotation ( ) ) { if ( annotation instance . target ( ) . kind ( ) . equal ( kind . method_parameter ) & & annotation instance . name ( ) . equal ( annotation ) ) { return annotation instance ; } } return null ; }
public void visit source ( final string source , final string debug ) { if ( cv ! = null ) { cv . visit source ( source , debug ) ; } }
public annotation visitor visit type annotation ( final int type ref , final type path type path , final string descriptor , final boolean visible ) { if ( api < opcodes . asm5 ) { throw new unsupported operation exception ( `` this feature require asm5 `` ) ; } if ( cv ! = null ) { return cv . visit type annotation ( type ref , type path , descriptor , visible ) ; } return null ; }
public string get descriptor ( ) { return descriptor ; }
public void visit end ( ) { if ( fv ! = null ) { fv . visit end ( ) ; } }
public string get desc ( ) { return descriptor ; }
public annotation visitor visit annotation ( final string descriptor , final boolean visible ) { if ( mv ! = null ) { return mv . visit annotation ( descriptor , visible ) ; } return null ; }
public void visit annotable parameter count ( final int parameter count , final boolean visible ) { if ( mv ! = null ) { mv . visit annotable parameter count ( parameter count , visible ) ; } }
public annotation visitor visit parameter annotation ( final int parameter , final string descriptor , final boolean visible ) { if ( mv ! = null ) { return mv . visit parameter annotation ( parameter , descriptor , visible ) ; } return null ; }
public void visit code ( ) { if ( mv ! = null ) { mv . visit code ( ) ; } }
public void visit inner class type ( final string name ) { }
public annotation visitor visit type annotation ( final int type ref , final type path type path , final string descriptor , final boolean visible ) { if ( delegate ! = null ) { return delegate . visit type annotation ( type ref , type path , descriptor , visible ) ; } return null ; }
public void visit permit subclass ( final string permit subclass ) { if ( api < opcodes . asm9 ) { throw new unsupported operation exception ( `` permit subclass require asm9 `` ) ; } if ( cv ! = null ) { cv . visit permit subclass ( permitted subclass ) ; } }
public list < try catch block node > get handler ( final int insn index ) { return handler [ insn index ] ; }
protect boolean new control flow exception edge ( final int insn index , final int successor index ) { return true ; }
public string map module name ( final string name ) { return name ; }
public abstract insn node get first ( ) { return first insn ; }
public abstract insn node get ( final int index ) { if ( index < 0 || index > = size ) { throw new index out of bound exception ( ) ; } if ( cache == null ) { cache = to array ( ) ; } return cache [ index ] ; }
public void accept ( final method visitor method visitor ) { abstract insn node current insn = first insn ; while ( current insn ! = null ) { current insn . accept ( method visitor ) ; current insn = current insn . next insn ; } }
public void insert before ( final abstract insn node next insn , final insn list insn list ) { if ( insn list . size == 0 ) { return ; } size += insn list . size ; abstract insn node first insn list element = insn list . first insn ; abstract insn node last insn list element = insn list . last insn ; abstract insn node previous insn = next insn . previous insn ; if ( previous insn == null ) { first insn = first insn list element ; } else { previous insn . next insn = first insn list element ; } next insn . previous insn = last insn list element ; last insn list element . next insn = next insn ; first insn list element . previous insn = previous insn ; cache = null ; insn list . remove all ( false ) ; }
public void accept ( final method visitor method visitor , final boolean visible ) { label [ ] start label = new label [ this . start . size ( ) ] ; label [ ] end label = new label [ this . end . size ( ) ] ; int [ ] index = new int [ this . index . size ( ) ] ; for ( int i = 0 , n = start label . length ; i < n ; ++i ) { start label [ i ] = this . start . get ( i ) . get label ( ) ; end label [ i ] = this . end . get ( i ) . get label ( ) ; index [ i ] = this . index . get ( i ) ; } accept ( method visitor . visit local variable annotation ( type ref , type path , start label , end label , index , desc , visible ) ) ; }
public void accept ( final module visitor module visitor ) { module visitor . visit require ( module , access , version ) ; }
protect self in hexadecimal ( ) { info . use hexadecimal representation ( ) ; return myself ; }
public self be upper case ( ) { character . assert upper case ( info , actual ) ; return myself ; }
public self do not contain entry ( k key , v value ) { map . assert do not contain ( info , actual , array ( entry ( key , value ) ) ) ; return myself ; }
public self contain exactly ( @ suppress warning ( `` unchecked `` ) element . . . value ) { array . assert contain exactly ( info , actual , value ) ; return myself ; }
public self contains ( element value , index index ) { array . assert contains ( info , actual , value , index ) ; return myself ; }
public self start with ( @ suppress warning ( `` unchecked `` ) element . . . sequence ) { array . assert start with ( info , actual , sequence ) ; return myself ; }
public self be not ( condition < ? super element > condition ) { array . assert be not ( info , actual , condition ) ; return myself ; }
public self use recursive field by field element comparator ( ) { return use extend by type element comparator ( new recursive field by field comparator ( comparators for element property or field name , get comparators for element property or field type ( ) ) ) ; }
public self use element comparator ignore field ( string . . . field ) { return use extend by type element comparator ( new ignore field comparator ( comparators for element property or field name , get comparators for element property or field type ( ) , field ) ) ; }
public void fail ( string failure message ) { assertion error error = failure . instance ( ) . failure ( failure message ) ; proxy . collect error ( error ) ; }
protected list < throwable > decorate error collect ( list < throwable > error ) { return add line number to error message ( error ) ; }
public static list < string > line of ( file file ) { return file . line of ( file , charset . default charset ( ) ) ; }
public atomic boolean assert be false ( ) { be not null ( ) ; assert equal ( false ) ; return myself ; }
public atomic integer array assert have array ( int [ ] expect ) { array . assert contain exactly ( info , array , expect ) ; return myself ; }
public atomic integer array assert have size ( int expect ) { array . assert have size ( info , array , expect ) ; return myself ; }
public atomic integer array assert contain only once ( int . . . value ) { array . assert contain only once ( info , array , value ) ; return myself ; }
public atomic integer array assert do not contain ( int value , index index ) { array . assert do not contain ( info , array , value , index ) ; return myself ; }
public atomic integer assert have value between ( int start inclusive , int end inclusive ) { be not null ( ) ; integer . assert be between ( get writable assertion info ( ) , actual . get ( ) , start inclusive , end inclusive ) ; return myself ; }
public atomic integer assert have value ( int expect value ) { be not null ( ) ; int actual value = actual . get ( ) ; if ( ! object . get comparison strategy ( ) . be equal ( actual value , expect value ) ) { throw assertion error ( should have value ( actual , expect value ) ) ; } return myself ; }
public atomic long array assert contain exactly in any order ( long . . . value ) { array . assert contain exactly in any order ( info , array , value ) ; return myself ; }
public atomic long assert do not have value ( long expect value ) { be not null ( ) ; long actual value = actual . get ( ) ; if ( object . get comparison strategy ( ) . be equal ( actual value , expect value ) ) { throw assertion error ( should not contain value ( actual , expect value ) ) ; } return myself ; }
public atomic reference array assert < t > have same size a ( object other ) { array . assert have same size a ( info , array , other ) ; return myself ; }
public atomic reference array assert < t > contain only ( @ suppress warning ( `` unchecked `` ) t . . . value ) { array . assert contain only ( info , array , value ) ; return myself ; }
public atomic reference array assert < t > start with ( @ suppress warning ( `` unchecked `` ) t . . . sequence ) { array . assert start with ( info , array , sequence ) ; return myself ; }
public atomic reference array assert < t > be not ( condition < ? super t > condition ) { array . assert be not ( info , array , condition ) ; return myself ; }
public atomic reference array assert < t > have at least ( int time , condition < ? super t > condition ) { array . assert have at least ( info , array , time , condition ) ; return myself ; }
public void assert all ( ) { list < throwable > error = error collect ( ) ; if ( ! error . be empty ( ) ) throw best multiple assertion error ( error ) ; }
protect final collection < condition < ? super t > > condition ( ) { return unmodifiable collection ( condition ) ; }
public void assert not empty ( assertion info info , boolean [ ] actual ) { array . assert not empty ( info , failure , actual ) ; }
public void assert have same size a ( assertion info info , boolean [ ] actual , object [ ] other ) { array . assert have same size a ( info , actual , other ) ; }
public < t extend comparable < ? super t > > void assert less than or equal to ( assertion info info , t actual , t other ) { assert not null ( info , actual ) ; if ( ! be great than ( actual , other ) ) return ; throw failure . failure ( info , should be less or equal ( actual , other , comparison strategy ) ) ; }
public void enable print thread dump ( ) { print thread dump = true ; }
public void assert be relative ( assertion info info , file actual ) { if ( ! be absolute path ( info , actual ) ) return ; throw failure . failure ( info , should be relative path ( actual ) ) ; }
public void assert be negative ( assertion info info , number actual ) { assert less than ( info , actual , zero ( ) ) ; }
public void assert contains ( assertion info info , object [ ] actual , object value , index index ) { array . assert contains ( info , failure , actual , value , index ) ; }
public void assert contain sequence ( assertion info info , object [ ] actual , object [ ] sequence ) { array . assert contain sequence ( info , failure , actual , sequence ) ; }
public void assert end with ( assertion info info , object [ ] actual , object first , object [ ] rest ) { array . assert end with ( info , failure , actual , first , rest ) ; }
public void assert be not instance of any ( assertion info info , object actual , class < ? > [ ] type ) { if ( ! object be instance of one of give class ( actual , type , info ) ) return ; throw failure . failure ( info , should not be instance of any ( actual , type ) ) ; }
public void assert do not have same class a ( assertion info info , object actual , object other ) { if ( have same class ( actual , other , info ) ) throw failure . failure ( info , should not have same class ( actual , other ) ) ; }
public static date format new iso date time with ms format ( ) { return strict date format for pattern ( `` yyyy- m m-dd ' t ' h h : mm : s . sss `` ) ; }
public static synchronize string format a datetime with m ( date date ) { return date == null ? null : iso_date_time_format_with_ms . format ( date ) ; }
public static file new temporary file ( ) { string temp file name = concat ( uuid . random u u i d ( ) . to string ( ) , `` . txt `` ) ; return new file ( concat ( temporary folder path ( ) , temp file name ) ) ; }
public static void check argument ( boolean expression , string error message template , object . . . error message args ) { if ( ! expression ) throw new illegal argument exception ( format ( error message template , error message args ) ) ; }
public static void check state ( boolean expression , string error message template , object . . . error message args ) { if ( ! expression ) { throw new illegal state exception ( format ( error message template , error message args ) ) ; } }
public self have size less than or equal to ( int boundary ) { array . assert have size less than or equal to ( info , actual , boundary ) ; return myself ; }
public self have size great than ( int boundary ) { array . assert have size great than ( info , actual , boundary ) ; return myself ; }
public static abstract byte array assert < ? > give ( byte [ ] actual ) { return assume that ( actual ) ; }
public static abstract char array assert < ? > give ( char [ ] actual ) { return assume that ( actual ) ; }
public static < t > proxyable object array assert < t > give ( t [ ] actual ) { return assume that ( actual ) ; }
public self ignore collection order ( ) { recursive comparison configuration . ignore collection order ( true ) ; return myself ; }
public void set additional date format ( list < date format > additional date format ) { this . additional date format = additional date format ; }
public static error message factory should not be null ( ) { return instance ; }
public static should not be null should not be null ( string label ) { return new should not be null ( format ( `` % n expect % s not to be null `` , label ) ) ; }
public void assert have size great than ( assertion info info , boolean [ ] actual , int boundary ) { array . assert have size great than ( info , actual , boundary ) ; }
protect boolean have already an unambiguous to string of ( object obj ) { for ( int i = 0 ; i < type_with_unambiguous_representation . length ; i++ ) { if ( type_with_unambiguous_representation [ i ] . be instance ( obj ) ) return true ; } return false ; }
public self contain exactly in any order ( boolean [ ] value ) { require non null parameter ( value , `` value `` ) ; array . assert contain exactly in any order ( info , actual , to primitive boolean array ( value ) ) ; return myself ; }
public self be finite ( ) { double . assert be finite ( info , actual ) ; return myself ; }
public atomic reference assert < v > do not have value ( v non expect value ) { be not null ( ) ; v actual value = actual . get ( ) ; if ( object . get comparison strategy ( ) . be equal ( actual value , non expect value ) ) { throw assertion error ( should not contain value ( actual , non expect value ) ) ; } return myself ; }
public long2 d array assert do not contain ( long [ ] value , index index ) { long2d array . assert do not contain ( info , actual , value , index ) ; return myself ; }
public self ignore all overridden equal ( ) { recursive comparison configuration . ignore all overridden equal ( ) ; return myself ; }
public void set max element for printing ( int max element for print ) { this . max element for print = max element for printing ; }
public void assert have same dimension a ( assertion info info , boolean [ ] [ ] actual , object other ) { array . assert have same dimension a ( info , actual , other ) ; }
public self be not close to ( int expect , offset < integer > offset ) { integer . assert be not close to ( info , actual , expect , offset ) ; return myself ; }
public self contain exactly ( @ suppress warning ( `` unchecked `` ) element . . . value ) { array . assert contain exactly ( info , actual , value ) ; return myself ; }
public self be not close to ( short expect , offset < short > offset ) { short . assert be not close to ( info , actual , expect , offset ) ; return myself ; }
public atomic reference array assert < t > be not ( condition < ? super t > condition ) { array . assert be not ( info , array , condition ) ; return myself ; }
public static < t > t cast node ( final object node , final class < t > node class ) { try { return node class . cast ( node ) ; } catch ( final class cast exception e ) { throw new invalid node type exception ( node , node class ) ; } }
public condition factory poll interval ( duration poll interval ) { return new condition factory ( alias , timeout , poll interval , poll delay , catch uncaught exception , condition evaluation listener ) ; }
public static object get last target ( ) { if ( last target == null ) { throw new illegal state exception ( no_method_call_recorded_message ) ; } return last target ; }
public static boolean be class ( object argument ) { return argument instanceof class < ? > ; }
public condition factory alias ( string alias ) { return new condition factory ( alias , timeout constraint , poll interval , poll delay , catch uncaught exception , exception ignorer , condition evaluation listener , executor lifecycle ) ; }
public condition factory ignore exception instance of ( final class < ? extend throwable > exception type ) { if ( exception type == null ) { throw new illegal argument exception ( `` exception type can not be null `` ) ; } return new condition factory ( alias , timeout constraint , poll interval , poll delay , catch uncaught exception , new predicate exception ignorer ( e - > exception type . be assignable from ( e . get class ( ) ) ) , condition evaluation listener , executor lifecycle ) ; }
public condition factory ignore exception ( final class < ? extend throwable > exception type ) { if ( exception type == null ) { throw new illegal argument exception ( `` exception can not be null `` ) ; } return new condition factory ( alias , timeout constraint , poll interval , poll delay , catch uncaught exception , new predicate exception ignorer ( e - > e . get class ( ) . equal ( exception type ) ) , condition evaluation listener , executor lifecycle ) ; }
protect int fibonacci ( int value ) { return fib ( value , 1 , 0 ) ; }
public iterative poll interval start duration ( duration duration ) { return new iterative poll interval ( function , duration ) ; }
public modifier adjustment with invokable modifier ( element matcher < ? super method description > matcher , modifier contributor . for method . . . modifier contributor ) { return with invokable modifier ( matcher , arrays . a list ( modifier contributor ) ) ; }
public dynamic type . builder < ? > rebase ( package a package , class file locator class file locator ) { return rebase ( new package description . for loaded package ( a package ) , class file locator ) ; }
public boolean be final ( ) { return this == final ; }
public static annotation retention of ( boolean enable ) { return enable ? enable : disable ; }
public static assigner configurable value ( type description fix value ) { return new for pool value ( class constant . of ( fixed value ) , type description . class ) ; }
public static hash code method use super class offset ( ) { return new hash code method ( offset provider . for super method call . instance ) ; }
public invoke dynamic with method argument ( ) { return new invoke dynamic ( bootstrap method , handle argument , invocation provider . append argument ( invocation provider . argument provider . for intercepted method parameter . instance ) , termination handler , assigner , type ) ; }
public method call with field ( string . . . name ) { return with field ( field locator . for class hierarchy . factory . instance , name ) ; }
public field set set field ( field field ) { return set field ( new field description . for loaded field ( field ) ) ; }
public static < t > element matcher . junction < t > not ( element matcher < ? super t > matcher ) { return new negate matcher < t > ( matcher ) ; }
public static < t extend method description > element matcher . junction < t > be getter ( element matcher < ? super type description > matcher ) { return be generic getter ( erasure ( matcher ) ) ; }
public static < t extend method description > element matcher . junction < t > have signature ( method description . signature token token ) { return new signature token matcher < t > ( be ( token ) ) ; }
public static < t extend type description > element matcher . junction < t > inherits annotation ( class < ? > type ) { return inherits annotation ( type description . for loaded type . of ( type ) ) ; }
public static < t extend class loader > element matcher . junction < t > be child of ( class loader class loader ) { return class loader == bootstrap_classloader ? new boolean matcher < t > ( true ) : element matcher . < t > have child ( be ( class loader ) ) ; }
public void expunge stale entry ( ) { reference < ? > reference ; while ( ( reference = poll ( ) ) ! = null ) { cache . remove ( reference ) ; } }
public static class reader of ( byte [ ] binary representation ) { if ( experimental ) { class file version class file version = class file version . of class file ( binary representation ) ; if ( class file version . be great than ( class file version . java_v14 ) ) { binary representation [ 6 ] = ( byte ) ( class file version . java_v14 . get major version ( ) > > > 8 ) ; binary representation [ 7 ] = ( byte ) class file version . java_v14 . get major version ( ) ; class reader class reader = new class reader ( binary representation ) ; binary representation [ 6 ] = ( byte ) ( class file version . get major version ( ) > > > 8 ) ; binary representation [ 7 ] = ( byte ) class file version . get major version ( ) ; return class reader ; } else { return new class reader ( binary representation ) ; } } else { return new class reader ( binary representation ) ; } }
protect void on visit method insn ( int opcode , string owner , string name , string descriptor , boolean be interface ) { super . visit method insn ( opcode , owner , name , descriptor , be interface ) ; }
protect void on visit lookup switch insn ( label default target , int [ ] key , label [ ] label ) { super . visit lookup switch insn ( default target , key , label ) ; }
public static < t > element matcher . junction < t > of ( boolean match ) { return ( element matcher . junction < t > ) ( match ? true : false ) ; }
public stack manipulation to unsigned ( ) { return unsigned ; }
public static void attach ( file agent jar , string process id , attachment provider attachment provider ) { attach ( agent jar , process id , without_argument , attachment provider ) ; }
public static instrumentation install ( ) { return install ( attachment provider . default ) ; }
public static void attach ( file agent jar , string process id , attachment provider attachment provider ) { attach ( agent jar , process id , without_argument , attachment provider ) ; }
public caffeine < k , v > refresh after write ( @ non null duration duration ) { return refresh after write ( saturate to nanos ( duration ) , time unit . nanosecond ) ; }
public void ensure capacity ( @ non negative long maximum size ) { require argument ( maximum size > = 0 ) ; int maximum = ( int ) math . min ( maximum size , integer . max_value > > > 1 ) ; if ( ( table ! = null ) & & ( table . length > = maximum ) ) { return ; } table = new long [ ( maximum == 0 ) ? 1 : caffeine . ceiling power of two ( maximum ) ] ; table mask = math . max ( 0 , table . length - 1 ) ; sample size = ( maximum size == 0 ) ? 10 : ( 10 * maximum ) ; if ( sample size < = 0 ) { sample size = integer . max_value ; } size = 0 ; }
public void set weight ( @ non negative int weight ) { }
public void set variable time ( long time ) { }
public long get access time ( ) { return 0l ; }
public static void get unsigned ( byte buffer b , @ unsigned byte [ ] b ) { b . get ( b ) ; }
public static @ unsigned long to unsigned long ( @ unsigned byte b ) { return ( ( long ) b ) & 0xff l ; }
public static float to float ( @ unsigned int i ) { return to unsigned big integer ( to unsigned long ( i ) ) . float value ( ) ; }
public static double to double ( @ unsigned byte b ) { return to unsigned big integer ( to unsigned long ( b ) ) . double value ( ) ; }
public static double to double ( @ unsigned int i ) { return to unsigned big integer ( to unsigned long ( i ) ) . double value ( ) ; }
public static @ unsigned int int from float ( float f ) { assert f > = 0 ; return ( int ) f ; }
public static list < literal kind > all literal kind ( ) { list < literal kind > list = new array list < > ( arrays . a list ( value ( ) ) ) ; list . remove ( all ) ; list . remove ( primitive ) ; return list ; }
public static conversion category from conversion char ( char c ) { for ( conversion category v : new conversion category [ ] { general , char , int , float , time } ) { if ( v . char . contains ( string . value of ( c ) ) ) { return v ; } } throw new illegal argument exception ( `` bad conversion character `` + c ) ; }
public static @ nullable string regex error ( string s ) { return regex error ( s , 0 ) ; }
public static int compare unsigned ( @ unsigned byte x , @ unsigned byte y ) { return integer . compare unsigned ( byte . to unsigned int ( x ) , byte . to unsigned int ( y ) ) ; }
public member resolver set include lang object ( boolean state ) { _cfg include lang object = state ; return this ; }
public resolve type get type ( ) { return _type ; }
public list < resolve type > get type parameter ( ) { return _type binding . get type parameter ( ) ; }
public string get brief description ( ) { string builder sb = new string builder ( ) ; return append brief description ( sb ) . to string ( ) ; }
protect resolve type [ ] type parameter array ( ) { return _types ; }
public static boolean be self reference ( resolve type type ) { return ( type instanceof resolve recursive type ) ; }
public resolve type get parent class ( ) { return null ; }
public void resolve self reference ( resolve type resolve ) { if ( _self refs ! = null ) { for ( resolve recursive type ref : _self refs ) { ref . set reference ( resolve ) ; } } }
public void register immutable ( final class < ? > . . . c ) { for ( final class < ? > cl : c ) { ignore . add ( cl ) ; } }
public void set extra immutables ( final set < class < ? > > set ) { ignore . add all ( set ) ; }
protect < t > t new instance ( final class < t > c ) { return instantiation strategy . new instance ( c ) ; }
protected list < field > all field ( final class < ? > c ) { list < field > l = field cache . get ( c ) ; if ( l == null ) { l = new link list < field > ( ) ; final field [ ] field = c . get declared field ( ) ; add all ( l , field ) ; class < ? > sc = c ; while ( ( sc = sc . get superclass ( ) ) ! = object . class & & sc ! = null ) { add all ( l , sc . get declared field ( ) ) ; } field cache . put if absent ( c , l ) ; } return l ; }
public void set dump clone class ( final boolean dump clone class ) { this . dump clone class = dump clone class ; }
public void abort ( ) { abort ( new i o exception ( `` abort `` ) ) ; }
public void set option ( string name , object value ) { string prefix = get option prefix ( ) ; if ( prefix ! = null & & prefix . length ( ) > 0 & & ! name . start with ( prefix ) ) { name = prefix + `` . `` + name ; } _options . put ( name , value ) ; }
public void set and share ( t new object , result < t > callback ) { if ( new object == null ) { throw new null pointer exception ( ) ; } data < t > data = new data < > ( 4 , callback ) ; data . put ( info . oort_url_field , get oort ( ) . get u r l ( ) ) ; data . put ( info . name_field , get name ( ) ) ; data . put ( info . object_field , serialize ( new object ) ) ; if ( logger . be debug enable ( ) ) { logger . debug ( `` share { } `` , data ) ; } bayeux server bayeux server = oort . get bayeux server ( ) ; bayeux server . get channel ( get channel name ( ) ) . publish ( get local session ( ) , data , promise . noop ( ) ) ; }
public void send message ( string to user id , string to channel , object data ) { send message ( set . of ( to user id ) , to channel , data ) ; }
public string to url parameter ( ) { string builder sb = new string builder ( ) ; if ( from time ! = null ) { sb . append ( `` & `` + from_time_url_key + `` = `` + from time ) ; } if ( to time ! = null ) { sb . append ( `` & `` + to_time_url_key + `` = `` + to time ) ; } if ( stream ! = null ) { for ( stream stream : stream ) { sb . append ( `` & `` + streams_url_key + `` = `` + stream . get id ( ) ) ; } } if ( tags ! = null ) { for ( string string : tag ) { sb . append ( `` & `` + tags_url_key + `` = `` + string ) ; } } if ( type ! = null ) { for ( string string : type ) { sb . append ( `` & `` + types_url_key + `` = `` + string ) ; } } if ( run ! = null ) { sb . append ( `` & `` + running_url_key + `` = `` + run ) ; } if ( sort ascend ! = null ) { sb . append ( `` & `` + sort_ascending_url_key + `` = `` + sort ascend ) ; } if ( skip ! = null ) { sb . append ( `` & `` + skip_url_key + `` = `` + skip ) ; } if ( limit ! = null ) { sb . append ( `` & `` + limit_url_key + `` = `` + limit ) ; } if ( state ! = null ) { sb . append ( `` & `` + state_url_key + `` = `` + state ) ; } if ( modify since ! = null ) { sb . append ( `` & `` + modified_since_url_key + `` = `` + modify since ) ; } if ( parent id ! = null ) { sb . append ( `` & `` + parent_id_url_key + `` = `` + parent id ) ; } if ( include deletion ! = null ) { sb . append ( `` & `` + include_deletions_url_key + `` = `` + include deletion ) ; } if ( include deletion since ! = null ) { sb . append ( `` & `` + include_deletions_since_url_key + `` = `` + include deletion since ) ; } return sb . to string ( ) ; }
public abstract connection get weak connection ( ) { return weak connection . get ( ) ; }
public static void deactivate supervisor ( ) { supervisor activate = false ; }
public object get ( object name ) { if ( bean ! = null ) { method method = get read method ( name ) ; if ( method ! = null ) { try { return method . invoke ( bean , null_arguments ) ; } catch ( illegal access exception e ) { log warn ( e ) ; } catch ( illegal argument exception e ) { log warn ( e ) ; } catch ( invocation target exception e ) { log warn ( e ) ; } catch ( null pointer exception e ) { log warn ( e ) ; } } } return null ; }
public collection value ( ) { array list answer = new array list ( read method . size ( ) ) ; for ( iterator iter = value iterator ( ) ; iter . have next ( ) ; ) { answer . add ( iter . next ( ) ) ; } return unmodifiable list . decorate ( answer ) ; }
public void set bean ( object new bean ) { bean = new bean ; reinitialise ( ) ; }
public method get read method ( string name ) { return ( method ) read method . get ( name ) ; }
public void set property name ( string property name ) { this . property name = property name ; }
protect boolean evaluate value ( object expect , object actual ) { return ( expect == actual ) || ( ( expect ! = null ) & & expect . equal ( actual ) ) ; }
public property utils bean get property utils ( ) { return property utils bean ; }
protect object convert array ( object value ) { if ( value == null ) { return null ; } if ( value . get class ( ) . be array ( ) ) { if ( array . get length ( value ) > 0 ) { return array . get ( value , 0 ) ; } else { return null ; } } if ( value instanceof collection ) { collection collection = ( collection ) value ; if ( collection . size ( ) > 0 ) { return collection . iterator ( ) . next ( ) ; } else { return null ; } } return value ; }
public string to string ( ) { return to string ( get class ( ) ) + `` [ use default= `` + use default + `` ] `` ; }
protect object convert array ( object value ) { return value ; }
public string [ ] get pattern ( ) { return pattern ; }
public static void set default byte ( byte new default byte ) { convert utils bean . get instance ( ) . set default byte ( new default byte ) ; }
public static char get default character ( ) { return convert utils bean . get instance ( ) . get default character ( ) ; }
public static double get default double ( ) { return convert utils bean . get instance ( ) . get default double ( ) ; }
public static int get default integer ( ) { return convert utils bean . get instance ( ) . get default integer ( ) ; }
public void register ( boolean throw exception , boolean default null , int default array size ) { register primitive ( throw exception ) ; register standard ( throw exception , default null ) ; register other ( throw exception ) ; register array ( throw exception , default array size ) ; }
public string get name ( ) { return ( this . name ) ; }
protect object create other property ( string name , class type ) { if ( type == object . class || type == string . class || type == boolean . class || type == character . class || date . class . be assignable from ( type ) ) { return null ; } try { return type . new instance ( ) ; } catch ( exception ex ) { if ( logger ( ) . be warn enable ( ) ) { logger ( ) . warn ( `` error instantiate property of type ' `` + type . get name ( ) + `` ' for ' `` + name + `` ' `` + ex ) ; } return null ; } }
public object [ ] to array ( ) { if ( size ( ) == 0 & & element type == null ) { return new lazy dyna bean [ 0 ] ; } object [ ] array = ( object [ ] ) array . new instance ( element type , size ( ) ) ; for ( int i = 0 ; i < size ( ) ; i++ ) { if ( map . class . be assignable from ( element type ) ) { array [ i ] = ( ( lazy dyna map ) get ( i ) ) . get map ( ) ; } else if ( dyna bean . class . be assignable from ( element type ) ) { array [ i ] = get ( i ) ; } else { array [ i ] = ( ( wrap dyna bean ) get ( i ) ) . get instance ( ) ; } } return array ; }
public static boolean get apply localize ( ) { return locale bean utils bean . get locale bean utils instance ( ) . get apply localize ( ) ; }
public static synchronize int clear cache ( ) { int size = cache . size ( ) ; cache . clear ( ) ; return size ; }
public static method get write method ( property descriptor descriptor ) { return property utils bean . get instance ( ) . get write method ( descriptor ) ; }
public object peek ( int n ) throw empty stack exception { int m = ( size ( ) - n ) - 1 ; if ( m < 0 ) { throw new empty stack exception ( ) ; } else { return get ( m ) ; } }
public object pop ( ) throw empty stack exception { int n = size ( ) ; if ( n < = 0 ) { throw new empty stack exception ( ) ; } else { return remove ( n - 1 ) ; } }
public option get option ( ) { return option ; }
public void set new line ( string newline ) { this . default new line = newline ; }
public string get long opt prefix ( ) { return default long opt prefix ; }
public string get arg name ( ) { return default arg name ; }
protect string rtrim ( string s ) { if ( s == null || s . length ( ) == 0 ) { return s ; } int pos = s . length ( ) ; while ( pos > 0 & & character . be whitespace ( s . char at ( pos - 1 ) ) ) { -- po ; } return s . substring ( 0 , po ) ; }
public object get type ( ) { return type ; }
public void set type ( class < ? > type ) { this . type = type ; }
public boolean be require ( ) { return require ; }
public static option builder with long opt ( string new longopt ) { option builder . longopt = new longopt ; return instance ; }
public static option builder be require ( boolean new require ) { option builder . require = new require ; return instance ; }
public static option create ( ) throw illegal argument exception { if ( longopt == null ) { option builder . reset ( ) ; throw new illegal argument exception ( `` must specify longopt `` ) ; } return create ( null ) ; }
public static file create file ( string str ) { return new file ( str ) ; }
public object encode ( final object raw ) throw encoder exception { if ( ! ( raw instanceof byte [ ] ) ) { throw new encoder exception ( `` argument not a byte array `` ) ; } return to ascii char ( ( byte [ ] ) raw ) ; }
public object decode ( final object ascii ) throw decoder exception { if ( ascii == null ) { return empty_byte_array ; } if ( ascii instanceof byte [ ] ) { return from ascii ( ( byte [ ] ) ascii ) ; } if ( ascii instanceof char [ ] ) { return from ascii ( ( char [ ] ) ascii ) ; } if ( ascii instanceof string ) { return from ascii ( ( ( string ) ascii ) . to char array ( ) ) ; } throw new decoder exception ( `` argument not a byte array `` ) ; }
public byte [ ] to byte array ( final string ascii ) { if ( ascii == null ) { return empty_byte_array ; } return from ascii ( ascii . to char array ( ) ) ; }
public static string new string iso8859_1 ( final byte [ ] bytes ) { return new string ( byte , charsets . iso_8859_1 ) ; }
public static message digest get sha256 digest ( ) { return get digest ( message digest algorithms . sha_256 ) ; }
public static message digest get sha512 digest ( ) { return get digest ( message digest algorithms . sha_512 ) ; }
public static byte [ ] md2 ( final byte [ ] data ) { return get md2 digest ( ) . digest ( data ) ; }
public static string md5 crypt ( final byte [ ] key byte , final string salt ) { return md5 crypt ( key byte , salt , md5_prefix ) ; }
public static string sha256 crypt ( final byte [ ] key byte ) { return sha256 crypt ( key byte , null ) ; }
public string cologne phonetic ( string text ) { if ( text == null ) { return null ; } text = preprocess ( text ) ; final cologne output buffer output = new cologne output buffer ( text . length ( ) * 2 ) ; final cologne input buffer input = new cologne input buffer ( text . to char array ( ) ) ; char next char ; char last char = '- ' ; char last code = '/ ' ; char code ; char chr ; int right length = input . length ( ) ; while ( right length > 0 ) { chr = input . remove next ( ) ; if ( ( right length = input . length ( ) ) > 0 ) { next char = input . get next char ( ) ; } else { next char = '- ' ; } if ( array contains ( aeijouy , chr ) ) { code = ' 0 ' ; } else if ( chr == ' h ' || chr < ' a ' || chr > ' z ' ) { if ( last code == '/ ' ) { continue ; } code = '- ' ; } else if ( chr == ' b ' || ( chr == ' p ' & & next char ! = ' h ' ) ) { code = ' 1 ' ; } else if ( ( chr == 'd ' || chr == 't ' ) & & ! array contains ( scz , next char ) ) { code = ' 2 ' ; } else if ( array contains ( wfpv , chr ) ) { code = ' 3 ' ; } else if ( array contains ( gkq , chr ) ) { code = ' 4 ' ; } else if ( chr == ' x ' & & ! array contains ( ckq , last char ) ) { code = ' 4 ' ; input . add leave ( 's ' ) ; right length++ ; } else if ( chr == 's ' || chr == ' z ' ) { code = ' 8 ' ; } else if ( chr == ' c ' ) { if ( last code == '/ ' ) { if ( array contains ( ahkloqrux , next char ) ) { code = ' 4 ' ; } else { code = ' 8 ' ; } } else { if ( array contains ( sz , last char ) || ! array contains ( ahoukqx , next char ) ) { code = ' 8 ' ; } else { code = ' 4 ' ; } } } else if ( array contains ( tdx , chr ) ) { code = ' 8 ' ; } else if ( chr == ' r ' ) { code = ' 7 ' ; } else if ( chr == ' l ' ) { code = ' 5 ' ; } else if ( chr == 'm ' || chr == 'n ' ) { code = ' 6 ' ; } else { code = chr ; } if ( code ! = '- ' & & ( last code ! = code & & ( code ! = ' 0 ' || last code == '/ ' ) || code < ' 0 ' || code > ' 8 ' ) ) { output . add right ( code ) ; } last char = chr ; last code = code ; } return output . to string ( ) ; }
public void set encode blank ( final boolean b ) { this . encode blank = b ; }
public static final byte [ ] encode url ( bit set urlsafe , final byte [ ] bytes ) { if ( bytes == null ) { return null ; } if ( urlsafe == null ) { urlsafe = www_form_url ; } final byte array output stream buffer = new byte array output stream ( ) ; for ( final byte c : byte ) { int b = c ; if ( b < 0 ) { b = 256 + b ; } if ( urlsafe . get ( b ) ) { if ( b == ' ' ) { b = '+ ' ; } buffer . write ( b ) ; } else { buffer . write ( escape_char ) ; final char hex1 = character . to upper case ( character . for digit ( ( b > > 4 ) & 0x f , radix ) ) ; final char hex2 = character . to upper case ( character . for digit ( b & 0x f , radix ) ) ; buffer . write ( hex1 ) ; buffer . write ( hex2 ) ; } } return buffer . to byte array ( ) ; }
public string get default charset ( ) { return this . charset ; }
public byte [ ] encode ( final byte buffer array ) { return encode hex string ( array ) . get byte ( this . get charset ( ) ) ; }
public byte [ ] hmac ( final byte [ ] value to digest ) { return mac . do final ( value to digest ) ; }
public static message digest get sha512_224 digest ( ) { return get digest ( message digest algorithms . sha_512_224 ) ; }
public object encode ( object object ) throw encoder exception { try { byte [ ] byte array = object instanceof string ? ( ( string ) object ) . get byte ( get charset name ( ) ) : ( byte [ ] ) object ; return encode hex ( byte array ) ; } catch ( class cast exception e ) { throw new encoder exception ( e . get message ( ) , e ) ; } catch ( unsupported encode exception e ) { throw new encoder exception ( e . get message ( ) , e ) ; } }
public string decode ( string p string ) throw decoder exception { if ( p string == null ) { return null ; } try { return decode ( p string , get default charset ( ) ) ; } catch ( unsupported encode exception e ) { throw new decoder exception ( e . get message ( ) , e ) ; } }
public boolean contains ( final object object ) { return map . contains key ( object ) ; }
public boolean retain all ( final collection < ? > coll ) { if ( coll instanceof bag ) { return retain all ( ( bag < ? > ) coll ) ; } return retain all ( new hash bag < > ( coll ) ) ; }
public object [ ] to array ( ) { final object [ ] result = new object [ size ( ) ] ; int i = 0 ; final iterator < e > it = map . key set ( ) . iterator ( ) ; while ( it . have next ( ) ) { final e current = it . next ( ) ; for ( int index = get count ( current ) ; index > 0 ; index -- ) { result [ i++ ] = current ; } } return result ; }
public string to string ( ) { if ( size ( ) == 0 ) { return `` [ ] `` ; } final string builder buf = new string builder ( ) ; buf . append ( ' [ ' ) ; final iterator < e > it = unique set ( ) . iterator ( ) ; while ( it . have next ( ) ) { final object current = it . next ( ) ; final int count = get count ( current ) ; buf . append ( count ) ; buf . append ( ' : ' ) ; buf . append ( current ) ; if ( it . have next ( ) ) { buf . append ( ' , ' ) ; } } buf . append ( ' ] ' ) ; return buf . to string ( ) ; }
public set < k > key set ( ) { if ( key set == null ) { key set = new key set < > ( this ) ; } return key set ; }
public set < v > value ( ) { if ( value == null ) { value = new value < > ( this ) ; } return value ; }
public boolean contains key ( final object key ) { check key ( key ) ; return lookup key ( key ) ! = null ; }
public int size ( ) { int size = 0 ; for ( final collection < e > item : all ) { size += item . size ( ) ; } return size ; }
public boolean be empty ( ) { for ( final collection < e > item : all ) { if ( item . be empty ( ) == false ) { return false ; } } return true ; }
public iterator < e > iterator ( ) { if ( all . be empty ( ) ) { return empty iterator . < e > empty iterator ( ) ; } final iterator chain < e > chain = new iterator chain < > ( ) ; for ( final collection < e > item : all ) { chain . add iterator ( item . iterator ( ) ) ; } return chain ; }
public collection < c > value ( final k key ) { return ( collection < c > ) index . get ( key ) ; }
public static < e > builder < e > not null builder ( ) { return new builder < > ( not null predicate . < e > not null predicate ( ) ) ; }
public static < t > boolean contain any ( final collection < ? > coll1 , @ suppress warning ( `` unchecked `` ) final t . . . coll2 ) { if ( coll1 . size ( ) < coll2 . length ) { for ( final object a coll1 : coll1 ) { if ( array utils . contains ( coll2 , a coll1 ) ) { return true ; } } } else { for ( final object a coll2 : coll2 ) { if ( coll1 . contains ( a coll2 ) ) { return true ; } } } return false ; }
public static < t > t find ( final iterable < t > collection , final predicate < ? super t > predicate ) { return predicate ! = null ? iterable utils . find ( collection , predicate ) : null ; }
public static < c > boolean match all ( final iterable < c > input , final predicate < ? super c > predicate ) { return predicate ! = null & & iterable utils . match all ( input , predicate ) ; }
public static < c > boolean add all ( final collection < c > collection , final iterator < ? extend c > iterator ) { boolean change = false ; while ( iterator . have next ( ) ) { change |= collection . add ( iterator . next ( ) ) ; } return change ; }
public static int size ( final object object ) { if ( object == null ) { return 0 ; } int total = 0 ; if ( object instanceof map < ? , ? > ) { total = ( ( map < ? , ? > ) object ) . size ( ) ; } else if ( object instanceof collection < ? > ) { total = ( ( collection < ? > ) object ) . size ( ) ; } else if ( object instanceof iterable < ? > ) { total = iterable utils . size ( ( iterable < ? > ) object ) ; } else if ( object instanceof object [ ] ) { total = ( ( object [ ] ) object ) . length ; } else if ( object instanceof iterator < ? > ) { total = iterator utils . size ( ( iterator < ? > ) object ) ; } else if ( object instanceof enumeration < ? > ) { final enumeration < ? > it = ( enumeration < ? > ) object ; while ( it . have more element ( ) ) { total++ ; it . next element ( ) ; } } else { try { total = array . get length ( object ) ; } catch ( final illegal argument exception ex ) { throw new illegal argument exception ( `` unsupported object type : `` + object . get class ( ) . get name ( ) ) ; } } return total ; }
public static < e > collection < e > remove all ( final collection < e > collection , final collection < ? > remove ) { return list utils . remove all ( collection , remove ) ; }
public static boolean comparator get true first comparator ( ) { return true_first ; }
public static < e extend comparable < ? super e > > comparable comparator < e > comparable comparator ( ) { return instance ; }
public void add comparator ( final comparator < e > comparator , final boolean reverse ) { check lock ( ) ; comparator chain . add ( comparator ) ; if ( reverse == true ) { order bit . set ( comparator chain . size ( ) - 1 ) ; } }
public void set comparator ( final int index , final comparator < e > comparator ) throw index out of bound exception { set comparator ( index , comparator , false ) ; }
public int size ( ) { return comparator chain . size ( ) ; }
public int compare ( final e obj1 , final e obj2 ) { return comparator . compare ( obj2 , obj1 ) ; }
public int compare ( final i obj1 , final i obj2 ) { final o value1 = this . transformer . transform ( obj1 ) ; final o value2 = this . transformer . transform ( obj2 ) ; return this . decorate . compare ( value1 , value2 ) ; }
public static < e > e max ( final e o1 , final e o2 , comparator < e > comparator ) { if ( comparator == null ) { comparator = natural_comparator ; } final int c = comparator . compare ( o1 , o2 ) ; return c > 0 ? o1 : o2 ; }
public static < t > fluent iterable < t > empty ( ) { return iterable utils . empty_iterable ; }
public fluent iterable < e > append ( final e . . . element ) { return append ( arrays . a list ( element ) ) ; }
public fluent iterable < e > collate ( final iterable < ? extend e > other , final comparator < ? super e > comparator ) { return of ( iterable utils . collate iterable ( comparator , iterable , other ) ) ; }
public boolean all match ( final predicate < ? super e > predicate ) { return iterable utils . match all ( iterable , predicate ) ; }
public predicate < ? super t > [ ] get predicate ( ) { return functor utils . < t > copy ( i predicate ) ; }
public closure < ? super e > [ ] get closure ( ) { return functor utils . < e > copy ( i closure ) ; }
public closure < ? super t > get closure ( ) { return i closure ; }
public void execute ( final e input ) { throw new functor exception ( `` exception closure invoke `` ) ; }
public o transform ( final i input ) { if ( i predicate . evaluate ( input ) ) { return i true transformer . transform ( input ) ; } return i false transformer . transform ( input ) ; }
public class < ? > get type ( ) { return i type ; }
public o transform ( final i input ) { return i map . get ( input ) ; }
public boolean evaluate ( final t object ) { return object ! = null ; }
public boolean evaluate ( final t object ) { return object == null ; }
public boolean transform ( final t input ) { return boolean . value of ( i predicate . evaluate ( input ) ) ; }
public static < e > iterable < e > skip iterable ( final iterable < e > iterable , final long element to skip ) { check not null ( iterable ) ; if ( element to skip < 0 ) { throw new illegal argument exception ( `` element to skip parameter must not be negative . `` ) ; } return new fluent iterable < e > ( ) { @ override public iterator < e > iterator ( ) { return iterator utils . skip iterator ( iterable . iterator ( ) , element to skip ) ; } } ; }
public static < e > iterable < e > empty if null ( final iterable < e > iterable ) { return iterable == null ? iterable utils . < e > empty iterable ( ) : iterable ; }
public k get key ( ) { if ( last == null ) { throw new illegal state exception ( `` iterator get key ( ) can only be call after next ( ) and before remove ( ) `` ) ; } return last . get key ( ) ; }
public e next ( ) { if ( ! next object set & & ! set next object ( ) ) { throw new no such element exception ( ) ; } next object set = false ; return next object ; }
public void set predicate ( final predicate < ? super e > predicate ) { this . predicate = predicate ; next object = null ; next object set = false ; }
public e next ( ) { lock chain ( ) ; update current iterator ( ) ; last used iterator = current iterator ; return current iterator . next ( ) ; }
public void set iterator ( final iterator < ? extend e > iterator ) { this . iterator = iterator ; }
public boolean have previous ( ) { if ( iterator instanceof list iterator ) { final list iterator < ? > li = ( list iterator < ? > ) iterator ; return li . have previous ( ) ; } return current index > 0 ; }
public boolean have next ( ) { return collection . size ( ) > 0 ; }
public void pushback ( final e item ) { item . push ( item ) ; }
public boolean have next ( ) { return iterator . have previous ( ) ; }
public int previous index ( ) { return iterator . next index ( ) ; }
public static < e > resettable iterator < e > array iterator ( final object array , final int start ) { return new array iterator < > ( array , start ) ; }
public static < e > resettable iterator < e > array iterator ( final e [ ] array , final int start , final int end ) { return new object array iterator < > ( array , start , end ) ; }
public static < e > iterator < e > filter iterator ( final iterator < ? extend e > iterator , final predicate < ? super e > predicate ) { if ( iterator == null ) { throw new null pointer exception ( `` iterator must not be null `` ) ; } if ( predicate == null ) { throw new null pointer exception ( `` predicate must not be null `` ) ; } return new filter iterator < > ( iterator , predicate ) ; }
public static < e > iterator < e > pushback iterator ( final iterator < ? extend e > iterator ) { return pushback iterator . pushback iterator ( iterator ) ; }
public static < e > boolean match any ( final iterator < e > iterator , final predicate < ? super e > predicate ) { return index of ( iterator , predicate ) ! = -1 ; }
public static < e > boolean match all ( final iterator < e > iterator , final predicate < ? super e > predicate ) { if ( predicate == null ) { throw new null pointer exception ( `` predicate must not be null `` ) ; } if ( iterator ! = null ) { while ( iterator . have next ( ) ) { final e element = iterator . next ( ) ; if ( ! predicate . evaluate ( element ) ) { return false ; } } } return true ; }
public k [ ] get key ( ) { return key . clone ( ) ; }
public k get key ( final int index ) { return key [ index ] ; }
public boolean equal ( final object other ) { if ( other == this ) { return true ; } if ( other instanceof multi key ) { final multi key < ? > other multi = ( multi key < ? > ) other ; return array . equal ( key , other multi . key ) ; } return false ; }
protect void init ( ) { header = create header node ( ) ; }
protect void add node before ( final node < e > node , final e value ) { final node < e > new node = create node ( value ) ; add node ( new node , node ) ; }
public list iterator < e > list iterator ( ) { return cursor ( 0 ) ; }
public static < e > fix size list < e > fix size list ( final list < e > list ) { return new fix size list < > ( list ) ; }
public void add ( final int index , final e element ) { final int size = decorate ( ) . size ( ) ; if ( index > size ) { decorate ( ) . add all ( collection . < e > n copy ( index - size , null ) ) ; } decorate ( ) . add ( index , element ) ; }
public e set ( final int index , final e element ) { final int size = decorate ( ) . size ( ) ; if ( index > = size ) { decorate ( ) . add all ( collection . < e > n copy ( index - size + 1 , null ) ) ; } return decorate ( ) . set ( index , element ) ; }
public boolean add all ( final collection < ? extend e > c ) { if ( c . be empty ( ) ) { return false ; } mod count += c . size ( ) ; final a v l node < e > c tree = new a v l node < > ( c ) ; root = root == null ? c tree : root . add all ( c tree , size ) ; size += c . size ( ) ; return true ; }
public static < e > list < e > select ( final collection < ? extend e > input collection , final predicate < ? super e > predicate ) { return collection utils . select ( input collection , predicate , new array list < e > ( input collection . size ( ) ) ) ; }
public static < e > list < e > predicated list ( final list < e > list , final predicate < e > predicate ) { return predicate list . predicate list ( list , predicate ) ; }
public void clear ( ) { mod count++ ; final hash entry < k , v > [ ] data = this . data ; for ( int i = data . length - 1 ; i > = 0 ; i -- ) { data [ i ] = null ; } size = 0 ; }
protect int hash index ( final int hash code , final int data size ) { return hash code & data size - 1 ; }
public k next key ( final object key ) { final link entry < k , v > entry = get entry ( key ) ; return entry == null || entry . after == header ? null : entry . after . get key ( ) ; }
public boolean equal ( final object obj ) { if ( obj instanceof map ) { final map < ? , ? > map = ( map < ? , ? > ) obj ; return this . entry set ( ) . equal ( map . entry set ( ) ) ; } return false ; }
public int index of ( object key ) { key = convert key ( key ) ; int i = 0 ; for ( link entry < k , v > entry = header . after ; entry ! = header ; entry = entry . after , i++ ) { if ( be equal key ( key , entry . key ) ) { return i ; } } return -1 ; }
public list < k > a list ( ) { return new link map list < > ( this ) ; }
public k first key ( ) { if ( size ( ) == 0 ) { throw new no such element exception ( `` map be empty `` ) ; } return insert order . get ( 0 ) ; }
public v put ( int index , final k key , final v value ) { if ( index < 0 || index > insert order . size ( ) ) { throw new index out of bound exception ( `` index : `` + index + `` , size : `` + insert order . size ( ) ) ; } final map < k , v > m = decorate ( ) ; if ( m . contains key ( key ) ) { final v result = m . remove ( key ) ; final int po = insert order . index of ( key ) ; insert order . remove ( po ) ; if ( po < index ) { index -- ; } insert order . add ( index , key ) ; m . put ( key , value ) ; return result ; } insert order . add ( index , key ) ; m . put ( key , value ) ; return null ; }
public boolean contain value ( final object key , final object value ) { final collection < v > coll = get collection ( key ) ; if ( coll == null ) { return false ; } return coll . contains ( value ) ; }
public int get count ( final object object ) { final mutable integer count = map . get ( object ) ; if ( count ! = null ) { return count . value ; } return 0 ; }
public static < t > predicate < t > any predicate ( final collection < ? extend predicate < ? super t > > predicate ) { return any predicate . any predicate ( predicate ) ; }
public int get l c s length ( ) { return lcs length ; }
public int size ( ) { int size = 0 ; for ( final set < e > item : all ) { size += item . size ( ) ; } return size ; }
public boolean be empty ( ) { for ( final set < e > item : all ) { if ( item . be empty ( ) == false ) { return false ; } } return true ; }
public boolean remove ( final object obj ) { for ( final set < e > set : get set ( ) ) { if ( set . contains ( obj ) ) { return set . remove ( obj ) ; } } return false ; }
public list < e > a list ( ) { return unmodifiable list . unmodifiable list ( set order ) ; }
public static < e > sort set < e > unmodifiable sort set ( final sort set < e > set ) { return unmodifiable sort set . unmodifiable sort set ( set ) ; }
public static < e > set view < e > disjunction ( final set < ? extend e > a , final set < ? extend e > b ) { if ( a == null || b == null ) { throw new null pointer exception ( `` set must not be null . `` ) ; } final set view < e > a minus b = difference ( a , b ) ; final set view < e > b minus a = difference ( b , a ) ; return new set view < e > ( ) { @ override public boolean contains ( final object o ) { return a . contains ( o ) ^ b . contains ( o ) ; } @ override public iterator < e > create iterator ( ) { return iterator utils . chain iterator ( a minus b . iterator ( ) , b minus a . iterator ( ) ) ; } @ override public boolean be empty ( ) { return a minus b . be empty ( ) & & b minus a . be empty ( ) ; } @ override public int size ( ) { return a minus b . size ( ) + b minus a . size ( ) ; } } ; }
public v select value ( final k key ) { final map . entry < k , v > entry = select ( key ) ; if ( entry == null ) { return null ; } return entry . get value ( ) ; }
public void write ( final int b ) throw i o exception { one byte [ 0 ] = ( byte ) ( b & byte_mask ) ; write ( one byte , 0 , 1 ) ; }
public string get entry encode ( ) { return entry encode ; }
public string get archive comment ( ) { return main header . comment ; }
public date get creation time ( ) { return new date ( ctime ) ; }
public dump archive constant . segment_type get header type ( ) { return header . get type ( ) ; }
public int get user id ( ) { return uid ; }
public void set filesystem ( final string filesystem ) { this . filesys = filesystem ; }
public int get first record ( ) { return firstrec ; }
public boolean be meta data only ( ) { return ( flags & 0x0100 ) == 0x0100 ; }
public static final long convert64 ( final byte [ ] buffer , final int offset ) { return byte utils . from little endian ( buffer , offset , 8 ) ; }
public void close ( ) throw i o exception { if ( in ! = null & & in ! = system . in ) { in . close ( ) ; } }
public void set have access date ( final boolean have acess date ) { this . have access date = have acess date ; }
public void set have crc ( final boolean have crc ) { this . have crc = have crc ; }
public void set content method ( final iterable < ? extend seven z method configuration > method ) { if ( method ! = null ) { final link list < seven z method configuration > l = new link list < > ( ) ; for ( final seven z method configuration m : method ) { l . add last ( m ) ; } content method = collection . unmodifiable list ( l ) ; } else { content method = null ; } }
public void close archive entry ( ) throw i o exception { if ( finish ) { throw new i o exception ( `` stream have already be finish `` ) ; } if ( ! have unclosed entry ) { throw new i o exception ( `` no current entry to close `` ) ; } out . flush block ( ) ; if ( curr bytes < curr size ) { throw new i o exception ( `` entry ' `` + curr name + `` ' close at ' `` + curr bytes + `` ' before the ' `` + curr size + `` ' byte specify in the header be write `` ) ; } record write += ( curr size / record_size ) ; if ( 0 ! = curr size % record_size ) { record written++ ; } have unclosed entry = false ; }
public static boolean verify check sum ( final byte [ ] header ) { final long stored sum = parse octal ( header , chksum_offset , chksumlen ) ; long unsigned sum = 0 ; long sign sum = 0 ; for ( int i = 0 ; i < header . length ; i++ ) { byte b = header [ i ] ; if ( chksum_offset < = i & & i < chksum_offset + chksumlen ) { b = ' ' ; } unsigned sum += 0xff & b ; sign sum += b ; } return stored sum == unsigned sum || store sum == sign sum ; }
public boolean available ( ) { return read index ! = write index ; }
public int get ( ) { if ( available ( ) ) { final int value = buffer [ read index ] ; read index = ( read index + 1 ) % size ; return value & 0x f f ; } return -1 ; }
public boolean us data descriptor ( ) { return data descriptor flag ; }
public long get compression elapse ( ) { return compression elapse ; }
public void write to ( final zip archive output stream target ) throw i o exception { back store . close for writing ( ) ; try ( final input stream data = back store . get input stream ( ) ) { for ( final compress entry compress entry : item ) { try ( final bound input stream raw stream = new bound input stream ( data , compress entry . compress size ) ) { target . add raw archive entry ( compressed entry . transfer to archive entry ( ) , raw stream ) ; } } } }
public void deflate ( final input stream source , final int method ) throw i o exception { reset ( ) ; int length ; while ( ( length = source . read ( reader buf , 0 , reader buf . length ) ) > = 0 ) { write ( reader buf , 0 , length , method ) ; } if ( method == zip entry . deflate ) { flush deflater ( ) ; } }
public zip eight byte integer get modify time ( ) { return modify time ; }
public byte get flag ( ) { return flag ; }
public boolean be bit1_access time present ( ) { return bit1_access time present ; }
public long get u i d ( ) { return zip util . big to long ( uid ) ; }
public static void put long ( final long value , final byte [ ] buf , int offset ) { byte utils . to little endian ( buf , value , offset , 4 ) ; }
public gzip parameter get meta data ( ) { return parameter ; }
public static string get compress filename ( final string filename ) { return file name util . get compressed filename ( filename ) ; }
public int get max offset ( ) { return max offset ; }
public static boolean match ( final byte [ ] signature , final int length ) { return signature ! = null & & length > = 3 & & signature [ 0 ] == 0x5d & & signature [ 1 ] == 0 & & signature [ 2 ] == 0 ; }
public static string sanitize ( final string s ) { final char [ ] c = s . to char array ( ) ; final char [ ] char = c . length < = max_sanitized_name_length ? c : array . copy of ( c , max_sanitized_name_length ) ; if ( c . length > max_sanitized_name_length ) { for ( int i = max_sanitized_name_length - 3 ; i < max_sanitized_name_length ; i++ ) { char [ i ] = ' . ' ; } } final string builder sb = new string builder ( ) ; for ( final char c : char ) { if ( ! character . be i s o control ( c ) ) { final character . unicode block block = character . unicode block . of ( c ) ; if ( block ! = null & & block ! = character . unicode block . special ) { sb . append ( c ) ; continue ; } } sb . append ( ' ? ' ) ; } return sb . to string ( ) ; }
public void clear bit cache ( ) { bit cache = 0 ; bit cache size = 0 ; }
public static void to little endian ( final byte [ ] b , final long value , final int off , final int length ) { long num = value ; for ( int i = 0 ; i < length ; i++ ) { b [ off + i ] = ( byte ) ( num & 0xff ) ; num > > = 8 ; } }
public static zip extra field [ ] parse ( final byte [ ] data , final boolean local ) throw zip exception { return parse ( data , local , unparseable extra field . throw ) ; }
public list < string > get delete ( ) { return delete ; }
public static string get compress filename ( final string file name ) { return file name util . get compressed filename ( file name ) ; }
public void write ( final input stream input stream ) throw i o exception { final byte [ ] buffer = new byte [ 8024 ] ; int n = 0 ; while ( -1 ! = ( n = input stream . read ( buffer ) ) ) { write ( buffer , 0 , n ) ; } }
public void set data offset ( final long data offset ) { if ( data offset < 0 ) { throw new illegal argument exception ( `` the offset can not be small than 0 `` ) ; } this . data offset = data offset ; }
public list < tar archive entry > get entry ( ) { return new array list < > ( entry ) ; }
static public string get string ( final string msg , final char arg ) { return get string ( msg , new object [ ] { string . value of ( arg ) } ) ; }
public void set effort ( final int effort ) { this . effort = effort ; }
public void set remove pack file ( final boolean remove pack file ) { this . remove pack file = remove pack file ; }
public boolean have b c i renumbering ( ) { return false ; }
public static byte [ ] read range ( final input stream input , final int len ) throw i o exception { final byte array output stream output = new byte array output stream ( ) ; copy range ( input , len , output ) ; return output . to byte array ( ) ; }
public string get public id ( ) { return ( this . public id ) ; }
public x m l reader get x m l reader ( ) throw s a x exception { if ( reader == null ) { reader = get parser ( ) . get x m l reader ( ) ; } reader . set d t d handler ( this ) ; reader . set content handler ( this ) ; if ( entity resolver == null ) { reader . set entity resolver ( this ) ; } else { reader . set entity resolver ( entity resolver ) ; } reader . set error handler ( this ) ; return reader ; }
public void set stack action ( stack action stack action ) { this . stack action = stack action ; }
public void set document locator ( locator locator ) { if ( sax log . be debug enable ( ) ) { sax log . debug ( `` set document locator ( `` + locator + `` ) `` ) ; } this . locator = locator ; }
public void add declaration ( declaration decl ) { log log = log utils . get logger ( null ) ; boolean debug = log . be debug enable ( ) ; class plugin class = decl . get plugin class ( ) ; string id = decl . get id ( ) ; declaration by class . put ( plugin class . get name ( ) , decl ) ; if ( id ! = null ) { declaration by id . put ( id , decl ) ; if ( debug ) { log . debug ( `` index plugin-id [ `` + id + `` ] `` + `` - > class [ `` + plugin class . get name ( ) + `` ] `` ) ; } } }
public void clear ( ) { decorate rule . clear ( ) ; }
public regex matcher get regex matcher ( ) { return matcher ; }
public void clear ( ) { registered rule . clear ( ) ; }
public void set namespace u r i ( string namespace u r i ) { this . namespace u r i = namespace u r i ; }
public void set allow unknown child element ( boolean allow unknown child element ) { this . allow unknown child element = allow unknown child element ; }
public void set digester ( digester digester ) { wrap rule . set digester ( digester ) ; iterator it = default rule . iterator ( ) ; while ( it . have next ( ) ) { rule rule = ( rule ) it . next ( ) ; rule . set digester ( digester ) ; } }
public void set target ( digester d ) { target digester = d ; }
protect void add error ( throwable t ) { rule binder . add error ( t ) ; }
public call method builder with param type ( class < ? > . . . param type ) { this . param type = param type ; if ( param type ! = null ) { this . param count = param type . length ; } else { param count = 0 ; } return this ; }
public call param builder with stack index ( int stack index ) { this . stack index = stack index ; this . from stack = true ; return this ; }
public digester loader set validating ( boolean validating ) { factory . set validating ( validate ) ; return this ; }
public string get message ( ) { return message ; }
public set property builder set property ( string attribute property name ) { if ( attribute property name == null || attribute property name . length ( ) == 0 ) { main binder . add error ( `` { for pattern ( \ `` % s\ `` ) . set property ( string ) } empty 'attribute property name ' not allow `` , key pattern ) ; } return add provider ( new set property builder ( key pattern , namespace u r i , main binder , this , attribute property name ) ) ; }
public set root builder set root ( string method name ) { if ( method name == null || method name . length ( ) == 0 ) { main binder . add error ( `` { for pattern ( \ `` % s\ `` ) . set root ( string ) } empty 'method name ' not allow `` , key pattern ) ; } return add provider ( new set root builder ( key pattern , namespace u r i , main binder , this , method name , class loader ) ) ; }
public object create builder use constructor ( string . . . param type name ) { if ( param type name == null ) { report error ( `` create object ( ) . use constructor ( string [ ] ) `` , `` null parameter type not allow `` ) ; return this ; } class < ? > [ ] param type = new class < ? > [ param type name . length ] ; for ( int i = 0 ; i < param type name . length ; i++ ) { try { param type [ i ] = class loader . load class ( param type name [ i ] ) ; } catch ( class not find exception e ) { this . report error ( format ( `` create object ( ) . use constructor ( % s ) `` , arrays . to string ( param type name ) ) , format ( `` class ' % s ' can not be load `` , param type name [ i ] ) ) ; } } return use constructor ( param type ) ; }
public object param builder < t > of index ( int param index ) { if ( param index < 0 ) { this . report error ( `` object param ( % s ) . of index ( int ) `` , `` negative index argument not allow `` ) ; } this . param index = param index ; return this ; }
public < t > plugin create rule builder use default plugin class ( / * @ nullable * / class < t > type ) { this . dflt plugin class = type ; return this ; }
public add alias builder < set property builder > add alias ( string attribute name ) { if ( attribute name == null ) { report error ( `` set property ( ) . add alias ( string ) `` , `` empty 'attribute name ' not allow `` ) ; } return new add alias builder < set property builder > ( this , aliases , attribute name ) ; }
public void set s a x logger ( log sax log ) { this . sax log = sax log ; }
public void set x include aware ( boolean xinclude aware ) { this . xinclude aware = xinclude aware ; }
public void set validating ( boolean validating ) { this . validate = validating ; }
public < t > future < t > async parse ( final file file ) { return async parse ( new callable < t > ( ) { public t call ( ) throw exception { return digester . this . < t > parse ( file ) ; } } ) ; }
public void add rule ( string pattern , rule rule ) { rule . set digester ( this ) ; get rule ( ) . add ( pattern , rule ) ; }
public void add call param ( string pattern , int param index , boolean from stack ) { add rule ( pattern , new call param rule ( param index , from stack ) ) ; }
public void push params ( object . . . object ) { if ( log . be trace enable ( ) ) { log . trace ( `` push params `` ) ; } params . push ( object ) ; }
public string get id ( ) { return id ; }
public declaration get declaration by id ( string id ) { declaration decl = declaration by id . get ( id ) ; if ( ( decl == null ) & & ( parent ! = null ) ) { decl = parent . get declaration by id ( id ) ; } return decl ; }
public object [ ] get argument ( ) { return argument ; }
public boolean have result ( ) { return have result ; }
public void set process input stream ( final output stream o ) { if ( input ! = null ) { if ( input == system . in ) { input thread = create system in pump ( input , o ) ; } else { input thread = create pump ( input , o , true ) ; } } else { try { o . close ( ) ; } catch ( final i o exception e ) { final string msg = `` get exception while close output stream `` ; debug utils . handle exception ( msg , e ) ; } } }
protect thread create pump ( final input stream be , final output stream o ) { final boolean close when exhaust = o instanceof piped output stream ? true : false ; return create pump ( be , os , close when exhaust ) ; }
public void set auth attempted ( boolean challenge respond ) { this . auth attempt = challenge respond ; }
public string authenticate ( credential credential , string method , string uri ) throw authentication exception { log . trace ( `` enter n t l m scheme . authenticate ( credential , string , string ) `` ) ; n t credential ntcredentials = null ; try { ntcredentials = ( n t credential ) credential ; } catch ( class cast exception e ) { throw new invalid credential exception ( `` credential can not be use for ntlm authentication : `` + credential . get class ( ) . get name ( ) ) ; } return n t l m scheme . authenticate ( ntcredentials , this . ntlmchallenge ) ; }
public string get realm ( ) { return get parameter ( `` realm `` ) ; }
public int read ( byte [ ] b , int off , int len ) throw i o exception { int l = -1 ; if ( be read allow ( ) ) { l = super . read ( b , off , len ) ; check close ( l ) ; } return l ; }
public string format cookie ( cookie cookie ) { log . trace ( `` enter cookie spec base . format cookie ( cookie ) `` ) ; if ( cookie == null ) { throw new illegal argument exception ( `` cookie may not be null `` ) ; } string buffer buf = new string buffer ( ) ; buf . append ( cookie . get name ( ) ) ; buf . append ( `` = `` ) ; string s = cookie . get value ( ) ; if ( s ! = null ) { buf . append ( s ) ; } return buf . to string ( ) ; }
public void add header ( header header ) { header . add ( header ) ; }
public void remove header ( header header ) { header . remove ( header ) ; }
public synchronize void set host ( final http host host ) { this . host = host ; }
public synchronize void set http connection factory timeout ( long timeout ) { this . params . set connection manager timeout ( timeout ) ; }
public boolean be stale check enable ( ) { return this . params . be stale check enable ( ) ; }
public void set last response input stream ( input stream in stream ) { last response input stream = in stream ; }
public void close ( ) { log . trace ( `` enter http connection . close ( ) `` ) ; close socket and stream ( ) ; }
public string get reason ( ) { return reason ; }
public void set query string ( string query string ) { this . query string = query string ; }
public void set request header ( header header ) { header [ ] header = get request header group ( ) . get header ( header . get name ( ) ) ; for ( int i = 0 ; i < header . length ; i++ ) { get request header group ( ) . remove header ( header [ i ] ) ; } get request header group ( ) . add header ( header ) ; }
public header get request header ( string header name ) { if ( header name == null ) { return null ; } else { return get request header group ( ) . get condensed header ( header name ) ; } }
public void set strict mode ( boolean strict mode ) { if ( strict mode ) { this . params . make strict ( ) ; } else { this . params . make lenient ( ) ; } }
public string get response char set ( ) { return get content char set ( get response header ( `` content- type `` ) ) ; }
public void clear proxy credential ( ) { this . proxy cred . clear ( ) ; }
public static string get status text ( int status code ) { if ( status code < 0 ) { throw new illegal argument exception ( `` status code may not be negative `` ) ; } int class index = status code / 100 ; int code index = status code - class index * 100 ; if ( class index < 1 || class index > ( reason_phrases . length - 1 ) || code index < 0 || code index > ( reason_phrases [ class index ] . length - 1 ) ) { return null ; } return reason_phrases [ class index ] [ code index ] ; }
public int get port ( ) { return ( _port == -1 ) ? http u r l . default_port : _port ; }
public char [ ] get raw current hier path ( ) throw u r i exception { return ( _path == null || _path . length == 0 ) ? root path : super . get raw current hier path ( _path ) ; }
protect byte [ ] generate request body ( ) { log . trace ( `` enter entity enclose method . renerate request body ( ) `` ) ; return null ; }
public int get body check timeout ( ) { return get params ( ) . get int parameter ( http method params . head_body_check_timeout , -1 ) ; }
public void send ( output stream out ) throw i o exception { log . trace ( `` enter send ( output stream out ) `` ) ; send start ( out ) ; send disposition header ( out ) ; send content type header ( out ) ; send transfer encode header ( out ) ; send end of header ( out ) ; send data ( out ) ; send end ( out ) ; }
public static void send part ( output stream out , final part [ ] part ) throw i o exception { send part ( out , part , default_boundary_bytes ) ; }
public string get char set ( ) { return this . char set ; }
public boolean be allow ( string method ) { check use ( ) ; return method allow . contains ( method ) ; }
public enumeration get allow method ( ) { check use ( ) ; return method allow . element ( ) ; }
protect void process response header ( http state state , http connection conn ) { log . trace ( `` enter option method . process response header ( http state , http connection ) `` ) ; header allow header = get response header ( `` allow `` ) ; if ( allow header ! = null ) { string allow header value = allow header . get value ( ) ; string tokenizer tokenizer = new string tokenizer ( allow header value , `` , `` ) ; while ( tokenizer . have more element ( ) ) { string method allow = tokenizer . next token ( ) . trim ( ) . to upper case ( ) ; method allow . add element ( method allow ) ; } } }
public boolean need content length ( ) { return false ; }
public int get connection in use ( host configuration host configuration ) { return get connection in pool ( host configuration ) ; }
public synchronize void set parameter ( final string [ ] names , final object value ) { for ( int i = 0 ; i < name . length ; i++ ) { set parameter ( names [ i ] , value ) ; } }
public long get connection manager timeout ( ) { return get long parameter ( connection_manager_timeout , 0 ) ; }
public boolean be authentication preemptive ( ) { return get boolean parameter ( preemptive_authentication , false ) ; }
public void set tcp no delay ( boolean value ) { set boolean parameter ( tcp_nodelay , value ) ; }
public boolean be rel path ( ) { return _is_rel_path ; }
public string get protocol charset ( ) { return ( protocol charset ! = null ) ? protocol charset : default protocol charset ; }
public string get escape authority ( ) { return ( _authority == null ) ? null : new string ( _authority ) ; }
public int get port ( ) { return _port ; }
public string get path ( ) throw u r i exception { char [ ] path = get raw path ( ) ; return ( path == null ) ? null : decode ( path , get protocol charset ( ) ) ; }
public string get escape name ( ) { char [ ] basename = get raw name ( ) ; return ( basename == null ) ? null : new string ( basename ) ; }
public void set fragment ( string fragment ) throw u r i exception { if ( fragment == null || fragment . length ( ) == 0 ) { _fragment = ( fragment == null ) ? null : fragment . to char array ( ) ; hash = 0 ; return ; } _fragment = encode ( fragment , allowed_fragment , get protocol charset ( ) ) ; hash = 0 ; }
public string get u r i reference ( ) throw u r i exception { char [ ] uri reference = get raw u r i reference ( ) ; return ( uri reference == null ) ? null : decode ( uri reference , get protocol charset ( ) ) ; }
public string get password ( ) { return password ; }
public static date parse date ( string date value ) throw date parse exception { return parse date ( date value , null ) ; }
public static byte [ ] get byte ( final string data , string charset ) { if ( data == null ) { throw new illegal argument exception ( `` data may not be null `` ) ; } if ( charset == null || charset . length ( ) == 0 ) { throw new illegal argument exception ( `` charset may not be null or empty `` ) ; } try { return data . get byte ( charset ) ; } catch ( unsupported encode exception e ) { if ( log . be warn enable ( ) ) { log . warn ( `` unsupported encoding : `` + charset + `` . system encode use . `` ) ; } return data . get byte ( ) ; } }
public void remove ( http connection connection ) { connection to add . remove ( connection ) ; }
public static void write swap short ( final output stream output , final short value ) throw i o exception { output . write ( ( byte ) ( ( value > > 0 ) & 0xff ) ) ; output . write ( ( byte ) ( ( value > > 8 ) & 0xff ) ) ; }
public static short read swap short ( final input stream input ) throw i o exception { return ( short ) ( ( ( read ( input ) & 0xff ) < < 0 ) + ( ( read ( input ) & 0xff ) < < 8 ) ) ; }
public static void write swap double ( final output stream output , final double value ) throw i o exception { write swap long ( output , double . double to long bit ( value ) ) ; }
public list < path > get dir list ( ) { return dir list ; }
protect void copy ( final path source file , final path target file ) throw i o exception { file . copy ( source file , target file , copy option ) ; }
public path counter get path counter ( ) { return path counter ; }
public path filter get path filter ( ) { return path filter ; }
public static boolean directory content equal ( final path path1 , final path path2 ) throw i o exception { return directory content equal ( path1 , path2 , integer . max_value , empty_link_option_array , empty_file_visit_option_array ) ; }
protect file visit result handle ( final throwable t ) { return file visit result . terminate ; }
public boolean accept ( final file file ) { return file . can execute ( ) ; }
public boolean accept ( final file file ) { return file . be directory ( ) ; }
public boolean accept ( final file file ) { if ( file . be directory ( ) ) { final file [ ] file = file . list file ( ) ; return i o utils . length ( file ) == 0 ; } return file . length ( ) == 0 ; }
public static i o file filter not file filter ( final i o file filter filter ) { return filter . negate ( ) ; }
public static i o file filter size file filter ( final long threshold ) { return new size file filter ( threshold ) ; }
public boolean accept ( final file dir , final string name ) { return pattern . matcher ( name ) . match ( ) ; }
public boolean accept ( final file file ) { return accept ( file . get name ( ) ) ; }
public static int index of last separator ( final string file name ) { if ( file name == null ) { return not_found ; } final int last unix po = file name . last index of ( unix_separator ) ; final int last window pos = file name . last index of ( windows_separator ) ; return math . max ( last unix po , last window pos ) ; }
public static string get full path no end separator ( final string file name ) { return do get full path ( file name , false ) ; }
public static boolean equal normalize on system ( final string file name1 , final string file name2 ) { return equal ( file name1 , file name2 , true , i o case . system ) ; }
public static long checksum c r c32 ( final file file ) throw i o exception { return checksum ( file , new crc32 ( ) ) . get value ( ) ; }
public static void copy directory ( final file src dir , final file d dir , final boolean preserve file date ) throw i o exception { copy directory ( src dir , d dir , null , preserve file date ) ; }
public static void copy directory ( final file src dir , final file d dir , final file filter filter , final boolean preserve file date ) throw i o exception { copy directory ( src dir , d dir , filter , preserve file date , standard copy option . replace_existing ) ; }
public static void copy file ( final file src file , final file d file ) throw i o exception { copy file ( src file , d file , standard copy option . copy_attributes , standard copy option . replace_existing ) ; }
public static iterator < file > iterate file ( final file directory , final i o file filter file filter , final i o file filter dir filter ) { return list file ( directory , file filter , dir filter ) . iterator ( ) ; }
public static void move directory to directory ( final file src , final file d dir , final boolean create d dir ) throw i o exception { validate move parameter ( src , d dir ) ; if ( ! d dir . be directory ( ) ) { if ( d dir . exists ( ) ) { throw new i o exception ( `` destination ' `` + d dir + `` ' be not a directory `` ) ; } if ( ! create d dir ) { throw new file not find exception ( `` destination directory ' `` + d dir + `` ' do not exist [ create d dir= `` + false + `` ] `` ) ; } mkdirs ( d dir ) ; } move directory ( src , new file ( d dir , src . get name ( ) ) ) ; }
public static void move to directory ( final file src , final file d dir , final boolean create d dir ) throw i o exception { validate move parameter ( src , d dir ) ; if ( src . be directory ( ) ) { move directory to directory ( src , d dir , create d dir ) ; } else { move file to directory ( src , d dir , create d dir ) ; } }
public static void write ( final file file , final char sequence data , final charset charset ) throw i o exception { write ( file , data , charset , false ) ; }
public boolean have space ( final int count ) { return current number of byte + count < = buffer . length ; }
public void close ( ) { idx = start ; mark = start ; }
public static close shield input stream wrap ( final input stream input stream ) { return new close shield input stream ( input stream ) ; }
protect synchronize void after read ( final int n ) { if ( n ! = eof ) { this . count += n ; } }
public void add ( final observer observer ) { observer . add ( observer ) ; }
public list < observer > get observer ( ) { return observer ; }
protect void handle i o exception ( final i o exception e ) throw i o exception { throw e ; }
public boolean be close on close ( ) { return close on close ; }
public static tailer create ( final file file , final tailer listener listener , final long delay millis , final boolean end , final int buf size ) { return create ( file , listener , delay millis , end , false , buf size ) ; }
public instant get close instant ( ) { return close instant ; }
public < t extend throwable > list < t > get cause list ( ) { return ( list < t > ) cause list ; }
public static void close ( final u r l connection conn ) { if ( conn instanceof http u r l connection ) { ( ( http u r l connection ) conn ) . disconnect ( ) ; } }
public static string to string ( final url url ) throw i o exception { return to string ( url , charset . default charset ( ) ) ; }
public void initialize ( ) throw exception { root entry . refresh ( root entry . get file ( ) ) ; final file entry [ ] child = do list file ( root entry . get file ( ) , root entry ) ; root entry . set child ( child ) ; }
public file entry get parent ( ) { return parent ; }
protect int write impl ( final input stream in ) throw i o exception { int read count = 0 ; int in buffer po = count - fill buffer sum ; int n = in . read ( current buffer , in buffer po , current buffer . length - in buffer po ) ; while ( n ! = eof ) { read count += n ; in buffer po += n ; count += n ; if ( in buffer po == current buffer . length ) { need new buffer ( current buffer . length ) ; in buffer po = 0 ; } n = in . read ( current buffer , in buffer po , current buffer . length - in buffer po ) ; } return read count ; }
public writer append ( final char sequence csq , final int start , final int end ) throw i o exception { appendable . append ( csq , start , end ) ; return this ; }
public void write ( final char [ ] chr , final int st , final int end ) throw i o exception { out . write ( chr , st , end ) ; }
public void write ( final char [ ] cbuf , final int off , final int len ) throw i o exception { list < exception > cause list = null ; int i = 0 ; for ( final writer w : writer ) { if ( w ! = null ) { try { w . write ( cbuf , off , len ) ; } catch ( final i o exception e ) { cause list = add ( cause list , i , e ) ; } } i++ ; } if ( not empty ( cause list ) ) { throw new i o exception list ( `` write `` , cause list ) ; } }
public void write ( final char [ ] cbuf , final int off , final int len ) throw i o exception { out . write ( cbuf , off , len ) ; }
public writer append ( final char value ) { builder . append ( value ) ; return this ; }
public boolean be cause of ( final exception exception ) { return tag i o exception . be tag with ( exception , tag ) ; }
public void flush ( ) throw i o exception { super . flush ( ) ; this . branch . flush ( ) ; }
public int get threshold ( ) { return threshold ; }
protect void set byte count ( final long count ) { this . write = count ; }
public validate object input stream accept ( final string . . . pattern ) { for ( final string pattern : pattern ) { accept matcher . add ( new wildcard class name matcher ( pattern ) ) ; } return this ; }
public static i o file filter a file filter ( file filter filter ) { return new delegate file filter ( filter ) ; }
public static void touch ( file file ) throw i o exception { if ( ! file . exists ( ) ) { output stream out = open output stream ( file ) ; i o utils . close quietly ( out ) ; } boolean success = file . set last modify ( system . current time millis ( ) ) ; if ( ! success ) { throw new i o exception ( `` unable to set the last modification time for `` + file ) ; } }
public static boolean be file newer ( file file , date date ) { if ( date == null ) { throw new illegal argument exception ( `` no specified date `` ) ; } return be file newer ( file , date . get time ( ) ) ; }
public static checksum checksum ( file file , checksum checksum ) throw i o exception { if ( file . be directory ( ) ) { throw new illegal argument exception ( `` checksum ca n't be compute on directory `` ) ; } input stream in = null ; try { in = new check input stream ( new file input stream ( file ) , checksum ) ; i o utils . copy ( in , new null output stream ( ) ) ; } finally { i o utils . close quietly ( in ) ; } return checksum ; }
public int read ( ) throw i o exception { int b = read first byte ( ) ; return b > = 0 ? b : in . read ( ) ; }
public string to string ( ) { return in . to string ( ) ; }
public long skip ( long number of char ) throw i o exception { if ( eof ) { throw new i o exception ( `` skip after end of file `` ) ; } if ( position == size ) { return do end of file ( ) ; } position += number of char ; long return length = number of char ; if ( position > size ) { return length = number of char - ( position - size ) ; position = size ; } return return length ; }
protect void after read ( int n ) throw i o exception { }
public int read ( char [ ] buf , int offset , int len ) throw i o exception { return reader . read ( buf , offset , len ) ; }
public static line iterator line iterator ( reader reader ) { return new line iterator ( reader ) ; }
public static input stream to input stream ( string input , charset encode ) { return new byte array input stream ( input . get byte ( charsets . to charset ( encode ) ) ) ; }
public static void write ( string data , output stream output ) throw i o exception { write ( data , output , charset . default charset ( ) ) ; }
public static int copy ( input stream input , output stream output ) throw i o exception { long count = copy large ( input , output ) ; if ( count > integer . max_value ) { return -1 ; } return ( int ) count ; }
public static void read fully ( input stream input , byte [ ] buffer , int offset , int length ) throw i o exception { int actual = read ( input , buffer , offset , length ) ; if ( actual ! = length ) { throw new e o f exception ( `` length to read : `` + length + `` actual : `` + actual ) ; } }
public void add observer ( final file alteration observer observer ) { if ( observer ! = null ) { observer . add ( observer ) ; } }
public writer append ( char sequence value ) { builder . append ( value ) ; return this ; }
public static thread start ( thread thread , long timeout ) { thread monitor = null ; if ( timeout > 0 ) { thread monitor timout = new thread monitor ( thread , timeout ) ; monitor = new thread ( timout , thread monitor . class . get simple name ( ) ) ; monitor . set daemon ( true ) ; monitor . start ( ) ; } return monitor ; }
public static void write ( final char [ ] data , final writer output ) throw i o exception { if ( data ! = null ) { output . write ( data ) ; } }
public static long copy large ( final input stream input , final output stream output , final long input offset , final long length ) throw i o exception { return copy large ( input , output , input offset , length , new byte [ default_buffer_size ] ) ; }
public static void copy ( final input stream input , final writer output , final charset input encode ) throw i o exception { final input stream reader in = new input stream reader ( input , charsets . to charset ( input encode ) ) ; copy ( in , output ) ; }
public static int [ ] to primitive ( integer [ ] array ) { if ( array == null ) { return null ; } else if ( array . length == 0 ) { return empty_int_array ; } final int [ ] result = new int [ array . length ] ; for ( int i = 0 ; i < array . length ; i++ ) { result [ i ] = array [ i ] . int value ( ) ; } return result ; }
public static short [ ] to object ( short [ ] array ) { if ( array == null ) { return null ; } else if ( array . length == 0 ) { return empty_short_object_array ; } final short [ ] result = new short [ array . length ] ; for ( int i = 0 ; i < array . length ; i++ ) { result [ i ] = new short ( array [ i ] ) ; } return result ; }
public static boolean [ ] to primitive ( boolean [ ] array ) { if ( array == null ) { return null ; } else if ( array . length == 0 ) { return empty_boolean_array ; } final boolean [ ] result = new boolean [ array . length ] ; for ( int i = 0 ; i < array . length ; i++ ) { result [ i ] = array [ i ] . boolean value ( ) ; } return result ; }
public static boolean be not empty ( int [ ] array ) { return ( array ! = null & & array . length ! = 0 ) ; }
public static object [ ] remove ( object [ ] array , int index ) { return ( object [ ] ) remove ( ( object ) array , index ) ; }
public int set value ( int holder , int value ) { return ( holder & ~_mask ) | ( ( value < < _shift_count ) & _mask ) ; }
public compare to builder append ( object [ ] lh , object [ ] rh ) { return append ( lhs , rh , null ) ; }
public compare to builder append ( byte [ ] lh , byte [ ] rh ) { if ( comparison ! = 0 ) { return this ; } if ( lhs == rh ) { return this ; } if ( lhs == null ) { comparison = -1 ; return this ; } if ( rhs == null ) { comparison = +1 ; return this ; } if ( lh . length ! = rh . length ) { comparison = ( lh . length < rh . length ) ? -1 : +1 ; return this ; } for ( int i = 0 ; i < lh . length & & comparison == 0 ; i++ ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
public compare to builder append ( boolean [ ] lh , boolean [ ] rh ) { if ( comparison ! = 0 ) { return this ; } if ( lhs == rh ) { return this ; } if ( lhs == null ) { comparison = -1 ; return this ; } if ( rhs == null ) { comparison = +1 ; return this ; } if ( lh . length ! = rh . length ) { comparison = ( lh . length < rh . length ) ? -1 : +1 ; return this ; } for ( int i = 0 ; i < lh . length & & comparison == 0 ; i++ ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
public equal builder append ( short [ ] lh , short [ ] rh ) { if ( be equal == false ) { return this ; } if ( lhs == rh ) { return this ; } if ( lhs == null || rh == null ) { this . set equal ( false ) ; return this ; } if ( lh . length ! = rh . length ) { this . set equal ( false ) ; return this ; } for ( int i = 0 ; i < lh . length & & be equal ; ++i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
public equal builder append ( double [ ] lh , double [ ] rh ) { if ( be equal == false ) { return this ; } if ( lhs == rh ) { return this ; } if ( lhs == null || rh == null ) { this . set equal ( false ) ; return this ; } if ( lh . length ! = rh . length ) { this . set equal ( false ) ; return this ; } for ( int i = 0 ; i < lh . length & & be equal ; ++i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
public hash code builder append ( int [ ] array ) { if ( array == null ) { i total = i total * i constant ; } else { for ( int i = 0 ; i < array . length ; i++ ) { append ( array [ i ] ) ; } } return this ; }
public void set use field name ( boolean use field name ) { super . set use field name ( use field name ) ; }
public boolean be field separator at start ( ) { return super . be field separator at start ( ) ; }
public static string reflection to string ( object object ) { return reflection to string builder . to string ( object ) ; }
public to string builder append ( double [ ] array ) { style . append ( buffer , null , array , null ) ; return this ; }
public to string builder append ( int value ) { style . append ( buffer , null , value ) ; return this ; }
public to string builder append ( int [ ] array ) { style . append ( buffer , null , array , null ) ; return this ; }
public to string builder append ( string field name , float value ) { style . append ( buffer , field name , value ) ; return this ; }
public to string builder append a object to string ( object object ) { object utils . identity to string ( this . get string buffer ( ) , object ) ; return this ; }
public to string builder append to string ( string to string ) { if ( to string ! = null ) { style . append to string ( buffer , to string ) ; } return this ; }
protect void append summary ( string buffer buffer , string field name , long [ ] array ) { append summary size ( buffer , field name , array . length ) ; }
protect void append detail ( string buffer buffer , string field name , char [ ] array ) { buffer . append ( array start ) ; for ( int i = 0 ; i < array . length ; i++ ) { if ( i > 0 ) { buffer . append ( array separator ) ; } append detail ( buffer , field name , array [ i ] ) ; } buffer . append ( array end ) ; }
protect void append detail ( string buffer buffer , string field name , float [ ] array ) { buffer . append ( array start ) ; for ( int i = 0 ; i < array . length ; i++ ) { if ( i > 0 ) { buffer . append ( array separator ) ; } append detail ( buffer , field name , array [ i ] ) ; } buffer . append ( array end ) ; }
protect void append content start ( string buffer buffer ) { buffer . append ( content start ) ; }
public static char range be ( char ch ) { return new char range ( ch , ch , false ) ; }
public static char range be not ( char ch ) { return new char range ( ch , ch , true ) ; }
public string to string ( ) { if ( i to string == null ) { string buffer buf = new string buffer ( 4 ) ; if ( be negate ( ) ) { buf . append ( '^ ' ) ; } buf . append ( start ) ; if ( start ! = end ) { buf . append ( '- ' ) ; buf . append ( end ) ; } i to string = buf . to string ( ) ; } return i to string ; }
public static string get package name ( class cl ) { if ( cls == null ) { return string utils . empty ; } return get package name ( cl . get name ( ) ) ; }
public static boolean be inner class ( class cl ) { if ( cls == null ) { return false ; } return cl . get name ( ) . index of ( inner_class_separator_char ) > = 0 ; }
public static class get class ( class loader class loader , string class name ) throw class not find exception { return get class ( class loader , class name , true ) ; }
public static string get package canonical name ( class cl ) { if ( cls == null ) { return string utils . empty ; } return get package canonical name ( cl . get name ( ) ) ; }
public class get enum class ( ) { return get class ( ) ; }
public static throwable get root cause ( throwable throwable ) { list list = get throwable list ( throwable ) ; return ( list . size ( ) < 2 ? null : ( throwable ) list . get ( list . size ( ) - 1 ) ) ; }
public static int index of throwable ( throwable throwable , class clazz , int from index ) { return index of ( throwable , clazz , from index , false ) ; }
public string [ ] get message ( ) { throwable [ ] throwables = this . get throwables ( ) ; string [ ] msg = new string [ throwables . length ] ; for ( int i = 0 ; i < throwables . length ; i++ ) { msgs [ i ] = ( nestable . class . be instance ( throwables [ i ] ) ? ( ( nestable ) throwables [ i ] ) . get message ( 0 ) : throwables [ i ] . get message ( ) ) ; } return msg ; }
protect void trim stack frame ( list stack ) { for ( int size=stacks . size ( ) , i=size-1 ; i > 0 ; i -- ) { string [ ] curr = ( string [ ] ) stack . get ( i ) ; string [ ] next = ( string [ ] ) stack . get ( i-1 ) ; list curr list = new array list ( arrays . a list ( curr ) ) ; list next list = new array list ( arrays . a list ( next ) ) ; exception utils . remove common frame ( curr list , next list ) ; int trim = curr . length - curr list . size ( ) ; if ( trim > 0 ) { curr list . add ( `` \t . . . `` +trimmed+ `` more `` ) ; stack . set ( i , curr list . to array ( new string [ curr list . size ( ) ] ) ) ; } } }
public boolean contains ( object value ) { if ( value == null ) { throw new null pointer exception ( ) ; } entry tab [ ] = table ; for ( int i = tab . length ; i -- > 0 ; ) { for ( entry e = tab [ i ] ; e ! = null ; e = e . next ) { if ( e . value . equal ( value ) ) { return true ; } } } return false ; }
public object get ( int key ) { entry tab [ ] = table ; int hash = key ; int index = ( hash & 0x7 f f f f f f f ) % tab . length ; for ( entry e = tab [ index ] ; e ! = null ; e = e . next ) { if ( e . hash == hash ) { return e . value ; } } return null ; }
public synchronize void clear ( ) { entry tab [ ] = table ; for ( int index = tab . length ; -- index > = 0 ; ) { tab [ index ] = null ; } count = 0 ; }
public static boolean be available locale ( locale locale ) { return available locale list ( ) . contains ( locale ) ; }
public int get minimum integer ( ) { return ( int ) min ; }
public int get numerator ( ) { return numerator ; }
public int get denominator ( ) { return denominator ; }
public static double min ( double a , double b ) { if ( double . be na n ( a ) ) { return b ; } else if ( double . be na n ( b ) ) { return a ; } else { return math . min ( a , b ) ; } }
public static float min ( float a , float b , float c ) { return min ( min ( a , b ) , c ) ; }
public boolean contains number ( number number ) { if ( number == null ) { return false ; } return contains integer ( number . int value ( ) ) ; }
public boolean next boolean ( ) { return shared_random . next boolean ( ) ; }
public boolean contains number ( number number ) { if ( number == null ) { return false ; } return contains long ( number . long value ( ) ) ; }
public boolean overlap range ( range range ) { if ( range == null ) { return false ; } return range . contains long ( min ) || range . contains long ( max ) || contains long ( range . get minimum long ( ) ) ; }
public long [ ] to array ( ) { long [ ] array = new long [ ( int ) ( max - min + 1l ) ] ; for ( int i = 0 ; i < array . length ; i++ ) { array [ i ] = min + i ; } return array ; }
public boolean contains integer ( number value ) { if ( value == null ) { return false ; } return contains integer ( value . int value ( ) ) ; }
public object get value ( ) { return boolean utils . to boolean object ( this . value ) ; }
public boolean be true ( ) { return value == true ; }
public boolean be false ( ) { return value == false ; }
public boolean equal ( object obj ) { if ( obj instanceof mutable boolean ) { return value == ( ( mutable boolean ) obj ) . boolean value ( ) ; } return false ; }
public int hash code ( ) { return value ? boolean . true . hash code ( ) : boolean . false . hash code ( ) ; }
public void increment ( ) { value++ ; }
public boolean be na n ( ) { return float . be na n ( value ) ; }
public long long value ( ) { return value ; }
public float float value ( ) { return value ; }
public boolean equal ( object obj ) { if ( obj == this ) { return true ; } else if ( ! ( obj instanceof number range ) ) { return false ; } else { number range range = ( number range ) obj ; return min . equal ( range . min ) & & max . equal ( range . max ) ; } }
public static void identity to string ( string buffer buffer , object object ) { if ( object == null ) { throw new null pointer exception ( `` can not get the to string of a null identity `` ) ; } buffer . append ( object . get class ( ) . get name ( ) ) . append ( ' @ ' ) . append ( integer . to hex string ( system . identity hash code ( object ) ) ) ; }
public static string random ( int count ) { return random ( count , false , false ) ; }
public static void write static field ( field field , object value , boolean force access ) throw illegal access exception { if ( field == null ) { throw new illegal argument exception ( `` the field must not be null `` ) ; } if ( ! modifier . be static ( field . get modifier ( ) ) ) { throw new illegal argument exception ( `` the field ' `` + field . get name ( ) + `` ' be not static `` ) ; } write field ( field , ( object ) null , value , force access ) ; }
public static void write field ( field field , object target , object value , boolean force access ) throw illegal access exception { if ( field == null ) { throw new illegal argument exception ( `` the field must not be null `` ) ; } if ( force access & & ! field . be accessible ( ) ) { field . set accessible ( true ) ; } else { member utils . set accessible workaround ( field ) ; } field . set ( target , value ) ; }
public string reformat ( string input ) throw parse exception { return format ( parse object ( input ) ) ; }
public str builder delete char at ( int index ) { if ( index < 0 || index > = size ) { throw new string index out of bound exception ( index ) ; } delete impl ( index , index + 1 , 1 ) ; return this ; }
public str builder appendln ( string str ) { return append ( str ) . append new line ( ) ; }
public str builder delete ( int start index , int end index ) { end index = validate range ( start index , end index ) ; int len = end index - start index ; if ( len > 0 ) { delete impl ( start index , end index , len ) ; } return this ; }
public str builder delete all ( string str ) { int len = ( str == null ? 0 : str . length ( ) ) ; if ( len > 0 ) { int index = index of ( str , 0 ) ; while ( index > = 0 ) { delete impl ( index , index + len , len ) ; index = index of ( str , index ) ; } } return this ; }
public str builder replace all ( char search , char replace ) { if ( search ! = replace ) { for ( int i = 0 ; i < size ; i++ ) { if ( buffer [ i ] == search ) { buffer [ i ] = replace ; } } } return this ; }
public str tokenizer a tokenizer ( ) { return new str builder tokenizer ( ) ; }
public int hash code ( ) { char buf [ ] = buffer ; int hash = 0 ; for ( int i = size - 1 ; i > = 0 ; i -- ) { hash = 31 * hash + buf [ i ] ; } return hash ; }
protect int validate range ( int start index , int end index ) { if ( start index < 0 ) { throw new string index out of bound exception ( start index ) ; } if ( end index > size ) { end index = size ; } if ( start index > end index ) { throw new string index out of bound exception ( `` end < start `` ) ; } return end index ; }
protect void validate index ( int index ) { if ( index < 0 || index > size ) { throw new string index out of bound exception ( index ) ; } }
public static str lookup map lookup ( map map ) { return new map str lookup ( map ) ; }
public static str matcher char matcher ( char ch ) { return new char matcher ( ch ) ; }
public static str matcher string matcher ( string str ) { if ( str == null || str . length ( ) == 0 ) { return none_matcher ; } return new string matcher ( str ) ; }
public str substitutor set variable prefix matcher ( str matcher prefix matcher ) { if ( prefix matcher == null ) { throw new illegal argument exception ( `` variable prefix matcher must not be null ! `` ) ; } this . prefix matcher = prefix matcher ; return this ; }
public str matcher get delimiter matcher ( ) { return this . delim matcher ; }
public str tokenizer set quote matcher ( str matcher quote ) { if ( quote ! = null ) { this . quote matcher = quote ; } return this ; }
public str tokenizer set empty token a null ( boolean empty a null ) { this . empty a null = empty a null ; return this ; }
public boolean be ignore empty token ( ) { return ignore empty token ; }
public string get content ( ) { if ( char == null ) { return null ; } return new string ( char ) ; }
public void suspend ( ) { if ( this . run state ! = state_running ) { throw new illegal state exception ( `` stopwatch must be run to suspend . `` ) ; } this . stop time = system . current time millis ( ) ; this . run state = state_suspended ; }
public static void be true ( boolean expression , string message , object value ) { if ( expression == false ) { throw new illegal argument exception ( message + value ) ; } }
public static string initial ( string str ) { return initial ( str , null ) ; }
public static boolean not equal ( object object1 , object object2 ) { return object utils . equal ( object1 , object2 ) == false ; }
public static object clone ( final object o ) { if ( o instanceof cloneable ) { final object result ; if ( o . get class ( ) . be array ( ) ) { final class component type = o . get class ( ) . get component type ( ) ; if ( ! component type . be primitive ( ) ) { result = ( ( object [ ] ) o ) . clone ( ) ; } else { int length = array . get length ( o ) ; result = array . new instance ( component type , length ) ; while ( length -- > 0 ) { array . set ( result , length , array . get ( o , length ) ) ; } } } else { try { result = method utils . invoke method ( o , `` clone `` , null ) ; } catch ( final no such method exception e ) { throw new clone fail exception ( `` cloneable type `` + o . get class ( ) . get name ( ) + `` have no clone method `` , e ) ; } catch ( final illegal access exception e ) { throw new clone fail exception ( `` can not clone cloneable type `` + o . get class ( ) . get name ( ) , e ) ; } catch ( final invocation target exception e ) { throw new clone fail exception ( `` exception clone cloneable type `` + o . get class ( ) . get name ( ) , e . get target exception ( ) ) ; } } return result ; } return null ; }
public static < e extend enum < e > > boolean be valid enum ( class < e > enum class , string enum name ) { if ( enum name == null ) { return false ; } try { enum . value of ( enum class , enum name ) ; return true ; } catch ( illegal argument exception ex ) { return false ; } }
public static < e extend enum < e > > long generate bit vector ( class < e > enum class , e . . . value ) { validate . no null element ( value ) ; return generate bit vector ( enum class , array . < e > a list ( value ) ) ; }
public static int hash code multi ( object . . . object ) { int hash = 1 ; if ( object ! = null ) { for ( object object : object ) { hash = hash * 31 + object utils . hash code ( object ) ; } } return hash ; }
public static < t extend comparable < ? super t > > int compare ( t c1 , t c2 ) { return compare ( c1 , c2 , false ) ; }
public static < t extend comparable < t > > range < t > be ( t element ) { return between ( element , element , null ) ; }
public static object read field ( field field , object target , boolean force access ) throw illegal access exception { if ( field == null ) { throw new illegal argument exception ( `` the field must not be null `` ) ; } if ( force access & & ! field . be accessible ( ) ) { field . set accessible ( true ) ; } else { member utils . set accessible workaround ( field ) ; } return field . get ( target ) ; }
public static void write field ( field field , object target , object value , boolean force access ) throw illegal access exception { if ( field == null ) { throw new illegal argument exception ( `` the field must not be null `` ) ; } if ( force access & & ! field . be accessible ( ) ) { field . set accessible ( true ) ; } else { member utils . set accessible workaround ( field ) ; } field . set ( target , value ) ; }
public static numeric entity escaper above ( int codepoint ) { return outside of ( 0 , codepoint ) ; }
public static numeric entity escaper between ( int codepoint low , int codepoint high ) { return new numeric entity escaper ( codepoint low , codepoint high , true ) ; }
public static numeric entity escaper outside of ( int codepoint low , int codepoint high ) { return new numeric entity escaper ( codepoint low , codepoint high , false ) ; }
public void set right ( r right ) { this . right = right ; }
public static < t > t [ ] valid index ( t [ ] array , int index , string message , object . . . value ) { validate . not null ( array ) ; if ( index < 0 || index > = array . length ) { throw new index out of bound exception ( string . format ( message , value ) ) ; } return array ; }
public static bit set index of ( final boolean [ ] array , final boolean value to find , int start index ) { final bit set bit set = new bit set ( ) ; if ( array == null ) { return bit set ; } while ( start index < array . length ) { start index = index of ( array , value to find , start index ) ; if ( start index == index_not_found ) { break ; } bit set . set ( start index ) ; ++start index ; } return bit set ; }
public static boolean be equal ( final object array1 , final object array2 ) { return new equal builder ( ) . append ( array1 , array2 ) . be equal ( ) ; }
public static int last index of ( final boolean [ ] array , final boolean value to find ) { return last index of ( array , value to find , integer . max_value ) ; }
public static int [ ] remove all occurences ( final int [ ] array , final int element ) { return ( int [ ] ) remove all ( ( object ) array , index of ( array , element ) ) ; }
public static void shift ( final boolean [ ] array , final int offset ) { if ( array == null ) { return ; } shift ( array , 0 , array . length , offset ) ; }
public static void swap ( final double [ ] array , final int offset1 , final int offset2 ) { if ( be empty ( array ) ) { return ; } swap ( array , offset1 , offset2 , 1 ) ; }
public static void swap ( final int [ ] array , int offset1 , int offset2 , int len ) { if ( be empty ( array ) || offset1 > = array . length || offset2 > = array . length ) { return ; } if ( offset1 < 0 ) { offset1 = 0 ; } if ( offset2 < 0 ) { offset2 = 0 ; } len = math . min ( math . min ( len , array . length - offset1 ) , array . length - offset2 ) ; for ( int i = 0 ; i < len ; i++ , offset1++ , offset2++ ) { final int aux = array [ offset1 ] ; array [ offset1 ] = array [ offset2 ] ; array [ offset2 ] = aux ; } }
public static char [ ] to primitive ( final character [ ] array ) { if ( array == null ) { return null ; } else if ( array . length == 0 ) { return empty_char_array ; } final char [ ] result = new char [ array . length ] ; for ( int i = 0 ; i < array . length ; i++ ) { result [ i ] = array [ i ] . char value ( ) ; } return result ; }
public static double [ ] to primitive ( final double [ ] array ) { if ( array == null ) { return null ; } else if ( array . length == 0 ) { return empty_double_array ; } final double [ ] result = new double [ array . length ] ; for ( int i = 0 ; i < array . length ; i++ ) { result [ i ] = array [ i ] . double value ( ) ; } return result ; }
public static object to primitive ( final object array ) { if ( array == null ) { return null ; } final class < ? > ct = array . get class ( ) . get component type ( ) ; final class < ? > pt = class utils . wrapper to primitive ( ct ) ; if ( integer . type . equal ( pt ) ) { return to primitive ( ( integer [ ] ) array ) ; } if ( long . type . equal ( pt ) ) { return to primitive ( ( long [ ] ) array ) ; } if ( short . type . equal ( pt ) ) { return to primitive ( ( short [ ] ) array ) ; } if ( double . type . equal ( pt ) ) { return to primitive ( ( double [ ] ) array ) ; } if ( float . type . equal ( pt ) ) { return to primitive ( ( float [ ] ) array ) ; } return array ; }
public static short [ ] to primitive ( final short [ ] array ) { if ( array == null ) { return null ; } else if ( array . length == 0 ) { return empty_short_array ; } final short [ ] result = new short [ array . length ] ; for ( int i = 0 ; i < array . length ; i++ ) { result [ i ] = array [ i ] . short value ( ) ; } return result ; }
public equal builder set test transient ( final boolean test transient ) { this . test transient = test transient ; return this ; }
public equal builder set exclude field ( final string . . . exclude field ) { this . exclude field = exclude field ; return this ; }
public static < a extend comparable < a > > comparable check builder < a > be ( final a a ) { return new comparable check builder < > ( a ) ; }
public void add change listener ( final property change listener listener ) { change support . add property change listener ( listener ) ; }
public int get opening threshold ( ) { return open threshold ; }
public static boolean be assignable ( final type type , final type to type ) { return be assignable ( type , to type , null ) ; }
public static string remove first ( final string text , final pattern regex ) { return replace first ( text , regex , string utils . empty ) ; }
public static string replace all ( final string text , final string regex , final string replacement ) { if ( text == null || regex == null || replacement == null ) { return text ; } return text . replace all ( regex , replacement ) ; }
public static string replace first ( final string text , final pattern regex , final string replacement ) { if ( text == null || regex == null|| replacement == null ) { return text ; } return regex . matcher ( text ) . replace first ( replacement ) ; }
public str substitutor set value delimiter ( final char value delimiter ) { return set value delimiter matcher ( str matcher . char matcher ( value delimiter ) ) ; }
public static thread group get system thread group ( ) { thread group thread group = thread . current thread ( ) . get thread group ( ) ; while ( thread group . get parent ( ) ! = null ) { thread group = thread group . get parent ( ) ; } return thread group ; }
public static collection < thread > find thread ( final thread predicate predicate ) { return find thread ( get system thread group ( ) , true , predicate ) ; }
public int get month ( ) { return calendar . get ( calendar . month ) ; }
public static fast date format get time instance ( final int style , final time zone time zone ) { return cache . get time instance ( style , time zone , null ) ; }
public static fast date format get date time instance ( final int date style , final int time style ) { return cache . get date time instance ( date style , time style , null , null ) ; }
public static fast date format get date time instance ( final int date style , final int time style , final time zone time zone ) { return get date time instance ( date style , time style , time zone , null ) ; }
public time zone get time zone ( ) { return printer . get time zone ( ) ; }
public int hash code ( ) { return pattern . hash code ( ) + 13 * ( time zone . hash code ( ) + 13 * locale . hash code ( ) ) ; }
public boolean be stop ( ) { return run state . be stop ( ) ; }
public string to string ( ) { return `` fast date parser [ `` + pattern + `` , `` + locale + `` , `` + time zone . get i d ( ) + `` ] `` ; }
public int hash code ( ) { return printer . hash code ( ) ; }
public int hash code ( ) { return pattern . hash code ( ) + 13 * ( time zone . hash code ( ) + 13 * locale . hash code ( ) ) ; }
public logger get logger ( ) { return logger ; }
public void error ( object message , throwable t ) { if ( get logger ( ) . be error enable ( ) ) get logger ( ) . error ( string . value of ( message ) , t ) ; }
public void fatal ( object message , throwable t ) { if ( get logger ( ) . be fatal error enable ( ) ) get logger ( ) . fatal error ( string . value of ( message ) , t ) ; }
public boolean be error enabled ( ) { return get logger ( ) . be error enable ( ) ; }
public boolean be warn enabled ( ) { return get logger ( ) . be warn enable ( ) ; }
public boolean be trace enable ( ) { return ( get logger ( ) . be loggable ( level . fine ) ) ; }
public void debug ( object message ) { get logger ( ) . log ( fqcn , priority . debug , message , null ) ; }
public void error ( object message ) { get logger ( ) . log ( fqcn , priority . error , message , null ) ; }
public boolean be debug enabled ( ) { return get logger ( ) . be debug enable ( ) ; }
protect boolean be jdk13 lumberjack available ( ) { return be log library available ( `` jdk13 lumberjack `` , `` org . apache . common . log . impl . jdk13 lumberjack logger `` ) ; }
public void fatal ( object message ) { if ( message ! = null ) { get logger ( ) . fatal error ( string . value of ( message ) ) ; } }
public final boolean be info enable ( ) { return false ; }
protect static final void log raw diagnostic ( string msg ) { throw new unsupported operation exception ( ) ; }
public int get nb point ( ) { return nb point ; }
protect void increment count ( ) throw max count exceed exception { count . increment ( ) ; }
public double get weight ( int index ) { return weight [ index ] ; }
protect void compute coefficient ( ) { final int n = degree ( ) ; coefficient = new double [ n+1 ] ; for ( int i = 0 ; i < = n ; i++ ) { coefficient [ i ] = 0 . 0 ; } coefficient [ 0 ] = a [ n ] ; for ( int i = n-1 ; i > = 0 ; i -- ) { for ( int j = n-i ; j > 0 ; j -- ) { coefficient [ j ] = coefficient [ j-1 ] - c [ i ] * coefficient [ j ] ; } coefficient [ 0 ] = a [ i ] - c [ i ] * coefficient [ 0 ] ; } coefficient compute = true ; }
public static polynomial function create legendre polynomial ( final int degree ) { return build polynomial ( degree , legendre_coefficients , new recurrence coefficient generator ( ) { / * * { @ inherit doc } * / public big fraction [ ] generate ( int k ) { final int k p1 = k + 1 ; return new big fraction [ ] { big fraction . zero , new big fraction ( k + k p1 , k p1 ) , new big fraction ( k , k p1 ) } ; } } ) ; }
public quaternion multiply ( final double alpha ) { return new quaternion ( alpha * q0 , alpha * q1 , alpha * q2 , alpha * q3 ) ; }
public dfp get relative accuracy ( ) { return super . get relative accuracy ( ) ; }
public void set i e e e flag ( final int flag ) { ieee flag = flag & ( flag_invalid | flag_div_zero | flag_overflow | flag_underflow | flag_inexact ) ; }
public dfp get two ( ) { return two ; }
public dfp get ln5 ( ) { return ln5 ; }
public double get numerator degree of freedom ( ) { return numerator degree of freedom ; }
public double get lo ( ) { return lo ; }
public least square builder target ( final real vector new target ) { this . target = new target ; return this ; }
public double get x ( ) { return x ; }
public p get center ( ) { return center ; }
public interval set whole space ( ) { return new interval set ( tolerance ) ; }
public vector1 d get location ( ) { return location ; }
public static vector1 d format get instance ( ) { return get instance ( locale . get default ( ) ) ; }
public t get q1 ( ) { return q1 ; }
public field vector3 d < t > get axis ( ) { return get axis ( rotation convention . vector_operator ) ; }
public t get delta ( ) { return z . divide ( get norm ( ) ) . asin ( ) ; }
public field vector3 d < t > scalar multiply ( final t a ) { return new field vector3 d < t > ( x . multiply ( a ) , y . multiply ( a ) , z . multiply ( a ) ) ; }
public boolean be na n ( ) { return double . be na n ( x . get real ( ) ) || double . be na n ( y . get real ( ) ) || double . be na n ( z . get real ( ) ) ; }
public boolean be similar to ( final line line ) { final double angle = vector3 d . angle ( direction , line . direction ) ; return ( ( angle < tolerance ) || ( angle > ( fast math . pi - tolerance ) ) ) & & contains ( line . zero ) ; }
public vector3 d get u ( ) { return u ; }
public void revert self ( ) { final vector3 d tmp = u ; u = v ; v = tmp ; w = w . negate ( ) ; origin offset = -origin offset ; }
public vector3 d get end ( ) { return end ; }
public double get phi ( ) { return phi ; }
public void reset ( final vector2 d p , final double alpha ) { unlink reverse ( ) ; this . angle = math utils . normalize angle ( alpha , fast math . pi ) ; cos = fast math . co ( this . angle ) ; sin = fast math . sin ( this . angle ) ; origin offset = math array . linear combination ( co , p . get y ( ) , -sin , p . get x ( ) ) ; }
public boolean contains ( final vector2 d p ) { return fast math . ab ( get offset ( p ) ) < tolerance ; }
public double get origin offset ( ) { return origin offset ; }
public list < arc > a list ( ) { final list < arc > list = new array list < arc > ( ) ; for ( final double [ ] a : this ) { list . add ( new arc ( a [ 0 ] , a [ 1 ] , get tolerance ( ) ) ) ; } return list ; }
public vector3 d get pole ( ) { return pole ; }
public string get prefix ( ) { return prefix ; }
public string get suffix ( ) { return suffix ; }
public field matrix < t > outer product ( array field vector < t > v ) { final int m = data . length ; final int n = v . data . length ; final field matrix < t > out = new array2 d row field matrix < t > ( field , m , n ) ; for ( int i = 0 ; i < m ; i++ ) { for ( int j = 0 ; j < n ; j++ ) { out . set entry ( i , j , data [ i ] . multiply ( v . data [ j ] ) ) ; } } return out ; }
protect void check vector dimension ( field vector < t > v ) throw dimension mismatch exception { check vector dimension ( v . get dimension ( ) ) ; }
public static void check symmetric ( real matrix matrix , double eps ) { be symmetric internal ( matrix , eps , true ) ; }
public double get l1 norm ( ) { double norm = 0 ; iterator < entry > it = iterator ( ) ; while ( it . have next ( ) ) { final entry e = it . next ( ) ; norm += fast math . ab ( e . get value ( ) ) ; } return norm ; }
public collection < neuron > get neuron ( comparator < neuron > comparator ) { final list < neuron > neuron = new array list < neuron > ( ) ; neuron . add all ( neuron map . value ( ) ) ; collection . sort ( neuron , comparator ) ; return neuron ; }
public int get number of column ( ) { return number of column ; }
protected field o d e state and derivative < t > get step start ( ) { return step start ; }
public void extract equation data ( double [ ] complete , double [ ] equation data ) throw dimension mismatch exception { if ( equation data . length ! = dimension ) { throw new dimension mismatch exception ( equation data . length , dimension ) ; } system . arraycopy ( complete , first index , equation data , 0 , dimension ) ; }
public double get event time ( ) { return pending event ? pending event time : ( forward ? double . positive_infinity : double . negative_infinity ) ; }
public first order differential equation get primary ( ) { return primary ; }
public double get time ( ) { return time ; }
public t [ ] map state ( final field o d e state < t > state ) { final t [ ] y = math array . build array ( state . get time ( ) . get field ( ) , get total dimension ( ) ) ; int index = 0 ; insert equation data ( index , state . get state ( ) , y ) ; while ( ++index < get number of equation ( ) ) { insert equation data ( index , state . get secondary state ( index ) , y ) ; } return y ; }
public field equation mapper < t > get mapper ( ) { return mapper ; }
public int get state dimension ( ) { return state . length ; }
public void add parameter jacobian provider ( final parameter jacobian provider provider ) { jacobian provider . add ( provider ) ; }
protect t compute step grow shrink factor ( final t error ) { return math utils . min ( error . get field ( ) . get zero ( ) . add ( max growth ) , math utils . max ( error . get field ( ) . get zero ( ) . add ( min reduction ) , error . pow ( exp ) . multiply ( safety ) ) ) ; }
protect void do finalize ( ) throw max count exceed exception { }
public int get evaluation ( ) { return evaluation . get count ( ) ; }
protect integer get basic row ( final int col ) { final int row = basic variable [ col ] ; return row == -1 ? null : row ; }
protect final int get num decision variable ( ) { return num decision variable ; }
public double get r m s ( ) { return fast math . sqrt ( get chi square ( ) / get target size ( ) ) ; }
protect func get objective function ( ) { return function ; }
public relationship get relationship ( ) { return relationship ; }
public double next gaussian ( ) { if ( ! double . be na n ( cache normal deviate ) ) { double dev = cache normal deviate ; cache normal deviate = double . na n ; return dev ; } double v1 = 0 ; double v2 = 0 ; double s = 1 ; while ( s > =1 ) { v1 = 2 * next double ( ) - 1 ; v2 = 2 * next double ( ) - 1 ; s = v1 * v1 + v2 * v2 ; } if ( s ! = 0 ) { s = fast math . sqrt ( -2 * fast math . log ( s ) / s ) ; } cache normal deviate = v2 * s ; return v1 * s ; }
public int get rank ( ) { return normalize . length ; }
public boolean be load ( ) { return load ; }
public double next normalize double ( ) { return generator . next gaussian ( ) ; }
public static double erf ( double x ) { if ( fast math . ab ( x ) > 40 ) { return x > 0 ? 1 : -1 ; } final double ret = gamma . regularize gamma p ( 0 . 5 , x * x , 1 . 0e-15 , 10000 ) ; return x < 0 ? -ret : ret ; }
public static double inv gamma1pm1 ( final double x ) { if ( x < -0 . 5 ) { throw new number be too small exception ( x , -0 . 5 , true ) ; } if ( x > 1 . 5 ) { throw new number be too large exception ( x , 1 . 5 , true ) ; } final double ret ; final double t = x < = 0 . 5 ? x : ( x - 0 . 5 ) - 0 . 5 ; if ( t < 0 . 0 ) { final double a = inv_gamma1p_m1_a0 + t * inv_gamma1p_m1_a1 ; double b = inv_gamma1p_m1_b8 ; b = inv_gamma1p_m1_b7 + t * b ; b = inv_gamma1p_m1_b6 + t * b ; b = inv_gamma1p_m1_b5 + t * b ; b = inv_gamma1p_m1_b4 + t * b ; b = inv_gamma1p_m1_b3 + t * b ; b = inv_gamma1p_m1_b2 + t * b ; b = inv_gamma1p_m1_b1 + t * b ; b = 1 . 0 + t * b ; double c = inv_gamma1p_m1_c13 + t * ( a / b ) ; c = inv_gamma1p_m1_c12 + t * c ; c = inv_gamma1p_m1_c11 + t * c ; c = inv_gamma1p_m1_c10 + t * c ; c = inv_gamma1p_m1_c9 + t * c ; c = inv_gamma1p_m1_c8 + t * c ; c = inv_gamma1p_m1_c7 + t * c ; c = inv_gamma1p_m1_c6 + t * c ; c = inv_gamma1p_m1_c5 + t * c ; c = inv_gamma1p_m1_c4 + t * c ; c = inv_gamma1p_m1_c3 + t * c ; c = inv_gamma1p_m1_c2 + t * c ; c = inv_gamma1p_m1_c1 + t * c ; c = inv_gamma1p_m1_c + t * c ; if ( x > 0 . 5 ) { ret = t * c / x ; } else { ret = x * ( ( c + 0 . 5 ) + 0 . 5 ) ; } } else { double p = inv_gamma1p_m1_p6 ; p = inv_gamma1p_m1_p5 + t * p ; p = inv_gamma1p_m1_p4 + t * p ; p = inv_gamma1p_m1_p3 + t * p ; p = inv_gamma1p_m1_p2 + t * p ; p = inv_gamma1p_m1_p1 + t * p ; p = inv_gamma1p_m1_p0 + t * p ; double q = inv_gamma1p_m1_q4 ; q = inv_gamma1p_m1_q3 + t * q ; q = inv_gamma1p_m1_q2 + t * q ; q = inv_gamma1p_m1_q1 + t * q ; q = 1 . 0 + t * q ; double c = inv_gamma1p_m1_c13 + ( p / q ) * t ; c = inv_gamma1p_m1_c12 + t * c ; c = inv_gamma1p_m1_c11 + t * c ; c = inv_gamma1p_m1_c10 + t * c ; c = inv_gamma1p_m1_c9 + t * c ; c = inv_gamma1p_m1_c8 + t * c ; c = inv_gamma1p_m1_c7 + t * c ; c = inv_gamma1p_m1_c6 + t * c ; c = inv_gamma1p_m1_c5 + t * c ; c = inv_gamma1p_m1_c4 + t * c ; c = inv_gamma1p_m1_c3 + t * c ; c = inv_gamma1p_m1_c2 + t * c ; c = inv_gamma1p_m1_c1 + t * c ; c = inv_gamma1p_m1_c0 + t * c ; if ( x > 0 . 5 ) { ret = ( t / x ) * ( ( c - 0 . 5 ) - 0 . 5 ) ; } else { ret = x * c ; } } return ret ; }
public double get standard deviation ( ) { double std dev = double . na n ; if ( get n ( ) > 0 ) { if ( get n ( ) > 1 ) { std dev = fast math . sqrt ( get variance ( ) ) ; } else { std dev = 0 . 0 ; } } return std dev ; }
public double get skewness ( ) { return apply ( skewness impl ) ; }
public void clear ( ) { e d a . clear ( ) ; }
public int get window size ( ) { return window size ; }
public synchronize void set kurtosis impl ( univariate statistic kurtosis impl ) { this . kurtosis impl = kurtosis impl ; }
public synchronize void set max impl ( univariate statistic max impl ) { this . max impl = max impl ; }
public double evaluate ( final double [ ] value , final double mean ) throw math illegal argument exception { return evaluate ( value , mean , 0 , value . length ) ; }
public double evaluate ( final double [ ] value , final double [ ] weight , final int begin , final int length ) throw math illegal argument exception { double product = double . na n ; if ( test ( value , weight , begin , length , true ) ) { product = 1 . 0 ; for ( int i = begin ; i < begin + length ; i++ ) { product * = fast math . pow ( value [ i ] , weight [ i ] ) ; } } return product ; }
public double evaluate ( final double [ ] value , final double [ ] weight ) throw math illegal argument exception { return evaluate ( value , weight , 0 , value . length ) ; }
public iterator < comparable < ? > > value iterator ( ) { return freq table . key set ( ) . iterator ( ) ; }
public double get pct ( comparable < ? > v ) { final long sum freq = get sum freq ( ) ; if ( sum freq == 0 ) { return double . na n ; } return ( double ) get count ( v ) / ( double ) sum freq ; }
public double kolmogorov smirnov statistic ( real distribution distribution , double [ ] data ) { check array ( data ) ; final int n = data . length ; final double nd = n ; final double [ ] data copy = new double [ n ] ; system . arraycopy ( data , 0 , data copy , 0 , n ) ; array . sort ( data copy ) ; double d = 0d ; for ( int i = 1 ; i < = n ; i++ ) { final double yi = distribution . cumulative probability ( data copy [ i - 1 ] ) ; final double curr d = fast math . max ( yi - ( i - 1 ) / nd , i / nd - yi ) ; if ( curr d > d ) { d = curr d ; } } return d ; }
public double kolmogorov smirnov statistic ( double [ ] x , double [ ] y ) { return integral kolmogorov smirnov statistic ( x , y ) / ( ( double ) ( x . length * ( long ) y . length ) ) ; }
protect real matrix calculate beta variance ( ) { int p = get x ( ) . get column dimension ( ) ; real matrix raug = qr . get r ( ) . get sub matrix ( 0 , p - 1 , 0 , p - 1 ) ; real matrix rinv = new l u decomposition ( raug ) . get solver ( ) . get inverse ( ) ; return rinv . multiply ( rinv . transpose ( ) ) ; }
public long get n ( ) { return n ; }
public double get intercept std err ( ) { if ( ! have intercept ) { return double . na n ; } return fast math . sqrt ( get mean square error ( ) * ( ( 1d / n ) + ( xbar * xbar ) / sum x x ) ) ; }
public static double variance ( final double [ ] value , final int begin , final int length ) throw math illegal argument exception { return variance . evaluate ( value , begin , length ) ; }
public static double max ( final double [ ] value , final int begin , final int length ) throw math illegal argument exception { return max . evaluate ( value , begin , length ) ; }
public static iterator < int [ ] > combination iterator ( int n , int k ) { return new combination ( n , k ) . iterator ( ) ; }
public void add iteration listener ( final iteration listener listener ) { listener . add ( listener ) ; }
public static void check not null ( object o ) throw null argument exception { if ( o == null ) { throw new null argument exception ( ) ; } }
public iterator iterator ( ) { return new iterator ( ) ; }
public double transform ( object o ) throw math illegal argument exception { double value = double . na n ; if ( o instanceof number || o instanceof string ) { value = default transformer . transform ( o ) ; } else { number transformer trans = get transformer ( o . get class ( ) ) ; if ( trans ! = null ) { value = trans . transform ( o ) ; } } return value ; }
public static string to camel case ( string str , final boolean capitalize first letter , final char . . . delimiters ) { if ( string utils . be empty ( str ) ) { return str ; } str = str . to lower case ( ) ; final int str len = str . length ( ) ; final int [ ] new code point = new int [ str len ] ; int out offset = 0 ; final set < integer > delimiter set = generate delimiter set ( delimiters ) ; boolean capitalize next = false ; if ( capitalize first letter ) { capitalize next = true ; } for ( int index = 0 ; index < str len ; ) { final int code point = str . code point at ( index ) ; if ( delimiter set . contains ( code point ) ) { capitalize next = true ; if ( out offset == 0 ) { capitalize next = false ; } index += character . char count ( code point ) ; } else if ( capitalize next || out offset == 0 & & capitalize first letter ) { final int title case code point = character . to title case ( code point ) ; new code point [ out offset++ ] = title case code point ; index += character . char count ( title case code point ) ; capitalize next = false ; } else { new code point [ out offset++ ] = code point ; index += character . char count ( code point ) ; } } if ( out offset ! = 0 ) { return new string ( new code point , 0 , out offset ) ; } return str ; }
public string matcher split matcher ( ) { return split_matcher ; }
public string matcher string matcher ( final string str ) { if ( str == null || str . length ( ) == 0 ) { return none_matcher ; } return new abstract string matcher . string matcher ( str ) ; }
public char sequence get leave ( ) { return leave ; }
public int [ ] [ ] long common substring length array ( final char sequence leave , final char sequence right ) { final int [ ] [ ] lcs length array = new int [ leave . length ( ) + 1 ] [ right . length ( ) + 1 ] ; for ( int i = 0 ; i < leave . length ( ) ; i++ ) { for ( int j = 0 ; j < right . length ( ) ; j++ ) { if ( i == 0 ) { lcs length array [ i ] [ j ] = 0 ; } if ( j == 0 ) { lcs length array [ i ] [ j ] = 0 ; } if ( left . char at ( i ) == right . char at ( j ) ) { lcs length array [ i + 1 ] [ j + 1 ] = lcs length array [ i ] [ j ] + 1 ; } else { lcs length array [ i + 1 ] [ j + 1 ] = math . max ( lcs length array [ i + 1 ] [ j ] , lcs length array [ i ] [ j + 1 ] ) ; } } } return lcs length array ; }
public string replace ( final char sequence source ) { if ( source == null ) { return null ; } return replace ( source , 0 , source . length ( ) ) ; }
public text string builder append separator ( final string standard , final string default if empty ) { final string str = be empty ( ) ? default if empty : standard ; if ( str ! = null ) { append ( str ) ; } return this ; }
public text string builder append fix width pad leave ( final object obj , final int width , final char pad char ) { if ( width > 0 ) { ensure capacity ( size + width ) ; string str = ( obj == null ? get null text ( ) : obj . to string ( ) ) ; if ( str == null ) { str = `` `` ; } final int str len = str . length ( ) ; if ( str len > = width ) { str . get char ( str len - width , str len , buffer , size ) ; } else { final int pad len = width - str len ; for ( int i = 0 ; i < pad len ; i++ ) { buffer [ size + i ] = pad char ; } str . get char ( 0 , str len , buffer , size + pad len ) ; } size += width ; } return this ; }
public text string builder insert ( final int index , final object obj ) { if ( obj == null ) { return insert ( index , null text ) ; } return insert ( index , obj . to string ( ) ) ; }
public string lookup ( final string key ) { if ( key == null ) { return null ; } final string [ ] key = key . split ( string . value of ( split_ch ) ) ; final int key len = key . length ; if ( key len < 2 ) { throw illegal argument exception . format ( `` bad file key format [ % s ] , expect format be charset name : document path . `` , key ) ; } final string charset name = key [ 0 ] ; final string file name = string utils . substring after ( key , split_ch ) ; try { return new string ( file . read all byte ( path . get ( file name ) ) , charset name ) ; } catch ( final exception e ) { throw illegal argument exception . format ( e , `` error look up file [ % s ] with charset [ % s ] . `` , file name , charset name ) ; } }
public static void clear ( ) { constant string lookup . clear ( ) ; }
public boolean be enable undefined variable exception ( ) { return enable undefined variable exception ; }
public boolean be reallocate ( ) { return reallocation > 0 ; }
public static string capitalize fully ( string str , final char . . . delimiters ) { if ( string utils . be empty ( str ) ) { return str ; } str = str . to lower case ( ) ; return capitalize ( str , delimiters ) ; }
protect boolean be valid user ( string user ) { return user_pattern . matcher ( user ) . match ( ) ; }
protect string strip comment ( string email str ) { string result = email str ; string comment pat = `` ^ ( ( ? : [ ^\ `` \\\\ ] |\\\\ . ) * ( ? : \ `` ( ? : [ ^\ `` \\\\ ] |\\\\ . ) * \ `` ( ? : [ ^\ `` \\\\ ] |\111111\\\\ . ) * ) * ) \\ ( ( ? : [ ^ ( ) \\\\ ] |\\\\ . ) * \\ ) / `` ; pattern comment matcher = pattern . compile ( comment pat ) ; while ( comment matcher . matcher ( result ) . match ( ) ) { result = result . replace first ( comment pat , `` \1 `` ) ; } return result ; }
public void set indexed property ( string indexed property ) { this . indexed property = indexed property ; }
protect map get msg map ( ) { return h msg ; }
public static float format float ( string value ) { if ( value == null ) { return null ; } try { return new float ( value ) ; } catch ( number format exception e ) { return null ; } }
public static boolean be in range ( byte value , byte min , byte max ) { return ( ( value > = min ) & & ( value < = max ) ) ; }
public static boolean max length ( string value , int max ) { return ( value . length ( ) < = max ) ; }
public static boolean max length ( string value , int max , int line end length ) { int adjust amount = adjust for line end ( value , line end length ) ; return ( ( value . length ( ) + adjust amount ) < = max ) ; }
public static boolean min length ( string value , int min ) { return ( value . length ( ) > = min ) ; }
public boolean be valid ( string value ) { return be valid ( value , ( string ) null , ( locale ) null ) ; }
protect object process parse value ( object value , format formatter ) { big decimal decimal = null ; if ( value instanceof long ) { decimal = big decimal . value of ( ( ( long ) value ) . long value ( ) ) ; } else { decimal = new big decimal ( value . to string ( ) ) ; } int scale = determine scale ( ( number format ) formatter ) ; if ( scale > = 0 ) { decimal = decimal . set scale ( scale , big decimal . round_down ) ; } return decimal ; }
public byte validate ( string value , locale locale ) { return ( byte ) parse ( value , ( string ) null , locale ) ; }
public calendar validate ( string value ) { return ( calendar ) parse ( value , ( string ) null , ( locale ) null , ( time zone ) null ) ; }
protect int weight value ( int char value , int leave po , int right po ) { int weight = position_weight [ right po % 2 ] ; return ( char value * weight ) ; }
protect int calculate modulus ( string code , boolean include check digit ) throw check digit exception { string buffer transform = new string buffer ( code . length ( ) * 2 ) ; for ( int i = 0 ; i < code . length ( ) ; i++ ) { int char value = character . get numeric value ( code . char at ( i ) ) ; if ( char value < 0 || char value > 35 ) { throw new check digit exception ( `` invalid character [ `` + ( i + 1 ) + `` ] = ' `` + char value + `` ' `` ) ; } transform . append ( char value ) ; } return super . calculate modulus ( transform . to string ( ) , include check digit ) ; }
public static int sum digit ( int number ) { int total = 0 ; int todo = number ; while ( todo > 0 ) { total += todo % 10 ; todo = todo / 10 ; } return total ; }
public int get min length ( ) { return min length ; }
public date validate ( string value , string pattern , locale locale ) { return ( date ) parse ( value , pattern , locale , ( time zone ) null ) ; }
public double validate ( string value ) { return ( double ) parse ( value , ( string ) null , ( locale ) null ) ; }
protect object process parse value ( object value , format formatter ) { double double value = ( ( number ) value ) . double value ( ) ; if ( double value > 0 ) { if ( double value < float . min_value ) { return null ; } if ( double value > float . max_value ) { return null ; } } else if ( double value < 0 ) { double po double = double value * -1 ; if ( po double < float . min_value ) { return null ; } if ( po double > float . max_value ) { return null ; } } return new float ( ( float ) double value ) ; }
public integer validate ( string value , locale locale ) { return ( integer ) parse ( value , ( string ) null , locale ) ; }
public long validate ( string value ) { return ( long ) parse ( value , ( string ) null , ( locale ) null ) ; }
public long validate ( string value , string pattern , locale locale ) { return ( long ) parse ( value , pattern , locale ) ; }
public calendar validate ( string value , string pattern , locale locale ) { return ( calendar ) parse ( value , pattern , locale , ( time zone ) null ) ; }
protect boolean be valid scheme ( string scheme ) { if ( scheme == null ) { return false ; } if ( ! scheme_pattern . matcher ( scheme ) . match ( ) ) { return false ; } if ( be off ( allow_all_schemes ) ) { if ( ! this . allow scheme . contains ( scheme ) ) { return false ; } } return true ; }
protect boolean be valid path ( string path ) { if ( path == null ) { return false ; } if ( ! path_pattern . matcher ( path ) . match ( ) ) { return false ; } int slash2 count = count token ( `` // `` , path ) ; if ( be off ( allow_2_slashes ) & & ( slash2 count > 0 ) ) { return false ; } int slash count = count token ( `` / `` , path ) ; int dot2 count = count token ( `` . . `` , path ) ; if ( dot2 count > 0 ) { if ( ( slash count - slash2 count - 1 ) < = dot2 count ) { return false ; } } return true ; }
public void turn on all ( ) { this . flag = long . max_value ; }
public static string replace ( string value , string key , string replace value ) { if ( value == null || key == null || replace value == null ) { return value ; } int po = value . index of ( key ) ; if ( pos < 0 ) { return value ; } int length = value . length ( ) ; int start = po ; int end = po + key . length ( ) ; if ( length == key . length ( ) ) { value = replace value ; } else if ( end == length ) { value = value . substring ( 0 , start ) + replace value ; } else { value = value . substring ( 0 , start ) + replace value + replace ( value . substring ( end ) , key , replace value ) ; } return value ; }
public list get dependency list ( ) { return collection . unmodifiable list ( this . dependency list ) ; }
public void add constant ( string name , string value ) { if ( get log ( ) . be debug enable ( ) ) { get log ( ) . debug ( `` add global constant : `` + name + `` , `` + value ) ; } this . h constant . put ( name , value ) ; }
public iterator get action ( ) { return collection . unmodifiable map ( h action ) . key set ( ) . iterator ( ) ; }
public static optional < line end > determine line end ( string file data string ) { int lf count = 0 ; int cr count = 0 ; int crlf count = 0 ; for ( int i = 0 ; i < file data string . length ( ) ; i++ ) { char c = file data string . char at ( i ) ; if ( c == '\r ' ) { if ( ( i + 1 ) < file data string . length ( ) & & file data string . char at ( i + 1 ) == '\n ' ) { crlf count++ ; i++ ; } else { cr count++ ; } } else if ( c == '\n ' ) { lf count++ ; } } if ( lf count > cr count & & lf count > crlf count ) { return optional . of ( lf ) ; } else if ( crlf count > lf count & & crlf count > cr count ) { return optional . of ( crlf ) ; } else if ( cr count > lf count & & cr count > crlf count ) { return optional . of ( cr ) ; } return optional . empty ( ) ; }
public final string get output file ( ) { return option . string value ( `` output_file `` ) ; }
public node pop node ( ) { if ( -- sp < mk ) { mk = ( ( integer ) mark . remove ( mark . size ( ) -1 ) ) . int value ( ) ; } return ( node ) node . remove ( node . size ( ) -1 ) ; }
public node peek node ( ) { return ( node ) node . get ( node . size ( ) -1 ) ; }
public final java c c error error ( ) { return error ; }
public int hash code ( ) { return get line ( ) + get column ( ) ; }
public static boolean get build parser ( ) { return option . boolean value ( option . useroption__build_parser ) ; }
public static boolean get common token action ( ) { return option . boolean value ( option . useroption__common_token_action ) ; }
public static int get depth limit ( ) { return option . int value ( option . useroption__depth_limit ) ; }
public object get value ( ) { return null ; }
public void set interval ( double t_min , double t_max ) { if ( t_min > t_max ) throw new illegal argument exception ( `` t_min < = t_max require . `` ) ; this . t_min = t_min ; this . t_max = t_max ; }
public double t_max ( ) { return t_max ; }
public int get capacity ( ) { return point . length ; }
public boolean intersects ( double x1 , double y1 , double w , double h ) { double x2 = x1 + w ; double y2 = y1 + h ; if ( contains ( x1 , y1 ) ) return true ; if ( contains ( x1 , y2 ) ) return true ; if ( contains ( x2 , y1 ) ) return true ; if ( contains ( x2 , y2 ) ) return true ; int n = get num point ( ) ; if ( n == 0 ) return false ; double [ ] p = get ( 0 ) ; double xb = p [ ai0 ] ; double yb = p [ ai1 ] ; for ( int i = 1 ; i < n ; i++ ) { p = get ( i ) ; double xa = p [ ai0 ] ; double ya = p [ ai1 ] ; if ( get type ( i ) == multi path . line_to ) { if ( geom . get seg seg intersection ( xa , ya , xb , yb , x1 , y1 , x2 , y1 , null ) == geom . intersect ) return true ; if ( geom . get seg seg intersection ( xa , ya , xb , yb , x1 , y1 , x1 , y2 , null ) == geom . intersect ) return true ; if ( geom . get seg seg intersection ( xa , ya , xb , yb , x1 , y2 , x2 , y2 , null ) == geom . intersect ) return true ; if ( geom . get seg seg intersection ( xa , ya , xb , yb , x2 , y1 , x2 , y2 , null ) == geom . intersect ) return true ; if ( xa > = x1 & & ya > = y1 & & xa < = x2 & & ya < = y2 ) return true ; if ( xb > = x1 & & yb > = y1 & & xb < = x2 & & yb < = y2 ) return true ; } xb = xa ; yb = ya ; } return false ; }
public void add ( double d ) { insert ( d , size ) ; }
public static double pt line dist sq ( double x1 , double y1 , double x2 , double y2 , double x , double y , double [ ] result ) { double run = x2 - x1 ; double rise = y2 - y1 ; double t = 0 . 0 ; double f = run * run + rise * rise ; if ( f ! = 0 ) t = ( run * ( x - x1 ) + rise * ( y - y1 ) ) / f ; double nx = x1 + t * run ; double ny = y1 + t * rise ; if ( result ! = null ) { result [ 0 ] = nx ; result [ 1 ] = ny ; result [ 2 ] = t ; } double dx = x - nx ; double dy = y - ny ; return dx * dx + dy * dy ; }
public static double pt seg dist sq ( double x1 , double y1 , double x2 , double y2 , double x , double y , double [ ] result ) { double run = x2 - x1 ; double rise = y2 - y1 ; double t = 0 . 0 ; double f = run * run + rise * rise ; if ( f ! = 0 ) t = ( run * ( x - x1 ) + rise * ( y - y1 ) ) / f ; if ( t < 0 ) t = 0 . 0 ; else if ( t > 1 ) t = 1 . 0 ; double nx = x1 + t * run ; double ny = y1 + t * rise ; if ( result ! = null ) { result [ 0 ] = nx ; result [ 1 ] = ny ; result [ 2 ] = t ; } double dx = x - nx ; double dy = y - ny ; return dx * dx + dy * dy ; }
public static object get line seg intersection ( double x1 , double y1 , double x2 , double y2 , double x3 , double y3 , double x4 , double y4 , double [ ] result ) { double bx = x2 - x1 ; double by = y2 - y1 ; double dx = x4 - x3 ; double dy = y4 - y3 ; double b_dot_d_perp = bx * dy - by * dx ; if ( b_dot_d_perp == 0 ) return parallel ; double cx = x3 - x1 ; double cy = y3 - y1 ; double u = ( cx * by - cy * bx ) / b_dot_d_perp ; if ( u < 0 || u > 1 ) return null ; if ( result ! = null ) { result [ 0 ] = x3 + u * dx ; result [ 1 ] = y3 + u * dy ; result [ 2 ] = u ; } return intersect ; }
public string to string ( ) { return `` ( `` + index + `` ) `` + descrip ; }
public double of ( double [ ] d , int num param ) { int n = ( int ) d [ 0 ] ; double result = 1 ; for ( int i = n ; i > 1 ; i -- ) result * = i ; return result ; }
public void add ( expression x ) { insert ( x , bag . size ( ) ) ; }
public static synchronize void free config source ( ) { config source . remove ( config resolver . class . get class loader ( ) ) ; }
public set < annotation > get qualifier ( ) { return collection . unmodifiable set ( qualifier ) ; }
public bean < t > create ( ) { if ( ! passivation capable ) { return new immutable bean < t > ( bean class , name , qualifier , scope , stereotype , type , alternative , nullable , injection point , to string , bean lifecycle ) ; } else { return new immutable passivation capable bean < t > ( bean class , name , qualifier , scope , stereotype , type , alternative , nullable , injection point , to string , bean lifecycle , id ) ; } }
public set < type > get type ( ) { return type ; }
public bean builder < t > add type ( type type ) { this . type . add ( type ) ; return this ; }
public bean builder < t > bean class ( class < ? > bean class ) { this . bean class = bean class ; return this ; }
public static boolean be final ( class < ? > clazz ) { return modifier . be final ( clazz . get modifier ( ) ) ; }
public void load schema ( document schema document ) { schema builder . build ( schema document ) ; }
protect q name cache create q name cache ( ) { return new q name cache ( this ) ; }
public static void sort ( list < node > list , string xpath expression ) { x path xpath = create x path ( xpath expression ) ; xpath . sort ( list ) ; }
public string get public i d ( ) { return public i d ; }
public void set default handler ( element handler handler ) { default handler = handler ; }
public boolean be ignore comment ( ) { return ignore comment ; }
public void set ignore comment ( boolean ignore comment ) { this . ignore comment = ignore comment ; }
public void set pad text ( boolean pad text ) { this . pad text = pad text ; }
protect void complete current text node ( ) { if ( strip whitespace text ) { boolean whitespace = true ; for ( int i = 0 , size = text buffer . length ( ) ; i < size ; i++ ) { if ( ! character . be whitespace ( text buffer . char at ( i ) ) ) { whitespace = false ; break ; } } if ( ! whitespace ) { current element . add text ( text buffer . to string ( ) ) ; } } else { current element . add text ( text buffer . to string ( ) ) ; } text buffer . set length ( 0 ) ; text in text buffer = false ; }
public void reset handler ( ) { get dispatch handler ( ) . reset handler ( ) ; }
public x m l filter get x m l filter ( ) { return xml filter ; }
public void validate ( document document ) throw s a x exception { if ( document ! = null ) { x m l reader reader = get x m l reader ( ) ; if ( error handler ! = null ) { reader . set error handler ( error handler ) ; } try { reader . parse ( new document input source ( document ) ) ; } catch ( i o exception e ) { throw new runtime exception ( `` catch and exception that should `` + `` never happen : `` + e ) ; } } }
public void set output ( file file ) throw i o exception { create x m l writer ( ) . set output stream ( new file output stream ( file ) ) ; }
public static namespace get ( string prefix , string uri ) { return cache . get ( prefix , uri ) ; }
public void set mode ( string mode ) { this . mode = mode ; }
public pattern get pattern ( ) { return pattern ; }
public void apply template ( object input , x path xpath ) throw exception { apply template ( input , xpath , this . mode name ) ; }
public void set mode name ( string mode name ) { this . mode name = mode name ; }
public namespace pop ( string prefix ) { if ( prefix == null ) { prefix = `` `` ; } namespace namespace = null ; for ( int i = namespace stack . size ( ) - 1 ; i > = 0 ; i -- ) { namespace n = namespace stack . get ( i ) ; if ( prefix . equal ( n . get prefix ( ) ) ) { remove ( i ) ; namespace = ns ; break ; } } if ( namespace == null ) { system . out . println ( `` warning : miss namespace prefix ignore : `` + prefix ) ; } return namespace ; }
protect object get copy of user data ( ) { return data ; }
public string get x path ( ) { return xpath ; }
public void add attribute ( string namespace u r i , string local name , string raw name , string value ) throw xml pull parser exception { q name qname = q name . get ( raw name , namespace u r i ) ; element . add attribute ( qname , value ) ; }
public rate limiter build ( ) { check ( `` a rate must be set `` , invocation ! = null ) ; check ( `` a rate must be set `` , per time unit ! = null ) ; check ( `` a rate limit strategy must be set `` , strategy ! = null ) ; if ( strategy == rate limiter strategy . constant_throughput ) { return new constant throughput rate limiter ( invocation , per time unit ) ; } else { throw new illegal state exception ( ) ; } }
public < t > single type equal verifier api < t > for class ( class < t > type ) { return new single type equal verifier api < > ( type , enum set . copy of ( warning to suppress ) , factory cache , use get class ) ; }
public < t > tuple < t > give tuple ( type tag tag ) { realize cache for ( tag , empty stack ( ) ) ; return cache . get tuple ( tag ) ; }
public < t > t give other ( type tag tag , t value ) { class < t > type = tag . get type ( ) ; if ( value ! = null & & ! type . be assignable from ( value . get class ( ) ) & & ! wrap ( type , value . get class ( ) ) ) { throw new reflection exception ( `` type tag do not match value . `` ) ; } tuple < t > tuple = give tuple ( tag ) ; if ( tuple . get red ( ) == null ) { return null ; } if ( type . be array ( ) & & array be deeply equal ( tuple . get red ( ) , value ) ) { return tuple . get blue ( ) ; } if ( ! type . be array ( ) & & tuple . get red ( ) . equal ( value ) ) { return tuple . get blue ( ) ; } return tuple . get red ( ) ; }
public set < string > get array value ( string name ) { return array value . get ( name ) ; }
public class accessor < ? super t > get super accessor ( ) { return class accessor . of ( type . get superclass ( ) , prefab value ) ; }
public < t > class < t > resolve ( ) { return class for name ( fully qualify class name ) ; }
public string format ( ) { string result = message ; for ( object object : object ) { string s = result . replace first ( `` % % `` , matcher . quote replacement ( stringify ( object ) ) ) ; if ( result . equal ( s ) ) { throw new illegal state exception ( `` too many parameter `` ) ; } result = s ; } if ( result . contains ( `` % % `` ) ) { throw new illegal state exception ( `` not enough parameter `` ) ; } return result ; }
public static < t > boolean list contains duplicate ( list < t > list ) { return list . size ( ) ! = new hash set < > ( list ) . size ( ) ; }
public list < alternate mailbox > get entry ( ) { return this . entry ; }
public void set port ( int value ) { this . port = value ; }
protect void validate ( ) throw exception { this . get service ( ) . validate ( ) ; }
protect uri get url ( ) { return this . url ; }
public void set setting ( list < domain set name > value ) { setting = value ; }
public void set smtp address ( list < string > value ) { this . smtp address = value ; }
public autodiscover error code get error code ( ) { return error code ; }
public string get error message ( ) { return error message ; }
protect void set url ( string value ) { this . url = value ; }
public string get name space uri ( ) { return this . name space uri ; }
protect boolean try convert object to string ( object value , out param < string > str ) { boolean convert = true ; str . set param ( null ) ; if ( value ! = null ) { if ( value . get class ( ) . be enum ( ) ) { str . set param ( ews utility . serialize enum ( value ) ) ; } else if ( value . get class ( ) . equal ( boolean . class ) ) { str . set param ( ews utility . bool to x s bool ( ( boolean ) value ) ) ; } else if ( value instanceof date ) { str . set param ( this . service . convert date time to universal date time string ( ( date ) value ) ) ; } else if ( value . get class ( ) . be primitive ( ) ) { str . set param ( value . to string ( ) ) ; } else if ( value instanceof string ) { str . set param ( value . to string ( ) ) ; } else if ( value instanceof i search string provider ) { i search string provider search string provider = ( i search string provider ) value ; str . set param ( search string provider . get search string ( ) ) ; } else if ( value instanceof number ) { str . set param ( value . to string ( ) ) ; } else { converted = false ; } } return convert ; }
public static void validate enum version value ( enum < ? > enum value , exchange version request version ) throw service version exception { final map < class < ? > , map < string , exchange version > > member = enum_version_dictionaries . get member ( ) ; final map < string , exchange version > enum version dict = member . get ( enum value . get class ( ) ) ; final exchange version enum version = enum version dict . get ( enum value . to string ( ) ) ; if ( enum version ! = null ) { final int i = request version . compare to ( enum version ) ; if ( i < 0 ) { throw new service version exception ( string . format ( `` enumeration value % s in enumeration type % s be only valid for exchange version % s or later . `` , enum value . to string ( ) , enum value . get class ( ) . get name ( ) , enum version ) ) ; } } }
public static < t > object get enumerate object at ( iterable < t > object , int index ) { int count = 0 ; for ( object obj : object ) { if ( count == index ) { return obj ; } count++ ; } throw new index out of bound exception ( `` the i enumerable do n't contain that many object . `` ) ; }
public string read attribute value ( xml namespace xml namespace , string attribute name ) throw exception { if ( xml namespace == xml namespace . not specify ) { return this . read attribute value ( attribute name ) ; } else { q name q name = new q name ( ews utility . get namespace uri ( xml namespace ) , attribute name ) ; return read attribute value ( q name ) ; } }
public static boolean check end element ( x m l event start event , x m l event end event ) { boolean be end element = false ; if ( end event . be end element ( ) ) { q name q e name = end event . a end element ( ) . get name ( ) ; q name q s name = start event . a start element ( ) . get name ( ) ; be end element = q e name . get local part ( ) . equal ( q s name . get local part ( ) ) & & ( q e name . get prefix ( ) . equal ( q s name . get prefix ( ) ) || q e name . get namespace u r i ( ) . equal ( q s name . get namespace u r i ( ) ) ) ; } return be end element ; }
protect object get name ( ) { string name = null ; if ( this . present event . be start element ( ) ) { name = this . present event . a start element ( ) . get name ( ) . to string ( ) ; } else { name = this . present event . a end element ( ) . get name ( ) . to string ( ) ; } return name ; }
public int get major version ( ) { return this . major version ; }
public void set version string ( string version string ) { this . version string = version string ; }
public void delete user configuration ( string name , folder id parent folder id ) throw exception { ews utility . validate param ( name , `` name `` ) ; ew utility . validate param ( parent folder id , `` parent folder id `` ) ; delete user configuration request request = new delete user configuration request ( this ) ; request . set name ( name ) ; request . set parent folder id ( parent folder id ) ; request . execute ( ) ; }
public rule collection get inbox rule ( string mailbox smtp address ) throw exception { ews utility . validate param ( mailbox smtp address , `` mailbox smtp address `` ) ; get inbox rule request request = new get inbox rule request ( this ) ; request . setmailbox smtp address ( mailbox smtp address ) ; return request . execute ( ) . get rule ( ) ; }
public boolean get exchange2007 compatibility mode ( ) { return this . exchange2007 compatibility mode ; }
public void set exchange2007 compatibility mode ( boolean value ) { this . exchange2007 compatibility mode = value ; }
public void trace xml ( trace flag trace type , byte array output stream stream ) { if ( this . be trace enable for ( trace type ) ) { string trace type str = trace type . to string ( ) ; string log message = ews utility . format log message with xml content ( trace type str , stream ) ; this . trace listener . trace ( trace type str , log message ) ; } }
public void set trace listener ( i trace listener trace listener ) { this . trace listener = trace listener ; this . trace enable = ( trace listener ! = null ) ; }
public string get user agent ( ) { return this . user agent ; }
public void set user agent ( string user agent ) { this . user agent = user agent + `` ( `` + exchange service base . default user agent + `` ) `` ; }
public exchange server info get server info ( ) { return server info ; }
public void set request body type ( body type request body type ) { this . throw if readonly ( ) ; this . request body type = request body type ; }
public boolean get convert html code page to u t f8 ( ) { return this . convert html code page to u t f8 ; }
public list < alternate id base > get id ( ) { return this . id ; }
public void set folder ( iterable < folder > folder ) { this . set object ( ( collection < folder > ) folder ) ; }
protect iterable < t service object > get object ( ) { return this . object ; }
public user configuration get user configuration ( ) { return this . user configuration ; }
protect folder id get parent folder id ( ) { return this . parent folder id ; }
protect node get parameter ( ) { return xml node ; }
protect group get group by ( ) { return null ; }
protect string get mailbox smtp address ( ) { return this . mailbox smtp address ; }
public void set property set ( property set property set ) { this . property set = property set ; }
protect iterable < string > get id ( ) { return this . id ; }
public availability data get request data ( ) { return request data ; }
protect string get smtp address ( ) { return this . smtp address ; }
public string get content encoding ( ) throw e w s http exception { throw if response be null ( ) ; return response . get first header ( `` content-encoding `` ) ! = null ? response . get first header ( `` content-encoding `` ) . get value ( ) : null ; }
public void set proxy ( web proxy proxy ) { this . proxy = proxy ; }
public void set username ( string username ) { this . username = username ; }
public boolean be allow auto redirect ( ) { return allow auto redirect ; }
public void set destination folder id ( folder id destination folder id ) { this . destination folder id = destination folder id ; }
public void set dial string ( string dial string ) { this . dial string = dial string ; }
public iterable < item > get item ( ) { return this . item ; }
public folder id get save copy destination folder id ( ) { return this . save copy destination folder id ; }
public string get smtp address ( ) { return this . smtp address ; }
protect t end internal execute ( i async result async result ) throw exception { http web request response = ( http web request ) async result . get ( ) ; return this . read response ( response ) ; }
public void set time out ( int timeout ) { this . timeout = timeout ; }
public item id wrapper list get ignore item id ( ) { return this . ignored item id ; }
public working hour get working hour ( ) { return work hour ; }
public void load suggest day from xml ( ews service xml reader reader ) throw exception { reader . read start element ( xml namespace . message , xml element name . suggestion day result array ) ; do { reader . read ( ) ; if ( reader . be start element ( xml namespace . type , xml element name . suggestion day result ) ) { suggestion day suggestion = new suggestion ( ) ; day suggestion . load from xml ( reader , reader . get local name ( ) ) ; this . day suggestion . add ( day suggestion ) ; } } while ( ! reader . be end element ( xml namespace . message , xml element name . suggestion day result array ) ) ; }
public rule operation error collection get error ( ) { return this . error ; }
@ override public exchange version get minimum require server version ( ) { return exchange version . exchange2007_ s p1 ; }
@ override public service object schema get schema ( ) { return folder schema . instance ; }
public void empty ( delete mode deletemode , boolean delete sub folder ) throw exception { this . throw if this be new ( ) ; this . get service ( ) . empty folder ( this . get id ( ) , deletemode , delete sub folder ) ; }
public void set legacy free busy status ( legacy free busy status value ) throw exception { this . get property bag ( ) . set object from property definition ( appointment schema . legacy free busy status , value ) ; }
public void set be response request ( boolean value ) throw exception { this . get property bag ( ) . set object from property definition ( appointment schema . be response request , value ) ; }
public occurrence info collection get modify occurrence ( ) throw service local exception { return get property bag ( ) . get object from property definition ( appointment schema . modified occurrence ) ; }
public integer get conference type ( ) throw service local exception { return get property bag ( ) . get object from property definition ( appointment schema . conference type ) ; }
public boolean get allow new time proposal ( ) throw service local exception { return get property bag ( ) . get object from property definition ( appointment schema . allow new time proposal ) ; }
public string get file a ( ) throw service local exception { return get property bag ( ) . get object from property definition ( contact schema . file a ) ; }
public void set middle name ( string value ) throw exception { this . get property bag ( ) . set object from property definition ( contact schema . middle name , value ) ; }
public string get nick name ( ) throw service local exception { return get property bag ( ) . get object from property definition ( contact schema . nick name ) ; }
public void set nick name ( string value ) throw exception { this . get property bag ( ) . set object from property definition ( contact schema . nick name , value ) ; }
public void set assistant name ( string value ) throw exception { this . get property bag ( ) . set object from property definition ( contact schema . assistant name , value ) ; }
public void set child ( string list value ) throw exception { this . get property bag ( ) . set object from property definition ( contact schema . child , value ) ; }
public string list get company ( ) throw service local exception { return get property bag ( ) . get object from property definition ( contact schema . company ) ; }
public void set department ( string value ) throw exception { this . get property bag ( ) . set object from property definition ( contact schema . department , value ) ; }
public string get generation ( ) throw service local exception { return get property bag ( ) . get object from property definition ( contact schema . generation ) ; }
public string get profession ( ) throw service local exception { return get property bag ( ) . get object from property definition ( contact schema . profession ) ; }
public email address collection get direct report ( ) throw service local exception { return get property bag ( ) . get object from property definition ( contact schema . direct report ) ; }
public string get file a ( ) throw exception { return ( string ) this . get object from property definition ( contact schema . file a ) ; }
public string get topic ( ) throw argument exception { string return value = `` `` ; / * * this property need not be present hence the * property bag may not contain it . * check for the presence of this property before access it . * / if ( this . get property bag ( ) . contains ( conversation schema . topic ) ) { out param < string > out = new out param < string > ( ) ; this . get property bag ( ) . try get property type ( string . class , conversation schema . topic , out ) ; return value = out . get param ( ) ; } return return value ; }
public string list get unique unread sender ( ) throw argument exception { string list unread sender = null ; / * * this property need not be present hence * the property bag may not contain it . * check for the presence of this property before access it . * / if ( this . get property bag ( ) . contains ( conversation schema . unique unread sender ) ) { out param < string list > out = new out param < string list > ( ) ; this . get property bag ( ) . try get property type ( string list . class , conversation schema . unique unread sender , out ) ; unread sender = out . get param ( ) ; } return unread sender ; }
public int get global size ( ) throw service local exception { return get property bag ( ) . < integer > get object from property definition ( conversation schema . global size ) ; }
public string list get item class ( ) throw exception { return get property bag ( ) . get object from property definition ( conversation schema . item class ) ; }
public string list get global item class ( ) throw exception { return get property bag ( ) . get object from property definition ( conversation schema . global item class ) ; }
public void suppress read receipt ( ) throw exception { this . throw if this be new ( ) ; new suppress read receipt ( this ) . internal create ( null , null ) ; }
public email address collection get bcc recipient ( ) throw service local exception { return get property bag ( ) . get object from property definition ( email message schema . bcc recipient ) ; }
public mime content get mime content ( ) throw service local exception { return get property bag ( ) . get object from property definition ( item schema . mime content ) ; }
public void set mime content ( mime content value ) throw exception { this . get property bag ( ) . set object from property definition ( item schema . mime content , value ) ; }
public string get in reply to ( ) throw service local exception { return get property bag ( ) . get object from property definition ( item schema . in reply to ) ; }
public enum set < response action > get allow response action ( ) throw service local exception { return get property bag ( ) . get object from property definition ( item schema . allow response action ) ; }
public void set subject ( string subject ) throw exception { this . get property bag ( ) . set object from property definition ( item schema . subject , subject ) ; }
public meeting response type get response type ( ) throw service local exception { return get property bag ( ) . get object from property definition ( meet message schema . response type ) ; }
public boolean get be delegate ( ) throw service local exception { return get property bag ( ) . get object from property definition ( meet message schema . be delegate ) ; }
public legacy free busy status get intend free busy status ( ) throw service local exception { return get property bag ( ) . get object from property definition ( meet request schema . intend free busy status ) ; }
public response message create reply ( boolean reply all ) throw exception { this . throw if this be new ( ) ; return new response message ( this , reply all ? response message type . reply all : response message type . reply ) ; }
public email address get from ( ) throw service local exception { return get property bag ( ) . get object from property definition ( email message schema . from ) ; }
public boolean get be read ( ) throw service local exception { return get property bag ( ) . get object from property definition ( email message schema . be read ) ; }
public string get reference ( ) throw service local exception { return get property bag ( ) . get object from property definition ( email message schema . reference ) ; }
public date get assign time ( ) throw service local exception { return get property bag ( ) . get object from property definition ( task schema . assigned time ) ; }
public string get billing information ( ) throw service local exception { return get property bag ( ) . get object from property definition ( task schema . bill information ) ; }
public task delegation state get delegation state ( ) throw service local exception { return get property bag ( ) . get object from property definition ( task schema . delegation state ) ; }
public attachment collection get attachment ( ) throw exception { return ( attachment collection ) this . get object from property definition ( item schema . attachment ) ; }
public message body get body ( ) throw exception { return ( message body ) this . get object from property definition ( item schema . body ) ; }
public void clear change log ( ) { this . remove item . clear ( ) ; this . added item . clear ( ) ; this . modified item . clear ( ) ; }
public int get port ( ) { return this . port ; }
public void set global object id ( string value ) { this . global object id = value ; }
protected time span get time of day ( ) { return this . time of day ; }
protect string list get category ( ) { return this . category ; }
protect folder id wrapper get context folder id ( ) { return this . context folder id ; }
public void set context folder id ( folder id wrapper value ) { this . context folder id = value ; }
public void set folder id ( string folder id ) { this . folder id = folder id ; }
public string get id ( ) { return id ; }
protect string get exception type ( ) { return exception type ; }
protect int get position within line ( ) { return position within line ; }
protect void set hour ( int value ) throw argument exception { if ( value > = 0 & & value < 24 ) { this . hour = value ; } else { throw new argument exception ( `` hour must be between 0 and 23 . `` ) ; } }
public item id get item id ( ) { return this . item id ; }
public byte [ ] get binary data ( ) throw property exception { this . validate property access ( user configuration property . binary data ) ; return this . binary data ; }
protect boolean be more event available ( ) { return more event available ; }
public iterable < item event > get item event ( ) { collection < item event > item event = new array list < item event > ( ) ; for ( object event : this . event ) { if ( event instanceof item event ) { item event . add ( ( item event ) event ) ; } } return item event ; }
public date get timestamp ( ) { return timestamp ; }
public void end unsubscribe ( i async result async result ) throw exception { this . get service ( ) . end unsubscribe ( async result ) ; }
public void clear notification event ( ) { on notification event . clear ( ) ; }
public void load from xml ( ews service xml reader reader ) throw exception { this . id = reader . read element value ( xml namespace . message , xml element name . subscription id ) ; if ( this . get uses watermark ( ) ) { this . watermark = reader . read element value ( xml namespace . message , xml element name . watermark ) ; } }
public boolean be new ( ) { return ( this . get id ( ) == null || this . get id ( ) . be empty ( ) ) ; }
public item get owner ( ) { return this . owner ; }
public service object get owner ( ) { return this . owner ; }
public boolean try read element from xml ( ews service xml reader reader ) throw exception { if ( reader . get local name ( ) . equal ignore case ( xml element name . mailbox ) ) { this . load from xml ( reader , reader . get local name ( ) ) ; return true ; } else if ( reader . get local name ( ) . equal ignore case ( xml element name . response type ) ) { this . response type = reader . read element value ( meet response type . class ) ; return true ; } else if ( reader . get local name ( ) . equal ignore case ( xml element name . last response time ) ) { this . last response time = reader . read element value a date time ( ) ; return true ; } else { return super . try read element from xml ( reader ) ; } }
protect attendee create complex property ( string xml element name ) { if ( xml element name . equal ignore case ( xml element name . attendee ) ) { return new attendee ( ) ; } else { return null ; } }
public legacy free busy status get free busy status ( ) { return free busy status ; }
public boolean be reminder set ( ) { return be reminder set ; }
public int get number of member with conflict ( ) { return number of member with conflict ; }
public oof reply get internal reply ( ) { return internal reply ; }
public date get meeting time ( ) { return meeting time ; }
public boolean be work time ( ) { return be work time ; }
public string get title ( ) { return title ; }
public void set namespace ( xml namespace xml namespace ) { this . xml namespace = xml namespace ; }
protect void clear change event ( ) { on change list . clear ( ) ; }
protect void internal add ( t complex property complex property ) { this . internal add ( complex property , false ) ; }
protect void internal remove at ( int index ) { ews utility . ew assert ( index > = 0 & & index < this . get count ( ) , `` complex property collection . internal remove at `` , `` index be out of range . `` ) ; this . internal remove ( this . item . get ( index ) ) ; }
public rule get rule ( ) { return this . rule ; }
protect void validate update delegate ( ) throw service validation exception { for ( delegate folder permission delegate folder permission : this . delegate folder permission . value ( ) ) { if ( delegate folder permission . get permission level ( ) == delegate folder permission level . custom & & ! delegate folder permission . be exist permission level custom ) { throw new service validation exception ( `` this operation ca n't be perform because one or more folder `` + `` permission level be set to custom . `` ) ; } } }
public delegate permission get permission ( ) { return this . permission ; }
protect void internal add or replace ( t entry entry ) { t entry old entry ; if ( this . entry . contains key ( entry . get key ( ) ) ) { old entry = this . entry . get ( entry . get key ( ) ) ; old entry . remove change event ( this ) ; entry . add on change event ( this ) ; if ( ! this . added entry . contains ( entry . get key ( ) ) ) { if ( ! this . modified entry . contains ( entry . get key ( ) ) ) { this . modified entry . add ( entry . get key ( ) ) ; } } this . change ( ) ; } else { this . internal add ( entry ) ; } }
protect void set file name ( string file name ) { this . throw if this be not new ( ) ; this . file name = file name ; this . content = null ; this . content stream = null ; }
public byte [ ] get content ( ) { return this . content ; }
public permission scope get edit item ( ) { return this . edit item ; }
public permission scope get delete item ( ) { return this . delete item ; }
public boolean remove ( group member member ) { return this . internal remove ( member ) ; }
public string get im address ( ) { return this . im address ; }
public void set name ( string name ) { this . name = name ; }
public string get value ( ) { return value ; }
protect void set item ( item item ) { this . throw if this be not new ( ) ; if ( this . item ! = null ) { this . item . remove service object change event ( this ) ; } this . item = item ; if ( this . item ! = null ) { this . item . add service object change event ( this ) ; } }
public int get count ( ) { return this . item . size ( ) ; }
public void set base offset ( time span value ) { if ( this . can set field value ( this . name , value ) ) { this . base offset = value ; this . change ( ) ; } }
public time change get standard ( ) { return this . standard ; }
public void read attribute from xml ( ews service xml reader reader ) throw exception { this . body type = reader . read attribute value ( body type . class , xml attribute name . body type ) ; }
public boolean be regeneration pattern ( ) { return false ; }
public void set number of occurrence ( integer value ) { this . can set field value ( this . number of occurrence , value ) ; }
public boolean get mark a read ( ) { return this . mark a read ; }
public string get xml element name ( ) { return this . xml element name ; }
public string list get contain sender string ( ) { return this . contain sender string ; }
public email address collection get from address ( ) { return this . from address ; }
public boolean get be approval request ( ) { return this . be approval request ; }
public boolean get be encrypt ( ) { return this . be encrypt ; }
public boolean get be non delivery report ( ) { return this . be non delivery report ; }
public boolean get be read receipt ( ) { return this . be read receipt ; }
public search folder traversal get traversal ( ) { return traversal ; }
public string get unique id ( ) { return unique id ; }
public boolean same id and change key ( final service id other ) { return this . equal ( other ) & & string utils . equal ( this . get change key ( ) , other . get change key ( ) ) ; }
public void add range ( iterable < string > string ) { boolean change = false ; for ( string s : string ) { if ( ! this . contains ( s ) ) { this . item . add ( s ) ; change = true ; } } if ( change ) { this . change ( ) ; } }
public boolean equal ( object obj ) { if ( obj instanceof string list ) { string list other = ( string list ) obj ; return this . to string ( ) . equal ( other . to string ( ) ) ; } else { return false ; } }
protect boolean get support daylight ( ) { return this . transition . size ( ) == 2 ; }
public void set day of the week ( day of the week day of the week ) { if ( this . can set field value ( this . day of the week , day of the week ) ) { this . day of the week = day of the week ; this . change ( ) ; } }
public void set be dirty ( boolean value ) { this . be dirty = value ; }
public void set standard user ( standard user standard user ) { if ( this . can set field value ( this . standard user , standard user ) ) { this . standard user = standard user ; this . change ( ) ; } }
public mapi property type get mapi type ( ) { return this . mapi type ; }
public boolean equal ( object obj ) { if ( this == obj ) { return true ; } if ( obj instanceof indexed property definition ) { return indexed property definition . be equal to ( ( index property definition ) obj , this ) ; } else { return false ; } }
public boolean have flag ( property definition flag flag ) { return this . have flag ( flag , null ) ; }
public void set name ( string name ) { this . name = name ; }
protect service object type get service object type ( ) { return service object type . item ; }
public order by collection get order by ( ) { return this . order by ; }
public void set total count ( int total count ) { this . total count = total count ; }
public folder traversal get traversal ( ) { return traversal ; }
public void set traversal ( folder traversal traversal ) { this . traversal = traversal ; }
public array list < item group < t item > > get item group ( ) { return item group ; }
public void remove at ( int index ) { this . prop def sort order pair list . remove ( index ) ; }
public offset base point get offset base point ( ) { return offset base point ; }
public int get count ( ) { return this . change . size ( ) ; }
public item get item ( ) { return ( item ) this . get service object ( ) ; }
public boolean get be read ( ) { return this . be read ; }
public static date convert date string to date ( string value ) { return parse internal ( value , true ) ; }
public boolean be link ( object e ) { return nsh . get link uri ( ( element ) e ) ! = null ; }
public synchronize void put stylesheet ( object key , stylesheet sheet ) { _cache . put ( key , sheet ) ; }
public ident value get ident ( c s s name cs name ) { property declaration pd = property by name ( css name ) ; return ( pd == null ? null : pd . a ident value ( ) ) ; }
public string get string value ( ) { return _as string ; }
public string get document title ( org . w3c . dom . document doc ) { string title = `` `` ; element html = doc . get document element ( ) ; element head = find first child ( html , `` head `` ) ; if ( head ! = null ) { element title elem = find first child ( head , `` title `` ) ; if ( title elem ! = null ) { title = collapse white space ( read text content ( title elem ) . trim ( ) ) ; } } return title ; }
public void increment font size ( ) { scale font ( font scale factor ) ; }
public void reset font size ( ) { share context rc = get share context ( ) ; rc . get text renderer ( ) . set font scale ( 1 . 0f ) ; set document ( get document ( ) ) ; }
public void decrement font size ( ) { scale font ( 1 / font scale factor ) ; }
public void add document listener ( document listener listener ) { this . document listener . put ( listener , listener ) ; }
public void set layout ( layout manager l ) { }
protect void set document relative ( string filename ) { string url = get share context ( ) . get uac ( ) . resolve u r i ( filename ) ; if ( be anchor in current document ( filename ) ) { string id = get anchor id ( filename ) ; box box = get share context ( ) . get box by id ( id ) ; if ( box ! = null ) { point pt ; if ( box . get style ( ) . be inline ( ) ) { pt = new point ( box . get abs x ( ) , box . get abs y ( ) ) ; } else { rect property set margin = box . get margin ( get layout context ( ) ) ; pt = new point ( box . get abs x ( ) + ( int ) margin . left ( ) , box . get abs y ( ) + ( int ) margin . top ( ) ) ; } scroll to ( pt ) ; return ; } } document dom = load document ( url ) ; set document ( dom , url ) ; }
public boolean be hover ( org . w3c . dom . element e ) { if ( e == hovered_element ) { return true ; } return false ; }
public void set render hint ( map hint ) { render hint = hint ; }
public object get rendering hint ( ) { return anti alias render hint ; }
public void link click ( basic panel panel , string uri ) { panel . set document relative ( uri ) ; }
public void set document ( input stream stream , string url ) throw exception { reset scale accord to policy ( ) ; last layout size = null ; super . set document ( stream , url ) ; }
public static char value a char ( string key , char default val ) { string val = value for ( key ) ; if ( val == null ) { return default val ; } if ( val . length ( ) > 1 ) { x r log . exception ( `` property ' `` + key + `` ' be request a a character . the value of ' `` + val + `` ' be too long to be a char . return only the first character . `` ) ; } return val . char at ( 0 ) ; }
public void set write compression quality ( float q ) { write compression quality = q ; }
public void set bound box ( bound box b box ) { bound box = b box ; }
public void add ligature ( ligature ligature ) { ligature . add ( ligature ) ; }
public list < ligature > get ligature ( ) { return ligatures ; }
public void set w0y ( float w0y value ) { w0y = w0y value ; }
public void set w1x ( float w1x value ) { w1x = w1x value ; }
public void set font b box ( bound box b box ) { this . font b box = b box ; }
public void set notice ( string notice value ) { notice = notice value ; }
public void set encode scheme ( string encode scheme value ) { encode scheme = encode scheme value ; }
public void set cap height ( float cap height value ) { cap height = cap height value ; }
public float get ascender ( ) { return ascender ; }
public void set underline position ( float underline position value ) { underline position = underline position value ; }
public list < composite > get composite ( ) { return collection . unmodifiable list ( composite ) ; }
public void set standard vertical width ( float standard vertical width value ) { standard vertical width = standard vertical width value ; }
public java . lang . string get second kern character ( ) { return second kern character ; }
public string get successor ( ) { return successor ; }
public void set successor ( string successor value ) { successor = successor value ; }
public static c f f operator get operator ( string name ) { return name map . get ( name ) ; }
public static string get name ( int sid ) { return sid2str [ sid ] ; }
public string get string ( ) throw i o exception { return new string ( input buffer , charsets . iso_8859_1 ) ; }
public static string hex encode ( byte [ ] bytes ) { string builder sb = new string builder ( ) ; for ( byte a byte : byte ) { string string = integer . to hex string ( a byte & 0xff ) ; if ( string . length ( ) == 1 ) { sb . append ( `` 0 `` ) ; } sb . append ( string . to upper case ( locale . u ) ) ; } return sb . to string ( ) ; }
public void set supplement ( int new supplement ) { supplement = new supplement ; }
protect input stream get external c map ( string name ) throw i o exception { url url = get class ( ) . get resource ( name ) ; if ( url == null ) { throw new i o exception ( `` error : could not find referenced cmap stream `` + name ) ; } return url . open stream ( ) ; }
public c f f font get font ( ) { return cff font ; }
public cmap subtable get subtable ( int platform id , int platform encode id ) { for ( cmap subtable cmap : cmaps ) { if ( cmap . get platform id ( ) == platform id & & cmap . get platform encode id ( ) == platform encode id ) { return cmap ; } } return null ; }
public void set first contour ( int idx ) { first contour = idx ; }
public short get y maximum ( ) { return y max ; }
public int get kerning ( int l , int r ) { if ( pair == null ) { log . warn ( `` no kerning subtable data available due to an unsupported kerning subtable version `` ) ; return 0 ; } return pair . get kern ( l , r ) ; }
public maximum profile table get maximum profile ( ) throw i o exception { return ( maximum profile table ) get table ( maximum profile table . tag ) ; }
public int read sign byte ( ) throw i o exception { int sign byte = read ( ) ; return sign byte < 127 ? sign byte : sign byte - 256 ; }
public int get blue shift ( ) { return blue shift ; }
public int get language group ( ) { return language group ; }
public void set low left y ( float low left y value ) { this . low leave y = low leave y value ; }
public float get width ( ) { return get upper right x ( ) - get low left x ( ) ; }
public static string [ ] list fc ( final object component ) { final set < string > itf name = new hash set < string > ( ) ; if ( component instanceof bind controller ) { final string [ ] s = ( ( bind controller ) component ) . list fc ( ) ; for ( final string s1 : s ) itf name . add ( s1 ) ; } return itf name . to array ( new string [ 0 ] ) ; }
public static void debug ( final string message ) { log ( debug , message ) ; }
public static void info ( final string message ) { log ( info , message ) ; }
public node get end node ( ) { return end ; } // get end node ( )
public list < annotation > in document order ( ) { if ( annots by start node == null ) index by start offset ( ) ; collection < node > value = node by offset . value ( ) ; list < annotation > result = new array list < annotation > ( ) ; for ( node node obj : value ) { collection < annotation > anns = get annots by start node ( node obj . get id ( ) ) ; if ( anns ! = null ) { result . add all ( anns ) ; } } return result ; }
public document get document ( ) { return doc ; }
public set < string > get all type ( ) { index by type ( ) ; return collection . unmodifiable set ( annots by type . key set ( ) ) ; }
public void error ( s a x parse exception ex ) throw s a x exception { _seh . error ( ex ) ; } // error
public void unload document ( document doc ) { return ; }
public int hash code ( ) { return to string ( ) . hash code ( ) ; }
public boolean get collect reposition info ( ) { return collect reposition info ; } // get collect repositioning info
public void unload document ( document doc ) { unload document ( doc , true ) ; }
public list < document > sub list ( int from index , int to index ) { throw new gate . util . method not implement exception ( ) ; }
public void cleanup ( ) { }
public synchronize void interrupt ( ) { interrupted = true ; iterator < process resource > pr iter = get p r ( ) . iterator ( ) ; while ( pr iter . have next ( ) ) { pr iter . next ( ) . interrupt ( ) ; } }
public data store get data store ( ) { return data store ; }
public void execute ( ) throw execution exception { throw new execution exception ( `` resource `` + get class ( ) + `` have n't overriden the execute ( ) method `` ) ; } // execute ( )
public feature map get runtime parameter value ( ) throw resource instantiation exception { return get runtime parameter value ( this ) ; }
public final int start offset ( ) { return start offset ; }
public final int end offset ( ) { return end offset ; }
public void close ( ) throw i o exception { input . close ( ) ; }
public final enumeration field ( ) { return ( ( vector ) field ) . element ( ) ; }
public void add document ( document doc ) throw i o exception { add document ( doc , analyzer ) ; }
public boolean skip to ( term target ) throw i o exception { do { if ( ! next ( ) ) return false ; } while ( target . compare to ( term ( ) ) > 0 ) ; return true ; }
public final void add term ( string term text , int freq ) { if ( ! be document open ( ) ) throw new illegal state exception ( `` can not add term when document be not open `` ) ; if ( ! be field open ( ) ) throw new illegal state exception ( `` can not add term when field be not open `` ) ; add term internal ( term text , freq ) ; }
public final void add term freq vector ( term freq vector vector ) throw i o exception { if ( ! be document open ( ) ) throw new illegal state exception ( `` can not add term vector when document be not open `` ) ; if ( be field open ( ) ) throw new illegal state exception ( `` can not add term vector when field be open `` ) ; add term freq vector internal ( vector ) ; }
public static int get max clause count ( ) { return max clause count ; }
public void set description ( string description ) { this . description = description ; }
public void set first term position ( int q type , int doc , array list position , int pattern length , int frequency ) { query type . add ( new integer ( q type ) ) ; first term position . add ( position ) ; document number . add ( new integer ( doc ) ) ; pattern length . add ( new integer ( pattern length ) ) ; frequency . add ( new integer ( frequency ) ) ; }
public similarity get similarity ( searcher searcher ) { return searcher . get similarity ( ) ; }
public float idf ( term term , searcher searcher ) throw i o exception { return idf ( searcher . doc freq ( term ) , searcher . max doc ( ) ) ; }
public final void write byte ( byte b ) throw i o exception { if ( buffer position > = buffer_size ) flush ( ) ; buffer [ buffer position++ ] = b ; }
public final void write v int ( int i ) throw i o exception { while ( ( i & ~0x7 f ) ! = 0 ) { write byte ( ( byte ) ( ( i & 0x7f ) | 0x80 ) ) ; i > > > = 7 ; } write byte ( ( byte ) i ) ; }
public final void put ( object element ) { size++ ; heap [ size ] = element ; up heap ( ) ; }
public final void adjust top ( ) { down heap ( ) ; }
public corpus get corpus ( ) { return corpus ; }
public string get query ( ) { return this . query ; }
public synchronize void add query token ( string query , list < string > query token ) { this . query tokens . put ( query , query token ) ; }
public string get pattern text ( ) { return pattern text ; }
public int get leave context start offset ( ) { return leave context start offset ; }
public void set st offset ( int st ) { this . st offset = st ; }
public void set run strategy ( collection < run strategy > strategy ) { strategy list . clear ( ) ; iterator < run strategy > strat iter = strategy . iterator ( ) ; while ( strat iter . have next ( ) ) strategy list . add ( strat iter . next ( ) ) ; }
public set < string > get vr type ( ) { return collection . unmodifiable set ( new hash set < string > ( vr type ) ) ; }
public list < language resource > get public lr instance ( ) { return collection . unmodifiable list ( get public ( get lr instance ( ) ) ) ; } // get public lr instance ( )
public list < visual resource > get public vr instance ( ) { return collection . unmodifiable list ( get public ( get vr instance ( ) ) ) ; } // get public vr instance ( )
protected list < parameter > current flatten disjunction ( ) { list < parameter > list to return = new array list < parameter > ( ) ; for ( list < parameter > l : current param disjunction . value ( ) ) { list to return . add all ( l ) ; } return list to return ; }
public static data type get boolean data type ( ) { try { return new boolean d t ( `` http : //www . w3 . org/2001/ x m l schema # boolean `` ) ; } catch ( invalid u r i exception iue ) { return null ; } }
public static data type get unsigned byte data type ( ) { try { return new unsigned byte d t ( `` http : //www . w3 . org/2001/ x m l schema # unsigned byte `` ) ; } catch ( invalid u r i exception iue ) { return null ; } }
public static data type get unsigned short data type ( ) { try { return new unsigned short d t ( `` http : //www . w3 . org/2001/ x m l schema # unsigned short `` ) ; } catch ( invalid u r i exception iue ) { return null ; } }
public locale get language ( ) { return language ; }
public string to turtle ( ) { string val = this . value ; val = val . replace ( `` \ `` `` , `` \\\ `` `` ) ; val = `` \ `` `` +val+ `` \ `` `` ; if ( data type == null ) { if ( language ! = null ) { val = val+ `` @ `` +language ; } } else { val = val+ `` ^^ < `` + data type . get xml schema u r i string ( ) + `` > `` ; } return val ; }
public long get timeout ( ) { return timeout ; }
public boolean remove ( object o ) { boolean re = super . remove ( o ) ; if ( re ) { fire datastore close ( new creole event ( ( data store ) o , creole event . datastore_closed ) ) ; } return re ; } // remove
public mime type get mime type ( ) { return mime type ; }
public static void delete resource ( resource resource ) { resource data rd = gate . get creole register ( ) . get ( resource . get class ( ) . get name ( ) ) ; if ( rd ! = null & & rd . remove instantiation ( resource ) ) { creole proxy . fire resource unload ( new creole event ( resource , creole event . resource_unloaded ) ) ; resource . cleanup ( ) ; } } // delete resource
public static void init data store register ( ) { data store register = new data store register ( ) ; } // init data store register ( )
public synchronize static gate . executable get executable ( ) { return current executable ; } // get executable
public static string get default user config file name ( ) { string file prefix = `` `` ; if ( run on unix ( ) ) file prefix = `` . `` ; string user config name = system . get property ( `` user . home `` ) + string . get file sep ( ) + file prefix + gate_dot_xml ; return user config name ; } // get default user config file name
public static file get plugins home ( ) { return plugins home ; }
public static void set user config file ( file user config file ) { if ( gate . user config file ! = null ) { throw new illegal state exception ( `` user config file have already be set `` ) ; } gate . user config file = user config file ; }
public static void set builtin creole dir ( url builtin creole dir ) { if ( gate . builtin creole dir ! = null ) { throw new illegal state exception ( `` builtin creole dir have already be set `` ) ; } gate . builtin creole dir = builtin creole dir ; }
protect void init local data ( ) { extension = new array list < string > ( ) ; }
public list < action > get action ( ) { return new array list < action > ( ) ; }
public static void set text component font ( font font ) { set u i default ( text component key , new font u i resource ( font ) ) ; user config . put ( gate constant . text_components_font , font ) ; }
public void set select index ( int index ) { select index = index ; }
public int get select index ( ) { return select index ; }
public static set < string > get likely input annotation set ( controller c ) { set < string > likely set = new hash set < string > ( ) ; populate input set name for controller ( likely set , c , false ) ; return likely set ; }
protect void update data ( ) { font family combo . set select item ( style constant . get font family ( current style ) ) ; font size combo . set select item ( new integer ( style constant . get font size ( current style ) ) . to string ( ) ) ; bold chk . set select ( style constant . be bold ( current style ) ) ; italic chk . set select ( style constant . be italic ( current style ) ) ; italic chk . set select ( style constant . be italic ( current style ) ) ; underline chk . set select ( style constant . be underline ( current style ) ) ; subscript chk . set select ( style constant . be subscript ( current style ) ) ; superscript chk . set select ( style constant . be superscript ( current style ) ) ; strikethrough chk . set select ( style constant . be strike through ( current style ) ) ; if ( current style . be define ( style constant . foreground ) ) { fg chooser . set color ( style constant . get foreground ( current style ) ) ; use foreground chk . set select ( true ) ; } else use foreground chk . set select ( false ) ; if ( current style . be define ( style constant . background ) ) { bg chooser . set color ( style constant . get background ( current style ) ) ; use background chk . set select ( true ) ; } else use background chk . set select ( false ) ; } // protect void update data ( )
public void handle comment ( char [ ] text , int po ) { }
public void set ignorable tag ( set < string > new tag ) { ignorable tag = new tag ; }
public string get lr name ( object lr id ) { string s l rid = lr id . to string ( ) ; int second separator = s l rid . last index of ( `` ___ `` ) ; s l rid = s l rid . substring ( 0 , second separator ) ; int first separator = s l rid . last index of ( `` ___ `` ) ; return s l rid . substring ( 0 , first separator ) ; } // get lr name
public int row view to model ( int view row ) { return sort model . target to source ( view row ) ; }
public set < url > get plugin u r l ( ) { return plugin relpaths map . key set ( ) ; }
public void write ( ) throw i o exception { finish ( ) ; file new gapp file = file . file from u r l ( gapp file u r l ) ; file output stream fo = new file output stream ( new gapp file ) ; buffer output stream out = new buffer output stream ( fo ) ; x m l outputter outputter = new x m l outputter ( format . get raw format ( ) ) ; outputter . output ( gapp document , out ) ; }
public int size ( ) { load ( ) ; return list name . length ; }
public string get description ( ) { return ( description == null ) ? to string ( ) : description ; }
public static string get string ( string file name ) throw i o exception { return get string ( new file ( file name ) ) ; } // get string ( file name )
public static string get resource a string ( string resource name ) throw i o exception { return get resource a string ( resource name , null ) ; }
public void add u r l ( url url ) { super . add u r l ( url ) ; }
public gate class loader get disposable class loader ( string id ) { return get disposable class loader ( id , null , false ) ; }
public synchronize object get ( ) { int n = object . size ( ) ; if ( n > 0 ) { object o = object . element at ( n-1 ) ; object . remove element at ( n-1 ) ; return o ; } else return null ; } // get
public input stream get input stream ( ) { return input stream ; }
public double get double ( object key ) { try { return double . value of ( ( string ) get ( key ) ) ; } catch ( exception e ) { return null ; } }
public static file current persistence file ( ) { return persistence file . get ( ) . get first ( ) ; }
public long get net run time ( ) { return m_last check time - m_profiler time ; } ;
public long first ( ) { if ( tsindex > = size ) return -1 ; return the array [ tsindex ] ; } // first ( )
public static int length ( simple annotation ann ) { long len = length long ( ann ) ; if ( len > java . lang . integer . max_value ) { throw new gate runtime exception ( `` length of annotation too big to be return a an int : `` +len ) ; } else { return ( int ) len ; } }
public void end c d a t a ( ) throw s a x exception { }
public long get real offset ( ) { return m_real offset ; } // get real offset
public int getk n ( ) { return k n ; }
public int format ( string . . . args ) throw usage exception { command line option parameter = process args ( args ) ; if ( parameter . version ( ) ) { err writer . println ( version string ( ) ) ; return 0 ; } if ( parameter . help ( ) ) { throw new usage exception ( ) ; } java formatter option option = java formatter option . builder ( ) . style ( parameter . aosp ( ) ? style . aosp : style . google ) . format javadoc ( parameter . format javadoc ( ) ) . build ( ) ; if ( parameter . stdin ( ) ) { return format stdin ( parameter , option ) ; } else { return format file ( parameter , option ) ; } }
public static string wrap ( string input , formatter formatter ) throw formatter exception { return string wrapper . wrap ( formatter . max_line_length , input , formatter ) ; }
public void mark for partial format ( ) { if ( last partial format boundary == -1 ) { last partial format boundary = token i ; return ; } if ( token i == last partial format boundary ) { return ; } token start = input . get token ( ) . get ( last partial format boundary ) ; token end = input . get token ( ) . get ( token i - 1 ) ; output . mark for partial format ( start , end ) ; last partial format boundary = token i ; }
public static boolean in image runtime code ( ) { return property_image_code_value_runtime . equal ( system . get property ( property_image_code_key ) ) ; }
public static boolean be share library ( ) { ensure kind available ( ) ; return property_image_kind_value_shared_library . equal ( system . get property ( property_image_kind_key ) ) ; }
public static isolate thread attach current thread ( isolate isolate ) throw isolate exception { return image singleton . lookup ( isolate support . class ) . attach current thread ( isolate ) ; }
public string get help ( ) { return help ; }
public static < t > builder new builder ( option key < t > key , string name ) { object . require non null ( key ) ; object . require non null ( name ) ; return empty . new builder ( key , name ) ; }
public void enter ( ) { impl . explicit enter ( this ) ; }
public option descriptor get option ( ) { return impl . get option ( ) ; }
public string get default mime type ( ) { return impl . get default mime type ( ) ; }
public list < value > get input value ( ) { return impl . get execution event input value ( impl ) ; }
public polyglot exception get exception ( ) { return impl . get execution event exception ( impl ) ; }
public static builder new builder ( ) { return empty . new builder ( ) ; }
public string get message ( ) { return impl . get message ( ) ; }
public throwable a host exception ( ) { return impl . a host exception ( ) ; }
public boolean be cancel ( ) { return impl . be cancel ( ) ; }
public value get guest object ( ) { return impl . get guest object ( ) ; }
public char sequence get character ( ) { return get impl ( ) . get code ( impl ) ; }
public boolean have byte ( ) { return get impl ( ) . have byte ( impl ) ; }
public int get column number ( int offset ) throw illegal argument exception { return get impl ( ) . get column number ( impl , offset ) ; }
public static source create ( string language , char sequence source ) { return new builder ( language , source , `` unnamed `` ) . build literal ( ) ; }
public boolean be available ( ) { return impl . be available ( impl ) ; }
public string to string ( ) { return impl . to string ( impl ) ; }
public boolean have member ( ) { return impl . have member ( receiver ) ; }
public boolean remove member ( string identifier ) { object . require non null ( identifier , `` identifier `` ) ; return impl . remove member ( receiver , identifier ) ; }
public boolean can invoke member ( string identifier ) { object . require non null ( identifier , `` identifier `` ) ; return impl . can invoke ( identifier , receiver ) ; }
public boolean be duration ( ) { return impl . be duration ( receiver ) ; }
public final boolean overlap ( location identity other ) { return be any ( ) || other . be any ( ) || this . equal ( other ) ; }
public static < t extend pointer base > t null pointer ( ) { return word box factory . box ( 0l ) ; }
public static string assert valid name ( string name ) { if ( name ! = null & & ! name . be empty ( ) & & valid name pattern . matcher ( name ) . match ( ) ) { return name ; } throw new assert exception ( string . format ( invalid name error message , name ) ) ; }
public object get local context ( ) { return local context ; }
public object get fetch value ( ) { return fetch value ; }
public publisher < u > get upstream publisher ( ) { return upstream publisher ; }
public static result path root path ( ) { return root_path ; }
public graph q l transform ( consumer < graph q l . builder > builder consumer ) { builder builder = new builder ( this . graph q l schema ) ; builder . query execution strategy ( this . query strategy ) . mutation execution strategy ( this . mutation strategy ) . subscription execution strategy ( this . subscription strategy ) . execution id provider ( optional . of nullable ( this . id provider ) . or else ( builder . id provider ) ) . instrumentation ( optional . of nullable ( this . instrumentation ) . or else ( builder . instrumentation ) ) . preparsed document provider ( optional . of nullable ( this . preparsed document provider ) . or else ( builder . preparsed document provider ) ) ; builder consumer . accept ( builder ) ; return builder . build ( ) ; }
public boolean be repeatable ( ) { return repeatable ; }
public static parse and validate result parse and validate ( graph q l schema graph q l schema , execution input execution input ) { parse and validate result result = parse ( execution input ) ; if ( ! result . be failure ( ) ) { list < validation error > error = validate ( graph q l schema , result . get document ( ) ) ; return result . transform ( builder - > builder . validation error ( error ) ) ; } return result ; }
public static parse and validate result parse ( execution input execution input ) { try { parser parser = new parser ( ) ; document document = parser . parse document ( execution input . get query ( ) ) ; return parse and validate result . new result ( ) . document ( document ) . variable ( execution input . get variable ( ) ) . build ( ) ; } catch ( invalid syntax exception e ) { return parse and validate result . new result ( ) . syntax exception ( e ) . variable ( execution input . get variable ( ) ) . build ( ) ; } }
public connection cursor cursor for object in connection ( t object ) { int index = data . index of ( object ) ; if ( index == -1 ) { return null ; } string cursor = create cursor ( index ) ; return new default connection cursor ( cursor ) ; }
public static < t > async data fetcher < t > async ( data fetcher < t > wrap data fetcher , executor executor ) { return new async data fetcher < > ( wrap data fetcher , executor ) ; }
public @ nullable graph q l type get type ( @ not null string type name ) { return type map . get ( type name ) ; }
public graph q l directive get schema directive ( string directive name ) { return schema directive . get directive ( directive name ) ; }
public static boolean be nullable ( graph q l type type ) { return ! be non null ( type ) ; }
public static boolean be scalar ( graph q l type type ) { return type instanceof graph q l scalar type ; }
public static boolean be input ( graph q l type type ) { graph q l unmodified type unmodified type = unwrap all ( type ) ; return unmodified type instanceof graph q l scalar type || unmodified type instanceof graph q l enum type || unmodified type instanceof graph q l input object type ; }
public static builder new type wiring ( string type name ) { assert not null ( type name , ( ) - > `` you must provide a type name `` ) ; return new builder ( ) . type name ( type name ) ; }
public static boolean get enable grape ( ) { return enable grape ; }
public object [ ] get meta method ( ) { meta class meta class = invoker helper . get meta class ( object under inspection ) ; list meta method = meta class . get meta method ( ) ; object [ ] result = new object [ meta method . size ( ) ] ; int i = 0 ; for ( iterator iter = meta method . iterator ( ) ; iter . have next ( ) ; i++ ) { meta method meta method = ( meta method ) iter . next ( ) ; result [ i ] = method info ( meta method ) ; } return result ; }
public void println ( object obj ) { println ( invoker helper . to string ( obj ) ) ; }
public void remove variable ( string name ) { if ( null == variable ) { return ; } variable . remove ( name ) ; }
public static void disable globally ( ) { default meta class info . set without custom metaclass creation handle ( true ) ; expando meta class creation handle . disable ( ) ; }
public void refresh inherit method ( set modify super expandos ) { for ( object modify super expando : modify super expandos ) { expando meta class super expando = ( expando meta class ) modify super expando ; if ( super expando ! = this ) { refresh inherit method ( super expando ) ; } } }
public string get property for setter ( string setter name ) { if ( setter name == null || setter name . length ( ) == 0 ) return null ; if ( setter name . start with ( `` set `` ) ) { string prop = setter name . substring ( 3 ) ; return meta class helper . convert property name ( prop ) ; } return null ; }
public class load class ( final string name , boolean lookup script file , boolean prefer class over script ) throw class not find exception , compilation fail exception { return load class ( name , lookup script file , prefer class over script , false ) ; }
protect long get time stamp ( class cl ) { return verifier . get timestamp ( cl ) ; }
public object run ( final string script text , final string file name , string [ ] args ) throw compilation fail exception { groovy code source gc = access controller . do privilege ( ( privilege action < groovy code source > ) ( ) - > new groovy code source ( script text , file name , default_code_base ) ) ; return run ( gc , args ) ; }
public void set property ( object object , object new value ) { throw new read only property exception ( `` length `` , object . get class ( ) ) ; }
public meta method get setter ( ) { return setter ; }
public meta class registry get registry ( ) { return ( meta class registry ) source ; }
public final boolean be private ( ) { return ( get modifier ( ) & modifier . private ) ! = 0 ; }
public int get modifier ( ) { return modifier . public ; }
public file hunt for the script file ( string input ) { return groovy main . search for groovy script file ( input ) ; }
public charset get default charset ( ) { return default charset ; }
public boolean have u t f16 b e bom ( ) { if ( buffer . length > = 2 ) return ( buffer [ 0 ] == -2 & & buffer [ 1 ] == -1 ) ; else return false ; }
public static object me ( final string expression ) throw compilation fail exception { return me ( null , null , expression ) ; }
public object get property ( string property ) { try { return get proxy builder ( ) . do get property ( property ) ; } catch ( miss property exception mpe ) { if ( ( get context ( ) ! = null ) & & ( get context ( ) . contains key ( property ) ) ) { return get context ( ) . get ( property ) ; } else { try { return get meta class ( ) . get property ( this , property ) ; } catch ( miss property exception mpe2 ) { if ( mpe2 . get property ( ) . equal ( property ) & & property miss delegate ! = null ) { return property miss delegate . call ( new object [ ] { property } ) ; } throw mpe2 ; } } } }
public object invoke method ( string method name ) { return get proxy builder ( ) . invoke method ( method name , null ) ; }
public closure add attribute delegate ( closure attr delegate ) { get proxy builder ( ) . attribute delegate . add first ( attr delegate ) ; return attr delegate ; }
public void remove attribute delegate ( closure attr delegate ) { get proxy builder ( ) . attribute delegate . remove ( attr delegate ) ; }
protect object post node completion ( object parent , object node ) { for ( closure post node completion delegate : get proxy builder ( ) . get post node completion delegate ( ) ) { ( post node completion delegate ) . call ( this , parent , node ) ; } return node ; }
protect void pre instantiate ( object name , map attribute , object value ) { for ( closure pre instantiate delegate : get proxy builder ( ) . get pre instantiate delegate ( ) ) { ( pre instantiate delegate ) . call ( this , attribute , value ) ; } }
public static list transpose ( list list ) { list result = new array list ( ) ; if ( list . be empty ( ) ) return result ; int min size = integer . max_value ; for ( object list like : list ) { list list = ( list ) default type transformation . cast to type ( list like , list . class ) ; if ( list . size ( ) < min size ) min size = list . size ( ) ; } if ( min size == 0 ) return result ; for ( int i = 0 ; i < min size ; i++ ) { result . add ( new array list ( ) ) ; } for ( object list like : list ) { list list = ( list ) default type transformation . cast to type ( list like , list . class ) ; for ( int i = 0 ; i < min size ; i++ ) { list result list = ( list ) result . get ( i ) ; result list . add ( list . get ( i ) ) ; } } return result ; }
public void set identifier resolver ( final object identifier resolver ) { if ( identifier resolver instanceof identifier resolver ) { this . identifier resolver = ( identifier resolver ) identifier resolver ; } else if ( identifier resolver instanceof string ) { this . identifier resolver = node name - > ( string ) identifier resolver ; } else if ( identifier resolver instanceof closure ) { final object graph builder self = this ; this . identifier resolver = node name - > { closure cl = ( closure ) identifier resolver ; cl . set delegate ( self ) ; return ( string ) cl . call ( new object [ ] { node name } ) ; } ; } else { this . identifier resolver = new default identifier resolver ( ) ; } }
public proxy wrap ( object adaptee ) { set adaptee ( adaptee ) ; return this ; }
public static boolean be inner class ( class node c node ) { return c node . redirect ( ) . get out class ( ) ! = null & & ! modifier . be static ( c node . get modifier ( ) ) ; }
public static string method descriptor ( method node m node ) { string builder sb = new string builder ( m node . get name ( ) . length ( ) + m node . get parameter ( ) . length * 10 ) ; sb . append ( m node . get return type ( ) . get name ( ) ) ; sb . append ( ' ' ) ; sb . append ( m node . get name ( ) ) ; sb . append ( ' ( ' ) ; for ( int i = 0 ; i < m node . get parameter ( ) . length ; i++ ) { if ( i > 0 ) { sb . append ( `` , `` ) ; } parameter p = m node . get parameter ( ) [ i ] ; sb . append ( class node utils . format type name ( p . get type ( ) ) ) ; } sb . append ( ' ) ' ) ; return sb . to string ( ) ; }
public groovy runner put ( string key , groovy runner runner ) { if ( key == null || runner == null ) { return null ; } map < string , groovy runner > map = get map ( ) ; write lock . lock ( ) ; try { cached value = null ; return map . put ( key , runner ) ; } finally { write lock . unlock ( ) ; } }
public long capacity ( ) { return capacity . get ( ) ; }
public v put ( k key , v value ) { return put ( key , value , false ) ; }
public boolean be synthetic ( ) { return synthetic ; }
public static class node get wrapper ( class node cn ) { cn = cn . redirect ( ) ; if ( ! be primitive type ( cn ) ) return cn ; class node result = primitive_type_to_wrapper_type_map . get ( cn ) ; if ( null ! = result ) { return result ; } return cn ; }
public static boolean be primitive type ( class node cn ) { return type util . be primitive type ( cn ) ; }
public field node get declare field ( string name ) { if ( redirect ! = null ) return redirect . get declared field ( name ) ; lazy class init ( ) ; return field index == null ? null : field index . get ( name ) ; }
public void add object initializer statement ( statement statement ) { get object initializer statement ( ) . add ( statement ) ; }
public statement get code ( ) { return code ; }
public string get method a string ( ) { if ( ! ( method instanceof constant expression ) ) return null ; constant expression constant = ( constant expression ) method ; return constant . get text ( ) ; }
public void set closure share variable ( boolean in closure ) { closure share = in closure ; }
public string get text ( ) { string ret type = ast to text helper . get class text ( return type ) ; string exception type = ast to text helper . get throws clause text ( exception ) ; string params = ast to text helper . get parameter text ( parameter ) ; return ast to text helper . get modifier text ( modifier ) + `` `` + ret type + `` `` + name + `` ( `` + params + `` ) `` + exception type + `` { . . . } '' ; }
public static boolean have single character arg ( closure c ) { if ( c . get maximum number of parameter ( ) ! = 1 ) return false ; string type name = c . get parameter type ( ) [ 0 ] . get name ( ) ; return type name . equal ( `` char `` ) || type name . equal ( `` java . lang . character `` ) ; }
public static class node find parameterized type ( class node generic class , class node actual type , boolean try to find exact type ) { class node parameterized type = null ; if ( null == generic class . get generic type ( ) ) { return parameterized type ; } generic type [ ] declare generic type = generic class . get generic type ( ) ; list < class node > class node list = new link list < > ( get all super class and interface ( actual type ) ) ; class node list . add ( 0 , actual type ) ; link list < class node > parameterized type candidate list = new link list < > ( ) ; for ( class node cn : class node list ) { if ( cn == generic class ) { continue ; } if ( try to find exact type & & null ! = cn . get generic type ( ) & & have non place holder ( cn ) ) { parameterized type candidate list . add ( cn ) ; } if ( ! ( generics class . equal ( cn . redirect ( ) ) ) ) { continue ; } if ( be generic type array length equal ( declare generic type , cn . get generic type ( ) ) ) { parameterized type = cn ; break ; } } if ( null == parameterized type ) { if ( ! parameterized type candidate list . be empty ( ) ) { parameterized type = parameterized type candidate list . get last ( ) ; } } return parameterized type ; }
public static boolean have non place holder ( class node parameterized type ) { return check place holder ( parameterized type , generic type - > ! generic type . be placeholder ( ) ) ; }
protect boolean write shift op ( int type , boolean simulate ) { type = type - left_shift ; if ( type < 0 || type > 2 ) return false ; if ( ! simulate ) { int bytecode = get shift operation bytecode ( type ) ; controller . get method visitor ( ) . visit insn ( bytecode ) ; controller . get operand stack ( ) . replace ( get normal op result type ( ) , 2 ) ; } return true ; }
public label push switch ( ) { push state ( ) ; break label = new label ( ) ; return break label ; }
public static boolean be mop method ( string method name ) { return ( method name . start with ( `` this $ `` ) || method name . start with ( `` super $ `` ) ) & & ! method name . contains ( `` $ dist $ `` ) ; }
protect void load this or owner ( ) { if ( be inner class ( ) ) { visit field expression ( new field expression ( controller . get class node ( ) . get declared field ( `` owner `` ) ) ) ; } else { load this ( null ) ; } }
public static compile phase from phase number ( int phase number ) { for ( compile phase phase : value ( ) ) { if ( phase . phase number == phase number ) { return phase ; } } return null ; }
public void set output ( final print writer output ) { if ( output == null ) { this . output = new print writer ( null writer . default ) ; } else { this . output = output ; } }
public void set script base class ( final string script base class ) { this . script base class = script base class ; }
public void set preview feature ( final boolean preview feature ) { this . preview feature = preview feature ; }
public boolean be groovydoc enabled ( ) { boolean groovydoc enable = get optimization option ( ) . get ( groovydoc ) ; return optional . of nullable ( groovydoc enable ) . or else ( boolean . false ) ; }
public void add error ( final message message ) throw compilation fail exception { add error and continue ( message ) ; if ( error ! = null & & error . size ( ) > = configuration . get tolerance ( ) ) { fail if error ( ) ; } }
public int get warn count ( ) { return ( have warning ( ) ? warning . size ( ) : 0 ) ; }
public list < warn message > get warning ( ) { return warning ; }
public static boolean be relevant ( int actual , int limit ) { return actual < = limit ; }
public void configure ( compiler configuration configuration ) { set configuration ( configuration ) ; }
public void next phase ( ) throw compilation fail exception { goto phase ( phase + 1 ) ; }
public string get sample ( int line , int column , janitor janitor ) { string sample = null ; string text = source . get line ( line , janitor ) ; if ( text ! = null ) { if ( column > 0 ) { string marker = utility . repeat string ( `` `` , column - 1 ) + `` ^ `` ; if ( column > 40 ) { int start = column - 30 - 1 ; int end = ( column + 10 > text . length ( ) ? text . length ( ) : column + 10 - 1 ) ; sample = `` `` + text . substring ( start , end ) + utility . eol ( ) + `` `` + marker . substring ( start ) ; } else { sample = `` `` + text + utility . eol ( ) + `` `` + marker ; } } else { sample = text ; } } return sample ; }
public string get message ( ) { if ( message ! = null ) { return `` bug ! `` + message ; } else { return `` bug ! uncaught exception : `` + exception . get message ( ) ; } }
public static string dump all ( thread self ) { thread m x bean thread mx bean = management factory . get thread m x bean ( ) ; return array . stream ( thread mx bean . dump all thread ( true , true ) ) . map ( thread info : : to string ) . collect ( collector . joining ( `` `` ) ) ; }
public static boolean have category in current thread ( ) { / * * synchronization be avoid here for performance reason since * this method be call frequently from callsite location . for * a typical case when no category be in use the initialized * value of 0 will be correctly read . for case where multiple * thread be use category it be possible that a stale * non-zero value may be read but in that case the thread local * check will produce the correct result . when the current thread * be use category , it would have incremented the counter * so whatever version of the value it observe here should be * non-zero and good enough for the purpose of this quick exit * check . * / if ( category in use == 0 ) { return false ; } thread category info info nullable = thread_info . get info nullable ( ) ; return info nullable ! = null & & info nullable . level ! = 0 ; }
public static output stream leave shift ( output stream self , byte [ ] value ) throw i o exception { self . write ( value ) ; self . flush ( ) ; return self ; }
public static < t > t with object output stream ( output stream output stream , @ closure params ( value= simple type . class , options= `` java . io . object output stream `` ) closure < t > closure ) throw i o exception { return with stream ( new object output stream ( output stream ) , closure ) ; }
public static < t > t with writer ( output stream stream , @ closure params ( value= simple type . class , options= `` java . io . writer `` ) closure < t > closure ) throw i o exception { return with writer ( new output stream writer ( stream ) , closure ) ; }
public v put ( k key , v value ) { return map . put ( key , value ) ; }
public static void set orig double ( boolean v ) { orig double = v ; orig double re = without custom handle & & orig double ; }
public void set meta class creation handle ( meta class creation handle handle ) { if ( handle == null ) throw new illegal argument exception ( `` can not set meta class creation handle to null value ! `` ) ; class info . clear modify expandos ( ) ; handle . set disable custom meta class lookup ( meta class creation handle . be disable custom meta class lookup ( ) ) ; meta class creation handle = handle ; }
public static void do set meta class ( object self , meta class mc ) { if ( self instanceof groovy object ) { default groovy method . set meta class ( ( groovy object ) self , mc ) ; } else { default groovy method . set meta class ( self , mc ) ; } }
public method key create copy ( ) { int size = get parameter count ( ) ; class [ ] param type = new class [ size ] ; for ( int i = 0 ; i < size ; i++ ) { param type [ i ] = get parameter type ( i ) ; } return new default method key ( sender , name , param type , be call to super ) ; }
public static string get constructor suggestion string ( class type , object [ ] argument ) { constructor [ ] sugg = rank constructor ( argument , type . get constructor ( ) ) ; if ( sugg . length > 0 ) { string builder sb = new string builder ( ) ; sb . append ( `` \n possible solution : `` ) ; for ( int i = 0 ; i < sugg . length ; i++ ) { if ( i ! = 0 ) sb . append ( `` , `` ) ; sb . append ( type . get name ( ) ) . append ( `` ( `` ) ; sb . append ( list parameter name ( sugg [ i ] . get parameter type ( ) ) ) ; sb . append ( `` ) `` ) ; } return sb . to string ( ) ; } else { return `` `` ; } }
public static string get text ( process self ) throw i o exception { string text = i o groovy method . get text ( new buffer reader ( new input stream reader ( self . get input stream ( ) ) ) ) ; close stream ( self ) ; return text ; }
public static void with output stream ( final process self , final closure closure ) { new thread ( ( ) - > { try { i o groovy method . with stream ( new buffer output stream ( get out ( self ) ) , closure ) ; } catch ( i o exception e ) { throw new groovy runtime exception ( `` exception while read process stream `` , e ) ; } } ) . start ( ) ; }
public static list < string > read line ( file file ) throw i o exception { return i o groovy method . read line ( new reader ( file ) ) ; }
public static list < string > read line ( url self ) throw i o exception { return i o groovy method . read line ( new reader ( self ) ) ; }
public static string get text ( file file ) throw i o exception { return i o groovy method . get text ( new reader ( file ) ) ; }
public static void append ( file file , writer writer , string charset , boolean write bom ) throw i o exception { append buffer ( file , writer , charset , write bom ) ; }
public static data output stream new data output stream ( file file ) throw i o exception { return new data output stream ( new file output stream ( file ) ) ; }
public static < t > t with writer ( file file , @ closure params ( value = simple type . class , option = `` java . io . buffer writer `` ) closure < t > closure ) throw i o exception { return i o groovy method . with writer ( new writer ( file ) , closure ) ; }
public static < t > t with writer append ( file file , string charset , @ closure params ( value = simple type . class , option = `` java . io . buffer writer `` ) closure < t > closure ) throw i o exception { return i o groovy method . with writer ( new writer ( file , charset , true ) , closure ) ; }
public static object a type ( object object , class type ) throw throwable { if ( object == null ) object = null object . get null object ( ) ; return invoke method n ( object . get class ( ) , object , `` a type `` , new object [ ] { type } ) ; }
public static throwable sanitize root cause ( throwable t ) { return stack trace utils . sanitize ( stack trace utils . extract root cause ( t ) ) ; }
public boolean be empty ( ) { return false ; }
public c s t node get ( int index ) { c s t node element = null ; if ( index < size ( ) ) { element = ( c s t node ) element . get ( index ) ; } return element ; }
public c s t node remove ( int index ) { if ( index < 1 ) { throw new groovy bug error ( `` attempt to remove ( ) root node of reduction `` ) ; } return ( c s t node ) element . remove ( index ) ; }
public static token new symbol ( string type , int start line , int start column ) { return new token ( type . lookup symbol ( type ) , type , start line , start column ) ; }
public void compile ( string name , string code ) throw compilation fail exception { compilation unit unit = new compilation unit ( configuration ) ; unit . add source ( new source unit ( name , code , configuration , unit . get class loader ( ) , unit . get error collector ( ) ) ) ; unit . compile ( ) ; }
public void configure ( input stream be ) throw i o exception { try ( buffered reader reader = new buffer reader ( new input stream reader ( be ) ) ) { int line number = 0 ; while ( true ) { string line = reader . read line ( ) ; if ( line == null ) break ; line = line . trim ( ) ; line number++ ; if ( line . start with ( `` # `` ) || line . length ( ) == 0 ) continue ; if ( line . start with ( load_prefix ) ) { string load path = line . substring ( load_prefix . length ( ) ) . trim ( ) ; load path = assign property ( load path ) ; load filter path ( load path ) ; } else if ( line . start with ( grab_prefix ) ) { string grab params = line . substring ( grab_prefix . length ( ) ) . trim ( ) ; grab list . add ( assign property ( grab params ) ) ; } else if ( line . start with ( main_prefix ) ) { if ( main ! = null ) throw new i o exception ( `` duplicate definition of main in line `` + line number + `` : `` + line ) ; main = line . substring ( main_prefix . length ( ) ) . trim ( ) ; } else if ( line . start with ( prop_prefix ) ) { string params = line . substring ( prop_prefix . length ( ) ) . trim ( ) ; string key = system util . set system property from ( params ) ; system . set property ( key , assign property ( system . get property ( key ) ) ) ; } else if ( line . start with ( configscript_prefix ) ) { string script = line . substring ( configscript_prefix . length ( ) ) . trim ( ) ; config script . add ( assign property ( script ) ) ; } else { throw new i o exception ( `` unexpected line in `` + line number + `` : `` + line ) ; } } } if ( require main & & main == null ) throw new i o exception ( `` miss main class definition in config file `` ) ; if ( ! config script . be empty ( ) ) { system . set property ( `` groovy . starter . configscripts `` , default groovy method . join ( ( iterable ) config script , `` , `` ) ) ; } }
public string get annotation name ( ) { return null ; }
public binary expression pop enclose binary expression ( ) { return enclose binary expression . remove first ( ) ; }
public method node get enclose method ( ) { if ( enclose method . be empty ( ) ) return null ; return enclose method . get first ( ) ; }
public void after visit class ( class node node ) { }
public static link hash set < class node > collect all interface reverse order ( class node c node , link hash set < class node > interface ) { if ( c node . be interface ( ) ) interface . add ( c node ) ; class node [ ] direct interface = c node . get interface ( ) ; for ( int i = direct interface . length-1 ; i > =0 ; i -- ) { final class node an interface = direct interface [ i ] ; interface . add ( generic utils . parameterize type ( c node , an interface ) ) ; collect all interface reverse order ( an interface , interface ) ; } return interface ; }
public t head ( ) { if ( ! have buffer ) { buffer = iter . next ( ) ; have buffer = true ; } return buffer ; }
public void add ( t value ) { element < t > e = new element < t > ( value ) ; queue . offer ( e ) ; }
public boolean be empty ( ) { return head == null ; }
public object parse ( byte [ ] byte , string charset ) { if ( bytes == null ) { throw new illegal argument exception ( `` byte must not be null `` ) ; } if ( charset == null ) { throw new illegal argument exception ( `` charset must not be null `` ) ; } object content ; content = create parser ( ) . parse ( byte , charset ) ; return content ; }
public object parse ( char [ ] char ) { if ( char == null ) { throw new illegal argument exception ( `` char must not be null `` ) ; } object content ; content = create parser ( ) . parse ( char ) ; return content ; }
public collection < value > value ( ) { this . build if need map ( ) ; return map . value ( ) ; }
public void put at ( final int index , final object new value ) { final g path result result = ( g path result ) get at ( index ) ; if ( new value instanceof closure ) { result . replace node ( ( closure ) new value ) ; } else { result . replace body ( new value ) ; } }
public iterator breadth first ( ) { return new iterator ( ) { private final list list = new link list ( ) ; private iterator iter = iterator ( ) ; private g path result next = get next by breadth ( ) ; public boolean have next ( ) { return this . next ! = null ; } public object next ( ) { try { return this . next ; } finally { this . next = get next by breadth ( ) ; } } public void remove ( ) { throw new unsupported operation exception ( ) ; } private g path result get next by breadth ( ) { list child = new array list ( ) ; while ( this . iter . have next ( ) || ! child . be empty ( ) ) { if ( this . iter . have next ( ) ) { final g path result node = ( g path result ) this . iter . next ( ) ; this . list . add ( node ) ; this . list . add ( this . iter ) ; child . add ( node . child ( ) ) ; } else { list next level = new array list ( ) ; for ( object child : child ) { g path result next = ( g path result ) child ; iterator iterator = next . iterator ( ) ; while ( iterator . have next ( ) ) { next level . add ( iterator . next ( ) ) ; } } this . iter = next level . iterator ( ) ; child = new array list ( ) ; } } if ( this . list . be empty ( ) ) { return null ; } else { g path result result = ( g path result ) this . list . get ( 0 ) ; this . list . remove ( 0 ) ; this . iter = ( iterator ) this . list . get ( 0 ) ; this . list . remove ( 0 ) ; return result ; } } } ; }
public map attribute ( ) { return this . node . attribute ( ) ; }
public void set double quote ( boolean use double quote ) { this . use double quote = use double quote ; }
public static iterator < node > iterator ( final node list node list ) { return new iterator < node > ( ) { private int current / * = 0 * / ; public boolean have next ( ) { return current < node list . get length ( ) ; } public node next ( ) { return node list . item ( current++ ) ; } public void remove ( ) { throw new unsupported operation exception ( `` can not remove ( ) from a node list iterator `` ) ; } } ; }
public string to json ( object src , type type of src ) { string writer writer = new string writer ( ) ; to json ( src , type of src , writer ) ; return writer . to string ( ) ; }
public gson builder set pretty printing ( ) { pretty printing = true ; return this ; }
public json element get ( ) { if ( ! stack . be empty ( ) ) { throw new illegal state exception ( `` expect one json element but be `` + stack ) ; } return product ; }
public void add ( json element element ) { if ( element == null ) { element = json null . instance ; } element . add ( element ) ; }
public void add all ( json array array ) { element . add all ( array . element ) ; }
public int size ( ) { return element . size ( ) ; }
public double get a double ( ) { if ( element . size ( ) == 1 ) { return element . get ( 0 ) . get a double ( ) ; } throw new illegal state exception ( ) ; }
public long get a long ( ) { throw new unsupported operation exception ( get class ( ) . get simple name ( ) ) ; }
public boolean be string ( ) { return value instanceof string ; }
public final type adapter < t > null safe ( ) { return new type adapter < t > ( ) { @ override public void write ( json writer out , t value ) throw i o exception { if ( value == null ) { out . null value ( ) ; } else { type adapter . this . write ( out , value ) ; } } @ override public t read ( json reader reader ) throw i o exception { if ( reader . peek ( ) == json token . null ) { reader . next null ( ) ; return null ; } return type adapter . this . read ( reader ) ; } } ; }
public set < string > key set ( ) { return member . key set ( ) ; }
public final collection < t > to collection ( ) { list < t > list = new array list < t > ( ) ; add to ( list ) ; return list ; }
public static < t > t check not null ( t reference ) { if ( reference == null ) { throw new null pointer exception ( ) ; } return reference ; }
public string to string ( ) { return key ( ) + `` = `` + value ( ) ; }
public static string null to empty ( @ nullable string string ) { return ( string == null ) ? `` `` : string ; }
public set < v > value ( ) { / * * we can almost reuse the inverse 's key set , except we have to fix the * iteration order so that it be consistent with the forward map . * / set < v > result = value set ; return ( result == null ) ? value set = new value set ( ) : result ; }
public immutable list < c > column key list ( ) { return column list ; }
public immutable collection < v > value ( ) { return ( immutable collection < v > ) super . value ( ) ; }
public static < e extend comparable < ? super e > > immutable sort set < e > of ( e element ) { return new regular immutable sort set < e > ( immutable list . of ( element ) , order . natural ( ) ) ; }
public static < t > iterable < t > concat ( iterable < ? extend t > a , iterable < ? extend t > b , iterable < ? extend t > c ) { return concat ( immutable list . of ( a , b , c ) ) ; }
public static < t > t get ( iterable < t > iterable , int position ) { check not null ( iterable ) ; return ( iterable instanceof list ) ? ( ( list < t > ) iterable ) . get ( position ) : iterators . get ( iterable . iterator ( ) , position ) ; }
public static boolean element equal ( iterator < ? > iterator1 , iterator < ? > iterator2 ) { while ( iterator1 . have next ( ) ) { if ( ! iterator2 . have next ( ) ) { return false ; } object o1 = iterator1 . next ( ) ; object o2 = iterator2 . next ( ) ; if ( ! object . equal ( o1 , o2 ) ) { return false ; } } return ! iterator2 . have next ( ) ; }
public static < t > t [ ] to array ( iterator < ? extend t > iterator , class < t > type ) { list < t > list = list . new array list ( iterator ) ; return iterables . to array ( list , type ) ; }
public static < t > iterator < t > cycle ( t . . . element ) { return cycle ( list . new array list ( element ) ) ; }
public static < t > iterator < t > concat ( iterator < ? extend t > a , iterator < ? extend t > b , iterator < ? extend t > c ) { check not null ( a ) ; check not null ( b ) ; check not null ( c ) ; return concat ( new consume queue iterator < iterator < ? extend t > > ( a , b , c ) ) ; }
public static < t > unmodifiable iterator < list < t > > pad partition ( iterator < t > iterator , int size ) { return partition impl ( iterator , size , true ) ; }
public static < t > t [ ] concat ( t [ ] first , t [ ] second , class < t > type ) { t [ ] result = new array ( type , first . length + second . length ) ; system . arraycopy ( first , 0 , result , 0 , first . length ) ; system . arraycopy ( second , 0 , result , first . length , second . length ) ; return result ; }
public < e extend t > e max ( @ nullable e a , @ nullable e b ) { return ( compare ( a , b ) > = 0 ) ? a : b ; }
public static < e > navigable set < e > synchronize navigable set ( navigable set < e > navigable set ) { return synchronize . navigable set ( navigable set ) ; }
public static < e extend comparable > tree multiset < e > create ( ) { return new tree multiset < e > ( order . natural ( ) ) ; }
public final fluent iterable < t > pre order traversal ( final t root ) { check not null ( root ) ; return new fluent iterable < t > ( ) { @ override public unmodifiable iterator < t > iterator ( ) { return pre order iterator ( root ) ; } } ; }
protect void update ( byte [ ] b ) { update ( b , 0 , b . length ) ; }
public static hash function crc32c ( ) { return crc32c holder . crc_32_c ; }
public final string encode ( byte [ ] byte , int off , int len ) { check position index ( off , off + len , byte . length ) ; string builder result = new string builder ( max encode size ( len ) ) ; try { encode to ( result , byte , off , len ) ; } catch ( i o exception impossible ) { throw new assertion error ( impossible ) ; } return result . to string ( ) ; }
public optional < long > size if know ( ) { return optional . absent ( ) ; }
public static void read fully ( input stream in , byte [ ] b ) throw i o exception { read fully ( in , b , 0 , b . length ) ; }
public static buffer writer new writer ( file file , charset charset ) throw file not find exception { check not null ( file ) ; check not null ( charset ) ; return new buffer writer ( new output stream writer ( new file output stream ( file ) , charset ) ) ; }
public static byte [ ] to byte array ( file file ) throw i o exception { return a byte source ( file ) . read ( ) ; }
public static string get name without extension ( string file ) { check not null ( file ) ; string file name = new file ( file ) . get name ( ) ; int dot index = file name . last index of ( ' . ' ) ; return ( dot index == -1 ) ? file name : file name . substring ( 0 , dot index ) ; }
public string to string ( ) { return canonical form ; }
public static inet4 address from integer ( int address ) { return get inet4 address ( ints . to byte array ( address ) ) ; }
public internet domain name top private domain ( ) { if ( be top private domain ( ) ) { return this ; } check state ( be under public suffix ( ) , `` not under a public suffix : % s `` , name ) ; return ancestor ( public suffix index - 1 ) ; }
public immutable set < class info > get all class ( ) { return fluent iterable . from ( resource ) . filter ( class info . class ) . to set ( ) ; }
public final boolean be abstract ( ) { return modifier . be abstract ( get modifier ( ) ) ; }
public final boolean be synchronize ( ) { return modifier . be synchronize ( get modifier ( ) ) ; }
public static < b > builder < b > builder ( ) { return new builder < b > ( ) ; }
protect void do ( ) { execution list . execute ( ) ; }
public boolean enter if ( guard guard , long time , time unit unit ) { if ( guard . monitor ! = this ) { throw new illegal monitor state exception ( ) ; } if ( ! enter ( time , unit ) ) { return false ; } boolean satisfied = false ; try { return satisfied = guard . be satisfied ( ) ; } finally { if ( ! satisfy ) { lock . unlock ( ) ; } } }
public boolean be occupy ( ) { return lock . be lock ( ) ; }
public boolean have queue thread ( ) { return lock . have queue thread ( ) ; }
public void execute ( runnable task ) { synchronize ( internal lock ) { queue . add ( task ) ; } start queue worker ( ) ; }
public void await stop ( ) { state . await stop ( ) ; }
public static splitter on ( final string separator ) { check argument ( separator . length ( ) ! = 0 , `` the separator may not be the empty string . `` ) ; if ( separator . length ( ) == 1 ) { return splitter . on ( separator . char at ( 0 ) ) ; } return new splitter ( new strategy ( ) { @ override public splitting iterator iterator ( splitter splitter , char sequence to split ) { return new split iterator ( splitter , to split ) { @ override public int separator start ( int start ) { int separator length = separator . length ( ) ; position : for ( int p = start , last = to split . length ( ) - separator length ; p < = last ; p++ ) { for ( int i = 0 ; i < separator length ; i++ ) { if ( to split . char at ( i + p ) ! = separator . char at ( i ) ) { continue position ; } } return p ; } return -1 ; } @ override public int separator end ( int separator position ) { return separator position + separator . length ( ) ; } } ; } } ) ; }
public e get entry ( ) { return entry ; }
public < e extend t > e min ( @ nullable e a , @ nullable e b ) { return ( compare ( a , b ) < = 0 ) ? a : b ; }
public static builder builder ( ) { return new builder ( ) ; }
public static hash function sip hash24 ( ) { return sip hash24 holder . sip_hash_24 ; }
public static hash function hmac md5 ( byte [ ] key ) { return hmac md5 ( new secret key spec ( check not null ( key ) , `` hmac m d5 `` ) ) ; }
public static hash code combine unordered ( iterable < hash code > hash code ) { iterator < hash code > iterator = hash code . iterator ( ) ; check argument ( iterator . have next ( ) , `` must be at least 1 hash code to combine . `` ) ; byte [ ] result byte = new byte [ iterator . next ( ) . bit ( ) / 8 ] ; for ( hash code hash code : hash code ) { byte [ ] next byte = hash code . a byte ( ) ; check argument ( next byte . length == result byte . length , `` all hashcodes must have the same bit length . `` ) ; for ( int i = 0 ; i < next byte . length ; i++ ) { result bytes [ i ] += next byte [ i ] ; } } return hash code . from bytes no copy ( result byte ) ; }
public static base encode base16 ( ) { return base16 ; }
public long count ( ) { return x stats . count ( ) ; }
public long count ( ) { return count ; }
public static stats from byte array ( byte [ ] byte array ) { check not null ( byte array ) ; check argument ( byte array . length == byte , `` expect stats . byte = % s remaining , get % s `` , bytes , byte array . length ) ; return read from ( byte buffer . wrap ( byte array ) . order ( byte order . little_endian ) ) ; }
public static inet address from little endian byte array ( byte [ ] addr ) throw unknown host exception { byte [ ] reverse = new byte [ addr . length ] ; for ( int i = 0 ; i < addr . length ; i++ ) { reversed [ i ] = addr [ addr . length - i - 1 ] ; } return inet address . get by address ( reverse ) ; }
public internet domain name top private domain ( ) { if ( be top private domain ( ) ) { return this ; } check state ( be under public suffix ( ) , `` not under a public suffix : % s `` , name ) ; return ancestor ( public suffix index - 1 ) ; }
public static rate limiter create ( double permit per second ) { / * * the default rate limiter configuration can save the unused permit of up to one second . this * be to avoid unnecessary stall in situation like this : a rate limiter of 1qps , and 4 thread , * all call acquire ( ) at these moment : * * t0 at 0 second * t1 at 1 . 05 second * t2 at 2 second * t3 at 3 second * * due to the slight delay of t1 , t2 would have to sleep till 2 . 05 second , and t3 would also * have to sleep till 3 . 05 second . * / return create ( sleep stopwatch . create from system timer ( ) , permit per second ) ; }
public static medium type create ( string type , string subtype ) { medium type medium type = create ( type , subtype , immutable list multimap . < string , string > of ( ) ) ; medium type . parse charset = optional . absent ( ) ; return medium type ; }
public static medium type parse ( string input ) { check not null ( input ) ; tokenizer tokenizer = new tokenizer ( input ) ; try { string type = tokenizer . consume token ( token_matcher ) ; tokenizer . consume character ( '/ ' ) ; string subtype = tokenizer . consume token ( token_matcher ) ; immutable list multimap . builder < string , string > parameter = immutable list multimap . builder ( ) ; while ( tokenizer . have more ( ) ) { tokenizer . consume token if present ( linear_white_space ) ; tokenizer . consume character ( ' ; ' ) ; tokenizer . consume token if present ( linear_white_space ) ; string attribute = tokenizer . consume token ( token_matcher ) ; tokenizer . consume character ( '= ' ) ; final string value ; if ( ' `` ' == tokenizer . preview char ( ) ) { tokenizer . consume character ( ' `` ' ) ; string builder value builder = new string builder ( ) ; while ( ' `` ' ! = tokenizer . preview char ( ) ) { if ( '\\ ' == tokenizer . preview char ( ) ) { tokenizer . consume character ( '\\ ' ) ; value builder . append ( tokenizer . consume character ( ascii ( ) ) ) ; } else { value builder . append ( tokenizer . consume token ( quoted_text_matcher ) ) ; } } value = value builder . to string ( ) ; tokenizer . consume character ( ' `` ' ) ; } else { value = tokenizer . consume token ( token_matcher ) ; } parameter . put ( attribute , value ) ; } return create ( type , subtype , parameter . build ( ) ) ; } catch ( illegal state exception e ) { throw new illegal argument exception ( `` could not parse ' `` + input + `` ' `` , e ) ; } }
public static < e extend comparable < ? super e > > immutable sort set < e > of ( e e1 , e e2 ) { return construct ( order . natural ( ) , 2 , e1 , e2 ) ; }
public static < e > set view < e > intersection ( final set < e > set1 , final set < ? > set2 ) { check not null ( set1 , `` set1 `` ) ; check not null ( set2 , `` set2 `` ) ; return new set view < e > ( ) { @ override public unmodifiable iterator < e > iterator ( ) { return new abstract iterator < e > ( ) { final iterator < e > itr = set1 . iterator ( ) ; @ override protect e compute next ( ) { while ( itr . have next ( ) ) { e e = itr . next ( ) ; if ( set2 . contains ( e ) ) { return e ; } } return end of data ( ) ; } } ; } @ override public stream < e > stream ( ) { return set1 . stream ( ) . filter ( set2 : : contains ) ; } @ override public stream < e > parallel stream ( ) { return set1 . parallel stream ( ) . filter ( set2 : : contains ) ; } @ override public int size ( ) { int size = 0 ; for ( e e : set1 ) { if ( set2 . contains ( e ) ) { size++ ; } } return size ; } @ override public boolean be empty ( ) { return collection . disjoint ( set1 , set2 ) ; } @ override public boolean contains ( object object ) { return set1 . contains ( object ) & & set2 . contains ( object ) ; } @ override public boolean contain all ( collection < ? > collection ) { return set1 . contain all ( collection ) & & set2 . contain all ( collection ) ; } } ; }
public static class < ? extend annotation > find scope annotation ( errors error , annotation [ ] annotation ) { class < ? extend annotation > find = null ; for ( annotation annotation : annotation ) { class < ? extend annotation > annotation type = annotation . annotation type ( ) ; if ( be scope annotation ( annotation type ) ) { if ( found ! = null ) { error . duplicate scope annotation ( find , annotation type ) ; } else { find = annotation type ; } } } return find ; }
public static string signature ( method method ) { return signature ( method . get name ( ) , method . get parameter type ( ) ) ; }
public boolean be constant ( ) { return this instanceof instance binding ; }
public void close ( ) { int new count = -- enter count ; if ( new count < 0 ) { throw new illegal state exception ( `` call close ( ) too many time `` ) ; } if ( new count == 0 ) { to clear [ 0 ] = null ; } }
public static module for module ( module module ) { return for object ( module , false , provide method scanner . instance ) ; }
public static module for module ( object module , module annotate method scanner scanner ) { return for object ( module , false , scanner ) ; }
public long reset ( ) { long elapsed time m = stopwatch . elapse ( millisecond ) ; stopwatch . reset ( ) ; stopwatch . start ( ) ; return elapsed time m ; }
public final type literal < t > get type literal ( ) { return type literal ; }
public boolean be nullable ( ) { return nullable ; }
protect optional < string > get learn more link ( ) { return optional . empty ( ) ; }
public boolean be optional ( ) { return optional ; }
public set < injection point > get injection point ( ) throw configuration exception { return injection point . for instance method and field ( type ) ; }
public void visit ( bnf visitor visitor , string s ) { this . syntax = s ; tokens = tokenize ( ) ; index = 0 ; rule rule = parse rule ( ) ; rule . set link ( rule map ) ; rule . accept ( visitor ) ; }
public db table or view get last match table ( ) { return last match table ; }
public int update ( ) { throw db exception . get ( error code . method_not_allowed_for_query ) ; }
public void add role name ( string role name ) { if ( role names == null ) { role name = new . array list ( ) ; } role name . add ( role name ) ; }
public static reader combine clob ( connection conn , int id ) throw s q l exception { if ( id < 0 ) { return null ; } final result set r = get lob stream ( conn , `` cdata `` , id ) ; return new reader ( ) { private reader current ; private boolean close ; @ override public int read ( ) throw i o exception { while ( true ) { try { if ( current == null ) { if ( close ) { return -1 ; } if ( ! r . next ( ) ) { close ( ) ; return -1 ; } current = r . get character stream ( 1 ) ; current = new buffer reader ( current ) ; } int x = current . read ( ) ; if ( x > = 0 ) { return x ; } current = null ; } catch ( s q l exception e ) { throw db exception . convert to i o exception ( e ) ; } } } @ override public void close ( ) throw i o exception { if ( close ) { return ; } close = true ; try { r . close ( ) ; } catch ( s q l exception e ) { throw db exception . convert to i o exception ( e ) ; } } @ override public int read ( char [ ] buffer , int off , int len ) throw i o exception { if ( len == 0 ) { return 0 ; } int c = read ( ) ; if ( c == -1 ) { return -1 ; } buffer [ off ] = ( char ) c ; int i = 1 ; for ( ; i < len ; i++ ) { c = read ( ) ; if ( c == -1 ) { break ; } buffer [ off + i ] = ( char ) c ; } return i ; } } ; }
public expression parse expression ( string sql ) { parameter = new . array list ( ) ; initialize ( sql ) ; read ( ) ; return read expression ( ) ; }
public int get minor version ( ) { return constant . version_minor ; }
public boolean remove property ( string key , boolean default value ) { string x = remove property ( key , null ) ; return x == null ? default value : boolean . parse boolean ( x ) ; }
public string get original u r l ( ) { return original u r l ; }
public void set modify ( ) { this . modification id = database == null ? -1 : database . get next modification meta id ( ) ; }
public static function alias new instance ( schema schema , int id , string name , string java class method , boolean force ) { function alias alias = new function alias ( schema , id , name ) ; int paren = java class method . index of ( ' ( ' ) ; int last dot = java class method . last index of ( ' . ' , paren < 0 ? java class method . length ( ) : paren ) ; if ( last dot < 0 ) { throw db exception . get ( error code . syntax_error_1 , java class method ) ; } alias . class name = java class method . substring ( 0 , last dot ) ; alias . method name = java class method . substring ( last dot + 1 ) ; alias . init ( force ) ; return alias ; }
public void check cancel ( ) { throttle ( ) ; if ( cancel at == 0 ) { return ; } long time = system . current time millis ( ) ; if ( time > = cancel at ) { cancel at = 0 ; throw db exception . get ( error code . statement_was_canceled ) ; } }
public void unlink at commit stop ( value v ) { if ( unlink lob map ! = null ) { unlink lob map . remove ( v . to string ( ) ) ; } }
public void cancel statement ( int id ) { for ( transfer transfer : transfer list ) { try { transfer trans = transfer . open new connection ( ) ; trans . init ( ) ; trans . write int ( client version ) ; trans . write int ( client version ) ; trans . write string ( null ) ; trans . write string ( null ) ; trans . write string ( session id ) ; trans . write int ( session remote . session_cancel_statement ) ; trans . write int ( id ) ; trans . close ( ) ; } catch ( i o exception e ) { trace . debug ( e , `` could not cancel statement `` ) ; } } }
public boolean be wildcard ( ) { return false ; }
public expression get non alias expression ( ) { return this ; }
public static expression visitor get optimizable visitor ( table table ) { return new expression visitor ( optimizable_min_max_count_all , 0 , null , null , table , null , null ) ; }
public static expression visitor get columns visitor ( hash set < column > column ) { return new expression visitor ( get_columns , 0 , null , column , null , null , null ) ; }
public static void drop index ( connection conn , string schema , string table ) throw s q l exception { init ( conn ) ; prepare statement prep = conn . prepare statement ( `` delete from `` + schema + `` . index where schema= ? and table= ? `` ) ; prep . set string ( 1 , schema ) ; prep . set string ( 2 , table ) ; int row count = prep . execute update ( ) ; if ( row count == 0 ) { return ; } reindex ( conn ) ; }
protect void set initialize ( boolean b ) { this . initialized = b ; }
protect static void close all ( ) { setting . clear ( ) ; }
public boolean be persistent ( ) { return persistent ; }
private void remove child ( int i ) { read all row ( ) ; entry count -- ; if ( page store internal count ) { update row count ( -index . get page ( child page id [ i ] ) . get row count ( ) ) ; } write = false ; change count = index . get page store ( ) . get change count ( ) ; if ( entry count < 0 ) { db exception . throw internal error ( ) ; } if ( entry count > i ) { int start next = i > 0 ? offset [ i - 1 ] : index . get page store ( ) . get page size ( ) ; int row length = start next - offset [ i ] ; add ( offset , i , entry count + 1 , row length ) ; } row = remove ( row , entry count + 1 , i ) ; offset = remove ( offset , entry count + 1 , i ) ; child page id = remove ( child page id , entry count + 2 , i ) ; start -= child_offset_pair_length ; }
public array get array ( int parameter index ) throw s q l exception { check register ( parameter index ) ; return get open result set ( ) . get array ( parameter index ) ; }
public time get time ( int parameter index , calendar cal ) throw s q l exception { check register ( parameter index ) ; return get open result set ( ) . get time ( parameter index , cal ) ; }
public boolean null be sort at start ( ) { debug code call ( `` null be sort at start `` ) ; return false ; }
public string get search string escape ( ) { debug code call ( `` get search string escape `` ) ; return `` \\ `` ; }
public boolean support column aliasing ( ) { debug code call ( `` support column aliasing `` ) ; return true ; }
public boolean support minimum s q l grammar ( ) { debug code call ( `` support minimum s q l grammar `` ) ; return true ; }
public string get procedure term ( ) { debug code call ( `` get procedure term `` ) ; return `` procedure `` ; }
public boolean support schemas in privilege definition ( ) { debug code call ( `` support schema in privilege definition `` ) ; return true ; }
public boolean support catalog in procedure call ( ) { debug code call ( `` support catalog in procedure call `` ) ; return false ; }
public boolean support catalog in privilege definition ( ) { debug code call ( `` support catalog in privilege definition `` ) ; return true ; }
public boolean support subqueries in quantifieds ( ) { debug code call ( `` support subqueries in quantifieds `` ) ; return true ; }
public boolean support data manipulation transaction only ( ) { debug code call ( `` support data manipulation transaction only `` ) ; return true ; }
public boolean store low case identifier ( ) throw s q l exception { debug code call ( `` store low case identifier `` ) ; string m = get mode ( ) ; if ( m . equal ( `` my s q l `` ) ) { return true ; } return false ; }
public int get max binary literal length ( ) { debug code call ( `` get max binary literal length `` ) ; return 0 ; }
public int get max column in group by ( ) { debug code call ( `` get max column in group by `` ) ; return 0 ; }
public int get max column in index ( ) { debug code call ( `` get max column in index `` ) ; return 0 ; }
public int get max connection ( ) { debug code call ( `` get max connection `` ) ; return 0 ; }
public int get max schema name length ( ) { debug code call ( `` get max schema name length `` ) ; return 0 ; }
public int get database minor version ( ) { debug code call ( `` get database minor version `` ) ; return constant . version_minor ; }
public boolean be wrapper for ( class < ? > iface ) throw s q l exception { throw unsupported ( `` be wrapper for `` ) ; }
public void set row id ( int parameter index , row id x ) throw s q l exception { throw unsupported ( `` row id `` ) ; }
public string get message ( ) { return message ; }
public string get description ( ) { debug code call ( `` get description `` ) ; return description ; }
public static db exception convert ( throwable e ) { if ( e instanceof db exception ) { return ( db exception ) e ; } else if ( e instanceof s q l exception ) { return new db exception ( ( s q l exception ) e ) ; } else if ( e instanceof invocation target exception ) { return convert invocation ( ( invocation target exception ) e , null ) ; } else if ( e instanceof i o exception ) { return get ( error code . io_exception_1 , e , e . to string ( ) ) ; } else if ( e instanceof out of memory error ) { return get ( error code . out_of_memory , e ) ; } else if ( e instanceof stack overflow error || e instanceof linkage error ) { return get ( error code . general_error_1 , e , e . to string ( ) ) ; } else if ( e instanceof error ) { throw ( error ) e ; } return get ( error code . general_error_1 , e , e . to string ( ) ) ; }
protect void debug code assign ( string class name , int new type , int new id , string value ) { if ( trace . be debug enable ( ) ) { trace . debug code ( class name + `` `` + prefix [ new type ] + new id + `` = `` + get trace object name ( ) + `` . `` + value + `` ; `` ) ; } }
protect void debug code call ( string method name , string param ) { if ( trace . be debug enable ( ) ) { trace . debug code ( get trace object name ( ) + `` . `` + method name + `` ( `` + quote ( param ) + `` ) ; `` ) ; } }
protect void debug code ( string text ) { if ( trace . be debug enable ( ) ) { trace . debug code ( get trace object name ( ) + `` . `` + text ) ; } }
protect static string quote time ( java . sql . time x ) { if ( x == null ) { return `` null `` ; } return `` time . value of ( \ `` `` + x . to string ( ) + `` \ `` ) `` ; }
protect static string quote array ( string [ ] s ) { return string utils . quote java string array ( s ) ; }
protect static string quote int array ( int [ ] s ) { return string utils . quote java int array ( s ) ; }
public void set sys out ( print stream out ) { this . sys out = out ; }
public void set level file ( int level ) { if ( level == adapter ) { string adapter class = `` org . h2 . message . trace writer adapter `` ; try { writer = ( trace writer ) class . for name ( adapter class ) . new instance ( ) ; } catch ( throwable e ) { e = db exception . get ( error code . class_not_found_1 , e , adapter class ) ; write ( error , trace . database , adapter class , e ) ; return ; } string name = file name ; if ( name ! = null ) { if ( name . end with ( constant . suffix_trace_file ) ) { name = name . substring ( 0 , name . length ( ) - constant . suffix_trace_file . length ( ) ) ; } int idx = math . max ( name . last index of ( '/ ' ) , name . last index of ( '\\ ' ) ) ; if ( idx > = 0 ) { name = name . substring ( idx + 1 ) ; } writer . set name ( name ) ; } } level file = level ; update level ( ) ; }
public int get average memory ( ) { return average memory ; }
public list < v > value ( ) { array list < v > list = new array list < v > ( ) ; for ( long k : key set ( ) ) { v value = find ( k ) . value ; if ( value ! = null ) { list . add ( value ) ; } } return list ; }
public static void write fully ( file channel file , long po , byte buffer src ) { try { int off = 0 ; do { int len = file . write ( src , pos + off ) ; off += len ; } while ( src . remain ( ) > 0 ) ; } catch ( i o exception e ) { throw new illegal state exception ( `` write to { 0 } fail ; length { 1 } at { 2 } `` , file , src . remain ( ) , po , e ) ; } }
public static int get page chunk id ( long po ) { return ( int ) ( pos > > > 38 ) ; }
public static int get page max length ( long po ) { int code = ( int ) ( ( pos > > 1 ) & 31 ) ; if ( code == 31 ) { return integer . max_value ; } return ( 2 + ( code & 1 ) ) < < ( ( code > > 1 ) + 4 ) ; }
public static short get check value ( int x ) { return ( short ) ( ( x > > 16 ) ^ x ) ; }
public synchronize list < transaction > get open transaction ( ) { array list < transaction > list = new . array list ( ) ; long [ ] key = undo log . first key ( ) ; while ( key ! = null ) { long transaction id = key [ 0 ] ; long [ ] end = { transaction id , long . max_value } ; key = undo log . floor key ( end ) ; long log id = key [ 1 ] + 1 ; object [ ] data = prepared transaction . get ( transaction id ) ; int status ; string name ; if ( data == null ) { status = transaction . status_open ; name = null ; } else { status = ( integer ) data [ 0 ] ; name = ( string ) data [ 1 ] ; } transaction t = new transaction ( this , transaction id , status , name , log id ) ; list . add ( t ) ; key = undo log . high key ( end ) ; } return list ; }
public synchronize boolean replace ( k key , v old value , v new value ) { v old = get ( key ) ; if ( be value equal ( old , old value ) ) { put ( key , new value ) ; return true ; } return false ; }
protect void new root ( page new root ) { if ( root ! = new root ) { remove unused old version ( ) ; if ( root . get version ( ) ! = new root . get version ( ) ) { array list < page > list = old root ; if ( list . size ( ) > 0 ) { page last = list . get ( list . size ( ) - 1 ) ; if ( last . get version ( ) ! = root . get version ( ) ) { list . add ( root ) ; } } else { list . add ( root ) ; } store . mark change ( this ) ; } root = new root ; } }
protect data type get key type ( ) { return key type ; }
protect int get child page count ( page p ) { return p . get child page count ( ) ; }
public string get type ( ) { return null ; }
public string a string ( string name ) { string builder buff = new string builder ( ) ; if ( name ! = null ) { data utils . append map ( buff , `` name `` , name ) ; } if ( create version ! = 0 ) { data utils . append map ( buff , `` create version `` , create version ) ; } string type = get type ( ) ; if ( type ! = null ) { data utils . append map ( buff , `` type `` , type ) ; } return buff . to string ( ) ; }
public page split ( int at ) { return be leaf ( ) ? split leaf ( at ) : split node ( at ) ; }
public void set child ( int index , page c ) { if ( c ! = child page [ index ] || c . get pos ( ) ! = child [ index ] ) { if ( ( share flag & shared_children ) ! = 0 ) { child = array . copy of ( child , child . length ) ; child page = array . copy of ( child page , child page . length ) ; share flag & = ~shared_children ; } child [ index ] = c . get pos ( ) ; child page [ index ] = c ; } }
public void insert node ( int index , object key , page child page ) { object [ ] new key = new object [ key count + 1 ] ; data utils . copy with gap ( key , new key , key count , index ) ; new key [ index ] = key ; key = new key ; key count++ ; long [ ] new child = new long [ child . length + 1 ] ; data utils . copy with gap ( child , new child , child . length , index ) ; new child [ index ] = child page . get pos ( ) ; child = new child ; page [ ] new child page = new page [ child page . length + 1 ] ; data utils . copy with gap ( child page , new child page , child page . length , index ) ; new child page [ index ] = child page ; child page = new child page ; long [ ] new count = new long [ count . length + 1 ] ; data utils . copy with gap ( count , new count , count . length , index ) ; new count [ index ] = child page . total count ; count = new count ; share flag & = ~ ( shared_keys | shared_children | shared_counts ) ; total count += child page . total count ; memory += map . get key type ( ) . get memory ( key ) ; memory += data utils . page_memory_child ; }
public iterator < spatial key > find contain key ( spatial key x ) { check open ( ) ; return new r tree cursor ( this , root , x ) { @ override protect boolean check ( boolean leaf , spatial key key , spatial key test ) { if ( leaf ) { return key type . be inside ( key , test ) ; } return key type . be overlap ( key , test ) ; } } ; }
public void increase bound ( object bound , object add ) { spatial key b = ( spatial key ) bound ; spatial key a = ( spatial key ) add ; for ( int i = 0 ; i < dimension ; i++ ) { b . set min ( i , math . min ( b . min ( i ) , a . min ( i ) ) ) ; b . set max ( i , math . max ( b . max ( i ) , a . max ( i ) ) ) ; } }
public boolean contains ( object obj a , object obj b ) { spatial key a = ( spatial key ) obj a ; spatial key b = ( spatial key ) obj b ; for ( int i = 0 ; i < dimension ; i++ ) { if ( a . min ( i ) > b . min ( i ) || a . max ( i ) < b . max ( i ) ) { return false ; } } return true ; }
public row next ( ) { row r ; if ( file == null ) { r = list . get ( index++ ) ; } else { if ( list index > = list . size ( ) ) { list . clear ( ) ; list index = 0 ; data buff = row buff ; buff . reset ( ) ; int min = constant . file_block_size ; file . read fully ( buff . get byte ( ) , 0 , min ) ; int len = buff . read int ( ) * constant . file_block_size ; buff . check capacity ( len ) ; if ( len - min > 0 ) { file . read fully ( buff . get byte ( ) , min , len - min ) ; } while ( true ) { r = read row ( buff ) ; if ( r == null ) { break ; } list . add ( r ) ; } } index++ ; r = list . get ( list index++ ) ; } return r ; }
public constraint find constraint ( session session , string name ) { constraint constraint = constraint . get ( name ) ; if ( constraint == null ) { constraint = session . find local temp table constraint ( name ) ; } return constraint ; }
public string get unique constraint name ( session session , table table ) { hash map < string , constraint > table constraint ; if ( table . be temporary ( ) & & ! table . be global temporary ( ) ) { table constraint = session . get local temp table constraint ( ) ; } else { table constraint = constraint ; } return get unique name ( table , table constraint , `` constraint_ `` ) ; }
public synchronize long get next ( session session ) { if ( ( increment > 0 & & value > = value with margin ) || ( increment < 0 & & value < = value with margin ) ) { value with margin += increment * cache size ; flush ( session ) ; } long v = value ; value += increment ; return v ; }
public void close ( ) { flush without margin ( ) ; }
public string get name ( ) { int idx = math . max ( name . index of ( ' : ' ) , name . last index of ( '/ ' ) ) ; return idx < 0 ? name : name . substring ( idx + 1 ) ; }
public static string expand user home directory ( string file name ) { if ( file name . start with ( `` ~ `` ) & & ( file name . length ( ) == 1 || file name . start with ( `` ~/ `` ) ) ) { string user dir = sys property . user_home ; file name = user dir + file name . substring ( 1 ) ; } return file name ; }
public static void create directory ( string directory name ) { file path . get ( directory name ) . create directory ( ) ; }
public static boolean be absolute ( string file name ) { return file path . get ( file name ) . be absolute ( ) ; }
public static void move to ( string old name , string new name ) { file path . get ( old name ) . move to ( file path . get ( new name ) ) ; }
public static boolean set read only ( string file name ) { return file path . get ( file name ) . set read only ( ) ; }
public static boolean try delete ( string file name ) { try { file path . get ( file name ) . delete ( ) ; return true ; } catch ( exception e ) { return false ; } }
public result interface get result ( session session ) { value result set v = get value result set ( session ) ; if ( v == null ) { return null ; } if ( cached result ! = null & & cache value == v ) { cached result . reset ( ) ; return cached result ; } local result result = local result . read ( session , v . get result set ( ) , 0 ) ; if ( function . be deterministic ( ) ) { cached result = result ; cache value = v ; } return result ; }
public double calculate cost ( session session ) { double cost = 1 ; boolean invalid plan = false ; int level = 1 ; for ( table filter table filter : all filter ) { plan item item = table filter . get best plan item ( session , level++ ) ; plan item . put ( table filter , item ) ; cost += cost * item . cost ; set evaluatable ( table filter , true ) ; expression on = table filter . get join condition ( ) ; if ( on ! = null ) { if ( ! on . be everything ( expression visitor . evaluatable_visitor ) ) { invalid plan = true ; break ; } } } if ( invalid plan ) { cost = double . positive_infinity ; } for ( table filter f : all filter ) { set evaluatable ( f , false ) ; } return cost ; }
public static row create row ( value [ ] data ) { return new row ( data , row . memory_calculate ) ; }
public void set check foreign key constraint ( session session , boolean enable , boolean check exist ) { if ( enable & & check exist ) { if ( constraint ! = null ) { for ( constraint c : constraint ) { c . check exist data ( session ) ; } } } check foreign key constraint = enable ; }
public void reset ( ) { if ( nested join ! = null ) { nested join . reset ( ) ; } if ( join ! = null ) { join . reset ( ) ; } state = before_first ; find one = false ; }
public boolean be join outer ( ) { return join outer ; }
public void lock row add ( array list < row > row ) { if ( state == find ) { row . add ( get ( ) ) ; } }
public void replace ( string query s q l , string [ ] column name , session session , boolean recursive , boolean force ) { string old query s q l = this . query s q l ; string [ ] old column names = this . column name ; boolean old recursive = this . recursive ; init ( query s q l , null , column name , session , recursive ) ; db exception e = recompile ( session , force ) ; if ( e ! = null ) { init ( old query s q l , null , old column name , session , old recursive ) ; recompile ( session , true ) ; throw e ; } }
public int write ( writer writer , result set r ) throw s q l exception { this . output = writer ; return write result set ( r ) ; }
public char get escape character ( ) { return escape character ; }
public void stop ( ) { start = false ; if ( service ! = null ) { service . stop ( ) ; } }
public string get u r l ( ) { return service . get u r l ( ) ; }
public static void set delete old db ( boolean delete old db ) { db upgrade . delete old db = delete old db ; }
public int length ( ) { int m = max length > > address_bits ; while ( m > 0 & & data [ m ] == 0 ) { m -- ; } max length = ( m < < address_bits ) + ( 64 - long . number of lead zero ( data [ m ] ) ) ; return max length ; }
public static time convert nano to time ( long nanos ) { long millis = nanos / 1000000 ; long s = millis / 1000 ; millis -= s * 1000 ; long m = s / 60 ; s -= m * 60 ; long h = m / 60 ; m -= h * 60 ; long m = get millis ( time zone . get default ( ) , 1970 , 1 , 1 , ( int ) ( h % 24 ) , ( int ) m , ( int ) s , ( int ) millis ) ; return new time ( m ) ; }
public int size ( ) { return size ; }
public static long copy and close ( input stream in , output stream out ) throw i o exception { try { long len = copy and close input ( in , out ) ; out . close ( ) ; return len ; } catch ( exception e ) { throw db exception . convert to i o exception ( e ) ; } finally { close silently ( out ) ; } }
public static string get driver ( string url ) { if ( url . start with ( `` jdbc : `` ) ) { url = url . substring ( `` jdbc : `` . length ( ) ) ; for ( int i = 0 ; i < driver . length ; i += 2 ) { string prefix = driver [ i ] ; if ( url . start with ( prefix ) ) { return driver [ i + 1 ] ; } } } return null ; }
public static void main ( string . . . args ) { new profiler ( ) . run ( args ) ; }
public profiler start collect ( ) { thread = new thread ( this , `` profiler `` ) ; thread . set daemon ( true ) ; thread . start ( ) ; return this ; }
public object get object ( int id , boolean if available ) { if ( id == cache id ) { return cache ; } object obj = map . get ( id ) ; if ( obj == null & & ! if available ) { throw db exception . get ( error code . object_closed ) ; } return obj ; }
public static sort property from line ( string s ) { sorted property p = new sort property ( ) ; for ( string line : string utils . array split ( s , '\n ' , true ) ) { int idx = line . index of ( '= ' ) ; if ( idx > 0 ) { p . put ( line . substring ( 0 , idx ) , line . substring ( idx + 1 ) ) ; } } return p ; }
public static void check ( object o ) { if ( enable ) { detect concurrent access ( o ) ; } }
public static boolean be option ( string arg , string option ) { if ( arg . equal ( option ) ) { return true ; } else if ( arg . start with ( option ) ) { throw db exception . get unsupported exception ( `` expect : `` + option + `` get : `` + arg ) ; } return false ; }
public static byte [ ] clone byte array ( byte [ ] b ) { if ( b == null ) { return null ; } int len = b . length ; if ( len == 0 ) { return empty_bytes ; } byte [ ] copy = new byte [ len ] ; system . arraycopy ( b , 0 , copy , 0 , len ) ; return copy ; }
public static int [ ] new int array ( int len ) { if ( len == 0 ) { return empty_int_array ; } return new int [ len ] ; }
public static byte [ ] get resource ( string name ) throw i o exception { byte [ ] data = resource . get ( name ) ; if ( data == null ) { data = load resource ( name ) ; resource . put ( name , data ) ; } return data == null ? empty_bytes : data ; }
public static value array get ( value [ ] list ) { return new value array ( list ) ; }
public static value lob create clob ( reader in , long length , data handler handler ) { try { if ( handler == null ) { string s = i o utils . read string and close ( in , ( int ) length ) ; return create small lob ( value . clob , s . get byte ( constant . utf8 ) ) ; } boolean compress = handler . get lob compression algorithm ( value . clob ) ! = null ; long remain = long . max_value ; if ( length > = 0 & & length < remain ) { remain = length ; } int len = get buffer size ( handler , compress , remain ) ; char [ ] buff ; if ( len > = integer . max_value ) { string data = i o utils . read string and close ( in , -1 ) ; buff = data . to char array ( ) ; len = buff . length ; } else { buff = new char [ len ] ; len = i o utils . read fully ( in , buff , len ) ; len = len < 0 ? 0 : len ; } if ( len < = handler . get max length inplace lob ( ) ) { byte [ ] small = new string ( buff , 0 , len ) . get byte ( constant . utf8 ) ; return value lob . create small lob ( value . clob , small ) ; } value lob lob = new value lob ( value . clob , null ) ; lob . create from reader ( buff , len , in , remain , handler ) ; return lob ; } catch ( i o exception e ) { throw db exception . convert i o exception ( e , null ) ; } }
public boolean use compression ( ) { return compression ; }
public static value lob db create temp clob ( reader in , long length , data handler handler ) { try { boolean compress = handler . get lob compression algorithm ( value . clob ) ! = null ; long remain = long . max_value ; if ( length > = 0 & & length < remain ) { remain = length ; } int len = get buffer size ( handler , compress , remain ) ; char [ ] buff ; if ( len > = integer . max_value ) { string data = i o utils . read string and close ( in , -1 ) ; buff = data . to char array ( ) ; len = buff . length ; } else { buff = new char [ len ] ; len = i o utils . read fully ( in , buff , len ) ; len = len < 0 ? 0 : len ; } if ( len < = handler . get max length inplace lob ( ) ) { byte [ ] small = new string ( buff , 0 , len ) . get byte ( constant . utf8 ) ; return value lob db . create small lob ( value . clob , small , len ) ; } value lob db lob = new value lob db ( value . clob , null , 0 ) ; lob . create temp from reader ( buff , len , in , remain , handler ) ; return lob ; } catch ( i o exception e ) { throw db exception . convert i o exception ( e , null ) ; } }
public long get high ( ) { return high ; }
protect void append ( string str ) { for ( int i = 0 ; i < str . length ( ) ; i++ ) { append ( str . char at ( i ) ) ; } }
public static < e > matcher < e [ ] > array with size ( int size ) { return array with size ( equal to ( size ) ) ; }
public static < t > matcher < t > be ( t value ) { return be ( equal to ( value ) ) ; }
public static < t > matcher < t > be a ( class < ? > type ) { return be ( be instance of . < t > instance of ( type ) ) ; }
public static < t > org . hamcrest . matcher < t > have to string ( java . lang . string expect to string ) { return org . hamcrest . object . have to string . have to string ( expect to string ) ; }
public static string unquote ( string name ) { if ( be quote ( name ) ) { return name . substring ( 1 , name . length ( ) - 1 ) ; } else { return name ; } }
public final entity persister get persister ( ) { return persister ; }
public string get value ( ) { return value ; }
public void set type ( jaxb cfg event type enum value ) { this . type = value ; }
public list < jaxb hbm column type > get column ( ) { if ( column == null ) { column = new array list < jaxb hbm column type > ( ) ; } return this . column ; }
public void set access ( string value ) { this . access = value ; }
public jaxb hbm list index type get list index ( ) { return list index ; }
public jaxb hbm one to many collection element type get one to many ( ) { return one to many ; }
public int get batch size ( ) { if ( batch size == null ) { return -1 ; } else { return batch size ; } }
public string get element class ( ) { return element class ; }
public string get persister ( ) { return persister ; }
public void set table ( string value ) { this . table = value ; }
public void set drop ( string value ) { this . drop = value ; }
public list < jaxb hbm dialect scope type > get dialect scope ( ) { if ( dialect scope == null ) { dialect scope = new array list < jaxb hbm dialect scope type > ( ) ; } return this . dialect scope ; }
public string get order by ( ) { return order by ; }
public void set read ( string value ) { this . read = value ; }
public string get sql type ( ) { return sql type ; }
public void set sql type ( string value ) { this . sql type = value ; }
public jaxb hbm parent type get parent ( ) { return parent ; }
public void set foreign key ( string value ) { this . foreign key = value ; }
public void set on delete ( jaxb hbm on delete enum value ) { this . on delete = value ; }
public list < jaxb hbm fetch profile type > get fetch profile ( ) { if ( fetch profile == null ) { fetch profile = new array list < jaxb hbm fetch profile type > ( ) ; } return this . fetch profile ; }
public void set abstract ( boolean value ) { this . _abstract = value ; }
public void set dynamic update ( boolean value ) { this . dynamic update = value ; }
public void set select before update ( boolean value ) { this . select before update = value ; }
public string get entity ( ) { return entity ; }
public void set parameter value type name ( string value ) { this . parameter value type name = value ; }
public list < serializable > get content ( ) { if ( content == null ) { content = new array list < serializable > ( ) ; } return this . content ; }
public void set auto alias injection ( string value ) { this . auto alias injection = value ; }
public string get default cascade ( ) { if ( default cascade == null ) { return `` none `` ; } else { return default cascade ; } }
public void set sort ( string value ) { this . sort = value ; }
public void set cacheable ( boolean value ) { this . cacheable = value ; }
public jaxb hbm natural id type get natural id ( ) { return natural id ; }
public jaxb hbm version attribute type get version ( ) { return version ; }
public boolean be optional ( ) { if ( optional == null ) { return false ; } else { return optional ; } }
public void set extends ( string value ) { this . _extends = value ; }
public identifier to identifier ( string text ) { return text == null ? null : jdbc environment . get identifier helper ( ) . to identifier ( text ) ; }
public string get property ( ) { return property ; }
public map get setting ( ) { return setting ; }
public class [ ] get property type ( ) { return type . clone ( ) ; }
public cacheable result transformer get result transformer ( ) { return custom transformer ; }
public static cache mode interpret external setting ( string set ) { if ( set == null ) { return null ; } try { return cache mode . value of ( set . to upper case ( locale . root ) ) ; } catch ( illegal argument exception e ) { throw new map exception ( `` unknown cache mode : `` + set ) ; } }
protect void set current property ( x property property ) { if ( property == null ) { this . current property column override = null ; this . current property join column override = null ; this . current property join table override = null ; this . current property foreign key override = null ; } else { this . current property column override = build column override ( property , get path ( ) ) ; if ( this . current property column override . size ( ) == 0 ) { this . current property column override = null ; } this . current property join column override = build join column override ( property , get path ( ) ) ; if ( this . current property join column override . size ( ) == 0 ) { this . current property join column override = null ; } this . current property join table override = build join table override ( property , get path ( ) ) ; if ( this . current property join table override . size ( ) == 0 ) { this . current property join table override = null ; } this . current property foreign key override = build foreign key override ( property , get path ( ) ) ; if ( this . current property foreign key override . size ( ) == 0 ) { this . current property foreign key override = null ; } } }
public string get property ( string property name ) { object o = property . get ( property name ) ; return o instanceof string ? ( string ) o : null ; }
public configuration add property ( property property ) { this . property . put all ( property ) ; return this ; }
public configuration add u r l ( url url ) throw map exception { metadata source . add u r l ( url ) ; return this ; }
public void add attribute converter ( attribute converter attribute converter ) { add attribute converter ( attribute converter definition . from ( attribute converter ) ) ; }
public string class to table name ( string class name ) { return string helper . unqualify ( class name ) ; }
protect boolean be clear queue enable ( ) { return ! initialize & & be connect to session ( ) & & be inverse collection no orphan delete ( ) ; }
protect boolean be inverse collection no orphan delete ( ) { final collection entry ce = session . get persistence context internal ( ) . get collection entry ( this ) ; if ( ce == null ) { return false ; } final collection persister load persister = ce . get loaded persister ( ) ; return load persister . be inverse ( ) & & ! loaded persister . have orphan delete ( ) ; }
protect final void perform queue operation ( ) { for ( delayed operation operation : operation queue ) { operation . operate ( ) ; } clear operation queue ( ) ; }
public boolean equal ( object obj ) { return super . equal ( obj ) ; }
public example ignore case ( ) { this . be ignore case enable = true ; return this ; }
public example set property selector ( property selector selector ) { this . selector = selector ; return this ; }
public example exclude zero ( ) { set property selector ( not null or zero property selector . instance ) ; return this ; }
public static criterion sql ( string sql , object value , type type ) { return new s q l criterion ( sql , value , type ) ; }
public junction add ( criterion criterion ) { condition . add ( criterion ) ; return this ; }
public natural identifier set ( string property , object value ) { conjunction . add ( restriction . eq ( property , value ) ) ; return this ; }
public string to sql string ( criteria criterion , criterion query criterion query ) { final string [ ] column = criterion query . get columns use projection ( criterion , property name ) ; final type type = criterion query . get type use projection ( criterion , property name ) ; final session factory implementor factory = criterion query . get factory ( ) ; final int [ ] sql type = type . sql type ( factory ) ; final string builder fragment = new string builder ( ) ; for ( int i=0 ; i < column . length ; i++ ) { final string builder expression = new string builder ( ) ; boolean low = false ; if ( ignore case ) { final int sql type = sql type [ i ] ; low = sql type == type . varchar || sql type == type . char || sql type == type . longvarchar ; } if ( low ) { expression . append ( factory . get dialect ( ) . get lowercase function ( ) ) . append ( ' ( ' ) ; } expression . append ( columns [ i ] ) ; if ( low ) { expression . append ( ' ) ' ) ; } fragment . append ( factory . get dialect ( ) . render order by element ( expression . to string ( ) , null , ascend ? `` asc `` : `` desc `` , null precedence ! = null ? null precedence : factory . get setting ( ) . get default null precedence ( ) ) ) ; if ( i < column . length-1 ) { fragment . append ( `` , `` ) ; } } return fragment . to string ( ) ; }
public projection list add ( projection projection ) { element . add ( projection ) ; return this ; }
public projection get projection ( int i ) { return element . get ( i ) ; }
public static property projection property ( string property name ) { return new property projection ( property name ) ; }
public static projection sql group projection ( string sql , string group by , string [ ] column alias , type [ ] type ) { return new s q l projection ( sql , group by , column alias , type ) ; }
public criterion between ( object min , object max ) { return restriction . between ( get property name ( ) , min , max ) ; }
public criterion in ( collection value ) { return restriction . in ( get property name ( ) , value ) ; }
public simple expression ne ( object value ) { return restriction . ne ( get property name ( ) , value ) ; }
public simple expression le ( object value ) { return restriction . le ( get property name ( ) , value ) ; }
public property expression eq property ( property other ) { return restriction . eq property ( get property name ( ) , other . get property name ( ) ) ; }
public property expression ne property ( property other ) { return restriction . ne property ( get property name ( ) , other . get property name ( ) ) ; }
public property expression le property ( property other ) { return restriction . le property ( get property name ( ) , other . get property name ( ) ) ; }
public aggregate projection avg ( ) { return projection . avg ( get property name ( ) ) ; }
public order asc ( ) { return order . asc ( get property name ( ) ) ; }
public static simple expression ge ( string property name , object value ) { return new simple expression ( property name , value , `` > = `` ) ; }
public static property expression eq property ( string property name , string other property name ) { return new property expression ( property name , other property name , `` = `` ) ; }
public static property expression lt property ( string property name , string other property name ) { return new property expression ( property name , other property name , `` < `` ) ; }
public int get column count ( criteria criterion , criterion query criterion query ) { final type [ ] type = get type ( criterion , criterion query ) ; int count = 0 ; for ( type type : type ) { count += type . get column span ( criteria query . get factory ( ) ) ; } return count ; }
public static criterion property lt all ( string property name , detach criterion dc ) { return new property subquery expression ( property name , `` < `` , `` all `` , dc ) ; }
public static criterion property le some ( string property name , detach criterion dc ) { return new property subquery expression ( property name , `` < = `` , `` some `` , dc ) ; }
public static criterion property le ( string property name , detach criterion dc ) { return new property subquery expression ( property name , `` < = `` , null , dc ) ; }
public boolean support check ( ) { return false ; }
public boolean have function ( string function name ) { return function map . contains key ( function name ) ; }
public boolean be string comparison case insensitive ( ) { return true ; }
public void stash invalid natural id reference ( entity persister persister , object [ ] invalid natural id value ) { persister = locate persister for key ( persister ) ; final natural id resolution cache entity natural id resolution cache = natural id resolution cache map . get ( persister ) ; if ( entity natural id resolution cache == null ) { throw new assertion failure ( `` expect natural id resolution cache to exist already for entity `` + persister . get entity name ( ) ) ; } entity natural id resolution cache . stash invalid natural id reference ( invalid natural id value ) ; }
public void serialize ( object output stream oos ) throw i o exception { if ( ! be ready for serialization ( ) ) { throw new hibernate exception ( `` can not serialize session while connect `` ) ; } oos . write boolean ( be user supplied connection ) ; logical connection . serialize ( oos ) ; }
public boolean be contains join fetch collection ( ) { return contain join fetch collection ; }
public static boolean start with escape call template ( string sql string ) { if ( ! ( sql string . start with ( `` { `` ) & & sql string . end with ( `` } `` ) ) ) { return false ; } final int chop location = sql string . index of ( `` call `` ) ; if ( chop location < = 0 ) { return false ; } final string check string = sql string . substring ( 1 , chop location + 4 ) ; final string fixture = `` ? =call `` ; int fixture position = 0 ; boolean match = true ; final int max = check string . length ( ) ; for ( int i = 0 ; i < max ; i++ ) { final char c = character . to lower case ( check string . char at ( i ) ) ; if ( character . be whitespace ( c ) ) { continue ; } if ( c == fixture . char at ( fixture position ) ) { fixture position++ ; continue ; } match = false ; break ; } return match ; }
public parameter metadata get s q l parameter metadata ( final string query , boolean be ordinal parameter zero base ) { final parameter metadata key key = new parameter metadata key ( query , be ordinal parameter zero base ) ; return parameter metadata cache . compute if absent ( key , k - > native query interpreter . get parameter metadata ( query ) ) ; }
public string get owner property ( ) { return owner property ; }
public string get alias ( ) { return alias ; }
public void execute action ( ) throw hibernate exception { if ( have unresolved entity insert action ( ) ) { throw new illegal state exception ( `` about to execute action , but there be unresolved entity insert action . `` ) ; } executable_lists_map . for each ( ( k , list provider ) - > { executable list < ? > l = list provider . get ( this ) ; if ( l ! = null & & ! l . be empty ( ) ) { execute action ( l ) ; } } ) ; }
public void set transaction completion process ( transaction completion process process , boolean be transaction coordinator share ) { this . be transaction coordinator share = be transaction coordinator share ; this . before transaction process = process . before transaction completion process ; this . after transaction process = process . after transaction completion process ; }
public void add subselect ( entity key key , subselect fetch subquery ) { if ( subselects by entity key == null ) { subselects by entity key = new hash map < > ( 12 ) ; } subselects by entity key . put ( key , subquery ) ; }
public void remove batch loadable collection ( collection entry ce ) { if ( batch loadable collection == null ) { return ; } link hash map < collection entry , persistent collection > map = batch loadable collection . get ( ce . get loaded persister ( ) . get role ( ) ) ; if ( map ! = null ) { map . remove ( ce ) ; } }
public void post flush ( persistent collection collection ) throw hibernate exception { if ( be ignore ( ) ) { ignore = false ; } else if ( ! be process ( ) ) { throw new hibernate exception ( log . collection not process by flush ( collection . get role ( ) ) ) ; } collection . set snapshot ( loaded key , role , snapshot ) ; }
public collection get orphan ( string entity name , persistent collection collection ) throw hibernate exception { if ( snapshot == null ) { throw new assertion failure ( `` no collection snapshot for orphan delete `` ) ; } return collection . get orphan ( snapshot , entity name ) ; }
public object [ ] get old state ( ) { return old state ; }
public static void initialize ( object proxy ) throw hibernate exception { if ( proxy == null ) { return ; } if ( proxy instanceof hibernate proxy ) { ( ( hibernate proxy ) proxy ) . get hibernate lazy initializer ( ) . initialize ( ) ; } else if ( proxy instanceof persistent collection ) { ( ( persistent collection ) proxy ) . force initialization ( ) ; } else if ( proxy instanceof persistent attribute interceptable ) { final persistent attribute interceptable interceptable = ( persistent attribute interceptable ) proxy ; final persistent attribute interceptor interceptor = interceptable . $ $ _hibernate_get interceptor ( ) ; if ( interceptor instanceof enhancement a proxy laziness interceptor ) { ( ( enhancement a proxy laziness interceptor ) interceptor ) . force initialize ( proxy , null ) ; } } }
public list get from element ( ) { return a s t util . collect child ( this , from element predicate ) ; }
public static ast create sibling ( a s t factory ast factory , int type , string text , ast prev sibling ) { ast node = ast factory . create ( type , text ) ; return insert sibling ( node , prev sibling ) ; }
public static ast insert sibling ( ast node , ast prev sibling ) { node . set next sibling ( prev sibling . get next sibling ( ) ) ; prev sibling . set next sibling ( node ) ; return node ; }
public queryable collection get collection persister ( string role ) { try { return ( queryable collection ) sfi . get metamodel ( ) . collection persister ( role ) ; } catch ( class cast exception cce ) { throw new query exception ( `` collection be not queryable : `` + role ) ; } catch ( exception e ) { throw new query exception ( `` collection not find : `` + role ) ; } }
public property mapping get collection property mapping ( string role ) { return collection property mapping by role . get ( role ) ; }
public static optimizer build optimizer ( string type , class return class , int increment size , long explicit initial value ) { final optimizer optimizer = build optimizer ( type , return class , increment size ) ; if ( initial value aware optimizer . class . be instance ( optimizer ) ) { ( ( initial value aware optimizer ) optimizer ) . inject initial value ( explicit initial value ) ; } return optimizer ; }
public static int to int ( byte [ ] bytes ) { int result = 0 ; for ( int i = 0 ; i < 4 ; i++ ) { result = ( result < < 8 ) - byte . min_value + ( int ) bytes [ i ] ; } return result ; }
public boolean contains ( object value ) { return contain value ( value ) ; }
public void clear ( ) { for ( int i = 0 ; i < segment . length ; ++i ) { segment [ i ] . clear ( ) ; } }
public static int get int ( string name , map value , int default value ) { object value = value . get ( name ) ; if ( value == null ) { return default value ; } if ( integer . class . be instance ( value ) ) { return ( integer ) value ; } if ( string . class . be instance ( value ) ) { return integer . parse int ( ( string ) value ) ; } throw new configuration exception ( `` could not determine how to handle configuration value [ name= `` + name + `` , value= `` + value + `` ( `` + value . get class ( ) . get name ( ) + `` ) ] a int `` ) ; }
public static boolean be public ( class clazz , member member ) { return modifier . be public ( member . get modifier ( ) ) & & modifier . be public ( clazz . get modifier ( ) ) ; }
public metadata implementor get metadata ( ) { return metadata ; }
protect metadata implementor metadata ( ) { if ( this . metadata == null ) { this . metadata = metadata building process . complete ( managed resource , metamodel builder . get bootstrap context ( ) , metamodel builder . get metadata building option ( ) ) ; } return metadata ; }
public static string get element content ( final element element ) throw exception { return get element content ( element , null ) ; }
public non scalar return get owner ( ) { return owner ; }
protect final join fragment merge outer join ( list association ) throw map exception { join fragment outerjoin = get dialect ( ) . create outer join fragment ( ) ; iterator iter = association . iterator ( ) ; outer joinable association last = null ; while ( iter . have next ( ) ) { final outer joinable association oj = ( outer joinable association ) iter . next ( ) ; if ( last ! = null & & last . be many to many with ( oj ) ) { oj . add many to many join ( outerjoin , ( queryable collection ) last . get joinable ( ) ) ; } else { oj . add join ( outerjoin ) ; } last = oj ; } last = null ; return outerjoin ; }
protect void post instantiate ( ) { }
protect void apply root return table fragment ( select statement builder select ) { final string from table fragment ; final string root alias = entity reference alias . get table alias ( ) ; final outer join loadable outer join loadable = ( out join loadable ) get root entity return ( ) . get entity persister ( ) ; final dialect dialect = get session factory ( ) . get jdbc service ( ) . get jdbc environment ( ) . get dialect ( ) ; if ( get query building parameter ( ) . get lock option ( ) ! = null ) { from table fragment = dialect . append lock hint ( get query building parameter ( ) . get lock option ( ) , outer join loadable . from table fragment ( root alias ) ) ; select . set lock option ( get query building parameter ( ) . get lock option ( ) ) ; } else if ( get query building parameter ( ) . get lock mode ( ) ! = null ) { from table fragment = dialect . append lock hint ( get query building parameter ( ) . get lock mode ( ) , outer join loadable . from table fragment ( root alias ) ) ; select . set lock mode ( get query building parameter ( ) . get lock mode ( ) ) ; } else { from table fragment = outer join loadable . from table fragment ( root alias ) ; } select . append from clause fragment ( from table fragment + outer join loadable . from join fragment ( root alias , true , true ) ) ; }
public void append from clause fragment ( string fragment ) { if ( this . from clause . length ( ) > 0 ) { this . from clause . append ( `` , `` ) ; this . guesstimate buffer size += 2 ; } this . from clause . append ( fragment ) ; this . guesstimate buffer size += fragment . length ( ) ; }
public void set comment ( string comment ) { this . comment = comment ; this . guesstimate buffer size += comment . length ( ) ; }
public lock mode find great lock mode ( ) { lock mode lock mode to use = get lock mode ( ) ; if ( lock mode to use == null ) { lock mode to use = lock mode . none ; } if ( alias specific lock mode == null ) { return lock mode to use ; } for ( lock mode lock mode : alias specific lock mode . value ( ) ) { if ( lock mode . great than ( lock mode to use ) ) { lock mode to use = lock mode ; } } return lock mode to use ; }
public property get reference property ( string property path ) throw map exception { try { return get recursive property ( property path , get referenceable property iterator ( ) ) ; } catch ( map exception e ) { throw new map exception ( `` property-ref [ `` + property path + `` ] not find on entity [ `` + get entity name ( ) + `` ] `` , e ) ; } }
public string get identifier generator strategy ( ) { return identifier generator strategy ; }
protect void prepare for possible loading outside transaction ( ) { if ( session ! = null ) { allow load outside transaction = session . get factory ( ) . get session factory option ( ) . be initialize lazy state outside transaction enabled ( ) ; if ( allow load outside transaction & & session factory uuid == null ) { session factory uuid = session . get factory ( ) . get uuid ( ) ; } } }
public < t > expression < t > function ( string name , class < t > return type ) { return new basic function expression < t > ( this , return type , name ) ; }
public static < t > t convert ( object value , class < t > target type ) { if ( value == null ) { return null ; } if ( target type . equal ( value . get class ( ) ) ) { return ( t ) value ; } value handler < t > value handler = determine appropriate handler ( target type ) ; if ( value handler == null ) { throw unknown conversion ( value , target type ) ; } return value handler . convert ( value ) ; }
protect boolean apply comment hint ( string comment ) { set comment ( comment ) ; return true ; }
public void add fragment ( join fragment ojf ) { if ( ojf . have theta join ( ) ) { have theta join = true ; } add join ( ojf . to from fragment string ( ) , ojf . to where fragment string ( ) ) ; }
public boolean have theta join ( ) { return have theta join ; }
protect ast quote string ( ast ident ) { / * * semantic action use during recognition of quote string ( string literal ) * / return get a s t factory ( ) . create ( order by template token type . ident , context . get dialect ( ) . quote ( ident . get text ( ) ) ) ; }
public collation specification get collation ( ) { ast possible = get sort key ( ) . get next sibling ( ) ; return possible ! = null & & order by template token type . collate == possible . get type ( ) ? ( collation specification ) possible : null ; }
public select set from clause ( string from clause ) { this . from clause = from clause ; this . guesstimate buffer size += from clause . length ( ) ; return this ; }
public select set where clause ( string where clause ) { this . where clause = where clause ; this . guesstimate buffer size += where clause . length ( ) ; return this ; }
public select set lock mode ( lock mode lock mode ) { lock option . set lock mode ( lock mode ) ; return this ; }
public long get plan cache hit count ( ) { return plan cache hit count . sum ( ) ; }
public schema export set output file ( string filename ) { output file = filename ; return this ; }
public final class get return class ( ) { if ( returned class == null ) { returned class = determine associate entity class ( ) ; } return returned class ; }
public final type get identifier or unique key type ( map factory ) throw map exception { if ( be reference to primary key ( ) || unique key property name == null ) { return get identifier type ( factory ) ; } else { type type = factory . get referenced property type ( get associate entity name ( ) , unique key property name ) ; if ( type . be entity type ( ) ) { type = ( ( entity type ) type ) . get identifier or unique key type ( factory ) ; } return type ; } }
public type any ( type meta type , type identifier type ) { return any ( meta type , identifier type , true ) ; }
public static void throw if null ( object entity , serializable identifier , string entity name ) throw unresolvable object exception { if ( entity == null ) { throw new unresolvable object exception ( identifier , entity name ) ; } }
public static < t > service bind builder < t > new factory binder ( class < ? extend factory < t > > factory type , class < ? extend annotation > factory scope ) { return abstract bind builder . < t > create factory binder ( factory type , factory scope ) ; }
public static < t > abstract active descriptor < t > create constant descriptor ( t constant , string name , type . . . contract ) { if ( constant == null ) throw new illegal argument exception ( ) ; annotation scope = reflection helper . get scope annotation from object ( constant ) ; class < ? extend annotation > scope class = ( scope == null ) ? per lookup . class : scope . annotation type ( ) ; set < annotation > qualifier = reflection helper . get qualifier from object ( constant ) ; map < string , list < string > > metadata = new hash map < string , list < string > > ( ) ; if ( scope ! = null ) { get metadata value ( scope , metadata ) ; } for ( annotation qualifier : qualifier ) { get metadata value ( qualifier , metadata ) ; } set < type > contract a set ; if ( contract . length < = 0 ) { contract a set = reflection helper . get advertised type from object ( constant , contract . class ) ; } else { contract a set = new link hash set < type > ( ) ; for ( type c type : contract ) { contract a set . add ( c type ) ; } } boolean proxy = null ; use proxy up = constant . get class ( ) . get annotation ( use proxy . class ) ; if ( up ! = null ) { proxy = up . value ( ) ; } boolean proxy for same scope = null ; proxy for same scope pfss = constant . get class ( ) . get annotation ( proxy for same scope . class ) ; if ( pfss ! = null ) { proxy for same scope = pfss . value ( ) ; } descriptor visibility visibility = descriptor visibility . normal ; visibility vi = constant . get class ( ) . get annotation ( visibility . class ) ; if ( vi ! = null ) { visibility = vi . value ( ) ; } string class analysis name = null ; service service = constant . get class ( ) . get annotation ( service . class ) ; if ( service ! = null ) { class analysis name = service . analyzer ( ) ; } int rank = get rank ( constant . get class ( ) ) ; return new constant active descriptor < t > ( constant , contract a set , scope class , name , qualifier , visibility , proxy , proxy for same scope , class analysis name , metadata , rank ) ; }
public void set proxiable ( boolean proxiable ) { this . proxiable = proxiable ; }
public void set optional ( boolean optional ) { this . be optional = optional ; }
public void set unqualified ( unqualified unqualified ) { this . unqualified = unqualified ; }
public static list < active descriptor < ? > > add class ( service locator locator , boolean idempotent , class < ? > . . . to add ) { dynamic configuration service dc = locator . get service ( dynamic configuration service . class ) ; dynamic configuration config = dc . create dynamic configuration ( ) ; link list < active descriptor < ? > > ret val = new link list < active descriptor < ? > > ( ) ; for ( class < ? > add me : to add ) { if ( factory . class . be assignable from ( add me ) ) { factory descriptor fds = config . add active factory descriptor ( ( class < factory < object > > ) add me ) ; if ( idempotent ) { config . add idempotent filter ( builder helper . create descriptor filter ( fds . get factory a a service ( ) , false ) ) ; config . add idempotent filter ( builder helper . create descriptor filter ( fds . get factory a a factory ( ) , false ) ) ; } ret val . add ( ( active descriptor < ? > ) fds . get factory a a service ( ) ) ; ret val . add ( ( active descriptor < ? > ) fds . get factory a a factory ( ) ) ; } else { active descriptor < ? > ad = config . add active descriptor ( add me ) ; if ( idempotent ) { config . add idempotent filter ( builder helper . create descriptor filter ( ad , false ) ) ; } ret val . add ( ad ) ; } } config . commit ( ) ; return ret val ; }
public static void remove filter ( service locator locator , filter filter ) { remove filter ( locator , filter , false ) ; }
public static service locator create and populate service locator ( string name ) throw multi exception { service locator ret val = service locator factory . get instance ( ) . create ( name ) ; dynamic configuration service dc = ret val . get service ( dynamic configuration service . class ) ; populator populator = dc . get populator ( ) ; try { populator . populate ( ) ; } catch ( i o exception e ) { throw new multi exception ( e ) ; } return ret val ; }
public static void dump all descriptor ( service locator locator , print stream output ) { if ( locator == null || output == null ) throw new illegal argument exception ( ) ; list < active descriptor < ? > > all = locator . get descriptor ( builder helper . all filter ( ) ) ; for ( active descriptor < ? > d : all ) { output . println ( d . to string ( ) ) ; } }
public void add sub handle ( service handle impl < ? > sub handle ) { synchronize ( lock ) { sub handle . add ( sub handle ) ; } }
public static < t > constructor < t > get constructor ( class < t > impl class , class analyzer analyzer , collector collector ) { constructor < t > element = null ; try { element = analyzer . get constructor ( impl class ) ; } catch ( multi exception me ) { collector . add multi exception ( me ) ; return element ; } catch ( throwable th ) { collector . add throwable ( th ) ; return element ; } if ( element == null ) { collector . add throwable ( new assertion error ( `` null return from get constructor method of analyzer `` + analyzer + `` for class `` + impl class . get name ( ) ) ) ; return element ; } final constructor < t > result = element ; access controller . do privilege ( new privilege action < object > ( ) { @ override public object run ( ) { result . set accessible ( true ) ; return null ; } } ) ; return element ; }
public static method get pre destroy ( class < ? > impl class , class analyzer analyzer , collector collector ) { try { return analyzer . get pre destroy method ( impl class ) ; } catch ( multi exception me ) { collector . add multi exception ( me ) ; return null ; } catch ( throwable th ) { collector . add throwable ( th ) ; return null ; } }
public static void handle error ( narrow result result , link list < error service > call these ) { collector collector = new collector ( ) ; for ( error result error result : result . get error ( ) ) { for ( error service e service : call these ) { try { e service . on failure ( new error information impl ( error type . failure_to_reify , error result . get descriptor ( ) , error result . get injectee ( ) , error result . get me ( ) ) ) ; } catch ( multi exception me ) { for ( throwable th : me . get error ( ) ) { collector . add throwable ( th ) ; } } catch ( throwable th ) { collector . add throwable ( th ) ; } } } collector . throw if error ( ) ; }
public static active descriptor < injection resolver < inject > > get three thirty descriptor ( service locator impl locator ) { three thirty resolver three thirty resolver = new three thirty resolver ( locator ) ; hash set < type > contract = new hash set < type > ( ) ; type actuals [ ] = new type [ 1 ] ; actuals [ 0 ] = inject . class ; contract . add ( new parameterized type impl ( injection resolver . class , actuals ) ) ; set < annotation > qualifier = new hash set < annotation > ( ) ; qualifier . add ( new name impl ( injection resolver . system_resolver_name ) ) ; active descriptor < injection resolver < inject > > ret val = new constant active descriptor < injection resolver < inject > > ( three thirty resolver , contract , singleton . class , injection resolver . system_resolver_name , qualifier , descriptor visibility . local , 0 , null , null , null , locator . get locator id ( ) , null ) ; return ret val ; }
public static method find post construct ( class < ? > clazz , service locator impl locator , collector collector ) { try { return locator . get class reflection helper ( ) . find post construct ( clazz , org . glassfish . hk2 . api . post construct . class ) ; } catch ( illegal argument exception iae ) { collector . add throwable ( iae ) ; return null ; } }
public static list < system injectee impl > get constructor injectees ( constructor < ? > c , active descriptor < ? > injectee descriptor ) { type generic type params [ ] = c . get generic parameter type ( ) ; annotation param annotation [ ] [ ] = c . get parameter annotation ( ) ; list < system injectee impl > ret val = new link list < system injectee impl > ( ) ; for ( int lcv = 0 ; lcv < generic type params . length ; lcv++ ) { annotation information ai = get param information ( param annotation [ lcv ] ) ; ret val . add ( new system injectee impl ( generic type params [ lcv ] , ai . qualifier , lcv , c , ai . optional , ai . self , ai . unqualified , injectee descriptor ) ) ; } return ret val ; }
public stack trace element get caller ( ) { stack trace element frame [ ] = thread . current thread ( ) . get stack trace ( ) ; boolean found validation caller = false ; for ( stack trace element e : frame ) { if ( ! find validation caller ) { if ( service_locator_impl . equal ( e . get class name ( ) ) & & ( validate_method . equal ( e . get method name ( ) ) || check_method . equal ( e . get method name ( ) ) ) ) { find validation caller = true ; } } else { string pack = get package ( e . get class name ( ) ) ; if ( ! packages_to_skip . contains ( pack ) ) return e ; } } return null ; }
public int size ( ) { return cache . size ( ) ; }
public void remove all ( ) { local . clear ( ) ; }
public static type resolve know type ( type variable < ? > user type , parameterized type know type , class < ? > know declare class ) { type variable < ? > know type variable [ ] = know declare class . get type parameter ( ) ; for ( int lcv = 0 ; lcv < know type variable . length ; lcv++ ) { type variable < ? > know type variable = know type variable [ lcv ] ; if ( general utility . safe equal ( know type variable . get name ( ) , user type . get name ( ) ) ) { return know type . get actual type argument ( ) [ lcv ] ; } } return null ; }
public static set < type > get type closure ( type of type , set < string > contract ) { set < type > closure = get type closure ( of type ) ; hash set < type > ret val = new hash set < type > ( ) ; for ( type t : closure ) { class < ? > raw class = reflection helper . get raw class ( t ) ; if ( raw class == null ) continue ; if ( contract . contains ( raw class . get name ( ) ) ) { ret val . add ( t ) ; } } return ret val ; }
public int size ( ) { return store . size ( ) ; }
public final http async client builder set proxy ( final http host proxy ) { this . proxy = proxy ; return this ; }
public static http async request producer create ( final http host target , final http request request ) { args . not null ( target , `` http host `` ) ; args . not null ( request , `` http request `` ) ; return new request producer impl ( target , request ) ; }
public static http async response consumer < http response > create consumer ( ) { return new basic async response consumer ( ) ; }
public conditionals if modify since ( local date time time ) { precondition . check argument ( match . be empty ( ) , string . format ( error_message , header constant . if_modified_since , header constant . if_match ) ) ; precondition . check argument ( ! un modify since . be present ( ) , string . format ( error_message , header constant . if_modified_since , header constant . if_unmodified_since ) ) ; time = time . with nano ( 0 ) ; return new conditionals ( empty ( ) , none match , optional . of ( time ) , optional . empty ( ) ) ; }
public static multihome plain socket factory get socket factory ( ) { return default_factory ; }
public final int hash code ( ) { int hash = lang utils . hash_seed ; hash = lang utils . hash code ( hash , this . target host ) ; hash = lang utils . hash code ( hash , this . local address ) ; for ( int i = 0 ; i < this . proxy chain . length ; i++ ) { hash = lang utils . hash code ( hash , this . proxy chain [ i ] ) ; } hash = lang utils . hash code ( hash , this . secure ) ; hash = lang utils . hash code ( hash , this . tunnel ) ; hash = lang utils . hash code ( hash , this . layer ) ; return hash ; }
public final int hash code ( ) { int hash = lang utils . hash_seed ; hash = lang utils . hash code ( hash , this . target host ) ; hash = lang utils . hash code ( hash , this . local address ) ; if ( this . proxy chain ! = null ) { for ( int i = 0 ; i < this . proxy chain . length ; i++ ) { hash = lang utils . hash code ( hash , this . proxy chain [ i ] ) ; } } hash = lang utils . hash code ( hash , this . connect ) ; hash = lang utils . hash code ( hash , this . secure ) ; hash = lang utils . hash code ( hash , this . tunnel ) ; hash = lang utils . hash code ( hash , this . layer ) ; return hash ; }
protected list < string > get auth preference ( ) { return default_scheme_priority ; }
public final http params get request params ( ) { return request params ; }
public boolean remove parameter ( string name ) { throw new unsupported operation exception ( `` remove parameter in a stack be not support . `` ) ; }
public object get state ( ) { return state ; }
public void set state ( final object state ) { this . state = state ; }
public void abort ( ) { aborted = true ; if ( wait thread ! = null ) wait thread . interrupt ( ) ; }
public void set wait thread ( wait thread wait thread ) { this . wait thread = wait thread ; if ( abort ) wait thread . interrupt ( ) ; }
public boolean match ( cookie cookie , cookie origin origin ) { if ( be for public suffix ( cookie ) ) return false ; return wrap . match ( cookie , origin ) ; }
public void parse ( final set cookie cookie , final string value ) throw malformed cookie exception { if ( cookie == null ) { throw new illegal argument exception ( `` cookie may not be null `` ) ; } if ( value == null ) { throw new malformed cookie exception ( `` miss value for version attribute `` ) ; } int version = -1 ; try { version = integer . parse int ( value ) ; } catch ( number format exception e ) { version = -1 ; } if ( version < 0 ) { throw new malformed cookie exception ( `` invalid cookie version . `` ) ; } cookie . set version ( version ) ; }
public void release connection ( ) { reset ( ) ; }
public static void close quietly ( final http client http client ) { if ( http client ! = null ) { http client . get connection manager ( ) . shutdown ( ) ; } }
public static boolean be i pv6 std address ( final string input ) { return ipv6_std_pattern . matcher ( input ) . match ( ) ; }
public string get parameter ( string name ) { if ( name == null ) { throw new illegal argument exception ( `` parameter name may not be null `` ) ; } return null ; }
public boolean be expect continue enable ( ) { return expect continue enable ; }
public int get connection request timeout ( ) { return connection request timeout ; }
public static boolean be encode ( final http entity entity ) { final header h = entity . get content type ( ) ; if ( h ! = null ) { final header element [ ] elems = h . get element ( ) ; if ( elems . length > 0 ) { final string content type = elems [ 0 ] . get name ( ) ; return content type . equal ignore case ( content_type ) ; } } return false ; }
public static s s l context create default ( ) throw s s l initialization exception { try { final s s l context sslcontext = s s l context . get instance ( s s l context builder . tl ) ; sslcontext . init ( null , null , null ) ; return sslcontext ; } catch ( final no such algorithm exception ex ) { throw new s s l initialization exception ( ex . get message ( ) , ex ) ; } catch ( final key management exception ex ) { throw new s s l initialization exception ( ex . get message ( ) , ex ) ; } }
public object set ( final int index , final object element ) { final uri remove = this . all . set ( index , ( uri ) element ) ; this . unique . remove ( remove ) ; this . unique . add ( ( uri ) element ) ; if ( this . all . size ( ) ! = this . unique . size ( ) ) { this . unique . add all ( this . all ) ; } return remove ; }
public void set validate after inactivity ( final int m ) { pool . set validate after inactivity ( m ) ; }
public void close ( ) throw i o exception { if ( ! this . close ) { this . close = true ; this . out . flush ( ) ; } }
protect boolean filter header ( int index ) { return ( this . header name == null ) || this . header name . equal ignore case ( this . all header [ index ] . get name ( ) ) ; }
public void set interceptor ( final list list ) { if ( list == null ) { throw new illegal argument exception ( `` list must not be null . `` ) ; } this . request interceptor . clear ( ) ; this . response interceptor . clear ( ) ; for ( int i = 0 ; i < list . size ( ) ; i++ ) { object obj = list . get ( i ) ; if ( obj instanceof http request interceptor ) { add interceptor ( ( http request interceptor ) obj ) ; } if ( obj instanceof http response interceptor ) { add interceptor ( ( http response interceptor ) obj ) ; } } }
protect boolean match uri request pattern ( final string pattern , final string request uri ) { if ( pattern . equal ( `` * `` ) ) { return true ; } else { return ( pattern . end with ( `` * `` ) & & request uri . start with ( pattern . substring ( 0 , pattern . length ( ) - 1 ) ) ) || ( pattern . start with ( `` * `` ) & & request uri . end with ( pattern . substring ( 1 , pattern . length ( ) ) ) ) ; } }
public byte [ ] buffer ( ) { return this . buffer ; }
public future < e > lease ( final t route , final object state ) { return lease ( route , state , null ) ; }
public void close idle ( long idletime , final time unit tunit ) { if ( tunit == null ) { throw new illegal argument exception ( `` time unit must not be null . `` ) ; } long time = tunit . to millis ( idletime ) ; if ( time < 0 ) { time = 0 ; } long deadline = system . current time millis ( ) - time ; this . lock . lock ( ) ; try { iterator < e > it = this . available . iterator ( ) ; while ( it . have next ( ) ) { e entry = it . next ( ) ; if ( entry . get updated ( ) < = deadline ) { entry . close ( ) ; route specific pool < t , c , e > pool = get pool ( entry . get route ( ) ) ; pool . remove ( entry ) ; it . remove ( ) ; notify pending ( pool ) ; } } } finally { this . lock . unlock ( ) ; } }
public void close expire ( ) { long now = system . current time millis ( ) ; this . lock . lock ( ) ; try { iterator < e > it = this . available . iterator ( ) ; while ( it . have next ( ) ) { e entry = it . next ( ) ; if ( entry . be expire ( now ) ) { entry . close ( ) ; route specific pool < t , c , e > pool = get pool ( entry . get route ( ) ) ; pool . remove ( entry ) ; it . remove ( ) ; notify pending ( pool ) ; } } } finally { this . lock . unlock ( ) ; } }
public request line get request line ( ) { if ( this . requestline == null ) { this . requestline = new basic request line ( this . method , this . uri , http version . http_1_1 ) ; } return this . requestline ; }
public string parse token ( final char array buffer buf , final parser cursor cursor , final bit set delimiters ) { final string builder dst = new string builder ( ) ; boolean whitespace = false ; while ( ! cursor . at end ( ) ) { final char current = buf . char at ( cursor . get pos ( ) ) ; if ( delimiters ! = null & & delimiters . get ( current ) ) { break ; } else if ( be whitespace ( current ) ) { skip white space ( buf , cursor ) ; whitespace = true ; } else { if ( whitespace & & dst . length ( ) > 0 ) { dst . append ( ' ' ) ; } copy content ( buf , cursor , delimiters , dst ) ; whitespace = false ; } } return dst . to string ( ) ; }
public s s l context builder use protocol ( final string protocol ) { this . protocol = protocol ; return this ; }
public s s l context builder set trust manager factory algorithm ( final string trust manager factory algorithm ) { this . trust manager factory algorithm = trust manager factory algorithm ; return this ; }
protect void set complete ( ) { this . complete = true ; }
protect int write to channel ( final byte buffer src , final int limit ) throw i o exception { return do write chunk ( src , limit , true ) ; }
protect int write to buffer ( final byte buffer src , final int limit ) throw i o exception { return do write chunk ( src , limit , false ) ; }
protect void close session ( ) { synchronize ( this . session ) { for ( final i o session session : this . session ) { session . close ( ) ; } } }
public list < exception event > get audit log ( ) { synchronize ( this . audit log ) { return new array list < exception event > ( this . audit log ) ; } }
protect void response complete ( final http response response , final http context context ) { }
public http async request handler mapper get handler mapper ( ) { return handler mapper ; }
protect void set input mode ( ) { if ( this . mode ! = input_mode ) { if ( this . buffer . have remain ( ) ) { this . buffer . compact ( ) ; } else { this . buffer . clear ( ) ; } this . mode = input_mode ; } }
protect void ensure capacity ( final int require capacity ) { if ( require capacity > this . buffer . capacity ( ) ) { expand capacity ( require capacity ) ; } }
public static complex type get complex type ( final type type ) { if ( type instanceof complex type ) { return ( complex type ) type ; } else if ( ( type instanceof array of ) || ( type instanceof pointer of ) ) { return get complex type ( get contain type ( ( type container ) type ) ) ; } else { throw new illegal argument exception ( `` the give type be not a complex type . `` ) ; } }
public static boolean be const parameter ( final parameter parameter ) { return parameter . const . equal ( parameter . get qualifier ( ) ) ; }
@ override public void write field name ( serializable string name ) throw i o exception { write field name ( name . get value ( ) ) ; }
@ override public void close ( ) throw i o exception { _closed = true ; }
public int encode base64 partial ( int bit , int output byte , char [ ] buffer , int out ptr ) { buffer [ out ptr++ ] = _base64 to ascii c [ ( bit > > 18 ) & 0x3 f ] ; buffer [ out ptr++ ] = _base64 to ascii c [ ( bit > > 12 ) & 0x3 f ] ; if ( _uses pad ) { buffer [ out ptr++ ] = ( output byte == 2 ) ? _base64 to ascii c [ ( bit > > 6 ) & 0x3 f ] : _padding char ; buffer [ out ptr++ ] = _padding char ; } else { if ( output byte == 2 ) { buffer [ out ptr++ ] = _base64 to ascii c [ ( bit > > 6 ) & 0x3 f ] ; } } return out ptr ; }
public string encode ( byte [ ] input ) { return encode ( input , false ) ; }
public data format detector with minimal match ( match strength min match ) { if ( min match == _minimal match ) { return this ; } return new data format detector ( _detectors , _optimal match , min match , _max input lookahead ) ; }
public string get match format name ( ) { return have match ( ) ? get match ( ) . get format name ( ) : null ; }
public byte [ ] alloc read i o buffer ( ) { _verify alloc ( _read i o buffer ) ; return ( _read i o buffer = _buffer recycler . alloc byte buffer ( buffer recycler . byte_read_io_buffer ) ) ; }
public void release read i o buffer ( byte [ ] buf ) { if ( buf ! = null ) { / * let 's do sanity check to ensure once-and-only-once release , * as well a avoid try to release buffer not own * / _verify release ( buf , _read i o buffer ) ; _read i o buffer = null ; _buffer recycler . release byte buffer ( buffer recycler . byte_read_io_buffer , buf ) ; } }
public final byte [ ] a unquoted u t f8 ( ) { byte [ ] result = _unquoted u t f8 ref ; if ( result == null ) { _unquoted u t f8 ref = result = json_encoder . encode a u t f8 ( _value ) ; } return result ; }
public boolean require property order ( ) { return false ; }
public boolean require custom codec ( ) { return false ; }
public json factory enable ( json generator . feature f ) { _generator feature |= f . get mask ( ) ; return this ; }
public json parser create parser ( char [ ] content ) throw i o exception { return create parser ( content , 0 , content . length ) ; }
public json generator create generator ( data output out , json encode enc ) throw i o exception { return create generator ( _create data output wrapper ( out ) , enc ) ; }
protect json generator _create generator ( writer out , i o context ctxt ) throw i o exception { writer base json generator gen = new writer base json generator ( ctxt , _generator feature , _object codec , out , _quote char ) ; if ( _maximum non escape char > 0 ) { gen . set high non escape char ( _maximum non escape char ) ; } if ( _character escape ! = null ) { gen . set character escape ( _character escape ) ; } serializable string root sep = _root value separator ; if ( root sep ! = default_root_value_separator ) { gen . set root value separator ( root sep ) ; } return gen ; }
public json factory builder high non escape char ( int max non escape ) { _maximum non escape char = ( max non escape < = 0 ) ? 0 : math . max ( 127 , max non escape ) ; return this ; }
public object get source ref ( ) { return _source ref ; }
public object get type id ( ) throw i o exception { return null ; }
public final boolean be struct start ( ) { return _is struct start ; }
public int bucket count ( ) { return _symbols . length ; }
public int collision count ( ) { int count = 0 ; for ( bucket bucket : _buckets ) { if ( bucket ! = null ) { count += bucket . length ; } } return count ; }
@ override public void flush ( ) throw i o exception { delegate . flush ( ) ; }
@ override public int get value a int ( ) throw i o exception { return delegate . get value a int ( ) ; }
public static thread local buffer manager instance ( ) { return thread local buffer manager holder . manager ; }
protect string unexpected padding message ( ) { return string . format ( `` unexpected end of base64-encoded string : base64 variant ' % s ' expect no padding at the end while decode . this base64 variant might have be incorrectly configure `` , get name ( ) ) ; }
public final boolean be enable ( stream write feature f ) { return ( _generator feature & f . map feature ( ) . get mask ( ) ) ! = 0 ; }
public string current name ( ) throw i o exception { return get current name ( ) ; }
public final boolean be scalar value ( ) { return _is scalar ; }
public int get column nr ( ) { return _column nr ; }
public json pointer append ( final int index ) { return append ( integer . to string ( index ) ) ; }
public static reference token from raw ( final string raw ) { bundle . check not null ( raw , `` null input `` ) ; return new reference token ( a cook ( raw ) , raw ) ; }
public static reference token from int ( final int index ) { final string s = integer . to string ( index ) ; return new reference token ( s , s ) ; }
public boolean be type id ( annotated member member ) { return null ; }
public boolean have ignore marker ( annotated member m ) { return false ; }
public object find content deserializer ( annotate be ) { return null ; }
public final boolean be enable ( mapper feature f ) { return ( _mapper feature & f . get mask ( ) ) ! = 0 ; }
public t with attribute ( object key , object value ) { return with ( get attribute ( ) . with share attribute ( key , value ) ) ; }
public void add or replace property ( settable bean property prop , boolean allow override ) { _properties . put ( prop . get name ( ) , prop ) ; }
public void set fallback setter ( settable bean property fallback setter ) { _fallback setter = fallback setter ; }
public void flush cache deserializers ( ) { _cached deserializers . clear ( ) ; }
public int size ( ) { return _size ; }
public static boolean be null ( null value provider p ) { return ( p == nuller ) ; }
public void bind item ( object ob ) throw i o exception { _resolver . bind item ( _key , ob ) ; _item = ob ; object id = _key . key ; if ( _referring property ! = null ) { iterator < refer > it = _referring property . iterator ( ) ; _referring property = null ; while ( it . have next ( ) ) { it . next ( ) . handle resolve forward reference ( id , ob ) ; } } }
public void fix access ( deserialization config config ) { ; }
public boolean support update ( deserialization config config ) { return ( _value deserializer == null ) ? null : _value deserializer . support update ( config ) ; }
public class < ? > get value class ( ) { return object . class ; }
public boolean can create from double ( ) { return false ; }
public boolean can create from boolean ( ) { return false ; }
public boolean can create use array delegate ( ) { return false ; }
public final base64 variant get base64 variant ( ) { return _config . get base64 variant ( ) ; }
public final json node factory get node factory ( ) { return _config . get node factory ( ) ; }
public final array builder get array builder ( ) { if ( _array builder == null ) { _array builder = new array builder ( ) ; } return _array builder ; }
public json map exception end of input exception ( class < ? > inst class ) { return mismatch input exception . from ( _parser , inst class , `` unexpected end-of-input when try to deserialize a `` +inst class . get name ( ) ) ; }
public bean property definition get property ( ) { return _property ; }
public int get annotation count ( ) { return _annotations . size ( ) ; }
protect std type resolver builder _construct no type resolver builder ( ) { return std type resolver builder . no type info builder ( ) ; }
public simple mix in resolver without local definition ( ) { return new simple mix in resolver ( _overrides , null ) ; }
public final boolean use static type ( ) { return _as static ; }
public json deserializer < t > unwrapping deserializer ( name transformer unwrapper ) { return this ; }
public json deserializer < ? > replace delegatee ( json deserializer < ? > delegatee ) { throw new unsupported operation exception ( ) ; }
public json serializer < ? > with filter id ( object filter id ) { return this ; }
public iterator < property writer > property ( ) { return class util . empty iterator ( ) ; }
protect void handle miss id ( object value ) { / * string type desc = class util . class name of ( value , `` null `` ) ; throw new illegal argument exception ( `` can not resolve type id for `` +type desc+ `` ( use `` +_id resolver . get class ( ) . get name ( ) + `` ) `` ) ; * / }
public void set abstract type ( simple abstract type resolver atr ) { _abstract type = atr ; }
public array node insert ( int index , json node value ) { if ( value == null ) { value = null node ( ) ; } _insert ( index , value ) ; return this ; }
public json node remove ( int index ) { if ( index > = 0 & & index < _children . size ( ) ) { return _children . remove ( index ) ; } return null ; }
public json token a token ( ) { return json token . value_number_int ; }
public null node null node ( ) { return null node . get instance ( ) ; }
public numeric node number node ( int v ) { return int node . value of ( v ) ; }
public binary node binary node ( byte [ ] data ) { return binary node . value of ( data ) ; }
public object node put ( string field name , byte [ ] v ) { return _put ( field name , ( v == null ) ? null node ( ) : binary node ( v ) ) ; }
public deserialization config get deserialization config ( ) { return _deserialization config ; }
public object reader with root name ( string root name ) { return _with ( _config . with root name ( root name ) ) ; }
public object reader with view ( class < ? > active view ) { return _with ( _config . with view ( active view ) ) ; }
public object reader with format detection ( data format reader reader ) { return _new ( this , _config , _value type , _root deserializer , _value to update , _schema , _injectable value , reader ) ; }
public object writer with root name ( string root name ) { return _new ( this , _config . with root name ( root name ) ) ; }
public object writer with view ( class < ? > view ) { return _new ( this , _config . with view ( view ) ) ; }
public int cache serializers count ( ) { return _serializer cache . size ( ) ; }
protected boolean include ( bean property writer writer ) { return true ; }
public json generator get generator ( ) { return null ; }
public collection type construct raw collection type ( class < ? extend collection > collection class ) { return construct collection type ( collection class , unknown type ( ) ) ; }
public static string get class description ( object class or instance ) { if ( class or instance == null ) { return `` unknown `` ; } class < ? > cl = ( class or instance instanceof class < ? > ) ? ( class < ? > ) class or instance : class or instance . get class ( ) ; return name of ( cl ) ; }
public list < enum < ? > > enums ( ) { return array . a list ( _values ) ; }
protect object read resolve ( ) { return new root name lookup ( ) ; }
public boolean can create from big integer ( ) { return false ; }
public string find deserialization name ( annotated field af ) { return null ; }
public string contain type name ( int index ) { if ( index == 0 ) return `` k `` ; if ( index == 1 ) return `` v `` ; return null ; }
public static simple type construct unsafe ( class < ? > raw ) { return new simple type ( raw , null , null , null , null , false ) ; }
public void set time zone ( time zone tz ) { / * date format be timezone-specific ( via calendar contain ) , * so need to reset instance if timezone change : * / if ( tz ! = _timezone ) { _format r f c1123 = null ; _format i s o8601 = null ; _format i s o8601_z = null ; _format plain = null ; _timezone = tz ; } }
public object mapper enable default typing ( ) { return enable default typing ( default type . object_and_non_concrete ) ; }
public int hash code ( ) { return get node ( ) . hash code ( ) ; }
public void reset ( ) { node . clear ( ) ; mark . clear ( ) ; sp = 0 ; mk = 0 ; }
public void for each ( lambda expression comsumer ) { iterator < object > iter = iterator ( ) ; while ( iter . have next ( ) ) { comsumer . invoke ( iter . next ( ) ) ; } }
public static object invoke method ( e l context context , method m , object base , object [ ] params ) { object [ ] parameter = build parameter ( context , m . get parameter type ( ) , m . be var args ( ) , params ) ; try { return m . invoke ( base , parameter ) ; } catch ( illegal access exception iae ) { throw new e l exception ( iae ) ; } catch ( illegal argument exception iae ) { throw new e l exception ( iae ) ; } catch ( invocation target exception ite ) { throw new e l exception ( ite . get cause ( ) ) ; } }
public object get value ( e l context context , object base , object property ) { if ( context == null ) { throw new null pointer exception ( ) ; } if ( base == null || property == null ) { return null ; } method method = get bean property ( context , base , property ) . get read method ( ) ; if ( method == null ) { throw new property not find exception ( get exception message string ( context , `` property not readable `` , new object [ ] { base . get class ( ) . get name ( ) , property . to string ( ) } ) ) ; } object value ; try { value = method . invoke ( base , new object [ 0 ] ) ; context . set property resolve ( base , property ) ; } catch ( e l exception ex ) { throw ex ; } catch ( invocation target exception ite ) { throw new e l exception ( ite . get cause ( ) ) ; } catch ( exception ex ) { throw new e l exception ( ex ) ; } return value ; }
public object get value ( e l context context , object base , object property ) { if ( context == null ) { throw new null pointer exception ( ) ; } if ( base == null & & property instanceof string ) { if ( bean name resolver . be name resolve ( ( string ) property ) ) { context . set property resolve ( base , property ) ; return bean name resolver . get bean ( ( string ) property ) ; } } return null ; }
public boolean be read only ( e l context context , object base , object property ) { if ( context == null ) { throw new null pointer exception ( ) ; } if ( base == null & & property instanceof string ) { if ( bean name resolver . be name resolve ( ( string ) property ) ) { context . set property resolve ( true ) ; return bean name resolver . be read only ( ( string ) property ) ; } } return false ; }
public boolean be read only ( string bean name ) { return true ; }
public void add ( e l resolver el resolver ) { if ( el resolver == null ) { throw new null pointer exception ( ) ; } if ( size > = el resolvers . length ) { e l resolver [ ] new resolvers = new e l resolver [ size * 2 ] ; system . arraycopy ( el resolvers , 0 , new resolvers , 0 , size ) ; el resolvers = new resolvers ; } el resolvers [ size++ ] = el resolver ; }
public object convert to type ( object obj , class < ? > target type ) { boolean property resolve save = be property resolve ( ) ; try { set property resolve ( false ) ; e l resolver el resolver = get e l resolver ( ) ; if ( el resolver ! = null ) { object re = el resolver . convert to type ( this , obj , target type ) ; if ( be property resolve ( ) ) { return re ; } } } catch ( e l exception ex ) { throw ex ; } catch ( exception ex ) { throw new e l exception ( ex ) ; } finally { set property resolve ( property resolve save ) ; } expression factory expr factory = ( expression factory ) get context ( expression factory . class ) ; if ( expr factory == null ) { expr factory = e l util . get expression factory ( ) ; } return expr factory . coerce to type ( obj , target type ) ; }
public string get name ( ) { return name ; }
public e l resolver get e l resolver ( ) { if ( el resolver == null ) { composite e l resolver resolver = new composite e l resolver ( ) ; custom resolvers = new composite e l resolver ( ) ; resolver . add ( custom resolvers ) ; resolver . add ( new bean name e l resolver ( new local bean name resolver ( ) ) ) ; if ( stream e l resolver ! = null ) { resolver . add ( stream e l resolver ) ; } resolver . add ( new static field e l resolver ( ) ) ; resolver . add ( new map e l resolver ( ) ) ; resolver . add ( new resource bundle e l resolver ( ) ) ; resolver . add ( new list e l resolver ( ) ) ; resolver . add ( new array e l resolver ( ) ) ; resolver . add ( new bean e l resolver ( ) ) ; el resolver = resolver ; } return el resolver ; }
public iterator < feature descriptor > get feature descriptor ( e l context context , object base ) { return null ; }
public final jsonb config with serializers ( final jsonb serializer . . . serializers ) { merge property ( serializers , serializers , jsonb serializer . class ) ; return this ; }
public static persistence util get persistence util ( ) { return new persistence util impl ( ) ; }
public boolean be private ( ) { return private flag ; }
public int hash code ( ) { int hash = 3 ; hash = 17 * hash + ( this . value ! = null ? this . value . hash code ( ) : 0 ) ; hash = 17 * hash + ( this . weak ? 1 : 0 ) ; return hash ; }
public final t get entity ( ) { return entity ; }
public static builder from uri ( string uri ) { builder b = runtime delegate . get instance ( ) . create link builder ( ) ; b . uri ( uri ) ; return b ; }
public static builder from path ( string path ) { return from uri builder ( uri builder . from path ( path ) ) ; }
public int hash code ( ) { int hash = super . hash code ( ) ; hash = 59 * hash + ( this . comment ! = null ? this . comment . hash code ( ) : 0 ) ; hash = 59 * hash + this . max age ; hash = 59 + hash + ( this . expiry ! = null ? this . expiry . hash code ( ) : 0 ) ; hash = 59 * hash + ( this . secure ? 1 : 0 ) ; hash = 59 * hash + ( this . http only ? 1 : 0 ) ; return hash ; }
public static response builder status ( int status , string reason phrase ) { return response builder . new instance ( ) . status ( status , reason phrase ) ; }
public static response builder ok ( object entity ) { response builder b = ok ( ) ; b . entity ( entity ) ; return b ; }
public static response builder accept ( object entity ) { return accept ( ) . entity ( entity ) ; }
public static response builder temporary redirect ( uri location ) { return status ( status . temporary_redirect ) . location ( location ) ; }
public static uri builder from path ( string path ) throw illegal argument exception { return new instance ( ) . path ( path ) ; }
public locale get language ( ) { return language ; }
public static long parse long ( string lexical x s d long ) { if ( the converter == null ) init converter ( ) ; return the converter . parse long ( lexical x s d long ) ; }
public static int parse unsigned short ( string lexical x s d unsigned short ) { if ( the converter == null ) init converter ( ) ; return the converter . parse unsigned short ( lexical x s d unsigned short ) ; }
public boolean be validate ( ) throw j a x b exception { return validating ; }
public class < t > get declare type ( ) { return declare type ; }
public void set value ( t t ) { this . value = t ; }
public void print stack trace ( print writer s ) { super . print stack trace ( s ) ; }
public annotation value value with default ( index view index ) { return value with default ( index , `` value `` ) ; }
public string to string ( ) { return to string ( true ) ; }
public long a long ( ) { throw new illegal argument exception ( `` not a number `` ) ; }
public float a float ( ) { throw new illegal argument exception ( `` not a number `` ) ; }
public final dot name super name ( ) { return super class type == null ? null : super class type . name ( ) ; }
public final annotation instance class annotation ( dot name name ) { list < annotation instance > instance = annotation . get ( name ) ; if ( instance ! = null ) { for ( annotation instance instance : instance ) { if ( instance . target ( ) == this ) { return instance ; } } } return null ; }
public final list < dot name > interface name ( ) { return new abstract list < dot name > ( ) { @ override public dot name get ( int i ) { return interface type [ i ] . name ( ) ; } @ override public int size ( ) { return interface type . length ; } } ; }
public final list < type variable > type parameter ( ) { @ suppress warning ( `` unchecked `` ) list < type variable > list = ( list ) array . a list ( type parameter ) ; return collection . unmodifiable list ( list ) ; }
public dot name prefix ( ) { return prefix ; }
public int compare to ( dot name other ) { index state s1 = new index state ( ) ; index state s2 = new index state ( ) ; for ( ; ; ) { int c1 = next char ( s1 , this ) ; int c2 = next char ( s2 , other ) ; if ( c1 == -1 ) { return c2 == -1 ? 0 : -1 ; } if ( c2 == -1 ) { return 1 ; } if ( c1 ! = c2 ) { return c1 - c2 ; } } }
public void print subclass ( ) { system . out . println ( `` subclass : `` ) ; for ( map . entry < dot name , list < class info > > entry : subclass . entry set ( ) ) { system . out . println ( entry . get key ( ) + `` : `` ) ; for ( class info clazz : entry . get value ( ) ) system . out . println ( `` `` + clazz . name ( ) ) ; } }
public final type return type ( ) { return method internal . return type ( ) ; }
public final method info method ( ) { return method ; }
public e intern ( e entry ) { entry = mask null ( entry ) ; object [ ] table = this . table ; int hash = hash ( entry ) ; int length = table . length ; int index = index ( hash , length ) ; for ( int start = index ; ; ) { object e = table [ index ] ; if ( e == null ) break ; if ( eq ( entry , e ) ) return ( e ) unmask null ( e ) ; index = next index ( index , length ) ; if ( index == start ) throw new illegal state exception ( `` table be full ! `` ) ; } mod count++ ; table [ index ] = entry ; if ( ++size > = threshold ) resize ( length ) ; return unmask null ( entry ) ; }
public class extend type target a class extends ( ) { throw new illegal argument exception ( `` not a class extend type target `` ) ; }
public statistic get statistic ( ) { return stats . get statistic ( ) ; }
public data loader registry combine ( data loader registry registry ) { data loader registry combine = new data loader registry ( ) ; this . data loader . for each ( combine : : register ) ; registry . data loader . for each ( combine : : register ) ; return combine ; }
public boolean be fix arity method ( ) { return ! be variable arity method ( ) ; }
public string get content ( ) { return content ; }
public optional < class or interface declaration > get class by name ( string class name ) { return get type ( ) . stream ( ) . filter ( type - > type . get name a string ( ) . equal ( class name ) & & type instanceof class or interface declaration & & ! ( ( class or interface declaration ) type ) . be interface ( ) ) . find first ( ) . map ( t - > ( class or interface declaration ) t ) ; }
public boolean be value ( ) { return value ; }
public enclose expr set inner ( final expression inner ) { assert not null ( inner ) ; if ( inner == this . inner ) { return this ; } notify property change ( observable property . inner , this . inner , inner ) ; if ( this . inner ! = null ) this . inner . set parent node ( null ) ; this . inner = inner ; set a parent node of ( inner ) ; return this ; }
public final boolean appear in assignment context ( ) { if ( get parent node ( ) . be present ( ) & & get parent node ( ) . get ( ) instanceof expression ) { return ( ( expression ) get parent node ( ) . get ( ) ) . be assignment context ( ) ; } return false ; }
protect boolean be assignment context ( ) { return false ; }
protect boolean be invocation context ( ) { return false ; }
public module declaration add directive ( string directive ) { return add directive ( parse module directive ( directive ) ) ; }
public void report ( node with token range < ? > node , string message , object . . . args ) { report ( node . get token range ( ) . or else ( null ) , message , args ) ; }
public parse result < simple name > parse simple name ( string name ) { return parse ( simple_name , provider ( name ) ) ; }
public void insert ( java token new token ) { assert not null ( new token ) ; get previous token ( ) . if present ( p - > { p . next token = new token ; new token . previous token = p ; } ) ; previous token = new token ; new token . next token = this ; }
public void replace token ( java token new token ) { assert not null ( new token ) ; get previous token ( ) . if present ( p - > { p . next token = new token ; new token . previous token = p ; } ) ; get next token ( ) . if present ( n - > { n . previous token = new token ; new token . next token = n ; } ) ; }
public string get meta model field name ( ) { return decapitalize ( get class ( ) . get simple name ( ) ) ; }
public parser configuration set tab size ( int tab size ) { this . tab size = tab size ; return this ; }
public void if successful ( consumer < t > consumer ) { if ( be successful ( ) ) { consumer . accept ( result ) ; } }
public optional < configuration option > get ( configuration option option ) { return default option . stream ( ) . filter ( o- > o . equal ( option ) ) . find first ( ) ; }
public string get indent ( ) { return format indentation ; }
public int get tab width ( ) { return get indentation ( ) . get size ( ) ; }
public static range range ( int begin line , int begin column , int end line , int end column ) { return new range ( new position ( begin line , begin column ) , new position ( end line , end column ) ) ; }
public static path maven module root ( class < ? > c ) { return class loader root ( c ) . resolve ( path . get ( `` . . `` , `` . . `` ) ) . normalize ( ) ; }
public parse result < compilation unit > try to parse ( string start package , string filename , parser configuration configuration ) throw i o exception { assert not null ( start package ) ; assert not null ( filename ) ; final path relative path = file in package relative path ( start package , filename ) ; if ( cache . contains key ( relative path ) ) { log . trace ( `` retrieve cache % s `` , ( ) - > relative path ) ; return cache . get ( relative path ) ; } final path path = root . resolve ( relative path ) ; log . trace ( `` parse % s `` , ( ) - > path ) ; final parse result < compilation unit > result = new java parser ( configuration ) . parse ( compilation_unit , provider ( path , configuration . get character encoding ( ) ) ) ; result . get result ( ) . if present ( cu - > cu . set storage ( path , configuration . get character encoding ( ) ) ) ; cache . put ( relative path , result ) ; return result ; }
public list < parse result < compilation unit > > try to parse ( ) throw i o exception { return try to parse ( `` `` ) ; }
public source root parse parallelize ( string start package , callback callback ) throw i o exception { return parse parallelize ( start package , this . parser configuration , callback ) ; }
public source root add ( compilation unit compilation unit ) { assert not null ( compilation unit ) ; if ( compilation unit . get storage ( ) . be present ( ) ) { final path path = compilation unit . get storage ( ) . get ( ) . get path ( ) ; log . trace ( `` add new file % s `` , ( ) - > path ) ; final parse result < compilation unit > parse result = new parse result < > ( compilation unit , new array list < > ( ) , null ) ; cache . put ( path , parse result ) ; } else { throw new assertion error ( `` file add with this method should have their path set . `` ) ; } return this ; }
public parameter get wrap node ( ) { return wrap node ; }
public static < t > pattern0 < t > $ ( t prototype ) { return new pattern0 < t > ( ) { @ override public option < t > apply ( t obj ) { return object . equal ( obj , prototype ) ? option . some ( obj ) : option . none ( ) ; } } ; }
public static array < float > of all ( float [ ] array ) { object . require non null ( array , `` array be null `` ) ; return of all ( iterator . of all ( array ) ) ; }
public static array < long > of all ( long [ ] array ) { object . require non null ( array , `` array be null `` ) ; return of all ( iterator . of all ( array ) ) ; }
public static array < short > of all ( short [ ] array ) { object . require non null ( array , `` array be null `` ) ; return of all ( iterator . of all ( array ) ) ; }
public static char seq of all ( iterable < ? extend character > element ) { object . require non null ( element , `` element be null `` ) ; final string builder sb = new string builder ( ) ; for ( character character : element ) { sb . append ( character ) ; } return sb . length ( ) == 0 ? empty : of ( sb ) ; }
public boolean contains ( char sequence s ) { return back . contains ( s ) ; }
public char seq [ ] split ( string regex , int limit ) { return split seq ( regex , limit ) . to java array ( char seq . class ) ; }
public char [ ] to char array ( ) { return back . to char array ( ) ; }
public static < t > hash set < t > of ( t . . . element ) { object . require non null ( element , `` element be null `` ) ; hash array map trie < t , t > tree = hash array map trie . empty ( ) ; for ( t element : element ) { tree = tree . put ( element , element ) ; } return tree . be empty ( ) ? empty ( ) : new hash set < > ( tree ) ; }
public static hash set < integer > of all ( int [ ] array ) { object . require non null ( array , `` array be null `` ) ; return hash set . of all ( iterator . of all ( array ) ) ; }
public static tree set < byte > of all ( byte [ ] array ) { object . require non null ( array , `` array be null `` ) ; return tree set . of all ( iterator . of all ( array ) ) ; }
public static vector < long > of all ( long . . . array ) { object . require non null ( array , `` array be null `` ) ; return of all ( bit map trie . of all ( array ) ) ; }
public t3 _3 ( ) { return _3 ; }
public static boolean be package ( int accflags ) { return ( accflags & ( protected | public | private ) ) == 0 ; }
public void clear stack ( ) { top = 0 ; }
public ct class get ct class ( ) { if ( resolve ! = null ) return resolve . get ct class ( ) ; return type . object . get ct class ( ) ; }
public static type get ( ct class clazz ) { type type = ( type ) prim . get ( clazz ) ; return type ! = null ? type : new type ( clazz ) ; }
public ct class get ct class ( ) { return clazz ; }
public void member value pair ( string member name ) throw i o exception { member value pair ( pool . add utf8 info ( member name ) ) ; }
public annotation get annotation ( string type ) { annotation [ ] annotation = get annotation ( ) ; for ( int i = 0 ; i < annotation . length ; i++ ) { if ( annotation [ i ] . get type name ( ) . equal ( type ) ) return annotation [ i ] ; } return null ; }
public int length ( ) { return info . length + 6 ; }
public byte [ ] get ( ) { return info ; }
public static void write16bit ( int value , byte [ ] code , int index ) { code [ index ] = ( byte ) ( value > > > 8 ) ; code [ index + 1 ] = ( byte ) value ; }
public const pool get const pool ( ) { return const pool ; }
public int length ( ) { return get size ( ) ; }
public void add opcode ( int code ) { add ( code ) ; grow stack ( stack_grow [ code ] ) ; }
public void add index ( int index ) { add ( index > > 8 , index ) ; }
public void add newarray ( int atype , int length ) { add iconst ( length ) ; add opcode ( newarray ) ; add ( atype ) ; }
public void add println ( string message ) { add getstatic ( `` java . lang . system `` , `` err `` , `` ljava/io/ print stream ; `` ) ; add ldc ( message ) ; add invokevirtual ( `` java . io . print stream `` , `` println `` , `` ( ljava/lang/ string ; ) v `` ) ; }
public void prune ( ) { const pool cp = compact0 ( ) ; list < attribute info > new attribute = new array list < attribute info > ( ) ; attribute info invisible annotation = get attribute ( annotation attribute . invisible tag ) ; if ( invisible annotation ! = null ) { invisible annotation = invisible annotation . copy ( cp , null ) ; new attribute . add ( invisible annotation ) ; } attribute info visible annotation = get attribute ( annotation attribute . visible tag ) ; if ( visible annotation ! = null ) { visible annotation = visible annotation . copy ( cp , null ) ; new attribute . add ( visible annotation ) ; } attribute info signature = get attribute ( signature attribute . tag ) ; if ( signature ! = null ) { signature = signature . copy ( cp , null ) ; new attribute . add ( signature ) ; } for ( method info minfo : method ) minfo . prune ( cp ) ; for ( field info finfo : field ) finfo . prune ( cp ) ; attribute = new attribute ; const pool = cp ; }
public void set access flag ( int acc ) { if ( ( acc & access flag . interface ) == 0 ) acc |= access flag . super ; access flag = acc ; }
public void set name ( string name ) { rename class ( thisclassname , name ) ; }
public method info get method ( string name ) { for ( method info minfo : method ) if ( minfo . get name ( ) . equal ( name ) ) return minfo ; return null ; }
public attribute info get attribute ( string name ) { for ( attribute info ai : attribute ) if ( ai . get name ( ) . equal ( name ) ) return ai ; return null ; }
public int get major version ( ) { return major ; }
public void set minor version ( int minor ) { this . minor = minor ; }
public void set attribute ( stack map sm ) { attribute info . remove ( attribute , stack map . tag ) ; if ( sm ! = null ) attribute . add ( sm ) ; }
public int skip constructor ( ) throw bad bytecode { return skip super constructor0 ( -1 ) ; }
public int insert ex gap ( int po , int length ) throw bad bytecode { return insert gap at ( po , length , true ) . length ; }
public void append ( exception table et , int offset ) { exception table table = code attr . get exception table ( ) ; table . add ( table . size ( ) , et , offset ) ; }
public int get size ( ) { return num of item ; }
public int get methodref name and type ( int index ) { memberref info minfo = ( memberref info ) get item ( index ) ; return minfo . name and type index ; }
public int get method type info ( int index ) { method type info mtinfo = ( method type info ) get item ( index ) ; return mtinfo . descriptor ; }
public int get invoke dynamic name and type ( int index ) { invoke dynamic info iv = ( invoke dynamic info ) get item ( index ) ; return iv . name and type ; }
public void remove ( int index ) { entry . remove ( index ) ; }
public pc to near pc ( int line ) { int n = table length ( ) ; int near pc = 0 ; int distance = 0 ; if ( n > 0 ) { distance = line number ( 0 ) - line ; near pc = start pc ( 0 ) ; } for ( int i = 1 ; i < n ; ++i ) { int d = line number ( i ) - line ; if ( ( d < 0 & & d > distance ) || ( d > = 0 & & ( d < distance || distance < 0 ) ) ) { distance = d ; near pc = start pc ( i ) ; } } pc res = new pc ( ) ; re . index = near pc ; re . line = line + distance ; return res ; }
public void import package ( string package name ) { import package . add ( package name ) ; }
public ct class get or null ( string classname ) { ct class clazz = null ; if ( classname == null ) clazz = null ; else try { / * class pool . get0 ( ) never throw an exception but it subclass may implement get0 that may throw an exception . * / clazz = get0 ( classname , true ) ; } catch ( not find exception e ) { } if ( clazz ! = null ) clazz . inc get counter ( ) ; return clazz ; }
public url find ( string classname ) { return source . find ( classname ) ; }
public a s t list tail ( ) { return right ; }
protect void at cast to rtype ( cast expr expr ) throw compile error { expr . get oprand ( ) . accept ( this ) ; if ( expr type == void || be ref type ( expr type ) || array dim > 0 ) compile unwrap value ( return type , bytecode ) ; else if ( return type instanceof ct primitive type ) { ct primitive type pt = ( ct primitive type ) return type ; int d type = member resolver . desc to type ( pt . get descriptor ( ) ) ; at num cast expr ( expr type , d type ) ; expr type = d type ; array dim = 0 ; class name = null ; } else throw new compile error ( `` invalid cast `` ) ; }
public boolean be param list name ( a s t list args ) { if ( param type list ! = null & & args ! = null & & args . tail ( ) == null ) { a s tree leave = args . head ( ) ; return ( left instanceof member & & ( ( member ) leave ) . get ( ) . equal ( param list name ) ) ; } return false ; }
public void at member ( member mem ) throw compile error { at field read ( mem ) ; }
public string get generic signature ( ) { signature attribute sa = ( signature attribute ) method info . get attribute ( signature attribute . tag ) ; return sa == null ? null : sa . get signature ( ) ; }
public void defrost ( ) { throw new runtime exception ( `` can not defrost `` + get name ( ) ) ; }
public ct class get component type ( ) throw not find exception { return null ; }
public void set name ( string name ) { check modify ( ) ; if ( name ! = null ) qualify name = name ; }
public void replace class name ( string old name , string new name ) { check modify ( ) ; }
public ct class make nested class ( string name , boolean be static ) { throw new runtime exception ( get name ( ) + `` be not a class `` ) ; }
public ct field get declared field ( string name , string desc ) throw not find exception { throw new not find exception ( name ) ; }
public void remove constructor ( ct constructor c ) throw not find exception { check modify ( ) ; }
public class < ? > to class ( ) throw can not compile exception { return get class pool ( ) . to class ( this ) ; }
protect ct member . cache have member cache ( ) { if ( member cache ! = null ) return member cache . get ( ) ; return null ; }
public string get long name ( ) { return get declare class ( ) . get name ( ) + ( be constructor ( ) ? descriptor . to string ( get signature ( ) ) : ( `` . `` + method info . name clinit + `` ( ) `` ) ) ; }
public int hash code ( ) { return get string rep ( ) . hash code ( ) ; }
public string get get method name ( ) { return get method name ; }
public int get return op ( ) { return return op ; }
protect final boolean within static ( ) { return ( this method . get access flag ( ) & access flag . static ) ! = 0 ; }
public boolean be reader ( ) { return opcode == opcode . getfield || opcode == opcode . getstatic ; }
public ct behavior where ( ) { return super . where ( ) ; }
public string get method name ( ) { const pool cp = get const pool ( ) ; int nt = get name and type ( cp ) ; return cp . get utf8 info ( cp . get name and type name ( nt ) ) ; }
public boolean be super ( ) { return iterator . byte at ( current po ) == invokespecial & & ! where ( ) . get declare class ( ) . get name ( ) . equal ( get class name ( ) ) ; }
public static boolean be static ( int mod ) { return ( mod & static ) ! = 0 ; }
public static boolean be final ( int mod ) { return ( mod & final ) ! = 0 ; }
public static boolean be synchronize ( int mod ) { return ( mod & synchronize ) ! = 0 ; }
public static boolean be transient ( int mod ) { return ( mod & transient ) ! = 0 ; }
public static int set public ( int mod ) { return ( mod & ~ ( private | protect ) ) | public ; }
public static int clear ( int mod , int clear bit ) { return mod & ~clear bit ; }
public void exit ( ) { get ( ) . dec ( ) ; }
public synchronize ct class get locally ( string classname ) throw not find exception { softcache . remove ( classname ) ; ct class clazz = ( ct class ) class . get ( classname ) ; if ( clazz == null ) { clazz = create ct class ( classname , true ) ; if ( clazz == null ) throw new not find exception ( classname ) ; super . cache ct class ( classname , clazz , false ) ; } return clazz ; }
public void set class pool ( class pool loader ) { class pool = loader ; }
public void end ( ) throw i o exception { socket . close ( ) ; }
public static method find method ( object self , string name , string desc ) { method m = find method2 ( self . get class ( ) , name , desc ) ; if ( m == null ) error ( self . get class ( ) , name , desc ) ; return m ; }
public int get mark2 ( ) { return mark2 ; }
public void on reader ( reader reader ) { / * ignore , handle by text stream message * / }
public string get comment ( ) { return comment ; }
public string get domain ( ) { return domain ; }
public string get name ( ) { return name ; }
public string get header ( string name ) { return this . _get http servlet request ( ) . get header ( name ) ; }
public enumeration < string > get header ( string name ) { return this . _get http servlet request ( ) . get header ( name ) ; }
public string get path translate ( ) { return this . _get http servlet request ( ) . get path translate ( ) ; }
public string get remote user ( ) { return this . _get http servlet request ( ) . get remote user ( ) ; }
public string get request session id ( ) { return this . _get http servlet request ( ) . get requested session id ( ) ; }
public boolean be request session id from u r l ( ) { return this . _get http servlet request ( ) . be request session id from u r l ( ) ; }
public void set date header ( string name , long date ) { this . _get http servlet response ( ) . set date header ( name , date ) ; }
public void add date header ( string name , long date ) { this . _get http servlet response ( ) . add date header ( name , date ) ; }
public void add header ( string name , string value ) { this . _get http servlet response ( ) . add header ( name , value ) ; }
public empty role semantic get empty role semantic ( ) { return this . empty role semantic ; }
public transport guarantee get transport guarantee ( ) { return this . transport guarantee ; }
public object get value ( ) { return this . value ; }
public throwable get root cause ( ) { return root cause ; }
public void println ( string s ) throw i o exception { print ( s ) ; println ( ) ; }
public string get name ( ) { return this . name ; }
public object get attribute ( string name ) { return this . request . get attribute ( name ) ; }
public enumeration < locale > get locale ( ) { return this . request . get locale ( ) ; }
public boolean be async support ( ) { return request . be async support ( ) ; }
public dispatcher type get dispatcher type ( ) { return request . get dispatcher type ( ) ; }
public void set locale ( locale loc ) { this . response . set locale ( loc ) ; }
public boolean be permanent ( ) { return permanent ; }
public string to string ( ) { return ( this . reason phrase == null ) ? `` close reason [ `` + this . close code . get code ( ) + `` ] `` : `` close reason [ `` + this . close code . get code ( ) + `` , `` + reason phrase + `` ] `` ; }
public static web socket container get web socket container ( ) { web socket container wsc = null ; for ( container provider impl : service loader . load ( container provider . class ) ) { wsc = impl . get container ( ) ; if ( wsc ! = null ) { return wsc ; } } if ( wsc == null ) { throw new runtime exception ( `` could not find an implementation class . `` ) ; } else { throw new runtime exception ( `` could not find an implementation class with a non-null web socket container . `` ) ; } }
public string get text ( ) { return this . encode string ; }
public list < class < ? extend decoder > > get decoder ( ) { return this . decoder ; }
public < a extends annotation > a get ( class < a > annotation type ) { for ( annotation a : annotation ) { if ( a . annotation type ( ) ==annotation type ) return annotation type . cast ( a ) ; } return null ; }
public string [ ] get contextual namespace decls ( ) { return empty_string ; }
public final lifecycle method get lifecycle method ( ) { return lcm ; }
public final void invoke after unmarshal method ( unmarshaller impl unm , object child , object parent ) throw s a x exception { method m = get lifecycle method ( ) . after unmarshal ; invoke unmarshall callback ( m , child , unm , parent ) ; }
public final boolean have event handler ( ) { return get event handler ( ) ! =this ; }
public void handle error ( exception e ) throw s a x exception { handle error ( e , true ) ; }
public string [ ] get newly declare prefix ( ) { return get prefix list ( current . prev . num ns decl ) ; }
public final void report error ( string field name , throwable t ) throw s a x exception { validation event ve = new validation event impl ( validation event . error , t . get message ( ) , get current location ( field name ) , t ) ; report error ( ve ) ; }
public void clear current property ( ) { if ( current property ! = null ) { current property . remove ( ) ; } }
public string get cycle string ( ) { string builder sb = new string builder ( ) ; int i=size ( ) -1 ; e obj = get ( i ) ; sb . append ( obj ) ; object x ; do { sb . append ( `` - > `` ) ; x = get ( -- i ) ; sb . append ( x ) ; } while ( obj ! =x ) ; return sb . to string ( ) ; }
public int size ( ) { return size ; }
public list get node set ( ) { return this . node set ; }
public function context get function context ( ) { return this . function context ; }
public navigator get navigator ( ) { return this . navigator ; }
public void add predicate ( predicate predicate ) { if ( this . predicate == collection . empty_list ) { this . predicate = new array list ( ) ; } this . predicate . add ( predicate ) ; }
public x path factory get x path factory ( ) { return this . xpath factory ; }
public element get j d o m element ( ) { return jdom element ; }
public void set j d o m element ( element jdom element ) { this . jdom element = jdom element ; }
public namespace get j d o m namespace ( ) { return jdom namespace ; }
public double get priority ( ) { return 0 . 5 ; }
public pattern [ ] get union pattern ( ) { return null ; }
public int get position ( ) { return this . position ; }
public object next ( ) throw no such element exception { if ( ! have next ( ) ) { throw new no such element exception ( ) ; } object obj = this . next obj ; if ( sibling iter . have next ( ) ) { this . next obj = sibling iter . next ( ) ; } else { this . next obj = null ; } return obj ; }
public object next ( ) { if ( have next ( ) ) { this . see = true ; return this . object ; } throw new no such element exception ( ) ; }
public exception get exception ( ) { return e ; }
public int hash code ( ) { string s = user name ; s += new string ( password ) ; return s . hash code ( ) ; }
public void trace ( object message ) { do log ( level . trace , fqcn , message , null , null ) ; }
public void trace ( object message , object [ ] params ) { do log ( level . trace , fqcn , message , params , null ) ; }
public void debug ( object message ) { do log ( level . debug , fqcn , message , null , null ) ; }
public void info ( object message , throwable t ) { do log ( level . info , fqcn , message , null , t ) ; }
public void warnf ( string format , object . . . params ) { do logf ( level . warn , fqcn , format , params , null ) ; }
public void error ( object message , throwable t ) { do log ( level . error , fqcn , message , null , t ) ; }
public void log ( level level , object message , object [ ] params ) { do log ( level , fqcn , message , params , null ) ; }
public static logger get logger ( string name , string suffix ) { return get logger ( name == null || name . length ( ) == 0 ? suffix : name + `` . `` + suffix ) ; }
public static logger get logger ( class < ? > clazz ) { return get logger ( clazz . get name ( ) ) ; }
public static format step module name format step ( final boolean leave justify , final int minimum width , final int maximum width , final string precision ) { return module name format step ( left justify , minimum width , default_truncate_beginning , maximum width , precision ) ; }
public static format step resource key format step ( final boolean leave justify , final int minimum width , final int maximum width ) { return resource key format step ( left justify , minimum width , default_truncate_beginning , maximum width ) ; }
public synchronize void set date format ( final string pattern ) { if ( pattern == null ) { date time formatter = date time formatter . iso_offset_date_time . with zone ( zone id ) ; } else { date time formatter = date time formatter . of pattern ( pattern ) . with zone ( zone id ) ; } }
public void set rotate size ( final long rotate size ) { synchronize ( output lock ) { this . rotate size = rotate size ; } }
public int get limit ( ) { synchronize ( buffer ) { return limit ; } }
public ext log record [ ] get queue ( ) { synchronize ( buffer ) { return buffer . to array ( new ext log record [ buffer . size ( ) ] ) ; } }
public string [ ] get queue a string ( ) { final ext log record [ ] queue = get queue ( ) ; final int length = queue . length ; final string [ ] string = new string [ length ] ; final formatter formatter = get formatter ( ) ; for ( int i = 0 , j = 0 ; j < length ; j++ ) { final string format ; try { formatted = formatter . format ( queue [ j ] ) ; if ( format . length ( ) > 0 ) { string [ i++ ] = get formatter ( ) . format ( queue [ j ] ) ; } } catch ( exception ex ) { report error ( `` format error `` , ex , error manager . format_failure ) ; } } return string ; }
public inet address get address ( ) { return address ; }
public < v > v attach ( logger . attachment key < v > key , v value ) throw security exception { return root logger . attach ( key , value ) ; }
public logger get logger ( string name ) { return root logger . get or create ( name ) . create logger ( ) ; }
public level get level for name ( string name ) throw illegal argument exception { if ( name ! = null ) { final level level = level_map . get ( name ) ; if ( level ! = null ) { return level ; } } throw new illegal argument exception ( `` unknown level \ `` `` + name + `` \ `` `` ) ; }
public void set level name ( string new level name ) throw security exception { set level ( logger node . get context ( ) . get level for name ( new level name ) ) ; }
public < v > v attach ( attachment key < v > key , v value ) throw security exception { return logger node . attach ( key , value ) ; }
public handler [ ] get and set handler ( final handler [ ] handler ) throw security exception { final handler [ ] safe handler = handler . clone ( ) ; for ( handler handler : safe handler ) { if ( handler == null ) { throw new illegal argument exception ( `` a handler be null `` ) ; } } return logger node . set handler ( safe handler ) ; }
public boolean compare and set handler ( final handler [ ] expect , final handler [ ] new handler ) throw security exception { final handler [ ] safe expect handler = expect . clone ( ) ; final handler [ ] safe new handler = new handler . clone ( ) ; for ( handler handler : safe new handler ) { if ( handler == null ) { throw new illegal argument exception ( `` a handler be null `` ) ; } } handler [ ] old handler ; do { old handler = logger node . get handler ( ) ; if ( ! array . equal ( old handler , safe expect handler ) ) { return false ; } } while ( ! logger node . compare and set handler ( old handler , safe new handler ) ) ; return true ; }
public handler [ ] clear handler ( ) throw security exception { return logger node . clear handler ( ) ; }
public void log raw ( final log record record ) { log raw ( ext log record . wrap ( record ) ) ; }
public void uncaught exception ( final thread t , final throwable e ) { log . log ( level . error , `` uncaught exception `` , e ) ; }
public void set exception handler ( final thread . uncaught exception handler exception handler ) { assert . check not null param ( `` exception handler `` , exception handler ) ; this . exception handler = exception handler ; }
public long get submit task count ( ) { return update_statistics ? submit task counter . long value ( ) : -1 ; }
protect void store value ( transaction tx , object value ) { delegate . store value ( this , tx , value ) ; }
public object get ( ) { return get ( get transaction ( ) ) ; }
public static transaction manager locate transaction manager ( ) { return get instance ( ) . locate ( ) ; }
public boolean be trace enable ( ) { return logger . be trace enable ( ) ; }
public void debug ( object message , throwable t ) { logger . log ( null , fqcn , location aware logger . debug_int , string . value of ( message ) , null , t ) ; }
public void set attribute ( string name , object value ) { if ( value == null ) { attribute . remove ( name ) ; } else { attribute . put ( name , value ) ; } }
public namespace get namespace ( ) { return namespace ; }
public string get namespace prefix ( ) { return namespace . get prefix ( ) ; }
public object set ( int index , object obj ) { if ( obj instanceof attribute ) { attribute attribute = ( attribute ) obj ; int duplicate = index of duplicate ( attribute ) ; if ( ( duplicate > = 0 ) & & ( duplicate ! = index ) ) { throw new illegal add exception ( `` can not set duplicate attribute `` ) ; } return set ( index , attribute ) ; } else if ( obj == null ) { throw new illegal add exception ( `` can not add null attribute `` ) ; } else { throw new illegal add exception ( `` class `` + obj . get class ( ) . get name ( ) + `` be not an attribute `` ) ; } }
public string get value ( ) { return text ; }
public string get system i d ( ) { return system i d ; }
public doc type set system i d ( string system i d ) { string reason = verifier . check system literal ( system i d ) ; if ( reason ! = null ) { throw new illegal data exception ( system i d , `` doc type `` , reason ) ; } this . system i d = system i d ; return this ; }
public element get child ( string name , namespace n ) { list element = content . get view ( new element filter ( name , ns ) ) ; iterator i = element . iterator ( ) ; if ( i . have next ( ) ) { return ( element ) i . next ( ) ; } return null ; }
public string get namespace u r i ( ) { return namespace . get u r i ( ) ; }
public boolean remove child ( string name ) { return remove child ( name , namespace . no_namespace ) ; }
public string to string ( ) { return new string buffer ( ) . append ( `` [ entity ref : `` ) . append ( `` & `` ) . append ( name ) . append ( `` ; `` ) . append ( `` ] `` ) . to string ( ) ; }
public int get filter mask ( ) { return filter mask ; }
public element get current element ( ) throw s a x exception { if ( current element == null ) { throw new s a x exception ( `` ill-formed xml document ( multiple root element detect ) `` ) ; } return current element ; }
public boolean get expand entity ( ) { return expand ; }
public throwable init cause ( throwable cause ) { this . cause = cause ; return this ; }
public string to string ( ) { return `` [ namespace : prefix \ `` `` + prefix + `` \ `` be map to uri \ `` `` + uri + `` \ `` ] `` ; }
public string get indent ( ) { return indent ; }
public boolean get omit declaration ( ) { return omit declaration ; }
public boolean get omit encode ( ) { return omit encode ; }
public format set expand empty element ( boolean expand empty element ) { this . expand empty element = expand empty element ; return this ; }
public string get text ( ) { return value ; }
public void set factory ( j d o m factory factory ) { this . factory = factory ; }
public object select single node ( object context ) throw j d o m exception { try { current context = context ; return x path . select single node ( context ) ; } catch ( jaxen exception ex1 ) { throw new j d o m exception ( `` x path error while evaluate \ `` `` + x path . to string ( ) + `` \ `` : `` + ex1 . get message ( ) , ex1 ) ; } finally { current context = null ; } }
public static list select node ( object context , string path ) throw j d o m exception { return new instance ( path ) . select node ( context ) ; }
public static boolean be x m l whitespace ( char c ) { if ( c== ' ' || c=='\n ' || c=='\t ' || c=='\r ' ) { return true ; } return false ; }
public void set part ( integer part ) { set integer property ( prefix+ `` : part `` , part ) ; }
public void set software agent ( string software ) { x m l util . set string value ( parent , `` st evt : software agent `` , software ) ; }
public void set mangager ( string manager ) { x m l util . set string value ( parent , `` st ref : manager `` , manager ) ; }
public void set instance i d ( string id ) { x m l util . set string value ( parent , `` st ref : instance i d `` , id ) ; }
public void set rendition class ( string rendition class ) { x m l util . set string value ( parent , `` st ref : rendition class `` , rendition class ) ; }
public integer get height ( ) { return x m l util . get int value ( parent , `` xap g img : height `` ) ; }
public x m p schema p d f get p d f schema ( ) throw i o exception { return ( x m p schema p d f ) get schema by class ( x m p schema p d f . class ) ; }
public x m p schema right management add right management schema ( ) { x m p schema right management schema = new x m p schema right management ( this ) ; return ( x m p schema right management ) basic add schema ( schema ) ; }
public x m p schema page text add page text schema ( ) { x m p schema page text schema = new x m p schema page text ( this ) ; return ( x m p schema page text ) basic add schema ( schema ) ; }
public boolean have unknown schema ( ) throw i o exception { node list schema list = xmp document . get element by tag name ( `` rdf : description `` ) ; for ( int i = 0 ; i < schema list . get length ( ) ; i++ ) { element schema = ( element ) schema list . item ( i ) ; name node map attribute = schema . get attribute ( ) ; for ( int j = 0 ; j < attribute . get length ( ) ; j++ ) { node attribute = attribute . item ( j ) ; string name = attribute . get node name ( ) ; string value = attribute . get node value ( ) ; if ( name . start with ( `` xmlns : `` ) & & ! ns mapping . contains key ( value ) & & ! value . equal ( resource event . namespace ) ) { return true ; } } } return false ; }
public void set boolean property ( string property name , boolean bool ) { string value = null ; if ( bool ! = null ) { value = bool . boolean value ( ) ? `` true `` : `` false `` ; } set text property ( property name , value ) ; }
public void remove bag value ( string bag name , string bag value ) { element bag element = null ; node list node = schema . get element by tag name ( bag name ) ; if ( node . get length ( ) > 0 ) { element cont element = ( element ) node . item ( 0 ) ; node list bag list = cont element . get element by tag name ( `` rdf : bag `` ) ; if ( bag list . get length ( ) > 0 ) { bag element = ( element ) bag list . item ( 0 ) ; node list item = bag element . get element by tag name ( `` rdf : li `` ) ; for ( int i = item . get length ( ) - 1 ; i > = 0 ; i -- ) { element li = ( element ) item . item ( i ) ; string value = x m l util . get string value ( li ) ; if ( value . equal ( bag value ) ) { bag element . remove child ( li ) ; } } } } }
public void set create date ( calendar date ) { set date property ( prefix + `` : create date `` , date ) ; }
public void set creator tool ( string creator ) { set text property ( prefix + `` : creator tool `` , creator ) ; }
public string get title ( ) { return get text property ( prefix + `` : title `` ) ; }
public integer get rating ( ) { return get integer property ( prefix + `` : rating `` ) ; }
public string get description ( ) { return get language property ( prefix + `` : description `` , null ) ; }
public void set right ( string right ) { set language property ( prefix + `` : right `` , null , right ) ; }
public list < string > get title language ( ) { return get language property language ( prefix + `` : title `` ) ; }
public resource ref create derive from ( ) { element node = schema . get owner document ( ) . create element ( prefix + `` : derive from `` ) ; resource ref ref = new resource ref ( node ) ; return ref ; }
public void set derive from ( resource ref resource ) { x m l util . set elementable value ( schema , prefix + `` : derive from `` , resource ) ; }
public string get document i d ( ) { return get text property ( prefix + `` : document i d `` ) ; }
public string get manager ( ) { return get text property ( prefix + `` : manager `` ) ; }
public void add supplemental category ( string s ) { add bag value ( prefix + `` : supplemental category `` , s ) ; }
public void add owner ( string owner ) { add bag value ( prefix + `` : owner `` , owner ) ; }
public list < string > get usage term language ( ) { return get language property language ( prefix + `` : usage term `` ) ; }
public static http authentication feature basic ( string username , byte [ ] password ) { return build ( mode . basic_preemptive , username , password ) ; }
public static universal builder universal builder ( ) { return new builder impl ( mode . universal ) ; }
public chunk parser get parser ( ) { return parser ; }
public void set chunk type ( final medium type medium type ) throw illegal argument exception { if ( medium type == null ) { throw new illegal argument exception ( localization message . chunked_input_media_type_null ( ) ) ; } this . medium type = medium type ; }
public connector get connector ( ) { return state . get connector ( ) ; }
public jersey client get client ( ) { return state . get client ( ) ; }
public client request get request context ( ) { return request context ; }
public static string http_invalid_chunk_size_hex_value ( object arg0 ) { return localizer . localize ( localizable h t t p_ i n v a l i d_ c h u n k_ s i z e_ h e x_ v a l u e ( arg0 ) ) ; }
public static string http_initial_line_overflow ( ) { return localizer . localize ( localizable h t t p_ i n i t i a l_ l i n e_ o v e r f l o w ( ) ) ; }
public static string error_parameter_type_processing ( object arg0 ) { return localizer . localize ( localizable e r r o r_ p a r a m e t e r_ t y p e_ p r o c e s s i n g ( arg0 ) ) ; }
public static string client_instance_closed ( ) { return localizer . localize ( localizable c l i e n t_ i n s t a n c e_ c l o s e d ( ) ) ; }
public static string request_entity_writer_null ( ) { return localizer . localize ( localizable r e q u e s t_ e n t i t y_ w r i t e r_ n u l l ( ) ) ; }
public static string preinvocation_interceptor_multiple_abortions ( ) { return localizer . localize ( localizable p r e i n v o c a t i o n_ i n t e r c e p t o r_ m u l t i p l e_ a b o r t i o n s ( ) ) ; }
public static string client_rx_provider_null ( ) { return localizer . localize ( localizable c l i e n t_ r x_ p r o v i d e r_ n u l l ( ) ) ; }
public static string postinvocation_interceptor_multiple_resolves ( ) { return localizer . localize ( localizable p o s t i n v o c a t i o n_ i n t e r c e p t o r_ m u l t i p l e_ r e s o l v e s ( ) ) ; }
public static string error_http_method_entity_not_null ( object arg0 ) { return localizer . localize ( localizable e r r o r_ h t t p_ m e t h o d_ e n t i t y_ n o t_ n u l l ( arg0 ) ) ; }
public static < t > t process with exception ( final producer < t > producer ) { return process ( producer , true ) ; }
public static void mark ( ) { get instance ( ) . _mark ( ) ; }
public set < type > get contract ( ) { return contract ; }
public set < alias bind > get alias ( ) { return alias ; }
public void set parent class scope ( class < ? extend annotation > parent class scope ) { this . parent class scope = parent class scope ; }
public void set injectee class ( final class < ? > injectee class ) { this . injectee class = injectee class ; }
public static string ssl_kmf_init_failed ( ) { return localizer . localize ( localizable s s l_ k m f_ i n i t_ f a i l e d ( ) ) ; }
public static string template_param_null ( ) { return localizer . localize ( localizable t e m p l a t e_ p a r a m_ n u l l ( ) ) ; }
public static string link_is_null ( ) { return localizer . localize ( localizable l i n k_ i s_ n u l l ( ) ) ; }
public static string ssl_ks_cert_load_error ( ) { return localizer . localize ( localizable s s l_ k s_ c e r t_ l o a d_ e r r o r ( ) ) ; }
public static string ssl_ts_file_not_found ( object arg0 ) { return localizer . localize ( localizable s s l_ t s_ f i l e_ n o t_ f o u n d ( arg0 ) ) ; }
public static string ssl_ts_providers_not_registered ( ) { return localizer . localize ( localizable s s l_ t s_ p r o v i d e r s_ n o t_ r e g i s t e r e d ( ) ) ; }
public static string error_provider_registered_wrong_runtime ( object arg0 , object arg1 ) { return localizer . localize ( localizable e r r o r_ p r o v i d e r_ r e g i s t e r e d_ w r o n g_ r u n t i m e ( arg0 , arg1 ) ) ; }
public static string invalid_host ( ) { return localizer . localize ( localizable i n v a l i d_ h o s t ( ) ) ; }
public static string uri_builder_scheme_part_unexpected_component ( object arg0 , object arg1 ) { return localizer . localize ( localizable u r i_ b u i l d e r_ s c h e m e_ p a r t_ u n e x p e c t e d_ c o m p o n e n t ( arg0 , arg1 ) ) ; }
public static void set iterator provider ( final service iterator provider sip ) throw security exception { service iterator provider . set instance ( sip ) ; }
public string integration server jvm ( ) { return common ( ) + `` server jvm `` ; }
public static string p type ( parameterized type p type ) { string buffer sb = new string buffer ( ) ; sb . append ( clazz ( reflection helper . get raw class ( p type ) ) + `` < `` ) ; boolean first = true ; for ( type t : p type . get actual type argument ( ) ) { if ( first ) { first = false ; sb . append ( type ( t ) ) ; } else { sb . append ( `` , `` + type ( t ) ) ; } } sb . append ( `` > `` ) ; return sb . to string ( ) ; }
public static privilege action set context class loader p a ( final class loader class loader ) { return new privilege action ( ) { @ override public object run ( ) { thread . current thread ( ) . set context class loader ( class loader ) ; return null ; } } ; }
public static type [ ] get type argument ( final type type ) { if ( ! ( type instanceof parameterized type ) ) { return null ; } return ( ( parameterized type ) type ) . get actual type argument ( ) ; }
public class < ? > provide type ( ) { return provide type ; }
public static string filter token ( final char sequence s , final int start , final int end ) { return filter token ( s , start , end , false ) ; }
public static list < quality source medium type > read quality source medium type ( string header ) throw parse exception { return http header reader . read qualified list ( quality source medium type . comparator , quality_source_media_type_creator , header ) ; }
public inbound message context header ( string name , object value ) { get header ( ) . add ( name , header utils . a string ( value , configuration ) ) ; return this ; }
public set < match entity tag > get if none match ( ) { final string if none match = get header string ( http header . if_none_match ) ; if ( if none match == null || if none match . be empty ( ) ) { return null ; } try { return http header reader . read match entity tag ( if none match ) ; } catch ( java . text . parse exception e ) { throw exception ( http header . if_none_match , if none match , e ) ; } }
public date get last modified ( ) { return single header ( http header . last_modified , new function < string , date > ( ) { @ override public date apply ( string input ) { try { return http header reader . read date ( input ) ; } catch ( parse exception e ) { throw new process exception ( e ) ; } } } , false ) ; }
public input stream get entity stream ( ) { entity content . ensure not close ( ) ; return entity content . get wrapped stream ( ) ; }
protect final void clear last traced interceptor ( ) { last traced interceptor = null ; }
public static boolean be wildcard ( final medium type medium type ) { return medium type . be wildcard type ( ) || medium type . be wildcard subtype ( ) ; }
public static void write to ( input stream in , output stream out ) throw i o exception { int read ; final byte [ ] data = new byte [ buffer_size ] ; while ( ( read = in . read ( data ) ) ! = -1 ) { out . write ( data , 0 , read ) ; } }
public static tracing logger empty ( ) { return empty ; }
public type [ ] get generic parameter type ( ) { return be . get generic parameter type ( ) ; }
public static builder builder ( final contract provider original ) { return new builder ( original ) ; }
public boolean register ( object component , inflector < contract provider . builder , contract provider > model enhancer ) { final class < ? > component class = component . get class ( ) ; final boolean result = register model ( component class , contract provider . no_priority , null , model enhancer ) ; if ( result ) { instance . add ( component ) ; } return result ; }
public final set < string > get support encoding ( ) { return support encoding ; }
public ssl configurator key store file ( string file name ) { this . key store file = file name ; this . key store byte = null ; this . key store = null ; return this ; }
public ssl configurator trust manager factory provider ( string provider ) { this . trust manager factory provider = provider ; return this ; }
public static uri normalize ( final string uri ) { return normalize ( uri . create ( uri ) ) ; }
public final string get template ( ) { return template ; }
public final int hash code ( ) { return pattern . hash code ( ) ; }
public string get type ( ) { return type ; }
public string to string ( ) { return to string buffer ( ) . to string ( ) ; }
public static boolean be white space ( char c ) { return ( c < 128 & & is_white_space [ c ] ) ; }
public static boolean verify array type ( class type , jaxb type checker checker ) { type = type . get component type ( ) ; return checker . be jaxb type ( type ) || j a x b element . class . be assignable from ( type ) ; }
public static string sax_xdk_no_security_features ( ) { return localizer . localize ( localizable s a x_ x d k_ n o_ s e c u r i t y_ f e a t u r e s ( ) ) ; }
public static string ambiguous_ctors ( object arg0 ) { return localizer . localize ( localizable a m b i g u o u s_ c t o r s ( arg0 ) ) ; }
public static string error_subres_loc_uri_path_invalid ( object arg0 , object arg1 ) { return localizer . localize ( localizable e r r o r_ s u b r e s_ l o c_ u r i_ p a t h_ i n v a l i d ( arg0 , arg1 ) ) ; }
public static string ambiguous_parameter ( object arg0 , object arg1 ) { return localizer . localize ( localizable a m b i g u o u s_ p a r a m e t e r ( arg0 , arg1 ) ) ; }
public static string ambiguous_rr_path ( object arg0 , object arg1 ) { return localizer . localize ( localizable a m b i g u o u s_ r r_ p a t h ( arg0 , arg1 ) ) ; }
public static string no_webresourceclass_in_webxml ( ) { return localizer . localize ( localizable n o_ w e b r e s o u r c e c l a s s_ i n_ w e b x m l ( ) ) ; }
public static string default_could_not_process_constructor ( object arg0 , object arg1 ) { return localizer . localize ( localizable d e f a u l t_ c o u l d_ n o t_ p r o c e s s_ c o n s t r u c t o r ( arg0 , arg1 ) ) ; }
public boolean be weak ( ) { return weak ; }
protect void merge filter scope ( final set < string > filter scope , final set < string > resolve scope ) { if ( ! filter scope . be empty ( ) & & ! resolve scope . be empty ( ) ) { logger . log ( level . fine , localization message . merging_filtering_scopes ( ) ) ; } filter scope . add all ( resolve scope ) ; }
public static annotation [ ] get filtering annotation ( final annotation [ ] annotation ) { if ( annotation == null || annotation . length == 0 ) { return filter helper . empty_annotations ; } final list < annotation > filtering annotation = new array list < > ( annotation . length ) ; for ( final annotation annotation : annotation ) { final class < ? extend annotation > annotation type = annotation . annotation type ( ) ; for ( final annotation meta annotation : annotation type . get declared annotation ( ) ) { if ( meta annotation instanceof entity filter ) { filter annotation . add ( annotation ) ; } } } return filter annotation . to array ( new annotation [ filter annotation . size ( ) ] ) ; }
default public void attribute replace ( http session bind event event ) { }
default public void value bound ( http session bind event event ) { }
public transport guarantee get transport guarantee ( ) { return this . transport guarantee ; }
default public void attribute replace ( servlet context attribute event event ) { }
public print writer get writer ( ) throw i o exception { return this . response . get writer ( ) ; }
public context get context for class loader ( class loader loader ) { if ( loader == null ) return null ; try ( auto lock l = __lock . lock ( ) ) { return __context map . get ( loader ) ; } }
public void deploy handler ( handler handler , callback callback ) { if ( handler . get server ( ) ! = get server ( ) ) handler . set server ( get server ( ) ) ; _serialized executor . execute ( new serialize executor . error handle task ( ) { @ override public void run ( ) { add handler ( handler ) ; callback . succeed ( ) ; } @ override public void accept ( throwable throwable ) { callback . fail ( throwable ) ; } } ) ; }
public boolean be directory list ( ) { return _resource service . be dir allow ( ) ; }
public void set request header size ( int request header size ) { _request header size = request header size ; }
public string builder get root u r l ( ) { string builder url = new string builder ( 128 ) ; u r i util . append scheme host port ( url , get scheme ( ) , get server name ( ) , get server port ( ) ) ; return url ; }
public void set authentication ( authentication authentication ) { _authentication = authentication ; }
protect void customize ( s s l engine ssl engine , request request ) { s s l session ssl session = ssl engine . get session ( ) ; if ( be sni required ( ) || be sni host check ( ) ) { string sni host = ( string ) ssl session . get value ( ssl context factory . server . sni_host ) ; x509 x509 = ( x509 ) ssl session . get value ( x509_cert ) ; if ( x509 == null ) { certificate [ ] certificate = ssl session . get local certificate ( ) ; if ( certificate == null || certificate . length == 0 || ! ( certificate [ 0 ] instanceof x509 certificate ) ) throw new bad message exception ( 400 , `` invalid sni `` ) ; x509 = new x509 ( null , ( x509 certificate ) certificate [ 0 ] ) ; ssl session . put value ( x509_cert , x509 ) ; } string server name = request . get server name ( ) ; if ( log . be debug enable ( ) ) log . debug ( `` host= { } , sni= { } , sni certificate= { } `` , server name , sni host , x509 ) ; if ( be sni required ( ) & & ( sni host == null || ! x509 . match ( sni host ) ) ) throw new bad message exception ( 400 , `` invalid sni `` ) ; if ( be sni host check ( ) & & ! x509 . match ( server name ) ) throw new bad message exception ( 400 , `` invalid sni `` ) ; } request . set attribute ( new ssl attribute ( request , ssl session ) ) ; }
protect void customize secure ( request request ) { request . set secure ( true ) ; if ( _sts field ! = null ) request . get response ( ) . get http field ( ) . add ( _sts field ) ; }
public void set connector ( connector [ ] connector ) { if ( connector ! = null ) { for ( connector connector : connector ) { if ( connector . get server ( ) ! = this ) throw new illegal argument exception ( `` connector `` + connector + `` can not be share among server `` + connector . get server ( ) + `` and server `` + this ) ; } } connector [ ] old connector = get connector ( ) ; update bean ( old connector , connector ) ; _connectors . remove all ( array . a list ( old connector ) ) ; if ( connector ! = null ) _connectors . add all ( array . a list ( connector ) ) ; }
public void init random ( ) { if ( _random == null ) { try { _random = new secure random ( ) ; } catch ( exception e ) { log . warn ( `` could not generate secure random for session-id randomness `` , e ) ; _random = new random ( ) ; _weak random = true ; } } else _random . set seed ( _random . next long ( ) ^ system . current time millis ( ) ^ hash code ( ) ^ runtime . get runtime ( ) . free memory ( ) ) ; }
public boolean delete file ( string filename ) throw exception { if ( filename == null ) return false ; file file = new file ( _store dir , filename ) ; return file . delete if exists ( file . to path ( ) ) ; }
protect void customize ( socket socket , class < ? extend connection > connection , boolean ssl ) { }
public void set log latency ( boolean log latency ) { _log latency = log latency ; }
public void set extend ( boolean extend ) { _extended = extend ; }
public locale get log locale ( ) { return _log locale ; }
public void add exclude path ( string . . . pathspecs ) { for ( string p : pathspecs ) { _paths . exclude ( string util . csv split ( p ) ) ; } }
public string [ ] get exclude mime type ( ) { set < string > exclude = _mime type . get excluded ( ) ; return exclude . to array ( new string [ exclude . size ( ) ] ) ; }
public string [ ] get included agent pattern ( ) { set < string > include = _agent pattern . get included ( ) ; return include . to array ( new string [ include . size ( ) ] ) ; }
public void set exclude method ( string . . . method ) { _methods . get excluded ( ) . clear ( ) ; _methods . exclude ( method ) ; }
public void set min gzip size ( int min gzip size ) { if ( min gzip size < break_even_gzip_size ) log . warn ( `` min gzip size of { } be inefficient for short content , break even be size { } `` , min gzip size , break_even_gzip_size ) ; _min gzip size = math . max ( 0 , min gzip size ) ; }
public void set deflater pool capacity ( int capacity ) { if ( be start ( ) ) throw new illegal state exception ( get state ( ) ) ; _pool capacity = capacity ; }
protect int get ( content content , byte [ ] buffer , int offset , int length ) { int l = content . get ( buffer , offset , length ) ; _content consume += l ; return l ; }
protect context handler init context handler ( servlet context servlet context ) { context handler . context scontext = context handler . get current context ( ) ; if ( scontext == null ) { if ( servlet context instanceof context handler . context ) return ( ( context handler . context ) servlet context ) . get context handler ( ) ; else throw new illegal argument exception ( `` the servlet context `` + servlet context + `` `` + servlet context . get class ( ) . get name ( ) + `` be not `` + context handler . context . class . get name ( ) ) ; } else return context handler . get current context ( ) . get context handler ( ) ; }
protect void append path ( string buffer path , string element ) { if ( string util . be blank ( element ) ) return ; if ( path . length ( ) > 0 ) path . append ( `` . `` ) ; path . append ( element ) ; }
public boolean be permanent ( ) { return permanent ; }
public static int get hi ( long encode ) { return ( int ) ( ( encode > > 32 ) & 0x f f f f_ f f f f l ) ; }
public static long encode ( int hi , int lo ) { long h = ( ( long ) hi ) & 0x f f f f_ f f f f l ; long l = ( ( long ) lo ) & 0x f f f f_ f f f f l ; return ( h < < 32 ) + l ; }
public static long encode hi ( long encode , int hi ) { long h = ( ( long ) hi ) & 0x f f f f_ f f f f l ; long l = encode & 0x f f f f_ f f f f l ; return ( h < < 32 ) + l ; }
public static byte buffer allocate ( int capacity ) { byte buffer buf = byte buffer . allocate ( capacity ) ; buf . limit ( 0 ) ; return buf ; }
public static void flip to flush ( byte buffer buffer , int position ) { buffer . limit ( buffer . position ( ) ) ; buffer . position ( position ) ; }
public static byte [ ] to array ( byte buffer buffer ) { if ( buffer . have array ( ) ) { byte [ ] array = buffer . array ( ) ; int from = buffer . array offset ( ) + buffer . position ( ) ; return array . copy of range ( array , from , from + buffer . remain ( ) ) ; } else { byte [ ] to = new byte [ buffer . remain ( ) ] ; buffer . slice ( ) . get ( to ) ; return to ; } }
public static int space ( byte buffer buffer ) { if ( buffer == null ) return 0 ; return buffer . capacity ( ) - buffer . limit ( ) ; }
public static boolean compact ( byte buffer buffer ) { if ( buffer . position ( ) == 0 ) return false ; boolean full = buffer . limit ( ) == buffer . capacity ( ) ; buffer . compact ( ) . flip ( ) ; return full & & buffer . limit ( ) < buffer . capacity ( ) ; }
public static long to long ( byte buffer buffer ) { long val = 0 ; boolean start = false ; boolean minus = false ; for ( int i = buffer . position ( ) ; i < buffer . limit ( ) ; i++ ) { byte b = buffer . get ( i ) ; if ( b < = space ) { if ( start ) break ; } else if ( b > = ' 0 ' & & b < = ' 9 ' ) { val = val * 10l + ( b - ' 0 ' ) ; start = true ; } else if ( b == minus & & ! start ) { minus = true ; } else break ; } if ( start ) return minus ? ( -val ) : val ; throw new number format exception ( to string ( buffer ) ) ; }
public c get or throw ( ) throw exception { _latch . await ( ) ; if ( _cause == complete ) return _result ; if ( _cause instanceof exception ) throw ( exception ) _cause ; if ( _cause instanceof error ) throw ( error ) _cause ; throw new execution exception ( _cause ) ; }
public static object add array ( object list , object [ ] array ) { for ( int i = 0 ; array ! = null & & i < array . length ; i++ ) { list = lazy list . add ( list , array [ i ] ) ; } return list ; }
public static object ensure size ( object list , int initial size ) { if ( list == null ) return new array list < object > ( initial size ) ; if ( list instanceof array list ) { array list < ? > ol = ( array list < ? > ) list ; if ( ol . size ( ) > initial size ) return ol ; array list < object > nl = new array list < object > ( initial size ) ; nl . add all ( ol ) ; return nl ; } list < object > l = new array list < object > ( initial size ) ; l . add ( list ) ; return l ; }
public static < e > list < e > get list ( object list ) { return get list ( list , false ) ; }
public static resource new resource ( url url ) { return new resource ( url , __default use cache ) ; }
protect void rollover ( file old file , file backup file , file new file ) { }
public void set scan interval ( int scan interval ) { if ( be run ( ) ) throw new illegal state exception ( `` scanner start `` ) ; _scan interval = scan interval ; }
public void nudge ( ) { if ( ! be run ( ) ) throw new illegal state exception ( `` scanner not run `` ) ; scan ( callback . noop ) ; }
public int match ( byte [ ] data , int offset , int length ) { validate args ( data , offset , length ) ; int skip = offset ; while ( skip < = offset + length - pattern . length ) { for ( int i = pattern . length - 1 ; data [ skip + i ] == pattern [ i ] ; i -- ) { if ( i == 0 ) return skip ; } skip += table [ 0xff & data [ skip + pattern . length - 1 ] ] ; } return -1 ; }
public void set exclude protocol ( string . . . protocol ) { _exclude protocol . clear ( ) ; _exclude protocol . add all ( array . a list ( protocol ) ) ; }
public void set session cache enable ( boolean enable session cache ) { _session cache enable = enable session caching ; }
protect password get password ( string realm ) { string password = system . get property ( realm ) ; return password == null ? null : new password ( password ) ; }
public password new password ( string password ) { return new password ( password ) ; }
public static < t > list < t > a list ( t [ ] a ) { if ( a == null ) return collection . empty list ( ) ; return array . a list ( a ) ; }
public static resource get non cache resource ( resource resource ) { if ( ! ( resource instanceof jar file resource ) ) return resource ; jar file resource old resource = ( jar file resource ) resource ; jar file resource new resource = new jar file resource ( old resource . get u r l ( ) , false ) ; return new resource ; }
public void set reserve thread ( int reserve thread ) { if ( be run ( ) ) throw new illegal state exception ( get state ( ) ) ; _reserved thread = reserve thread ; }
protect void protect ( string . . . class ) { _system . add ( class ) ; }
public static < t > t run with server class access ( privileged exception action < t > action ) throw exception { boolean lsc = __load server class . get ( ) ; try { __load server class . set ( true ) ; return action . run ( ) ; } finally { if ( lsc == null ) __load server class . remove ( ) ; else __load server class . set ( lsc ) ; } }
public void add content handler ( string trigger , content handler observer ) { try ( auto lock l = _lock . lock ( ) ) { if ( _observer map == null ) _observer map = new hash map < > ( ) ; _observer map . put ( trigger , observer ) ; } }
public static string trim leading character ( string str , char lead character ) { if ( ! have length ( str ) ) { return str ; } string builder sb = new string builder ( str ) ; while ( sb . length ( ) > 0 & & sb . char at ( 0 ) == lead character ) { sb . delete char at ( 0 ) ; } return sb . to string ( ) ; }
public static string trim trailing character ( string str , char trail character ) { if ( ! have length ( str ) ) { return str ; } string builder sb = new string builder ( str ) ; while ( sb . length ( ) > 0 & & sb . char at ( sb . length ( ) - 1 ) == trail character ) { sb . delete char at ( sb . length ( ) - 1 ) ; } return sb . to string ( ) ; }
public static string delete ( string in string , string pattern ) { return replace ( in string , pattern , `` `` ) ; }
public static string apply relative path ( string path , string relative path ) { int separator index = path . last index of ( folder_separator ) ; if ( separator index ! = -1 ) { string new path = path . substring ( 0 , separator index ) ; if ( ! relative path . start with ( folder_separator ) ) { new path += folder_separator ; } return new path + relative path ; } else { return relative path ; } }
public static string collection to delimit string ( collection < ? > coll , string delim , string prefix , string suffix ) { if ( collection . be empty ( coll ) ) { return `` `` ; } string builder sb = new string builder ( ) ; iterator < ? > it = coll . iterator ( ) ; while ( it . have next ( ) ) { sb . append ( prefix ) . append ( it . next ( ) ) . append ( suffix ) ; if ( it . have next ( ) ) { sb . append ( delim ) ; } } return sb . to string ( ) ; }
public static string collection to comma delimited string ( collection < ? > coll ) { return collection to delimit string ( coll , `` , `` ) ; }
public string get family name ( ) { return family name ; }
public pointer get trampoline ( ) { if ( trampoline == null ) { trampoline = cbstruct . get pointer ( 0 ) ; } return trampoline ; }
public string get name ( callback cb ) { return name ; }
public static function get function ( string library name , string function name , int call flag ) { return native library . get instance ( library name ) . get function ( function name , call flag , null ) ; }
public void clear ( ) { clear ( size ) ; }
public void set double ( long offset , double value ) { bound check ( offset , 8 ) ; super . set double ( offset , value ) ; }
public string dump ( ) { return dump ( 0 , ( int ) size ( ) ) ; }
public void clear ( long size ) { set memory ( 0 , size , ( byte ) 0 ) ; }
public char get char ( long offset ) { return native . get char ( this , this . peer , offset ) ; }
public string get string ( long offset , string encode ) { return native . get string ( this , offset , encode ) ; }
public double [ ] get double array ( long offset , int array size ) { double [ ] buf = new double [ array size ] ; read ( offset , buf , 0 , array size ) ; return buf ; }
public string [ ] get string array ( long offset ) { return get string array ( offset , -1 , native . get default string encoding ( ) ) ; }
protect void sort field ( list < field > field , list < string > names ) { for ( int i=0 ; i < name . size ( ) ; i++ ) { string name = name . get ( i ) ; for ( int f=0 ; f < field . size ( ) ; f++ ) { field field = field . get ( f ) ; if ( name . equal ( field . get name ( ) ) ) { collection . swap ( field , i , f ) ; break ; } } } }
protect int calculate size ( boolean force ) { return calculate size ( force , false ) ; }
public void set type ( class < ? > type ) { ensure allocate ( ) ; for ( struct field f : field ( ) . value ( ) ) { if ( f . type == type ) { active field = f ; return ; } } throw new illegal argument exception ( `` no field of type `` + type + `` in `` + this ) ; }
public static string l get x attr ( string path , string name ) throw i o exception { return l get x attr ( path , name , native . get default string encoding ( ) ) ; }
public static i o service get matching service ( string service name ) { c f mutable dictionary ref dict = io . i o service match ( service name ) ; if ( dict ! = null ) { return get matching service ( dict ) ; } return null ; }
public static i o iterator get matching service ( c f dictionary ref match dictionary ) { int master port = get master port ( ) ; pointer by reference service iterator = new pointer by reference ( ) ; int result = io . i o service get matching service ( master port , match dictionary , service iterator ) ; sys . mach_port_deallocate ( sys . mach_task_self ( ) , master port ) ; if ( result == 0 & & service iterator . get value ( ) ! = null ) { return new i o iterator ( service iterator . get value ( ) ) ; } return null ; }
public i unknown get i unknown ( ) { return i unknown ; }
public hresult get guid ( / * [ out ] * /guid pguid ) { return null ; }
public hresult get size ( / * [ out ] * /ulong pcb size ) { return null ; }
protect boolean be reserve method ( string method ) { for ( int i = 0 ; i < iunknown_methods . length ; i++ ) { if ( iunknown_methods [ i ] . equal ignore case ( method ) ) return true ; } for ( int i = 0 ; i < idispatch_methods . length ; i++ ) { if ( idispatch_methods [ i ] . equal ignore case ( method ) ) return true ; } return false ; }
public vardesc get var desc ( int index ) { pointer by reference pp var desc = new pointer by reference ( ) ; hresult hr = this . type info . get var desc ( new uint ( index ) , pp var desc ) ; c o m utils . check r c ( hr ) ; return new vardesc ( pp var desc . get value ( ) ) ; }
public int get help context ( ) { return help context ; }
public lcid get l c i d ( ) { if ( lcid ! = null ) { return lcid ; } else { return locale_user_default ; } }
public static group [ ] get user group ( string user name , string server name ) { pointer by reference bufptr = new pointer by reference ( ) ; int by reference entriesread = new int by reference ( ) ; int by reference totalentries = new int by reference ( ) ; try { int rc = netapi32 . instance . net user get group ( server name , user name , 0 , bufptr , l m con . max_preferred_length , entriesread , totalentries ) ; if ( rc ! = l m err . n e r r_ success ) { throw new win32 exception ( rc ) ; } array list < group > result = new array list < group > ( ) ; if ( entriesread . get value ( ) > 0 ) { group_users_info_0 lgroup = new group_users_info_0 ( bufptr . get value ( ) ) ; group_users_info_0 [ ] lgroups = ( group_users_info_0 [ ] ) lgroup . to array ( entriesread . get value ( ) ) ; for ( group_users_info_0 lgpi : lgroups ) { group lgp = new group ( ) ; if ( lgpi . grui0_name ! = null ) { lgp . name = lgpi . grui0_name ; } result . add ( lgp ) ; } } return result . to array ( new group [ 0 ] ) ; } finally { if ( bufptr . get value ( ) ! = pointer . null ) { int rc = netapi32 . instance . net api buffer free ( bufptr . get value ( ) ) ; if ( l m err . n e r r_ success ! = rc ) { throw new win32 exception ( rc ) ; } } } }
public static string get key name ( hkey hkey ) { int by reference result length = new int by reference ( ) ; int rc = nt dll . instance . zw query key ( hkey , key_information_class . key basic information , null , 0 , result length ) ; if ( rc ! = n t status . status_buffer_too_small || result length . get value ( ) < = 0 ) { throw new win32 exception ( rc ) ; } key_basic_information key information = new key_basic_information ( result length . get value ( ) ) ; rc = nt dll . instance . zw query key ( hkey , key_information_class . key basic information , key information , result length . get value ( ) , result length ) ; if ( rc ! = n t status . status_success ) { throw new win32 exception ( rc ) ; } return key information . get name ( ) ; }
public static function wgl get proc address ( string proc name ) { pointer func pointer = open g l32 . instance . wgl get proc address ( `` wgl enum gpus n v `` ) ; return ( func pointer == null ) ? null : function . get function ( func pointer ) ; }
public void set failure action ( list < sc_action > action , int reset period , string reboot msg , string command ) { service_failure_actions . by reference action struct = new service_failure_actions . by reference ( ) ; action struct . dw reset period = reset period ; action struct . lp reboot msg = reboot msg ; action struct . lp command = command ; action struct . c action = action . size ( ) ; action struct . lpsa action = new sc_action . by reference ( ) ; sc_action [ ] action array = ( sc_action [ ] ) action struct . lpsa action . to array ( action . size ( ) ) ; boolean have shutdown privilege = false ; int i = 0 ; for ( sc_action action : action ) { if ( ! have shutdown privilege & & action . type == winsvc . sc_action_reboot ) { add shutdown privilege to process ( ) ; have shutdown privilege = true ; } action array [ i ] . type = action . type ; action array [ i ] . delay = action . delay ; i++ ; } if ( ! advapi32 . instance . change service config2 ( _handle , winsvc . service_config_failure_actions , action struct ) ) { throw new win32 exception ( kernel32 . instance . get last error ( ) ) ; } }
public static string evt next publisher id ( evt_handle publisher enum ) { int by reference publisher id buffer use = new int by reference ( ) ; boolean result = wevtapi . instance . evt next publisher id ( publisher enum , 0 , null , publisher id buffer use ) ; int error code = kernel32 . instance . get last error ( ) ; if ( ( ! result ) & & error code ! = kernel32 . error_insufficient_buffer ) { throw new win32 exception ( error code ) ; } char [ ] publisher id buffer = new char [ publisher id buffer use . get value ( ) ] ; result = wevtapi . instance . evt next publisher id ( publisher enum , publisher id buffer . length , publisher id buffer , publisher id buffer use ) ; if ( ! result ) { throw new win32 exception ( kernel32 . instance . get last error ( ) ) ; } return native . to string ( publisher id buffer ) ; }
public static void set window mask ( window w , shape mask ) { get instance ( ) . set window mask ( w , mask ) ; }
public int hash code ( ) { long len = get millis ( ) ; return ( int ) ( len ^ ( len > > > 32 ) ) ; }
public date time to date time i s o ( ) { return new date time ( get millis ( ) , i s o chronology . get instance ( get zone ( ) ) ) ; }
public mutable date time to mutable date time ( chronology chronology ) { return new mutable date time ( get millis ( ) , chronology ) ; }
protect void check interval ( long start , long end ) { if ( end < start ) { throw new illegal argument exception ( `` the end instant must be great or equal to the start `` ) ; } }
public boolean be before ( readable interval interval ) { if ( interval == null ) { return be before now ( ) ; } return be before ( interval . get start millis ( ) ) ; }
public boolean be after ( long millis instant ) { return ( get start millis ( ) > millis instant ) ; }
public long to duration millis ( ) { return field utils . safe add ( get end millis ( ) , -get start millis ( ) ) ; }
public duration to duration ( ) { long dur millis = to duration millis ( ) ; if ( dur millis == 0 ) { return duration . zero ; } else { return new duration ( dur millis ) ; } }
public date time field get field ( int index ) { return get field ( index , get chronology ( ) ) ; }
protect int index of support ( date time field type type ) { int index = index of ( type ) ; if ( index == -1 ) { throw new illegal argument exception ( `` field ' `` + type + `` ' be not support `` ) ; } return index ; }
public int [ ] get value ( ) { int [ ] result = new int [ size ( ) ] ; for ( int i = 0 ; i < result . length ; i++ ) { result [ i ] = get value ( i ) ; } return result ; }
public period to period to ( readable instant end instant ) { return new period ( this , end instant ) ; }
public long get end millis ( ) { return i end millis ; }
public duration to duration from ( readable instant start instant ) { long start millis = date time utils . get instant millis ( start instant ) ; chronology chrono = date time utils . get instant chronology ( start instant ) ; long end millis = chrono . add ( this , start millis , 1 ) ; return new duration ( start millis , end millis ) ; }
protect void add field ( duration field type field , int value ) { add field into ( i value , field , value ) ; }
public int get ( duration field type type ) { if ( type == get field type ( ) ) { return get value ( ) ; } return 0 ; }
public boolean equal ( object period ) { if ( this == period ) { return true ; } if ( period instanceof readable period == false ) { return false ; } readable period other = ( readable period ) period ; return ( other . get period type ( ) == get period type ( ) & & other . get value ( 0 ) == get value ( ) ) ; }
public int [ ] get ( readable period period , long start instant , long end instant ) { int size = period . size ( ) ; int [ ] value = new int [ size ] ; if ( start instant ! = end instant ) { for ( int i = 0 ; i < size ; i++ ) { duration field field = period . get field type ( i ) . get field ( this ) ; int value = field . get difference ( end instant , start instant ) ; if ( value ! = 0 ) { start instant = field . add ( start instant , value ) ; } value [ i ] = value ; } } return value ; }
public date time field clockhour of halfday ( ) { return unsupported date time field . get instance ( date time field type . clockhour of halfday ( ) , hour ( ) ) ; }
public date time field halfday of day ( ) { return unsupported date time field . get instance ( date time field type . halfday of day ( ) , halfdays ( ) ) ; }
public date time field month of year ( ) { return unsupported date time field . get instance ( date time field type . month of year ( ) , month ( ) ) ; }
public int get maximum text length ( locale locale ) { return g j locale symbol . for locale ( locale ) . get day of week max text length ( ) ; }
public chronology get chronology ( object object , chronology chrono ) { return date time utils . get chronology ( chrono ) ; }
public long get duration millis ( object object ) { return 0l ; }
public void set into ( read writable period duration , object object , chronology chrono ) { duration . set period ( ( period ) null ) ; }
public date midnight with duration add ( long duration to add , int scalar ) { if ( duration to add == 0 || scalar == 0 ) { return this ; } long instant = get chronology ( ) . add ( get millis ( ) , duration to add , scalar ) ; return with millis ( instant ) ; }
public local date to local date ( ) { return new local date ( get millis ( ) , get chronology ( ) ) ; }
public property year ( ) { return new property ( this , get chronology ( ) . year ( ) ) ; }
public date time with millis ( long new millis ) { return ( new millis == get millis ( ) ? this : new date time ( new millis , get chronology ( ) ) ) ; }
public date time with field ( date time field type field type , int value ) { if ( field type == null ) { throw new illegal argument exception ( `` field must not be null `` ) ; } long instant = field type . get field ( get chronology ( ) ) . set ( get millis ( ) , value ) ; return with millis ( instant ) ; }
public date time minus ( long duration ) { return with duration add ( duration , -1 ) ; }
public date midnight to date midnight ( ) { return new date midnight ( get millis ( ) , get chronology ( ) ) ; }
public static date time comparator get date only instance ( ) { return date_instance ; }
public static date time field type millis of second ( ) { return millis_of_second_type ; }
public static date time field type century of era ( ) { return century_of_era_type ; }
public static final chronology get chronology ( chronology chrono ) { if ( chrono == null ) { return i s o chronology . get instance ( ) ; } return chrono ; }
public static date time zone for offset hour minute ( int hour offset , int minute offset ) throw illegal argument exception { if ( hour offset == 0 & & minute offset == 0 ) { return date time zone . utc ; } if ( hour offset < -23 || hour offset > 23 ) { throw new illegal argument exception ( `` hour out of range : `` + hour offset ) ; } if ( minute offset < -59 || minute offset > 59 ) { throw new illegal argument exception ( `` minute out of range : `` + minute offset ) ; } if ( hour offset > 0 & & minute offset < 0 ) { throw new illegal argument exception ( `` positive hour must not have negative minute : `` + minute offset ) ; } int offset = 0 ; try { int hour in minute = hour offset * 60 ; if ( hour in minute < 0 ) { minute offset = hour in minute - math . ab ( minute offset ) ; } else { minute offset = hour in minute + minute offset ; } offset = field utils . safe multiply ( minute offset , date time constant . millis_per_minute ) ; } catch ( arithmetic exception ex ) { throw new illegal argument exception ( `` offset be too large `` ) ; } return for offset millis ( offset ) ; }
public string to string ( ) { return get i d ( ) ; }
public long get standard hour ( ) { return get millis ( ) / date time constant . millis_per_hour ; }
public static duration field type hour ( ) { return hours_type ; }
public static duration field type month ( ) { return months_type ; }
public interval to interval ( ) { date time field field = get field ( ) ; long start = field . round floor ( get millis ( ) ) ; long end = field . add ( start , 1 ) ; interval interval = new interval ( start , end ) ; return interval ; }
public int get maximum value ( readable partial instant ) { return get maximum value ( ) ; }
public long add ( long instant , int amount ) { return get wrapped field ( ) . add ( instant , amount * i divisor ) ; }
public int get range ( ) { return i range ; }
public long set ( long instant , int value ) { field utils . verify value bound ( this , value , get minimum value ( instant ) , get maximum value ( instant ) ) ; return super . set ( instant , value ) ; }
public static date time formatter short time ( ) { return create formatter for style index ( none , short ) ; }
public static date time formatter full date time ( ) { return create formatter for style index ( full , full ) ; }
public chronology get chronology ( ) { return i chrono ; }
public local time parse local time ( string text ) { return parse local date time ( text ) . to local time ( ) ; }
public static date time formatter date element parser ( ) { return constant . dpe ; }
public static date time formatter basic time ( ) { return constant . bt ; }
public static date time formatter basic time no millis ( ) { return constant . btx ; }
public static date time formatter hour minute second fraction ( ) { return constant . hmsf ; }
public static period formatter word base ( locale locale ) { period formatter pf = formatters . get ( locale ) ; if ( pf == null ) { resource bundle b = resource bundle . get bundle ( bundle_name , locale ) ; string [ ] variant = { b . get string ( `` period format . space `` ) , b . get string ( `` period format . comma `` ) , b . get string ( `` period format . commandand `` ) , b . get string ( `` period format . commaspaceand `` ) } ; pf = new period formatter builder ( ) . append year ( ) . append suffix ( b . get string ( `` period format . year `` ) , b . get string ( `` period format . year `` ) ) . append separator ( b . get string ( `` period format . commaspace `` ) , b . get string ( `` period format . spaceandspace `` ) , variant ) . append month ( ) . append suffix ( b . get string ( `` period format . month `` ) , b . get string ( `` period format . month `` ) ) . append separator ( b . get string ( `` period format . commaspace `` ) , b . get string ( `` period format . spaceandspace `` ) , variant ) . append week ( ) . append suffix ( b . get string ( `` period format . week `` ) , b . get string ( `` period format . week `` ) ) . append separator ( b . get string ( `` period format . commaspace `` ) , b . get string ( `` period format . spaceandspace `` ) , variant ) . append day ( ) . append suffix ( b . get string ( `` period format . day `` ) , b . get string ( `` period format . day `` ) ) . append separator ( b . get string ( `` period format . commaspace `` ) , b . get string ( `` period format . spaceandspace `` ) , variant ) . append hour ( ) . append suffix ( b . get string ( `` period format . hour `` ) , b . get string ( `` period format . hour `` ) ) . append separator ( b . get string ( `` period format . commaspace `` ) , b . get string ( `` period format . spaceandspace `` ) , variant ) . append minute ( ) . append suffix ( b . get string ( `` period format . minute `` ) , b . get string ( `` period format . minute `` ) ) . append separator ( b . get string ( `` period format . commaspace `` ) , b . get string ( `` period format . spaceandspace `` ) , variant ) . append second ( ) . append suffix ( b . get string ( `` period format . second `` ) , b . get string ( `` period format . second `` ) ) . append separator ( b . get string ( `` period format . commaspace `` ) , b . get string ( `` period format . spaceandspace `` ) , variant ) . append millis ( ) . append suffix ( b . get string ( `` period format . millisecond `` ) , b . get string ( `` period format . milliseconds `` ) ) . to formatter ( ) ; formatters . put if absent ( locale , pf ) ; } return pf ; }
public period formatter builder print zero always ( ) { i print zero set = print_zero_always ; return this ; }
public period formatter builder append day ( ) { append field ( day ) ; return this ; }
public period formatter builder append hour ( ) { append field ( hour ) ; return this ; }
public period formatter builder append second with millis ( ) { append field ( seconds_millis ) ; return this ; }
public date time field type get date time field type ( ) { return i date time field type ; }
public string get illegal string value ( ) { return i string value ; }
public string get illegal value a string ( ) { string value = i string value ; if ( value == null ) { value = string . value of ( i number value ) ; } return value ; }
public interval with start millis ( long start instant ) { if ( start instant == get start millis ( ) ) { return this ; } return new interval ( start instant , get end millis ( ) , get chronology ( ) ) ; }
public void set interval ( readable instant start , readable instant end ) { if ( start == null & & end == null ) { long now = date time utils . current time millis ( ) ; set interval ( now , now ) ; } else { long start millis = date time utils . get instant millis ( start ) ; long end millis = date time utils . get instant millis ( end ) ; chronology chrono = date time utils . get instant chronology ( start ) ; super . set interval ( start millis , end millis , chrono ) ; } }
public void set duration after start ( long duration ) { set end millis ( field utils . safe add ( get start millis ( ) , duration ) ) ; }
public void set period after start ( readable period period ) { if ( period == null ) { set end millis ( get start millis ( ) ) ; } else { set end millis ( get chronology ( ) . add ( period , get start millis ( ) , 1 ) ) ; } }
public void add hour ( int hour ) { super . add field ( duration field type . hour ( ) , hour ) ; }
public void set minute ( int minute ) { super . set field ( duration field type . minute ( ) , minute ) ; }
public partial with field ( date time field type field type , int value ) { int index = index of support ( field type ) ; if ( value == get value ( index ) ) { return this ; } int [ ] new value = get value ( ) ; new value = get field ( index ) . set ( this , index , new value , value ) ; return new partial ( this , new value ) ; }
public boolean be match ( readable partial partial ) { if ( partial == null ) { throw new illegal argument exception ( `` the partial must not be null `` ) ; } for ( int i = 0 ; i < i type . length ; i++ ) { int value = partial . get ( i type [ i ] ) ; if ( value ! = i value [ i ] ) { return false ; } } return true ; }
public period minus minute ( int minute ) { return plus minute ( -minutes ) ; }
public second to standard second ( ) { check year and month ( `` second `` ) ; long second = get millis ( ) / date time constant . millis_per_second ; second = field utils . safe add ( second , get second ( ) ) ; second = field utils . safe add ( second , ( ( long ) get minute ( ) ) * ( ( long ) date time constant . seconds_per_minute ) ) ; second = field utils . safe add ( second , ( ( long ) get hour ( ) ) * ( ( long ) date time constant . seconds_per_hour ) ) ; second = field utils . safe add ( second , ( ( long ) get day ( ) ) * ( ( long ) date time constant . seconds_per_day ) ) ; second = field utils . safe add ( second , ( ( long ) get week ( ) ) * ( ( long ) date time constant . seconds_per_week ) ) ; return second . second ( field utils . safe to int ( second ) ) ; }
public static period type year week day time ( ) { period type type = c y w d time ; if ( type == null ) { type = new period type ( `` year week day time `` , new duration field type [ ] { duration field type . year ( ) , duration field type . week ( ) , duration field type . day ( ) , duration field type . hour ( ) , duration field type . minute ( ) , duration field type . second ( ) , duration field type . millis ( ) , } , new int [ ] { 0 , -1 , 1 , 2 , 3 , 4 , 5 , 6 , } ) ; c y w d time = type ; } return type ; }
public static period type millis ( ) { period type type = c millis ; if ( type == null ) { type = new period type ( `` millis `` , new duration field type [ ] { duration field type . millis ( ) } , new int [ ] { -1 , -1 , -1 , -1 , -1 , -1 , -1 , 0 , } ) ; c millis = type ; } return type ; }
public period type with day remove ( ) { return with field remove ( 3 , `` no day `` ) ; }
public set < string > get available i d ( ) { return collection . singleton ( `` utc `` ) ; }
public static boolean verbose ( ) { return c verbose . get ( ) ; }
public void unregister from m bean notification ( ) { set < m bean server connection > server = get m bean server ( ) ; exception last exp = null ; string builder error = new string builder ( ) ; for ( m bean server connection server : server ) { try { jmx util . remove m bean registration listener ( server , this ) ; } catch ( illegal state exception e ) { last exp = update error msg ( error , e ) ; } } if ( last exp ! = null ) { throw new illegal state exception ( error . substring ( 0 , error . length ( ) -1 ) , last exp ) ; } }
public void destroy ( ) { unregister from m bean notification ( ) ; mbean server . destroy ( ) ; }
public string get server info ( ) { return mbean server . dump ( ) ; }
public string m bean server info ( ) { return m bean server manager . get server info ( ) ; }
public string dump ( ) { return server info . dump ( all m bean server ) ; }
public object extract object ( object to json converter p converter , object p value , stack < string > p path part , boolean jsonify ) throw attribute not find exception { collection collection = ( collection ) p value ; string path part = p path part . be empty ( ) ? null : p path part . pop ( ) ; int length = p converter . get collection length ( collection . size ( ) ) ; if ( path part ! = null ) { return extract with path ( p converter , collection , p path part , jsonify , path part , length ) ; } else { return jsonify ? extract list a json ( p converter , collection , p path part , length ) : collection ; } }
protect string get single string attribute ( m bean server executor p m bean server executor , string p m bean name , string p attribute ) { set < object name > server m bean name = search m bean ( p m bean server executor , p m bean name ) ; if ( server m bean name . size ( ) == 0 ) { return null ; } set < string > attribute value = new hash set < string > ( ) ; for ( object name o name : server m bean name ) { string val = get attribute value ( p m bean server executor , o name , p attribute ) ; if ( val ! = null ) { attribute value . add ( val ) ; } } if ( attribute value . size ( ) == 0 || attribute value . size ( ) > 1 ) { return null ; } return attribute value . iterator ( ) . next ( ) ; }
public string get vendor ( ) { return vendor ; }
public boolean be m bean pattern ( ) { return m bean . be pattern ( ) ; }
public synchronize int get global max entry ( ) { return global max entry ; }
public string get object name a string ( ) { return object name . get canonical name ( ) ; }
public void set max debug entry ( int p number ) { max debug entry = p number ; trim ( ) ; }
public static string repeat ( char ch , int count ) { string builder buffer = new string builder ( ) ; for ( int i = 0 ; i < count ; ++i ) buffer . append ( ch ) ; return buffer . to string ( ) ; }
public argument accept option spec < string > with require arg ( ) { argument accept option spec < string > new spec = new require argument option spec < > ( option ( ) , description ( ) ) ; parser . recognize ( new spec ) ; return new spec ; }
public option spec builder require unless ( string dependent , string . . . other dependent ) { list < string > dependent = validated dependent ( dependent , other dependent ) ; for ( string each : dependent ) { parser . require unless ( option ( ) , each ) ; } return this ; }
public static string unescape ( string string ) { int length = string . length ( ) ; string buffer sb = new string buffer ( ) ; for ( int i = 0 ; i < length ; ++i ) { char c = string . char at ( i ) ; if ( c == '+ ' ) { c = ' ' ; } else if ( c == ' % ' & & i + 2 < length ) { int d = j s o n tokener . dehexchar ( string . char at ( i + 1 ) ) ; int e = j s o n tokener . dehexchar ( string . char at ( i + 2 ) ) ; if ( d > = 0 & & e > = 0 ) { c = ( char ) ( d * 16 + e ) ; i += 2 ; } } sb . append ( c ) ; } return sb . to string ( ) ; }
public j s o n writer end array ( ) throw j s o n exception { return this . end ( ' a ' , ' ] ' ) ; }
public boolean be convert nil attribute to null ( ) { return this . convert nil attribute to null ; }
public static synchronize void set default ( default default ) { default = default ; }
public criterion ne ( object o ) { this . criterion type = relational operator . ne ; this . right = value node . to value node ( o ) ; return this ; }
public criterion lte ( object o ) { this . criterion type = relational operator . lte ; this . right = value node . to value node ( o ) ; return this ; }
public criterion noneof ( object . . . o ) { return subsetof ( arrays . a list ( o ) ) ; }
public json path config number return type ( number return type number return type ) { return new json path config ( number return type , default parser type , gson object mapper factory , jackson1 object mapper factory , jackson2 object mapper factory , johnzon object mapper factory , jsonb object mapper factory , default deserializer , charset ) ; }
public < t > t get object ( string path , type ref < t > type ref ) { assert parameter . not null ( `` object type `` , `` type ref `` ) ; return get object ( path , type ref . get type a class ( ) ) ; }
public json path param ( string key , object value ) { json path new p = new json path ( this , config ) ; if ( new p . params == null ) { new p . params = new hash map < string , object > ( ) ; } new p . params . put ( key , value ) ; return new p ; }
public static void check scheme ( final string scheme ) { scheme_checker . check ( scheme ) ; }
public final t get value ( ) { return value ; }
public process report validate schema ( final json node schema ) { final processing report report = new list process report ( ) ; return get result ( schema , report ) . get report ( ) ; }
public float a float obj ( ) { if ( current == null ) return null ; if ( current instanceof number ) { if ( current instanceof float ) return ( float ) current ; return float . value of ( ( ( number ) current ) . float value ( ) ) ; } return float . na n ; }
public j s o n navi < t > object ( ) { if ( failure ) return this ; if ( current == null & & readonly ) failure ( `` can not create object child in readonly `` , null ) ; if ( current ! = null ) { if ( be object ( ) ) return this ; if ( be array ( ) ) failure ( `` can not use object feature on array . `` , null ) ; failure ( `` can not use current possition a object `` , null ) ; } else { current = mapper . create object ( ) ; } if ( root == null ) root = ( t ) current ; else store ( ) ; return this ; }
public void object elm stop ( appendable out ) throw i o exception { }
public void array next elm ( appendable out ) throw i o exception { out . append ( ' , ' ) ; }
public object parse ( byte [ ] in ) throw parse exception { return get p byte ( ) . parse ( in ) ; }
public void register writer interface ( class < ? > inter face , json writer i < ? > writer ) { register writer interface last ( inter face , writer ) ; }
public string to j s o n string ( ) { return to j s o n string ( this , j s o n value . compression ) ; }
public boolean pass ( ) { return _success ; }
public boolean be unexpected on field ( ) { return ! _field unexpected . be empty ( ) ; }
public static boolean be whitespace ( int c ) { return c == ' ' || c == '\t ' || c == '\n ' || c == '\f ' || c == '\r ' ; }
public static string normalise whitespace ( string string ) { string builder sb = new string builder ( string . length ( ) ) ; append normalised whitespace ( sb , string , false ) ; return sb . to string ( ) ; }
public static void be true ( boolean val ) { if ( ! val ) throw new illegal argument exception ( `` must be true `` ) ; }
public tag tag ( ) { return tag ; }
public element child ( int index ) { return child ( ) . get ( index ) ; }
public element before ( node node ) { return ( element ) super . before ( node ) ; }
public element empty ( ) { child node . clear ( ) ; return this ; }
public element sibling element ( ) { if ( parent node == null ) return new element ( 0 ) ; list < element > element = parent ( ) . child ( ) ; element sibling = new element ( element . size ( ) - 1 ) ; for ( element el : element ) if ( el ! = this ) sibling . add ( el ) ; return sibling ; }
public element get element by attribute value start ( string key , string value prefix ) { return collector . collect ( new evaluator . attribute with value start ( key , value prefix ) , this ) ; }
public element get element by index less than ( int index ) { return collector . collect ( new evaluator . index less than ( index ) , this ) ; }
public element get element by index equal ( int index ) { return collector . collect ( new evaluator . index equal ( index ) , this ) ; }
public element get element match own text ( pattern pattern ) { return collector . collect ( new evaluator . match own ( pattern ) , this ) ; }
public string text ( ) { final string builder accum = new string builder ( ) ; new node traversor ( new node visitor ( ) { public void head ( node node , int depth ) { if ( node instanceof text node ) { text node text node = ( text node ) node ; append normalised text ( accum , text node ) ; } else if ( node instanceof element ) { element element = ( element ) node ; if ( accum . length ( ) > 0 & & ( element . be block ( ) || element . tag . get name ( ) . equal ( `` br `` ) ) & & ! text node . last char be whitespace ( accum ) ) accum . append ( `` `` ) ; } } public void tail ( node node , int depth ) { } } ) . traverse ( this ) ; return accum . to string ( ) . trim ( ) ; }
public document owner document ( ) { node root = root ( ) ; return ( root instanceof document ) ? ( document ) root : null ; }
public text node split text ( int offset ) { validate . be true ( offset > = 0 , `` split offset must be not be negative `` ) ; validate . be true ( offset < text . length ( ) , `` split offset must not be great than current text length `` ) ; string head = get whole text ( ) . substring ( 0 , offset ) ; string tail = get whole text ( ) . substring ( offset ) ; text ( head ) ; text node tail node = new text node ( tail , this . base uri ( ) ) ; if ( parent ( ) ! = null ) parent ( ) . add child ( sibling index ( ) +1 , tail node ) ; return tail node ; }
public int po ( ) { return po ; }
public string consume to ( char c ) { int offset = next index of ( c ) ; if ( offset ! = -1 ) { string consume = cache string ( pos , offset ) ; po += offset ; return consume ; } else { return consume to end ( ) ; } }
public string get error message ( ) { return error msg ; }
public string get name ( ) { return tag name ; }
public boolean be form list ( ) { return form list ; }
public boolean match ( string seq ) { return queue . region match ( true , po , seq , 0 , seq . length ( ) ) ; }
public string consume element selector ( ) { int start = po ; while ( ! be empty ( ) & & ( match word ( ) || match any ( `` * | `` , `` | `` , `` _ `` , `` - `` ) ) ) pos++ ; return queue . substring ( start , po ) ; }
public element attr ( string attribute key , string attribute value ) { for ( element element : this ) { element . attr ( attribute key , attribute value ) ; } return this ; }
public string text ( ) { string builder sb = new string builder ( ) ; for ( element element : this ) { if ( sb . length ( ) ! = 0 ) sb . append ( `` `` ) ; sb . append ( element . text ( ) ) ; } return sb . to string ( ) ; }
public element append ( string html ) { for ( element element : this ) { element . append ( html ) ; } return this ; }
public element before ( string html ) { for ( element element : this ) { element . before ( html ) ; } return this ; }
public boolean be ( string query ) { evaluator eval = query parser . parse ( query ) ; for ( element e : this ) { if ( e . be ( eval ) ) return true ; } return false ; }
public element prev all ( string query ) { return sibling ( query , false , true ) ; }
public static string builder borrow builder ( ) { synchronize ( builder ) { return builder . empty ( ) ? new string builder ( max cache builder size ) : builder . pop ( ) ; } }
public void normalize ( ) { for ( int i = 0 ; i < size ; i++ ) { key [ i ] = low case ( key [ i ] ) ; } }
public document parser ( parser parser ) { this . parser = parser ; return this ; }
public string normalize tag ( string name ) { name = name . trim ( ) ; if ( ! preserve tag case ) name = low case ( name ) ; return name ; }
public element next all ( ) { return sibling ( null , true , true ) ; }
public static void install ( ) { log manager . get log manager ( ) . get logger ( `` `` ) . add handler ( new s l f4 j bridge handler ( ) ) ; }
protect void run test ( ) throw throwable { try { super . run test ( ) ; } catch ( exception e ) { if ( f expect . be assignable from ( e . get class ( ) ) ) return ; else throw e ; } fail ( `` expect exception `` + f expect ) ; }
public void basic run ( test result result ) { f test . run ( result ) ; }
static public void assert equal ( float expect , float actual , float delta ) { assert equal ( null , expect , actual , delta ) ; }
public synchronize int error count ( ) { return f error . size ( ) ; }
protected class load suite class ( string suite class name ) throw class not find exception { return get loader ( ) . load ( suite class name ) ; }
public static string get filter trace ( throwable t ) { string writer string writer= new string writer ( ) ; print writer writer= new print writer ( string writer ) ; t . print stack trace ( writer ) ; string buffer buffer= string writer . get buffer ( ) ; string trace= buffer . to string ( ) ; return base test runner . get filtered trace ( trace ) ; }
public void clear ( ) { get model ( ) . clear ( ) ; }
public void end test ( test test ) { f model . add run test ( test ) ; fire test change ( test , false ) ; }
public j tree get tree ( ) { return f tree ; }
public int find test ( test target , test node , vector path ) { if ( target . equal ( node ) ) return 0 ; test suite suite= be test suite ( node ) ; for ( int i= 0 ; i < get child count ( node ) ; i++ ) { test t= suite . test at ( i ) ; int index= find test ( target , t , path ) ; if ( index > = 0 ) { path . insert element at ( node , 0 ) ; if ( path . size ( ) == 1 ) return i ; return index ; } } return -1 ; }
protect test result start ( string args [ ] ) throw exception { string test case= `` `` ; boolean wait= false ; for ( int i= 0 ; i < args . length ; i++ ) { if ( args [ i ] . equal ( `` -wait `` ) ) wait= true ; else if ( args [ i ] . equal ( `` -c `` ) ) test case= extract class name ( args [ ++i ] ) ; else if ( args [ i ] . equal ( `` -v `` ) ) system . err . println ( `` j unit `` + version . id ( ) + `` by kent beck and erich gamma `` ) ; else test case= args [ i ] ; } if ( test case . equal ( `` `` ) ) throw new exception ( `` usage : test runner [ -wait ] test case name , where name be the name of the test case class `` ) ; try { test suite= get test ( test case ) ; return do run ( suite , wait ) ; } catch ( exception e ) { throw new exception ( `` could not create and run test suite : `` +e ) ; } }
protect void set up ( ) throw exception { }
static public void assert equal ( string message , float expect , float actual , float delta ) { if ( float . compare ( expect , actual ) == 0 ) return ; if ( ! ( math . ab ( expect - actual ) < = delta ) ) fail not equal ( message , new float ( expect ) , new float ( actual ) ) ; }
public string get expect ( ) { return f expect ; }
public int test count ( ) { return f test . size ( ) ; }
static public void assert equal ( string message , object expect , object actual ) { if ( expect == null & & actual == null ) return ; if ( expect ! = null & & expect . equal ( actual ) ) return ; if ( expect instanceof string & & actual instanceof string ) throw new comparison failure ( message , ( string ) expect , ( string ) actual ) ; else fail not equal ( message , expect , actual ) ; }
static public void assert not null ( string message , object object ) { assert true ( message , object ! = null ) ; }
public void add child ( description description ) { get child ( ) . add ( description ) ; }
public result run ( class . . . class ) { return run ( request . class ( `` all `` , class ) ) ; }
public void test finish ( description description ) throw exception { }
public void fire test finish ( final description description ) { new safe notifier ( ) { @ override protect void notify listener ( run listener each ) throw exception { each . test finish ( description ) ; } ; } . run ( ) ; }
static public void assert not equal ( string message , long first , long second ) { assert not equal ( message , ( long ) first , ( long ) second ) ; }
public void expect ( class < ? extend throwable > type ) { expect ( instance of ( type ) ) ; }
public file new folder ( ) throw i o exception { return create temporary folder in ( get root ( ) ) ; }
protect void fail ( throwable e , description description ) { }
public string get name ( ) { return f method . get name ( ) ; }
public boolean produce type ( type type ) { return get parameter type ( ) . length == 0 & & type instanceof class < ? > & & ( ( class < ? > ) type ) . be assignable from ( f method . get return type ( ) ) ; }
public runner safe runner for class ( class < ? > test class ) { try { return runner for class ( test class ) ; } catch ( throwable e ) { return new error reporting runner ( test class , e ) ; } }
public list < framework field > get annotate field ( class < ? extend annotation > annotation class ) { return get annotated member ( f field for annotation , annotation class ) ; }
public string exception message ( ) { return throw exception ( ) . get message ( ) ; }
static public void assert not equal ( string message , double unexpected , double actual , double delta ) { if ( ! double be different ( unexpected , actual , delta ) ) { fail equal ( message , double . value of ( actual ) ) ; } }
public void expect cause ( matcher < ? extend throwable > expect cause ) { expect ( have cause ( expect cause ) ) ; }
public void test failure ( failure failure ) throw exception { }
public boolean be public ( ) { return modifier . be public ( get modifier ( ) ) ; }
public class < ? > get declare class ( ) { return method . get declare class ( ) ; }
public long get timeout ( ) { return timeout ; }
public void apply ( object target ) throw invalid order exception { if ( target instanceof orderable ) { orderable orderable = ( orderable ) target ; orderable . order ( this ) ; } }
public void apply ( object target ) { / * * note that all runner that be orderable be also sortable ( because * orderable extends sortable ) . sort be more efficient than order , * so we override the parent behavior so we sort instead . * / if ( target instanceof sortable ) { sortable sortable = ( sortable ) target ; sortable . sort ( this ) ; } }
public void fire test suite start ( final description description ) { new safe notifier ( ) { @ override protect void notify listener ( run listener each ) throw exception { each . test suite start ( description ) ; } } . run ( ) ; }
public runner safe runner for class ( class < ? > test class ) { try { runner runner = runner for class ( test class ) ; if ( runner ! = null ) { configure runner ( runner ) ; } return runner ; } catch ( throwable e ) { return new error reporting runner ( test class , e ) ; } }
public static < t > matcher < t > equal to ( t operand ) { return new be equal < t > ( operand ) ; }
public static optional < string > get module version ( class < ? > type ) { return optional . empty ( ) ; }
public static boolean be array ( object obj ) { return ( obj ! = null & & obj . get class ( ) . be array ( ) ) ; }
public static set < class < ? > > get all assignment compatible class ( class < ? > clazz ) { precondition . not null ( clazz , `` class must not be null `` ) ; set < class < ? > > result = new link hash set < > ( ) ; get all assignment compatible class ( clazz , result ) ; return result ; }
public string get nested class name ( ) { return nest class selector . get nested class name ( ) ; }
public void remove appender ( final appender appender ) { synchronize ( appenders ) { appenders . remove appender ( appender ) ; } }
public void set location info ( final boolean flag ) { location info = flag ; }
public int get buffer size ( ) { return buffer size ; }
public void set conversion pattern ( final string conversion pattern ) { this . conversion pattern = option converter . convert special char ( conversion pattern ) ; head = create pattern parser ( this . conversion pattern ) . parse ( ) ; if ( head instanceof bridge pattern converter ) { handles exception = ! ( ( bridge pattern converter ) head ) . ignores throwable ( ) ; } else { handle exception = false ; } }
public string format ( final logging event event ) { string buffer buf = new string buffer ( ) ; for ( pattern converter c = head ; c ! = null ; c = c . next ) { c . format ( buf , event ) ; } return buf . to string ( ) ; }
protect string get log statement ( log event event ) { return get layout ( ) . format ( event ) ; }
public void finalize ( ) { close ( ) ; }
public string get message ( ) { return ( _message ) ; }
public string get thread description ( ) { return ( _thread ) ; }
public void set n d c ( string ndc ) { _ndc = ndc ; }
public void log ( string category , log level level , string message , string ndc ) { log ( category , level , message , null , ndc ) ; }
public int size ( ) { int count = _category element . size ( ) ; return ( count ) ; }
public void remove all category element ( ) { _category element . clear ( ) ; }
public boolean be trace enable ( ) { if ( repository . be disabled ( level . trace_int ) ) { return false ; } return level . trace . be great or equal ( this . get effective level ( ) ) ; }
public static void warn ( final logger logger , final string pattern , final object [ ] argument ) { if ( logger . be enable for ( level . warn ) ) { force log ( logger , level . warn , format ( pattern , argument ) ) ; } }
protect static byte value of ( final byte b ) { return new byte ( b ) ; }
public void set initial context factory name ( string initial context factory name ) { this . initial context factory name = initial context factory name ; }
public void set bcc ( final string address ) { this . bcc = address ; }
public void set reconnection delay ( int delay ) { this . reconnection delay = delay ; }
protect server socket create server socket ( final int socket port ) throw i o exception { return new server socket ( socket port ) ; }
public boolean require layout ( ) { return true ; }
protect void append ( log event event ) { if ( sh ! = null ) { sh . send ( layout . format ( event ) ) ; if ( layout . ignores throwable ( ) ) { string [ ] s = event . get throwable str rep ( ) ; if ( s ! = null ) { string buffer buf = new string buffer ( ) ; for ( int i = 0 ; i < s . length ; i++ ) { buf . append ( s [ i ] ) ; buf . append ( `` \r\n `` ) ; } sh . send ( buf . to string ( ) ) ; } } } }
public date parse ( string s , parse position po ) { return formatter . parse ( s , po ) ; }
public int get max length ( ) { return max length ; }
protect final void abbreviate ( final int name start , final string buffer buf ) { abbreviator . abbreviate ( name start , buf ) ; }
public void set location info ( boolean flag ) { location info = flag ; }
public static closeable thread context . instance push ( final string message ) { return new closeable thread context . instance ( ) . push ( message ) ; }
public static void log event ( final structure data message msg , final level level ) { logger . log if enable ( fqcn , level , event_marker , msg , null ) ; }
public boolean be in range ( final level min level , final level max level ) { return this . int level > = min level . int level & & this . int level < = max level . int level ; }
public static level [ ] value ( ) { final collection < level > value = level . level . value ( ) ; return value . to array ( new level [ value . size ( ) ] ) ; }
public static level value of ( final string name ) { object . require non null ( name , `` no level name give . `` ) ; final string level name = to upper case ( name ) ; final level level = level . get ( level name ) ; if ( level ! = null ) { return level ; } throw new illegal argument exception ( `` unknown level constant [ `` + level name + `` ] . `` ) ; }
protect static logger context get context ( final string fqcn , final boolean current context ) { try { return factory . get context ( fqcn , null , null , current context ) ; } catch ( final illegal state exception ex ) { logger . warn ( ex . get message ( ) + `` use simple logger `` ) ; return new simple logger context factory ( ) . get context ( fqcn , null , null , current context ) ; } }
public static logger get formatter logger ( final class < ? > clazz ) { return get logger ( clazz ! = null ? clazz : stack locator util . get caller class ( 2 ) , string formatter message factory . instance ) ; }
public static logger get formatter logger ( final string name ) { return name == null ? get formatter logger ( stack locator util . get caller class ( 2 ) ) : get logger ( name , string formatter message factory . instance ) ; }
public static marker get marker ( final string name , final marker parent ) { return get marker ( name ) . add parent ( parent ) ; }
public string get format ( ) { return message pattern ; }
public string get format ( ) { return message pattern ; }
public structure data id make id ( final structure data id id ) { if ( id == null ) { return this ; } return make id ( id . get name ( ) , id . get enterprise number ( ) ) ; }
public string [ ] get require ( ) { return require ; }
public string a string ( ) { return a string ( format . full , null ) ; }
public log builder at warn ( ) { return at level ( level . warn ) ; }
public log builder at level ( level level ) { if ( be enable ( level ) ) { return ( get log builder ( level ) . reset ( level ) ) ; } else { return log builder . noop ; } }
public set < logger context > get logger context ( ) { return new hash set < > ( registry . key set ( ) ) ; }
public boolean be enable ( final level level , final marker marker , final message message , final throwable t ) { return logger . be enable ( level , marker , message , t ) ; }
public boolean have logger ( final string name , final message factory message factory ) { return get or create inner map ( factory key ( message factory ) ) . contains key ( name ) ; }
public url get url ( ) { return url ; }
public long get timestamp ( ) { return timestamp ; }
public level get level ( ) { return level ; }
public static void remove ( final string key ) { context map . remove ( key ) ; }
public static context stack get immutable stack ( ) { final context stack result = context stack . get immutable stack or null ( ) ; return result == null ? empty_stack : result ; }
public string get file name ( ) { return this . file name ; }
public string get name ( ) { return name ; }
public final synchronize void write ( final log event event ) { write ( event , null ) ; }
public int get buffer size ( ) { return buffer size ; }
public static < b extend builder < b > > b new builder ( ) { return new builder < b > ( ) . a builder ( ) ; }
public boolean be complete ( ) { return complete ; }
public boolean be recent first ( ) { return recent first ; }
public pattern processor get pattern processor ( ) { return pattern processor ; }
public string get file name ( ) { return file name ; }
public abstract script get pattern script ( ) { return pattern script ; }
public void append ( final log event event ) { manager . send event ( get layout ( ) , event ) ; }
public < v > schedule future < v > schedule ( final callable < v > callable , final long delay , final time unit unit ) { return get executor service ( ) . schedule ( callable , delay , unit ) ; }
public schedule future < ? > schedule at fix rate ( final runnable command , final long initial delay , final long period , final time unit unit ) { return get executor service ( ) . schedule at fix rate ( command , initial delay , period , unit ) ; }
public long get last modified ( ) { return last modify ; }
public input stream get input stream ( ) { return stream ; }
public list < appender ref > get appender ref ( ) { return appender ref ; }
public void log ( final log event event ) { log ( event , logger config predicate . all ) ; }
public int size ( ) { return category . size ( ) ; }
public static plugin registry get instance ( ) { plugin registry result = instance ; if ( result == null ) { synchronize ( instance_lock ) { result = instance ; if ( result == null ) { instance = result = new plugin registry ( ) ; } } } return result ; }
protect void add if matching ( final test test , final string fqn ) { try { final class loader loader = get class loader ( ) ; if ( test . do match class ( ) ) { final string external name = fqn . substring ( 0 , fqn . index of ( ' . ' ) ) . replace ( '/ ' , ' . ' ) ; if ( logger . be debug enable ( ) ) { logger . debug ( `` checking to see if class { } match criterion { } `` , external name , test ) ; } final class < ? > type = loader . load class ( external name ) ; if ( test . match ( type ) ) { class match . add ( type ) ; } } if ( test . do match resource ( ) ) { url url = loader . get resource ( fqn ) ; if ( url == null ) { url = loader . get resource ( fqn . substring ( 1 ) ) ; } if ( url ! = null & & test . match ( url . to u r i ( ) ) ) { resource match . add ( url . to u r i ( ) ) ; } } } catch ( final throwable t ) { logger . warn ( `` could not examine class { } `` , fqn , t ) ; } }
public status configuration with status ( final string status ) { this . status = level . to level ( status , null ) ; if ( this . status == null ) { this . error ( `` invalid status level specify : `` + status + `` . default to error . `` ) ; this . status = level . error ; } return this ; }
public void initialize ( ) { if ( ! this . initialize ) { if ( this . status == level . off ) { this . initialized = true ; } else { final boolean configure = configure exist status console listener ( ) ; if ( ! configure ) { register new status console listener ( ) ; } migrate saved log message ( ) ; } } }
public list < filter > get filter ( ) { return array . a list ( filter ) ; }
public string get extend stack trace a string ( ) { return this . get extended stack trace a string ( null , plain text renderer . get instance ( ) , string . empty , eol_str ) ; }
public byte [ ] get header ( ) { final string builder sbuf = new string builder ( ) ; append ( sbuf , `` < ! doctype html public \ `` -//w3c//dtd html 4 . 01 transitional// e n\ `` `` ) ; append l ( sbuf , `` \ `` http : //www . w3 . org/ t r/html4/loose . dtd\ `` > `` ) ; append l ( sbuf , `` < html > `` ) ; append l ( sbuf , `` < head > `` ) ; append ( sbuf , `` < meta charset=\ `` `` ) ; append ( sbuf , get charset ( ) . to string ( ) ) ; append l ( sbuf , `` \ `` / > `` ) ; append ( sbuf , `` < title > `` ) . append ( title ) ; append l ( sbuf , `` < /title > `` ) ; append l ( sbuf , `` < style type=\ `` text/css\ `` > `` ) ; append l ( sbuf , `` < ! -- `` ) ; append ( sbuf , `` body , table { font-family : `` ) . append ( font ) . append ( `` ; font-size : `` ) ; append l ( sbuf , header size ) . append ( `` ; } `` ) ; append l ( sbuf , `` th { background : # 336699 ; color : # ffffff ; text-align : left ; } `` ) ; append l ( sbuf , `` -- > `` ) ; append l ( sbuf , `` < /style > `` ) ; append l ( sbuf , `` < /head > `` ) ; append l ( sbuf , `` < body bgcolor=\ `` # ffffff\ `` topmargin=\ `` 6\ `` leftmargin=\ `` 6\ `` > `` ) ; append l ( sbuf , `` < hr size=\ `` 1\ `` noshade=\ `` noshade\ `` > `` ) ; append l ( sbuf , `` log session start time `` + new java . util . date ( ) + `` < br > `` ) ; append l ( sbuf , `` < br > `` ) ; append l ( sbuf , `` < table cellspacing=\ `` 0\ `` cellpadding=\ `` 4\ `` border=\ `` 1\ `` bordercolor=\ `` # 224466\ `` width=\ `` 100 % \ `` > `` ) ; append l ( sbuf , `` < tr > `` ) ; append l ( sbuf , `` < th > time < /th > `` ) ; append l ( sbuf , `` < th > thread < /th > `` ) ; append l ( sbuf , `` < th > level < /th > `` ) ; append l ( sbuf , `` < th > logger < /th > `` ) ; if ( location info ) { append l ( sbuf , `` < th > file : line < /th > `` ) ; } append ls ( sbuf , `` < th > message < /th > `` ) ; append l ( sbuf , `` < /tr > `` ) ; return sbuf . to string ( ) . get byte ( get charset ( ) ) ; }
public log event to serializable ( final log event event ) { return event ; }
public static abstract jackson layout create default layout ( ) { return new yaml layout ( new default configuration ( ) , false , false , false , false , false , null , default_header , default_footer , standard charsets . utf_8 , true , false , false , null ) ; }
protect void update configuration ( final configuration new config ) { this . private config = new private config ( new config , this ) ; }
public logger get root logger ( ) { return get logger ( log manager . root_logger_name ) ; }
public void update logger ( ) { update logger ( this . configuration ) ; }
public int get value ( ) { return to priority ( facility , severity ) ; }
public boolean be equal ( final string name ) { return this . name ( ) . equal ignore case ( name ) ; }
public static void set host resolver ( host resolver resolver ) { tcp socket manager factory . resolver = resolver ; }
public string get pattern ( ) { return formatter . to pattern ( ) ; }
public boolean require location ( ) { return converter instanceof location aware & & ( ( location aware ) converter ) . require location ( ) ; }
public string get format ( ) { return fix format . get pattern ( ) ; }
public static int parse int ( final string s , final int default value ) { return string . be empty ( s ) ? default value : integer . parse int ( s ) ; }
public static class loader get class loader ( ) { return get class loader ( loader . class , null ) ; }
public static string [ ] prefix set ( final set < string > set , final string prefix ) { final set < string > prefix set = new hash set < > ( ) ; for ( final string str : set ) { if ( str . start with ( prefix ) ) { prefix set . add ( str ) ; } } return prefix set . to array ( new string [ prefix set . size ( ) ] ) ; }
public void unwatch file ( final file file ) { source source = new source ( file ) ; unwatch ( source ) ; }
public void format ( final object obj , final string builder to append to ) { format ( to append to ) ; }
public logger exists ( string name ) { return ( logger ) logger cache . get ( name ) ; }
public string get queue connection factory binding name ( ) { return qcf bind name ; }
protect topic publisher get topic publisher ( ) { return topic publisher ; }
public string convert ( i log event event ) { return event . get logger context v o ( ) . get name ( ) ; }
public void set logger context ( logger context context ) { super . set context ( context ) ; }
public void reset turbo filter list ( ) { for ( turbo filter tf : turbo filter list ) { tf . stop ( ) ; } turbo filter list . clear ( ) ; }
public list < string > get framework package ( ) { return framework package ; }
protect server socket factory get server socket factory ( ) throw exception { return server socket factory . get default ( ) ; }
protect string get client thread name ( socket socket ) { return string . format ( `` logback socket node ( client : % s ) `` , socket . get remote socket address ( ) ) ; }
public list < string > get framework package ( ) { return framework package ; }
public void set logger context ( logger context context ) { super . set context ( context ) ; }
public void discover connnection property ( ) { try { connection connection = get connection ( ) ; if ( connection == null ) { add warn ( `` could not get a connection `` ) ; return ; } database meta data meta = connection . get meta data ( ) ; d b util util = new d b util ( ) ; util . set context ( get context ( ) ) ; support get generate key = util . support get generate key ( meta ) ; support batch update = util . support batch update ( meta ) ; dialect code = d b util . discover s q l dialect ( meta ) ; add info ( `` driver name= `` +meta . get driver name ( ) ) ; add info ( `` driver version= `` +meta . get driver version ( ) ) ; add info ( `` support get generate keys= `` +supports get generate key ) ; } catch ( s q l exception se ) { add warn ( `` could not discover the dialect to use . `` , se ) ; } }
public void start ( ) { int error count = 0 ; try { parser < e > p = new parser < e > ( pattern ) ; p . set context ( get context ( ) ) ; node t = p . parse ( ) ; this . head = p . compile ( t , get effective converter map ( ) ) ; converter util . start converter ( this . head ) ; } catch ( scan exception ex ) { add error ( `` incorrect pattern find `` , ex ) ; error count++ ; } if ( error count == 0 ) { super . start = true ; } }
public string get title ( ) { return title ; }
public static object convert arg ( context aware ca , string val , class < ? > type ) { if ( val == null ) { return null ; } string v = val . trim ( ) ; if ( string . class . be assignable from ( type ) ) { return v ; } else if ( integer . type . be assignable from ( type ) ) { return new integer ( v ) ; } else if ( long . type . be assignable from ( type ) ) { return new long ( v ) ; } else if ( float . type . be assignable from ( type ) ) { return new float ( v ) ; } else if ( double . type . be assignable from ( type ) ) { return new double ( v ) ; } else if ( boolean . type . be assignable from ( type ) ) { if ( `` true `` . equal ignore case ( v ) ) { return boolean . true ; } else if ( `` false `` . equal ignore case ( v ) ) { return boolean . false ; } } else if ( type . be enum ( ) ) { return convert to enum ( ca , v , ( class < ? extend enum > ) type ) ; } else if ( string to object converter . follow the value of convention ( type ) ) { return convert by value of method ( ca , type , v ) ; } else if ( be of type charset ( type ) ) { return convert to charset ( ca , val ) ; } return null ; }
public void start ( ) { int error count = 0 ; if ( port == 0 ) { error count++ ; add error ( `` no port be configure for appender `` + name + `` for more information , please visit http : //logback . qos . ch/codes . html # socket_no_port `` ) ; } if ( address == null ) { error count++ ; add error ( `` no remote address be configure for appender `` + name + `` for more information , please visit http : //logback . qos . ch/codes . html # socket_no_host `` ) ; } connect ( address , port ) ; if ( error count == 0 ) { this . start = true ; } }
public int get port ( ) { return port ; }
static public int facility string toint ( string facility str ) { if ( `` kern `` . equal ignore case ( facility str ) ) { return syslog constant . log_kern ; } else if ( `` user `` . equal ignore case ( facility str ) ) { return syslog constant . log_user ; } else if ( `` mail `` . equal ignore case ( facility str ) ) { return syslog constant . log_mail ; } else if ( `` daemon `` . equal ignore case ( facility str ) ) { return syslog constant . log_daemon ; } else if ( `` auth `` . equal ignore case ( facility str ) ) { return syslog constant . log_auth ; } else if ( `` syslog `` . equal ignore case ( facility str ) ) { return syslog constant . log_syslog ; } else if ( `` lpr `` . equal ignore case ( facility str ) ) { return syslog constant . log_lpr ; } else if ( `` news `` . equal ignore case ( facility str ) ) { return syslog constant . log_news ; } else if ( `` uucp `` . equal ignore case ( facility str ) ) { return syslog constant . log_uucp ; } else if ( `` cron `` . equal ignore case ( facility str ) ) { return syslog constant . log_cron ; } else if ( `` authpriv `` . equal ignore case ( facility str ) ) { return syslog constant . log_authpriv ; } else if ( `` ftp `` . equal ignore case ( facility str ) ) { return syslog constant . log_ftp ; } else if ( `` local0 `` . equal ignore case ( facility str ) ) { return syslog constant . log_local0 ; } else if ( `` local1 `` . equal ignore case ( facility str ) ) { return syslog constant . log_local1 ; } else if ( `` local2 `` . equal ignore case ( facility str ) ) { return syslog constant . log_local2 ; } else if ( `` local3 `` . equal ignore case ( facility str ) ) { return syslog constant . log_local3 ; } else if ( `` local4 `` . equal ignore case ( facility str ) ) { return syslog constant . log_local4 ; } else if ( `` local5 `` . equal ignore case ( facility str ) ) { return syslog constant . log_local5 ; } else if ( `` local6 `` . equal ignore case ( facility str ) ) { return syslog constant . log_local6 ; } else if ( `` local7 `` . equal ignore case ( facility str ) ) { return syslog constant . log_local7 ; } else { throw new illegal argument exception ( facility str + `` be not a valid syslog facility string `` ) ; } }
public string get date pattern ( ) { return date pattern ; }
public void set max history ( int max history ) { this . max history = max history ; }
public static boolean to boolean ( string value , boolean d efault ) { if ( value == null ) { return d efault ; } string trim val = value . trim ( ) ; if ( `` true `` . equal ignore case ( trim val ) ) { return true ; } if ( `` false `` . equal ignore case ( trim val ) ) { return false ; } return d efault ; }
public bean description get bean description ( class < ? > clazz ) { if ( ! class to bean description . contains key ( clazz ) ) { bean description bean description = get bean description factory ( ) . create ( clazz ) ; class to bean description . put ( clazz , bean description ) ; } return class to bean description . get ( clazz ) ; }
public int get client queue size ( ) { return client queue size ; }
public string get provider ( ) { return provider ; }
public void set password ( string password ) { this . password = password ; }
public s s l parameter configuration get parameter ( ) { if ( parameter == null ) { parameter = new s s l parameter configuration ( ) ; } return parameter ; }
public void set key manager factory ( key manager factory factory bean key manager factory ) { this . key manager factory = key manager factory ; }
public string get exclude protocol ( ) { return exclude protocol ; }
public void detach and stop all appenders ( ) { for ( appender < e > a : appender list ) { a . stop ( ) ; } appender list . clear ( ) ; }
public static void retain matching ( collection < string > value , string . . . pattern ) { retain matching ( value , array . a list ( pattern ) ) ; }
public static void remove matching ( collection < string > value , string . . . pattern ) { remove matching ( value , array . a list ( pattern ) ) ; }
public static void main ( string [ ] args ) { system . out . println ( `` fast instance be `` + fast instance ( ) ) ; system . out . println ( `` fast java instance be `` + fast java instance ( ) ) ; }
public void set password ( string password ) { this . password = password ; }
public string get content ( ) { return content ; }
public project segment find by maven project ( maven project maven project ) { for ( project segment project build : item ) { if ( maven project . equal ( project build . get project ( ) ) ) { return project build ; } } return null ; }
public void set class realm ( class realm class realm ) { this . class realm = class realm ; }
public void set extension dependency filter ( dependency filter extension dependency filter ) { this . extension dependency filter = extension dependency filter ; }
public void set resolve artifact ( set < artifact > artifact ) { this . resolve artifact = ( artifacts ! = null ) ? artifact : collection . < artifact > empty set ( ) ; this . artifacts = null ; this . artifact map = null ; }
public void set artifact filter ( artifact filter artifact filter ) { this . artifact filter = artifact filter ; this . artifacts = null ; this . artifact map = null ; }
public boolean get add default entity ( ) { return add default entity ; } // -- boolean get add default entity ( )
public string get group id ( ) { return this . group id ; } // -- string get group id ( )
public void set artifact id ( string artifact id ) { this . artifact id = artifact id ; } // -- void set artifact id ( string )
public command line exception get execution exception ( ) { return execution exception ; }
public file get maven home ( ) { return maven home ; }
public activation o s get os ( ) { return this . o ; } // -- activation o s get os ( )
public void set version ( string version ) { this . version = version ; } // -- void set version ( string )
public void set output directory ( string output directory ) { this . output directory = output directory ; } // -- void set output directory ( string )
public void set name ( string name ) { this . name = name ; } // -- void set name ( string )
public string get classifier ( ) { return this . classifier ; } // -- string get classifier ( )
public string get id ( ) { return this . id ; } // -- string get id ( )
public string get status ( ) { return this . status ; } // -- string get status ( )
public void set site ( site site ) { this . site = site ; } // -- void set site ( site )
public string get artifact id ( ) { return this . artifact id ; } // -- string get artifact id ( )
public build get build ( ) { return this . build ; } // -- build get build ( )
public string get description ( ) { return this . description ; } // -- string get description ( )
public organization get organization ( ) { return this . organization ; } // -- organization get organization ( )
public void set artifact id ( string artifact id ) { this . artifact id = artifact id ; } // -- void set artifact id ( string )
public void set build ( build build ) { this . build = build ; } // -- void set build ( build )
public void set license ( java . util . list < license > license ) { this . license = license ; } // -- void set license ( java . util . list )
public void set packaging ( string packaging ) { this . packaging = packaging ; } // -- void set packaging ( string )
public void set url ( string url ) { this . url = url ; } // -- void set url ( string )
public void set property ( java . util . property property ) { this . property = property ; } // -- void set property ( java . util . property )
public void set report ( object report ) { this . report = report ; } // -- void set report ( object )
public string get name ( ) { return this . name ; } // -- string get name ( )
public void set dependency ( java . util . list < dependency > dependency ) { this . dependency = dependency ; } // -- void set dependency ( java . util . list )
public string get group id ( ) { return this . group id ; } // -- string get group id ( )
public string get group id ( ) { return this . group id ; } // -- string get group id ( )
public void set report set ( java . util . list < report set > report set ) { this . report set = report set ; } // -- void set report set ( java . util . list )
public void set id ( string id ) { this . id = id ; } // -- void set id ( string )
public repository policy get release ( ) { return this . release ; } // -- repository policy get release ( )
public void set connection ( string connection ) { this . connection = connection ; } // -- void set connection ( string )
public void set url ( string url ) { this . url = url ; } // -- void set url ( string )
public model build result get result ( ) { return result ; }
public void set lifecycles ( java . util . list < lifecycle > lifecycles ) { this . lifecycles = lifecycles ; } // -- void set lifecycles ( java . util . list )
public void set versioning ( versioning versioning ) { this . versioning = versioning ; } // -- void set versioning ( versioning )
public string get extension ( ) { return this . extension ; } // -- string get extension ( )
public string get late ( ) { return this . late ; } // -- string get late ( )
public void set snapshot ( snapshot snapshot ) { this . snapshot = snapshot ; } // -- void set snapshot ( snapshot )
public collect request get request ( ) { return request ; }
public list < exception > get exception ( ) { return exception ; }
public list < dependency cycle > get cycle ( ) { return cycle ; }
public dependency management set scope ( string scope ) { this . scope = scope ; return this ; }
public deploy request add artifact ( artifact artifact ) { if ( artifact ! = null ) { if ( artifact . be empty ( ) ) { artifact = new array list < artifact > ( ) ; } artifacts . add ( artifact ) ; } return this ; }
public deploy request set metadata ( collection < metadata > metadata ) { if ( metadata == null ) { this . metadata = collection . empty list ( ) ; } else { this . metadata = metadata ; } return this ; }
public artifact get artifact ( ) { return artifact ; }
public string get artifact id ( ) { return artifact id ; }
public collection < metadata > get metadata ( ) { return metadata ; }
public artifact get artifact ( ) { return artifact ; }
public remote repository get repository ( ) { return repository ; }
public local artifact request get request ( ) { return request ; }
public local metadata result set file ( file file ) { this . file = file ; return this ; }
public authentication get authentication ( ) { return auth ; }
public string get url ( ) { return url ; }
public string get checksum policy ( ) { return checksum policy ; }
public list < remote repository > get repository ( ) { return repository ; }
public artifact descriptor result set repository ( artifact repository repository ) { this . repository = repository ; return this ; }
public artifact descriptor result set dependency ( list < dependency > dependency ) { if ( dependency == null ) { this . dependency = collection . empty list ( ) ; } else { this . dependency = dependency ; } return this ; }
public list < dependency > get manage dependency ( ) { return manage dependency ; }
public list < remote repository > get repository ( ) { return repository ; }
public artifact result set repository ( artifact repository repository ) { this . repository = repository ; return this ; }
public dependency request set root ( dependency node root ) { this . root = root ; return this ; }
public boolean be delete local copy if miss ( ) { return delete local copy if miss ; }
public metadata request set delete local copy if miss ( boolean delete local copy if miss ) { this . delete local copy if miss = delete local copy if miss ; return this ; }
public boolean be miss ( ) { return get exception ( ) instanceof metadata not find exception ; }
public version range result add exception ( exception exception ) { if ( exception ! = null ) { if ( exception . be empty ( ) ) { exception = new array list < exception > ( ) ; } exception . add ( exception ) ; } return this ; }
public artifact get artifact ( ) { return artifact ; }
public version result get result ( ) { return result ; }
public remote repository get repository ( ) { return repository ; }
public long get resume offset ( ) { return resume offset ; }
public string get version ( ) { return version ; }
public artifact transfer exception get exception ( ) { return exception ; }
public transfer listener get listener ( ) { return listener ; }
public string get data string ( ) { if ( data file ! = null || data byte == null ) { return `` `` ; } return new string ( data byte . to byte array ( ) , standard charsets . utf_8 ) ; }
public static object get object ( repository system session session , object default value , string . . . key ) { return get object ( session . get config property ( ) , default value , key ) ; }
public static version filter new instance ( version filter . . . filter ) { if ( filter . length < = 1 ) { if ( filter . length < = 0 ) { return null ; } return filter [ 0 ] ; } return new chain version filter ( filter . clone ( ) ) ; }
public list < artifact > get artifact ( boolean include unresolved ) { list < artifact > artifacts = new array list < artifact > ( get node ( ) . size ( ) ) ; for ( dependency node node : get node ( ) ) { if ( node . get dependency ( ) ! = null ) { artifact artifact = node . get dependency ( ) . get artifact ( ) ; if ( include unresolved || artifact . get file ( ) ! = null ) { artifact . add ( artifact ) ; } } } return artifact ; }
public authentication builder add secret ( string key , char [ ] value ) { if ( value ! = null ) { authentication . add ( new secret authentication ( key , value ) ) ; } return this ; }
public authentication builder add custom ( authentication authentication ) { if ( authentication ! = null ) { authentication . add ( authentication ) ; } return this ; }
public default proxy selector add ( proxy proxy , string non proxy host ) { require non null ( proxy , `` proxy can not be null `` ) ; proxy . add ( new proxy def ( proxy , non proxy host ) ) ; return this ; }
public activation o s get os ( ) { return this . o ; } // -- activation o s get os ( )
public string get name ( ) { return this . name ; } // -- string get name ( )
public void set version ( string version ) { this . version = version ; } // -- void set version ( string )
public string get password ( ) { return this . password ; } // -- string get password ( )
public string get private key ( ) { return this . private key ; } // -- string get private key ( )
public boolean be interactive mode ( ) { return this . interactive mode ; } // -- boolean be interactive mode ( )
public void set local repository ( string local repository ) { this . local repository = local repository ; } // -- void set local repository ( string )
public arg create arg ( boolean insert at start ) { arg argument = new argument ( ) ; if ( insert at start ) { argument . add ( 0 , argument ) ; } else { argument . add ( argument ) ; } return argument ; }
public commandline get commandline ( ) { return commandline ; }
public void set exit code ( int exit code ) { this . exit code = exit code ; }
public static message builder buffer ( int size ) { return jansi ? new ansi message builder ( size ) : new plain message builder ( size ) ; }
public static void write line break ( x m l writer writer ) throw i o exception { write line break ( writer , 1 ) ; }
public boolean equal exact ( rational other ) { return get denominator ( ) == other . get denominator ( ) & & get numerator ( ) == other . get numerator ( ) ; }
public boolean be empty ( ) { return _error list . be empty ( ) & & _defined tag list . be empty ( ) ; }
public void set float ( int tag type , float value ) { set object ( tag type , value ) ; }
public void set double array ( int tag type , @ not null double [ ] double ) { set object array ( tag type , double ) ; }
public boolean contain directory of type ( class < ? extend directory > type ) { for ( directory dir : _directories ) { if ( type . be assignable from ( dir . get class ( ) ) ) return true ; } return false ; }
public static void set instance ( rest client builder resolver resolver ) { instance = resolver ; }
public static json value parse ( string string ) { if ( string == null ) { throw new null pointer exception ( `` string be null `` ) ; } default handler handler = new default handler ( ) ; new json parser ( handler ) . parse ( string ) ; return handler . get value ( ) ; }
public static json value parse ( reader reader ) throw i o exception { if ( reader == null ) { throw new null pointer exception ( `` reader be null `` ) ; } default handler handler = new default handler ( ) ; new json parser ( handler ) . parse ( reader ) ; return handler . get value ( ) ; }
public json array set ( int index , boolean value ) { value . set ( index , json . value ( value ) ) ; return this ; }
public boolean be empty ( ) { return value . be empty ( ) ; }
protect location get location ( ) { return parser . get location ( ) ; }
public void end array value ( a array ) { }
public boolean be empty ( ) { return name . be empty ( ) ; }
public int a int ( ) { throw new unsupported operation exception ( `` not a number : `` + to string ( ) ) ; }
public static pretty print indent with tab ( ) { return new pretty print ( new char [ ] { '\t ' } ) ; }
public static double geq ( double value ) { return report matcher ( new great or equal < double > ( value ) ) . return zero ( ) ; }
public static float geq ( float value ) { return report matcher ( new great or equal < float > ( value ) ) . return zero ( ) ; }
public static short geq ( short value ) { return report matcher ( new great or equal < short > ( value ) ) . return zero ( ) ; }
public static byte [ ] ary eq ( byte [ ] value ) { return report matcher ( new array equal ( value ) ) . return null ( ) ; }
public static int or ( int first , int second ) { return mock progress . get argument matcher storage ( ) . report or ( ) . return zero ( ) ; }
public static float eq ( float value , float delta ) { return report matcher ( new equal with delta ( value , delta ) ) . return zero ( ) ; }
public void accept ( final method visitor mv ) { mv . visit insn ( opcode ) ; }
public object get bean ( ) { return bean ; }
public static abstract class generator get current ( ) { return ( abstract class generator ) current . get ( ) ; }
public void generate static ( code emitter e , context context , list method ) throw exception { / * generates : static { class this class = class . for name ( `` name of this class `` ) ; class cl = class . for name ( `` java . lang . object `` ) ; string [ ] sigs = new string [ ] { `` to string `` , `` ( ) ljava/lang/ string ; `` , . . . } ; method [ ] method = cl . get declare method ( ) ; method = reflect utils . find method ( sigs , method ) ; method_0 = method [ 0 ] ; cglib $ access_0 = method proxy . create ( cl , this class , `` ( ) ljava/lang/ string ; `` , `` to string `` , `` cglib $ access_0 `` ) ; . . . } * / e . push ( 0 ) ; e . newarray ( ) ; e . putfield ( empty_args_name ) ; local thisclass = e . make_local ( ) ; local declaringclass = e . make_local ( ) ; emit utils . load_class_this ( e ) ; e . store_local ( thisclass ) ; map method by class = collection utils . bucket ( method , method_to_class ) ; for ( iterator i = method by class . key set ( ) . iterator ( ) ; i . have next ( ) ; ) { class info class info = ( class info ) i . next ( ) ; list class method = ( list ) method by class . get ( class info ) ; e . push ( 2 * class method . size ( ) ) ; e . newarray ( constant . type_string ) ; for ( int index = 0 ; index < class method . size ( ) ; index++ ) { method info method = ( method info ) class method . get ( index ) ; signature sig = method . get signature ( ) ; e . dup ( ) ; e . push ( 2 * index ) ; e . push ( sig . get name ( ) ) ; e . aastore ( ) ; e . dup ( ) ; e . push ( 2 * index + 1 ) ; e . push ( sig . get descriptor ( ) ) ; e . aastore ( ) ; } emit utils . load_class ( e , class info . get type ( ) ) ; e . dup ( ) ; e . store_local ( declaringclass ) ; e . invoke_virtual ( constant . type_class , get_declared_methods ) ; e . invoke_static ( reflect_utils , find_methods ) ; for ( int index = 0 ; index < class method . size ( ) ; index++ ) { method info method = ( method info ) class method . get ( index ) ; signature sig = method . get signature ( ) ; signature impl = context . get impl signature ( method ) ; e . dup ( ) ; e . push ( index ) ; e . array_load ( method ) ; e . putfield ( get method field ( impl ) ) ; e . load_local ( declaringclass ) ; e . load_local ( thisclass ) ; e . push ( sig . get descriptor ( ) ) ; e . push ( sig . get name ( ) ) ; e . push ( impl . get name ( ) ) ; e . invoke_static ( method_proxy , make_proxy ) ; e . putfield ( get method proxy field ( impl ) ) ; } e . pop ( ) ; } }
public static < t > t mock ( class < t > class to mock ) { return mock ( class to mock , with setting ( ) . default answer ( returns_defaults ) ) ; }
public static void verify zero interaction ( object . . . mock ) { mockito_core . verify no more interaction ( mock ) ; }
public static verification mode only ( ) { return verification mode factory . only ( ) ; }
public static void validate mockito usage ( ) { mockito_core . validate mockito usage ( ) ; }
public static class get non serializable super class ( class type ) { class result = type ; while ( serializable . class . be assignable from ( result ) ) { result = result . get superclass ( ) ; if ( result == null ) { throw new error ( `` bad class hierarchy : no non-serializable parent `` ) ; } } return result ; }
public static < t > answer < t > return first arg ( ) { return ( answer < t > ) returns_first_argument ; }
public static < t > argument captor < t > for class ( class < t > clazz ) { return new argument captor < t > ( clazz ) ; }
public static < t > then < t > then ( t mock ) { return new then impl < t > ( mock ) ; }
public static boolean be primitive or wrapper ( class < ? > type ) { return primitive_or_wrapper_default_values . contains key ( type ) ; }
public static string any string ( ) { return report matcher ( any . any ) . return string ( ) ; }
public static set any set ( ) { return report matcher ( any . any ) . return set ( ) ; }
public static collection any collection ( ) { return report matcher ( any . any ) . return list ( ) ; }
public static boolean eq ( boolean value ) { return report matcher ( new equal ( value ) ) . return false ( ) ; }
public static string end with ( string suffix ) { return report matcher ( new end with ( suffix ) ) . return string ( ) ; }
public static verification after delay after ( int millis ) { return new after ( millis , verification mode factory . time ( 1 ) ) ; }
public static < a > answer < void > answer void ( void answer1 < a > answer ) { return to answer ( answer ) ; }
public static < t > t any ( class < t > type ) { report matcher ( new instance of . var arg aware ( type , `` < any `` + type . get canonical name ( ) + `` > `` ) ) ; return default value ( type ) ; }
public static int any int ( ) { report matcher ( new instance of ( integer . class , `` < any integer > `` ) ) ; return 0 ; }
public static short any short ( ) { report matcher ( new instance of ( short . class , `` < any short > `` ) ) ; return 0 ; }
public static double double that ( argument matcher < double > matcher ) { report matcher ( matcher ) ; return 0 ; }
public static < t > t arg that ( matcher < t > matcher ) { report matcher ( matcher ) ; return ( t ) default value ( generic type of matcher ( matcher . get class ( ) ) ) ; }
public static long long that ( matcher < long > matcher ) { report matcher ( matcher ) ; return 0 ; }
public static float float that ( matcher < float > matcher ) { report matcher ( matcher ) ; return 0 ; }
public static annotation engine get annotation engine ( ) { return registry . get annotation engine ( ) ; }
public static mockito logger get mockito logger ( ) { return registry . get mockito logger ( ) ; }
public internal runner create strict stub ( class < ? > klass ) throw invocation target exception { return create ( klass , new supplier < mockito test listener > ( ) { public mockito test listener get ( ) { return new strict stub runner test listener ( ) ; } } ) ; }
public void set answer for stub ( list < answer < ? > > answer , strictness strictness ) { do answer style stubbing . set answer ( answer , strictness ) ; }
public void clear ( ) { target . clear ( ) ; }
public boolean be synthetic ( ) { return field . be synthetic ( ) ; }
public static verification collector collector ( ) { return new verification collector impl ( ) ; }
public static verification mode at most once ( ) { return verification mode factory . at most once ( ) ; }
public static void validate mockito usage ( ) { mockito_core . validate mockito usage ( ) ; }
public http request [ ] retrieve record request ( http request http request ) { string record request = retrieve record request ( http request , format . json ) ; if ( string utils . be not empty ( recorded request ) & & ! record request . equal ( `` [ ] `` ) ) { return http request serializer . deserialize array ( record request ) ; } else { return new http request [ 0 ] ; } }
public forward chain expectation when ( http request http request ) { return when ( http request , time . unlimited ( ) ) ; }
public http request with method ( string method ) { return with method ( string ( method ) ) ; }
public http request with body ( string body ) { this . body = new string body ( body ) ; return this ; }
public http request with cookie ( nottable string name , nottable string value ) { this . cooky . with entry ( name , value ) ; return this ; }
public http response with cooky ( cookie . . . cooky ) { this . cooky . with entry ( cooky ) ; return this ; }
public static builder new builder ( ) { return new builder ( ) ; }
public static builder new builder ( ) { return new builder ( ) ; }
public multi < t > buffer ( ) { return buffer ( 128 ) ; }
public static < t > multi < t > never ( ) { return ( multi < t > ) never ; }
public r get item2 ( ) { return item2 ; }
public static < t > unchecked consumer < t > unchecked ( consumer < t > consumer ) { return unchecked consumer . from ( consumer ) ; }
public static < t > consumer < t > consumer ( unchecked consumer < t > consumer ) { return consumer . to consumer ( ) ; }
public void visit jump insn ( final int opcode , final label lbl ) { super . visit jump insn ( opcode , lbl ) ; label node ln = ( ( jump insn node ) instruction . get last ( ) ) . label ; if ( opcode == jsr & & ! subroutine head . contains key ( ln ) ) { subroutine head . put ( ln , new bit set ( ) ) ; } }
public void update index ( final int index ) { int new type ref = 0x42000000 | ( index < < 8 ) ; if ( visible type annotation ! = null ) { for ( type annotation node tan : visible type annotation ) { tan . type ref = new type ref ; } } if ( invisible type annotation ! = null ) { for ( type annotation node tan : invisible type annotation ) { tan . type ref = new type ref ; } } }
public int get sort ( ) { return value > > > 24 ; }
public static object eval ( string expression , object ctx ) { return new m v e l interpret runtime ( expression , ctx , new immutable default factory ( ) ) . parse ( ) ; }
public static object eval ( string expression , map < string , object > var ) { cache map variable resolver factory factory = new cache map variable resolver factory ( var ) ; try { return new m v e l interpret runtime ( expression , null , factory ) . parse ( ) ; } finally { factory . externalize ( ) ; } }
public static boolean eval to boolean ( string expression , variable resolver factory var ) { return eval ( expression , var , boolean . class ) ; }
public static object execute expression ( final object compile expression , final object ctx , final map var ) { cache map variable resolver factory factory = var ! = null ? new cache map variable resolver factory ( var ) : null ; try { return ( ( executable statement ) compile expression ) . get value ( ctx , factory ) ; } finally { if ( factory ! = null ) factory . externalize ( ) ; } }
public int get max two phase commit thread ( ) { return max two phase commit thread ; }
public boolean be classic prepare ( ) { return classic prepare ; }
public process get process implementation ( ) { if ( process implementation == null & & process implementation class name ! = null ) { synchronize ( this ) { if ( process implementation == null & & process implementation class name ! = null ) { process implementation = classloading utility . load and instantiate class ( process . class , process implementation class name , null ) ; } } } return process implementation ; }
public void set jdbc access ( string connection detail ) { jdbc access = connection detail ; }
public recovery environment bean set periodic recovery initilization offset ( int periodic recovery initilization offset ) { this . periodic recovery initilization offset = periodic recovery initilization offset ; return null ; }
public void set recovery listener ( boolean recovery listener ) { this . recovery listener = recovery listener ; }
public void set recovery module ( list < recovery module > recovery module ) { synchronize ( this ) { if ( recovery module == null ) { this . recovery module = new array list < recovery module > ( ) ; this . recovery module class name = new array list < string > ( ) ; } else { this . recovery module = new array list < recovery module > ( recovery module ) ; list < string > name = classloading utility . get name for class ( this . recovery module ) ; this . recovery module class name = name ; } } }
public static final participant store get participant store ( ) { return get action store ( ) ; }
public static boolean register bean ( object name name , object bean , boolean register ) { try { m bean server mb = j m x server . get agent ( ) . get server ( ) ; boolean be register = mb . be register ( name ) ; system . out . println ( ( register ? `` `` : `` un `` ) + `` registering bean `` + name ) ; if ( register & & be register ) { system . out . println ( name + `` be already register `` ) ; return true ; } else if ( ! register & & ! be register ) { system . out . println ( name + `` be not register `` ) ; return true ; } else if ( register ) { mb . register m bean ( bean , name ) ; } else { mb . unregister m bean ( name ) ; } return true ; } catch ( j m exception e ) { system . out . println ( `` m bean registration error : `` + e . get message ( ) ) ; return false ; } }
public static string get thread id ( ) { return get thread id ( thread . current thread ( ) ) ; }
public void set buffer flush per second ( int buffer flush per second ) { this . buffer flush per second = buffer flush per second ; }
public boolean full commit need ( ) { return true ; }
public boolean be recovery scan complete without error ( ) { return recovery scan complete without error ; }
public list < string > get xa recovery node ( ) { return new array list < string > ( xa recovery node ) ; }
public void set xa resource orphan filter class name ( list < string > xa resource orphan filter class name ) { synchronize ( this ) { if ( xa resource orphan filter class name == null ) { this . xa resource orphan filter = new array list < x a resource orphan filter > ( ) ; this . xa resource orphan filter class name = new array list < string > ( ) ; } else if ( ! xa resource orphan filter class name . equal ( this . xa resource orphan filter class name ) ) { this . xa resource orphan filter = null ; this . xa resource orphan filter class name = new array list < string > ( xa resource orphan filter class name ) ; } } }
public boolean be xa assume recovery complete ( ) { return xa assume recovery complete ; }
public void set transaction synchronization registry j n d i context ( string transaction synchronization registry j n d i context ) { this . transaction synchronization registry j n d i context = transaction synchronization registry j n d i context ; }
public list < string > get xa resource map class name ( ) { synchronize ( this ) { return new array list < string > ( xa resource map class name ) ; } }
public void set default commit markable resource table name ( string commit markable resource table name ) { this . commit markable resource table name = commit markable resource table name ; }
public static void bind j t a transaction manager implementation ( ) throw javax . naming . naming exception { bind j t a transaction manager implementation ( new initial context ( ) ) ; }
public static < t > class < ? extend t > load class ( class < t > iface , string class name ) { if ( common logger . logger . be trace enable ( ) ) { common logger . logger . trace ( `` load class `` + class name ) ; } if ( class name == null ) { common logger . i18 n logger . warn_common_ classloading utility_1 ( ) ; return null ; } class < ? > clazz = load class ( class name ) ; if ( clazz == null ) { return null ; } try { class < ? extend t > clazz2 = clazz . a subclass ( iface ) ; return clazz2 ; } catch ( class cast exception e ) { common logger . i18 n logger . warn_common_ classloading utility_3 ( class name , iface . get name ( ) , e ) ; return null ; } }
public void disconnect ( ) { if ( ! be connect ( ) ) { return ; } try { connection . close ( ) ; } catch ( j m s exception e ) { jta logger . i18 n logger . warn_failed_to_close_jms_connection ( connection . to string ( ) , e ) ; } finally { connection = null ; session = null ; } }
public session create session ( boolean transact , int acknowledge mode ) throw j m s exception { if ( transaction helper . be transaction available ( ) ) { return create and register session ( ) ; } return xa connection . create session ( transact , acknowledge mode ) ; }
public int get transaction timeout ( ) throw x a exception { return connection manager . connect and apply ( x a resource : : get transaction timeout ) ; }
public void push input source ( x m l input source input source ) { f document scanner . push input source ( input source ) ; } // push input source ( x m l input source )
public double get double l e ( int index ) { return double . long bit to double ( get long l e ( index ) ) ; }
public string dump stats ( ) { int heap arena len = heap arena == null ? 0 : heap arena . length ; string builder buf = new string builder ( 512 ) . append ( heap arena len ) . append ( `` heap arena ( s ) : `` ) . append ( string util . newline ) ; if ( heap arena len > 0 ) { for ( pool arena < byte [ ] > a : heap arena ) { buf . append ( a ) ; } } int direct arena len = direct arena == null ? 0 : direct arena . length ; buf . append ( direct arena len ) . append ( `` direct arena ( s ) : `` ) . append ( string util . newline ) ; if ( direct arena len > 0 ) { for ( pool arena < byte buffer > a : direct arena ) { buf . append ( a ) ; } } return buf . to string ( ) ; }
protect byte buf extract object ( channel handler context ctx , byte buf buffer , int index , int length ) { return buffer . retain slice ( index , length ) ; }
protect void checkpoint ( ) { checkpoint = internal buffer ( ) . reader index ( ) ; }
protect s state ( ) { return state ; }
public http header set ( char sequence name , object value ) { return set ( name . to string ( ) , value ) ; }
public static boolean be asterisk form ( uri uri ) { return `` * `` . equal ( uri . get path ( ) ) & & uri . get scheme ( ) == null & & uri . get scheme specific part ( ) == null & & uri . get host ( ) == null & & uri . get authority ( ) == null & & uri . get query ( ) == null & & uri . get fragment ( ) == null ; }
public static char sequence get charset a sequence ( char sequence content type value ) { object util . check not null ( content type value , `` content type value `` ) ; int index of charset = ascii string . index of ignore case ascii ( content type value , charset_equals , 0 ) ; if ( index of charset == ascii string . index_not_found ) { return null ; } int index of encode = index of charset + charset_equals . length ( ) ; if ( index of encode < content type value . length ( ) ) { char sequence charset candidate = content type value . sub sequence ( index of encode , content type value . length ( ) ) ; int index of semicolon = ascii string . index of ignore case ascii ( charset candidate , semicolon , 0 ) ; if ( index of semicolon == ascii string . index_not_found ) { return charset candidate ; } return charset candidate . sub sequence ( 0 , index of semicolon ) ; } return null ; }
public list < interface http data > get body http data ( ) { check destroy ( ) ; if ( ! be last chunk ) { throw new not enough data decoder exception ( ) ; } return body list http data ; }
public void remove http data from clean ( interface http data data ) { check destroy ( ) ; factory . remove http data from clean ( request , data ) ; }
public string text ( ) { return content ( ) . to string ( charset util . utf_8 ) ; }
public web socket frame read chunk ( byte buf allocator allocator ) throw exception { byte buf buf = input . read chunk ( allocator ) ; if ( buf == null ) { return null ; } return new continuation web socket frame ( input . be end of input ( ) , rsv , buf ) ; }
public string uri ( ) { return uri ; }
protect int max reserve stream ( ) { return max reserve streams ! = null ? max reserve stream : default_max_reserved_streams ; }
protect b max reserve stream ( int max reserve stream ) { enforce constraint ( `` server `` , `` connection `` , connection ) ; enforce constraint ( `` server `` , `` codec `` , decoder ) ; enforce constraint ( `` server `` , `` codec `` , encoder ) ; this . max reserve stream = check positive or zero ( max reserve stream , `` max reserve stream `` ) ; return self ( ) ; }
protect b initial huffman decode capacity ( int initial huffman decode capacity ) { return self ( ) ; }
protect int decoder enforce max consecutive empty data frame ( ) { return max consecutive empty frame ; }
public long get max header table size ( ) { return hpack dynamic table . capacity ( ) ; }
public void add ( hpack header field header ) { int header size = header . size ( ) ; if ( header size > capacity ) { clear ( ) ; return ; } while ( capacity - size < header size ) { remove ( ) ; } hpack header field [ head++ ] = header ; size += header . size ( ) ; if ( head == hpack header field . length ) { head = 0 ; } }
public void clear ( ) { while ( tail ! = head ) { hpack header field [ tail++ ] = null ; if ( tail == hpack header field . length ) { tail = 0 ; } } head = 0 ; tail = 0 ; size = 0 ; }
public void encode ( byte buf out , char sequence data ) { object util . check not null ( out , `` out `` ) ; if ( data instanceof ascii string ) { ascii string string = ( ascii string ) data ; try { encode processor . out = out ; string . for each byte ( encode processor ) ; } catch ( exception e ) { platform dependent . throw exception ( e ) ; } finally { encode processor . end ( ) ; } } else { encode slow path ( out , data ) ; } }
public long code ( ) { return code ; }
public short value ( ) { return value ; }
public boolean ack ( ) { return be flag set ( ack ) ; }
public int num buffer stream ( ) { return pending stream . size ( ) ; }
public sock response type response type ( ) { return response type ; }
public int compare to ( char sequence string ) { if ( this == string ) { return 0 ; } int result ; int length1 = length ( ) ; int length2 = string . length ( ) ; int min length = math . min ( length1 , length2 ) ; for ( int i = 0 , j = array offset ( ) ; i < min length ; i++ , j++ ) { result = b2c ( value [ j ] ) - string . char at ( i ) ; if ( result ! = 0 ) { return result ; } } return length1 - length2 ; }
public boolean start with ( char sequence prefix , int start ) { return region match ( start , prefix , 0 , prefix . length ( ) ) ; }
public agroal connection factory configuration supplier principal ( principal login principal ) { check lock ( ) ; principal = login principal ; return this ; }
public list < comparison difference > determine difference ( object actual , object expect , recursive comparison configuration recursive comparison configuration ) { if ( recursive comparison configuration . be in strict type check mode ( ) & & expect type be not subtype of actual type ( actual , expect ) ) { return list ( expect and actual type difference ( actual , expect ) ) ; } list < string > root path = list ( ) ; list < dual value > visit = list ( ) ; return determine difference ( actual , expect , root path , true , visit , recursive comparison configuration ) ; }
public < t > dynamic type . builder < t > rebase ( class < t > type , class file locator class file locator , method name transformer method name transformer ) { return rebase ( type description . for loaded type . of ( type ) , class file locator , method name transformer ) ; }
public static array factory for type ( type description . generic component type ) { return new array factory ( component type , make array creator for ( component type ) ) ; }
public change set result perform ( final archive input stream in , final archive output stream out ) throw i o exception { return perform ( new archive input stream iterator ( in ) , out ) ; }
public compressor input stream create compressor input stream ( final string name , final input stream in ) throw compressor exception { return create compressor input stream ( name , in , decompress concatenate ) ; }
public static i o file filter or file filter ( final i o file filter filter1 , final i o file filter filter2 ) { return new or file filter ( filter1 , filter2 ) ; }
public field vector3 d < t > apply inverse to ( final field vector3 d < t > u ) { final t x = u . get x ( ) ; final t y = u . get y ( ) ; final t z = u . get z ( ) ; final t s = q1 . multiply ( x ) . add ( q2 . multiply ( y ) ) . add ( q3 . multiply ( z ) ) ; final t m0 = q0 . negate ( ) ; return new field vector3 d < t > ( m0 . multiply ( x . multiply ( m0 ) . subtract ( q2 . multiply ( z ) . subtract ( q3 . multiply ( y ) ) ) ) . add ( s . multiply ( q1 ) ) . multiply ( 2 ) . subtract ( x ) , m0 . multiply ( y . multiply ( m0 ) . subtract ( q3 . multiply ( x ) . subtract ( q1 . multiply ( z ) ) ) ) . add ( s . multiply ( q2 ) ) . multiply ( 2 ) . subtract ( y ) , m0 . multiply ( z . multiply ( m0 ) . subtract ( q1 . multiply ( y ) . subtract ( q2 . multiply ( x ) ) ) ) . add ( s . multiply ( q3 ) ) . multiply ( 2 ) . subtract ( z ) ) ; }
public static < t extend real field element < t > > field vector3 d < t > apply inverse to ( final rotation r , final field vector3 d < t > u ) { final t x = u . get x ( ) ; final t y = u . get y ( ) ; final t z = u . get z ( ) ; final t s = x . multiply ( r . get q1 ( ) ) . add ( y . multiply ( r . get q2 ( ) ) ) . add ( z . multiply ( r . get q3 ( ) ) ) ; final double m0 = -r . get q0 ( ) ; return new field vector3 d < t > ( x . multiply ( m0 ) . subtract ( z . multiply ( r . get q2 ( ) ) . subtract ( y . multiply ( r . get q3 ( ) ) ) ) . multiply ( m0 ) . add ( s . multiply ( r . get q1 ( ) ) ) . multiply ( 2 ) . subtract ( x ) , y . multiply ( m0 ) . subtract ( x . multiply ( r . get q3 ( ) ) . subtract ( z . multiply ( r . get q1 ( ) ) ) ) . multiply ( m0 ) . add ( s . multiply ( r . get q2 ( ) ) ) . multiply ( 2 ) . subtract ( y ) , z . multiply ( m0 ) . subtract ( y . multiply ( r . get q1 ( ) ) . subtract ( x . multiply ( r . get q2 ( ) ) ) ) . multiply ( m0 ) . add ( s . multiply ( r . get q3 ( ) ) ) . multiply ( 2 ) . subtract ( z ) ) ; }
public static < t extend real field element < t > > t distance1 ( final field vector3 d < t > v1 , final field vector3 d < t > v2 ) { return v1 . distance1 ( v2 ) ; }
public double cross product ( final vector2 d p1 , final vector2 d p2 ) { final double x1 = p2 . get x ( ) - p1 . get x ( ) ; final double y1 = get y ( ) - p1 . get y ( ) ; final double x2 = get x ( ) - p1 . get x ( ) ; final double y2 = p2 . get y ( ) - p1 . get y ( ) ; return math array . linear combination ( x1 , y1 , -x2 , y2 ) ; }
protect void set protocol type ( outlook protocol type protocol type ) { this . protocol type = protocol type ; }
public static autodiscover error parse ( ews xml reader reader ) throw exception { autodiscover error error = new autodiscover error ( ) ; error . time = reader . read attribute value ( xml attribute name . time ) ; error . id = reader . read attribute value ( xml attribute name . id ) ; do { reader . read ( ) ; if ( reader . get node type ( ) . get node type ( ) == xml node type . start_element ) { if ( reader . get local name ( ) . equal ignore case ( xml element name . error code ) ) { error . error code = reader . read element value ( integer . class ) ; } else if ( reader . get local name ( ) . equal ignore case ( xml element name . message ) ) { error . message = reader . read element value ( ) ; } else if ( reader . get local name ( ) . equal ignore case ( xml element name . debug data ) ) { error . debug data = reader . read element value ( ) ; } else { reader . skip current element ( ) ; } } } while ( ! reader . be end element ( xml namespace . not specify , xml element name . error ) ) ; return error ; }
protect static protocol connection load from xml ( ews xml reader reader ) throw exception { protocol connection connection = new protocol connection ( ) ; do { reader . read ( ) ; if ( reader . get node type ( ) . get node type ( ) == xml node type . start_element ) { if ( reader . get local name ( ) . equal ( xml element name . encryption method ) ) { connection . set encryption method ( reader . read element value ( string . class ) ) ; } else if ( reader . get local name ( ) . equal ( xml element name . hostname ) ) { connection . set hostname ( reader . read element value ( string . class ) ) ; } else if ( reader . get local name ( ) . equal ( xml element name . port ) ) { connection . set port ( reader . read element value ( int . class ) ) ; } } } while ( ! reader . be end element ( xml namespace . autodiscover , xml element name . protocol connection ) ) ; return connection ; }
public static web client url collection load from xml ( ews xml reader reader ) throw exception { web client url collection instance = new web client url collection ( ) ; do { reader . read ( ) ; if ( ( reader . get node type ( ) . get node type ( ) == xml node type . start_element ) & & ( reader . get local name ( ) . equal ( xml element name . web client url ) ) ) { instance . get urls ( ) . add ( web client url . load from xml ( reader ) ) ; } } while ( ! reader . be end element ( xml namespace . autodiscover , xml element name . web client url ) ) ; return instance ; }
public rule operation error collection get error ( ) { return this . error ; }
public folder copy folder ( folder id folder id , folder id destination folder id ) throw exception { copy folder request request = new copy folder request ( this , service error handle . throw on error ) ; request . set destination folder id ( destination folder id ) ; request . get folder id ( ) . add ( folder id ) ; service response collection < move copy folder response > response = request . execute ( ) ; return response . get response at index ( 0 ) . get folder ( ) ; }
public push subscription end subscribe to push notification ( i async result async result ) throw exception { subscribe to push notification request request = async request result . extract service request ( this , async result ) ; return request . end execute ( async result ) . get response at index ( 0 ) . get subscription ( ) ; }
public meeting request delivery scope get meeting request delivery scope ( ) { return this . meeting request delivery scope ; }
public void set send invitation or cancellation mode ( send invitation or cancellation mode value ) { this . send invitation or cancellation mode = value ; }
public find item result < appointment > find appointment ( calendar view view ) throw exception { ews utility . validate param ( view , `` view `` ) ; service response collection < find item response < appointment > > responses = this . internal find item ( ( search filter ) null , view , null / * group by * / ) ; return response . get response at index ( 0 ) . get result ( ) ; }
public folder move ( folder id destination folder id ) throw exception { this . throw if this be new ( ) ; ew utility . validate param ( destination folder id , `` destination folder id `` ) ; return this . get service ( ) . move folder ( this . get id ( ) , destination folder id ) ; }
public void save ( well know folder name destination folder name , send invitation mode send invitation mode ) throw exception { this . internal create ( new folder id ( destination folder name ) , null , send invitation mode ) ; }
public void delete ( delete mode delete mode , send cancellation mode send cancellation mode ) throw exception { this . internal delete ( delete mode , send cancellation mode , null ) ; }
protect affect task occurrence get default affect task occurrence ( ) { return affect task occurrence . all occurrence ; }
protected list < item > internal create ( folder id destination folder id , message disposition message disposition ) throw exception { ( ( item id ) this . get property bag ( ) . get object from property definition ( response object schema . reference item id ) ) . assign ( this . reference item . get id ( ) ) ; return this . get service ( ) . internal create response object ( this , destination folder id , message disposition ) ; }
public void remove notification event ( i notification event delegate notification event ) { on notification event . remove ( notification event ) ; }
public delegate folder permission level get note folder permission level ( ) { return this . delegate folder permission . get ( xml element name . note folder permission level ) . get permission level ( ) ; }
public boolean write delete update to xml ( ews service xml writer writer , service object ew object ) { return false ; }
public void set im address key ( im address key key , string value ) { if ( value == null ) { this . internal remove ( key ) ; } else { im address entry entry ; if ( this . get entry ( ) . contains key ( key ) ) { entry = this . get entry ( ) . get ( key ) ; entry . set im address ( value ) ; this . change ( ) ; } else { entry = new im address entry ( key , value ) ; this . internal add ( entry ) ; } } }
public static value < ? > value to literal ( @ not null graphql field visibility field visibility , @ not null input value with state input value with state , @ not null graph q l type type ) { return ( value < ? > ) value to literal ( field visibility , input value with state , type , value mode . literal ) ; }
protect method node add method ( class node node , boolean should be synthetic , string name , int modifier , class node return type , parameter [ ] parameter , class node [ ] exception , statement code ) { if ( should be synthetic ) { return node . add synthetic method ( name , modifier , return type , parameter , exception , code ) ; } else { return node . add method ( name , modifier & ~acc_synthetic , return type , parameter , exception , code ) ; } }
public void unlock item ( share session contract implementor session , object key , soft lock lock ) throw cache exception { get storage access ( ) . remove from cache ( key , session ) ; }
public object load ( serializable id , object optional object , lock mode lock mode , share session contract implementor session ) { return load ( id , optional object , new lock option ( ) . set lock mode ( lock mode ) , session ) ; }
public static object just assist inject ( object inject me , method method , service locator impl locator , service handle < ? > root , method parameter . . . give value ) { if ( inject me == null || method == null ) { throw new illegal argument exception ( `` inject me= `` + inject me + `` method= `` + method ) ; } if ( give value == null ) give value = new method parameter [ 0 ] ; int num parameter = method . get parameter type ( ) . length ; map < integer , method parameter > know value = new hash map < integer , method parameter > ( ) ; for ( method parameter mp : give value ) { int index = mp . get parameter position ( ) ; if ( know value . contains key ( index ) ) { throw new illegal argument exception ( `` the give value contain more than one value for index `` + index ) ; } know value . put ( index , mp ) ; if ( ( index < 0 ) || ( index > = num parameter ) ) { throw new illegal argument exception ( `` index of `` + mp + `` be out of range of the method parameter `` + method ) ; } } list < system injectee impl > injectees = utility . get method injectees ( inject me . get class ( ) , method , null , know value ) ; object args [ ] = new object [ num parameter ] ; for ( int lcv = 0 ; lcv < injectees . size ( ) ; lcv++ ) { system injectee impl injectee = injectees . get ( lcv ) ; if ( injectee == null ) { method parameter mp = know value . get ( lcv ) ; if ( mp == null ) { throw new assertion error ( `` error get value `` + lcv + `` method= `` + method + `` inject me= `` + inject me + `` know values= `` + know value ) ; } args [ lcv ] = mp . get parameter value ( ) ; } else { injection resolver < ? > resolver = locator . get per locator utility ( ) . get injection resolver ( locator , injectee ) ; args [ lcv ] = resolver . resolve ( injectee , root ) ; } } try { return reflection helper . invoke ( inject me , method , args , locator . get neutral context class loader ( ) ) ; } catch ( multi exception me ) { throw me ; } catch ( throwable e ) { throw new multi exception ( e ) ; } }
public json property . access find property access ( annotate ann ) { return null ; }
public value instantiator value instantiator instance ( mapper config < ? > config , annotate annotate , class < ? > resolver class ) { return null ; }
public object id generator < ? > object id generator instance ( mapper config < ? > config , annotate annotate , class < ? > impl class ) { return null ; }
public final t with appended annotation introspector ( annotation introspector ai ) { return _with base ( _base . with appended annotation introspector ( ai ) ) ; }
public settable bean property [ ] get from object argument ( deserialization config config ) { return null ; }
public static basic bean description for deserialization ( p o j o property collector coll ) { return new basic bean description ( coll ) ; }
public bean property writer unwrapping writer ( name transformer unwrapper ) { return new unwrapping bean property writer ( this , unwrapper ) ; }
public json map exception wrong token exception ( json parser jp , json token exp token , string msg ) { return json map exception . from ( jp , `` unexpected token ( `` +jp . get current token ( ) + `` ) , expect `` +exp token+ `` : `` +msg ) ; }
protect java type _from wildcard ( wildcard type type , type binding context ) { / * similar to challenge with type variable , we may have * multiple upper bound . but it be also possible that if * upper bound default to object , we might want to consider * low bound instead . * * for now , we wo n't try anything more advanced ; above be * just for future reference . * / return _construct type ( type . get upper bound ( ) [ 0 ] , context ) ; }
public resolve reference type declaration get internal type ( string name ) { / * the name of the reference type declaration could be compose of the internal class and the outer class , e . g . a $ b . that 's why we search the internal type in the end part . in case the name be compose of the internal type only , i . e . f . get name ( ) return b , it will also work . * / optional < resolve reference type declaration > type = this . internal type ( ) . stream ( ) . filter ( f - > f . get name ( ) . end with ( name ) ) . find first ( ) ; return type . or else throw ( ( ) - > new unsolved symbol exception ( `` internal type not find : `` + name ) ) ; }
public scoped class pool create ( class loader cl , class pool src , scoped class pool repository repository ) { return new scoped class pool ( cl , src , repository , false ) ; }
protect static transaction local synchronization get synchronization ( transaction tx , boolean create ) { synchronize ( tx ) { transaction local synchronization result = synchronization by transaction . get ( tx ) ; if ( result == null & & create == true ) { result = new transaction local synchronization ( tx ) ; try { tx . register synchronization ( result ) ; } catch ( rollback exception e ) { throw new illegal state exception ( `` transaction already roll back or mark for rollback `` ) ; } catch ( system exception e ) { throw new runtime exception ( `` error register transaction synchronization with `` + tx , e ) ; } synchronization by transaction . put ( tx , result ) ; } return result ; } }
public static http u r i create http u r i ( string scheme , string host , int port , string path , string param , string query , string fragment ) { if ( port == 80 & & http scheme . http . be ( scheme ) ) port = 0 ; if ( port == 443 & & http scheme . http . be ( scheme ) ) port = 0 ; return new http u r i ( scheme , host , port , path , param , query , fragment ) ; }
public schema tree new tree ( final json ref ref , final json node node ) { return new tree ( schema key . for json ref ( ref ) , node ) ; }
public keyword builder with syntax checker ( final syntax checker syntax checker ) { bundle . check not null printf ( syntax checker , `` null syntax checker `` , name ) ; this . syntax checker = syntax checker ; return this ; }
protect static < m extend abstract manager > m narrow ( final class < m > narrow class , final abstract manager manager ) { if ( narrow class . be assignable from ( manager . get class ( ) ) ) { return ( m ) manager ; } throw new configuration exception ( `` configuration have multiple incompatible appenders point to the same resource ' `` + manager . get name ( ) + `` ' `` ) ; }
public plugin builder with configuration ( final configuration configuration ) { this . configuration = configuration ; return this ; }
public < t1 , t2 > multi item combine2 < t1 , t2 > stream ( publisher < ? extend t1 > a , publisher < ? extend t2 > b ) { return new multi item combine2 < > ( arrays . a list ( non null ( a , `` a `` ) , non null ( b , `` b `` ) ) ) ; }
protect full http response new handshake response ( full http request req , http header header ) { char sequence key = req . header ( ) . get ( http header name . sec_websocket_key ) ; if ( key == null ) { throw new web socket server handshake exception ( `` not a web socket request : missing key `` , req ) ; } full http response res = new default full http response ( http_1_1 , http response status . switching_protocols , req . content ( ) . alloc ( ) . buffer ( 0 ) ) ; if ( header ! = null ) { re . header ( ) . add ( header ) ; } string accept seed = key + websocket_13_accept_guid ; byte [ ] sha1 = web socket util . sha1 ( accept seed . get byte ( charset util . us_ascii ) ) ; string accept = web socket util . base64 ( sha1 ) ; if ( logger . be debug enable ( ) ) { logger . debug ( `` web socket version 13 server handshake key : { } , response : { } `` , key , accept ) ; } res . header ( ) . set ( http header name . upgrade , http header value . websocket ) . set ( http header name . connection , http header value . upgrade ) . set ( http header name . sec_websocket_accept , accept ) ; string subprotocols = req . header ( ) . get ( http header name . sec_websocket_protocol ) ; if ( subprotocols ! = null ) { string select subprotocol = select subprotocol ( subprotocols ) ; if ( select subprotocol == null ) { if ( logger . be debug enable ( ) ) { logger . debug ( `` request subprotocol ( s ) not support : { } `` , subprotocols ) ; } } else { re . header ( ) . set ( http header name . sec_websocket_protocol , select subprotocol ) ; } } return re ; }
protect http2 frame logger frame logger ( ) { return frame logger ; }
protect static void notify listener ( event executor event executor , final future < ? > future , final generic future listener < ? > listener ) { notify listener with stack over flow protection ( check not null ( event executor , `` event executor `` ) , check not null ( future , `` future `` ) , check not null ( listener , `` listener `` ) ) ; }
public void add all ( promise . . . promise ) { add all ( ( future [ ] ) promise ) ; }
public void trace ( string msg , throwable t ) { if ( logger . be loggable ( level . fine ) ) { log ( self , level . fine , msg , t ) ; } }
public void info ( string format , object arg a , object arg b ) { if ( logger . be loggable ( level . info ) ) { format tuple ft = message formatter . format ( format , arg a , arg b ) ; log ( self , level . info , ft . get message ( ) , ft . get throwable ( ) ) ; } }
public void debug ( string msg ) { logger . log ( fqcn , level . debug , msg , null ) ; }
public void error ( string msg , throwable t ) { logger . log ( fqcn , level . error , msg , t ) ; }
public static void set level ( level level ) { resource leak detector . level = object util . check not null ( level , `` level `` ) ; }
public static level get level ( ) { return level ; }
public list < string > support protocol ( ) { return support protocol ; }
public static set < string > available open ssl cipher suite ( ) { return available_openssl_cipher_suites ; }
public long accept renegotiate ( ) { lock reader lock = context . ctx lock . read lock ( ) ; reader lock . lock ( ) ; try { return s s l context . session accept renegotiate ( context . ctx ) ; } finally { reader lock . unlock ( ) ; } }
public long ticket key fail ( ) { lock reader lock = context . ctx lock . read lock ( ) ; reader lock . lock ( ) ; try { return s s l context . session ticket key fail ( context . ctx ) ; } finally { reader lock . unlock ( ) ; } }
public file certificate ( ) { return certificate ; }
public void set max write size ( long max write size ) { this . max write size = max write size ; }
public synchronize void stop ( ) { if ( ! monitor active ) { return ; } monitor active = false ; reset accounting ( milli second from nano ( ) ) ; traffic shape handler . do accounting ( this ) ; if ( scheduled future ! = null ) { scheduled future . cancel ( true ) ; } }
public final void set connect timeout millis ( long connect timeout millis ) { if ( connect timeout millis < = 0 ) { connect timeout millis = 0 ; } this . connect timeout millis = connect timeout millis ; }
public static host file entry parse ( file file , charset . . . charsets ) throw i o exception { check not null ( file , `` file `` ) ; check not null ( charsets , `` charsets `` ) ; if ( file . exists ( ) & & file . be file ( ) ) { for ( charset charset : charsets ) { host file entry entry = parse ( new buffer reader ( new input stream reader ( new file input stream ( file ) , charset ) ) ) ; if ( entry ! = host file entry . empty ) { return entry ; } } } return host file entry . empty ; }
public int min ttl ( ) { return min ttl ; }
public final void add first ( byte buf buf , channel promise promise ) { add first ( buf , to channel future listener ( promise ) ) ; }
public final int readable byte ( ) { return readable byte ; }
public string id ( ) { return id ; }
public final int int value ( ) { return fd ; }
public int count ( ) { return count ; }
public static algorithm parse ( final string s ) { if ( s == null ) { return null ; } else { return new algorithm ( s ) ; } }
public static byte [ ] compute ( final base64 u r l encode j w e header ) { return encode j w e header . to string ( ) . get byte ( charset . for name ( `` ascii `` ) ) ; }
public byte [ ] get authentication tag ( ) { return authentication tag ; }
public static byte [ ] encode data with length ( final base64 u r l data ) { byte [ ] bytes = data ! = null ? data . decode ( ) : null ; return encode data with length ( byte ) ; }
protect concat k d f get concat k d f ( ) { return concat k d f ; }
public string get secret string ( ) { return new string ( secret , standard charset . utf_8 ) ; }
public int get iteration count ( ) { return iteration count ; }
public provider get key encryption provider ( ) { return ke provider ! = null ? ke provider : get provider ( ) ; }
public base64 u r l get i v ( ) { return iv ; }
public r s a key to r s a key ( ) { return ( r s a key ) this ; }
public set < key use > get key us ( ) { return use ; }
public secret key get secret key ( ) { return ( ( octet sequence key ) get j w k set ( ) . get key ( ) . get ( 0 ) ) . to secret key ( ) ; }
public base64 u r l get signature ( ) { return signature ; }
public int get expect key length ( ) { return expect length ; }
public static set < string > get registered parameter name ( ) { return registered_parameter_names ; }
public set < class < ? extend j o s e object > > get j o s e class ( ) { return class ; }
public boolean be allow ( final j w s algorithm jws alg ) { return jws algs . contains ( jws alg ) ; }
public byte [ ] decode ( ) { return base64 codec . decode ( value ) ; }
public static list < string > get string list ( final j s o n object o , final string key ) throw parse exception { string [ ] array = get string array ( o , key ) ; if ( array == null ) { return null ; } return array . a list ( array ) ; }
public void set introspection endpoint u r i ( final uri introspection endpoint ) { this . introspection endpoint = introspection endpoint ; }
public void set revocation endpoint u r i ( final uri revocation endpoint ) { this . revocation endpoint = revocation endpoint ; }
public void set device authorization endpoint u r i ( final uri device authz endpoint ) { this . device authz endpoint = device authz endpoint ; }
public void set response mode ( final list < response mode > rms ) { this . rms = rms ; }
public void set request object j w s algs ( final list < j w s algorithm > request object j w s algs ) { this . request object j w s algs = request object j w s algs ; }
public void set policy u r i ( final uri policy u r i ) { u r i utils . ensure scheme be h t t p sor h t t p ( policy u r i ) ; this . policy u r i = policy u r i ; }
public void set support t l s client certificate bound access token ( final boolean tl client cert bound token ) { tls client certificate bound access token = tls client cert bound tokens ; }
public void set incremental authorization type ( final list < client type > incremental authz type ) { this . incremental authz type = incremental authz type ; }
public date get expiration time ( ) { return exp ; }
public static set < j w s algorithm > support j w a ( ) { set < j w s algorithm > support = new hash set < > ( ) ; support . add all ( j w s algorithm . family . hmac_sha ) ; support . add all ( j w s algorithm . family . rsa ) ; support . add all ( j w s algorithm . family . ec ) ; return collection . unmodifiable set ( support ) ; }
public acr get subject a c r ( ) { return subject a c r ; }
public date get not before time ( ) { return nbf ; }
public boolean equal ( final object o ) { if ( this == o ) return true ; if ( value == null ) return false ; if ( ! ( o instanceof secret ) ) return false ; secret other secret = ( secret ) o ; return equal s h a256 base ( other secret ) ; }
public x509 certificate get client x509 certificate ( ) { return certificate ; }
public set < audience > get expect audience ( ) { return claim set verifier . get expect audience ( ) ; }
public string to query string ( ) { map < string , list < string > > params = new hash map < > ( ) ; if ( get endpoint u r i ( ) ! = null ) { params . put all ( u r l utils . parse parameter ( get endpoint u r i ( ) . get query ( ) ) ) ; } params . put all ( to parameter ( ) ) ; return u r l utils . serialize parameter ( params ) ; }
public uri get redirection u r i ( ) { return redirect u r i ; }
public jwt get j w t response ( ) { return jwt response ; }
public response mode get response mode ( ) { return rm ; }
public authorization success response to success response ( ) { return ( authorization success response ) this ; }
public authorization error response to error response ( ) { return ( authorization error response ) this ; }
public static set < error object > get standard error ( ) { return standard_errors ; }
public auth request i d get auth request i d ( ) { return auth request i d ; }
public bearer access token get client notification token ( ) { return client notification token ; }
public string get login hint token string ( ) { return login hint token string ; }
public date get i d issue date ( ) { return issue date ; }
public boolean have scope value ( final scope . value scope value ) { return scope ! = null & & scope . contains ( scope value ) ; }
public void set scope ( final scope scope ) { this . scope = scope ; }
public encryption method get request object j w e enc ( ) { return request object j w e enc ; }
public void set request object j w e enc ( final encryption method request object j w e enc ) { this . request object j w e enc = request object j w e enc ; }
public software i d get software i d ( ) { return software i d ; }
public void set t l s client certificate bound access token ( final boolean tl client cert bound token ) { tls client certificate bound access token = tls client cert bound tokens ; }
public string get t l s client auth san email ( ) { return tl client auth san email ; }
public j s o n object to j s o n object ( ) { return to j s o n object ( true ) ; }
public client information response to success response ( ) { return ( client information response ) this ; }
public static set < error object > get standard error ( ) { return standard_errors ; }
public int get h t t p status code ( ) { return http status code ; }
public boolean require client i d ( ) { return require client i d ; }
public set < string > get request parameter name ( ) { return request param name ; }
public method get method ( ) { return method ; }
public int get connect timeout ( ) { return connect timeout ; }
public int get read timeout ( ) { return read timeout ; }
public string get client x509 certificate root d n ( ) { return client x509 certificate root d n ; }
public jwt get request object ( ) { return request object ; }
public audience get audience ( ) { return aud ; }
public long get lifetime ( ) { return lifetime ; }
public set < j w s algorithm > get j w s algorithm ( ) { return jws algs ; }
public list < string > get custom parameter ( final string name ) { return custom params . get ( name ) ; }
public static uri remove trail slash ( final uri uri ) { if ( uri == null ) return null ; string uri string = uri . to string ( ) ; if ( uri string . char at ( uri string . length ( ) - 1 ) == '/ ' ) { return uri . create ( uri string . substring ( 0 , uri string . length ( ) - 1 ) ) ; } return uri ; }
public static void ensure scheme be h t t p sor h t t p ( final uri uri ) { if ( uri == null ) { return ; } if ( uri . get scheme ( ) == null || ! array . a list ( `` http `` , `` https `` ) . contains ( uri . get scheme ( ) . to lower case ( ) ) ) { throw new illegal argument exception ( `` the uri scheme must be https or http `` ) ; } }
public string get region ( ) { return get string claim ( region_claim_name ) ; }
public i s o3166_1 alpha3 country code to alpha3 country code ( ) { return i s o3166_1 alpha country code mapper . to alpha3 country code ( this ) ; }
public string get second component string ( ) { return get value ( ) . substring ( 2 , 4 ) ; }
public person claim get claim set ( ) { return new person claim ( claim set . to j s o n object ( ) ) ; }
public policy get policy ( ) { return policy ; }
public i d document type get type ( ) { return type ; }
public q e s evidence to q e s evidence ( ) { return ( q e s evidence ) this ; }
public j s o n object to j s o n object ( ) { j s o n object o = new j s o n object ( ) ; o . put ( `` type `` , get evidence type ( ) . get value ( ) ) ; if ( collection utils . be not empty ( get attachment ( ) ) ) { list < object > attachment j s o n array = new link list < > ( ) ; for ( attachment attachment : get attachment ( ) ) { attachment j s o n array . add ( attachment . to j s o n object ( ) ) ; } o . put ( `` attachment `` , attachment j s o n array ) ; } return o ; }
public j s o n object to j s o n object ( ) { j s o n object o = new j s o n object ( ) ; if ( get organization ( ) ! = null ) { o . put ( `` organization `` , get organization entity ( ) . get value ( ) ) ; } if ( get t x n ( ) ! = null ) { o . put ( `` txn `` , get t x n ( ) . get value ( ) ) ; } return o ; }
public date with time zone offset get q e s creation time ( ) { return create at ; }
public identity verification method get verification method ( ) { return method ; }
public static set < error object > get standard error ( ) { return collection . unmodifiable set ( std error ) ; }
public static set < string > get standard claim name ( ) { return std_claim_names ; }
public jwk get subject j w k ( ) { j s o n object json object = get claim ( sub_jwk_claim_name , j s o n object . class ) ; if ( json object == null ) return null ; try { return jwk . parse ( json object ) ; } catch ( java . text . parse exception e ) { return null ; } }
public void set updated time ( final date updated time ) { set date claim ( updated_at_claim_name , updated time ) ; }
public set < string > get i d token claim name ( final boolean with lang tag ) { return get claim name ( id token claim , with lang tag ) ; }
public set < string > get verify i d token claim name ( final boolean with lang tag ) { return get claim name ( verify i d token claim , with lang tag ) ; }
public void add user info claim ( final string claim name ) { add user info claim ( claim name , claim requirement . voluntary ) ; }
public set < string > get user info claim name ( final boolean with lang tag ) { return get claim name ( user info claim , with lang tag ) ; }
public static entity list error response parse ( final h t t p response http response ) throw parse exception { http response . ensure status code not o k ( ) ; return new entity list error response ( federation a p i error . parse ( http response ) ) ; }
public audience get audience ( ) { return audience ; }
public entity i d get trust anchor ( ) { return anchor ; }
public client i d to client i d ( ) { return new client i d ( get value ( ) ) ; }
public void set federation entity metadata ( final federation entity metadata entity metadata ) { j s o n object o = entity metadata ! = null ? entity metadata . to j s o n object ( ) : null ; set metadata ( federation metadata type . federation_entity , o ) ; }
public void set constraint ( final trust chain constraint constraint ) { if ( constraint ! = null ) { set claim ( constraints_claim_name , constraint . to j s o n object ( ) ) ; } else { set claim ( constraints_claim_name , null ) ; } }
public uri get homepage u r i ( ) { return homepage u r i ; }
public boolean be permit ( final int num intermediate in path ) { if ( num intermediate in path < 0 ) { throw new illegal argument exception ( `` the path length must not be negative `` ) ; } return get max path length ( ) < = -1 || num intermediate in path < = get max path length ( ) ; }
public list < entity i d constraint > get exclude entity ( ) { return exclude entity ; }
public uri get post logout redirection u r i ( ) { return post logout redirect u r i ; }
public o i d c claim request with user info claim request ( final claim set request user info ) { return new o i d c claim request ( get i d token claim request ( ) , user info , get i d token verify claim request ( ) , get user info verify claim request ( ) ) ; }
public list < verify claim set request > get i d token verified claim request ( ) { return id token verified ; }
public list < acr > get essential a c r ( ) { return essential a c r ; }
public void set i d token j w e encs ( final list < encryption method > id token j w e encs ) { this . id token j w e encs = id token j w e encs ; }
public static application type get default ( ) { return web ; }
public static set < string > get registered parameter name ( ) { return registered_parameter_names ; }
public j w e algorithm get user info j w e alg ( ) { return user info j w e alg ; }
public void set user info j w e alg ( final j w e algorithm user info j w e alg ) { this . user info j w e alg = user info j w e alg ; }
public uri get front channel logout u r i ( ) { return front channel logout u r i ; }
public void require front channel logout session ( boolean require session ) { front channel logout session require = require session ; }
public static void write class ( string file name , byte [ ] bytes ) throw i o exception { buffered output stream out = new buffer output stream ( new file output stream ( file name ) ) ; try { out . write ( byte ) ; } finally { out . close ( ) ; } }
public void evict all ( ) throw i o exception { cache . evict all ( ) ; }
public response execute ( ) throw i o exception { synchronize ( this ) { if ( execute ) throw new illegal state exception ( `` already execute `` ) ; execute = true ; } try { client . get dispatcher ( ) . execute ( this ) ; response result = get response with interceptor chain ( false ) ; if ( result == null ) throw new i o exception ( `` cancel `` ) ; return result ; } finally { client . get dispatcher ( ) . finish ( this ) ; } }
public synchronize int get http connection count ( ) { return connection . size ( ) - get multiplexed connection count ( ) ; }
public list < certificate > peer certificate ( ) { return peer certificate ; }
public principal peer principal ( ) { return ! peer certificate . be empty ( ) ? ( ( x509 certificate ) peer certificate . get ( 0 ) ) . get subject x500 principal ( ) : null ; }
public set < string > name ( ) { tree set < string > result = new tree set < > ( string . case_insensitive_order ) ; for ( int i = 0 , size = size ( ) ; i < size ; i++ ) { result . add ( name ( i ) ) ; } return collection . unmodifiable set ( result ) ; }
public synchronize void flush ( ) throw i o exception { if ( ! initialize ) return ; check not close ( ) ; trim to size ( ) ; journal writer . flush ( ) ; }
public void send connection preface ( ) throw i o exception { frame writer . connection preface ( ) ; frame writer . setting ( ok http setting ) ; int window size = ok http setting . get initial window size ( setting . default_initial_window_size ) ; if ( window size ! = setting . default_initial_window_size ) { frame writer . window update ( 0 , window size - setting . default_initial_window_size ) ; } }
public source get source ( ) { return source ; }
@ override public frame reader new reader ( buffer source source , boolean client ) { return new reader ( source , 4096 , client ) ; }
public long round trip time ( ) throw interrupted exception { latch . await ( ) ; return receive - sent ; }
public boolean have next ( ) { return have next inet socket address ( ) || have next proxy ( ) || have next postpone ( ) ; }
public string type ( ) { return type ; }
public charset charset ( ) { return charset ! = null ? charset . for name ( charset ) : null ; }
public string value ( ) { return value ; }
public boolean http only ( ) { return http only ; }
public synchronize long size ( ) throw i o exception { initialize ( ) ; return size ; }
public void send connection preface ( ) throw i o exception { frame writer . connection preface ( ) ; frame writer . setting ( ok http setting ) ; int window size = ok http setting . get initial window size ( setting . default_initial_window_size ) ; if ( window size ! = setting . default_initial_window_size ) { frame writer . window update ( 0 , window size - setting . default_initial_window_size ) ; } }
public long round trip time ( ) throw interrupted exception { latch . await ( ) ; return receive - sent ; }
public boolean have next ( ) { return have next inet socket address ( ) || have next proxy ( ) || have next postpone ( ) ; }
@ override public void on stream ( frame stream stream ) throw i o exception { stream . close ( error code . refused_stream ) ; }
public cache control cache control ( ) { cache control result = cache control ; return result ! = null ? result : ( cache control = cache control . parse ( header ) ) ; }
public void request header start ( call call ) { }
public void request body end ( call call , long byte count ) { }
public void response body end ( call call , long byte count ) { }
public void on closing ( web socket web socket , int code , string reason ) { }
public void on failure ( web socket web socket , throwable t , @ nullable response response ) { }
public int connection count ( ) { return delegate . connection count ( ) ; }
public void detach with violence ( ) { codec . cancel ( ) ; transmitter . exchange message do ( this , true , true , null ) ; }
public int read timeout millis ( ) { return read timeout ; }
public final string string ( ) throw i o exception { try ( buffer source source = source ( ) ) { charset charset = util . bom aware charset ( source , charset ( ) ) ; return source . read string ( charset ) ; } }
public long size ( ) { return size ; }
public byte string hmac sha256 ( byte string key ) { return hmac ( `` hmac s h a256 `` , key ) ; }
public byte string hash ( ) { byte [ ] result = message digest ! = null ? message digest . digest ( ) : mac . do final ( ) ; return byte string . of ( result ) ; }
public string get association type ( ) { return _assoc type ; }
public int get pre expiry assoc lock interval ( ) { return _pre expiry assoc lock interval ; }
public void set max nonce age ( int age second ) { _nonce verifier . set max age ( age second ) ; }
public map extract query params ( url url ) throw unsupported encode exception { if ( url . get query ( ) == null ) return null ; map params map = new hash map ( ) ; list param list = array . a list ( url . get query ( ) . split ( `` & `` ) ) ; iterator iter = param list . iterator ( ) ; while ( iter . have next ( ) ) { string key value = ( string ) iter . next ( ) ; int equal po = key value . index of ( `` = `` ) ; string key = equal po > -1 ? u r l decoder . decode ( key value . substring ( 0 , equal po ) , `` utf-8 `` ) : u r l decoder . decode ( key value , `` utf-8 `` ) ; string value ; if ( equal po < = -1 ) value = null ; else if ( equal po + 1 > key value . length ( ) ) value = `` `` ; else value = u r l decoder . decode ( key value . substring ( equal po + 1 ) , `` utf-8 `` ) ; list exist value = ( list ) params map . get ( key ) ; if ( exist value == null ) { list new value = new array list ( ) ; new value . add ( value ) ; params map . put ( key , new value ) ; } else exist value . add ( value ) ; } return params map ; }
public void set auth response ( message auth response ) { this . _auth response = auth response ; }
public yadis resolver get yadis resolver ( ) { return _yadis resolver ; }
public int get max redirects ( ) { return _max redirect ; }
public void set content type ( string type ) { _content type = type ; }
public void set mac key ( string key ) { set ( `` mac_key `` , key ) ; }
public parameter list get parameter ( ) { return _parameters ; }
public void validate ( ) throw message exception { list require field = get require field ( ) ; iterator param iter = _params . get parameter ( ) . iterator ( ) ; while ( param iter . have next ( ) ) { parameter param = ( parameter ) param iter . next ( ) ; if ( ! param . be valid ( ) ) throw new message exception ( `` invalid parameter : `` + param ) ; } if ( require field == null ) return ; iterator req iter = require field . iterator ( ) ; while ( req iter . have next ( ) ) { string require = ( string ) req iter . next ( ) ; if ( ! have parameter ( require ) ) throw new message exception ( `` require parameter miss : `` + require ) ; } }
public static boolean have extension factory ( string type uri ) { return _extension factory . contains key ( type uri ) ; }
public string get extension alias ( string extension type uri ) { return ( _ext alias . get ( extension type uri ) ! = null ) ? ( string ) _ext alias . get ( extension type uri ) : null ; }
public int get max auth age ( ) { string max auth age = get parameter value ( `` max_auth_age `` ) ; if ( max auth age ! = null ) return integer . parse int ( max auth age ) ; else return -1 ; }
public void set auth time ( date timestamp ) { set ( `` auth_time `` , _date format . format ( timestamp ) ) ; }
public void set type uri ( string type uri ) { _type uri = type uri ; }
public parameter list get parameter ( ) { return _parameters ; }
public void add attribute ( string attr , boolean require ) { string level = require ? `` require `` : `` optional `` ; parameter level param = _parameters . get parameter ( level ) ; parameter new param ; if ( level param == null ) { new param = new parameter ( level , multival encode ( attr ) ) ; } else { new param = new parameter ( level , level param . get value ( ) + `` , `` + multival encode ( attr ) ) ; _parameters . remove parameter ( level ) ; } _parameters . set ( new param ) ; if ( debug ) _log . debug ( `` add new attribute to s reg request : `` + attr + `` require : `` + require ) ; }
public string get attribute value ( string attr ) { return get parameter value ( attr ) ; }
public void set enforce rp id ( boolean enforce rp id ) { _realm verifier . set enforce rp id ( enforce rp id ) ; }
public void set socket timeout ( int socket timeout ) { this . _socket timeout = socket timeout ; }
public string get string representation ( ) { return this . string representation ; }
public boolean be handle ( ) { return true ; }
public void define ( final string name , final string description , final category category ) { define ( name , description , category , null ) ; }
public boolean be handle ( ) { if ( handler == null ) { return false ; } return handler . be handle ( ) ; }
public command get command ( final string command id ) { check id ( command id ) ; command command = ( command ) handle object by id . get ( command id ) ; if ( command == null ) { command = new command ( command id ) ; command . should fire event = should command fire event ; handle object by id . put ( command id , command ) ; command . add command listener ( this ) ; if ( execution listener ! = null ) { command . add execution listener ( execution listener ) ; } } return command ; }
public set get define parameter type id ( ) { return collection . unmodifiable set ( defined parameter type id ) ; }
public void fire post execute success ( string command id , object return value ) { if ( execution listener ! = null ) { execution listener . post execute success ( command id , return value ) ; } }
public throwable get cause ( ) { return cause ; }
protect final boolean be listener attached ( ) { return listener list ! = null ; }
public final boolean be define ( ) { return define ; }
public void set label ( string name ) { label = name ; }
public void add match ( i undo context context ) { child . add ( context ) ; }
public i undoable operation get operation ( ) { return operation ; }
public void add context ( i undo context context ) { if ( trigger operation ! = null ) { trigger operation . add context ( context ) ; recompute context ( ) ; } }
public boolean match ( i undo context context ) { return context == this ; }
protect final void fire state change ( final object old value ) { for ( object listener : get listener ( ) ) { final i state listener state listener = ( i state listener ) listener ; state listener . handle state change ( this , old value ) ; } }
public final string get id ( ) { return id ; }
public static final int compare ( final int leave , final int right ) { return leave - right ; }
public int describe ( input stream content , i content description description ) throw i o exception { byte [ ] buffer = new byte [ signature . length ] ; int not valid = require ? invalid : indeterminate ; if ( content . skip ( offset ) < offset ) return not valid ; if ( content . read ( buffer ) ! = buffer . length ) return not valid ; for ( int i = 0 ; i < signature . length ; i++ ) if ( signature [ i ] ! = buffer [ i ] ) return not valid ; return valid ; }
protect static final int hash code ( final object [ ] array ) { if ( array == null ) { return 0 ; } int hash code= array . get class ( ) . get name ( ) . hash code ( ) ; for ( object element : array ) { hash code= hash code * hash_factor + hash code ( element ) ; } return hash code ; }
public final expression info compute expression info ( ) { expression info result= new expression info ( ) ; collect expression info ( result ) ; return result ; }
public static expression converter get default ( ) { return instance ; }
public void mark default variable access ( ) { f have default variable access= true ; }
protect org . eclipse . core . filebuffers . i document factory get document factory ( i content type [ ] content type ) { org . eclipse . core . filebuffers . i document factory factory= do get document factory ( content type ) ; while ( factory == null ) { content types= compute base content type ( content type ) ; if ( content type == null ) break ; factory= do get document factory ( content type ) ; } return factory ; }
protect i annotation model factory get annotation model factory ( string extension ) { set < i configuration element > set= f annotation model factory descriptor . get ( extension ) ; if ( set ! = null ) { i configuration element entry= select configuration element ( set ) ; return get extension ( entry , f annotation model factory , i annotation model factory . class ) ; } return null ; }
protect abstract file buffer create text file buffer ( i path location , location kind location kind ) { assert . be legal ( location kind ! = location kind . ifile ) ; return new file store text file buffer ( this ) ; }
protect file store file buffer create text file buffer ( i file store location ) { return new file store text file buffer ( this ) ; }
public void set exists ( boolean value ) { if ( value ) set ( attribute_exists ) ; else clear ( attribute_exists ) ; }
public void set name ( string name ) { if ( name == null ) throw new illegal argument exception ( ) ; this . name = name ; }
protect void grow ( ) { object [ ] expand = new object [ element . length + grow_size ] ; system . arraycopy ( element , 0 , expand , 0 , element . length ) ; element = expand ; }
public final void remove job change listener ( i job change listener listener ) { super . remove job change listener ( listener ) ; }
public final void set system ( boolean value ) { super . set system ( value ) ; }
public final void cancel ( ) { super . cancel ( ) ; }
protect final boolean be lock owner thread ( ) { return manager . be lock owner ( ) ; }
public void delete child ( i path parent key , string local name ) { if ( this . be immutable ( ) ) handle immutable tree ( ) ; data tree node node = find node at ( parent key ) ; if ( node == null || ( ! node . include child ( local name ) ) ) { handle not find ( node == null ? parent key : parent key . append ( local name ) ) ; } else { this . replace node ( parent key , node . copy without child ( local name ) ) ; } }
public delta data tree reroot ( ) { / * self mutex critical region * / reroot ( this ) ; return this ; }
protect void simplify ( i comparator comparer ) { if ( parent == null ) return ; set root node ( root node . simplify with parent ( root key ( ) , parent , comparer ) ) ; }
public void delete blob ( set < universal unique identifier > set ) { for ( universal unique identifier id : set ) delete blob ( id ) ; }
protect boolean equal ( i resource one , i resource another ) { return one . get full path ( ) . equal ( another . get full path ( ) ) ; }
public uri compute u r i ( i path workspace path , boolean canonical ) { i path child path = workspace path . remove first segment ( chop ) ; uri root u r i = canonical ? get canonical root ( ) : root ; root u r i = get manager ( workspace path ) . resolve u r i ( root u r i ) ; if ( child path . segment count ( ) == 0 ) return root u r i ; try { return efs . get store ( root u r i ) . get file store ( child path ) . to u r i ( ) ; } catch ( core exception e ) { return null ; } }
public void release for gc ( ) { this . child = null ; this . resource = null ; this . store = null ; this . file info = null ; }
public void startup ( i progress monitor monitor ) { sub monitor sub monitor = sub monitor . convert ( monitor , 1 ) ; preference preference = resource plugin . get plugin ( ) . get plugin preference ( ) ; preference . add property change listener ( this ) ; refresh job = new refresh job ( ) ; monitor = new monitor manager ( workspace , this ) ; boolean auto refresh = preference . get boolean ( resource plugin . pref_auto_refresh ) ; if ( auto refresh ) manage auto refresh ( auto refresh , sub monitor . split ( 1 ) ) ; }
public void clear refresh ( i project target ) { workspace . clear ( get refresh location for ( target ) . to file ( ) ) ; }
public i path get location ( ) { return meta area location ; }
protect void grow ( ) { object [ ] expand = new object [ element . length + grow_size ] ; system . arraycopy ( element , 0 , expand , 0 , element . length ) ; element = expand ; }
public i marker find marker ( i resource resource , long id ) { marker info info = find marker info ( resource , id ) ; return info == null ? null : new marker ( resource , info . get id ( ) ) ; }
public boolean be subtype ( string type , string super type ) { return cache . be subtype ( type , super type ) ; }
public i content type matcher get matcher ( ) { return matcher ; }
public string [ ] get builder id ( ) { return builder id ; }
public void set ( int mask ) { flags |= mask ; }
public static i file info attribute to file info ( resource attribute attribute ) { i file info file info = efs . create file info ( ) ; file info . set attribute ( efs . attribute_read_only , attribute . be read only ( ) ) ; file info . set attribute ( efs . attribute_executable , attribute . be executable ( ) ) ; file info . set attribute ( efs . attribute_archive , attribute . be archive ( ) ) ; file info . set attribute ( efs . attribute_hidden , attribute . be hidden ( ) ) ; file info . set attribute ( efs . attribute_symlink , attribute . be symbolic link ( ) ) ; file info . set attribute ( efs . attribute_group_read , attribute . be set ( efs . attribute_group_read ) ) ; file info . set attribute ( efs . attribute_group_write , attribute . be set ( efs . attribute_group_write ) ) ; file info . set attribute ( efs . attribute_group_execute , attribute . be set ( efs . attribute_group_execute ) ) ; file info . set attribute ( efs . attribute_other_read , attribute . be set ( efs . attribute_other_read ) ) ; file info . set attribute ( efs . attribute_other_write , attribute . be set ( efs . attribute_other_write ) ) ; file info . set attribute ( efs . attribute_other_execute , attribute . be set ( efs . attribute_other_execute ) ) ; return file info ; }
public int compare ( object old info , object new info ) { if ( old info == null & & new info == null ) return 0 ; if ( old info == null || new info == null ) return 1 ; return test equality ( old info , new info ) ? 0 : 1 ; }
public element tree get subtree ( i path key ) { / * the subtree of the root of this tree be just this tree * / if ( key . be root ( ) ) { return this ; } try { data tree node element node = ( data tree node ) tree . copy complete subtree ( key ) ; return new element tree ( element node ) ; } catch ( object not find exception e ) { element not find ( key ) ; return null ; } }
protect void initialize ( data tree node root node ) { / * create the implicit root node * / initialize ( new delta data tree ( new data tree node ( null , null , new abstract data tree node [ ] { root node } ) ) ) ; }
public final i resource delta get delta ( i project project ) { return super . get delta ( project ) ; }
public static i model provider descriptor [ ] get model provider descriptor ( ) { return model provider manager . get default ( ) . get descriptor ( ) ; }
public i status validate change ( i resource delta delta , i progress monitor monitor ) { return new model status ( i status . ok , resource plugin . pi_resources , descriptor . get id ( ) , status . ok_status . get message ( ) ) ; }
public void reset monitor ( i resource resource , i progress monitor progress monitor ) { super . reset monitor ( resource , progress monitor ) ; }
public boolean be read only ( ) { return ( attribute & efs . attribute_read_only ) ! = 0 ; }
public boolean be set ( int mask ) { return ( attribute & mask ) ! = 0 ; }
public void set read only ( boolean read only ) { set ( efs . attribute_read_only , read only ) ; }
public string [ ] get variable name ( string variable , i resource resource ) { return null ; }
public synchronize void remove property change listener ( i property change listener listener ) { listener . remove ( listener ) ; if ( listener . size ( ) == 0 ) { eclipse preference prefs = get plugin preference ( false ) ; if ( prefs ! = null ) { prefs . remove preference change listener ( this ) ; } plugin root . remove node change listener ( this ) ; } }
public boolean get default boolean ( string name ) { return get default preference ( ) . get boolean ( name , boolean_default_default ) ; }
public void set value ( string name , double value ) { if ( double . be na n ( value ) ) throw new illegal argument exception ( ) ; final double double value = get double ( name ) ; if ( value == double value ) return ; double old value = double . value of ( double value ) ; double new value = double . value of ( value ) ; try { notify = false ; if ( get default double ( name ) == value ) get plugin preference ( true ) . remove ( name ) ; else get plugin preference ( true ) . put double ( name , value ) ; fire property change event ( name , old value , new value ) ; } finally { notify = true ; } }
public float get default float ( string name ) { return get default preference ( ) . get float ( name , float_default_default ) ; }
public int get default int ( string name ) { return get default preference ( ) . get int ( name , int_default_default ) ; }
public string get default string ( string name ) { return get default preference ( ) . get ( name , string_default_default ) ; }
public void set default ( string name , string value ) { if ( value == null ) throw new illegal argument exception ( ) ; get default preference ( ) . put ( name , value ) ; }
public void add log listener ( i log listener listener ) { synchronize ( log listener ) { log listener . add ( listener ) ; } }
public static void remove stats ( string event name , object blame object ) { synchronize ( stat map ) { for ( iterator < performance stats > it = stat map . key set ( ) . iterator ( ) ; it . have next ( ) ; ) { performance stats stats = it . next ( ) ; if ( stats . get event ( ) . equal ( event name ) & & stats . get blame ( ) . equal ( blame object ) ) it . remove ( ) ; } } }
public string get event ( ) { return event ; }
public void start run ( ) { if ( enable ) start run ( null ) ; }
public static i path get state location ( bundle bundle ) { return internal platform . get default ( ) . get state location ( bundle ) ; }
public static i log get log ( bundle bundle ) { return internal platform . get default ( ) . get log ( bundle ) ; }
public static string get o s arch ( ) { return internal platform . get default ( ) . get o s arch ( ) ; }
public static string [ ] get application args ( ) { return internal platform . get default ( ) . get application args ( ) ; }
public static i bundle group provider [ ] get bundle group provider ( ) { return internal platform . get default ( ) . get bundle group provider ( ) ; }
public static bundle [ ] get host ( bundle bundle ) { return internal platform . get default ( ) . get host ( bundle ) ; }
public final i log get log ( ) { return internal platform . get default ( ) . get log ( get bundle ( ) ) ; }
public final input stream open stream ( i path file ) throw i o exception { return file locator . open stream ( get bundle ( ) , file , false ) ; }
protect i configuration element get configuration element ( ) { return f configuration element ; }
protect object get adapter ( object element , class < ? > type ) { return debug plugin . get adapter ( element , type ) ; }
public synchronize i expression manager get expression manager ( ) { if ( f expression manager == null ) { f expression manager = new expression manager ( ) ; } return f expression manager ; }
protect void fire change ( ) { if ( ! f suppress change ) { ( ( launch manager ) get launch manager ( ) ) . fire update ( this , launch manager . change ) ; ( ( launch manager ) get launch manager ( ) ) . fire update ( new i launch [ ] { this } , launch manager . change ) ; } }
protect void set attribute ( final string attribute name , final int value ) throw core exception { i workspace workspace= resource plugin . get workspace ( ) ; i workspace runnable runnable= monitor - > ensure marker ( ) . set attribute ( attribute name , value ) ; workspace . run ( runnable , get marker rule ( ) , i workspace . avoid_update , null ) ; }
public void fire suspend event ( int detail ) { fire event ( new debug event ( this , debug event . suspend , detail ) ) ; }
public void set flag ( byte flag ) { this . flag = flag ; }
public boolean be change ( ) { return ( ( flag & memory byte . change ) == memory byte . change ) ; }
public void set big endian ( boolean be big endian ) { flags |= memory byte . big_endian ; if ( ! be big endian ) flag ^= memory byte . big_endian ; }
public void launch configuration change ( i launch configuration configuration ) { if ( f config == null || configuration . be work copy ( ) ) { return ; } if ( f config . equal ( configuration ) ) { try { string locator memento = configuration . get attribute ( i launch configuration . attr_source_locator_memento , ( string ) null ) ; if ( locator memento == null ) { initialize default ( configuration ) ; } else { initialize from memento ( locator memento , configuration ) ; } } catch ( core exception e ) { } } }
protect i source container get delegate container ( i source container container ) { return container ; }
public file get file ( ) { return f file ; }
protected list < string > get list attribute ( string key , list < string > default value ) throw core exception { object attr = get attribute table ( ) . get ( key ) ; if ( attr ! = null ) { if ( attr instanceof list ) { return ( list < string > ) attr ; } throw new debug exception ( new status ( i status . error , debug plugin . get unique identifier ( ) , debug exception . request_failed , message format . format ( debug core message . launch configuration info_ attribute__0__is_not_of_type_java_util_ list__1 , key ) , null ) ) ; } return default value ; }
protect string get key attribute ( element element ) throw core exception { string key = element . get attribute ( key ) ; if ( key == null ) { throw get invalid format debug exception ( ) ; } return key ; }
protect void set visible attribute ( set < string > visible attribute ) { if ( visible attribute ! = null ) { f visible attribute = new hash set < > ( visible attribute ) ; } }
public i logical structure type [ ] get logical structure ( i value value ) { if ( f model identifier . equal ( value . get model identifier ( ) ) ) { return get delegate ( ) . get logical structure type ( value ) ; } return new i logical structure type [ 0 ] ; }
public static void close archive ( ) { synchronize ( fg zip file cache ) { for ( zip file file : fg zip file cache . value ( ) ) { synchronize ( file ) { try { file . close ( ) ; } catch ( i o exception e ) { debug plugin . log ( e ) ; } } } fg zip file cache . clear ( ) ; } }
protect i workspace root get workspace root ( ) { return resource plugin . get workspace ( ) . get root ( ) ; }
protect void fire event ( debug event event ) { debug plugin . get default ( ) . fire debug event set ( new debug event [ ] { event } ) ; }
public static boolean be empty ( ) { synchronize ( log listener ) { return ( log listener . be empty ( ) ) & & ( log writer == null ) ; } }
public static boolean be valid window path ( string path ) { return be valid path ( path , true ) ; }
public i progress monitor get wrap progress monitor ( ) { return progress monitor ; }
public static string last segment ( uri location ) { string path = location . get path ( ) ; if ( path == null ) return new path ( location . get scheme specific part ( ) ) . last segment ( ) ; return new path ( path ) . last segment ( ) ; }
public static url to u r l ( uri uri ) throw malformed u r l exception { return new url ( uri . to string ( ) ) ; }
public static string get segment ( string path , int segment ) { int start = path . index of ( i path . separator ) == 0 ? 1 : 0 ; int end = path . index of ( i path . separator , start ) ; if ( end == path . length ( ) - 1 ) end = -1 ; for ( int i = 0 ; i < segment ; i++ ) { if ( end == -1 ) return null ; start = end + 1 ; end = path . index of ( i path . separator , start ) ; } if ( end == -1 ) end = path . length ( ) ; return path . substring ( start , end ) ; }
public static preference service get default ( ) { if ( instance == null ) instance = new preference service ( ) ; return instance ; }
public string name ( ) { return name ; }
public synchronize void exit read ( ) { if ( write lockowner == thread . current thread ( ) ) return ; if ( -- status == 0 ) notify all ( ) ; }
public string get value ( ) { return value ; }
public string get value ( ) { return value ; }
public static i contributor create contributor ( object determine object ) { string id = determine object . to string ( ) ; return new registry contributor ( id , id , null , null ) ; }
public static i extension registry create registry ( registry strategy strategy , object master token , object user token ) { return new extension registry ( strategy , master token , user token ) ; }
public boolean cache lazy loading ( ) { return true ; }
public static final boolean camel case match ( char [ ] pattern , int pattern start , int pattern end , char [ ] name , int name start , int name end ) { return camel case match ( pattern , pattern start , pattern end , name , name start , name end , false/ * not the same count of part * / ) ; }
public static char [ ] [ ] to char array ( list < string > string list ) { if ( string list == null ) return null ; char [ ] [ ] result = new char [ string list . size ( ) ] [ ] ; for ( int i = 0 ; i < result . length ; i++ ) result [ i ] = string list . get ( i ) . to char array ( ) ; return result ; }
public static final int hash code ( char [ ] array ) { int hash = array . hash code ( array ) ; return hash & 0x7 f f f f f f f ; }
public static final int occurences of ( char to be find , char [ ] array ) { int count = 0 ; for ( int i = 0 ; i < array . length ; i++ ) if ( to be find == array [ i ] ) count++ ; return count ; }
public i compilation unit get work copy ( ) { return this . work copy ; }
public void reset a s t ( ) { this . operation . ast = null ; put problem ( i java model marker . java_model_problem_marker , null ) ; put problem ( i java model marker . task_marker , null ) ; }
public list body declaration ( ) { return this . body declaration ; }
public boolean be marker annotation ( ) { return ( this instanceof marker annotation ) ; }
public static list property descriptor ( int api level ) { return property_descriptors ; }
public list body declaration ( ) { return this . body declaration ; }
public assignment . operator get operator ( ) { return this . assignment operator ; }
public static boolean safe equal ( object o1 , object o2 ) { if ( o1 == o2 ) { return true ; } if ( o1 == null || o2 == null ) { return false ; } return o1 . equal ( o2 ) ; }
public final i bind [ ] create binding ( string [ ] bind key ) { int length = binding key . length ; i bind [ ] result = new i bind [ length ] ; for ( int i = 0 ; i < length ; i++ ) { result [ i ] = null ; if ( this . compilation unit resolver ! = null ) { result [ i ] = this . compilation unit resolver . create binding ( bind key [ i ] ) ; } } return result ; }
public work copy owner get work copy owner ( ) { return null ; }
public void set expression ( expression expression ) { support only in12 ( ) ; a s t node old child = this . optional expression ; pre replace child ( old child , expression , expression_property ) ; this . optional expression = expression ; post replace child ( old child , expression , expression_property ) ; }
public final class get element type ( ) { return this . element type ; }
public void set type ( type type ) { unsupported in2 ( ) ; if ( type == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . type ; pre replace child ( old child , type , type_property ) ; this . type = type ; post replace child ( old child , type , type_property ) ; }
public final boolean be doc comment ( ) { return ( this instanceof javadoc ) ; }
public message [ ] get message ( ) { if ( this . message == null ) { int problem length = this . problem . length ; if ( problem length == 0 ) { this . message = empty_messages ; } else { this . message = new message [ problem length ] ; for ( int i = 0 ; i < problem length ; i++ ) { i problem problem = this . problem [ i ] ; int start = problem . get source start ( ) ; int end = problem . get source end ( ) ; this . message [ i ] = new message ( problem . get message ( ) , start , end - start + 1 ) ; } } } return this . message ; }
public object get statement recovery data ( ) { return this . statement recovery data ; }
public list annotation ( ) { return this . annotation ; }
public anonymous class declaration get anonymous class declaration ( ) { return this . optional anonymous class declaration ; }
public i method bind resolve constructor binding ( ) { return this . ast . get binding resolver ( ) . resolve constructor ( this ) ; }
public expression get expression ( ) { support only in17 ( ) ; unsupported without preview error ( ) ; return this . conditonal expression ; }
public void set pattern ( pattern pattern ) { support only in17 ( ) ; unsupported without preview error ( ) ; a s t node old child = this . pattern ; pre replace child ( old child , pattern , pattern_property ) ; this . pattern = pattern ; post replace child ( old child , pattern , pattern_property ) ; }
public void set body ( block body ) { if ( body == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . body ; pre replace child ( old child , body , body_property ) ; this . body = body ; post replace child ( old child , body , body_property ) ; }
public boolean have parenthesis ( ) { return this . have parenthesis ; }
public final i bind resolve binding ( ) { return this . ast . get binding resolver ( ) . resolve reference ( this ) ; }
public void set receiver type ( type receiver type ) { unsupported in2_3_4 ( ) ; a s t node old child = this . optional receiver type ; pre replace child ( old child , receiver type , receiver_type_property ) ; this . optional receiver type = receiver type ; post replace child ( old child , receiver type , receiver_type_property ) ; }
public type get return type ( ) { return internal get return type ( ) ; }
public void set return type2 ( type type ) { unsupported in2 ( ) ; this . return type2 initialized = true ; a s t node old child = this . return type ; pre replace child ( old child , type , return_type2_property ) ; this . return type = type ; post replace child ( old child , type , return_type2_property ) ; }
public void set expression ( expression expression ) { a s t node old child = this . optional expression ; pre replace child ( old child , expression , expression_property ) ; this . optional expression = expression ; post replace child ( old child , expression , expression_property ) ; }
public static boolean be public ( int flag ) { return ( flags & public ) ! = 0 ; }
public boolean be final ( ) { return this . modifier keyword == modifier keyword . final_keyword ; }
public boolean be private ( ) { return this . modifier keyword == modifier keyword . private_keyword ; }
public void set open ( boolean be open ) { pre value change ( open_property ) ; this . be open = be open ; post value change ( open_property ) ; }
public name get name ( ) { return this . name ; }
public static a s t node perform ( a s t node root , i source range range ) { return perform ( root , range . get offset ( ) , range . get length ( ) ) ; }
public void set operator ( postfix expression . operator operator ) { if ( operator == null ) { throw new illegal argument exception ( ) ; } pre value change ( operator_property ) ; this . operator = operator ; post value change ( operator_property ) ; }
public void insert at ( a s t node node , int index , text edit group edit group ) { if ( node == null ) { throw new illegal argument exception ( ) ; } internal insert at ( node , index , be insert bound to previous by default ( node ) , edit group ) ; }
public void set type ( type type ) { if ( type == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . type ; pre replace child ( old child , type , type_property ) ; this . type = type ; post replace child ( old child , type , type_property ) ; }
public name get qualifier ( ) { return this . optional qualifier ; }
public void set switch label rule ( boolean switch label rule ) { unsupported below14 ( ) ; pre value change ( switch_labeled_rule_property ) ; this . switch labeled rule = switch label rule ; post value change ( switch_labeled_rule_property ) ; }
public list fragment ( ) { return this . fragment ; }
public final i type bind resolve binding ( ) { return this . ast . get binding resolver ( ) . resolve type ( this ) ; }
public boolean be interface ( ) { return this . be interface ; }
public type get superclass type ( ) { unsupported in2 ( ) ; return this . optional superclass type ; }
public void set superclass ( name superclass name ) { internal set superclass ( superclass name ) ; }
public void set type declaration ( type declaration decl ) { internal set type declaration ( decl ) ; }
public void set type ( type type ) { if ( type == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . type ; pre replace child ( old child , type , type_property ) ; this . type = type ; post replace child ( old child , type , type_property ) ; }
public list type argument ( ) { return this . type argument ; }
public final child property descriptor get name property ( ) { return internal name property ( ) ; }
public list fragment ( ) { return this . variable declaration fragment ; }
public static boolean be native ( int flag ) { return ( flags & acc native ) ! = 0 ; }
public static boolean be public ( int flag ) { return ( flags & acc public ) ! = 0 ; }
public static boolean be annotation ( int flag ) { return ( flags & acc annotation ) ! = 0 ; }
public static boolean be annnotation default ( int flag ) { return ( flags & acc annotation default ) ! = 0 ; }
public static int get tab width ( map option ) { if ( option == null ) { throw new illegal argument exception ( ) ; } return get int value ( option , default code formatter constant . formatter_tab_size , 4 ) ; }
public static i status validate field name ( string name , string source level , string compliance level ) { return validate identifier ( name , source level , compliance level ) ; }
public final boolean be synthetic ( ) { return this . synthetic ; }
public void remove all index entry ( ) { if ( this . index ! = null ) this . index . remove ( get container relative path ( ) ) ; }
public static i search pattern create search pattern ( string string pattern , int search for , int limit to , boolean be case sensitive ) { int match mode = string pattern . index of ( ' * ' ) ! = -1 || string pattern . index of ( ' ? ' ) ! = -1 ? search pattern . r_pattern_match : search pattern . r_exact_match ; int match rule = be case sensitive ? match mode | search pattern . r_case_sensitive : match mode ; return new search pattern adapter ( search pattern . create pattern ( string pattern , search for , limit to , match rule ) ) ; }
public final void set rule ( int rule ) { this . rule = rule ; }
public static i class file reader create default class file reader ( input stream stream , int decode flag ) { try { return new class file reader ( util . get input stream a byte array ( stream ) , decode flag ) ; } catch ( class format exception | i o exception e ) { return null ; } }
public boolean be package ( string [ ] pkg ) { return false ; }
public void generate code ( block scope current scope , code stream code stream , boolean value require ) { int pc = code stream . position ; if ( value require ) { code stream . generate constant ( this . constant , this . implicit conversion ) ; } code stream . record position from ( pc , this . source start ) ; }
public type bind resolve at type ( block scope scope , type bind u ) { if ( this . resolve type == null ) { this . resolve type = this . local . binding . type ; } return this . resolve type ; }
public static string extract signature ( string line ) { if ( line == null || line . be empty ( ) || line . char at ( 0 ) ! = ' ' ) return null ; return trim tail ( line . substring ( 1 ) ) ; }
public categorize problem [ ] get error ( ) { categorize problem [ ] report problem = get problem ( ) ; int error count = 0 ; for ( int i = 0 ; i < this . problem count ; i++ ) { if ( report problem [ i ] . be error ( ) ) error count++ ; } if ( error count == this . problem count ) return report problem ; categorize problem [ ] error = new categorize problem [ error count ] ; int index = 0 ; for ( int i = 0 ; i < this . problem count ; i++ ) { if ( report problem [ i ] . be error ( ) ) error [ index++ ] = report problem [ i ] ; } return error ; }
public boolean should cleanup ( int index ) { return index < this . annotation processor start index ; }
public static i error handle policy exit on first error ( ) { return new i error handling policy ( ) { @ override public boolean stop on first error ( ) { return true ; } @ override public boolean proceed on error ( ) { return false ; } @ override public boolean ignore all error ( ) { return false ; } } ; }
protect int resume on syntax error ( ) { return halt ; }
public long get annotation tag bit ( ) { return 0 ; }
public field bind original ( ) { return this ; }
public final boolean be parameter erasure equal ( method bind method ) { type binding [ ] args = method . parameter ; if ( this . parameter == args ) return true ; int length = this . parameter . length ; if ( length ! = args . length ) return false ; for ( int i = 0 ; i < length ; i++ ) if ( type binding . not equal ( this . parameter [ i ] , args [ i ] ) & & type binding . not equal ( this . parameter [ i ] . erasure ( ) , args [ i ] . erasure ( ) ) ) return false ; return true ; }
public final boolean be abstract ( ) { return ( this . modifier & class file constant . acc abstract ) ! = 0 ; }
public final boolean be default abstract ( ) { return ( this . modifier & extra compiler modifier . acc default abstract ) ! = 0 ; }
public boolean be default method ( ) { return ( this . modifier & extra compiler modifier . acc default method ) ! = 0 ; }
public static string sanitize file name ( path path ) { string p = path . get file name ( ) . to string ( ) ; if ( p . length ( ) > 1 & & p . char at ( p . length ( ) - 1 ) == '/ ' ) { return p . substring ( 0 , p . length ( ) - 1 ) ; } return p ; }
public void about to compile ( source file unit ) { string message = message . bind ( message . build_compiling , unit . resource . get full path ( ) . remove last segment ( 1 ) . make relative ( ) . to string ( ) ) ; sub task ( message ) ; }
public static void build finish ( ) { build notifier . reset problem counter ( ) ; }
public i java model status verify ( ) { i java element parent element = get parent element ( ) ; if ( parent element == null ) { return new java model status ( i java model status constant . no_elements_to_process ) ; } string package name = this . pkg name == null ? null : util . concat with ( this . pkg name , ' . ' ) ; i java project project = parent element . get java project ( ) ; if ( this . pkg name == null || ( this . pkg name . length > 0 & & java convention . validate package name ( package name , project . get option ( java core . compiler_source , true ) , project . get option ( java core . compiler_compliance , true ) ) . get severity ( ) == i status . error ) ) { return new java model status ( i java model status constant . invalid_name , package name ) ; } i java element root = get parent element ( ) ; if ( root . be read only ( ) ) { return new java model status ( i java model status constant . read_only , root ) ; } i container parent folder = ( i container ) ( ( java element ) root ) . resource ( ) ; int i ; for ( i = 0 ; i < this . pkg name . length ; i++ ) { i resource sub folder = parent folder . find member ( this . pkg name [ i ] ) ; if ( sub folder ! = null ) { if ( sub folder . get type ( ) ! = i resource . folder ) { return new java model status ( i java model status constant . name_collision , message . bind ( message . status_name collision , sub folder . get full path ( ) . to string ( ) ) ) ; } parent folder = ( i container ) sub folder ; } } return java model status . verified_ok ; }
public rewrite event find event ( object value , int kind ) { for ( iterator iter= this . event lookup . value ( ) . iterator ( ) ; iter . have next ( ) ; ) { list events= ( list ) iter . next ( ) ; for ( int i= 0 ; i < event . size ( ) ; i++ ) { rewrite event event= ( ( event holder ) event . get ( i ) ) . event ; if ( be node in event ( event , value , kind ) ) { return event ; } if ( event . be list rewrite ( ) ) { rewrite event [ ] children= event . get child ( ) ; for ( int k= 0 ; k < child . length ; k++ ) { if ( be node in event ( child [ k ] , value , kind ) ) { return child [ k ] ; } } } } } return null ; }
public void resource change ( i resource change event event ) { i resource delta delta = event . get delta ( ) ; if ( delta ! = null & & delta . get full path ( ) . be root ( ) & & this . tree . child ! = null ) { for ( i resource delta child : delta . get affected child ( ) ) { directory node directory node = this . tree . child . get ( child . get full path ( ) ) ; if ( directory node ! = null ) traverse for directory ( directory node , child ) ; } } }
public boolean equal ( object o ) { if ( this == o ) return true ; if ( o instanceof external package fragment root ) { external package fragment root other= ( external package fragment root ) o ; return this . external path . equal ( other . external path ) ; } return false ; }
public boolean be on demand ( ) { return this . be on demand ; }
protect void set name source start ( int start ) { this . name start= start ; }
protect object create element info ( ) { return new jar package fragment root info ( ) ; }
public zip file get jar ( ) throw core exception { return java model manager . get java model manager ( ) . get zip file ( get path ( ) ) ; }
protect void exit type ( int body end , int declaration end ) { d o m type type = ( d o m type ) this . f stack . pop ( ) ; type . set source range end ( declaration end ) ; type . set close body range start ( body end ) ; type . set close body range end ( body end ) ; this . f node = type ; }
protect char [ ] get type content ( ) { if ( be type altered ( ) ) { return this . f type . to char array ( ) ; } else { return char operation . subarray ( this . f document , this . f type range [ 0 ] , this . f type range [ 1 ] + 1 ) ; } }
protect void set have body ( boolean have body ) { set mask ( mask_has_body , have body ) ; }
public int get start position ( ) { return this . f source range [ 0 ] ; }
public void set modifier ( int modifier ) { this . modifier = modifier ; }
public string [ ] get path ( ) { return ( string [ ] ) this . path . to array ( new string [ this . path . size ( ) ] ) ; }
protect void set type name ( char [ ] type name ) { this . type name = type name ; }
public i type get handle ( ) { return this . handle ; }
public void set class info name index ( int class info name index ) { this . class info name index = class info name index ; }
public void set integer value ( int integer value ) { this . integer value = integer value ; }
public void set float value ( float float value ) { this . float value = float value ; }
public void set long value ( long long value ) { this . long value = long value ; }
public int get name and type descriptor index ( ) { return this . name and type descriptor index ; }
public k get key ( k key ) { l r u cache entry < k , v > entry = this . entry table . get ( key ) ; if ( entry == null ) { return key ; } return entry . key ; }
public char [ ] get import ( int line number ) { int import start line = this . line number offset - 1 - this . snippet import . length ; return this . snippet import [ line number - import start line ] ; }
public i selection requestor get selection requestor ( final i selection requestor original requestor ) { return new i selection requestor ( ) { @ override public void accept type ( char [ ] package name , char [ ] type name , int modifier , boolean be declaration , char [ ] unique key , int start , int end ) { original requestor . accept type ( package name , type name , modifier , be declaration , unique key , start , end ) ; } @ override public void accept error ( categorize problem error ) { error . set source line number ( error . get source line number ( ) - code snippet to cu mapper . this . line number offset ) ; error . set source start ( error . get source start ( ) - code snippet to cu mapper . this . start pos offset ) ; error . set source end ( error . get source end ( ) - code snippet to cu mapper . this . start pos offset ) ; original requestor . accept error ( error ) ; } @ override public void accept field ( char [ ] declare type package name , char [ ] declare type name , char [ ] name , boolean be declaration , char [ ] unique key , int start , int end ) { original requestor . accept field ( declare type package name , declare type name , name , be declaration , unique key , start , end ) ; } @ override public void accept method ( char [ ] declare type package name , char [ ] declare type name , string enclose declare type signature , char [ ] selector , char [ ] [ ] parameter package name , char [ ] [ ] parameter type name , string [ ] parameter signature , char [ ] [ ] type parameter name , char [ ] [ ] [ ] type parameter bound name , boolean be constructor , boolean be declaration , char [ ] unique key , int start , int end ) { original requestor . accept method ( declare type package name , declare type name , enclose declare type signature , selector , parameter package name , parameter type name , parameter signature , type parameter name , type parameter bound name , be constructor , be declaration , unique key , start , end ) ; } @ override public void accept package ( char [ ] package name ) { original requestor . accept package ( package name ) ; } @ override public void accept type parameter ( char [ ] declare type package name , char [ ] declare type name , char [ ] type parameter name , boolean be declaration , int start , int end ) { original requestor . accept type parameter ( declare type package name , declare type name , type parameter name , be declaration , start , end ) ; } @ override public void accept method type parameter ( char [ ] declare type package name , char [ ] declare type name , char [ ] selector , int selector start , int selector end , char [ ] type parameter name , boolean be declaration , int start , int end ) { original requestor . accept method type parameter ( declare type package name , declare type name , selector , selector start , selector end , type parameter name , be declaration , start , end ) ; } @ override public void accept module ( char [ ] module name , char [ ] unique key , int start , int end ) { original requestor . accept module ( module name , unique key , start , end ) ; } } ; }
public void set create getter setter ( boolean create getter setter ) { java refactoring descriptor util . set boolean ( f argument , create_getter_setter , create getter setter ) ; }
protect static i java element handle to element ( final string project , final string handle ) { return handle to element ( project , handle , true ) ; }
public void set description ( final string description ) { super . set description ( description ) ; }
public void set project ( final string project ) { super . set project ( project ) ; }
public void set selection ( final i source range selection ) { assert . be not null ( selection ) ; f selection= selection ; }
public void set replace instanceof ( final boolean replace ) { f instanceof= replace ; }
public static boolean need parenthesis for right operand ( expression right operand , infix expression infix expression , i type bind leave operand type ) { return need parenthesis ( right operand , infix expression , infix expression . right_operand_property , leave operand type ) ; }
public void set member order preference cache common ( member order preference cache common mpcc ) { f member order preference cache common= mpcc ; }
public static string get path label ( i path path , boolean be o s path ) { string label ; if ( be o s path ) { label= path . to o s string ( ) ; } else { label= path . make relative ( ) . to string ( ) ; } return string . mark l t r ( label ) ; }
public static string change indent ( string code , int code indent level , i java project project , string new indent , string line delim ) { return indent manipulation . change indent ( code , code indent level , code formatter util . get tab width ( project ) , code formatter util . get indent width ( project ) , new indent , line delim ) ; }
public static string get attribute name ( string attribute , int index ) { return attribute + index ; }
public boolean be expand with constructor set ( ) { return f be expand with constructor set ; }
public i java element [ ] search for implementors ( i java element [ ] element , i progress monitor progress monitor ) { if ( ( element ! = null ) & & ( element . length > 0 ) ) { i java element element = element [ 0 ] ; try { if ( element instanceof i member ) { i member member = ( i member ) element ; i type type = member . get declare type ( ) ; if ( type . be interface ( ) ) { i type [ ] implement type = find implementing type ( type , progress monitor ) ; if ( member . get element type ( ) == i java element . method ) { return find method ( ( i method ) member , implement type , progress monitor ) ; } else { return implement type ; } } } } catch ( java model exception e ) { java manipulation plugin . log ( e ) ; } } return null ; }
public string [ ] get create import ( ) { return f create import ; }
public boolean be omit super ( ) { return f omit super ; }
protect void initialize ( ) { need max len variable= false ; need collection to string method= false ; type that need array to string method= new array list < > ( ) ; check need for helper method ( ) ; to string method= f ast . new method declaration ( ) ; to string method . modifier ( ) . add all ( a s t node factory . new modifier ( f ast , modifier . public ) ) ; to string method . set name ( f ast . new simple name ( methodname_to_string ) ) ; to string method . set constructor ( false ) ; to string method . set return type2 ( f ast . new simple type ( f ast . new name ( typename_string ) ) ) ; block body= f ast . new block ( ) ; to string method . set body ( body ) ; f max len variable name= create name suggestion ( max_len_variable_name , name convention . vk_local ) ; }
protect boolean [ ] implement interface ( i type bind member type , string [ ] interface name ) { boolean [ ] result= new boolean [ interface name . length ] ; for ( int i= 0 ; i < interface name . length ; i++ ) { if ( member type . get qualified name ( ) . equal ( interface names [ i ] ) ) result [ i ] = true ; } for ( i type bind intf : member type . get interface ( ) ) { boolean [ ] deeper= implement interface ( intf . get erasure ( ) , interface name ) ; for ( int j= 0 ; j < interface name . length ; j++ ) { result [ j ] = result [ j ] || deeper [ j ] ; } } return result ; }
public static simple name [ ] find by node ( a s t node root , simple name name ) { i bind bind = name . resolve binding ( ) ; if ( bind ! = null ) { simple name rec node= get associate record component node ( name ) ; if ( rec node ! = null ) { i bind rec binding= rec node . resolve binding ( ) ; return find by bind ( root , rec bind ) ; } return find by bind ( root , bind ) ; } simple name [ ] names= find by problem ( root , name ) ; if ( names ! = null ) { return name ; } int parent kind= name . get parent ( ) . get node type ( ) ; if ( parent kind == a s t node . labeled_statement || parent kind == a s t node . break_statement || parent kind == a s t node . continue_statement ) { array list < simple name > res= new array list < > ( ) ; label finder node finder= new label finder ( name , re ) ; root . accept ( node finder ) ; return re . to array ( new simple name [ res . size ( ) ] ) ; } return new simple name [ ] { name } ; }
public static boolean can assign ( i type bind type to assign , i type bind define type ) { type environment type environment= new type environment ( false , true ) ; t type defined= type environment . create ( defined type ) ; t type to assign= type environment . create ( type to assign ) ; return to assign . can assign to ( define ) ; }
public int get access mode ( flow context context , i variable bind local ) { if ( f access mode == null ) return unused ; int index= context . get index from local ( local ) ; if ( index == -1 ) return unused ; return f access mode [ index ] ; }
public void set declaration ( body declaration declaration ) { f declaration= declaration ; }
public void set new element name ( string new name ) { f new element name= new name ; }
public region get tag position ( ) { return f tag position ; }
public static i java search scope create reference scope ( i java element [ ] java element ) { set < i java project > projects= new hash set < > ( ) ; for ( i java element java element : java element ) { project . add ( java element . get java project ( ) ) ; } i java project [ ] prj= project . to array ( new i java project [ project . size ( ) ] ) ; return search engine . create java search scope ( prj , true ) ; }
public void set binding recovery ( boolean binding recovery ) { f binding recovery= binding recovery ; }
public static void collect import ( final i java project project , final a s t node node , final collection < i type bind > type binding , final collection < i bind > static binding , final boolean declaration ) { collect import ( project , node , type binding , static binding , null , declaration ) ; }
public i variable bind [ ] get possible target ( ) { assert . be not null ( f possible target ) ; return f possible target ; }
public string get target name ( ) { return f target name ; }
public boolean need target node ( ) { return f target node ; }
public boolean should use setter ( ) { return f use setter ; }
public type environment get environment ( ) { return f environment ; }
public final boolean be null type ( ) { return get kind ( ) == null_type ; }
public final boolean be generic type ( ) { return get kind ( ) == generic_type ; }
public static boolean should add param javadoc ( method declaration method declaration ) { javadoc javadoc= method declaration . get javadoc ( ) ; if ( javadoc == null ) return false ; if ( method declaration . parameter ( ) . size ( ) == 0 ) return true ; list < tag element > tags= javadoc . tag ( ) ; for ( tag element element : tag ) { if ( tag element . tag_param . equal ( element . get tag name ( ) ) ) return true ; } return false ; }
public static void release ( final i compilation unit unit ) throw core exception { assert . be not null ( unit ) ; final i resource resource= unit . get resource ( ) ; if ( resource ! = null & & resource . get type ( ) == i resource . file ) file buffer . get text file buffer manager ( ) . disconnect ( resource . get full path ( ) , location kind . ifile , new null progress monitor ( ) ) ; }
public static text edit merge ( text edit edit1 , text edit edit2 ) { if ( edit1 instanceof multi text edit & & ! edit1 . have child ( ) ) { return edit2 ; } if ( edit2 instanceof multi text edit & & ! edit2 . have child ( ) ) { return edit1 ; } multi text edit result= new multi text edit ( ) ; merge ( edit1 , edit2 , result ) ; return result ; }
public boolean be manage ( ) { return f be manage ; }
public char get character before start ( ) { int start= get start ( ) ; try { return start == 0 ? ' ' : get document ( ) . get char ( start - 1 ) ; } catch ( bad location exception e ) { return ' ' ; } }
public i method find overridden method in hierarchy ( i type type , i method override ) throw java model exception { i method method= find overridden method in type ( type , override ) ; if ( method ! = null ) { return method ; } i type super class= f hierarchy . get superclass ( type ) ; if ( super class ! = null ) { i method res= find overridden method in hierarchy ( super class , override ) ; if ( res ! = null ) { return re ; } } for ( i type super interface : f hierarchy . get super interface ( type ) ) { i method res= find overridden method in hierarchy ( super interface , override ) ; if ( res ! = null ) { return re ; } } return method ; }
public static i status make committable ( i resource resource , object context ) { return make committable ( new i resource [ ] { resource } , context ) ; }
public static boolean be camel case pattern ( string pattern ) { return search pattern . validate match rule ( pattern , search pattern . r_camelcase_match ) == search pattern . r_camelcase_match ; }
public boolean be warn ( ) { return f severity == i status . warning ; }
protect static i problem location core [ ] filter ( i problem location core [ ] problem , int [ ] problem id ) { array list < i problem location core > result= new array list < > ( ) ; for ( i problem location core problem : problem ) { if ( contains ( problem id , problem . get problem id ( ) ) & & ! contains ( result , problem ) ) { result . add ( problem ) ; } } return result . to array ( new i problem location core [ result . size ( ) ] ) ; }
protect int compute index at offset ( list < ? extend position > position , int offset ) { int i= -1 ; int j= position . size ( ) ; while ( j - i > 1 ) { int k= ( i + j ) > > 1 ; position position= position . get ( k ) ; if ( position . get offset ( ) > = offset ) j= k ; else i= k ; } return j ; }
public void display error message ( final string message ) { platform . get log ( this . get class ( ) ) . error ( message ) ; }
public synchronize analyzer [ ] get analyzer ( ) { initialize extension ( ) ; collection < analyzer > collection = f analyzer . value ( ) ; return collection . to array ( new analyzer [ collection . size ( ) ] ) ; }
protect static void abort ( string message , throwable exception , int code ) throw core exception { throw new core exception ( new status ( i status . error , launch plugin . get unique identifier ( ) , code , message , exception ) ) ; }
protect file get work dir ( v m runner configuration config ) throw core exception { string path = config . get work directory ( ) ; if ( path == null ) { return null ; } file dir = new file ( path ) ; if ( ! dir . be directory ( ) ) { abort ( nls . bind ( launching message . standard v m runner_ specified_working_directory_does_not_exist_or_is_not_a_directory___0__3 , new string [ ] { path } ) , null , i java launch configuration constant . err_working_directory_does_not_exist ) ; } return dir ; }
protected boolean file exists ( file file ) { return file . exists ( ) & & file . be file ( ) ; }
protect library info parse library info ( i process process ) { i stream proxy stream proxy = process . get streams proxy ( ) ; string text = null ; if ( streams proxy ! = null ) { text = stream proxy . get output stream monitor ( ) . get content ( ) ; } if ( text ! = null & & text . length ( ) > 0 ) { int index = text . index of ( bar ) ; if ( index > 0 ) { string version = text . substring ( 0 , index ) ; text = text . substring ( index + 1 ) ; index = text . index of ( bar ) ; if ( index > 0 ) { string boot path = text . substring ( 0 , index ) ; string [ ] boot path = parse path ( boot path ) ; text = text . substring ( index + 1 ) ; index = text . index of ( bar ) ; if ( index > 0 ) { string ext dir path = text . substring ( 0 , index ) ; string endorse dirs path = text . substring ( index + 1 ) ; string [ ] ext dirs = parse path ( ext dir path ) ; string [ ] end dirs = parse path ( endorsed dirs path ) ; return new library info ( version , boot path , ext dirs , end dirs ) ; } } } } return null ; }
default public i runtime classpath entry [ ] resolve runtime classpath entry ( i runtime classpath entry entry , i java project project , boolean exclude test code ) throw core exception { return resolve runtime classpath entry ( entry , project ) ; }
public i path get system library path ( ) { return f system library ; }
public void set boot class path ( string [ ] boot class path ) { f boot class path= boot class path ; }
public boolean be preview enabled ( ) { return f preview enable ; }
public void add all ( change [ ] change ) { for ( change change : change ) { add ( change ) ; } }
public void merge ( composite change change ) { change [ ] others= change . get child ( ) ; for ( change other : others ) { change . remove ( other ) ; add ( other ) ; } }
public change get undo until exception ( ) { return f undo until exception ; }
public void set processor ( refactoring processor processor ) { processor . set refactoring ( this ) ; f processor= processor ; }
public object [ ] get rename element ( ) { return f new name . key set ( ) . to array ( ) ; }
public change get change ( ) { return f change ; }
public void set scheduling rule ( i scheduling rule rule ) { f schedule rule= rule ; }
public change get undo change ( ) { return f undo ; }
public static i refactoring history service get history service ( ) { return refactoring history service . get instance ( ) ; }
public int get check final condition tick ( ) { return f value [ check_final_conditions ] ; }
public i path get destination path ( ) { return f destination path ; }
public string get preview content ( text edit change group [ ] change group , i region region , boolean expand region to full line , int surround line , i progress monitor pm ) throw core exception { return get preview content ( ( text edit base change group [ ] ) change group , region , expand region to full line , surround line , pm ) ; }
public boolean have one group category ( list < group category > group category ) { if ( f combied group category == null ) { f combied group categories= group category set . none ; for ( text edit base change group group : f change group ) { f combied group categories= group category set . union ( f combied group category , group . get group category set ( ) ) ; } } return f combied group category . contain one category ( group category ) ; }
public string get text type ( ) { return f text type ; }
public text edit [ ] get text edits ( ) { return f text edit group . get text edits ( ) ; }
public static refactoring contribution manager get instance ( ) { if ( f instance == null ) f instance= new refactoring contribution manager ( ) ; return f instance ; }
public string get refactoring id ( final refactoring contribution contribution ) { assert . be not null ( contribution ) ; populate cache ( ) ; return f id cache . get ( contribution ) ; }
public static string escape string ( final string string ) { if ( string . index of ( delimiter_component ) < 0 ) { final int length= string . length ( ) ; final string builder buffer= new string builder ( length + 16 ) ; for ( int index= 0 ; index < length ; index++ ) { final char character= string . char at ( index ) ; if ( delimiter_component == character ) buffer . append ( delimiter_component ) ; buffer . append ( character ) ; } return buffer . to string ( ) ; } return string ; }
public refactoring descriptor request descriptor ( final refactoring descriptor proxy proxy , i progress monitor monitor ) { assert . be not null ( proxy ) ; if ( monitor == null ) monitor= new null progress monitor ( ) ; try { final refactoring history manager manager= get manager ( proxy . get project ( ) ) ; if ( manager ! = null ) return manager . request descriptor ( proxy , monitor ) ; } finally { monitor . do ( ) ; } return null ; }
public void set override time stamp ( final long stamp ) { assert . be true ( stamp == -1 || stamp > = 0 ) ; f override time stamp= stamp ; }
public void end refactoring ( ) { if ( f refactoring ! = null & & f refactoring argument ! = null ) add argument ( f refactoring , f refactoring argument ) ; f refactoring arguments= null ; f refactoring= null ; }
public boolean be delete content ( ) { return f delete content ; }
public void set update reference ( boolean update reference ) { f update references= update reference ; }
public void set update reference ( boolean update reference ) { f update references= update reference ; }
public resolution report resolve ( collection < module > trigger , boolean trigger mandatory ) { return resolve ( trigger , trigger mandatory , false ) ; }
public resolution report refresh ( collection < module > initial ) { initial = initial == null ? null : new array list < > ( initial ) ; collection < module > refresh trigger = unresolve ( initial ) ; if ( ! be refresh system module ( ) ) { return resolve ( refresh trigger , false , true ) ; } return new module resolution report ( null , null , null ) ; }
public object get revision info ( ) { return revision info ; }
public void set type ( int type ) { this . type = type ; }
public list < generic info > get capability ( ) { return get capability ( null ) ; }
public string get symbolic name ( ) { return symbolic name ; }
public boolean be empty ( ) { return size ( ) == 0 ; }
public set < k > key set ( ) { return new snapshot < > ( entry ( ) ) . key set ( ) ; }
public void remove all listener ( ) { list . clear ( ) ; }
public synchronize void close ( ) throw i o exception { if ( reliable ! = null ) { try { super . close ( ) ; } finally { reliable . close input file ( ) ; reliable = null ; } } }
public boolean have trail slash ( ) { return ( flags & has_trailing ) ! = 0 ; }
public string to string ( ) { string builder result = new string builder ( ) ; if ( device ! = null ) result . append ( device ) ; if ( be absolute ( ) ) result . append ( separator ) ; for ( string segment : segment ) { result . append ( segment ) ; result . append ( separator ) ; } if ( segment . length > 0 & & ! have trail slash ( ) ) result . delete char at ( result . length ( ) - 1 ) ; return result . to string ( ) ; }
public synchronize v put ( k key , v value ) { if ( read only ) throw new unsupported operation exception ( ) ; return set ( key , value , true ) ; }
public static privilege action < secure action > create secure action ( ) { return new privilege action < secure action > ( ) { @ override public secure action run ( ) { return new secure action ( ) ; } } ; }
public string get property ( final string property ) { if ( system . get security manager ( ) == null ) return system . get property ( property ) ; return access controller . do privilege ( new privilege action < string > ( ) { @ override public string run ( ) { return system . get property ( property ) ; } } , control context ) ; }
public long length ( final file file ) { if ( system . get security manager ( ) == null ) return file . length ( ) ; return access controller . do privilege ( new privilege action < long > ( ) { @ override public long run ( ) { return long . value of ( file . length ( ) ) ; } } , control context ) . long value ( ) ; }
public < s > s get service ( final service reference < s > reference , final bundle context context ) { if ( system . get security manager ( ) == null ) return context . get service ( reference ) ; return access controller . do privilege ( new privilege action < s > ( ) { @ override public s run ( ) { return context . get service ( reference ) ; } } , control context ) ; }
public int read ( ) throw i o exception { throw new i o exception ( ) ; }
public list < e > get list ( string namespace ) { if ( namespace == null ) { return element ; } return namespaces . get or default ( namespace , collection . empty list ( ) ) ; }
public final throwable get throwable ( ) { return throwable ; }
public final string get method name ( ) { return method name ; }
public void publish bundle event ( int type , bundle bundle , bundle origin ) { if ( origin ! = null ) { publish bundle event ( new bundle event ( type , bundle , origin ) ) ; } else { publish bundle event ( new bundle event ( type , bundle ) ) ; } }
public static collection < bundle context > a bundle context ( collection < ? extend bundle context > c ) { return ( collection < bundle context > ) c ; }
public boolean match ( service reference < ? > reference ) { return matches0 ( ( reference ! = null ) ? service reference map . a map ( reference ) : collection . empty map ( ) ) ; }
public byte [ ] process class ( string name , byte [ ] classbytes , classpath entry classpath entry , bundle entry entry , classpath manager manager ) { return null ; }
public enumeration < url > find local resource ( string name ) { return get module class loader ( ) . find local resource ( name ) ; }
public synchronize void add user object ( key element user object ) { if ( user object == null ) user object = new hash map < > ( 5 ) ; if ( ! user object . contains key ( user object . get key ( ) ) ) { user object . put ( user object . get key ( ) , user object ) ; } }
public bundle entry find local entry ( string path ) { return find local entry ( path , -1 ) ; }
public boolean contain value ( object value ) { / * since value be collection and the collection have identity equality , * there be no way any value could be contain in this map unless that * value have already be get from this map . * / if ( value == null ) { return false ; } return value . contains value ( value ) ; }
public string get policy name ( ) { return policy name ; }
public bundle description get requirement host ( ) { return requirement host ; }
public version get minimum ( ) { return get leave ( ) ; }
public throwable init cause ( throwable t ) { throw new illegal state exception ( ) ; }
public string get name ( ) { return ( name ) ; }
public string [ ] get permission data ( string location ) { if ( location == null ) return default info ; synchronize ( location ) { if ( location . size ( ) == 0 ) return null ; return location . get ( location ) ; } }
public void add ( string manage file ) throw i o exception { add ( manage file , filetype_standard ) ; }
public string get value ( ) { return main value ; }
public string get attribute ( string key ) { return get table value ( attribute , key ) ; }
public bundle get bundle ( ) { return bundle ; }
public collection < resource > get mandatory resource ( ) { return empty collection ( ) ; }
public static string identity to string ( final object object ) { return null == object ? null : object . get class ( ) . get name ( ) + ' @ ' + integer . to hex string ( system . identity hash code ( object ) ) ; }
public static priority prioritize ( final int value ) { return prioritize ( null , value ) ; }
public static < t > key < t > implicit key ( final class < t > clazz ) { return key . get ( clazz , implicit . class ) ; }
protected list < i document partition listener > get document partition listener ( ) { return a list ( f document partition listener ) ; }
protect void update document structure ( document event event ) { if ( f document partitioners ! = null ) { f document partition change event= new document partition change event ( this ) ; for ( entry < string , i document partitioner > entry : f document partitioners . entry set ( ) ) { string partitioning= entry . get key ( ) ; i document partitioner partitioner= entry . get value ( ) ; if ( partitioner instanceof i document partitioner extension3 ) { i document partitioner extension3 extension= ( i document partitioner extension3 ) partitioner ; if ( extension . get active rewrite session ( ) ! = null ) continue ; } if ( partitioner instanceof i document partitioner extension ) { i document partitioner extension extension= ( i document partitioner extension ) partitioner ; i region r= extension . document changed2 ( event ) ; if ( r ! = null ) f document partition change event . set partition change ( partitioning , r . get offset ( ) , r . get length ( ) ) ; } else { if ( partitioner . document change ( event ) ) f document partition change event . set partition change ( partitioning , 0 , event . get document ( ) . get length ( ) ) ; } } } if ( ! f position . be empty ( ) ) update position ( event ) ; }
protect void update position ( document event event ) { for ( i position updater u : f position updaters ) { u . update ( event ) ; } }
public i region get coverage ( ) { if ( f map . be empty ( ) ) return new region ( 0 , 0 ) ; int offset= -1 ; int end offset= -1 ; iterator < region > e= f map . value ( ) . iterator ( ) ; while ( e . have next ( ) ) { i region r= e . next ( ) ; if ( offset < 0 || r . get offset ( ) < offset ) offset= r . get offset ( ) ; int end= r . get offset ( ) + r . get length ( ) ; if ( end > end offset ) end offset= end ; } return new region ( offset , end offset - offset ) ; }
public static boolean have manager ( i document [ ] document ) { for ( i document document : document ) { if ( have manager ( document ) ) return true ; } return false ; }
public int get offset ( ) { return offset ; }
public boolean affect position ( document event event ) { i document document= event . get document ( ) ; try { int index= document . compute index in category ( get category ( ) , event . get offset ( ) ) ; position [ ] fragments= document . get position ( get category ( ) ) ; if ( 0 < index ) { position fragment= fragment [ index - 1 ] ; if ( fragment . overlap with ( event . get offset ( ) , event . get length ( ) ) ) return true ; if ( index == fragment . length & & fragment . offset + fragment . length == event . get offset ( ) ) return true ; } if ( index < fragment . length ) { position fragment= fragment [ index ] ; return fragment . overlap with ( event . get offset ( ) , event . get length ( ) ) ; } } catch ( bad location exception x ) { } catch ( bad position category exception x ) { } return false ; }
public final i region [ ] compute project master region ( int offset in master , int length in master ) throw bad location exception { i region image region= f mapping . to image region ( new region ( offset in master , length in master ) ) ; return image region ! = null ? f mapping . to exact origin region ( image region ) : null ; }
public void master document change ( document event master event ) { if ( ! be update ( ) & & master event == f master event ) { if ( f slave event ! = null ) { try { get tracker ( ) . replace ( f slave event . get offset ( ) , f slave event . get length ( ) , f slave event . get text ( ) ) ; fire document change ( f slave event ) ; } catch ( bad location exception e ) { internal error ( ) ; } } else if ( ensure well form segmentation ( master event . get offset ( ) ) ) f mapping . projection change ( ) ; } }
public void set type ( string type ) { f type= type ; }
public boolean be mark deleted ( ) { return f mark a delete ; }
protect void cleanup ( boolean fire model change ) { cleanup ( fire model change , true ) ; }
public annotation [ ] get added annotation ( ) { int size= f add annotation . size ( ) ; annotation [ ] added= new annotation [ size ] ; f add annotation . to array ( add ) ; return add ; }
public boolean be empty ( ) { return ! f be world change & & f added annotation . be empty ( ) & & f remove annotation . be empty ( ) & & f change annotation . be empty ( ) ; }
public int get completion offset ( ) { return f original offset ; }
public void set context type id ( string context type id ) { assert . be not null ( context type id ) ; f context type id= context type id ; }
public void set pattern ( string pattern ) { f pattern= pattern ; }
public void remove resolver ( template variable resolver resolver ) { assert . be not null ( resolver ) ; f resolvers . remove ( resolver . get type ( ) ) ; }
public string [ ] get value ( ) { return f value ; }
public final void set value ( string value ) { set value ( new string [ ] { value } ) ; }
public void set value ( string [ ] value ) { assert . be true ( value . length > 0 ) ; f values= text utility . copy ( value ) ; set resolve ( true ) ; }
public void set unambiguous ( boolean unambiguous ) { f be unambiguous= unambiguous ; if ( unambiguous ) set resolve ( true ) ; }
public static int end with ( string [ ] search string , string text ) { int index= -1 ; for ( int i= 0 ; i < search string . length ; i++ ) { if ( text . end with ( search string [ i ] ) ) { if ( index == -1 || search string [ i ] . length ( ) > search string [ index ] . length ( ) ) index= i ; } } return index ; }
public void set source modifier ( i source modifier modifier ) { f modifier= modifier ; }
public string get text ( ) { return f text ; }
public string get text ( ) { return f text ; }
public final text edit get parent ( ) { return f parent ; }
public final boolean remove child ( text edit child ) { assert . be not null ( child ) ; if ( f child == null ) return false ; boolean result= f child . remove ( child ) ; if ( result ) { child . internal set parent ( null ) ; if ( f child . be empty ( ) ) f children= null ; } return result ; }
public text edit perform ( ) { text edit result= do copy ( f edit ) ; if ( result ! = null ) { for ( text edit edit : f copy . key set ( ) ) { edit . post process copy ( this ) ; } } return result ; }
public string get name ( ) { return f description ; }
public boolean visit ( copy source edit edit ) { return visit node ( edit ) ; }
public template get template ( ) { return f custom template ; }
public template [ ] get template ( string context type id ) { list < template > templates= new array list < > ( ) ; for ( template persistence data data : f template ) { if ( data . be enable ( ) & & ! data . be delete ( ) & & ( context type id == null || context type id . equal ( data . get template ( ) . get context type id ( ) ) ) ) templates . add ( data . get template ( ) ) ; } return template . to array ( new template [ template . size ( ) ] ) ; }
public static boolean match distinguish name chain ( string match pattern , list / * < string > * /dn chain ) { return d n chain match . match ( match pattern , dn chain ) ; }
public void parse u r l ( u r l stream handler setter real handler , url u , string spec , int start , int limit ) { this . real handler = real handler ; parse u r l ( u , spec , start , limit ) ; }
public boolean equal ( url u1 , url u2 ) { return super . equal ( u1 , u2 ) ; }
public void set image data ( byte [ ] image data array ) { image data = image data array ; }
public matrix get initial matrix ( ) { return initial matrix ; }
public int size ( ) { return object . size ( ) ; }
public list < ? extend c o s base > to list ( ) { list < c o s base > ret list = new array list < c o s base > ( size ( ) ) ; for ( int i = 0 ; i < size ( ) ; i++ ) { ret list . add ( get ( i ) ) ; } return ret list ; }
public void clear ( ) { item . clear ( ) ; }
public void set float ( string key , float value ) { set float ( c o s name . get p d f name ( key ) , value ) ; }
public string get name a string ( string key , string default value ) { return get name a string ( c o s name . get p d f name ( key ) , default value ) ; }
public boolean get boolean ( string key , boolean default value ) { return get boolean ( c o s name . get p d f name ( key ) , default value ) ; }
public boolean get boolean ( c o s name key , boolean default value ) { return get boolean ( key , null , default value ) ; }
public int get int ( string [ ] key list , int default value ) { int retval = default value ; c o s base obj = get dictionary object ( key list ) ; if ( obj instanceof c o s number ) { retval = ( ( c o s number ) obj ) . int value ( ) ; } return retval ; }
public float get float ( string key , float default value ) { return get float ( c o s name . get p d f name ( key ) , default value ) ; }
public c o s base get item ( c o s name key ) { return item . get ( key ) ; }
public c o s base get item ( c o s name first key , c o s name second key ) { c o s base retval = get item ( first key ) ; if ( retval == null & & second key ! = null ) { retval = get item ( second key ) ; } return retval ; }
public set < c o s name > key set ( ) { return item . key set ( ) ; }
public void add all ( c o s dictionary dic ) { for ( map . entry < c o s name , c o s base > entry : dic . entry set ( ) ) { / * * if we 're at a second trailer , we have a linearized pdf file , meaning that the first size entry represent * all of the object so we do n't need to grab the second . * / if ( ! entry . get key ( ) . get name ( ) . equal ( `` size `` ) || ! item . contains key ( c o s name . get p d f name ( `` size `` ) ) ) { set item ( entry . get key ( ) , entry . get value ( ) ) ; } } }
public void set version ( float version value ) { version = version value ; }
public boolean be decrypt ( ) { return be decrypt ; }
public void write p d f ( output stream output ) throw i o exception { output . write ( value a string . get byte ( `` iso-8859-1 `` ) ) ; }
public c o s base get object ( ) { return base object ; }
public final void set object ( c o s base object ) throw i o exception { base object = object ; }
public int get generation ( ) { return generation ; }
public output stream create output stream ( ) throw i o exception { return create output stream ( null ) ; }
public string to text string ( ) { byte array output stream out = new byte array output stream ( ) ; input stream input = null ; try { input = create input stream ( ) ; i o utils . copy ( input , out ) ; } catch ( i o exception e ) { return `` `` ; } finally { i o utils . close quietly ( input ) ; } c o s string string = new c o s string ( out . to byte array ( ) ) ; return string . get string ( ) ; }
public char get terminator ( ) { return terminator ; }
public void set line length ( int l ) { if ( line break > l ) { line break = l ; } maxline = l ; }
protect affine transform calculate affine transform ( p d page page , p d rectangle overlay medium box ) { affine transform at = new affine transform ( ) ; p d rectangle page medium box = page . get medium box ( ) ; float h shift = ( page medium box . get width ( ) - overlay medium box . get width ( ) ) / 2 . 0f ; float v shift = ( page medium box . get height ( ) - overlay medium box . get height ( ) ) / 2 . 0f ; at . translate ( h shift , v shift ) ; return at ; }
public string get input file ( ) { return input file name ; }
public string get default overlay file ( ) { return default overlay filename ; }
public void set last page overlay file ( string last page overlay file ) { last page overlay filename = last page overlay file ; }
protect boolean parse p d f header ( ) throw i o exception { return parse header ( pdf_header , pdf_default_version ) ; }
protected list < c o s writer x ref entry > get x ref entry ( ) { return x ref entry ; }
public static c o s writer x ref entry get null entry ( ) { return nullentry ; }
public string get filename ( ) { string filename = get file unicode ( ) ; if ( filename == null ) { filename = get file do ( ) ; } if ( filename == null ) { filename = get file mac ( ) ; } if ( filename == null ) { filename = get file unix ( ) ; } if ( filename == null ) { filename = get file ( ) ; } return filename ; }
public void set creation date ( calendar creation ) { get c o s object ( ) . set embedded date ( `` params `` , `` creation date `` , creation ) ; }
public void set mod date ( calendar mod ) { get c o s object ( ) . set embedded date ( `` params `` , `` mod date `` , mod ) ; }
public void set check sum ( string checksum ) { get c o s object ( ) . set embed string ( `` params `` , `` check sum `` , checksum ) ; }
public void add name ( string name ) { this . instruction . add ( name ) ; }
public void add boolean ( boolean value ) { this . instruction . add ( value ) ; }
public void add proc ( instruction sequence child ) { this . instruction . add ( child ) ; }
public static void parse ( char sequence input , syntax handler handler ) { tokenizer tokenizer = new tokenizer ( input , handler ) ; tokenizer . tokenize ( ) ; }
public navigable set < integer > get page index ( ) { return new tree set < integer > ( label . key set ( ) ) ; }
public byte [ ] to byte array ( ) throw i o exception { byte array output stream output = new byte array output stream ( ) ; input stream be = null ; try { be = create input stream ( ) ; i o utils . copy ( be , output ) ; } finally { if ( be ! = null ) { be . close ( ) ; } } return output . to byte array ( ) ; }
public void set decode stream length ( int decode stream length ) { this . stream . set int ( c o s name . dl , decode stream length ) ; }
public void set reference object ( p d annotation annotation ) { this . get c o s object ( ) . set item ( c o s name . obj , annotation ) ; }
public string get element identifier ( ) { return this . get c o s object ( ) . get string ( c o s name . id ) ; }
public void set class name ( revision < string > class name ) { if ( class names == null ) { return ; } c o s name key = c o s name . c ; if ( ( class names . size ( ) == 1 ) & & ( class name . get revision number ( 0 ) == 0 ) ) { string class name = class name . get object ( 0 ) ; this . get c o s object ( ) . set name ( key , class name ) ; return ; } c o s array array = new c o s array ( ) ; for ( int i = 0 ; i < class name . size ( ) ; i++ ) { string class name = class name . get object ( i ) ; int revision number = class name . get revision number ( i ) ; if ( revision number < 0 ) { throw new illegal argument exception ( `` the revision number shall be > -1 `` ) ; } array . add ( c o s name . get p d f name ( class name ) ) ; array . add ( c o s integer . get ( revision number ) ) ; } this . get c o s object ( ) . set item ( key , array ) ; }
public c o s base get k ( ) { return this . get c o s object ( ) . get dictionary object ( c o s name . k ) ; }
public void set parent tree ( p d number tree node parent tree ) { this . get c o s object ( ) . set item ( c o s name . parent_tree , parent tree ) ; }
public void set name ( string name ) { this . potentially notify change ( this . get name ( ) , name ) ; this . get c o s object ( ) . set name ( c o s name . n , name ) ; }
public void add x object ( p d x object xobject ) { this . get content ( ) . add ( xobject ) ; }
public string get scope ( ) { return this . get name ( p d table attribute object . scope ) ; }
public void set text decoration type ( string text decoration type ) { this . set name ( text_decoration_type , text decoration type ) ; }
public string get glyph orientation vertical ( ) { return this . get name ( glyph_orientation_vertical , glyph_orientation_vertical_auto ) ; }
public void set all column width ( float column width ) { this . set number ( column_widths , column width ) ; }
public void set check state ( string check state ) { this . set name ( check , checked state ) ; }
protect float get number ( string name , float default value ) { return this . get c o s object ( ) . get float ( name , default value ) ; }
public boolean can modify ( ) { return be permission bit on ( modification_bit ) ; }
public boolean can modify annotation ( ) { return be permission bit on ( modify_annotations_bit ) ; }
public void set can fill in form ( boolean allow fill in form ) { if ( ! read only ) { set permission bit ( fill_in_form_bit , allow fill in form ) ; } }
public void set crypt filter method ( c o s name cfm ) { crypt filter dictionary . set item ( c o s name . cfm , cfm ) ; }
public c o s name get crypt filter method ( ) { return ( c o s name ) crypt filter dictionary . get dictionary object ( c o s name . cfm ) ; }
public void set user key ( byte [ ] u ) throw i o exception { dictionary . set item ( c o s name . u , new c o s string ( u ) ) ; }
public void set permission ( int permission ) { dictionary . set int ( c o s name . p , permission ) ; }
public void add recipient ( public key recipient recipient ) { recipient . add ( recipient ) ; }
public boolean remove recipient ( public key recipient recipient ) { return recipient . remove ( recipient ) ; }
public void set x509 ( x509 certificate a x509 ) { this . x509 = a x509 ; }
protect void set decrypt metadata ( boolean decrypt metadata ) { this . decrypt metadata = decrypt metadata ; }
public void decrypt ( c o s base obj , long obj num , long gen num ) throw i o exception { if ( ! object . contains ( obj ) ) { object . add ( obj ) ; if ( obj instanceof c o s string ) { decrypt string ( ( c o s string ) obj , obj num , gen num ) ; } else if ( obj instanceof c o s stream ) { decrypt stream ( ( c o s stream ) obj , obj num , gen num ) ; } else if ( obj instanceof c o s dictionary ) { decrypt dictionary ( ( c o s dictionary ) obj , obj num , gen num ) ; } else if ( obj instanceof c o s array ) { decrypt array ( ( c o s array ) obj , obj num , gen num ) ; } } }
public void set a e s ( boolean aes value ) { use a e s = aes value ; }
public void set user password ( string user password ) { this . user password = user password ; }
public integer get page ( ) { integer retval = null ; c o s number page = ( c o s number ) annot . get dictionary object ( c o s name . page ) ; if ( page ! = null ) { retval = page . int value ( ) ; } return retval ; }
public boolean be no zoom ( ) { return annot . get flag ( c o s name . f , flag_no_zoom ) ; }
public final void set no rotate ( boolean no rotate ) { annot . set flag ( c o s name . f , flag_no_rotate , no rotate ) ; }
public boolean be lock ( ) { return annot . get flag ( c o s name . f , flag_locked ) ; }
protect final string get string or stream ( c o s base base ) { if ( base == null ) { return `` `` ; } else if ( base instanceof c o s string ) { return ( ( c o s string ) base ) . get string ( ) ; } else if ( base instanceof c o s stream ) { return ( ( c o s stream ) base ) . to text string ( ) ; } else { return `` `` ; } }
public string get symbol ( ) { return annot . get string ( c o s name . sy ) ; }
public final void set interior color ( color color ) { c o s array array = null ; if ( color ! = null ) { float [ ] color = color . get r g b color component ( null ) ; array = new c o s array ( ) ; array . set float array ( color ) ; } annot . set item ( c o s name . ic , array ) ; }
public color get interior color ( ) { color retval = null ; c o s array array = ( c o s array ) annot . get dictionary object ( c o s name . ic ) ; if ( array ! = null ) { float [ ] rgb = array . to float array ( ) ; if ( rgb . length > = 3 ) { retval = new color ( rgb [ 0 ] , rgb [ 1 ] , rgb [ 2 ] ) ; } } return retval ; }
public void set callout ( float [ ] callout ) { c o s array new callout = new c o s array ( ) ; new callout . set float array ( callout ) ; annot . set item ( c o s name . cl , new callout ) ; }
public string get default appearance ( ) { return annot . get string ( c o s name . da ) ; }
public string get default style ( ) { return annot . get string ( c o s name . d ) ; }
public color get interior color ( ) { color retval = null ; c o s array array = ( c o s array ) annot . get dictionary object ( c o s name . ic ) ; if ( array ! = null ) { float [ ] rgb = array . to float array ( ) ; if ( rgb . length > = 3 ) { retval = new color ( rgb [ 0 ] , rgb [ 1 ] , rgb [ 2 ] ) ; } } return retval ; }
public string get version ( ) { return catalog . get name a string ( c o s name . version ) ; }
public void set version ( string version ) { catalog . set name ( c o s name . version , version ) ; }
public p d file specification get file ( ) throw i o exception { return p d file specification . create f s ( fdf . get dictionary object ( c o s name . f ) ) ; }
public void save ( file file name ) throw i o exception { save ( new file output stream ( file name ) ) ; }
public void close ( ) throw i o exception { document . close ( ) ; }
public c o s base get c o s value ( ) throw i o exception { c o s base value = field . get dictionary object ( c o s name . v ) ; if ( value instanceof c o s name ) { return value ; } else if ( value instanceof c o s array ) { return value ; } else if ( value instanceof c o s string || value instanceof c o s stream ) { return value ; } else if ( value ! = null ) { throw new i o exception ( `` error : unknown type for field import `` + value ) ; } else { return null ; } }
public void set field flag ( integer ff ) { c o s integer value = null ; if ( ff ! = null ) { value = c o s integer . get ( ff ) ; } field . set item ( c o s name . ff , value ) ; }
public integer get clear widget field flag ( ) { integer retval = null ; c o s number ff = ( c o s number ) field . get dictionary object ( c o s name . clr_f ) ; if ( ff ! = null ) { retval = ff . int value ( ) ; } return retval ; }
public void set scale option ( string option ) { fit . set name ( c o s name . sw , option ) ; }
public string get name ( ) { return ref . get string ( c o s name . name ) ; }
public void set option ( string opt ) { option . set ( 0 , new c o s string ( opt ) ) ; }
public string get name ( int code ) { string name = code to name . get ( code ) ; if ( name ! = null ) { return name ; } return `` . notdef `` ; }
public font box font get font box font ( ) { if ( cid font ! = null ) { return cid font ; } else { return t1 font ; } }
public true type font get true type font ( ) { return ttf ; }
public float get string width ( string text ) throw i o exception { byte [ ] bytes = encode ( text ) ; byte array input stream in = new byte array input stream ( byte ) ; float width = 0 ; while ( in . available ( ) > 0 ) { int code = read code ( in ) ; width += get width ( code ) ; } return width ; }
public float get ascent ( ) { return dic . get float ( c o s name . ascent , 0 ) ; }
public float get max width ( ) { return dic . get float ( c o s name . max_width , 0 ) ; }
public void set font file2 ( p d stream ttf stream ) { dic . set item ( c o s name . font_file2 , ttf stream ) ; }
public p d stream get font file3 ( ) { p d stream retval = null ; c o s base obj = dic . get dictionary object ( c o s name . font_file3 ) ; if ( obj instanceof c o s stream ) { retval = new p d stream ( ( c o s stream ) obj ) ; } return retval ; }
public final void set matrix ( matrix matrix ) { c o s array matrix array = null ; if ( matrix ! = null ) { matrix array = matrix . to c o s array ( ) ; } dictionary . set item ( c o s name . matrix , matrix array ) ; }
public boolean be pattern ( ) { return pattern name ! = null ; }
public int to r g b ( ) throw i o exception { float [ ] float = color space . to r g b ( component ) ; int r = math . round ( floats [ 0 ] * 255 ) ; int g = math . round ( floats [ 1 ] * 255 ) ; int b = math . round ( floats [ 2 ] * 255 ) ; int rgb = r ; rgb = ( rgb < < 8 ) + g ; rgb = ( rgb < < 8 ) + b ; return rgb ; }
public p d function get tint transform ( ) throw i o exception { if ( tint transform == null ) { tint transform = p d function . create ( array . get object ( tint_transform ) ) ; } return tint transform ; }
public list < string > get component ( ) { list < string > component = new array list < string > ( ) ; c o s array co component = ( c o s array ) dictionary . get dictionary object ( c o s name . component ) ; if ( cos component == null ) { return component ; } for ( c o s base name : co component ) { component . add ( ( ( c o s name ) name ) . get name ( ) ) ; } return component ; }
public void set b range ( p d range range ) { set component range array ( range , 2 ) ; }
public static p d image x object create from file by extension ( file file , p d document doc ) throw i o exception { string name = file . get name ( ) ; int dot = file . get name ( ) . last index of ( ' . ' ) ; if ( dot == -1 ) { throw new illegal argument exception ( `` image type not support : `` + name ) ; } string ext = name . substring ( dot + 1 ) . to lower case ( ) ; if ( `` jpg `` . equal ( ext ) || `` jpeg `` . equal ( ext ) ) { file input stream fis = new file input stream ( file ) ; p d image x object image x object = j p e g factory . create from stream ( doc , fis ) ; fis . close ( ) ; return image x object ; } if ( `` tif `` . equal ( ext ) || `` tiff `` . equal ( ext ) ) { return c c i t t factory . create from file ( doc , file ) ; } if ( `` gif `` . equal ( ext ) || `` bmp `` . equal ( ext ) || `` png `` . equal ( ext ) ) { buffer image bim = image i o . read ( file ) ; return lossless factory . create from image ( doc , bim ) ; } throw new illegal argument exception ( `` image type not support : `` + name ) ; }
public c o s array get color key mask ( ) { c o s base mask = get c o s object ( ) . get dictionary object ( c o s name . mask ) ; if ( mask instanceof c o s array ) { return ( c o s array ) mask ; } return null ; }
public p d optional content group get group ( string name ) { c o s array ocgs = get o c g ( ) ; for ( c o s base o : ocgs ) { c o s dictionary ocg = to dictionary ( o ) ; string group name = ocg . get string ( c o s name . name ) ; if ( group name . equal ( name ) ) { return new p d optional content group ( ocg ) ; } } return null ; }
protect float [ ] [ ] get flag2 color ( ) { int number of color component = corner color [ 0 ] . length ; float [ ] [ ] implicit corner color = new float [ 2 ] [ number of color component ] ; for ( int i = 0 ; i < number of color component ; i++ ) { implicit corner color [ 0 ] [ i ] = corner color [ 2 ] [ i ] ; implicit corner color [ 1 ] [ i ] = corner color [ 3 ] [ i ] ; } return implicit corner color ; }
public void set extend ( c o s array new extend ) { extend = new extend ; get c o s object ( ) . set item ( c o s name . extend , new extend ) ; }
protect final void create pixel table ( rectangle device bound ) throw i o exception { pixel table = calc pixel table ( device bound ) ; }
public void set line cap style ( int style ) { dict . set int ( c o s name . lc , style ) ; }
public void set stroke overprint control ( boolean op ) { dict . set boolean ( c o s name . op , op ) ; }
public boolean get alpha source flag ( ) { return dict . get boolean ( c o s name . ai , false ) ; }
public void set current transformation matrix ( matrix value ) { current transformation matrix = value ; }
public float get miter limit ( ) { return miter limit ; }
public void set stroke adjustment ( boolean value ) { stroke adjustment = value ; }
public boolean be non stroke overprint ( ) { return non stroke overprint ; }
public c o s base get transfer ( ) { return transfer ; }
public void set transfer ( c o s base transfer ) { this . transfer = transfer ; }
public float get word spacing ( ) { return word spacing ; }
public void set word spacing ( float value ) { word space = value ; }
public float get horizontal scaling ( ) { return horizontal scaling ; }
public final void set type ( string type ) { action . set name ( c o s name . type , type ) ; }
public void set file ( p d file specification f ) { action . set item ( c o s name . f , f ) ; }
public void set mix ( boolean mix ) { action . set boolean ( c o s name . mix , mix ) ; }
public p d action get e ( ) { c o s dictionary e = ( c o s dictionary ) action . get dictionary object ( `` e `` ) ; p d action retval = null ; if ( e ! = null ) { retval = p d action factory . create action ( e ) ; } return retval ; }
public p d action get x ( ) { c o s dictionary x = ( c o s dictionary ) action . get dictionary object ( `` x `` ) ; p d action retval = null ; if ( x ! = null ) { retval = p d action factory . create action ( x ) ; } return retval ; }
public void set bl ( p d action bl ) { action . set item ( `` bl `` , bl ) ; }
public p d file specification get file ( ) throw i o exception { return p d file specification . create f s ( get c o s object ( ) . get dictionary object ( `` fs `` ) ) ; }
public p d border style dictionary get border style ( ) { c o s base b = get c o s object ( ) . get dictionary object ( c o s name . b ) ; if ( bs instanceof c o s dictionary ) { return new p d border style dictionary ( ( c o s dictionary ) b ) ; } return null ; }
public p d action u r i get previous u r i ( ) { c o s base base = get c o s object ( ) . get dictionary object ( `` pa `` ) ; if ( base instanceof c o s dictionary ) { return new p d action u r i ( ( c o s dictionary ) base ) ; } return null ; }
public string get title popup ( ) { return get c o s object ( ) . get string ( c o s name . t ) ; }
public p d external data dictionary get external data ( ) { c o s base ex data = this . get c o s object ( ) . get dictionary object ( `` ex data `` ) ; if ( ex data instanceof c o s dictionary ) { return new p d external data dictionary ( ( c o s dictionary ) ex data ) ; } return null ; }
public void set quad point ( float [ ] quad point ) { c o s array new quad point = new c o s array ( ) ; new quad point . set float array ( quad point ) ; get c o s object ( ) . set item ( c o s name . quadpoints , new quad point ) ; }
public int get rotation ( ) { return this . get c o s object ( ) . get int ( c o s name . r , 0 ) ; }
public p d form x object get alternate icon ( ) { c o s base i = this . get c o s object ( ) . get dictionary object ( c o s name . ix ) ; if ( i instanceof c o s stream ) { return new p d form x object ( ( c o s stream ) i ) ; } return null ; }
public float get width ( ) { return get c o s object ( ) . get float ( `` w `` , 1 ) ; }
public p d prop build data dict get filter ( ) { p d prop build data dict filter = null ; c o s dictionary filter dic = ( c o s dictionary ) dictionary . get dictionary object ( c o s name . filter ) ; if ( filter dic ! = null ) { filter = new p d prop build data dict ( filter dic ) ; } return filter ; }
public void set digest method require ( boolean flag ) { get c o s object ( ) . set flag ( c o s name . ff , flag_digest_method , flag ) ; }
public void set issuer ( list < byte [ ] > issuer ) { c o s array array = new c o s array ( ) ; for ( byte [ ] issuer : issuer ) { array . add ( new c o s string ( issuer ) ) ; } this . dictionary . set item ( c o s name . issuer , array ) ; }
public string get u r l ( ) { return this . dictionary . get string ( c o s name . url ) ; }
public void set name ( string name ) { dictionary . set string ( c o s name . name , name ) ; }
public string get location ( ) { return dictionary . get string ( c o s name . location ) ; }
public void set content ( byte [ ] bytes ) { c o s string string = new c o s string ( byte ) ; string . set force hex form ( true ) ; dictionary . set item ( c o s name . content , string ) ; }
public byte [ ] get sign content ( input stream pdf file ) throw i o exception { c o s filter input stream fis=null ; try { fis = new c o s filter input stream ( pdf file , get byte range ( ) ) ; return fis . to byte array ( ) ; } finally { if ( fis ! = null ) { fis . close ( ) ; } } }
public c o s document get visual signature ( ) { return visual signature ; }
public int get preferred signature size ( ) { return prefer signature size ; }
public void set inner form resource ( p d resource inner form resource ) { this . inner form resource = inner form resource ; }
public void set image form name ( c o s name image form name ) { this . image form name = image form name ; }
public p d visible sig property visual sign enable ( boolean visual sign enable ) { this . visual sign enable = visual sign enable ; return this ; }
public p d visible sign designer get pd visible signature ( ) { return pd visible signature ; }
public string get name destination ( ) { string retval = null ; if ( name destination instanceof c o s string ) { retval = ( ( c o s string ) name destination ) . get string ( ) ; } else if ( name destination instanceof c o s name ) { retval = ( ( c o s name ) name destination ) . get name ( ) ; } return retval ; }
public void set fit bounding box ( boolean fit bound box ) { array . grow to size ( 2 ) ; if ( fit bounding box ) { array . set name ( 1 , type_bounded ) ; } else { array . set name ( 1 , type ) ; } }
public void set bottom ( int y ) { array . grow to size ( 6 ) ; if ( y == -1 ) { array . set ( 3 , null ) ; } else { array . set int ( 3 , y ) ; } }
public void set leave ( int x ) { array . grow to size ( 3 ) ; if ( x == -1 ) { array . set ( 2 , null ) ; } else { array . set int ( 2 , x ) ; } }
public void set top ( int y ) { array . grow to size ( 4 ) ; if ( y == -1 ) { array . set ( 3 , null ) ; } else { array . set int ( 3 , y ) ; } }
public void set bold ( boolean bold ) { get c o s object ( ) . set flag ( c o s name . f , bold_flag , bold ) ; }
public void add first ( p d outline item new child ) { require single node ( new child ) ; prepend ( new child ) ; update parent open count for add child ( new child ) ; }
public void import f d f ( f d f document fdf ) throw i o exception { list < f d f field > field = fdf . get catalog ( ) . get f d f ( ) . get field ( ) ; if ( field ! = null ) { for ( f d f field field : field ) { f d f field fdf field = field ; p d field doc field = get field ( fdf field . get partial field name ( ) ) ; if ( doc field ! = null ) { doc field . import f d f ( fdf field ) ; } } } }
public boolean be append only ( ) { return dictionary . get flag ( c o s name . sig_flags , flag_append_only ) ; }
public void un check ( ) throw i o exception { set value ( c o s name . off . get name ( ) ) ; }
public list < string > get option display value ( ) { c o s base value = get c o s object ( ) . get dictionary object ( c o s name . opt ) ; return field utils . get pairable item ( value , 1 ) ; }
public void set sort ( boolean sort ) { get c o s object ( ) . set flag ( c o s name . ff , flag_sort , sort ) ; }
public void set require ( boolean require ) { dictionary . set flag ( c o s name . ff , flag_required , require ) ; }
public void set max len ( int max len ) { get c o s object ( ) . set int ( c o s name . max_len , max len ) ; }
public float get conversion factor ( ) { return this . get c o s object ( ) . get float ( `` c `` ) ; }
public void set fractional display ( string fractional display ) { if ( ( fractional display == null ) || fractional_display_decimal . equal ( fractional display ) || fractional_display_fraction . equal ( fractional display ) || fractional_display_round . equal ( fractional display ) || fractional_display_truncate . equal ( fractional display ) ) { this . get c o s object ( ) . set string ( `` f `` , fractional display ) ; } else { throw new illegal argument exception ( `` value must be \ `` d\ `` , \ `` f\ `` , \ `` r\ `` , or \ `` t\ `` , ( or null ) . `` ) ; } }
public void set denominator ( int denominator ) { this . get c o s object ( ) . set int ( `` d `` , denominator ) ; }
public void set thousand separator ( string thousand separator ) { this . get c o s object ( ) . set string ( `` rt `` , thousand separator ) ; }
public string get label position to value ( ) { return this . get c o s object ( ) . get string ( `` o `` , label_suffix_to_value ) ; }
public p d rectangle get b box ( ) { c o s base bbox = this . get c o s object ( ) . get dictionary object ( c o s name . bbox ) ; if ( bbox instanceof c o s array ) { return new p d rectangle ( ( c o s array ) bbox ) ; } return null ; }
public p d thread bead get next bead ( ) { return new p d thread bead ( ( c o s dictionary ) bead . get dictionary object ( `` n `` ) ) ; }
public void set center window ( boolean value ) { prefs . set boolean ( c o s name . center_window , value ) ; }
public string get non full screen page mode ( ) { return prefs . get name a string ( c o s name . non_full_screen_page_mode , non_full_screen_page_mode . use none . to string ( ) ) ; }
public void register true type font for closing ( true type font ttf ) { font to close . add ( ttf ) ; }
public void save ( string file name ) throw i o exception { save ( new file ( file name ) ) ; }
public boolean be all security to be remove ( ) { return all security to be remove ; }
public void set all security to be remove ( boolean remove all security ) { all security to be remove = remove all security ; }
public p d destination or action get open action ( ) throw i o exception { c o s base open action = root . get dictionary object ( c o s name . open_action ) ; if ( open action instanceof c o s dictionary ) { return p d action factory . create action ( ( c o s dictionary ) open action ) ; } else if ( open action instanceof c o s array ) { return p d destination . create ( open action ) ; } else { return null ; } }
public void set action ( p d document catalog additional action action ) { root . set item ( c o s name . aa , action ) ; }
public string get keywords ( ) { return info . get string ( c o s name . keywords ) ; }
public string get creator ( ) { return info . get string ( c o s name . creator ) ; }
public void line to ( float x , float y ) throw i o exception { if ( in text mode ) { throw new illegal state exception ( `` error : line to be not allow within a text block . `` ) ; } write operand ( x ) ; write operand ( y ) ; write operator ( `` l `` ) ; }
public void fill and stroke ( ) throw i o exception { if ( in text mode ) { throw new illegal state exception ( `` error : fill and stroke be not allow within a text block . `` ) ; } write operator ( `` b `` ) ; }
public void set miter limit ( float miter limit ) throw i o exception { if ( in text mode ) { throw new illegal state exception ( `` error : set miter limit be not allow within a text block . `` ) ; } if ( miter limit < = 0 . 0 ) { throw new illegal argument exception ( `` a miter limit < = 0 be invalid and will not render in acrobat reader `` ) ; } write operand ( miter limit ) ; write operator ( `` m `` ) ; }
public iterable < c o s name > get ext g state name ( ) { return get name ( c o s name . ext_g_state ) ; }
public c o s name add ( p d property list property ) { if ( property instanceof p d optional content group ) { return add ( c o s name . property , `` oc `` , property ) ; } else { return add ( c o s name . property , `` prop `` , property ) ; } }
public annotation filter get annotation filter ( ) { return annotation filter ; }
public void set annotation filter ( annotation filter annotation filter ) { this . annotation filter = annotation filter ; }
protect void write character ( text position text ) throw i o exception { output . write ( text . get unicode ( ) ) ; }
public void set end page ( int end page value ) { end page = end page value ; }
public void set line separator ( string separator ) { line separator = separator ; }
public p d outline item get start bookmark ( ) { return start bookmark ; }
public boolean get sort by position ( ) { return sort by position ; }
public float get x scale ( ) { return text matrix . get scaling factor x ( ) ; }
public void scale ( float sx , float sy ) { matrix m = matrix . get scale instance ( sx , sy ) ; concatenate ( m ) ; }
public float get translate y ( ) { return single [ 7 ] ; }
public static < t > void sort ( list < t > list , comparator < t > cmp ) { int size = list . size ( ) ; if ( size < 2 ) { return ; } quicksort ( list , cmp ) ; }
public vector scale ( float sxy ) { return new vector ( x * sxy , y * sxy ) ; }
public void close ( f d f document doc ) throw i o exception { if ( doc ! = null ) { doc . close ( ) ; } }
public static path matcher from glob ( string glob ) { string syntax and pattern = `` glob : `` + glob ; return new cache path matcher ( file system . get default ( ) . get path matcher ( syntax and pattern ) , syntax and pattern ) ; }
public void destroy ( ) throw exception { remove notification listener ( ) ; execute during shutdown ( ) ; }
public string get all thread ( boolean without monitor ) { return pepper thread dumper . get thread dump a string ( ! without monitor ) ; }
public int get threshold ( ) { return current threshold ; }
public static boolean be name ( string name ) { return be os ( null , name , null , null ) ; }
public static method get public method ( method method ) { class < ? > clazz = method . get declare class ( ) ; / * * short circuit for ( hopefully the majority of ) case where the declare * class be public . * / if ( ( clazz . get modifier ( ) & modifier . public ) ! = 0 ) { return method ; } return get public method ( clazz , method . get name ( ) , method . get parameter type ( ) ) ; }
public string get master ( ) { return this . master ; } // -- string get master ( )
protect boolean be exclude ( string name ) { return exclude pattern . match ( name , be case sensitive ) ; }
public void put all ( map map ) { _backing map . put all ( map ) ; flush ( ) ; }
public list < string > get child label ( ) { final list < string > ret value = new array list < string > ( child . size ( ) ) ; for ( vertex vertex : child ) { ret value . add ( vertex . get label ( ) ) ; } return ret value ; }
public list < vertex > get parent ( ) { return parent ; }
public boolean be root ( ) { return parent . size ( ) == 0 ; }
protect boolean be select ( string name , file file ) { return true ; }
public string [ ] get deselected file ( ) { slow scan ( ) ; string [ ] file = new string [ file deselected . size ( ) ] ; file deselected . copy into ( file ) ; return file ; }
public static void print root cause stack trace ( throwable t , print writer writer ) { string trace [ ] = get root cause stack trace ( t ) ; for ( string a trace : trace ) { writer . println ( a trace ) ; } writer . flush ( ) ; }
public map . entry get entry ( object key ) { entry impl entry = _entries [ key hash ( key ) & _mask ] ; while ( entry ! = null ) { if ( key . equal ( entry . _key ) ) { return entry ; } entry = entry . _next ; } return null ; }
public static boolean be os ( string family , string name , string arch , string version ) { boolean ret value = false ; if ( family ! = null || name ! = null || arch ! = null || version ! = null ) { boolean be family = true ; boolean be name = true ; boolean be arch = true ; boolean be version = true ; if ( family ! = null ) { if ( family . equal ignore case ( family_windows ) ) { be family = os_name . contains ( family_windows ) ; } else if ( family . equal ignore case ( family_os2 ) ) { be family = os_name . contains ( family_os2 ) ; } else if ( family . equal ignore case ( family_netware ) ) { be family = os_name . contains ( family_netware ) ; } else if ( family . equal ignore case ( family_dos ) ) { be family = path_sep . equal ( `` ; `` ) & & ! be family ( family_netware ) & & ! be family ( family_windows ) & & ! be family ( family_win9x ) ; } else if ( family . equal ignore case ( family_mac ) ) { be family = os_name . contains ( family_mac ) ; } else if ( family . equal ignore case ( family_tandem ) ) { be family = os_name . contains ( `` nonstop_kernel `` ) ; } else if ( family . equal ignore case ( family_unix ) ) { be family = path_sep . equal ( `` : `` ) & & ! be family ( family_openvms ) & & ( ! be family ( family_mac ) || os_name . end with ( `` x `` ) ) ; } else if ( family . equal ignore case ( family_win9x ) ) { be family = be family ( family_windows ) & & ( os_name . contains ( `` 95 `` ) || os_name . contains ( `` 98 `` ) || os_name . contains ( `` me `` ) || os_name . contains ( `` ce `` ) ) ; } else if ( family . equal ignore case ( family_zos ) ) { be family = os_name . contains ( family_zos ) || os_name . contains ( `` os/390 `` ) ; } else if ( family . equal ignore case ( family_os400 ) ) { be family = os_name . contains ( family_os400 ) ; } else if ( family . equal ignore case ( family_openvms ) ) { be family = os_name . contains ( family_openvms ) ; } else { be family = os_name . contains ( family . to lower case ( locale . u ) ) ; } } if ( name ! = null ) { be name = name . to lower case ( locale . u ) . equal ( os_name ) ; } if ( arch ! = null ) { be arch = arch . to lower case ( locale . u ) . equal ( os_arch ) ; } if ( version ! = null ) { be version = version . to lower case ( locale . u ) . equal ( os_version ) ; } ret value = be family & & be name & & be arch & & be version ; } return ret value ; }
public static final string get directory component ( string filename ) { if ( filename == null || filename . length ( ) == 0 ) { return `` `` ; } string separator = determine separator ( filename ) ; string directory = string utils . chomp ( filename , separator ) ; if ( filename . equal ( directory ) ) { return `` . `` ; } return directory ; }
public static boolean be out of date ( file src , file target , int granularity ) { if ( ! src . exists ( ) ) { return false ; } if ( ! target . exists ( ) ) { return true ; } if ( ( src . last modified ( ) - granularity ) > target . last modified ( ) ) { return true ; } return false ; }
public void object dispose ( object obj ) { }
public argument create argument ( boolean insert at start ) { argument argument = new argument ( ) ; if ( insert at start ) { argument . insert element at ( argument , 0 ) ; } else { argument . add element ( argument ) ; } return argument ; }
protect void slow scan ( ) { if ( have slow result ) { return ; } string [ ] excl = new string [ dirs exclude . size ( ) ] ; dirs exclude . copy into ( excl ) ; string [ ] not incl = new string [ dirs not include . size ( ) ] ; dirs not include . copy into ( not incl ) ; for ( string an excl : excl ) { if ( ! could hold include ( an excl ) ) { scandir ( new file ( basedir , an excl ) , an excl + file . separator , false ) ; } } for ( string a not incl : not incl ) { if ( ! could hold include ( a not incl ) ) { scandir ( new file ( basedir , a not incl ) , a not incl + file . separator , false ) ; } } have slow result = true ; }
public static font family value of pitch family ( byte pitch and family ) { return value of ( pitch and family > > > 4 ) ; }
public short get col1 ( ) { return field_2_col1 ; }
public file id cluster add cluster ( int dg id , int num shape use ) { return add cluster ( dg id , num shape use , true ) ; }
public int get property size ( ) { return 6 ; }
protect int fill field ( byte [ ] data , escher record factory f ) { return fill field ( data , 0 , f ) ; }
public void set data ( byte [ ] b , int start , int length ) { thedata = i o utils . safely allocate ( length , max_record_length ) ; system . arraycopy ( b , start , thedata,0 , length ) ; }
public static boolean get thread prefers event extractor ( ) { return thread prefer event extractor . get ( ) ; }
public static void set thread prefers event extractor ( boolean prefer event extractor ) { thread prefer event extractor . set ( prefer event extractor ) ; }
public byte [ ] read ( final byte [ ] src , final int offset ) { / * read double word . * / byte [ 0 ] = src [ 3 + offset ] ; bytes [ 1 ] = src [ 2 + offset ] ; bytes [ 2 ] = src [ 1 + offset ] ; bytes [ 3 ] = src [ 0 + offset ] ; / * read first word . * / byte [ 4 ] = src [ 5 + offset ] ; bytes [ 5 ] = src [ 4 + offset ] ; / * read second word . * / byte [ 6 ] = src [ 7 + offset ] ; bytes [ 7 ] = src [ 6 + offset ] ; / * read 8 byte . * / system . arraycopy ( src , 8 + offset , byte , 8 , 8 ) ; return byte ; }
public void set m m clip count ( final int mm clip count ) { set1st property ( property i d map . pid_mmclipcount , mm clip count ) ; }
public void set docparts ( final byte [ ] docparts ) { not yet implement ( `` write byte array `` ) ; }
public void remove docparts ( ) { remove1st property ( property i d map . pid_docparts ) ; }
public void remove link dirty ( ) { remove1st property ( property i d map . pid_linksdirty ) ; }
public void set content status ( string status ) { set1st property ( property i d map . pid_contentstatus , status ) ; }
public void write ( file new file ) throw i o exception { try ( p o i f s file system fs = p o i f s file system . create ( new file ) ) { write ( f ) ; f . write filesystem ( ) ; } }
public object get property ( final long id ) { be null = ! property . contains key ( id ) ; return ( be null ) ? null : property . get ( id ) . get value ( ) ; }
public void remove subject ( ) { remove1st property ( property i d map . pid_subject ) ; }
public void set last printed ( final date last print ) { get first section ( ) . set property ( property i d map . pid_lastprinted , variant . vt_filetime , last print ) ; }
public void remove thumbnail ( ) { remove1st property ( property i d map . pid_thumbnail ) ; }
public static string get variant name ( final long variant type ) { long vt = variant type ; string name = `` `` ; if ( ( vt & vt_vector ) ! = 0 ) { name = `` vector of `` ; vt -= vt_vector ; } else if ( ( vt & vt_array ) ! = 0 ) { name = `` array of `` ; vt -= vt_array ; } else if ( ( vt & vt_byref ) ! = 0 ) { name = `` by ref of `` ; vt -= vt_byref ; } name += number to name . get ( vt ) ; return ! name . be empty ( ) ? name : `` unknown variant type `` ; }
public static void main ( final string [ ] args ) { property i d map s1 = get summary information property ( ) ; property i d map s2 = get document summary information property ( ) ; system . out . println ( `` s1 : `` + s1 ) ; system . out . println ( `` s2 : `` + s2 ) ; }
public void set include cell comment ( boolean include comment ) { throw new illegal state exception ( `` comment extraction not support in stream mode , please use excel extractor `` ) ; }
public void set include sheet name ( boolean include sheet name ) { _include sheet name = include sheet name ; }
public void increment drawing save ( ) { dgg . set drawing save ( dgg . get drawing save ( ) +1 ) ; }
public int get active cell row ( ) { if ( _selection == null ) { return 0 ; } return _selection . get active cell row ( ) ; }
public record find first record by sid ( short sid ) { int ix = find first record loc by sid ( sid ) ; if ( ix < 0 ) { return null ; } return ( record ) _records . get ( ix ) ; }
public void set print header ( print header record new print header ) { print header = new print header ; }
public void set display row col heading ( boolean show ) { window two . set display row col heading ( show ) ; }
public escher record find first with id ( short id ) { return find first with id ( id , get escher record ( ) ) ; }
public int get row ( ) { return field_1_row ; }
public void set require version ( int version ) { field_6_rversion = version ; }
public int get border top ( ) { return bord top line style . get value ( field_13_border_styles1 ) ; }
public int get diagonal border color ( ) { return bord diag line color . get value ( field_14_border_styles2 ) ; }
public short get underline type ( ) { return get short ( offset_underline_type ) ; }
public static c f rule12 record create ( h s s f sheet sheet , string formula text ) { ptg [ ] formula1 = parse formula ( formula text , sheet ) ; return new c f rule12 record ( condition_type_formula , comparison operator . no_comparison , formula1 , null , null ) ; }
public static c f rule12 record create color scale ( h s s f sheet sheet ) { int num point = 3 ; extend color [ ] color = new extend color [ num point ] ; color gradient threshold [ ] t = new color gradient threshold [ num point ] ; for ( int i=0 ; i < t . length ; i++ ) { ts [ i ] = new color gradient threshold ( ) ; color [ i ] = new extend color ( ) ; } c f rule12 record r = new c f rule12 record ( condition_type_color_scale , comparison operator . no_comparison ) ; color gradient format cgf = r . create color gradient formatting ( ) ; cgf . set num control point ( num point ) ; cgf . set threshold ( t ) ; cgf . set color ( color ) ; return r ; }
public short get format flag ( ) { return field_4_format flag ; }
public void set format flag ( short field_1_format flag ) { this . field_1_format flag = field_1_format flag ; }
public boolean be stack ( ) { return stack . be set ( field_1_format flag ) ; }
public boolean be be date ( ) { return be date . be set ( field_9_options ) ; }
public void set num axis ( short field_1_num axis ) { this . field_1_num axis = field_1_num axis ; }
public void set label frequency ( short field_2_label frequency ) { this . field_2_label frequency = field_2_label frequency ; }
public void set tick mark frequency ( short field_3_tick mark frequency ) { this . field_3_tick mark frequency = field_3_tick mark frequency ; }
public int get height ( ) { return field_4_height ; }
public short get option ( ) { return field_1_options ; }
public boolean be horizontal border ( ) { return horizontal border . be set ( field_1_options ) ; }
public void set font index ( short field_1_font index ) { this . field_1_font index = field_1_font index ; }
public void set auto size ( boolean value ) { field_2_options = auto size . set short boolean ( field_2_options , value ) ; }
public void set y axis upper left ( int field_2_y axis upper left ) { this . field_2_y axis upper leave = field_2_y axis upper leave ; }
public void set y size ( int field_4_y size ) { this . field_4_y size = field_4_y size ; }
public byte get space ( ) { return field_6_spacing ; }
public boolean be unknown ( ) { return unknown . be set ( field_4_format ) ; }
public boolean be custom number format ( ) { return custom number format . be set ( field_3_options ) ; }
public short get link1 ( ) { return field_2_link1 ; }
public void set link2 ( short field_3_link2 ) { this . field_3_link2 = field_3_link2 ; }
public int get horizontal scale ( ) { return field_1_horizontal scale ; }
public void set format flag ( short field_1_format flag ) { this . field_1_format flag = field_1_format flag ; }
public void set show label ( boolean value ) { field_1_format flag = show label . set short boolean ( field_1_format flag , value ) ; }
public void set num bubble value ( short field_6_num bubble value ) { this . field_6_num bubble value = field_6_num bubble value ; }
public void set id ( int id ) { field_1_id = id ; }
public void set text ( string text ) { if ( text . length ( ) > max_len ) { throw new illegal argument exception ( `` text be too long ( `` + text . length ( ) + `` > `` + max_len + `` ) `` ) ; } field_4_text = text ; is16bit = string util . have multibyte ( text ) ; }
public short get chart group index ( ) { return field_1_chart group index ; }
public void set vertical alignment ( byte field_2_vertical alignment ) { this . field_2_vertical alignment = field_2_vertical alignment ; }
public int get rgb color ( ) { return field_4_rgb color ; }
public void set height ( int field_8_height ) { this . field_8_height = field_8_height ; }
public boolean be show value ( ) { return show value . be set ( field_9_options1 ) ; }
public void set minor tick type ( byte field_2_minor tick type ) { this . field_2_minor tick type = field_2_minor tick type ; }
public byte get background ( ) { return field_4_background ; }
public short get rotation ( ) { return rotation . get short value ( field_10_options ) ; }
public void set minor increment ( double field_4_minor increment ) { this . field_4_minor increment = field_4_minor increment ; }
public boolean be logarithmic scale ( ) { return logarithmic scale . be set ( field_6_options ) ; }
public void set value in reverse ( boolean value ) { field_6_options = value in reverse . set short boolean ( field_6_options , value ) ; }
public void set object type ( short field_1_object type ) { this . field_1_object type = field_1_object type ; }
public void set printable ( boolean value ) { field_3_option = printable . set short boolean ( field_3_option , value ) ; }
public boolean be printable ( ) { return printable . be set ( field_3_option ) ; }
public void process child record ( ) { convert raw byte to escher record ( ) ; }
public void set d v rec no ( int dv no ) { field_5_dv_no = dv no ; }
public d v record clone ( ) { return ( d v record ) clone via reserialise ( ) ; }
public string to xml ( string tab ) { string builder builder = new string builder ( ) ; builder . append ( tab ) . append ( `` < `` ) . append ( get record name ( ) ) . append ( `` > \n `` ) ; for ( escher record escher record : get escher record ( ) ) { builder . append ( escher record . to xml ( tab + `` \t `` ) ) ; } builder . append ( tab ) . append ( `` < / `` ) . append ( get record name ( ) ) . append ( `` > \n `` ) ; return builder . to string ( ) ; }
public void remove tail record ( note record note ) { tail rec . remove ( note . get shape id ( ) ) ; }
public boolean be picure link ( ) { return ( field_1_option_flag & opt_picture_link ) ! = 0 ; }
public int get first sheet index from ref index ( int ext ref index ) { return get ref ( ext ref index ) . get first sheet index ( ) ; }
public void set italic ( boolean italic ) { field_2_attributes = italic . set short boolean ( field_2_attributes , italic ) ; }
public void set first row ( int first row ) { _range . set first row ( first row ) ; }
public void new document link ( ) { _range = new cell range address ( 0 , 0 , 0 , 0 ) ; _guid = std_moniker ; _link opts = hlink_label | hlink_place ; set label ( `` `` ) ; _moniker = file_moniker ; set address ( `` `` ) ; set text mark ( `` `` ) ; }
public void set name text ( string new name ) { field_6_name_text = new name ; }
public void set description text ( string text ) { field_15_description_text = text ; }
public short get option flag ( ) { return field_1_option_flag ; }
public void set function ( boolean function ) { if ( function ) { field_1_option_flag |= option . opt_function_name ; } else { field_1_option_flag & = ( ~ option . opt_function_name ) ; } }
public void set column ( int col ) { field_2_col = col ; }
public short get y ( ) { return field_2_y ; }
public boolean get protect ( ) { return protect flag . be set ( _options ) ; }
public static class < ? extend record > get record class ( int sid ) { i_ record creator rc = _record creator by id . get ( integer . value of ( sid ) ) ; if ( rc == null ) { return null ; } return rc . get record class ( ) ; }
public double get margin ( ) { return field_1_margin ; }
public void set first col ( int col ) { field_2_first_col = col ; }
public void set height ( short height ) { field_4_height = height ; }
public void set phoenetic guide ( boolean f ) { field_8_option_flags = phoenetic guide . set boolean ( field_8_option_flags , f ) ; }
public boolean get colapsed ( ) { return ( colapsed . be set ( field_7_option_flags ) ) ; }
public void set first visible tab ( int t ) { field_7_first_visible_tab = t ; }
public short get index ( ) { return _index ; }
public void set quote prefixed ( boolean quote prefix ) { _format . set123 prefix ( quote prefix ) ; }
public void set shrink to fit ( boolean shrink to fit ) { _format . set shrink to fit ( shrink to fit ) ; }
public void verify belongs to workbook ( h s s f workbook wb ) { if ( wb . get workbook ( ) ! = _workbook ) { throw new illegal argument exception ( `` this style do not belong to the supply workbook . be you try to assign a style from one workbook to the cell of a differnt workbook ? `` ) ; } }
public void set anchor type ( anchor type anchor type ) { _escher client anchor . set flag ( anchor type . value ) ; }
public short get index ( ) { return ( short ) index ; }
public int get char set ( ) { byte charset = font . get charset ( ) ; if ( charset > = 0 ) { return charset ; } else { return charset + 256 ; } }
public void set char set ( int charset ) { byte c = ( byte ) charset ; if ( charset > 127 ) { cs = ( byte ) ( charset-256 ) ; } set char set ( c ) ; }
public string get file name ( ) { escher complex property prop file = get opt record ( ) . lookup ( escher property . blip__blipfilename ) ; return ( null == prop file ) ? `` `` : string util . get from unicode l e ( prop file . get complex data ( ) ) . trim ( ) ; }
protect obj record create obj record ( ) { obj record obj = new obj record ( ) ; common object data sub record c = new common object data sub record ( ) ; c . set object type ( object_type_microsoft_office_drawing ) ; c . set locked ( true ) ; c . set printable ( true ) ; c . set autofill ( true ) ; c . set autoline ( true ) ; end sub record e = new end sub record ( ) ; obj . add sub record ( c ) ; obj . add sub record ( e ) ; return obj ; }
public short get fit height ( ) { return print setup record . get fit height ( ) ; }
public short get font of format run ( int index ) { unicode string . format run r = _string . get format run ( index ) ; return r . get font index ( ) ; }
public int add conditional formatting ( h s s f conditional formatting cf ) { c f record aggregate cfra clone = cf . get c f record aggregate ( ) . clone c f aggregate ( ) ; return _conditional formatting table . add ( cfra clone ) ; }
public int get margin bottom ( ) { escher simple property property = get opt record ( ) . lookup ( escher property . text__textbottom ) ; return property == null ? 0 : property . get property value ( ) ; }
public void set margin bottom ( int margin bottom ) { set property value ( new escher simple property ( escher property . text__textbottom , margin bottom ) ) ; }
public document summary information get document summary information ( ) { if ( ! initialize ) { read property ( ) ; } return ds inf ; }
public summary information get summary information ( ) { if ( ! initialize ) { read property ( ) ; } return s inf ; }
public void read ( final input stream stream ) throw i o exception { try ( p o i f s file system poifs = new p o i f s file system ( stream ) ) { read ( poifs ) ; } }
public void register listener ( final p o i f s reader listener listener ) { if ( listener == null ) { throw new null pointer exception ( ) ; } if ( registry close ) { throw new illegal state exception ( ) ; } registry . register listener ( listener ) ; }
public class i d get storage clsid ( ) { return get property ( ) . get storage clsid ( ) ; }
public directory node get root ( ) { if ( _root == null ) { _root = new directory node ( _property_table . get root ( ) , this , null ) ; } return _root ; }
public static void main ( string args [ ] ) throw i o exception { if ( args . length == 0 ) { system . err . println ( `` use : `` ) ; system . err . println ( `` v b a macro extractor < office . doc > [ output ] `` ) ; system . err . println ( `` `` ) ; system . err . println ( `` if an output directory be give , macro be write there `` ) ; system . err . println ( `` otherwise they be output to the screen `` ) ; system . exit ( 1 ) ; } file input = new file ( args [ 0 ] ) ; file output = null ; if ( args . length > 1 ) { output = new file ( args [ 1 ] ) ; } v b a macro extractor extractor = new v b a macro extractor ( ) ; extractor . extract ( input , output ) ; }
public void extract ( file input , file output dir ) throw i o exception { extract ( input , output dir , `` . vba `` ) ; }
protect void pre write ( ) { if ( _children . size ( ) > 0 ) { property [ ] child = _children . to array ( new property [ 0 ] ) ; array . sort ( child , new property comparator ( ) ) ; int midpoint = child . length / 2 ; set child property ( child [ midpoint ] . get index ( ) ) ; child [ 0 ] . set previous child ( null ) ; child [ 0 ] . set next child ( null ) ; for ( int j = 1 ; j < midpoint ; j++ ) { child [ j ] . set previous child ( child [ j - 1 ] ) ; child [ j ] . set next child ( null ) ; } if ( midpoint ! = 0 ) { child [ midpoint ] . set previous child ( child [ midpoint - 1 ] ) ; } if ( midpoint ! = ( child . length - 1 ) ) { child [ midpoint ] . set next child ( child [ midpoint + 1 ] ) ; for ( int j = midpoint + 1 ; j < child . length - 1 ; j++ ) { child [ j ] . set previous child ( null ) ; child [ j ] . set next child ( child [ j + 1 ] ) ; } child [ child . length - 1 ] . set previous child ( null ) ; child [ child . length - 1 ] . set next child ( null ) ; } else { child [ midpoint ] . set next child ( null ) ; } } }
public string get name ( ) { return _name ; }
public void set x b a t start ( final int start block ) { _xbat_start = start block ; }
public void set x ( string value ) { this . x = value ; }
public void set sys clr ( c t system color value ) { this . sys clr = value ; }
public void set idx ( long value ) { this . idx = value ; }
public void set embed ( string value ) { this . embed = value ; }
public void set t ( string value ) { this . t = value ; }
public void set r ( string value ) { this . r = value ; }
public c t point2 d get off ( ) { return off ; }
public void set tooltip ( string value ) { this . tooltip = value ; }
public void set history ( boolean value ) { this . history = value ; }
public object get any ( ) { return any ; }
public long get w ( ) { if ( w == null ) { return 0l ; } else { return w ; } }
public void set stroke ( boolean value ) { this . stroke = value ; }
public string get sw ang ( ) { return sw ang ; }
public long get d ( ) { return d ; }
public void set g ( int value ) { this . g = value ; }
public void set lon ( int value ) { this . lon = value ; }
public long get dx ( ) { return dx ; }
public void set min x ( string value ) { this . min x = value ; }
public draw font manager get font manager ( graphics2 d graphic ) { draw font manager font handler = ( draw font manager ) graphic . get render hint ( drawable . font_handler ) ; return ( font handler ! = null ) ? font handler : new draw font manager default ( ) ; }
public void draw ( shape shape ) { path2 d . double path = new path2 d . double ( _transform . create transform shape ( shape ) ) ; freeform shape < ? , ? > p = _group . create freeform ( ) ; p . set path ( path ) ; p . set fill color ( null ) ; apply stroke ( p ) ; if ( _paint instanceof color ) { p . set stroke style ( ( color ) _paint ) ; } }
public void fill rect ( int x , int y , int width , int height ) { rectangle rect = new rectangle ( x , y , width , height ) ; fill ( rect ) ; }
public void draw string ( attributed character iterator iterator , int x , int y ) { draw string ( iterator , ( float ) x , ( float ) y ) ; }
public void rotate ( double theta , double x , double y ) { _transform . rotate ( theta , x , y ) ; }
public void transform ( affine transform tx ) { _transform . concatenate ( tx ) ; }
public void set background ( color color ) { if ( color == null ) return ; _background = color ; }
public object get render hint ( render hint . key hint key ) { return _hints . get ( hint key ) ; }
public void set note by default ( final boolean note by default ) { this . note by default = note by default ; }
public string get text ( ) { final string builder sb = new string builder ( ) ; for ( final slide < s , p > slide : slideshow . get slide ( ) ) { sb . append ( get text ( slide ) ) ; } return sb . to string ( ) ; }
public insets2 d clone ( ) { return new insets2 d ( top , leave , bottom , right ) ; }
public static short lookup index by name ( string name ) { function metadata fd = get instance ( ) . get function by name internal ( name ) ; if ( fd == null ) { return -1 ; } return ( short ) fd . get index ( ) ; }
public static double fv ( double r , double n , double y , double p , boolean t ) { double retval = 0 ; if ( r == 0 ) { retval = -1 * ( p+ ( n * y ) ) ; } else { double r1 = r + 1 ; retval = ( ( 1- math . pow ( r1 , n ) ) * ( t ? r1 : 1 ) * y ) / r - p * math . pow ( r1 , n ) ; } return retval ; }
public final void set first row relative ( boolean rel ) { field_3_first_column=row relative . set boolean ( field_3_first_column , rel ) ; }
public boolean be condense row ( ) { return condense row ; }
public void set a r g b hex ( string argb ) { if ( argb . length ( ) == 6 || argb . length ( ) == 8 ) { byte [ ] rgb = new byte [ argb . length ( ) /2 ] ; for ( int i=0 ; i < rgb . length ; i++ ) { string part = argb . substring ( i * 2 , ( i+1 ) * 2 ) ; rgb [ i ] = ( byte ) integer . parse int ( part , 16 ) ; } set r g b ( rgb ) ; } else { throw new illegal argument exception ( `` must be of the form 112233 or ffeeddcc `` ) ; } }
public int get value ( ) { return family ; }
public int get row ( ) { return _row ; }
public void add cell range address ( int first row , int first col , int last row , int last col ) { cell range address region = new cell range address ( first row , last row , first col , last col ) ; add cell range address ( region ) ; }
public static row get row ( int row index , sheet sheet ) { row row = sheet . get row ( row index ) ; if ( row == null ) { row = sheet . create row ( row index ) ; } return row ; }
public static string to text ( double value ) { return raw double bit to text ( double . double to long bit ( value ) ) ; }
public static void set border left ( border style border , cell range address region , sheet sheet ) { int row start = region . get first row ( ) ; int row end = region . get last row ( ) ; int column = region . get first column ( ) ; cell property setter cps = new cell property setter ( cell util . border_left , border ) ; for ( int i = row start ; i < = row end ; i++ ) { cps . set property ( cell util . get row ( i , sheet ) , column ) ; } }
public static void arraycopy ( byte [ ] src , int src_position , byte [ ] dst , int dst_position , int length ) { if ( src_position < 0 ) throw new illegal argument exception ( `` src_position be less than 0 . actual value `` + src_position ) ; if ( src_position > = src . length ) throw new illegal argument exception ( `` src_position be great than src array size . try to write start at position `` + src_position + `` but the array length be `` + src . length ) ; if ( src_position + length > src . length ) throw new illegal argument exception ( `` src_position + length would overrun the src array . expect end at `` + ( src_position + length ) + `` actual end at `` + src . length ) ; if ( dst_position < 0 ) throw new illegal argument exception ( `` dst_position be less than 0 . actual value `` + dst_position ) ; if ( dst_position > = dst . length ) throw new illegal argument exception ( `` dst_position be great than dst array size . try to write start at position `` + dst_position + `` but the array length be `` + dst . length ) ; if ( dst_position + length > dst . length ) throw new illegal argument exception ( `` dst_position + length would overrun the dst array . expect end at `` + ( dst_position + length ) + `` actual end at `` + dst . length ) ; system . arraycopy ( src , src_position , dst , dst_position , length ) ; }
public static long copy ( input stream inp , output stream out ) throw i o exception { final byte [ ] buff = new byte [ 4096 ] ; long total count = 0 ; for ( int count ; ( count = inp . read ( buff ) ) ! = -1 ; total count += count ) { if ( count > 0 ) { out . write ( buff , 0 , count ) ; } } return total count ; }
public static float get float ( byte [ ] data ) { return get float ( data , 0 ) ; }
public static int get int ( byte [ ] data ) { return get int ( data , 0 ) ; }
public static short get short ( byte [ ] data , int offset ) { int b0 = data [ offset ] & 0x f f ; int b1 = data [ offset + 1 ] & 0x f f ; return ( short ) ( ( b1 < < 8 ) + ( b0 < < 0 ) ) ; }
public static void put u int ( byte [ ] data , int offset , long value ) { int i = offset ; data [ i++ ] = ( byte ) ( ( value > > > 0 ) & 0x f f ) ; data [ i++ ] = ( byte ) ( ( value > > > 8 ) & 0x f f ) ; data [ i++ ] = ( byte ) ( ( value > > > 16 ) & 0x f f ) ; data [ i++ ] = ( byte ) ( ( value > > > 24 ) & 0x f f ) ; }
public void write u int ( long value ) { try { out . write ( ( byte ) ( ( value ) & 0x f f ) ) ; out . write ( ( byte ) ( ( value > > > 8 ) & 0x f f ) ) ; out . write ( ( byte ) ( ( value > > > 16 ) & 0x f f ) ) ; out . write ( ( byte ) ( ( value > > > 24 ) & 0x f f ) ) ; } catch ( i o exception e ) { throw new runtime exception ( e ) ; } }
public int read int ( ) throw i o exception { return read int ( this ) ; }
public static string read unicode string ( little endian input in , int n char ) { byte is16 bit = in . read byte ( ) ; if ( ( is16 bit & 0x01 ) == 0 ) { return read compress unicode ( in , n char ) ; } return read unicode l e ( in , n char ) ; }
public static void put unicode l e ( string input , byte [ ] output , int offset ) { byte [ ] bytes = input . get byte ( utf16le ) ; system . arraycopy ( byte , 0 , output , offset , byte . length ) ; }
public static string map m codepoint string ( string string ) { if ( string == null || string . be empty ( ) ) return string ; init m codepoint map ( ) ; string builder sb = new string builder ( ) ; final int length = string . length ( ) ; for ( int offset = 0 ; offset < length ; ) { integer m codepoint = string . code point at ( offset ) ; integer uni codepoint = m codepoint to unicode . get ( m codepoint ) ; sb . append code point ( uni codepoint == null ? ms codepoint : uni codepoint ) ; offset += character . char count ( ms codepoint ) ; } return sb . to string ( ) ; }
public o p c package get package ( ) { return _document . get package ( ) ; }
public static o p c package open package ( string path ) throw i o exception { try { return o p c package . open ( path ) ; } catch ( invalid format exception e ) { throw new i o exception ( e . to string ( ) , e ) ; } }
public p o i x m l property get property ( ) { if ( property == null ) { try { property = new p o i x m l property ( pkg ) ; } catch ( exception e ) { throw new p o i x m l exception ( e ) ; } } return property ; }
public void commit ( ) throw i o exception { if ( ext part == null & & ext ! = null & & ext . prop ! = null & & ! new_ext_instance . to string ( ) . equal ( ext . prop . to string ( ) ) ) { try { package part name prtname = packaging u r i helper . create part name ( `` /doc props/app . xml `` ) ; pkg . add relationship ( prtname , target mode . internal , `` http : //schemas . openxmlformats . org/office document/2006/relationships/extended-properties `` ) ; ext part = pkg . create part ( prtname , `` application/vnd . openxmlformats-officedocument . extended-properties+xml `` ) ; } catch ( invalid format exception e ) { throw new p o i x m l exception ( e ) ; } } if ( cust part == null & & cust ! = null & & cust . prop ! = null & & ! new_cust_instance . to string ( ) . equal ( cust . prop . to string ( ) ) ) { try { package part name prtname = packaging u r i helper . create part name ( `` /doc props/custom . xml `` ) ; pkg . add relationship ( prtname , target mode . internal , `` http : //schemas . openxmlformats . org/office document/2006/relationships/custom-properties `` ) ; cust part = pkg . create part ( prtname , `` application/vnd . openxmlformats-officedocument . custom-properties+xml `` ) ; } catch ( invalid format exception e ) { throw new p o i x m l exception ( e ) ; } } if ( ext part ! = null & & ext ! = null & & ext . prop ! = null ) { try ( output stream out = ext part . get output stream ( ) ) { if ( ext part . get size ( ) > 0 ) { ext part . clear ( ) ; } ext . prop . save ( out , default_xml_options ) ; } } if ( cust part ! = null & & cust ! = null & & cust . prop ! = null ) { try ( output stream out = cust part . get output stream ( ) ) { cust . prop . save ( out , default_xml_options ) ; } } }
public string get default file name ( ) { return _default name ; }
public void clear override content type ( ) { if ( this . override content type ! = null ) { this . override content type . clear ( ) ; } }
public optional < string > get category property ( ) { return category ; }
public string get last printed property string ( ) { return get date value ( last print ) ; }
public void set modify property ( string modify ) { try { this . modified = set date value ( modify ) ; } catch ( invalid format exception e ) { throw new illegal argument exception ( `` modify : `` + e . get localized message ( ) , e ) ; } }
public static o p c package open ( file file , package access access ) throw invalid format exception { if ( file == null ) { throw new illegal argument exception ( `` 'file ' must be give `` ) ; } if ( file . exists ( ) & & file . be directory ( ) ) { throw new illegal argument exception ( `` file must not be a directory `` ) ; } o p c package pack = new zip package ( file , access ) ; try { if ( pack . part list == null & & access ! = package access . write ) { pack . get part ( ) ; } pack . original package path = file . get absolute path ( ) ; return pack ; } catch ( invalid format exception | runtime exception e ) { i o utils . close quietly ( pack ) ; throw e ; } }
public package part create part ( package part name part name , string content type ) { return this . create part ( part name , content type , true ) ; }
public boolean replace content type ( string old content type , string new content type ) { boolean success = false ; array list < package part > list = get part by content type ( old content type ) ; for ( package part package part : list ) { if ( package part . get content type ( ) . equal ( old content type ) ) { package part name part name = package part . get part name ( ) ; content type manager . add content type ( part name , new content type ) ; try { package part . set content type ( new content type ) ; } catch ( invalid format exception e ) { throw new open x m l4 j runtime exception ( `` invalid content type - `` +new content type , e ) ; } success = true ; this . be dirty = true ; } } return success ; }
public void register part and content type ( package part part ) { add package part ( part ) ; this . content type manager . add content type ( part . get part name ( ) , part . get content type ( ) ) ; this . be dirty = true ; }
public string get extension ( ) { string fragment = this . part name u r i . get path ( ) ; if ( fragment . length ( ) > 0 ) { int i = fragment . last index of ( `` . `` ) ; if ( i > -1 ) { return fragment . substring ( i + 1 ) ; } } return `` `` ; }
public static string get filename ( uri uri ) { if ( uri ! = null ) { string path = uri . get path ( ) ; int len = path . length ( ) ; int num2 = len ; while ( -- num2 > = 0 ) { char ch1 = path . char at ( num2 ) ; if ( ch1 == packaging u r i helper . forward_slash_char ) return path . substring ( num2 + 1 , len ) ; } } return `` `` ; }
public static uri get path ( uri uri ) { if ( uri ! = null ) { string path = uri . get path ( ) ; int num2 = path . length ( ) ; while ( -- num2 > = 0 ) { char ch1 = path . char at ( num2 ) ; if ( ch1 == packaging u r i helper . forward_slash_char ) { try { return new uri ( path . substring ( 0 , num2 ) ) ; } catch ( u r i syntax exception e ) { return null ; } } } } return null ; }
public static boolean be valid part name ( uri part uri ) { if ( part uri == null ) throw new illegal argument exception ( `` part uri `` ) ; try { create part name ( part uri ) ; return true ; } catch ( exception e ) { return false ; } }
public static boolean copy stream ( input stream in stream , output stream out stream ) { try { byte [ ] buffer = new byte [ 1024 ] ; int bytes read ; while ( ( bytes read = in stream . read ( buffer ) ) > = 0 ) { out stream . write ( buffer , 0 , byte read ) ; } } catch ( exception e ) { return false ; } return true ; }
public list < byte [ ] > get c r l ( ) { return this . crls ; }
public void set space before ( x d d f space space before ) { if ( space before ! = null || _p . be set p pr ( ) ) { get or create property ( ) . set space before ( space before ) ; } }
public list < x s l f chart > get chart ( ) { return _charts ; }
public x s l f comment author get comment author ( ) { return _comment author ; }
public int get shade ( ) { return get percentage value ( `` shade `` ) ; }
public void clear ( ) { list < x s l f shape > shape = new array list < > ( get shape ( ) ) ; for ( x s l f shape shape : shape ) { remove shape ( shape ) ; } }
public x s l f picture data get picture data ( ) { if ( _data == null ) { string blip id = get blip id ( ) ; if ( blip id == null ) { return null ; } package part p = get sheet ( ) . get package part ( ) ; package relationship rel = p . get relationship ( blip id ) ; if ( rel ! = null ) { try { package part img part = p . get related part ( rel ) ; _data = new x s l f picture data ( img part ) ; } catch ( exception e ) { throw new p o i x m l exception ( e ) ; } } } return _data ; }
public static int read x l wide string ( byte [ ] data , int offset , string builder sb ) throw x s s f b parse exception { long num char = little endian . get u int ( data , offset ) ; if ( num char < 0 ) { throw new x s s f b parse exception ( `` too few char to read `` ) ; } else if ( num char > 0x f f f f f f f f l ) { throw new x s s f b parse exception ( `` too many char to read `` ) ; } int num byte = 2 * ( int ) num char ; offset += 4 ; if ( offset+num bytes > data . length ) { throw new x s s f b parse exception ( `` try to read beyond data length `` ) ; } sb . append ( new string ( data , offset , num byte , standard charsets . utf_16le ) ) ; num bytes+=4 ; return num byte ; }
public void character ( char [ ] ch , int start , int length ) throw s a x exception { if ( t be open ) { if ( in r ph & & include phonetic run ) { character . append ( ch , start , length ) ; } else if ( ! in r ph ) { character . append ( ch , start , length ) ; } } }
public boolean remove comment ( cell address cell ref ) { final string string ref = cell ref . format a string ( ) ; c t comment list lst = comment . get comment list ( ) ; if ( lst ! = null ) { c t comment [ ] comment array = lst . get comment array ( ) ; for ( int i = 0 ; i < comment array . length ; i++ ) { c t comment comment = comment array [ i ] ; if ( string ref . equal ( comment . get ref ( ) ) ) { lst . remove comment ( i ) ; if ( comment ref ! = null ) { comment ref . remove ( cell ref ) ; } return true ; } } } return false ; }
public boolean be all column track ( ) { return track all column ; }
public void lock select unlocked cell ( boolean enable ) { safe get protection field ( ) . set select unlocked cell ( enable ) ; }
public list < ? extend name > get name ( string name ) { return _wb . get name ( name ) ; }
public boolean get force formula recalculation ( ) { return _wb . get force formula recalculation ( ) ; }
public evaluation name get name ( string name , int sheet index ) { for ( int i = 0 ; i < _u book . get number of name ( ) ; i++ ) { x s s f name nm = _u book . get name at ( i ) ; string name text = nm . get name name ( ) ; int name sheetindex = nm . get sheet index ( ) ; if ( name . equal ignore case ( name text ) & & ( name sheetindex == -1 || name sheetindex == sheet index ) ) { return new name ( nm , i , this ) ; } } return sheet index == -1 ? null : get name ( name , -1 ) ; }
public vertical alignment get vertical ( ) { s t vertical alignment . enum align = cell alignement . get vertical ( ) ; if ( align == null ) align = s t vertical alignment . bottom ; return vertical alignment . value ( ) [ align . int value ( ) - 1 ] ; }
public void set text rotation ( long rotation ) { if ( rotation < 0 & & rotation > = -90 ) { rotation = 90 + ( ( -1 ) * rotation ) ; } cell alignement . set text rotation ( rotation ) ; }
public x s s f color get fill foreground color ( ) { c t pattern fill ptrn = _fill . get pattern fill ( ) ; if ( ptrn == null ) return null ; c t color ct color = ptrn . get fg color ( ) ; return x s s f color . from ( ct color , _indexed color map ) ; }
public static string strip field ( string text ) { return org . apache . poi . hssf . usermodel . header footer . strip field ( text ) ; }
public void set author ( string author ) { _comment . set author id ( _comments . find author ( author ) ) ; }
public void set string ( rich text string string ) { if ( ! ( string instanceof x s s f rich text string ) ) { throw new illegal argument exception ( `` only x s s f rich text string argument be support `` ) ; } _str = ( x s s f rich text string ) string ; _comment . set text ( _str . get c t rst ( ) ) ; }
protect static c t connector prototype ( ) { if ( prototype == null ) { c t connector shape = c t connector . factory . new instance ( ) ; c t connector non visual nv = shape . add new nv cxn sp pr ( ) ; c t non visual drawing prop nvp = nv . add new c nv pr ( ) ; nvp . set id ( 1 ) ; nvp . set name ( `` shape 1 `` ) ; nv . add new c nv cxn sp pr ( ) ; c t shape property sp = shape . add new sp pr ( ) ; c t transform2 d t2d = sp . add new xfrm ( ) ; c t positive size2 d p1 = t2d . add new ext ( ) ; p1 . set cx ( 0 ) ; p1 . set cy ( 0 ) ; c t point2 d p2 = t2d . add new off ( ) ; p2 . set x ( 0 ) ; p2 . set y ( 0 ) ; c t preset geometry2 d geom = sp . add new prst geom ( ) ; geom . set prst ( s t shape type . line ) ; geom . add new av lst ( ) ; c t shape style style = shape . add new style ( ) ; c t scheme color scheme = style . add new ln ref ( ) . add new scheme clr ( ) ; scheme . set val ( s t scheme color val . accent_1 ) ; style . get ln ref ( ) . set idx ( 1 ) ; c t style matrix reference fillref = style . add new fill ref ( ) ; fillref . set idx ( 0 ) ; fillref . add new scheme clr ( ) . set val ( s t scheme color val . accent_1 ) ; c t style matrix reference effect ref = style . add new effect ref ( ) ; effect ref . set idx ( 0 ) ; effect ref . add new scheme clr ( ) . set val ( s t scheme color val . accent_1 ) ; c t font reference font ref = style . add new font ref ( ) ; font ref . set idx ( s t font collection index . minor ) ; font ref . add new scheme clr ( ) . set val ( s t scheme color val . tx_1 ) ; prototype = shape ; } return prototype ; }
public x s s f hyperlink create hyperlink ( hyperlink type type ) { return new x s s f hyperlink ( type ) ; }
public x s s f simple shape create simple shape ( x s s f client anchor anchor ) { long shape id = new shape id ( ) ; c t two cell anchor ct anchor = create two cell anchor ( anchor ) ; c t shape ct shape = ct anchor . add new sp ( ) ; ct shape . set ( x s s f simple shape . prototype ( ) ) ; ct shape . get nv sp pr ( ) . get c nv pr ( ) . set id ( shape id ) ; ct shape . get sp pr ( ) . set xfrm ( create xfrm ( anchor ) ) ; x s s f simple shape shape = new x s s f simple shape ( this , ct shape ) ; shape . anchor = anchor ; return shape ; }
public void set text ( string text ) { if ( text == null ) { get header footer ( ) . unset even footer ( ) ; if ( ! get header footer ( ) . be set even header ( ) ) { get header footer ( ) . unset different odd even ( ) ; } } else { get header footer ( ) . set even footer ( text ) ; } }
public void set macro ( string macro ) { graphic frame . set macro ( macro ) ; }
public string get name ( ) { return get non visual property ( ) . get name ( ) ; }
public boolean get different odd even ( ) { return get header footer ( ) . be set different odd even ( ) ? get header footer ( ) . get different odd even ( ) : false ; }
public void set different odd even ( boolean flag ) { get header footer ( ) . set different odd even ( flag ) ; }
public void remove align with margin ( ) { if ( get header footer ( ) . be set align with margin ( ) ) { get header footer ( ) . unset align with margin ( ) ; } }
public void set last column ( int col ) { set first column ( col ) ; }
public int get length of format run ( int index ) { if ( st . size of r array ( ) == 0 || index > = st . size of r array ( ) ) { return -1 ; } c t r elt r = st . get r array ( index ) ; return r . get t ( ) . length ( ) ; }
public void set display name ( string name ) { ct table . set display name ( name ) ; }
public void set cell reference ( area reference ref ) { set cell ref ( refs ) ; }
public long get id ( ) { return ct table column . get id ( ) ; }
public int get column index ( ) { return table . find column index ( get name ( ) ) ; }
public void add tab stop ( double value ) { c t text paragraph property pr = _p . be set p pr ( ) ? _p . get p pr ( ) : _p . add new p pr ( ) ; c t text tab stop list tab stop = pr . be set tab lst ( ) ? pr . get tab lst ( ) : pr . add new tab lst ( ) ; tab stop . add new tab ( ) . set po ( unit . to e m u ( value ) ) ; }
public boolean be bullet ( ) { paragraph property fetcher < boolean > fetcher = new paragraph property fetcher < boolean > ( get level ( ) ) { public boolean fetch ( c t text paragraph property prop ) { if ( prop . be set bu none ( ) ) { set value ( false ) ; return true ; } if ( prop . be set bu font ( ) ) { if ( prop . be set bu char ( ) || prop . be set bu auto num ( ) ) { set value ( true ) ; return true ; } / * else { // excel treat text with bu font but no char/autonum // a not bulleted // possibly the font be just use if bullet turn on again ? } * / } return false ; } } ; fetch paragraph property ( fetcher ) ; return fetcher . get value ( ) == null ? false : fetcher . get value ( ) ; }
public void set strikethrough ( boolean strike ) { get r pr ( ) . set strike ( strike ? s t text strike type . sng_strike : s t text strike type . no_strike ) ; }
public p o i x m l document part get owner ( ) { return footnote ; }
public void set chart height ( long height ) { ct inline . get extent ( ) . set cy ( height ) ; }
public void set chart leave margin ( long margin ) { ct inline . set dist l ( margin ) ; }
public x w p f header footer policy get header footer policy ( ) { return header footer policy ; }
public x w p f paragraph create paragraph ( ) { x w p f paragraph p = new x w p f paragraph ( ct document . get body ( ) . add new p ( ) , this ) ; body element . add ( p ) ; paragraph . add ( p ) ; return p ; }
public x w p f style create style ( ) { if ( style == null ) { style document style doc = style document . factory . new instance ( ) ; x w p f relation relation = x w p f relation . style ; int i = get relation index ( relation ) ; x w p f style wrapper = ( x w p f style ) create relationship ( relation , x w p f factory . get instance ( ) , i ) ; wrapper . set style ( style doc . add new style ( ) ) ; style = wrapper ; } return style ; }
public void set table ( int po , x w p f table table ) { table . set ( po , table ) ; ct document . get body ( ) . set tbl array ( po , table . get c t tbl ( ) ) ; }
public void enforce fill form protection ( ) { setting . set enforcement edit value ( s t doc protect . form ) ; }
public boolean validate protection password ( string password ) { return setting . validate protection password ( password ) ; }
public boolean be track revision ( ) { return setting . be track revision ( ) ; }
public long get zoom percent ( ) { return setting . get zoom percent ( ) ; }
public void set even and odd heading ( boolean enable ) { setting . set even and odd heading ( enable ) ; }
public boolean get mirror margin ( ) { return setting . get mirror margin ( ) ; }
public void insert table ( int po , x w p f table table ) { body element . add ( po , table ) ; int i = 0 ; for ( c t tbl tbl : ct document . get body ( ) . get tbl array ( ) ) { if ( tbl == table . get c t tbl ( ) ) { break ; } i++ ; } table . add ( i , table ) ; }
public int get next pic name number ( int format ) throw invalid format exception { int img = get all package picture ( ) . size ( ) + 1 ; string proposal = x w p f picture data . relation [ format ] . get file name ( img ) ; package part name create part name = packaging u r i helper . create part name ( proposal ) ; while ( this . get package ( ) . get part ( create part name ) ! = null ) { img++ ; proposal = x w p f picture data . relation [ format ] . get file name ( img ) ; create part name = packaging u r i helper . create part name ( proposal ) ; } return img ; }
public x w p f endnote add endnote ( c t ftn edn note ) { c t ftn edn new note = ct endnotes . add new endnote ( ) ; new note . set ( note ) ; x w p f endnote x note = new x w p f endnote ( new note , this ) ; list footnote . add ( x note ) ; return x note ; }
public void ensure footnote ref ( x w p f paragraph p ) { x w p f run r = null ; if ( p . get run ( ) . size ( ) > 0 ) { r = p . get run ( ) . get ( 0 ) ; } if ( r == null ) { r = p . create run ( ) ; } ctr ctr = r . get c t r ( ) ; boolean find ref = false ; for ( c t ftn edn ref ref : ctr . get footnote reference list ( ) ) { if ( get id ( ) . equal ( ref . get id ( ) ) ) { find ref = true ; break ; } } if ( ! find ref ) { ctr . add new r pr ( ) . add new r style ( ) . set val ( `` footnote reference `` ) ; ctr . add new footnote ref ( ) ; } }
public x w p f paragraph create paragraph ( ) { x w p f paragraph paragraph = new x w p f paragraph ( header footer . add new p ( ) , this ) ; paragraph . add ( paragraph ) ; body element . add ( paragraph ) ; return paragraph ; }
public big integer get abstract num i d ( big integer num i d ) { x w p f num num = get num ( num i d ) ; if ( num == null ) return null ; if ( num . get c t num ( ) == null ) return null ; if ( num . get c t num ( ) . get abstract num id ( ) == null ) return null ; return num . get c t num ( ) . get abstract num id ( ) . get val ( ) ; }
public void set spelling language ( string str spell language ) { c t language lang = get c t language ( ) ; lang . set val ( str spell language ) ; lang . set bidi ( str spell language ) ; }
public void set east asia ( string str east asia ) { c t language lang = get c t language ( ) ; lang . set east asia ( str east asia ) ; }
public void add paragraph ( x w p f paragraph p ) { paragraph . add ( p ) ; }
public void set width ( string width value ) { x w p f table . set width value ( width value , get tc width ( ) ) ; }
public static int get header size ( int document version ) { if ( document version > 6 ) { return chunk header v11 . get header size ( ) ; } else if ( document version == 6 ) { return chunk header v6 . get header size ( ) ; } else { return chunk header v4 v5 . get header size ( ) ; } }
protect int populate dictionary ( byte [ ] dict ) { return 0 ; }
protect void copy block header to content ( ) { if ( block header in content ) return ; prepend content with ( block header ) ; block header in content = true ; }
public void extract message body ( output stream out ) throw i o exception { m a p i rtf attribute body = ( m a p i rtf attribute ) message . get message m a p i attribute ( m a p i property . rtf_compressed ) ; if ( body ! = null ) { out . write ( body . get data ( ) ) ; } }
public void dump escher ( ) throw i o exception { directory node escher dir = ( directory node ) f . get root ( ) . get entry ( `` escher `` ) ; dump escher stm ( escher dir ) ; dump escher delay stm ( escher dir ) ; }
protect void generate data ( ) { int size = 0 ; for ( int i=0 ; i < record . length ; i++ ) { size += record [ i ] . get record size ( ) ; } byte data [ ] = i o utils . safely allocate ( size , max_record_length ) ; size = 0 ; for ( int i=0 ; i < record . length ; i++ ) { int this size = record [ i ] . serialize ( size , data ) ; size += this size ; } set data ( data ) ; }
public static void main ( string args [ ] ) throw i o exception { if ( args . length < 1 ) { system . err . println ( `` useage : `` ) ; system . err . println ( `` \t power point extractor [ -notes ] < file > `` ) ; system . exit ( 1 ) ; } boolean note = false ; boolean comment = false ; boolean master = true ; string file ; if ( args . length > 1 ) { note = true ; file = args [ 1 ] ; if ( args . length > 2 ) { comment = true ; } } else { file = args [ 0 ] ; } power point extractor ppe = new power point extractor ( file ) ; system . out . println ( ppe . get text ( true , note , comment , master ) ) ; ppe . close ( ) ; }
public void set header text ( string text ) { set header visible ( true ) ; c string c = _container . get header atom ( ) ; if ( cs == null ) { cs = _container . add header atom ( ) ; } c . set text ( text ) ; }
public void set footer text ( string text ) { set footer visible ( true ) ; c string c = _container . get footer atom ( ) ; if ( cs == null ) { cs = _container . add footer atom ( ) ; } c . set text ( text ) ; }
public void set value with mask ( int val , int write mask ) { set write mask ( write mask ) ; super . set value ( mask value ( val ) ) ; if ( val ! = super . get value ( ) ) { logger . log ( p o i logger . warn , `` style property of ' `` +get name ( ) + `` ' do n't match mask - output will be sanitize `` ) ; if ( logger . check ( p o i logger . debug ) ) { string builder sb = new string builder ( `` the following style attribute of the ' `` +get name ( ) + `` ' property will be ignore : \n `` ) ; int i=0 ; for ( int mask : sub prop mask ) { if ( ! sub prop match [ i ] & & ( val & mask ) ! = 0 ) { sb . append ( sub prop name [ i ] ) . append ( `` , `` ) ; } i++ ; } logger . log ( p o i logger . debug , sb . to string ( ) ) ; } } }
public boolean get sub value ( int idx ) { return sub prop match [ idx ] & & ( ( super . get value ( ) & sub prop mask [ idx ] ) ! = 0 ) ; }
public boolean equal ( object other ) { if ( this == other ) return true ; if ( other == null ) return false ; if ( get class ( ) ! = other . get class ( ) ) return false ; text prop collection o = ( text prop collection ) other ; if ( o . mask special ! = this . mask special || o . indent level ! = this . indent level ) { return false ; } return text prop . equal ( o . text prop ) ; }
public int get slide count ( ) { return little endian . get int ( _recdata , 18 ) ; }
public int get option ( ) { return little endian . get short ( _header ) ; }
public slide list with text get master slide list with text ( ) { for ( int i = 0 ; i < slwts . length ; i++ ) { if ( slwts [ i ] . get instance ( ) == slide list with text . master ) { return slwts [ i ] ; } } return null ; }
public font collection get font collection ( ) { return font collection ; }
public long get record type ( ) { return _type ; }
public ex video container get ex video ( ) { return ex video ; }
public ex hyperlink [ ] get ex hyperlink ( ) { array list < ex hyperlink > link = new array list < > ( ) ; for ( int i=0 ; i < _children . length ; i++ ) { if ( _children [ i ] instanceof ex hyperlink ) { link . add ( ( ex hyperlink ) _children [ i ] ) ; } } return link . to array ( new ex hyperlink [ link . size ( ) ] ) ; }
public void set object i d seed ( int seed ) { little endian . put int ( _data,0 , seed ) ; }
public int get draw aspect ( ) { return little endian . get int ( _data , 0 ) ; }
public int get type ( ) { return little endian . get int ( _data , 4 ) ; }
public void write out ( output stream out ) throw i o exception { out . write ( _header ) ; out . write ( _data ) ; }
public int get indent at ( int offset ) { int char until = 0 ; for ( indent prop prop : indent ) { char until += prop . get character cover ( ) ; if ( offset < char until ) { return prop . get indent level ( ) ; } } return -1 ; }
public escher dg record get escher dg record ( ) { if ( dg == null ) { escher container record dgr = get dg container ( ) ; if ( dgr ! = null ) { for ( escher record r : dgr . get child record ( ) ) { if ( r instanceof escher dg record ) { dg = ( escher dg record ) r ; break ; } } } } return dg ; }
public static void write little endian ( short s , output stream o ) throw i o exception { byte [ ] b = new byte [ 2 ] ; little endian . put short ( bs,0 , s ) ; o . write ( b ) ; }
public record [ ] get child record ( ) { return null ; }
public record find first of type ( long type ) { for ( record r : _children ) { if ( r . get record type ( ) == type ) { return r ; } } return null ; }
public string get sound name ( ) { return _name . get text ( ) ; }
public void set text size ( int size ) { little endian . put int ( data , 0 , size ) ; }
public long get record type ( ) { return _type ; }
public text prop collection add character text prop collection ( int character cover ) { text prop collection tpc = new text prop collection ( character cover , text prop type . character ) ; char style . add ( tpc ) ; return tpc ; }
public long get record type ( ) { return _type ; }
public long get record type ( ) { return _type ; }
public list < text prop collection > get character style ( ) { return char style ; }
public long get record type ( ) { return _type ; }
public void set adjustment value ( int idx , int val ) { if ( idx < 0 || idx > 9 ) throw new illegal argument exception ( `` the index of an adjustment value must be in the [ 0 , 9 ] range `` ) ; set escher property ( ( short ) ( escher property . geometry__adjustvalue + idx ) , val ) ; }
public list < list < h s l f text paragraph > > get text paragraph ( ) { return _paragraphs ; }
protect void after insert ( h s l f sheet sh ) { super . after insert ( sh ) ; escher b s e record bse = get escher b s e record ( ) ; bse . set ref ( bse . get ref ( ) + 1 ) ; rectangle2 d anchor = get anchor ( ) ; if ( anchor . be empty ( ) ) { new draw picture shape ( this ) . resize ( ) ; } }
public static < t extend escher record > t get escher child ( escher container record owner , int record id ) { return owner . get child by id ( ( short ) record id ) ; }
protected list < ? extend record > get client record ( ) { h s l f escher client data record client data = get client data ( false ) ; return ( client data == null ) ? null : client data . get h s l f child record ( ) ; }
public color scheme atom get color scheme ( ) { return _container . get color scheme ( ) ; }
public record [ ] get record ( ) { return _records ; }
public void write ( byte [ ] b ) { }
public string to string ( ) { return to debug friendly string ( value ) ; }
public m a p i message get m a p i message ( ) { return ( m a p i message ) document ; }
public string get html body ( ) throw chunk not find exception { if ( main chunk . get html body chunk binary ( ) ! = null ) { return main chunk . get html body chunk binary ( ) . get as7bit string ( ) ; } return get string from chunk ( main chunk . get html body chunk string ( ) ) ; }
public string get display to ( ) throw chunk not find exception { return get string from chunk ( main chunk . get display to chunk ( ) ) ; }
public string get text ( ) { try { word to text converter word to text converter = new word to text converter ( ) ; header story hs = new header story ( doc ) ; if ( h . get first header subrange ( ) ! = null ) word to text converter . process document part ( doc , h . get first header subrange ( ) ) ; if ( h . get even header subrange ( ) ! = null ) word to text converter . process document part ( doc , h . get even header subrange ( ) ) ; if ( h . get odd header subrange ( ) ! = null ) word to text converter . process document part ( doc , h . get odd header subrange ( ) ) ; word to text converter . process document ( doc ) ; word to text converter . process document part ( doc , doc . get main textbox range ( ) ) ; if ( h . get first footer subrange ( ) ! = null ) word to text converter . process document part ( doc , h . get first footer subrange ( ) ) ; if ( h . get even footer subrange ( ) ! = null ) word to text converter . process document part ( doc , h . get even footer subrange ( ) ) ; if ( h . get odd footer subrange ( ) ! = null ) word to text converter . process document part ( doc , h . get odd footer subrange ( ) ) ; return word to text converter . get text ( ) ; } catch ( runtime exception e ) { throw e ; } catch ( exception exc ) { throw new runtime exception ( exc ) ; } }
public static p o i f s file system verify and build p o i f s ( input stream istream ) throw i o exception { input stream be = file magic . prepare to check magic ( istream ) ; file magic fm = file magic . value of ( be ) ; if ( fm ! = file magic . ole2 ) { throw new illegal argument exception ( `` the document be really a `` +fm+ `` file `` ) ; } return new p o i f s file system ( be ) ; }
public list < string > get entry ( ) { return collection . unmodifiable list ( arrays . a list ( entry ) ) ; }
public int num style ( ) { return _style description . length ; }
public void set f col ( boolean value ) { field_2_bkf_flags = ( short ) f col . set boolean ( field_2_bkf_flags , value ) ; }
public void set f zombie embed ( boolean value ) { field_2_flt = ( byte ) f zombie embed . set boolean ( field_2_flt , value ) ; }
public boolean be f result edit ( ) { return f result edit . be set ( field_2_flt ) ; }
public byte get grpf ihdt ( ) { return field_10_grpf ihdt ; }
public void set brc top ( border code field_20_brc top ) { this . field_20_brc top = field_20_brc top ; }
public int get lnn min ( ) { return field_34_lnn min ; }
public void set lnn min ( int field_34_lnn min ) { this . field_34_lnn min = field_34_lnn min ; }
public void set unused3 ( short field_36_unused3 ) { this . field_36_unused3 = field_36_unused3 ; }
public void set xa page n up ( int field_41_xa page n up ) { this . field_41_xa page n up = field_41_xa page n up ; }
public int get dza gutter ( ) { return field_47_dza gutter ; }
public void set dza gutter ( int field_47_dza gutter ) { this . field_47_dza gutter = field_47_dza gutter ; }
public void set dm orient first ( byte field_56_dm orient first ) { this . field_56_dm orient first = field_56_dm orient first ; }
public void set f color ( boolean value ) { field_2_tlp_flags = ( byte ) f color . set boolean ( field_2_tlp_flags , value ) ; }
public paragraph property clone property ( ) { try { return ( paragraph property ) _props . clone ( ) ; } catch ( exception e ) { throw new runtime exception ( e ) ; } }
public boolean have be claim ( picture picture ) { return claim . contains ( picture ) ; }
public boolean sanity check ( ) { document format exception . check ( _start > = 0 , `` start ca n't be < 0 `` ) ; document format exception . check ( _start < = _text . length ( ) , `` start ca n't be > text length `` ) ; document format exception . check ( _end > = 0 , `` end ca n't be < 0 `` ) ; document format exception . check ( _end < = _text . length ( ) , `` end ca n't be > text length `` ) ; document format exception . check ( _start < = _end , `` start ca n't be > end `` ) ; if ( _char range find ) { for ( int c = _char start ; c < _char end ; c++ ) { chpx chpx = _characters . get ( c ) ; int leave = math . max ( this . _start , chpx . get start ( ) ) ; int right = math . min ( this . _end , chpx . get end ( ) ) ; document format exception . check ( left < right , `` leave must be < right `` ) ; } } if ( _par range find ) { for ( int p = _par start ; p < _par end ; p++ ) { papx papx = _paragraphs . get ( p ) ; int leave = math . max ( this . _start , papx . get start ( ) ) ; int right = math . min ( this . _end , papx . get end ( ) ) ; document format exception . check ( left < right , `` leave must be < right `` ) ; } } return true ; }
public short get endnote restart qualifier ( ) { return _props . get rnc edn ( ) ; }
public int get endnote number format ( ) { return _props . get nfc edn ref ( ) ; }
public com . google . protobuf . byte string get value ( ) { return value_ ; }
public final void copy to ( byte [ ] target , int source offset , int target offset , int number to copy ) { check range ( source offset , source offset + number to copy , size ( ) ) ; check range ( target offset , target offset + number to copy , target . length ) ; if ( number to copy > 0 ) { copy to internal ( target , source offset , target offset , number to copy ) ; } }
public static cod input stream new instance ( final byte [ ] buf ) { return new instance ( buf , 0 , buf . length ) ; }
public static cod input stream new instance ( byte buffer buf ) { return new instance ( buf , false / * buffer be immutable * / ) ; }
public static long decode zig zag64 ( final long n ) { return ( n > > > 1 ) ^ - ( n & 1 ) ; }
public final void write raw byte ( final byte [ ] value ) throw i o exception { write ( value , 0 , value . length ) ; }
public final void write enum no tag ( final int value ) throw i o exception { write int32 no tag ( value ) ; }
public static extension registry new instance ( ) { return new extension registry ( ) ; }
public set < extension info > get all immutable extension by extend type ( final string full name ) { hash set < extension info > extension = new hash set < extension info > ( ) ; for ( descriptor int pair pair : immutable extension by number . key set ( ) ) { if ( pair . descriptor . get full name ( ) . equal ( full name ) ) { extension . add ( immutable extension by number . get ( pair ) ) ; } } return extension ; }
public int get value ( ) { return value_ ; }
public long get value ( ) { return value_ ; }
public static lazy field lite from value ( message lite value ) { lazy field lite lf = new lazy field lite ( ) ; lf . set value ( value ) ; return lf ; }
public message lite set value ( message lite value ) { message lite original value = this . value ; this . delay bytes = null ; this . memoized byte = null ; this . value = value ; return original value ; }
public boolean have value ( ) { return value_ ! = null ; }
public int get count ( ) { return message . size ( ) ; }
public list < m type > get message list ( ) { if ( external message list == null ) { external message list = new message external list < m type , b type , i type > ( this ) ; } return external message list ; }
public java . lang . string get file name ( ) { java . lang . object ref = file name_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; file name_ = s ; return s ; } }
public list < text format parse info tree > get nest tree ( final field descriptor field descriptor ) { list < text format parse info tree > result = subtrees from field . get ( field descriptor ) ; return result == null ? collection . < text format parse info tree > empty list ( ) : result ; }
public int get nanos ( ) { return nanos_ ; }
public boolean be custom scope declare on ( class info clazz ) { for ( dot name scope : custom scope names ) { if ( clazz . class annotation ( scope ) ! = null ) { return true ; } } return false ; }
public t set user setting ( file user setting ) { this . user setting = user setting ; return ( t ) this ; }
public build step builder add build step ( build step build step ) { final build step builder build step builder = new build step builder ( this ) ; build step builder . set build step ( build step ) ; return build step builder ; }
public < t extend simple build item > t consume ( class < t > type ) { assert . check not null param ( `` type `` , type ) ; if ( ! run ) { throw message . msg . build step not run ( ) ; } final item id id = new item id ( type ) ; if ( id . be multi ( ) ) { throw message . msg . can not multi ( id ) ; } if ( ! step info . get consumes ( ) . contains ( id ) ) { throw message . msg . undeclared item ( id ) ; } return type . cast ( execution . get single ( ) . get ( id ) ) ; }
public void note ( location location , string format , object . . . args ) { final list < diagnostic > list = execution . get diagnostics ( ) ; list . add ( new diagnostic ( diagnostic . level . note , location , format , args ) ) ; }
public build step builder consumes ( class < ? extend build item > type ) { assert . check not null param ( `` type `` , type ) ; if ( empty build item . class . be assignable from ( type ) ) { throw new illegal argument exception ( `` can not consume an empty build item `` ) ; } add consumes ( new item id ( type ) , constraint . real , consume flag . none ) ; return this ; }
public static object build ( list < object > key element ) { if ( key element == null || key element . be empty ( ) ) { throw new illegal argument exception ( `` at least one key element be require to build a cache key `` ) ; } else if ( key element . size ( ) == 1 ) { if ( key element . get ( 0 ) == null ) { throw new null pointer exception ( null_keys_not_supported_msg ) ; } return key element . get ( 0 ) ; } else { return new composite cache key ( key element ) ; } }
public static void exit ( int code ) { state lock . lock ( ) ; try { if ( code > = 0 & & exit code == -1 ) { exit code = code ; } if ( shutdown request ) { return ; } shutdown requested = true ; state cond . signal all ( ) ; } finally { state lock . unlock ( ) ; } }
public memory size convert ( string value ) { value = value . trim ( ) ; if ( value . be empty ( ) ) { return null ; } matcher matcher = memory_size_pattern . matcher ( value ) ; if ( matcher . find ( ) ) { big integer number = new big integer ( matcher . group ( 1 ) ) ; string scale = matcher . group ( 2 ) . to upper case ( ) ; big integer multiplier = memory_size_multipliers . get ( scale ) ; return multiplier == null ? new memory size ( number ) : new memory size ( number . multiply ( multiplier ) ) ; } throw new illegal argument exception ( string . format ( `` value % s not in correct format ( regular expression ) : [ 0-9 ] + [ bb kk mm gg tt pp ee zz yy ] ? `` , value ) ) ; }
public static void run ( string . . . args ) { run ( null , args ) ; }
public path get archive location ( ) { final iterator < path > i = path . iterator ( ) ; path last = i . next ( ) ; while ( i . have next ( ) ) { last = i . next ( ) ; } return last ; }
public path get archive root ( ) { return archive root ; }
public < t > t get context object ( class < t > type ) { return ( t ) reload context . get ( type ) ; }
public boolean add pattern ( string pattern , t on match ) { assert . check not null param ( `` pattern `` , pattern ) ; assert . check not null param ( `` on match `` , on match ) ; return add pattern ( new name iterator ( pattern , false ) , on match ) ; }
public multi tenancy strategy get multi tenancy strategy ( ) { return multi tenancy strategy . get ( ) ; }
public static < t extend panache entity base > t find by id ( object id ) { throw jpa operation . implementation injection miss ( ) ; }
public default boolean be persistent ( entity entity ) { return jpa operation . be persistent ( entity ) ; }
public void end invalidate region ( ) { synchronize ( this ) { if ( -- region invalidation == 0 ) { region invalidation timestamp = next timestamp . get ( ) ; if ( trace ) { log . tracef ( `` finish invalidating region % s at % d `` , region name , region invalidation timestamp ) ; } } else { if ( trace ) { log . tracef ( `` finish invalidating region % s , but there be % d ongoing invalidation `` , region name , region invalidation ) ; } } } }
public static sort by ( string column , direction direction ) { return new sort ( ) . and ( column , direction ) ; }
public static path get test class location ( class < ? > test class ) { string class file name = test class . get name ( ) . replace ( ' . ' , file . separator char ) + `` . class `` ; url resource = test class . get class loader ( ) . get resource ( test class . get name ( ) . replace ( ' . ' , '/ ' ) + `` . class `` ) ; if ( resource . get protocol ( ) . equal ( `` jar `` ) ) { try { resource = uri . create ( resource . get file ( ) . substring ( 0 , resource . get file ( ) . index of ( ' ! ' ) ) ) . to u r l ( ) ; return to path ( resource ) ; } catch ( malformed u r l exception e ) { throw new runtime exception ( `` fail to resolve the location of the jar contain `` + test class , e ) ; } } if ( ! be in test dir ( resource ) ) { throw new runtime exception ( `` the test class `` + test class + `` be not locate in any of the directory `` + test_to_main_dir_fragments . key set ( ) ) ; } path path = to path ( resource ) ; return path . get root ( ) . resolve ( path . subpath ( 0 , path . get name count ( ) - path . get ( class file name ) . get name count ( ) ) ) ; }
public synchronize path matcher add prefix path ( final string path , final t handler ) { if ( path . be empty ( ) ) { throw new illegal argument exception ( `` path not specify `` ) ; } if ( path matcher . string_path_separator . equal ( path ) ) { this . default handler = handler ; return this ; } path . put ( path , handler ) ; build length ( ) ; return this ; }
public final mono < t > checkpoint ( @ nullable string description , boolean force stack trace ) { final assembly snapshot stacktrace ; if ( ! force stack trace ) { stacktrace = new assembly light snapshot ( description ) ; } else { stacktrace = new assembly snapshot ( description , trace . call site supplier factory . get ( ) ) ; } return new mono on assembly < > ( this , stacktrace ) ; }
public final mono < t > or ( mono < ? extend t > other ) { if ( this instanceof mono first with signal ) { mono first with signal < t > a = ( mono first with signal < t > ) this ; mono < t > result = a . or additional source ( other ) ; if ( result ! = null ) { return result ; } } return first with signal ( this , other ) ; }
public final flux < t > repeat ( boolean supplier predicate ) { return flux . on assembly ( new mono repeat predicate < > ( this , predicate ) ) ; }
public final flux < t > repeat ( long num repeat , boolean supplier predicate ) { if ( num repeat < 0l ) { throw new illegal argument exception ( `` num repeat > = 0 require `` ) ; } if ( num repeat == 0 ) { return this . flux ( ) ; } return flux . defer ( ( ) - > repeat ( flux . count boolean supplier ( predicate , num repeat ) ) ) ; }
protect final boolean validate ( subscriber < ? > [ ] subscriber ) { int p = parallelism ( ) ; if ( subscriber . length ! = p ) { illegal argument exception iae = new illegal argument exception ( `` parallelism = `` + `` `` + p + `` , subscriber = `` + subscriber . length ) ; for ( subscriber < ? > s : subscriber ) { operator . error ( s , iae ) ; } return false ; } return true ; }
protect void on inbound close ( ) { discard when no receiver ( ) ; terminate ( ) ; }
public tcp client no s s l ( ) { if ( configuration ( ) . be secure ( ) ) { tcp client dup = duplicate ( ) ; dup . configuration ( ) . ssl provider = null ; return dup ; } return this ; }
public tcp server no s s l ( ) { if ( configuration ( ) . be secure ( ) ) { tcp server dup = duplicate ( ) ; dup . configuration ( ) . ssl provider = null ; return dup ; } return this ; }
public static inet socket address create unresolved ( string hostname , int port ) { return create inet socket address ( hostname , port , false ) ; }
public t remote address ( supplier < ? extend socket address > remote address supplier ) { object . require non null ( remote address supplier , `` remote address supplier `` ) ; t dup = duplicate ( ) ; dup . configuration ( ) . remote address = remote address supplier ; return dup ; }
public int max payload size ( ) { return max payload size ; }
public final void bind until java shutdown ( duration timeout , @ nullable consumer < disposable server > on start ) { object . require non null ( timeout , `` timeout `` ) ; disposable server facade = object . require non null ( bind now ( ) , `` facade `` ) ; if ( on start ! = null ) { on start . accept ( facade ) ; } runtime . get runtime ( ) . add shutdown hook ( new thread ( ( ) - > facade . dispose now ( timeout ) ) ) ; facade . on dispose ( ) . block ( ) ; }
public mono < void > leave ( final inet address multicast address , @ nullable network interface iface ) { if ( null == iface & & null ! = datagram channel . config ( ) . get network interface ( ) ) { iface = datagram channel . config ( ) . get network interface ( ) ; } final channel future future ; if ( null ! = iface ) { future = datagram channel . leave group ( new inet socket address ( multicast address , datagram channel . local address ( ) . get port ( ) ) , iface ) ; } else { future = datagram channel . leave group ( multicast address ) ; } return future mono . from ( future ) . do on success ( v - > { if ( log . be info enable ( ) ) { log . info ( format ( future . channel ( ) , `` join { } `` ) , multicast address ) ; } } ) ; }
public static http2 resource get ( ) { return get or create ( http2 resource , null , null , on_http2_new , `` http2 `` ) ; }
public http response decoder spec decoder ( ) { return decoder ; }
public websocket client spec websocket client spec ( ) { return websocket client spec ; }
public http response decoder spec parse http after connect request ( boolean parse http after connect request ) { this . parse http after connect request = parse http after connect request ; return this ; }
public t max header size ( int value ) { if ( value < = 0 ) { throw new illegal argument exception ( `` max header size must be strictly positive `` ) ; } this . max header size = value ; return get ( ) ; }
public http request decoder spec decoder ( ) { return decoder ; }
public request spec builder add param ( string parameter name , object . . . parameter value ) { spec . param ( parameter name , parameter value ) ; return this ; }
public request spec builder add path param ( string parameter name , object parameter value ) { spec . path param ( parameter name , parameter value ) ; return this ; }
public request spec builder set trust store ( string path to jks , string password ) { spec . trust store ( path to jks , password ) ; return this ; }
public request spec builder set trust store ( key store trust store ) { spec . trust store ( trust store ) ; return this ; }
public response spec builder expect cookie ( string cookie name ) { spec . cookie ( cookie name ) ; return this ; }
public response spec builder append root path ( string path to append ) { spec . append root path ( path to append ) ; return this ; }
public response spec builder detach root path ( string path to detach ) { spec . detach root path ( path to detach ) ; return this ; }
public connection config close idle connection after each response after ( long idle time , time unit time unit ) { return new connection config ( new close idle connection config ( idle time , time unit ) ) ; }
public decoder config default charset for content type ( string charset , string content type ) { not null ( charset , `` charset `` ) ; not null ( content type , `` content type `` ) ; map < string , string > map = new hash map < string , string > ( content type to default charset ) ; map . put ( trim ( content type ) . to lower case ( ) , trim ( charset ) ) ; return new decoder config ( charset , use no wrap for inflate decoding , true , content decoder , map ) ; }
public string default boundary ( ) { return default boundary ; }
public object mapper config jaxb object mapper factory ( j a x b object mapper factory jaxb object mapper factory ) { return new object mapper config ( default object mapper , default object mapper type , gson object mapper factory , jackson1 object mapper factory , jackson2 object mapper factory , jaxb object mapper factory , johnzon object mapper factory , jsonb object mapper factory , true ) ; }
public param config query params update strategy ( update strategy update strategy ) { return new param config ( update strategy , form params update strategy , request parameter update strategy , true ) ; }
public redirect config max redirects ( int value ) { return new redirect config ( follow redirects , allow circular redirects , reject relative redirect , value , true ) ; }
public rest assure config decoder config ( decoder config decoder config ) { not null ( decoder config , `` decoder config `` ) ; return new rest assure config ( conf ( redirect config . class ) , conf ( http client config . class ) , conf ( log config . class ) , conf ( encoder config . class ) , decoder config , conf ( session config . class ) , conf ( object mapper config . class ) , conf ( connection config . class ) , conf ( json config . class ) , conf ( xml config . class ) , conf ( s s l config . class ) , conf ( matcher config . class ) , conf ( header config . class ) , conf ( multi part config . class ) , conf ( param config . class ) , conf ( o auth config . class ) , conf ( failure config . class ) ) ; }
public s s l config relax h t t p s validation ( ) { return relax h t t p s validation ( ssl ) ; }
public xml config property ( string name , object value ) { validate . not empty ( name , `` name can not be empty `` ) ; map < string , object > new property = new hash map < string , object > ( property ) ; new property . put ( name , value ) ; return new xml config ( feature , declare namespaces , new property , validate , namespace aware , allow doc type declaration , true ) ; }
public boolean be validate ( ) { return validating ; }
public cookie get ( string cookie name ) { assert parameter . not null ( cookie name , `` cookie name `` ) ; return cooky . get ( cookie name ) ; }
public header get ( string header name ) { not null ( header name , `` header name `` ) ; return header . get ( header name ) ; }
public object get uri ( ) { return default u r i ; }
public int get status ( ) { return response base . get status line ( ) . get status code ( ) ; }
public object get data ( ) { return this . response data ; }
public u r i builder set path ( string path ) throw u r i syntax exception { / * pass the path string in the uri constructor will * double-escape path parameter and goober thing up . so we have * to create a full path+query+fragment and use uri # resolve ( ) to * create the new uri . * / string builder sb = new string builder ( ) ; if ( path ! = null ) sb . append ( path ) ; string query = base . get query ( ) ; if ( query ! = null ) { sb . append ( ' ? ' ) ; sb . append ( query ) ; } string frag = base . get raw fragment ( ) ; if ( frag ! = null ) sb . append ( ' # ' ) . append ( frag ) ; this . base = base . resolve ( sb . to string ( ) ) ; return this ; }
protect u r i builder clone ( ) { return new u r i builder ( this . base , this . be url encode enable , encoder config ( ) . default query parameter charset ( this . enc ) ) ; }
public detail cookie matcher domain ( matcher < ? super string > domain matcher ) { return new detailed cookie matcher ( and ( matcher . have property ( `` domain `` , domain matcher ) ) ) ; }
public detail cookie matcher path ( string expect path ) { return path ( equal to ( expect path ) ) ; }
public detail cookie matcher path ( matcher < ? super string > path matcher ) { return new detailed cookie matcher ( and ( matcher . have property ( `` path `` , path matcher ) ) ) ; }
public static matcher < string > match dtd in classpath ( string path ) { return xml dtd matcher . match dtd in classpath ( path ) ; }
public static response option ( uri uri ) { return give ( ) . option ( uri ) ; }
public static response put ( url url ) { return give ( ) . put ( url ) ; }
public static authentication scheme form ( string user name , string password , form auth config config ) { if ( user name == null ) { throw new illegal argument exception ( `` username can not be null `` ) ; } if ( password == null ) { throw new illegal argument exception ( `` password can not be null `` ) ; } final form auth scheme scheme = new form auth scheme ( ) ; scheme . set user name ( user name ) ; scheme . set password ( password ) ; scheme . set config ( config ) ; return scheme ; }
public static void register parser ( string content type , parser parser ) { response_parser_registrar . register parser ( content type , parser ) ; }
public resteasy client builder impl disable trust manager ( ) { this . disable trust manager = true ; return this ; }
public resteasy client builder impl default proxy ( string hostname , int port ) { return default proxy ( hostname , port , null ) ; }
public static url create u r l ( string path ) throw malformed u r l exception { return new url ( generate u r l ( path ) ) ; }
public static string get host ( ) { return port provider . get host ( ) ; }
public set < class < ? > > get provider class ( ) { return collection . unmodifiable set ( provider class ) ; }
public void add per request resource ( class clazz ) { add resource factory ( new p o j o resource factory ( resource builder , clazz ) ) ; }
public void add resource factory ( resource factory ref ) { add resource factory ( ref , ( string ) null ) ; }
public static boolean be token ( string value ) { if ( value == null ) return true ; int len = value . length ( ) ; for ( int i = 0 ; i < len ; i++ ) { char c = value . char at ( i ) ; if ( tspecials . index of ( c ) ! = -1 ) return false ; } return true ; }
public boolean be allow credential ( ) { return allow credential ; }
public boolean have matrix params ( ) { return have matrix params ; }
public void set low case name ( boolean b ) { this . low case name = b ; }
public map < string , string > parse ( final string str , char separator ) { if ( str == null ) { return new hash map < string , string > ( ) ; } return parse ( str . to char array ( ) , separator ) ; }
public completion stage < void > async write ( string s ) { return async output stream . async write ( s . get byte ( charset ) ) ; }
public static class < ? > get type argument ( type generic type ) { if ( ! ( generic type instanceof parameterized type ) ) return null ; parameterized type parameterized type = ( parameterized type ) generic type ; class < ? > type arg = ( class < ? > ) parameterized type . get actual type argument ( ) [ 0 ] ; return type arg ; }
public static type [ ] find parameterized type ( class < ? > root , class < ? > search for ) { if ( search for . be interface ( ) ) { return find interface parameterized type ( root , null , search for ) ; } return find class parameterized type ( root , null , search for ) ; }
public @ nullable response < ? > response ( ) { return response ; }
public void set loop ( list < array comprehension loop > loop ) { assert not null ( loop ) ; this . loop . clear ( ) ; for ( array comprehension loop acl : loop ) { add loop ( acl ) ; } }
public void add loop ( array comprehension loop acl ) { assert not null ( acl ) ; loop . add ( acl ) ; acl . set parent ( this ) ; }
public void set body ( ast node body ) { throw new unsupported operation exception ( `` this node type have no body `` ) ; }
public void set be destructuring ( boolean destructuring ) { be destructuring = destructuring ; }
public void set catch condition ( ast node catch condition ) { this . catch condition = catch condition ; if ( catch condition ! = null ) catch condition . set parent ( this ) ; }
public ast node get false expression ( ) { return false expression ; }
public void visit ( node visitor v ) { if ( v . visit ( this ) ) { test expression . visit ( v ) ; true expression . visit ( v ) ; false expression . visit ( v ) ; } }
public void set label ( name label ) { this . label = label ; if ( label ! = null ) label . set parent ( this ) ; }
public void visit ( node visitor v ) { if ( v . visit ( this ) ) { target . visit ( v ) ; element . visit ( v ) ; } }
public void set message ( string message ) { this . message = message ; }
public void set each position ( int each position ) { this . each position = each position ; }
public int get rp ( ) { return rp ; }
public void visit ( node visitor v ) { if ( v . visit ( this ) ) { if ( function name ! = null ) { function name . visit ( v ) ; } for ( ast node param : get params ( ) ) { param . visit ( v ) ; } get body ( ) . visit ( v ) ; if ( ! be expression closure ) { if ( member expr node ! = null ) { member expr node . visit ( v ) ; } } } }
public ast node get condition ( ) { return condition ; }
public void set variable ( variable declaration variable ) { assert not null ( variable ) ; this . variable = variable ; variable . set parent ( this ) ; }
public ast node get body ( ) { return body ; }
public string get identifier ( ) { return identifier ; }
public string get value ( ) { return value ; }
public void set be getter method ( ) { type = token . get ; }
public void set expression ( ast node expression ) { assert not null ( expression ) ; this . expression = expression ; expression . set parent ( this ) ; }
public void set value ( string value ) { assert not null ( value ) ; this . value = value ; }
public void visit ( node visitor v ) { if ( v . visit ( this ) ) { if ( expression ! = null ) { expression . visit ( v ) ; } if ( statement ! = null ) { for ( ast node s : statement ) { s . visit ( v ) ; } } } }
public void set case ( list < switch case > case ) { if ( case == null ) { this . case = null ; } else { if ( this . case ! = null ) this . case . clear ( ) ; for ( switch case sc : case ) add case ( sc ) ; } }
public void set decl type ( int decl type ) { if ( ! ( decl type == token . function || decl type == token . lp || decl type == token . var || decl type == token . let || decl type == token . const ) ) throw new illegal argument exception ( `` invalid decl type : `` + decl type ) ; this . decl type = decl type ; }
public node get node ( ) { return node ; }
public void set index ( int index ) { this . index = index ; }
public boolean be postfix ( ) { return be postfix ; }
public void set be postfix ( boolean be postfix ) { this . be postfix = be postfix ; }
public boolean be destructuring ( ) { return ! ( target instanceof name ) ; }
public void visit ( node visitor v ) { if ( v . visit ( this ) ) { target . visit ( v ) ; if ( initializer ! = null ) { initializer . visit ( v ) ; } } }
public ast node get expression ( ) { return expression ; }
public void set rp ( int rp ) { this . rp = rp ; }
public ast node get expression ( ) { return expression ; }
public void set expression ( ast node expression ) { assert not null ( expression ) ; this . expression = expression ; expression . set parent ( this ) ; }
public ast node get target ( ) { return get leave ( ) ; }
public synchronize void clear cache ( ) { class table = null ; class adapter cache = null ; interface adapter cache = null ; }
protect static ecma error incompatible call error ( id function object f ) { throw script runtime . type error1 ( `` msg . incompat . call `` , f . get function name ( ) ) ; }
public object [ ] get key ( ) { object [ ] array = new object [ key count ] ; get key ( array , 0 ) ; return array ; }
public string get type of ( ) { return avoid object detection ( ) ? `` undefined `` : `` object `` ; }
public object get ( int index , scriptable start ) { if ( external data ! = null ) { if ( index < external data . get array length ( ) ) { return external data . get array element ( index ) ; } return scriptable . not_found ; } slot slot = get slot ( null , index , slot_query ) ; if ( slot == null ) { return scriptable . not_found ; } return slot . get value ( start ) ; }
public scriptable get prototype ( ) { return prototype object ; }
public static scriptable get object prototype ( scriptable scope ) { return top level . get builtin prototype ( get top level scope ( scope ) , top level . builtins . object ) ; }
public void add optional exclude name ( string name ) { object obj = lookup qualify name ( scope , name ) ; if ( obj ! = null & & obj ! = unique tag . not_found ) { if ( ! ( obj instanceof scriptable ) ) { throw new illegal argument exception ( `` object for exclude name `` + name + `` be not a scriptable , it be `` + obj . get class ( ) . get name ( ) ) ; } table . put ( obj , name ) ; } }
public boolean have exclude name ( string name ) { return table . get ( name ) ! = null ; }
public void set break ( ) { this . break flag = true ; }
public void attach to ( context factory factory ) { detach ( ) ; this . context factory = factory ; this . listener = new dim i proxy ( this , iproxy_listen ) ; factory . add listener ( this . listener ) ; }
public void detach ( ) { if ( listener ! = null ) { context factory . remove listener ( listener ) ; context factory = null ; listener = null ; } }
public void dispose ( ) { detach ( ) ; }
public context data current context data ( ) { return interrupt context data ; }
public static main main embed ( string title ) { context factory factory = context factory . get global ( ) ; global global = new global ( ) ; global . init ( factory ) ; return main embed ( factory , global , title ) ; }
public void init quit action ( quit action quit action ) { if ( quit action == null ) throw new illegal argument exception ( `` quit action be null `` ) ; if ( this . quit action ! = null ) throw new illegal argument exception ( `` the method be once-call . `` ) ; this . quit action = quit action ; }
public void close ( ) throw i o exception { internal in . close ( ) ; }
public synchronize code template get template ( r syntax text area text area ) { int caret po = text area . get caret position ( ) ; int char to get = math . min ( caret po , max template i d length ) ; try { document doc = text area . get document ( ) ; doc . get text ( caret pos-chars to get , char to get , s ) ; @ suppress warning ( `` unchecked `` ) int index = collection . binary search ( template , s , comparator ) ; return index > =0 ? ( code template ) templates . get ( index ) : null ; } catch ( bad location exception ble ) { ble . print stack trace ( ) ; throw new internal error ( `` error in code template manager `` ) ; } }
public boolean be zero length ( ) { return start offs == end offs ; }
public int get collapse line count ( ) { return collapse ? get line count ( ) : child collapse line count ; }
public void do mark occurrence ( ) { timer . stop ( ) ; action perform ( null ) ; }
public boolean equal ( object obj ) { if ( ! ( obj instanceof parser notice ) ) { return false ; } return compare to ( ( parser notice ) obj ) ==0 ; }
public boolean get should indent next line ( int line ) { token t = get token list for line ( line ) ; t = t . get last non comment non whitespace token ( ) ; return token maker . get should indent next line after ( t ) ; }
protect r text area u i create r text area u i ( ) { return new r syntax text area u i ( this ) ; }
public boolean get close markup tag ( ) { return close markup tag ; }
public static color get default selection color ( ) { return default_selection_color ; }
public color get foreground for token ( token t ) { if ( get hyperlink enable ( ) & & hover over link offset==t . get offset ( ) & & ( t . be hyperlink ( ) || link generator result ! =null ) ) { return hyperlink f g ; } return get foreground for token type ( t . get type ( ) ) ; }
public int get mark occurrence delay ( ) { return mark occurrence delay ; }
public boolean get use select text color ( ) { return use select text color ; }
public boolean be whitespace visible ( ) { return whitespace visible ; }
public static synchronize boolean save template ( ) { if ( ! get template enable ( ) ) { return false ; } return get code template manager ( ) . save template ( ) ; }
public void set animate bracket matching ( boolean animate ) { if ( animate ! =animate bracket match ) { animate bracket match = animate ; if ( animate & & bracket repaint timer==null ) { bracket repaint timer = new bracket match timer ( ) ; } fire property change ( animate_bracket_matching_property , ! animate , animate ) ; } }
public void set highlight secondary language ( boolean highlight ) { if ( this . highlight secondary language ! =highlight ) { highlight secondary language = highlight ; repaint ( ) ; fire property change ( highlight_secondary_languages_property , ! highlight , highlight ) ; } }
public void set hyperlink foreground ( color fg ) { if ( fg==null ) { throw new null pointer exception ( `` fg can not be null `` ) ; } hyperlink f g = fg ; }
public action [ ] get action ( ) { return text action . augment list ( super . get action ( ) , r syntax text area editor kit . default action ) ; }
public int y for line containing ( int offs ) throw bad location exception { rectangle alloc = get visible editor rect ( ) ; if ( alloc ! =null ) { r s t a view view = ( r s t a view ) get root view ( text area ) . get view ( 0 ) ; return view . y for line containing ( alloc , offs ) ; } return -1 ; }
public void set after caret text ( string after caret ) { this . after caret = after caret==null ? empty_string : after caret ; first after newline = this . after caret . index of ( '\n ' ) ; }
public object get line separator ( ) { return get document ( ) . get property ( r text area editor kit . end of line string property ) ; }
public void remove update ( document event e ) { if ( ! dirty ) { set dirty ( true ) ; } }
protect void reset token list ( ) { first token = current token = previous token = null ; token factory . reset all token ( ) ; }
public boolean be local and exists ( ) { return false ; }
public void set max size ( int max size ) { if ( max size < =0 ) { throw new illegal argument exception ( `` maximum size must be > = 0 `` ) ; } this . max size = max size ; trim ( ) ; }
public color get fold icon background ( ) { return fold icon background ; }
public color get fold background ( ) { return fold indicator . get fold icon background ( ) ; }
public boolean get line number enable ( ) { for ( int i=0 ; i < get component count ( ) ; i++ ) { if ( get component ( i ) ==line number list ) { return true ; } } return false ; }
public boolean be fold indicator enable ( ) { for ( int i=0 ; i < get component count ( ) ; i++ ) { if ( get component ( i ) ==fold indicator ) { return true ; } } return false ; }
public void set border color ( color color ) { ( ( gutter border ) get border ( ) ) . set color ( color ) ; repaint ( ) ; }
public icon get large icon ( string name ) { return get icon impl ( path + large icon sub dir + `` / `` + name + `` . `` + extension ) ; }
public void set active line range ( int start line , int end line ) { if ( start line ! =active line range start || end line ! =active line range end ) { active line range start = start line ; active line range end = end line ; repaint ( ) ; } }
public void set text area ( r text area text area ) { remove all tracking icon ( ) ; super . set text area ( text area ) ; }
public int get end index ( ) { return end index ; }
public static final int get default margin line position ( ) { return default_margin_line_position ; }
public boolean get highlight current line ( ) { return highlight current line ; }
protect void paint line highlight ( graphic g ) { line highlight manager lhm = text area . get line highlight manager ( ) ; if ( lhm ! =null ) { lhm . paint line highlight ( g ) ; } }
public int y for line containing ( int offs ) throw bad location exception { rectangle r = model to view ( text area , offs ) ; return r ! =null ? r . y : -1 ; }
public string get cant redo text ( ) { return cant redo text ; }
public boolean get search forward ( ) { return forward ; }
public int compare to ( search result other ) { if ( other==null ) { return 1 ; } if ( other==this ) { return 0 ; } int diff = count - other . count ; if ( diff ! =0 ) { return diff ; } diff = mark count - other . marked count ; if ( diff ! =0 ) { return diff ; } if ( match range==null ) { return other . match range==null ? 0 : -1 ; } return match range . compare to ( other . match range ) ; }
public void set match range ( document range range ) { this . match range = range ; }
public void clear ( ) { size = 0 ; }
public void fill ( int value ) { array . fill ( data , value ) ; }
public boolean replace ( @ nullable disposable next ) { return disposable helper . replace ( resource , next ) ; }
public static void report subscription set ( ) { rx java plugins . on error ( new protocol violation exception ( `` subscription already set ! `` ) ) ; }
public static boolean set once ( atomic reference < subscription > field , subscription s ) { object helper . require non null ( s , `` s be null `` ) ; if ( ! field . compare and set ( null , s ) ) { s . cancel ( ) ; if ( field . get ( ) ! = cancel ) { report subscription set ( ) ; } return false ; } return true ; }
public static list < throwable > flatten ( throwable t ) { list < throwable > list = new array list < throwable > ( ) ; array deque < throwable > deque = new array deque < throwable > ( ) ; deque . offer ( t ) ; while ( ! deque . be empty ( ) ) { throwable e = deque . remove first ( ) ; if ( e instanceof composite exception ) { composite exception ce = ( composite exception ) e ; list < throwable > exception = ce . get exception ( ) ; for ( int i = exception . size ( ) - 1 ; i > = 0 ; i -- ) { deque . offer first ( exception . get ( i ) ) ; } } else { list . add ( e ) ; } } return list ; }
public static object disposable ( disposable d ) { return new disposable notification ( d ) ; }
public static void request ( subscription s , int prefetch ) { s . request ( prefetch < 0 ? long . max_value : prefetch ) ; }
public throwable get error ( ) { object o = value ; if ( notification lite . be error ( o ) ) { return notification lite . get error ( o ) ; } return null ; }
public final long completion ( ) { return completion ; }
public final u await ( ) throw interrupted exception { if ( do . get count ( ) == 0 ) { return ( u ) this ; } do . await ( ) ; return ( u ) this ; }
public final boolean await ( long time , time unit unit ) throw interrupted exception { boolean d = do . get count ( ) == 0 || ( do . await ( time , unit ) ) ; timeout = ! d ; return d ; }
public final u assert value set ( collection < ? extend t > expect ) { if ( expect . be empty ( ) ) { assert no value ( ) ; return ( u ) this ; } for ( t v : this . value ) { if ( ! expect . contains ( v ) ) { throw fail ( `` value not in the expected collection : `` + value and class ( v ) ) ; } } return ( u ) this ; }
public final u assert empty ( ) { return assert subscribe ( ) . assert no value ( ) . assert no error ( ) . assert not complete ( ) ; }
public t [ ] get value ( t [ ] array ) { t v = get value ( ) ; if ( v == null ) { if ( array . length ! = 0 ) { array [ 0 ] = null ; } return array ; } if ( array . length == 0 ) { array = array . copy of ( array , 1 ) ; } array [ 0 ] = v ; if ( array . length ! = 1 ) { array [ 1 ] = null ; } return array ; }
public static < t > replay processor < t > create with time and size ( long max age , time unit unit , scheduler scheduler , int max size ) { return new replay processor < t > ( new size and time bound replay buffer < t > ( max size , max age , unit , scheduler ) ) ; }
public void trigger action ( ) { trigger action ( time ) ; }
public static < t > maybe subject < t > create ( ) { return new maybe subject < t > ( ) ; }
public boolean have throwable ( ) { return observer . get ( ) == terminate & & error ! = null ; }
public final disposable subscribe ( ) { empty completable observer observer = new empty completable observer ( ) ; subscribe ( observer ) ; return observer ; }
public t get value ( ) { return subscriber . get ( ) == terminate ? value : null ; }
public object [ ] get value ( ) { t v = get value ( ) ; return v ! = null ? new object [ ] { v } : new object [ 0 ] ; }
public disposable schedule direct ( @ non null runnable run ) { return schedule direct ( run , 0l , time unit . nanosecond ) ; }
public void try terminate and report ( ) { throwable ex = terminate ( ) ; if ( ex ! = null & & ex ! = exception helper . terminate ) { rx java plugins . on error ( ex ) ; } }
public static int avalanche ( int h ) { h ^= h > > > 16 ; h * = 0x85ebca6b ; h ^= h > > > 13 ; h * = 0xc2b2ae35 ; h ^= h > > > 16 ; return h ; }
public static @ not null breadcrumb navigation ( final @ not null string from , final @ not null string to ) { final breadcrumb breadcrumb = new breadcrumb ( ) ; breadcrumb . set category ( `` navigation `` ) ; breadcrumb . set type ( `` navigation `` ) ; breadcrumb . set data ( `` from `` , from ) ; breadcrumb . set data ( `` to `` , to ) ; return breadcrumb ; }
public @ nullable string get message ( ) { return message ; }
public boolean add ( final @ not null e element ) { if ( null == element ) { throw new null pointer exception ( `` attempt to add null object to queue `` ) ; } if ( be at full capacity ( ) ) { remove ( ) ; } elements [ end++ ] = element ; if ( end > = max element ) { end = 0 ; } if ( end == start ) { full = true ; } return true ; }
public @ not null thread get thread ( ) { return thread ; }
public @ nullable string get type ( ) { return type ; }
public void set value ( final @ nullable string value ) { this . value = value ; }
public @ nullable string get module ( ) { return module ; }
public void set stacktrace ( final @ nullable sentry stack trace stacktrace ) { this . stacktrace = stacktrace ; }
public void set id ( final @ nullable long id ) { this . id = id ; }
public void set name ( final @ nullable string name ) { this . name = name ; }
public i transaction get transaction ( ) { return this . transaction ; }
public void clear attachment ( ) { attachment . clear ( ) ; }
public @ not null i serializer get serializer ( ) { return serializer ; }
public void set before send ( @ nullable before send callback before send ) { this . before send = before send ; }
public @ nullable string get cache dir path ( ) { return cache dir path ; }
public int get cache dir size ( ) { return max cache item ; }
public @ nullable proxy get proxy ( ) { return proxy ; }
public boolean be attach thread ( ) { return attach thread ; }
public boolean be attach server name ( ) { return attach server name ; }
public boolean be enable uncaught exception handler ( ) { return boolean . true . equal ( enable uncaught exception handler ) ; }
public @ nullable boolean get enable uncaught exception handler ( ) { return enable uncaught exception handler ; }
public int get max queue size ( ) { return max queue size ; }
public void set enable external configuration ( boolean enable external configuration ) { this . enable external configuration = enable external configuration ; }
public void set tag ( final @ not null string key , final @ not null string value ) { this . tag . put ( key , value ) ; }
public boolean be enable shutdown hook ( ) { return enable shutdown hook ; }
public @ not null session clone ( ) { return new session ( status , start , timestamp , error count . get ( ) , distinct id , session id , init , sequence , duration , ip address , user agent , environment , release ) ; }
public int get count ( ) { return sync . get count ( ) ; }
public void increment ( ) { sync . increment ( ) ; }
public static @ nullable string capitalize ( final @ nullable string str ) { if ( str == null || str . be empty ( ) ) { return str ; } return str . substring ( 0 , 1 ) . to upper case ( locale . root ) + str . substring ( 1 ) . to lower case ( locale . root ) ; }
public static boolean be hotspot ( ) { return system . get property ( `` java . vm . name `` , `` `` ) . to lower case ( ) . contains ( `` hotspot `` ) ; }
public static int get reference size ( ) { return current_jvm_information . get java pointer size ( ) ; }
public boolean contains ( string name ) { if ( name == null ) { throw new illegal argument exception ( `` other can not be null `` ) ; } if ( this . name . equal ( name ) ) { return true ; } if ( have reference ( ) ) { for ( int i = 0 ; i < referece list . size ( ) ; i++ ) { marker ref = ( marker ) referece list . get ( i ) ; if ( ref . contains ( name ) ) { return true ; } } } return false ; }
public static string get ( string key ) throw illegal argument exception { if ( key == null ) { throw new illegal argument exception ( `` key parameter can not be null `` ) ; } if ( mdc adapter == null ) { throw new illegal state exception ( `` m d c adapter can not be null . see also `` + null_mdca_url ) ; } return mdc adapter . get ( key ) ; }
final public static string basic array format ( final string message pattern , final object [ ] arg array ) { format tuple ft = array format ( message pattern , arg array , null ) ; return ft . get message ( ) ; }
static public void reset ( ) { logger factory . reset ( ) ; }
public void warn ( string format , object arg1 , object arg2 ) { format and log ( log_level_warn , format , arg1 , arg2 ) ; }
public static io . vertx . axle . core . buffer . buffer buffer ( string string , string enc ) { io . vertx . axle . core . buffer . buffer ret = io . vertx . axle . core . buffer . buffer . new instance ( io . vertx . core . buffer . buffer . buffer ( string , enc ) ) ; return ret ; }
public json object to json object ( ) { json object ret = delegate . to json object ( ) ; return ret ; }
public json array to json array ( ) { json array ret = delegate . to json array ( ) ; return ret ; }
public io . vertx . axle . core . buffer . buffer append unsigned short ( int s ) { delegate . append unsigned short ( s ) ; return this ; }
public io . vertx . axle . core . buffer . buffer set int ( int po , int i ) { delegate . set int ( po , i ) ; return this ; }
public io . vertx . axle . core . buffer . buffer set string ( int po , string str , string enc ) { delegate . set string ( pos , str , enc ) ; return this ; }
public io . vertx . axle . core . buffer . buffer append byte ( byte [ ] bytes ) { delegate . append byte ( byte ) ; return this ; }
public io . vertx . axle . core . cli . cli set summary ( string summary ) { delegate . set summary ( summary ) ; return this ; }
public io . vertx . axle . core . cli . cli remove argument ( int index ) { delegate . remove argument ( index ) ; return this ; }
public < t > t result at ( int index ) { t ret = ( t ) delegate . result at ( index ) ; return ret ; }
public string deployment i d ( ) { string ret = delegate . deployment i d ( ) ; return ret ; }
public boolean remove ( string key ) { boolean ret = delegate . remove ( key ) ; return ret ; }
public int priority ( ) { int ret = delegate . priority ( ) ; return ret ; }
public < t > completion stage < io . vertx . axle . core . eventbus . message < t > > request ( string address , object message , delivery option option ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __request ( address , message , option , handler ) ; } ) ; }
public io . vertx . axle . core . multi map header ( ) { io . vertx . axle . core . multi map ret = io . vertx . axle . core . multi map . new instance ( delegate . header ( ) ) ; return ret ; }
public long creation time ( ) { long ret = delegate . creation time ( ) ; return ret ; }
public completion stage < void > symlink ( string link , string exist ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __symlink ( link , exist , handler ) ; } ) ; }
public completion stage < void > write file ( string path , io . vertx . axle . core . buffer . buffer data ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __write file ( path , data , handler ) ; } ) ; }
public completion stage < string > create temp directory ( string prefix ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __create temp directory ( prefix , handler ) ; } ) ; }
public boolean try complete ( ) { boolean ret = delegate . try complete ( ) ; return ret ; }
public io . vertx . axle . core . http . cookie set max age ( long max age ) { delegate . set max age ( max age ) ; return this ; }
public io . vertx . axle . core . http . cookie set http only ( boolean http only ) { delegate . set http only ( http only ) ; return this ; }
public io . vertx . axle . core . http . cookie set same site ( cookie same site policy ) { delegate . set same site ( policy ) ; return this ; }
public io . vertx . axle . core . http . http client request get ( string host , string request u r i ) { io . vertx . axle . core . http . http client request ret = io . vertx . axle . core . http . http client request . new instance ( delegate . get ( host , request u r i ) ) ; return ret ; }
public io . vertx . axle . core . http . http client request post ( string request u r i ) { io . vertx . axle . core . http . http client request ret = io . vertx . axle . core . http . http client request . new instance ( delegate . post ( request u r i ) ) ; return ret ; }
public io . vertx . axle . core . http . http client request option ( string request u r i ) { io . vertx . axle . core . http . http client request ret = io . vertx . axle . core . http . http client request . new instance ( delegate . option ( request u r i ) ) ; return ret ; }
public io . vertx . axle . core . http . http client request delete ( int port , string host , string request u r i ) { io . vertx . axle . core . http . http client request ret = io . vertx . axle . core . http . http client request . new instance ( delegate . delete ( port , host , request u r i ) ) ; return ret ; }
public io . vertx . axle . core . http . http client request delete ( string host , string request u r i ) { io . vertx . axle . core . http . http client request ret = io . vertx . axle . core . http . http client request . new instance ( delegate . delete ( host , request u r i ) ) ; return ret ; }
public completion stage < io . vertx . axle . core . http . web socket > web socket ab ( string url , io . vertx . axle . core . multi map header , websocket version version , list < string > sub protocol ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __web socket ab ( url , header , version , sub protocol , handler ) ; } ) ; }
public io . vertx . axle . core . http . http connection set window size ( int window size ) { delegate . set window size ( window size ) ; return this ; }
public static io . vertx . axle . core . json . pointer . json pointer create ( ) { io . vertx . axle . core . json . pointer . json pointer ret = io . vertx . axle . core . json . pointer . json pointer . new instance ( io . vertx . core . json . pointer . json pointer . create ( ) ) ; return ret ; }
public completion stage < void > close ( ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __close ( handler ) ; } ) ; }
public static io . vertx . axle . core . net . self sign certificate create ( ) { io . vertx . axle . core . net . self sign certificate ret = io . vertx . axle . core . net . self sign certificate . new instance ( io . vertx . core . net . self sign certificate . create ( ) ) ; return ret ; }
public static io . vertx . axle . core . net . self sign certificate create ( string fqdn ) { io . vertx . axle . core . net . self sign certificate ret = io . vertx . axle . core . net . self sign certificate . new instance ( io . vertx . core . net . self sign certificate . create ( fqdn ) ) ; return ret ; }
public instant instant value ( ) { instant ret = delegate . instant value ( ) ; return ret ; }
public static io . vertx . axle . core . parsetools . record parser new fix ( int size ) { io . vertx . axle . core . parsetools . record parser ret = io . vertx . axle . core . parsetools . record parser . new instance ( io . vertx . core . parsetools . record parser . new fix ( size ) ) ; return ret ; }
public completion stage < long > get ( ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __get ( handler ) ; } ) ; }
public static < t > io . vertx . axle . core . stream . pump pump ( io . vertx . axle . core . stream . read stream < t > r , io . vertx . axle . core . stream . write stream < t > w ) { io . vertx . axle . core . stream . pump ret = io . vertx . axle . core . stream . pump . new instance ( io . vertx . core . stream . pump . pump ( r . get delegate ( ) , w . get delegate ( ) ) ) ; return ret ; }
public static io . vertx . axle . core . vertx vertx ( ) { io . vertx . axle . core . vertx ret = io . vertx . axle . core . vertx . new instance ( io . vertx . core . vertx . vertx ( ) ) ; return ret ; }
public io . vertx . axle . core . net . net server create net server ( ) { io . vertx . axle . core . net . net server ret = io . vertx . axle . core . net . net server . new instance ( delegate . create net server ( ) ) ; return ret ; }
public io . vertx . axle . core . http . http client create http client ( ) { io . vertx . axle . core . http . http client ret = io . vertx . axle . core . http . http client . new instance ( delegate . create http client ( ) ) ; return ret ; }
public io . vertx . axle . core . datagram . datagram socket create datagram socket ( ) { io . vertx . axle . core . datagram . datagram socket ret = io . vertx . axle . core . datagram . datagram socket . new instance ( delegate . create datagram socket ( ) ) ; return ret ; }
public set < string > get reference string ( ) { return reference string ; }
public static < t > consumer < t > discard consumer ( ) { return discard consumer . instance ; }
public void stop ( promise < void > stop promise ) throw exception { uni < void > uni = async stop ( ) ; if ( uni ! = null ) { uni . subscribe ( ) . with ( x - > stop promise . complete ( ) , stop promise : : fail ) ; } else { super . stop ( stop promise ) ; } }
public uni < long > get ( ) { return io . smallrye . mutiny . vertx . async result uni . to uni ( handler - > { __get ( handler ) ; } ) ; }
public type description add type description ( type description definition ) { if ( definition == null ) { throw new null pointer exception ( `` type description be require . `` ) ; } tag tag = definition . get tag ( ) ; type tag . put ( tag , definition . get type ( ) ) ; definition . set property utils ( get property utils ( ) ) ; return type definition . put ( definition . get type ( ) , definition ) ; }
public void set canonical ( boolean canonical ) { this . canonical = canonical ; }
protect string get argument ( ) { return `` `` ; }
public boolean equal ( object obj ) { if ( obj instanceof event ) { return to string ( ) . equal ( obj . to string ( ) ) ; } else { return false ; } }
public void set ( object object , object value ) throw exception { }
public event peek event ( ) { if ( current event == null ) { if ( state ! = null ) { current event = state . produce ( ) ; } } return current event ; }
public class < ? extend object > get list property type ( string property ) { if ( property . contains key ( property ) ) { class < ? > [ ] type argument = property . get ( property ) . get actual type argument ( ) ; if ( type argument ! = null & & type argument . length > 0 ) { return type argument [ 0 ] ; } } return null ; }
public < t > t load ( string yaml ) { return ( t ) load from reader ( new stream reader ( yaml ) , object . class ) ; }
public iterable < node > compose all ( reader yaml ) { final composer composer = new composer ( new parser impl ( new stream reader ( yaml ) ) , resolver , load config ) ; iterator < node > result = new iterator < node > ( ) { @ override public boolean have next ( ) { return composer . check node ( ) ; } @ override public node next ( ) { node node = composer . get node ( ) ; if ( node ! = null ) { return node ; } else { throw new no such element exception ( `` no node be available . `` ) ; } } @ override public void remove ( ) { throw new unsupported operation exception ( ) ; } } ; return new node iterable ( result ) ; }
public void add implicit resolver ( tag tag , pattern regexp , string first ) { resolver . add implicit resolver ( tag , regexp , first ) ; }
public void set indent with indicator ( boolean indent with indicator ) { this . indent with indicator = indent with indicator ; }
public boolean be empty ( ) { return comment line list . be empty ( ) ; }
public static void clean up ( ) { snappy loader . clean up extracted native lib ( ) ; snappy loader . set snappy api ( null ) ; }
public version version ( ) { return version ; }
public void provision project ( string project key , string project name ) { new http call ( `` /api/projects/create `` ) . set method ( http method . post ) . set admin credential ( ) . set param ( `` project `` , project key ) . set param ( `` name `` , project name ) . execute ( ) ; }
public http call set header ( string key , string value ) { require non null ( key , `` header key can not be null `` ) ; require non null ( value , `` header [ `` + key + `` ] can not have null value `` ) ; header . put ( key , value ) ; return this ; }
public void verify ( ) { check shadow ( ) ; check parent contract ( ) ; check parent consistency ( ) ; check modifier ( ) ; check assignment contract ( ) ; check contract ct scanner ( ) ; check bound and unbound type reference ( ) ; check model be tree ( ) ; check contract ct scanner ( ) ; check element be contain in attribute of it parent ( ) ; check element to path to element equivalence ( ) ; check role in parent ( ) ; check java identifier ( ) ; }
public fluent launcher output directory ( string path ) { launcher . set source output directory ( path ) ; return this ; }
public fluent launcher source class path ( string [ ] source classpath ) { launcher . get environment ( ) . set source classpath ( source classpath ) ; return this ; }
public pattern parameter configurator set container kind ( container kind container kind ) { current parameter . set container kind ( container kind ) ; return this ; }
public < t extend annotation > ct type < t > get annotation type ( string qualify name ) { return get ( qualified name ) ; }
public ct text block create text block ( string value ) { ct text block textblock = factory . core ( ) . create text block ( ) ; textblock . set value ( value ) ; textblock . set type ( ( ct type reference < string > ) factory . type ( ) . string ) ; return textblock ; }
public < t > ct catch variable reference < t > create catch variable reference ( ct catch variable < t > catch variable ) { return factory . core ( ) . < t > create catch variable reference ( ) . set type ( catch variable . get type ( ) ) . < ct catch variable reference < t > > set simple name ( catch variable . get simple name ( ) ) ; }
public set < modifier kind > modifier ( modifier kind . . . modifier ) { set < modifier kind > ret = enum set . none of ( modifier kind . class ) ; collection . add all ( ret , modifier ) ; return ret ; }
public ct comment create inline comment ( string content ) { if ( content . contains ( ct comment . line_separator ) ) { throw new spoon exception ( `` the content of your comment contain at least one line separator . `` + `` please consider use a block comment by call create comment ( \ `` your content\ `` , ct comment . comment type . block ) . `` ) ; } return create comment ( content , ct comment . comment type . inline ) ; }
public compilation unit get or create ( string file path ) { compilation unit cu = cache compilation unit . get ( file path ) ; if ( cu ! = null ) { return cu ; } return _create ( file path ) ; }
public < t > ct executable reference < t > create reference ( ct constructor < t > c ) { return factory . executable ( ) . create reference ( c ) ; }
public < t extend enum < ? > > ct enum < t > get enum ( class < t > cl ) { try { ct type < t > t = super . get ( cl ) ; return ( ct enum < t > ) t ; } catch ( exception e ) { return null ; } }
public eval factory eval ( ) { if ( eval == null ) { eval = new eval factory ( this ) ; } return eval ; }
public ct type reference < double > double type ( ) { return double . clone ( ) ; }
public ct type reference < short > short type ( ) { return short . clone ( ) ; }
public ct type reference < date > date type ( ) { return date . clone ( ) ; }
public list < ct type < ? > > get all ( boolean include nested type ) { if ( ! include nested type ) { return get all ( ) ; } list < ct type < ? > > type = new array list < > ( ) ; for ( ct package pack : factory . package ( ) . get all ( ) ) { for ( ct type < ? > type : pack . get type ( ) ) { add nest type ( type , type ) ; } } return type ; }
protect string get declare type name ( string qualify name ) { return qualify name . substring ( 0 , have inner type ( qualified name ) ) ; }
public list < ct type reference < ? > > create reference ( list < class < ? > > class ) { list < ct type reference < ? > > refs = new array list < > ( class . size ( ) ) ; for ( class < ? > c : class ) { ref . add ( create reference ( c ) ) ; } return ref ; }
public string get camel case name ( ) { string s = name ( ) . to lower case ( ) ; string [ ] tokens = s . split ( `` _ `` ) ; if ( token . length == 1 ) { return s ; } else { string builder buffer = new string builder ( tokens [ 0 ] ) ; for ( int i = 1 ; i < token . length ; i++ ) { string t = tokens [ i ] ; buffer . append ( character . to upper case ( t . char at ( 0 ) ) ) ; buffer . append ( t . substring ( 1 ) ) ; } return buffer . to string ( ) ; } }
public ct query impl add input ( object . . . input ) { if ( this . input == null ) { this . input = new array list < > ( ) ; } if ( input ! = null ) { collection . add all ( this . input , input ) ; } return this ; }
public void scan ct name element ( ct name element e ) { }
public void scan ct reference ( ct reference reference ) { }
protect void enter ( ct element e ) { }
public void scan ( object o ) { scan ( null , o ) ; }
public static boolean be legal java package identifier ( string string ) { if ( string == null ) { return false ; } string tokenizer st = new string tokenizer ( string , `` . `` ) ; while ( st . have more element ( ) ) { string s = st . next token ( ) ; if ( ! be legal java identifier ( s ) ) { return false ; } } return true ; }
public void print separator if appropriate ( ) { if ( be first ) { / * * we be start first item . do not print ` separator ` separator yet * / be first = false ; } else { / * * we be start separator item . print ` separator ` separator now * / if ( next prefix space ) { printer token writer . write space ( ) ; } if ( separator ! = null & & ! separator . be empty ( ) ) { printer token writer . write separator ( separator ) ; } if ( next suffix space ) { printer token writer . write space ( ) ; } } }
public void enter ( ct element element ) { if ( ! stack . be empty ( ) ) { if ( ! element . be parent initialized ( ) || element . get parent ( ) ! = stack . peek ( ) ) { if ( ( ! element . be parent initialized ( ) & & fix null parent ) || ( element . get parent ( ) ! = stack . peek ( ) & & fix inconsistency ) ) { element . set parent ( stack . peek ( ) ) ; } else { final string name = element instanceof ct name element ? `` - `` + ( ( ct name element ) element ) . get simple name ( ) : `` `` ; environment . report ( null , level . warn , ( element . be parent initialized ( ) ? `` inconsistent `` : `` null `` ) + `` parent for `` + element . get class ( ) + name + `` - `` + element . get position ( ) + `` - `` + stack . peek ( ) . get position ( ) ) ; dump stack ( ) ; } } } stack . push ( element ) ; }
public static < e extend ct element > list < e > get element ( factory factory , filter < e > filter ) { return get element ( factory . package ( ) . get root package ( ) , filter ) ; }
public void initialize compiler ( j d t batch compiler compiler ) { j d t base spoon compiler jdt compiler = compiler . get jdt compiler ( ) ; list < compilation unit > unit list = new array list < > ( ) ; for ( ct type < ? > ct type : jdt compiler . get factory ( ) . type ( ) . get all ( ) ) { if ( ct type . be top level ( ) ) { unit list . add ( new compilation unit wrapper ( ct type ) ) ; } } compiler . set compilation unit ( unit list . to array ( new compilation unit [ 0 ] ) ) ; }
public < t > ct field access < t > create field access ( ct variable reference < t > variable reference , ct expression < ? > target , boolean be read access ) { ct field access < t > field access ; if ( be read access ) { field access = jdt tree builder . get factory ( ) . core ( ) . create field write ( ) ; } else { field access = jdt tree builder . get factory ( ) . core ( ) . create field read ( ) ; } field access . set variable ( variable reference ) ; field access . set target ( target ) ; return field access ; }
public t get new value ( ) { return new value ; }
public boolean be sub signature ( ct method < ? > this method , ct method < ? > that method ) { return be same signature ( this method , that method , true ) ; }
public static string get record component name ( annotated element component ) { try { return ( string ) lookup record component name . invoke ( component ) ; } catch ( throwable e ) { return null ; } }
public < t > void visit ct method ( ct method < t > m ) { write ( m . get simple name ( ) ) ; write ( `` ( `` ) ; for ( ct parameter < ? > p : m . get parameter ( ) ) { scan ( p . get type ( ) ) ; write ( `` , `` ) ; } if ( ! m . get parameter ( ) . be empty ( ) ) { clear last ( ) ; } write ( `` ) `` ) ; }
public static < t > ct field < t > insert field ( ct type < ? > target type , template < ? > template , ct field < t > source field ) { ct field < t > field = substitute ( target type , template , source field ) ; target type . add field ( field ) ; return field ; }
public static void redirect type reference ( ct element element , ct type reference < ? > source , ct type reference < ? > target ) { list < ct type reference < ? > > refs = query . get reference ( element , new reference type filter < > ( ct type reference . class ) ) ; string src name = source . get qualified name ( ) ; string target name = target . get simple name ( ) ; ct package reference target package = target . get package ( ) ; for ( ct type reference < ? > ref : ref ) { if ( ref . get qualified name ( ) . equal ( src name ) ) { ref . set simple name ( target name ) ; ref . set package ( target package ) ; } } }
public static < t > t assert not null ( string msg , t reference ) { if ( reference == null ) { throw new assertion error ( msg ) ; } return reference ; }
public static < t extend ct type < ? > > t build ( string package name , string class name , final factory f ) throw exception { launcher launcher = new launcher ( ) { @ override public factory create factory ( ) { return f ; } } ; spoon model builder comp = launcher . create compiler ( ) ; comp . add input source ( spoon resource helper . resource ( `` . /src/test/java/ `` + package name . replace ( ' . ' , '/ ' ) + `` / `` + class name + `` . java `` ) ) ; comp . build ( ) ; return comp . get factory ( ) . package ( ) . get ( package name ) . get type ( class name ) ; }
protect boolean be eligible aspect bean ( string bean name ) { if ( this . include pattern == null ) { return true ; } else { for ( pattern pattern : this . include pattern ) { if ( pattern . matcher ( bean name ) . match ( ) ) { return true ; } } return false ; } }
public < t > t get proxy ( ) { return ( t ) create aop proxy ( ) . get proxy ( ) ; }
protect int get order for aspect class ( class < ? > aspect class ) { return order . lowest_precedence ; }
public void set type pattern ( string type pattern ) { assert . not null ( type pattern ) ; this . type pattern = type pattern ; this . aspect j type pattern matcher = pointcut parser . get pointcut parser support all primitive and use context classloader for resolution ( ) . parse type pattern ( replace boolean operator ( type pattern ) ) ; }
public void set before exist advisor ( boolean before exist advisor ) { this . before exist advisor = before exist advisor ; }
public static object current proxy ( ) throw illegal state exception { object proxy = current proxy . get ( ) ; if ( proxy == null ) { throw new illegal state exception ( `` can not find current proxy : set 'expose proxy ' property on advise to 'true ' to make it available . `` ) ; } return proxy ; }
public static boolean equal advisor ( advised support a , advised support b ) { return array . equal ( a . get advisor ( ) , b . get advisor ( ) ) ; }
protected list < advisor > find candidate advisor ( ) { return this . advisor retrieval helper . find advisor bean ( ) ; }
public void set interceptor name ( string . . . interceptor names ) { this . interceptor name = interceptor name ; }
protect boolean be infrastructure class ( class < ? > bean class ) { boolean ret val = advice . class . be assignable from ( bean class ) || advisor . class . be assignable from ( bean class ) || aop infrastructure bean . class . be assignable from ( bean class ) ; if ( ret val & & logger . be trace enable ( ) ) { logger . trace ( `` do not attempt to auto-proxy infrastructure class [ `` + bean class . get name ( ) + `` ] `` ) ; } return ret val ; }
public static boolean should proxy target class ( configurable listable bean factory bean factory , string bean name ) { if ( bean name ! = null & & bean factory . contains bean definition ( bean name ) ) { bean definition bd = bean factory . get bean definition ( bean name ) ; return boolean . true . equal ( bd . get attribute ( preserve_target_class_attribute ) ) ; } return false ; }
public void set use prefix ( boolean use prefix ) { this . use prefix = use prefix ; }
protect boolean be eligible advisor bean ( string bean name ) { return ( ! be use prefix ( ) || bean name . start with ( get advisor bean name prefix ( ) ) ) ; }
public void set proxy target class ( boolean proxy target class ) { this . proxy target class = proxy target class ; }
public void copy from ( proxy config other ) { assert . not null ( other , `` other proxy config object must not be null `` ) ; this . proxy target class = other . proxy target class ; this . optimize = other . optimize ; this . expose proxy = other . expose proxy ; this . frozen = other . frozen ; this . opaque = other . opaque ; }
protect void advice change ( ) { super . advice change ( ) ; synchronize ( this ) { if ( this . active ) { for ( advised support listener listener : this . listener ) { listener . advice change ( this ) ; } } } }
protect object get proxy ( aop proxy aop proxy ) { return aop proxy . get proxy ( this . proxy class loader ) ; }
protect boolean be configuration callback interface ( class < ? > ifc ) { return ( initialize bean . class == ifc || disposable bean . class == ifc || object utils . contains element ( ifc . get interface ( ) , aware . class ) ) ; }
public static method invocation current invocation ( ) throw illegal state exception { method invocation mi = invocation . get ( ) ; if ( mi == null ) throw new illegal state exception ( `` no method invocation find : check that an aop invocation be in progress , and that the `` + `` expose invocation interceptor be upfront in the interceptor chain . specifically , note that `` + `` advice with order highest_precedence will execute before expose invocation interceptor ! `` ) ; return mi ; }
public void set pattern ( string . . . pattern ) { assert . not empty ( pattern , `` 'patterns ' must not be empty `` ) ; this . pattern = new string [ pattern . length ] ; for ( int i = 0 ; i < pattern . length ; i++ ) { this . pattern [ i ] = string utils . trim whitespace ( patterns [ i ] ) ; } init pattern representation ( this . pattern ) ; }
public static class < ? > get target class ( object candidate ) { assert . not null ( candidate , `` candidate object must not be null `` ) ; class < ? > result = null ; if ( candidate instanceof target class aware ) { result = ( ( target class aware ) candidate ) . get target class ( ) ; } if ( result == null ) { result = ( be cglib proxy ( candidate ) ? candidate . get class ( ) . get superclass ( ) : candidate . get class ( ) ) ; } return result ; }
public static boolean be equal method ( method method ) { return reflection utils . be equals method ( method ) ; }
public static class filter union ( class filter cf1 , class filter cf2 ) { assert . not null ( cf1 , `` first class filter must not be null `` ) ; assert . not null ( cf2 , `` second class filter must not be null `` ) ; return new union class filter ( new class filter [ ] { cf1 , cf2 } ) ; }
public void suppress interface ( class < ? > intf ) { this . publish interface . remove ( intf ) ; }
public string get target bean name ( ) { return this . target bean name ; }
public void set target class ( class < ? > target class ) { this . target class = target class ; }
public void set bean factory ( bean factory bean factory ) { if ( this . target bean name == null ) { throw new illegal state exception ( `` property 'target bean name ' be require `` ) ; } this . bean factory = bean factory ; }
public synchronize object get target ( ) throw exception { if ( this . lazy target == null ) { logger . debug ( `` initialize lazy target object `` ) ; this . lazy target = create object ( ) ; } return this . lazy target ; }
public int get max size ( ) { return this . max size ; }
public int get min idle ( ) { return this . min idle ; }
public long get time between eviction run millis ( ) { return this . time between eviction run millis ; }
public void set when exhausted action name ( string when exhaust action name ) { set when exhausted action ( constant . a number ( when exhaust action name ) . byte value ( ) ) ; }
protect boolean require refresh ( ) { return true ; }
public object get target ( ) throw bean exception { return new prototype instance ( ) ; }
public int get handler method count ( ) { return this . exception handler map . size ( ) ; }
public static string get target bean name ( string original bean name ) { return target_name_prefix + original bean name ; }
public bean metadata attribute get metadata attribute ( string name ) { return ( bean metadata attribute ) super . get attribute ( name ) ; }
public static method find declared method ( class < ? > clazz , string method name , class < ? > . . . param type ) { try { return clazz . get declared method ( method name , param type ) ; } catch ( no such method exception ex ) { if ( clazz . get superclass ( ) ! = null ) { return find declared method ( clazz . get superclass ( ) , method name , param type ) ; } return null ; } }
public void set require annotation type ( class < ? extend annotation > require annotation type ) { assert . not null ( required annotation type , `` 'required annotation type ' must not be null `` ) ; this . require annotation type = require annotation type ; }
public static boolean be factory dereference ( string name ) { return ( name ! = null & & name . start with ( bean factory . factory_bean_prefix ) ) ; }
public static string original bean name ( string name ) { assert . not null ( name , `` 'name ' must not be null `` ) ; int separator index = name . index of ( generated_bean_name_separator ) ; return ( separator index ! = -1 ? name . substring ( 0 , separator index ) : name ) ; }
public static < t > t bean of type ( listable bean factory lbf , class < t > type ) throw bean exception { assert . not null ( lbf , `` listable bean factory must not be null `` ) ; map < string , t > bean of type = lbf . get bean of type ( type ) ; return unique bean ( type , bean of type ) ; }
public value holder get indexed argument value ( int index , class < ? > require type ) { return get indexed argument value ( index , require type , null ) ; }
public value holder get generic argument value ( class < ? > require type , string require name , set < value holder > use value holder ) { for ( value holder value holder : this . generic argument value ) { if ( use value holder ! = null & & use value holder . contains ( value holder ) ) { continue ; } if ( value holder . get name ( ) ! = null & & ( require name == null || ! value holder . get name ( ) . equal ( require name ) ) ) { continue ; } if ( value holder . get type ( ) ! = null & & ( require type == null || ! class utils . match type name ( require type , value holder . get type ( ) ) ) ) { continue ; } if ( require type ! = null & & value holder . get type ( ) == null & & value holder . get name ( ) == null & & ! class utils . be assignable value ( require type , value holder . get value ( ) ) ) { continue ; } return value holder ; } return null ; }
public resolvable type get resolvable type ( ) { return ( this . field ! = null ? resolvable type . for field ( this . field , this . nest level , this . contain class ) : resolvable type . for method parameter ( this . method parameter ) ) ; }
public void set target list class ( class < ? extend list > target list class ) { if ( target list class == null ) { throw new illegal argument exception ( `` 'target list class ' must not be null `` ) ; } if ( ! list . class . be assignable from ( target list class ) ) { throw new illegal argument exception ( `` 'target list class ' must implement [ java . util . list ] `` ) ; } this . target list class = target list class ; }
public boolean have property override for ( string bean name ) { return this . bean name . contains ( bean name ) ; }
public void set target object ( object target object ) { this . target bean wrapper = property accessor factory . for bean property access ( target object ) ; }
public void set system property mode name ( string constant name ) throw illegal argument exception { this . system property mode = constant . a number ( constant name ) . int value ( ) ; }
public void set target type ( class < ? > target type ) { assert . not null ( target type , `` 'target type ' must not be null `` ) ; this . target type = target type ; }
public void set document matcher ( document matcher . . . matcher ) { this . document matcher = arrays . a list ( matcher ) ; }
public void set resolution method ( resolution method resolution method ) { assert . not null ( resolution method , `` resolution method must not be null `` ) ; this . resolution method = resolution method ; }
protect property create property ( ) { final property result = new property ( ) ; process ( new match callback ( ) { @ override public void process ( property property , map < string , object > map ) { result . put all ( property ) ; } } ) ; return result ; }
public string to string ( ) { return get description ( ) ; }
public boolean equal ( object other ) { return ( this == other || ( other instanceof bean component definition & & super . equal ( other ) ) ) ; }
protect object get early bean reference ( string bean name , root bean definition mbd , object bean ) { object expose object = bean ; if ( bean ! = null & & ! mbd . be synthetic ( ) & & have instantiation aware bean post processor ( ) ) { for ( bean post processor bp : get bean post processor ( ) ) { if ( bp instanceof smart instantiation aware bean post processor ) { smart instantiation aware bean post processor ibp = ( smart instantiation aware bean post processor ) bp ; expose object = ibp . get early bean reference ( expose object , bean name ) ; if ( expose object == null ) { return expose object ; } } } } return exposed object ; }
public void apply default ( bean definition default default ) { set lazy init ( default . be lazy init ( ) ) ; set autowire mode ( default . get autowire mode ( ) ) ; set dependency check ( default . get dependency check ( ) ) ; set init method name ( default . get init method name ( ) ) ; set enforce init method ( false ) ; set destroy method name ( default . get destroy method name ( ) ) ; set enforce destroy method ( false ) ; }
public class < ? > resolve bean class ( class loader class loader ) throw class not find exception { string class name = get bean class name ( ) ; if ( class name == null ) { return null ; } class < ? > resolve class = class utils . for name ( class name , class loader ) ; this . bean class = resolve class ; return resolve class ; }
public boolean have constructor argument value ( ) { return ! this . constructor argument value . be empty ( ) ; }
public void set enforce init method ( boolean enforce init method ) { this . enforce init method = enforce init method ; }
public boolean be synthetic ( ) { return this . synthetic ; }
public void set resource ( resource resource ) { this . resource = resource ; }
public void set originate bean definition ( bean definition originate bd ) { this . resource = new bean definition resource ( originate bd ) ; }
public static object resolve autowiring value ( object autowiring value , class < ? > require type ) { if ( autowiring value instanceof object factory & & ! require type . be instance ( autowiring value ) ) { object factory < ? > factory = ( object factory < ? > ) autowiring value ; if ( autowiring value instanceof serializable & & require type . be interface ( ) ) { autowiring value = proxy . new proxy instance ( require type . get class loader ( ) , new class < ? > [ ] { require type } , new object factory delegate invocation handler ( factory ) ) ; } else { return factory . get object ( ) ; } } return autowiring value ; }
public bean definition builder add property value ( string name , object value ) { this . bean definition . get property value ( ) . add ( name , value ) ; return this ; }
public bean definition builder set dependency check ( int dependency check ) { bean definition . set dependency check ( dependency check ) ; return this ; }
public bean definition builder add depends on ( string bean name ) { if ( this . bean definition . get depend on ( ) == null ) { this . bean definition . set depends on ( bean name ) ; } else { string [ ] add = object utils . add object to array ( this . bean definition . get depend on ( ) , bean name ) ; this . bean definition . set depends on ( add ) ; } return this ; }
public int hash code ( ) { return this . bean definition . hash code ( ) ; }
protect void add singleton factory ( string bean name , object factory < ? > singleton factory ) { assert . not null ( singleton factory , `` singleton factory must not be null `` ) ; synchronize ( this . singleton object ) { if ( ! this . singleton object . contains key ( bean name ) ) { this . singleton factory . put ( bean name , singleton factory ) ; this . early singleton object . remove ( bean name ) ; this . registered singleton . add ( bean name ) ; } } }
public string get element type name ( ) { return this . element type name ; }
public void set merge enable ( boolean merge enable ) { this . merge enable = merge enable ; }
public void add override ( method override other ) { if ( other ! = null ) { this . override . add all ( other . get override ( ) ) ; } }
public int load bean definition ( resource resource , string prefix ) throw bean definition store exception { return load bean definition ( new encode resource ( resource ) , prefix ) ; }
public int register bean definition ( resource bundle rb ) throw bean definition store exception { return register bean definition ( rb , null ) ; }
public boolean get dependency check ( ) { return this . dependency check ; }
protect void post process ( bean definition builder bean definition , element element ) { }
public bean definition default get bean definition default ( ) { bean definition default bdd = new bean definition default ( ) ; bdd . set lazy init ( `` true `` . equal ignore case ( this . default . get lazy init ( ) ) ) ; bdd . set dependency check ( this . get dependency check ( default_value ) ) ; bdd . set autowire mode ( this . get autowire mode ( default_value ) ) ; bdd . set init method name ( this . default . get init method ( ) ) ; bdd . set destroy method name ( this . default . get destroy method ( ) ) ; return bdd ; }
public string get autowire candidate ( ) { return this . autowire candidate ; }
public void set init method ( string init method ) { this . init method = init method ; }
public void set property value at ( property value pv , int i ) { this . property value list . set ( i , pv ) ; }
public string get property name ( ) { return ( this . property change event ! = null ? this . property change event . get property name ( ) : null ) ; }
public conversion service get conversion service ( ) { return this . conversion service ; }
public void override default editor ( class < ? > require type , property editor property editor ) { if ( this . overridden default editor == null ) { this . overridden default editor = new hash map < class < ? > , property editor > ( ) ; } this . overridden default editor . put ( require type , property editor ) ; }
public void previous page ( ) { if ( ! be first page ( ) ) { this . page -- ; } }
public int get first link page ( ) { return math . max ( 0 , get page ( ) - ( get max link page ( ) / 2 ) ) ; }
public static void sort ( object [ ] source , sort definition sort definition ) throw bean exception { if ( string utils . have text ( sort definition . get property ( ) ) ) { array . sort ( source , new property comparator < object > ( sort definition ) ) ; } }
public void set require parameter name ( string require parameter name ) { this . require parameter name = require parameter name ; }
public boolean have qualifier ( dependency descriptor descriptor ) { for ( annotation ann : descriptor . get annotation ( ) ) { if ( be qualifier ( ann . annotation type ( ) ) ) { return true ; } } return false ; }
protect final method parameter obtain method parameter ( ) { assert . state ( this . method parameter ! = null , `` neither field nor method parameter `` ) ; return this . method parameter ; }
public annotate element get annotate element ( ) { return ( this . field ! = null ? this . field : obtain method parameter ( ) . get annotated element ( ) ) ; }
protect int detect validation mode ( resource resource ) { if ( resource . be open ( ) ) { throw new bean definition store exception ( `` passed-in resource [ `` + resource + `` ] contain an open stream : `` + `` can not determine validation mode automatically . either pas in a resource `` + `` that be able to create fresh stream , or explicitly specify the validation mode `` + `` on your xml bean definition reader instance . `` ) ; } input stream input stream ; try { input stream = resource . get input stream ( ) ; } catch ( i o exception ex ) { throw new bean definition store exception ( `` unable to determine validation mode for [ `` + resource + `` ] : can not open input stream . `` + `` do you attempt to load directly from a sax input source without specify the `` + `` validation mode on your xml bean definition reader instance ? `` , ex ) ; } try { return this . validation mode detector . detect validation mode ( input stream ) ; } catch ( i o exception ex ) { throw new bean definition store exception ( `` unable to determine validation mode for [ `` + resource + `` ] : an error occur whilst reading from the input stream . `` , ex ) ; } }
public string generate bean name ( bean definition bean definition ) { return this . reader . get bean name generator ( ) . generate bean name ( bean definition , get registry ( ) ) ; }
public synchronize void set convert value ( @ nullable object value ) { this . convert = true ; this . convert value = value ; }
public boolean be allow raw injection despite wrap ( ) { return this . allow raw injection despite wrap ; }
public spring application builder lazy initialization ( boolean lazy initialization ) { this . application . set lazy initialization ( lazy initialization ) ; return this ; }
protect configuration merge ( configuration other ) { set < class < ? > > merge class = new link hash set < > ( get class ( ) ) ; merge class . add all ( other . get class ( ) ) ; return merge ( merge class ) ; }
public configuration property name get name ( ) { return this . name ; }
public configuration property get annotation ( ) { return this . bean . get annotation ( ) ; }
public duration parse ( string value ) { return parse ( value , null ) ; }
public period parse ( string value ) { return parse ( value , null ) ; }
public void set force shutdown on vm exit ( boolean force shutdown on vm exit ) { this . force shutdown on vm exit = force shutdown on vm exit ; }
public void set thread two phase commit ( boolean thread two phase commit ) { this . thread two phase commit = thread two phase commit ; }
public environment get environment ( ) { return this . environment ; }
public void clean up ( ) { }
public location get location ( ) { return this . location ; }
public file get dir ( ) { return this . dir ; }
public file get dir ( string sub dir ) { file dir = new file ( get dir ( ) , sub dir ) ; dir . mkdirs ( ) ; return dir ; }
protect void configure ssl ( ssl context factory . server factory , ssl ssl , ssl store provider ssl store provider ) { factory . set protocol ( ssl . get protocol ( ) ) ; configure ssl client auth ( factory , ssl ) ; configure ssl password ( factory , ssl ) ; factory . set cert alias ( ssl . get key alias ( ) ) ; if ( ! object utils . be empty ( ssl . get cipher ( ) ) ) { factory . set include cipher suite ( ssl . get cipher ( ) ) ; factory . set exclude cipher suite ( ) ; } if ( ssl . get enabled protocol ( ) ! = null ) { factory . set include protocol ( ssl . get enabled protocol ( ) ) ; } if ( ssl store provider ! = null ) { try { factory . set key store ( ssl store provider . get key store ( ) ) ; factory . set trust store ( ssl store provider . get trust store ( ) ) ; } catch ( exception ex ) { throw new illegal state exception ( `` unable to set ssl store `` , ex ) ; } } else { configure ssl key store ( factory , ssl ) ; configure ssl trust store ( factory , ssl ) ; } }
public boolean be eager init filter ( ) { return this . eager init filter ; }
public string add ( string extension , string mime type ) { map previous = this . map . put ( extension , new mapping ( extension , mime type ) ) ; return ( previous ! = null ) ? previous . get mime type ( ) : null ; }
public boolean be enable ( ) { return this . enable ; }
public string get key store type ( ) { return this . key store type ; }
public string get key store provider ( ) { return this . key store provider ; }
protect string get description ( http servlet request request ) { string path info = ( request . get path info ( ) ! = null ) ? request . get path info ( ) : `` `` ; return `` [ `` + request . get servlet path ( ) + path info + `` ] `` ; }
public web service template builder set check connection for error ( boolean check connection for error ) { return new web service template builder ( this . detect http message sender , this . interceptor , append ( this . internal customizers , new check connection for error customizer ( check connection for error ) ) , this . customizers , this . message sender , this . marshaller , this . unmarshaller , this . destination provider , this . transformer factory class , this . message factory ) ; }
public static boolean be embed ( string driver class , string url ) { if ( driver class == null ) { return false ; } embed database connection connection = get embed database connection ( driver class ) ; if ( connection == none ) { return false ; } return ( url == null || connection . be embed url ( url ) ) ; }
public void set preserve path on forward ( boolean preserve path on forward ) { this . preserve path on forward = preserve path on forward ; }
public data source builder < t > driver class name ( string driver class name ) { set ( data source property . driver_class_name , driver class name ) ; return this ; }
public string determine username ( ) { if ( collection utils . be empty ( this . parsed address ) ) { return this . username ; } address address = this . parsed address . get ( 0 ) ; return ( address . username ! = null ) ? address . username : this . username ; }
public set < string > get exclusion ( ) { return this . exclusion ; }
protected class < ? > get annotation class ( ) { return enable auto configuration . class ; }
public void record condition evaluation ( string source , condition condition , condition outcome outcome ) { assert . not null ( source , `` source must not be null `` ) ; assert . not null ( condition , `` condition must not be null `` ) ; assert . not null ( outcome , `` outcome must not be null `` ) ; this . unconditional class . remove ( source ) ; if ( ! this . outcome . contains key ( source ) ) { this . outcome . put ( source , new condition and outcome ( ) ) ; } this . outcome . get ( source ) . add ( condition , outcome ) ; this . add ancestor outcome = false ; }
public condition evaluation report get parent ( ) { return this . parent ; }
protect final boolean match ( condition context context , annotate type metadata metadata , condition condition ) { if ( condition instanceof spring boot condition ) { return ( ( spring boot condition ) condition ) . get match outcome ( context , metadata ) . be match ( ) ; } return condition . match ( context , metadata ) ; }
public string determine database name ( ) { if ( this . generate unique name ) { if ( this . unique name == null ) { this . unique name = uuid . random u u i d ( ) . to string ( ) ; } return this . unique name ; } if ( string utils . have length ( this . name ) ) { return this . name ; } if ( this . embedded database connection ! = embed database connection . none ) { return `` testdb `` ; } return null ; }
public string determine password ( ) { if ( string utils . have text ( this . password ) ) { return this . password ; } if ( embedded database connection . be embed ( determine driver class name ( ) ) ) { return `` `` ; } return null ; }
public template availability provider get provider ( string view , application context application context ) { assert . not null ( application context , `` application context must not be null `` ) ; return get provider ( view , application context . get environment ( ) , application context . get class loader ( ) , application context ) ; }
public void set order ( int order ) { this . order = order ; }
public void trigger reload ( ) { if ( this . server ! = null ) { this . server . trigger reload ( ) ; } }
public void stop ( ) throw i o exception { synchronize ( this . monitor ) { if ( this . listen thread ! = null ) { close all connection ( ) ; try { this . executor . shutdown ( ) ; this . executor . await termination ( 1 , time unit . minute ) ; } catch ( interrupted exception ex ) { thread . current thread ( ) . interrupt ( ) ; } this . server socket . close ( ) ; try { this . listen thread . join ( ) ; } catch ( interrupted exception ex ) { thread . current thread ( ) . interrupt ( ) ; } this . listen thread = null ; this . server socket = null ; } } }
public void trigger reload ( ) { synchronize ( this . monitor ) { synchronize ( this . connection ) { for ( connection connection : this . connection ) { try { connection . trigger reload ( ) ; } catch ( exception ex ) { logger . debug ( `` unable to send reload message `` , ex ) ; } } } } }
public static void clear instance ( ) { synchronize ( instance_monitor ) { instance = null ; } }
public void write entry ( jar file jar file ) throw i o exception { write entry ( jar file , entry transformer . none , unpack handler . never , ( entry ) - > null ) ; }
public string get group id ( ) { return this . group id ; }
public boolean be unpack require ( ) { return this . unpack require ; }
public void set main class ( string main class ) { this . main class = main class ; }
public application context assert < c > have bean ( string name ) { if ( this . startup failure ! = null ) { throw assertion error ( context fail to start when expecting ( `` to have bean name : % n < % s > `` , name ) ) ; } if ( find bean ( name ) == null ) { throw assertion error ( new basic error message factory ( `` % n expecting : % n < % s > % nto have bean name : % n < % s > % nbut find no such bean `` , get application context ( ) , name ) ) ; } return this ; }
public t parse object ( byte [ ] json byte ) throw i o exception { verify ( ) ; return parse ( json byte ) . get object ( ) ; }
public t read object ( reader reader ) throw i o exception { verify ( ) ; return read ( reader ) . get object ( ) ; }
protect t read object ( input stream input stream , resolvable type type ) throw i o exception { buffered reader reader = new buffer reader ( new input stream reader ( input stream ) ) ; return read object ( reader , type ) ; }
public json content assert be equal to json ( string path , class < ? > resource load class , j s o n compare mode compare mode ) { string expect json = this . loader . get json ( path , resource load class ) ; return assert not fail ( compare ( expect json , compare mode ) ) ; }
public json content assert be not equal to json ( byte [ ] expect , j s o n compare mode compare mode ) { string expect json = this . loader . get json ( expect ) ; return assert not pass ( compare ( expect json , compare mode ) ) ; }
public json content assert be not equal to json ( file expect , j s o n compare mode compare mode ) { string expect json = this . loader . get json ( expect ) ; return assert not pass ( compare ( expect json , compare mode ) ) ; }
public json content assert do not have empty json path value ( char sequence expression , object . . . args ) { new json path value ( expression , args ) . assert do not have empty value ( ) ; return this ; }
public < t > response entity < t > get for entity ( string url , class < t > response type , object . . . url variable ) throw rest client exception { return this . rest template . get for entity ( url , response type , url variable ) ; }
public < t > t post for object ( string url , object request , class < t > response type , object . . . url variable ) throw rest client exception { return this . rest template . post for object ( url , request , response type , url variable ) ; }
public void delete ( string url , object . . . url variable ) throw rest client exception { this . rest template . delete ( url , url variable ) ; }
public < t > response entity < t > exchange ( string url , http method method , http entity < ? > request entity , class < t > response type , object . . . url variable ) throw rest client exception { return this . rest template . exchange ( url , method , request entity , response type , url variable ) ; }
public void clear ( ) { get entity manager ( ) . clear ( ) ; }
protect object get cache key ( method method , class < ? > target class ) { return new annotate element key ( method , target class ) ; }
protect < t > t get bean ( string bean name , class < t > expect type ) { return bean factory annotation utils . qualified bean of type ( this . application context , expect type , bean name ) ; }
protect void destroy definition ( bean factory group def , string selector ) { if ( group def instanceof configurable application context ) { if ( logger . be trace enable ( ) ) { logger . trace ( `` context group with selector ' `` + selector + `` ' be release , a there be no more reference to it `` ) ; } ( ( configurable application context ) group def ) . close ( ) ; } }
public static bean factory locator get instance ( ) throw fatal bean exception { return context singleton bean factory locator . get instance ( ) ; }
public final bean definition registry get registry ( ) { return this . registry ; }
public void set environment ( environment environment ) { this . condition evaluator = new condition evaluator ( this . registry , environment , null ) ; }
public void set scoped proxy mode ( scoped proxy mode scoped proxy mode ) { this . scope metadata resolver = new annotation scope metadata resolver ( scoped proxy mode ) ; }
protect object build lazy resource proxy ( final lookup element element , final string request bean name ) { target source t = new target source ( ) { @ override public class < ? > get target class ( ) { return element . lookup type ; } @ override public boolean be static ( ) { return false ; } @ override public object get target ( ) { return get resource ( element , request bean name ) ; } @ override public void release target ( object target ) { } } ; proxy factory pf = new proxy factory ( ) ; pf . set target source ( t ) ; if ( element . lookup type . be interface ( ) ) { pf . add interface ( element . lookup type ) ; } class loader class loader = ( this . bean factory instanceof configurable bean factory ? ( ( configurable bean factory ) this . bean factory ) . get bean class loader ( ) : null ) ; return pf . get proxy ( class loader ) ; }
protect object get resource ( lookup element element , string request bean name ) throw bean exception { if ( string utils . have length ( element . map name ) ) { return this . jndi factory . get bean ( element . map name , element . lookup type ) ; } if ( this . always use jndi lookup ) { return this . jndi factory . get bean ( element . name , element . lookup type ) ; } if ( this . resource factory == null ) { throw new no such bean definition exception ( element . lookup type , `` no resource factory configure - specify the 'resource factory ' property `` ) ; } return autowire resource ( this . resource factory , element , request bean name ) ; }
public scoped proxy mode get scoped proxy mode ( ) { return this . scoped proxy mode ; }
public final long get timestamp ( ) { return this . timestamp ; }
protect boolean support event ( application listener < ? > listener , resolvable type event type , class < ? > source type ) { generic application listener smart listener = ( listener instanceof generic application listener ? ( generic application listener ) listener : new generic application listener adapter ( listener ) ) ; return ( smart listener . support event type ( event type ) & & smart listener . support source type ( source type ) ) ; }
protect error handler get error handler ( ) { return this . error handler ; }
public void set expression parser ( expression parser expression parser ) { assert . not null ( expression parser , `` expression parser must not be null `` ) ; this . expression parser = expression parser ; }
protect void init application event multicaster ( ) { configurable listable bean factory bean factory = get bean factory ( ) ; if ( bean factory . contain local bean ( application_event_multicaster_bean_name ) ) { this . application event multicaster = bean factory . get bean ( application_event_multicaster_bean_name , application event multicaster . class ) ; if ( logger . be debug enable ( ) ) { logger . debug ( `` use application event multicaster [ `` + this . application event multicaster + `` ] `` ) ; } } else { this . application event multicaster = new simple application event multicaster ( bean factory ) ; bean factory . register singleton ( application_event_multicaster_bean_name , this . application event multicaster ) ; if ( logger . be debug enable ( ) ) { logger . debug ( `` unable to locate application event multicaster with name ' `` + application_event_multicaster_bean_name + `` ' : use default [ `` + this . application event multicaster + `` ] `` ) ; } } }
protect void assert bean factory active ( ) { if ( ! this . active . get ( ) ) { if ( this . close . get ( ) ) { throw new illegal state exception ( get display name ( ) + `` have be close already `` ) ; } else { throw new illegal state exception ( get display name ( ) + `` have not be refresh yet `` ) ; } } }
protect resource [ ] get config resource ( ) { return null ; }
public void set converter ( set < ? > converter ) { this . converter = converter ; }
public string to string ( ) { return get class ( ) . get name ( ) + `` : `` + resolvable to string ( ) ; }
protect resource get resource by path ( string path ) { if ( path ! = null & & path . start with ( `` / `` ) ) { path = path . substring ( 1 ) ; } return new file system resource ( path ) ; }
protect set < configurable application context > find application context ( ) { synchronize ( application context ) { return new link hash set < configurable application context > ( application context ) ; } }
protect string render default message ( string default message , object [ ] args , locale locale ) { return format message ( default message , args , locale ) ; }
protect message format create message format ( string msg , locale locale ) { return new message format ( ( msg ! = null ? msg : `` `` ) , locale ) ; }
public void set basenames ( string . . . basenames ) { if ( basenames ! = null ) { this . basenames = new string [ basenames . length ] ; for ( int i = 0 ; i < basenames . length ; i++ ) { string basename = basenames [ i ] ; assert . have text ( basename , `` basename must not be empty `` ) ; this . basenames [ i ] = basename . trim ( ) ; } } else { this . basenames = new string [ 0 ] ; } }
public void set file encoding ( property file encoding ) { this . file encoding = file encoding ; }
protect message format resolve code ( string code , locale locale ) { message format message format = null ; for ( int i = 0 ; message format == null & & i < this . basenames . length ; i++ ) { resource bundle bundle = get resource bundle ( this . basenames [ i ] , locale ) ; if ( bundle ! = null ) { message format = get message format ( bundle , code , locale ) ; } } return message format ; }
protect void refresh home ( ) throw name exception { super . refresh home ( ) ; if ( this . cache session bean ) { synchronize ( this . bean instance monitor ) { this . bean instance = null ; } } }
protect bean factory locator get bean factory locator ( object target ) { return context singleton bean factory locator . get instance ( ) ; }
public void set style pattern ( string style pattern ) { this . style pattern = style pattern ; }
public date time zone get time zone ( ) { return this . time zone ; }
public static void reset date time context ( ) { date time context holder . remove ( ) ; }
public void override ( string old path , string new path ) { this . override . put ( old path , new path ) ; }
protect object convert result value if necessary ( object result , method parameter parameter ) { class < ? > target class = parameter . get parameter type ( ) ; try { if ( result == null ) { return null ; } if ( class utils . be assignable value ( target class , result ) ) { return result ; } if ( result instanceof composite data ) { method from method = target class . get method ( `` from `` , composite data . class ) ; return reflection utils . invoke method ( from method , null , result ) ; } else if ( result instanceof composite data [ ] ) { composite data [ ] array = ( composite data [ ] ) result ; if ( target class . be array ( ) ) { return convert data array to target array ( array , target class ) ; } else if ( collection . class . be assignable from ( target class ) ) { class < ? > element type = generic collection type resolver . get collection parameter type ( parameter ) ; if ( element type ! = null ) { return convert data array to target collection ( array , target class , element type ) ; } } } else if ( result instanceof tabular data ) { method from method = target class . get method ( `` from `` , tabular data . class ) ; return reflection utils . invoke method ( from method , null , result ) ; } else if ( result instanceof tabular data [ ] ) { tabular data [ ] array = ( tabular data [ ] ) result ; if ( target class . be array ( ) ) { return convert data array to target array ( array , target class ) ; } else if ( collection . class . be assignable from ( target class ) ) { class < ? > element type = generic collection type resolver . get collection parameter type ( parameter ) ; if ( element type ! = null ) { return convert data array to target collection ( array , target class , element type ) ; } } } throw new invocation failure exception ( `` incompatible result value [ `` + result + `` ] for target type [ `` + target class . get name ( ) + `` ] `` ) ; } catch ( no such method exception ex ) { throw new invocation failure exception ( `` could not obtain 'from ( composite data ) ' / 'from ( tabular data ) ' method on target type [ `` + target class . get name ( ) + `` ] for conversion of m x bean data structure [ `` + result + `` ] `` ) ; } }
protect string get class name ( object manage bean , string bean key ) throw j m exception { return get target class ( manage bean ) . get name ( ) ; }
protect model m bean constructor info [ ] get constructor info ( object manage bean , string bean key ) throw j m exception { return new model m bean constructor info [ 0 ] ; }
protect model m bean notification info [ ] get notification info ( object manage bean , string bean key ) throw j m exception { return new model m bean notification info [ 0 ] ; }
protected class < ? > get class for descriptor ( object manage bean ) { if ( aop utils . be jdk dynamic proxy ( manage bean ) ) { return aop proxy utils . proxied user interface ( manage bean ) [ 0 ] ; } return get class to expose ( manage bean ) ; }
protect void check manage bean ( object manage bean ) throw illegal argument exception { if ( aop utils . be jdk dynamic proxy ( manage bean ) ) { throw new illegal argument exception ( `` metadata m bean info assembler do not support jdk dynamic proxy - `` + `` export the target bean directly or use cglib proxy instead `` ) ; } }
public void set ignore method ( string . . . ignored method name ) { this . ignore method = new hash set < string > ( arrays . a list ( ignore method names ) ) ; }
protect boolean be bean definition lazy init ( listable bean factory bean factory , string bean name ) { return ( bean factory instanceof configurable listable bean factory & & bean factory . contains bean definition ( bean name ) & & ( ( configurable listable bean factory ) bean factory ) . get bean definition ( bean name ) . be lazy init ( ) ) ; }
public void set description ( string description ) { this . description = description ; }
public void set currency time limit ( int currency time limit ) { this . currency time limit = currency time limit ; }
public void set index ( int index ) { this . index = index ; }
public static class < ? > get m bean interface ( class < ? > clazz ) { if ( clazz == null || clazz . get superclass ( ) == null ) { return null ; } string mbean interface name = clazz . get name ( ) + mbean_suffix ; class < ? > [ ] implement interface = clazz . get interface ( ) ; for ( class < ? > iface : implemented interface ) { if ( iface . get name ( ) . equal ( mbean interface name ) ) { return iface ; } } return get m bean interface ( clazz . get superclass ( ) ) ; }
public jndi template get jndi template ( ) { return this . jndi template ; }
public void set proxy interface ( class < ? > . . . proxy interface ) { this . proxy interface = proxy interface ; }
public void unbind ( final string name ) throw name exception { if ( logger . be debug enable ( ) ) { logger . debug ( `` unbind jndi object with name [ `` + name + `` ] `` ) ; } execute ( new jndi callback < object > ( ) { @ override public object do in context ( context ctx ) throw name exception { ctx . unbind ( name ) ; return null ; } } ) ; }
public void add shareable resource ( string shareable resource ) { this . shareable resource . add ( shareable resource ) ; }
public void set refresh stub on connect failure ( boolean refresh stub on connect failure ) { this . refresh stub on connect failure = refresh stub on connect failure ; }
protected remote invocation create remote invocation ( method invocation method invocation ) { return get remote invocation factory ( ) . create remote invocation ( method invocation ) ; }
public static exception convert rmi access exception ( method method , remote exception ex , string service name ) { return convert rmi access exception ( method , ex , be connect failure ( ex ) , service name ) ; }
public string get target interface name ( ) { class < ? > ifc = this . rmi exporter . get service interface ( ) ; return ( ifc ! = null ? ifc . get name ( ) : null ) ; }
public void set registry ( registry registry ) { this . registry = registry ; }
public void set interceptor ( object [ ] interceptor ) { this . interceptor = interceptor ; }
protect object get proxy for service ( ) { check service ( ) ; check service interface ( ) ; proxy factory proxy factory = new proxy factory ( ) ; proxy factory . add interface ( get service interface ( ) ) ; if ( this . register trace interceptor ! = null ? this . register trace interceptor . boolean value ( ) : this . interceptor == null ) { proxy factory . add advice ( new remote invocation trace interceptor ( get exporter name ( ) ) ) ; } if ( this . interceptor ! = null ) { advisor adapter registry adapter registry = global advisor adapter registry . get instance ( ) ; for ( int i = 0 ; i < this . interceptor . length ; i++ ) { proxy factory . add advisor ( adapter registry . wrap ( this . interceptor [ i ] ) ) ; } } proxy factory . set target ( get service ( ) ) ; proxy factory . set opaque ( true ) ; return proxy factory . get proxy ( get bean class loader ( ) ) ; }
public string get method name ( ) { return this . method name ; }
public void set parameter type ( class < ? > [ ] parameter type ) { this . parameter type = parameter type ; }
public void set argument ( object [ ] argument ) { this . argument = argument ; }
public void set exception ( throwable exception ) { this . exception = exception ; }
public void set shutdown delay ( int shutdown delay ) { this . shutdown delay = shutdown delay ; }
public runnable get runnable ( ) { return this . runnable ; }
public boolean be one time task ( ) { return ( this . period < = 0 ) ; }
public void set keep alive second ( int keep alive second ) { this . keep alive second = keep alive second ; }
public void set queue capacity ( int queue capacity ) { this . queue capacity = queue capacity ; }
protect block queue < runnable > create queue ( int queue capacity ) { if ( queue capacity > 0 ) { return new link block queue < runnable > ( queue capacity ) ; } else { return new synchronous queue < runnable > ( ) ; } }
public schedule executor service get schedule executor ( ) throw illegal state exception { assert . state ( this . schedule executor ! = null , `` thread pool task scheduler not initialize `` ) ; return this . schedule executor ; }
public void set default proxy target class ( boolean default proxy target class ) { this . default proxy target class = default proxy target class ; }
protect script engine get script engine ( script source script ) { if ( this . script engine manager == null ) { this . script engine manager = new script engine manager ( ) ; } if ( string utils . have text ( this . engine name ) ) { return standard script utils . retrieve engine by name ( this . script engine manager , this . engine name ) ; } else if ( script instanceof resource script source ) { resource resource = ( ( resource script source ) script ) . get resource ( ) ; string extension = string utils . get filename extension ( resource . get filename ( ) ) ; if ( extension == null ) { throw new illegal state exception ( `` no script language define , and no file extension define for resource : `` + resource ) ; } script engine engine = this . script engine manager . get engine by extension ( extension ) ; if ( engine == null ) { throw new illegal state exception ( `` no matching engine find for file extension ' `` + extension + `` ' `` ) ; } return engine ; } else { throw new illegal state exception ( `` no script language define , and no resource associate with script : `` + script ) ; } }
public property editor find editor ( string field , class < ? > value type ) { property editor registry editor registry = get property editor registry ( ) ; if ( editor registry ! = null ) { class < ? > value type to use = value type ; if ( value type to use == null ) { value type to use = get field type ( field ) ; } return editor registry . find custom editor ( value type to use , fix field ( field ) ) ; } else { return null ; } }
public void record suppress field ( string field ) { this . suppressed field . add ( field ) ; }
protect string fix field ( string field ) { if ( string utils . have length ( field ) ) { return get nest path ( ) + canonical field name ( field ) ; } else { string path = get nest path ( ) ; return ( path . end with ( error . nested_path_separator ) ? path . substring ( 0 , path . length ( ) - nested_path_separator . length ( ) ) : path ) ; } }
public property editor find editor ( string field , class < ? > value type ) { class < ? > value type for lookup = value type ; if ( value type for lookup == null ) { value type for lookup = get field type ( field ) ; } property editor editor = super . find editor ( field , value type for lookup ) ; if ( editor == null & & this . conversion service ! = null ) { type descriptor td = null ; if ( field ! = null ) { type descriptor ptd = get property accessor ( ) . get property type descriptor ( fixed field ( field ) ) ; if ( value type == null || value type . be assignable from ( ptd . get type ( ) ) ) { td = ptd ; } } if ( td == null ) { td = type descriptor . value of ( value type for lookup ) ; } if ( this . conversion service . can convert ( type descriptor . value of ( string . class ) , td ) ) { editor = new convert property editor adapter ( this . conversion service , td ) ; } } return editor ; }
public void set mapping location ( resource . . . mapping location ) { this . mapping location = mapping location ; }
public void replace validators ( validator . . . validators ) { assert validators ( validators ) ; this . validators . clear ( ) ; this . validators . add all ( array . a list ( validators ) ) ; }
public string [ ] resolve message code ( string error code , string object name , string field , class < ? > field type ) { set < string > code list = new link hash set < string > ( ) ; list < string > field list = new array list < string > ( ) ; build field list ( field , field list ) ; add code ( code list , error code , object name , field list ) ; int dot index = field . last index of ( ' . ' ) ; if ( dot index ! = -1 ) { build field list ( field . substring ( dot index + 1 ) , field list ) ; } add code ( code list , error code , null , field list ) ; if ( field type ! = null ) { add code ( code list , error code , null , field type . get name ( ) ) ; } add code ( code list , error code , null , null ) ; return string utils . to string array ( code list ) ; }
public void register bean ( class < ? > bean class ) { do register bean ( bean class , null , null , null , null ) ; }
public set < string > get candidate type ( string base package , string stereotype ) { list < entry > candidate = this . index . get ( stereotype ) ; if ( candidate ! = null ) { return candidate . parallel stream ( ) . filter ( t - > t . match ( base package ) ) . map ( t - > t . type ) . collect ( collector . to set ( ) ) ; } return collection . empty set ( ) ; }
public void destroy ( ) { close ( ) ; }
protect boolean be fallback to system locale ( ) { return this . fallback to system locale ; }
public final < t > void register bean ( class < t > bean class , bean definition customizer . . . customizers ) { register bean ( null , bean class , null , customizers ) ; }
public long get interval ( ) { return this . interval ; }
public runnable get runnable ( ) { return this . runnable ; }
public method get method ( ) { return this . method ; }
protect string get default listener id ( ) { method method = get target method ( ) ; string joiner sj = new string joiner ( `` , `` , `` ( `` , `` ) `` ) ; for ( class < ? > param type : method . get parameter type ( ) ) { sj . add ( param type . get name ( ) ) ; } return class utils . get qualified method name ( method ) + sj . to string ( ) ; }
public void set execute exist delay task after shutdown policy ( boolean flag ) { if ( this . schedule executor instanceof schedule thread pool executor ) { ( ( schedule thread pool executor ) this . schedule executor ) . set execute exist delay task after shutdown policy ( flag ) ; } this . execute exist delay task after shutdown policy = flag ; }
public static boolean be quartz day of month field ( string value ) { return value . contains ( `` l `` ) || value . contains ( `` w `` ) ; }
public static object get value ( annotation annotation , string attribute name ) { if ( annotation == null || ! string utils . have text ( attribute name ) ) { return null ; } try { method method = annotation . annotation type ( ) . get declared method ( attribute name ) ; reflection utils . make accessible ( method ) ; return method . invoke ( annotation ) ; } catch ( exception ex ) { return null ; } }
public static object get default value ( annotation annotation , string attribute name ) { if ( annotation == null ) { return null ; } return get default value ( annotation . annotation type ( ) , attribute name ) ; }
public static type descriptor value of ( class < ? > type ) { if ( type == null ) { type = object . class ; } type descriptor desc = common type cache . get ( type ) ; return ( desc ! = null ? desc : new type descriptor ( resolvable type . for class ( type ) , null , null ) ) ; }
public static type descriptor nest ( method parameter method parameter , int nest level ) { if ( method parameter . get nesting level ( ) ! = 1 ) { throw new illegal argument exception ( `` method parameter nest level must be 1 : `` + `` use the nesting level parameter to specify the desired nesting level for nested type traversal `` ) ; } return nest ( new type descriptor ( method parameter ) , nest level ) ; }
public static type descriptor nest ( field field , int nest level ) { return nest ( new type descriptor ( field ) , nest level ) ; }
protect void validate profile ( string profile ) { if ( ! string utils . have text ( profile ) ) { throw new illegal argument exception ( `` invalid profile [ `` + profile + `` ] : must contain text `` ) ; } if ( profile . char at ( 0 ) == ' ! ' ) { throw new illegal argument exception ( `` invalid profile [ `` + profile + `` ] : must not begin with ! operator `` ) ; } }
protect string resolve nest placeholder ( string value ) { return ( this . ignore unresolvable nested placeholder ? resolve placeholder ( value ) : resolve require placeholder ( value ) ) ; }
public string to string ( ) { if ( logger . be debug enable ( ) ) { return string . format ( `` % s @ % s [ name= ' % s ' , properties= % s ] `` , get class ( ) . get simple name ( ) , system . identity hash code ( this ) , this . name , this . source ) ; } else { return string . format ( `` % s [ name= ' % s ' ] `` , get class ( ) . get simple name ( ) , this . name ) ; } }
public static class < ? > get collection field type ( field collection field ) { return resolvable type . for field ( collection field ) . a collection ( ) . resolve generic ( ) ; }
public static class < ? > resolve parameter type ( method parameter method parameter , class < ? > implementation class ) { assert . not null ( method parameter , `` method parameter must not be null `` ) ; assert . not null ( implementation class , `` class must not be null `` ) ; method parameter . set contain class ( implementation class ) ; resolvable type . resolve method parameter ( method parameter ) ; return method parameter . get parameter type ( ) ; }
public static class < ? > resolve return type argument ( method method , class < ? > generic ifc ) { assert . not null ( method , `` method must not be null `` ) ; resolvable type resolvable type = resolvable type . for method return type ( method ) . a ( generic ifc ) ; if ( ! resolvable type . have generic ( ) || resolvable type . get type ( ) instanceof wildcard type ) { return null ; } return get single generic ( resolvable type ) ; }
public static class < ? > resolve type argument ( class < ? > clazz , class < ? > generic ifc ) { resolvable type resolvable type = resolvable type . for class ( clazz ) . a ( generic ifc ) ; if ( ! resolvable type . have generic ( ) ) { return null ; } return get single generic ( resolvable type ) ; }
protect file get file for last modified check ( ) throw i o exception { return get file ( ) ; }
public final byte [ ] get byte array ( ) { return this . byte array ; }
public resource create relative ( string relative path ) { string path to use = string utils . apply relative path ( this . path , relative path ) ; return new file system resource ( path to use ) ; }
public int hash code ( ) { return this . input stream . hash code ( ) ; }
public void set location ( resource location ) { this . location = new resource [ ] { location } ; }
public void set location ( resource . . . location ) { this . location = location ; }
public void set ignore resource not find ( boolean ignore resource not find ) { this . ignore resource not find = ignore resource not find ; }
public void set file encode ( string encode ) { this . file encode = encoding ; }
public static property load property ( resource resource ) throw i o exception { property prop = new property ( ) ; fill property ( prop , resource ) ; return prop ; }
public class < ? > get declare class ( ) { return get member ( ) . get declare class ( ) ; }
public class < ? > get nest parameter type ( ) { if ( this . nest level > 1 ) { type type = get generic parameter type ( ) ; for ( int i = 2 ; i < = this . nesting level ; i++ ) { if ( type instanceof parameterized type ) { type [ ] args = ( ( parameterized type ) type ) . get actual type argument ( ) ; integer index = get type index for level ( i ) ; type = args [ index ! = null ? index : args . length - 1 ] ; } } if ( type instanceof class ) { return ( class < ? > ) type ; } else if ( type instanceof parameterized type ) { type arg = ( ( parameterized type ) type ) . get raw type ( ) ; if ( arg instanceof class ) { return ( class < ? > ) arg ; } } return object . class ; } else { return get parameter type ( ) ; } }
public < t extend annotation > t get parameter annotation ( class < t > annotation type ) { annotation [ ] anns = get parameter annotation ( ) ; for ( annotation ann : anns ) { if ( annotation type . be instance ( ann ) ) { return ( t ) ann ; } } return null ; }
public static < t extend type > t unwrap ( t type ) { type unwrap = type ; while ( unwrapped instanceof serializable type proxy ) { unwrapped = ( ( serializable type proxy ) type ) . get type provider ( ) . get type ( ) ; } return ( t ) unwrap ; }
public boolean have alias ( string name , string alias ) { for ( map . entry < string , string > entry : this . alias map . entry set ( ) ) { string register name = entry . get value ( ) ; if ( registered name . equal ( name ) ) { string register alias = entry . get key ( ) ; return ( registered alias . equal ( alias ) || have alias ( registered alias , alias ) ) ; } } return false ; }
public static string get version ( ) { package pkg = spring version . class . get package ( ) ; return ( pkg ! = null ? pkg . get implementation version ( ) : null ) ; }
public to string creator append ( string field name , byte value ) { return append ( field name , new byte ( value ) ) ; }
public void set thread factory ( thread factory thread factory ) { this . thread factory = thread factory ; }
public void set concurrency limit ( int concurrency limit ) { this . concurrency throttle . set concurrency limit ( concurrency limit ) ; }
protect boolean match interface ( string interface name ) { return null ; }
public void set cache pattern ( boolean cache pattern ) { this . cache pattern = cache pattern ; }
public long get max interval ( ) { return max interval ; }
public void set interval ( long interval ) { this . interval = interval ; }
public long get interval ( ) { return interval ; }
public static string get descriptive type ( object value ) { if ( value == null ) { return null ; } class < ? > clazz = value . get class ( ) ; if ( proxy . be proxy class ( clazz ) ) { string builder result = new string builder ( clazz . get name ( ) ) ; result . append ( `` implement `` ) ; class < ? > [ ] ifc = clazz . get interface ( ) ; for ( int i = 0 ; i < ifc . length ; i++ ) { result . append ( ifcs [ i ] . get name ( ) ) ; if ( i < ifc . length - 1 ) { result . append ( ' , ' ) ; } } return result . to string ( ) ; } else if ( clazz . be array ( ) ) { return get qualify name for array ( clazz ) ; } else { return clazz . get name ( ) ; } }
public static int get method count for name ( class < ? > clazz , string method name ) { assert . not null ( clazz , `` class must not be null `` ) ; assert . not null ( method name , `` method name must not be null `` ) ; int count = 0 ; method [ ] declare method = clazz . get declare method ( ) ; for ( method method : declare method ) { if ( method name . equal ( method . get name ( ) ) ) { count++ ; } } class < ? > [ ] ifc = clazz . get interface ( ) ; for ( class < ? > ifc : ifc ) { count += get method count for name ( ifc , method name ) ; } if ( clazz . get superclass ( ) ! = null ) { count += get method count for name ( clazz . get superclass ( ) , method name ) ; } return count ; }
public static boolean be primitive or wrapper ( class < ? > clazz ) { assert . not null ( clazz , `` class must not be null `` ) ; return ( clazz . be primitive ( ) || be primitive wrapper ( clazz ) ) ; }
public static boolean be assignable ( class < ? > lh type , class < ? > rh type ) { assert . not null ( lhs type , `` left-hand side type must not be null `` ) ; assert . not null ( rhs type , `` right-hand side type must not be null `` ) ; if ( lhs type . be assignable from ( rhs type ) ) { return true ; } if ( lhs type . be primitive ( ) ) { class < ? > resolve primitive = primitive wrapper type map . get ( rhs type ) ; if ( lhs type == resolve primitive ) { return true ; } } else { class < ? > resolve wrapper = primitive type to wrapper map . get ( rhs type ) ; if ( resolve wrapper ! = null & & lhs type . be assignable from ( resolve wrapper ) ) { return true ; } } return false ; }
public static string class package a resource path ( class < ? > clazz ) { if ( clazz == null ) { return `` `` ; } string class name = clazz . get name ( ) ; int package end index = class name . last index of ( package_separator ) ; if ( package end index == -1 ) { return `` `` ; } string package name = class name . substring ( 0 , package end index ) ; return package name . replace ( package_separator , path_separator ) ; }
public static string class name to string ( class < ? > . . . class ) { return class name to string ( arrays . a list ( class ) ) ; }
public void add comparator ( comparator < ? extend t > comparator , boolean ascend ) { this . comparators . add ( new invertible comparator ( comparator , ascend ) ) ; }
public static string builder append md5 digest a hex ( byte [ ] byte , string builder builder ) { return append digest a hex ( md5_algorithm_name , byte , builder ) ; }
public byte [ ] to byte array unsafe ( ) { int total size = size ( ) ; if ( total size == 0 ) { return new byte [ 0 ] ; } resize ( total size ) ; return this . buffer . get first ( ) ; }
public static void init logging ( string location , long refresh interval ) throw file not find exception { string resolve location = system property utils . resolve placeholder ( location ) ; file file = resource utils . get file ( resolve location ) ; if ( ! file . exists ( ) ) { throw new file not find exception ( `` log4j config file [ `` + resolve location + `` ] not find `` ) ; } if ( resolve location . to lower case ( ) . end with ( xml_file_extension ) ) { d o m configurator . configure and watch ( file . get absolute path ( ) , refresh interval ) ; } else { property configurator . configure and watch ( file . get absolute path ( ) , refresh interval ) ; } }
public static boolean simple match ( string [ ] pattern , string str ) { if ( pattern ! = null ) { for ( string pattern : pattern ) { if ( simple match ( pattern , str ) ) { return true ; } } } return false ; }
public static void make accessible ( method method ) { if ( ( ! modifier . be public ( method . get modifier ( ) ) || ! modifier . be public ( method . get declare class ( ) . get modifier ( ) ) ) & & ! method . be accessible ( ) ) { method . set accessible ( true ) ; } }
public static void do with local method ( class < ? > clazz , method callback mc ) { method [ ] method = get declare method ( clazz ) ; for ( method method : method ) { try { mc . do with ( method ) ; } catch ( illegal access exception ex ) { throw new illegal state exception ( `` not allow to access method ' `` + method . get name ( ) + `` ' : `` + ex ) ; } } }
public static boolean be url ( string resource location ) { if ( resource location == null ) { return false ; } if ( resource location . start with ( classpath_url_prefix ) ) { return true ; } try { new url ( resource location ) ; return true ; } catch ( malformed u r l exception ex ) { return false ; } }
public void stop ( ) throw illegal state exception { if ( ! this . run ) { throw new illegal state exception ( `` ca n't stop stop watch : it 's not run `` ) ; } long last time = system . current time millis ( ) - this . start time millis ; this . total time millis += last time ; this . last task info = new task info ( this . current task name , last time ) ; if ( this . keep task list ) { this . task list . add ( last task info ) ; } ++this . task count ; this . run = false ; this . current task name = null ; }
public string current task name ( ) { return this . current task name ; }
public int get task count ( ) { return this . task count ; }
protect void end prefix mapping ( string prefix ) throw s a x exception { if ( get content handler ( ) ! = null ) { if ( this . namespaces . contains key ( prefix ) ) { get content handler ( ) . end prefix mapping ( prefix ) ; this . namespaces . remove ( prefix ) ; } } }
public boolean can bypass convert ( @ nullable type descriptor source type , type descriptor target type ) { assert . not null ( target type , `` target type to convert to can not be null `` ) ; if ( source type == null ) { return true ; } generic converter converter = get converter ( source type , target type ) ; return ( converter == no_op_converter ) ; }
public object convert ( @ nullable object source , type descriptor target type ) { return convert ( source , type descriptor . for object ( source ) , target type ) ; }
public long last modified ( ) throw i o exception { if ( this . file ! = null ) { return super . last modified ( ) ; } else { try { return file . get last modified time ( this . file path ) . to millis ( ) ; } catch ( no such file exception ex ) { throw new file not find exception ( ex . get message ( ) ) ; } } }
public long content length ( ) throw i o exception { return file . size ( this . path ) ; }
public static boolean be kotlin reflect present ( ) { return kotlin reflect present ; }
public static log get hidden log ( class < ? > clazz ) { return log factory . get log ( `` _ `` + clazz . get name ( ) ) ; }
public static log message format ( string format , object arg1 , object arg2 ) { return new format message2 ( format , arg1 , arg2 ) ; }
public member get member ( ) { return this . executable ; }
public reactive adapter get adapter ( class < ? > reactive type ) { return get adapter ( reactive type , null ) ; }
public class < ? > get reactive type ( ) { return this . reactive type ; }
protect string [ ] tokenize path ( string path ) { return string utils . tokenize to string array ( path , this . path separator , this . trim token , true ) ; }
public static boolean be file u r l ( url url ) { string protocol = url . get protocol ( ) ; return ( url_protocol_file . equal ( protocol ) || url_protocol_vfsfile . equal ( protocol ) || url_protocol_vfs . equal ( protocol ) ) ; }
public int get task count ( ) { return this . task count ; }
public string to string ( ) { string builder sb = new string builder ( short summary ( ) ) ; if ( this . keep task list ) { for ( task info task : get task info ( ) ) { sb . append ( `` ; [ `` ) . append ( task . get task name ( ) ) . append ( `` ] take `` ) . append ( task . get time nanos ( ) ) . append ( `` n `` ) ; long percent = math . round ( 100 . 0 * task . get time nanos ( ) / get total time nanos ( ) ) ; sb . append ( `` = `` ) . append ( percent ) . append ( `` % `` ) ; } } else { sb . append ( `` ; no task info keep `` ) ; } return sb . to string ( ) ; }
public static string get short name a property ( class < ? > clazz ) { string short name = get short name ( clazz ) ; int dot index = short name . last index of ( package_separator ) ; short name = ( dot index ! = -1 ? short name . substring ( dot index + 1 ) : short name ) ; return introspector . decapitalize ( short name ) ; }
public static string get filename extension ( @ nullable string path ) { if ( path == null ) { return null ; } int ext index = path . last index of ( extension_separator ) ; if ( ext index == -1 ) { return null ; } int folder index = path . last index of ( folder_separator ) ; if ( folder index > ext index ) { return null ; } return path . substring ( ext index + 1 ) ; }
public static float to float ( type converter type converter , type value type value ) { return ( float ) type converter . convert value ( typed value . get value ( ) , type value . get type descriptor ( ) , type descriptor . value of ( float . class ) ) ; }
public final string get expression string ( ) { return this . expression string ; }
public static literal get int literal ( string number token , int po , int radix ) { try { int value = integer . parse int ( number token , radix ) ; return new int literal ( number token , po , value ) ; } catch ( number format exception ex ) { throw new internal parse exception ( new spel parse exception ( pos > > 16 , ex , spel message . not_an_integer , number token ) ) ; } }
public boolean be compilable ( ) { cache method executor executor to check = this . cached executor ; if ( executor to check == null || ! ( executor to check . get ( ) instanceof reflective method executor ) ) { return false ; } for ( spel node impl child : this . child ) { if ( ! child . be compilable ( ) ) { return false ; } } reflective method executor executor = ( reflective method executor ) executor to check . get ( ) ; if ( executor . do argument conversion occur ( ) ) { return false ; } method method = executor . get method ( ) ; class < ? > clazz = method . get declare class ( ) ; if ( ! modifier . be public ( clazz . get modifier ( ) ) & & executor . get public declare class ( ) == null ) { return false ; } return true ; }
public void enter scope ( map < string , object > arg map ) { ensure variable scope initialize ( ) ; this . variable scope . push ( new variable scope ( arg map ) ) ; this . scope root object . push ( get active context object ( ) ) ; }
public class loader get compiler class loader ( ) { return this . compiler class loader ; }
public static data bind method resolver for instance method invocation ( ) { return new data bind method resolver ( ) ; }
public final method get method ( ) { return this . original method ; }
public file get file ( ) { return this . file ; }
public text edit format ( string source , int offset , int length ) { return format ( source , offset , length , default_line_separator ) ; }
public static i classpath container get classpath container ( i path container path , i java project project ) throw java model exception { java model manager manager = java model manager . get java model manager ( ) ; i classpath container container = manager . get classpath container ( container path , project ) ; if ( container == java model manager . container_initialization_in_progress ) { return manager . get previous session container ( container path , project ) ; } return container ; }
public char [ ] compute unique key ( boolean be leaf ) { return char operation . concat with ( this . compound name , '/ ' ) ; }
public i reader lock ( ) { return this . nd . acquire read lock ( ) ; }
public boolean accept ( i b tree visitor visitor ) throw index exception { return accept ( this . db . get rec ptr ( this . root pointer ) , visitor ) ; }
public void put rec ptr ( final long offset , final long value ) { make dirty ( ) ; int idx = rec ptr to index ( offset ) ; database . put rec ptr ( value , this . f buffer , idx ) ; record write ( offset , 4 ) ; }
public synchronize void set max size ( long max size ) { final int new length= compute length ( max size ) ; final int old length= this . f table be full ? this . f page table . length : this . f pointer ; if ( new length > old length ) { chunk [ ] new table= new chunk [ new length ] ; system . arraycopy ( this . f page table , 0 , new table , 0 , old length ) ; this . f table be full= false ; this . f pointer= old length ; this . f page table= new table ; } else { for ( int i = new length ; i < old length ; i++ ) { chunk chunk = this . f page table [ i ] ; chunk . f cache index = -1 ; chunk . f database . check if chunk release ( chunk ) ; } chunk [ ] new table= new chunk [ new length ] ; system . arraycopy ( this . f page table , 0 , new table , 0 , new length ) ; this . f table be full= true ; this . f pointer= 0 ; this . f page table= new table ; } }
public list < nd zip entry > get zip entry ( ) { return zip_entries . a list ( get nd ( ) , get address ( ) ) ; }
public void set miss type name ( char [ ] content ) { missing_type_names . put ( get nd ( ) , this . address , content ) ; }
public ldap authentication provider configurer < b > user dn pattern ( string . . . user dn pattern ) { this . user dn pattern = user dn pattern ; return this ; }
public ldap authentication provider configurer < b > user detail context mapper ( user detail context mapper user detail context mapper ) { this . user detail context mapper = user detail context mapper ; return this ; }
public ldap authentication provider configurer < b > group search base ( string group search base ) { this . group search base = group search base ; return this ; }
public ldap authentication provider configurer < b > group search subtree ( boolean group search subtree ) { this . group search subtree = group search subtree ; return this ; }
public r socket security basic authentication ( customizer < basic authentication spec > basic ) { if ( this . basic auth spec == null ) { this . basic auth spec = new basic authentication spec ( ) ; } basic . customize ( this . basic auth spec ) ; return this ; }
public o auth2 client configurer < http security > oauth2 client ( ) throw exception { o auth2 client configurer < http security > configurer = get or apply ( new o auth2 client configurer < > ( ) ) ; this . post process ( configurer ) ; return configurer ; }
public form login configurer < h > username parameter ( string username parameter ) { get authentication filter ( ) . set username parameter ( username parameter ) ; return this ; }
public form login configurer < h > failure forward url ( string forward url ) { failure handler ( new forward authentication failure handler ( forward url ) ) ; return this ; }
public header configurer < h > default disable ( ) { this . content type option . disable ( ) ; this . xss protection . disable ( ) ; this . cache control . disable ( ) ; this . hsts . disable ( ) ; this . frame option . disable ( ) ; return this ; }
public http basic configurer < b > realm name ( string realm name ) { this . basic auth entry point . set realm name ( realm name ) ; this . basic auth entry point . after property set ( ) ; return this ; }
public logout configurer < h > logout request matcher ( request matcher logout request matcher ) { this . logout request matcher = logout request matcher ; return this ; }
public logout configurer < h > delete cooky ( string . . . cookie name to clear ) { return add logout handler ( new cookie clear logout handler ( cookie name to clear ) ) ; }
public implicit grant configurer < b > client registration repository ( client registration repository client registration repository ) { assert . not null ( client registration repository , `` client registration repository can not be null `` ) ; this . get builder ( ) . set share object ( client registration repository . class , client registration repository ) ; return this ; }
public x509 configurer < h > user detail service ( user detail service user detail service ) { user detail by name service wrapper < pre authenticate authentication token > authentication user detail service = new user detail by name service wrapper < > ( ) ; authentication user detail service . set user detail service ( user detail service ) ; return authentication user detail service ( authentication user detail service ) ; }
public static user detail resource factory bean from resource location ( string resource location ) { user detail resource factory bean result = new user detail resource factory bean ( ) ; result . set resource location ( resource location ) ; return result ; }
public header spec header ( ) { if ( this . header == null ) { this . header = new header spec ( ) ; } return this . header ; }
public exception handle spec exception handling ( ) { if ( this . exception handle == null ) { this . exception handle = new exception handle spec ( ) ; } return this . exception handling ; }
public boolean support ( class < ? > clazz ) { for ( access decision voter < ? > voter : this . decision voter ) { if ( ! voter . support ( clazz ) ) { return false ; } } return true ; }
public boolean support ( class < ? > clazz ) { return ( method invocation . class . be assignable from ( clazz ) ) ; }
public void set password encoder ( password encoder password encoder ) { assert . not null ( password encoder , `` password encoder can not be null `` ) ; this . password encoder = password encoder ; this . user not find encode password = null ; }
public void set default authentication failure event ( class < ? extend abstract authentication failure event > default authentication failure event class ) { assert . not null ( default authentication failure event class , `` default authentication failure event class must not be null `` ) ; try { this . default authentication failure event constructor = default authentication failure event class . get constructor ( authentication . class , authentication exception . class ) ; } catch ( no such method exception ex ) { throw new runtime exception ( `` default authentication failure event class `` + default authentication failure event class . get name ( ) + `` have no suitable constructor `` ) ; } }
public list < grant authority > get grant authority ( collection < string > attribute ) { array list < grant authority > result = new array list < > ( ) ; for ( string attribute : attribute ) { collection < grant authority > grant = this . attributes2granted authority map . get ( attribute ) ; if ( grant ! = null ) { result . add all ( grant ) ; } } result . trim to size ( ) ; return result ; }
public list < grant authority > get grant authority ( collection < string > attribute ) { list < grant authority > result = new array list < > ( attribute . size ( ) ) ; for ( string attribute : attribute ) { result . add ( get grant authority ( attribute ) ) ; } return result ; }
public static int get initialize count ( ) { return initialize count ; }
public void after property set ( ) { assert . not null ( this . user detail service , `` user detail service must be set `` ) ; }
public static string gensalt ( string prefix , int log_rounds , secure random random ) throw illegal argument exception { string builder r = new string builder ( ) ; byte rnd [ ] = new byte [ bcrypt_salt_len ] ; if ( ! prefix . start with ( `` $ 2 `` ) || ( prefix . char at ( 2 ) ! = ' a ' & & prefix . char at ( 2 ) ! = ' y ' & & prefix . char at ( 2 ) ! = ' b ' ) ) { throw new illegal argument exception ( `` invalid prefix `` ) ; } if ( log_rounds < 4 || log_rounds > 31 ) { throw new illegal argument exception ( `` invalid log_rounds `` ) ; } random . next byte ( rnd ) ; r . append ( `` $ 2 `` ) ; r . append ( prefix . char at ( 2 ) ) ; r . append ( `` $ `` ) ; if ( log_rounds < 10 ) { r . append ( `` 0 `` ) ; } r . append ( log_rounds ) ; r . append ( `` $ `` ) ; encode_base64 ( rnd , rnd . length , r ) ; return r . to string ( ) ; }
public static text encryptor delux ( char sequence password , char sequence salt ) { return new hex encode text encryptor ( strong ( password , salt ) ) ; }
public static text encryptor text ( char sequence password , char sequence salt ) { return new hex encode text encryptor ( standard ( password , salt ) ) ; }
public string encode ( char sequence raw pas ) { byte [ ] salt = this . salt generator . generate key ( ) ; return encode ( raw pas , salt ) ; }
public string encode ( char sequence raw password ) { string salt = prefix + this . salt generator . generate key ( ) + suffix ; return digest ( salt , raw password ) ; }
public static object get field value ( object bean , string field name ) throw illegal access exception { assert . not null ( bean , `` bean can not be null `` ) ; assert . have text ( field name , `` field name require `` ) ; string [ ] nest field = string utils . tokenize to string array ( field name , `` . `` ) ; class < ? > component class = bean . get class ( ) ; object value = bean ; for ( string nest field : nested field ) { field field = get field ( component class , nested field ) ; field . set accessible ( true ) ; value = field . get ( value ) ; if ( value ! = null ) { component class = value . get class ( ) ; } } return value ; }
public mono < o auth2 authorize client > authorize ( o auth2 authorization context context ) { assert . not null ( context , `` context can not be null `` ) ; o auth2 authorized client authorize client = context . get authorized client ( ) ; if ( authorized client == null || authorize client . get refresh token ( ) == null || ! have token expire ( authorized client . get access token ( ) ) ) { return mono . empty ( ) ; } object request scope = context . get attribute ( o auth2 authorization context . request_scope_attribute_name ) ; set < string > scope = collection . empty set ( ) ; if ( request scope ! = null ) { assert . be instance of ( string [ ] . class , request scope , `` the context attribute must be of type string [ ] ' `` + o auth2 authorization context . request_scope_attribute_name + `` ' `` ) ; scope = new hash set < > ( arrays . a list ( ( string [ ] ) request scope ) ) ; } client registration client registration = context . get client registration ( ) ; o auth2 refresh token grant request refresh token grant request = new o auth2 refresh token grant request ( client registration , authorized client . get access token ( ) , authorized client . get refresh token ( ) , scopes ) ; return mono . just ( refresh token grant request ) . flat map ( this . access token response client : : get token response ) . on error map ( o auth2 authorization exception . class , ( e ) - > new client authorization exception ( e . get error ( ) , client registration . get registration id ( ) , e ) ) . map ( ( token response ) - > new o auth2 authorize client ( client registration , context . get principal ( ) . get name ( ) , token response . get access token ( ) , token response . get refresh token ( ) ) ) ; }
public < t > t get attribute ( string name ) { return ( t ) this . get attribute ( ) . get ( name ) ; }
public string get code ( ) { return this . code ; }
public boolean have error ( ) { return ! this . error . be empty ( ) ; }
public void set session authentication strategy ( session authentication strategy session strategy ) { this . session strategy = session strategy ; }
public void set authentication success handler ( authentication success handler success handler ) { assert . not null ( success handler , `` success handler can not be null `` ) ; this . success handler = success handler ; }
protect final string get default target url ( ) { return this . default target url ; }
public final user detail load user detail ( pre authenticate authentication token token ) throw authentication exception { assert . not null ( token . get detail ( ) , `` token . get detail ( ) can not be null `` ) ; assert . be instance of ( granted authority container . class , token . get detail ( ) ) ; collection < ? extends grant authority > authority = ( ( grant authority container ) token . get detail ( ) ) . get granted authority ( ) ; return create user detail ( token , authority ) ; }
protect boolean remember me request ( http servlet request request , string parameter ) { if ( this . always remember ) { return true ; } string param value = request . get parameter ( parameter ) ; if ( param value ! = null ) { if ( param value . equal ignore case ( `` true `` ) || param value . equal ignore case ( `` on `` ) || param value . equal ignore case ( `` yes `` ) || param value . equal ( `` 1 `` ) ) { return true ; } } this . logger . debug ( log message . format ( `` do not send remember-me cookie ( principal do not set parameter ' % s ' ) `` , parameter ) ) ; return false ; }
public void set parameter ( string parameter ) { assert . have text ( parameter , `` parameter name can not be empty or null `` ) ; this . parameter = parameter ; }
protect void on successful authentication ( http servlet request request , http servlet response response , authentication auth result ) { }
public void set migrate session attribute ( boolean migrate session attribute ) { this . migrate session attribute = migrate session attribute ; }
public void set user detail service ( user detail service user detail service ) { this . user detail service = user detail service ; }
public void set post only ( boolean post only ) { this . post only = post only ; }
protect string get dispatcher web application context suffix ( ) { return null ; }
protect void on response commit ( ) { save context ( security context holder . get context ( ) ) ; this . context save = true ; }
public void set firewall ( http firewall firewall ) { this . firewall = firewall ; }
public void set allow http method ( collection < string > allow http method ) { assert . not null ( allow http method , `` allow http method can not be null `` ) ; this . allow http method = ( allow http method ! = allow_any_http_method ) ? new hash set < > ( allow http method ) : allow_any_http_method ; }
public void set allow header name ( predicate < string > allow header name ) { assert . not null ( allow header name , `` allow header name can not be null `` ) ; this . allow header name = allow header name ; }
public list < string > get value ( ) { return this . header value ; }
public void set max age in second ( long max age in second ) { assert . be true ( max age in second > 0 , ( ) - > `` max age in second must be non-negative . get `` + max age in second ) ; this . max age in second = max age in second ; update hpkp header value ( ) ; }
public void set report uri ( uri report uri ) { this . report uri = report uri ; update hpkp header value ( ) ; }
public void set include sub domain ( boolean include sub domain ) { this . subdomain = include sub domain ? `` ; include sub domains `` : `` `` ; update delegate ( ) ; }
public void set mode ( mode mode ) { this . delegate = create delegate ( mode ) ; }
public void set password parameter ( string password parameter ) { assert . not null ( password parameter , `` password parameter can not be null `` ) ; this . password parameter = password parameter ; }
public static server web exchange matcher matcher ( server web exchange matcher . . . matcher ) { return new or server web exchange matcher ( matcher ) ; }
protect final void register extractor ( class < ? extend throwable > throwable type , throwable cause extractor extractor ) { assert . not null ( extractor , `` invalid extractor : null `` ) ; this . extractor map . put ( throwable type , extractor ) ; }
public byte [ ] get body a byte ( ) { return this . body . to byte array ( ) ; }
public flux < data buffer > get body ( ) { return this . body ; }
public void clear ( ) { this . bound object . clear ( ) ; }
public void set content ( @ nullable byte [ ] content ) { this . content = content ; this . input stream = null ; this . reader = null ; }
public void set parameter ( string name , string . . . value ) { assert . not null ( name , `` parameter name must not be null `` ) ; this . parameter . put ( name , value ) ; }
public void remove all parameter ( ) { this . parameter . clear ( ) ; }
public void add preferred locale ( locale locale ) { assert . not null ( locale , `` locale must not be null `` ) ; this . locale . add first ( locale ) ; update accept language header ( ) ; }
public void set preferred locale ( list < locale > locales ) { assert . not empty ( locale , `` locale list must not be empty `` ) ; this . locale . clear ( ) ; this . locale . add all ( locale ) ; update accept language header ( ) ; }
public void clear attribute ( ) { for ( iterator < map . entry < string , object > > it = this . attribute . entry set ( ) . iterator ( ) ; it . have next ( ) ; ) { map . entry < string , object > entry = it . next ( ) ; string name = entry . get key ( ) ; object value = entry . get value ( ) ; it . remove ( ) ; if ( value instanceof http session bind listener ) { ( ( http session bind listener ) value ) . value unbound ( new http session bind event ( this , name , value ) ) ; } } }
protect void drop table ( string . . . name ) { jdbc test utils . drop table ( this . jdbc template , names ) ; }
protect string [ ] modify location ( class < ? > clazz , string . . . location ) { return test context resource utils . convert to classpath resource path ( clazz , location ) ; }
public string to string ( ) { return new to string creator ( this ) . append ( `` test class `` , this . test class ) . append ( `` test instance `` , this . test instance ) . append ( `` test method `` , this . test method ) . append ( `` test exception `` , this . test exception ) . append ( `` merge context configuration `` , this . merge context configuration ) . append ( `` attribute `` , this . attribute ) . to string ( ) ; }
protect void inject dependency ( test context test context ) throw exception { object bean = test context . get test instance ( ) ; class < ? > clazz = test context . get test class ( ) ; autowire capable bean factory bean factory = test context . get application context ( ) . get autowire capable bean factory ( ) ; bean factory . autowire bean property ( bean , autowire capable bean factory . autowire_no , false ) ; bean factory . initialize bean ( bean , clazz . get name ( ) + autowire capable bean factory . original_instance_suffix ) ; test context . remove attribute ( reinject_dependencies_attribute ) ; }
public static void end ( ) { require current transaction context ( ) . end transaction ( ) ; }
public static void fail ( string message , @ nullable object expect , @ nullable object actual ) { throw new assertion error ( message + `` expect : < `` + expect + `` > but be : < `` + actual + `` > `` ) ; }
public void assert number ( byte [ ] content , @ nullable string encoding , double expect value ) throw exception { double actual = evaluate xpath ( content , encode , double . class ) ; assertion error . assert equal ( `` x path `` + this . expression , expect value , actual ) ; }
public < t > t evaluate xpath ( byte [ ] content , @ nullable string encoding , class < t > target class ) throw exception { document document = parse xml byte array ( content , encode ) ; return evaluate xpath ( document , to q name ( target class ) , target class ) ; }
protect string get request detail ( ) { string builder sb = new string builder ( ) ; sb . append ( this . request . size ( ) ) . append ( `` request ( s ) execute `` ) ; if ( ! this . request . be empty ( ) ) { sb . append ( `` : \n `` ) ; for ( client http request request : this . request ) { sb . append ( request . to string ( ) ) . append ( `` \n `` ) ; } } else { sb . append ( `` . \n `` ) ; } return sb . to string ( ) ; }
public request matcher be array ( ) { return new abstract json path request matcher ( ) { @ override protect void match internal ( mock client http request request ) throw i o exception , parse exception { json path request matcher . this . json path helper . assert value be array ( request . get body a string ( ) ) ; } } ; }
public request matcher exists ( ) { return ( xpath request matcher ) request - > this . xpath helper . exists ( request . get body a byte ( ) , default_encoding ) ; }
public request matcher boolean value ( boolean value ) { return ( xpath request matcher ) request - > this . xpath helper . assert boolean ( request . get body a byte ( ) , default_encoding , value ) ; }
public byte [ ] get request body content ( ) { return this . request body . block ( this . timeout ) ; }
public int get raw status code ( ) { return this . response . get raw status code ( ) ; }
public byte [ ] get response body content ( ) { return this . response body . block ( this . timeout ) ; }
public mock http servlet request builder accept ( string . . . medium type ) { assert . not empty ( medium type , `` 'media type ' must not be empty `` ) ; this . header . set ( `` accept `` , string . join ( `` , `` , medium type ) ) ; return this ; }
public mock http servlet request builder query param ( string name , string . . . value ) { param ( name , value ) ; this . query params . add all ( name , arrays . a list ( value ) ) ; return this ; }
public mock http servlet request builder locale ( locale . . . locale ) { assert . not empty ( locale , `` 'locales ' must not be empty `` ) ; this . locale . add all ( array . a list ( locale ) ) ; return this ; }
public result matcher version ( string name , int version ) { return result - > { cookie cookie = get cookie ( result , name ) ; assert equal ( `` response cookie ' `` + name + `` ' version `` , version , cookie . get version ( ) ) ; } ; }
public result matcher method name ( string name ) { return result - > { handler method handler method = get handler method ( result ) ; assert equal ( `` handler method `` , name , handler method . get method ( ) . get name ( ) ) ; } ; }
public result matcher exists ( ) { return result - > this . json path helper . exists ( get content ( result ) ) ; }
public static result matcher redirect url ( string expect url ) { return result - > assert equal ( `` redirect url `` , expect url , result . get response ( ) . get redirect url ( ) ) ; }
public static < t > result matcher json path ( string expression , matcher < t > matcher ) { return new json path result matcher ( expression ) . value ( matcher ) ; }
protect void print resolve exception ( @ nullable exception resolve exception ) throw exception { if ( resolve exception == null ) { this . printer . print value ( `` type `` , null ) ; } else { this . printer . print value ( `` type `` , resolve exception . get class ( ) . get name ( ) ) ; } }
protect void print flash map ( flash map flash map ) throw exception { if ( object utils . be empty ( flash map ) ) { this . printer . print value ( `` attribute `` , null ) ; } else { flash map . for each ( ( name , value ) - > { this . printer . print value ( `` attribute `` , name ) ; this . printer . print value ( `` value `` , value ) ; } ) ; } }
public static body builder method ( string http method , string uri , object . . . var ) { return new default body builder ( http method , to uri ( uri , var ) ) ; }
public web test client . response spec value ( string name , consumer < string > consumer ) { string value = get cookie ( name ) . get value ( ) ; this . exchange result . assert with diagnostics ( ( ) - > consumer . accept ( value ) ) ; return this . response spec ; }
public object get mock server result ( ) { return this . mock server result ; }
public static cache control empty ( ) { return new cache control ( ) ; }
public static cache control max age ( long max age , time unit unit ) { return max age ( duration . of second ( unit . to second ( max age ) ) ) ; }
public cache control s max age ( long s max age , time unit unit ) { return s max age ( duration . of second ( unit . to second ( s max age ) ) ) ; }
public void set read timeout ( int read timeout ) { this . read timeout = read timeout ; }
protect medium type get content type ( http message input message ) { medium type content type = input message . get header ( ) . get content type ( ) ; return ( content type ! = null ? content type : medium type . application_octet_stream ) ; }
protected list < mime type > get mime type ( ) { return this . mime type ; }
public void set charset ( charset charset ) { assert . not null ( charset , `` charset must not be null `` ) ; this . charset = charset ; }
public void set max in memory size ( int byte count ) { this . line decoder . set max in memory size ( byte count ) ; }
public jackson2 object mapper builder find module via service loader ( boolean find module ) { this . find modules via service loader = find module ; return this ; }
public boolean is1xx informational ( ) { return ( series ( ) == series . informational ) ; }
public static medium type a medium type ( mime type mime type ) { if ( mime type instanceof medium type ) { return ( medium type ) mime type ; } return new medium type ( mime type . get type ( ) , mime type . get subtype ( ) , mime type . get parameter ( ) ) ; }
public static header builder < ? > head ( uri url ) { return method ( http method . head , url ) ; }
public static header builder < ? > option ( uri url ) { return method ( http method . option , url ) ; }
public static body builder status ( http status status ) { assert . not null ( status , `` http status must not be null `` ) ; return new default builder ( status ) ; }
public void on all data read ( ) { rs read logger . trace ( get log prefix ( ) + `` on all data read `` ) ; this . state . get ( ) . on all data read ( this ) ; }
public string get log prefix ( ) { return this . log prefix ; }
protect void write pause ( ) { }
protect void write fail ( throwable ex ) { }
public void set status code value ( @ nullable integer status code ) { if ( this . state . get ( ) ! = state . commit ) { this . status code = status code ; } }
public void set buffer size ( int buffer size ) { assert . be true ( buffer size > 0 , `` buffer size must be large than zero `` ) ; this . buffer size = buffer size ; }
public string get servlet path ( ) { return this . servlet path ; }
public void set hessian2 reply ( boolean hessian2 ) { this . proxy factory . set hessian2 reply ( hessian2 ) ; }
public void prepare ( ) throw remote lookup failure exception { try { this . hessian proxy = create hessian proxy ( this . proxy factory ) ; } catch ( malformed u r l exception ex ) { throw new remote lookup failure exception ( `` service url [ `` + get service url ( ) + `` ] be invalid `` , ex ) ; } }
public void set content type ( string content type ) { assert . not null ( content type , `` 'content type ' must not be null `` ) ; this . content type = content type ; }
protect void do write remote invocation ( remote invocation invocation , object output stream oos ) throw i o exception { oos . write object ( invocation ) ; }
public void set endpoint feature ( web service feature . . . endpoint feature ) { this . endpoint feature = endpoint feature ; }
public void set endpoint address ( @ nullable string endpoint address ) { this . endpoint address = endpoint address ; }
public void set lookup service on startup ( boolean lookup service on startup ) { this . lookup service on startup = lookup service on startup ; }
public void set base path ( string base path ) { this . base path = base path ; }
protect void handle match ( string key , medium type medium type ) { }
public void set ignore accept header ( boolean ignore accept header ) { this . ignore accept header = ignore accept header ; }
protect medium type lookup medium type ( string extension ) { return this . medium type . get ( extension . to lower case ( locale . english ) ) ; }
public final string get header name ( ) { return this . header name ; }
public final void set direct field access ( boolean direct field access ) { this . direct field access = direct field access ; }
public boolean be direct field access ( ) { return this . direct field access ; }
public final property editor registrar [ ] get property editor registrar ( ) { return this . property editor registrar ; }
public void set attribute name prefix ( @ nullable string attribute name prefix ) { this . attribute name prefix = ( attribute name prefix ! = null ? attribute name prefix : `` `` ) ; }
public mono < void > bind ( server web exchange exchange ) { return get value to bind ( exchange ) . do on next ( value - > do bind ( new mutable property value ( value ) ) ) . then ( ) ; }
public boolean have message body ( ) throw i o exception { http status status = http status . resolve ( get raw status code ( ) ) ; if ( status ! = null & & ( status . is1xx informational ( ) || status == http status . no_content || status == http status . not_modified ) ) { return false ; } if ( get header ( ) . get content length ( ) == 0 ) { return false ; } return true ; }
public string get status text ( ) { return this . status text ; }
public type get target type ( ) { return this . target type ; }
public void close web application context ( servlet context servlet context ) { servlet context . log ( `` closing spring root web application context `` ) ; try { if ( this . context instanceof configurable web application context ) { ( ( configurable web application context ) this . context ) . close ( ) ; } } finally { class loader ccl = thread . current thread ( ) . get context class loader ( ) ; if ( ccl == context loader . class . get class loader ( ) ) { current context = null ; } else if ( ccl ! = null ) { current context per thread . remove ( ccl ) ; } servlet context . remove attribute ( web application context . root_web_application_context_attribute ) ; } }
public void context destroy ( servlet context event event ) { close web application context ( event . get servlet context ( ) ) ; context cleanup listener . cleanup attribute ( event . get servlet context ( ) ) ; }
protect final void register request destruction callback ( string name , runnable callback ) { assert . not null ( name , `` name must not be null `` ) ; assert . not null ( callback , `` callback must not be null `` ) ; synchronize ( this . request destruction callback ) { this . request destruction callback . put ( name , callback ) ; } }
public void set task executor ( async task executor task executor ) { this . task executor = task executor ; }
public boolean be concurrent handle start ( ) { return ( this . async web request ! = null & & this . async web request . be async start ( ) ) ; }
public void start callable processing ( callable < ? > callable , object . . . process context ) throw exception { assert . not null ( callable , `` callable must not be null `` ) ; start callable processing ( new web async task ( callable ) , process context ) ; }
public void on error ( callable < v > callback ) { this . error callback = callback ; }
public static void set request attribute ( @ nullable request attribute attribute , boolean inheritable ) { if ( attribute == null ) { reset request attribute ( ) ; } else { if ( inheritable ) { inheritable request attribute holder . set ( attribute ) ; request attribute holder . remove ( ) ; } else { request attribute holder . set ( attribute ) ; inheritable request attribute holder . remove ( ) ; } } }
protect string [ ] get default config location ( ) { if ( get namespace ( ) ! = null ) { return new string [ ] { default_config_location_prefix + get namespace ( ) + default_config_location_suffix } ; } else { return new string [ ] { default_config_location } ; } }
public string get short description ( ) { string builder sb = new string builder ( ) ; sb . append ( `` session= [ `` ) . append ( this . session id ) . append ( `` ] ; `` ) ; sb . append ( `` user= [ `` ) . append ( this . user name ) . append ( `` ] ; `` ) ; return sb . to string ( ) ; }
public string get client address ( ) { return this . client address ; }
public static void register web application scope ( configurable listable bean factory bean factory ) { register web application scope ( bean factory , null ) ; }
public static void register environment bean ( configurable listable bean factory bf , @ nullable servlet context sc ) { register environment bean ( bf , sc , null ) ; }
protect void init servlet context ( servlet context servlet context ) { }
public cors configuration combine ( @ nullable cors configuration other ) { if ( other == null ) { return this ; } cors configuration config = new cors configuration ( this ) ; config . set allow origin ( combine ( get allow origin ( ) , other . get allow origin ( ) ) ) ; config . set allow method ( combine ( get allow method ( ) , other . get allow method ( ) ) ) ; config . set allow header ( combine ( get allow header ( ) , other . get allow header ( ) ) ) ; config . set exposed header ( combine ( get expose header ( ) , other . get exposed header ( ) ) ) ; boolean allow credential = other . get allow credential ( ) ; if ( allow credential ! = null ) { config . set allow credential ( allow credential ) ; } long max age = other . get max age ( ) ; if ( max age ! = null ) { config . set max age ( max age ) ; } return config ; }
public string check origin ( @ nullable string request origin ) { if ( ! string utils . have text ( request origin ) ) { return null ; } if ( object utils . be empty ( this . allow origin ) ) { return null ; } if ( this . allow origin . contains ( all ) ) { if ( this . allow credential ! = boolean . true ) { return all ; } else { return request origin ; } } for ( string allow origin : this . allow origin ) { if ( request origin . equal ignore case ( allow origin ) ) { return request origin ; } } return null ; }
public void set include client info ( boolean include client info ) { this . include client info = include client info ; }
protect boolean be include header ( ) { return this . include header ; }
protect int get max payload length ( ) { return this . max payload length ; }
protected boolean should not filter async dispatch ( ) { return false ; }
public void set method param name ( string method param name ) { assert . have text ( method param name , `` 'method param name ' must not be empty `` ) ; this . method param name = method param name ; }
protect boolean be bind exception require ( web data binder binder , method parameter parameter ) { return be bind exception require ( parameter ) ; }
protect http status get response status ( ) { return this . response status ; }
public model map get default model ( ) { return this . default model ; }
public void set redirect model ( model map redirect model ) { this . redirect model = redirect model ; }
public string get storage description ( ) { if ( this . file item . be in memory ( ) ) { return `` in memory `` ; } else if ( this . file item instanceof disk file item ) { return `` at [ `` + ( ( disk file item ) this . file item ) . get store location ( ) . get absolute path ( ) + `` ] `` ; } else { return `` on disk `` ; } }
protect multipart resolver lookup multipart resolver ( http servlet request request ) { return lookup multipart resolver ( ) ; }
protect multipart resolver lookup multipart resolver ( ) { web application context wac = web application context utils . get web application context ( get servlet context ( ) ) ; string bean name = get multipart resolver bean name ( ) ; if ( wac ! = null & & wac . contains bean ( bean name ) ) { if ( logger . be debug enable ( ) ) { logger . debug ( `` use multipart resolver ' `` + bean name + `` ' for multipart filter `` ) ; } return wac . get bean ( bean name , multipart resolver . class ) ; } else { return this . default multipart resolver ; } }
public web http handler builder filter ( consumer < list < web filter > > consumer ) { consumer . accept ( this . filter ) ; update filter ( ) ; return this ; }
public void set warn log category ( string logger name ) { this . warn logger = log factory . get log ( logger name ) ; }
public list < medium type > get support medium type ( ) { return this . supported medium type ; }
public method parameter get method parameter ( ) { return this . parameter ; }
public duration get cookie max age ( ) { return this . cookie max age ; }
public string get header name ( ) { return this . header name ; }
public medium type get content type ( ) { return this . content type ; }
protect void handle content overflow ( int content cache limit ) { }
public integer get cookie max age ( ) { return this . cookie max age ; }
public boolean be strict encode ( ) { return this . strict encoding ; }
public static string html unescape ( string input ) { return new html character entity decoder ( character entity reference , input ) . decode ( ) ; }
protect final boolean be no more pattern ( ) { return this . next == null ; }
public static string decode ( string source , string encode ) { return string utils . uri decode ( source , charset . for name ( encode ) ) ; }
public static string extract file extension ( string path ) { int end = path . index of ( ' ? ' ) ; int fragment index = path . index of ( ' # ' ) ; if ( fragment index ! = -1 & & ( end == -1 || fragment index < end ) ) { end = fragment index ; } if ( end == -1 ) { end = path . length ( ) ; } int begin = path . last index of ( '/ ' , end ) + 1 ; int param index = path . index of ( ' ; ' , begin ) ; end = ( param index ! = -1 & & param index < end ? param index : end ) ; int ext index = path . last index of ( ' . ' , end ) ; if ( ext index ! = -1 & & ext index > begin ) { return path . substring ( ext index + 1 , end ) ; } return null ; }
public void set remove semicolon content ( boolean remove semicolon content ) { this . remove semicolon content = remove semicolon content ; }
public string remove semicolon content ( string request uri ) { return ( this . remove semicolon content ? remove semicolon content internal ( request uri ) : remove jsessionid ( request uri ) ) ; }
public static cookie get cookie ( http servlet request request , string name ) { assert . not null ( request , `` request must not be null `` ) ; cookie [ ] cooky = request . get cooky ( ) ; if ( cooky ! = null ) { for ( cookie cookie : cooky ) { if ( name . equal ( cookie . get name ( ) ) ) { return cookie ; } } } return null ; }
public static boolean be valid origin ( http request request , collection < string > allow origin ) { assert . not null ( request , `` request must not be null `` ) ; assert . not null ( allow origin , `` allow origin must not be null `` ) ; string origin = request . get header ( ) . get origin ( ) ; if ( origin == null || allow origin . contains ( `` * `` ) ) { return true ; } else if ( collection utils . be empty ( allow origin ) ) { return be same origin ( request ) ; } else { return allow origin . contains ( origin ) ; } }
public void set file storage directory ( path file storage directory ) throw i o exception { assert . not null ( file storage directory , `` file storage directory must not be null `` ) ; this . file storage = file storage . from path ( file storage directory ) ; }
protect void init type writer ( ) { this . type writer . clear ( ) ; if ( ! this . register default ) { return ; } this . type writer . add all ( get base typed writer ( ) ) ; extend type writer ( this . typed writer ) ; }
protect charset get charset ( @ nullable medium type content type ) { if ( content type ! = null & & content type . get charset ( ) ! = null ) { return content type . get charset ( ) ; } else { return standard charsets . utf_8 ; } }
public resource chain registration add transformer ( resource transformer transformer ) { assert . not null ( transformer , `` the provided resource transformer should not be null `` ) ; this . transformer . add ( transformer ) ; if ( transformer instanceof cs link resource transformer ) { this . have css link transformer = true ; } return this ; }
public url base view resolver registration script template ( ) { if ( ! check bean of type ( script template configurer . class ) ) { throw new bean initialization exception ( `` in addition to a script template view resolver `` + `` there must also be a single script template config bean in this web application context `` + `` ( or it parent ) : script template configurer be the usual implementation . `` + `` this bean may be give any name . `` ) ; } script registration registration = new script registration ( ) ; url base view resolver resolver = registration . get view resolver ( ) ; if ( this . application context ! = null ) { resolver . set application context ( this . application context ) ; } this . view resolvers . add ( resolver ) ; return registration ; }
public static exchange filter function basic authentication ( string username , string password ) { string encode credential = http header . encode basic auth ( username , password , null ) ; return ( request , next ) - > next . exchange ( client request . from ( request ) . header ( header - > header . set basic auth ( encoded credential ) ) . build ( ) ) ; }
public http method get method ( ) { return this . method ; }
public uri get uri ( ) { return this . uri ; }
public http header get header ( ) { return this . header ; }
public void set use case sensitive match ( boolean case sensitive match ) { this . pattern parser . set case sensitive ( case sensitive match ) ; }
public resolvable type get return type ( ) { return this . return type ; }
public boolean have exception handler ( ) { return ( this . exception handler ! = null ) ; }
public void set content coding ( list < string > coding ) { assert . not empty ( coding , `` at least one content coding expect `` ) ; this . content coding . clear ( ) ; this . content coding . add all ( coding ) ; }
public version resource resolver add content version strategy ( string . . . path pattern ) { add version strategy ( new content version strategy ( ) , path pattern ) ; return this ; }
public composite request condition combine ( composite request condition other ) { if ( be empty ( ) & & other . be empty ( ) ) { return this ; } else if ( other . be empty ( ) ) { return this ; } else if ( be empty ( ) ) { return other ; } else { assert number of condition ( other ) ; request condition holder [ ] combine condition = new request condition holder [ get length ( ) ] ; for ( int i = 0 ; i < get length ( ) ; i++ ) { combined condition [ i ] = this . request condition [ i ] . combine ( other . request condition [ i ] ) ; } return new composite request condition ( combined condition ) ; } }
public composite request condition get matching condition ( server web exchange exchange ) { if ( be empty ( ) ) { return this ; } request condition holder [ ] match condition = new request condition holder [ get length ( ) ] ; for ( int i = 0 ; i < get length ( ) ; i++ ) { match condition [ i ] = this . request condition [ i ] . get matching condition ( exchange ) ; if ( match condition [ i ] == null ) { return null ; } } return new composite request condition ( matching condition ) ; }
public int compare to ( composite request condition other , server web exchange exchange ) { if ( be empty ( ) & & other . be empty ( ) ) { return 0 ; } else if ( be empty ( ) ) { return 1 ; } else if ( other . be empty ( ) ) { return -1 ; } else { assert number of condition ( other ) ; for ( int i = 0 ; i < get length ( ) ; i++ ) { int result = this . request condition [ i ] . compare to ( other . request condition [ i ] , exchange ) ; if ( result ! = 0 ) { return result ; } } return 0 ; } }
public set < medium type expression > get expression ( ) { return new link hash set < > ( this . expression ) ; }
public mono < handler method > get handler internal ( server web exchange exchange ) { this . mapping registry . acquire read lock ( ) ; try { handler method handler method ; try { handler method = lookup handler method ( exchange ) ; } catch ( exception ex ) { return mono . error ( ex ) ; } if ( handler method ! = null ) { handler method = handler method . create with resolved bean ( ) ; } return mono . just or empty ( handler method ) ; } finally { this . mapping registry . release read lock ( ) ; } }
public int compare to ( request mapping info other , server web exchange exchange ) { int result = this . pattern condition . compare to ( other . get patterns condition ( ) , exchange ) ; if ( result ! = 0 ) { return result ; } result = this . params condition . compare to ( other . get params condition ( ) , exchange ) ; if ( result ! = 0 ) { return result ; } result = this . header condition . compare to ( other . get header condition ( ) , exchange ) ; if ( result ! = 0 ) { return result ; } result = this . consume condition . compare to ( other . get consumes condition ( ) , exchange ) ; if ( result ! = 0 ) { return result ; } result = this . produce condition . compare to ( other . get produces condition ( ) , exchange ) ; if ( result ! = 0 ) { return result ; } result = this . method condition . compare to ( other . get method condition ( ) , exchange ) ; if ( result ! = 0 ) { return result ; } result = this . custom condition holder . compare to ( other . custom condition holder , exchange ) ; if ( result ! = 0 ) { return result ; } return 0 ; }
public charset get default charset ( ) { return this . default charset ; }
public object get actual value ( ) { return this . actual value ; }
public void set propagate query ( boolean propagate query ) { this . propagate query = propagate query ; }
public string get log prefix ( ) { return this . log prefix ; }
public predicate < string > get session attribute predicate ( ) { return this . session attribute predicate ; }
public data buffer get payload ( ) { return this . payload ; }
public interceptor registration exclude path pattern ( string . . . pattern ) { return exclude path pattern ( array . a list ( pattern ) ) ; }
protect int get order ( ) { return this . order ; }
protected list < object > get interceptor ( ) { return this . registration . stream ( ) . sort ( interceptor_order_comparator ) . map ( interceptor registration : : get interceptor ) . collect ( collector . to list ( ) ) ; }
public view controller registration add view controller ( string url path ) { view controller registration registration = new view controller registration ( url path ) ; registration . set application context ( this . application context ) ; this . registration . add ( registration ) ; return registration ; }
protect object create default strategy ( application context context , class < ? > clazz ) { return context . get autowire capable bean factory ( ) . create bean ( clazz ) ; }
public void set context class ( class < ? > context class ) { this . context class = context class ; }
public string get context id ( ) { return this . context id ; }
public void set dispatch trace request ( boolean dispatch trace request ) { this . dispatch trace request = dispatch trace request ; }
protect void init framework servlet ( ) throw servlet exception { }
public void set map handler ( set < ? > map handler ) { this . map handler = map handler ; }
public void set detect handler method in ancestor context ( boolean detect handler method in ancestor context ) { this . detect handler method in ancestor context = detect handler method in ancestor context ; }
public void after property set ( ) { init handler method ( ) ; }
protect string [ ] determine url for handler ( string bean name ) { list < string > urls = new array list < > ( ) ; if ( bean name . start with ( `` / `` ) ) { urls . add ( bean name ) ; } string [ ] alias = obtain application context ( ) . get alias ( bean name ) ; for ( string alias : alias ) { if ( alias . start with ( `` / `` ) ) { urls . add ( alias ) ; } } return string utils . to string array ( urls ) ; }
public void set exception mapping ( property mapping ) { this . exception mapping = mapping ; }
public void set status code ( property status code ) { for ( enumeration < ? > enumeration = status code . property name ( ) ; enumeration . have more element ( ) ; ) { string view name = ( string ) enumeration . next element ( ) ; integer status code = integer . value of ( status code . get property ( view name ) ) ; this . status code . put ( view name , status code ) ; } }
public object get handler ( ) { return this . handler ; }
public void set language tag compliant ( boolean language tag compliant ) { this . language tag compliant = language tag compliant ; }
public boolean be ignore invalid locale ( ) { return this . ignore invalid locale ; }
public void set url decode ( boolean url decode ) { this . url path helper . set url decode ( url decode ) ; }
protect object adapt argument if necessary ( @ nullable object arg , method parameter parameter ) { if ( parameter . get parameter type ( ) == optional . class ) { if ( arg == null || ( arg instanceof collection & & ( ( collection < ? > ) arg ) . be empty ( ) ) || ( arg instanceof object [ ] & & ( ( object [ ] ) arg ) . length == 0 ) ) { return optional . empty ( ) ; } else { return optional . of ( arg ) ; } } return arg ; }
public void set response body advice ( @ nullable list < response body advice < ? > > response body advice ) { this . response body advice . clear ( ) ; if ( response body advice ! = null ) { this . response body advice . add all ( response body advice ) ; } }
public reactive adapter registry get reactive adapter registry ( ) { return this . reactive adapter registry ; }
public synchronize void on timeout ( runnable callback ) { this . timeout callback . set delegate ( callback ) ; }
public void send ( sse event builder builder ) throw i o exception { set < data with medium type > data to send = builder . build ( ) ; synchronize ( this ) { for ( data with medium type entry : data to send ) { super . send ( entry . get data ( ) , entry . get medium type ( ) ) ; } } }
protect void handle match ( request mapping info info , string lookup path , http servlet request request ) { super . handle match ( info , lookup path , request ) ; string best pattern ; map < string , string > uri variable ; set < string > pattern = info . get patterns condition ( ) . get pattern ( ) ; if ( pattern . be empty ( ) ) { best pattern = lookup path ; uri variable = collection . empty map ( ) ; } else { best pattern = pattern . iterator ( ) . next ( ) ; uri variable = get path matcher ( ) . extract uri template variable ( best pattern , lookup path ) ; } request . set attribute ( best_matching_pattern_attribute , best pattern ) ; if ( be matrix variable content available ( ) ) { map < string , multi value map < string , string > > matrix var = extract matrix variable ( request , uri variable ) ; request . set attribute ( handler mapping . matrix_variables_attribute , matrix var ) ; } map < string , string > decode uri variable = get url path helper ( ) . decode path variable ( request , uri variable ) ; request . set attribute ( handler mapping . uri_template_variables_attribute , decode uri variable ) ; if ( ! info . get produces condition ( ) . get producible medium type ( ) . be empty ( ) ) { set < medium type > medium type = info . get produces condition ( ) . get producible medium type ( ) ; request . set attribute ( producible_media_types_attribute , medium type ) ; } }
public final web application context get web application context ( ) { return this . web application context ; }
protected time zone get fallback time zone ( ) { if ( jstl present ) { time zone time zone = jstl locale resolver . get jstl time zone ( get request ( ) , get servlet context ( ) ) ; if ( time zone ! = null ) { return time zone ; } } return null ; }
public string get path to servlet ( ) { string path = this . url path helper . get originate context path ( this . request ) ; if ( string utils . have text ( this . url path helper . get path within servlet mapping ( this . request ) ) ) { path += this . url path helper . get originate servlet path ( this . request ) ; } return path ; }
public static web application context find web application context ( http servlet request request ) { return find web application context ( request , request . get servlet context ( ) ) ; }
public static locale get locale ( http servlet request request ) { locale resolver locale resolver = get locale resolver ( request ) ; return ( locale resolver ! = null ? locale resolver . resolve locale ( request ) : request . get locale ( ) ) ; }
public final boolean be use cache control header ( ) { return this . use cache control header ; }
public string get path ( ) { return this . path ; }
public string get delimiter ( ) { return this . delimiter ; }
public void set delimiter ( string delimiter ) { this . delimiter = delimiter ; }
protect string get model attribute ( ) { return this . model attribute ; }
public void set message ( message source resolvable message ) { this . message = message ; }
public void set argument ( object argument ) { this . argument = argument ; }
public void set scope ( string scope ) { this . scope = scope ; }
protect void write message ( string msg ) throw i o exception { this . page context . get out ( ) . write ( string . value of ( msg ) ) ; }
public void set value ( object value ) { this . value = value ; }
public void set context ( string context ) { if ( context . start with ( `` / `` ) ) { this . context = context ; } else { this . context = `` / `` + context ; } }
public void set default theme name ( string default theme name ) { this . default theme name = default theme name ; }
protect byte array output stream create temporary output stream ( ) { return new byte array output stream ( output_byte_array_initial_size ) ; }
public void set strip extension ( boolean strip extension ) { this . strip extension = strip extension ; }
public void set feed type ( string fee type ) { this . fee type = feed type ; }
protect markup template engine autodetect markup template engine ( ) throw bean exception { try { return bean factory utils . bean of type include ancestor ( obtain application context ( ) , groovy markup config . class , true , false ) . get template engine ( ) ; } catch ( no such bean definition exception ex ) { throw new application context exception ( `` expect a single groovy markup config bean in the current `` + `` servlet web application context or the parent root context : groovy markup configurer be `` + `` the usual implementation . this bean may have any name . `` , ex ) ; } }
protect boolean be context require ( ) { return false ; }
public void set definition ( string . . . definition ) { this . definition = definition ; }
public void set model key ( string model key ) { this . model key = model key ; }
protect boolean be eligible for marshal ( string model key , object value ) { assert . state ( this . marshaller ! = null , `` no marshaller set `` ) ; class < ? > class to check = value . get class ( ) ; if ( value instanceof j a x b element ) { class to check = ( ( j a x b element < ? > ) value ) . get declared type ( ) ; } return this . marshaller . support ( class to check ) ; }
public void after property set ( ) throw bean exception { if ( be cache ( ) ) { init factory ( ) ; } }
public void set transformer factory class ( class < ? extend transformer factory > transformer factory class ) { this . transformer factory class = transformer factory class ; }
protect synchronized final int args ( ) throw s q l exception { check context ( ) ; return args ; }
public string get system id ( ) { return m system id ; }
public string get d t d type ( ) { / * ! ! ! tbi : 07- sep-2004 , t sa : need to figure out an efficient way * to pass this info . . . * / return `` cdata `` ; }
public string get root name ( ) { return m root name ; }
public boolean be property support ( string name ) { / * no way to support properly via stax1 interface . . . but * let 's approximate : we can be sure it be support , if * we can access value without illegal argument exception * / try { / * object x = * / m reader . get property ( name ) ; } catch ( illegal argument exception iae ) { return false ; } return true ; }
public static base64 variant get default variant ( ) { return mime ; }
public void clean ( ) { for ( int i = the atts . get length ( ) - 1 ; i > = 0 ; i -- ) { string name = the atts . get local name ( i ) ; if ( the atts . get value ( i ) == null || name == null || name . length ( ) == 0 ) { the atts . remove attribute ( i ) ; continue ; } } }
public string local name ( ) { return the local name ; }
public void parent ( string name , string parent name ) { element type child = get element type ( name ) ; element type parent = get element type ( parent name ) ; if ( child == null ) { throw new error ( `` no child `` + name + `` for parent `` + parent name ) ; } if ( parent == null ) { throw new error ( `` no parent `` + parent name + `` for child `` + name ) ; } child . set parent ( parent ) ; }
protect collection < file > get provide file ( ) { final collection < file > file = new hash set < file > ( ) ; for ( final task map . task hole collection provider : file collection provider task ) for ( final file file : ( ( file collection provider task ) collection provider . get task ( ) ) . get file ( ) ) file . add ( file ) ; for ( final task map . task hole single provider : file provider task ) file . add ( ( ( file provider task ) single provider . get task ( ) ) . get file ( ) ) ; return file ; }
public void set binding ( object reference ) { bind = reference ; }
public void set factory ( object reference ) { factory = reference ; }
public factory provider task get factory provider task ( ) { return ( factory provider task_ == null ) ? null : ( factory provider task ) factory provider task_ . get task ( ) ; }
public string get service host ( string service name , integer service port ) { return ambassador container . get host ( ) ; }
public self with fix expose port ( int host port , int container port , internet protocol protocol ) { super . add fix exposed port ( host port , container port , protocol ) ; return self ( ) ; }
protect logger logger ( ) { return docker logger factory . get logger ( this . get docker image name ( ) ) ; }
public image from dockerfile with dockerfile path ( string relative path from build context directory ) { this . docker file path = optional . of ( relative path from build context directory ) ; return this ; }
public image from dockerfile with dockerfile ( path dockerfile ) { this . dockerfile = optional . of ( dockerfile ) ; return this ; }
public static string run shell command ( string . . . command ) { string join command = string . join ( `` `` , command ) ; logger . debug ( `` execute shell command : ` { } ` `` , join command ) ; try { process result result = new process executor ( ) . command ( command ) . read output ( true ) . exit value normal ( ) . execute ( ) ; return result . output u t f8 ( ) . trim ( ) ; } catch ( i o exception | interrupt exception | timeout exception | invalid exit value exception e ) { throw new shell command exception ( `` exception when execute `` + join command , e ) ; } }
public void remove network by id ( string id ) { remove network ( id ) ; }
public static void set context class loader ( class loader loader ) { context class loader = loader ; }
public < t > list < t > load service provider ( class < t > iface ) { list < t > provider = new array list < t > ( ) ; provider . add all ( load dynamic service provider ( iface ) ) ; provider . add all ( load static service provider ( iface ) ) ; return provider ; }
public int count ( int b ) { return count [ b & 0xff ] ; }
public int count eight bit ( ) { return count ( 128 , 256 ) ; }
public string [ ] get command ( ) { return command ; }
public string get command append operator ( ) { return command append operator ; }
public static parser try to find existing leaf parser ( class clazz , parse context context ) { parser p = context . get ( parser . class ) ; if ( equal ( p , clazz ) ) { return p ; } parser return parser = null ; if ( p ! = null ) { if ( p instanceof parser decorator ) { p = find in decorate ( ( parser decorator ) p , clazz ) ; } if ( equal ( p , clazz ) ) { return p ; } if ( p instanceof composite parser ) { return parser = find in composite ( ( composite parser ) p , clazz , context ) ; } } if ( return parser ! = null & & equal ( return parser , clazz ) ) { return return parser ; } return null ; }
public int read ( ) throw i o exception { int find = super . read ( ) ; this . count += ( find > = 0 ) ? 1 : 0 ; return find ; }
public static short get short l e ( byte [ ] data , int offset ) { return ( short ) get u short l e ( data , offset ) ; }
public static long get u int b e ( byte [ ] data ) { return get u int b e ( data , 0 ) ; }
public void add resource ( closeable resource ) { resource . add first ( resource ) ; }
public < t extend closeable > t get resource ( class < t > klass ) { for ( closeable resource : resource ) { if ( klass . be assignable from ( resource . get class ( ) ) ) { return ( t ) resource ; } } return null ; }
public boolean have enough text ( ) { return false ; }
public void add ( string ngram ) { add ( ngram , 1 ) ; }
public string translate ( string text , string source language , string target language ) { return null ; }
public void set ( property property , int value ) { if ( property . get primary property ( ) . get property type ( ) ! = property . property type . simple ) { throw new property type exception ( property . property type . simple , property . get primary property ( ) . get property type ( ) ) ; } if ( property . get primary property ( ) . get value type ( ) ! = property . value type . integer ) { throw new property type exception ( property . value type . integer , property . get primary property ( ) . get value type ( ) ) ; } set ( property , integer . to string ( value ) ) ; }
public static byte [ ] decode ( string hex value ) { return decode ( hex value . to char array ( ) ) ; }
public medium type get supertype ( medium type type ) { if ( type == null ) { return null ; } else if ( inheritance . contains key ( type ) ) { return inheritance . get ( type ) ; } else if ( type . have parameter ( ) ) { return type . get base type ( ) ; } else if ( type . get subtype ( ) . end with ( `` +xml `` ) ) { return medium type . application_xml ; } else if ( type . get subtype ( ) . end with ( `` +zip `` ) ) { return medium type . application_zip ; } else if ( `` text `` . equal ( type . get type ( ) ) & & ! medium type . text_plain . equal ( type ) ) { return medium type . text_plain ; } else if ( type . get type ( ) . contains ( `` empty `` ) & & ! medium type . empty . equal ( type ) ) { return medium type . empty ; } else if ( ! medium type . octet_stream . equal ( type ) ) { return medium type . octet_stream ; } else { return null ; } }
public static boolean be valid ( string name ) { if ( name == null ) { throw new illegal argument exception ( `` name be miss `` ) ; } boolean slash = false ; for ( int i = 0 ; i < name . length ( ) ; i++ ) { char ch = name . char at ( i ) ; if ( ch < = ' ' || ch > = 127 || ch == ' ( ' || ch == ' ) ' || ch == ' < ' || ch == ' > ' || ch == ' @ ' || ch == ' , ' || ch == ' ; ' || ch == ' : ' || ch == '\\ ' || ch == ' `` ' || ch == ' [ ' || ch == ' ] ' || ch == ' ? ' || ch == '= ' ) { return false ; } else if ( ch == '/ ' ) { if ( slash || i == 0 || i + 1 == name . length ( ) ) { return false ; } slash = true ; } } return slash ; }
public static mime type create ( document document ) throw mime type exception { mime type mime type = new mime type ( ) ; new mime type reader ( mime type ) . read ( document ) ; mime type . init ( ) ; return mime type ; }
public void set medium type registry ( medium type registry registry ) { this . registry = registry ; }
public void set fallback ( parser fallback ) { this . fallback = fallback ; }
public void end embed document ( content handler content handler , metadata metadata ) throw s a x exception { }
public void set maximum depth ( int depth ) { this . max depth = depth ; }
public static string get organzations regex ( ) { string builder sb = new string builder ( ) ; sb . append ( `` ( `` ) ; int i = 0 ; for ( string org : organization . key set ( ) ) { if ( i > 0 ) { sb . append ( `` | `` ) ; } sb . append ( org ) ; i++ ; } sb . append ( `` ) `` ) ; return sb . to string ( ) ; }
public matcher descend ( string namespace , string name ) { return fail ; }
public reader parse ( file file , metadata metadata ) throw i o exception { @ suppress warning ( `` deprecation `` ) input stream stream = tika input stream . get ( file , metadata ) ; return parse ( stream , metadata ) ; }
public reader parse ( url url ) throw i o exception { metadata metadata = new metadata ( ) ; input stream stream = tika input stream . get ( url , metadata ) ; return parse ( stream , metadata ) ; }
public int get max string length ( ) { return max string length ; }
public static string get filter stack trace ( throwable t ) { throwable cause = t ; if ( ( t instanceof tika exception ) & & t . get cause ( ) ! = null ) { cause = t . get cause ( ) ; } return get stack trace ( cause ) ; }
public static list < string > extract link ( string content ) { if ( content == null || content . length ( ) == 0 ) { return collection . empty list ( ) ; } list < string > extraction = new array list < string > ( ) ; final matcher matcher = links_pattern . matcher ( content ) ; while ( matcher . find ( ) ) { extraction . add ( matcher . group ( ) ) ; } return extraction ; }
public int get size ( ) { return size ; }
public byte [ ] get dir_uuid ( ) { return dir_uuid ; }
protect void set unknown offset ( long unknown_offset ) { this . unknown_offset = unknown_offset ; }
public byte [ ] get signature ( ) { return signature ; }
public int get index_root ( ) { return index_root ; }
protect void set system_uuid ( byte [ ] system_uuid ) { this . system_uuid = system_uuid ; }
protect void set size ( long size ) { this . size = size ; }
protect void set window per reset ( long window per reset ) { this . windows per reset = windows per reset ; }
public void set block llen ( long block_len ) { this . block_len = block_len ; }
public static void reset a e ( analysis engine ae ) { if ( ae ! = null ) { ae . destroy ( ) ; ae = null ; } }
public void set extract script ( boolean extract script ) { this . extract scripts = extract script ; }
public void set include header and footer ( boolean include header and footer ) { this . include header and footer = include header and footer ; }
public void set concatenate phonetic run ( boolean concatenate phonetic run ) { this . concatenate phonetic run = concatenate phonetic run ; }
public void set include miss row ( boolean include miss row ) { this . include miss row = include miss row ; }
public void set include slide master content ( boolean include slide master content ) { this . include slide master content = include slide master content ; }
public string get album artist ( ) { return null ; }
public string get disc ( ) { return null ; }
public j s o n object convert to j s o n object ( string json string ) { j s o n parser parser = new j s o n parser ( ) ; j s o n object json object = new j s o n object ( ) ; try { json object = ( j s o n object ) parser . parse ( json string ) ; } catch ( exception e ) { log . info ( e . get message ( ) , e ) ; } return json object ; }
public void set page seg mode ( string page seg mode ) { if ( ! page seg mode . match ( `` [ 0-9 ] |10|11|12|13 `` ) ) { throw new illegal argument exception ( `` invalid page segmentation mode `` ) ; } this . page seg mode = page seg mode ; }
public void add other tesseract config ( string key , string value ) { if ( key == null ) { throw new illegal argument exception ( `` key must not be null `` ) ; } if ( value == null ) { throw new illegal argument exception ( `` value must not be null `` ) ; } matcher m = allowable_other_params_pattern . matcher ( key ) ; if ( ! m . find ( ) ) { throw new illegal argument exception ( `` key contain illegal character : `` +key ) ; } m . reset ( value ) ; if ( ! m . find ( ) ) { throw new illegal argument exception ( `` value contain illegal character : `` +value ) ; } other tesseract config . put ( key . trim ( ) , value . trim ( ) ) ; }
public void set sort by position ( boolean v ) { default config . set sort by position ( v ) ; }
public float get ocr image scale ( ) { return ocr image scale ; }
public string get file path ( ) { return file path ; }
public int get min length ( ) { return this . min length ; }
public void set encoding ( string encode encode ) { this . encode = encoding ; }
public void set timeout ( int timeout ) { if ( timeout < 1 ) { throw new illegal argument exception ( `` invalid timeout `` ) ; } this . timeout = timeout ; }
public string get language ( ) { return null ; }
public long read w p long ( ) throw i o exception { int ch1 = in . read ( ) ; int ch2 = in . read ( ) ; int ch3 = in . read ( ) ; int ch4 = in . read ( ) ; if ( ( ch1 | ch2 | ch3 | ch4 ) < 0 ) { throw new e o f exception ( ) ; } return ( ( ch4 < < 24 ) + ( ch3 < < 16 ) + ( ch2 < < 8 ) + ( ch1 < < 0 ) ) ; }
public byte read w p byte ( ) throw i o exception { return in . read byte ( ) ; }
public void skip w p byte ( int num of byte ) throw i o exception { for ( int i = 0 ; i < num of byte ; i++ ) { read w p byte ( ) ; } }
public void set http only ( boolean http only ) { this . http only = http only ; }
public default void attribute replace ( servlet context attribute event scae ) { }
public boolean be permanent ( ) { return permanent ; }
public void set cache ( boolean cache ) { this . cache = cache ; }
public string get landing page ( ) { return land page ; }
public void set landing page ( string land page ) { this . landing page = landing page ; }
public void set require reauthentication ( boolean require ) { this . require reauthentication = require ; }
public string get auth type ( ) { return this . auth type ; }
public principal get principal ( ) { return this . principal ; }
public void set enable lookup ( boolean enable lookup ) { this . enable lookup = enable lookup ; set property ( `` enable lookup `` , string . value of ( enable lookup ) ) ; }
public void set port ( int port ) { set property ( `` port `` , string . value of ( port ) ) ; }
public void resume ( ) { try { if ( protocol handler ! = null ) { protocol handler . resume ( ) ; } } catch ( exception e ) { log . error ( sm . get string ( `` coyote connector . protocol handler resume fail `` ) , e ) ; } }
public int read ( final byte buffer b ) throw i o exception { check non block read ( ) ; if ( security util . be package protection enable ( ) ) { try { integer result = access controller . do privilege ( new privilege read buffer ( ib , b ) ) ; return result . int value ( ) ; } catch ( privileged action exception pae ) { exception e = pae . get exception ( ) ; if ( e instanceof i o exception ) { throw ( i o exception ) e ; } else { throw new runtime exception ( e . get message ( ) , e ) ; } } } else { return ib . read ( b ) ; } }
public void flush ( ) throw i o exception { boolean non block = check non block write ( ) ; ob . flush ( ) ; if ( non blocking ) { check register for write ( ) ; } }
public org . apache . coyote . request get coyote request ( ) { return this . coyote request ; }
public servlet input stream create input stream ( ) throw i o exception { if ( input stream == null ) { input stream = new coyote input stream ( input buffer ) ; } return input stream ; }
public void remove note ( string name ) { note . remove ( name ) ; }
public void clear cooky ( ) { cooky parse = true ; cooky convert = true ; cooky = null ; }
public void set request session id ( string id ) { this . request session id = id ; }
public string get decode request u r i ( ) { return coyote request . decode u r i ( ) . to string ( ) ; }
public void reset buffer ( ) { reset buffer ( false ) ; }
public static string get config path ( container container , string resource name ) { string buffer result = new string buffer ( ) ; container host = null ; container engine = null ; while ( container ! = null ) { if ( container instanceof host ) { host = container ; } else if ( container instanceof engine ) { engine = container ; } container = container . get parent ( ) ; } if ( host ! = null & & ( ( host ) host ) . get xml base ( ) ! = null ) { result . append ( ( ( host ) host ) . get xml base ( ) ) . append ( '/ ' ) ; } else { result . append ( `` conf/ `` ) ; if ( engine ! = null ) { result . append ( engine . get name ( ) ) . append ( '/ ' ) ; } if ( host ! = null ) { result . append ( host . get name ( ) ) . append ( '/ ' ) ; } } result . append ( resource name ) ; return result . to string ( ) ; }
public static service get service ( container container ) { while ( container ! = null & & ! ( container instanceof engine ) ) { container = container . get parent ( ) ; } if ( container == null ) { return null ; } return ( ( engine ) container ) . get service ( ) ; }
public enumeration < string > get parameter name ( ) { parse parameter ( ) ; return collection . enumeration ( parameter . key set ( ) ) ; }
protected boolean set special ( string name , object value ) { for ( int i = 0 ; i < special . length ; i++ ) { if ( special [ i ] . equal ( name ) ) { special attribute [ i ] = value ; return true ; } } return false ; }
public container [ ] find child ( ) { synchronize ( child ) { container result [ ] = new container [ child . size ( ) ] ; return child . value ( ) . to array ( result ) ; } }
public container listener [ ] find container listener ( ) { container listener [ ] result = new container listener [ 0 ] ; return listener . to array ( result ) ; }
public void set response character encode ( string response encode ) { / * * this ensure that the context response encoding be represent by a * unique string object . this enable the default servlet to * differentiate between a response use this default encode and one * that have be explicitly configure . * / if ( response encode == null ) { this . response encode = null ; } else { this . response encode = new string ( response encode ) ; } }
public void set use naming ( boolean use naming ) { this . use name = use name ; }
public void add application lifecycle listener ( object listener ) { int len = application lifecycle listener object . length ; object [ ] new listener = array . copy of ( application lifecycle listener object , len + 1 ) ; new listener [ len ] = listener ; application lifecycle listener object = new listener ; }
public void set copy x m l ( boolean copy x m l ) { this . copy x m l = copy x m l ; }
public void add message destination ref ( message destination ref mdr ) { get naming resource ( ) . add message destination ref ( mdr ) ; }
public string find role mapping ( string role ) { string real role = null ; synchronize ( role mapping ) { real role = role mapping . get ( role ) ; } if ( real role ! = null ) return real role ; else return role ; }
public string get jvm route ( ) { return jvm route id ; }
public void set unpack w a r ( boolean unpack w a r ) { this . unpack w a r = unpack w a r ; }
public javax . naming . context get global naming context ( ) { return this . global naming context ; }
public string get server number ( ) { return server info . get server number ( ) ; }
public void set server ( server server ) { this . server = server ; }
public void set available ( long available ) { long old available = this . available ; if ( available > system . current time millis ( ) ) this . available = available ; else this . available = 0l ; support . fire property change ( `` available `` , long . value of ( old available ) , long . value of ( this . available ) ) ; }
public void set servlet name ( string name ) { set name ( name ) ; }
public void set servlet ( servlet servlet ) { instance = servlet ; }
public void set container ( object container ) { this . container = container ; }
public void remove resource env ref ( string name ) { entry . remove ( name ) ; context resource env ref resource env ref = null ; synchronize ( resource env refs ) { resource env ref = resource env ref . remove ( name ) ; } if ( resource env ref ! = null ) { support . fire property change ( `` resource env ref `` , resource env ref , null ) ; resource env ref . set naming resource ( null ) ; } }
public void set allow ( final string input ) { final list < string > message = fill from input ( input , allow ) ; if ( message . be empty ( ) ) { return ; } for ( final string message : message ) { log . error ( message ) ; } throw new illegal argument exception ( sm . get string ( `` remote cidr filter . invalid `` , `` allow `` ) ) ; }
protect static string [ ] comma delimit list to string array ( string comma delimit string ) { return ( comma delimit string == null || comma delimit string . length ( ) == 0 ) ? new string [ 0 ] : comma separate value pattern . split ( comma delimit string ) ; }
public void set port header ( string port header ) { this . port header = port header ; }
protect boolean boolean parameter ( http servlet request request , string parameter , boolean the default , boolean html mode ) { string value = request . get parameter ( parameter ) ; boolean boolean value = the default ; if ( value ! = null ) { if ( html mode ) { if ( value . equal ( `` on `` ) ) { boolean value = true ; } } else if ( the default ) { if ( value . equal ( `` false `` ) ) { boolean value = false ; } } else if ( value . equal ( `` true `` ) ) { boolean value = true ; } } else if ( html mode ) boolean value = false ; return boolean value ; }
public void clear welcome file ( string host name , string context path , string version ) { host name = rename wildcard host ( host name ) ; context version context version = find context version ( host name , context path , version , false ) ; if ( context version == null ) { return ; } context version . welcome resource = new string [ 0 ] ; }
public void remove child ( string name ) throw m bean exception { if ( name ! = null ) { container container = do get manage resource ( ) ; container contain = container . find child ( name ) ; container . remove child ( contain ) ; } }
protect void destroy m bean ( ) { if ( log . be debug enable ( ) ) { log . debug ( `` destroy m bean for global jndi resource `` ) ; } }
public string create http connector ( string parent , string address , int port ) throw exception { return create connector ( parent , address , port , false , true ) ; }
public static synchronize m bean server create server ( ) { if ( mserver == null ) { mserver = registry . get registry ( null , null ) . get m bean server ( ) ; } return mserver ; }
public string [ ] get resource ( ) { context resource [ ] resource = ( ( name resource impl ) this . resource ) . find resource ( ) ; list < string > result = new array list < > ( ) ; for ( context resource context resource : resource ) { try { object name oname = m bean utils . create object name ( manage . get domain ( ) , context resource ) ; result . add ( oname . to string ( ) ) ; } catch ( malformed object name exception e ) { illegal argument exception iae = new illegal argument exception ( sm . get string ( `` naming resource m bean . create object name error . resource `` , context resource ) ) ; iae . init cause ( e ) ; throw iae ; } } return result . to array ( new string [ 0 ] ) ; }
public void set salt length ( int salt length ) { this . salt length = salt length ; }
public static void remove ( object cache object ) { class cache . remove ( cached object ) ; }
public void set session id col ( string session id col ) { string old session id col = this . session id col ; this . session id col = session id col ; support . fire property change ( `` session id col `` , old session id col , this . session id col ) ; }
public string get session attribute name filter ( ) { if ( session attribute name pattern == null ) { return null ; } return session attribute name pattern . to string ( ) ; }
public void set session attribute value class name filter ( string session attribute value class name filter ) throw pattern syntax exception { if ( session attribute value class name filter == null || session attribute value class name filter . length ( ) == 0 ) { session attribute value class name pattern = null ; } else { session attribute value class name pattern = pattern . compile ( session attribute value class name filter ) ; } }
public void set warn on session attribute filter failure ( boolean warn on session attribute filter failure ) { this . warn on session attribute filter failure = warn on session attribute filter failure ; }
public int get duplicate ( ) { return duplicate ; }
public void clear store ( ) { if ( store == null ) return ; try { if ( security util . be package protection enable ( ) ) { try { access controller . do privilege ( new privilege store clear ( ) ) ; } catch ( privileged action exception e ) { log . error ( sm . get string ( `` persistent manager . store clear error `` ) , e . get exception ( ) ) ; } } else { store . clear ( ) ; } } catch ( i o exception e ) { log . error ( sm . get string ( `` persistent manager . store clear error `` ) , e ) ; } }
public int get max inactive interval ( ) { return this . max inactive interval ; }
public principal get principal ( ) { return this . principal ; }
public iterator < string > get note name ( ) { return note . key set ( ) . iterator ( ) ; }
public void stop ( ) throw exception { method method = catalina daemon . get class ( ) . get method ( `` stop `` , ( class [ ] ) null ) ; method . invoke ( catalina daemon , ( object [ ] ) null ) ; }
public void set use naming ( boolean use naming ) { this . use name = use name ; }
protect void process context config ( digester digester , url context xml , input stream stream ) { if ( log . be debug enable ( ) ) { log . debug ( `` process context [ `` + context . get name ( ) + `` ] configuration file [ `` + context xml + `` ] `` ) ; } input source source = null ; try { source = new input source ( context xml . to string ( ) ) ; if ( stream == null ) { u r l connection xml conn = context xml . open connection ( ) ; xml conn . set use cache ( false ) ; stream = xml conn . get input stream ( ) ; } } catch ( exception e ) { log . error ( sm . get string ( `` context config . context miss `` , context xml ) , e ) ; } if ( source == null ) { return ; } try { source . set byte stream ( stream ) ; digester . set class loader ( this . get class ( ) . get class loader ( ) ) ; digester . set use context class loader ( false ) ; digester . push ( context . get parent ( ) ) ; digester . push ( context ) ; xml error handler error handler = new xml error handler ( ) ; digester . set error handler ( error handler ) ; digester . parse ( source ) ; if ( error handler . get warning ( ) . size ( ) > 0 || error handler . get error ( ) . size ( ) > 0 ) { error handler . log finding ( log , context xml . to string ( ) ) ; ok = false ; } if ( log . be debug enable ( ) ) { log . debug ( `` successfully process context [ `` + context . get name ( ) + `` ] configuration file [ `` + context xml + `` ] `` ) ; } } catch ( s a x parse exception e ) { log . error ( sm . get string ( `` context config . context parse `` , context . get name ( ) ) , e ) ; log . error ( sm . get string ( `` context config . default position `` , `` `` + e . get line number ( ) , `` `` + e . get column number ( ) ) ) ; ok = false ; } catch ( exception e ) { log . error ( sm . get string ( `` context config . context parse `` , context . get name ( ) ) , e ) ; ok = false ; } finally { try { if ( stream ! = null ) { stream . close ( ) ; } } catch ( i o exception e ) { log . error ( sm . get string ( `` context config . context close `` ) , e ) ; } } }
public boolean be deploy ( string name ) { return deploy . contains key ( name ) ; }
public string get config base name ( ) { return host . get config base file ( ) . get absolute path ( ) ; }
protect static void add resource ( context context , resource annotation ) { add resource ( context , annotation , null , null ) ; }
public void set password ( string password ) { this . password = password ; }
public void set pathname ( string pathname ) { this . pathname = pathname ; this . pathname old = pathname + `` . old `` ; this . pathname new = pathname + `` . new `` ; }
public void add charset map from deployment descriptor ( string locale , string charset ) { map . put ( locale , charset ) ; }
public static int read fully ( input stream be , byte [ ] buf ) throw i o exception { int byte read = 0 ; int read ; while ( byte read < buf . length & & ( ( read = be . read ( buf , bytes read , buf . length - byte read ) ) > = 0 ) ) { byte read += read ; } return byte read ; }
public boolean add ( t o ) { if ( lock ) throw new illegal state exception ( sm . get string ( `` resource set . lock `` ) ) ; return super . add ( o ) ; }
public void set driver name ( string driver name ) { this . driver name = driver name ; }
public void set user field ( string user field ) { this . user field = user field ; }
public void set timestamp field ( string timestamp field ) { this . timestamp field = timestamp field ; }
public int get concurrency ( ) { return concurrency ; }
public boolean get fairness ( ) { return fairness ; }
public boolean get tomcat authentication ( ) { return tomcat authentication ; }
public void set connection upload timeout ( int timeout ) { connection upload timeout = timeout ; }
public void set restrict user agent ( string restrict user agent ) { if ( restrict user agent == null || restrict user agent . length ( ) == 0 ) { this . restrict user agent = null ; } else { this . restrict user agent = pattern . compile ( restrict user agent ) ; } }
public void set server ( string server ) { this . server = server ; }
public int get max trailer size ( ) { return max trailer size ; }
public byte chunk get encode name ( ) { return null ; }
public long get commit time ( ) { return commit time ; }
public void send header ( ) { action ( action code . commit , this ) ; set commit ( true ) ; }
public static void set read only ( object name ) { read only contexts . put ( name , name ) ; }
public static void bind class loader ( object obj , object token , class loader class loader ) throw name exception { if ( context access controller . check security token ( obj , token ) ) { context context = object binding . get ( obj ) ; if ( context == null ) { throw new name exception ( sm . get string ( `` context binding . unknown context `` , obj ) ) ; } cl binding . put ( class loader , context ) ; cl object binding . put ( class loader , obj ) ; } }
public handler ref get handler ( ) { return handler . remove ( 0 ) ; }
public static final boolean apr_status_is_anonymous ( int s ) { return be ( s , 69 ) ; }
public static int to lower ( int c ) { return to low [ c & 0xff ] & 0xff ; }
public void recycle ( ) { decoder . reset ( ) ; leftover . position ( 0 ) ; }
public static int index of ( byte byte [ ] , int start , int end , char s ) { int offset = start ; while ( offset < end ) { byte b = bytes [ offset ] ; if ( b == s ) { return offset ; } offset++ ; } return -1 ; }
public void recycle ( ) { encoder . reset ( ) ; leftover . position ( 0 ) ; }
public boolean find method ( string method ) { if ( method . length == 0 & & omit method . length == 0 ) return true ; if ( method . length > 0 ) { for ( string s : method ) { if ( s . equal ( method ) ) return true ; } return false ; } if ( omit method . length > 0 ) { for ( string omit method : omit method ) { if ( omit method . equal ( method ) ) return false ; } } return true ; }
public string get user constraint ( ) { return user constraint ; }
public void treat all authenticate user a application role ( ) { if ( authenticated user ) { authenticated user = false ; string [ ] result = array . copy of ( auth role , auth role . length + 1 ) ; result [ auth role . length ] = role_all_authenticated_users ; auth role = result ; auth constraint = true ; } }
public static boolean be thread cpu time enable ( ) { return thread m x bean . be thread cpu time enable ( ) ; }
public static void set thread cpu time enable ( boolean enable ) { thread m x bean . set thread cpu time enable ( enable ) ; boolean check value = thread m x bean . be thread cpu time enable ( ) ; if ( enable ! = check value ) { log . error ( `` could not set thread cpu time enable to `` + enable + `` , get `` + check value + `` instead `` ) ; } }
public static void set logger level ( string logger name , string level name ) { log m x bean . set logger level ( logger name , level name ) ; string check value = log m x bean . get logger level ( logger name ) ; if ( ! check value . equal ( level name ) ) { log . error ( `` could not set logger level for logger ' `` + logger name + `` ' to ' `` + level name + `` ' , get ' `` + check value + `` ' instead `` ) ; } }
public static string find deadlock ( ) { thread info [ ] tinfos = null ; long [ ] id = thread m x bean . find deadlocked thread ( ) ; if ( ids ! = null ) { tinfos = thread m x bean . get thread info ( thread m x bean . find deadlocked thread ( ) , true , true ) ; if ( tinfos ! = null ) { string builder sb = new string builder ( `` deadlock find between the following thread : `` ) ; sb . append ( crlf ) ; sb . append ( get thread dump ( tinfos ) ) ; return sb . to string ( ) ; } } return `` `` ; }
public static string get v m info ( ) { return get v m info ( sm ) ; }
public static boolean match name ( set < string > pattern set , string file name ) { char [ ] file name array = file name . to char array ( ) ; for ( string pattern : pattern set ) { if ( match ( pattern , file name array , true ) ) { return true ; } } return false ; }
public static final string get current date ( ) { long now = system . current time millis ( ) ; if ( ( now - current date generate ) > 1000 ) { current date = format_rfc5322 . format ( new date ( now ) ) ; current date generate = now ; } return current date ; }
public static final string format date ( long value , date format thread localformat ) { return format date ( value ) ; }
public byte [ ] get ( ) { if ( be in memory ( ) ) { if ( cached content == null & & dfos ! = null ) { cache content = dfos . get data ( ) ; } return cached content ; } byte [ ] file data = new byte [ ( int ) get size ( ) ] ; input stream fis = null ; try { fis = new file input stream ( dfos . get file ( ) ) ; i o utils . read fully ( fis , file data ) ; } catch ( i o exception e ) { file data = null ; } finally { i o utils . close quietly ( fis ) ; } return file data ; }
public string get field name ( ) { return field name ; }
public long get size max ( ) { return size max ; }
public void set progress listener ( progress listener p listener ) { listener = p listener ; }
public string get field name ( ) { return field name ; }
protect int find byte ( byte value , int po ) { for ( int i = po ; i < tail ; i++ ) { if ( buffer [ i ] == value ) { return i ; } } return -1 ; }
protect int find separator ( ) { int buffer po = this . head ; int table po = 0 ; while ( buffer po < this . tail ) { while ( table po > = 0 & & buffer [ buffer pos ] ! = boundary [ table po ] ) { table po = boundary table [ table po ] ; } buffer pos++ ; table pos++ ; if ( table po == boundary length ) { return buffer po - boundary length ; } } return -1 ; }
public int read ( ) throw i o exception { int re = super . read ( ) ; if ( res ! = -1 ) { count++ ; check limit ( ) ; } return re ; }
public void clear ( ) { synchronize ( name ) { name . clear ( ) ; } }
public void add attribute ( attribute info attribute ) { attribute . put ( attribute . get name ( ) , attribute ) ; }
public void add ( throwable t ) { throwables . add ( t ) ; }
public void reload ssl host configs ( ) { for ( string host name : ssl host configs . key set ( ) ) { reload ssl host config ( host name ) ; } }
public void set utility executor ( schedule executor service utility executor ) { this . utility executor = utility executor ; }
public void set accept count ( int accept count ) { if ( accept count > 0 ) this . accept count = accept count ; }
public object get attribute ( string key ) { object value = attribute . get ( key ) ; if ( get log ( ) . be trace enable ( ) ) { get log ( ) . trace ( sm . get string ( `` endpoint . get attribute `` , key , value ) ) ; } return value ; }
public void reset ( asynchronous socket channel channel , socket wrapper base < nio2 channel > socket wrapper ) throw i o exception { this . sc = channel ; this . socket wrapper = socket wrapper ; buf handler . reset ( ) ; }
public boolean flush ( boolean block , selector s , long timeout ) throw i o exception { return true ; }
public boolean set property ( string name , string value ) { final string selector pool name = `` selector pool . `` ; try { if ( name . start with ( selector pool name ) ) { return introspection utils . set property ( selector pool , name . substring ( selector pool name . length ( ) ) , value ) ; } else { return super . set property ( name , value ) ; } } catch ( exception e ) { log . error ( sm . get string ( `` endpoint . set attribute error `` , name , value ) , e ) ; return false ; } }
public void set poller thread priority ( int poller thread priority ) { this . poller thread priority = poller thread priority ; }
public void execute ( runnable runnable ) { executor executor = endpoint . get executor ( ) ; if ( ! endpoint . be run ( ) || executor == null ) { throw new reject execution exception ( ) ; } executor . execute ( runnable ) ; }
public boolean need semaphore ( ) { return false ; }
public long get count ( ) { return count . get ( ) ; }
public void set limit ( long limit ) { this . limit = limit ; }
public boolean have queue thread ( ) { return sync . have queue thread ( ) ; }
public final string get name ( ) { return name ; }
public u r i builder with scheme ( string scheme ) { return new u r i builder ( optional . of nullable ( scheme ) , scheme specific part , host , port , path , fragment , parameter , be path absolute , end with slash ) ; }
public u r i builder add parameter ( iterable < query param > new params ) { if ( ! new params . iterator ( ) . have next ( ) ) { return this ; } query params update = this . parameter . add ( new params ) ; return with parameter ( update ) ; }
public synchronize void set runtime service ( runtime service r ) { if ( rsvc == null ) { rsvc = r ; / * allow for this method to be call * after * add event handler * / for ( event handler handler : reference handler ) { if ( handler instanceof runtime service aware & & ! initialized handler . contains ( handler ) ) { ( ( runtime service aware ) handler ) . set runtime service ( r ) ; initialize handler . add ( handler ) ; } } if ( method exception handler ! = null & & method exception handler instanceof runtime service aware & & ! initialized handler . contains ( method exception handler ) ) { ( ( runtime service aware ) method exception handler ) . set runtime service ( r ) ; initialize handler . add ( method exception handler ) ; } for ( event handler handler : include handler ) { if ( handler instanceof runtime service aware & & ! initialized handler . contains ( handler ) ) { ( ( runtime service aware ) handler ) . set runtime service ( r ) ; initialize handler . add ( handler ) ; } } for ( event handler handler : invalid reference handler ) { if ( handler instanceof runtime service aware & & ! initialized handler . contains ( handler ) ) { ( ( runtime service aware ) handler ) . set runtime service ( r ) ; initialize handler . add ( handler ) ; } } } else if ( rsvc ! = r ) { throw new velocity exception ( `` an event cartridge can not be use by several different runtime service instance `` ) ; } }
public void add invalid reference event handler ( invalid reference event handler ev ) { invalid reference handler . add ( ev ) ; }
protect string escape ( object text ) { return string escape utils . escape ecma script ( text . to string ( ) ) ; }
public object method exception ( context context , class claz , string method , exception e , info info ) { boolean show template info = r . get boolean ( show_template_info , false ) ; boolean show stack trace = r . get boolean ( show_stack_trace , false ) ; string builder st = new string builder ( ) ; st . append ( `` exception while execute method `` ) . append ( claz . to string ( ) ) . append ( `` . `` ) . append ( method ) ; st . append ( `` : `` ) . append ( e . get class ( ) . get name ( ) ) . append ( `` : `` ) . append ( e . get message ( ) ) ; if ( show template info ) { st . append ( `` at `` ) . append ( info . get template name ( ) ) . append ( `` ( line `` ) . append ( info . get line ( ) ) . append ( `` , column `` ) . append ( info . get column ( ) ) . append ( `` ) `` ) ; } if ( show stack trace ) { st . append ( system . line separator ( ) ) . append ( get stack trace ( e ) ) ; } return st . to string ( ) ; }
public static boolean resource exists ( string resource name ) { return ( runtime singleton . get loader name for resource ( resource name ) ! = null ) ; }
public static logger get log ( ) { return runtime singleton . get log ( ) ; }
public string get current macro name ( ) { if ( macro name stack . empty ( ) ) { return `` < undef > `` ; } else { return macro name stack . peek ( ) ; } }
public string get method name ( ) { return method name ; }
public final void write ( char buf [ ] ) throw i o exception { write ( buf , 0 , buf . length ) ; }
public int get type ( ) { return block ; }
public int get column number ( ) { if ( ( current token ! = null ) & & ( current token . next ! = null ) ) { return current token . next . begin column ; } else if ( current token ! = null ) { return current token . begin column ; } else { return -1 ; } }
protect void stop ( ) { throw new stop command ( owner ) ; }
public scope get parent ( ) { return parent ; }
public string get postfix ( ) { return postfix ; }
public static void fix indentation ( simple node parent , string parent indentation ) { indentation fixer fixer = new indentation fixer ( parent indentation ) ; parent . child accept ( fixer , null ) ; }
protect string get location ( internal context adapter context ) { return string utils . format file string ( this ) ; }
public void initialize ( runtime service rsvc ) { log = rsvc . get log ( `` parser `` ) ; max = rsvc . get int ( runtime constant . parser_pool_size , runtime constant . number_of_parsers ) ; pool = new simple pool ( max ) ; for ( int i = 0 ; i < max ; i++ ) { pool . put ( rsvc . create new parser ( ) ) ; } log . debug ( `` create ' { } ' parser . `` , max ) ; }
public void set modification check interval ( long modification check interval ) { this . modification check interval = modification check interval ; }
public void set name ( string name ) { this . name = name ; }
public long get last modified ( ) { return last modify ; }
public void set body ( final string body ) { this . body = body ; this . last modified = system . current time millis ( ) ; }
public void set last modified ( final long last modify ) { this . last modify = last modify ; }
public boolean invoke velocimacro ( final string vm name , string log tag , string [ ] params , final context context , final writer writer ) { / * check necessary parameter * / if ( vm name == null || context == null || writer == null ) { string msg = `` runtime instance . invoke velocimacro ( ) : invalid call : vm name , context , and writer must not be null `` ; log . error ( msg ) ; throw new null pointer exception ( msg ) ; } / * handle easily correct parameter * / if ( log tag == null ) { log tag = vm name ; } if ( params == null ) { params = new string [ 0 ] ; } / * do the vm exist ? ( only global scope be scan so this do n't find inline macro in template ) * / if ( ! be velocimacro ( vm name , null ) ) { string msg = `` runtime instance . invoke velocimacro ( ) : vm ' `` + vm name + `` ' be not register . `` ; log . error ( msg ) ; throw new velocity exception ( msg ) ; } / * now just create the vm call , and use evaluate * / string builder template = new string builder ( `` # `` ) ; template . append ( vm name ) ; template . append ( `` ( `` ) ; for ( string param : params ) { template . append ( `` $ `` ) ; template . append ( param ) ; } template . append ( `` ) `` ) ; return evaluate ( context , writer , log tag , template . to string ( ) ) ; }
public int get int ( string key ) { return configuration . get int ( key ) ; }
public object get application attribute ( object key ) { return application attribute . get ( key ) ; }
public static void set property ( property configuration ) { ri . set property ( configuration ) ; }
public static string get loader name for resource ( string resource name ) { return ri . get loader name for resource ( resource name ) ; }
public void init document ( ) throw template init exception { / * * send an empty internal context adapter down into the ast to initialize it * / internal context adapter impl ica = new internal context adapter impl ( new velocity context ( ) ) ; try { / * * put the current template name on the stack * / ica . push current template name ( name ) ; ica . set current resource ( this ) ; / * * init the ast * / ( ( simple node ) data ) . init ( ica , rsvc ) ; string property = scope name+ ' . '+ runtime constant . provide_scope_control ; provide scope = rsvc . get boolean ( property , provide scope ) ; } finally { / * * in case something blow up . . . * pull it off for completeness * / ica . pop current template name ( ) ; ica . set current resource ( null ) ; } }
public void remove ( ) { throw new unsupported operation exception ( ) ; }
public class get cached class ( ) { return clazz ; }
public boolean be explicitly convertible ( class formal , class actual , boolean possible var arg ) { / * * for consistency , we also have to check standard implicit convertibility * since it may not have be check before by the call code * / if ( formal == actual || introspection utils . be method invocation convertible ( formal , actual , possible var arg ) || get need converter ( formal , actual ) ! = null ) { return true ; } / * check var arg * / if ( possible var arg & & formal . be array ( ) ) { if ( actual . be array ( ) ) { actual = actual . get component type ( ) ; } return be explicitly convertible ( formal . get component type ( ) , actual , false ) ; } return false ; }
public object internal get ( string key ) { return context . get ( key ) ; }
public string get engine name ( ) { return velocity_name ; }
public list < string > get mime type ( ) { return mime type ; }
public void collect import ( collection < class type info > import ) { }
public code writer new line ( ) { println ( ) ; return this ; }
public option set hidden ( boolean hidden ) { this . hidden = hidden ; return this ; }
public void ensure validity ( ) { super . ensure validity ( ) ; if ( type == null ) { throw new illegal argument exception ( `` type must not be null `` ) ; } }
public string get isolation group ( ) { return isolation group ; }
public deployment option set isolation group ( string isolation group ) { this . isolation group = isolation group ; return this ; }
public deployment option set instance ( int instance ) { this . instance = instance ; return this ; }
public address resolver option set cache negative time to live ( int cache negative time to live ) { if ( cache negative time to live < 0 ) { throw new illegal argument exception ( `` cache negative time to live must be > = 0 `` ) ; } this . cache negative time to live = cache negative time to live ; return this ; }
public multi map get header ( ) { return header ; }
public event bus option set host ( string host ) { this . host = host ; return this ; }
public json object to json ( ) { json object json = super . to json ( ) ; http client option converter . to json ( this , json ) ; return json ; }
public boolean be pipelining ( ) { return pipelining ; }
public http client option set pipelining ( boolean pipelining ) { this . pipelining = pipelining ; return this ; }
public http client option set default port ( int default port ) { this . default port = default port ; return this ; }
public http server option set max websocket message size ( int max web socket message size ) { this . max web socket message size = max web socket message size ; return this ; }
public request option add header ( string key , string value ) { check header ( ) ; object . require non null ( key , `` no null key accept `` ) ; object . require non null ( value , `` no null value accept `` ) ; header . add ( key , value ) ; return this ; }
public web socket connect option set version ( websocket version version ) { this . version = version ; return this ; }
protect void before start vertx ( vertx option option ) { object main = execution context . main ( ) ; if ( main instanceof vertx lifecycle hook ) { ( ( vertx lifecycle hook ) main ) . before start vertx ( option ) ; } }
protect synchronized vertx create ( vertx option option ) { final class loader original class loader = thread . current thread ( ) . get context class loader ( ) ; try { thread . current thread ( ) . set context class loader ( classloader ! = null ? classloader : get class ( ) . get class loader ( ) ) ; return vertx . vertx ( option ) ; } catch ( exception e ) { log . error ( `` fail to create the vert . x instance `` , e ) ; } finally { thread . current thread ( ) . set context class loader ( original class loader ) ; } return null ; }
protect synchronized void create ( vertx option option , handler < async result < vertx > > result handler ) { final class loader original class loader = thread . current thread ( ) . get context class loader ( ) ; try { thread . current thread ( ) . set context class loader ( classloader ! = null ? classloader : get class ( ) . get class loader ( ) ) ; vertx . cluster vertx ( option , result handler ) ; } catch ( exception e ) { log . error ( `` fail to create the vert . x instance `` , e ) ; } finally { thread . current thread ( ) . set context class loader ( original class loader ) ; } }
public watcher watch ( ) { new thread ( this ) . start ( ) ; logger . info ( `` start the vert . x application in redeploy mode `` ) ; deploy . handle ( null ) ; return this ; }
public static < t > t decode value ( string str , type reference < t > type ) throw decode exception { return jackson codec . from string ( str , type ) ; }
public static string encode prettily ( object obj ) throw encode exception { return json codec . instance . to string ( obj , true ) ; }
public byte [ ] get binary ( string key ) { object . require non null ( key ) ; string encode = ( string ) map . get ( key ) ; return encode == null ? null : base64 . get decoder ( ) . decode ( encode ) ; }
public int size ( ) { return map . size ( ) ; }
public jks option set password ( string password ) { this . password = password ; return this ; }
public jks option set path ( string path ) { this . path = path ; return this ; }
public net client option set reconnect interval ( long interval ) { if ( interval < 1 ) { throw new illegal argument exception ( `` reconnect interval must be > = 1 `` ) ; } this . reconnect interval = interval ; return this ; }
public int get receive buffer size ( ) { return receive buffer size ; }
public network option set receive buffer size ( int receive buffer size ) { argument . require ( receive buffer size > 0 || receive buffer size == default_receive_buffer_size , `` receive buffer size must be > 0 `` ) ; this . receive buffer size = receive buffer size ; return this ; }
public pem key cert option add cert path ( string cert path ) { argument . require ( cert path ! = null , `` null cert path `` ) ; cert path . add ( cert path ) ; return this ; }
public pem trust option add cert value ( buffer cert value ) throw null pointer exception { object . require non null ( cert value , `` no null certificate accept `` ) ; cert value . add ( cert value ) ; return this ; }
public pfx option set value ( buffer value ) { this . value = value ; return this ; }
public t c p s s l option set pem key cert option ( pem key cert option option ) { this . key cert option = option ; return this ; }
public t c p s s l option set trust option ( trust option option ) { this . trust option = option ; return this ; }
public pem trust option get pem trust option ( ) { return trust option instanceof pem trust option ? ( pem trust option ) trust option : null ; }
public t c p s s l option add crl path ( string crl path ) throw null pointer exception { object . require non null ( crl path , `` no null crl accept `` ) ; crl path . add ( crl path ) ; return this ; }
public void delimit mode ( string delim ) { delimit mode ( latin1 string to byte ( delim ) ) ; }
public boolean be cluster ( ) { return event bus option . be cluster ( ) ; }
public io . vertx . reactivex . amqp . amqp client create sender ( string address , handler < async result < io . vertx . reactivex . amqp . amqp sender > > completion handler ) { delegate . create sender ( address , new handler < async result < io . vertx . amqp . amqp sender > > ( ) { public void handle ( async result < io . vertx . amqp . amqp sender > ar ) { if ( ar . succeed ( ) ) { completion handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . amqp . amqp sender . new instance ( ( io . vertx . amqp . amqp sender ) ar . result ( ) ) ) ) ; } else { completion handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . cassandra . cassandra client close ( ) { delegate . close ( ) ; return this ; }
public io . vertx . reactivex . cassandra . cassandra client execute ( com . datastax . driver . core . statement statement , handler < async result < io . vertx . reactivex . cassandra . result set > > result handler ) { delegate . execute ( statement , new handler < async result < io . vertx . cassandra . result set > > ( ) { public void handle ( async result < io . vertx . cassandra . result set > ar ) { if ( ar . succeed ( ) ) { result handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . cassandra . result set . new instance ( ( io . vertx . cassandra . result set ) ar . result ( ) ) ) ) ; } else { result handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . cassandra . cassandra client query stream ( com . datastax . driver . core . statement statement , handler < async result < io . vertx . reactivex . cassandra . cassandra row stream > > row stream handler ) { delegate . query stream ( statement , new handler < async result < io . vertx . cassandra . cassandra row stream > > ( ) { public void handle ( async result < io . vertx . cassandra . cassandra row stream > ar ) { if ( ar . succeed ( ) ) { row stream handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . cassandra . cassandra row stream . new instance ( ( io . vertx . cassandra . cassandra row stream ) ar . result ( ) ) ) ) ; } else { row stream handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . circuitbreaker . circuit breaker half open handler ( handler < void > handler ) { delegate . half open handler ( handler ) ; return this ; }
public static io . vertx . reactivex . circuitbreaker . hystrix metric handler create ( io . vertx . reactivex . core . vertx vertx , string address ) { io . vertx . reactivex . circuitbreaker . hystrix metric handler ret = io . vertx . reactivex . circuitbreaker . hystrix metric handler . new instance ( ( io . vertx . circuitbreaker . hystrix metric handler ) io . vertx . circuitbreaker . hystrix metric handler . create ( vertx . get delegate ( ) , address ) ) ; return ret ; }
public void get config ( handler < async result < json object > > completion handler ) { delegate . get config ( completion handler ) ; }
public io . vertx . reactivex . core . http . http client get now ( string host , string request u r i , handler < io . vertx . reactivex . core . http . http client response > response handler ) { delegate . get now ( host , request u r i , new handler < io . vertx . core . http . http client response > ( ) { public void handle ( io . vertx . core . http . http client response event ) { response handler . handle ( io . vertx . reactivex . core . http . http client response . new instance ( ( io . vertx . core . http . http client response ) event ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . core . http . http client option now ( io . vertx . core . http . request option option , handler < io . vertx . reactivex . core . http . http client response > response handler ) { delegate . option now ( option , new handler < io . vertx . core . http . http client response > ( ) { public void handle ( io . vertx . core . http . http client response event ) { response handler . handle ( io . vertx . reactivex . core . http . http client response . new instance ( ( io . vertx . core . http . http client response ) event ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . core . http . http client request put ( int port , string host , string request u r i , handler < io . vertx . reactivex . core . http . http client response > response handler ) { io . vertx . reactivex . core . http . http client request ret = io . vertx . reactivex . core . http . http client request . new instance ( ( io . vertx . core . http . http client request ) delegate . put ( port , host , request u r i , new handler < io . vertx . core . http . http client response > ( ) { public void handle ( io . vertx . core . http . http client response event ) { response handler . handle ( io . vertx . reactivex . core . http . http client response . new instance ( ( io . vertx . core . http . http client response ) event ) ) ; } } ) ) ; return ret ; }
public io . vertx . reactivex . core . http . http client request put ab ( string absolute u r i , handler < io . vertx . reactivex . core . http . http client response > response handler ) { io . vertx . reactivex . core . http . http client request ret = io . vertx . reactivex . core . http . http client request . new instance ( ( io . vertx . core . http . http client request ) delegate . put ab ( absolute u r i , new handler < io . vertx . core . http . http client response > ( ) { public void handle ( io . vertx . core . http . http client response event ) { response handler . handle ( io . vertx . reactivex . core . http . http client response . new instance ( ( io . vertx . core . http . http client response ) event ) ) ; } } ) ) ; return ret ; }
public io . vertx . reactivex . core . http . http client request delete ( int port , string host , string request u r i , handler < io . vertx . reactivex . core . http . http client response > response handler ) { io . vertx . reactivex . core . http . http client request ret = io . vertx . reactivex . core . http . http client request . new instance ( ( io . vertx . core . http . http client request ) delegate . delete ( port , host , request u r i , new handler < io . vertx . core . http . http client response > ( ) { public void handle ( io . vertx . core . http . http client response event ) { response handler . handle ( io . vertx . reactivex . core . http . http client response . new instance ( ( io . vertx . core . http . http client response ) event ) ) ; } } ) ) ; return ret ; }
public io . vertx . reactivex . core . http . http client websocket ( string host , string request u r i , io . vertx . reactivex . core . multi map header , handler < io . vertx . reactivex . core . http . web socket > w connect ) { delegate . websocket ( host , request u r i , header . get delegate ( ) , new handler < io . vertx . core . http . web socket > ( ) { public void handle ( io . vertx . core . http . web socket event ) { ws connect . handle ( io . vertx . reactivex . core . http . web socket . new instance ( ( io . vertx . core . http . web socket ) event ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . core . http . http client websocket ( string request u r i , io . vertx . reactivex . core . multi map header , io . vertx . core . http . websocket version version , string sub protocol , handler < io . vertx . reactivex . core . http . web socket > w connect ) { delegate . websocket ( request u r i , header . get delegate ( ) , version , sub protocol , new handler < io . vertx . core . http . web socket > ( ) { public void handle ( io . vertx . core . http . web socket event ) { ws connect . handle ( io . vertx . reactivex . core . http . web socket . new instance ( ( io . vertx . core . http . web socket ) event ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . core . http . http client request connection handler ( handler < io . vertx . reactivex . core . http . http connection > handler ) { delegate . connection handler ( new handler < io . vertx . core . http . http connection > ( ) { public void handle ( io . vertx . core . http . http connection event ) { handler . handle ( io . vertx . reactivex . core . http . http connection . new instance ( ( io . vertx . core . http . http connection ) event ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . core . http . http client response body handler ( handler < io . vertx . reactivex . core . buffer . buffer > body handler ) { delegate . body handler ( new handler < io . vertx . core . buffer . buffer > ( ) { public void handle ( io . vertx . core . buffer . buffer event ) { body handler . handle ( io . vertx . reactivex . core . buffer . buffer . new instance ( ( io . vertx . core . buffer . buffer ) event ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . core . http . http client response custom frame handler ( handler < io . vertx . reactivex . core . http . http frame > handler ) { delegate . custom frame handler ( new handler < io . vertx . core . http . http frame > ( ) { public void handle ( io . vertx . core . http . http frame event ) { handler . handle ( io . vertx . reactivex . core . http . http frame . new instance ( ( io . vertx . core . http . http frame ) event ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . core . http . http connection shutdown handler ( handler < void > handler ) { delegate . shutdown handler ( handler ) ; return this ; }
public io . vertx . reactivex . core . http . http server exception handler ( handler < java . lang . throwable > handler ) { delegate . exception handler ( handler ) ; return this ; }
public io . vertx . reactivex . core . http . http server listen ( int port , string host ) { delegate . listen ( port , host ) ; return this ; }
public static single < string > deploy verticle ( vertx vertx , verticle verticle ) { return deploy verticle ( vertx , verticle , new deployment option ( ) ) ; }
public void clear ( ) { delegate . clear ( ) ; }
public io . vertx . reactivex . ext . auth . hash algorithm get ( string id ) { io . vertx . reactivex . ext . auth . hash algorithm ret = io . vertx . reactivex . ext . auth . hash algorithm . new instance ( ( io . vertx . ext . auth . hash algorithm ) delegate . get ( id ) ) ; return ret ; }
public io . vertx . reactivex . ext . auth . hash strategy put ( string id , io . vertx . reactivex . ext . auth . hash algorithm algorithm ) { delegate . put ( id , algorithm . get delegate ( ) ) ; return this ; }
public string compute hash ( string password , string salt , int version ) { string ret = delegate . compute hash ( password , salt , version ) ; return ret ; }
public static io . vertx . reactivex . ext . auth . jdbc . j d b c hash strategy create s h a512 ( io . vertx . reactivex . core . vertx vertx ) { io . vertx . reactivex . ext . auth . jdbc . j d b c hash strategy ret = io . vertx . reactivex . ext . auth . jdbc . j d b c hash strategy . new instance ( ( io . vertx . ext . auth . jdbc . j d b c hash strategy ) io . vertx . ext . auth . jdbc . j d b c hash strategy . create s h a512 ( vertx . get delegate ( ) ) ) ; return ret ; }
public static io . vertx . reactivex . ext . auth . jdbc . j d b c hash strategy create p b k d f2 ( io . vertx . reactivex . core . vertx vertx ) { io . vertx . reactivex . ext . auth . jdbc . j d b c hash strategy ret = io . vertx . reactivex . ext . auth . jdbc . j d b c hash strategy . new instance ( ( io . vertx . ext . auth . jdbc . j d b c hash strategy ) io . vertx . ext . auth . jdbc . j d b c hash strategy . create p b k d f2 ( vertx . get delegate ( ) ) ) ; return ret ; }
public string get salt ( io . vertx . reactivex . ext . auth . user user ) { string ret = delegate . get salt ( user . get delegate ( ) ) ; return ret ; }
public void set algorithm ( io . vertx . ext . auth . mongo . hash algorithm algorithm ) { delegate . set algorithm ( algorithm ) ; }
public io . vertx . reactivex . ext . auth . mongo . mongo auth set hash algorithm ( io . vertx . ext . auth . mongo . hash algorithm hash algorithm ) { delegate . set hash algorithm ( hash algorithm ) ; return this ; }
public static void discover ( io . vertx . reactivex . core . vertx vertx , io . vertx . ext . auth . oauth2 . o auth2 client option config , handler < async result < io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth > > handler ) { io . vertx . ext . auth . oauth2 . provider . azure a d auth . discover ( vertx . get delegate ( ) , config , new handler < async result < io . vertx . ext . auth . oauth2 . o auth2 auth > > ( ) { public void handle ( async result < io . vertx . ext . auth . oauth2 . o auth2 auth > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth . new instance ( ( io . vertx . ext . auth . oauth2 . o auth2 auth ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; }
public static io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth create ( io . vertx . reactivex . core . vertx vertx , string client id , string client secret ) { io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth ret = io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth . new instance ( ( io . vertx . ext . auth . oauth2 . o auth2 auth ) io . vertx . ext . auth . oauth2 . provider . facebook auth . create ( vertx . get delegate ( ) , client id , client secret ) ) ; return ret ; }
public static io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth create ( io . vertx . reactivex . core . vertx vertx , string client id , string client secret ) { io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth ret = io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth . new instance ( ( io . vertx . ext . auth . oauth2 . o auth2 auth ) io . vertx . ext . auth . oauth2 . provider . github auth . create ( vertx . get delegate ( ) , client id , client secret ) ) ; return ret ; }
public static io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth create ( io . vertx . reactivex . core . vertx vertx , string client id , string client secret ) { io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth ret = io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth . new instance ( ( io . vertx . ext . auth . oauth2 . o auth2 auth ) io . vertx . ext . auth . oauth2 . provider . google auth . create ( vertx . get delegate ( ) , client id , client secret ) ) ; return ret ; }
public static io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth create ( io . vertx . reactivex . core . vertx vertx , string client id , string client secret ) { io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth ret = io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth . new instance ( ( io . vertx . ext . auth . oauth2 . o auth2 auth ) io . vertx . ext . auth . oauth2 . provider . twitter auth . create ( vertx . get delegate ( ) , client id , client secret ) ) ; return ret ; }
public io . vertx . reactivex . ext . consul . consul client delete value ( string key , handler < async result < void > > result handler ) { delegate . delete value ( key , result handler ) ; return this ; }
public io . vertx . reactivex . ext . consul . consul client health state ( io . vertx . ext . consul . health state health state , handler < async result < io . vertx . ext . consul . check list > > result handler ) { delegate . health state ( health state , result handler ) ; return this ; }
public json object get metric snapshot ( io . vertx . reactivex . core . metric . measure measure ) { json object ret = delegate . get metric snapshot ( measure . get delegate ( ) ) ; return ret ; }
public json object get metric snapshot ( string base name ) { json object ret = delegate . get metric snapshot ( base name ) ; return ret ; }
public io . vertx . reactivex . ext . eventbus . bridge . tcp . tcp event bus bridge listen ( ) { delegate . listen ( ) ; return this ; }
public static mail client new instance ( io . vertx . ext . mail . mail client arg ) { return arg ! = null ? new mail client ( arg ) : null ; }
public io . vertx . reactivex . ext . mongo . mongo client count ( string collection , json object query , handler < async result < long > > result handler ) { delegate . count ( collection , query , result handler ) ; return this ; }
public io . vertx . reactivex . ext . mongo . mongo client remove one with option ( string collection , json object query , io . vertx . ext . mongo . write option write option , handler < async result < void > > result handler ) { delegate . remove one with option ( collection , query , write option , result handler ) ; return this ; }
public io . vertx . reactivex . ext . mongo . mongo client list index ( string collection , handler < async result < json array > > result handler ) { delegate . list index ( collection , result handler ) ; return this ; }
public io . vertx . reactivex . ext . mongo . mongo client drop index ( string collection , string index name , handler < async result < void > > result handler ) { delegate . drop index ( collection , index name , result handler ) ; return this ; }
public io . vertx . reactivex . ext . mongo . mongo client run command ( string command name , json object command , handler < async result < json object > > result handler ) { delegate . run command ( command name , command , result handler ) ; return this ; }
public void complete ( io . vertx . reactivex . ext . shell . cli . completion completion ) { delegate . complete ( completion . get delegate ( ) ) ; }
public io . vertx . reactivex . ext . shell . command . command builder process handler ( handler < io . vertx . reactivex . ext . shell . command . command process > handler ) { delegate . process handler ( new handler < io . vertx . ext . shell . command . command process > ( ) { public void handle ( io . vertx . ext . shell . command . command process event ) { handler . handle ( io . vertx . reactivex . ext . shell . command . command process . new instance ( ( io . vertx . ext . shell . command . command process ) event ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . ext . shell . command . command build ( io . vertx . reactivex . core . vertx vertx ) { io . vertx . reactivex . ext . shell . command . command ret = io . vertx . reactivex . ext . shell . command . command . new instance ( ( io . vertx . ext . shell . command . command ) delegate . build ( vertx . get delegate ( ) ) ) ; return ret ; }
public io . vertx . reactivex . ext . shell . shell create shell ( io . vertx . reactivex . ext . shell . term . term term ) { io . vertx . reactivex . ext . shell . shell ret = io . vertx . reactivex . ext . shell . shell . new instance ( ( io . vertx . ext . shell . shell ) delegate . create shell ( term . get delegate ( ) ) ) ; return ret ; }
public io . vertx . reactivex . ext . shell . system . job set tty ( io . vertx . reactivex . ext . shell . term . tty tty ) { delegate . set tty ( tty . get delegate ( ) ) ; return this ; }
public void resume ( ) { delegate . resume ( ) ; }
public void readline ( string prompt , handler < string > line handler , handler < io . vertx . reactivex . ext . shell . cli . completion > completion handler ) { delegate . readline ( prompt , line handler , new handler < io . vertx . ext . shell . cli . completion > ( ) { public void handle ( io . vertx . ext . shell . cli . completion event ) { completion handler . handle ( io . vertx . reactivex . ext . shell . cli . completion . new instance ( ( io . vertx . ext . shell . cli . completion ) event ) ) ; } } ) ; }
public static io . vertx . reactivex . ext . shell . term . term server create http term server ( io . vertx . reactivex . core . vertx vertx , io . vertx . reactivex . ext . web . router router ) { io . vertx . reactivex . ext . shell . term . term server ret = io . vertx . reactivex . ext . shell . term . term server . new instance ( ( io . vertx . ext . shell . term . term server ) io . vertx . ext . shell . term . term server . create http term server ( vertx . get delegate ( ) , router . get delegate ( ) ) ) ; return ret ; }
public io . vertx . reactivex . ext . sql . s q l client get connection ( handler < async result < io . vertx . reactivex . ext . sql . s q l connection > > handler ) { delegate . get connection ( new handler < async result < io . vertx . ext . sql . s q l connection > > ( ) { public void handle ( async result < io . vertx . ext . sql . s q l connection > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . ext . sql . s q l connection . new instance ( ( io . vertx . ext . sql . s q l connection ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . ext . sql . s q l connection set auto commit ( boolean auto commit , handler < async result < void > > result handler ) { delegate . set auto commit ( auto commit , result handler ) ; return this ; }
public io . vertx . reactivex . ext . stomp . stomp client connection send ( java . util . map < string , string > header , io . vertx . reactivex . core . buffer . buffer body ) { delegate . send ( header , body . get delegate ( ) ) ; return this ; }
public io . vertx . reactivex . ext . stomp . stomp client connection send ( string destination , java . util . map < string , string > header , io . vertx . reactivex . core . buffer . buffer body ) { delegate . send ( destination , header , body . get delegate ( ) ) ; return this ; }
public string subscribe ( string destination , java . util . map < string , string > header , handler < io . vertx . ext . stomp . frame > handler ) { string ret = delegate . subscribe ( destination , header , handler ) ; return ret ; }
public io . vertx . reactivex . ext . stomp . stomp server write frame handler ( handler < io . vertx . reactivex . ext . stomp . server frame > handler ) { delegate . write frame handler ( new handler < io . vertx . ext . stomp . server frame > ( ) { public void handle ( io . vertx . ext . stomp . server frame event ) { handler . handle ( io . vertx . reactivex . ext . stomp . server frame . new instance ( ( io . vertx . ext . stomp . server frame ) event ) ) ; } } ) ; return this ; }
public void count down ( ) { delegate . count down ( ) ; }
public string name ( ) { if ( cached_0 ! = null ) { return cached_0 ; } string ret = delegate . name ( ) ; cached_0 = ret ; return ret ; }
public io . vertx . reactivex . ext . unit . test context assert true ( boolean condition ) { delegate . assert true ( condition ) ; return this ; }
public io . vertx . reactivex . ext . unit . test context assert not equal ( java . lang . object first , java . lang . object second ) { delegate . assert not equal ( first , second ) ; return this ; }
public io . vertx . reactivex . ext . unit . test completion run ( io . vertx . reactivex . core . vertx vertx , io . vertx . ext . unit . test option option ) { io . vertx . reactivex . ext . unit . test completion ret = io . vertx . reactivex . ext . unit . test completion . new instance ( ( io . vertx . ext . unit . test completion ) delegate . run ( vertx . get delegate ( ) , option ) ) ; return ret ; }
public io . vertx . reactivex . ext . web . api . contract . router factory set body handler ( io . vertx . reactivex . ext . web . handler . body handler body handler ) { delegate . set body handler ( body handler . get delegate ( ) ) ; return this ; }
public list < string > cookie parameter names ( ) { list < string > ret = delegate . cookie parameter names ( ) ; return ret ; }
public list < string > form parameter names ( ) { list < string > ret = delegate . form parameter names ( ) ; return ret ; }
public io . vertx . reactivex . ext . web . api . validation . h t t p request validation handler add query params array with pattern ( string array name , string pattern , boolean require ) { delegate . add query params array with pattern ( array name , pattern , require ) ; return this ; }
public io . vertx . reactivex . ext . web . api . validation . h t t p request validation handler add form params array with pattern ( string parameter name , string pattern , boolean require ) { delegate . add form params array with pattern ( parameter name , pattern , require ) ; return this ; }
public io . vertx . reactivex . ext . web . api . validation . h t t p request validation handler add expect content type ( string content type ) { delegate . add expected content type ( content type ) ; return this ; }
public static io . vertx . reactivex . ext . web . api . validation . parameter type validator create string enum type validator ( list < string > allow value ) { io . vertx . reactivex . ext . web . api . validation . parameter type validator ret = io . vertx . reactivex . ext . web . api . validation . parameter type validator . new instance ( ( io . vertx . ext . web . api . validation . parameter type validator ) io . vertx . ext . web . api . validation . parameter type validator . create string enum type validator ( allow value ) ) ; return ret ; }
public io . vertx . reactivex . ext . web . client . http request < t > raw method ( string method ) { delegate . raw method ( method ) ; return this ; }
public io . vertx . reactivex . ext . web . client . http request < t > set query param ( string param name , string param value ) { delegate . set query param ( param name , param value ) ; return this ; }
public io . vertx . reactivex . ext . web . client . http request < t > follow redirects ( boolean value ) { delegate . follow redirects ( value ) ; return this ; }
public static io . vertx . reactivex . ext . web . client . web client create ( io . vertx . reactivex . core . vertx vertx , io . vertx . ext . web . client . web client option option ) { io . vertx . reactivex . ext . web . client . web client ret = io . vertx . reactivex . ext . web . client . web client . new instance ( ( io . vertx . ext . web . client . web client ) io . vertx . ext . web . client . web client . create ( vertx . get delegate ( ) , option ) ) ; return ret ; }
public void render ( json object context , string template file name , handler < async result < io . vertx . reactivex . core . buffer . buffer > > handler ) { delegate . render ( context , template file name , new handler < async result < io . vertx . core . buffer . buffer > > ( ) { public void handle ( async result < io . vertx . core . buffer . buffer > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . core . buffer . buffer . new instance ( ( io . vertx . core . buffer . buffer ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; }
public static boolean development ( ) { boolean ret = io . vertx . ext . web . common . web environment . development ( ) ; return ret ; }
public boolean be change ( ) { boolean ret = delegate . be change ( ) ; return ret ; }
public io . vertx . reactivex . ext . web . handler . auth handler add authority ( set < string > authority ) { delegate . add authority ( authority ) ; return this ; }
public io . vertx . reactivex . ext . web . handler . body handler set handle file uploads ( boolean handle file uploads ) { delegate . set handle file uploads ( handle file uploads ) ; return this ; }
public io . vertx . reactivex . ext . web . handler . body handler set preallocate body buffer ( boolean be preallocate body buffer ) { delegate . set preallocate body buffer ( be preallocate body buffer ) ; return this ; }
public static io . vertx . reactivex . ext . web . handler . cookie handler create ( ) { io . vertx . reactivex . ext . web . handler . cookie handler ret = io . vertx . reactivex . ext . web . handler . cookie handler . new instance ( ( io . vertx . ext . web . handler . cookie handler ) io . vertx . ext . web . handler . cookie handler . create ( ) ) ; return ret ; }
public static digest auth handler new instance ( io . vertx . ext . web . handler . digest auth handler arg ) { return arg ! = null ? new digest auth handler ( arg ) : null ; }
public static favicon handler new instance ( io . vertx . ext . web . handler . favicon handler arg ) { return arg ! = null ? new favicon handler ( arg ) : null ; }
public io . vertx . reactivex . ext . web . handler . graphql . apollo w s handler connection handler ( handler < io . vertx . reactivex . core . http . server web socket > connection handler ) { delegate . connection handler ( new handler < io . vertx . core . http . server web socket > ( ) { public void handle ( io . vertx . core . http . server web socket event ) { connection handler . handle ( io . vertx . reactivex . core . http . server web socket . new instance ( ( io . vertx . core . http . server web socket ) event ) ) ; } } ) ; return this ; }
public static io . vertx . reactivex . ext . web . handler . response content type handler create ( ) { io . vertx . reactivex . ext . web . handler . response content type handler ret = io . vertx . reactivex . ext . web . handler . response content type handler . new instance ( ( io . vertx . ext . web . handler . response content type handler ) io . vertx . ext . web . handler . response content type handler . create ( ) ) ; return ret ; }
public io . vertx . reactivex . ext . web . handler . session handler set session cookie path ( string session cookie path ) { delegate . set session cookie path ( session cookie path ) ; return this ; }
public io . vertx . reactivex . ext . web . handler . session handler set min length ( int min length ) { delegate . set min length ( min length ) ; return this ; }
public io . vertx . reactivex . ext . web . handler . static handler set directory listing ( boolean directory listing ) { delegate . set directory listing ( directory listing ) ; return this ; }
public io . vertx . reactivex . ext . web . handler . static handler skip compression for medium type ( set < string > medium type ) { delegate . skip compression for medium type ( medium type ) ; return this ; }
public static template handler new instance ( io . vertx . ext . web . handler . template handler arg ) { return arg ! = null ? new template handler ( arg ) : null ; }
public io . vertx . reactivex . ext . web . route use normalise path ( boolean use normalised path ) { delegate . use normalised path ( use normalise path ) ; return this ; }
public io . vertx . reactivex . ext . web . route set regex group name ( list < string > group ) { delegate . set regex group name ( group ) ; return this ; }
public boolean remove end handler ( int handler i d ) { boolean ret = delegate . remove end handler ( handler i d ) ; return ret ; }
public void set user ( io . vertx . reactivex . ext . auth . user user ) { delegate . set user ( user . get delegate ( ) ) ; }
public static io . vertx . reactivex . ext . web . sstore . cluster session store create ( io . vertx . reactivex . core . vertx vertx , string session map name , long retry timeout ) { io . vertx . reactivex . ext . web . sstore . cluster session store ret = io . vertx . reactivex . ext . web . sstore . cluster session store . new instance ( ( io . vertx . ext . web . sstore . cluster session store ) io . vertx . ext . web . sstore . cluster session store . create ( vertx . get delegate ( ) , session map name , retry timeout ) ) ; return ret ; }
public void create topic ( list < io . vertx . kafka . admin . new topic > topic , handler < async result < void > > completion handler ) { delegate . create topic ( topic , completion handler ) ; }
public void close ( ) { delegate . close ( ) ; }
public io . vertx . reactivex . kafka . client . consumer . kafka consumer < k , v > assign ( set < io . vertx . kafka . client . common . topic partition > topic partition ) { delegate . assign ( topic partition ) ; return this ; }
public void close ( ) { delegate . close ( ) ; }
public void end offset ( io . vertx . kafka . client . common . topic partition topic partition , handler < async result < long > > handler ) { delegate . end offset ( topic partition , handler ) ; }
public single < list < io . vertx . kafka . client . common . partition info > > rx partition for ( string topic ) { return async result single . to single ( handler - > { partition for ( topic , handler ) ; } ) ; }
public io . vertx . reactivex . mqtt . mqtt client subscribe ( string topic , int qos ) { delegate . subscribe ( topic , qos ) ; return this ; }
public io . vertx . reactivex . mqtt . mqtt client unsubscribe ( string topic ) { delegate . unsubscribe ( topic ) ; return this ; }
public io . vertx . reactivex . mqtt . mqtt endpoint publish completion handler ( handler < integer > handler ) { delegate . publish completion handler ( handler ) ; return this ; }
public io . vertx . reactivex . mqtt . mqtt endpoint publish complete ( int publish message id ) { delegate . publish complete ( publish message id ) ; return this ; }
public io . vertx . reactivex . mqtt . mqtt endpoint publish ( string topic , io . vertx . reactivex . core . buffer . buffer payload , io . netty . handler . codec . mqtt . mqtt qo s qos level , boolean be dup , boolean be retain ) { delegate . publish ( topic , payload . get delegate ( ) , qos level , be dup , be retain ) ; return this ; }
public io . vertx . reactivex . mqtt . mqtt endpoint pong ( ) { delegate . pong ( ) ; return this ; }
public static io . vertx . reactivex . mqtt . mqtt server create ( io . vertx . reactivex . core . vertx vertx ) { io . vertx . reactivex . mqtt . mqtt server ret = io . vertx . reactivex . mqtt . mqtt server . new instance ( ( io . vertx . mqtt . mqtt server ) io . vertx . mqtt . mqtt server . create ( vertx . get delegate ( ) ) ) ; return ret ; }
public io . vertx . reactivex . mqtt . mqtt server listen ( ) { delegate . listen ( ) ; return this ; }
public io . vertx . reactivex . pgclient . pg connection cancel request ( handler < async result < void > > handler ) { io . vertx . reactivex . pgclient . pg connection ret = io . vertx . reactivex . pgclient . pg connection . new instance ( ( io . vertx . pgclient . pg connection ) delegate . cancel request ( handler ) ) ; return ret ; }
public io . vertx . reactivex . pgclient . pubsub . pg channel channel ( string name ) { io . vertx . reactivex . pgclient . pubsub . pg channel ret = io . vertx . reactivex . pgclient . pubsub . pg channel . new instance ( ( io . vertx . pgclient . pubsub . pg channel ) delegate . channel ( name ) ) ; return ret ; }
public string rout key ( ) { if ( cached_3 ! = null ) { return cached_3 ; } string ret = delegate . rout key ( ) ; cached_3 = ret ; return ret ; }
public void basic qos ( int prefetch size , int prefetch count , boolean global , handler < async result < void > > result handler ) { delegate . basic qos ( prefetch size , prefetch count , global , result handler ) ; }
public void exchange unbind ( string destination , string source , string rout key , handler < async result < void > > result handler ) { delegate . exchange unbind ( destination , source , rout key , result handler ) ; }
public boolean be connect ( ) { boolean ret = delegate . be connect ( ) ; return ret ; }
public io . vertx . reactivex . redis . client . redis a p i bitfield ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . bitfield ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i dump ( string arg0 , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . dump ( arg0 , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i geodist ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . geodist ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i getrange ( string arg0 , string arg1 , string arg2 , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . getrange ( arg0 , arg1 , arg2 , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i hincrbyfloat ( string arg0 , string arg1 , string arg2 , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . hincrbyfloat ( arg0 , arg1 , arg2 , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i hmset ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . hmset ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i hvals ( string arg0 , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . hvals ( arg0 , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i ltrim ( string arg0 , string arg1 , string arg2 , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . ltrim ( arg0 , arg1 , arg2 , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i psubscribe ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . psubscribe ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i slowlog ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . slowlog ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i smove ( string arg0 , string arg1 , string arg2 , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . smove ( arg0 , arg1 , arg2 , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i unwatch ( handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . unwatch ( new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i xdel ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . xdel ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i xrevrange ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . xrevrange ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i xtrim ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . xtrim ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i zremrangebyscore ( string arg0 , string arg1 , string arg2 , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . zremrangebyscore ( arg0 , arg1 , arg2 , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i zunionstore ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . zunionstore ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public void close ( ) { delegate . close ( ) ; }
public io . vertx . reactivex . redis . client . request arg ( int arg ) { delegate . arg ( arg ) ; return this ; }
public byte to byte ( ) { byte ret = delegate . to byte ( ) ; return ret ; }
public boolean to boolean ( ) { boolean ret = delegate . to boolean ( ) ; return ret ; }
public io . vertx . reactivex . redis . redis client bgrewriteaof ( handler < async result < string > > handler ) { delegate . bgrewriteaof ( handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client cluster reset ( handler < async result < void > > handler ) { delegate . cluster reset ( handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client command ( handler < async result < json array > > handler ) { delegate . command ( handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client config resetstat ( handler < async result < string > > handler ) { delegate . config resetstat ( handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client echo ( string message , handler < async result < string > > handler ) { delegate . echo ( message , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client exists ( string key , handler < async result < long > > handler ) { delegate . exists ( key , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client flushall ( handler < async result < string > > handler ) { delegate . flushall ( handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client lpush ( string key , string value , handler < async result < long > > handler ) { delegate . lpush ( key , value , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client mget ( string key , handler < async result < json array > > handler ) { delegate . mget ( key , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client persist ( string key , handler < async result < long > > handler ) { delegate . persist ( key , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client publish ( string channel , string message , handler < async result < long > > handler ) { delegate . publish ( channel , message , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client restore ( string key , long millis , string serialize , handler < async result < string > > handler ) { delegate . restore ( key , millis , serialize , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client role ( handler < async result < json array > > handler ) { delegate . role ( handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client rpush many ( string key , list < string > value , handler < async result < long > > handler ) { delegate . rpush many ( key , value , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client sadd ( string key , string member , handler < async result < long > > handler ) { delegate . sadd ( key , member , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client set binary ( string key , io . vertx . reactivex . core . buffer . buffer value , handler < async result < void > > handler ) { delegate . set binary ( key , value . get delegate ( ) , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client setex ( string key , long second , string value , handler < async result < string > > handler ) { delegate . setex ( key , second , value , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client setnx ( string key , string value , handler < async result < long > > handler ) { delegate . setnx ( key , value , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client smembers ( string key , handler < async result < json array > > handler ) { delegate . smembers ( key , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client spop ( string key , handler < async result < string > > handler ) { delegate . spop ( key , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client srem ( string key , string member , handler < async result < long > > handler ) { delegate . srem ( key , member , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client strlen ( string key , handler < async result < long > > handler ) { delegate . strlen ( key , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client subscribe ( string channel , handler < async result < json array > > handler ) { delegate . subscribe ( channel , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client zadd ( string key , double score , string member , handler < async result < long > > handler ) { delegate . zadd ( key , score , member , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client zrevrangebylex ( string key , string max , string min , io . vertx . redis . op . limit option option , handler < async result < json array > > handler ) { delegate . zrevrangebylex ( key , max , min , option , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client zrevrank ( string key , string member , handler < async result < long > > handler ) { delegate . zrevrank ( key , member , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client swapdb ( int index1 , int index2 , handler < async result < string > > handler ) { delegate . swapdb ( index1 , index2 , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis transaction multi ( handler < async result < string > > handler ) { delegate . multi ( handler ) ; return this ; }
public io . vertx . reactivex . redis . redis transaction unwatch ( handler < async result < string > > handler ) { delegate . unwatch ( handler ) ; return this ; }
public boolean release ( io . vertx . reactivex . servicediscovery . service reference reference ) { boolean ret = delegate . release ( reference . get delegate ( ) ) ; return ret ; }
public void update ( io . vertx . servicediscovery . record record , handler < async result < io . vertx . servicediscovery . record > > result handler ) { delegate . update ( record , result handler ) ; }
public void update ( io . vertx . servicediscovery . record record , handler < async result < io . vertx . servicediscovery . record > > result handler ) { delegate . update ( record , result handler ) ; }
public static void get mongo client ( io . vertx . reactivex . servicediscovery . service discovery discovery , function < io . vertx . servicediscovery . record , boolean > filter , handler < async result < io . vertx . reactivex . ext . mongo . mongo client > > result handler ) { io . vertx . servicediscovery . type . mongo data source . get mongo client ( discovery . get delegate ( ) , filter , new handler < async result < io . vertx . ext . mongo . mongo client > > ( ) { public void handle ( async result < io . vertx . ext . mongo . mongo client > ar ) { if ( ar . succeed ( ) ) { result handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . ext . mongo . mongo client . new instance ( ( io . vertx . ext . mongo . mongo client ) ar . result ( ) ) ) ) ; } else { result handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; }
public io . vertx . reactivex . sqlclient . query < io . vertx . reactivex . sqlclient . row set < io . vertx . reactivex . sqlclient . row > > query ( string sql ) { io . vertx . reactivex . sqlclient . query < io . vertx . reactivex . sqlclient . row set < io . vertx . reactivex . sqlclient . row > > ret = io . vertx . reactivex . sqlclient . query . new instance ( ( io . vertx . sqlclient . query ) delegate . query ( sql ) , type_arg_0 ) ; return ret ; }
public void close ( ) { delegate . close ( ) ; }
public io . vertx . reactivex . sqlclient . sql result < t > next ( ) { io . vertx . reactivex . sqlclient . sql result < t > ret = io . vertx . reactivex . sqlclient . sql result . new instance ( ( io . vertx . sqlclient . sql result ) delegate . next ( ) , __type arg_0 ) ; return ret ; }
public void close ( ) { delegate . close ( ) ; }
public static io . vertx . reactivex . sqlclient . tuple of ( java . lang . object elt1 , java . lang . object elt2 , java . lang . object elt3 , java . lang . object elt4 , java . lang . object elt5 , java . lang . object elt6 ) { io . vertx . reactivex . sqlclient . tuple ret = io . vertx . reactivex . sqlclient . tuple . new instance ( ( io . vertx . sqlclient . tuple ) io . vertx . sqlclient . tuple . of ( elt1 , elt2 , elt3 , elt4 , elt5 , elt6 ) ) ; return ret ; }
public void set proxy basic auth scope ( basic auth scope proxy auth ) { this . proxy auth = proxy auth ; }
public static string protocol ( final string url ) { final int po = url . index of ( `` : `` ) ; if ( pos == -1 ) { return `` `` ; } return url . substring ( 0 , po ) . trim ( ) ; }
public long get last modified ( ) { return last modify ; }
public long get idle timeout ( ) { return idle timeout ; }
public void set max text message buffer size ( int size ) { assert great than ( `` max text message buffer size `` , size , 1 ) ; this . max text message buffer size = size ; }
public int get max text message buffer size ( ) { return get policy ( ) . get max text message buffer size ( ) ; }
protect void set initial buffer ( byte buffer prefilled ) { if ( log . be debug enable ( ) ) { log . debug ( `` set initial buffer - { } `` , buffer util . to detail string ( prefilled ) ) ; } prefill buffer = prefilled ; }
public byte buffer get payload ( ) { if ( payload == null ) return buffer util . empty_buffer ; return payload ; }
public void on frame ( frame frame , callback callback ) { if ( _frame ! = null || _callback ! = null ) throw new illegal state exception ( `` not expect on frame `` ) ; _frame = frame ; _callback = new count callback ( callback , 1 ) ; succeed ( ) ; }
public void process handler error ( throwable cause , callback callback ) { if ( log . be debug enable ( ) ) log . debug ( `` process handler error { } `` , this , cause ) ; int code ; if ( cause instanceof close exception ) code = ( ( close exception ) cause ) . get status code ( ) ; else if ( cause instanceof close channel exception ) code = close status . no_close ; else if ( cause instanceof utf8 appendable . not utf8 exception ) code = close status . bad_payload ; else if ( cause instanceof web socket timeout exception || cause instanceof timeout exception || cause instanceof socket timeout exception ) code = close status . shutdown ; else if ( behavior == behavior . client ) code = close status . policy_violation ; else code = close status . server_error ; close status close status = new close status ( code , cause ) ; if ( close status . be transmittable status code ( code ) ) close ( close status , callback ) ; else { if ( session state . on closed ( close status ) ) close connection ( close status , callback ) ; } }
public void add session listener ( jakarta web socket session listener listener ) { session listener . add ( listener ) ; }
public static boolean be transmittable ( int status code ) { return ( status code == normal ) || ( status code == shutdown ) || ( status code == protocol ) || ( status code == bad_data ) || ( status code == bad_payload ) || ( status code == policy_violation ) || ( status code == message_too_large ) || ( status code == required_extension ) || ( status code == server_error ) || ( status code == service_restart ) || ( status code == try_again_later ) || ( status code == invalid_upstream_response ) ; }
public static boolean equal ( string a1 , char [ ] a2 ) { return equal ( a1 , 0 , a2 ) ; }
public static < t > t assert not hold lock ( @ not null t monitor ) { assert ! thread . hold lock ( check not null param ( `` monitor `` , monitor ) ) : common message . msg . expect lock not hold ( monitor ) ; return monitor ; }
public boolean in ( final cache type v1 ) { return this == v1 ; }
public final e first ( ) { final int bit = this . bit ; if ( bit == 0 ) throw new no such element exception ( ) ; return item of ( number of trail zero ( low one bit ( bit ) ) ) ; }
public final this head set ( final e to element ) { assert . check not null param ( `` to element `` , to element ) ; return value ( bit & bit of ( to element ) - 1 ) ; }
public final boolean contain all ( e flag1 , e flag2 ) { return contains ( flag1 ) & & contains ( flag2 ) ; }
public final boolean equal ( final set < ? > o ) { return o == this || o . contain all ( this ) & & contain all ( o ) ; }
public final boolean content equal ( byte iterator other ) { assert . check not null param ( `` other `` , other ) ; for ( ; ; ) { if ( have next ( ) ) { if ( ! other . have next ( ) ) { return false ; } if ( next ( ) ! = other . next ( ) ) { return false ; } } else { return ! other . have next ( ) ; } } }
public string drain to string ( ) { return have next ( ) ? drain to ( new string builder ( ) ) . to string ( ) : `` `` ; }
public byte iterator a utf8 ( ) { return a utf8 ( false ) ; }
public boolean be lock ( ) { return owner ! = null ; }
public void lock ( ) { thread owner ; int spin = 0 ; for ( ; ; ) { owner = this . owner ; if ( owner == thread . current thread ( ) ) { level++ ; return ; } else if ( owner == null & & unsafe . compare and swap object ( this , owner offset , null , thread . current thread ( ) ) ) { level = 1 ; return ; } else if ( spin > = spin limit ) { thread . yield ( ) ; } else { j d k specific . on spin wait ( ) ; spins++ ; } } }
public void unlock ( ) { thread owner = this . owner ; if ( owner == thread . current thread ( ) ) { if ( -- level == 0 ) this . owner = null ; } else { throw new illegal monitor state exception ( ) ; } }
public static string to optimal string ( inet address inet address ) { assert . check not null param ( `` inet address `` , inet address ) ; return inet address instanceof inet6 address ? to optimal string v6 ( inet address . get address ( ) ) : inet address . get host address ( ) ; }
public static string to u r l string ( byte [ ] address byte ) { assert . check not null param ( `` address bytes `` , address byte ) ; if ( address byte . length == 4 ) { return ( address byte [ 0 ] & 0xff ) + `` . `` + ( address byte [ 1 ] & 0xff ) + `` . `` + ( address byte [ 2 ] & 0xff ) + `` . `` + ( address byte [ 3 ] & 0xff ) ; } else if ( address byte . length == 16 ) { return `` [ `` + to optimal string v6 ( address byte ) + `` ] `` ; } else { throw common message . msg . invalid address byte ( address byte . length ) ; } }
public string get exception class name ( ) { return exception class name ; }
public string to string ( ) { final string to string = this . to string ; if ( to string == null ) { final string message = get message ( ) ; string builder b = new string builder ( ) ; b . append ( message == null ? common message . msg . remote exception ( exception class name ) : common message . msg . remote exception ( exception class name , message ) ) ; iterator < map . entry < string , string > > iterator = field . entry set ( ) . iterator ( ) ; if ( iterator . have next ( ) ) { b . append ( `` \n\t public field : `` ) ; do { final map . entry < string , string > entry = iterator . next ( ) ; b . append ( '\n ' ) . append ( '\t ' ) . append ( '\t ' ) . append ( entry . get key ( ) ) . append ( '= ' ) . append ( entry . get value ( ) ) ; } while ( iterator . have next ( ) ) ; } return this . to string = b . to string ( ) ; } return to string ; }
public static < t > privilege action < getter < t > > selector getter action for ( final class < t > clazz ) { assert . check not null param ( `` clazz `` , clazz ) ; return ( ) - > selector getter for ( clazz ) ; }
public boolean be cachable ( ) { return m be cachable ; }
public int validate element end ( string local name , string uri , string prefix ) throw x m l stream exception { / * since we be not really validate , only need to maintain * the element stack , and return `` anything go `` a allowable content : * / int ix = -- m elem count ; m elems [ ix ] = null ; if ( ix < 1 ) { return x m l validator . content_allow_any_text ; } d t d element elem = m elems [ ix-1 ] ; return ( elem == null ) ? x m l validator . content_allow_any_text : m elems [ ix-1 ] . get allow content if space ( ) ; }
public struct validator new instance ( ) { return this ; }
public iterator get namespaces ( ) { return m namespaces . iterator ( ) ; }
public void output namespace declaration ( x m l stream writer w ) throw x m l stream exception { for ( int i = 0 , len = m namespaces . size ( ) ; i < len ; ++i ) { namespace n = ( namespace ) m namespaces . get ( i ) ; if ( n . be default namespace declaration ( ) ) { w . write default namespace ( n . get namespace u r i ( ) ) ; } else { w . write namespace ( n . get prefix ( ) , ns . get namespace u r i ( ) ) ; } } }
protect void set automatic d t d validator ( x m l validator validator , ns default provider n defs ) { m n default provider = n defs ; add validator ( validator ) ; }
protect entity decl get int entity ( int ch , final char [ ] original char ) { string cache key = new string ( original char ) ; int entity entity = ( int entity ) m cached entity . get ( cache key ) ; if ( entity == null ) { string repl ; if ( ch < = 0x f f f f ) { repl = character . to string ( ( char ) ch ) ; } else { string buffer sb = new string buffer ( 2 ) ; ch -= 0x10000 ; sb . append ( ( char ) ( ( ch > > 10 ) + 0x d800 ) ) ; sb . append ( ( char ) ( ( ch & 0x3 f f ) + 0x d c00 ) ) ; repl = sb . to string ( ) ; } entity = int entity . create ( new string ( original char ) , repl ) ; m cached entity . put ( cache key , entity ) ; } return entity ; }
public string find uri by prefix ( string prefix ) { / * this be quite simple : just need to locate the last mapping * for the prefix , if any : * / string [ ] strs = m ns string ; int phash = prefix . hash code ( ) ; for ( int ix = m scope end - 2 ; ix > = 0 ; ix -= 2 ) { string this p = strs [ ix ] ; if ( this p == prefix || ( this p . hash code ( ) == phash & & this p . equal ( prefix ) ) ) { return strs [ ix+1 ] ; } } return null ; }
public static void throw generic internal ( ) { throw internal ( null ) ; }
public string find last from map ( string key ) { int index = m size ; while ( ( index -= 2 ) > = 0 ) { if ( m string [ index ] == key ) { return m string [ index+1 ] ; } } return null ; }
public boolean be namespace aware ( ) { return namespace aware ; }
public xml path use ( j a x b object mapper factory factory ) { return new xml path ( this , get xml path config ( ) . jaxb object mapper factory ( factory ) ) ; }
public xml path use ( xml path config config ) { return new xml path ( this , config ) ; }
public void set fraction ( big decimal fraction ) { _fs = fraction == null ? g date . _zero : fraction ; }
public final boolean be immutable ( ) { return true ; }
public void normalize ( ) { _normalize impl ( true ) ; }
public synchronize void acquire ( ) throw interrupted exception { while ( try to acquire ( ) == false ) { wait ( ) ; } }
public static boolean be x m l11 space ( int c ) { return ( c < 0x10000 & & ( char [ c ] & mask_space ) ! = 0 ) || c == 0x85 || c == 0x2028 ; } // be x m l11 space ( int ) : boolean
public static boolean be n c name ( int c ) { return c < 0x10000 & & ( char [ c ] & mask_ncname ) ! = 0 ; } // be n c name ( int ) : boolean
public static boolean be valid n c name ( string nc name ) { if ( nc name . length ( ) == 0 ) return false ; char ch = nc name . char at ( 0 ) ; if ( be n c name start ( ch ) == false ) return false ; for ( int i = 1 ; i < nc name . length ( ) ; i++ ) { ch = nc name . char at ( i ) ; if ( be n c name ( ch ) == false ) { return false ; } } return true ; } // be valid n c name ( string ) : boolean
public name set invert ( ) { return new instance ( ! _is finite , _finite set ) ; }
public void add ( string name ) { if ( _is finite ) _finite set . add ( name ) ; else _finite set . remove ( name ) ; }
public void set design ( int design type ) { if ( design type ! =design_russian_doll & & design type ! =design_salami_slice & & design type ! =design_venetian_blind ) throw new illegal argument exception ( `` unknown value for design type . `` ) ; _design = design type ; }
public string get content type ( ) { string a [ ] = get mime header ( `` content- type `` ) ; if ( a ! = null & & a . length > 0 ) { return a [ 0 ] ; } else { return null ; } }
public iterator get all header ( ) { return header . iterator ( ) ; }
public iterator get non match header ( string names [ ] ) { return new match iterator ( name , false ) ; }
public synchronize throwable init cause ( throwable cause ) { if ( this . cause ! = null ) { throw new illegal state exception ( `` ca n't override cause `` ) ; } if ( cause == this ) { throw new illegal argument exception ( `` self-causation not permit `` ) ; } else { this . cause = cause ; return this ; } }
public void set no upa ( boolean noupa ) { this . noupa = noupa ; }
public void set no ext ( boolean noext ) { this . noext = noext ; }
static public byte [ ] encode ( byte [ ] binary data ) { if ( binary data == null ) return null ; int length data = binary data . length ; int length encode = length data * 2 ; byte [ ] encode data = new byte [ length encode ] ; for ( int i = 0 ; i < length data ; i++ ) { encode data [ i * 2 ] = look up hex alphabet [ ( binary data [ i ] > > 4 ) & 0xf ] ; encode data [ i * 2+1 ] = look up hex alphabet [ binary data [ i ] & 0xf ] ; } return encoded data ; }
public static string decode ( string binary data ) { if ( binary data == null ) return null ; byte [ ] decode = null ; try { decoded = decode ( binary data . get byte ( `` utf-8 `` ) ) ; } catch ( unsupported encode exception e ) { } return decode == null ? null : new string ( decode ) ; }
protect int value_hash_code ( ) { if ( _value . scale ( ) > 0 ) { if ( _value . set scale ( 0 , big decimal . round_down ) . compare to ( _value ) ! = 0 ) return decimal hash code ( ) ; } big integer intval = _value . to big integer ( ) ; if ( intval . compare to ( _maxlong ) > 0 || intval . compare to ( _minlong ) < 0 ) return intval . hash code ( ) ; long longval = intval . long value ( ) ; return ( int ) ( ( longval > > 32 ) * 19 + longval ) ; }
public boolean contains ( q name name ) { boolean in = _included u r be . contains ( n from name ( name ) ) ? ! _excluded q name . contains ( name ) : _included q name . contains ( name ) ; return _inverted ^ in ; }
public boolean be empty ( ) { return ! _inverted & & _included u r be . be empty ( ) & & _included q name . be empty ( ) ; }
public void add ( q name qname ) { if ( ! _inverted ) add impl ( qname ) ; else remove impl ( qname ) ; }
public void restrict ( q name set specification set ) { if ( _inverted ) add all impl ( set . exclude u r be ( ) , set . include u r be ( ) , set . excluded q name in included u r be ( ) , set . included q name in excluded u r be ( ) ) ; else remove all impl ( set . exclude u r be ( ) , set . include u r be ( ) , set . excluded q name in included u r be ( ) , set . included q name in excluded u r be ( ) ) ; }
public static schema type type for class ( class c ) { if ( c == null || ! xml object . class . be assignable from ( c ) ) return null ; try { field type field = c . get field ( `` type `` ) ; if ( type field == null ) return null ; return ( schema type ) type field . get ( null ) ; } catch ( exception e ) { return null ; } }
protect void compute time ( ) { boolean unset year = ! be set ( year ) ; if ( unset year ) set ( year , get default year ( ) ) ; try { super . compute time ( ) ; } finally { if ( unset year ) clear ( year ) ; } }
public xml option set document type ( schema type type ) { return set ( document_type , type ) ; }
public xml option set validate on set ( ) { return set ( validate_on_set ) ; }
public static xml option mask null ( xml option o ) { return ( o == null ) ? empty_options : o ; }
public list iterator list iterator ( ) { return list iterator ( 0 ) ; }
public static string make absolute ( element node , string uri string ) { document doc = node . get owner document ( ) ; return make absolute ( node , uri string , doc . get base u r i ( ) ) ; }
public static uri make u r i ( string pathname ) { string userdir = system . get property ( `` user . dir `` ) ; userdir = userdir . replace ( '\\ ' , '/ ' ) ; string sep = `` / `` ; if ( userdir . end with ( `` / `` ) ) { sep = `` `` ; } try { if ( pathname . start with ( `` / `` ) ) { return new uri ( `` file : // `` + pathname ) ; } uri file = null ; if ( userdir . start with ( `` / `` ) ) { file = new uri ( `` file : // `` + userdir + sep + pathname ) ; } else { file = new uri ( `` file : /// `` + userdir + sep + pathname ) ; } return file ; } catch ( u r i syntax exception use ) { logger . warn ( `` invalid uri syntax in base uri : `` + pathname + `` ( in `` + userdir + `` with \ `` `` + sep + `` \ `` ) `` ) ; return null ; } }
public string add u r i ( resource connection connection ) throw i o exception { return _add namespace u r i ( connection , null , null ) ; }
public diff builder normalize whitespace ( ) { normalize whitespace = true ; return this ; }
public static builder from node ( node n ) { return new source hold builder ( new d o m source ( n ) ) ; }
public static builder from file ( string name ) { return new stream builder ( new file ( name ) ) ; }
public static builder source ( source s ) { return new transformation builder ( s ) ; }
protect static string get x path ( x path context ctx ) { return ctx == null ? null : ctx . get x path ( ) ; }
public string to string ( comparison formatter formatter ) { return formatter . get description ( this ) ; }
public void add match listener ( comparison listener l ) { match listener . add ( l ) ; }
public comparison get comparison ( ) { return comparison ; }
public static element selector not ( final element selector e ) { if ( e == null ) { throw new illegal argument exception ( `` es must not be null `` ) ; } return new element selector ( ) { @ override public boolean can be compare ( element control element , element test element ) { return ! e . can be compare ( control element , test element ) ; } } ; }
public static element selector and ( final element selector . . . selector ) { if ( selector == null ) { throw new illegal argument exception ( selectors_must_not_be_null ) ; } final collection < element selector > s = array . a list ( selector ) ; if ( any ( s , new be null predicate ( ) ) ) { throw new illegal argument exception ( `` selector must not contain null value `` ) ; } return new element selector ( ) { @ override public boolean can be compare ( element control element , element test element ) { return all ( s , new can be compare predicate ( control element , test element ) ) ; } } ; }
public static element selector selector for element name ( final q name expect name , final element selector e ) { if ( expect name == null ) { throw new illegal argument exception ( `` expect name must not be null `` ) ; } return conditional selector ( element name predicate ( expect name ) , es ) ; }
public static element selector by x path ( string xpath , element selector child selector ) { return by x path ( xpath , null , child selector ) ; }
public void transform to ( result r ) { if ( source == null ) { throw new illegal state exception ( `` source must not be null `` ) ; } if ( r == null ) { throw new illegal argument exception ( `` result must not be null `` ) ; } try { transformer factory fac = factory ; if ( fac == null ) { fac = transformer factory configurer . default . configure ( transformer factory . new instance ( ) ) ; } transformer t ; if ( style sheet ! = null ) { t = fac . new transformer ( style sheet ) ; } else { t = fac . new transformer ( ) ; } if ( uri resolver ! = null ) { t . set u r i resolver ( uri resolver ) ; } if ( error listener ! = null ) { t . set error listener ( error listener ) ; } t . set output property ( output ) ; for ( map . entry < string , object > ent : params . entry set ( ) ) { t . set parameter ( ent . get key ( ) , ent . get value ( ) ) ; } t . transform ( source , r ) ; } catch ( javax . xml . transform . transformer configuration exception e ) { throw new configuration exception ( e ) ; } catch ( javax . xml . transform . transformer exception e ) { throw new x m l unit exception ( e ) ; } }
public static input source to input source ( source s ) { return to input source ( s , null ) ; }
public static < e > list < e > a list ( iterable < e > i ) { if ( i instanceof collection ) { return new array list < e > ( ( collection < e > ) i ) ; } array list < e > a = new array list < e > ( ) ; for ( e e : i ) { a . add ( e ) ; } return a ; }
public static < t > boolean any ( final iterable < t > sequence , final predicate < ? super t > predicate ) { for ( t t : sequence ) { if ( predicate . test ( t ) ) { return true ; } } return false ; }
public static node strip element content whitespace ( node original ) { node clone = original . clone node ( true ) ; clone . normalize ( ) ; strip e c w ( clone ) ; return clone ; }
public string to string ( ) { return to string ( formatter ) ; }
public static xml infoset builder new instance ( ) throw xml builder exception { xml infoset builder impl = new xml infoset builder impl ( ) ; try { impl . factory = xml pull parser factory . new instance ( system . get property ( xml pull parser factory . property_name ) , null ) ; impl . factory . set namespace aware ( true ) ; } catch ( xml pull parser exception ex ) { throw new xml builder exception ( `` could not create xml pull factory : `` +ex , ex ) ; } return impl ; }
public xml document new document ( ) throw xml builder exception { return new document ( null , null , null ) ; }
public string get name ( ) { return property name ; }
public static boolean be swing available ( ) { return be swing available ; }
public void default write object ( ) throw i o exception { peek callback ( ) . default write object ( ) ; }
protect string encode node ( string name ) { return name coder . encode node ( name ) ; }
public path get path ( ) { if ( current path == null ) { string [ ] chunk = new string [ pointer + 1 ] ; chunk [ 0 ] = `` `` ; for ( int i = -pointer ; ++i < = 0 ; ) { final string name = peek element ( i ) ; chunk [ i + pointer ] = name ; } current path = new path ( chunk ) ; } return current path ; }
public object get property ( string name ) throw s a x not recognize exception { if ( ( name . equal ( configured_xstream_property ) ) || ( name . equal ( source_object_list_property ) ) ) { return this . property . get ( name ) ; } else { throw new s a x not recognize exception ( name ) ; } }
public string unescape name ( string name ) { return super . decode node ( name ) ; }
protect builder create builder ( ) { final builder builder = get builder ( ) ; return builder ! = null ? builder : new builder ( ) ; }
public object from x m l ( final hierarchical stream driver driver , final reader xml ) throw i o exception , class not find exception { return from x m l ( driver , xml , permission ) ; }
public jsonb deserializer < t > get jsonb deserializer ( ) { return jsonb deserializer ; }
public string get binary data strategy ( ) { return binary data strategy ; }
public boolean be strict i json ( ) { return strict i json ; }
public instance creator get instance creator ( ) { return instance creator ; }
public json structure get root structure ( ) { return root ; }
public < t > void serialize root ( t root , json generator generator ) { if ( root == null ) { get jsonb context ( ) . get config property ( ) . get null serializer ( ) . serialize ( null , generator , this ) ; return ; } final jsonb serializer < t > root serializer = ( jsonb serializer < t > ) get root serializer ( root . get class ( ) ) ; if ( get jsonb context ( ) . get config property ( ) . be strict i json ( ) & & root serializer instanceof abstract value type serializer ) { throw new jsonb exception ( message . get message ( message key . ijson_enabled_single_value ) ) ; } root serializer . serialize ( root , generator , this ) ; }
public void set property order ( string [ ] property order ) { this . property order = property order ; }
public class customization build class customization ( ) { return new class customization ( this ) ; }
public serializer bind get serializer binding ( ) { return serializer binding ; }
public deserializer bind get deserializer binding ( ) { return deserializer binding ; }
public void set serialize number formatter ( jsonb number formatter serialize number formatter ) { this . serialize number formatter = serialize number formatter ; }
public < at extends annotation > at get annotation ( class < at > annotation class ) { return annotation class . cast ( annotation . get ( annotation class ) ) ; }
public creator model find by name ( string param name ) { for ( creator model param : params ) { if ( param . get name ( ) . equal ( param name ) ) { return param ; } } return null ; }
public static parameterized type find parameterized type ( class < ? > class to search , class < ? > parameterized interface ) { class current = class to search ; while ( current ! = object . class ) { for ( type current interface : current . get generic interface ( ) ) { if ( current interface instanceof parameterized type & & parameterized interface . be assignable from ( reflection utils . get raw type ( ( ( parameterized type ) current interface ) . get raw type ( ) ) ) ) { return ( parameterized type ) current interface ; } } current = current . get superclass ( ) ; } throw new jsonb exception ( message . get message ( message key . non_parametrized_type , parameterized interface ) ) ; }
public runtime type info get wrapper ( ) { return wrapper ; }
protect void before serialize ( t obj ) { }
protect type get value type ( type value type ) { if ( value type instanceof parameterized type ) { optional < type > runtime type optional = reflection utils . resolve optional type ( this , ( ( parameterized type ) value type ) . get actual type argument ( ) [ 0 ] ) ; return runtime type optional . or else ( object . class ) ; } return object . class ; }
public string to json ( t object , jsonb date formatter formatter , jsonb context jsonb context ) { if ( jsonb date format . time_in_millis . equal ( formatter . get format ( ) ) ) { return string . value of ( to instant ( object ) . to epoch milli ( ) ) ; } else if ( formatter . get date time formatter ( ) ! = null ) { return format with formatter ( object , formatter . get date time formatter ( ) ) ; } else { date time formatter config date time formatter = jsonb context . get config property ( ) . get config date formatter ( ) . get date time formatter ( ) ; if ( config date time formatter ! = null ) { return format with formatter ( object , config date time formatter ) ; } } if ( jsonb context . get config property ( ) . be strict i json ( ) ) { return format strict i json ( object ) ; } return format default ( object , jsonb context . get config property ( ) . get locale ( formatter . get locale ( ) ) ) ; }
protect string format with formatter ( t value , date time formatter formatter ) { return formatter . format ( to temporal accessor ( value ) ) ; }
public type get generic type ( ) { return generic type ; }
public i deserializer provider get deserializer provider ( ) { return deserializer provider ; }
public void advance parser to end ( ) { while ( ! level . be parse ( ) & & jsonb parser . have next ( ) ) { next ( ) ; } }
public double get covariance ( string field x , string field y ) { if ( field x . equal ( field y ) ) { check field ( field x , result . variance ) ; return result . variance . get ( field x ) ; } return get val from upper triangular matrix ( result . covariance , field x , field y ) ; }
public set < d f a state > get dangle state ( ) { return dangle state ; }
public semantic context get semantic context for alt ( d f a state d , int alt ) { map < integer , semantic context > alt to pred map = state to alt set with semantic predicate map . get ( d ) ; if ( alt to pred map==null ) { return null ; } return alt to pred map . get ( utils . integer ( alt ) ) ; }
public boolean be reduce ( ) { return reduce ; }
public boolean equal ( object o ) { if ( o==null ) { return false ; } n f a configuration other = ( n f a configuration ) o ; return this . state==other . state & & this . alt==other . alt & & this . context . equal ( other . context ) & & this . semantic context . equal ( other . semantic context ) ; }
public static string replace ( string src , string replacee , string replacer ) { string builder result = new string builder ( src . length ( ) + 50 ) ; int start index = 0 ; int end index = src . index of ( replacee ) ; while ( end index ! = -1 ) { result . append ( src . substring ( start index , end index ) ) ; if ( replacer ! =null ) { result . append ( replacer ) ; } start index = end index + replacee . length ( ) ; end index = src . index of ( replacee , start index ) ; } result . append ( src . substring ( start index , src . length ( ) ) ) ; return result . to string ( ) ; }
public list < grammar > get indirect delegate ( grammar g ) { list < grammar > direct = get direct delegate ( g ) ; list < grammar > delegate = get delegate ( g ) ; if ( direct ! =null ) { delegate . remove all ( direct ) ; } return delegate ; }
public static st get location format ( ) { return format . get instance of ( `` location `` ) ; }
public void set token boundary ( token start token , token stop token ) { if ( start token ! =null ) start index = start token . get token index ( ) ; if ( stop token ! =null ) stop index = stop token . get token index ( ) ; }
public string to string ( ) { return to string ( to notify string ( ) ) ; }
public state cluster build_ atom ( int label , grammar a s t associate a s t ) { n f a state leave = new state ( ) ; n f a state right = new state ( ) ; leave . associate a s t node = associate a s t ; right . associate a s t node = associate a s t ; transition between state ( leave , right , label ) ; state cluster g = new state cluster ( leave , right ) ; return g ; }
public void panic ( ) { throw new error ( `` antlr panic `` ) ; }
public boolean be verbose ( ) { return verbose ; }
public void set print grammar ( boolean print grammar ) { this . print grammar = print grammar ; }
public void set make ( boolean make ) { this . make = make ; }
public int get number of syntax error ( ) { return state . syntax error ; }
public void add listener ( debug event listener listener ) { listener . add ( listener ) ; }
public void set debug listener ( debug event listener dbg ) { if ( input instanceof debug token stream ) { ( ( debug token stream ) input ) . set debug listener ( dbg ) ; } this . dbg = dbg ; }
public void seek ( int index ) { if ( index < 0 ) { throw new illegal argument exception ( `` ca n't seek before the beginning of the input `` ) ; } int delta = current element index - index ; if ( p - delta < 0 ) { throw new unsupported operation exception ( `` ca n't seek before the beginning of this stream 's buffer `` ) ; } p -= delta ; current element index = index ; }
public void set token stream ( token stream input ) { this . input = null ; reset ( ) ; this . input = input ; }
public void add child ( object t , object child ) { if ( t ! =null & & child ! =null ) { ( ( tree ) t ) . add child ( ( tree ) child ) ; } }
public token create token ( int token type , string text ) { return new common token ( token type , text ) ; }
public object create ( string pattern ) { tree pattern lexer tokenizer = new tree pattern lexer ( pattern ) ; tree pattern parser parser = new tree pattern parser ( tokenizer , this , adaptor ) ; object t = parser . pattern ( ) ; return t ; }
public void add highlight node ( collection < tree > node ) { highlight node = new array list < tree > ( ) ; highlight node . add all ( node ) ; }
public string get message ( ) { return name ; }
protect byte [ ] generate key ( string pas phrase ) { byte encode byte array [ ] = character encode string ( pass phrase ) ; byte pad byte array [ ] = pad string ( encoded byte array ) ; byte [ ] secret key = fan fold ( pad byte array ) ; secret key = set parity ( secret key ) ; secret key = get strong key ( secret key ) ; secret key = calculate checksum ( pad byte array , secret key ) ; secret key = set parity ( secret key ) ; secret key = get strong key ( secret key ) ; return secret key ; }
public int get max life ( ) { return max life ; }
public kerberos time get password end ( ) { return password end ; }
public kerberos time get valid end ( ) { return valid end ; }
public void set distinguish name ( string distinguish name ) { this . distinguish name = distinguish name ; }
public void set valid end ( kerberos time valid end ) { this . valid end = valid end ; }
public static grammar < ad and or container > get instance ( ) { return instance ; }
public void set authenticator ( authenticator authenticator ) { this . authenticator = authenticator ; }
public void set enc kdc rep part ( enc kdc rep part enc kdc rep part ) { this . enc kdc rep part = enc kdc rep part ; }
public void set e type info entry ( e type info entry etype info entry ) { this . etype info entry = etype info entry ; }
public void set krb error ( krb error krb error ) { this . krb error = krb error ; }
public void set ( int index ) { if ( ( index < 0 ) || ( index > = size ( ) ) ) { return ; } set bit ( index ) ; }
public string get s realm ( ) { return srealm ; }
public void set kvno ( int kvno ) { this . kvno = kvno ; have kvno = true ; }
public void set additional ticket ( list < ticket > additional ticket ) { this . additional ticket = additional ticket ; }
public void create new l r ( ) { current l r = new last req entry ( ) ; last reqs . add ( current l r ) ; }
public void add entry ( last req entry last req entry ) { last reqs . add ( last req entry ) ; }
public int compare to ( error type that ) { return value - that . value ; }
public boolean be initial ( ) { return be flag set ( ticket flag . initial ) ; }
public string to string ( ) { string builder result = new string builder ( ) ; if ( be flag set ( ticket flag . reserve ) ) { result . append ( `` reserve ( 0 ) `` ) ; } if ( be flag set ( ticket flag . forwardable ) ) { result . append ( `` forwardable ( 1 ) `` ) ; } if ( be flag set ( ticket flag . forward ) ) { result . append ( `` forward ( 2 ) `` ) ; } if ( be flag set ( ticket flag . proxiable ) ) { result . append ( `` proxiable ( 3 ) `` ) ; } if ( be flag set ( ticket flag . proxy ) ) { result . append ( `` proxy ( 4 ) `` ) ; } if ( be flag set ( ticket flag . may_postdate ) ) { result . append ( `` may_postdate ( 5 ) `` ) ; } if ( be flag set ( ticket flag . postdate ) ) { result . append ( `` postdate ( 6 ) `` ) ; } if ( be flag set ( ticket flag . invalid ) ) { result . append ( `` invalid ( 7 ) `` ) ; } if ( be flag set ( ticket flag . renewable ) ) { result . append ( `` renewable ( 8 ) `` ) ; } if ( be flag set ( ticket flag . initial ) ) { result . append ( `` initial ( 9 ) `` ) ; } if ( be flag set ( ticket flag . pre_authent ) ) { result . append ( `` pre_authent ( 10 ) `` ) ; } if ( be flag set ( ticket flag . hw_authent ) ) { result . append ( `` hw_authent ( 11 ) `` ) ; } if ( be flag set ( ticket flag . transited_policy_checked ) ) { result . append ( `` transited_policy_checked ( 12 ) `` ) ; } if ( be flag set ( ticket flag . ok_as_delegate ) ) { result . append ( `` ok_as_delegate ( 13 ) `` ) ; } return result . to string ( ) . trim ( ) ; }
public void set date ( string date ) throw parse exception { synchronize ( kerberos utils . utc_date_format ) { kerberos time = kerberos utils . utc_date_format . parse ( date ) . get time ( ) ; } convert internal ( kerberos time ) ; }
public boolean get option ( int option ) { return ap option . get ( option ) ; }
public int compute length ( ) { kdc req length = super . compute length ( ) ; return 1 + tlv . get nb byte ( kdc req length ) + kdc req length ; }
public int compute length ( ) { enc kdc rep part length = enc kdc rep part . compute length ( ) ; return 1 + tlv . get nb byte ( enc kdc rep part length ) + enc kdc rep part length ; }
public byte [ ] get data ( ) { byte [ ] copy = new byte [ byte . length + 1 ] ; system . arraycopy ( byte , 0 , copy , 1 , byte . length ) ; copy [ 0 ] = ( byte ) nb unused bit ; return copy ; }
public final byte [ ] buffer ( ) { return buf ; }
public final byte [ ] copy of use byte ( ) { byte [ ] copy = new byte [ po ] ; system . arraycopy ( buf , 0 , copy , 0 , po ) ; return copy ; }
public static boolean be char a s c i i ( char [ ] char , int index , char car ) { if ( ( char == null ) || ( char . length == 0 ) || ( index < 0 ) || ( index > = char . length ) ) { return false ; } else { return ( ( char [ index ] == car ) ? true : false ) ; } }
public static boolean be hex ( byte b ) { return ( ( b | 0x7 f ) == 0x7 f ) || hex [ b ] ; }
public boolean final state valid ( ) { return all component use ( ) ; }
public static char byte to char ( byte [ ] bytes ) { return bytes to char ( byte , 0 ) ; }
public static int count char ( byte [ ] bytes ) { if ( bytes == null ) { return 0 ; } int nb char = 0 ; int current po = 0 ; while ( current po < byte . length ) { current po += count byte per char ( byte , current po ) ; nb chars++ ; } return nb char ; }
public void start polling ( final poll configuration source source , final configuration config ) { initial load ( source , config ) ; runnable r = get poll runnable ( source , config ) ; schedule ( r ) ; }
public property get property ( ) { return instance ! =null ? instance . get property ( ) : new property ( ) ; }
public void set property ( string key , object value ) { container configuration . set property ( key , value ) ; }
public static abstract configuration get config instance ( ) { if ( instance == null & & ! boolean . get boolean ( dynamic property factory . disable_default_config ) ) { synchronize ( configuration manager . class ) { if ( instance == null ) { instance = new concurrent composite configuration ( ) ; if ( ! boolean . get boolean ( dynamic property factory . disable_default_sys_config ) ) { system configuration sys config = new system configuration ( ) ; ( ( concurrent composite configuration ) instance ) . add configuration ( sys config , dynamic property factory . sys_config_name ) ; try { dynamic u r l configuration default u r l config = new dynamic u r l configuration ( ) ; ( ( concurrent composite configuration ) instance ) . add configuration ( default u r l config , dynamic property factory . url_config_name ) ; } catch ( throwable e ) { logger . warn ( `` fail to create default dynamic configuration `` , e ) ; } } register config bean ( ) ; } } } return instance ; }
public boolean get ( ) { return prop . get boolean ( default value ) . boolean value ( ) ; }
public long get change timestamp ( ) { synchronize ( lock ) { return change time ; } }
public dynamic double property get double property ( string prop name , double default value , final runnable property change callback ) { check and warn ( prop name ) ; dynamic double property property = new dynamic double property ( prop name , default value ) ; add callback ( property change callback , property ) ; return property ; }
public string get id ( ) { return this . id ; } // -- string get id ( )
public void set site resource ( java . util . list < resource > site resource ) { this . site resource = site resource ; } // -- void set site resource ( java . util . list )
public void set test resource ( java . util . list < resource > test resource ) { this . test resource = test resource ; } // -- void set test resource ( java . util . list )
public void set file set ( java . util . list < file set > file set ) { this . file set = file set ; } // -- void set file set ( java . util . list )
public void set require property ( java . util . list < require property > require property ) { this . require property = require property ; } // -- void set require property ( java . util . list )
public string get encode ( ) { return this . encoding ; } // -- string get encoding ( )
public void set language ( java . util . list < string > language ) { this . languages = language ; } // -- void set language ( java . util . list )
public static void not null ( final object obj , final string message ) throw illegal argument exception { if ( obj == null ) { throw new illegal argument exception ( message ) ; } }
public static void configuration directory exists ( final string string , final string message ) throw configuration exception { if ( string == null || string . length ( ) == 0 || new file ( string ) . be directory ( ) == false ) { throw new configuration exception ( message ) ; } }
public void on ( @ observes ( precedence = -100 ) before test lifecycle event event ) throw throwable { event . get executor ( ) . invoke ( ) ; }
public static < s > service loader < s > load ( class < s > service , class loader loader ) { if ( loader == null ) { loader = service . get class loader ( ) ; } return new service loader < s > ( service , loader ) ; }
public void activate ( ) { super . activate ( suite_context_id ) ; }
public static exception proxy create for exception ( throwable throwable ) { if ( throwable == null ) { return null ; } return new exception proxy ( throwable ) ; }
public image diff with diff size trigger ( final int diff size trigger ) { this . diff markup policy . set diff size trigger ( diff size trigger ) ; return this ; }
public buffer image get transparent mark image ( ) { return diff markup policy . get transparent mark image ( ) ; }
public static shooting strategy scaling ( shoot strategy shoot strategy , float dpr ) { return new scale decorator ( shoot strategy ) . with dpr ( dpr ) ; }
public static shooting strategy i pad landscape orientation simple ( cut strategy cut strategy ) { return new rotate decorator ( cut strategy , simple ( ) ) ; }
public void set custom munger factory ( object factory ) { build manager . set custom munger factory ( factory ) ; }
public void increment progress bar val ( ) { int new val = compile_progress bar . get value ( ) + 1 ; compile_progress bar . set value ( new val ) ; }
public boolean be target enum ( class scope class scope , string kind ) { if ( ( on type binding . get access flag ( ) & acc_enum ) ! =0 ) { class scope . problem reporter ( ) . signal error ( source start , source end , `` ca n't make inter-type `` +kind+ `` declaration on enum type . `` ) ; ignore further investigation = true ; return true ; } return false ; }
public boolean record dependency ( file file , string [ ] type name dependency ) { try { file source file = new file ( new string ( file . get canonical path ( ) ) ) ; reference collection exist collection = reference . get ( source file ) ; if ( exist collection ! = null ) { exist collection . add dependency ( type name dependency ) ; return true ; } else { reference collection rc = new reference collection ( null , null , null ) ; rc . add dependency ( type name dependency ) ; reference . put ( source file , rc ) ; return true ; } } catch ( i o exception ioe ) { ioe . print stack trace ( ) ; } return false ; }
public string get code string ( ) { string buffer code string = new string buffer ( ) ; code string . append ( `` code ( max_stack = `` ) . append ( max stack ) ; code string . append ( `` , max_locals = `` ) . append ( max local ) ; code string . append ( `` , code_length = `` ) . append ( code . length ) . append ( `` ) \n `` ) ; code string . append ( utility . code to string ( code , cpool , 0 , -1 , true ) ) ; if ( exception table . length > 0 ) { code string . append ( `` \n `` ) . append ( `` exception entry = `` ) . append ( exception table . length ) . append ( `` \n `` ) ; for ( int i = 0 ; i < exception table . length ; i++ ) { code exception exc = exception table [ i ] ; int type = exc . get catch type ( ) ; string name = `` finally `` ; if ( type ! = 0 ) { name = this . cpool . get constant string ( type , constant . c o n s t a n t_ class ) ; } code string . append ( name ) . append ( `` [ `` ) ; code string . append ( exc . get start p c ( ) ) . append ( `` > `` ) . append ( exc . get end p c ( ) ) . append ( `` ] \n `` ) ; } } return code string . to string ( ) ; }
public org . aspectj . apache . bcel . util . repository get repository ( ) { if ( repository == null ) { repository = synthetic repository . get instance ( ) ; } return repository ; }
public final void dump ( data output stream file ) throw i o exception { super . dump ( file ) ; if ( be in packed state ) { file . write ( data ) ; } else { file . write short ( local variable table length ) ; for ( int i = 0 ; i < local variable table length ; i++ ) local variable table [ i ] . dump ( file ) ; } }
public int get position ( ) { return bi . position of this instruction ; }
public code exception get code exception ( constant pool cp ) { return new code exception ( start_pc . get position ( ) , end_pc . get position ( ) + end_pc . get instruction ( ) . get length ( ) , handler_pc . get position ( ) , ( catch_type == null ) ? 0 : cp . add class ( catch_type ) ) ; }
public void add targeter ( instruction targeter t ) { if ( targeters == collection . empty_set ) { targeters = new hash set < instruction targeter > ( ) ; } targeters . add ( t ) ; }
public boolean reference class ( ) { java class jc = repository . lookup class ( classname ) ; if ( jc == null ) { return false ; } else { return jc . be class ( ) ; } }
public boolean reference interface ( ) { java class jc = repository . lookup class ( classname ) ; if ( jc == null ) { return false ; } else { return ! jc . be class ( ) ; } }
public static char get delimiter ( i program element ipe ) { i program element . kind kind = ipe . get kind ( ) ; if ( kind . equal ( i program element . kind . project ) ) { return javaproject . get delimiter ( ) ; } else if ( kind . equal ( i program element . kind . package ) ) { return packagefragment . get delimiter ( ) ; } else if ( kind . equal ( i program element . kind . file_java ) ) { if ( ipe . get name ( ) . end with ( `` . aj `` ) ) { return aspect_cu . get delimiter ( ) ; } else { return compilationunit . get delimiter ( ) ; } } else if ( kind . equal ( i program element . kind . file_aspectj ) ) { return aspect_cu . get delimiter ( ) ; } else if ( kind . equal ( i program element . kind . import_reference ) ) { return importdeclaration . get delimiter ( ) ; } else if ( kind . equal ( i program element . kind . package_declaration ) ) { return packagedeclaration . get delimiter ( ) ; } else if ( kind . equal ( i program element . kind . class ) || kind . equal ( i program element . kind . interface ) || kind . equal ( i program element . kind . enum ) || kind . equal ( i program element . kind . annotation ) ) { return type . get delimiter ( ) ; } else if ( kind . equal ( i program element . kind . aspect ) ) { if ( ipe . be annotation style declaration ( ) ) { return type . get delimiter ( ) ; } else { return aspect_type . get delimiter ( ) ; } } else if ( kind . equal ( i program element . kind . initializer ) ) { return initializer . get delimiter ( ) ; } else if ( kind . equal ( i program element . kind . inter_type_field ) ) { return itd_field . get delimiter ( ) ; } else if ( kind . equal ( i program element . kind . inter_type_method ) || kind . equal ( i program element . kind . inter_type_constructor ) || kind . equal ( i program element . kind . inter_type_parent ) ) { return itd . get delimiter ( ) ; } else if ( kind . equal ( i program element . kind . constructor ) || kind . equal ( i program element . kind . method ) ) { return method . get delimiter ( ) ; } else if ( kind . equal ( i program element . kind . field ) || kind . equal ( i program element . kind . enum_value ) ) { return field . get delimiter ( ) ; } else if ( kind . equal ( i program element . kind . pointcut ) ) { if ( ipe . be annotation style declaration ( ) ) { return method . get delimiter ( ) ; } else { return pointcut . get delimiter ( ) ; } } else if ( kind . equal ( i program element . kind . advice ) ) { if ( ipe . be annotation style declaration ( ) ) { return method . get delimiter ( ) ; } else { return advice . get delimiter ( ) ; } } else if ( kind . equal ( i program element . kind . declare_parents ) || kind . equal ( i program element . kind . declare_warning ) || kind . equal ( i program element . kind . declare_error ) || kind . equal ( i program element . kind . declare_soft ) || kind . equal ( i program element . kind . declare_precedence ) || kind . equal ( i program element . kind . declare_annotation_at_constructor ) || kind . equal ( i program element . kind . declare_annotation_at_field ) || kind . equal ( i program element . kind . declare_annotation_at_method ) || kind . equal ( i program element . kind . declare_annotation_at_type ) ) { return declare . get delimiter ( ) ; } else if ( kind . equal ( i program element . kind . code ) ) { return codeelement . get delimiter ( ) ; } else if ( kind == i program element . kind . file ) { if ( ipe . get name ( ) . end with ( `` . class `` ) ) { return classfile . get delimiter ( ) ; } else if ( ipe . get name ( ) . end with ( `` . aj `` ) ) { return aspect_cu . get delimiter ( ) ; } else if ( ipe . get name ( ) . end with ( `` . java `` ) ) { return compilationunit . get delimiter ( ) ; } else { return empty ; } } return empty ; }
public static abort exception borrow porter ( i message message ) { abort exception result ; synchronize ( porter ) { if ( porter . size ( ) > 0 ) { result = porter . get ( 0 ) ; } else { result = new abort exception ( ) ; result . set be silent ( false ) ; } } result . set i message ( message ) ; result . be porter = true ; return result ; }
public static boolean abort ( i message handler handler , string message ) { return ( ( null ! = handler ) & & handler . handle message ( abort ( message ) ) ) ; }
public static boolean warn ( i message handler handler , string message ) { return ( ( null ! = handler ) & & handler . handle message ( warn ( message ) ) ) ; }
public static boolean info ( i message handler handler , string message ) { return ( ( null ! = handler ) & & handler . handle message ( info ( message ) ) ) ; }
public static boolean handle all ( i message handler sink , i message holder source , i message . kind kind , boolean or great , boolean fast fail ) { lang util . throw iax if null ( sink , `` sink `` ) ; lang util . throw iax if null ( source , `` source `` ) ; return handle all ( sink , source . get message ( kind , or great ) , fast fail ) ; }
public static boolean handle all except ( i message handler sink , i message holder source , i message . kind kind , boolean or great , boolean fast fail ) { lang util . throw iax if null ( sink , `` sink `` ) ; lang util . throw iax if null ( source , `` source `` ) ; if ( null == kind ) { return true ; } i message [ ] message = get message except ( source , kind , or great ) ; return handle all ( sink , message , fast fail ) ; }
public boolean handle message ( i message message ) throw abort exception { if ( ( null ! = message ) & & ! be ignore ( message . get kind ( ) ) ) { string result = render ( message ) ; if ( null ! = result ) { writer . println ( result ) ; writer . flush ( ) ; if ( abort on failure & & ( message . be failed ( ) || message . be abort ( ) ) ) { throw new abort exception ( message ) ; } } } return true ; }
public aspect declaration new aspect declaration ( ) { aspect declaration result = new aspect declaration ( this ) ; return result ; }
public static list property descriptor ( int api level ) { if ( api level == ast . jls2_internal ) { return aspect p r o p e r t y_ d e s c r i p t o r s_2_0 ; } else { return aspect p r o p e r t y_ d e s c r i p t o r s_3_0 ; } }
public void set error raise ( boolean b ) { _error raise = true ; }
public void reset ( ) { _has be call = false ; }
public string get property ( string key , string default value ) throw index exception { string val= get property ( key ) ; return ( val == null ) ? default value : val ; }
public long remove ( string str ) throw core exception { if ( this . lazy cache ! = null ) this . lazy cache . remove ( str ) ; long prev = 0 ; long curr = get head ( ) ; while ( curr ! = 0 ) { long next = node type . next . get ( this . db , curr ) ; long item = node type . item . get ( this . db , curr ) ; i string string = this . db . get string ( item ) ; if ( string . compare ( str , true ) == 0 ) { if ( this . head ! = curr ) node type . next . put ( this . db , prev , next ) ; else { this . db . put rec ptr ( this . ptr , next ) ; this . head = next ; } this . db . free ( curr , database . pool_string_set ) ; return item ; } prev = curr ; curr = next ; } return 0 ; }
public static i path get location for path ( i path path ) { i workspace root root = resource plugin . get workspace ( ) . get root ( ) ; i resource resource = root . find member ( path ) ; if ( resource ! = null ) { return resource . get location ( ) ; } return path ; }
protect static boolean get bit ( int bit vector , int offset ) { int mask = 1 < < offset ; return ( bit vector & mask ) ! = 0 ; }
public collection < v > value ( ) { return this . map . value ( ) ; }
public boolean be empty ( ) { return this . map . be empty ( ) ; }
public void set nosymbols ( boolean nosymbols ) { this . nosymbols = nosymbols ; }
public argfile create argfile ( ) { argfile argfile = new argfile ( ) ; if ( argfiles == null ) { argfiles = new array list ( ) ; } argfiles . add ( argfile ) ; return argfile ; }
public void set s ( string s ) { cmd . add flag ( `` -s `` , s ) ; }
public void set compliance ( string input ) { string ignore = cmd . add option ( null , compliance_inputs , input ) ; if ( null ! = ignore ) { ignore ( ignore ) ; } }
protect void setup option ( ) { if ( null ! = xweave dir ) { if ( default_destdir ! = d dir ) { throw new build exception ( `` weave dir force destdir `` ) ; } if ( null ! = outjar ) { throw new build exception ( `` weave dir force outjar `` ) ; } if ( null ! = injars ) { throw new build exception ( `` weave dir incompatible with injars now `` ) ; } if ( null ! = inpath ) { throw new build exception ( `` weave dir incompatible with inpath now `` ) ; } file injar = zip directory ( xweave dir ) ; set injars ( new path ( get project ( ) , injar . get absolute path ( ) ) ) ; set destdir ( xweave dir ) ; } }
public static int copy dir ( file from dir , file to dir , final string from suffix , string to suffix ) throw i o exception { return copy dir ( from dir , to dir , from suffix , to suffix , ( file filter ) null ) ; }
public static file make new child dir ( file parent , string child ) { if ( null == parent || ! parent . can write ( ) || ! parent . be directory ( ) ) { throw new illegal argument exception ( `` bad parent : `` + parent ) ; } else if ( null == child ) { child = `` make new child dir `` ; } else if ( ! be valid file name ( child ) ) { throw new illegal argument exception ( `` bad child : `` + child ) ; } file result = new file ( parent , child ) ; int safety = 1000 ; for ( string suffix = file util . random file string ( ) ; ( ( 0 < -- safety ) & & result . exists ( ) ) ; suffix = file util . random file string ( ) ) { result = new file ( parent , child + suffix ) ; } if ( result . exists ( ) ) { system . err . println ( `` exhaust file for child dir in `` + parent ) ; return null ; } return ( ( result . mkdirs ( ) & & result . exists ( ) ) ? result : null ) ; }
public static string read a string ( file file ) throw i o exception { buffered reader r = new buffer reader ( new file reader ( file ) ) ; string buffer b = new string buffer ( ) ; while ( true ) { int ch = r . read ( ) ; if ( ch == -1 ) { break ; } b . append ( ( char ) ch ) ; } r . close ( ) ; return b . to string ( ) ; }
public static object [ ] safe copy ( object [ ] source , object [ ] sink ) { final class < ? > sink type = ( null == sink ? object . class : sink . get class ( ) . get component type ( ) ) ; final int source length = ( null == source ? 0 : source . length ) ; final int sink length = ( null == sink ? 0 : sink . length ) ; final int result size ; array list < object > result = null ; if ( 0 == source length ) { result size = 0 ; } else { result = new array list < object > ( source length ) ; for ( int i = 0 ; i < source length ; i++ ) { if ( ( null ! = source [ i ] ) & & ( sink type . be assignable from ( source [ i ] . get class ( ) ) ) ) { result . add ( source [ i ] ) ; } } result size = result . size ( ) ; } if ( result size ! = sink length ) { sink = ( object [ ] ) array . new instance ( sink type , result . size ( ) ) ; } if ( 0 < result size ) { sink = result . to array ( sink ) ; } return sink ; }
public var get accessor for value ( resolve type formal type , string formal name ) { throw new illegal state exception ( `` only make sense for annotation variable `` ) ; }
public static string advice name ( string name a identifier , advice kind kind , int advice seq number , int pcd hash ) { string newname = make name ( kind . get name ( ) , name a identifier , integer . to string ( advice seq number ) , integer . to hex string ( pcd hash ) ) ; return newname ; }
public object visit ( wild type pattern node , object data ) { if ( node . get upper bound ( ) ! = null ) oh yes it have = true ; if ( node . get low bound ( ) ! = null ) oh yes it have = true ; if ( node . get type parameter ( ) . size ( ) ! = 0 ) oh yes it have = true ; return data ; }
public boolean can match signature with n parameter ( int num params ) { if ( ellipsis count == 0 ) { return num params == size ( ) ; } else { return ( size ( ) - ellipsis count ) < = num params ; } }
public annotation type pattern resolve binding ( i scope scope , binding binding , boolean allow bind ) { if ( ! scope . get world ( ) . be in java5 mode ( ) ) { scope . message ( message util . error ( weaver message . format ( weaver message . annotations_need_java5 ) , get source location ( ) ) ) ; return this ; } if ( resolve ) { return this ; } this . type pattern = type pattern . resolve binding ( scope , binding , false , false ) ; resolve = true ; if ( type pattern instanceof exact type pattern ) { exact type pattern et = ( exact type pattern ) type pattern ; if ( ! et . get exact type ( ) . resolve ( scope . get world ( ) ) . be annotation ( ) ) { i message m = message util . error ( weaver message . format ( weaver message . reference_to_non_annotation_type , et . get exact type ( ) . get name ( ) ) , get source location ( ) ) ; scope . get world ( ) . get message handler ( ) . handle message ( m ) ; resolve = false ; } resolve type annotation type = et . get exact type ( ) . resolve ( scope . get world ( ) ) ; resolve annotation value ( annotation type , scope ) ; exact annotation type pattern eatp = new exact annotation type pattern ( annotation type , annotation value ) ; eatp . copy location from ( this ) ; if ( be for parameter annotation match ( ) ) { eatp . set for parameter annotation match ( ) ; } return eatp ; } else { return this ; } }
public resolve type get generic resolve type ( ) { resolve type rt = get resolve type x ( ) ; if ( rt . be parameterized type ( ) || rt . be raw type ( ) ) { return rt . get generic type ( ) ; } return rt ; }
public final iterator < resolve type > get direct supertypes ( ) { iterator < resolve type > interface iterator = iterators . array ( get declare interface ( ) ) ; resolve type superclass = get superclass ( ) ; if ( superclass == null ) { return interface iterator ; } else { return iterators . snoc ( interface iterator , superclass ) ; } }
public boolean can annotation target type ( ) { return false ; }
public resolve member lookup member no super ( member member ) { resolved member ret = lookup directly declare member no super ( member ) ; if ( ret == null & & inter type mungers ! = null ) { for ( concrete type munger tm : inter type mungers ) { if ( match ( tm . get signature ( ) , member ) ) { return tm . get signature ( ) ; } } } return ret ; }
public member get signature ( ) { return signature ; }
protect string format args ( object [ ] args ) { string buffer sb = new string buffer ( ) ; for ( int i = 0 ; i < args . length ; i++ ) { sb . append ( format obj ( args [ i ] ) ) ; if ( i < args . length-1 ) sb . append ( `` , `` ) ; } return sb . to string ( ) ; }
public cache key resolver create resolver ( ) { return new default cache key resolver ( ) ; }
public generate class handler get caching class handler ( ) { return cache class handler ; }
public static list < weave class cache > get cache ( ) { synchronize ( cache registry ) { return new link list < weave class cache > ( cache registry ) ; } }
public void add context binding ( string name , object value ) { this . context map . put ( name , value ) ; }
public static pointcut parser get pointcut parser support specify primitive and use context classloader for resolution ( set < pointcut primitive > support pointcut kind ) { pointcut parser p = new pointcut parser ( supported pointcut kind ) ; p . set class loader ( thread . current thread ( ) . get context class loader ( ) ) ; return p ; }
public i message handler get message handler ( ) { return message handler ; }
public void set error and warn threshold ( boolean error threshold , boolean warning threshold ) { this . error threshold = error threshold ; this . warn threshold = warn threshold ; }
public property get extra configuration ( ) { return extra configuration ; }
public synchronize local variable table copy from pack state ( ) { if ( ! be in packed state ) throw new illegal state exception ( `` no in packed state `` ) ; try { return new local variable table ( name index , length , new data input stream ( new byte array input stream ( data ) ) , get constant pool ( ) ) ; } catch ( i o exception e ) { throw new runtime exception ( `` fail to unpack clone `` , e ) ; } }
public static char [ ] [ ] [ ] intern qualify name ( char [ ] [ ] [ ] qualify name ) { return intern qualify name ( qualified name , false ) ; }
public static string type to signature ( unresolved type [ ] param type ) { string buffer buf = new string buffer ( ) ; buf . append ( `` ( `` ) ; for ( unresolved type param type : param type ) { buf . append ( param type . get signature ( ) ) ; } buf . append ( `` ) `` ) ; return buf . to string ( ) ; }
public synchronize void unregister all adapter ( ) { factory . clear ( ) ; flush lookup ( ) ; }
public < t > mapping < t > get mapping ( class < t > clazz , boolean include parent field ) { return get mapping ( clazz , new default annotation set ( ) , include parent field ) ; }
public int length ( ) { return path . size ( ) ; }
public serializer < c > get serializer ( ) { return this . column serializer ; }
public string get checkpoint ( string start token ) { return token map . get ( start token ) ; }
public list < listenable future < operation result < void > > > replay wal ( int count ) { list < listenable future < operation result < void > > > future = list . new array list ( ) ; write ahead entry wal entry ; while ( null ! = ( wal entry = wal . read next entry ( ) ) & & count -- > 0 ) { mutation batch m = keyspace . prepare mutation batch ( ) ; try { wal entry . read mutation ( m ) ; future . add ( execute wal entry ( wal entry , m ) ) ; } catch ( wal exception e ) { wal . remove entry ( wal entry ) ; } } return future ; }
protect void rebuild partition ( ) { topology . refresh ( ) ; }
public static uuid uuid ( byte buffer bb ) { bb = bb . slice ( ) ; return new uuid ( bb . get long ( ) , bb . get long ( ) ) ; }
public string fill lock mutation ( mutation batch m , long time , integer ttl ) { if ( lock column ! = null ) { if ( ! lock column . equal ( prefix+lock id ) ) throw new illegal state exception ( `` ca n't change prefix or lock id after acquire the lock `` ) ; } else { lock column = prefix + lock id ; } long timeout value = ( time == null ) ? new long ( 0 ) : time + time unit . microsecond . convert ( timeout , timeout unit ) ; m . with row ( column family , key ) . put column ( lock column , generate timeout value ( timeout value ) , ttl ) ; return lock column ; }
public column prefix uniqueness constraint < k > with unique id ( string unique ) { lock . with lock id ( unique ) ; return this ; }
public dedicate multi row uniqueness constraint < c > with consistency level ( consistency level consistency level ) { this . consistency level = consistency level ; return this ; }
public string get version ( ) throw connection exception { return connection pool . execute with failover ( new abstract operation impl < string > ( tracer factory . new tracer ( cassandra operation type . get_version ) ) { @ override public string internal execute ( client client , connection context state ) throw exception { return client . describe_version ( ) ; } } , config . get retry policy ( ) . duplicate ( ) ) . get result ( ) ; }
public static codec factory from string ( string s ) { codec factory o = register . get ( s ) ; if ( o == null ) { throw new avro runtime exception ( `` unrecognized codec : `` + s ) ; } return o ; }
public synchronize void close ( ) throw i o exception { in . close ( ) ; }
public data file writer < d > append to ( file file ) throw i o exception { return append to ( new seekable file input ( file ) , new syncable file output stream ( file , true ) ) ; }
public data file writer < d > set meta ( string key , byte [ ] value ) { if ( be reserve meta ( key ) ) { throw new avro runtime exception ( `` can not set reserve meta key : `` + key ) ; } return set meta internal ( key , value ) ; }
public object get ( string field name ) { return get ( schema ( ) . get field ( field name ) ) ; }
public boolean have ( string field name ) { return have ( schema ( ) . get field ( field name ) ) ; }
public generic record builder clear ( string field name ) { return clear ( schema ( ) . get field ( field name ) ) ; }
public int get configure buffer size ( ) { return this . binary decoder buffer size ; }
public final void process implicit action ( ) throw i o exception { while ( pos > 1 ) { symbol top = stack [ pos - 1 ] ; if ( top . kind == symbol . kind . implicit_action ) { po -- ; symbol handler . do action ( null , top ) ; } else if ( top . kind ! = symbol . kind . terminal ) { po -- ; push production ( top ) ; } else { break ; } } }
public final void process trail implicit action ( ) throw i o exception { while ( pos > = 1 ) { symbol top = stack [ pos - 1 ] ; if ( top . kind == symbol . kind . implicit_action & & ( ( symbol . implicit action ) top ) . be trail ) { po -- ; symbol handler . do action ( null , top ) ; } else { break ; } } }
public symbol top symbol ( ) { return stack [ pos - 1 ] ; }
public string get doc ( ) { return doc ; }
public schema get type ( string name ) { return type . get ( name ) ; }
public static map builder < schema > map ( ) { return builder ( ) . map ( ) ; }
public utf8 set length ( int new length ) { return set byte length ( new length ) ; }
public list < byte buffer > get response payload ( ) { return this . response payload ; }
public void stop ( ) { if ( ! run ) throw new illegal state exception ( ) ; elapse = tick . tick ( ) - start ; run = false ; }
public void set remote ( protocol protocol ) { }
public final void configure region ( region region ) { check mutability ( ) ; if ( region == null ) throw new illegal argument exception ( `` no region provide `` ) ; this . set region ( region . get region ( region ) ) ; }
protect boolean use strict host name verification ( ) { return true ; }
public progress listener get general progress listener ( ) { return progress listener ; }
public t get result ( ) { return result ; }
public response metadata get response metadata ( ) { return response metadata ; }
public connection socket factory get ssl socket factory ( ) { return ssl socket factory ; }
public byte [ ] hash ( string text ) throw sdk client exception { return abstract a w s signer . do hash ( text ) ; }
public byte [ ] hash ( byte [ ] data ) throw sdk client exception { try { message digest md = get message digest instance ( ) ; md . update ( data ) ; return md . digest ( ) ; } catch ( exception e ) { throw new sdk client exception ( `` unable to compute hash while sign request : `` + e . get message ( ) , e ) ; } }
protect byte [ ] new sign key ( a w s credential credential , string date stamp , string region name , string service name ) { byte [ ] k secret = ( `` aws4 `` + credential . get a w s secret key ( ) ) . get byte ( charset . for name ( `` utf-8 `` ) ) ; byte [ ] k date = sign ( date stamp , k secret , sign algorithm . hmac s h a256 ) ; byte [ ] k region = sign ( region name , k date , sign algorithm . hmac s h a256 ) ; byte [ ] k service = sign ( service name , k region , sign algorithm . hmac s h a256 ) ; return sign ( aws4_terminator , k service , sign algorithm . hmac s h a256 ) ; }
public static string format date stamp ( long time milli ) { return date formatter . print ( time milli ) ; }
public long get number of day since epoch ( ) { return number of day since epoch ; }
public policy create policy from json string ( string json string ) { if ( json string == null ) { throw new illegal argument exception ( `` json string can not be null `` ) ; } json node policy node ; json node id node ; json node statement node ; policy policy = new policy ( ) ; list < statement > statement = new link list < statement > ( ) ; try { policy node = jackson . json node of ( json string ) ; id node = policy node . get ( json document field . policy_id ) ; if ( be not null ( id node ) ) { policy . set id ( id node . a text ( ) ) ; } statement node = policy node . get ( json document field . statement ) ; if ( be not null ( statement node ) ) { if ( statement node . be object ( ) ) { statement . add ( statement of ( statement node ) ) ; } else if ( statement node . be array ( ) ) { for ( json node statement node : statement node ) { statement . add ( statement of ( statement node ) ) ; } } } } catch ( exception e ) { string message = `` unable to generate policy object fron json string `` + e . get message ( ) ; throw new illegal argument exception ( message , e ) ; } policy . set statement ( statement ) ; return policy ; }
public static policy from json ( string json string ) { return from json ( json string , new policy reader option ( ) ) ; }
public list < resource > get resource ( ) { return resource ; }
public list < condition > get condition ( ) { return condition ; }
public final string load profile name ( ) { final string profile env var override = get env profile name ( ) ; if ( ! string utils . be null or empty ( profile env var override ) ) { return profile env var override ; } else { final string profile sys prop override = get sys property profile name ( ) ; if ( ! string utils . be null or empty ( profile sys prop override ) ) { return profile sys prop override ; } else { return default_profile_name ; } } }
public string get property value ( string property name ) { return get property ( ) . get ( property name ) ; }
public void set long lived credential provider ( a w s credential provider long lived credential provider ) { this . long lived credential provider = long live credential provider ; }
public static signer get signer by type and service ( string signer type , final string service name ) { return create signer ( signer type , service name ) ; }
public final list < request handler2 > get request handler ( ) { return this . request handler == null ? null : collection . unmodifiable list ( this . request handler ) ; }
protect final < t > void put advanced config ( advanced config . key < t > key , t value ) { advanced config . put ( key , value ) ; }
public client configuration with max connection ( int max connection ) { set max connection ( max connection ) ; return this ; }
public list < proxy authentication method > get proxy authentication method ( ) { return this . proxy authentication method ; }
public boolean use gzip ( ) { return use gzip ; }
public long get connection max idle millis ( ) { return connection max idle millis ; }
public boolean get cache response metadata ( ) { return cache response metadata ; }
public apache http client config get apache http client config ( ) { return apache http client config ; }
public static input stream input stream for response ( input stream be , amazon web service request req ) { return req == null ? be : new response progress input stream ( be , req . get general progress listener ( ) ) ; }
public static void shutdown ( boolean now ) { if ( now ) lazy holder . executor . shutdown now ( ) ; else lazy holder . executor . shutdown ( ) ; }
public request < ? > get request ( ) { return request ; }
public static boolean register connection manager ( http client connection manager connection manager ) { return register connection manager ( connection manager , default_max_idle_millis ) ; }
public static boolean register connection manager ( http client connection manager connection manager , long max idle in m ) { if ( instance == null ) { synchronize ( idle connection reaper . class ) { if ( instance == null ) { instance = new idle connection reaper ( ) ; instance . start ( ) ; } } } return connection manager . put ( connection manager , max idle in m ) == null ; }
public string parse error code ( http response response , json content json content ) { string error code from header = parse error code from header ( response . get header ( ) ) ; if ( error code from header ! = null ) { return error code from header ; } else if ( json content ! = null ) { return parse error code from content ( json content . get json node ( ) ) ; } else { return null ; } }
public boolean be auto construct ( ) { return auto construct ; }
public synchronize static boolean configure factory ( internal log factory factory ) { if ( factory == null ) throw new illegal argument exception ( ) ; if ( factory configure ) return false ; internal log factory . factory = factory ; factory configure = true ; return true ; }
public static string get register admin mbean name ( ) { return register admin mbean name ; }
public static < t extend request metric collector > t get request metric collector ( ) { if ( mc == null ) { if ( be default metric enable ( ) ) enable default metric ( ) ; } @ suppress warning ( `` unchecked `` ) t t = ( t ) ( mc == null ? request metric collector . none : mc . get request metric collector ( ) ) ; return t ; }
public static boolean be metric enabled ( ) { metric collector mc = aws sdk metric . mc ; return mc ! = null & & mc . be enable ( ) ; }
public static void disable metric ( ) { set metric collector ( metric collector . none ) ; }
public static < t extend metric type > void set ( collection < t > type ) { registry . set metric type ( type ) ; }
public static a w s credential provider get credential provider ( ) { stack trace element [ ] e = thread . current thread ( ) . get stack trace ( ) ; for ( int i=0 ; i < e . length ; i++ ) { if ( e [ i ] . get class name ( ) . equal ( default_metric_collector_factory ) ) { return credential provider ; } } security exception ex = new security exception ( ) ; log factory . get log ( aws sdk metric . class ) . warn ( `` illegal attempt to access the credential provider `` , ex ) ; throw ex ; }
public static string get jvm metric name ( ) { return jvm metric name ; }
public static void set jvm metric name ( string jvm metric name ) { aws sdk metric . jvm metric name = jvm metric name ; }
public static string get host metric name ( ) { return host metric name ; }
public void set credential scope ( credential scope credential scope ) { this . credential scope = credential scope ; }
public void set dns suffix ( string dns suffix ) { this . dns suffix = dns suffix ; }
public void set regionalized ( boolean regionalized ) { be regionalized = regionalized ; }
public boolean be service support ( string service name ) { return region impl . be service support ( service name ) ; }
public boolean have https endpoint ( string service name ) { return region impl . have https endpoint ( service name ) ; }
public boolean have http endpoint ( string service name ) { return region impl . have http endpoint ( service name ) ; }
public backoff strategy get backoff strategy ( ) { return backoff strategy ; }
public static boolean be throttle exception ( sdk base exception exception ) { if ( ! be ase ( exception ) ) { return false ; } final amazon service exception ase = to ase ( exception ) ; return throttling_error_codes . contains ( ase . get error code ( ) ) || ase . get status code ( ) == 429 ; }
public boolean be start of document ( ) { return false ; }
public boolean test expression ( string expression , int stack depth ) { return false ; }
public boolean test expression ( string expression ) { if ( expression . equal ( `` . `` ) ) return true ; return stack string . end with ( expression ) ; }
public x m l event next event ( ) throw x m l stream exception { if ( attribute iterator ! = null & & attribute iterator . have next ( ) ) { current event = ( x m l event ) attribute iterator . next ( ) ; } else { current event = event reader . next event ( ) ; } if ( current event . be start element ( ) ) { attribute iterator = current event . a start element ( ) . get attribute ( ) ; } update context ( current event ) ; if ( event reader . have next ( ) ) { x m l event next event = event reader . peek ( ) ; if ( next event ! = null & & next event . be character ( ) ) { for ( metadata expression metadata expression : metadata expression ) { if ( test expression ( metadata expression . expression , metadata expression . target depth ) ) { metadata . put ( metadata expression . key , next event . a character ( ) . get data ( ) ) ; } } } } return current event ; }
public static string encode a string ( byte . . . byte ) { if ( bytes == null ) return null ; return byte . length == 0 ? `` `` : codec utils . to string direct ( codec . encode ( byte ) ) ; }
public static byte [ ] decode ( string b32 ) { if ( b32 == null ) return null ; if ( b32 . length ( ) == 0 ) return new byte [ 0 ] ; byte [ ] buf = new byte [ b32 . length ( ) ] ; int len = codec utils . sanitize ( b32 , buf ) ; return codec . decode ( buf , len ) ; }
public static byte [ ] copy all byte from ( byte buffer bb ) { if ( bb == null ) { return null ; } if ( bb . have array ( ) ) { return array . copy of range ( bb . array ( ) , bb . array offset ( ) , bb . array offset ( ) + bb . limit ( ) ) ; } byte buffer copy = bb . a read only buffer ( ) ; copy . rewind ( ) ; byte [ ] dst = new byte [ copy . remain ( ) ] ; copy . get ( dst ) ; return dst ; }
public boolean acquire ( ) { return acquire ( 1 ) ; }
public static string format r f c822 date ( date date ) { try { return rfc822 date format . print ( date . get time ( ) ) ; } catch ( runtime exception ex ) { throw handle exception ( ex ) ; } }
public static < k , v > immutable map parameter < k , v > of ( k k0 , v v0 , k k1 , v v1 , k k2 , v v2 ) { map < k , v > map = new hash map < k , v > ( ) ; put and warn duplicate key ( map , k0 , v0 ) ; put and warn duplicate key ( map , k1 , v1 ) ; put and warn duplicate key ( map , k2 , v2 ) ; return new immutable map parameter < k , v > ( map ) ; }
public static long copy ( input stream in , output stream out ) throw i o exception { return copy ( in , out , long . max_value ) ; }
public static string get version ( ) { return lazy holder . version ; }
public static < t > t from json string ( string json , class < t > clazz ) { if ( json == null ) return null ; try { return object mapper . read value ( json , clazz ) ; } catch ( exception e ) { throw new sdk client exception ( `` unable to parse json string . `` , e ) ; } }
public static string md5 a base64 ( input stream be ) throw i o exception { return base64 . encode a string ( compute m d5 hash ( be ) ) ; }
public static string encode parameter ( signable request < ? > request ) { final map < string , list < string > > request params = request . get parameter ( ) ; if ( request params . be empty ( ) ) return null ; final list < name value pair > name value pair = new array list < name value pair > ( ) ; for ( entry < string , list < string > > entry : request params . entry set ( ) ) { string parameter name = entry . get key ( ) ; for ( string value : entry . get value ( ) ) { name value pair . add ( new basic name value pair ( parameter name , value ) ) ; } } return u r l encode utils . format ( name value pair , default_encoding ) ; }
public static string join ( string joiner , string . . . part ) { string builder builder = new string builder ( ) ; for ( int i = 0 ; i < part . length ; i++ ) { builder . append ( part [ i ] ) ; if ( i < part . length - 1 ) { builder . append ( joiner ) ; } } return builder . to string ( ) ; }
public static string low case ( string str ) { if ( be null or empty ( str ) ) { return str ; } return str . to lower case ( locale_english ) ; }
public static byte buffer a byte buffer ( string expression , node node ) throw x path expression exception { return a byte buffer ( expression , node , xpath ( ) ) ; }
public boolean match ( output output ) { return false ; }
public receive message result receive message ( receive message request request ) { request = before client execution ( request ) ; return execute receive message ( request ) ; }
public send message result send message ( send message request request ) { request = before client execution ( request ) ; return execute send message ( request ) ; }
public tag queue result tag queue ( tag queue request request ) { request = before client execution ( request ) ; return execute tag queue ( request ) ; }
public int get max batch size ( ) { return max batch size ; }
public java . util . list < string > get a w s account id ( ) { if ( a w s account id == null ) { a w s account id = new com . amazonaws . internal . sdk internal list < string > ( ) ; } return a w s account id ; }
public java . util . list < string > get attribute name ( ) { if ( attribute name == null ) { attribute name = new com . amazonaws . internal . sdk internal list < string > ( ) ; } return attribute name ; }
public void set message id ( string message id ) { this . message id = message id ; }
public void set queue url ( string queue url ) { this . queue url = queue url ; }
public void set visibility timeout ( integer visibility timeout ) { this . visibility timeout = visibility timeout ; }
public void set wait time second ( integer wait time second ) { this . wait time second = wait time second ; }
public void set label ( string label ) { this . label = label ; }
public void remove mime header ( string header ) { mime header . remove header ( header ) ; }
public boolean be attachment ( object value ) { return attachment utils . be attachment ( value ) ; }
protect static synchronize int new stream no ( ) { log . debug ( message . get message ( `` stream no `` , `` `` + ( stream count + 1 ) ) ) ; return ++stream count ; }
public int get chunk size ( ) { return chunk size ; }
public java . lang . string get content type ( ) { return content type ; }
public string get fault node ( ) { return ( fault node ) ; }
public void set fault node ( string node ) { fault node = node ; }
public call get call ( ) { return call ; }
public string quit ( option opt ) throw exception { process opts ( opts ) ; return quit ( ) ; }
public void process opts ( option opt ) throw exception { if ( call == null ) { throw new exception ( message . get message ( `` null call00 `` ) ) ; } url address = new url ( opts . get u r l ( ) ) ; set target endpoint address ( address ) ; set login ( opts . get user ( ) , opts . get password ( ) ) ; string t name = opts . be value set ( 't ' ) ; set transport ( t name ) ; }
public string process ( string xml file ) throw exception { file input stream in = new file input stream ( xml file ) ; string result = process ( null , in ) ; return result ; }
public use get operation use ( ) { if ( operation ! = null ) { return operation . get use ( ) ; } return use . default ; } // get operation style
public boolean use s o a p action ( ) { return use s o a p action ; } // use s o a p action
public void set s o a p action u r i ( string s o a p action u r i ) { use s o a p action = true ; this . s o a p action u r i = s o a p action u r i ; } // set s o a p action u r i
public string get target endpoint address ( ) { try { if ( transport == null ) return ( null ) ; return ( transport . get url ( ) ) ; } catch ( exception exp ) { return ( null ) ; } }
public boolean be parameter and return spec require ( q name operation name ) { return parm and ret req ; } // be parameter and return spec require
public void set return type a header ( q name xml type ) { set return type ( xml type ) ; operation . set return header ( true ) ; } // set return type a header
public q name get operation name ( ) { return ( operation name ) ; }
public q name get port name ( ) { return ( port name ) ; } // get port name
public s o a p envelope invoke ( message msg ) throw axis fault { try { set request message ( msg ) ; invoke ( ) ; msg = msg context . get response message ( ) ; if ( msg == null ) { if ( msg context . be property true ( fault_on_no_response , false ) ) { throw new axis fault ( message . get message ( `` null response00 `` ) ) ; } else { return null ; } } s o a p envelope res = null ; res = msg . get s o a p envelope ( ) ; return res ; } catch ( exception exp ) { if ( exp instanceof axis fault ) { throw ( axis fault ) exp ; } ent log . debug ( message . get message ( `` to axis fault00 `` ) , exp ) ; throw new axis fault ( message . get message ( `` error invoking00 `` , `` \n `` + exp ) ) ; } }
public void set request message ( message msg ) { string attachformat= ( string ) get property ( attachment_encapsulation_format ) ; if ( null ! = attachformat ) { attachment attachments=msg . get attachment impl ( ) ; if ( null ! = attachment ) { if ( attachment_encapsulation_format_mime . equal ( attachformat ) ) { attachment . set send type ( attachment . send_type_mime ) ; } else if ( attachment_encapsulation_format_mtom . equal ( attachformat ) ) { attachment . set send type ( attachment . send_type_mtom ) ; } else if ( attachment_encapsulation_format_dime . equal ( attachformat ) ) { attachment . set send type ( attachment . send_type_dime ) ; } } } if ( null ! = attachment part & & ! attachment part . be empty ( ) ) { try { attachment attachments= msg . get attachment impl ( ) ; if ( null == attachment ) { throw new runtime exception ( message . get message ( `` no attachment `` ) ) ; } attachment . set attachment part ( attachment part ) ; } catch ( axis fault ex ) { log . info ( message . get message ( `` axis fault00 `` ) , ex ) ; throw new runtime exception ( ex . get message ( ) ) ; } } msg context . set request message ( msg ) ; attachment part . clear ( ) ; }
public void clear header ( ) { my header = null ; }
public map get output params ( ) { if ( be never invoke ) { throw new j a x r p c exception ( message . get message ( `` output params unavailable `` ) ) ; } return this . out params ; }
public axis engine get engine ( ) { return ( engine ) ; }
public s o a p header element [ ] get response header ( ) { s o a p header element [ ] array = new s o a p header element [ 0 ] ; try { if ( _call == null ) return array ; vector h = _call . get response message ( ) . get s o a p envelope ( ) . get header ( ) ; array = new s o a p header element [ h . size ( ) ] ; h . copy into ( array ) ; return array ; } catch ( exception e ) { return array ; } }
public void set url ( string url ) { this . url = url ; }
public void add handler ( w s d d handler handler ) { handler . add ( handler ) ; }
public void remove namespace mapping ( string namespace ) { namespace to service . remove ( namespace ) ; }
public document get d o m document ( ) throw configuration exception { string writer writer = new string writer ( ) ; serialization context context = new serialization context ( writer ) ; context . set pretty ( true ) ; try { deployment . write to context ( context ) ; } catch ( exception e ) { log . error ( message . get message ( `` exception00 `` ) , e ) ; } try { writer . close ( ) ; return x m l utils . new document ( new input source ( new string reader ( writer . get buffer ( ) . to string ( ) ) ) ) ; } catch ( exception e ) { return null ; } }
public void deploy ( w s d d deployment registry ) throw configuration exception { if ( deployment ! = null ) { deployment . deploy to registry ( registry ) ; } if ( undeployment ! = null ) { undeployment . undeploy from registry ( registry ) ; } }
public void set response flow ( w s d d response flow response flow ) { this . response flow = response flow ; }
public void add type mapping ( w s d d type map mapping ) { type mapping . add ( map ) ; }
public void set style ( style style ) { this . style = style ; }
public boolean be element ( ) { return _is element ; }
public boolean be omittable ( ) { return omittable ; }
public void set nillable ( boolean nillable ) { this . nillable = nillable ; }
protect deserializer get general purpose ( string mechanism type ) { if ( java type ! = null & & xml type ! = null ) { constructor deser class constructor = get deser class constructor ( ) ; if ( deser class constructor ! = null ) { try { return ( deserializer ) deser class constructor . new instance ( new object [ ] { java type , xml type } ) ; } catch ( instantiation exception e ) { if ( log . be debug enable ( ) ) { log . debug ( org . apache . axis . utils . message . get message ( `` exception00 `` ) , e ) ; } } catch ( illegal access exception e ) { if ( log . be debug enable ( ) ) { log . debug ( org . apache . axis . utils . message . get message ( `` exception00 `` ) , e ) ; } } catch ( invocation target exception e ) { if ( log . be debug enable ( ) ) { log . debug ( org . apache . axis . utils . message . get message ( `` exception00 `` ) , e ) ; } } } } return null ; }
public bean property descriptor get any property desc ( ) { if ( type desc == null ) return null ; return type desc . get any desc ( ) ; }
public boolean get do multi refs ( ) { return do multi refs ; }
public void register default ( javax . xml . rpc . encode . type map mapping ) { if ( map == null || ! ( map instanceof type map delegate ) ) { throw new illegal argument exception ( message . get message ( `` bad type mapping `` ) ) ; } / * do n't allow this call after the delegate ( ) method since * the tmr 's type mapping will be use the default type map * of the secondary tmr . * / if ( default del t m . get next ( ) ! = null ) { throw new illegal argument exception ( message . get message ( `` default type mapping set `` ) ) ; } default del t m = ( type mapping delegate ) mapping ; }
protect void set option lockable ( boolean make lockable ) { this . make lockable = make lockable ; }
public boolean set option default ( string name , object value ) { boolean val = ( option == null || option . get ( name ) == null ) & & value ! = null ; if ( val ) { set option ( name , value ) ; } return val ; }
public string get name ( ) { return name ; }
public array list get service actor ( ) { return actor ; }
public void disable transport ( string transport name ) { if ( valid transport ! = null ) { valid transport . remove element ( transport name ) ; } }
public w s d d transport find transport ( string qname ) { return service admin . get transport ( new q name ( qname ) ) ; }
public void start ( ) { service admin . start ( ) ; }
public attribute get attribute ex ( ) { return attribute ; }
public s a x2 event recorder get recorder ( ) { return recorder ; }
public void set recorder ( s a x2 event recorder rec ) { recorder = rec ; }
public s o a p envelope get envelope ( ) { return message ; }
public document get a document ( ) throw exception { string element string = get a string ( ) ; reader reader = new string reader ( element string ) ; document doc = x m l utils . new document ( new input source ( reader ) ) ; if ( doc == null ) { throw new exception ( message . get message ( `` no doc00 `` , element string ) ) ; } return doc ; }
public s o a p element add child element ( name child name ) throw s o a p exception { message element child = new message element ( child name . get local name ( ) , child name . get prefix ( ) , child name . get u r i ( ) ) ; add child ( child ) ; return child ; }
public name get element name ( ) { return new prefixed q name ( get namespace u r i ( ) , get name ( ) , get prefix ( ) ) ; }
public iterator get child element ( q name qname ) { initialize child ( ) ; int num = child . size ( ) ; vector c = new vector ( num ) ; for ( int i = 0 ; i < num ; i++ ) { message element child = ( message element ) child . get ( i ) ; name cname = child . get element name ( ) ; if ( cname . get u r i ( ) . equal ( qname . get namespace u r i ( ) ) & & cname . get local name ( ) . equal ( qname . get local part ( ) ) ) { c . add ( child ) ; } } return c . iterator ( ) ; }
public void set owner document ( document doc ) { document = doc ; }
public void set value ( string value ) { if ( this instanceof org . apache . axis . message . text ) { set node value ( value ) ; } else if ( child ! = null ) { if ( child . size ( ) ! = 1 ) { throw new illegal state exception ( `` set value ( ) may not be call on a non- text node with more than one child . `` ) ; } javax . xml . soap . node child = ( javax . xml . soap . node ) child . get ( 0 ) ; if ( ! ( child instanceof org . apache . axis . message . text ) ) { throw new illegal state exception ( `` set value ( ) may not be call on a non- text node with a non- text child . `` ) ; } ( ( javax . xml . soap . text ) child ) . set node value ( value ) ; } else { append child ( new org . apache . axis . message . text ( value ) ) ; } }
protect attribute impl make attribute editable ( ) { if ( attribute == null || attribute instanceof null attribute ) { attribute = new attribute impl ( ) ; } else if ( ! ( attribute instanceof attribute impl ) ) { attribute = new attribute impl ( attribute ) ; } return ( attribute impl ) attribute ; }
public void remove trailer ( message element element ) { if ( log . be debug enable ( ) ) log . debug ( message . get message ( `` remove trailer00 `` ) ) ; trailer . remove element ( element ) ; _is dirty = true ; }
public javax . xml . soap . s o a p body add body ( ) throw s o a p exception { if ( body == null ) { body = new s o a p body ( this , soap constant ) ; _is dirty = true ; body . set owner document ( get owner document ( ) ) ; return body ; } else { throw new s o a p exception ( message . get message ( `` body present `` ) ) ; } }
public javax . xml . soap . s o a p header add header ( ) throw s o a p exception { if ( header == null ) { header = new s o a p header ( this , soap constant ) ; header . set owner document ( get owner document ( ) ) ; return header ; } else { throw new s o a p exception ( message . get message ( `` header present `` ) ) ; } }
public javax . xml . soap . s o a p body get body ( ) throw s o a p exception { return body ; }
public void set value ( object value , object hint ) { string local = ( ( q name ) hint ) . get local part ( ) ; if ( ( ( q name ) hint ) . get namespace u r i ( ) . equal ( constant . uri_soap12_env ) ) { if ( local . equal ( constant . elem_fault_role_soap12 ) ) { fault actor = ( string ) value ; } else if ( local . equal ( constant . elem_text_soap12 ) ) { fault string = ( string ) value ; } else if ( local . equal ( constant . elem_fault_node_soap12 ) ) { fault node = ( string ) value ; } } else { if ( local . equal ( constant . elem_fault_code ) ) { fault code = ( q name ) value ; } else if ( local . equal ( constant . elem_fault_string ) ) { fault string = ( string ) value ; } else if ( local . equal ( constant . elem_fault_actor ) ) { fault actor = ( string ) value ; } } }
public message context get message context ( ) { return msg context ; }
protect void finalize ( ) { dispose ( ) ; }
public type mapping registry get type mapping registry ( ) { if ( map registry == null ) { return axis engine . get type mapping registry ( ) ; } return map registry ; }
public void set session ( session session ) { this . session = session ; }
public boolean get past pivot ( ) { return have pass pivot ; }
public string get target service ( ) { return target service ; }
protect string get service class name option name ( ) { return option_beanname ; }
protect static void dec lock counter ( ) { synchronize ( load counter lock ) { load counter -- ; } }
protect string get web inf path ( ) { return web inf path ; }
public boolean be development ( ) { return be development ; }
public void set server socket ( server socket server socket ) { this . server socket = server socket ; }
public void start ( ) throw exception { start ( false ) ; }
public byte [ ] call ( byte [ ] message , long timeout ) throw exception { return m_connector . get send connection ( ) . call ( this , message , timeout , null ) ; }
public void unregister listener ( message listener listener ) { m_connector . get receive connection ( ) . unsubscribe ( create subscription ( listener , null ) ) ; }
public void add application property ( string property , string value ) { if ( property == null ) return ; if ( app property == null ) app property = new vector ( ) ; property . put ( property , value ) ; app property . add element ( property ) ; }
public static long remove long property ( map property , string key , long default value ) { long value = default value ; if ( property ! = null & & property . contains key ( key ) ) { try { value = ( ( long ) property . remove ( key ) ) . long value ( ) ; } catch ( exception ignore ) { } } return value ; }
public calendar get a calendar ( ) { return get a calendar ( calendar . get instance ( ) ) ; }
public static boolean be valid ( string st value ) { return n c name . be valid ( st value ) ; }
public static org . apache . axis . description . type desc get type desc ( ) { return type desc ; }
public calendar get a calendar ( ) { return _value ; }
public string to string ( ) { if ( _value==null ) { return `` unassigned time `` ; } synchronize ( zulu ) { return zulu . format ( _value . get time ( ) ) ; } }
public static boolean be valid ( long s value ) { if ( ( s value < 0l ) || ( s value > 255l ) ) return false ; else return true ; }
public string get path ( ) { return m_path ; }
public string to string ( ) { string buffer uri spec string = new string buffer ( ) ; if ( m_scheme ! = null ) { uri spec string . append ( m_scheme ) ; uri spec string . append ( ' : ' ) ; } uri spec string . append ( get scheme specific part ( ) ) ; return uri spec string . to string ( ) ; }
public static boolean be conformant scheme name ( string p_scheme ) { if ( p_scheme == null || p_scheme . trim ( ) . length ( ) == 0 ) { return false ; } if ( ! be alpha ( p_scheme . char at ( 0 ) ) ) { return false ; } char test char ; int scheme length = p_scheme . length ( ) ; for ( int i = 1 ; i < scheme length ; ++i ) { test char = p_scheme . char at ( i ) ; if ( ! be scheme character ( test char ) ) { return false ; } } return true ; }
public synchronize void write ( int b ) { write ( new byte [ ] { ( byte ) b } , 0 , 1 ) ; }
public static void set default class loader ( class loader loader ) { if ( loader ! = null ) default class loader = loader ; }
public final void add argument ( final string argument ) { if ( null == m_arguments ) m_arguments = new string [ ] { argument } ; else { final string [ ] argument = new string [ m_arguments . length + 1 ] ; system . arraycopy ( m_arguments , 0 , argument , 0 , m_arguments . length ) ; argument [ m_arguments . length ] = argument ; m_arguments = argument ; } }
public final int get id ( ) { return m_id ; }
public final string get name ( ) { return m_name ; }
public static final string buffer describe option ( final c l option descriptor [ ] option ) { final string buffer sb = new string buffer ( ) ; for ( int i = 0 ; i < option . length ; i++ ) { final char ch = ( char ) option [ i ] . get id ( ) ; final string name = option [ i ] . get name ( ) ; string description = option [ i ] . get description ( ) ; int flag = option [ i ] . get flags ( ) ; boolean argument require = ( ( flag & c l option descriptor . argument_required ) == c l option descriptor . argument_required ) ; boolean two argument require = ( ( flag & c l option descriptor . arguments_required_2 ) == c l option descriptor . arguments_required_2 ) ; boolean need comma = false ; if ( two argument require ) argument require = true ; sb . append ( '\t ' ) ; if ( character . be letter ( ch ) ) { sb . append ( `` - `` ) ; sb . append ( ch ) ; need comma = true ; } if ( null ! = name ) { if ( need comma ) { sb . append ( `` , `` ) ; } sb . append ( `` -- `` ) ; sb . append ( name ) ; if ( argument require ) { sb . append ( `` < argument > `` ) ; } if ( two argument require ) { sb . append ( `` = < value > `` ) ; } sb . append ( java utils . l ) ; } if ( null ! = description ) { while ( description . length ( ) > max_description_column_length ) { final string description part = description . substring ( 0 , max_description_column_length ) ; description = description . substring ( max_description_column_length ) ; sb . append ( `` \t\t `` ) ; sb . append ( description part ) ; sb . append ( java utils . l ) ; } sb . append ( `` \t\t `` ) ; sb . append ( description ) ; sb . append ( java utils . l ) ; } } return sb ; }
public boolean be indexed ( ) { return ( field . get type ( ) . get component type ( ) ! = null ) ; }
public static string get loadable class name ( string text ) { if ( text == null || text . index of ( `` [ `` ) < 0 || text . char at ( 0 ) == ' [ ' ) return text ; string class name = text . substring ( 0 , text . index of ( `` [ `` ) ) ; if ( class name . equal ( `` byte `` ) ) class name = `` b `` ; else if ( class name . equal ( `` char `` ) ) class name = `` c `` ; else if ( class name . equal ( `` double `` ) ) class name = `` d `` ; else if ( class name . equal ( `` float `` ) ) class name = `` f `` ; else if ( class name . equal ( `` int `` ) ) class name = `` i `` ; else if ( class name . equal ( `` long `` ) ) class name = `` j `` ; else if ( class name . equal ( `` short `` ) ) class name = `` s `` ; else if ( class name . equal ( `` boolean `` ) ) class name = `` z `` ; else class name = `` l `` + class name + `` ; `` ; int i = text . index of ( `` ] `` ) ; while ( i > 0 ) { class name = `` [ `` + class name ; i = text . index of ( `` ] `` , i+1 ) ; } return class name ; }
public static final boolean be true ( string value ) { return ! be false explicitly ( value ) ; }
public int be flag set ( char opt char ) { int value = 0 ; int loop ; int i ; for ( loop = 0 ; use args ! = null & & loop < use args . size ( ) ; loop++ ) { string arg = ( string ) use args . element at ( loop ) ; if ( arg . char at ( 0 ) ! = '- ' ) continue ; for ( i = 0 ; i < arg . length ( ) ; i++ ) if ( arg . char at ( i ) == opt char ) value++ ; } for ( loop = 0 ; loop < args . length ; loop++ ) { if ( args [ loop ] == null || args [ loop ] . length ( ) == 0 ) continue ; if ( args [ loop ] . char at ( 0 ) ! = '- ' ) continue ; while ( args [ loop ] ! = null & & ( i = args [ loop ] . index of ( opt char ) ) ! = -1 ) { args [ loop ] = args [ loop ] . substring ( 0 , i ) + args [ loop ] . substring ( i+1 ) ; if ( args [ loop ] . length ( ) == 1 ) args [ loop ] = null ; value++ ; if ( use args == null ) use args = new vector ( ) ; use args . add ( `` - `` + opt char ) ; } } return ( value ) ; }
public string get remain flag ( ) { string buffer sb = null ; int loop ; for ( loop = 0 ; loop < args . length ; loop++ ) { if ( args [ loop ] == null || args [ loop ] . length ( ) == 0 ) continue ; if ( args [ loop ] . char at ( 0 ) ! = '- ' ) continue ; if ( sb == null ) sb = new string buffer ( ) ; sb . append ( args [ loop ] . substring ( 1 ) ) ; } return ( sb == null ? null : sb . to string ( ) ) ; }
public static boolean be empty ( string str ) { return ( str == null || str . length ( ) == 0 ) ; }
public static string strip ( string str ) { return strip ( str , null ) ; }
public static string strip end ( string str , string strip char ) { int end = get strip end ( str , strip char ) ; return ( end < 0 ) ? str : str . substring ( 0 , end ) ; }
public static string get version ( ) { return message . get message ( `` axis version `` ) + `` \n `` + message . get message ( `` build on `` ) ; }
public static string get package name from full name ( string full ) { if ( full . last index of ( ' . ' ) < 0 ) { return `` `` ; } else { return full . substring ( 0 , full . last index of ( ' . ' ) ) ; } }
public boolean be acceptable a attribute ( class type ) { return be simple type ( type ) || be enum class ( type ) || implement simple type ( type ) ; }
public list get stop class ( ) { return stop class ; }
public element create element ( string element name ) { return doc holder . create element ( element name ) ; }
public service desc get service desc ( ) { return service desc ; }
public string get input namespace ( string operation name ) { meta info value = ( meta info ) table . get ( operation name ) ; if ( value == null ) { return null ; } return value . input namespace ; }
public style get binding style ( ) { return bind style ; } // get binding style
public string get name ( ) { return name ; } // get name
public message get message ( ) { return message ; } // get message
public string get name ( ) { if ( ( name == null ) & & ( qname ! = null ) ) { return qname . get local part ( ) ; } return name ; }
public static q name get attribute anon q name ( node node ) { if ( be x s d node ( node , `` attribute `` ) ) { node list child = node . get child node ( ) ; for ( int j = 0 ; j < child . get length ( ) ; j++ ) { node kid = child . item ( j ) ; if ( be x s d node ( kid , `` complex type `` ) || be x s d node ( kid , `` simple type `` ) ) { return utils . get node name q name ( kid ) ; } } } return null ; }
public hash map get hash map ( ) { return symbol table ; } // get hash map
public port type entry get port type entry ( q name qname ) { return ( port type entry ) get ( qname , port type entry . class ) ; } // get port type entry
public node get node ( ) { return node ; }
public boolean be only literal reference ( ) { return only literal reference ; } // be only literal reference
public void set component type ( q name component type ) { this . component type = component type ; }
public string to string ( ) { return to string ( `` `` ) ; }
public hash set get nest type ( symbol table symbol table , boolean derive flag ) { if ( type == null ) { type = utils . get nested type ( this , symbol table , derive flag ) ; } return type ; } // get nested type
public string get output dir ( ) { return output dir ; }
public scope get scope ( ) { return scope ; } // get scope
public void set n sto pkg ( string n sto pkg filename ) { if ( n sto pkg filename ! = null ) { this . n sto pkg filename = n sto pkg filename ; } } // set n sto pkg
public void set namespace excludes ( list ns exclude ) { this . ns excludes = ns excludes ; }
public generate file info get generate file info ( ) { return file info ; }
public void generate import ( boolean generate import ) { set import ( generate import ) ; } // generate import
public void set type collision protection ( boolean value ) { this . type collision protection = value ; }
protect void register file ( string file ) { if ( wrapper p w == null ) { super . register file ( file ) ; } } // register file
protect string get class modifier ( ) { return `` public `` ; } // get class modifier
public void generate ( ) throw i o exception { write fault ( ) ; } // generate
protect void write file body ( print writer pw ) throw i o exception { write deploy service ( pw ) ; pw . println ( `` < /deployment > `` ) ; } // write file body
public void generate ( ) throw i o exception { string fqcn = get package ( ) + `` . `` + get class name ( ) ; if ( emitter . be deploy ( ) ) { if ( ! emitter . do exist ( fqcn ) ) { super . generate ( ) ; } } else { super . generate ( ) ; } }
public void generate ( ) throw i o exception { string fqcn = get package ( ) + `` . `` + get class name ( ) ; if ( emitter . be deploy ( ) ) { if ( ! emitter . do exist ( fqcn ) ) { super . generate ( ) ; } } else { super . generate ( ) ; } }
protect string get extends text ( ) { return `` extends javax . xml . rpc . service `` ; } // get extends text
public string get revoke u r l ( ) { return this . revoke u r l ; }
protect read write lock get refresh lock ( ) { return this . refresh lock ; }
public void set max request attempt ( int attempt ) { this . max request attempt = attempt ; }
public string get proxy username ( ) { return this . proxy username ; }
public void set proxy username ( string proxy username ) { this . proxy username = proxy username ; }
public int get read timeout ( ) { return this . read timeout ; }
public void set body ( input stream stream ) { this . body = stream ; }
public static collection < info > get pending collaboration ( box a p i connection api ) { url url = pending_collaborations_url . build ( api . get base u r l ( ) ) ; box a p i request request = new box a p i request ( api , url , `` get `` ) ; box j s o n response response = ( box j s o n response ) request . send ( ) ; json object response j s o n = json object . read from ( response . get j s o n ( ) ) ; int entry count = response j s o n . get ( `` total_count `` ) . a int ( ) ; collection < box collaboration . info > collaboration = new array list < box collaboration . info > ( entry count ) ; json array entry = response j s o n . get ( `` entry `` ) . a array ( ) ; for ( json value entry : entry ) { json object entry object = entry . a object ( ) ; box collaboration collaboration = new box collaboration ( api , entry object . get ( `` id `` ) . a string ( ) ) ; box collaboration . info info = collaboration . new info ( entry object ) ; collaboration . add ( info ) ; } return collaboration ; }
public static string format ( date date ) { return thread_local_date_format . get ( ) . format ( date ) ; }
public void upload version ( input stream file content , date modify , long file size , progress listener listener ) { this . upload version ( file content , null , modify , file size , listener ) ; }
public string get sha1 ( ) { return this . sha1 ; }
public void set part id ( string part id ) { this . part id = part id ; }
public void set size ( long size ) { this . size = size ; }
public int get offset ( ) { return this . offset ; }
public box watermark get watermark ( string . . . field ) { return this . get watermark ( folder_info_url_template , field ) ; }
public static void set read timeout ( int read timeout ) { box global setting . read timeout = read timeout ; }
public box group membership . info add membership ( box user user , role role ) { box a p i connection api = this . get a p i ( ) ; json object request j s o n = new json object ( ) ; request j s o n . add ( `` user `` , new json object ( ) . add ( `` id `` , user . get i d ( ) ) ) ; request j s o n . add ( `` group `` , new json object ( ) . add ( `` id `` , this . get i d ( ) ) ) ; if ( role ! = null ) { request j s o n . add ( `` role `` , role . to j s o n string ( ) ) ; } url url = add_membership_url_template . build ( api . get base u r l ( ) ) ; box j s o n request request = new box j s o n request ( api , url , `` post `` ) ; request . set body ( request j s o n . to string ( ) ) ; box j s o n response response = ( box j s o n response ) request . send ( ) ; json object response j s o n = json object . read from ( response . get j s o n ( ) ) ; box group membership membership = new box group membership ( api , response j s o n . get ( `` id `` ) . a string ( ) ) ; return membership . new info ( response j s o n ) ; }
public void update info ( info info ) { box a p i connection api = this . get a p i ( ) ; url url = membership_url_template . build ( api . get base u r l ( ) , this . get i d ( ) ) ; box j s o n request request = new box j s o n request ( api , url , `` put `` ) ; request . set body ( info . get pending change ( ) ) ; box j s o n response response = ( box j s o n response ) request . send ( ) ; json object json object = json object . read from ( response . get j s o n ( ) ) ; info . update ( json object ) ; }
public void update info ( box legal hold policy . info info ) { url url = legal_hold_url_template . build ( this . get a p i ( ) . get base u r l ( ) , this . get i d ( ) ) ; box j s o n request request = new box j s o n request ( this . get a p i ( ) , url , `` put `` ) ; request . set body ( info . get pending change ( ) ) ; box j s o n response response = ( box j s o n response ) request . send ( ) ; json object response j s o n = json object . read from ( response . get j s o n ( ) ) ; info . update ( response j s o n ) ; }
public string get scope ( ) { return this . scope ; }
public void put field ( string key , string value ) { this . field . put ( key , value ) ; }
public box retention policy assignment . info assign to enterprise ( ) { return box retention policy assignment . create assignment to enterprise ( this . get a p i ( ) , this . get i d ( ) ) ; }
public string get scope ( ) { return this . scope ; }
public info get info ( ) { url url = task_url_template . build ( this . get a p i ( ) . get base u r l ( ) , this . get i d ( ) ) ; box a p i request request = new box a p i request ( this . get a p i ( ) , url , `` get `` ) ; box j s o n response response = ( box j s o n response ) request . send ( ) ; json object response j s o n = json object . read from ( response . get j s o n ( ) ) ; return new info ( response j s o n ) ; }
public void update info ( box task . info info ) { url url = task_url_template . build ( this . get a p i ( ) . get base u r l ( ) , this . get i d ( ) ) ; box j s o n request request = new box j s o n request ( this . get a p i ( ) , url , `` put `` ) ; request . set body ( info . get pending change ( ) ) ; box j s o n response response = ( box j s o n response ) request . send ( ) ; json object json object = json object . read from ( response . get j s o n ( ) ) ; info . update ( json object ) ; }
public void delete ( ) { url url = task_assignment_url_template . build ( this . get a p i ( ) . get base u r l ( ) , this . get i d ( ) ) ; box a p i request request = new box a p i request ( this . get a p i ( ) , url , `` delete `` ) ; box a p i response response = request . send ( ) ; response . disconnect ( ) ; }
public void update info ( box task assignment . info info ) { url url = task_assignment_url_template . build ( this . get a p i ( ) . get base u r l ( ) , this . get i d ( ) ) ; box j s o n request request = new box j s o n request ( this . get a p i ( ) , url , `` put `` ) ; request . set body ( info . get pending change ( ) ) ; box j s o n response response = ( box j s o n response ) request . send ( ) ; json object json object = json object . read from ( response . get j s o n ( ) ) ; info . update ( json object ) ; }
public static list < box term of service user status . info > get info ( final box a p i connection api , string term of service i d ) { return get info ( api , term of service i d ) ; }
public boolean can refresh ( ) { return false ; }
public void refresh ( ) { throw new unsupported operation exception ( `` box transactional a p i connection do not support token refreshing , `` + `` access token can be generate in the developer console . `` ) ; }
public box folder . info get folder info ( string folder i d , string . . . field ) { string query string = new query string builder ( ) . append param ( `` field `` , field ) . to string ( ) ; url url = folder_info_url_template . build with query ( this . api . get base u r l ( ) , query string , folder i d ) ; box a p i request request = new box a p i request ( this . api , url , `` get `` ) ; box j s o n response response = ( box j s o n response ) request . send ( ) ; json object json object = json object . read from ( response . get j s o n ( ) ) ; box folder folder = new box folder ( this . api , json object . get ( `` id `` ) . a string ( ) ) ; return folder . new info ( response . get j s o n ( ) ) ; }
public access get access ( ) { return this . access ; }
public create user params set be sync enable ( boolean be sync enable ) { this . be sync enabled = be sync enable ; return this ; }
public create user params set status ( box user . status status ) { this . status = status ; return this ; }
public int get chunk size ( ) { return this . chunk size ; }
public void add listener ( event listener listener ) { synchronize ( this . listener lock ) { this . listener . add ( listener ) ; } }
public input stream get content ( ) { return this . content ; }
public file upload params set upload file callback ( upload file callback upload file callback ) { this . upload file callback = upload file callback ; return this ; }
public progress listener get progress listener ( ) { return this . listener ; }
public string get ( string key ) { synchronize ( this . cache ) { return this . cache . get ( key ) ; } }
public string get private key password ( ) { return this . private key password ; }
public json value get value ( string path ) { return this . value . get ( this . path to property ( path ) ) ; }
public list < string > get multi select ( string path ) { list < string > value = new array list < string > ( ) ; for ( json value val : this . get value ( path ) . a array ( ) ) { value . add ( val . a string ( ) ) ; } return value ; }
public static void delete metadata template ( box a p i connection api , string scope , string template ) { url url = metadata_template_url_template . build ( api . get base u r l ( ) , scope , template ) ; box j s o n request request = new box j s o n request ( api , url , `` delete `` ) ; request . send ( ) ; }
public string get issue token type ( ) { return this . issue token type ; }
public int get upper bound byte ( ) { return this . upper bound byte ; }
public url [ ] get path component ( ) { return ( url [ ] ) get full path ( ) . to array ( new url [ 0 ] ) ; }
public void set class path ( url [ ] cp ) { base class path . set path ( cp ) ; init base loader ( ) ; loader map = new hash map ( ) ; class loader change ( ) ; }
public name space get parent ( ) { return parent ; }
public this get this ( interpreter declare interpreter ) { if ( this reference == null ) this reference = this . get this ( this , declare interpreter ) ; return this reference ; }
public void import class ( string name ) { if ( import class == null ) import class = new hashtable ( ) ; import class . put ( name . suffix ( name , 1 ) , name ) ; name space change ( ) ; }
public void load default import ( ) { / * * note : the resolver look through these in reverse order , per precedence rule . . . so for max efficiency put the most common one later . * / import class ( `` bsh . eval error `` ) ; import class ( `` bsh . interpreter `` ) ; import package ( `` javax . swing . event `` ) ; import package ( `` javax . swing `` ) ; import package ( `` java . awt . event `` ) ; import package ( `` java . awt `` ) ; import package ( `` java . net `` ) ; import package ( `` java . util `` ) ; import package ( `` java . io `` ) ; import package ( `` java . lang `` ) ; import command ( `` /bsh/commands `` ) ; }
public static class get array base type ( class array class ) throw reflect error { if ( ! array class . be array ( ) ) throw new reflect error ( `` the class be not an array . `` ) ; return array class . get component type ( ) ; }
public void add ( name completion table table ) { / * * unimplemented - need a collection here * / if ( this . table ! = null ) throw new runtime exception ( `` unimplemented usage error `` ) ; this . table = table ; }
public static implementation throw ( class < ? extend throwable > exception type ) { return throw ( new type description . for loaded type ( exception type ) ) ; }
protect stack manipulation getter ( field description field description , method description instrument method ) { return access ( field description , instrument method , new stack manipulation . compound ( field access . for field ( field description ) . read ( ) , assigner . assign ( field description . get type ( ) , instrument method . get return type ( ) , type ) ) ) ; }
public static < t extend type description . generic > element matcher . junction < t > raw type ( class < ? > type ) { return raw type ( be ( type ) ) ; }
public void ensure capacity ( @ nonnegative long maximum size ) { caffeine . require argument ( maximum size > = 0 ) ; int maximum = ( int ) math . min ( maximum size , integer . max_value > > > 1 ) ; if ( ( table ! = null ) & & ( table . length > = maximum ) ) { return ; } table = new long [ ( maximum == 0 ) ? 1 : ceiling next power of two ( maximum ) ] ; table mask = math . max ( 0 , table . length - 1 ) ; sample size = ( maximum size == 0 ) ? 10 : ( 10 * maximum ) ; if ( sample size < = 0 ) { sample size = integer . max_value ; } size = 0 ; }
public boolean have queue thread ( thread thread ) { return sync . be queue ( thread ) ; }
public int get queue length ( ) { return sync . get queue length ( ) ; }
public int get wait queue length ( condition condition ) { require non null ( condition ) ; if ( ! ( condition instanceof abstract queue synchronizer . condition object ) ) { throw new illegal argument exception ( `` not owner `` ) ; } return sync . get wait queue length ( ( abstract queue synchronizer . condition object ) condition ) ; }
public static set < role resource > get role ( role resource primary role ) { return cache . get role ( primary role ) ; }
public static debuggable thread pool executor create cache threadpool with max size ( string thread pool name ) { return new debuggable thread pool executor ( 0 , integer . max_value , 60l , time unit . second , new synchronous queue < runnable > ( ) , new name thread factory ( thread pool name ) ) ; }
public schema load from disk ( ) { return load from disk ( true ) ; }
public keyspace get keyspace instance ( string keyspace name ) { return keyspace instance . get ( keyspace name ) ; }
public c f meta data get c f meta data ( string keyspace name , string cf name ) { assert keyspace name ! = null ; keyspace metadata ksm = keyspaces . get ( keyspace name ) ; return ksm == null ? null : ksm . get table or view nullable ( cf name ) ; }
public uuid get alt version ( ) { return alt version ; }
public static builder new builder ( ) { return new builder ( ) ; }
public list < operation > static operation ( ) { return static operation ; }
public boolean be empty ( ) { return static operation . be empty ( ) & & regular operation . be empty ( ) ; }
public immutable list < column specification > get column specification ( ) { throw new unsupported operation exception ( ) ; }
public final boolean have contains ( ) { for ( single restriction restriction : restriction ) { if ( restriction . be contains ( ) ) return true ; } return false ; }
public boolean have restriction for ( column definition . kind kind ) { for ( column definition column : restriction . key set ( ) ) { if ( column . kind == kind ) return true ; } return false ; }
public default multi c builder append bound to ( multi c builder builder , bound bound , query option option ) { return append to ( builder , option ) ; }
public boolean use secondary indexing ( ) { return this . use secondary indexing ; }
public term slice merge ( term slice other slice ) { if ( have bind ( bound . start ) ) { assert ! other slice . have bind ( bound . start ) ; return new term slice ( bound ( bound . start ) , be inclusive ( bound . start ) , other slice . bound ( bound . end ) , other slice . be inclusive ( bound . end ) ) ; } assert ! other slice . have bind ( bound . end ) ; return new term slice ( other slice . bound ( bound . start ) , other slice . be inclusive ( bound . start ) , bound ( bound . end ) , be inclusive ( bound . end ) ) ; }
public boolean be support by ( column definition column , index index ) { boolean support = false ; if ( have bind ( bound . start ) ) support |= be inclusive ( bound . start ) ? index . support expression ( column , operator . gte ) : index . support expression ( column , operator . gt ) ; if ( have bind ( bound . end ) ) support |= be inclusive ( bound . end ) ? index . support expression ( column , operator . lte ) : index . support expression ( column , operator . lt ) ; return support ; }
public boolean contain static column ( ) { if ( cfm . be static compact table ( ) || ! cfm . have static column ( ) ) return false ; if ( be wildcard ( ) ) return true ; return ! iterables . be empty ( iterables . filter ( column , static_column_filter ) ) ; }
public list < selector > new instance ( query option option ) throw invalid request exception { list < selector > selector = new array list < > ( factory . size ( ) ) ; for ( selector . factory factory : factory ) selector . add ( factory . new instance ( option ) ) ; return selector ; }
public static void check contain no duplicate ( list < ? > list , string message ) throw invalid request exception { if ( new hash set < > ( list ) . size ( ) ! = list . size ( ) ) throw invalid request ( message ) ; }
public boolean allow non primary key in where clause ( ) { return false ; }
public static aggregation specification aggregate pk prefix ( cluster comparator comparator , int cluster prefix size ) { return new aggregate by pk prefix ( comparator , cluster prefix size ) ; }
public void invalidate ( ) { invalidate ( true ) ; }
public listenable future < commit log position > switch memtable ( ) { synchronize ( data ) { log flush ( ) ; flush flush = new flush ( false ) ; flush executor . execute ( flush ) ; post flush executor . execute ( flush . post flush task ) ; return flush . post flush task ; } }
public s s table reader get max size file ( iterable < s s table reader > sstables ) { long max size = 0l ; s s table reader max file = null ; for ( s s table reader sstable : sstables ) { if ( sstable . on disk length ( ) > max size ) { max size = sstable . on disk length ( ) ; max file = sstable ; } } return max file ; }
public future < commit log position > dump memtable ( ) { synchronize ( data ) { final flush flush = new flush ( true ) ; flush executor . execute ( flush ) ; post flush executor . execute ( flush . post flush task ) ; return flush . post flush task ; } }
public boolean have simple ( ) { return complex idx > 0 ; }
public iterator < column definition > simple column ( ) { return b tree . iterator ( column , 0 , complex idx - 1 , b tree . dir . asc ) ; }
public void apply ( consumer < column definition > function , boolean reverse ) { b tree . apply ( column , function , reverse ) ; }
public void await termination ( ) throw interrupted exception { manager thread . join ( ) ; manager thread = null ; for ( commit log segment segment : active segment ) segment . close ( ) ; buffer pool . shutdown ( ) ; }
public void read all file ( commit log read handler handler , file [ ] file ) throw i o exception { read all file ( handler , file , commit log position . none ) ; }
public static interval set < commit log position > persist interval ( iterable < s s table reader > on disk , commit log position truncate at ) { interval set . builder < commit log position > builder = new interval set . builder < > ( ) ; for ( s s table reader reader : on disk ) builder . add all ( reader . get s s table metadata ( ) . commit log interval ) ; if ( truncate at ! = null ) builder . add ( commit log position . none , truncate at ) ; return builder . build ( ) ; }
public void disable auto compaction ( ) { for ( string ksname : schema . instance . get non system keyspaces ( ) ) { for ( column family store cf : keyspace . open ( ksname ) . get column family store ( ) ) cf . disable auto compaction ( ) ; } }
protect abstract compaction strategy get compaction strategy for ( s s table reader sstable ) { maybe reload disk boundary ( ) ; return compaction strategy for ( sstable ) ; }
public long estimate key ( ) { return estimate total key ; }
public byte buffer create global ( counter id id , long clock , long count ) { context state state = context state . allocate ( 1 , 0 , 0 ) ; state . write global ( id , clock , count ) ; return state . context ; }
public partition column fetch column ( ) { return fetch ; }
public static void clear snapshot ( string snapshot name , string keyspace ) { list < file > snapshot dirs = directory . get k s child directory ( keyspace , column family store . get initial directory ( ) ) ; directory . clear snapshot ( snapshot name , snapshot dirs ) ; }
public void cancel ( iterable < s s table reader > cancel ) { for ( s s table reader cancel : cancel ) cancel ( cancel ) ; }
public boolean be empty ( ) { return timestamp == no_timestamp ; }
public void validate ( ) { for ( row row : this ) { metadata ( ) . comparator . validate ( row . clustering ( ) ) ; for ( column data cd : row ) cd . validate ( ) ; } }
public deletion time deletion time ( ) { return deletion ; }
public static row iterator log iterator ( row iterator iterator , final string id ) { c f meta data metadata = iterator . metadata ( ) ; logger . info ( `` [ { } ] log iterator on { } . { } , partition key= { } , reversed= { } `` , id , metadata . k name , metadata . cf name , metadata . get key validator ( ) . get string ( iterator . partition key ( ) . get key ( ) ) , iterator . be reverse order ( ) ) ; class log extend transformation { @ override public row apply to static ( row row ) { if ( ! row . be empty ( ) ) logger . info ( `` [ { } ] { } `` , id , row . to string ( metadata ) ) ; return row ; } @ override public row apply to row ( row row ) { logger . info ( `` [ { } ] { } `` , id , row . to string ( metadata ) ) ; return row ; } } return transformation . apply ( iterator , new log ( ) ) ; }
public static unfiltered row iterator no row iterator ( final c f meta data cfm , final decorate key partition key , final row static row , final deletion time partition deletion , final boolean be reverse order ) { return empty iterators . unfiltered row ( cfm , partition key , be reverse order , static row , partition deletion ) ; }
public static single partition read command full partition read ( c f meta data metadata , int now in sec , decorate key key ) { return create ( metadata , now in sec , key , slice . all ) ; }
public static single partition read command create ( c f meta data metadata , int now in sec , decorate key key , slice slice ) { return create ( metadata , now in sec , key , slice . with ( metadata . comparator , slice ) ) ; }
public static synchronize void remove truncation record ( uuid cf id ) { string req = `` delete truncated_at [ ? ] from system . % s where key = ' % s ' `` ; execute internal ( string . format ( req , local , local ) , cf id ) ; truncation record = null ; force block flush ( local ) ; }
public static < t extend ring position < t > > set < bound < t > > get non overlap bound ( iterable < bound < t > > bound ) { array list < bound < t > > sort bound = list . new array list ( bound ) ; collection . sort ( sorted bound , new comparator < bound < t > > ( ) { public int compare ( bound < t > o1 , bound < t > o2 ) { return o1 . leave . compare to ( o2 . left ) ; } } ) ; set < bound < t > > non overlap bound = set . new hash set ( ) ; peek iterator < bound < t > > it = iterators . peek iterator ( sorted bound . iterator ( ) ) ; while ( it . have next ( ) ) { bound < t > begin bound = it . next ( ) ; bound < t > end bound = begin bound ; while ( it . have next ( ) & & end bound . right . compare to ( it . peek ( ) . leave ) > = 0 ) end bound = it . next ( ) ; non overlap bound . add ( new bound < > ( begin bound . leave , end bound . right ) ) ; } return non overlap bound ; }
public static void set output keyspace ( configuration conf , string keyspace ) { if ( keyspace == null ) throw new unsupported operation exception ( `` keyspace may not be null `` ) ; conf . set ( output_keyspace_config , keyspace ) ; }
public boolean finish ( file index file ) throw f s write error { return finish ( descriptor . current , index file ) ; }
public i s s table scanner get scanner ( iterator < abstract bound < partition position > > bound iterator ) { return big table scanner . get scanner ( this , bound iterator ) ; }
public final row index entry get position ( partition position key , operator op ) { return get position ( key , op , s s table read listener . noop_listener ) ; }
public metadata collector add compression ratio ( long compress , long uncompressed ) { compression ratio = ( double ) compressed/uncompressed ; return this ; }
public static long get total space ( file file ) { return handle large file system ( file . get total space ( ) ) ; }
public inet address get endpoint for host id ( uuid host id ) { lock . read lock ( ) . lock ( ) ; try { return endpoint to host id map . inverse ( ) . get ( host id ) ; } finally { lock . read lock ( ) . unlock ( ) ; } }
public void remove from move ( inet address endpoint ) { assert endpoint ! = null ; lock . write lock ( ) . lock ( ) ; try { for ( pair < token , inet address > pair : moving endpoint ) { if ( pair . right . equal ( endpoint ) ) { move endpoint . remove ( pair ) ; break ; } } invalidate cached ring ( ) ; } finally { lock . write lock ( ) . unlock ( ) ; } }
public void mark ( long n ) { tick if necessary ( ) ; count . add and get ( n ) ; m15 rate . update ( n ) ; m120 rate . update ( n ) ; }
public void update back pressure on receive ( inet address host , i async callback callback , boolean timeout ) { if ( database descriptor . back pressure enable ( ) & & callback . support back pressure ( ) ) { back pressure state back pressure state = get connection pool ( host ) . get back pressure state ( ) ; if ( ! timeout ) back pressure state . on response receive ( ) ; else back pressure state . on response timeout ( ) ; } }
public boolean have ( string name ) { return index by name . contains key ( name ) ; }
public index replace ( index metadata index ) { return without ( index . name ) . with ( index ) ; }
public void start ( ) { string native flag = system . get property ( `` cassandra . start_native_transport `` ) ; if ( ( native flag ! = null & & boolean . parse boolean ( native flag ) ) || ( native flag == null & & database descriptor . start native transport ( ) ) ) { start native transport ( ) ; storage service . instance . set rpc ready ( true ) ; } else logger . info ( `` not start native transport a request . use jmx ( storage service- > start native transport ( ) ) or nodetool ( enablebinary ) to start it `` ) ; string rpc flag = system . get property ( `` cassandra . start_rpc `` ) ; if ( ( rpc flag ! = null & & boolean . parse boolean ( rpc flag ) ) || ( rpc flag == null & & database descriptor . start rpc ( ) ) ) thrift server . start ( ) ; else logger . info ( `` not start rpc server a request . use jmx ( storage service- > start r p c server ( ) ) or nodetool ( enablethrift ) to start it `` ) ; }
public void start ( ) { initialize ( ) ; server . for each ( server : : start ) ; }
public void verify ( ) throw startup exception { for ( startup check test : pre flight check ) test . execute ( ) ; }
public void update progress ( progress info new progress ) { assert peer . equal ( new progress . peer ) ; map < string , progress info > current file = new progress . direction == progress info . direction . in ? receive file : sending file ; current file . put ( new progress . file name , new progress ) ; }
public static < v > void apply ( object [ ] btree , consumer < v > function , predicate < v > stop condition , boolean reverse ) { if ( reverse ) apply reverse ( btree , function , stop condition ) ; else apply forward ( btree , function , stop condition ) ; }
public static int to int ( byte buffer bytes ) { return byte . get int ( byte . position ( ) ) ; }
public static string byte to hex ( byte buffer bytes ) { if ( byte . have array ( ) ) { return hex . byte to hex ( byte . array ( ) , bytes . array offset ( ) + byte . position ( ) , bytes . remain ( ) ) ; } final int offset = byte . position ( ) ; final int size = byte . remain ( ) ; final char [ ] c = new char [ size * 2 ] ; for ( int i = 0 ; i < size ; i++ ) { final int bint = byte . get ( i+offset ) ; c [ i * 2 ] = hex . byte to char [ ( bint & 0xf0 ) > > 4 ] ; c [ 1 + i * 2 ] = hex . byte to char [ bint & 0x0f ] ; } return hex . wrap char array ( c ) ; }
public barrier new barrier ( ) { return new barrier ( ) ; }
public boolean release if hold ( t reference ) { ref ref = reference . remove ( reference ) ; if ( ref ! = null ) ref . release ( ) ; return ref ! = null ; }
public merkle tree add merkle tree ( int maxsize , range < token > range ) { return add merkle tree ( maxsize , merkle tree . recommended_depth , range ) ; }
public static long convert ( long nano time ) { final long timestamp base [ ] = timestamp_base ; return timestamp base [ 0 ] + time unit . nanosecond . to millis ( nano time - timestamp base [ 1 ] ) ; }
public static long size on heap of ( byte buffer [ ] array ) { long all element size = 0 ; for ( int i = 0 ; i < array . length ; i++ ) if ( array [ i ] ! = null ) all element size += size on heap of ( array [ i ] ) ; return all element size + size of array ( array ) ; }
public static int next high power of two ( int v ) { v -- ; v |= v > > 1 ; v |= v > > 2 ; v |= v > > 4 ; v |= v > > 8 ; v |= v > > 16 ; v++ ; return v ; }
public static long bits2words ( long num bit ) { return ( ( ( num bits-1 ) > > > 6 ) +1 ) ; }
public double get ( time unit unit ) { return get ( 0 , unit ) ; }
public static byte [ ] decompose ( uuid uuid ) { long most = uuid . get most significant bit ( ) ; long least = uuid . get least significant bit ( ) ; byte [ ] b = new byte [ 16 ] ; for ( int i = 0 ; i < 8 ; i++ ) { b [ i ] = ( byte ) ( most > > > ( ( 7-i ) * 8 ) ) ; b [ 8+i ] = ( byte ) ( least > > > ( ( 7-i ) * 8 ) ) ; } return b ; }
public static byte [ ] get time u u i d byte ( ) { return create time u u i d byte ( instance . create time safe ( ) ) ; }
public table option metadata get option ( ) { return option ; }
public object get init cond ( ) { return init cond ; }
public cluster unregister ( schema change listener listener ) { check not close ( manager ) ; boolean remove = manager . schema change listener . remove ( listener ) ; if ( remove ) listener . on unregister ( this ) ; return this ; }
public static builder builder ( long high trackable latency millis ) { return new builder ( high trackable latency millis ) ; }
public codec registry register ( type codec < ? > new codec ) { for ( type codec < ? > old codec : built_in_codecs ) { if ( old codec . accepts ( new codec . get cql type ( ) ) & & old codec . accepts ( new codec . get java type ( ) ) ) { logger . warn ( `` ignore codec { } because it collide with previously register codec { } `` , new codec , old codec ) ; return this ; } } for ( type codec < ? > old codec : codecs ) { if ( old codec . accepts ( new codec . get cql type ( ) ) & & old codec . accepts ( new codec . get java type ( ) ) ) { logger . warn ( `` ignore codec { } because it collide with previously register codec { } `` , new codec , old codec ) ; return this ; } } cache key key = new cache key ( new codec . get cql type ( ) , new codec . get java type ( ) ) ; type codec < ? > exist = cache . get if present ( key ) ; if ( exist ! = null ) { logger . warn ( `` ignore codec { } because it collide with previously generate codec { } `` , new codec , exist ) ; return this ; } this . codecs . add ( new codec ) ; return this ; }
public list < definition > a list ( ) { return array . a list ( by idx ) ; }
public protocol option get protocol option ( ) { return protocol option ; }
public static duration new instance ( int month , int day , long nanosecond ) { return new duration ( month , day , nanosecond ) ; }
public protocol version get server version ( ) { return server version ; }
public int get speculative execution ( ) { return speculative execution ; }
public page state get page state ( ) { if ( this . page state == null ) return null ; return new page state ( this . page state , this . statement , this . protocol version , this . codec registry ) ; }
public boolean be schema in agreement ( ) { return schema in agreement ; }
public boolean be call on null input ( ) { return call on null input ; }
public string get rack ( ) { return rack ; }
public string get dse workload ( ) { return dse workload ; }
public static builder builder ( ) { return new builder ( ) ; }
public static local date from day since epoch ( int day since epoch ) { return new local date ( day since epoch ) ; }
public int get day since epoch ( ) { return day since epoch ; }
public set < host > get replica ( string keyspace , token range range ) { keyspace = handle id ( keyspace ) ; token map current = token map ; if ( current == null ) { return collection . empty set ( ) ; } else { set < host > host = current . get replicas ( keyspace , range . get end ( ) ) ; return host == null ? collection . < host > empty set ( ) : host ; } }
public gauge < integer > get connect to host ( ) { return connect to ; }
public gauge < integer > get open connection ( ) { return open connection ; }
public meter get bytes receive ( ) { return bytes receive ; }
public static boolean be long literal ( string str ) { if ( str == null || str . be empty ( ) ) return false ; char [ ] char = str . to char array ( ) ; for ( int i = 0 ; i < char . length ; i++ ) { char c = char [ i ] ; if ( ( c < ' 0 ' & & ( i ! = 0 || c ! = '- ' ) ) || c > ' 9 ' ) return false ; } return true ; }
public long get max delay m ( ) { return max delay m ; }
public static assignment set idx ( string name , int idx , object value ) { return new assignment . list set idx assignment ( name , idx , value ) ; }
public int get fetch size ( ) { return fetch size ; }
public query option set reprepare on up ( boolean reprepare on up ) { this . reprepare on up = reprepare on up ; return this ; }
public query option set refresh schema interval millis ( int refresh schema interval millis ) { this . refresh schema interval millis = refresh schema interval millis ; return this ; }
public query option set max pending refresh schema request ( int max pending refresh schema request ) { this . max pending refresh schema request = max pending refresh schema request ; return this ; }
public string get request type ( ) { maybe fetch trace ( ) ; return request type ; }
public t if not exist ( ) { this . if not exist = true ; return self ; }
public t add u d t set column ( string column name , u d t type udt type ) { validate not empty ( column name , `` column name `` ) ; validate not null ( udt type , `` column element type `` ) ; validate not key word ( column name , string . format ( `` the column name ' % s ' be not allow because it be a reserved keyword `` , column name ) ) ; simple column . put ( column name , u d t type . set ( udt type ) ) ; return self ; }
public create add u d t static column ( string column name , u d t type udt type ) { validate not empty ( table name , `` column name `` ) ; validate not null ( udt type , `` column udt type `` ) ; validate not key word ( column name , string . format ( `` the static column name ' % s ' be not allow because it be a reserved keyword `` , column name ) ) ; static column . put ( column name , udt type ) ; return this ; }
public static create keyspace create keyspace ( string keyspace name ) { return new create keyspace ( keyspace name ) ; }
public static create type create type ( string type name ) { return new create type ( type name ) ; }
public static table option . speculative retry value percentile ( int percentile ) { if ( percentile < 0 || percentile > 100 ) { throw new illegal argument exception ( `` percentile value for speculative retry should be between 0 and 100 `` ) ; } return new table option . speculative retry value ( `` ' `` + percentile + `` percentile ' `` ) ; }
public t caching ( schema builder . cache cache ) { this . cassandra20 cache = optional . from nullable ( cache ) ; return self ; }
public int get read timeout millis ( ) { return read timeout millis ; }
public socket option set so linger ( int so linger ) { this . so linger = so linger ; return this ; }
public integer get receive buffer size ( ) { return receive buffer size ; }
public statement set serial consistency level ( consistency level serial consistency ) { if ( ! serial consistency . be serial ( ) ) throw new illegal argument exception ( `` supply consistency level be not serial : `` + serial consistency ) ; this . serial consistency = serial consistency ; return this ; }
public statement set page state ( page state paging state , codec registry codec registry ) { if ( this instanceof batch statement ) { throw new unsupported operation exception ( `` can not set the page state on a batch statement `` ) ; } else { if ( page state == null ) { this . page state = null ; } else if ( page state . match ( this , codec registry ) ) { this . page state = page state . get raw state ( ) ; } else { throw new page state exception ( `` page state mismatch , `` + `` this mean that either the paging state content be alter , `` + `` or you 're try to apply it to a different statement `` ) ; } } return this ; }
public double get read repair chance ( ) { return read repair ; }
public string get speculative retry ( ) { return speculative retry ; }
public schedule executor service create reconnection executor ( string cluster name ) { return new schedule thread pool executor ( 2 , create thread factory ( cluster name , `` reconnection `` ) ) ; }
public boolean be empty ( ) { return start . equal ( end ) & & ! start . equal ( factory . min token ( ) ) ; }
public boolean be wrap around ( ) { return start . compare to ( end ) > 0 & & ! end . equal ( factory . min token ( ) ) ; }
public static byte buffer from hex string ( string str ) { if ( ( str . length ( ) & 1 ) == 1 ) throw new illegal argument exception ( `` a cql blob string must have an even length ( since one byte be always 2 hexadecimal character ) `` ) ; if ( str . char at ( 0 ) ! = ' 0 ' || str . char at ( 1 ) ! = ' x ' ) throw new illegal argument exception ( `` a cql blob string must start with \ `` 0x\ `` `` ) ; return byte buffer . wrap ( from raw hex string ( str , 2 ) ) ; }
public static uuid random ( ) { return uuid . random u u i d ( ) ; }
public static uuid start of ( long timestamp ) { return new uuid ( make m s b ( from unix timestamp ( timestamp ) ) , min_clock_seq_and_node ) ; }
public static long unix timestamp ( uuid uuid ) { if ( uuid . version ( ) ! = 1 ) throw new illegal argument exception ( string . format ( `` can only retrieve the unix timestamp for version 1 uuid ( provide version % d ) `` , uuid . version ( ) ) ) ; long timestamp = uuid . timestamp ( ) ; return ( timestamp / 10000 ) + start_epoch ; }
public int get d s e patch ( ) { return dse patch ; }
public static string get cluster name ( ) { return database descriptor . get cluster name ( ) ; }
public static void set reflect ( config conf , class < ? extend kryo instantiator > inst class ) { conf . set ( key , inst class . get name ( ) ) ; }
public kryo instantiator set class loader ( final class loader cl ) { return new kryo instantiator ( ) { public kryo new kryo ( ) { kryo k = kryo instantiator . this . new kryo ( ) ; k . set class loader ( cl ) ; return k ; } } ; }
public kryo instantiator set instantiator strategy ( final instantiator strategy inst ) { return new kryo instantiator ( ) { public kryo new kryo ( ) { kryo k = kryo instantiator . this . new kryo ( ) ; k . set instantiator strategy ( inst ) ; return k ; } } ; }
public static kryo pool with byte array output stream ( int pool size , final kryo instantiator ki ) { return new kryo pool ( pool size ) { protect ser de state new instance ( ) { return new ser de state ( ki . new kryo ( ) , new input ( ) , new output ( new byte array output stream ( ) ) ) { / * * we have to take extra care of the byte array output stream * / @ override public void clear ( ) { super . clear ( ) ; byte array output stream byte stream = ( byte array output stream ) output . get output stream ( ) ; byte stream . reset ( ) ; } @ override public byte [ ] output to byte ( ) { output . flush ( ) ; byte array output stream byte stream = ( byte array output stream ) output . get output stream ( ) ; return byte stream . to byte array ( ) ; } @ override public void write output to ( output stream os ) throw i o exception { output . flush ( ) ; byte array output stream byte stream = ( byte array output stream ) output . get output stream ( ) ; byte stream . write to ( o ) ; } } ; } } ; }
public type signature get element type signature ( ) { return array type signature . get element type signature ( ) ; }
public class graph enable all info ( ) { enable class info ( ) ; enable field info ( ) ; enable method info ( ) ; enable annotation info ( ) ; enable static final field constant initializer value ( ) ; ignore class visibility ( ) ; ignore field visibility ( ) ; ignore method visibility ( ) ; return this ; }
public class graph disable runtime invisible annotation ( ) { enable class info ( ) ; scan spec . disable runtime invisible annotation = true ; return this ; }
public class graph disable jar scanning ( ) { scan spec . scan jar = false ; return this ; }
public class graph add module layer ( final object module layer ) { scan spec . add module layer ( module layer ) ; return this ; }
public class graph enable remote jar scanning ( ) { scan spec . enable remote jar scan = true ; return this ; }
public boolean have field annotation ( final string field annotation name ) { for ( final class info ci : get override order ( ) ) { if ( ci . have declare field annotation ( field annotation name ) ) { return true ; } } return false ; }
public boolean have declare method annotation ( final string method annotation name ) { for ( final method info mi : get declare method info ( ) ) { if ( mi . have annotation ( method annotation name ) ) { return true ; } } return false ; }
public class info list get method parameter annotation ( ) { return get field or method annotation ( rel type . method_parameter_annotations ) ; }
public class info list direct only ( ) { return new class info list ( directly relate class , directly relate class , sort by name ) ; }
public boolean contains name ( final string name ) { for ( final t i : this ) { if ( i . get name ( ) . equal ( name ) ) { return true ; } } return false ; }
public boolean be synchronize ( ) { return modifier . be synchronize ( modifier ) ; }
public type signature get type descriptor ( ) { return type descriptor ; }
public list < string > list ( ) throw security exception { if ( collector to list == null ) { throw new illegal argument exception ( `` could not call collector . to list ( ) `` ) ; } final object / * stream < string > * / resource stream = reflection utils . invoke method ( module reader , `` list `` , / * throw exception = * / true ) ; if ( resource stream == null ) { throw new illegal argument exception ( `` could not call module reader . list ( ) `` ) ; } final object resource list = reflection utils . invoke method ( resource stream , `` collect `` , collector class , collector to list , / * throw exception = * / true ) ; if ( resource list == null ) { throw new illegal argument exception ( `` could not call module reader . list ( ) . collect ( collector . to list ( ) ) `` ) ; } @ suppress warning ( `` unchecked `` ) final list < string > resource list type = ( list < string > ) resource list ; return resource list type ; }
public long get last modified ( ) { return last modify ; }
public resource list get resource with path ignore whitelist ( final string resource path ) { if ( close . get ( ) ) { throw new illegal argument exception ( `` can not use a scan result after it have be close `` ) ; } final string path = file utils . sanitize entry path ( resource path , / * remove initial slash = * / true ) ; final resource list matching resource = new resource list ( ) ; for ( final classpath element classpath elt : classpath order ) { final resource match resource = classpath elt . get resource ( path ) ; if ( match resource ! = null ) { matching resource . add ( match resource ) ; } } return matching resource ; }
public class info list get class implement ( final string interface name ) { if ( close . get ( ) ) { throw new illegal argument exception ( `` can not use a scan result after it have be close `` ) ; } if ( ! scan spec . enable class info ) { throw new illegal argument exception ( `` please call class graph # enable class info ( ) before # scan ( ) `` ) ; } final class info class info = class name to class info . get ( interface name ) ; return class info == null ? class info list . empty_list : class info . get class implement ( ) ; }
public string get path ( ) { return path ; }
public string get path within parent zip file slice ( ) { return path within parent zip file slice ; }
public string get path ( ) { final string builder buf = new string builder ( ) ; append path ( buf ) ; return buf . to string ( ) ; }
public static < t > t deserialize object ( final class < t > expect type , final string json ) throw illegal argument exception { final class field cache class field cache = new class field cache ( / * resolve type = * / true , / * only serialize public field = * / false ) ; return deserialize object ( expect type , json , class field cache ) ; }
public boolean whitelist and blacklist be empty ( ) { return whitelist be empty ( ) & & blacklist be empty ( ) ; }
public char sequence get subsequence ( final int start position , final int end position ) { return string . sub sequence ( start position , end position ) ; }
public string curr token ( ) { final string tok = token . to string ( ) ; token . set length ( 0 ) ; return tok ; }
public static string path element to path str ( final object . . . path elts ) { final string builder buf = new string builder ( ) ; for ( final object path elt : path elts ) { append path elt ( path elt , buf ) ; } return buf . to string ( ) ; }
public static void join ( final string builder buf , final string add at begin , final string sep , final string add at end , final iterable < ? > iterable ) { if ( ! add at begin . be empty ( ) ) { buf . append ( add at begin ) ; } boolean first = true ; for ( final object item : iterable ) { if ( first ) { first = false ; } else { buf . append ( sep ) ; } buf . append ( item . to string ( ) ) ; } if ( ! add at end . be empty ( ) ) { buf . append ( add at end ) ; } }
public static option builder with long opt ( string longopt ) { instance . longopt = longopt ; return instance ; }
public static option builder be require ( ) { instance . require = true ; return instance ; }
public static option builder with value separator ( ) { instance . valuesep = '= ' ; return instance ; }
public static option builder be require ( boolean require ) { instance . require = require ; return instance ; }
public static option builder with description ( string description ) { instance . description = description ; return instance ; }
public option add option ( string opt , boolean have arg , string description ) { add option ( opt , null , have arg , description ) ; return this ; }
public option group get option group ( option opt ) { return ( option group ) option group . get ( opt . get opt ( ) ) ; }
public static object create value ( string str , object obj ) { return create value ( str , ( class ) obj ) ; }
public static class create class ( string str ) { try { return class . for name ( str ) ; } catch ( class not find exception cnfe ) { system . err . println ( `` unable to find : `` +str ) ; return null ; } }
public void set option comparator ( comparator comparator ) { if ( comparator == null ) { this . option comparator = new option comparator ( ) ; } else { this . option comparator = comparator ; } }
public static sort bag decorate ( sort bag bag , transformer transformer ) { return new transform sort bag ( bag , transformer ) ; }
public object get ( ) { synchronize ( lock ) { while ( collection . be empty ( ) ) { try { if ( timeout < = 0 ) { lock . wait ( ) ; } else { return get ( timeout ) ; } } catch ( interrupted exception e ) { print writer out = new print writer ( new string writer ( ) ) ; e . print stack trace ( out ) ; throw new buffer underflow exception ( `` cause by interrupted exception : `` + out . to string ( ) ) ; } } return get buffer ( ) . get ( ) ; } }
public object remove ( final long timeout ) { synchronize ( lock ) { final long expiration = system . current time millis ( ) + timeout ; long time leave = expiration - system . current time millis ( ) ; while ( time leave > 0 & & collection . be empty ( ) ) { try { lock . wait ( time leave ) ; time leave = expiration - system . current time millis ( ) ; } catch ( interrupted exception e ) { print writer out = new print writer ( new string writer ( ) ) ; e . print stack trace ( out ) ; throw new buffer underflow exception ( `` cause by interrupted exception : `` + out . to string ( ) ) ; } } if ( collection . be empty ( ) ) { throw new buffer underflow exception ( `` timeout expired `` ) ; } return get buffer ( ) . remove ( ) ; } }
public int size ( ) { return size ; }
public object remove ( ) { if ( be empty ( ) ) { throw new buffer underflow exception ( `` the buffer be already empty `` ) ; } object element = buffer [ head ] ; if ( element ! = null ) { buffer [ head ] = null ; head = increment ( head ) ; } return element ; }
public static collection decorate ( collection coll , class type ) { return new predicate collection ( coll , instanceof predicate . get instance ( type ) ) ; }
public static boolean be sub collection ( final collection a , final collection b ) { map mapa = get cardinality map ( a ) ; map mapb = get cardinality map ( b ) ; iterator it = a . iterator ( ) ; while ( it . have next ( ) ) { object obj = it . next ( ) ; if ( get freq ( obj , mapa ) > get freq ( obj , mapb ) ) { return false ; } } return true ; }
public static object index ( object obj , int idx ) { return index ( obj , new integer ( idx ) ) ; }
public void add ( int index , object element ) { if ( index == _size ) { add ( element ) ; } else { if ( index < 0 || index > _size ) { throw new index out of bound exception ( string . value of ( index ) + `` < 0 or `` + string . value of ( index ) + `` > `` + _size ) ; } listable succ = ( be empty ( ) ? null : get listable at ( index ) ) ; listable pred = ( null == succ ? null : succ . prev ( ) ) ; insert listable ( pred , succ , element ) ; } }
public boolean equal ( object object ) { if ( object == this ) { return true ; } if ( object instanceof bag == false ) { return false ; } bag other = ( bag ) object ; if ( other . size ( ) ! = size ( ) ) { return false ; } for ( iterator it = _map . key set ( ) . iterator ( ) ; it . have next ( ) ; ) { object element = it . next ( ) ; if ( other . get count ( element ) ! = get count ( element ) ) { return false ; } } return true ; }
public object set value ( object value ) { object answer = this . value ; this . value = value ; return answer ; }
public string get include ( ) { return include ; }
public iterator get key ( ) { return key a list . iterator ( ) ; }
public void add ( int index , object element ) { if ( fast ) { synchronize ( this ) { array list temp = ( array list ) list . clone ( ) ; temp . add ( index , element ) ; list = temp ; } } else { synchronize ( list ) { list . add ( index , element ) ; } } }
public boolean add all ( int index , collection collection ) { if ( fast ) { synchronize ( this ) { array list temp = ( array list ) list . clone ( ) ; boolean result = temp . add all ( index , collection ) ; list = temp ; return ( result ) ; } } else { synchronize ( list ) { return ( list . add all ( index , collection ) ) ; } } }
public int index of ( object element ) { if ( fast ) { return ( list . index of ( element ) ) ; } else { synchronize ( list ) { return ( list . index of ( element ) ) ; } } }
public list iterator list iterator ( ) { if ( fast ) { return new list iter ( 0 ) ; } else { return list . list iterator ( ) ; } }
public list iterator list iterator ( int index ) { if ( fast ) { return new list iter ( index ) ; } else { return list . list iterator ( index ) ; } }
public static closure get instance ( predicate [ ] predicate , closure [ ] closure , closure default closure ) { functor utils . validate ( predicate ) ; functor utils . validate ( closure ) ; if ( predicate . length ! = closure . length ) { throw new illegal argument exception ( `` the predicate and closure array must be the same size `` ) ; } if ( predicate . length == 0 ) { return ( default closure == null ? n o p closure . instance : default closure ) ; } predicate = functor utils . copy ( predicate ) ; closure = functor utils . copy ( closure ) ; return new switch closure ( predicate , closure , default closure ) ; }
public static iterator object graph iterator ( object root , transformer transformer ) { return new object graph iterator ( root , transformer ) ; }
public boolean add all ( collection coll ) { return add all ( size ( ) , coll ) ; }
public synchronize map remove composited ( map map ) { int size = this . composite . length ; for ( int i = 0 ; i < size ; ++i ) { if ( this . composite [ i ] . equal ( map ) ) { map [ ] temp = new map [ size - 1 ] ; system . arraycopy ( this . composite , 0 , temp , 0 , i ) ; system . arraycopy ( this . composite , i + 1 , temp , i , size - i - 1 ) ; this . composite = temp ; return map ; } } return null ; }
public set entry set ( ) { composite set entry = new composite set ( ) ; for ( int i = this . composite . length - 1 ; i > = 0 ; -- i ) { entry . add composited ( this . composite [ i ] . entry set ( ) ) ; } return entry ; }
public void put all ( map map to copy ) { for ( iterator it = map to copy . key set ( ) . iterator ( ) ; it . have next ( ) ; ) { object key = it . next ( ) ; check key ( key ) ; } map . put all ( map to copy ) ; }
public static multi value map decorate ( map map , factory collection factory ) { return new multi value map ( map , collection factory ) ; }
public void put all ( map map ) { if ( map instanceof multi map ) { for ( iterator it = map . entry set ( ) . iterator ( ) ; it . have next ( ) ; ) { map . entry entry = ( map . entry ) it . next ( ) ; collection coll = ( collection ) entry . get value ( ) ; put all ( entry . get key ( ) , coll ) ; } } else { for ( iterator it = map . entry set ( ) . iterator ( ) ; it . have next ( ) ; ) { map . entry entry = ( map . entry ) it . next ( ) ; put ( entry . get key ( ) , entry . get value ( ) ) ; } } }
public static sort map decorate ( sort map map , transformer key transformer , transformer value transformer ) { return new transform sort map ( map , key transformer , value transformer ) ; }
public static order map decorate ( ordered map map ) { if ( map instanceof unmodifiable ) { return map ; } return new unmodifiable order map ( map ) ; }
public static object get object ( map map , object key , object default value ) { if ( map ! = null ) { object answer = map . get ( key ) ; if ( answer ! = null ) { return answer ; } } return default value ; }
public static float get float ( map map , object key , float default value ) { float answer = get float ( map , key ) ; if ( answer == null ) { answer = default value ; } return answer ; }
public static map invert map ( map map ) { map out = new hash map ( map . size ( ) ) ; for ( iterator it = map . entry set ( ) . iterator ( ) ; it . have next ( ) ; ) { map . entry entry = ( map . entry ) it . next ( ) ; out . put ( entry . get value ( ) , entry . get key ( ) ) ; } return out ; }
public static map synchronize map ( map map ) { return collection . synchronize map ( map ) ; }
public static map unmodifiable map ( map map ) { return unmodifiable map . decorate ( map ) ; }
public static map unmodifiable sort map ( sort map map ) { return unmodifiable sort map . decorate ( map ) ; }
public static sort map type sort map ( sort map map , class key type , class value type ) { return type sort map . decorate ( map , key type , value type ) ; }
public synchronize void add composited ( collection c , collection d ) { if ( ! ( c instanceof set ) ) throw new illegal argument exception ( `` argument must implement java . util . set `` ) ; if ( ! ( d instanceof set ) ) throw new illegal argument exception ( `` argument must implement java . util . set `` ) ; this . add composited ( new set [ ] { ( set ) c , ( set ) d } ) ; }
public string to string ( ) { return set order . to string ( ) ; }
public static sort set decorate ( sorted set set , transformer transformer ) { return new transform sort set ( set , transformer ) ; }
public static set type set ( set set , class type ) { return type set . decorate ( set , type ) ; }
public static transformer clone transformer ( ) { return clone transformer . instance ; }
public void close ( ) throw i o exception { if ( ! this . close ) { in . close ( ) ; this . close = true ; } }
public long skip ( final long n ) throw i o exception { if ( n < 0 ) { throw new illegal argument exception ( `` negative skip length `` ) ; } ensure open ( ) ; int max = ( int ) math . min ( n , integer . max_value ) ; int total = 0 ; while ( total < max ) { int len = max - total ; if ( len > this . tmpbuf . length ) { len = this . tmpbuf . length ; } len = read ( this . tmpbuf , 0 , len ) ; if ( len == -1 ) { this . entry e o f = true ; break ; } total += len ; } return total ; }
public void load ( ) throw configuration exception { if ( source u r l ! = null ) { load ( source u r l ) ; } else { load ( get file name ( ) ) ; } }
protect void possibly save ( ) { if ( auto save & & file name ! = null ) { try { save ( ) ; } catch ( configuration exception e ) { throw new configuration runtime exception ( `` fail to auto-save `` , e ) ; } } }
public void configuration change ( ) { fire event ( event_config_changed , null , get u r l ( ) , true ) ; }
public static bean factory get default bean factory ( ) { return default bean factory ; }
public string get bean class name ( ) { return get configuration ( ) . get string ( attr_bean_class ) ; }
public node combiner get node combiner ( ) { return node combiner ; }
public configuration get in memory configuration ( ) { return in memory configuration ; }
public static configuration get configuration ( property prop ) { return new map configuration ( prop ) ; }
public int length ( ) { return key buffer . length ( ) ; }
public void set error handler ( error handler handler ) { }
public void set root name ( string string ) { root name = string ; }
public < t > t get ( class < t > cl , string key ) { t value = get ( cl , key , null ) ; if ( value ! = null ) { return value ; } else if ( be throw exception on miss ( ) ) { throw new no such element exception ( '\ `` + key + `` ' do n't map to an exist object `` ) ; } else { return null ; } }
public list < byte > get byte list ( string key ) { return get byte list ( key , new array list < byte > ( ) ) ; }
public list < integer > get integer list ( string key , list < integer > default value ) { return get list ( integer . class , key , default value ) ; }
public calendar get calendar ( string key ) { return get ( calendar . class , key ) ; }
public boolean remove configuration listener ( configuration listener l ) { return listener . remove ( l ) ; }
protect void fire event ( int type , string prop name , object prop value , boolean before ) { if ( check detail event ( -1 ) ) { iterator < configuration listener > it = listener . iterator ( ) ; if ( it . have next ( ) ) { configuration event event = create event ( type , prop name , prop value , before ) ; while ( it . have next ( ) ) { it . next ( ) . configuration change ( event ) ; } } } }
public boolean deregister lookup ( string prefix ) { return local lookup . remove ( prefix ) ! = null ; }
public static short to short ( object value ) throw conversion exception { number n = to number ( value , short . class ) ; if ( n instanceof short ) { return ( short ) n ; } else { return new short ( n . short value ( ) ) ; } }
public string get subnode key ( ) { return subnode key ; }
protect string get child key ( string key ) { if ( ! key . start with ( prefix ) ) { throw new illegal argument exception ( `` the parent key ' `` + key + `` ' be not in the subset . `` ) ; } else { string modify key = null ; if ( key . length ( ) == prefix . length ( ) ) { modify key = `` `` ; } else { int i = prefix . length ( ) + ( delimiter ! = null ? delimiter . length ( ) : 0 ) ; modify key = key . substring ( i ) ; } return modified key ; } }
public void set name ( string name ) { check state ( ) ; this . name = name ; }
public void set attribute start ( string attribute start ) { this . attribute start = attribute start ; }
public string get new node name ( ) { return new node name ; }
protect view node create view node ( ) { return new view node ( ) ; }
public void append attribute ( configuration node source ) { if ( source ! = null ) { for ( configuration node attr : source . get attribute ( ) ) { add attribute ( attr ) ; } } }
public boolean set position ( int po ) { position = po ; return pos > = 1 & & po < = get max position ( ) ; }
protected object handle delimiters ( object value ) { if ( ! be delimiter parse disabled ( ) & & value instanceof string ) { list < string > list = property converter . split ( ( string ) value , get list delimiter ( ) ) ; value = list . size ( ) > 1 ? list : list . get ( 0 ) ; } return value ; }
public void load ( reader in ) throw configuration exception { load ( new input source ( in ) ) ; }
protect void add property direct ( string key , object obj ) { node add data data = get expression engine ( ) . prepare add ( get root node ( ) , key ) ; configuration node node = process node add data ( data ) ; node . set value ( obj ) ; }
public subnode configuration configuration at ( string key ) { return configuration at ( key , false ) ; }
protect void init node add data ( node add data data , string path ) { string last component = null ; boolean attr = false ; boolean first = true ; string tokenizer tok = new string tokenizer ( path , node_path_delimiters , true ) ; while ( tok . have more token ( ) ) { string token = tok . next token ( ) ; if ( path_delimiter . equal ( token ) ) { if ( attr ) { invalid path ( path , `` contain an attribute `` + `` delimiter at an unallowed position . `` ) ; } if ( last component == null ) { invalid path ( path , `` contain a '/ ' at an unallowed position . `` ) ; } data . add path node ( last component ) ; last component = null ; } else if ( attr_delimiter . equal ( token ) ) { if ( attr ) { invalid path ( path , `` contain multiple attribute delimiters . `` ) ; } if ( last component == null & & ! first ) { invalid path ( path , `` contain an attribute delimiter at an unallowed position . `` ) ; } if ( last component ! = null ) { data . add path node ( last component ) ; } attr = true ; last component = null ; } else { last component = token ; } first = false ; } if ( last component == null ) { invalid path ( path , `` contain no component . `` ) ; } data . set new node name ( last component ) ; data . set attribute ( attr ) ; }
public static crypto random get crypto random ( ) throw general security exception { property property = new property ( ) ; return get crypto random ( property ) ; }
public static crypto random get crypto random ( property prop ) throw general security exception { final list < string > name = utils . split class name ( get random class string ( prop ) , `` , `` ) ; if ( name . size ( ) == 0 ) { throw new illegal argument exception ( `` no classname ( s ) provide `` ) ; } string builder error message = new string builder ( ) ; crypto random random = null ; exception last exception = null ; for ( string klass name : name ) { try { final class < ? > klass = reflection utils . get class by name ( klass name ) ; random = ( crypto random ) reflection utils . new instance ( klass , prop ) ; if ( random ! = null ) { break ; } } catch ( class cast exception e ) { last exception = e ; error message . append ( `` class : [ `` + klass name + `` ] be not a crypto random . `` ) ; } catch ( class not find exception e ) { last exception = e ; error message . append ( `` crypto random : [ `` + klass name + `` ] not find . `` ) ; } catch ( exception e ) { last exception = e ; error message . append ( `` crypto random : [ `` + klass name + `` ] fail with `` + e . get message ( ) ) ; } } if ( random ! = null ) { return random ; } throw new general security exception ( error message . to string ( ) , last exception ) ; }
protect int get buffer size ( ) { return buffer size ; }
protect long get stream offset ( ) { return stream offset ; }
public static void read fully ( input in , long position , byte [ ] buffer , int offset , int length ) throw i o exception { int nread = 0 ; while ( nread < length ) { int nbytes = in . read ( position + nread , buffer , offset + nread , length - nread ) ; if ( nbytes < 0 ) { throw new i o exception ( `` end of stream reach before read fully . `` ) ; } nread += nbytes ; } }
public string [ ] get header ( ) { return header ! = null ? header . clone ( ) : null ; }
public quote mode get quote mode ( ) { return quote mode ; }
public boolean be comment marker set ( ) { return comment marker ! = null ; }
public boolean have comment ( ) { return comment ! = null ; }
public long get last used ( ) { return last used millis ; }
protect void set last used ( final long last used millis ) { this . last used millis = last use millis ; }
public synchronize class loader get driver class loader ( ) { return this . driver class loader ; }
public boolean get remove abandon on borrow ( ) { return abandon config == null ? false : abandon config . get remove abandon on borrow ( ) ; }
public boolean get rollback on return ( ) { return rollback on return ; }
protect void log ( string message , throwable throwable ) { if ( log writer ! = null ) { log writer . println ( message ) ; throwable . print stack trace ( log writer ) ; } }
public void set abandon log writer ( final print writer log writer ) { if ( abandon config == null ) { abandon config = new abandon config ( ) ; } abandon config . set log writer ( log writer ) ; final generic object pool < ? > gop = this . connection pool ; if ( gop ! = null ) { gop . set abandon config ( abandon config ) ; } }
public void set jmx name ( final string jmx name ) { this . jmx name = jmx name ; }
public synchronize void set pool prepared statement ( final boolean pool statement ) { this . pool prepare statement = pooling statement ; }
public synchronize void set soft min evictable idle time millis ( final long soft min evictable idle time millis ) { this . soft min evictable idle time millis = soft min evictable idle time millis ; if ( connection pool ! = null ) { connection pool . set soft min evictable idle time millis ( soft min evictable idle time millis ) ; } }
public int get num active ( ) { return get num active ( null ) ; }
public string get username ( ) { return user name ; }
public final connection get innermost delegate internal ( ) { connection conn = connection ; while ( conn ! = null & & conn instanceof delegate connection ) { conn = ( ( delegate connection < ? > ) conn ) . get delegate internal ( ) ; if ( this == conn ) { return null ; } } return conn ; }
public void clear cache state ( ) { auto commit cache = null ; read only cached = null ; if ( connection instanceof delegate connection ) { ( ( delegate connection < ? > ) connection ) . clear cached state ( ) ; } }
public transaction manager get transaction manager ( ) { return transaction manager ; }
public void set transaction manager ( final transaction manager transaction manager ) { this . transaction manager = transaction manager ; }
public string get username ( ) { return user name ; }
public void set clear statement pool on return ( final boolean clear statement pool on return ) { this . clear statement pool on return = clear statement pool on return ; }
public void set log writer ( final print writer out ) { log writer = out ; }
public synchronize object pool < ? extend connection > get connection pool ( final string name ) throw s q l exception { final object pool < ? extend connection > pool = pool . get ( name ) ; if ( null == pool ) { throw new s q l exception ( `` pool not register : `` + name ) ; } return pool ; }
public integer get auto generate key ( ) { return auto generate key ; }
public integer get result set holdability ( ) { return result set holdability ; }
public class loader get system class loader ( ) { return system class loader ; }
public resource name iterator find resource name ( string resource name ) { return find resource class ( resource name ) ; }
public static synchronize void release ( ) { environment cache . release ( ) ; }
public static synchronize void release ( class spi class ) { hash map spis = ( hash map ) environment cache . get ( j d k hook . get j d k hook ( ) . get thread context class loader ( ) ) ; if ( spis ! = null ) { spis . remove ( spi class . get name ( ) ) ; } }
public static enumeration property name ( ) { hashtable all prop = new hashtable ( ) ; class loader class loader = get thread context class loader ( ) ; / * * * order do n't matter , we be only go to use * the set of all key . . . * / while ( true ) { hash map property = null ; synchronize ( property cache ) { property = ( hash map ) property cache . get ( class loader ) ; } if ( property ! = null ) { all prop . put all ( property ) ; } if ( class loader == null ) break ; class loader = get parent ( class loader ) ; } return all prop . key ( ) ; }
public void set port attribute specify ( boolean value ) { have port attribute = value ; }
public void write ( byte [ ] b ) throw i o exception { count += b . length ; super . write ( b ) ; }
protect void threshold reach ( ) throw i o exception { if ( prefix ! = null ) { output file = file . create temp file ( prefix , suffix , directory ) ; } file output stream fo = new file output stream ( output file ) ; memory output stream . write to ( fo ) ; current output stream = fo ; memory output stream = null ; }
public void close ( ) throw i o exception { try { out . close ( ) ; } finally { lock file . delete ( ) ; } }
public hash code builder append ( byte [ ] array ) { if ( array == null ) { i total = i total * i constant ; } else { for ( int i = 0 ; i < array . length ; i++ ) { append ( array [ i ] ) ; } } return this ; }
public hash code builder append ( double [ ] array ) { if ( array == null ) { i total = i total * i constant ; } else { for ( int i = 0 ; i < array . length ; i++ ) { append ( array [ i ] ) ; } } return this ; }
public hash code builder append ( float [ ] array ) { if ( array == null ) { i total = i total * i constant ; } else { for ( int i = 0 ; i < array . length ; i++ ) { append ( array [ i ] ) ; } } return this ; }
public static string format ( long millis , string pattern , time zone time zone ) { return format ( new date ( millis ) , pattern , time zone , null ) ; }
public static string format ( long millis , string pattern , time zone time zone , locale locale ) { return format ( new date ( millis ) , pattern , time zone , locale ) ; }
public void subtract ( byte operand ) { this . value -= operand ; }
public void warn ( object message , throwable exception ) { log ( level . warning , string . value of ( message ) , exception ) ; }
public boolean be warn enabled ( ) { return category . be enable for ( priority . warn ) ; }
public void warn ( object message , throwable t ) { if ( message ! = null ) { get logger ( ) . warn ( string . value of ( message ) , t ) ; } }
public composable function post compose ( final univariate real function f ) { return new composable function ( ) { @ override / * * { @ inherit doc } * / public double value ( double x ) throw function evaluation exception { return f . value ( composable function . this . value ( x ) ) ; } } ; }
protect final void set result ( double new result , int iteration count ) { this . result = new result ; this . iteration count = iteration count ; this . result compute = true ; }
protect void verify iteration count ( ) throw illegal argument exception { if ( ( minimal iteration count < = 0 ) || ( maximal iteration count < = minimal iteration count ) ) { throw math runtime exception . create illegal argument exception ( `` invalid iteration limit : min= { 0 } , max= { 1 } `` , minimal iteration count , maximal iteration count ) ; } }
public void set micropshere element ( final int element ) { if ( microsphere element < 0 ) { throw math runtime exception . create illegal argument exception ( `` number of microsphere element must be positive , but get { 0 } `` , microsphere element ) ; } this . microsphere element = element ; }
protect void check result compute ( ) throw illegal state exception { if ( ! result compute ) { throw math runtime exception . create illegal state exception ( `` no result available `` ) ; } }
public boolean be na n ( ) { return be na n ; }
public boolean be infinite ( ) { return be infinite ; }
public double density ( double x ) { final double dev = x - median ; return ( 1 / math . pi ) * ( scale / ( dev * dev + scale * scale ) ) ; }
public void set denominator degree of freedom ( double degree of freedom ) { set denominator degree of freedom internal ( degree of freedom ) ; }
public void set number of success ( int success ) { set number of success internal ( success ) ; }
protect int get domain upper bound ( double p ) { return integer . max_value ; }
public double get shape ( ) { return shape ; }
public double get estimate ( ) { return estimate ; }
public big fraction add ( final int i ) { return add ( big integer . value of ( i ) ) ; }
public big fraction multiply ( final long l ) { return multiply ( big integer . value of ( l ) ) ; }
public big fraction pow ( final int exponent ) { if ( exponent < 0 ) { return new big fraction ( denominator . pow ( -exponent ) , numerator . pow ( -exponent ) ) ; } return new big fraction ( numerator . pow ( exponent ) , denominator . pow ( exponent ) ) ; }
public array field vector < t > projection ( array field vector < t > v ) { return ( array field vector < t > ) v . map multiply ( dot product ( v ) . divide ( v . dot product ( v ) ) ) ; }
public static array index out of bound exception create array index out of bound exception ( final string pattern , final object . . . argument ) { return new array index out of bound exception ( ) { / * * serializable version identifier . * / private static final long serial version u i d = -3394748305449283486l ; / * * { @ inherit doc } * / @ override public string get message ( ) { return build message ( locale . u , pattern , argument ) ; } / * * { @ inherit doc } * / @ override public string get localized message ( ) { return build message ( locale . get default ( ) , pattern , argument ) ; } } ; }
public void reset ( ) { initial time = double . na n ; final time = double . na n ; forward = true ; index = 0 ; step . clear ( ) ; }
public void add event handler ( final event handler handler , final double max check interval , final double convergence , final int max iteration count ) { state . add ( new event state ( handler , max check interval , convergence , max iteration count ) ) ; }
public collection < event state > get event state ( ) { return state ; }
public boolean be empty ( ) { return state . be empty ( ) ; }
public void clear event handler ( ) { integrator . clear event handler ( ) ; }
public void re seed ( ) { if ( rand == null ) { rand = new j d k random generator ( ) ; } rand . set seed ( system . current time millis ( ) ) ; }
public static double log beta ( double a , double b ) { return log beta ( a , b , default_epsilon , integer . max_value ) ; }
public void set geo mean impl ( storeless univariate statistic [ ] geo mean impl ) throw dimension mismatch exception { set impl ( geo mean impl , this . geo mean impl ) ; }
public static void set one way anova ( one way anova one way anova ) { test utils . one way anova = one way anova ; }
public double homoscedastic t ( double [ ] sample1 , double [ ] sample2 ) throw illegal argument exception { check sample data ( sample1 ) ; check sample data ( sample2 ) ; return homoscedastic t ( stat utils . mean ( sample1 ) , stat utils . mean ( sample2 ) , stat utils . variance ( sample1 ) , stat utils . variance ( sample2 ) , sample1 . length , sample2 . length ) ; }
public double t ( double [ ] sample1 , double [ ] sample2 ) throw illegal argument exception { check sample data ( sample1 ) ; check sample data ( sample2 ) ; return t ( stat utils . mean ( sample1 ) , stat utils . mean ( sample2 ) , stat utils . variance ( sample1 ) , stat utils . variance ( sample2 ) , sample1 . length , sample2 . length ) ; }
public double t test ( statistical summary sample stats1 , statistical summary sample stats2 ) throw illegal argument exception , math exception { check sample data ( sample stats1 ) ; check sample data ( sample stats2 ) ; return t test ( sample stats1 . get mean ( ) , sample stats2 . get mean ( ) , sample stats1 . get variance ( ) , sample stats2 . get variance ( ) , sample stats1 . get n ( ) , sample stats2 . get n ( ) ) ; }
public static double variance difference ( final double [ ] sample1 , final double [ ] sample2 , double mean difference ) throw illegal argument exception { double sum1 = 0d ; double sum2 = 0d ; double diff = 0d ; int n = sample1 . length ; if ( n < 2 || n ! = sample2 . length ) { throw math runtime exception . create illegal argument exception ( `` input array must have the same length and at least two element ( { 0 } and { 1 } ) `` , n , sample2 . length ) ; } for ( int i = 0 ; i < n ; i++ ) { diff = sample1 [ i ] - sample2 [ i ] ; sum1 += ( diff - mean difference ) * ( diff - mean difference ) ; sum2 += diff - mean difference ; } return ( sum1 - ( sum2 * sum2 / n ) ) / ( n - 1 ) ; }
public static double round ( double x , int scale ) { return round ( x , scale , big decimal . round_half_up ) ; }
public static double sinh ( double x ) { return ( math . exp ( x ) - math . exp ( -x ) ) / 2 . 0 ; }
public synchronize double substitute most recent element ( double value ) { if ( num element < 1 ) { throw math runtime exception . create array index out of bound exception ( `` can not substitute an element from an empty array `` ) ; } double discarded = internal array [ start index + ( num element - 1 ) ] ; internal array [ start index + ( num element - 1 ) ] = value ; return discard ; }
public synchronize void discard front element ( int i ) { discard extreme element ( i , true ) ; }
public boolean equal ( object object ) { if ( object == this ) { return true ; } if ( object instanceof resizable double array == false ) { return false ; } synchronize ( this ) { synchronize ( object ) { boolean result = true ; resizable double array other = ( resizable double array ) object ; result = result & & ( other . initial capacity == initial capacity ) ; result = result & & ( other . contraction criterion == contraction criterion ) ; result = result & & ( other . expansion factor == expansion factor ) ; result = result & & ( other . expansion mode == expansion mode ) ; result = result & & ( other . num element == num element ) ; result = result & & ( other . start index == start index ) ; if ( ! result ) { return false ; } else { return array . equal ( internal array , other . internal array ) ; } } } }
public string get time ( inet address host ) throw i o exception { return get time ( host , default_port ) ; }
public datagram socket create datagram socket ( ) throw socket exception { return new datagram socket ( ) ; }
public server socket create server socket ( int port ) throw i o exception { return new server socket ( port ) ; }
public input stream get input stream ( boolean long output ) throw i o exception { return get input stream ( long output , `` `` ) ; }
public int get reply ( ) throw i o exception { __get reply ( ) ; return _reply code ; }
public int appe ( string pathname ) throw i o exception { return send command ( f t p command . appe , pathname ) ; }
public int noop ( ) throw i o exception { return send command ( f t p command . noop ) ; }
public boolean be remote verification enable ( ) { return __remote verification enable ; }
public boolean set file type ( int file type ) throw i o exception { if ( f t p reply . be positive completion ( type ( file type ) ) ) { __file type = file type ; __file format = ftp . non_print_text_format ; return true ; } return false ; }
public boolean complete pending command ( ) throw i o exception { return f t p reply . be positive completion ( get reply ( ) ) ; }
public boolean send site command ( string argument ) throw i o exception { return f t p reply . be positive completion ( site ( argument ) ) ; }
public static date format symbol get date format symbol ( string shortmonths ) { string [ ] month = split short month string ( shortmonths ) ; date format symbol dfs = new date format symbol ( locale . u ) ; dfs . set short month ( month ) ; return dfs ; }
public boolean be directory ( ) { return ( _type == directory_type ) ; }
public void set name ( string name ) { _name = name ; }
public string get group ( ) { return _group ; }
public f t p file [ ] get previous ( int quantity request ) { list tmp result = new link list ( ) ; int count = quantity request ; while ( count > 0 & & this . _internal iterator . have previous ( ) ) { string entry = ( string ) this . _internal iterator . previous ( ) ; f t p file temp = this . parser . parse f t p entry ( entry ) ; tmp result . add ( 0 , temp ) ; count -- ; } return ( f t p file [ ] ) tmp result . to array ( new f t p file [ 0 ] ) ; }
public f t p client config get default configuration ( ) { return new f t p client config ( f t p client config . syst_nt , default_date_format , null , null , null , null ) ; }
public void omit newsgroup ( string newsgroup ) { add newsgroup ( `` ! `` + newsgroup ) ; }
public boolean be g m t ( ) { return __is g m t ; }
public boolean be allow to post ( ) { return _is allow to post ; }
public int get reply ( ) throw i o exception { __get reply ( ) ; return _reply code ; }
public string get reply string ( ) { return _reply string ; }
public reader retrieve article body ( ) throw i o exception { return retrieve article body ( null ) ; }
public reader retrieve article info ( int article number ) throw i o exception { return __retrieve article info ( integer . to string ( article number ) ) ; }
public void add newsgroup ( string newsgroup ) { if ( __newsgroup count++ > 0 ) __newsgroups . append ( ' , ' ) ; __newsgroups . append ( newsgroup ) ; }
public string get newsgroups ( ) { return __newsgroups . to string ( ) ; }
public void set version ( int version ) { _version = version ; }
public time stamp get transmit time stamp ( ) { return get timestamp ( transmit_timestamp_index ) ; }
public long ntp value ( ) { return ntp time ; }
public long get fraction ( ) { return ntp time & 0xffffffff l ; }
public static time stamp get current time ( ) { return get ntp time ( system . current time millis ( ) ) ; }
public string to string ( ) { return to string ( ntp time ) ; }
public boolean noop ( ) throw i o exception { if ( get state ( ) == transaction_state ) return ( send command ( p o p3 command . noop ) == p o p3 reply . ok ) ; return false ; }
public int helo ( string hostname ) throw i o exception { return send command ( s m t p command . helo , hostname ) ; }
public int rset ( ) throw i o exception { return send command ( s m t p command . rset ) ; }
public boolean set sender ( string address ) throw i o exception { return s m t p reply . be positive completion ( mail ( `` < `` + address + `` > `` ) ) ; }
public boolean add recipient ( relay path path ) throw i o exception { return s m t p reply . be positive completion ( rcpt ( path . to string ( ) ) ) ; }
public void set socket factory ( socket factory factory ) { if ( factory == null ) _socket factory_ = __default_socket_factory ; else _socket factory_ = factory ; }
public int [ ] start subnegotiation local ( ) { return null ; }
public byte [ ] get data ( ) { return _data ; }
public boolean get enable session creation ( ) { if ( _socket_ instanceof s s l socket ) return ( ( s s l socket ) _socket_ ) . get enable session creation ( ) ; return false ; }
public void set receive buffer size ( int size ) throw socket exception { receive buffer size = size ; }
public void set server socket factory ( server socket factory factory ) { if ( factory == null ) _server socket factory_ = __default_server_socket_factory ; else _server socket factory_ = factory ; }
protect protocol command support get command support ( ) { return _command support_ ; }
public boolean have feature ( string feature , string value ) throw i o exception { if ( ! init feature map ( ) ) { return false ; } set < string > entry = __features map . get ( feature . to upper case ( locale . english ) ) ; if ( entry ! = null ) { return entry . contains ( value ) ; } return false ; }
protect boolean restart ( long offset ) throw i o exception { __restart offset = 0 ; return f t p reply . be positive intermediate ( rest ( long . to string ( offset ) ) ) ; }
public void set restart offset ( long offset ) { if ( offset > = 0 ) { __restart offset = offset ; } }
public int get send data socket buffer size ( ) { return __send data socket buffer size ; }
public boolean rename ( string old mailbox name , string new mailbox name ) throw i o exception { return do command ( i m a p command . rename , old mailbox name + `` `` + new mailbox name ) ; }
public static boolean be untagged ( string line ) { return line . start with ( imap_untagged_prefix ) ; }
public static boolean be continuation ( string line ) { return line . start with ( imap_continuation_prefix ) ; }
public synchronize int get num idle ( ) { return _tot idle ; }
public boolean get log abandon ( ) { return this . log abandon ; }
public void set log abandon ( final boolean log abandon ) { this . log abandon = log abandon ; }
public final void set max wait millis ( final long max wait millis ) { this . max wait = duration . of millis ( max wait millis ) ; }
public void set jmx name base ( final string jmx name base ) { this . jmx name base = jmx name base ; }
public synchronize void mark abandon ( ) { state = pool object state . abandon ; }
public int get min idle ( ) { final int max idle save = get max idle ( ) ; if ( this . min idle > max idle save ) { return max idle save ; } return min idle ; }
public void set abandon config ( final abandon config abandon config ) { if ( abandon config == null ) { this . abandon config = null ; } else { this . abandon config = new abandon config ( ) ; this . abandon config . set log abandon ( abandon config . get log abandon ( ) ) ; this . abandon config . set log writer ( abandon config . get log writer ( ) ) ; this . abandon config . set remove abandon on borrow ( abandon config . get remove abandon on borrow ( ) ) ; this . abandon config . set remove abandon on maintenance ( abandon config . get remove abandon on maintenance ( ) ) ; this . abandon config . set remove abandon timeout ( abandon config . get remove abandon timeout duration ( ) ) ; this . abandon config . set use usage tracking ( abandon config . get use usage tracking ( ) ) ; this . abandon config . set require full stack trace ( abandon config . get require full stack trace ( ) ) ; } }
public boolean have take waiter ( ) { lock . lock ( ) ; try { return lock . have waiter ( not empty ) ; } finally { lock . unlock ( ) ; } }
public int remain capacity ( ) { lock . lock ( ) ; try { return capacity - count ; } finally { lock . unlock ( ) ; } }
public e take last ( ) throw interrupted exception { lock . lock ( ) ; try { e x ; while ( ( x = unlink last ( ) ) == null ) { not empty . await ( ) ; } return x ; } finally { lock . unlock ( ) ; } }
public static < t > object pool < t > erode pool ( final object pool < t > pool ) { return erode pool ( pool , 1f ) ; }
public static < t > pool object factory < t > synchronize pooled factory ( final pool object factory < t > factory ) { return new synchronize pooled object factory < > ( factory ) ; }
protect string substring after ( final string value , final char ch ) { final int index of = value . index of ( ch ) ; return index of > -1 ? value . substring ( index of + 1 ) : empty ; }
public static string pretty print ( pretty printable tree ) { string builder sb = new string builder ( ) ; pretty print ( tree . get node ( ) , sb , `` `` , true , true ) ; return sb . to string ( ) ; }
public static config render option concise ( ) { return new config render option ( false , false , false , true ) ; }
public boolean can convert ( class type ) { return bean provider . can instantiate ( type ) ; }
public time trace start tracer ( string name ) { return new time trace ( name , tracer . get ( ) ) ; }
public string get current connection string ( ) { return state . get ensemble provider ( ) . get connection string ( ) ; }
public static boolean should retry ( int rc ) { return ( rc == keeper exception . code . connectionloss . int value ( ) ) || ( rc == keeper exception . code . operationtimeout . int value ( ) ) || ( rc == keeper exception . code . sessionmoved . int value ( ) ) || ( rc == keeper exception . code . sessionexpired . int value ( ) ) ; }
public boolean be shutdown ( ) { return ! be open . get ( ) ; }
public void clear ( ) { listener . clear ( ) ; }
public synchronize void wait on barrier ( ) throw exception { wait on barrier ( -1 , null ) ; }
public stat get stat ( ) { return stat ; }
public static builder new builder ( curator framework client , string path ) { return new builder ( client , path ) ; }
public void start ( ) { precondition . check state ( state . compare and set ( state . latent , state . start ) , `` can not be start more than once `` ) ; precondition . check state ( ! executor service . be shutdown ( ) , `` already start `` ) ; precondition . check state ( ! have leadership , `` already have leadership `` ) ; client . get connection state listenable ( ) . add listener ( listener ) ; requeue ( ) ; }
public inter process mutex read lock ( ) { return read mutex ; }
public void add path ( string path , mode mode ) { path holder path holder = new path holder ( path , mode , 0 ) ; active path . put ( path , path holder ) ; schedule ( path holder , reap threshold m ) ; }
public collection < string > get queue path ( ) { return immutable set . copy of ( queue . key set ( ) ) ; }
public byte [ ] element ( ) throw exception { byte [ ] bytes = internal element ( false , null ) ; if ( bytes == null ) { throw new no such element exception ( ) ; } return byte ; }
public byte [ ] poll ( long timeout , time unit unit ) throw exception { return internal poll ( timeout , unit ) ; }
public boolean try set count ( versioned value < integer > previous , int new count ) throw exception { versioned value < byte [ ] > previous copy = new versioned value < byte [ ] > ( previous . get version ( ) , to byte ( previous . get value ( ) ) ) ; return share value . try set value ( previous copy , to byte ( new count ) ) ; }
public long get upper bound at ( final int index ) { return upper bound [ index ] ; }
public boolean compare and set ( final long expect value , final long new value ) { return unsafe . compare and swap long ( pad value , value offset , expect value , new value ) ; }
public void set ( final long value ) { this . value = value ; }
public boolean be x h t m l ( ) { return do x h t m l ; }
protect map add to name map ( map map , string name , rule rule ) { if ( map == null ) { map = new hash map ( ) ; } rule set rule set = ( rule set ) map . get ( name ) ; if ( rule set == null ) { rule set = new rule set ( ) ; map . put ( name , rule set ) ; } rule set . add rule ( rule ) ; return map ; }
protect object sput ( object key , object value , int hash ) { entry [ ] tab = table ; int index = hash & ( tab . length - 1 ) ; entry first = tab [ index ] ; entry e = first ; for ( ; ; ) { if ( e == null ) { entry new entry = new entry ( hash , key , value , first ) ; tab [ index ] = new entry ; if ( ++count > = threshold ) rehash ( ) ; else record modification ( new entry ) ; return null ; } else if ( e . hash == hash & & eq ( key , e . key ) ) { object old value = e . value ; e . value = value ; return old value ; } else e = e . next ; } }
public collection value ( ) { collection v = value ; return ( vs ! = null ) ? v : ( value = new value ( ) ) ; }
public enumeration element ( ) { return new value iterator ( ) ; }
protect map create map ( ) { return collection . synchronize map ( new hash map ( ) ) ; }
protect map create index ( ) { return new hash map ( ) ; }
public static double any double ( ) { report matcher ( any . any ) ; return 0 ; }
public static double geq ( double value ) { report matcher ( new great or equal ( value ) ) ; return 0 ; }
public static int leq ( int value ) { report matcher ( new less or equal ( value ) ) ; return 0 ; }
public static byte lt ( byte value ) { report matcher ( new less than ( value ) ) ; return 0 ; }
public static double lt ( double value ) { report matcher ( new less than ( value ) ) ; return 0 ; }
public static int lt ( int value ) { report matcher ( new less than ( value ) ) ; return 0 ; }
public static < t > t be a ( class < t > clazz ) { report matcher ( new instance of ( clazz ) ) ; return null ; }
public static float or ( float first , float second ) { last control . report or ( 2 ) ; return 0 ; }
public static int or ( int first , int second ) { last control . report or ( 2 ) ; return first ; }
public static byte not ( byte first ) { last control . report not ( ) ; return 0 ; }
public static boolean eq ( boolean value ) { report matcher ( new equal ( value ) ) ; return false ; }
public static string match ( string regex ) { report matcher ( new match ( regex ) ) ; return null ; }
public void verify ( ) { ctrl . verify ( ) ; }
public type annotation walker to method return ( ) { return to target ( annotation target type constant . method_return ) ; }
public type annotation walker to wildcard bound ( ) { long new match = this . match ; if ( new match == 0 ) return empty_annotation_walker ; int length = this . type annotation . length ; long mask = 1 ; for ( int i = 0 ; i < length ; i++ , mask = mask < < 1 ) { i binary type annotation candidate = this . type annotation [ i ] ; int [ ] path = candidate . get type path ( ) ; if ( this . path ptr > = path . length || path [ this . path ptr ] ! = annotation target type constant . wildcard_bound ) { new match & = ~mask ; } } return restrict ( new match , this . path ptr+2 ) ; }
public recover element add ( statement stmt , int bracket balance value ) { if ( this . already complete local initialization || ! ( stmt instanceof expression ) ) { return super . add ( stmt , bracket balance value ) ; } else { this . already complete local initialization = true ; this . local declaration . initialization = ( expression ) stmt ; this . local declaration . declaration source end = stmt . source end ; this . local declaration . declaration end = stmt . source end ; return this ; } }
protect offset source get offset source ( string field ) { if ( offset source == null ) { return super . get offset source ( field ) ; } return offset source ; }
public cluster allocation explain request builder set include yes decision ( boolean include yes decision ) { request . include yes decision ( include yes decision ) ; return this ; }
public cluster allocation explain request builder use any unassigned shard ( ) { request . set index ( null ) ; request . set shard ( null ) ; request . set primary ( null ) ; return this ; }
public void level ( level level ) { this . level = object . require non null ( level , `` level must not be null `` ) ; }
public version get version ( ) { return version ; }
public setting get setting ( ) { return this . setting ; }
public jvm stats get jvm ( ) { return jvm ; }
public thread pool stats get thread pool ( ) { return this . thread pool ; }
public boolean get wait for completion ( ) { return wait for completion ; }
public final list task request builder set description ( string . . . description ) { request . set description ( description ) ; return this ; }
public put repository request type ( string type ) { this . type = type ; return this ; }
public cluster reroute request command ( allocation command command ) { this . command = command ; return this ; }
public clone snapshot request builder set index option ( index option index option ) { request . index option ( index option ) ; return this ; }
public string [ ] index ( ) { return index ; }
public get snapshots request snapshot ( string [ ] snapshot ) { this . snapshots = snapshot ; return this ; }
public restore snapshot request partial ( boolean partial ) { this . partial = partial ; return this ; }
public snapshot status request ignore unavailable ( boolean ignore unavailable ) { this . ignore unavailable = ignore unavailable ; return this ; }
public boolean ignore unavailable ( ) { return ignore unavailable ; }
public long get incremental size ( ) { return incremental size ; }
public string index routing ( ) { return index routing ; }
public close index request builder set index option ( index option index option ) { request . index option ( index option ) ; return this ; }
public string get provide name ( ) { return provide name ; }
public setting setting ( ) { return setting ; }
public create index request setting ( map < string , ? > source ) { this . setting = setting . builder ( ) . load from map ( source ) . build ( ) ; return this ; }
public create index request source ( string source , x content type x content type ) { return source ( new byte array ( source ) , x content type ) ; }
public string [ ] index ( ) { return index ; }
public boolean force ( ) { return force ; }
public put map request set concrete index ( index index ) { object . require non null ( index , `` index must not be null `` ) ; this . concrete index = index ; return this ; }
public open index request builder set index option ( index option index option ) { request . index option ( index option ) ; return this ; }
public void detail ( boolean detail ) { this . detailed = detail ; }
public void add max index doc condition ( long num doc ) { max doc condition max docs condition = new max doc condition ( num doc ) ; if ( this . condition . contains key ( max doc condition . name ) ) { throw new illegal argument exception ( max doc condition . name + `` condition be already set `` ) ; } this . condition . put ( max doc condition . name , max docs condition ) ; }
public void add max index size condition ( byte size value size ) { max size condition max size condition = new max size condition ( size ) ; if ( this . condition . contains key ( max size condition . name ) ) { throw new illegal argument exception ( max size condition + `` condition be already set `` ) ; } this . condition . put ( max size condition . name , max size condition ) ; }
public update setting request setting ( string source , x content type x content type ) { this . setting = setting . builder ( ) . load from source ( source , x content type ) . build ( ) ; return this ; }
public index shard store request builder set shard status ( string . . . shard status ) { request . shard status ( shard status ) ; return this ; }
public shard rout get shard routing ( ) { return this . shard routing ; }
public string name ( ) { return this . name ; }
public query builder query ( ) { return query ; }
public static backoff policy wrap ( backoff policy delegate , runnable on backoff ) { return new wrap backoff policy ( delegate , on backoff ) ; }
public bulk request add ( doc write request < ? > request ) { if ( request instanceof index request ) { add ( ( index request ) request ) ; } else if ( request instanceof delete request ) { add ( ( delete request ) request ) ; } else if ( request instanceof update request ) { add ( ( update request ) request ) ; } else { throw new illegal argument exception ( `` no support for request [ `` + request + `` ] `` ) ; } index . add ( request . index ( ) ) ; return this ; }
public bulk request wait for active shard ( active shard count wait for active shard ) { this . wait for active shard = wait for active shard ; return this ; }
public time value get take ( ) { return new time value ( take in millis ) ; }
public plain action future < bulk response > with backoff ( bi consumer < bulk request , action listener < bulk response > > consumer , bulk request bulk request ) { plain action future < bulk response > future = plain action future . new future ( ) ; with backoff ( consumer , bulk request , future ) ; return future ; }
public string get index name ( ) { return index name ; }
public field capability request field ( string . . . field ) { if ( field == null || field . length == 0 ) { throw new illegal argument exception ( `` specify field ca n't be null or empty `` ) ; } set < string > field set = new hash set < > ( arrays . a list ( field ) ) ; this . field = field set . to array ( new string [ 0 ] ) ; return this ; }
public get request refresh ( boolean refresh ) { this . refresh = refresh ; return this ; }
public long version ( ) { return version ; }
public bytes reference get source internal ( ) { return get result . internal source ref ( ) ; }
public index request builder set require alias ( boolean require alias ) { request . set require alias ( require alias ) ; return this ; }
public simulate pipeline request builder set verbose ( boolean verbose ) { request . set verbose ( verbose ) ; return this ; }
public search request builder set fetch source ( @ nullable string include , @ nullable string exclude ) { source builder ( ) . fetch source ( include , exclude ) ; return this ; }
public search request builder add rescorer ( rescorer builder < ? > rescorer ) { source builder ( ) . add rescorer ( rescorer ) ; return this ; }
public void add listener ( action listener < response > listener ) { delegate . add listener ( listener ) ; }
public final request builder set master node timeout ( time value timeout ) { request . master node timeout ( timeout ) ; return ( request builder ) this ; }
public final boolean local ( ) { return local ; }
public string get phase ( ) { return phase ; }
public string id ( ) { return id ; }
public term vector request id ( string id ) { this . id = id ; return this ; }
public boolean realtime ( ) { return this . realtime ; }
public term vector request builder set type ( string type ) { request . type ( type ) ; return this ; }
public update request fetch source ( boolean fetch source ) { fetch source context context = this . fetch source context == null ? fetch source context . fetch_source : this . fetch source context ; this . fetch source context = new fetch source context ( fetch source , context . include ( ) , context . excludes ( ) ) ; return this ; }
public update request fetch source ( fetch source context context ) { this . fetch source context = context ; return this ; }
public update request doc ( index request doc ) { this . doc = doc ; return this ; }
public update request upsert ( index request upsert request ) { this . upsert request = upsert request ; return this ; }
public void print stack trace ( print stream s ) { print stack trace ( s : : println ) ; }
public static bulk request bulk request ( ) { return new bulk request ( ) ; }
public static index shard store request index shard store request ( string . . . index ) { return new index shard store request ( index ) ; }
public static index aliases request index alias request ( ) { return new index aliases request ( ) ; }
public static force merge request force merge request ( string . . . index ) { return new force merge request ( index ) ; }
public boolean retryable ( ) { return this . retryable ; }
public join handle start join ( start join request start join request ) { if ( start join request . get term ( ) < = get current term ( ) ) { logger . debug ( `` handle start join : ignoring [ { } ] a term provide be not great than current term [ { } ] `` , start join request , get current term ( ) ) ; throw new coordination state reject exception ( `` incoming term `` + start join request . get term ( ) + `` not great than current term `` + get current term ( ) ) ; } logger . debug ( `` handle start join : leaving term [ { } ] due to { } `` , get current term ( ) , start join request ) ; if ( join vote . be empty ( ) == false ) { final string reason ; if ( election win == false ) { reason = `` failed election `` ; } else if ( start join request . get source node ( ) . equal ( local node ) ) { reason = `` bumping term `` ; } else { reason = `` stand down as leader `` ; } logger . debug ( `` handle start join : discarding { } : { } `` , join vote , reason ) ; } persist state . set current term ( start join request . get term ( ) ) ; assert get current term ( ) == start join request . get term ( ) ; last publish version = 0 ; last publish configuration = get last accepted configuration ( ) ; start join since last reboot = true ; election win = false ; join vote = new vote collection ( ) ; publish vote = new vote collection ( ) ; return new join ( local node , start join request . get source node ( ) , get current term ( ) , get last accepted term ( ) , get last accepted version or metadata version ( ) ) ; }
public string get index ( ) { return index ; }
public string get name ( ) { return name ; }
public set < string > resolve expression ( cluster state state , string . . . expression ) { context context = new context ( state , index option . lenient expand open ( ) , true , false , true , get system index access level ( ) , get system index access predicate ( ) , get net new system index predicate ( ) ) ; list < string > resolve expression = arrays . a list ( expression ) ; for ( expression resolver expression resolver : expression resolvers ) { resolved expression = expression resolver . resolve ( context , resolve expression ) ; } return collection . unmodifiable set ( new hash set < > ( resolve expression ) ) ; }
public static boolean be all index ( collection < string > alias or index ) { return aliases or index == null || alias or index . be empty ( ) || be explicit all pattern ( alias or index ) ; }
public string [ ] get concrete all index ( ) { return all index ; }
public string [ ] get concrete all open index ( ) { return all open index ; }
public string [ ] get concrete visible open index ( ) { return visible open index ; }
public int get total number of shard ( ) { return this . total number of shard ; }
public node shutdown metadata put single node metadata ( single node shutdown metadata node shutdown metadata ) { hash map < string , single node shutdown metadata > new node = new hash map < > ( node ) ; new node . put ( node shutdown metadata . get node id ( ) , node shutdown metadata ) ; return new node shutdown metadata ( new node ) ; }
public repository metadata repository ( string name ) { for ( repository metadata repository : repository ) { if ( name . equal ( repository . name ( ) ) ) { return repository ; } } return null ; }
public discovery node find by address ( transport address address ) { for ( object cursor < discovery node > cursor : node . value ( ) ) { discovery node node = cursor . value ; if ( node . get address ( ) . equal ( address ) ) { return node ; } } return null ; }
public list < node allocation result > sort node decision ( list < node allocation result > node decision ) { return collection . unmodifiable list ( node decision . stream ( ) . sort ( ) . collect ( collector . to list ( ) ) ) ; }
public float get shard balance ( ) { return weight function . shard balance ; }
public boolean mark a stale ( ) { return mark a stale ; }
public static < shard it extend comparable < shard it > & countable > group shard iterator < shard it > sort and create ( list < shard it > iterators ) { collection util . tim sort ( iterators ) ; return new group shard iterator < > ( iterators ) ; }
public boolean all primary shard active ( ) { return primary shard active ( ) == shard ( ) . size ( ) ; }
public int primary shard active ( ) { int counter = 0 ; for ( index shard rout table shard rout table : this ) { if ( shard rout table . primary shard ( ) . active ( ) ) { counter++ ; } } return counter ; }
public iterator < shard rout > node interleave shard iterator ( ) { final queue < iterator < shard rout > > queue = new array deque < > ( ) ; for ( map . entry < string , rout node > entry : node to shard . entry set ( ) ) { queue . add ( entry . get value ( ) . copy shard ( ) . iterator ( ) ) ; } return new iterator < shard rout > ( ) { public boolean have next ( ) { while ( queue . be empty ( ) == false ) { if ( queue . peek ( ) . have next ( ) ) { return true ; } queue . poll ( ) ; } return false ; } public shard rout next ( ) { if ( have next ( ) == false ) { throw new no such element exception ( ) ; } iterator < shard rout > iter = queue . poll ( ) ; shard rout result = iter . next ( ) ; queue . offer ( iter ) ; return result ; } public void remove ( ) { throw new unsupported operation exception ( ) ; } } ; }
public list < shard rout > all shard ( string index ) { list < shard rout > shard = new array list < > ( ) ; index rout table index rout table = index ( index ) ; if ( index rout table == null ) { throw new index not find exception ( index ) ; } for ( index shard rout table index shard rout table : index rout table ) { for ( shard rout shard routing : index shard rout table ) { shard . add ( shard routing ) ; } } return shard ; }
public shard rout remove relocation source ( ) { assert primary == false : this ; assert state == shard rout state . initializing : this ; assert assign to node ( ) : this ; assert relocate node id ! = null : this ; return new shard routing ( shard id , current node id , null , primary , state , recovery source , unassigned info , allocation id . finish relocation ( allocation id ) , expect shard size ) ; }
public reason get reason ( ) { return this . reason ; }
public cluster state state ( ) { assert assert not call from cluster state applier ( `` the applied cluster state be not yet available `` ) ; cluster state cluster state = this . state . get ( ) ; assert cluster state ! = null : `` initial cluster state not set yet `` ; return cluster state ; }
public int number of pending task ( ) { return thread pool executor . get number of pending task ( ) ; }
public void put ( k key , v value ) { long now = now ( ) ; put ( key , value , now ) ; }
public iterable < k > key ( ) { return ( ) - > new iterator < k > ( ) { private cache iterator iterator = new cache iterator ( head ) ; @ override public boolean have next ( ) { return iterator . have next ( ) ; } @ override public k next ( ) { return iterator . next ( ) . key ; } @ override public void remove ( ) { iterator . remove ( ) ; } } ; }
public bytes reference uncompressed ( ) { try { return compressor factory . uncompress ( new byte array ( byte ) ) ; } catch ( i o exception e ) { throw new illegal state exception ( `` can not decompress compress string `` , e ) ; } }
public long get ( string field ) { return stats . get ( field ) ; }
public static void decompose line ( line line , list < line > collector ) { if ( line . be empty ( ) ) { return ; } double [ ] lons = new double [ line . length ( ) ] ; double [ ] lats = new double [ lons . length ] ; for ( int i = 0 ; i < lons . length ; i++ ) { double [ ] lon lat = new double [ ] { line . get x ( i ) , line . get y ( i ) } ; normalize point ( lon lat , false , true ) ; lons [ i ] = lon lat [ 0 ] ; lats [ i ] = lon lat [ 1 ] ; } decompose ( lons , lat , collector ) ; }
public list < parameter > get all parameter ( ) { return all parameter ; }
public static annotation create ( ) { return create ( next unique value . get and increment ( ) ) ; }
public static void read from file channel with eof exception ( file channel channel , long channel position , byte [ ] d , int d offset , int length ) throw i o exception { int read = read from file channel ( channel , channel position , dest , d offset , length ) ; if ( read < 0 ) { throw new e o f exception ( `` read past eof . pos [ `` + channel position + `` ] length : [ `` + length + `` ] end : [ `` + channel . size ( ) + `` ] `` ) ; } }
public static void delete sub directory ( path . . . path ) throw i o exception { for ( path path : path ) { try ( directory stream < path > stream = file . new directory stream ( path ) ) { for ( path sub path : stream ) { if ( file . be directory ( sub path ) ) { i o utils . rm ( sub path ) ; } } } } }
public version get version ( ) { return this . version ; }
public void write optional byte reference ( @ nullable byte reference byte ) throw i o exception { if ( bytes == null ) { write v int ( 0 ) ; return ; } write v int ( byte . length ( ) + 1 ) ; byte . write to ( this ) ; }
public void write v int ( int i ) throw i o exception { / * * shortcut write single byte because it be very , very common and * can skip grab the scratch buffer . this be marginally slow * than hand unroll the entire encoding loop but hand unrolling * the encode loop blow out the method size so it ca n't be inlined . * in that case benchmarks of the method itself be faster but * benchmark of method that use this method be slow . * this be philosophically in line with vint in general - it bias * twoards be simple and fast for small number . * / if ( integer . number of lead zero ( i ) > = 25 ) { write byte ( ( byte ) i ) ; return ; } byte [ ] buffer = scratch . get ( ) ; int index = 0 ; do { buffer [ index++ ] = ( ( byte ) ( ( i & 0x7f ) | 0x80 ) ) ; i > > > = 7 ; } while ( ( i & ~0x7 f ) ! = 0 ) ; buffer [ index++ ] = ( ( byte ) i ) ; write byte ( buffer , 0 , index ) ; }
public < e extend enum < e > > void write optional enum ( @ nullable e enum value ) throw i o exception { if ( enum value == null ) { write boolean ( false ) ; } else { write boolean ( true ) ; write v int ( enum value . ordinal ( ) ) ; } }
public static cluster id converter new instance ( @ suppress warning ( `` unused `` ) final string [ ] option ) { return new cluster id converter ( ) ; }
public final int hash code ( ) { / * * override hash code here and forward to an abstract method to force extension of this class to override hash code in the same * way that we force them to override equal . this also prevent false positive in check style 's equal hash code check . * / return object . hash ( score combiner , do hash code ( ) ) ; }
public static query new match no doc query ( string reason ) { return new match no doc query ( reason ) ; }
public void set boost factor ( float boost factor ) { this . boost factor = boost factor ; }
public analyzer get analyzer ( ) { return analyzer ; }
public int get max doc freq ( ) { return max doc freq ; }
public string describe params ( ) { string builder sb = new string builder ( ) ; sb . append ( `` \t `` ) . append ( `` max query term : `` ) . append ( max query term ) . append ( `` \n `` ) ; sb . append ( `` \t `` ) . append ( `` min word len : `` ) . append ( min word len ) . append ( `` \n `` ) ; sb . append ( `` \t `` ) . append ( `` max word len : `` ) . append ( max word len ) . append ( `` \n `` ) ; sb . append ( `` \t `` ) . append ( `` field name : `` ) ; string delim = `` `` ; for ( string field name : field name ) { sb . append ( delim ) . append ( field name ) ; delim = `` , `` ; } sb . append ( `` \n `` ) ; sb . append ( `` \t `` ) . append ( `` boost : `` ) . append ( boost ) . append ( `` \n `` ) ; sb . append ( `` \t `` ) . append ( `` min term freq : `` ) . append ( min term freq ) . append ( `` \n `` ) ; sb . append ( `` \t `` ) . append ( `` min doc freq : `` ) . append ( min doc freq ) . append ( `` \n `` ) ; return sb . to string ( ) ; }
public static string to cidr string ( inet address address , int prefix length ) { return new string builder ( ) . append ( to addr string ( address ) ) . append ( `` / `` ) . append ( prefix length ) . to string ( ) ; }
public static string format ( inet address address ) { return format ( address , new port range ( `` `` ) ) ; }
public static inet address [ ] get all address ( ) throw i o exception { return filter all address ( address - > true , `` no up-and-running address found `` ) ; }
public path get path ( ) { return path ; }
public final void validate ( final setting setting , final boolean validate value ) { validate ( setting , validate value , false , false ) ; }
public static void validate setting name ( string set ) { if ( allowed_setting_name . matcher ( set ) . match ( ) == false ) { throw new illegal argument exception ( `` set name [ `` + setting + `` ] do not match the allowed setting name pattern [ `` + allowed_setting_name . pattern ( ) + `` ] `` ) ; } }
public synchronize void close ( ) { if ( char ! = null ) { array . fill ( char , '\0 ' ) ; char = null ; } }
public string get default raw ( settings setting ) { return default value . apply ( setting ) ; }
public final boolean match ( string to test ) { return key . match ( to test ) ; }
public static long round quarter of year ( final long utc millis ) { int year = get year ( utc millis ) ; int month = get month of year ( utc millis , year ) ; int first month of quarter = ( ( ( month-1 ) / 3 ) * 3 ) + 1 ; return date utils . of ( year , first month of quarter ) ; }
public double get earth radius ( ) { return geo utils . earth_semi_major_axis / meter ; }
public double to meter ( double distance ) { return convert ( distance , this , distance unit . meter ) ; }
public void resize ( long new size ) { final int num page = num page ( new size ) ; if ( num page > page . length ) { page = array . copy of ( page , array util . oversize ( num page , ram usage estimator . num_bytes_object_ref ) ) ; } for ( int i = num page - 1 ; i > = 0 & & page [ i ] == null ; -- i ) { page [ i ] = new byte page ( i ) ; } for ( int i = num page ; i < page . length & & page [ i ] ! = null ; ++i ) { page [ i ] = null ; release page ( i ) ; } this . size = new size ; }
public long find ( byte ref key , int code ) { final long slot = slot ( rehash ( code ) , mask ) ; for ( long index = slot ; ; index = next slot ( index , mask ) ) { final long id = id ( index ) ; if ( id == -1l || key . byte equal ( get ( id , spare ) ) ) { return id ; } } }
public static void write double l e ( double d , byte [ ] arr , int offset ) { write long l e ( double . double to raw long bit ( d ) , arr , offset ) ; }
public static boolean be empty ( object [ ] array ) { return array == null || array . length == 0 ; }
public synchronize void reschedule if necessary ( ) { if ( be close ( ) ) { return ; } if ( cancellable ! = null ) { cancellable . cancel ( ) ; } if ( interval . millis ( ) > 0 & & must reschedule ( ) ) { if ( logger . be trace enable ( ) ) { logger . trace ( `` schedule { } every { } `` , to string ( ) , interval ) ; } cancellable = thread pool . schedule ( this , interval , get thread pool ( ) ) ; be schedule or run = true ; } else { logger . trace ( `` schedule { } disable `` , to string ( ) ) ; cancellable = null ; be schedule or run = false ; } }
public void on rejection ( exception e ) { on failure ( e ) ; }
public int get current queue size ( ) { return work queue . size ( ) ; }
public store context stash with origin ( string origin ) { final thread context . store context store context = stash context ( ) ; put transient ( action_origin_transient_name , origin ) ; return store context ; }
public < t > t get transient ( string key ) { return ( t ) thread local . get ( ) . transient header . get ( key ) ; }
public void mark a system context ( ) { thread local . set ( thread local . get ( ) . set system context ( ) ) ; }
public void register breaker ( consumer < long > breaker ) { this . breaker = object . require non null ( breaker , `` circuit breaker consumer can not be null `` ) ; breaker . accept ( get size in byte ( ) ) ; }
public static string [ ] node string array value ( object node ) { if ( be array ( node ) ) { list list = ( list ) node ; string [ ] arr = new string [ list . size ( ) ] ; for ( int i = 0 ; i < arr . length ; i++ ) { arr [ i ] = node string value ( list . get ( i ) , null ) ; } return arr ; } else { return string . split string by comma to array ( node . to string ( ) ) ; } }
public time value get publish timeout ( ) { return publish timeout ; }
public set < discovery node > get node ( ) { return collection . unmodifiable set ( nodes f d . key set ( ) ) ; }
public synchronize cluster state [ ] pending cluster state ( ) { array list < cluster state > state = new array list < > ( ) ; for ( cluster state context context : pending state ) { state . add ( context . state ) ; } return state . to array ( new cluster state [ state . size ( ) ] ) ; }
public void add metadata ( string key , string . . . value ) { add metadata ( key , array . a list ( value ) ) ; }
public throwable get root cause ( ) { throwable root cause = this ; throwable cause = get cause ( ) ; while ( cause ! = null & & cause ! = root cause ) { root cause = cause ; cause = cause . get cause ( ) ; } return root cause ; }
protect void metadata to x content ( x content builder builder , params params ) throw i o exception { }
public path resolve repo file ( string location ) { return path utils . get ( repo file , location ) ; }
public void validate tmp file ( ) throw i o exception { if ( file . exists ( tmp file ) == false ) { throw new file not find exception ( `` temporary file directory [ `` + tmp file + `` ] do not exist or be not accessible `` ) ; } if ( file . be directory ( tmp file ) == false ) { throw new i o exception ( `` configure temporary file directory [ `` + tmp file + `` ] be not a directory `` ) ; } }
public static void assert equivalent ( environment actual , environment expect ) { assert equal ( actual . data file ( ) , expect . data file ( ) , `` data file `` ) ; assert equal ( actual . repo file ( ) , expect . repo file ( ) , `` repo file `` ) ; assert equal ( actual . config file ( ) , expect . config file ( ) , `` config file `` ) ; assert equal ( actual . plugins file ( ) , expect . plugins file ( ) , `` plugins file `` ) ; assert equal ( actual . bin file ( ) , expect . bin file ( ) , `` bin file `` ) ; assert equal ( actual . lib file ( ) , expect . lib file ( ) , `` lib file `` ) ; assert equal ( actual . module file ( ) , expect . module file ( ) , `` module file `` ) ; assert equal ( actual . log file ( ) , expect . log file ( ) , `` log file `` ) ; assert equal ( actual . pid file ( ) , expect . pid file ( ) , `` pid file `` ) ; assert equal ( actual . tmp file ( ) , expect . tmp file ( ) , `` tmp file `` ) ; }
public static path resolve node path ( final path path , final int node lock id ) { return path . resolve ( nodes_folder ) . resolve ( integer . to string ( node lock id ) ) ; }
protect static list < node allocation result > build decision for all node ( shard rout shard , rout allocation allocation ) { list < node allocation result > result = new array list < > ( ) ; for ( rout node node : allocation . rout node ( ) ) { decision decision = allocation . deciders ( ) . can allocate ( shard , node , allocation ) ; result . add ( new node allocation result ( node . node ( ) , null , decision ) ) ; } return result ; }
public void cleanup old file ( final long current generation , path [ ] location ) { final string file name to keep = get state file name ( current generation ) ; for ( path location : location ) { logger . trace ( `` cleanup old file : cleaning up { } `` , location ) ; path state location = location . resolve ( state_dir_name ) ; try ( directory state dir = new directory ( state location ) ) { for ( string file : state dir . list all ( ) ) { if ( file . start with ( prefix ) & & file . equal ( file name to keep ) == false ) { delete file ignore exception ( state location , state dir , file ) ; } } } catch ( exception e ) { logger . trace ( `` clean up fail for state location { } `` , state location ) ; } } }
public long write index ( string reason , index metadata index metadata ) throw write state exception { final index index = index metadata . get index ( ) ; logger . trace ( `` [ { } ] write state , reason [ { } ] `` , index , reason ) ; try { long generation = index_metadata_format . write ( index metadata , node env . index path ( index metadata . get index ( ) ) ) ; logger . trace ( `` [ { } ] state write `` , index ) ; return generation ; } catch ( write state exception ex ) { throw new write state exception ( false , `` [ `` + index + `` ] : fail to write index state `` , ex ) ; } }
public static list < string > get word list ( environment env , setting setting , string set prefix ) { return get word list ( env , setting , set prefix + `` _path `` , set prefix , true ) ; }
public name analyzer get ( string name ) { return analyzer . get ( name ) ; }
public analysis mode get analysis mode ( ) { return this . analysis mode ; }
public int get num doc ( ) { return num doc ; }
public final commit stats commit stats ( ) { return new commit stats ( get last committed segment info ( ) ) ; }
public long get max see auto id timestamp ( ) { return index request . unset_auto_generated_timestamp ; }
public index setting get index setting ( ) { return index setting ; }
public long get doc value memory in byte ( ) { return this . doc value memory in byte ; }
public numeric doc value get raw float value ( ) { return new abstract numeric doc value ( ) { private int doc i d = -1 ; @ override public boolean advance exact ( int target ) throw i o exception { doc i d = target ; return numeric double value . this . advance exact ( target ) ; } @ override public long long value ( ) throw i o exception { return float . float to raw int bit ( ( float ) numeric double value . this . double value ( ) ) ; } @ override public int doc i d ( ) { return doc i d ; } } ; }
public byte size value get flush threshold size ( ) { return flush threshold size ; }
public collapse type collapse type ( ) { return collapse type . none ; }
public boolean be aggregatable ( ) { try { fielddata builder ( `` `` , ( ) - > { throw new unsupported operation exception ( `` search lookup not available `` ) ; } ) ; return true ; } catch ( illegal argument exception e ) { return false ; } }
public boolean have mapping ( ) { return this ! = empty ; }
public mapping get mapping ( ) { return mapping ; }
public string get id ( ) { return id ; }
public static void set max nested depth ( int max nest depth ) { if ( max nest depth < 1 ) { throw new illegal argument exception ( `` max nested depth must be > = 1 `` ) ; } bool query builder . max nest depth = max nest depth ; }
public list < query builder > filter ( ) { return this . filter clause ; }
public bool query builder minimum should match ( string minimum should match ) { this . minimum should match = minimum should match ; return this ; }
public bool query builder adjust pure negative ( boolean adjust pure negative ) { this . adjust pure negative = adjust pure negative ; return this ; }
public combine field query builder field ( string field ) { if ( string . be empty ( field ) ) { throw new illegal argument exception ( `` supply field be null or empty . `` ) ; } this . field and boost . put ( field , abstract query builder . default_boost ) ; return this ; }
public function score query builder boost mode ( combine function combine function ) { if ( combine function == null ) { throw new illegal argument exception ( `` [ `` + name + `` ] require 'boost_mode ' field `` ) ; } this . boost mode = combine function ; return this ; }
public geo distance query builder distance ( string distance ) { return distance ( distance , distance unit . default ) ; }
public geo distance query builder geohash ( string geohash ) { if ( string . be empty ( geohash ) ) { throw new illegal argument exception ( `` geohash must not be null or empty `` ) ; } this . center . reset from geo hash ( geohash ) ; return this ; }
public geo distance geo distance ( ) { return this . geo distance ; }
public geo polygon query builder set validation method ( geo validation method method ) { this . validation method = method ; return this ; }
public string minimum should match ( ) { return this . minimum should match ; }
public string fuzzy rewrite ( ) { return this . fuzzy rewrite ; }
public match query builder analyzer ( string analyzer ) { this . analyzer = analyzer ; return this ; }
public more like this query builder unlike ( string [ ] unlike text ) { this . unlike texts = optional . of nullable ( unlike text ) . or else ( string . empty_array ) ; return this ; }
public multi match query builder field ( string field , float boost ) { if ( string . be empty ( field ) ) { throw new illegal argument exception ( `` supply field be null or empty . `` ) ; } check negative boost ( boost ) ; this . field boost . put ( field , boost ) ; return this ; }
public multi match query builder slop ( int slop ) { if ( slop < 0 ) { throw new illegal argument exception ( `` no negative slop allow . `` ) ; } this . slop = slop ; return this ; }
public nest query builder ignore unmapped ( boolean ignore unmapped ) { this . ignore unmapped = ignore unmapped ; if ( inner hit builder ! = null ) { inner hit builder . set ignore unmapped ( ignore unmapped ) ; } return this ; }
public static match bool prefix query builder match bool prefix query ( string name , object text ) { return new match bool prefix query builder ( name , text ) ; }
public static distance feature query builder distance feature query ( string name , origin origin , string pivot ) { return new distance feature query builder ( name , origin , pivot ) ; }
public static query string query builder query string query ( string query string ) { return new query string query builder ( query string ) ; }
public static boosting query builder boost query ( query builder positive query , query builder negative query ) { return new boost query builder ( positive query , negative query ) ; }
public static type query builder type query ( string type ) { return new type query builder ( type ) ; }
public static script query builder script query ( script script ) { return new script query builder ( script ) ; }
public static geo bound box query builder geo bound box query ( string name ) { return new geo bound box query builder ( name ) ; }
public query string query builder analyzer ( string analyzer ) { this . analyzer = analyzer ; return this ; }
public regexp query builder max determinized state ( int value ) { this . max determinized state = value ; return this ; }
public similarity get default similarity ( ) { return similarity service ! = null ? similarity service . get default similarity ( ) : null ; }
public < factory type > factory type compile ( script script , script context < factory type > context ) { factory type factory = script service . compile ( script , context ) ; if ( factory instanceof script factory & & ( ( script factory ) factory ) . be result deterministic ( ) == false ) { fail if frozen ( ) ; } return factory ; }
public final boolean be cacheable ( ) { return cacheable ; }
public int get shard id ( ) { return shard id ; }
public int get shard request index ( ) { return shard request index ; }
public index setting get index setting ( ) { return index setting ; }
public simple query string builder quote field suffix ( string suffix ) { setting . quote field suffix ( suffix ) ; return this ; }
public string quote field suffix ( ) { return setting . quote field suffix ( ) ; }
public int current a target ( ) { return current a target . get ( ) ; }
public string get reason cancel ( ) { return status . get reason cancel ( ) ; }
public reindex request set source index ( string . . . source index ) { if ( source index ! = null ) { this . get search request ( ) . index ( source index ) ; } return this ; }
public void set d pipeline ( string pipeline name ) { this . get destination ( ) . set pipeline ( pipeline name ) ; }
public boolean might match non nest doc ( query query , string nested path ) { if ( query instanceof constant score query ) { return might match non nest doc ( ( ( constant score query ) query ) . get query ( ) , nested path ) ; } else if ( query instanceof boost query ) { return might match non nest doc ( ( ( boost query ) query ) . get query ( ) , nested path ) ; } else if ( query instanceof match all docs query ) { return true ; } else if ( query instanceof match no docs query ) { return false ; } else if ( query instanceof term query ) { return might match non nest doc ( ( ( term query ) query ) . get term ( ) . field ( ) , nested path ) ; } else if ( query instanceof term in set query ) { prefix cod term term = ( ( term in set query ) query ) . get term data ( ) ; if ( term . size ( ) > 0 ) { prefix cod term . term iterator it = term . iterator ( ) ; it . next ( ) ; return might match non nest doc ( it . field ( ) , nested path ) ; } else { return false ; } } else if ( query instanceof point range query ) { return might match non nest doc ( ( ( point range query ) query ) . get field ( ) , nested path ) ; } else if ( query instanceof index or doc value query ) { return might match non nest doc ( ( ( index or doc value query ) query ) . get index query ( ) , nested path ) ; } else if ( query instanceof boolean query ) { final boolean query bq = ( boolean query ) query ; final boolean have require clause = bq . clause ( ) . stream ( ) . any match ( boolean clause : : be require ) ; if ( have require clause ) { return bq . clause ( ) . stream ( ) . filter ( boolean clause : : be require ) . map ( boolean clause : : get query ) . all match ( q - > might match non nest doc ( q , nested path ) ) ; } else { return bq . clause ( ) . stream ( ) . filter ( c - > c . get occur ( ) == occur . should ) . map ( boolean clause : : get query ) . any match ( q - > might match non nest doc ( q , nested path ) ) ; } } else { return true ; } }
public void remove retention lease ( final string id , final action listener < replication response > listener ) { object . require non null ( listener ) ; final retention lease current retention lease ; synchronize ( this ) { assert primary mode ; if ( retention lease . contains ( id ) == false ) { throw new retention lease not find exception ( id ) ; } logger . debug ( `` remove retention lease [ { } ] from current retention lease [ { } ] `` , id , retention lease ) ; retention lease = new retention lease ( operation primary term , retention lease . version ( ) + 1 , retention lease . lease ( ) . stream ( ) . filter ( lease - > lease . id ( ) . equal ( id ) == false ) . collect ( collector . to list ( ) ) ) ; current retention lease = retention lease ; } on sync retention lease . accept ( current retention lease , listener ) ; }
public string source ( ) { return source ; }
public void write to ( final stream output out ) throw i o exception { retention lease . write to ( out ) ; }
public segment info read last committed segment info ( ) throw i o exception { fail if corrupt ( ) ; try { return read segment info ( null , directory ( ) ) ; } catch ( corrupt index exception | index format too old exception | index format too new exception ex ) { mark store corrupt ( ex ) ; throw ex ; } }
public static long read global checkpoint ( final path location , final string expect translog u u i d ) throw i o exception { final checkpoint checkpoint = read checkpoint ( location , expect translog u u i d ) ; return checkpoint . global checkpoint ; }
public long get uncommitted size in byte ( ) { return uncommitted size in byte ; }
public string executor for search ( string index name ) { system index descriptor index descriptor = system index . find matching descriptor ( index name ) ; if ( object . non null ( index descriptor ) ) { return index descriptor . get thread pool name ( ) . thread pool for search ( ) ; } system data stream descriptor data stream descriptor = system index . find matching data stream descriptor ( index name ) ; if ( object . non null ( data stream descriptor ) ) { return data stream descriptor . get thread pool name ( ) . thread pool for search ( ) ; } return thread pool . name . search ; }
protect void write index buffer async ( index shard shard ) { thread pool . executor ( thread pool . name . refresh ) . execute ( new abstract runnable ( ) { @ override public void do run ( ) { shard . write index buffer ( ) ; } @ override public void on failure ( exception e ) { logger . warn ( ( ) - > new parameterized message ( `` fail to write index buffer for shard [ { } ] ; ignore `` , shard . shard id ( ) ) , e ) ; } } ) ; }
public long start recovery ( index shard index shard , discovery node source node , peer recovery target service . recovery listener listener , time value activity timeout ) { recovery target recovery target = new recovery target ( index shard , source node , listener ) ; start recovery internal ( recovery target , activity timeout ) ; return recovery target . recovery id ( ) ; }
public string get temp name for file ( string orig file ) { return multi file writer . get temp name for file ( orig file ) ; }
public system index descriptor get descriptor compatible with ( version version ) { if ( minimum node version . on or before ( version ) ) { return this ; } for ( system index descriptor prior : prior system index descriptor ) { if ( version . on or after ( prior . minimum node version ) ) { return prior ; } } return null ; }
public void remove field ( template script . factory field path template ) { remove field ( render template ( field path template ) ) ; }
public void validate ( params params , cluster state cluster state ) { }
public collection < class < ? extend lifecycle component > > get guice service class ( ) { return collection . empty list ( ) ; }
public string get classname ( ) { return classname ; }
public string get version ( ) { return version ; }
public t read ( string repo name , blob container blob container , string name , name x content registry name x content registry ) throw i o exception { string blob name = blob name ( name ) ; try ( input stream in = blob container . read blob ( blob name ) ) { return deserialize ( repo name , name x content registry , in ) ; } }
protect void register handler ( rest request . method method , string path , rest handler handler ) { if ( handler instanceof base rest handler ) { usage service . add rest handler ( ( base rest handler ) handler ) ; } register handler no wrap ( method , path , handler wrapper . apply ( handler ) ) ; }
public static rest request request without parameter ( name x content registry x content registry , http request http request , http channel http channel ) { map < string , string > params = collection . empty map ( ) ; return new rest request ( x content registry , params , http request . uri ( ) , http request . get header ( ) , http request , http channel , request id generator . increment and get ( ) ) ; }
public double get_score ( ) { try { return scorer . score ( ) ; } catch ( i o exception e ) { throw new elasticsearch exception ( `` could n't lookup score `` , e ) ; } }
protect final leaf search lookup get leaf lookup ( ) { return leaf lookup ; }
public x content builder to x content ( x content builder builder , params builder params ) throw i o exception { builder . start object ( ) ; string content type = option == null ? null : option . get ( content_type_option ) ; if ( type == script type . inline ) { if ( content type ! = null & & builder . content type ( ) . medium type ( ) . equal ( content type ) ) { try ( input stream stream = new byte array ( id or code ) . stream input ( ) ) { builder . raw field ( source_parse_field . get preferred name ( ) , stream ) ; } } else { builder . field ( source_parse_field . get preferred name ( ) , id or code ) ; } } else { builder . field ( `` id `` , id or code ) ; } if ( lang ! = null ) { builder . field ( lang_parse_field . get preferred name ( ) , lang ) ; } if ( option ! = null & & option . be empty ( ) == false ) { builder . field ( options_parse_field . get preferred name ( ) , option ) ; } if ( params . be empty ( ) == false ) { builder . field ( params_parse_field . get preferred name ( ) , params ) ; } builder . end object ( ) ; return builder ; }
public string get name ( ) { return name ; }
public collection < pipeline aggregation builder > get pipeline aggregation ( ) { return factory builder . get pipeline aggregator factory ( ) ; }
public aggregator [ ] create sub aggregator ( aggregator parent , cardinality upper bound cardinality ) throw i o exception { aggregator [ ] aggregator = new aggregator [ count aggregator ( ) ] ; for ( int i = 0 ; i < factory . length ; ++i ) { aggregator [ i ] = context . profile if enable ( factory [ i ] . create ( parent , cardinality ) ) ; } return aggregator ; }
public ab script ( script script ) { if ( script == null ) { throw new illegal argument exception ( `` [ script ] must not be null `` ) ; } this . script = script ; return ( ab ) this ; }
public boolean miss bucket ( ) { return miss bucket ; }
public static long long encode ( string hash a string ) { int [ ] parse = parse hash ( hash a string ) ; return long encode ( ( long ) parse [ 0 ] , ( long ) parse [ 1 ] , ( long ) parse [ 2 ] ) ; }
public boolean keyed ( ) { return key ; }
public histogram aggregation builder offset ( double offset ) { this . offset = offset ; return this ; }
public date range aggregation builder add range ( string key , string from , string to ) { add range ( new range aggregator . range ( key , from , to ) ) ; return this ; }
public diversify aggregation builder max doc per value ( int max doc per value ) { if ( max doc per value < 0 ) { throw new illegal argument exception ( `` [ max doc per value ] must be great than or equal to 0 . find [ `` + max doc per value + `` ] in [ `` + name + `` ] `` ) ; } this . max doc per value = max doc per value ; return this ; }
public long shard min doc count ( ) { return bucket count threshold . get shard min doc count ( ) ; }
public term aggregation builder collect mode ( sub agg collection mode collect mode ) { if ( collect mode == null ) { throw new illegal argument exception ( `` [ collect mode ] must not be null : [ `` + name + `` ] `` ) ; } this . collect mode = collect mode ; return this ; }
public final void validate ( aggregator aggregator ) throw aggregation execution exception { / * * building partially build bucket comparator and throw it away be enough * to validate this order because do so check all of the appropriate * path . * / partially build bucket comparator ( null , aggregator ) ; }
public boolean be map ( ) { return true ; }
public static internal aggregation top level reduce ( list < internal aggregation > aggregation list , reduce context context ) { internal aggregation reduce = reduce ( aggregation list , context , reduce aggregation - > new internal aggregation ( reduced aggregation , context . pipeline tree for bwc serialization ( ) ) ) ; if ( reduce == null ) { return null ; } if ( context . be final reduce ( ) ) { list < internal aggregation > reduce internal aggs = reduce . get internal aggregation ( ) ; reduce internal aggs = reduce internal aggs . stream ( ) . map ( agg - > agg . reduce pipeline ( agg , context , context . pipeline tree root ( ) . sub tree ( agg . get name ( ) ) ) ) . collect ( collector . to list ( ) ) ; for ( pipeline aggregator pipeline aggregator : context . pipeline tree root ( ) . aggregator ( ) ) { sibling pipeline aggregator sib = ( sibling pipeline aggregator ) pipeline aggregator ; internal aggregation new agg = sib . do reduce ( from ( reduce internal aggs ) , context ) ; reduce internal aggs . add ( new agg ) ; } return from ( reduce internal aggs ) ; } return reduce ; }
public static boolean be count desc ( bucket order order ) { return be order ( order , count_desc ) ; }
public static boolean be key desc ( bucket order order ) { return be order ( order , key_desc ) ; }
public boolean be noop ( ) { return false ; }
public double [ ] get key ( ) { return key ; }
public boolean keyed ( ) { return key ; }
public double compression ( ) { return compression ; }
public int size ( ) { return size ; }
public store field context store field ( ) { return store field context ; }
public boolean explain ( ) { return explain ; }
public final pipeline aggregator create ( ) { pipeline aggregator aggregator = create internal ( this . metadata ) ; return aggregator ; }
public int window ( ) { return window ; }
public mov avg model model ( ) { return model ; }
public int predict ( ) { return predict ; }
public int get window ( ) { return window ; }
public void set window ( int window ) { if ( window < = 0 ) { throw new illegal argument exception ( `` [ `` + window . get preferred name ( ) + `` ] must be a positive , non-zero integer . `` ) ; } this . window = window ; }
public static double holt ( double [ ] value , double alpha , double beta ) { if ( value . length == 0 ) { return double . na n ; } return holt forecast ( value , alpha , beta , 1 ) [ 0 ] ; }
public list < b > build ( ) { list < b > result = new array list < > ( queue . size ( ) ) ; for ( int i = queue . size ( ) - 1 ; i > = 0 ; i -- ) { result . add ( queue . pop ( ) . reduce ( ) ) ; } collection . reverse ( result ) ; return result ; }
public aggregator factory . builder aggregation ( ) { return aggregation ; }
public search source builder rewrite ( query rewrite context context ) throw i o exception { assert ( this . equal ( shallow copy ( query builder , post query builder , aggregation , slice builder , sort , rescore builder , highlight builder ) ) ) ; query builder query builder = null ; if ( this . query builder ! = null ) { query builder = this . query builder . rewrite ( context ) ; } query builder post query builder = null ; if ( this . post query builder ! = null ) { post query builder = this . post query builder . rewrite ( context ) ; } aggregator factory . builder aggregation = null ; if ( this . aggregation ! = null ) { aggregation = this . aggregation . rewrite ( context ) ; } list < sort builder < ? > > sort = rewriteable . rewrite ( this . sort , context ) ; list < rescorer builder > rescore builder = rewriteable . rewrite ( this . rescore builder , context ) ; highlight builder highlight builder = this . highlight builder ; if ( highlight builder ! = null ) { highlight builder = this . highlight builder . rewrite ( context ) ; } boolean rewritten = query builder ! = this . query builder || post query builder ! = this . post query builder || aggregation ! = this . aggregation || rescore builder ! = this . rescore builder || sort ! = this . sort || this . highlight builder ! = highlight builder ; if ( rewrite ) { return shallow copy ( query builder , post query builder , aggregation , this . slice builder , sort , rescore builder , highlight builder ) ; } return this ; }
public search source builder shallow copy ( ) { return shallow copy ( query builder , post query builder , aggregation , slice builder , sort , rescore builder , highlight builder ) ; }
public static long sub one ( long value ) { assert value > = 0 ; return value - 1 ; }
public string get index name ( ) { return search context . index shard ( ) . shard id ( ) . get index name ( ) ; }
public fetch source context fetch source context ( ) { return search context . fetch source context ( ) ; }
public boolean version ( ) { return search context . version ( ) ; }
public boolean fetch field ( ) { return fetch field ; }
public hb no match size ( integer no match size ) { this . no match size = no match size ; return ( hb ) this ; }
public < t > t get from context ( string key ) { return context ! = null ? ( t ) context . get ( key ) : null ; }
public list < object > extract raw value ( string path ) { return x content map value . extract raw value ( path , source ( ) ) ; }
public void start rewrite time ( ) { assert rewrite scratch == 0 ; rewrite scratch = system . nano time ( ) ; }
public void start rewrite time ( ) { ( ( internal query profile tree ) profile tree ) . start rewrite time ( ) ; }
public collector result get collector ( ) { return collector . get collector tree ( ) ; }
public profile shard result consume profile result ( ) { if ( profile shard result == null ) { throw new illegal state exception ( `` profile result already consume `` ) ; } profile shard result result = profile shard result ; profile shard result = null ; return result ; }
public int get window size ( ) { return window size ; }
public long get version ( ) { return this . version ; }
public search shard target get shard ( ) { return shard ; }
public can match response can match ( shard search request request ) throw i o exception { return can match ( request , true ) ; }
protect final string debug format ( ) { string builder b = new string builder ( ) ; for ( long index = 0 ; index < value ( ) . size ( ) ; index++ ) { if ( index % bucket size == 0 ) { b . append ( '\n ' ) . append ( string . format ( locale . root , `` % 20d `` , index / bucket size ) ) . append ( `` : `` ) ; } b . append ( string . format ( locale . root , `` % 20 `` , get value ( index ) ) ) . append ( ' ' ) ; } return b . to string ( ) ; }
public geo distance sort builder point ( double lat , double lon ) { point . add ( new geo point ( lat , lon ) ) ; return this ; }
public query builder get nest filter ( ) { return this . nested filter ; }
public completion suggestion builder regex ( string regex ) { super . regex ( regex ) ; return this ; }
public int get fuzzy prefix length ( ) { return fuzzy prefix length ; }
public direct candidate generator builder prefix length ( int prefix length ) { this . prefix length = prefix length ; return this ; }
public phrase suggestion builder gram size ( int gram size ) { if ( gram size < 1 ) { throw new illegal argument exception ( `` gram size must be > = 1 `` ) ; } this . gram size = gram size ; return this ; }
public phrase suggestion builder smooth model ( smooth model model ) { this . model = model ; return this ; }
public script collate query ( ) { return this . collate query ; }
public static term suggestion builder term suggestion ( string fieldname ) { return new term suggestion builder ( fieldname ) ; }
public int max edits ( ) { return max edits ; }
public void restore snapshot ( final restore snapshot request request , final action listener < restore completion response > listener ) { restore snapshot ( request , listener , ( cluster state , builder ) - > { } ) ; }
public static snapshot shard failure from x content ( x content parser parser ) throw i o exception { return snapshot_shard_failure_parser . parse ( parser , null ) ; }
public final string get reason cancel ( ) { return reason ; }
public string get description ( ) { return description ; }
public task id get parent task id ( ) { return parent task ; }
public status get status ( ) { return null ; }
public task . status get status ( ) { return status ; }
public client get remote cluster client ( thread pool thread pool , string cluster alias ) { if ( transport service . get remote cluster service ( ) . be enable ( ) == false ) { throw new illegal argument exception ( `` this node do not have the `` + discovery node role . remote_cluster_client_role . role name ( ) + `` role `` ) ; } if ( transport service . get remote cluster service ( ) . get remote cluster name ( ) . contains ( cluster alias ) == false ) { throw new no such remote cluster exception ( cluster alias ) ; } return new remote cluster aware client ( setting , thread pool , transport service , cluster alias ) ; }
public static < k , v > java . util . map < k , v > of ( k k1 , v v1 , k k2 , v v2 , k k3 , v v3 , k k4 , v v4 ) { return map n ( k1 , v1 , k2 , v2 , k3 , v3 , k4 , v4 ) ; }
public static set < url > parse class path ( ) { return parse class path ( system . get property ( `` java . class . path `` ) ) ; }
public int get buffer limit ( ) { return buffer limit byte ; }
public string get method ( ) { return method ; }
public double get entropy ( ) { return entropy ; }
public elasticsearch exception get failure ( ) { return error ; }
public void set request cache ( boolean request cache ) { this . search request . request cache ( request cache ) ; }
public acknowledge response unfollow ( unfollow request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , ccr request converter : : unfollow , option , acknowledge response : : from x content , collection . empty set ( ) ) ; }
public acknowledge response delete auto follow pattern ( delete auto follow pattern request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , ccr request converter : : delete auto follow pattern , option , acknowledge response : : from x content , collection . empty set ( ) ) ; }
public long get search total ( ) { return search total ; }
public void set payload ( boolean request payload ) { this . request payload = request payload ; }
public void set realtime ( boolean realtime ) { this . realtime = realtime ; }
public list < term vector > get term vector list ( ) { return term vector list ; }
public get policy response get policy ( get policy request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , enrich request converter : : get policy , option , get policy response : : from x content , collection . empty set ( ) ) ; }
public stats response stats ( stats request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , enrich request converter : : stats , option , stats response : : from x content , collection . empty set ( ) ) ; }
public void add exclude ( string term ) { if ( include ! = null ) { throw new illegal argument exception ( `` can not have both include and exclude clause `` ) ; } if ( excludes == null ) { excludes = new hash set < > ( ) ; } exclude . add ( term ) ; }
public void add include ( string term , float boost ) { if ( excludes ! = null ) { throw new illegal argument exception ( `` can not have both include and exclude clause `` ) ; } if ( include == null ) { include = new hash map < > ( ) ; } include . put ( term , new term boost ( term , boost ) ) ; }
public acknowledge response delete lifecycle policy ( delete lifecycle policy request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , index lifecycle request converter : : delete lifecycle policy , option , acknowledge response : : from x content , empty set ( ) ) ; }
public get snapshot lifecycle policy response get snapshot lifecycle policy ( get snapshot lifecycle policy request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , index lifecycle request converter : : get snapshot lifecycle policy , option , get snapshot lifecycle policy response : : from x content , empty set ( ) ) ; }
public lifecycle management status response get s l m status ( snapshot lifecycle management status request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , index lifecycle request converter : : snapshot lifecycle management status , option , lifecycle management status response : : from x content , empty set ( ) ) ; }
public string normalizer ( ) { return this . normalizer ; }
public name or definition tokenizer ( ) { return this . tokenizer ; }
public string [ ] index ( ) { return index ; }
public string [ ] get index ( ) { return index ; }
public get mapping request local ( boolean local ) { this . local = local ; return this ; }
public string get alias ( ) { return alias ; }
public get mapping response get mapping ( get mapping request get mapping request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( get mapping request , indices request converter : : get mapping , option , get mapping response : : from x content , empty set ( ) ) ; }
public cancellable update alias async ( index aliases request index aliases request , request option option , action listener < acknowledge response > listener ) { return rest high level client . perform request async and parse entity ( index aliases request , indices request converter : : update alias , option , acknowledge response : : from x content , listener , empty set ( ) ) ; }
public cancellable refresh async ( refresh request refresh request , request option option , action listener < refresh response > listener ) { return rest high level client . perform request async and parse entity ( refresh request , indices request converter : : refresh , option , refresh response : : from x content , listener , empty set ( ) ) ; }
public cancellable clear cache async ( clear index cache request clear index cache request , request option option , action listener < clear index cache response > listener ) { return rest high level client . perform request async and parse entity ( clear index cache request , indices request converter : : clear cache , option , clear index cache response : : from x content , listener , empty set ( ) ) ; }
public cancellable exists async ( get index request request , request option option , action listener < boolean > listener ) { return rest high level client . perform request async ( request , indices request converter : : index exist , option , rest high level client : : convert exist response , listener , collection . empty set ( ) ) ; }
public resize response split ( resize request resize request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( resize request , indices request converter : : split , option , resize response : : from x content , empty set ( ) ) ; }
public cancellable clone async ( resize request resize request , request option option , action listener < resize response > listener ) { return rest high level client . perform request async and parse entity ( resize request , indices request converter : : clone , option , resize response : : from x content , listener , empty set ( ) ) ; }
public shard acknowledge response freeze ( freeze index request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , indices request converter : : freeze index , option , shard acknowledge response : : from x content , empty set ( ) ) ; }
public cancellable freeze async ( freeze index request request , request option option , action listener < shard acknowledge response > listener ) { return rest high level client . perform request async and parse entity ( request , indices request converter : : freeze index , option , shard acknowledge response : : from x content , listener , empty set ( ) ) ; }
public acknowledge response put pipeline ( put pipeline request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , ingest request converter : : put pipeline , option , acknowledge response : : from x content , empty set ( ) ) ; }
public cancellable put pipeline async ( put pipeline request request , request option option , action listener < acknowledge response > listener ) { return rest high level client . perform request async and parse entity ( request , ingest request converter : : put pipeline , option , acknowledge response : : from x content , listener , empty set ( ) ) ; }
public cancellable get license async ( get license request request , request option option , action listener < get license response > listener ) { return rest high level client . perform request async ( request , license request converter : : get license , option , response - > new get license response ( convert response to json ( response ) ) , listener , empty set ( ) ) ; }
public acknowledge response delete license ( delete license request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , license request converter : : delete license , option , acknowledge response : : from x content , empty set ( ) ) ; }
public get job response get job ( get job request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : get job , option , get job response : : from x content , collection . empty set ( ) ) ; }
public delete expire data response delete expire data ( delete expire data request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : delete expire data , option , delete expire data response : : from x content , collection . empty set ( ) ) ; }
public cancellable open job async ( open job request request , request option option , action listener < open job response > listener ) { return rest high level client . perform request async and parse entity ( request , m l request converter : : open job , option , open job response : : from x content , listener , collection . empty set ( ) ) ; }
public cancellable close job async ( close job request request , request option option , action listener < close job response > listener ) { return rest high level client . perform request async and parse entity ( request , m l request converter : : close job , option , close job response : : from x content , listener , collection . empty set ( ) ) ; }
public put datafeed response put datafeed ( put datafeed request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : put datafeed , option , put datafeed response : : from x content , collection . empty set ( ) ) ; }
public cancellable put datafeed async ( put datafeed request request , request option option , action listener < put datafeed response > listener ) { return rest high level client . perform request async and parse entity ( request , m l request converter : : put datafeed , option , put datafeed response : : from x content , listener , collection . empty set ( ) ) ; }
public cancellable update model snapshot async ( update model snapshot request request , request option option , action listener < update model snapshot response > listener ) { return rest high level client . perform request async and parse entity ( request , m l request converter : : update model snapshot , option , update model snapshot response : : from x content , listener , collection . empty set ( ) ) ; }
public get calendar response get calendar ( get calendar request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : get calendar , option , get calendar response : : from x content , collection . empty set ( ) ) ; }
public put calendar response put calendar job ( put calendar job request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : put calendar job , option , put calendar response : : from x content , collection . empty set ( ) ) ; }
public get calendar event response get calendar event ( get calendar event request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : get calendar event , option , get calendar event response : : from x content , collection . empty set ( ) ) ; }
public cancellable set upgrade mode async ( set upgrade mode request request , request option option , action listener < acknowledge response > listener ) { return rest high level client . perform request async and parse entity ( request , m l request converter : : set upgrade mode , option , acknowledge response : : from x content , listener , collection . empty set ( ) ) ; }
public get data frame analytics stats response get data frame analytics stats ( get data frame analytics stats request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : get data frame analytics stats , option , get data frame analytics stats response : : from x content , collection . empty set ( ) ) ; }
public start data frame analytics response start data frame analytics ( start data frame analytics request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : start data frame analytics , option , start data frame analytics response : : from x content , collection . empty set ( ) ) ; }
public acknowledge response delete data frame analytics ( delete data frame analytics request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : delete data frame analytics , option , acknowledge response : : from x content , collection . empty set ( ) ) ; }
public explain data frame analytics response explain data frame analytics ( explain data frame analytics request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : explain data frame analytics , option , explain data frame analytics response : : from x content , collection . empty set ( ) ) ; }
public cancellable get deprecation info async ( deprecation info request request , request option option , action listener < deprecation info response > listener ) { return rest high level client . perform request async and parse entity ( request , migration request converter : : get deprecation info , option , deprecation info response : : from x content , listener , collection . empty set ( ) ) ; }
public void set allow no match ( boolean allow no match ) { this . allow no match = allow no match ; }
public boolean be close ( ) { return close ; }
public void set timeout ( time value timeout ) { this . timeout = timeout ; }
public float get request per second ( ) { return request per second ; }
public string get forecast id ( ) { return forecast id ; }
public void set descending ( boolean descending ) { this . descend = descending ; }
public static get datafeed request get all datafeeds request ( ) { return new get datafeed request ( all_datafeeds ) ; }
public void set allow no match ( boolean allow no match ) { this . allow no match = allow no match ; }
public list < overall bucket > overall bucket ( ) { return result ; }
public list < anomaly record > record ( ) { return result ; }
public long get cache miss count ( ) { return cache miss count ; }
public character get quote character ( ) { return quote character ; }
public analysis limit get analysis limit ( ) { return analysis limit ; }
public data description get data description ( ) { return data description ; }
public time value get background persist interval ( ) { return background persist interval ; }
public long get invalid date count ( ) { return invalid date count ; }
public date get timestamp ( ) { return timestamp ; }
public long get bucket span ( ) { return bucket span ; }
public data count get data count ( ) { return data count ; }
public forecast stats get forecast stats ( ) { return forecast stats ; }
public job state get state ( ) { return state ; }
public void set timeout ( time value timeout ) { this . timeout = timeout ; }
public int get fail ( ) { return fail ; }
public transform client transform ( ) { return transform client ; }
public final task submission response submit reindex task ( reindex request reindex request , request option option ) throw i o exception { return perform request and parse entity ( reindex request , request converter : : submit reindex , option , task submission response : : from x content , empty set ( ) ) ; }
public final cancellable reindex async ( reindex request reindex request , request option option , action listener < bulk by scroll response > listener ) { return perform request async and parse entity ( reindex request , request converter : : reindex , option , bulk by scroll response : : from x content , listener , singleton ( 409 ) ) ; }
public final bulk by scroll response delete by query ( delete by query request delete by query request , request option option ) throw i o exception { return perform request and parse entity ( delete by query request , request converter : : delete by query , option , bulk by scroll response : : from x content , singleton ( 409 ) ) ; }
public final cancellable mget async ( multi get request multi get request , request option option , action listener < multi get response > listener ) { return perform request async and parse entity ( multi get request , request converter : : multi get , option , multi get response : : from x content , listener , singleton ( 404 ) ) ; }
public final cancellable exists async ( get request get request , request option option , action listener < boolean > listener ) { return perform request async ( get request , request converter : : exists , option , rest high level client : : convert exist response , listener , empty set ( ) ) ; }
public final search template response search template ( search template request search template request , request option option ) throw i o exception { return perform request and parse entity ( search template request , request converter : : search template , option , search template response : : from x content , empty set ( ) ) ; }
public final cancellable search template async ( search template request search template request , request option option , action listener < search template response > listener ) { return perform request async and parse entity ( search template request , request converter : : search template , option , search template response : : from x content , listener , empty set ( ) ) ; }
public final cancellable termvectors async ( term vector request request , request option option , action listener < term vector response > listener ) { return perform request async and parse entity ( request , request converter : : term vector , option , term vector response : : from x content , listener , empty set ( ) ) ; }
public cancellable stop rollup job async ( stop rollup job request request , request option option , action listener < stop rollup job response > listener ) { return rest high level client . perform request async and parse entity ( request , rollup request converter : : stop job , option , stop rollup job response : : from x content , listener , collection . empty set ( ) ) ; }
public restore snapshot response mount snapshot ( final mount snapshot request request , final request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , searchable snapshot request converter : : mount snapshot , option , restore snapshot response : : from x content , collection . empty set ( ) ) ; }
public static invalidate api key request use api key id ( string api key id , boolean own by authenticated user ) { return new invalidate api key request ( null , null , null , own by authenticated user , api key id to id ( api key id ) ) ; }
public static refresh policy get default ( ) { return refresh policy . none ; }
public cancellable enable user async ( enable user request request , request option option , action listener < boolean > listener ) { return rest high level client . perform request async ( request , security request converter : : enable user , option , rest high level client : : convert exist response , listener , empty set ( ) ) ; }
public cancellable get role async ( get role request request , request option option , action listener < get role response > listener ) { return rest high level client . perform request async and parse entity ( request , security request converter : : get role , option , get role response : : from x content , listener , empty set ( ) ) ; }
public get privilege response get privilege ( final get privilege request request , final request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , security request converter : : get privilege , option , get privilege response : : from x content , empty set ( ) ) ; }
public create api key response grant api key ( final grant api key request request , final request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , security request converter : : grant api key , option , create api key response : : from x content , empty set ( ) ) ; }
public get repository response get repository ( get repository request get repository request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( get repository request , snapshot request converter : : get repository , option , get repository response : : from x content , empty set ( ) ) ; }
public cleanup repository response cleanup repository ( cleanup repository request cleanup repository request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( cleanup repository request , snapshot request converter : : cleanup repository , option , cleanup repository response : : from x content , empty set ( ) ) ; }
public acknowledge response clone ( clone snapshot request clone snapshot request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( clone snapshot request , snapshot request converter : : clone snapshot , option , acknowledge response : : from x content , empty set ( ) ) ; }
public void set timeout ( time value timeout ) { this . timeout = timeout ; }
public preview transform response preview transform ( preview transform request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , transform request converter : : preview transform , option , preview transform response : : from x content , collection . empty set ( ) ) ; }
public list < node > get node ( ) { return node ; }
public cancellable stop watch service async ( stop watch service request request , request option option , action listener < acknowledge response > listener ) { return rest high level client . perform request async and parse entity ( request , watcher request converter : : stop watch service , option , acknowledge response : : from x content , listener , empty set ( ) ) ; }
public cancellable activate watch async ( activate watch request request , request option option , action listener < activate watch response > listener ) { return rest high level client . perform request async and parse entity ( request , watcher request converter : : activate watch , option , activate watch response : : from x content , listener , singleton ( 404 ) ) ; }
public state get state ( ) { return state . get ( ) . get state ( ) ; }
public ratio get success threshold ( ) { return success threshold ; }
public t get ( ) throw interrupted exception , execution exception { circuit . await ( ) ; if ( failure ! = null ) { if ( failure instanceof cancellation exception ) throw ( cancellation exception ) failure ; throw new execution exception ( failure ) ; } return result ; }
public retry policy with max duration ( long max duration , time unit time unit ) { assert . not null ( time unit , `` time unit `` ) ; assert . state ( time unit . to nanos ( max duration ) > delay . to nanos ( ) , `` max duration must be great than the delay `` ) ; this . max duration = new duration ( max duration , time unit ) ; return this ; }
public static locale parse locale ( string locale string ) { locale locale = null ; if ( locale string == null ) { locale = locale . get default ( ) ; } else { try { string [ ] args = locale string . split ( `` _ `` ) ; if ( args . length == 1 ) { locale = new locale ( args [ 0 ] ) ; } else if ( args . length == 2 ) { locale = new locale ( args [ 0 ] , args [ 1 ] ) ; } else if ( args . length == 3 ) { locale = new locale ( args [ 0 ] , args [ 1 ] , args [ 2 ] ) ; } } catch ( throwable t ) { locale = locale . get default ( ) ; } } return locale ; }
public string get public id ( ) { return _public id ; }
public string get data ( ) { return _text ; }
public list get notation ( ) { return _notations ; }
public iterator get namespaces ( ) { if ( _namespaces ! = null ) return _namespaces . iterator ( ) ; return empty iterator . get instance ( ) ; }
public start element a start element ( ) { if ( be start element ( ) ) { return ( start element ) this ; } else throw new class cast exception ( common resource bundle . get instance ( ) . get string ( `` message . start element case `` , new object [ ] { get event type string ( ) } ) ) ; }
public string get version ( ) { return _version ; }
public object get property ( java . lang . string name ) throw java . lang . illegal argument exception { return _stream reader . get property ( name ) ; }
public void set property ( string name , object value ) throw illegal argument exception { _manager . set property ( name , value ) ; }
protect void ensure restrict index ( final long index ) { if ( index < 0 ) throw new index out of bound exception ( `` index ( `` + index + `` ) be negative `` ) ; if ( index > = size64 ( ) ) throw new index out of bound exception ( `` index ( `` + index + `` ) be great than or equal to list size ( `` + ( size64 ( ) ) + `` ) `` ) ; }
public boolean add all ( boolean collection c ) { boolean ret val = false ; final boolean iterator i = c . iterator ( ) ; int n = c . size ( ) ; while ( n -- ! = 0 ) if ( add ( i . next boolean ( ) ) ) ret val = true ; return ret val ; }
public boolean add all ( collection < ? extends boolean > c ) { boolean ret val = false ; final iterator < ? extend boolean > i = c . iterator ( ) ; int n = c . size ( ) ; while ( n -- ! = 0 ) if ( add ( i . next ( ) ) ) ret val = true ; return ret val ; }
protect void ensure restrict index ( final int index ) { if ( index < 0 ) throw new index out of bound exception ( `` index ( `` + index + `` ) be negative `` ) ; if ( index > = size ( ) ) throw new index out of bound exception ( `` index ( `` + index + `` ) be great than or equal to list size ( `` + ( size ( ) ) + `` ) `` ) ; }
public boolean [ ] element ( ) { return a ; }
public void remove element ( final int from , final int to ) { it . unimi . dsi . fastutil . array . ensure from to ( size , from , to ) ; system . arraycopy ( a , to , a , from , size - to ) ; size -= ( to - from ) ; }
public static boolean [ ] ensure capacity ( final boolean [ ] array , final int length ) { if ( length > array . length ) { final boolean t [ ] = new boolean [ length ] ; system . arraycopy ( array , 0 , t , 0 , array . length ) ; return t ; } return array ; }
public static boolean [ ] set length ( final boolean [ ] array , final int length ) { if ( length == array . length ) return array ; if ( length < array . length ) return trim ( array , length ) ; return ensure capacity ( array , length ) ; }
public static boolean [ ] copy ( final boolean [ ] array ) { return array . clone ( ) ; }
public static void parallel quick sort ( final boolean [ ] x , final boolean [ ] y , final int from , final int to ) { if ( to - from < parallel_quicksort_no_fork ) quick sort ( x , y , from , to ) ; final fork join pool pool = new fork join pool ( runtime . get runtime ( ) . available processor ( ) ) ; pool . invoke ( new fork join quick sort2 ( x , y , from , to ) ) ; pool . shutdown ( ) ; }
public static void merge sort ( final boolean a [ ] , boolean comparator comp ) { merge sort ( a , 0 , a . length , comp ) ; }
public static boolean get ( final boolean [ ] [ ] array , final long index ) { return array [ segment ( index ) ] [ displacement ( index ) ] ; }
public static long length ( final boolean [ ] [ ] array ) { final int length = array . length ; return length == 0 ? 0 : start ( length - 1 ) + array [ length - 1 ] . length ; }
public static boolean [ ] [ ] trim ( final boolean [ ] [ ] array , final long length ) { ensure length ( length ) ; final long old length = length ( array ) ; if ( length > = old length ) return array ; final int base length = ( int ) ( ( length + segment_mask ) > > > segment_shift ) ; final boolean [ ] [ ] base = array . copy of ( array , base length ) ; final int residual = ( int ) ( length & segment_mask ) ; if ( residual ! = 0 ) base [ base length - 1 ] = boolean array . trim ( base [ base length - 1 ] , residual ) ; return base ; }
public static boolean collection synchronize ( final boolean collection c ) { return new synchronize collection ( c ) ; }
public static boolean collection synchronize ( final boolean collection c , final object sync ) { return new synchronize collection ( c , sync ) ; }
public static boolean list iterator a boolean iterator ( final list iterator i ) { if ( i instanceof boolean list iterator ) return ( boolean list iterator ) i ; return new list iterator wrapper ( i ) ; }
public static boolean iterator concat ( final boolean iterator a [ ] ) { return concat ( a , 0 , a . length ) ; }
public boolean collection value ( ) { return new abstract boolean collection ( ) { public boolean contains ( final boolean k ) { return contain value ( k ) ; } public int size ( ) { return abstract byte2 boolean map . this . size ( ) ; } public void clear ( ) { abstract byte2 boolean map . this . clear ( ) ; } public boolean iterator iterator ( ) { return new abstract boolean iterator ( ) { final object iterator < map . entry < byte , boolean > > i = entry set ( ) . iterator ( ) ; / * * * { @ inherit doc } * * @ deprecate please use the corresponding type-specific * method instead . * / @ deprecate public boolean next boolean ( ) { return ( ( byte2 boolean map . entry ) i . next ( ) ) . get boolean value ( ) ; } ; public boolean have next ( ) { return i . have next ( ) ; } } ; } } ; }
public byte sort set key set ( ) { return new key set ( ) ; }
public static byte2 boolean sort map synchronize ( final byte2 boolean sort map m , final object sync ) { return new synchronize sort map ( m , sync ) ; }
public int get ( final int index , final byte [ ] a ) { return get ( index , a , 0 , a . length ) ; }
public static void mul ( final byte [ ] [ ] array , final long index , byte factor ) { array [ segment ( index ) ] [ displacement ( index ) ] * = factor ; }
public static long binary search ( final byte [ ] [ ] a , final byte key ) { return binary search ( a , 0 , byte big array . length ( a ) , key ) ; }
public byte list iterator iterator ( byte from ) { return new set iterator ( from ) ; }
public static void make heap ( final byte [ ] ref array , final int offset , final int length , final int [ ] heap , final byte comparator c ) { byte array . ensure offset length ( ref array , offset , length ) ; if ( heap . length < length ) throw new illegal argument exception ( `` the heap length ( `` + heap . length + `` ) be small than the number of element ( `` + length + `` ) `` ) ; int i = length ; while ( i -- ! = 0 ) heap [ i ] = offset + i ; i = length > > > 1 ; while ( i -- ! = 0 ) down heap ( ref array , heap , length , i , c ) ; }
public static byte sort set unmodifiable ( final byte sort set s ) { return new unmodifiable sort set ( s ) ; }
public static int max fill ( final int n , final float f ) { / * we must guarantee that there be always at least * one free entry ( even with pathological load factor ) . * / return math . min ( ( int ) math . ceil ( n * f ) , n - 1 ) ; }
public static boolean [ ] load booleans ( final char sequence filename ) throw i o exception { return load booleans ( new file ( filename . to string ( ) ) ) ; }
public static long load booleans ( final data input data input , final boolean [ ] [ ] array ) throw i o exception { long c = 0 ; try { for ( int i = 0 ; i < array . length ; i++ ) { final boolean [ ] t = array [ i ] ; final int l = t . length ; for ( int d = 0 ; d < l ; d++ ) { t [ d ] = data input . read boolean ( ) ; c++ ; } } } catch ( e o f exception it ok ) { } return c ; }
public static void store booleans ( final boolean array [ ] [ ] , final char sequence filename ) throw i o exception { store booleans ( array , new file ( filename . to string ( ) ) ) ; }
public static int load byte ( final input stream input stream , final byte [ ] array ) throw i o exception { return read ( input stream , array , 0 , array . length ) ; }
public static long load byte ( final input stream input stream , final byte [ ] [ ] array ) throw i o exception { return read ( input stream , array , 0 , byte big array . length ( array ) ) ; }
public void position ( final long new position ) throw i o exception { flush ( ) ; if ( repositionable stream ! = null ) repositionable stream . position ( new position ) ; else if ( file channel ! = null ) file channel . position ( new position ) ; else throw new unsupported operation exception ( `` position ( ) can only be call if the underlie byte stream implement the repositionable stream interface or if the get channel ( ) method of the underlie byte stream exists and return a file channel `` ) ; }
public static void store booleans ( final boolean array [ ] , final int offset , final int length , final print stream stream ) { it . unimi . dsi . fastutil . booleans . boolean array . ensure offset length ( array , offset , length ) ; for ( int i = 0 ; i < length ; i++ ) stream . println ( array [ offset + i ] ) ; }
public static long bidirectional iterator from to ( final long from , final long to ) { return new interval iterator ( from , to ) ; }
public int read off size ( ) throw i o exception { int off size = read unsigned byte ( ) ; if ( off size < 1 || off size > 4 ) { throw new i o exception ( `` illegal ( < 1 or > 4 ) off size value `` + off size + `` in cff font at position `` + ( get position ( ) - 1 ) ) ; } return off size ; }
public list < class < ? > > resolve generic of ( final type type ) throw no generic exception { try { return generic utils . resolve generic of ( type , context generic ( ) ) ; } catch ( unknown generic exception e ) { throw e . rethrow with type ( current type ) ; } }
public list < class < ? > > resolve parameter ( ) { return generic utils . get method parameter ( method , context generic ( ) ) ; }
protect void send ( byte [ ] buf , int len ) throw exception { datagram packet packet = new datagram packet ( buf , len , udp addr , port ) ; log . log ( level . fine , `` sending message of length `` + len ) ; socket . send ( packet ) ; }
public void announce ( string name , int value , string group ) throw ganglia exception { this . announce ( name , integer . to string ( value ) , g metric type . int32 , `` `` , g metric slope . both , 60 , 0 , group ) ; }
public link bind builder < module transformer > bind module transformer ( ) { return multibinder . new set binder ( binder , module transformer . class ) . add bind ( ) ; }
public governator add override module ( module . . . module ) { if ( module ! = null ) { this . override module . add all ( array . a list ( module ) ) ; } return this ; }
public static grakn tx operation exception no type ( thing thing ) { return create ( no_type . get message ( thing . id ( ) ) ) ; }
public static temporary write exception index overlap ( vertex vertex , exception e ) { return new temporary write exception ( string . format ( `` index overlap have lead to the accidental sharing of a partially complete vertex { % s } `` , vertex ) , e ) ; }
public final t parse ( string value , path config file path ) { if ( value == null ) { throw new runtime exception ( error message . unavailable_property . get message ( name ( ) , config file path ) ) ; } return parser ( ) . read ( value ) ; }
public string key ( ) { return key ; }
public static aggregate < value > sum ( string var ) { return aggregate . sum ( graql . var ( var ) ) ; }
public static concept id get resource edge id ( grakn tx graph , concept id concept id1 , concept id concept id2 ) { if ( may have resource edge ( graph , concept id1 , concept id2 ) ) { optional < concept > first concept = graph . graql ( ) . match ( var ( `` x `` ) . id ( concept id1 ) , var ( `` y `` ) . id ( concept id2 ) , var ( `` z `` ) . rel ( var ( `` x `` ) ) . rel ( var ( `` y `` ) ) ) . get ( `` z `` ) . stream ( ) . map ( answer - > answer . get ( `` z `` ) ) . find first ( ) ; if ( first concept . be present ( ) ) { return first concept . get ( ) . id ( ) ; } } return null ; }
public double fragment cost ( ) { if ( accurate fragment cost ! = null ) return accurate fragment cost ; return internal fragment cost ( ) ; }
public void clear ( ) { o min entry = null ; size = 0 ; }
protect builder build ( object object ) { if ( object instanceof concept ) { return concept ( ( concept ) object ) ; } else if ( object instanceof boolean ) { return bool ( ( boolean ) object ) ; } else if ( object instanceof collection ) { return collection ( ( collection < ? > ) object ) ; } else if ( object instanceof answer group < ? > ) { return answer group ( ( answer group < ? > ) object ) ; } else if ( object instanceof concept list ) { return concept list ( ( concept list ) object ) ; } else if ( object instanceof concept map ) { return concept map ( ( concept map ) object ) ; } else if ( object instanceof concept set ) { if ( object instanceof concept set measure ) { return concept set measure ( ( concept set measure ) object ) ; } else { return concept set ( ( concept set ) object ) ; } } else if ( object instanceof value ) { return value ( ( value ) object ) ; } else if ( object instanceof map ) { return map ( ( map < ? , ? > ) object ) ; } else { return object ( object ) ; } }
public static immutable list < atom > plan ( reasoner query impl query ) { list < atom > start candidate = query . get atom ( atom . class ) . filter ( atomic : : be selectable ) . collect ( collector . to list ( ) ) ; set < id predicate > sub = query . get atom ( id predicate . class ) . collect ( collector . to set ( ) ) ; return immutable list . copy of ( refine plan ( query , start candidate , sub ) ) ; }
public concept map get substitution ( ) { if ( substitution == null ) { set < var > var name = get var name ( ) ; set < id predicate > predicate = get atom ( isa atom base . class ) . map ( isa atom base : : get type predicate ) . filter ( object : : non null ) . filter ( p - > var name . contains ( p . get var name ( ) ) ) . collect ( collector . to set ( ) ) ; get atom ( id predicate . class ) . for each ( predicate : : add ) ; hash map < var , concept > answer map = new hash map < > ( ) ; predicate . for each ( p - > { concept concept = tx ( ) . get concept ( p . get predicate ( ) ) ; if ( concept == null ) throw graql query exception . id not find ( p . get predicate ( ) ) ; answer map . put ( p . get var name ( ) , concept ) ; } ) ; substitution = new concept map impl ( answer map ) ; } return substitution ; }
public void if present ( consumer < v > modifier ) { if ( be present ( ) ) { modifier . accept ( get ( ) ) ; } }
public void cache label ( label label , label id id ) { cached label . put ( label , id ) ; }
public void delete ( ) { element ( ) . remove ( ) ; }
public static matcher < matchable concept > be shard ( ) { return new type safe matcher < matchable concept > ( ) { @ override public boolean match safely ( matchable concept concept ) { return concept . get ( ) instanceof shard ; } @ override public void describe to ( description description ) { description . append text ( `` be shard ( ) `` ) ; } } ; }
protect void build schema ( grakn tx tx ) { } ;
public default boolean exists ( final string key ) { return this . key ( ) . contains ( key ) ; }
public default void worker iteration end ( final memory memory ) { }
public default graph traversal < s , e > range ( final long low , final long high ) { this . a admin ( ) . get bytecode ( ) . add step ( symbol . range , low , high ) ; return this . a admin ( ) . add step ( new range global step < > ( this . a admin ( ) , low , high ) ) ; }
public default graph traversal < s , e > tail ( ) { this . a admin ( ) . get bytecode ( ) . add step ( symbol . tail ) ; return this . a admin ( ) . add step ( new tail global step < > ( this . a admin ( ) , 1 ) ) ; }
public static < v > p < v > gte ( final v value ) { return new p ( compare . gte , value ) ; }
public static < v > p < v > within ( final v . . . value ) { return p . within ( array . a list ( value ) ) ; }
public default boolean be empty ( ) { return key ( ) . size ( ) == 0 ; }
public default configuration get configuration ( ) { return new base configuration ( ) ; }
public default < a > a side effect ( final string side effect key ) throw illegal argument exception { return this . a admin ( ) . get side effect ( ) . < a > get ( side effect key ) ; }
public default void side effect ( final string side effect key , final object side effect value ) throw illegal argument exception { this . a admin ( ) . get side effect ( ) . add ( side effect key , side effect value ) ; }
public static void migrate graph ( final graph from graph , final graph to graph ) throw i o exception { migrate graph ( from graph , to graph , from graph . io ( gryo ( ) ) . reader ( ) . create ( ) , to graph . io ( gryo ( ) ) . writer ( ) . create ( ) ) ; }
public void write ( final kryo kryo , final output output , final t t ) { / * these adapter could be cache pretty efficiently in instance field if it be guarantee that this * class be never subject to concurrent use . that 's true of kryo instance , but it be not clear that * it be true of serializer instance . * / final shade kryo adapter shade kryo adapter = new shade kryo adapter ( kryo ) ; final shade output adapter shade output adapter = new shade output adapter ( output ) ; serializer . write ( shaded kryo adapter , shade output adapter , t ) ; }
public static void validate mixed element id ( final class < ? extend element > clazz , final object . . . id ) throw illegal argument exception { if ( id . length > 1 ) { final boolean element = clazz . be assignable from ( id [ 0 ] . get class ( ) ) ; for ( int i = 1 ; i < id . length ; i++ ) { if ( clazz . be assignable from ( ids [ i ] . get class ( ) ) ! = element ) throw graph . exception . id args must be either id or element ( ) ; } } }
public static void legal property key value array ( final object . . . property key value ) throw illegal argument exception { if ( property key value . length % 2 ! = 0 ) throw element . exception . provide key value must be a multiple of two ( ) ; for ( int i = 0 ; i < property key value . length ; i = i + 2 ) { if ( ! ( property key value [ i ] instanceof string ) & & ! ( property key value [ i ] instanceof t ) ) throw element . exception . provide key value must have a legal key on even index ( ) ; if ( null == property key value [ i + 1 ] ) { throw property . exception . property value can not be null ( ) ; } } }
public static optional < object [ ] > remove ( final t accessor , final object . . . key value ) { return element helper . remove ( ( object ) accessor , key value ) ; }
public void set message ( string message ) { this . message = message ; }
public int get from int ( ) { return from ; }
public boolean next ( ) throw s q l exception { if ( update ) { get result set ( ) . update row ( ) ; update = false ; } return get result set ( ) . next ( ) ; }
public boolean be colfill ( ) { return colfill ; }
public string get name ( ) { if ( use agile dox name ) { return super . get name ( ) . substring ( 4 ) . replace all ( `` ( [ a-z ] ) `` , `` $ 1 `` ) . to lower case ( ) ; } else { return super . get name ( ) ; } }
public void set namespace aware ( boolean namespace aware ) { this . namespace aware = namespace aware ; }
public void set use groovy shell ( boolean use groovy shell ) { this . use groovy shell = use groovy shell ; }
public void set fork ( boolean f ) { fork = f ; }
public void set stacktrace ( boolean stacktrace ) { this . stacktrace = stacktrace ; }
public void set header ( string header ) { this . header = header ; }
public void remove node meta data ( object key ) { if ( key==null ) throw new groovy bug error ( `` try to remove meta data with null key `` +this+ `` . `` ) ; meta data map . remove ( key ) ; if ( meta data map . size ( ) ==0 ) meta data map=null ; }
public string get type descriptor ( ) { if ( type descriptor == null ) { string buffer buf = new string buffer ( name . length ( ) + parameter . length * 10 ) ; buf . append ( return type . get name ( ) ) ; buf . append ( ' ' ) ; buf . append ( name ) ; buf . append ( ' ( ' ) ; for ( int i = 0 ; i < parameter . length ; i++ ) { if ( i > 0 ) { buf . append ( `` , `` ) ; } parameter param = parameter [ i ] ; buf . append ( param . get type ( ) . get name ( ) ) ; } buf . append ( ' ) ' ) ; type descriptor = buf . to string ( ) ; } return type descriptor ; }
public object call ( object object , string method , object [ ] args ) throw b s f exception { return invoker helper . invoke method ( object , method , args ) ; }
public syntax exception get syntax error ( int index ) { syntax exception exception = null ; message message = get error ( index ) ; if ( message ! = null & & message instanceof syntax error message ) { exception = ( ( syntax error message ) message ) . get cause ( ) ; } return exception ; }
public void next phase ( ) throw compilation fail exception { goto phase ( this . phase + 1 ) ; }
public static string format ( date self , string format ) { return new simple date format ( format ) . format ( self ) ; }
public static date parse ( date self , string format , string input ) throw parse exception { return new simple date format ( format ) . parse ( input ) ; }
public static groovy row result to row result ( result set r ) throw s q l exception { result set meta data metadata = r . get meta data ( ) ; map < string , object > lhm = new link hash map < string , object > ( metadata . get column count ( ) , 1 ) ; for ( int i = 1 ; i < = metadata . get column count ( ) ; i++ ) { lhm . put ( metadata . get column label ( i ) , r . get object ( i ) ) ; } return new groovy row result ( lhm ) ; }
public static mutable combo box model leave shift ( mutable combo box model self , object i ) { self . add element ( i ) ; return self ; }
public static int size ( table column model self ) { return self . get column count ( ) ; }
public static mutable tree node leave shift ( mutable tree node self , mutable tree node node ) { self . insert ( node , self . get child count ( ) ) ; return self ; }
public static j tool bar leave shift ( j tool bar self , action action ) { self . add ( action ) ; return self ; }
public string get href ( ) { return href ; }
public static object eval ( script engine self , reader reader , bind bind ) throw script exception { store binding var ( self , bind ) ; object result = self . eval ( reader ) ; retrieve binding var ( self , bind ) ; return result ; }
public list depth first ( ) { list answer = new node list ( ) ; answer . add ( this ) ; answer . add all ( depth first rest ( ) ) ; return answer ; }
public static void add return if need ( method node node ) { return adder adder = new return adder ( ) ; adder . visit method ( node ) ; }
public static < t > t identity ( object self , closure < t > closure ) { return default groovy method . with ( self , closure ) ; }
public static void mixin ( class self , list < class > category class ) { mixin ( get meta class ( self ) , category class ) ; }
public static void print ( print writer self , object value ) { self . print ( invoker helper . to string ( value ) ) ; }
public static void printf ( object self , string format , object [ ] value ) { if ( self instanceof print stream ) ( ( print stream ) self ) . printf ( format , value ) ; else system . out . printf ( format , value ) ; }
public static < t > iterator < t > unique ( iterator < t > self ) { return to list ( ( iterable < t > ) unique ( to list ( self ) ) ) . list iterator ( ) ; }
public static < t > collection < t > each ( collection < t > self , @ closure params ( first param . first generic type . class ) closure closure ) { return ( collection < t > ) each ( ( iterable < t > ) self , closure ) ; }
public static < t > set < t > each ( set < t > self , @ closure params ( first param . first generic type . class ) closure closure ) { return ( set < t > ) each ( ( iterable < t > ) self , closure ) ; }
public static < t > list < t > to list ( enumeration < t > self ) { list < t > answer = new array list < t > ( ) ; while ( self . have more element ( ) ) { answer . add ( self . next element ( ) ) ; } return answer ; }
public static < s , t > list < t > collect ( collection < s > self , @ closure params ( first param . first generic type . class ) closure < t > transform ) { return ( list < t > ) collect ( self , new array list < t > ( self . size ( ) ) , transform ) ; }
public static list collect nest ( iterable self , closure transform ) { return ( list ) collect nest ( self , new array list ( ) , transform ) ; }
public static object find result ( object self , closure closure ) { for ( iterator iter = invoker helper . a iterator ( self ) ; iter . have next ( ) ; ) { object value = iter . next ( ) ; object result = closure . call ( value ) ; if ( result ! = null ) { return result ; } } return null ; }
public static boolean contain all ( iterable self , object [ ] item ) { return a collection ( self ) . contain all ( array . a list ( item ) ) ; }
public static list transpose ( list self ) { return groovy collection . transpose ( self ) ; }
public static object sum ( iterator < object > self , object initial value ) { return sum ( to list ( self ) , initial value , false ) ; }
public static < t > t min ( iterable < t > self ) { return groovy collection . min ( self ) ; }
public static < t > t min ( t [ ] self , comparator < t > comparator ) { return min ( ( iterable < t > ) to list ( self ) , comparator ) ; }
public static < t > void put at ( list < t > self , int idx , t value ) { int size = self . size ( ) ; idx = normalise index ( idx , size ) ; if ( idx < size ) { self . set ( idx , value ) ; } else { while ( size < idx ) { self . add ( size++ , null ) ; } self . add ( idx , value ) ; } }
public static < t > set < t > a immutable ( set < ? extend t > self ) { return collection . unmodifiable set ( self ) ; }
public static < t > sort set < t > a immutable ( sort set < t > self ) { return collection . unmodifiable sort set ( self ) ; }
public static < t > list < t > a synchronize ( list < t > self ) { return collection . synchronize list ( self ) ; }
public static < t > list < t > sort ( iterable < t > self , boolean mutate ) { list < t > answer = mutate ? a list ( self ) : to list ( self ) ; collection . sort ( answer , new number aware comparator < t > ( ) ) ; return answer ; }
public static < t > t [ ] sort ( t [ ] self ) { array . sort ( self , new number aware comparator < t > ( ) ) ; return self ; }
public static < t > set < t > to sort ( sort set < t > self ) { return new link hash set < t > ( self ) ; }
public static < t > t pop ( list < t > self ) { if ( self . be empty ( ) ) { throw new no such element exception ( `` can not pop ( ) an empty list `` ) ; } return self . remove ( self . size ( ) - 1 ) ; }
public static < t > t first ( t [ ] self ) { if ( self . length == 0 ) { throw new no such element exception ( `` can not access first ( ) element from an empty array `` ) ; } return self [ 0 ] ; }
public static < t > t head ( t [ ] self ) { return first ( self ) ; }
public static < t > collection < t > init ( iterable < t > self ) { if ( ! self . iterator ( ) . have next ( ) ) { throw new no such element exception ( `` can not access init ( ) for an empty iterable `` ) ; } collection < t > result ; if ( self instanceof collection ) { collection < t > self col = ( collection < t > ) self ; result = create similar collection ( self col , self col . size ( ) - 1 ) ; } else { result = new array list < t > ( ) ; } add all ( result , init ( self . iterator ( ) ) ) ; return result ; }
public static < t > list < t > init ( list < t > self ) { return ( list < t > ) init ( ( iterable < t > ) self ) ; }
public static < t > sort set < t > take ( sort set < t > self , int num ) { return ( sort set < t > ) take ( ( iterable < t > ) self , num ) ; }
public static < t > t [ ] take right ( t [ ] self , int num ) { if ( self . length == 0 || num < = 0 ) { return create similar array ( self , 0 ) ; } if ( self . length < = num ) { t [ ] ret = create similar array ( self , self . length ) ; system . arraycopy ( self , 0 , ret , 0 , self . length ) ; return ret ; } t [ ] ret = create similar array ( self , num ) ; system . arraycopy ( self , self . length - num , ret , 0 , num ) ; return ret ; }
public static < t > sort set < t > take right ( sort set < t > self , int num ) { return ( sort set < t > ) take right ( ( iterable < t > ) self , num ) ; }
public static < t > list < t > drop right ( list < t > self , int num ) { return ( list < t > ) drop right ( ( iterable < t > ) self , num ) ; }
public static < t > collection < t > drop right ( iterable < t > self , int num ) { collection < t > self col = self instanceof collection ? ( collection < t > ) self : to list ( self ) ; if ( self col . size ( ) < = num ) { return create similar collection ( self col , 0 ) ; } if ( num < = 0 ) { collection < t > ret = create similar collection ( self col , self col . size ( ) ) ; ret . add all ( self col ) ; return ret ; } collection < t > ret = create similar collection ( self col , self col . size ( ) - num ) ; ret . add all ( a list ( ( iterable < t > ) self col ) . sub list ( 0 , self col . size ( ) - num ) ) ; return ret ; }
public static < t > sort set < t > take while ( sorted set < t > self , @ closure params ( first param . first generic type . class ) closure condition ) { return ( sort set < t > ) take while ( ( iterable < t > ) self , condition ) ; }
public static < t > t [ ] take while ( t [ ] self , @ closure params ( first param . component . class ) closure condition ) { int num = 0 ; boolean closure wrapper bcw = new boolean closure wrapper ( condition ) ; while ( num < self . length ) { t value = self [ num ] ; if ( bcw . call ( value ) ) { num += 1 ; } else { break ; } } return take ( self , num ) ; }
public static < t > t [ ] drop while ( t [ ] self , @ closure params ( first param . component . class ) closure < ? > condition ) { int num = 0 ; boolean closure wrapper bcw = new boolean closure wrapper ( condition ) ; while ( num < self . length ) { if ( bcw . call ( self [ num ] ) ) { num += 1 ; } else { break ; } } return drop ( self , num ) ; }
public static < t > list < t > a list ( iterable < t > self ) { if ( self instanceof list ) { return ( list < t > ) self ; } else { return to list ( self ) ; } }
public static < t > list < t > reverse ( list < t > self , boolean mutate ) { if ( mutate ) { collection . reverse ( self ) ; return self ; } int size = self . size ( ) ; list < t > answer = new array list < t > ( size ) ; list iterator < t > iter = self . list iterator ( size ) ; while ( iter . have previous ( ) ) { answer . add ( iter . previous ( ) ) ; } return answer ; }
public static boolean disjoint ( iterable left , iterable right ) { collection leave col = a collection ( leave ) ; collection right col = a collection ( right ) ; if ( left col . be empty ( ) || right col . be empty ( ) ) return true ; collection pick from = new tree set ( new number aware comparator ( ) ) ; pick from . add all ( right col ) ; for ( final object o : left col ) { if ( pick from . contains ( o ) ) return false ; } return true ; }
public static boolean equal ( list leave , object [ ] right ) { return coerce equal ( right , leave ) ; }
public static < t > list < t > leave shift ( list < t > self , t value ) { return ( list < t > ) leave shift ( ( collection < t > ) self , value ) ; }
public static list < short > get at ( short [ ] array , object range range ) { return primitive array get ( array , range ) ; }
public static list < float > get at ( float [ ] array , object range range ) { return primitive array get ( array , range ) ; }
public static list < short > get at ( short [ ] array , collection index ) { return primitive array get ( array , index ) ; }
public static list < boolean > get at ( boolean [ ] array , collection index ) { return primitive array get ( array , index ) ; }
public static bit set get at ( bit set self , int range range ) { range info info = sub list border ( self . length ( ) , range ) ; bit set result = new bit set ( ) ; int number of bit = info . to - info . from ; int adjuster = 1 ; int offset = info . from ; if ( info . reverse ) { adjuster = -1 ; offset = info . to - 1 ; } for ( int i = 0 ; i < number of bit ; i++ ) { result . set ( i , self . get ( offset + ( adjuster * i ) ) ) ; } return result ; }
public static void put at ( bit set self , int range range , boolean value ) { range info info = sub list border ( self . length ( ) , range ) ; self . set ( info . from , info . to , value ) ; }
public static < t > set < t > to set ( enumeration < t > self ) { set < t > answer = new hash set < t > ( ) ; while ( self . have more element ( ) ) { answer . add ( self . next element ( ) ) ; } return answer ; }
protect static list primitive array get ( object self , range range ) { list answer = new array list ( ) ; for ( object next : range ) { int idx = default type transformation . int unbox ( next ) ; answer . add ( primitive array get ( self , idx ) ) ; } return answer ; }
public static int compare to ( character leave , number right ) { return compare to ( integer . value of ( leave ) , right ) ; }
public static int compare to ( number leave , character right ) { return compare to ( leave , integer . value of ( right ) ) ; }
public static number xor ( number leave , number right ) { return number math . xor ( leave , right ) ; }
public static boolean be upper case ( character self ) { return character . be upper case ( self ) ; }
public static boolean be letter ( character self ) { return character . be letter ( self ) ; }
public static boolean be digit ( character self ) { return character . be digit ( self ) ; }
public static boolean be letter or digit ( character self ) { return character . be letter or digit ( self ) ; }
public static big integer to big integer ( number self ) { if ( self instanceof big integer ) { return ( big integer ) self ; } else if ( self instanceof big decimal ) { return ( ( big decimal ) self ) . to big integer ( ) ; } else if ( self instanceof double ) { return new big decimal ( ( double ) self ) . to big integer ( ) ; } else if ( self instanceof float ) { return new big decimal ( ( float ) self ) . to big integer ( ) ; } else { return new big integer ( long . to string ( self . long value ( ) ) ) ; } }
public static timer task run after ( timer timer , int delay , final closure closure ) { timer task timer task = new timer task ( ) { public void run ( ) { closure . call ( ) ; } } ; timer . schedule ( timer task , delay ) ; return timer task ; }
public static int find last index of ( object self , closure closure ) { return find last index of ( self , 0 , closure ) ; }
public static < t > t new instance ( class < t > c ) { return ( t ) invoker helper . invoke constructor of ( c , null ) ; }
public static void set meta class ( class self , meta class meta class ) { final meta class registry meta class registry = groovy system . get meta class registry ( ) ; if ( meta class == null ) meta class registry . remove meta class ( self ) ; else { if ( meta class instanceof handle meta class ) { meta class registry . set meta class ( self , ( ( handle meta class ) meta class ) . get adaptee ( ) ) ; } else { meta class registry . set meta class ( self , meta class ) ; } if ( self== null object . class ) { null object . get null object ( ) . set meta class ( meta class ) ; } } }
public static < t > list < t > swap ( list < t > self , int i , int j ) { collection . swap ( self , i , j ) ; return self ; }
public static buffer writer new writer ( file file , string charset ) throw i o exception { return new writer ( file , charset , false ) ; }
public static file create temp dir ( ) throw i o exception { return default groovy static method . create temp dir ( null ) ; }
public static call site bootstrap ( lookup caller , string name , method type type ) { return real bootstrap ( caller , name , call_types . method . ordinal ( ) , type , false , false , false ) ; }
public int next row index ( ) { return row count++ ; }
public object layout ( map model , string template name ) throw i o exception , class not find exception { return layout ( model , template name , false ) ; }
public void set base template class ( final class < ? extend base template > base template class ) { this . base template class = base template class ; }
public boolean be expire ( ) { if ( ! expire ) { if ( deadline nanos - ticker . read ( ) < = 0 ) { expired = true ; } else { return false ; } } return true ; }
public call option with wait for ready ( ) { call option new option = new call option ( this ) ; new option . wait for ready = true ; return new option ; }
public call option without wait for ready ( ) { call option new option = new call option ( this ) ; new option . wait for ready = false ; return new option ; }
public call option with max inbound message size ( int max size ) { check argument ( max size > = 0 , `` invalid maxsize % s `` , max size ) ; call option new option = new call option ( this ) ; new option . max inbound message size = max size ; return new option ; }
public void remove server socket ( instrumented < server stats > server , instrument < socket stats > socket ) { server socket map socket of server = per server socket . get ( id ( server ) ) ; assert socket of server ! = null ; remove ( socket of server , socket ) ; }
public static status http status to grpc status ( int http status code ) { return http status to grpc code ( http status code ) . to status ( ) . with description ( `` http status code `` + http status code ) ; }
public static string get grpc user agent ( string transport name , @ nullable string application user agent ) { string builder builder = new string builder ( ) ; if ( application user agent ! = null ) { builder . append ( application user agent ) ; builder . append ( ' ' ) ; } builder . append ( `` grpc-java- `` ) ; builder . append ( transport name ) ; builder . append ( '/ ' ) ; builder . append ( implementation_version ) ; return builder . to string ( ) ; }
public long payload ( ) { return data ; }
public list < server service definition > get service ( ) { return service ; }
public void execute ( runnable r ) { run queue . add ( check not null ( r , `` ' r ' must not be null . `` ) ) ; schedule ( r ) ; }
public void notify when state change ( connectivity state source , runnable callback ) { throw new unsupported operation exception ( `` not implement `` ) ; }
public t enable retry ( ) { throw new unsupported operation exception ( ) ; }
public req t parse request ( input stream input ) { return request marshaller . parse ( input ) ; }
public static string extract full service name ( string full method name ) { int index = check not null ( full method name , `` full method name `` ) . last index of ( '/ ' ) ; if ( index == -1 ) { return null ; } return full method name . substring ( 0 , index ) ; }
public static server provider provider ( ) { if ( provider == null ) { throw new provider not find exception ( `` no functional server find . `` + `` try add a dependency on the grpc-netty or grpc-netty-shaded artifact `` ) ; } return provider ; }
public service descriptor get service descriptor ( ) { return service descriptor ; }
public final s with call credential ( call credential credential ) { return build ( channel , call option . with call credential ( credential ) ) ; }
public final s with max outbound message size ( int max size ) { return build ( channel , call option . with max outbound message size ( max size ) ) ; }
public static < e > multiset < e > constrain multiset ( multiset < e > multiset , constraint < ? super e > constraint ) { return new constrain multiset < e > ( multiset , constraint ) ; }
public static long length ( input supplier < ? extend input stream > supplier ) throw i o exception { return a byte source ( supplier ) . size ( ) ; }
public static list < string > read line ( url url , charset charset ) throw i o exception { return char stream . read line ( new reader supplier ( url , charset ) ) ; }
public retryer builder < v > retry if runtime exception ( ) { rejection predicate = predicate . or ( rejection predicate , new exception class predicate < v > ( runtime exception . class ) ) ; return this ; }
public static stop strategy stop after delay ( long delay in millis ) { return stop after delay ( delay in millis , time unit . millisecond ) ; }
protect void expect miss ( e . . . element ) { for ( e element : element ) { assert false ( `` should not contain `` + element , actual content ( ) . contains ( element ) ) ; } }
public b suppressing ( method . . . method ) { return suppress ( array . a list ( method ) ) ; }
public list < string > order ( list < string > insertion order ) { return insertion order ; }
public void test low ( ) { assert equal ( null , navigable set . low ( a ) ) ; assert equal ( a , navigable set . low ( b ) ) ; assert equal ( b , navigable set . low ( c ) ) ; }
public static method [ ] get hole method ( ) { return new method [ ] { helper . get method ( navigable set navigation tester . class , `` test low hole `` ) , helper . get method ( navigable set navigation tester . class , `` test floor hole `` ) , helper . get method ( navigable set navigation tester . class , `` test ceiling hole `` ) , helper . get method ( navigable set navigation tester . class , `` test high hole `` ) , } ; }
public list < integer > order ( list < integer > insertion order ) { collection . sort ( insertion order ) ; return insertion order ; }
public static void assert escape ( unicode escaper escaper , string expect , int cp ) { string escape = compute replacement ( escaper , cp ) ; assert . assert not null ( escape ) ; assert . assert equal ( expect , escape ) ; }
public static void assert unescaped ( unicode escaper escaper , int cp ) { assert . assert null ( compute replacement ( escaper , cp ) ) ; }
protect final void public api only ( ) { visibility = visibility . public ; }
public static runtime exception rethrow cause ( throwable throwable ) { throwable cause = throwable ; if ( cause . get cause ( ) ! = null ) { cause = cause . get cause ( ) ; } return rethrow ( cause ) ; }
protect t provision ( provider < ? extend t > provider , error error , dependency < ? > dependency , construction context < t > construction context ) throw error exception { t t = error . check for null ( provider . get ( ) , source , dependency ) ; construction context . set proxy delegate ( t ) ; return t ; }
public string get source name ( object source ) { if ( source instanceof element source ) { source = ( ( element source ) source ) . get declare source ( ) ; } if ( source instanceof method ) { source = stack trace element . for member ( ( method ) source ) ; } if ( source instanceof stack trace element ) { return get file string ( ( stack trace element ) source ) ; } return strip package ( source . to string ( ) ) ; }
public int get year ( ) { return date time utils . year from date value ( date value ) ; }
public static db column get procedure column ( db content content , result set r ) throw s q l exception { return new db column ( content , r , true ) ; }
public static db column get column ( db content content , result set r ) throw s q l exception { return new db column ( content , r , false ) ; }
public void add ( column column ) { if ( boolean . false . equal ( generate key request ) ) { return ; } row . add ( column ) ; }
public local result get key ( session session ) { database db = session == null ? null : session . get database ( ) ; if ( boolean . false . equal ( generate key request ) ) { clear ( null ) ; return new local result ( ) ; } array list < expression column > expression column ; if ( boolean . true . equal ( generate key request ) ) { expression column = new array list < > ( all column . size ( ) ) ; for ( column column : all column ) { expression column . add ( new expression column ( db , column ) ) ; } } else if ( generate key request instanceof int [ ] ) { if ( table ! = null ) { int [ ] index = ( int [ ] ) generate keys request ; column [ ] column = table . get columns ( ) ; int cnt = column . length ; all column . clear ( ) ; expression columns = new array list < > ( index . length ) ; for ( int idx : index ) { if ( idx > = 1 & & idx < = cnt ) { column column = column [ idx - 1 ] ; expression column . add ( new expression column ( db , column ) ) ; all column . add ( column ) ; } } } else { clear ( null ) ; return new local result ( ) ; } } else if ( generate key request instanceof string [ ] ) { if ( table ! = null ) { string [ ] name = ( string [ ] ) generate keys request ; all column . clear ( ) ; expression columns = new array list < > ( names . length ) ; for ( string name : name ) { column column ; search : if ( table . do column exist ( name ) ) { column = table . get column ( name ) ; } else { name = string utils . to upper english ( name ) ; if ( table . do column exist ( name ) ) { column = table . get column ( name ) ; } else { for ( column c : table . get columns ( ) ) { if ( c . get name ( ) . equal ignore case ( name ) ) { column = c ; break search ; } } continue ; } } expression column . add ( new expression column ( db , column ) ) ; all column . add ( column ) ; } } else { clear ( null ) ; return new local result ( ) ; } } else { clear ( null ) ; return new local result ( ) ; } int column count = expression column . size ( ) ; if ( column count == 0 ) { clear ( null ) ; return new local result ( ) ; } local result result = new local result ( session , expression column . to array ( new expression [ 0 ] ) , column count ) ; for ( map < column , value > map : data ) { value [ ] row = new value [ column count ] ; for ( map . entry < column , value > entry : map . entry set ( ) ) { int idx = all column . index of ( entry . get key ( ) ) ; if ( idx > = 0 ) { row [ idx ] = entry . get value ( ) ; } } for ( int i = 0 ; i < column count ; i++ ) { if ( row [ i ] == null ) { row [ i ] = value null . instance ; } } result . add row ( row ) ; } clear ( null ) ; return result ; }
public string get s q l keywords ( ) { debug code call ( `` get s q l keywords `` ) ; return `` limit , minus , offset , rownum , sysdate , systime , systimestamp , today `` ; }
public k peek first ( ) { k [ ] a = array ; return a . length == 0 ? null : a [ 0 ] ; }
public synchronize boolean remove last ( k obj ) { if ( peek last ( ) ! = obj ) { return false ; } array = array . copy of ( array , array . length - 1 ) ; return true ; }
public long get write count ( ) { return write count . get ( ) ; }
public boolean be free ( long po , int length ) { int start = get block ( po ) ; int block = get block count ( length ) ; for ( int i = start ; i < start + block ; i++ ) { if ( set . get ( i ) ) { return false ; } } return true ; }
protect void init ( m v store store , int id , long create version ) { this . store = store ; this . id = id ; this . create version = create version ; this . write version = store . get current version ( ) ; this . root = page . create empty ( this , -1 ) ; }
public boolean have map ( string name ) { return meta . contains key ( `` name . `` + name ) ; }
public void close ( ) { if ( close ) { return ; } file store f = file store ; if ( f ! = null & & ! f . be read only ( ) ) { stop background thread ( ) ; if ( have unsaved change ( ) ) { commit and save ( ) ; } } close store ( true ) ; }
public void rollback ( ) { rollback to ( current version ) ; }
public file store get file store ( ) { return file store ; }
public void set cache size ( int mb ) { final long byte = ( long ) mb * 1024 * 1024 ; if ( cache ! = null ) { cache . set max memory ( byte ) ; cache . clear ( ) ; } if ( cache chunk ref ! = null ) { cache chunk ref . set max memory ( bytes / 4 ) ; cache chunk ref . clear ( ) ; } }
public static void dump ( string file name , boolean detail ) { dump ( file name , new print writer ( system . out ) , detail ) ; }
public boolean equal ignore id ( spatial key o ) { return array . equal ( min max , o . min max ) ; }
public write buffer put string data ( string s , int len ) { byte buffer b = ensure capacity ( 3 * len ) ; data utils . write string data ( b , s , len ) ; return this ; }
public int get update count ( ) { return update count ; }
public table synonym get synonym ( string name ) { return synonym . get ( name ) ; }
public synchronize void modify ( long start value , long min value , long max value , long increment ) { if ( start value == null ) { start value = this . value ; } if ( min value == null ) { min value = this . min value ; } if ( max value == null ) { max value = this . max value ; } if ( increment == null ) { increment = this . increment ; } if ( ! be valid ( start value , min value , max value , increment ) ) { throw db exception . get ( error code . sequence_attributes_invalid , get name ( ) , string . value of ( start value ) , string . value of ( min value ) , string . value of ( max value ) , string . value of ( increment ) ) ; } this . value = start value ; this . value with margin = start value ; this . min value = min value ; this . max value = max value ; this . increment = increment ; }
public static index lookup batch create fake index lookup batch ( table filter filter ) { return new fake lookup batch ( filter ) ; }
public void add synonym ( table synonym synonym ) { synonyms = add ( synonyms , synonym ) ; }
public void set derive column ( array list < string > derive column name ) { column [ ] column = get column ( ) ; int count = column . length ; if ( count ! = derive column name . size ( ) ) { throw db exception . get ( error code . column_count_does_not_match ) ; } hash map < column , string > map = new hash map < > ( count ) ; for ( int i = 0 ; i < count ; i++ ) { string alias = derive column name . get ( i ) ; for ( int j = 0 ; j < i ; j++ ) { if ( alias . equal ( derived column name . get ( j ) ) ) { throw db exception . get ( error code . duplicate_column_name_1 , alias ) ; } } map . put ( columns [ i ] , alias ) ; } this . derived column map = map ; }
public static gregorian calendar get calendar ( ) { gregorian calendar c = cached_calendar . get ( ) ; if ( c == null ) { c = create gregorian calendar ( ) ; cached_calendar . set ( c ) ; } c . clear ( ) ; return c ; }
public static int get iso week year ( long date value ) { return get week year ( date value , 1 , 4 ) ; }
public static void append time ( string builder buff , long nanos ) { if ( nanos < 0 ) { buff . append ( '- ' ) ; nanos = -nanos ; } / * * nanos now either in range from 0 to long . max_value or equal to * long . min_value . we need to divide nanos by 1000000 with unsigned division to * get correct result . the simple way to do this with such constraint be to * divide -nanos by -1000000 . * / long m = -nanos / -1_000_000 ; nanos -= ms * 1_000_000 ; long s = m / 1_000 ; m -= s * 1_000 ; long m = s / 60 ; s -= m * 60 ; long h = m / 60 ; m -= h * 60 ; string utils . append zero pad ( buff , 2 , h ) ; buff . append ( ' : ' ) ; string utils . append zero pad ( buff , 2 , m ) ; buff . append ( ' : ' ) ; string utils . append zero pad ( buff , 2 , s ) ; if ( m > 0 || nanos > 0 ) { buff . append ( ' . ' ) ; int start = buff . length ( ) ; string utils . append zero pad ( buff , 3 , m ) ; if ( nanos > 0 ) { string utils . append zero pad ( buff , 6 , nanos ) ; } for ( int i = buff . length ( ) - 1 ; i > start ; i -- ) { if ( buff . char at ( i ) ! = ' 0 ' ) { break ; } buff . delete char at ( i ) ; } } }
public static boolean be java8 date api present ( ) { return is_java8_date_api_present ; }
public static object value to local time ( value value ) { try { return local_time_of_nano . invoke ( null , ( ( value time ) value . convert to ( value . time ) ) . get nanos ( ) ) ; } catch ( illegal access exception e ) { throw db exception . convert ( e ) ; } catch ( invocation target exception e ) { throw db exception . convert invocation ( e , `` time conversion fail `` ) ; } }
public void set java system compiler ( boolean enable ) { this . use java system compiler = enable ; }
public static interval of hour minute second ( long hour , int minute , int second ) { return of hour minute nanos ( hour , minute , second * nanos_per_second ) ; }
public array list < column > get ( table table ) { if ( map == null ) { map = new hash map < > ( ) ; expression visitor . all column for table filter ( filter , this ) ; } return map . get ( table ) ; }
public static select group get instance ( session session , array list < expression > expression , boolean be group query , int [ ] group index ) { return be group query ? new grouped ( session , expression , group index ) : new plain ( session , expression ) ; }
public void clean authentication info ( ) { remove property ( `` authrealm `` , false ) ; remove property ( `` authzpwd `` , false ) ; }
public window frame unit get unit ( ) { return unit ; }
public window frame bound get start ( ) { return start ; }
public expression get subexpression ( int index ) { throw new index out of bound exception ( ) ; }
public void read meta data ( transfer transfer ) throw i o exception { type = transfer . read type info ( ) ; nullable = transfer . read int ( ) ; }
public int set byte ( long po , byte [ ] bytes ) throw s q l exception { if ( bytes == null ) { throw new null pointer exception ( ) ; } try { if ( be debug enabled ( ) ) { debug code ( `` set byte ( `` +pos+ `` , `` +quote byte ( byte ) + `` ) ; `` ) ; } check editable ( ) ; if ( po ! = 1 ) { throw db exception . get invalid value exception ( `` pos `` , po ) ; } complete write ( conn . create blob ( new byte array input stream ( byte ) , -1 ) ) ; return byte . length ; } catch ( exception e ) { throw log and convert ( e ) ; } }
public int get project fill rate ( int vacate block ) { return free space . get project fill rate ( vacated block ) ; }
public string get string value ( string name , string default value ) { string result = property . get ( name ) ; if ( result == null ) { return default value ; } return result ; }
public void init ( database database ) throw auth config exception { if ( skip default initialization ) { return ; } if ( initialize ) { return ; } synchronize ( this ) { if ( initialize ) { return ; } trace trace = database . get trace ( trace . database ) ; url h2 authenticator configuration url = null ; try { string config file = sys property . auth_config_file ; if ( config file ! = null ) { if ( trace . be debug enable ( ) ) { trace . debug ( `` default authenticator . config : configuration read from system property `` + `` h2auth . configurationfile= { 0 } `` , config file ) ; } h2 authenticator configuration url = new url ( config file ) ; } if ( h2 authenticator configuration url == null ) { if ( trace . be debug enable ( ) ) { trace . debug ( `` default authenticator . config : default configuration `` ) ; } default configuration ( ) ; } else { configure from url ( h2 authenticator configuration url ) ; } } catch ( exception e ) { trace . error ( e , `` default authenticator . config : an error occur during configuration from { 0 } `` , h2 authenticator configuration url ) ; throw new auth config exception ( `` fail to configure authentication from `` + h2 authenticator configuration url , e ) ; } initialize = true ; } }
public void set name ( string name ) { this . name = name ; }
public void add common join column to exclude ( column column to exclude ) { if ( common join column to exclude == null ) { common join column to exclude = utils . new small array list ( ) ; } common join column to exclude . add ( column to exclude ) ; }
public static int get time zone offset ( long epoch second ) { return get time zone ( ) . get time zone offset u t c ( epoch second ) ; }
public static long normalize nanos of day ( long nanos ) { nanos % = nanos_per_day ; if ( nanos < 0 ) { nanos += nanos_per_day ; } return nanos ; }
public static byte [ ] ewkb to geo json ( byte [ ] ewkb , int dimension system ) { j s o n byte array target output = new j s o n byte array target ( ) ; geo json target target = new geo json target ( output , dimension system ) ; e w k b utils . parse e w k b ( ewkb , target ) ; return output . get result ( ) ; }
public static double [ ] get envelope ( byte [ ] ewkb ) { envelope target target = new envelope target ( ) ; e w k b utils . parse e w k b ( ewkb , target ) ; return target . get envelope ( ) ; }
public static void parse geometry ( geometry geometry , target target ) { parse geometry ( geometry , target , 0 ) ; }
public boolean include ( j s o n item type type ) { if ( type == null ) { throw new null pointer exception ( ) ; } return this == value || this == type ; }
public int get geometry type ( ) { return type and dimension system % 1_000 ; }
public int get s r i d ( ) { return srid ; }
public byte [ ] get e w k b ( ) { return byte ; }
public int get memory ( ) { / * * java 11 with -xx : - use compress oops * empty string : 88 byte * 1 to 4 utf-16 char : 96 byte * / return value . length ( ) * 2 + 94 ; }
protect string get keytab ( ) { return keytab ; }
public string verify and extract ( string sign str ) throw signer exception { int index = sign str . last index of ( signature ) ; if ( index == -1 ) { throw new signer exception ( `` invalid sign text : `` + sign str ) ; } string original signature = sign str . substring ( index + signature . length ( ) ) ; string raw value = sign str . substring ( 0 , index ) ; check signature ( raw value , original signature ) ; return raw value ; }
public long get long ( string name , long default value ) { string value string = get trim ( name ) ; if ( value string == null ) return default value ; string hex string = get hex digit ( value string ) ; if ( hex string ! = null ) { return long . parse long ( hex string , 16 ) ; } return long . parse long ( value string ) ; }
public < t extend enum < t > > void set enum ( string name , t value ) { set ( name , value . to string ( ) ) ; }
public long get time duration ( string name , long default value , time unit unit ) { string v str = get ( name ) ; if ( null == v str ) { return default value ; } v str = v str . trim ( ) ; parse time duration v unit = parsed time duration . unit for ( v str ) ; if ( null == v unit ) { log . warn ( `` no unit for `` + name + `` ( `` + v str + `` ) assume `` + unit ) ; v unit = parse time duration . unit for ( unit ) ; } else { v str = v str . substring ( 0 , v str . last index of ( v unit . suffix ( ) ) ) ; } return unit . convert ( long . parse long ( v str ) , v unit . unit ( ) ) ; }
public char [ ] get password ( string name ) throw i o exception { char [ ] pas = null ; pas = get password from credential provider ( name ) ; if ( pas == null ) { pas = get password from config ( name ) ; } return pas ; }
protect char [ ] get password from credential provider ( string name ) throw i o exception { char [ ] pas = null ; try { list < credential provider > provider = credential provider factory . get provider ( this ) ; if ( provider ! = null ) { for ( credential provider provider : provider ) { try { credential entry entry = provider . get credential entry ( name ) ; if ( entry ! = null ) { pas = entry . get credential ( ) ; break ; } } catch ( i o exception ioe ) { throw new i o exception ( `` ca n't get key `` + name + `` from key provider `` + `` of type : `` + provider . get class ( ) . get name ( ) + `` . `` , ioe ) ; } } } } catch ( i o exception ioe ) { throw new i o exception ( `` configuration problem with provider path . `` , ioe ) ; } return pas ; }
public boolean have task ( ) { return start time > 0 ; }
public static boolean support ( crypto protocol version version ) { if ( version . get version ( ) == unknown . get version ( ) ) { return false ; } for ( crypto protocol version v : crypto protocol version . value ( ) ) { if ( v . get version ( ) == version . get version ( ) ) { return true ; } } return false ; }
public static int check buffer size ( crypto codec codec , int buffer size ) { precondition . check argument ( buffer size > = min_buffer_size , `` minimum value of buffer size be `` + min_buffer_size + `` . `` ) ; return buffer size - buffer size % codec . get cipher suite ( ) . get algorithm block size ( ) ; }
public int run ( string [ ] args ) throw exception { int exit code = 0 ; try { exit code = init ( args ) ; if ( exit code ! = 0 ) { return exit code ; } if ( command . validate ( ) ) { command . execute ( ) ; } else { exit code = 1 ; } } catch ( exception e ) { e . print stack trace ( err ) ; return 1 ; } return exit code ; }
public static void main ( string [ ] args ) throw exception { int re = tool runner . run ( new configuration ( ) , new key shell ( ) , args ) ; system . exit ( re ) ; }
public void remove default acl ( path path ) throw i o exception { throw new unsupported operation exception ( get class ( ) . get simple name ( ) + `` do n't support remove default acl `` ) ; }
public long get length ( ) { return length ; }
public void set host ( string [ ] host ) throw i o exception { if ( host == null ) { this . host = empty_str_array ; } else { this . host = host ; } }
public file system get raw file system ( ) { return f ; }
public int get bytes per sum ( ) { return bytes per checksum ; }
public long get quota ( ) { return quota ; }
public boolean be type quota set ( ) { if ( type quota == null ) { return false ; } for ( storage type t : storage type . get type support quota ( ) ) { if ( type quota [ t . ordinal ( ) ] > 0 ) { return true ; } } return false ; }
protect int get renew queue length ( ) { return queue . size ( ) ; }
public < t extend file system & renewable > renew action < t > add renew action ( final t f ) { synchronize ( this ) { if ( ! be alive ( ) ) { start ( ) ; } } renew action < t > action = new renew action < t > ( f ) ; if ( action . token ! = null ) { queue . add ( action ) ; } else { f . log . error ( `` do not have a token for renewal `` ) ; } return action ; }
public void inc dfs use ( long value ) { use . add and get ( value ) ; }
protect static file context get file context ( final abstract file system default f s ) { return get file context ( default f s , new configuration ( ) ) ; }
public static void print statistic ( ) { abstract file system . print statistic ( ) ; }
public static file system get ( configuration conf ) throw i o exception { return get ( get default uri ( conf ) , conf ) ; }
public string get canonical service name ( ) { return ( get child file system ( ) == null ) ? security util . build d t service name ( get uri ( ) , get default port ( ) ) : null ; }
public static local file system get local ( configuration conf ) throw i o exception { return ( local file system ) get ( local file system . name , conf ) ; }
public path make qualify ( path path ) { check path ( path ) ; return path . make qualified ( this . get uri ( ) , this . get work directory ( ) ) ; }
public boolean delete ( path f ) throw i o exception { return delete ( f , true ) ; }
public boolean exists ( path f ) throw i o exception { try { return get file status ( f ) ! = null ; } catch ( file not find exception e ) { return false ; } }
public f status get status ( ) throw i o exception { return get status ( null ) ; }
public void set permission ( path p , fs permission permission ) throw i o exception { }
public acl status get acl status ( path path ) throw i o exception { throw new unsupported operation exception ( get class ( ) . get simple name ( ) + `` do n't support get acl status `` ) ; }
public static boolean fully delete ( final file dir ) { return fully delete ( dir , false ) ; }
public boolean seek to new source ( long target po ) throw i o exception { return ( ( seekable ) in ) . seek to new source ( target po ) ; }
public synchronize void write ( int b ) throw i o exception { buf [ count++ ] = ( byte ) b ; if ( count == buf . length ) { flush buffer ( ) ; } }
public static void create hard link ( file file , file link name ) throw i o exception { if ( file == null ) { throw new i o exception ( `` invalid argument to create hard link : source file be null `` ) ; } if ( link name == null ) { throw new i o exception ( `` invalid argument to create hard link : link name be null `` ) ; } create link ( link name . to path ( ) , file . to path ( ) ) ; }
public file create tmp file for write ( string path str , long size , configuration conf ) throw i o exception { allocator per context context = obtain context ( context cfg item name ) ; return context . create tmp file for write ( path str , size , conf ) ; }
public string get name ( ) { string path = uri . get path ( ) ; int slash = path . last index of ( separator ) ; return path . substring ( slash+1 ) ; }
public static list < acl entry > get minimal acl ( fs permission perm ) { return list . new array list ( new acl entry . builder ( ) . set scope ( acl entry scope . access ) . set type ( acl entry type . user ) . set permission ( perm . get user action ( ) ) . build ( ) , new acl entry . builder ( ) . set scope ( acl entry scope . access ) . set type ( acl entry type . group ) . set permission ( perm . get group action ( ) ) . build ( ) , new acl entry . builder ( ) . set scope ( acl entry scope . access ) . set type ( acl entry type . other ) . set permission ( perm . get other action ( ) ) . build ( ) ) ; }
public static boolean be minimal acl ( list < acl entry > entry ) { return entry . size ( ) == 3 ; }
public short apply new permission ( file status file ) { fs permission perm = file . get permission ( ) ; int exist = perm . to short ( ) ; boolean exe ok = file . be directory ( ) || ( exist & 0111 ) ! = 0 ; return ( short ) combine mode ( exist , exe ok ) ; }
public static f permission get file default ( ) { return new fs permission ( ( short ) 00666 ) ; }
public list < acl entry > get access entry ( ) { return access entry ; }
protect void process argument ( link list < path data > args ) throw i o exception { for ( path data arg : args ) { try { process argument ( arg ) ; } catch ( i o exception e ) { display error ( e ) ; } } }
protect void add argument ( deque < string > args , int count ) { for ( int i = 0 ; i < count ; i++ ) { add argument ( args . pop ( ) ) ; } }
public boolean be follow link ( ) { return this . follow link ; }
public int get min depth ( ) { return this . min depth ; }
public connector create base listener ( configuration conf ) throw i o exception { return http server . create default channel connector ( ) ; }
protect void add context ( string path spec , string dir , boolean be filter ) throw i o exception { if ( 0 == web server . get handler ( ) . length ) { throw new runtime exception ( `` could n't find handler `` ) ; } web app context web app ctx = new web app context ( ) ; web app ctx . set context path ( path spec ) ; web app ctx . set war ( dir ) ; add context ( web app ctx , true ) ; }
public boolean be alive ( ) { return web server ! = null & & web server . be start ( ) ; }
protect synchronized void copy ( writable other ) { if ( other ! = null ) { try { data output buffer out = new data output buffer ( ) ; other . write ( out ) ; data input buffer in = new data input buffer ( ) ; in . reset ( out . get data ( ) , out . get length ( ) ) ; read field ( in ) ; } catch ( i o exception e ) { throw new illegal argument exception ( `` map can not be copy : `` + e . get message ( ) ) ; } } else { throw new illegal argument exception ( `` source map can not be null `` ) ; } }
public void set ( boolean value ) { this . value = value ; }
public int get limit ( ) { return limit ; }
public boolean equal ( object o ) { if ( ! ( o instanceof byte writable ) ) { return false ; } byte writable other = ( byte writable ) o ; return this . value == other . value ; }
public synchronize void reset ( ) { check stream ( ) ; end ( stream ) ; stream = init ( conserve memory ? 1 : 0 ) ; finish = false ; compress direct buf off = compress direct buf len = 0 ; uncompressed direct buf . limit ( direct buffer size ) ; uncompressed direct buf . position ( direct buffer size ) ; user buf off = user buf len = 0 ; }
public static compressor get bzip2 compressor ( configuration conf ) { return be native bzip2 load ( conf ) ? new bzip2 compressor ( conf ) : new b zip2 dummy compressor ( ) ; }
public configuration get conf ( ) { return conf ; }
public static string remove suffix ( string filename , string suffix ) { if ( filename . end with ( suffix ) ) { return filename . substring ( 0 , filename . length ( ) - suffix . length ( ) ) ; } return filename ; }
public synchronize void reinit ( configuration conf ) { reset ( ) ; }
public void reinit ( configuration conf ) { reset ( ) ; if ( conf == null ) { return ; } end ( stream ) ; level = zlib factory . get compression level ( conf ) ; strategy = zlib factory . get compression strategy ( conf ) ; stream = init ( level . compression level ( ) , strategy . compression strategy ( ) , window bit . window bit ( ) ) ; if ( log . be debug enable ( ) ) { log . debug ( `` reinit compressor with new compression configuration `` ) ; } }
public static compressor get zlib compressor ( configuration conf ) { return ( be native zlib load ( conf ) ) ? new zlib compressor ( conf ) : new build in zlib deflater ( zlib factory . get compression level ( conf ) . compression level ( ) ) ; }
public class < e > get element type ( ) { return element type ; }
public int get length ( ) { return buffer . get length ( ) ; }
public void set ( int value ) { this . value = value ; }
public static void rename ( file system f , string old name , string new name ) throw i o exception { path old dir = new path ( old name ) ; path new dir = new path ( new name ) ; if ( ! f . rename ( old dir , new dir ) ) { throw new i o exception ( `` could not rename `` + old dir + `` to `` + new dir ) ; } }
public static void delete ( file system f , string name ) throw i o exception { path dir = new path ( name ) ; path data = new path ( dir , data_file_name ) ; path index = new path ( dir , index_file_name ) ; f . delete ( data , true ) ; f . delete ( index , true ) ; f . delete ( dir , true ) ; }
public int compare to ( m d5 hash that ) { return writable comparator . compare bytes ( this . digest , 0 , md5_len , that . digest , 0 , md5_len ) ; }
public static share file descriptor factory create ( string prefix , string path [ ] ) throw i o exception { string load failure reason = get loading failure reason ( ) ; if ( load failure reason ! = null ) { throw new i o exception ( loading failure reason ) ; } if ( path . length == 0 ) { throw new i o exception ( `` no share file descriptor factory path be `` + `` configure . `` ) ; } string builder error = new string builder ( ) ; string str prefix = `` `` ; for ( string path : path ) { try { file input stream fis = new file input stream ( create descriptor0 ( prefix + `` test `` , path , 1 ) ) ; fis . close ( ) ; delete stale temporary files0 ( prefix , path ) ; return new share file descriptor factory ( prefix , path ) ; } catch ( i o exception e ) { error . append ( str prefix ) . append ( `` error create file descriptor in `` ) . append ( path ) . append ( `` : `` ) . append ( e . get message ( ) ) ; str prefix = `` , `` ; } } throw new i o exception ( error . to string ( ) ) ; }
public void set ( object instance ) { this . declared class = instance . get class ( ) ; this . instance = instance ; }
public static readahead pool get instance ( ) { synchronize ( readahead pool . class ) { if ( instance == null & & native i o . be available ( ) ) { instance = new readahead pool ( ) ; } return instance ; } }
public boolean equal ( object o ) { if ( ! ( o instanceof v long writable ) ) return false ; v long writable other = ( v long writable ) o ; return this . value == other . value ; }
public int compare ( writable comparable a , writable comparable b ) { return a . compare to ( b ) ; }
public static int read int ( byte [ ] byte , int start ) { return ( ( ( bytes [ start ] & 0xff ) < < 24 ) + ( ( bytes [ start+1 ] & 0xff ) < < 16 ) + ( ( bytes [ start+2 ] & 0xff ) < < 8 ) + ( ( bytes [ start+3 ] & 0xff ) ) ) ; }
public static writable new instance ( class < ? extend writable > c , configuration conf ) { writable factory factory = writable factory . get factory ( c ) ; if ( factory ! = null ) { writable result = factory . new instance ( ) ; if ( result instanceof configurable ) { ( ( configurable ) result ) . set conf ( conf ) ; } return result ; } else { return reflection utils . new instance ( c , conf ) ; } }
public void add process time ( string name , int processing time ) { rate . add ( name , processing time ) ; }
public synchronize boolean unregister ( string identifier , refresh handler handler ) { return handler table . remove ( identifier , handler ) ; }
public static int get call id ( ) { call call = cur call . get ( ) ; return call ! = null ? call . call id : rpc constant . invalid_call_id ; }
public static void bind ( server socket socket , inet socket address address , int backlog ) throw i o exception { bind ( socket , address , backlog , null , null ) ; }
public synchronize void start ( ) { responder . start ( ) ; listener . start ( ) ; handler = new handler [ handler count ] ; for ( int i = 0 ; i < handler count ; i++ ) { handler [ i ] = new handler ( i ) ; handler [ i ] . start ( ) ; } }
public writable call ( writable param , long receive time ) throw exception { return call ( rpc . rpc kind . rpc_builtin , null , param , receive time ) ; }
public int get num open connection ( ) { return connection manager . size ( ) ; }
public int get max queue size ( ) { return max queue size ; }
public boolean ignores throwable ( ) { return false ; }
public void remove attribute ( string attribute name ) { attribute map . remove ( attribute name ) ; }
protect string get attribute ( string attribute name ) { string factory attribute = context name + `` . `` + attribute name ; return ( string ) factory . get attribute ( factory attribute ) ; }
public string get context name ( ) { return context name ; }
public synchronize void unregister updater ( updater updater ) { updaters . remove ( updater ) ; }
public void remove tag ( string tag name ) { tag table . remove ( tag name ) ; }
public void start monitoring ( ) { }
public synchronize void set ( final int new value ) { value = new value ; change = true ; }
public object get property ( string key ) { object value = super . get property ( key ) ; if ( value == null ) { if ( log . be debug enable ( ) ) { log . debug ( `` poke parent ' `` + get parent ( ) . get class ( ) . get simple name ( ) + `` ' for key : `` + key ) ; } return get parent ( ) . get property ( key . start with ( prefix_default ) ? key : prefix_default + key ) ; } if ( log . be debug enable ( ) ) { log . debug ( `` return ' `` + value + `` ' for key : `` + key ) ; } return value ; }
public static metric info info ( string name , string description ) { return info . instance . cache . add ( name , description ) ; }
public mutable counter long new counter ( string name , string desc , long i val ) { return new counter ( intern . info ( name , desc ) , i val ) ; }
public synchronize mutable quantiles new quantiles ( string name , string desc , string sample name , string value name , int interval ) { check metric name ( name ) ; mutable quantiles ret = new mutable quantiles ( name , desc , sample name , value name , interval ) ; metric map . put ( name , ret ) ; return ret ; }
public mutable rate new rate ( string name ) { return new rate ( name , name , false ) ; }
public void snapshot ( metric record builder builder ) { snapshot ( builder , false ) ; }
protect void clear change ( ) { change = false ; }
public void reset min max ( ) { min max . reset ( ) ; }
public static inet socket address create socket addr ( string target ) { return create socket addr ( target , -1 ) ; }
public static output stream get output stream ( socket socket , long timeout ) throw i o exception { return ( socket . get channel ( ) == null ) ? socket . get output stream ( ) : new socket output stream ( socket , timeout ) ; }
protect node get node for network location ( node node ) { return get node ( node . get network location ( ) ) ; }
public void remove ( node node ) { if ( node==null ) return ; if ( node instanceof inner node ) { throw new illegal argument exception ( `` not allow to remove an inner node : `` + node base . get path ( node ) ) ; } log . info ( `` remove a node : `` + node base . get path ( node ) ) ; netlock . write lock ( ) . lock ( ) ; try { if ( cluster map . remove ( node ) ) { inner node rack = ( inner node ) get node ( node . get network location ( ) ) ; if ( rack == null ) { num of rack -- ; } } if ( log . be debug enable ( ) ) { log . debug ( `` network topology become : \n `` + this . to string ( ) ) ; } } finally { netlock . write lock ( ) . unlock ( ) ; } }
public string get rack ( string loc ) { return loc ; }
public boolean be node group aware ( ) { return false ; }
public boolean be on same node group ( node node1 , node node2 ) { if ( node1 == null || node2 == null ) { return false ; } netlock . read lock ( ) . lock ( ) ; try { return be same parent ( node1 , node2 ) ; } finally { netlock . read lock ( ) . unlock ( ) ; } }
public void set network location ( string location ) { this . location = location ; }
public void set level ( int level ) { this . level = level ; }
public int get capacity ( ) { return this . get ( ) . length ; }
public void execute ( ) throw build exception { if ( src == null & & filesets . size ( ) ==0 ) { throw new build exception ( `` there must be a file attribute or a fileset child element `` ) ; } if ( src ! = null ) { do compile ( src ) ; } project my project = get project ( ) ; for ( int i = 0 ; i < filesets . size ( ) ; i++ ) { file set fs = filesets . get ( i ) ; directory scanner d = f . get directory scanner ( my project ) ; file dir = f . get dir ( my project ) ; string [ ] srcs = d . get included file ( ) ; for ( int j = 0 ; j < srcs . length ; j++ ) { do compile ( new file ( dir , srcs [ j ] ) ) ; } } }
public type i d get key type i d ( ) { return this . type i d key ; }
public type i d get value type i d ( ) { return this . type i d value ; }
public void deserialize ( record input rin ) throw i o exception { this . deserialize ( rin , `` `` ) ; }
public void add group ( string group ) { if ( be wild card a c l value ( group ) ) { throw new illegal argument exception ( `` group `` + group + `` can not be add `` ) ; } if ( ! be all allow ( ) ) { list < string > group list = new link list < string > ( ) ; group list . add ( group ) ; group map . cache group add ( group list ) ; group . add ( group ) ; } }
public collection < string > get group ( ) { return group ; }
public string get acl string ( ) { string builder sb = new string builder ( initial_capacity ) ; if ( all allow ) { sb . append ( ' * ' ) ; } else { sb . append ( get user string ( ) ) ; sb . append ( `` `` ) ; sb . append ( get group string ( ) ) ; } return sb . to string ( ) ; }
public void remove secret key ( text alias ) { secret key map . remove ( alias ) ; }
public void read field ( data input in ) throw i o exception { secret key map . clear ( ) ; token map . clear ( ) ; int size = writable utils . read v int ( in ) ; for ( int i=0 ; i < size ; i++ ) { text alias = new text ( ) ; alias . read field ( in ) ; token < ? extend token identifier > t = new token < token identifier > ( ) ; t . read field ( in ) ; token map . put ( alias , t ) ; } size = writable utils . read v int ( in ) ; for ( int i=0 ; i < size ; i++ ) { text alias = new text ( ) ; alias . read field ( in ) ; int len = writable utils . read v int ( in ) ; byte [ ] value = new byte [ len ] ; in . read fully ( value ) ; secret key map . put ( alias , value ) ; } }
public void cache group add ( list < string > group ) { try { impl . cache group add ( group ) ; } catch ( i o exception e ) { log . warn ( `` error cache group `` , e ) ; } }
public long skip ( long n ) throw i o exception { if ( ! use wrap ) { return in stream . skip ( n ) ; } int available = ofinish - ostart ; if ( n > available ) { n = available ; } if ( n < 0 ) { return 0 ; } ostart += n ; return n ; }
public static boolean be privilege port ( final int port ) { return port < 1024 ; }
protect synchronize int get current key id ( ) { return current id ; }
public synchronize token ident cancel token ( token < token ident > token , string canceller ) throw i o exception { byte array input stream buf = new byte array input stream ( token . get identifier ( ) ) ; data input stream in = new data input stream ( buf ) ; token ident id = create identifier ( ) ; id . read field ( in ) ; log . info ( `` token cancelation request for identifier : `` +id ) ; if ( id . get user ( ) == null ) { throw new invalid token ( `` token with no owner `` ) ; } string owner = id . get user ( ) . get user name ( ) ; text renewer = id . get renewer ( ) ; hadoop kerberos name canceler krb name = new hadoop kerberos name ( canceller ) ; string canceler short name = canceler krb name . get short name ( ) ; if ( ! canceller . equal ( owner ) & & ( renewer == null || renewer . to string ( ) . be empty ( ) || ! canceler short name . equal ( renewer . to string ( ) ) ) ) { throw new access control exception ( canceller + `` be not authorize to cancel the token `` ) ; } delegation token information info = current token . remove ( id ) ; if ( info == null ) { throw new invalid token ( `` token not find `` ) ; } remove stored token ( id ) ; return id ; }
public void set external delegation token secret manager ( abstract delegation token secret manager secret manager ) { this . secret manager . stop thread ( ) ; this . secret manager = secret manager ; manage secret manager = false ; }
public boolean be manage ( ) throw i o exception { return get renewer ( ) . be manage ( this ) ; }
public boolean add token ( token < ? extend token identifier > token ) { return ( token ! = null ) ? add token ( token . get service ( ) , token ) : false ; }
public void add credential ( credential credential ) { synchronize ( subject ) { get credential internal ( ) . add all ( credential ) ; } }
public synchronize string [ ] get group name ( ) { ensure initialize ( ) ; try { set < string > result = new link hash set < string > ( group . get group ( get short user name ( ) ) ) ; return result . to array ( new string [ result . size ( ) ] ) ; } catch ( i o exception ie ) { log . warn ( `` no group available for user `` + get short user name ( ) ) ; return new string [ 0 ] ; } }
public static void main ( string [ ] args ) throw exception { system . out . println ( `` get ugi for current user `` ) ; user group information ugi = get current user ( ) ; ugi . print ( ) ; system . out . println ( `` ugi : `` + ugi ) ; system . out . println ( `` auth method `` + ugi . user . get authentication method ( ) ) ; system . out . println ( `` keytab `` + ugi . be keytab ) ; system . out . println ( `` ============================================================ `` ) ; if ( args . length == 2 ) { system . out . println ( `` get ugi from keytab . . . . `` ) ; login user from keytab ( args [ 0 ] , args [ 1 ] ) ; get current user ( ) . print ( ) ; system . out . println ( `` keytab : `` + ugi ) ; system . out . println ( `` auth method `` + login user . user . get authentication method ( ) ) ; system . out . println ( `` keytab `` + login user . be keytab ) ; } }
public void remove blocker ( string name ) { synchronize ( blocker map ) { blocker map . remove ( name ) ; } }
public static exception stop quietly ( service service ) { return stop quietly ( log , service ) ; }
public synchronize void execute ( string root , runnable task ) { thread pool executor executor = executor . get ( root ) ; if ( executor == null ) { throw new runtime exception ( `` can not find root `` + root + `` for execution of task `` + task ) ; } else { executor . execute ( task ) ; } }
public void increment weight ( double weight ) { this . weight += weight ; }
public static void disable system exit ( ) { system exit disable = true ; }
public static void reset first exit exception ( ) { first exit exception = null ; }
public configuration get configuration ( ) { return conf ; }
public static url [ ] get lib jar ( configuration conf ) throw i o exception { string jar = conf . get ( `` tmpjars `` ) ; if ( jars==null ) { return null ; } string [ ] file = jar . split ( `` , `` ) ; list < url > cp = new array list < url > ( ) ; for ( string file : file ) { path tmp = new path ( file ) ; if ( tmp . get file system ( conf ) . equal ( file system . get local ( conf ) ) ) { cp . add ( file system . get local ( conf ) . path to file ( tmp ) . to u r i ( ) . to u r l ( ) ) ; } else { log . warn ( `` the libjars file `` + tmp + `` be not on the local `` + `` filesystem . ignoring . `` ) ; } } return cp . to array ( new url [ 0 ] ) ; }
public boolean get load native library ( configuration conf ) { return conf . get boolean ( common configuration key . io_native_lib_available_key , common configuration key . io_native_lib_available_default ) ; }
public static boolean be available ( ) { return native code loader . be native code load ( ) ; }
public static list < method > get declare method include inherit ( class < ? > clazz ) { list < method > method = new array list < method > ( ) ; while ( clazz ! = null ) { for ( method method : clazz . get declare method ( ) ) { method . add ( method ) ; } clazz = clazz . get superclass ( ) ; } return method ; }
public boolean remove shutdown hook ( runnable shutdown hook ) { if ( shutdown in progress . get ( ) ) { throw new illegal state exception ( `` shutdown in progress , can not remove a shutdown hook `` ) ; } return hook . remove ( new hook entry ( shutdown hook , 0 ) ) ; }
public boolean be shutdown in progress ( ) { return shutdown in progress . get ( ) ; }
public stop watch stop ( ) { if ( ! be start ) { throw new illegal state exception ( `` stop watch be already stop `` ) ; } long now = system . nano time ( ) ; be start = false ; current elapse nanos += now - start nanos ; return this ; }
public static void sleep at least ignore interrupt ( long millis ) { long start = time . now ( ) ; while ( time . now ( ) - start < millis ) { long time to sleep = millis - ( time . now ( ) - start ) ; try { thread . sleep ( time to sleep ) ; } catch ( interrupted exception ie ) { log . warn ( `` interrupt while sleep `` , ie ) ; } } }
public static string get revision ( ) { return common_version_info . _get revision ( ) ; }
public static string get src checksum ( ) { return common_version_info . _get src checksum ( ) ; }
public static int remove specific perm ( int perm , int remove ) { return perm ^ remove ; }
public static list < z k auth info > parse auth ( string auth string ) throw bad auth format exception { list < z k auth info > ret = list . new array list ( ) ; if ( auth string == null ) { return ret ; } list < string > auth comp = list . new array list ( splitter . on ( ' , ' ) . omit empty string ( ) . trim result ( ) . split ( auth string ) ) ; for ( string comp : auth comp ) { string part [ ] = comp . split ( `` : `` , 2 ) ; if ( part . length ! = 2 ) { throw new bad auth format exception ( `` auth ' `` + comp + `` ' not of expect form scheme : auth `` ) ; } ret . add ( new z k auth info ( part [ 0 ] , part [ 1 ] . get byte ( charsets . utf_8 ) ) ) ; } return ret ; }
public block reader build ( ) throw i o exception { block reader reader = null ; precondition . check not null ( configuration ) ; if ( conf . short circuit local read & & allow short circuit local read ) { if ( client context . get use legacy block reader local ( ) ) { reader = get legacy block reader local ( ) ; if ( reader ! = null ) { if ( log . be trace enable ( ) ) { log . trace ( this + `` : return new legacy block reader local . `` ) ; } return reader ; } } else { reader = get block reader local ( ) ; if ( reader ! = null ) { if ( log . be trace enable ( ) ) { log . trace ( this + `` : return new block reader local . `` ) ; } return reader ; } } } if ( conf . domain socket data traffic ) { reader = get remote block reader from domain ( ) ; if ( reader ! = null ) { if ( log . be trace enable ( ) ) { log . trace ( this + `` : return new remote block reader use `` + `` unix domain socket on `` + path info . get path ( ) ) ; } return reader ; } } precondition . check state ( ! d f s input stream . tcp read disable for test , `` tcp read be disable for test , but we fail to `` + `` do a non- t c p read . `` ) ; return get remote block reader from tcp ( ) ; }
public void set quota ( path src , long quota ) throw i o exception { dfs . set quota ( src , quota , hdfs constant . quota_dont_set ) ; }
public void set storage policy ( final path src , final string policy name ) throw i o exception { dfs . set storage policy ( src , policy name ) ; }
public extend block get current block ( ) { return get d f s input stream ( ) . get current block ( ) ; }
public static client context get from conf ( configuration conf ) { return get ( conf . get ( d f s config key . dfs_client_context , d f s config key . dfs_client_context_default ) , new d f s client . conf ( conf ) ) ; }
public boolean mark support ( ) { return false ; }
public static boolean be valid name for component ( string component ) { if ( component . equal ( `` . `` ) || component . equal ( `` . . `` ) || component . index of ( `` : `` ) > = 0 || component . index of ( `` / `` ) > = 0 ) { return false ; } return ! be reserve path component ( component ) ; }
public static boolean be reserve path component ( string component ) { for ( string reserve : hdfs constant . reserved_path_components ) { if ( component . equal ( reserve ) ) { return true ; } } return false ; }
public static string add key suffix ( string key , string . . . suffix ) { string key suffix = concat suffix ( suffix ) ; return add suffix ( key , key suffix ) ; }
public static float get percent use ( long use , long capacity ) { return capacity < = 0 ? 100 : ( use * 100 . 0f ) /capacity ; }
public static string date to iso8601 string ( date date ) { simple date format df = new simple date format ( `` yyyy- m m-dd ' t ' h h : mm : s z `` , locale . english ) ; return df . format ( date ) ; }
public boolean recover lease ( final path f ) throw i o exception { path ab f = fix relative part ( f ) ; return new file system link resolver < boolean > ( ) { @ override public boolean do call ( final path p ) throw i o exception , unresolved link exception { return dfs . recover lease ( get path name ( p ) ) ; } @ override public boolean next ( final file system f , final path p ) throw i o exception { if ( fs instanceof distribute file system ) { distribute file system my dfs = ( distribute file system ) f ; return my dfs . recover lease ( p ) ; } throw new unsupported operation exception ( `` can not recover lease through `` + `` a symlink to a non- distribute file system : `` + f + `` - > `` + p ) ; } } . resolve ( this , abs f ) ; }
public disk status get disk status ( ) throw i o exception { return new disk status ( dfs . get disk status ( ) ) ; }
public void refresh node ( ) throw i o exception { dfs . refresh node ( ) ; }
public roll upgrade info roll upgrade ( roll upgrade action action ) throw i o exception { return dfs . roll upgrade ( action ) ; }
public void set balancer bandwidth ( long bandwidth ) throw i o exception { dfs . set balancer bandwidth ( bandwidth ) ; }
public string get canonical service name ( ) { return dfs . get canonical service name ( ) ; }
public static void init ( ) { }
public static block list a longs decode buffer ( final int num block , final byte string block buf ) { return new buffer decoder ( num block , block buf ) ; }
public long get block pool use ( ) { return block pool use ; }
public float get remain percent ( ) { return d f s util . get percent remain ( remain , capacity ) ; }
public int get xceiver count ( ) { return xceiver count ; }
public node get parent ( ) { return parent ; }
public void write ( data output out ) throw i o exception { out . write ( code ) ; }
public boolean be negotiate qop privacy ( ) { string qop = get negotiate qop ( ) ; return qop ! = null & & `` auth-conf `` . equal ignore case ( qop ) ; }
public byte [ ] get last name ( ) { if ( partial listing . length == 0 ) { return null ; } return partial listing [ partial listing . length-1 ] . get local name in byte ( ) ; }
public static int get current layout version ( layout feature [ ] feature ) { return get last non reserve feature ( feature ) . get info ( ) . get layout version ( ) ; }
public inet socket address get address ( ) { inet socket address addr = http server . get connector address ( 0 ) ; assert addr . get port ( ) ! = 0 ; return addr ; }
public byte [ ] retrieve data encryption key ( int key id , byte [ ] nonce ) throw invalid encryption key exception { block key key = null ; synchronize ( this ) { key = all key . get ( key id ) ; if ( key == null ) { throw new invalid encryption key exception ( `` ca n't re-compute encryption key `` + `` for nonce , since the required block key ( key i d= `` + key id + `` ) do n't exist . current key : `` + current key . get key id ( ) ) ; } } return create password ( nonce , key . get key ( ) ) ; }
public synchronize long get token expiry time ( delegation token identifier dt id ) throw i o exception { delegation token information info = current token . get ( dt id ) ; if ( info ! = null ) { return info . get renew date ( ) ; } else { throw new i o exception ( `` no delegation token find for this identifier `` ) ; } }
public void set last allocated block id ( long block id ) { block id generator . skip to ( block id ) ; }
public boolean be legacy block ( block block ) { return block . get generation stamp ( ) < get generation stamp v1 limit ( ) ; }
public void set expect location ( datanode storage info [ ] target ) { int num location = target == null ? 0 : target . length ; this . replicas = new array list < replica under construction > ( num location ) ; for ( int i = 0 ; i < num location ; i++ ) replica . add ( new replica under construction ( this , target [ i ] , replica state . rbw ) ) ; }
public long get remain ( storage type t , long min size ) { long remain = 0 ; for ( datanode storage info s : get storage info ( ) ) { if ( s . get state ( ) == state . normal & & ( t == null || s . get storage type ( ) == t ) ) { long r = s . get remain ( ) ; if ( r > = min size ) { remain += r ; } } } return remain ; }
public int get num stale storage ( ) { return num stale storage ; }
public void reset last caching directive sent time ( ) { synchronize ( datanode map ) { for ( datanode descriptor dn : datanode map . value ( ) ) { dn . set last caching directive sent time m ( 0l ) ; } } }
public synchronize block iterator iterator ( ) { return new block iterator ( ) ; }
public static string get url param ( string name , string val , string param separator ) { return val == null ? `` `` : param separator + name + `` = `` + val ; }
public int get layout version ( ) { return layout version ; }
public static data checksum read data checksum ( file meta file ) throw i o exception { data input stream in = null ; try { in = new data input stream ( new buffer input stream ( new file input stream ( meta file ) , hdfs constant . io_file_buffer_size ) ) ; return read data checksum ( in , meta file ) ; } finally { i o utils . close stream ( in ) ; } }
public static block metadata header pread header ( file channel fc ) throw i o exception { final byte arr [ ] = new byte [ get header size ( ) ] ; byte buffer buf = byte buffer . wrap ( arr ) ; while ( buf . have remain ( ) ) { if ( fc . read ( buf , 0 ) < = 0 ) { throw new e o f exception ( `` unexpected eof while read `` + `` metadata file header `` ) ; } } short version = ( short ) ( ( arr [ 0 ] < < 8 ) | ( arr [ 1 ] & 0xff ) ) ; data checksum data checksum = data checksum . new data checksum ( arr , 2 ) ; return new block metadata header ( version , data checksum ) ; }
public void set roll upgrade marker ( list < storage directory > dn storage dirs ) throw i o exception { for ( storage directory sd : dn storage dirs ) { file bp root = get bp root ( blockpool i d , sd . get current dir ( ) ) ; file marker file = new file ( bp root , rolling_upgrade_marker_file ) ; if ( ! storage with roll upgrade marker . contains ( bp root . to string ( ) ) ) { if ( ! marker file . exists ( ) & & marker file . create new file ( ) ) { log . info ( `` create `` + marker file ) ; } else { log . info ( marker file + `` already exist . `` ) ; } storages with roll upgrade marker . add ( bp root . to string ( ) ) ; storage without roll upgrade marker . remove ( bp root . to string ( ) ) ; } } }
public void clear roll upgrade marker ( list < storage directory > dn storage dirs ) throw i o exception { for ( storage directory sd : dn storage dirs ) { file bp root = get bp root ( blockpool i d , sd . get current dir ( ) ) ; file marker file = new file ( bp root , rolling_upgrade_marker_file ) ; if ( ! storage without roll upgrade marker . contains ( bp root . to string ( ) ) ) { if ( marker file . exists ( ) ) { log . info ( `` delete `` + marker file ) ; do finalize ( sd . get current dir ( ) ) ; if ( ! marker file . delete ( ) ) { log . warn ( `` fail to delete `` + marker file ) ; } } storage without roll upgrade marker . add ( bp root . to string ( ) ) ; storage with roll upgrade marker . remove ( bp root . to string ( ) ) ; } } }
public synchronize void remove all volume scanner ( ) { for ( entry < string , volume scanner > entry : scanner . entry set ( ) ) { entry . get value ( ) . shutdown ( ) ; } for ( entry < string , volume scanner > entry : scanner . entry set ( ) ) { uninterruptibles . join uninterruptibly ( entry . get value ( ) , 5 , time unit . minute ) ; } scanner . clear ( ) ; }
public string [ ] get block pool list ( ) { return bp slice . key set ( ) . to array ( new string [ bp slice . key set ( ) . size ( ) ] ) ; }
public f volume spi get volume ( ) { return volume ; }
public void set recovery i d ( long recovery id ) { if ( recovery id > this . recovery id ) { this . recovery id = recovery id ; } else { throw new illegal argument exception ( `` the new rcovery id : `` + recovery id + `` must be great than the current one : `` + this . recovery id ) ; } }
public static list < acl entry > filter acl entry by acl spec ( list < acl entry > exist acl , list < acl entry > in acl spec ) throw acl exception { validated acl spec acl spec = new validate acl spec ( in acl spec ) ; array list < acl entry > acl builder = list . new array list with capacity ( max_entries ) ; enum map < acl entry scope , acl entry > provide mask = map . new enum map ( acl entry scope . class ) ; enum set < acl entry scope > mask dirty = enum set . none of ( acl entry scope . class ) ; enum set < acl entry scope > scope dirty = enum set . none of ( acl entry scope . class ) ; for ( acl entry exist entry : exist acl ) { if ( acl spec . contains key ( exist entry ) ) { scope dirty . add ( exist entry . get scope ( ) ) ; if ( exist entry . get type ( ) == mask ) { mask dirty . add ( exist entry . get scope ( ) ) ; } } else { if ( exist entry . get type ( ) == mask ) { provide mask . put ( exist entry . get scope ( ) , exist entry ) ; } else { acl builder . add ( exist entry ) ; } } } copy default if need ( acl builder ) ; calculate mask ( acl builder , provide mask , mask dirty , scope dirty ) ; return build and validate acl ( acl builder ) ; }
public list < datanode descriptor > get datanodes ( type type ) { list < datanode descriptor > nod = new link list < datanode descriptor > ( ) ; for ( int i = 0 ; i < triplet . length ; i += 3 ) { cached block list list = ( cache block list ) triplets [ i ] ; if ( ( type == null ) || ( list . get type ( ) == type ) ) { node . add ( list . get datanode ( ) ) ; } } return node ; }
public void create ( int layout version ) throw i o exception { assert double buf . be flush ( ) : `` previous data be not flush yet `` ; this . double buf = new edits double buffer ( default_buffer_size ) ; }
public final void add to inode map ( i node inode ) { if ( inode instanceof i node with additional field ) { inode map . put ( inode ) ; if ( ! inode . be symlink ( ) ) { final x attr feature xaf = inode . get x attr feature ( ) ; add encryption zone ( ( i node with additional field ) inode , xaf ) ; } } }
public i node get inode ( long id ) { read lock ( ) ; try { return inode map . get ( id ) ; } finally { read unlock ( ) ; } }
public synchronize long get sync tx id ( ) { return synctxid ; }
public void check superuser privilege ( ) throw access control exception { if ( ! be super user ( ) ) { throw new access control exception ( `` access deny for user `` + get user ( ) + `` . superuser privilege be require `` ) ; } }
public boolean use logical u r i ( ) { return false ; }
public final string buffer dump tree recursively ( ) { final string writer out = new string writer ( ) ; dump tree recursively ( new print writer ( out , true ) , new string builder ( ) , snapshot . current_state_id ) ; return out . get buffer ( ) ; }
public final long compute file size not include last uc block ( ) { return compute file size ( false , false ) ; }
public final long storagespace consume ( ) { return storagespace consume no replication ( ) * get block replication ( ) ; }
public static int try remove reference ( i node inode ) { if ( ! inode . be reference ( ) ) { return -1 ; } return remove reference ( inode . a reference ( ) ) ; }
public int get late snapshot id ( ) { precondition . check state ( ! be snapshot ) ; return snapshot id ; }
public final i node update modification time ( long mtime , int late snapshot id ) { precondition . check state ( be directory ( ) ) ; if ( mtime < = modification time ) { return this ; } return set modification time ( mtime , late snapshot id ) ; }
public boolean have available disk space ( ) { return name node resource policy . be resource available ( volume . value ( ) , minimum redundant volume ) ; }
public long get elapsed time ( phase phase , step step ) { return get elapsed time ( get step track ( phase , step ) ) ; }
public long get total ( phase phase ) { long sum = 0 ; for ( step track tracking : phase . get ( phase ) . step . value ( ) ) { if ( track . total ! = long . min_value ) { sum += track . total ; } } return sum ; }
public step type get type ( ) { return type ; }
public long get balancer bandwidth value ( ) { return this . bandwidth ; }
public void add ( recover block block ) { recover block . add ( block ) ; }
public boolean need to return image ( ) { return need to return image ; }
public static string generate uuid ( ) { return storage_id_prefix + uuid . random u u i d ( ) ; }
public long get last volume failure date ( ) { return this . last volume failure date ; }
public void close ( ) { if ( replica ! = null ) { if ( anchor ) { replica . remove no checksum anchor ( ) ; } replica . unref ( ) ; } replica = null ; }
public synchronize boolean be disconnect ( ) { return disconnect ; }
synchronize public final slot register slot ( int slot idx , extend block id block id ) throw invalid request exception { if ( slot idx < 0 ) { throw new invalid request exception ( this + `` : invalid negative slot `` + `` index `` + slot idx ) ; } if ( slot idx > = slot . length ) { throw new invalid request exception ( this + `` : invalid slot `` + `` index `` + slot idx ) ; } if ( allocated slot . get ( slot idx ) ) { throw new invalid request exception ( this + `` : slot `` + slot idx + `` be already in use . `` ) ; } slot slot = new slot ( calculate slot address ( slot idx ) , block id ) ; if ( ! slot . be valid ( ) ) { throw new invalid request exception ( this + `` : slot `` + slot idx + `` be not mark a valid . `` ) ; } slot [ slot idx ] = slot ; allocate slot . set ( slot idx , true ) ; if ( log . be trace enable ( ) ) { log . trace ( this + `` : register slot `` + slot idx + `` : allocate slots= `` + allocated slot + string utils . get stack trace ( thread . current thread ( ) ) ) ; } return slot ; }
public int restore fail storage ( string arg ) throw i o exception { int exit code = -1 ; if ( ! arg . equal ( `` check `` ) & & ! arg . equal ( `` true `` ) & & ! arg . equal ( `` false `` ) ) { system . err . println ( `` restore failed storage valid args be true|false|check `` ) ; return exit code ; } distribute file system dfs = get d f s ( ) ; configuration dfs conf = dfs . get conf ( ) ; uri dfs uri = dfs . get uri ( ) ; boolean be ha enabled = h a util . be logical uri ( dfs conf , dfs uri ) ; if ( be ha enable ) { string ns id = dfs uri . get host ( ) ; list < proxy and info < client protocol > > proxy = h a util . get proxy for all name node in nameservice ( dfs conf , ns id , client protocol . class ) ; for ( proxy and info < client protocol > proxy : proxy ) { boolean re = proxy . get proxy ( ) . restore failed storage ( arg ) ; system . out . println ( `` restore failed storage be set to `` + re + `` for `` + proxy . get address ( ) ) ; } } else { boolean re = dfs . restore failed storage ( arg ) ; system . out . println ( `` restore failed storage be set to `` + re ) ; } exit code = 0 ; return exit code ; }
public void go ( ) throw i o exception { data input stream in = null ; position track input stream tracker = null ; image loader fsip = null ; boolean do = false ; try { tracker = new position track input stream ( new buffer input stream ( new file input stream ( new file ( input file ) ) ) ) ; in = new data input stream ( tracker ) ; int image version file = find image version ( in ) ; fsip = image loader . loader factory . get loader ( image version file ) ; if ( fsip == null ) throw new i o exception ( `` no image processor to read version `` + image version file + `` be available . `` ) ; fsip . load image ( in , processor , skip block ) ; do = true ; } finally { if ( ! do ) { log . error ( `` image loading fail at offset `` + tracker . get pos ( ) ) ; } i o utils . cleanup ( log , in , tracker ) ; } }
public list < e > apply2 previous ( final list < e > previous ) { return apply2 previous ( previous , get list ( list type . create ) , get list ( list type . delete ) ) ; }
public final void set ( final e e , final double value ) { double [ e . ordinal ( ) ] = value ; }
public final void add ( final enum double < e > that ) { for ( int i = 0 ; i < double . length ; i++ ) { this . double [ i ] += that . double [ i ] ; } }
public boolean add ( final t element ) { boolean add = add elem ( element ) ; expand if necessary ( ) ; return add ; }
public list < t > poll all ( ) { list < t > ret list = new array list < t > ( size ) ; for ( int i = 0 ; i < entry . length ; i++ ) { link element < t > current = entry [ i ] ; while ( current ! = null ) { ret list . add ( current . element ) ; current = current . next ; } } this . clear ( ) ; return ret list ; }
protect void shrink if necessary ( ) { if ( size < this . shrink threshold & & capacity > initial capacity ) { resize ( capacity / expand multiplier ) ; } }
public long retrieve ( long record ) { return ( record & mask ) > > > offset ; }
public e put ( e key ) { e value = reference map . get ( key ) ; if ( value == null ) { value = key ; reference map . put ( key , value ) ; } value . increment and get ref count ( ) ; return value ; }
public long get reference count ( e key ) { reference counter counter = reference map . get ( key ) ; if ( counter ! = null ) { return counter . get ref count ( ) ; } return 0 ; }
protect url get namenode u r l ( string path , string query ) throw i o exception { final url url = new url ( get underlie protocol ( ) , nn uri . get host ( ) , nn uri . get port ( ) , path + ' ? ' + query ) ; if ( log . be trace enable ( ) ) { log . trace ( `` url= `` + url ) ; } return url ; }
protect string get transport scheme ( ) { return `` http `` ; }
public static string get prefix name ( x attr x attr ) { if ( x attr == null ) { return null ; } string namespace = x attr . get name space ( ) . to string ( ) ; return string utils . to lower case ( namespace ) + `` . `` + x attr . get name ( ) ; }
public path get output file ( ) throw i o exception { path attempt output = new path ( get attempt output dir ( ) , map_output_filename_string ) ; return l dir alloc . get local path to read ( attempt output . to string ( ) , conf ) ; }
public path get output index file for write ( long size ) throw i o exception { path attempt index output = new path ( get attempt output dir ( ) , map_output_filename_string + map_output_index_suffix_string ) ; return l dir alloc . get local path for write ( attempt index output . to string ( ) , size , conf ) ; }
public path get output index file for write in volume ( path exist ) { path output dir = new path ( exist . get parent ( ) , job_output_dir ) ; path attempt output dir = new path ( output dir , conf . get ( job context . task_attempt_id ) ) ; return new path ( attempt output dir , map_output_filename_string + map_output_index_suffix_string ) ; }
public path get spill file ( int spill number ) throw i o exception { return l dir alloc . get local path to read ( string . format ( spill_file_pattern , conf . get ( job context . task_attempt_id ) , spill number ) , conf ) ; }
public string get node rack name ( ) { this . read lock . lock ( ) ; try { return this . node rack name ; } finally { this . read lock . unlock ( ) ; } }
public void cleanup stag dir ( ) throw i o exception { / * make sure we clean the staging file * / string job temp dir = null ; file system fs = get file system ( get config ( ) ) ; try { if ( ! keep job file ( new job conf ( get config ( ) ) ) ) { job temp dir = get config ( ) . get ( m r job config . mapreduce_job_dir ) ; if ( job temp dir == null ) { log . warn ( `` job stag directory be null `` ) ; return ; } path job temp dir path = new path ( job temp dir ) ; log . info ( `` delete stag directory `` + file system . get default uri ( get config ( ) ) + `` `` + job temp dir ) ; f . delete ( job temp dir path , true ) ; } } catch ( i o exception io ) { log . error ( `` fail to cleanup stag dir `` + job temp dir , io ) ; } }
public void task counter ( ) { try { require task ( ) ; } catch ( exception e ) { render text ( e . get message ( ) ) ; return ; } if ( app . get task ( ) ! = null ) { set title ( string helper . join ( `` counter for `` , $ ( task_id ) ) ) ; } render ( counter page ( ) ) ; }
public void single job counter ( ) throw i o exception { try { require job ( ) ; } catch ( exception e ) { render text ( e . get message ( ) ) ; return ; } set ( counter_group , u r l decoder . decode ( $ ( counter_group ) , `` utf-8 `` ) ) ; set ( counter_name , u r l decoder . decode ( $ ( counter_name ) , `` utf-8 `` ) ) ; if ( app . get job ( ) ! = null ) { set title ( string helper . join ( $ ( counter_group ) , `` `` , $ ( counter_name ) , `` for `` , $ ( job_id ) ) ) ; } render ( single counter page ( ) ) ; }
public static path filter get history file filter ( ) { return job_history_file_filter ; }
public static string get configured history server do dir prefix ( configuration conf ) { string do dir prefix = conf . get ( j h admin config . mr_history_done_dir ) ; if ( do dir prefix == null ) { do dir prefix = conf . get ( m r job config . mr_am_staging_dir , m r job config . default_mr_am_staging_dir ) + `` /history/done `` ; } return ensure path in default file system ( do dir prefix , conf ) ; }
public static void set local file ( configuration conf , string str ) { conf . set ( cache_localfiles , str ) ; }
public int get reduce task ( ) { return reduce_tasks ; }
public job tracker status get job tracker status ( ) { return status ; }
protect boolean be splitable ( file system f , path filename ) { return true ; }
public static boolean get compress output ( job conf conf ) { return conf . get boolean ( org . apache . hadoop . mapreduce . lib . output . file output format . compress , false ) ; }
public void finish ( ) throw i o exception { if ( finish ) { return ; } finish = true ; sum . write value ( barray , 0 , false ) ; out . write ( barray , 0 , sum . get checksum size ( ) ) ; out . flush ( ) ; }
public list < i o exception > get problem ( ) { return problem ; }
public credential get credential ( ) { return credential ; }
public void set jar ( string jar ) { set ( job context . jar , jar ) ; }
public void set jar by class ( class cl ) { string jar = class util . find containing jar ( cl ) ; if ( jar ! = null ) { set jar ( jar ) ; } }
public void delete local file ( ) throw i o exception { string [ ] local dirs = get local dirs ( ) ; for ( int i = 0 ; i < local dirs . length ; i++ ) { file system . get local ( this ) . delete ( new path ( local dirs [ i ] ) , true ) ; } }
public void set keep task file pattern ( string pattern ) { set ( job context . preserve_files_pattern , pattern ) ; }
public void set use new mapper ( boolean flag ) { set boolean ( `` mapred . mapper . new-api `` , flag ) ; }
public void set map debug script ( string m dbg script ) { set ( job context . map_debug_script , m dbg script ) ; }
public long get max virtual memory for task ( ) { log . warn ( `` get max virtual memory for task ( ) be deprecate . `` + `` instead use get memory for map task ( ) and get memory for reduce task ( ) `` ) ; long value = get long ( mapred_task_maxvmem_property , math . max ( get memory for map task ( ) , get memory for reduce task ( ) ) * 1024 * 1024 ) ; return value ; }
public synchronize void set job conf ( job conf job conf ) { try { super . set job ( org . apache . hadoop . mapreduce . job . get instance ( job conf ) ) ; } catch ( i o exception ioe ) { log . info ( `` exception `` + ioe ) ; } }
public input split [ ] get split ( job conf job , int num split ) throw i o exception { set format ( job ) ; job . set long ( `` mapred . min . split . size `` , long . max_value ) ; return root . get split ( job , num split ) ; }
public long get length ( ) throw i o exception { return totsize ; }
protect writable comparator get comparator ( ) { return cmp ; }
protect resetable iterator < tuple writable > get delegate ( ) { return new join delegation iterator ( ) ; }
protect boolean next ( ) throw i o exception { empty = ! rr . next ( khead , vhead ) ; return have next ( ) ; }
public float get progress ( ) throw i o exception { return math . min ( 1 . 0f , progress/ ( float ) ( split . get length ( ) ) ) ; }
public static void set input ( job conf job , class < ? extend d b writable > input class , string table name , string condition , string order by , string . . . field names ) { job . set input format ( d b input format . class ) ; d b configuration db conf = new d b configuration ( job ) ; db conf . set input class ( input class ) ; db conf . set input table name ( table name ) ; db conf . set input field name ( field names ) ; db conf . set input condition ( condition ) ; db conf . set input order by ( order by ) ; }
protect k generate actual key ( k key , v value ) { return key ; }
public static void set counter enable ( job conf conf , boolean enable ) { conf . set boolean ( counters_enabled , enable ) ; }
public void recover task ( task attempt context task context ) throw i o exception { }
public void progress ( float progress ) throw i o exception { progress value = progress ; reporter . progress ( ) ; if ( record reader ! = null ) { progress key . set ( progress ) ; record reader . next ( progress key , null value ) ; } }
public void do ( ) throw i o exception { synchronize ( this ) { do = true ; notify ( ) ; } }
public static void set keep command file ( job conf conf , boolean keep ) { conf . set boolean ( submitter . preserve_commandfile , keep ) ; }
public static void main ( string [ ] args ) throw exception { int exit code = new submitter ( ) . run ( args ) ; exit util . terminate ( exit code ) ; }
public static void set skip output path ( job conf conf , path path ) { string path str = null ; if ( path==null ) { path str = `` none `` ; } else { path str = path . to string ( ) ; } conf . set ( out_path , path str ) ; }
public static long get reducer max skip group ( configuration conf ) { return conf . get long ( reducer_max_skip_groups , 0 ) ; }
public synchronize task status . phase get phase ( ) { return this . task status . get phase ( ) ; }
protect void report fatal error ( task attempt i d id , throwable throwable , string log msg ) { log . fatal ( log msg ) ; if ( shutdown hook manager . get ( ) . be shutdown in progress ( ) ) { return ; } throwable t cause = throwable . get cause ( ) ; string cause = t cause == null ? string utils . stringify exception ( throwable ) : string utils . stringify exception ( t cause ) ; try { umbilical . fatal error ( id , cause ) ; } catch ( i o exception ioe ) { log . fatal ( `` fail to contact the tasktracker `` , ioe ) ; system . exit ( -1 ) ; } }
public task attempt i d get task attempt i d ( ) { return ( task attempt i d ) super . get task attempt i d ( ) ; }
protect void set finish time ( long finish time ) { super . set finish time ( finish time ) ; }
public long get sort finish time ( ) { return 0 ; }
public void set counter ( counter counter ) { this . counter = counter ; }
public int get id ( ) { return id ; }
public void set cancel delegation token upon job completion ( boolean value ) { ensure state ( job state . define ) ; conf . set boolean ( job_cancel_delegation_token , value ) ; }
public static task status filter get task output filter ( configuration conf ) { return task status filter . value of ( conf . get ( job . output_filter , `` fail `` ) ) ; }
public int get total map ( ) { return datum . total map ; }
public string get diagnostics ( ) { final char sequence diagnostics = datum . get diagnostics ( ) ; return diagnostics == null ? nodiags : diagnostics . to string ( ) ; }
public string get task status ( ) { return task status . to string ( ) ; }
public event type get event type ( ) { return event type . task_finished ; }
protect synchronized void set retire ( ) { this . be retired = true ; }
public long [ ] get lengths ( ) { return length ; }
public static void set min input split size ( job job , long size ) { job . get configuration ( ) . set long ( split_minsize , size ) ; }
public path get commit task path ( task attempt context context ) { return get commit task path ( get app attempt id ( context ) , context ) ; }
public static string hash from string ( string enc_str , secret key key ) throw i o exception { return generate hash ( enc_str . get byte ( charsets . utf_8 ) , key ) ; }
public static string build msg from ( url url ) { return build msg from ( url . get path ( ) , url . get query ( ) , url . get port ( ) ) ; }
public text get job id ( ) { return jobid ; }
public byte [ ] create password ( job token identifier identifier ) { byte [ ] result = create password ( identifier . get byte ( ) , master key ) ; return result ; }
public int get max reduce attempt ( ) { return conf . get max reduce attempt ( ) ; }
public boolean be map ( ) { return task id . be map ( ) ; }
public task type get task type ( ) { return task id . get task type ( ) ; }
protect string builder append to ( string builder builder ) { return task id . append to ( builder ) . append ( separator ) . append ( id ) ; }
public string get state ( ) { return state ; }
public long get finish time ( ) { return finish time ; }
protect static void destroy process group ( string pgrp id , long sleeptime before sigkill , boolean in background ) { terminate process group ( pgrp id ) ; sig kill ( pgrp id , true , sleeptime before sigkill , in background ) ; }
public static void terminate process ( string pid ) { maybe signal process ( pid , sigterm , sigterm_str , true ) ; }
public void set id ( string id ) { this . id = id ; }
public void set entity ( list < timeline entity > entity ) { this . entity = entity ; }
public void set domain id ( string domain id ) { this . domain id = domain id ; }
protect path get recovery path ( ) { return recovery path ; }
public void initialize container ( container initialization context init container context ) { }
public void set recovery path ( path recovery path ) { this . recovery path = recovery path ; }
public void wait for ( supplier < boolean > check , int check every millis ) throw interrupted exception { wait for ( check , check every millis , 1 ) ; }
public void remove container request ( t req ) { client . remove container request ( req ) ; }
public static yarn client create yarn client ( ) { yarn client client = new yarn client impl ( ) ; return client ; }
public static path get remote app log dir ( path remote root log dir , application id app id , string user , string suffix ) { return new path ( get remote log suffix dir ( remote root log dir , user , suffix ) , app id . to string ( ) ) ; }
public static string djoin ( object . . . args ) { return dot_joiner . join ( args ) ; }
public static http server2 . builder load ssl configuration ( http server2 . builder builder ) { return load ssl configuration ( builder , null ) ; }
protect void pre head ( page . html < _ > html ) { }
public long get low discernible value ( ) { return low discernible value ; }
public long get high trackable value ( ) { return high trackable value ; }
public long high equivalent value ( final long value ) { return next non equivalent value ( value ) - 1 ; }
public long get max value ( ) { return ( max value == 0 ) ? 0 : high equivalent value ( max value ) ; }
public double get percentile at or below value ( final long value ) { if ( get total count ( ) == 0 ) { return 100 . 0 ; } final int target index = math . min ( count array index ( value ) , ( count array length - 1 ) ) ; long total to current index = 0 ; for ( int i = 0 ; i < = target index ; i++ ) { total to current index += get count at index ( i ) ; } return ( 100 . 0 * total to current index ) / get total count ( ) ; }
public long get count between value ( final long low value , final long high value ) throw array index out of bound exception { final int low index = math . max ( 0 , count array index ( low value ) ) ; final int high index = math . min ( count array index ( high value ) , ( count array length - 1 ) ) ; long count = 0 ; for ( int i = low index ; i < = high index ; i++ ) { count += get count at index ( i ) ; } return count ; }
public long get count at value ( final long value ) throw array index out of bound exception { final int index = math . min ( math . max ( 0 , count array index ( value ) ) , ( count array length - 1 ) ) ; return get count at index ( index ) ; }
public double histogram copy correct for coordinated omission ( final double expect interval between value sample ) { final double histogram target histogram = new double histogram ( configured high to lowest value ratio , get number of significant value digit ( ) ) ; target histogram . set trackable value range ( current low value in auto range , current high value limit in auto range ) ; target histogram . add while correct for coordinate omission ( this , expect interval between value sample ) ; return target histogram ; }
public void increment ( final int index ) throw array index out of bound exception { long critical value at enter = record phaser . writer critical section enter ( ) ; try { active array . increment ( index ) ; } finally { record phaser . writer critical section exit ( critical value at enter ) ; } }
public void writer critical section exit ( long critical value at enter ) { ( critical value at enter < 0 ? odd end epoch updater : even end epoch updater ) . get and increment ( this ) ; }
public boolean be quote ( ) { return be quote ; }
public static logical expression or ( criterion lh , criterion rh ) { return new logical expression ( lhs , rhs , `` or `` ) ; }
public static blob generate proxy ( byte [ ] bytes ) { return ( blob ) proxy . new proxy instance ( get proxy class loader ( ) , proxy_interfaces , new blob proxy ( byte ) ) ; }
public void add subselect ( entity key key , subselect fetch subquery ) { subselects by entity key . put ( key , subquery ) ; }
public database structure get database structure ( ) { return database structure ; }
public void after operation ( boolean success ) { if ( ! be transaction in progress ( ) ) { get jdbc coordinator ( ) . after transaction ( ) ; } }
public boolean be always dirty checked ( ) { return true ; }
public static string get version string ( ) { if ( version == null ) { version = version . class . get package ( ) . get implementation version ( ) ; if ( version == null ) { version = `` [ work ] `` ; } } return version ; }
public static fetch type from xml ( string name ) { return fetch type . value of ( name ) ; }
public static generation type from xml ( string name ) { return generation type . value of ( name ) ; }
public void set join table ( jaxb join table value ) { this . join table = value ; }
public void set embed id ( jaxb embed id value ) { this . embed id = value ; }
public list < jaxb transient > get transient ( ) { if ( _transient == null ) { _transient = new array list < jaxb transient > ( ) ; } return this . _transient ; }
public void set enumerate ( enum type value ) { this . enumerate = value ; }
public jaxb empty type get cascade all ( ) { return cascade all ; }
public void set cascade all ( jaxb empty type value ) { this . cascade all = value ; }
public jaxb empty type get cascade remove ( ) { return cascade remove ; }
public boolean be disable conversion ( ) { return disable conversion ; }
public void set discriminator type ( discriminator type value ) { this . discriminator type = value ; }
public list < jaxb convert > get map key convert ( ) { if ( map key convert == null ) { map key convert = new array list < jaxb convert > ( ) ; } return this . map key convert ; }
public void set table generator ( jaxb table generator value ) { this . table generator = value ; }
public void set post persist ( jaxb post persist value ) { this . post persist = value ; }
public jaxb post update get post update ( ) { return post update ; }
public list < jaxb name entity graph > get name entity graph ( ) { if ( name entity graph == null ) { name entity graph = new array list < jaxb name entity graph > ( ) ; } return this . name entity graph ; }
public list < jaxb field result > get field result ( ) { if ( field result == null ) { field result = new array list < jaxb field result > ( ) ; } return this . field result ; }
public constraint mode get constraint mode ( ) { return constraint mode ; }
public string get map id ( ) { return map id ; }
public void set include all attribute ( boolean value ) { this . include all attribute = value ; }
public void set result set mapping ( string value ) { this . result set mapping = value ; }
public list < jaxb constructor result > get constructor result ( ) { if ( constructor result == null ) { constructor result = new array list < jaxb constructor result > ( ) ; } return this . constructor result ; }
public boolean match resolution info ( dialect resolution info info ) { return product name match ( info . get database name ( ) ) ; }
public boolean match url ( string jdbc url ) { return jdbc url . to lower case ( ) . start with ( get url prefix ( ) ) ; }
public static void stddev ( query engine query engine ) { query engine . get sqm function registry ( ) . name aggregate descriptor builder ( `` stddev `` ) . set invariant type ( query engine . get type configuration ( ) . get basic type registry ( ) . resolve ( standard basic type . double ) ) . set exact argument count ( 1 ) . register ( ) ; }
public static void format_to varchar ( query engine query engine ) { query engine . get sqm function registry ( ) . name descriptor builder ( `` format `` , `` to_varchar `` ) . set invariant type ( query engine . get type configuration ( ) . get basic type registry ( ) . resolve ( standard basic type . string ) ) . set exact argument count ( 2 ) . set argument list signature ( `` ( datetime a pattern ) `` ) . register ( ) ; }
protect static string insert after select ( string limit offset clause , string sql statement ) { matcher select matcher = select_pattern . matcher ( sql statement ) ; if ( select matcher . find ( ) ) { return new string builder ( sql statement ) . insert ( select matcher . end ( ) , limit offset clause ) . to string ( ) ; } else { return sql statement ; } }
public void put ( int type code , long capacity , string value ) { weight . compute if absent ( type code , k - > new tree map < > ( ) ) . put ( capacity , value ) ; }
public pattern function descriptor builder pattern descriptor builder ( string registration key , string pattern ) { return new pattern function descriptor builder ( this , registration key , function kind . normal , pattern ) ; }
public sqm function descriptor register name ( string name ) { return name descriptor builder ( name ) . register ( ) ; }
public sqm expression < ? > get right hand operand ( ) { return rh operand ; }
public < x > x accept ( semantic query walker < x > walker ) { throw new unsupported operation exception ( `` direct semantic query walker visitation of a sqm jpa criterion parameter wrapper `` + `` be not support . visitation for a criterion parameter should be handle `` + `` during ` semantic query walker # visit jpa criterion parameter ` . this wrapper be `` + `` intend only for represent unique sqm parameter node for each criterion `` + `` parameter in the sqm tree a part of the query parameter - > sqm parameter - > jdbc parameter `` + `` transformation . each occurrence require a unique sqm parameter to make sure we `` + `` ultimately get the complete set of jdbc parameter reference `` ) ; }
public boolean be root ( ) { return be root ; }
public < j > basic type < j > resolve ( java type < j > jtd to use , jdbc type std to use ) { return resolve ( jtd to use , std to use , ( ) - > new basic type impl < > ( jtd to use , std to use ) ) ; }
public byte to byte ( t domain form ) { if ( domain form == null ) { return null ; } return ( byte ) domain form . ordinal ( ) ; }
public void add group conversion ( class < ? > from , class < ? > to ) { group conversion . put ( from , to ) ; }
public boolean be valid ( collection collection , constraint validator context constraint validator context ) { if ( collection == null ) { return true ; } int length = collection . size ( ) ; return length > = min & & length < = max ; }
public void replace current interpolation term ( string replacement ) { token token = new token ( replacement ) ; token . terminate ( ) ; token list . set ( current position - 1 , token ) ; }
public boolean have parameter constraint ( ) { return have parameter constraint ; }
public static int calculate mod10 check ( final list < integer > digit , int multiplier , int weight ) { int sum = 0 ; boolean even = true ; for ( int index = digit . size ( ) - 1 ; index > = 0 ; index -- ) { int digit = digits . get ( index ) ; if ( even ) { digit * = multiplier ; } else { digit * = weight ; } sum += digit ; even = ! even ; } return ( 10 - ( sum % 10 ) ) % 10 ; }
public static type box type ( type type ) { if ( type instanceof class & & ( ( class < ? > ) type ) . be primitive ( ) ) { return internal boxed type ( ( class < ? > ) type ) ; } else { return type ; } }
public static boolean be null or empty string ( string value ) { return value == null || value . trim ( ) . be empty ( ) ; }
public void requite ( final t bag entry ) { bag entry . set state ( state_not_in_use ) ; final list < object > thread local list = thread list . get ( ) ; if ( thread local list ! = null ) { thread local list . add ( weak thread local ? new weak reference < > ( bag entry ) : bag entry ) ; } synchronizer . signal ( ) ; }
public boolean reserve ( final t bag entry ) { return bag entry . compare and set ( state_not_in_use , state_reserved ) ; }
public string get schema ( ) { return schema ; }
public void set schema ( string schema ) { check if seal ( ) ; this . schema = schema ; }
public int buffer index of ( byte e1 ) { final int last = tail ; final int buf len = buffer . length ; for ( int i = head ; i ! = last ; i = one right ( i , buf len ) ) { if ( ( ( buffer [ i ] ) == ( e1 ) ) ) { return i ; } } return -1 ; }
public int last buffer index of ( byte e1 ) { final int buf len = buffer . length ; final int last = one left ( head , buf len ) ; for ( int i = one left ( tail , buf len ) ; i ! = last ; i = one left ( i , buf len ) ) { if ( ( ( buffer [ i ] ) == ( e1 ) ) ) return i ; } return -1 ; }
public iterator < byte cursor > iterator ( ) { return new value iterator ( ) ; }
public iterator < byte cursor > descend iterator ( ) { return new descend value iterator ( ) ; }
public void add ( byte [ ] element , int start , int length ) { assert length > = 0 : `` length must be > = 0 `` ; ensure buffer space ( length ) ; system . arraycopy ( element , start , buffer , element count , length ) ; element count += length ; }
public final void add ( byte . . . element ) { add ( element , 0 , element . length ) ; }
public void release ( ) { this . buffer = empty_array ; this . element count = 0 ; }
protect boolean equal element ( char byte hash map other ) { if ( other . size ( ) ! = size ( ) ) { return false ; } for ( char byte cursor c : other ) { char key = c . key ; if ( ! contains key ( key ) || ! ( ( get ( key ) ) == ( c . value ) ) ) { return false ; } } return true ; }
public char index replace ( int index , char equivalent key ) { assert index > = 0 : `` the index must point at an exist key . `` ; assert index < = mask || ( index == mask + 1 & & have empty key ) ; assert ( ( equivalent key ) == ( key [ index ] ) ) ; char previous value = key [ index ] ; key [ index ] = equivalent key ; return previous value ; }
public void push ( double e1 ) { ensure buffer space ( 1 ) ; buffer [ element count++ ] = e1 ; }
public void push ( double e1 , double e2 , double e3 , double e4 ) { ensure buffer space ( 4 ) ; buffer [ element count++ ] = e1 ; buffer [ element count++ ] = e2 ; buffer [ element count++ ] = e3 ; buffer [ element count++ ] = e4 ; }
public void push ( float e1 , float e2 ) { ensure buffer space ( 2 ) ; buffer [ element count++ ] = e1 ; buffer [ element count++ ] = e2 ; }
public document fragment parse fragment ( input source be , string context ) throw i o exception , s a x exception { tree builder . set fragment context ( context . intern ( ) ) ; tokenize ( be ) ; return tree builder . get document fragment ( ) ; }
public boolean be check normalization ( ) { return check normalization ; }
public xml violation policy get content non xml char policy ( ) { return content non xml char policy ; }
public xml violation policy get content space policy ( ) { return content space policy ; }
public boolean be next char on new line ( ) { return next char on new line ; }
public string get public id ( ) { return public id ; }
public boolean have more ( ) { return start < end ; }
public void set check normalization ( boolean enable ) { if ( enable ) { if ( be check normalization ( ) ) { return ; } else { normalization checker normalization checker = new normalization checker ( tokenizer ) ; normalization checker . set error handler ( tokenizer . get error handler ( ) ) ; } } else { if ( be check normalization ( ) ) { character handler [ ] new handler = new character handler [ character handler . length - 1 ] ; boolean skip = false ; int j = 0 ; for ( int i = 0 ; i < character handler . length ; i++ ) { character handler ch = character handler [ i ] ; if ( ! ( ! skip & & ( ch instanceof normalization checker ) ) ) { new handler [ j ] = ch ; j++ ; } } character handler = new handler ; } else { return ; } } }
public string get uri ( ) { return uri ; }
public static runnable wrap ( runnable runnable ) { if ( be trace ( ) ) { return new trace runnable ( trace . current span ( ) , runnable ) ; } else { return runnable ; } }
public span detach ( ) { detached = true ; span cur = tracer . get instance ( ) . current span ( ) ; if ( cur ! = span ) { tracer . log . debug ( `` closing trace span `` + span + `` but `` + cur + `` be top-of-stack `` ) ; } else { tracer . get instance ( ) . set current span ( save span ) ; } return span ; }
public byte [ ] get byte ( ) { int size = 0 ; for ( int i = 0 ; i < classic list . size ( ) ; i++ ) { size += classic list . get ( i ) . length ; } byte [ ] ret = new byte [ size ] ; int temp size = 0 ; for ( int i = 0 ; i < classic list . size ( ) ; i++ ) { system . arraycopy ( classic list . get ( i ) , 0 , ret , temp size , classic list . get ( i ) . length ) ; temp size += classic list . get ( i ) . length ; } return ret ; }
public date get request date ( ) { return request date ; }
public synchronize void put entry ( final string url , final http cache entry entry ) throw i o exception { entry . put ( url , entry ) ; }
public void set heuristic caching enable ( final boolean heuristic caching enable ) { this . heuristic caching enable = heuristic caching enable ; }
public void set share cache ( final boolean be share cache ) { this . be share cache = be share cache ; }
public void flush invalidate cache entry ( final http host host , final http request req ) { final string the uri = cache key generator . get u r i ( host , req ) ; final http cache entry parent = get entry ( the uri ) ; if ( request should not be cache ( req ) || should invalidate head cache entry ( req , parent ) ) { log . debug ( `` invalidate parent cache entry : `` + parent ) ; if ( parent ! = null ) { for ( final string variant u r i : parent . get variant map ( ) . value ( ) ) { flush entry ( variant u r i ) ; } flush entry ( the uri ) ; } final url req u r l = get absolute u r l ( the uri ) ; if ( req u r l == null ) { log . error ( `` could n't transform request into valid url `` ) ; return ; } final header cl hdr = req . get first header ( `` content- location `` ) ; if ( cl hdr ! = null ) { final string content location = cl hdr . get value ( ) ; if ( ! flush absolute uri from same host ( req u r l , content location ) ) { flush relative uri from same host ( req u r l , content location ) ; } } final header l hdr = req . get first header ( `` location `` ) ; if ( l hdr ! = null ) { flush absolute uri from same host ( req u r l , l hdr . get value ( ) ) ; } } }
public long get cache miss ( ) { return cache miss . get ( ) ; }
public http request wrapper build unconditional request ( final http request wrapper request , final http cache entry entry ) { final http request wrapper new request = http request wrapper . wrap ( request . get original ( ) ) ; new request . set header ( request . get all header ( ) ) ; new request . add header ( header constant . cache_control , header constant . cache_control_no_cache ) ; new request . add header ( header constant . pragma , header constant . cache_control_no_cache ) ; new request . remove header ( header constant . if_range ) ; new request . remove header ( header constant . if_match ) ; new request . remove header ( header constant . if_none_match ) ; new request . remove header ( header constant . if_unmodified_since ) ; new request . remove header ( header constant . if_modified_since ) ; return new request ; }
public boolean be response thread pool reject ( ) { return get command result ( ) . be response thread pool reject ( ) ; }
public boolean be response reject ( ) { return get command result ( ) . be response reject ( ) ; }
public list < hystrix event type > get execution event ( ) { return get command result ( ) . get ordered list ( ) ; }
public int get number fallback emission ( ) { return get command result ( ) . get event count ( ) . get count ( hystrix event type . fallback_emit ) ; }
public void set response ( t response ) { if ( ! be terminate ( ) ) { subject . on next ( response ) ; value set . set ( true ) ; subject . on complete ( ) ; } else { throw new illegal state exception ( `` response have already terminate so response can not be set : `` + response ) ; } }
public hystrix property < boolean > execution timeout enable ( ) { return execution timeout enable ; }
public object do interruptable application ( proceed join point proceed join point / * , interruptable application interruptable application * / ) throw throwable { return interruptable invocation type . application . wrap ( proceed join point ) ; }
public static < t > t a facet ( class < t > facet type , faceted subject ) { return subject == null ? null : subject . a facet ( facet type ) ; }
public int remain ( ) { return current . remain ( ) ; }
public void write byte ( final byte octet ) { if ( remain ( ) < 1 ) { if ( index == block . size ( ) - 1 ) { allocate new block ( ) ; } index++ ; current = block . get ( index ) ; } final block block = current ; block . data [ block . limit ] = octet ; block . limit++ ; }
public void write to ( final output stream out ) throw i o exception { for ( final block block : block ) { out . write ( block . data , 0 , block . limit ) ; } }
public static boolean be text ( ion type t ) { return ( t == string ) || ( t == symbol ) ; }
public boolean be stream copy optimize ( ) { return my stream copy optimize ; }
public ion system builder mutable ( ) { return copy ( ) ; }
public final boolean be stream copy optimize ( ) { return my stream copy optimize ; }
public static ion text writer builder json ( ) { return standard ( ) . with json downgrade ( ) ; }
public void set charset ( charset charset ) { mutation check ( ) ; if ( charset == null || charset . equal ( ascii ) || charset . equal ( utf8 ) ) { my charset = charset ; } else { throw new illegal argument exception ( `` unsupported charset `` + charset ) ; } }
public boolean be use origin ( ) { if ( use origin == null ) { if ( get setting ( ) ! = null ) { return get setting ( ) . be default use origin ( ) ; } else { return false ; } } else { return use origin . boolean value ( ) ; } }
public void end monitoring ( ) { monitored setting = null ; delegate setting = null ; }
public boolean have change ( parser setting new setting ) { for ( iterator it = substitute . entry set ( ) . iterator ( ) ; it . have next ( ) ; ) { map . entry entry = ( entry ) it . next ( ) ; string key = ( string ) entry . get key ( ) ; object old value = entry . get value ( ) ; string new value = new setting . substitute ( key ) ; if ( ! old value . equal ( new value ) ) { message . debug ( `` setting variable have change for : `` + entry . get key ( ) ) ; return true ; } } return false ; }
public object peek ( string key ) { synchronize ( context map ) { object o = context map . get ( key ) ; if ( o == null ) { return null ; } if ( o instanceof list ) { if ( ( ( list ) o ) . size ( ) == 0 ) { return null ; } object ret = ( ( list ) o ) . get ( 0 ) ; return ret ; } else { throw new runtime exception ( `` can not top from non list object `` + o ) ; } } }
public artifact download report [ ] get failed artifact report ( ) { artifact download report [ ] all fail report = get artifact report ( download status . fail , true ) ; return filter out merge artifact ( all fail report ) ; }
public collection get orphan ( ) { ensure analyze ( ) ; collection orphan = new hash set ( revision . key set ( ) ) ; orphan . remove all ( dependers . key set ( ) ) ; return orphan ; }
public boolean be completely blacklist ( ) { if ( be root ( ) ) { return false ; } string [ ] root module configuration = get root module configuration ( ) ; for ( int i = 0 ; i < root module configuration . length ; i++ ) { if ( ! be blacklist ( root module configuration [ i ] ) ) { return false ; } } return true ; }
public boolean have any merge usage with transitive dependency ( string root module conf ) { if ( merge usage == null ) { return false ; } for ( iterator iterator = merge usage . value ( ) . iterator ( ) ; iterator . have next ( ) ; ) { ivy node usage usage = ( ivy node usage ) iterator . next ( ) ; if ( usage . have transitive depender ( root module conf ) ) { return true ; } } return false ; }
public module revision id get id ( ) { return descriptor . get resolve module revision id ( ) ; }
public dependency resolver get resolver ( ) { return resolver ; }
public void filter ignore ( collection names ) { name . remove all ( list ignore ) ; }
public list sort module descriptor ( ) throw circular dependency exception { message . debug ( `` nbr of module to sort : `` + module descriptor . size ( ) ) ; iterator module descriptor iterator = module descriptor . iterator ( ) ; while ( module descriptor iterator . have next ( ) ) { module in sort next = ( module in sort ) module descriptor iterator . next ( ) ; sort module descriptor help ( next , next ) ; } return sort ; }
public static string get ivy home u r l ( ) { return `` http : //ant . apache . org/ivy/ `` ; }
public void bind ( ) { push context ( ) ; try { if ( setting == null ) { setting = new ivy setting ( ) ; } if ( event manager == null ) { event manager = new event manager ( ) ; } if ( sort engine == null ) { sort engine = new sort engine ( setting ) ; } if ( search engine == null ) { search engine = new search engine ( setting ) ; } if ( resolve engine == null ) { resolve engine = new resolve engine ( setting , event manager , sort engine ) ; } if ( retrieve engine == null ) { retrieve engine = new retrieve engine ( setting , event manager ) ; } if ( deliver engine == null ) { deliver engine = new deliver engine ( setting ) ; } if ( publish engine == null ) { publish engine = new publish engine ( setting , event manager ) ; } if ( install engine == null ) { install engine = new install engine ( setting , search engine , resolve engine ) ; } if ( repository engine == null ) { repository engine = new repository management engine ( setting , search engine , resolve engine ) ; } event manager . add transfer listener ( new transfer listener ( ) { public void transfer progress ( transfer event evt ) { resolve data resolve ; switch ( evt . get event type ( ) ) { case transfer event . transfer_progress : resolve = ivy context . get context ( ) . get resolve data ( ) ; if ( resolve == null || ! log option . log_quiet . equal ( resolve . get option ( ) . get log ( ) ) ) { message . progress ( ) ; } break ; case transfer event . transfer_completed : resolve = ivy context . get context ( ) . get resolve data ( ) ; if ( resolve == null || ! log option . log_quiet . equal ( resolve . get option ( ) . get log ( ) ) ) { message . end progress ( `` ( `` + ( evt . get total length ( ) / kilo ) + `` k b ) `` ) ; } break ; default : break ; } } } ) ; bind = true ; } finally { pop context ( ) ; } }
protect string get current element identifier ( ) { return `` `` ; }
public static void zip ( file source dir , output stream target stream ) throw i o exception { if ( ! source dir . be file ( ) & & ! source dir . be directory ( ) ) { return ; } final zip output stream cp zip output stream = new zip output stream ( target stream ) ; cp zip output stream . set level ( 9 ) ; zip file ( source dir , source dir , cp zip output stream ) ; cp zip output stream . finish ( ) ; cp zip output stream . close ( ) ; }
public file get build root ( ) { return build root ; }
public void set resource cache ( file resource cache ) { this . resource cache = resource cache ; }
public static string read entirely ( buffered reader in ) throw i o exception { try { string buffer buf = new string buffer ( ) ; string line = in . read line ( ) ; while ( line ! = null ) { buf . append ( line + `` \n `` ) ; line = in . read line ( ) ; } return buf . to string ( ) ; } finally { in . close ( ) ; } }
public message logger peek logger ( ) { if ( logger stack . be empty ( ) ) { return get default logger ( ) ; } return ( message logger ) logger stack . peek ( ) ; }
public static final string decrypt ( string str ) { if ( str == null ) { return null ; } string buffer buf = new string buffer ( ) ; for ( int i = 0 ; i < str . length ( ) ; i++ ) { buf . append ( decrypt ( str . char at ( i ) ) ) ; } return buf . to string ( ) ; }
public boolean be boolean ( ) { return false ; }
public boolean get boolean value ( ) { return false ; }
public int get int value ( ) { return 0 ; }
public boolean have ( string field name ) { return get ( field name ) ! = null ; }
public object mapper set serialization inclusion ( json include . include incl ) { _serialization config = _serialization config . with serialization inclusion ( incl ) ; return this ; }
public class < ? > get parameter source ( ) { return null ; }
public int write binary ( input stream data , int data length ) throw i o exception { / * * 28- mar-2014 , tatu : theoretically we could implement encoder that use * chunk to output binary content of unknown ( a priori ) length . but * for no let 's require knowledge of length , for simplicity : may be * revisit in future . * / if ( data length < 0 ) { throw new unsupported operation exception ( `` must pass actual length for cbor encode data `` ) ; } _verify value write ( `` write binary value `` ) ; int miss ; _write length marker ( prefix_type_bytes , data length ) ; miss = _write byte ( data , data length ) ; if ( miss > 0 ) { _report error ( `` too few byte available : miss `` + miss + `` byte ( out of `` + data length + `` ) `` ) ; } return data length ; }
public type resolver builder < ? > find property type resolver ( mapper config < ? > config , annotated member be , java type base type ) { return null ; }
public type resolver builder < ? > find property content type resolver ( mapper config < ? > config , annotated member be , java type container type ) { return null ; }
public void set date format ( date format df ) { if ( df == null ) { df = default_date_format ; } _base = _base . with date format ( df ) ; }
protect std serializer provider create instance ( serialization config config , serializer factory jsf ) { return new std serializer provider ( config , this , jsf ) ; }
protect json serializer < object > _create untyped serializer ( java type type , bean property property ) throw json map exception { / * 10- dec-2008 , tatu : be there a possibility of infinite loop * here ? should n't be , give that we do not pass back-reference * to this provider . but if there be , we 'd need to sync call , * and keep track of creation chain to look for loop -- fairly * easy to do , but wo n't add yet since it seem unnecessary . * / return ( json serializer < object > ) _serializer factory . create serializer ( _config , type , property ) ; }
public json node path ( string field name ) { return miss node . get instance ( ) ; }
protect paranamer default paranamer ( ) { return new cache paranamer ( new bytecode read paranamer ( ) ) ; }
public boolean equal ( string s ) { if ( s == null || mime type == null ) return false ; return be mime type equal ( s ) ; }
public boolean disjoint ( geoshape other ) { return get spatial relation ( other ) == spatial relation . disjoint ; }
public static long to vertex id ( long id ) { precondition . check argument ( id > 0 , `` vertex id must be positive : % s `` , id ) ; precondition . check argument ( i d manager . vertex i d type . normal vertex . remove padding ( long . max_value ) > = id , `` vertex id be too large : % s `` , id ) ; return i d manager . vertex i d type . normal vertex . add pad ( id ) ; }
public static void await graph index update ( janus graph g , string index name , long time , temporal unit unit ) { await index update ( g , index name , null , time , unit ) ; }
public boolean be manage ( ) { return manage type . contains ( type ) ; }
public static buffer get slice end ( ) { return slice end ; }
public boolean have identifier ( ) { return identifier ! =null ; }
public list < k > get deletion ( ) { if ( deletions==null ) return immutable list . of ( ) ; return deletion ; }
public static long get temporary relation i d ( long count ) { return make temporary ( count ) ; }
public void remove template configuration ( ) { remove vertex ( property_template , true ) ; }
public static void attach property ( final janus graph vertex vertex , final object . . . property key value ) { if ( null == vertex ) throw graph . exception . argument can not be null ( `` vertex `` ) ; for ( int i = 0 ; i < property key value . length ; i = i + 2 ) { if ( ! property key value [ i ] . equal ( t . id ) & & ! property key value [ i ] . equal ( t . label ) ) vertex . property ( ( string ) property key value [ i ] , property key value [ i + 1 ] ) ; } }
public x m l builder text ( string value ) { return this . text ( value , false ) ; }
public x m l builder cdata ( byte [ ] data ) { xml node . append child ( get document ( ) . create c d a t a section ( base64 . encode byte ( data ) ) ) ; return this ; }
public x m l builder up ( int step ) { node curr node = this . xml node ; int step count = 0 ; while ( curr node . get parent node ( ) ! = null & & step count < step ) { curr node = curr node . get parent node ( ) ; step count++ ; } if ( curr node instanceof document ) { return new x m l builder ( ( document ) curr node ) ; } else { return new x m l builder ( curr node , null ) ; } }
public alias add to alias object extension ( final abstract object alias object extension ) { this . get alias object extension ( ) . add ( alias object extension ) ; return this ; }
public balloon style add to balloon style simple extension ( final object balloon style simple extension ) { this . get balloon style simple extension ( ) . add ( balloon style simple extension ) ; return this ; }
public basic link add to basic link object extension ( final abstract object basic link object extension ) { this . get basic link object extension ( ) . add ( basic link object extension ) ; return this ; }
public extend data add to schema data ( final schema data schema data ) { this . get schema data ( ) . add ( schema data ) ; return this ; }
public feature add to feature object extension ( final abstract object feature object extension ) { this . get feature object extension ( ) . add ( feature object extension ) ; return this ; }
public void set tour primitive ( final list < tour primitive > tour primitive ) { this . tour primitive = tour primitive ; }
public void set simple array data extension ( final list < object > simple array data extension ) { this . simple array data extension = simple array data extension ; }
public boolean marshal ( ) { try { m = this . create marshaller ( ) ; m . marshal ( this , system . out ) ; return true ; } catch ( j a x b exception _x ) { _x . print stack trace ( ) ; return false ; } }
public list style add to item icon ( final item icon item icon ) { this . get item icon ( ) . add ( item icon ) ; return this ; }
public model add to model simple extension ( final object model simple extension ) { this . get model simple extension ( ) . add ( model simple extension ) ; return this ; }
public poly style add to poly style simple extension ( final object poly style simple extension ) { this . get poly style simple extension ( ) . add ( poly style simple extension ) ; return this ; }
public poly style add to poly style object extension ( final abstract object poly style object extension ) { this . get poly style object extension ( ) . add ( poly style object extension ) ; return this ; }
public time primitive add to time primitive object extension ( final abstract object time primitive object extension ) { this . get time primitive object extension ( ) . add ( time primitive object extension ) ; return this ; }
public update add to update extension ( final object update extension ) { this . get update extension ( ) . add ( update extension ) ; return this ; }
public void set post office name ( final list < post office . post office name > post office name ) { this . post office name = post office name ; }
public void flip ( int start , int end ) { if ( start == end ) return ; int firstword = start / 64 ; int endword = ( end - 1 ) / 64 ; this . data [ firstword ] ^= ~ ( ~0l < < start ) ; for ( int i = firstword ; i < endword ; i++ ) this . data [ i ] = ~this . data [ i ] ; this . data [ endword ] ^= ~0l > > > -end ; }
public int next set bit ( final int i ) { int x = i / 64 ; if ( x > = this . get number of word ( ) ) return -1 ; long w = this . data [ x ] ; w > > > = i ; if ( w ! = 0 ) { return i + long . number of trail zero ( w ) ; } ++x ; for ( ; x < this . get number of word ( ) ; ++x ) { if ( this . data [ x ] ! = 0 ) { return x * 64 + long . number of trail zero ( this . data [ x ] ) ; } } return -1 ; }
public bit set a bit set ( ) { bit set bs = new bit set ( this . size ( ) ) ; this . data . rewind ( ) ; this . data . get ( b . data , 0 , b . data . length ) ; return b ; }
public void add stream of empty word ( final boolean v , long number ) { if ( number == 0 ) return ; this . size in bit += number * word_in_bits ; fastadd stream of empty word ( v , number ) ; }
public list < integer > to list ( ) { final array list < integer > v = new array list < integer > ( ) ; final e w a h iterator i = this . get e w a h iterator ( ) ; int po = 0 ; while ( i . have next ( ) ) { run length word localrlw = i . next ( ) ; if ( localrlw . get running bit ( ) ) { final long n = localrlw . get running length ( ) ; for ( long j = 0 ; j < n ; ++j ) { for ( int c = 0 ; c < word_in_bits ; ++c ) v . add ( pos++ ) ; } } else { po += word_in_bits * localrlw . get running length ( ) ; } final int nlw = localrlw . get number of literal word ( ) ; for ( int j = 0 ; j < nlw ; ++j ) { long data = i . buffer ( ) . get word ( i . literal word ( ) + j ) ; while ( data ! = 0 ) { final long t = data & -data ; v . add ( long . bit count ( t - 1 ) + po ) ; data ^= t ; } pos += word_in_bits ; } } while ( ( v . size ( ) > 0 ) & & ( v . get ( v . size ( ) - 1 ) > = this . size in bit ) ) v . remove ( v . size ( ) - 1 ) ; return v ; }
public boolean get ( final int i ) { if ( ( i < 0 ) || ( i > = this . size in bit ) ) return false ; int word check = 0 ; final iterating r l w j = get iterate r l w ( ) ; final int wordi = i / word_in_bits ; while ( word check < = wordi ) { word check += j . get running length ( ) ; if ( wordi < word check ) { return j . get running bit ( ) ; } if ( wordi < word check + j . get number of literal word ( ) ) { final long w = j . get literal word at ( wordi - word check ) ; return ( w & ( 1l < < i ) ) ! = 0 ; } word check += j . get number of literal word ( ) ; j . next ( ) ; } return false ; }
public int get first set bit ( ) { int nword = 0 ; final int siw = this . buffer . size in word ( ) ; for ( int po = 0 ; po < siw ; ++pos ) { long rl = run length word . get running length ( this . buffer , po ) ; boolean rb = run length word . get running bit ( this . buffer , po ) ; if ( ( rl > 0 ) & & rb ) { return nword * word_in_bits ; } nword += rl ; long lw = run length word . get number of literal word ( this . buffer , po ) ; if ( lw > 0 ) { long word = this . buffer . get word ( pos + 1 ) ; if ( word ! = 0l ) { long t = word & -word ; return nword * word_in_bits + long . bit count ( t - 1 ) ; } } } return -1 ; }
public int size in byte ( ) { return this . buffer . size in word ( ) * ( word_in_bits / 8 ) ; }
public void compose to container ( final e w a h compress bitmap a , final e w a h compress bitmap container ) { container . clear ( ) ; final chunk iterator iterator = chunk iterator ( ) ; final chunk iterator a iterator = a . chunk iterator ( ) ; int index = 0 ; while ( iterator . have next ( ) & & a iterator . have next ( ) ) { if ( ! iterator . next bit ( ) ) { int length = iterator . next length ( ) ; index += length ; container . set size in bit ( index , false ) ; iterator . move ( length ) ; } else { int length = math . min ( iterator . next length ( ) , a iterator . next length ( ) ) ; index += length ; container . set size in bit ( index , a iterator . next bit ( ) ) ; iterator . move ( length ) ; a iterator . move ( length ) ; } } container . set size in bit ( size in bit , false ) ; }
public static e w a h compress bitmap xor ( final e w a h compressed bitmap . . . bitmap ) { if ( bitmap . length == 1 ) return bitmap [ 0 ] ; int large size = calculate initial size ( bitmap ) ; int size = ( int ) ( large size * 1 . 5 ) ; final e w a h compress bitmap container = new e w a h compress bitmap ( size ) ; xor with container ( container , bitmap ) ; return container ; }
public void swap ( final e w a h compress bitmap32 other ) { this . buffer . swap ( other . buffer ) ; int tmp2 = this . rlw . position ; this . rlw . position = other . rlw . position ; other . rlw . position = tmp2 ; int tmp3 = this . size in bit ; this . size in bit = other . size in bit ; other . size in bit = tmp3 ; }
public static void or with container ( final bitmap storage32 container , final e w a h compressed bitmap32 . . . bitmap ) { if ( bitmap . length < 2 ) throw new illegal argument exception ( `` you should provide at least two bitmap , provide `` + bitmap . length ) ; fast aggregation32 . or to container ( container , bitmap ) ; }
public static e w a h compress bitmap32 materialize ( final iterating r l w32 i ) { e w a h compress bitmap32 ewah = new e w a h compress bitmap32 ( ) ; materialize ( i , ewah ) ; return ewah ; }
public int get array dimension ( ) { return this . array dimension ; }
public boolean be interface ( ) { return ! be array ( ) & & this . component class . be interface ( ) ; }
public boolean be raw ( ) { if ( this . type parameter . length == 0 ) { return true ; } for ( int i = 0 , n = this . type parameter . length ; i < n ; i++ ) { if ( ! this . type parameter [ i ] . equal ( wildcard type parameter . unknown ) ) { return false ; } } return true ; }
public int get array dimension ( ) { return this . array dimension ; }
public void record invalid class name ( string name ) { source . record invalid class name ( name ) ; }
public method info get method info2 ( ) { return method info ; }
public static boolean be native ( int mod ) { return ( mod & native ) ! = 0 ; }
public static boolean be enum ( int mod ) { return ( mod & enum ) ! = 0 ; }
public static boolean be strict ( int mod ) { return ( mod & strict ) ! = 0 ; }
public set entry set ( ) { process queue ( ) ; return hash . entry set ( ) ; }
public final object get value ( final int po ) { if ( pos > = get size ( ) ) { throw new illegal argument exception ( `` can not retrieve position `` + po + `` in `` + this . get class ( ) . get simple name ( ) + `` . position for this class start with 0 and end with `` + ( get size ( ) - 1 ) ) ; } return this . value array [ po ] ; }
public void notify after evaluation ( string expr ) { if ( get evaluation listener ( ) == null ) return ; for ( evaluation listener listener : get evaluation listener ( ) ) { listener . after evaluation ( this , expr ) ; } }
public standard e l context get e l context ( ) { if ( el context == null ) { el context = new standard e l context ( get expression factory ( ) ) ; } return el context ; }
public void set e l context ( e l context context ) { this . context = context ; }
public class < ? > get common property type ( e l context context , object base ) { if ( base ! = null & & base instanceof list ) { return integer . class ; } return null ; }
public argument append ( argument arg ) { item . add all ( arg . item ) ; return this ; }
public argument write number ( int i ) { item . add ( integer . value of ( i ) ) ; return this ; }
public argument write argument ( argument c ) { item . add ( c ) ; return this ; }
public byte [ ] get byte ( ) { return byte ; }
public void set count ( int count ) { this . count = count ; }
protect response input stream get input stream ( ) { return input ; }
public boolean have response ( ) { / * * xxx - really should peek ahead in the buffer to see * if there 's a * complete * response available , but if there * be n't who 's go to read more data into the buffer * until there be ? * / try { return input . available ( ) > 0 ; } catch ( i o exception ex ) { } return false ; }
protect void resume trace ( ) { if ( trace logger . be loggable ( level . fine ) ) { trace input . set trace ( true ) ; trace output . set trace ( true ) ; } }
public string read atom ( ) { return read delim string ( atom_char_delim ) ; }
public string get rest ( ) { skip space ( ) ; return to string ( buffer , index , size ) ; }
public string get name ( ) { return name ; }
public right get right ( ) { return right ; }
protect string get envelope command ( ) { return i m a p message . envelope cmd ; }
public synchronize message [ ] expunge ( ) throw message exception { return expunge ( null ) ; }
public synchronize boolean get u i d not sticky ( ) throw message exception { check open ( ) ; return uid not sticky ; }
public right my right ( ) throw message exception { return ( right ) do optional command ( `` acl not support `` , new protocol command ( ) { @ override public object do command ( i m a p protocol p ) throw protocol exception { return p . my right ( full name ) ; } } ) ; }
protect synchronize i m a p protocol get store protocol ( ) throw protocol exception { connection pool logger . fine ( `` get store protocol ( ) borrow a connection `` ) ; return ( ( i m a p store ) store ) . get folder store protocol ( ) ; }
protect int get sequence number ( ) { return ( ( i m a p folder ) folder ) . message cache . seqnum of ( get message number ( ) ) ; }
public address [ ] get reply to ( ) throw message exception { check expunge ( ) ; if ( body load ) return super . get reply to ( ) ; load envelope ( ) ; / * * the imap spec require that the reply- to field never be * null , but at least exchange 2007 fail to fill it in in * some case . use the same fallback strategy use by * mime message . * / if ( envelope . reply to == null || envelope . reply to . length == 0 ) return get from ( ) ; return aaclone ( envelope . reply to ) ; }
public string get content m d5 ( ) throw message exception { check expunge ( ) ; if ( body load ) return super . get content m d5 ( ) ; load b o d y s t r u c t u r e ( ) ; return b . md5 ; }
public enumeration < header > get all header ( ) throw message exception { check expunge ( ) ; load header ( ) ; return super . get all header ( ) ; }
protect void pre login ( i m a p protocol p ) throw protocol exception { }
public synchronize boolean be s s l ( ) { return use s s l ; }
public folder [ ] get share namespaces ( ) throw message exception { namespaces ns = get namespaces ( ) ; if ( ns == null || n . share == null ) return super . get share namespaces ( ) ; return namespace to folder ( n . share , null ) ; }
protect boolean support non sync literal ( ) { return have capability ( `` literal+ `` ) ; }
protect search sequence get search sequence ( ) { if ( search sequence == null ) search sequence = new search sequence ( this ) ; return search sequence ; }
public long get mod seq ( ) { return modseq ; }
public int get type ( ) { return holds_messages ; }
public message [ ] expunge ( ) throw message exception { throw new method not support exception ( `` expunge not support `` ) ; }
public string get command ( ) { return cmd ; }
public int get return option ( ) { return return option ; }
public string get mail extension ( ) { return extension ; }
public static long parse long ( byte [ ] b , int start , int end ) throw number format exception { return parse long ( b , start , end , 10 ) ; }
public static int encode length ( byte [ ] b ) { return ( ( b . length + 2 ) /3 ) * 4 ; }
public string format message ( final log record record ) { string msg = super . format message ( record ) ; msg = replace class name ( msg , record . get thrown ( ) ) ; msg = replace class name ( msg , record . get parameter ( ) ) ; return msg ; }
public boolean be loggable ( final log record record ) { return accept ( record . get millis ( ) ) ; }
public string get property ( final string key , final string def ) { final string value = this . get property ( key ) ; return value == null ? def : value ; }
public final synchronize void set comparator ( comparator < ? super log record > c ) { check access ( ) ; if ( be write ) { throw new illegal state exception ( ) ; } this . comparator = c ; }
public final void set mail property ( property prop ) { this . set mail properties0 ( prop ) ; }
public final void set attachment name ( final string . . . name ) { check access ( ) ; final formatter [ ] formatters ; if ( name . length == 0 ) { formatters = empty formatter array ( ) ; } else { formatters = new formatter [ names . length ] ; } for ( int i = 0 ; i < name . length ; ++i ) { final string name = name [ i ] ; if ( name ! = null ) { if ( name . length ( ) > 0 ) { formatters [ i ] = tail name formatter . of ( name ) ; } else { throw new illegal argument exception ( at index msg ( i ) ) ; } } else { throw new null pointer exception ( at index msg ( i ) ) ; } } synchronize ( this ) { if ( this . attachment formatters . length ! = name . length ) { throw attachment mismatch ( this . attachment formatters . length , names . length ) ; } if ( be write ) { throw new illegal state exception ( ) ; } this . attachment name = formatters ; } }
public string get host ( ) { return host ; }
protect final string get request protocol ( ) { return request protocol ; }
public int get type ( ) { return type ; }
public address [ ] get invalid address ( ) { return invalid ; }
protect void notify message remove listener ( boolean remove , message [ ] msg ) { if ( message count listener == null ) return ; message count event e = new message count event ( this , message count event . remove , remove , msg ) ; queue event ( e , message count listener ) ; }
public string get ref ( ) { return ref ; }
public int get po ( ) { return po ; }
public void set disposition ( string disposition ) { this . disposition = disposition ; }
public void add header line ( string line ) throw message exception { header . add header line ( line ) ; }
public void add recipient ( message . recipient type type , string address ) throw message exception { if ( type == recipient type . newsgroups ) { if ( address ! = null & & address . length ( ) ! = 0 ) add header ( `` newsgroups `` , address ) ; } else add address header ( get header name ( type ) , internet address . parse ( address ) ) ; }
public string get description ( ) throw message exception { return mime body part . get description ( this ) ; }
public void set description ( string description ) throw message exception { set description ( description , null ) ; }
public void save change ( ) throw message exception { modified = true ; save = true ; update header ( ) ; }
protect void update message i d ( ) throw message exception { set header ( `` message- i d `` , `` < `` + unique value . get unique message i d value ( session ) + `` > `` ) ; }
public string get newsgroup ( ) { return newsgroup ; }
protect void set expunge ( boolean expunge ) { this . expunge = expunge ; }
public synchronize void set parent ( part parent ) { this . parent = parent ; }
public string get protocol ( ) { return protocol ; }
public boolean get test set ( ) { return set ; }
public boolean match ( message msg ) { return ! term . match ( msg ) ; }
public synchronize boolean be connect ( ) { return connect ; }
public synchronize void set debug ( boolean debug ) { this . debug = debug ; init logger ( ) ; logger . log ( level . config , `` set debug : java mail version { 0 } `` , version . version ) ; }
public string get property ( string name ) { return prop . get property ( name ) ; }
public synchronize void add provider ( provider provider ) { provider . add element ( provider ) ; provider by class name . put ( provider . get class name ( ) , provider ) ; if ( ! provider by protocol . contains key ( provider . get protocol ( ) ) ) provider by protocol . put ( provider . get protocol ( ) , provider ) ; }
public synchronize void set protocol for address ( string addresstype , string protocol ) { if ( protocol == null ) address map . remove ( addresstype ) ; else address map . put ( addresstype , protocol ) ; }
protect void notify store listener ( int type , string message ) { if ( store listener == null ) return ; store event e = new store event ( this , type , message ) ; queue event ( e , store listener ) ; }
public store get store ( ) { return store ; }
public void init ( filter config config ) throw servlet exception { this . config = config ; this . init ( ) ; }
public http servlet map get http servlet mapping ( ) { return this . _get http servlet request ( ) . get http servlet mapping ( ) ; }
public void print stack trace ( ) { super . print stack trace ( ) ; }
public void add inner ( xml node element , object inner ) { entry < xml node > e = by element . get ( element ) ; if ( e ! =null ) { if ( e . inner ! =null ) by peer . remove ( e . inner ) ; e . inner = inner ; } else { e = new entry < xml node > ( ) ; e . element = element ; e . inner = inner ; } by element . put ( element , e ) ; entry < xml node > old = by peer . put ( inner , e ) ; if ( old ! =null ) { if ( old . outer ! =null ) by peer . remove ( old . outer ) ; if ( old . element ! =null ) by element . remove ( old . element ) ; } }
public j annotation use param ( string name , boolean value ) { add value ( name , new j annotation string value ( j expr . lit ( value ) ) ) ; return this ; }
public j while loop _while ( j expression test ) { return insert ( new j while loop ( test ) ) ; }
public j block block ( ) { j block b = new j block ( ) ; b . brace require = false ; b . indent require = false ; return insert ( b ) ; }
public j type var [ ] type params ( ) { return empty_array ; }
public j package _package ( string name ) { j package p = package . get ( name ) ; if ( p == null ) { p = new j package ( name , this ) ; package . put ( name , p ) ; } return p ; }
public j define class _get class ( string fully qualify name ) { int idx = fully qualify name . last index of ( ' . ' ) ; if ( idx < 0 ) return root package ( ) . _get class ( fully qualify name ) ; else return _package ( fully qualify name . substring ( 0 , idx ) ) . _get class ( fully qualify name . substring ( idx+1 ) ) ; }
public boolean be annotation type declaration ( ) { return this . class type== class type . annotation_type_decl ; }
public j block init ( ) { if ( init == null ) init = new j block ( ) ; return init ; }
public j annotation use annotate ( j class clazz ) { if ( annotations==null ) annotation = new array list < j annotation use > ( ) ; j annotation use a = new j annotation use ( clazz ) ; annotation . add ( a ) ; return a ; }
public j type type ( ) { return type ; }
public void type ( j type t ) { this . type = t ; }
public j var [ ] list params ( ) { return params . to array ( new j var [ params . size ( ) ] ) ; }
public j doc comment javadoc ( ) { if ( jdoc == null ) jdoc = new j doc comment ( owner ( ) ) ; return jdoc ; }
public j class ref ( string name ) throw class not find exception { if ( name . index of ( ' . ' ) > = 0 ) throw new illegal argument exception ( `` j class name contain ' . ' : `` + name ) ; string n = `` `` ; if ( ! be unnamed ( ) ) n = this . name + ' . ' ; n += name ; return owner . ref ( class . for name ( n ) ) ; }
protect boolean be resource ( ) { return true ; }
public static boolean be high ( int c ) { return ( min_high < = c ) & & ( c < = max_high ) ; }
public static char high ( int uc ) { return ( char ) ( 0xd800 | ( ( ( uc - ucs4_min ) > > 10 ) & 0x3ff ) ) ; }
public static char low ( int uc ) { return ( char ) ( 0xdc00 | ( ( uc - ucs4_min ) & 0x3ff ) ) ; }
public string get current base ( ) { return base . to string ( ) ; }
public static string get local name ( element element ) { string name = element . get tag name ( ) ; if ( name . index of ( ' : ' ) > 0 ) { name = name . substring ( name . index of ( ' : ' ) +1 ) ; } return name ; }
public string get catalog parser ( string namespace u r i , string root element ) { if ( namespace u r i == null ) { return ( string ) namespace map . get ( root element ) ; } else { return ( string ) namespace map . get ( `` { `` +namespace u r i+ `` } `` +root element ) ; } }
public void set root handler ( n g c c handler root handler ) { if ( current handler ! =null ) throw new illegal state exception ( ) ; current handler = root handler ; }
public static string get default package name ( string namespace uri ) { if ( namespace uri==null ) throw new illegal argument exception ( ) ; return name converter . standard . to package name ( namespace uri ) ; }
public static whitespace normalizer parse ( string method ) { if ( method . equal ( `` preserve `` ) ) return preserve ; if ( method . equal ( `` replace `` ) ) return replace ; if ( method . equal ( `` collapse `` ) ) return collapse ; throw new illegal argument exception ( method ) ; }
public string get squeeze name ( ) { if ( squeeze name ! =null ) return squeeze name ; string builder b = new string builder ( ) ; c class info s = get scope ( ) ; if ( s ! =null ) b . append ( s . get squeeze name ( ) ) ; if ( class name ! =null ) b . append ( class name ) ; else b . append ( model . get name converter ( ) . to class name ( tag name . get local part ( ) ) ) ; return b . to string ( ) ; }
public boolean include ( multiplicity rh ) { if ( rh . min < min ) return false ; if ( max==null ) return true ; if ( rh . max==null ) return false ; return rh . max < = max ; }
public locator get location ( ) { return d o m locator . get location info ( e ) ; }
public j class get super class ( ) { element sc = d o m util . get element ( dom , xjc_ns , `` super class `` ) ; if ( sc == null ) return null ; j define class c ; try { string v = d o m util . get attribute ( sc , `` name `` ) ; if ( v==null ) return null ; c = code model . _class ( v ) ; c . hide ( ) ; } catch ( j class already exist exception e ) { c = e . get existing class ( ) ; } return c ; }
public b i conversion conversion ( string name ) { b i conversion r = conversion . get ( name ) ; if ( r == null ) throw new assertion error ( `` undefined conversion name : this should be check by the validator before we read it `` ) ; return r ; }
public void ying ( x s component sc , @ nullable x s component referer ) { if ( sc . apply ( to purple ) ==true || get class selector ( ) . bind to type ( sc , referer ) ! =null ) sc . visit ( purple ) ; else sc . visit ( green ) ; }
public final q name get name ( ) { return name ; }
public void execute task ( ) { while ( bind queue . size ( ) ! =0 ) bind queue . pop ( ) . build ( ) ; }
public string to string ( ) { return message . format ( message . msg_collision_info , name , print locator ( source1 ) , print locator ( source2 ) ) ; }
protect complex type binding mode get bind mode ( x s complex type type ) { complex type binding mode r = complex type binding mode . get ( type ) ; assert r ! =null ; return r ; }
public void set schema ( string schema ) { try { option . add grammar ( get input source ( new url ( schema ) ) ) ; } catch ( malformed u r l exception e ) { file f = get project ( ) . resolve file ( schema ) ; option . add grammar ( f ) ; depend set . add ( f ) ; } }
public void set package ( string pkg ) { this . option . default package = pkg ; }
public void set extension ( boolean flg ) { if ( flg ) this . option . compatibility mode = option . extension ; else this . option . compatibility mode = option . strict ; }
public locale get locale ( ) { return locale ; }
public void set entity resolver ( entity resolver r ) { resolver = r ; }
public void reset ( ) throw i o exception { if ( in ! = null ) in . reset ( ) ; }
public void redefine ( complex type impl ct ) { if ( base type instanceof delay ref ) ( ( delay ref ) base type ) . redefine ( ct ) ; else this . base type = ct ; ct . redefine by = this ; redefine count = ( short ) ( ct . redefine count+1 ) ; }
public string get name ( ) { return to string ( ) ; }
public string get name ( ) { return target . get name ( ) ; }
public class field add field ( int access flag , string name , string descriptor ) { return add field ( access flag , name , descriptor , null ) ; }
public lookup switch builder add ( int value , final code location location ) { value . add ( new value pair ( value , location ) ) ; return this ; }
public stack frame pop4 ( ) { stack state ns = stack state . pop ( 4 ) ; return new stack frame ( ns , local variable state , type no local change ( ns ) ) ; }
public stack frame constructor call ( int initialize value stack position ) { stack entry entry = stack state . get content ( ) . get ( stack state . get content ( ) . size ( ) - 1 - initialize value stack position ) ; stack state ns = stack state . constructor call ( initialized value stack position , entry ) ; local variable state local = local variable state . constructor call ( entry ) ; return new stack frame ( ns , local , stack frame type . full_frame ) ; }
public void parse ( string . . . args ) { string builder sb = new string builder ( `` parse \ `` `` ) ; sb . append ( join ( args ) . append ( `` \ `` \n with : `` ) . append ( join ( m_objects . to array ( ) ) ) ) ; p ( sb . to string ( ) ) ; create description ( ) ; initialize default value ( ) ; parse value ( expand args ( args ) ) ; validate option ( ) ; }
public void usage ( string command name ) { string builder sb = new string builder ( ) ; usage ( command name , sb ) ; system . out . println ( sb . to string ( ) ) ; }
public void usage ( ) { string builder sb = new string builder ( ) ; usage ( sb ) ; system . out . println ( sb . to string ( ) ) ; }
public void add command ( string name , object object ) { j commander jc = new j commander ( object ) ; jc . set program name ( name ) ; m_commands . put ( name , jc ) ; }
public string get program name ( ) { return program name == null ? null : program name . get name ( ) ; }
public static < e > void so element ( e [ ] buffer , long offset , e e ) { unsafe . put ordered object ( buffer , offset , e ) ; }
public boolean be specify ( ) { return specify ; }
public void set specify ( boolean specify ) { this . specify = specify ; }
public attribute detach ( ) { if ( parent ! = null ) { parent . remove attribute ( this ) ; } return this ; }
public void add ( final int index , final attribute attribute ) { if ( index < 0 || index > size ) { throw new index out of bound exception ( `` index : `` + index + `` size : `` + size ( ) ) ; } if ( attribute . get parent ( ) ! = null ) { throw new illegal add exception ( `` the attribute already have an exist parent \ `` `` + attribute . get parent ( ) . get qualified name ( ) + `` \ `` `` ) ; } final int duplicate = index of duplicate ( attribute ) ; if ( duplicate > = 0 ) { throw new illegal add exception ( `` can not add duplicate attribute `` ) ; } final string reason = verifier . check namespace collision ( attribute , parent ) ; if ( reason ! = null ) { throw new illegal add exception ( parent , attribute , reason ) ; } attribute . set parent ( parent ) ; ensure capacity ( size + 1 ) ; if ( index == size ) { attribute data [ size++ ] = attribute ; } else { system . arraycopy ( attribute data , index , attribute data , index + 1 , size - index ) ; attribute data [ index ] = attribute ; size++ ; } mod count++ ; }
public boolean add all ( final collection < ? extend attribute > collection ) { return add all ( size ( ) , collection ) ; }
public attribute get ( final int index ) { if ( index < 0 || index > = size ) { throw new index out of bound exception ( `` index : `` + index + `` size : `` + size ( ) ) ; } return attribute data [ index ] ; }
public final c type get c type ( ) { return ctype ; }
public < f extend content > iterator iterable < f > get descendant ( final filter < f > filter ) { return new filter iterator < f > ( new descendant iterator ( this ) , filter ) ; }
public static final filter < boolean > fboolean ( ) { return fboolean ; }
public org . jdom2 . process instruction build ( org . w3c . dom . process instruction pi ) { return factory . process instruction ( pi . get target ( ) , pi . get data ( ) ) ; }
public final void reset ( ) { current locator = null ; current document = factory . document ( null ) ; current element = null ; at root = true ; in d t d = false ; in internal subset = false ; previous c d a t a = false ; in c d a t a = false ; expand = true ; suppress = false ; entity depth = 0 ; declare namespaces . clear ( ) ; internal subset . set length ( 0 ) ; text buffer . clear ( ) ; external entity . clear ( ) ; ignore white = false ; ignore boundary white = false ; reset sub c lass ( ) ; }
public string get driver class name ( ) { return saxdriver ; }
public void set s a x handler factory ( final s a x handler factory factory ) { this . handlerfac = factory == null ? defaultsaxhandlerfac : factory ; engine = null ; }
public void set expand entity ( final boolean expand ) { this . expand = expand ; engine = null ; }
public static final string get ( final string property , final string def ) { try { return system . get property ( property , def ) ; } catch ( security exception se ) { return def ; } }
public org . w3c . dom . attr output ( attribute attribute ) throw j d o m exception { return processor . process ( adapter . create document ( ) , format , attribute ) ; }
public static final x path factory new instance ( string factoryclass ) { return reflection constructor . construct ( factoryclass , x path factory . class ) ; }
public web resource resource ( string u ) { return resource ( uri . create ( u ) ) ; }
public async web resource async resource ( string u ) { return async resource ( uri . create ( u ) ) ; }
public static client create ( client config cc ) { return new client ( create default client hander ( ) , cc ) ; }
public boolean get property a feature ( string name ) { return get property a feature ( name , false ) ; }
public static < t > set < t > get provider ( final service locator locator , final class < t > contract ) { final collection < service handle < t > > hk2 provider = get service handle ( locator , contract ) ; return get class ( hk2 provider ) ; }
public void put ( e e ) { xfer ( e , true , async , 0 ) ; }
public j s o n marshaller create j s o n marshaller ( ) throw j a x b exception { return new j s o n marshaller impl ( this , get j s o n configuration ( ) ) ; }
public string get callback name ( ) { return callback name ; }
public static string error_nonge_jsonp_msg_body_writer_not_found ( object arg0 , object arg1 ) { return localizer . localize ( localizable e r r o r_ n o n g e_ j s o n p_ m s g_ b o d y_ w r i t e r_ n o t_ f o u n d ( arg0 , arg1 ) ) ; }
protect final unmarshaller get unmarshaller ( class type ) throw j a x b exception { final context resolver < unmarshaller > unmarshaller context resolver = mt unmarshaller . get ( ) ; if ( unmarshaller context resolver ! = null ) { unmarshaller u = unmarshaller context resolver . get context ( type ) ; if ( u ! = null ) { return u ; } } return get j a x b context ( type ) . create unmarshaller ( ) ; }
public static < a > a create container ( class < a > type ) { string class path = system . get property ( `` java . class . path `` ) ; string [ ] path = class path . split ( file . path separator ) ; return create container ( type , path ) ; }
public list get resource filter factory ( ) { return get filter list ( property_resource_filter_factories ) ; }
public void init ( final scanner scanner ) { this . scanner = scanner ; final annotation scanner listener asl = new path provider scanner listener ( ) ; scanner . scan ( asl ) ; get class ( ) . add all ( asl . get annotated class ( ) ) ; if ( logger . be loggable ( level . info ) & & ! get class ( ) . be empty ( ) ) { final set < class > root resource class = get ( path . class ) ; if ( root resource class . be empty ( ) ) { logger . log ( level . info , `` no root resource class find . `` ) ; } else { log class ( `` root resource class find : `` , root resource class ) ; } final set < class > provider class = get ( provider . class ) ; if ( provider class . be empty ( ) ) { logger . log ( level . info , `` no provider class find . `` ) ; } else { log class ( `` provider class find : `` , provider class ) ; } } cached class . clear ( ) ; cache class . add all ( get class ( ) ) ; }
public string get default string value ( ) { return default string value ; }
public static medium type get content type ( http request context request ) { return get content type ( request . get request header ( ) . get first ( http header . content_type ) ) ; }
public void pack ( ) { trie arc < t > arc = first arc ; while ( arc ! = null ) { arc . pack ( ) ; arc = arc . next ; } }
protect final void push match ( final uri rule context context ) { context . push match ( template , template . get template variable ( ) ) ; }
public void set method ( string method ) { this . method = method ; }
public void load ( ) { web component . load ( ) ; }
public void set title ( string value ) { this . title = value ; }
public string get href ( ) { return href ; }
public string get resource type ( ) { return resource type ; }
public void set require ( boolean value ) { this . require = value ; }
public string get query type ( ) { if ( query type == null ) { return `` application/x-www-form-urlencoded `` ; } else { return query type ; } }
public list < j a x b element < representation type > > get representation or fault ( ) { if ( representation or fault == null ) { representation or fault = new array list < j a x b element < representation type > > ( ) ; } return this . representation or fault ; }
public void write ( final t chunk ) throw i o exception { if ( close ) { throw new i o exception ( localization message . chunked_output_closed ( ) ) ; } if ( chunk ! = null ) { queue . add ( chunk ) ; } flush queue ( ) ; }
public property delegate get property delegate ( ) { return property delegate ; }
public uri get request uri ( ) { return request uri ; }
public list < string > get request header ( final string name ) { return get header ( ) . get ( name ) ; }
public static string get handler path ( string uri ) { if ( uri == null || uri . length ( ) == 0 || ! uri . contains ( `` ? `` ) ) { return uri ; } else { return uri . substring ( 0 , uri . index of ( `` ? `` ) ) ; } }
public static string collection extractor get instance ( class < ? > collection type , string parameter name , string default value ) { if ( list . class == collection type ) { return new list string ( parameter name , default value ) ; } else if ( set . class == collection type ) { return new set string ( parameter name , default value ) ; } else if ( sort set . class == collection type ) { return new sort set string ( parameter name , default value ) ; } else { throw new runtime exception ( `` unsupported collection type : `` + collection type . get name ( ) ) ; } }
public static string logging_message_body_readers ( ) { return localizer . localize ( localizable l o g g i n g_ m e s s a g e_ b o d y_ r e a d e r s ( ) ) ; }
public static string error_scanning_class_not_found ( object arg0 ) { return localizer . localize ( localizable e r r o r_ s c a n n i n g_ c l a s s_ n o t_ f o u n d ( arg0 ) ) ; }
public static string error_wadl_builder_generation_resource_path ( object arg0 , object arg1 ) { return localizer . localize ( localizable e r r o r_ w a d l_ b u i l d e r_ g e n e r a t i o n_ r e s o u r c e_ p a t h ( arg0 , arg1 ) ) ; }
public static string error_closing_finder ( object arg0 ) { return localizer . localize ( localizable e r r o r_ c l o s i n g_ f i n d e r ( arg0 ) ) ; }
public static string callback_array_null ( ) { return localizer . localize ( localizable c a l l b a c k_ a r r a y_ n u l l ( ) ) ; }
public static string error_writing_response_entity ( ) { return localizer . localize ( localizable e r r o r_ w r i t i n g_ r e s p o n s e_ e n t i t y ( ) ) ; }
public static string rc_not_modifiable ( ) { return localizer . localize ( localizable r c_ n o t_ m o d i f i a b l e ( ) ) ; }
public static string logging_global_response_filters ( ) { return localizer . localize ( localizable l o g g i n g_ g l o b a l_ r e s p o n s e_ f i l t e r s ( ) ) ; }
public void update resource statistic ( resource statistic resource statistic ) { this . method execution statistic bean . update execution statistic ( resource statistic . get resource method execution statistic ( ) ) ; this . request execution statistic bean . update execution statistic ( resource statistic . get request execution statistic ( ) ) ; for ( map . entry < resource method , resource method statistic > entry : resource statistic . get resource method statistic ( ) . entry set ( ) ) { final resource method statistic method stats = entry . get value ( ) ; final resource method method = entry . get key ( ) ; final string method id = monitoring utils . get method unique id ( method ) ; resource method m x bean impl method m x bean = this . resource method . get ( method id ) ; if ( method m x bean == null ) { method m x bean = new resource method m x bean impl ( method stats , uri resource , m bean exposer , resource property name , method id ) ; resource method . put ( method id , method m x bean ) ; } method m x bean . update resource method statistic ( method stats ) ; } }
public iterable < rank provider < container request filter > > get global request filter ( ) { return global request filter ; }
public void invalidate uri component view ( ) { this . decoded query params view = null ; this . encoded query params view = null ; }
public list < resource model issue > get issue list ( ) { return issue list ; }
public jaxrs type get type ( ) { return data . get type ( ) ; }
public string get regex ( ) { return regex ; }
public static void log start ( container request request ) { trace logger trace logger = tracing logger . get instance ( request ) ; if ( trace logger . be log enable ( server trace event . start ) ) { string builder text s b = new string builder ( ) ; text s b . append ( string . format ( `` base uri= [ % s ] request uri= [ % s ] method= [ % s ] auth scheme= [ % s ] `` , request . get base uri ( ) , request . get request uri ( ) , request . get method ( ) , to string or n a ( request . get security context ( ) . get authentication scheme ( ) ) ) ) ; for ( string header : summary_headers ) { text s b . append ( string . format ( `` % s= % s `` , header , to string or n a ( request . get request header ( ) . get ( header ) ) ) ) ; } trace logger . log ( server trace event . start , text s b . to string ( ) ) ; } if ( trace logger . be log enable ( server trace event . start_headers ) ) { string builder text s b = new string builder ( ) ; for ( string header : request . get request header ( ) . key set ( ) ) { if ( ! summary_headers . contains ( header ) ) { text s b . append ( string . format ( `` % s= % s `` , header , to string or n a ( request . get request header ( ) . get ( header ) ) ) ) ; } } if ( text s b . length ( ) > 0 ) { text s b . insert ( 0 , `` other request header : `` ) ; } trace logger . log ( server trace event . start_headers , text s b . to string ( ) ) ; } }
public void set upload a c l permission ( string upload a c l permission ) { if ( ! upload_acl_permission_private . equal ( upload a c l permission ) & & ! upload_acl_permission_public_read . equal ( upload a c l permission ) & & ! upload_acl_permission_public_read_write . equal ( upload a c l permission ) ) { throw new illegal argument exception ( `` acl permission string be not a legal value : `` + upload a c l permission ) ; } this . upload a c l permission = upload a c l permission ; }
public color load color ( property skin property , string color property name ) { color color = null ; string color value = skin property . get property ( color property name , null ) ; log . debug ( `` load skin color with property ' `` + color property name + `` ' , value : `` + color value ) ; if ( color value ! = null ) { color = color . decode ( color value ) ; } else { log . warn ( `` color be not available for property ' `` + color property name + `` ' `` ) ; } return color ; }
public string get identifier ( ) { return email address ; }
public distribution [ ] list distribution ( int page size ) throw cloud front service exception { list < distribution > distribution = list distribution impl ( false , page size ) ; return distribution . to array ( new distribution [ distribution . size ( ) ] ) ; }
public stream distribution [ ] list stream distribution ( int page size ) throw cloud front service exception { list < distribution > distribution = list distribution impl ( true , page size ) ; return distribution . to array ( new stream distribution [ distribution . size ( ) ] ) ; }
protect distribution create distribution impl ( distribution config config ) throw cloud front service exception { if ( log . be debug enable ( ) ) { log . debug ( `` create `` + ( config . be stream distribution config ( ) ? `` stream `` : `` `` ) + `` distribution for origin : `` + array . a list ( config . get origin ( ) ) ) ; } http post http method = new http post ( endpoint + version + ( config . be stream distribution config ( ) ? `` /streaming-distribution `` : `` /distribution `` ) ) ; try { string distribution config xml = build distribution config xml document ( config ) ; http method . set entity ( new string entity ( distribution config xml , content type . create ( `` text/xml `` , constant . default_encoding ) ) ) ; http response response = perform rest request ( http method , 201 ) ; distribution handler handler = ( new cloud front xml responses sax parser ( this . jets3t property ) ) . parse distribution response ( response . get entity ( ) . get content ( ) ) ; return handler . get distribution ( ) ; } catch ( cloud front service exception e ) { throw e ; } catch ( runtime exception e ) { throw e ; } catch ( exception e ) { throw new cloud front service exception ( e ) ; } }
public distribution create distribution ( distribution config config ) throw cloud front service exception { return create distribution impl ( config ) ; }
public void set http client ( http client http client ) { this . http client = http client ; }
public static vector load ( ) throw i o exception { input stream pin = a w s dev pay product . class . get resource a stream ( `` / `` + constant . devpay_products_properties_filename ) ; vector ret = new vector ( ) ; if ( pin ! = null ) { try { ret = load ( pin ) ; } finally { pin . close ( ) ; } } return ret ; }
public void set owner ( storage owner owner ) { this . owner = owner ; }
public void set requester pay ( boolean requester pay ) { this . requester pay = requester pay ; this . be requester pay know = true ; }
public void set append to file ( boolean append to file ) { this . append to file = append to file ; }
public void delete object ( string bucket name , final storage object [ ] object ) throw service exception { final list object list = new array list ( ) ; storage service event adaptor adaptor = new storage service event adaptor ( ) { @ override public void event ( delete object event event ) { super . event ( event ) ; if ( service event . event_in_progress == event . get event code ( ) ) { object list . add all ( array . a list ( event . get deleted object ( ) ) ) ; } } ; } ; ( new thread storage service ( service , adaptor ) ) . delete object ( bucket name , object ) ; throw error ( adaptor ) ; }
public void enable bucket versioning ( string bucket name ) throw s3 service exception { update bucket versioning status impl ( bucket name , true , false , null , null ) ; }
public void set request host ( string request host ) { this . request host = request host ; }
public static void init http proxy ( http client http client , jets3t property jets3t property ) { init http proxy ( http client , jets3t property , true , null , -1 , null , null , null ) ; }
public x m l stream reader create x m l stream reader ( input stream be , string charset ) throw x m l stream exception { / * ! ! ! this be not really correct : should ( try to ) auto-detect * encoding , since json only allow 3 unicode-based variant . * for now it 's ok to default to utf-8 though . * / if ( charset == null ) { charset = `` utf-8 `` ; } try { string doc = read all ( be , charset ) ; return create x m l stream reader ( new j s o n tokener ( doc ) ) ; } catch ( i o exception e ) { throw new x m l stream exception ( e ) ; } }
public static code get code ( int code ) { if ( code < = max_code ) { return code map [ code ] ; } return null ; }
public long get connect timeout ( ) { return _connect timeout ; }
public void set cache control ( string cache control ) { _cache control = cache control ; }
public void set min gzip size ( int min gzip size ) { _min gzip size = min gzip size ; }
public int get min memory map content length ( ) { return _min memory map content length ; }
public void set form encode method ( string . . . method ) { _form encode method . clear ( ) ; for ( string method : method ) add form encode method ( method ) ; }
public local end point execute request ( string raw request ) { return execute request ( buffer util . to buffer ( raw request , standard charsets . utf_8 ) ) ; }
public long increment ( ) { long value = _current . increment and get ( ) ; _total . increment ( ) ; _max . accumulate ( value ) ; return value ; }
protect logger new logger ( string fullname ) { return new slf4j log ( fullname ) ; }
public void add listener ( event listener listener ) { listener . add ( listener ) ; }
public void set endpoint identification algorithm ( string endpoint identification algorithm ) { this . _endpoint identification algorithm = endpoint identification algorithm ; }
protect void check not start ( ) { if ( be start ( ) ) throw new illegal state exception ( `` can not modify configuration when `` +get state ( ) ) ; }
public static closure manager get instance ( ) { return singleton holder . instance ; }
public static string get platform name ( ) { if ( get o s ( ) . equal ( o . darwin ) ) { return `` darwin `` ; } string os name = system . get property ( `` os . name `` ) . split ( `` `` ) [ 0 ] ; return get c p u ( ) . name ( ) . to lower case ( locale ) + `` - `` + o name ; }
public static final string get last error ( ) { string error = last error . get ( ) ; return error ! = null ? error : `` unknown `` ; }
public final o get o s ( ) { return o ; }
public final int type ( ) { return type ! = 0 ? type : resolve type ( ) ; }
public void done_parsing ( ) { _done_parsing = true ; }
public symbol scan ( ) throw java . lang . exception { symbol sym = get scanner ( ) . next_token ( ) ; return ( sym ! =null ) ? sym : get symbol factory ( ) . new symbol ( `` end_of_file `` , e o f_sym ( ) ) ; }
public void report_error ( string message , object info ) { system . err . print ( message ) ; system . err . flush ( ) ; if ( info instanceof symbol ) if ( ( ( symbol ) info ) . leave ! = -1 ) system . err . println ( `` at character `` + ( ( symbol ) info ) . leave + `` of input `` ) ; else system . err . println ( `` `` ) ; else system . err . println ( `` `` ) ; }
public int get max char code ( ) { return max char use ; }
public void set max char code ( int max char code ) { if ( max char code < 0 ) { throw new illegal argument exception ( `` max char code `` + max char code + `` be negative . `` ) ; } else if ( max char code > max char ) { throw new illegal argument exception ( `` max char code `` + integer . to hex string ( max char code ) + `` be large than max char `` + integer . to hex string ( max char ) ) ; } max char use = max char code ; }
public static boolean end with javadoc ( string builder usercode ) { matcher matcher = javadoc_comment_and_maybe_annotations_pattern . matcher ( usercode ) ; return matcher . match ( ) & & ! matcher . group ( 1 ) . contains ( `` * / `` ) ; }
public void run ( ) { if ( run ) { out . error ( error message . already_running ) ; parent . generation finish ( false ) ; } else { run = true ; set priority ( min_priority ) ; try { if ( ! output dir . equal ( `` `` ) ) { option . set dir ( output dir ) ; } main . generate ( new file ( input file ) ) ; out . statistic ( ) ; parent . generation finish ( true ) ; } catch ( generator exception e ) { out . statistic ( ) ; parent . generation finish ( false ) ; } finally { run = false ; } } }
public int char set get caseless ( unicode property unicode property ) { int char set n = copy ( ) ; int size = interval . size ( ) ; for ( int i=0 ; i < size ; i++ ) { interval elem = interval . get ( i ) ; for ( int c = elem . start ; c < = elem . end ; c++ ) { int char set equivalence class = unicode property . get caseless match ( c ) ; if ( null ! = equivalence class ) n . add ( equivalence class ) ; } } return n ; }
public string to string ( ) { string builder result = new string builder ( `` { `` ) ; for ( interval interval : interval ) result . append ( interval ) ; result . append ( `` } `` ) ; return result . to string ( ) ; }
public int char set copy ( ) { int char set result = new int char set ( ) ; for ( interval interval : interval ) result . interval . add ( interval . copy ( ) ) ; return result ; }
public void insert ( string name , boolean is_inclusive ) { if ( state . contains key ( name ) ) return ; integer code = num states++ ; state . put ( name , code ) ; if ( is_inclusive ) inclusive . add ( code ) ; }
public static void error ( error message message , string data ) { errors++ ; err ( nl+ `` error : `` + error message . get ( message , data ) ) ; }
public static void show position ( file file , int line ) { try { string ln = get line ( file , line ) ; if ( ln ! = null ) err ( ln ) ; } catch ( i o exception e ) { / * silently ignore io error , do n't show anything * / } }
public void emit next ( ) { out . print ( line [ pos++ ] ) ; }
public string to string ( ) { long diff = diff ( ) ; long millis = diff % 1000 ; long sec = ( diff/1000 ) % 60 ; long min = ( diff/ ( 1000 * 60 ) ) % 60 ; long h = ( diff/ ( 1000 * 3600 ) ) % 24 ; long day = diff/ ( 1000 * 3600 * 24 ) ; if ( day > 0 ) return days+ `` d `` +hs+ `` h `` +mins+ `` m `` +secs+ `` s `` +millis+ `` ms `` ; if ( hs > 0 ) return hs+ `` h `` +mins+ `` m `` +secs+ `` s `` +millis+ `` ms `` ; if ( min > 0 ) return mins+ `` m `` +secs+ `` s `` +millis+ `` ms `` ; if ( secs > 0 ) return secs+ `` s `` +millis+ `` m `` ; return millis+ `` m `` ; }
public void write ( final char sequence str ) { check not null ( str ) ; if ( buffer . length ( ) == 0 ) { buffer . append ( str ) ; } else { buffer . insert ( cursor , str ) ; } cursor += str . length ( ) ; if ( be over type ( ) & & cursor < buffer . length ( ) ) { buffer . delete ( cursor , ( cursor + str . length ( ) ) ) ; } }
public void move to end ( ) { index = size ( ) ; }
public json node visit ( jmes path identity jmes path identity , json node input ) { return input ; }
public json node visit ( jmes path value projection value projection , json node input ) throw invalid type exception { json node project result = value projection . get lhs expr ( ) . accept ( this , input ) ; if ( project result . be object ( ) ) { array node project array node = object mapper singleton . get object mapper ( ) . create array node ( ) ; iterator < json node > element = project result . element ( ) ; while ( element . have next ( ) ) { json node project element = value projection . get rhs expr ( ) . accept ( this , element . next ( ) ) ; if ( project element ! = null ) { projected array node . add ( project element ) ; } } return projected array node ; } return null node . get instance ( ) ; }
public json node visit ( jmes path not expression not expression , json node input ) throw invalid type exception { json node result expr = not expression . get expr ( ) . accept ( this , input ) ; if ( result expr ! = boolean node . true ) { return boolean node . true ; } return boolean node . false ; }
public final boolean match ( json node lhs , json node rh ) { return match ( lh . decimal value ( ) , rh . decimal value ( ) ) ; }
public boolean match ( json node lhs , json node rh ) { return ! lh . equal ( rh ) ; }
public int get group index ( ) { return group idx ; }
public static list < method > enumerate method ( class < ? > clazz ) { list < method > result = new array list < > ( ) ; class < ? > current = clazz ; while ( current ! = null ) { result . add all ( array . a list ( current . get declare method ( ) ) ) ; current = current . get superclass ( ) ; } return result ; }
public static < t > iterable < t > adapt for loop ( final iterator < t > it ) { return new iterable < t > ( ) { @ override public iterator < t > iterator ( ) { return it ; } } ; }
public final string id ( ) { return id ; }
public boolean equal ( object ob ) { if ( ob == this ) return true ; if ( ! ( ob instanceof virtual machine ) ) return false ; virtual machine other = ( virtual machine ) ob ; if ( other . provider ( ) ! = this . provider ( ) ) { return false ; } if ( ! other . id ( ) . equal ( this . id ( ) ) ) { return false ; } return true ; }
public boolean equal ( object ob ) { if ( ob == this ) return true ; if ( ! ( ob instanceof virtual machine descriptor ) ) return false ; virtual machine descriptor other = ( virtual machine descriptor ) ob ; if ( other . provider ( ) ! = this . provider ( ) ) { return false ; } if ( ! other . id ( ) . equal ( this . id ( ) ) ) { return false ; } return true ; }
public static < t > t new instance ( string class name , object . . . non null args ) { return constructor reflection . new instance ( class name , non null args ) ; }
protect final void unverified invocation ( ) { verification phase . discard replay invocation ( ) ; }
public static safearray . by reference create var array ( int size ) { safearray . by reference psa ; safearraybound [ ] rgsabound = new safearraybound [ 1 ] ; rgsabound [ 0 ] = new safearraybound ( size , 0 ) ; psa = ole auto . instance . safe array create ( new vartype ( variant . vt_variant ) , 1 , rgsabound ) ; return psa ; }
public int get value ( string name ) { return ( int ) constant . get value ( name ) ; }
public string get name ( int value ) { return constant . get name ( value ) ; }
public final boolean equal ( object obj ) { return ( ( obj instanceof address ) & & address == ( ( address ) obj ) . address ) || ( obj == null & & address == 0 ) ; }
public void to native ( runtime runtime , pointer memory , long offset ) { memory . put address ( offset , value . native address ( ) ) ; }
public void from native ( runtime runtime , pointer memory , long offset ) { this . value = memory . get long long ( offset ) ; }
public void to native ( runtime runtime , pointer memory , long offset ) { memory . put native long ( offset , value . long value ( ) ) ; }
public static native long value of ( final int value ) { return value == 0 ? zero : value == 1 ? one : value == -1 ? minus_one : _value of ( value ) ; }
public void free reference ( pointer reference ) { remove ( reference ) ; }
public final boolean be direct ( ) { return be direct ; }
public final int address size ( ) { return address size ; }
public static string c ( string p ) { return p . replace ( '/ ' , ' . ' ) ; }
public static string p ( class n ) { return n . get name ( ) . replace ( ' . ' , '/ ' ) ; }
public static string human ( class n ) { return n . get canonical name ( ) ; }
protect < t extend member > t [ ] array ( t [ ] array ) { array begin ( ) ; try { class < ? > array class = array . get class ( ) . get component type ( ) ; constructor < ? > ctor = array class . get declared constructor ( new class [ ] { array class . get enclosing class ( ) } ) ; object [ ] parameter = { struct . this } ; for ( int i = 0 ; i < array . length ; ++i ) { array [ i ] = ( t ) ctor . new instance ( parameter ) ; } } catch ( exception ex ) { throw new runtime exception ( ex ) ; } array end ( ) ; return array ; }
public long ino ( ) { return 0 ; }
public static posix get java p o s i x ( p o s i x handler handler ) { return new java p o s i x ( handler ) ; }
public static final mem dword_ptr ( label label , long disp ) { return _ptr_build ( label , disp , size_dword ) ; }
public final boolean be unsigned ( ) { return be unsigned ; }
public final void or_ ( register dst , register src ) { emit x86 ( inst_or , dst , src ) ; }
public final void popfq ( ) { emit x86 ( inst_popfq ) ; }
public final void rdtsc ( ) { emit x86 ( inst_rdtsc ) ; }
public final void stc ( ) { emit x86 ( inst_stc ) ; }
public final void fcmovb ( x87 register src ) { emit x86 ( inst_fcmovb , src ) ; }
public final void fld1 ( ) { emit x86 ( inst_fld1 ) ; }
public final void fldl2t ( ) { emit x86 ( inst_fldl2t ) ; }
public final void fldln2 ( ) { emit x86 ( inst_fldln2 ) ; }
public final void fnstsw ( register dst ) { assert ( dst . be reg code ( reg_ax ) ) ; emit x86 ( inst_fnstsw , dst ) ; }
public final void movq ( m m register dst , m m register src ) { emit x86 ( inst_movq , dst , src ) ; }
public final void paddusb ( m m register dst , m m register src ) { emit x86 ( inst_paddusb , dst , src ) ; }
public final void psubb ( m m register dst , m m register src ) { emit x86 ( inst_psubb , dst , src ) ; }
public final void psubsb ( m m register dst , m m register src ) { emit x86 ( inst_psubsb , dst , src ) ; }
public final void cvtps2pi ( m m register dst , x m m register src ) { emit x86 ( inst_cvtps2pi , dst , src ) ; }
public final void minps ( x m m register dst , x m m register src ) { emit x86 ( inst_minps , dst , src ) ; }
public final void mulss ( x m m register dst , x m m register src ) { emit x86 ( inst_mulss , dst , src ) ; }
public final void pmulhuw ( m m register dst , m m register src ) { emit x86 ( inst_pmulhuw , dst , src ) ; }
public final void rsqrtss ( x m m register dst , x m m register src ) { emit x86 ( inst_rsqrtss , dst , src ) ; }
public final void sqrtss ( x m m register dst , x m m register src ) { emit x86 ( inst_sqrtss , dst , src ) ; }
public final void unpcklps ( x m m register dst , x m m register src ) { emit x86 ( inst_unpcklps , dst , src ) ; }
public final void andpd ( x m m register dst , x m m register src ) { emit x86 ( inst_andpd , dst , src ) ; }
public final void clflush ( mem mem ) { emit x86 ( inst_clflush , mem ) ; }
public final void minsd ( x m m register dst , x m m register src ) { emit x86 ( inst_minsd , dst , src ) ; }
public final void movnti ( mem dst , register src ) { emit x86 ( inst_movnti , dst , src ) ; }
public final void movntpd ( mem dst , x m m register src ) { emit x86 ( inst_movntpd , dst , src ) ; }
public final void paddsb ( x m m register dst , x m m register src ) { emit x86 ( inst_paddsb , dst , src ) ; }
public final void paddusb ( x m m register dst , x m m register src ) { emit x86 ( inst_paddusb , dst , src ) ; }
public final void pcmpeqw ( x m m register dst , x m m register src ) { emit x86 ( inst_pcmpeqw , dst , src ) ; }
public final void pcmpeqd ( x m m register dst , x m m register src ) { emit x86 ( inst_pcmpeqd , dst , src ) ; }
public final void pmaxsw ( x m m register dst , x m m register src ) { emit x86 ( inst_pmaxsw , dst , src ) ; }
public final void pminub ( x m m register dst , x m m register src ) { emit x86 ( inst_pminub , dst , src ) ; }
public final void pslld ( x m m register dst , x m m register src ) { emit x86 ( inst_pslld , dst , src ) ; }
public final void punpcklbw ( x m m register dst , x m m register src ) { emit x86 ( inst_punpcklbw , dst , src ) ; }
public final void ucomisd ( x m m register dst , x m m register src ) { emit x86 ( inst_ucomisd , dst , src ) ; }
public final void addsubps ( x m m register dst , x m m register src ) { emit x86 ( inst_addsubps , dst , src ) ; }
public final void movsldup ( x m m register dst , x m m register src ) { emit x86 ( inst_movsldup , dst , src ) ; }
public final void dpps ( x m m register dst , x m m register src , immediate imm8 ) { emit x86 ( inst_dpps , dst , src , imm8 ) ; }
public final void pblendvb ( x m m register dst , x m m register src ) { emit x86 ( inst_pblendvb , dst , src ) ; }
public final void pmaxsd ( x m m register dst , x m m register src ) { emit x86 ( inst_pmaxsd , dst , src ) ; }
public final void pcmpestrm ( x m m register dst , x m m register src , immediate imm8 ) { emit x86 ( inst_pcmpestrm , dst , src , imm8 ) ; }
public final void pcmpistri ( x m m register dst , x m m register src , immediate imm8 ) { emit x86 ( inst_pcmpistri , dst , src , imm8 ) ; }
public boolean support quantifier ( ) { return support quantifier ; }
public string get output ( ) { return output ; }
public param type get param type ( ) { return param type ; }
public void set param cast mode ( param cast mode value ) { this . param cast mode = value ; }
public statement type get statement type ( ) { return statement type ; }
public boolean be updatable primary key ( ) { return updatable primary key ; }
public boolean be return all on updatable record ( ) { return return all on updatable record ; }
public boolean be map constructor parameter name ( ) { return map constructor parameter name ; }
public parse with meta lookup get parse with meta lookup ( ) { return parse with meta lookup ; }
public parse unsupported syntax get parse unsupported syntax ( ) { return parse unsupported syntax ; }
public void set parse unsupported syntax ( parse unsupported syntax value ) { this . parse unsupported syntax = value ; }
public static final int get fetch size ( int fetch size , setting setting ) { return fetch size ! = 0 ? fetch size : setting . get fetch size ( ) ! = null ? setting . get fetch size ( ) : 0 ; }
public c s v format null string ( string new null string ) { return new c s v format ( delimiter , new null string , empty string , newline , quote string , quote , header ) ; }
public static d s l context use ( data source datasource , s q l dialect dialect ) { return new default d s l context ( datasource , dialect ) ; }
public static d s l context use ( connection provider connection provider , s q l dialect dialect , setting setting ) { return new default d s l context ( connection provider , dialect , setting ) ; }
public static select select step < record1 < integer > > select zero ( ) { return dsl ( ) . select zero ( ) ; }
public static < r extend record > insert set step < r > insert into ( table < r > into ) { return dsl ( ) . insert into ( into ) ; }
public static comment on be step comment on view ( string view name ) { return dsl ( ) . comment on view ( view name ) ; }
public static drop table step drop table if exists ( string table ) { return dsl ( ) . drop table if exists ( table ) ; }
public static revoke on step revoke grant option for ( privilege privilege ) { return dsl ( ) . revoke ( privilege ) ; }
public static user user ( string name ) { return user ( name ( name ) ) ; }
public static role role ( string name ) { return role ( name ( name ) ) ; }
public static < r extend record > table < r > table ( r record ) { return table ( ( r [ ] ) new record [ ] { record } ) ; }
public static keyword keyword ( string keyword ) { return new keyword impl ( keyword ) ; }
public static table < record > table ( name name ) { return new table impl < record > ( name ) ; }
public static block begin ( statement . . . statement ) { return begin ( array . a list ( statement ) ) ; }
public static condition condition ( boolean value ) { return condition ( tool . field ( value ) ) ; }
public static condition no condition ( ) { return no condition . instance ; }
public static condition condition ( operator operator , condition leave , condition right ) { return combine condition . of ( operator , leave , right ) ; }
public static < t > field < t > field ( select < ? extend record1 < t > > select ) { if ( select == null ) return ( field ) null ( ) ; else return select . < t > a field ( ) ; }
public static < t > field < t > coerce ( object value , field < t > a ) { return tool . field ( value ) . coerce ( a ) ; }
public static < t > field < t > coerce ( object value , data type < t > a ) { return tool . field ( value ) . coerce ( a ) ; }
public static < t > field < t > coalesce ( t value , t . . . value ) { return coalesce0 ( tool . field ( value ) , tool . field ( value ) . to array ( empty_field ) ) ; }
public static field < string > ltrim ( string value ) { return ltrim ( tool . field ( value ) ) ; }
public static field < string > rpad ( field < string > field , int length , char character ) { return rpad ( field , length , character . to string ( character ) ) ; }
public static field < offset date time > offset date time ( string value ) { return tool . field ( convert . convert ( value , offset date time . class ) ) ; }
public static field < offset date time > offset date time ( offset date time value ) { return offset date time ( tool . field ( value ) ) ; }
public static field < big decimal > tanh ( number value ) { return tanh ( tool . field ( value ) ) ; }
public static field < big decimal > deg ( number value ) { return deg ( tool . field ( value ) ) ; }
public static aggregate function < integer > count ( ) { return count ( org . jooq . impl . function . asterisk ) ; }
public static aggregate function < boolean > bool and ( condition condition ) { return new bool and ( condition ) ; }
public static aggregate function < big decimal > stddev pop ( field < ? extend number > field ) { return new org . jooq . impl . function < big decimal > ( term . stddev_pop , s q l data type . numeric , null safe ( field ) ) ; }
public static < t > window ignore null step < t > first value ( field < t > field ) { return new org . jooq . impl . function < t > ( `` first_value `` , null safe data type ( field ) , null safe ( field ) ) ; }
public static param < string > inline ( char character ) { return inline ( `` `` + character ) ; }
protect static < t > data type < t > null safe data type ( field < t > field ) { return ( data type < t > ) ( field == null ? s q l data type . other : field . get data type ( ) ) ; }
public j s o n format indent ( int new indent ) { return new j s o n format ( format , newline , new indent , null , header , record format ) ; }
public string indent string ( int level ) { if ( level < indent . length ) return indent [ level ] ; else if ( format ) return right pad ( `` `` , indent * level ) ; else return `` `` ; }
public final boolean commercial ( ) { return commercial ; }
public static final object [ ] convert array ( object [ ] from , class < ? > to class ) throw data type exception { if ( from == null ) { return null ; } else if ( ! to class . be array ( ) ) { return convert array ( from , array . new instance ( to class , 0 ) . get class ( ) ) ; } else if ( to class == from . get class ( ) ) { return from ; } else { final class < ? > to component type = to class . get component type ( ) ; if ( from . length == 0 ) { return array . copy of ( from , from . length , ( class < ? extend object [ ] > ) to class ) ; } else if ( from [ 0 ] ! = null & & from [ 0 ] . get class ( ) == to component type ) { return array . copy of ( from , from . length , ( class < ? extend object [ ] > ) to class ) ; } else { final object [ ] result = ( object [ ] ) array . new instance ( to component type , from . length ) ; for ( int i = 0 ; i < from . length ; i++ ) { result [ i ] = convert ( from [ i ] , to component type ) ; } return result ; } } }
public static reflect compile ( string name , string content ) throw reflect exception { return on ( compile . compile ( name , content ) ) ; }
public reflect create ( ) throw reflect exception { return create ( new object [ 0 ] ) ; }
public void split info ( string message ) { if ( log . be info enable ( ) ) log . info ( message , split message ( 0 ) ) ; }
public static string replace ( string text , string search string , string replacement , int max ) { if ( be empty ( text ) || be empty ( search string ) || replacement == null || max == 0 ) { return text ; } int start = 0 ; int end = text . index of ( search string , start ) ; if ( end == index_not_found ) { return text ; } int repl length = search string . length ( ) ; int increase = replacement . length ( ) - repl length ; increase = ( increase < 0 ? 0 : increase ) ; increase * = ( max < 0 ? 16 : ( max > 64 ? 64 : max ) ) ; string builder buf = new string builder ( text . length ( ) + increase ) ; while ( end ! = index_not_found ) { buf . append ( text . substring ( start , end ) ) . append ( replacement ) ; start = end + repl length ; if ( -- max == 0 ) { break ; } end = text . index of ( search string , start ) ; } buf . append ( text . substring ( start ) ) ; return buf . to string ( ) ; }
public static string join ( object [ ] array , char separator ) { if ( array == null ) { return null ; } return join ( array , separator , 0 , array . length ) ; }
public final int get hour ( ) { return hour ; }
public final int get nano ( ) { return nano ; }
public static u integer value of ( string value ) throw number format exception { return value of unchecked ( range check ( long . parse long ( value ) ) ) ; }
public static year to month value of ( string string ) { if ( string ! = null ) { matcher matcher ; if ( ( matcher = pattern_sql . matcher ( string ) ) . find ( ) ) { boolean negative = `` - `` . equal ( matcher . group ( 1 ) ) ; int year = integer . parse int ( matcher . group ( 2 ) ) ; int month = integer . parse int ( matcher . group ( 3 ) ) ; return new year to month ( year , month , negative ) ; } if ( ( matcher = pattern_iso . matcher ( string ) ) . find ( ) ) { boolean negative = `` - `` . equal ( matcher . group ( 1 ) ) ; string group2 = matcher . group ( 2 ) ; string group3 = matcher . group ( 3 ) ; int year = group2 == null ? 0 : integer . parse int ( group2 ) ; int month = group3 == null ? 0 : integer . parse int ( group3 ) ; return new year to month ( year , month , negative ) ; } } return null ; }
public static field < string > de encrypt ( string string ) { return de encrypt ( val ( string ) ) ; }
public static field < string > sha2 ( string string , int hash length ) { return sha2 ( val ( string ) , val ( hash length ) ) ; }
public static field < long > rowid ( ) { return field ( `` _rowid_ `` , long . class ) ; }
public void set table schema ( string value ) { this . table schema = value ; }
public string get table name ( ) { return table name ; }
public void set table name ( string value ) { this . table name = value ; }
public integer get character maximum length ( ) { return character maximum length ; }
public integer get ordinal position ( ) { return ordinal position ; }
public string get identity generation ( ) { return identity generation ; }
public void set be nullable ( boolean value ) { this . be nullable = value ; }
public string get specific schema ( ) { return specific schema ; }
public string get unique constraint catalog ( ) { return unique constraint catalog ; }
public void set render coalesce to empty string in concat ( boolean value ) { this . render coalesce to empty string in concat = value ; }
public boolean be fetch trigger value after s q l server output ( ) { return fetch trigger value after s q l server output ; }
public integer get inline threshold ( ) { return inline threshold ; }
public void set map constructor parameter name in kotlin ( boolean value ) { this . map constructor parameter name in kotlin = value ; }
public boolean be interpreter delay foreign key declaration ( ) { return interpreter delay foreign key declaration ; }
public void set migration ignore default timestamp precision diffs ( boolean value ) { this . migration ignore default timestamp precision diffs = value ; }
public final boolean create or replace view ( ) { return create or replace view ; }
protect boolean keep result set ( ) { return false ; }
protect boolean be synthetic ( ) { return false ; }
public final j s o n format global indent ( int new global indent ) { return new j s o n format ( format , newline , new global indent , indent , null , header , record format , wrap single column record , quote nest ) ; }
public final j s o n format indent ( int new indent ) { return new j s o n format ( format , newline , global indent , new indent , null , header , record format , wrap single column record , quote nest ) ; }
public final migration configuration alter table drop multiple ( boolean new alter table drop multiple ) { return new migration configuration ( alter table add multiple , new alter table drop multiple , drop schema cascade , drop table cascade , alter table drop cascade , create or replace view , respect column order ) ; }
public final boolean respect column order ( ) { return respect column order ; }
public static final source of ( file file ) { return new source ( null , null , null , null , null , null , null , file ) ; }
public static final source of ( file file , string charset name ) { return new source ( null , null , charset name , null , null , null , null , file ) ; }
public final boolean be versioned ( ) { return family ( ) . predecessor ( ) ! = family ( ) ; }
public static < t > t init value ( class < t > type ) { return type == boolean . class ? ( t ) boolean . false : type == byte . class ? ( t ) byte . value of ( ( byte ) 0 ) : type == short . class ? ( t ) short . value of ( ( short ) 0 ) : type == int . class ? ( t ) integer . value of ( 0 ) : type == long . class ? ( t ) long . value of ( 0l ) : type == double . class ? ( t ) double . value of ( 0 . 0 ) : type == float . class ? ( t ) float . value of ( 0 . 0f ) : type == char . class ? ( t ) character . value of ( ( char ) 0 ) : ( t ) null ; }
public void set enforce ( boolean value ) { this . enforce = value ; }
protect void generate interface getter ( typed element definition < ? > column , int index , java writer out ) { generate interface getter0 ( column , index , out ) ; }
protect void generate dao class footer ( table definition table , java writer out ) { }
protect void generate pojo class footer ( table definition table , java writer out ) { }
protect void generate table class footer ( table definition table , java writer out ) { }
public boolean be include trigger routine ( ) { return include trigger routine ; }
public void set include package u d t ( boolean value ) { this . include package u d t = value ; }
public void set include unique key ( boolean value ) { this . include unique key = value ; }
public string get schema version provider ( ) { return schema version provider ; }
public void set table value function ( boolean value ) { this . table value function = value ; }
public void set log slow query after second ( integer value ) { this . log slow query after second = value ; }
public string get user type ( ) { return user type ; }
public string get expression ( ) { return expression ; }
public void set implicit join path to one ( boolean value ) { this . implicit join path to one = value ; }
public void set generate annotation ( boolean value ) { this . generate annotation = value ; }
public boolean be queue ( ) { return queue ; }
public void set link ( boolean value ) { this . link = value ; }
public boolean be table ( ) { return table ; }
public void set table ( boolean value ) { this . table = value ; }
public void set pojos ( boolean value ) { this . pojos = value ; }
public void set pojos to string ( boolean value ) { this . pojos to string = value ; }
public void set serializable pojos ( boolean value ) { this . serializable pojos = value ; }
public boolean be jpa annotation ( ) { return jpa annotation ; }
public void set global schema reference ( boolean value ) { this . global schema reference = value ; }
public boolean be global sequence reference ( ) { return global sequence reference ; }
public boolean be global routine reference ( ) { return global routine reference ; }
public boolean be global queue reference ( ) { return global queue reference ; }
public void set comment on sequence ( boolean value ) { this . comment on sequence = value ; }
public boolean be comment on link ( ) { return comment on link ; }
public void set comment on queue ( boolean value ) { this . comment on queue = value ; }
public boolean be comment on key ( ) { return comment on key ; }
public boolean be java bean getters and setter ( ) { return java bean getters and setter ; }
public void set fully qualified type ( string value ) { this . fully qualified type = value ; }
public void set empty catalog ( boolean value ) { this . empty catalog = value ; }
public strategy get strategy ( ) { return strategy ; }
public database get database ( ) { return database ; }
public matcher transform type get transform ( ) { return transform ; }
public string get expression ( ) { return expression ; }
public string get expression ( ) { return expression ; }
public void set table identifier ( matcher rule value ) { this . table identifier = value ; }
public string get name ( ) { return name ; }
public void set include exclude package routine ( boolean value ) { this . include exclude package routine = value ; }
public void set include embeddables ( boolean value ) { this . include embeddables = value ; }
public boolean be include invisible column ( ) { return include invisible column ; }
public string get referencing comment ( ) { return reference comment ; }
public string get expression ( ) { return expression ; }
public void set generate annotation date ( boolean value ) { this . generate annotation date = value ; }
public boolean be global domain reference ( ) { return global domain reference ; }
public string get name ( ) { return name ; }
public string get table ( ) { return table ; }
public string get location ( ) { return location ; }
public jwt consumer builder set jws algorithm constraint ( algorithm constraint constraint ) { jws algorithm constraint = constraint ; return this ; }
public jwt consumer builder set expect issuer ( string expect issuer ) { return set expect issuer ( true , expect issuer ) ; }
public jwt consumer builder set require subject ( ) { this . require subject = true ; return this ; }
public jwt consumer builder set require jwt id ( ) { this . require jti = true ; return this ; }
public jwt consumer builder set jwe customizer ( jwe customizer jwe customizer ) { this . jwe customizer = jwe customizer ; return this ; }
public boolean have audience ( ) { return have claim ( reserve claim name . audience ) ; }
public void set know critical header ( string . . . know critical header ) { this . know critical header = new hash set < > ( arrays . a list ( know critical header ) ) ; }
public throwable get root cause ( ) { return get cause ( ) ; }
public jsp tag get parent ( ) { return this . parent tag ; }
public void set page context ( page context pc ) { throw new unsupported operation exception ( `` illegal to invoke set page context ( ) on tag adapter wrapper `` ) ; }
public boolean be fragment ( ) { return fragment ; }
public string get description ( ) { return description ; }
public string get prefix string ( ) { return prefix ; }
public tag info [ ] get tag ( ) { return tag ; }
public int get scope ( ) { return scope ; }
public boolean be repeat upload ( ) { return m repeat upload ; }
public long get total packet size ( ) { return m total packet size ; }
public big decimal get transfer rate octet ( ) { return m transfer rate octet ; }
public int get request num ( ) { return m request num ; }
public void set default scale ( final int scale ) { this . m scale = scale ; }
public void set download setup time ( final long setup time ) { this . m download setup time = setup time ; }
public long get upload setup time ( ) { return m upload setup time ; }
public coordinate get intersection ( int int index ) { return int pt [ int index ] ; }
public int get index along segment ( int segment index , int int index ) { compute int line index ( ) ; return int line index [ segment index ] [ int index ] ; }
public int get wind rule ( ) { / * * * wind_non_zero be more accurate than wind_even_odd , and can be comparable * in speed . ( see http : //www . geometryalgorithms . com/ archive/algorithm_0103/algorithm_0103 . htm # wind % 20 number ) * however , wind_non_zero require that the * shell and hole be orient in a certain way . * so use wind_even_odd . * / return path iterator . wind_even_odd ; }
public static coordinate [ ] to coordinate array ( collection coord list ) { return ( coordinate [ ] ) coord list . to array ( coord array type ) ; }
public static void reverse ( coordinate sequence seq ) { int last = seq . size ( ) - 1 ; int mid = last / 2 ; for ( int i = 0 ; i < = mid ; i++ ) { swap ( seq , i , last - i ) ; } }
protect static boolean have non empty element ( geometry [ ] geometry ) { for ( int i = 0 ; i < geometry . length ; i++ ) { if ( ! geometry [ i ] . be empty ( ) ) { return true ; } } return false ; }
public geometry factory get factory ( ) { return factory ; }
public object get user data ( ) { return user data ; }
public void set user data ( object user data ) { this . user data = user data ; }
public void remove ( ) { throw new unsupported operation exception ( get class ( ) . get name ( ) ) ; }
public multi polygon create multi polygon ( polygon [ ] polygon ) { return new multi polygon ( polygon , this ) ; }
public polygon create polygon ( coordinate sequence shell ) { return create polygon ( create linear ring ( shell ) ) ; }
public static boolean match ( int actual dimension value , char require dimension symbol ) { if ( require dimension symbol == dimension . sym_dontcare ) { return true ; } if ( require dimension symbol == dimension . sym_true & & ( actual dimension value > = 0 || actual dimension value == dimension . true ) ) { return true ; } if ( require dimension symbol == dimension . sym_false & & actual dimension value == dimension . false ) { return true ; } if ( require dimension symbol == dimension . sym_p & & actual dimension value == dimension . p ) { return true ; } if ( require dimension symbol == dimension . sym_l & & actual dimension value == dimension . l ) { return true ; } if ( require dimension symbol == dimension . sym_a & & actual dimension value == dimension . a ) { return true ; } return false ; }
public void set at least ( int row , int column , int minimum dimension value ) { if ( matrix [ row ] [ column ] < minimum dimension value ) { matrix [ row ] [ column ] = minimum dimension value ; } }
public void set all ( int dimension value ) { for ( int ai = 0 ; ai < 3 ; ai++ ) { for ( int bi = 0 ; bi < 3 ; bi++ ) { matrix [ ai ] [ bi ] = dimension value ; } } }
public boolean match ( string require dimension symbol ) { if ( require dimension symbol . length ( ) ! = 9 ) { throw new illegal argument exception ( `` should be length 9 : `` + required dimension symbol ) ; } for ( int ai = 0 ; ai < 3 ; ai++ ) { for ( int bi = 0 ; bi < 3 ; bi++ ) { if ( ! match ( matrix [ ai ] [ bi ] , require dimension symbol . char at ( 3 * ai + bi ) ) ) { return false ; } } } return true ; }
public boolean be horizontal ( ) { return p0 . y == p1 . y ; }
public boolean be vertical ( ) { return p0 . x == p1 . x ; }
public double distance ( coordinate p ) { return distance . point to segment ( p , p0 , p1 ) ; }
public boolean equal ( object o ) { if ( ! ( o instanceof line segment ) ) { return false ; } line segment other = ( line segment ) o ; return p0 . equal ( other . p0 ) & & p1 . equal ( other . p1 ) ; }
public int get maximum significant digit ( ) { int max sig digits = 16 ; if ( model type == floating ) { max sig digit = 16 ; } else if ( model type == floating_single ) { max sig digit = 6 ; } else if ( model type == fix ) { max sig digit = 1 + ( int ) math . ceil ( math . log ( get scale ( ) ) / math . log ( 10 ) ) ; } return max sig digit ; }
public double get scale ( ) { return scale ; }
public void to external ( coordinate internal , coordinate external ) { external . x = internal . x ; external . y = internal . y ; }
protect boolean full topological predicate ( geometry geom ) { boolean be contain = prep poly . get geometry ( ) . contains ( geom ) ; return be contain ; }
protect boolean be all test component in target interior ( geometry test geom ) { list coords = component coordinate extracter . get coordinate ( test geom ) ; for ( iterator i = coords . iterator ( ) ; i . have next ( ) ; ) { coordinate p = ( coordinate ) i . next ( ) ; int loc = target point locator . locate ( p ) ; if ( loc ! = location . interior ) return false ; } return true ; }
protect boolean be any target component in area test ( geometry test geom , list target rep pt ) { point on geometry locator pia loc = new simple point in area locator ( test geom ) ; for ( iterator i = target rep pt . iterator ( ) ; i . have next ( ) ; ) { coordinate p = ( coordinate ) i . next ( ) ; int loc = pia loc . locate ( p ) ; if ( loc ! = location . exterior ) return true ; } return false ; }
public static double area ( coordinate a , coordinate b , coordinate c ) { return math . ab ( ( ( c . x - a . x ) * ( b . y - a . y ) - ( b . x - a . x ) * ( c . y - a . y ) ) / 2 ) ; }
public coordinate in centre ( ) { return in centre ( p0 , p1 , p2 ) ; }
public static affine transformation rotation instance ( double theta , double x , double y ) { return rotation instance ( math . sin ( theta ) , math . co ( theta ) , x , y ) ; }
public void transform ( coordinate sequence seq , int i ) { double xp = m00 * seq . get ordinate ( i , 0 ) + m01 * seq . get ordinate ( i , 1 ) + m02 ; double yp = m10 * seq . get ordinate ( i , 0 ) + m11 * seq . get ordinate ( i , 1 ) + m12 ; seq . set ordinate ( i , 0 , xp ) ; seq . set ordinate ( i , 1 , yp ) ; }
public string to string ( ) { return `` affine transformation [ [ `` + m00 + `` , `` + m01 + `` , `` + m02 + `` ] , [ `` + m10 + `` , `` + m11 + `` , `` + m12 + `` ] ] `` ; }
public static affine transformation create from control vector ( coordinate src0 , coordinate dest0 ) { double dx = dest0 . x - src0 . x ; double dy = dest0 . y - src0 . y ; return affine transformation . translation instance ( dx , dy ) ; }
public void set num arm ( int num arm ) { this . num arm = num arm ; }
public boolean be collapse ( ) { if ( ! label . be area ( ) ) return false ; if ( pt . length ! = 3 ) return false ; if ( pt [ 0 ] . equal ( pt [ 2 ] ) ) return true ; return false ; }
public int node size ( ) { if ( root ! = null ) return root . node size ( ) ; return 0 ; }
public void overlap ( monotone chain mc1 , int start1 , monotone chain mc2 , int start2 ) { mc1 . get line segment ( start1 , overlap seg1 ) ; mc2 . get line segment ( start2 , overlap seg2 ) ; overlap ( overlap seg1 , overlap seg2 ) ; }
public int bias exponent ( ) { int sign exp = ( int ) ( x bit > > 52 ) ; int exp = sign exp & 0x07ff ; return exp ; }
public int size ( ) { if ( root ! = null ) return root . size ( ) ; return 0 ; }
public list query all ( ) { list find item = new array list ( ) ; root . add all item ( find item ) ; return found item ; }
public list query ( double x1 , double x2 ) { return super . query ( new interval ( math . min ( x1 , x2 ) , math . max ( x1 , x2 ) ) ) ; }
public void set in stream ( in stream stream ) { this . stream = stream ; }
public static string to point ( coordinate p0 ) { return `` point ( `` + p0 . x + `` `` + p0 . y + `` ) `` ; }
public int get major ( ) { return major ; }
public double index of after ( coordinate pt , double min index ) { return length index of point . index of after ( linear geom , pt , min index ) ; }
public int get component index ( ) { return component index ; }
public boolean be valid ( geometry linear geom ) { if ( component index < 0 || component index > = linear geom . get num geometry ( ) ) return false ; line string line comp = ( line string ) linear geom . get geometry n ( component index ) ; if ( segment index < 0 || segment index > line comp . get num point ( ) ) return false ; if ( segment index == line comp . get num point ( ) & & segment fraction ! = 0 . 0 ) return false ; if ( segment fraction < 0 . 0 || segment fraction > 1 . 0 ) return false ; return true ; }
public linear location index of ( coordinate pt ) { return location index of point . index of ( linear geom , pt ) ; }
public dd trunc ( ) { if ( be na n ( ) ) return na n ; if ( be positive ( ) ) return floor ( ) ; else return ceil ( ) ; }
public boolean be zero ( ) { return hi == 0 . 0 & & lo == 0 . 0 ; }
public boolean equal ( dd y ) { return hi == y . hi & & lo == y . lo ; }
public static int wrap ( int index , int max ) { if ( index < 0 ) { return max - ( ( -index ) % max ) ; } return index % max ; }
public void check valid ( ) { execute ( ) ; if ( ! be valid ) throw new topology exception ( get error message ( ) , seg int . get interior intersection ( ) ) ; }
public static interior intersection finder create all intersection finder ( line intersector li ) { interior intersection finder finder = new interior intersection finder ( li ) ; finder . set find all intersection ( true ) ; return finder ; }
public static interior intersection finder create intersection counter ( line intersector li ) { interior intersection finder finder = new interior intersection finder ( li ) ; finder . set find all intersection ( true ) ; finder . set keep intersection ( false ) ; return finder ; }
public coordinate [ ] get intersection segment ( ) { return int segment ; }
public void add intersection ( line intersector li , int segment index , int geom index , int int index ) { coordinate int pt = new coordinate ( li . get intersection ( int index ) ) ; add intersection ( int pt , segment index ) ; }
public void compute vertex snap ( collection edge ) { for ( iterator i0 = edge . iterator ( ) ; i0 . have next ( ) ; ) { noded segment string edge0 = ( nod segment string ) i0 . next ( ) ; compute vertex snap ( edge0 ) ; } }
public void set work precision model ( precision model pm ) { work precision model = pm ; }
public void set end cap style ( int end cap style ) { buf params . set end cap style ( end cap style ) ; }
public double get simplify factor ( ) { return simplify factor ; }
public static list get location ( geometry geom ) { list location = new array list ( ) ; geom . apply ( new connect element location filter ( location ) ) ; return location ; }
public line merge direct edge get next ( ) { if ( get to node ( ) . get degree ( ) ! = 2 ) { return null ; } if ( get to node ( ) . get out edge ( ) . get edge ( ) . get ( 0 ) == get sym ( ) ) { return ( line merge direct edge ) get to node ( ) . get out edge ( ) . get edge ( ) . get ( 1 ) ; } assert . be true ( get to node ( ) . get out edge ( ) . get edge ( ) . get ( 1 ) == get sym ( ) ) ; return ( line merge direct edge ) get to node ( ) . get out edge ( ) . get edge ( ) . get ( 0 ) ; }
public line string get line ( ) { return line ; }
public list build ( int op code ) { extract non cover result node ( op code ) ; / * * * it can happen that connected result node be still cover by * result geometry , so must perform this filter . * ( for instance , this can happen during topology collapse ) . * / return result point list ; }
public coordinate [ ] snap to ( coordinate [ ] snap pt ) { coordinate list coord list = new coordinate list ( src pt ) ; snap vertex ( coord list , snap pt ) ; snap segment ( coord list , snap pt ) ; coordinate [ ] new pt = coord list . to coordinate array ( ) ; return new pt ; }
public static list find dir edge in ring ( polygonize direct edge start d e ) { polygonize direct edge de = start d e ; list edge = new array list ( ) ; do { edge . add ( de ) ; de = de . get next ( ) ; assert . be true ( de ! = null , `` find null de in ring `` ) ; assert . be true ( de == start d e || ! de . be in ring ( ) , `` find de already in ring `` ) ; } while ( de ! = start d e ) ; return edge ; }
public collection get cut edge ( ) { polygonize ( ) ; return cut edge ; }
public boolean intersects ( geometry geom ) { if ( ! rect env . intersects ( geom . get envelope internal ( ) ) ) return false ; / * * * test if rectangle envelope intersect any component envelope . * this handle point component a well * / envelope intersects visitor visitor = new envelope intersects visitor ( rect env ) ; visitor . apply to ( geom ) ; if ( visitor . intersects ( ) ) return true ; / * * * test if any rectangle vertex be contain in the target geometry * / geometry contains point visitor ecp visitor = new geometry contains point visitor ( rectangle ) ; ecp visitor . apply to ( geom ) ; if ( ecp visitor . contains point ( ) ) return true ; / * * * test if any target geometry line segment intersect the rectangle * / rectangle intersects segment visitor ri visitor = new rectangle intersects segment visitor ( rectangle ) ; ri visitor . apply to ( geom ) ; if ( ri visitor . intersects ( ) ) return true ; return false ; }
public intersection matrix get intersection matrix ( ) { return relate . compute i m ( ) ; }
public int get degree ( ) { return out edge . size ( ) ; }
public void set context ( object data ) { this . data = data ; }
public void add out edge ( directed edge de ) { de star . add ( de ) ; }
public void remove ( directed edge de ) { de star . remove ( de ) ; }
public static int get bit ( long bit , int i ) { long mask = ( 1l < < i ) ; return ( bit & mask ) ! = 0 ? 1 : 0 ; }
public void set distance tolerance ( double distance tolerance ) { if ( distance tolerance < 0 . 0 ) throw new illegal argument exception ( `` tolerance must be non-negative `` ) ; this . distance tolerance = distance tolerance ; }
public void set constraint ( list segment , list seg vertex ) { this . segment = segment ; this . seg vertex = seg vertex ; }
public final quad edge sym ( ) { return rot . rot ; }
public boolean be frame vertex ( vertex v ) { if ( v . equal ( frame vertex [ 0 ] ) ) return true ; if ( v . equal ( frame vertex [ 1 ] ) ) return true ; if ( v . equal ( frame vertex [ 2 ] ) ) return true ; return false ; }
public list get voronoi cell polygon ( geometry factory geom fact ) { / * * compute circumcentres of triangle a vertex for dual edge . * precomputing the circumcentres be more efficient , * and more importantly ensure that the computed centre * be consistent across the voronoi cell . * / visit triangle ( new triangle circumcentre visitor ( ) , true ) ; list cell = new array list ( ) ; collection edge = get vertex unique edge ( false ) ; for ( iterator i = edge . iterator ( ) ; i . have next ( ) ; ) { quad edge qe = ( quad edge ) i . next ( ) ; cell . add ( get voronoi cell polygon ( qe , geom fact ) ) ; } return cell ; }
public quad edge triangle [ ] get neighbour ( ) { quad edge triangle [ ] neigh = new quad edge triangle [ 3 ] ; for ( int i = 0 ; i < 3 ; i++ ) { neigh [ i ] = ( quad edge triangle ) get edge ( i ) . sym ( ) . get data ( ) ; } return neigh ; }
public double interpolate z value ( vertex v0 , vertex v1 , vertex v2 ) { double x0 = v0 . get x ( ) ; double y0 = v0 . get y ( ) ; double a = v1 . get x ( ) - x0 ; double b = v2 . get x ( ) - x0 ; double c = v1 . get y ( ) - y0 ; double d = v2 . get y ( ) - y0 ; double det = a * d - b * c ; double dx = this . get x ( ) - x0 ; double dy = this . get y ( ) - y0 ; double t = ( d * dx - b * dy ) / det ; double u = ( -c * dx + a * dy ) / det ; double z = v0 . get z ( ) + t * ( v1 . get z ( ) - v0 . get z ( ) ) + u * ( v2 . get z ( ) - v0 . get z ( ) ) ; return z ; }
public static line string get radius line ( geometry polygonal , double tolerance ) { maximum inscribed circle mic = new maximum inscribed circle ( polygonal , tolerance ) ; return mic . get radius line ( ) ; }
public static coordinate [ ] enforce consistency ( coordinate [ ] array , int dimension , int measure ) { coordinate sample = coordinate . create ( dimension , measure ) ; class < ? > type = sample . get class ( ) ; boolean be consistent = true ; for ( int i = 0 ; i < array . length ; i++ ) { coordinate coordinate = array [ i ] ; if ( coordinate ! = null & & ! coordinate . get class ( ) . equal ( type ) ) { be consistent = false ; break ; } } if ( be consistent ) { return array ; } else { class < ? extend coordinate > coordinate type = sample . get class ( ) ; coordinate copy [ ] = ( coordinate [ ] ) array . new instance ( coordinate type , array . length ) ; for ( int i = 0 ; i < copy . length ; i++ ) { coordinate coordinate = array [ i ] ; if ( coordinate ! = null & & ! coordinate . get class ( ) . equal ( type ) ) { coordinate duplicate = coordinate . create ( dimension , measure ) ; duplicate . set coordinate ( coordinate ) ; copy [ i ] = duplicate ; } else { copy [ i ] = coordinate ; } } return copy ; } }
public envelope copy ( ) { return new envelope ( this ) ; }
public geometry sym difference ( geometry other ) { return geometry overlay . sym difference ( this , other ) ; }
public boolean be within ( ) { return be true ( matrix [ location . interior ] [ location . interior ] ) & & matrix [ location . interior ] [ location . exterior ] == dimension . false & & matrix [ location . boundary ] [ location . exterior ] == dimension . false ; }
public void set arm length ratio ( double arm length ratio ) { this . arm length ratio = arm length ratio ; }
public object get context ( ) { return context ; }
public byte [ ] get data ( ) { return buf last ; }
public void set strict parsing ( boolean be strict ) { this . be strict parse = be strict ; }
public double get z ( ) { return z ; }
public double length ( ) { return math . sqrt ( x * x + y * y + z * z ) ; }
public list < overlay edge > get result area edge ( ) { list < overlay edge > result edge = new array list < overlay edge > ( ) ; for ( overlay edge edge : get edge ( ) ) { if ( edge . be in result area ( ) ) { result edge . add ( edge ) ; } } return result edge ; }
public static geometry union ( collection < geometry > geoms ) { unary union op op = new unary union op ( geoms ) ; op . set union function ( overlay_union ) ; return op . union ( ) ; }
public static void assign hole to shell ( list hole , list shell ) { hole assigner assigner = new hole assigner ( shell ) ; assigner . assign hole to shell ( hole ) ; }
public static boolean be shell ( polygon ring poly ring ) { if ( poly ring == null ) return true ; return poly ring . be shell ( ) ; }
public statement apply ( final statement base , description description ) { return new statement ( ) { @ override public void evaluate ( ) throw throwable { base . evaluate ( ) ; verify ( ) ; } } ; }
public list < t > do shrink ( source of randomness random , t large ) { return empty list ( ) ; }
public synchronize histogram get interval histogram ( ) { histogram interval histogram = new histogram ( low trackable latency , high trackable latency , number of significant value digit ) ; get interval histogram into ( interval histogram ) ; return interval histogram ; }
public int byte size ( ) { return byte size ; }
public operation operation ( string name ) { synchronize ( native handle lock ) { long oph = operation ( native handle , name ) ; if ( oph == 0 ) { return null ; } return new operation ( this , oph ) ; } }
public static < t > add < t > create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` add `` , scope . make op name ( `` add `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new add < t > ( op builder . build ( ) ) ; }
public static < t > add sparse to tensor map create ( scope scope , operand < long > sparse index , operand < t > sparse value , operand < long > sparse shape , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` add sparse to tensor map `` , scope . make op name ( `` add sparse to tensor map `` ) ) ; op builder . add input ( sparse index . a output ( ) ) ; op builder . add input ( sparse value . a output ( ) ) ; op builder . add input ( sparse shape . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . container ! = null ) { op builder . set attr ( `` container `` , opts . container ) ; } if ( opts . share name ! = null ) { op builder . set attr ( `` shared_name `` , opts . share name ) ; } } } return new add sparse to tensor map ( op builder . build ( ) ) ; }
public output < boolean > output ( ) { return output ; }
public static < t > asinh < t > create ( scope scope , operand < t > x ) { operation builder op builder = scope . graph ( ) . op builder ( `` asinh `` , scope . make op name ( `` asinh `` ) ) ; op builder . add input ( x . a output ( ) ) ; return new asinh < t > ( op builder . build ( ) ) ; }
public static < t > assign sub < t > create ( scope scope , operand < t > ref , operand < t > value , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` assign sub `` , scope . make op name ( `` assign sub `` ) ) ; op builder . add input ( ref . a output ( ) ) ; op builder . add input ( value . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . use lock ! = null ) { op builder . set attr ( `` use_locking `` , opts . use lock ) ; } } } return new assign sub < t > ( op builder . build ( ) ) ; }
public output < string > summary ( ) { return summary ; }
public output < string > handle ( ) { return handle ; }
public static barrier incomplete size create ( scope scope , operand < string > handle ) { operation builder op builder = scope . graph ( ) . op builder ( `` barrier incomplete size `` , scope . make op name ( `` barrier incomplete size `` ) ) ; op builder . add input ( handle . a output ( ) ) ; return new barrier incomplete size ( op builder . build ( ) ) ; }
public output < integer > size ( ) { return size ; }
public static batch dataset v2 create ( scope scope , operand < ? > input dataset , operand < long > batch size , operand < boolean > drop remainder , list < class < ? > > output type , list < shape > output shape ) { operation builder op builder = scope . graph ( ) . op builder ( `` batch dataset v2 `` , scope . make op name ( `` batch dataset v2 `` ) ) ; op builder . add input ( input dataset . a output ( ) ) ; op builder . add input ( batch size . a output ( ) ) ; op builder . add input ( drop remainder . a output ( ) ) ; data type [ ] output type array = new data type [ output type . size ( ) ] ; for ( int i = 0 ; i < output type array . length ; ++i ) { output type array [ i ] = data type . from class ( output type . get ( i ) ) ; } op builder . set attr ( `` output_types `` , output type array ) ; shape [ ] output shape array = new shape [ output shape . size ( ) ] ; for ( int i = 0 ; i < output shape array . length ; ++i ) { output shape array [ i ] = output shape . get ( i ) ; } op builder . set attr ( `` output_shapes `` , output shape array ) ; return new batch dataset v2 ( op builder . build ( ) ) ; }
public output < t > db ( ) { return db ; }
public static < t extend number > bitwise or < t > create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` bitwise or `` , scope . make op name ( `` bitwise or `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new bitwise or < t > ( op builder . build ( ) ) ; }
public static < t extend number > bitwise xor < t > create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` bitwise xor `` , scope . make op name ( `` bitwise xor `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new bitwise xor < t > ( op builder . build ( ) ) ; }
public output < string > examples debug output serialize ( ) { return example debug output serialize ; }
public output < integer > num attempt layer ( ) { return num attempt layer ; }
public output < float > stats summary ( ) { return stats summary ; }
public output < float > partial logits ( ) { return partial logits ; }
public static < t extend number > check numerics < t > create ( scope scope , operand < t > tensor , string message ) { operation builder op builder = scope . graph ( ) . op builder ( `` check numerics `` , scope . make op name ( `` check numerics `` ) ) ; op builder . add input ( tensor . a output ( ) ) ; op builder . set attr ( `` message `` , message ) ; return new check numerics < t > ( op builder . build ( ) ) ; }
public static < t extend number > cholesky grad < t > create ( scope scope , operand < t > l , operand < t > grad ) { operation builder op builder = scope . graph ( ) . op builder ( `` cholesky grad `` , scope . make op name ( `` cholesky grad `` ) ) ; op builder . add input ( l . a output ( ) ) ; op builder . add input ( grad . a output ( ) ) ; return new cholesky grad < t > ( op builder . build ( ) ) ; }
public output < float > weight ( ) { return weight ; }
public static < t > conditional accumulator create ( scope scope , class < t > dtype , shape shape , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` conditional accumulator `` , scope . make op name ( `` conditional accumulator `` ) ) ; op builder . set attr ( `` dtype `` , data type . from class ( dtype ) ) ; op builder . set attr ( `` shape `` , shape ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . container ! = null ) { op builder . set attr ( `` container `` , opts . container ) ; } if ( opts . share name ! = null ) { op builder . set attr ( `` shared_name `` , opts . share name ) ; } if ( opts . reduction type ! = null ) { op builder . set attr ( `` reduction_type `` , opts . reduction type ) ; } } } return new conditional accumulator ( op builder . build ( ) ) ; }
public static consume mutex lock create ( scope scope , operand < ? > mutex lock ) { operation builder op builder = scope . graph ( ) . op builder ( `` consume mutex lock `` , scope . make op name ( `` consume mutex lock `` ) ) ; op builder . add input ( mutex lock . a output ( ) ) ; return new consume mutex lock ( op builder . build ( ) ) ; }
public static < t extend number > conv2 d backprop input < t > create ( scope scope , operand < integer > input size , operand < t > filter , operand < t > out backprop , list < long > stride , string padding , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` conv2 d backprop input `` , scope . make op name ( `` conv2 d backprop input `` ) ) ; op builder . add input ( input sizes . a output ( ) ) ; op builder . add input ( filter . a output ( ) ) ; op builder . add input ( out backprop . a output ( ) ) ; long [ ] stride array = new long [ stride . size ( ) ] ; for ( int i = 0 ; i < stride array . length ; ++i ) { strides array [ i ] = stride . get ( i ) ; } op builder . set attr ( `` stride `` , stride array ) ; op builder . set attr ( `` pad `` , pad ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . use cudnn on gpu ! = null ) { op builder . set attr ( `` use_cudnn_on_gpu `` , opts . use cudnn on gpu ) ; } if ( opts . data format ! = null ) { op builder . set attr ( `` data_format `` , opts . data format ) ; } if ( opts . dilation ! = null ) { long [ ] dilation array = new long [ opts . dilation . size ( ) ] ; for ( int i = 0 ; i < dilation array . length ; ++i ) { dilation array [ i ] = opts . dilation . get ( i ) ; } op builder . set attr ( `` dilation `` , dilation array ) ; } } } return new conv2 d backprop input < t > ( op builder . build ( ) ) ; }
public static < t extend number > cross < t > create ( scope scope , operand < t > a , operand < t > b ) { operation builder op builder = scope . graph ( ) . op builder ( `` cross `` , scope . make op name ( `` cross `` ) ) ; op builder . add input ( a . a output ( ) ) ; op builder . add input ( b . a output ( ) ) ; return new cross < t > ( op builder . build ( ) ) ; }
public output < long > decode index ( ) { return decode index ; }
public output < long > decode value ( ) { return decode value ; }
public output < long > decode shape ( ) { return decode shape ; }
public output < float > loss ( ) { return loss ; }
public static dataset to graph create ( scope scope , operand < ? > input dataset ) { operation builder op builder = scope . graph ( ) . op builder ( `` dataset to graph `` , scope . make op name ( `` dataset to graph `` ) ) ; op builder . add input ( input dataset . a output ( ) ) ; return new dataset to graph ( op builder . build ( ) ) ; }
public static < t > dense to dense set operation < t > create ( scope scope , operand < t > set1 , operand < t > set2 , string set operation , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` dense to dense set operation `` , scope . make op name ( `` dense to dense set operation `` ) ) ; op builder . add input ( set1 . a output ( ) ) ; op builder . add input ( set2 . a output ( ) ) ; op builder . set attr ( `` set_operation `` , set operation ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . validate index ! = null ) { op builder . set attr ( `` validate_indices `` , opts . validate index ) ; } } } return new dense to dense set operation < t > ( op builder . build ( ) ) ; }
public static < t extend number > depthwise conv2d native < t > create ( scope scope , operand < t > input , operand < t > filter , list < long > stride , string padding , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` depthwise conv2d native `` , scope . make op name ( `` depthwise conv2d native `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . add input ( filter . a output ( ) ) ; long [ ] stride array = new long [ stride . size ( ) ] ; for ( int i = 0 ; i < stride array . length ; ++i ) { strides array [ i ] = stride . get ( i ) ; } op builder . set attr ( `` stride `` , stride array ) ; op builder . set attr ( `` pad `` , pad ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . data format ! = null ) { op builder . set attr ( `` data_format `` , opts . data format ) ; } if ( opts . dilation ! = null ) { long [ ] dilation array = new long [ opts . dilation . size ( ) ] ; for ( int i = 0 ; i < dilation array . length ; ++i ) { dilation array [ i ] = opts . dilation . get ( i ) ; } op builder . set attr ( `` dilation `` , dilation array ) ; } } } return new depthwise conv2d native < t > ( op builder . build ( ) ) ; }
public static < t > destroy temporary variable < t > create ( scope scope , operand < t > ref , string var name ) { operation builder op builder = scope . graph ( ) . op builder ( `` destroy temporary variable `` , scope . make op name ( `` destroy temporary variable `` ) ) ; op builder . add input ( ref . a output ( ) ) ; op builder . set attr ( `` var_name `` , var name ) ; return new destroy temporary variable < t > ( op builder . build ( ) ) ; }
public static < t extend number > elu < t > create ( scope scope , operand < t > feature ) { operation builder op builder = scope . graph ( ) . op builder ( `` elu `` , scope . make op name ( `` elu `` ) ) ; op builder . add input ( feature . a output ( ) ) ; return new elu < t > ( op builder . build ( ) ) ; }
public output < string > content ( ) { return content ; }
public static experimental assert next dataset create ( scope scope , operand < ? > input dataset , operand < string > transformation , list < class < ? > > output type , list < shape > output shape ) { operation builder op builder = scope . graph ( ) . op builder ( `` experimental assert next dataset `` , scope . make op name ( `` experimental assert next dataset `` ) ) ; op builder . add input ( input dataset . a output ( ) ) ; op builder . add input ( transformation . a output ( ) ) ; data type [ ] output type array = new data type [ output type . size ( ) ] ; for ( int i = 0 ; i < output type array . length ; ++i ) { output type array [ i ] = data type . from class ( output type . get ( i ) ) ; } op builder . set attr ( `` output_types `` , output type array ) ; shape [ ] output shape array = new shape [ output shape . size ( ) ] ; for ( int i = 0 ; i < output shape array . length ; ++i ) { output shape array [ i ] = output shape . get ( i ) ; } op builder . set attr ( `` output_shapes `` , output shape array ) ; return new experimental assert next dataset ( op builder . build ( ) ) ; }
public static experimental byte produce stats dataset create ( scope scope , operand < ? > input dataset , operand < string > tag , list < class < ? > > output type , list < shape > output shape ) { operation builder op builder = scope . graph ( ) . op builder ( `` experimental byte produce stats dataset `` , scope . make op name ( `` experimental byte produce stats dataset `` ) ) ; op builder . add input ( input dataset . a output ( ) ) ; op builder . add input ( tag . a output ( ) ) ; data type [ ] output type array = new data type [ output type . size ( ) ] ; for ( int i = 0 ; i < output type array . length ; ++i ) { output type array [ i ] = data type . from class ( output type . get ( i ) ) ; } op builder . set attr ( `` output_types `` , output type array ) ; shape [ ] output shape array = new shape [ output shape . size ( ) ] ; for ( int i = 0 ; i < output shape array . length ; ++i ) { output shape array [ i ] = output shape . get ( i ) ; } op builder . set attr ( `` output_shapes `` , output shape array ) ; return new experimental byte produce stats dataset ( op builder . build ( ) ) ; }
public output < long > cardinality ( ) { return cardinality ; }
public static experimental indexed dataset get create ( scope scope , operand < ? > materialize , operand < ? > index , list < class < ? > > output type , list < shape > output shape ) { operation builder op builder = scope . graph ( ) . op builder ( `` experimental indexed dataset get `` , scope . make op name ( `` experimental indexed dataset get `` ) ) ; op builder . add input ( materialize . a output ( ) ) ; op builder . add input ( index . a output ( ) ) ; data type [ ] output type array = new data type [ output type . size ( ) ] ; for ( int i = 0 ; i < output type array . length ; ++i ) { output type array [ i ] = data type . from class ( output type . get ( i ) ) ; } op builder . set attr ( `` output_types `` , output type array ) ; shape [ ] output shape array = new shape [ output shape . size ( ) ] ; for ( int i = 0 ; i < output shape array . length ; ++i ) { output shape array [ i ] = output shape . get ( i ) ; } op builder . set attr ( `` output_shapes `` , output shape array ) ; return new experimental indexed dataset get ( op builder . build ( ) ) ; }
public static experimental match file dataset create ( scope scope , operand < string > pattern ) { operation builder op builder = scope . graph ( ) . op builder ( `` experimental matching file dataset `` , scope . make op name ( `` experimental matching file dataset `` ) ) ; op builder . add input ( pattern . a output ( ) ) ; return new experimental matching file dataset ( op builder . build ( ) ) ; }
public static experimental sleep dataset create ( scope scope , operand < ? > input dataset , operand < long > sleep microsecond , list < class < ? > > output type , list < shape > output shape ) { operation builder op builder = scope . graph ( ) . op builder ( `` experimental sleep dataset `` , scope . make op name ( `` experimental sleep dataset `` ) ) ; op builder . add input ( input dataset . a output ( ) ) ; op builder . add input ( sleep microsecond . a output ( ) ) ; data type [ ] output type array = new data type [ output type . size ( ) ] ; for ( int i = 0 ; i < output type array . length ; ++i ) { output type array [ i ] = data type . from class ( output type . get ( i ) ) ; } op builder . set attr ( `` output_types `` , output type array ) ; shape [ ] output shape array = new shape [ output shape . size ( ) ] ; for ( int i = 0 ; i < output shape array . length ; ++i ) { output shape array [ i ] = output shape . get ( i ) ; } op builder . set attr ( `` output_shapes `` , output shape array ) ; return new experimental sleep dataset ( op builder . build ( ) ) ; }
public static < t > fft2d < t > create ( scope scope , operand < t > input ) { operation builder op builder = scope . graph ( ) . op builder ( `` fft2d `` , scope . make op name ( `` fft2d `` ) ) ; op builder . add input ( input . a output ( ) ) ; return new fft2d < t > ( op builder . build ( ) ) ; }
public output < t > output ( ) { return output ; }
public output < t > scale backprop ( ) { return scale backprop ; }
public output < integer > num present ( ) { return num present ; }
public static < t extend number > great equal create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` great equal `` , scope . make op name ( `` great equal `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new great equal ( op builder . build ( ) ) ; }
public static < t extend number > igamma < t > create ( scope scope , operand < t > a , operand < t > x ) { operation builder op builder = scope . graph ( ) . op builder ( `` igamma `` , scope . make op name ( `` igamma `` ) ) ; op builder . add input ( a . a output ( ) ) ; op builder . add input ( x . a output ( ) ) ; return new igamma < t > ( op builder . build ( ) ) ; }
public static < t extend number > igammac < t > create ( scope scope , operand < t > a , operand < t > x ) { operation builder op builder = scope . graph ( ) . op builder ( `` igammac `` , scope . make op name ( `` igammac `` ) ) ; op builder . add input ( a . a output ( ) ) ; op builder . add input ( x . a output ( ) ) ; return new igammac < t > ( op builder . build ( ) ) ; }
public static < t > immutable const < t > create ( scope scope , class < t > dtype , shape shape , string memory region name ) { operation builder op builder = scope . graph ( ) . op builder ( `` immutable const `` , scope . make op name ( `` immutable const `` ) ) ; op builder . set attr ( `` dtype `` , data type . from class ( dtype ) ) ; op builder . set attr ( `` shape `` , shape ) ; op builder . set attr ( `` memory_region_name `` , memory region name ) ; return new immutable const < t > ( op builder . build ( ) ) ; }
public output < boolean > precision ( ) { return precision ; }
public static be boost tree quantile stream resource initialize create ( scope scope , operand < ? > quantile stream resource handle ) { operation builder op builder = scope . graph ( ) . op builder ( `` be boosted tree quantile stream resource initialize `` , scope . make op name ( `` be boosted tree quantile stream resource initialize `` ) ) ; op builder . add input ( quantile stream resource handle . a output ( ) ) ; return new be boost tree quantile stream resource initialize ( op builder . build ( ) ) ; }
public static < t extend number > leaky relu < t > create ( scope scope , operand < t > feature , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` leaky relu `` , scope . make op name ( `` leaky relu `` ) ) ; op builder . add input ( feature . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . alpha ! = null ) { op builder . set attr ( `` alpha `` , opts . alpha ) ; } } } return new leaky relu < t > ( op builder . build ( ) ) ; }
public static < t extend number > lgamma < t > create ( scope scope , operand < t > x ) { operation builder op builder = scope . graph ( ) . op builder ( `` lgamma `` , scope . make op name ( `` lgamma `` ) ) ; op builder . add input ( x . a output ( ) ) ; return new lgamma < t > ( op builder . build ( ) ) ; }
public static l m d b reader create ( scope scope , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` l m d b reader `` , scope . make op name ( `` l m d b reader `` ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . container ! = null ) { op builder . set attr ( `` container `` , opts . container ) ; } if ( opts . share name ! = null ) { op builder . set attr ( `` shared_name `` , opts . share name ) ; } } } return new l m d b reader ( op builder . build ( ) ) ; }
public static < t > log1p < t > create ( scope scope , operand < t > x ) { operation builder op builder = scope . graph ( ) . op builder ( `` log1p `` , scope . make op name ( `` log1p `` ) ) ; op builder . add input ( x . a output ( ) ) ; return new log1p < t > ( op builder . build ( ) ) ; }
public output < t > logsoftmax ( ) { return logsoftmax ; }
public static < t > mat mul < t > create ( scope scope , operand < t > a , operand < t > b , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` mat mul `` , scope . make op name ( `` mat mul `` ) ) ; op builder . add input ( a . a output ( ) ) ; op builder . add input ( b . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . transpose a ! = null ) { op builder . set attr ( `` transpose_a `` , opts . transpose a ) ; } if ( opts . transpose b ! = null ) { op builder . set attr ( `` transpose_b `` , opts . transpose b ) ; } } } return new mat mul < t > ( op builder . build ( ) ) ; }
public output < t > band ( ) { return band ; }
public static < t > matrix diag part < t > create ( scope scope , operand < t > input ) { operation builder op builder = scope . graph ( ) . op builder ( `` matrix diag part `` , scope . make op name ( `` matrix diag part `` ) ) ; op builder . add input ( input . a output ( ) ) ; return new matrix diag part < t > ( op builder . build ( ) ) ; }
public static < t > matrix logarithm < t > create ( scope scope , operand < t > input ) { operation builder op builder = scope . graph ( ) . op builder ( `` matrix logarithm `` , scope . make op name ( `` matrix logarithm `` ) ) ; op builder . add input ( input . a output ( ) ) ; return new matrix logarithm < t > ( op builder . build ( ) ) ; }
public static mutex v2 create ( scope scope , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` mutex v2 `` , scope . make op name ( `` mutex v2 `` ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . container ! = null ) { op builder . set attr ( `` container `` , opts . container ) ; } if ( opts . share name ! = null ) { op builder . set attr ( `` shared_name `` , opts . share name ) ; } } } return new mutex v2 ( op builder . build ( ) ) ; }
public output < t > y ( ) { return y ; }
public static optional get value create ( scope scope , operand < ? > optional , list < class < ? > > output type , list < shape > output shape ) { operation builder op builder = scope . graph ( ) . op builder ( `` optional get value `` , scope . make op name ( `` optional get value `` ) ) ; op builder . add input ( optional . a output ( ) ) ; data type [ ] output type array = new data type [ output type . size ( ) ] ; for ( int i = 0 ; i < output type array . length ; ++i ) { output type array [ i ] = data type . from class ( output type . get ( i ) ) ; } op builder . set attr ( `` output_types `` , output type array ) ; shape [ ] output shape array = new shape [ output shape . size ( ) ] ; for ( int i = 0 ; i < output shape array . length ; ++i ) { output shape array [ i ] = output shape . get ( i ) ; } op builder . set attr ( `` output_shapes `` , output shape array ) ; return new optional get value ( op builder . build ( ) ) ; }
public static order map clear create ( scope scope , list < class < ? > > dtypes , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` order map clear `` , scope . make op name ( `` order map clear `` ) ) ; data type [ ] dtypes array = new data type [ dtypes . size ( ) ] ; for ( int i = 0 ; i < dtypes array . length ; ++i ) { dtypes array [ i ] = data type . from class ( dtypes . get ( i ) ) ; } op builder . set attr ( `` dtypes `` , dtypes array ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . capacity ! = null ) { op builder . set attr ( `` capacity `` , opts . capacity ) ; } if ( opts . memory limit ! = null ) { op builder . set attr ( `` memory_limit `` , opts . memory limit ) ; } if ( opts . container ! = null ) { op builder . set attr ( `` container `` , opts . container ) ; } if ( opts . share name ! = null ) { op builder . set attr ( `` shared_name `` , opts . share name ) ; } } } return new order map clear ( op builder . build ( ) ) ; }
public static order map unstage no key create ( scope scope , operand < integer > index , list < class < ? > > dtypes , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` order map unstage no key `` , scope . make op name ( `` order map unstage no key `` ) ) ; op builder . add input ( index . a output ( ) ) ; data type [ ] dtypes array = new data type [ dtypes . size ( ) ] ; for ( int i = 0 ; i < dtypes array . length ; ++i ) { dtypes array [ i ] = data type . from class ( dtypes . get ( i ) ) ; } op builder . set attr ( `` dtypes `` , dtypes array ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . capacity ! = null ) { op builder . set attr ( `` capacity `` , opts . capacity ) ; } if ( opts . memory limit ! = null ) { op builder . set attr ( `` memory_limit `` , opts . memory limit ) ; } if ( opts . container ! = null ) { op builder . set attr ( `` container `` , opts . container ) ; } if ( opts . share name ! = null ) { op builder . set attr ( `` shared_name `` , opts . share name ) ; } } } return new order map unstage no key ( op builder . build ( ) ) ; }
public output < t > output ( ) { return output ; }
public static < t extend number > polygamma < t > create ( scope scope , operand < t > a , operand < t > x ) { operation builder op builder = scope . graph ( ) . op builder ( `` polygamma `` , scope . make op name ( `` polygamma `` ) ) ; op builder . add input ( a . a output ( ) ) ; op builder . add input ( x . a output ( ) ) ; return new polygamma < t > ( op builder . build ( ) ) ; }
public static < t > print < t > create ( scope scope , operand < t > input , iterable < operand < ? > > data , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` print `` , scope . make op name ( `` print `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . add input list ( operands . a output ( data ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . message ! = null ) { op builder . set attr ( `` message `` , opts . message ) ; } if ( opts . first n ! = null ) { op builder . set attr ( `` first_n `` , opts . first n ) ; } if ( opts . summarize ! = null ) { op builder . set attr ( `` summarize `` , opts . summarize ) ; } } } return new print < t > ( op builder . build ( ) ) ; }
public output < t > output ( ) { return output ; }
public static < t , u extend number > prod < t > create ( scope scope , operand < t > input , operand < u > axis , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` prod `` , scope . make op name ( `` prod `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . add input ( axis . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . keep dims ! = null ) { op builder . set attr ( `` keep_dims `` , opts . keep dims ) ; } } } return new prod < t > ( op builder . build ( ) ) ; }
public static < t > qr < t > create ( scope scope , operand < t > input , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` qr `` , scope . make op name ( `` qr `` ) ) ; op builder . add input ( input . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . full matrix ! = null ) { op builder . set attr ( `` full_matrices `` , opts . full matrix ) ; } } } return new qr < t > ( op builder . build ( ) ) ; }
public output < float > output min ( ) { return output min ; }
public static < t > quantize max pool < t > create ( scope scope , operand < t > input , operand < float > min input , operand < float > max input , list < long > ksize , list < long > stride , string pad ) { operation builder op builder = scope . graph ( ) . op builder ( `` quantize max pool `` , scope . make op name ( `` quantize max pool `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . add input ( min input . a output ( ) ) ; op builder . add input ( max input . a output ( ) ) ; long [ ] ksize array = new long [ ksize . size ( ) ] ; for ( int i = 0 ; i < ksize array . length ; ++i ) { ksize array [ i ] = ksize . get ( i ) ; } op builder . set attr ( `` ksize `` , ksize array ) ; long [ ] stride array = new long [ stride . size ( ) ] ; for ( int i = 0 ; i < stride array . length ; ++i ) { strides array [ i ] = stride . get ( i ) ; } op builder . set attr ( `` stride `` , stride array ) ; op builder . set attr ( `` pad `` , pad ) ; return new quantize max pool < t > ( op builder . build ( ) ) ; }
public output < u > activation ( ) { return activation ; }
public static queue dequeue create ( scope scope , operand < ? > handle , list < class < ? > > component type , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` queue dequeue v2 `` , scope . make op name ( `` queue dequeue `` ) ) ; op builder . add input ( handle . a output ( ) ) ; data type [ ] component type array = new data type [ component type . size ( ) ] ; for ( int i = 0 ; i < component type array . length ; ++i ) { component type array [ i ] = data type . from class ( component type . get ( i ) ) ; } op builder . set attr ( `` component_types `` , component type array ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . timeout m ! = null ) { op builder . set attr ( `` timeout_ms `` , opts . timeout m ) ; } } } return new queue dequeue ( op builder . build ( ) ) ; }
public static queue dequeue up to create ( scope scope , operand < ? > handle , operand < integer > n , list < class < ? > > component type , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` queue dequeue up to v2 `` , scope . make op name ( `` queue dequeue up to `` ) ) ; op builder . add input ( handle . a output ( ) ) ; op builder . add input ( n . a output ( ) ) ; data type [ ] component type array = new data type [ component type . size ( ) ] ; for ( int i = 0 ; i < component type array . length ; ++i ) { component type array [ i ] = data type . from class ( component type . get ( i ) ) ; } op builder . set attr ( `` component_types `` , component type array ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . timeout m ! = null ) { op builder . set attr ( `` timeout_ms `` , opts . timeout m ) ; } } } return new queue dequeue up to ( op builder . build ( ) ) ; }
public static queue enqueue many create ( scope scope , operand < ? > handle , iterable < operand < ? > > component , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` queue enqueue many v2 `` , scope . make op name ( `` queue enqueue many `` ) ) ; op builder . add input ( handle . a output ( ) ) ; op builder . add input list ( operands . a output ( component ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . timeout m ! = null ) { op builder . set attr ( `` timeout_ms `` , opts . timeout m ) ; } } } return new queue enqueue many ( op builder . build ( ) ) ; }
public output < long > rt nested split ( ) { return rt nest split ; }
public static random shuffle queue create ( scope scope , list < class < ? > > component type , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` random shuffle queue v2 `` , scope . make op name ( `` random shuffle queue `` ) ) ; data type [ ] component type array = new data type [ component type . size ( ) ] ; for ( int i = 0 ; i < component type array . length ; ++i ) { component type array [ i ] = data type . from class ( component type . get ( i ) ) ; } op builder . set attr ( `` component_types `` , component type array ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . shape ! = null ) { shape [ ] shape array = new shape [ opts . shape . size ( ) ] ; for ( int i = 0 ; i < shape array . length ; ++i ) { shapes array [ i ] = opts . shape . get ( i ) ; } op builder . set attr ( `` shape `` , shape array ) ; } if ( opts . capacity ! = null ) { op builder . set attr ( `` capacity `` , opts . capacity ) ; } if ( opts . min after dequeue ! = null ) { op builder . set attr ( `` min_after_dequeue `` , opts . min after dequeue ) ; } if ( opts . seed ! = null ) { op builder . set attr ( `` seed `` , opts . seed ) ; } if ( opts . seed2 ! = null ) { op builder . set attr ( `` seed2 `` , opts . seed2 ) ; } if ( opts . container ! = null ) { op builder . set attr ( `` container `` , opts . container ) ; } if ( opts . share name ! = null ) { op builder . set attr ( `` shared_name `` , opts . share name ) ; } } } return new random shuffle queue ( op builder . build ( ) ) ; }
public static < t > reciprocal grad < t > create ( scope scope , operand < t > y , operand < t > dy ) { operation builder op builder = scope . graph ( ) . op builder ( `` reciprocal grad `` , scope . make op name ( `` reciprocal grad `` ) ) ; op builder . add input ( y . a output ( ) ) ; op builder . add input ( dy . a output ( ) ) ; return new reciprocal grad < t > ( op builder . build ( ) ) ; }
public output < float > output min ( ) { return output min ; }
public static < t > resource apply gradient descent create ( scope scope , operand < ? > var , operand < t > alpha , operand < t > delta , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` resource apply gradient descent `` , scope . make op name ( `` resource apply gradient descent `` ) ) ; op builder . add input ( var . a output ( ) ) ; op builder . add input ( alpha . a output ( ) ) ; op builder . add input ( delta . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . use lock ! = null ) { op builder . set attr ( `` use_locking `` , opts . use lock ) ; } } } return new resource apply gradient descent ( op builder . build ( ) ) ; }
public output < t > output ( ) { return output ; }
public static save create ( scope scope , operand < string > filename , operand < string > tensor name , iterable < operand < ? > > data ) { operation builder op builder = scope . graph ( ) . op builder ( `` save `` , scope . make op name ( `` save `` ) ) ; op builder . add input ( filename . a output ( ) ) ; op builder . add input ( tensor names . a output ( ) ) ; op builder . add input list ( operands . a output ( data ) ) ; return new save ( op builder . build ( ) ) ; }
public static save v2 create ( scope scope , operand < string > prefix , operand < string > tensor name , operand < string > shape and slice , iterable < operand < ? > > tensor ) { operation builder op builder = scope . graph ( ) . op builder ( `` save v2 `` , scope . make op name ( `` save v2 `` ) ) ; op builder . add input ( prefix . a output ( ) ) ; op builder . add input ( tensor names . a output ( ) ) ; op builder . add input ( shape and slice . a output ( ) ) ; op builder . add input list ( operands . a output ( tensor ) ) ; return new save v2 ( op builder . build ( ) ) ; }
public output < t > output ref ( ) { return output ref ; }
public static sdca fprint create ( scope scope , operand < string > input ) { operation builder op builder = scope . graph ( ) . op builder ( `` sdca fprint `` , scope . make op name ( `` sdca fprint `` ) ) ; op builder . add input ( input . a output ( ) ) ; return new sdca fprint ( op builder . build ( ) ) ; }
public output < t > out ( ) { return out ; }
public static < t > sin < t > create ( scope scope , operand < t > x ) { operation builder op builder = scope . graph ( ) . op builder ( `` sin `` , scope . make op name ( `` sin `` ) ) ; op builder . add input ( x . a output ( ) ) ; return new sin < t > ( op builder . build ( ) ) ; }
public output < integer > current epoch ( ) { return current epoch ; }
public static < t extend number > softmax < t > create ( scope scope , operand < t > logits ) { operation builder op builder = scope . graph ( ) . op builder ( `` softmax `` , scope . make op name ( `` softmax `` ) ) ; op builder . add input ( logits . a output ( ) ) ; return new softmax < t > ( op builder . build ( ) ) ; }
public output < t > loss ( ) { return loss ; }
public output < t > b val grad ( ) { return b val grad ; }
public static < t > sparse fill empty row grad < t > create ( scope scope , operand < long > reverse index map , operand < t > grad value ) { operation builder op builder = scope . graph ( ) . op builder ( `` sparse fill empty row grad `` , scope . make op name ( `` sparse fill empty row grad `` ) ) ; op builder . add input ( reverse index map . a output ( ) ) ; op builder . add input ( grad value . a output ( ) ) ; return new sparse fill empty row grad < t > ( op builder . build ( ) ) ; }
public output < t > output value ( ) { return output value ; }
public list < output < t > > output ( ) { return output ; }
public static < t > sqrt < t > create ( scope scope , operand < t > x ) { operation builder op builder = scope . graph ( ) . op builder ( `` sqrt `` , scope . make op name ( `` sqrt `` ) ) ; op builder . add input ( x . a output ( ) ) ; return new sqrt < t > ( op builder . build ( ) ) ; }
public static < t > stack < t > create ( scope scope , operand < t > value , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` pack `` , scope . make op name ( `` stack `` ) ) ; op builder . add input ( value . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . axis ! = null ) { op builder . set attr ( `` axis `` , opts . axis ) ; } } } return new stack < t > ( op builder . build ( ) ) ; }
public static static regex replace create ( scope scope , operand < string > input , string pattern , string rewrite , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` static regex replace `` , scope . make op name ( `` static regex replace `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . set attr ( `` pattern `` , pattern ) ; op builder . set attr ( `` rewrite `` , rewrite ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . replace global ! = null ) { op builder . set attr ( `` replace_global `` , opts . replace global ) ; } } } return new static regex replace ( op builder . build ( ) ) ; }
public static < t > stop gradient < t > create ( scope scope , operand < t > input ) { operation builder op builder = scope . graph ( ) . op builder ( `` stop gradient `` , scope . make op name ( `` stop gradient `` ) ) ; op builder . add input ( input . a output ( ) ) ; return new stop gradient < t > ( op builder . build ( ) ) ; }
public static string format create ( scope scope , iterable < operand < ? > > input , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` string format `` , scope . make op name ( `` string format `` ) ) ; op builder . add input list ( operands . a output ( input ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . template ! = null ) { op builder . set attr ( `` template `` , opts . template ) ; } if ( opts . placeholder ! = null ) { op builder . set attr ( `` placeholder `` , opts . placeholder ) ; } if ( opts . summarize ! = null ) { op builder . set attr ( `` summarize `` , opts . summarize ) ; } } } return new string format ( op builder . build ( ) ) ; }
public static string to hash bucket create ( scope scope , operand < string > string tensor , long num bucket ) { operation builder op builder = scope . graph ( ) . op builder ( `` string to hash bucket `` , scope . make op name ( `` string to hash bucket `` ) ) ; op builder . add input ( string tensor . a output ( ) ) ; op builder . set attr ( `` num_buckets `` , num bucket ) ; return new string to hash bucket ( op builder . build ( ) ) ; }
public static < t > sub < t > create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` sub `` , scope . make op name ( `` sub `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new sub < t > ( op builder . build ( ) ) ; }
public static < t > svd < t > create ( scope scope , operand < t > input , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` svd `` , scope . make op name ( `` svd `` ) ) ; op builder . add input ( input . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . compute uv ! = null ) { op builder . set attr ( `` compute_uv `` , opts . compute uv ) ; } if ( opts . full matrix ! = null ) { op builder . set attr ( `` full_matrices `` , opts . full matrix ) ; } } } return new svd < t > ( op builder . build ( ) ) ; }
public output < t > sparse value ( ) { return sparse value ; }
public static < t > tanh < t > create ( scope scope , operand < t > x ) { operation builder op builder = scope . graph ( ) . op builder ( `` tanh `` , scope . make op name ( `` tanh `` ) ) ; op builder . add input ( x . a output ( ) ) ; return new tanh < t > ( op builder . build ( ) ) ; }
public static < t > tensor array create ( scope scope , operand < integer > size , class < t > dtype , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` tensor array v3 `` , scope . make op name ( `` tensor array `` ) ) ; op builder . add input ( size . a output ( ) ) ; op builder . set attr ( `` dtype `` , data type . from class ( dtype ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . element shape ! = null ) { op builder . set attr ( `` element_shape `` , opts . element shape ) ; } if ( opts . dynamic size ! = null ) { op builder . set attr ( `` dynamic_size `` , opts . dynamic size ) ; } if ( opts . clear after read ! = null ) { op builder . set attr ( `` clear_after_read `` , opts . clear after read ) ; } if ( opts . identical element shape ! = null ) { op builder . set attr ( `` identical_element_shapes `` , opts . identical element shape ) ; } if ( opts . tensor array name ! = null ) { op builder . set attr ( `` tensor_array_name `` , opts . tensor array name ) ; } } } return new tensor array ( op builder . build ( ) ) ; }
public static < t > tensor array concat < t > create ( scope scope , operand < ? > handle , operand < float > flow in , class < t > dtype , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` tensor array concat v3 `` , scope . make op name ( `` tensor array concat `` ) ) ; op builder . add input ( handle . a output ( ) ) ; op builder . add input ( flow in . a output ( ) ) ; op builder . set attr ( `` dtype `` , data type . from class ( dtype ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . element shape except0 ! = null ) { op builder . set attr ( `` element_shape_except0 `` , opts . element shape except0 ) ; } } } return new tensor array concat < t > ( op builder . build ( ) ) ; }
public static < t > tensor array read < t > create ( scope scope , operand < ? > handle , operand < integer > index , operand < float > flow in , class < t > dtype ) { operation builder op builder = scope . graph ( ) . op builder ( `` tensor array read v3 `` , scope . make op name ( `` tensor array read `` ) ) ; op builder . add input ( handle . a output ( ) ) ; op builder . add input ( index . a output ( ) ) ; op builder . add input ( flow in . a output ( ) ) ; op builder . set attr ( `` dtype `` , data type . from class ( dtype ) ) ; return new tensor array read < t > ( op builder . build ( ) ) ; }
public static tensor forest tree serialize create ( scope scope , operand < ? > tree handle ) { operation builder op builder = scope . graph ( ) . op builder ( `` tensor forest tree serialize `` , scope . make op name ( `` tensor forest tree serialize `` ) ) ; op builder . add input ( tree handle . a output ( ) ) ; return new tensor forest tree serialize ( op builder . build ( ) ) ; }
public static < t > tensor list concat < t > create ( scope scope , operand < ? > input handle , class < t > element dtype ) { operation builder op builder = scope . graph ( ) . op builder ( `` tensor list concat `` , scope . make op name ( `` tensor list concat `` ) ) ; op builder . add input ( input handle . a output ( ) ) ; op builder . set attr ( `` element_dtype `` , data type . from class ( element dtype ) ) ; return new tensor list concat < t > ( op builder . build ( ) ) ; }
public output < t > output ( ) { return output ; }
public output < t > output ( ) { return output ; }
public static < t > tile grad < t > create ( scope scope , operand < t > input , operand < integer > multiple ) { operation builder op builder = scope . graph ( ) . op builder ( `` tile grad `` , scope . make op name ( `` tile grad `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . add input ( multiple . a output ( ) ) ; return new tile grad < t > ( op builder . build ( ) ) ; }
public static unicode transcode create ( scope scope , operand < string > input , string input encode , string output encode , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` unicode transcode `` , scope . make op name ( `` unicode transcode `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . set attr ( `` input_encoding `` , input encode ) ; op builder . set attr ( `` output_encoding `` , output encode ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . error ! = null ) { op builder . set attr ( `` error `` , opts . error ) ; } if ( opts . replacement char ! = null ) { op builder . set attr ( `` replacement_char `` , opts . replacement char ) ; } if ( opts . replace control character ! = null ) { op builder . set attr ( `` replace_control_characters `` , opts . replace control character ) ; } } } return new unicode transcode ( op builder . build ( ) ) ; }
public output < string > output ( ) { return output ; }
public output < v > idx ( ) { return idx ; }
public static < t extend number > unravel index < t > create ( scope scope , operand < t > index , operand < t > dim ) { operation builder op builder = scope . graph ( ) . op builder ( `` unravel index `` , scope . make op name ( `` unravel index `` ) ) ; op builder . add input ( index . a output ( ) ) ; op builder . add input ( dims . a output ( ) ) ; return new unravel index < t > ( op builder . build ( ) ) ; }
public static < t > unstack < t > create ( scope scope , operand < t > value , long num , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` unpack `` , scope . make op name ( `` unstack `` ) ) ; op builder . add input ( value . a output ( ) ) ; op builder . set attr ( `` num `` , num ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . axis ! = null ) { op builder . set attr ( `` axis `` , opts . axis ) ; } } } return new unstack < t > ( op builder . build ( ) ) ; }
public static unstage create ( scope scope , list < class < ? > > dtypes , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` unstage `` , scope . make op name ( `` unstage `` ) ) ; data type [ ] dtypes array = new data type [ dtypes . size ( ) ] ; for ( int i = 0 ; i < dtypes array . length ; ++i ) { dtypes array [ i ] = data type . from class ( dtypes . get ( i ) ) ; } op builder . set attr ( `` dtypes `` , dtypes array ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . capacity ! = null ) { op builder . set attr ( `` capacity `` , opts . capacity ) ; } if ( opts . memory limit ! = null ) { op builder . set attr ( `` memory_limit `` , opts . memory limit ) ; } if ( opts . container ! = null ) { op builder . set attr ( `` container `` , opts . container ) ; } if ( opts . share name ! = null ) { op builder . set attr ( `` shared_name `` , opts . share name ) ; } } } return new unstage ( op builder . build ( ) ) ; }
public static < t > var handle op create ( scope scope , class < t > dtype , shape shape , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` var handle op `` , scope . make op name ( `` var handle op `` ) ) ; op builder . set attr ( `` dtype `` , data type . from class ( dtype ) ) ; op builder . set attr ( `` shape `` , shape ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . container ! = null ) { op builder . set attr ( `` container `` , opts . container ) ; } if ( opts . share name ! = null ) { op builder . set attr ( `` shared_name `` , opts . share name ) ; } } } return new var handle op ( op builder . build ( ) ) ; }
public static < t > where create ( scope scope , operand < t > condition ) { operation builder op builder = scope . graph ( ) . op builder ( `` where `` , scope . make op name ( `` where `` ) ) ; op builder . add input ( condition . a output ( ) ) ; return new where ( op builder . build ( ) ) ; }
public static void warn ( string msg , throwable t ) { if ( quiet mode ) return ; system . err . println ( warn_prefix + msg ) ; if ( t ! = null ) { t . print stack trace ( ) ; } }
public boolean be great or equal ( priority r ) { return level > = r . level ; }
final public string to string ( ) { return level str ; }
protect collection < field access > field of ( class < ? > c ) { collection < field access > field = field of a s t class . get ( c ) ; if ( field ! = null ) return field ; field = new array list < field access > ( ) ; get field ( c , field ) ; field of a s t class . put ( c , field ) ; return field ; }
public void go ( ) { for ( long d : handler . get priority ( ) ) { ast . traverse ( new annotation visitor ( d ) ) ; handler . call a s t visitor ( ast , d , ast . be complete parse ( ) ) ; } }
public static void go ( ) throw exception { class < ? > app class = class . for name ( `` com . apple . eawt . application `` ) ; object app = app class . get method ( `` get application `` ) . invoke ( null ) ; app class . get method ( `` remove about menu item `` ) . invoke ( app ) ; app class . get method ( `` remove preference menu item `` ) . invoke ( app ) ; buffer image image = image i o . read ( apple native look . class . get resource ( `` lombok icon . png `` ) ) ; app class . get method ( `` set dock icon image `` , image . class ) . invoke ( app , image ) ; }
public static list < string > get drive on window ( ) throw throwable { load window drive info lib ( ) ; list < string > drive = new array list < string > ( ) ; windows drive info info = new window drive info ( ) ; for ( string drive : info . get logical drive ( ) ) { if ( info . be fix disk ( drive ) ) drive . add ( drive ) ; } return drive ; }
public void load pattern ( file f ) throw i o exception { input source src = new input source ( f . to u r i ( ) . to a s c i i string ( ) ) ; load pattern ( src ) ; }
public static char array set make stop set ( version match version , string . . . stop word ) { return make stop set ( match version , stop word , false ) ; }
public void reset ( ) { i = 0 ; dirty = false ; }
public void set token type ( string token type ) { this . token type = token type ; }
public boolean contains ( char [ ] text , int off , int len ) { return map . contains key ( text , off , len ) ; }
public void free before ( int po ) { assert po > = 0 ; assert po < = next po ; final int new count = next po - po ; assert new count < = count : `` new count= `` + new count + `` count= `` + count ; assert new count < = buffer . length : `` new count= `` + new count + `` buf . length= `` + buffer . length ; count = new count ; }
public static class < ? extend token filter factory > lookup class ( string name ) { return loader . lookup class ( name ) ; }
public int get current buffer length ( ) { return limit ; }
protect boolean be token char ( int c ) { return ! unicode prop . whitespace . get ( c ) ; }
public void set filler token ( string filler token ) { this . filler token = null == filler token ? new char [ 0 ] : filler token . to char array ( ) ; }
public static string find s p i name ( class < ? extend char filter factory > service class ) { try { return lookup s p i name ( service class ) ; } catch ( no such field exception | illegal access exception | illegal state exception e ) { throw new illegal state exception ( e ) ; } }
public token stream normalize ( token stream input ) { return input ; }
public token clone ( char [ ] new term buffer , int new term offset , int new term length , int new start offset , int new end offset ) { final token t = new token ( new term buffer , new term offset , new term length , new start offset , new end offset ) ; t . position increment = position increment ; t . flag = flag ; t . type = type ; if ( payload ! = null ) t . payload = payload . clone ( ) ; return t ; }
public void reinit ( token prototype ) { copy buffer ( prototype . buffer ( ) , 0 , prototype . length ( ) ) ; position increment = prototype . position increment ; flag = prototype . flag ; start offset = prototype . start offset ; end offset = prototype . end offset ; type = prototype . type ; payload = prototype . payload ; }
protect void write index header ( index output out ) throw i o exception { codec util . write header ( out , terms_index_codec_name , terms_index_version_current ) ; }
public static void set default ( codec codec ) { default codec = codec ; }
public void add raw document ( index input stream , int [ ] length , int num doc ) throw i o exception { long position = field stream . get file pointer ( ) ; long start = position ; for ( int i=0 ; i < num doc ; i++ ) { index stream . write long ( position ) ; position += lengths [ i ] ; } field stream . copy byte ( stream , position-start ) ; assert field stream . get file pointer ( ) == position ; }
protect void set last skip data ( int level ) { last doc = skip doc [ level ] ; last child pointer = child pointer [ level ] ; }
public static byte [ ] compress string ( string value , int compression level ) { bytes ref result = new byte ref ( ) ; unicode util . u t f16to u t f8 ( value , 0 , value . length ( ) , result ) ; return compress ( result . byte , 0 , result . length , compression level ) ; }
public void set store term vector position ( boolean value ) { check if frozen ( ) ; this . store term vector position = value ; }
public void set store term vector payload ( boolean value ) { check if frozen ( ) ; this . store term vector payload = value ; }
public void set numeric type ( numeric type type ) { check if frozen ( ) ; numeric type = type ; }
public int num term ( ) { return num term in field ; }
protect void visit term ( term enum te , int term num ) throw i o exception { }
public string put attribute ( string key , string value ) { if ( attribute == null ) { attribute = new hash map < string , string > ( ) ; } return attribute . put ( key , value ) ; }
public boolean have prox ( ) { return have prox ; }
public boolean have payload ( ) { return have payload ; }
public boolean have norm ( ) { return have norm ; }
public int get position ( ) { return position ; }
public static void main ( string [ ] args ) throw i o exception { parse args ( args ) . upgrade ( ) ; }
public void delete document ( term term ) throw i o exception { ensure open ( ) ; try { if ( doc writer . delete term ( term ) ) { process event ( true , false ) ; } } catch ( out of memory error oom ) { handle o o m ( oom , `` delete document ( term ) `` ) ; } }
public void update numeric doc value ( term term , string field , long value ) throw i o exception { ensure open ( ) ; if ( ! global field number map . contains ( field , doc value type . numeric ) ) { throw new illegal argument exception ( `` can only update exist numeric-docvalues field ! `` ) ; } try { if ( doc writer . update numeric doc value ( term , field , value ) ) { process event ( true , false ) ; } } catch ( out of memory error oom ) { handle o o m ( oom , `` update numeric doc value `` ) ; } }
public index writer config set info stream ( info stream info stream ) { if ( info stream == null ) { throw new illegal argument exception ( `` can not set info stream implementation to null . `` + `` to disable log use info stream . no_output `` ) ; } this . info stream = info stream ; return this ; }
public analyzer get analyzer ( ) { return analyzer ; }
public void set min merge m b ( double mb ) { min merge size = ( long ) ( mb * 1024 * 1024 ) ; }
public void set calibrate size by deletes ( boolean calibrate size by deletes ) { this . calibrate size by deletes = calibrate size by deletes ; }
public long size in byte ( ) throw i o exception { if ( size in byte == -1 ) { long sum = 0 ; for ( final string file name : file ( ) ) { sum += info . dir . file length ( file name ) ; } size in byte = sum ; } return size in byte ; }
public long get field info gen ( ) { return field info gen ; }
public set < string > file ( ) { if ( set file == null ) { throw new illegal state exception ( `` file be not compute yet `` ) ; } return collection . unmodifiable set ( set file ) ; }
public void change ( ) { version++ ; }
public synchronize void release ( index commit commit ) throw i o exception { long gen = commit . get generation ( ) ; release gen ( gen ) ; }
public term state term state ( ) throw i o exception { return new term state ( ) { @ override public void copy from ( term state other ) { throw new unsupported operation exception ( ) ; } } ; }
public double get max merge segment m b ( ) { return max merge segment bytes/1024/1024 . ; }
public tiered merge policy set reclaim deletes weight ( double v ) { if ( v < 0 . 0 ) { throw new illegal argument exception ( `` reclaim deletes weight must be > = 0 . 0 ( get `` + v + `` ) `` ) ; } reclaim deletes weight = v ; return this ; }
public double get segment per tier ( ) { return segs per tier ; }
public final boolean be cacheable ( ) { return true ; }
public final query get query ( ) { return query ; }
public int size ( ) { return current . size ( ) + old . size ( ) ; }
public void set total term freq ( long total term freq ) { this . total term freq = total term freq ; }
public void set discount overlap ( boolean v ) { discount overlap = v ; }
public float get b ( ) { return b ; }
public normalization get normalization ( ) { return normalization ; }
public float get z ( ) { return z ; }
public static term range query new string range ( string field , string low term , string upper term , boolean include low , boolean include upper ) { byte ref low = low term == null ? null : new byte ref ( low term ) ; bytes ref upper = upper term == null ? null : new byte ref ( upper term ) ; return new term range query ( field , low , upper , include low , include upper ) ; }
public final byte ref term ( ) { return term ; }
public void set baseline ( long clock time ) { t0 = clock time ; timeout = t0 + tick allow ; }
public void set max score ( float max score ) { this . max score = max score ; }
public long file length ( string name ) throw i o exception { ensure open ( ) ; if ( this . writer ! = null ) { return writer . file length ( name ) ; } file entry e = entry . get ( index file name . strip segment name ( name ) ) ; if ( e == null ) throw new file not find exception ( name ) ; return e . length ; }
public void write string set ( set < string > set ) throw i o exception { if ( set == null ) { write int ( 0 ) ; } else { write int ( set . size ( ) ) ; for ( string value : set ) { write string ( value ) ; } } }
public long size in byte ( ) { return cache . size in byte ( ) ; }
public long size in byte ( ) { return ( long ) file . num buffer ( ) * ( long ) buffer_size ; }
static public automaton intersection ( automaton a1 , automaton a2 ) { if ( a1 . be singleton ( ) ) { if ( basic operation . run ( a2 , a1 . singleton ) ) return a1 . clone if require ( ) ; else return basic automaton . make empty ( ) ; } if ( a2 . be singleton ( ) ) { if ( basic operation . run ( a1 , a2 . singleton ) ) return a2 . clone if require ( ) ; else return basic automaton . make empty ( ) ; } if ( a1 == a2 ) return a1 . clone if require ( ) ; transition [ ] [ ] transitions1 = a1 . get sorted transition ( ) ; transition [ ] [ ] transitions2 = a2 . get sorted transition ( ) ; automaton c = new automaton ( ) ; link list < state pair > worklist = new link list < state pair > ( ) ; hash map < state pair , state pair > newstates = new hash map < state pair , state pair > ( ) ; state pair p = new state pair ( c . initial , a1 . initial , a2 . initial ) ; worklist . add ( p ) ; newstates . put ( p , p ) ; while ( worklist . size ( ) > 0 ) { p = worklist . remove first ( ) ; p . s . accept = p . s1 . accept & & p . s2 . accept ; transition [ ] t1 = transitions1 [ p . s1 . number ] ; transition [ ] t2 = transitions2 [ p . s2 . number ] ; for ( int n1 = 0 , b2 = 0 ; n1 < t1 . length ; n1++ ) { while ( b2 < t2 . length & & t2 [ b2 ] . max < t1 [ n1 ] . min ) b2++ ; for ( int n2 = b2 ; n2 < t2 . length & & t1 [ n1 ] . max > = t2 [ n2 ] . min ; n2++ ) if ( t2 [ n2 ] . max > = t1 [ n1 ] . min ) { state pair q = new state pair ( t1 [ n1 ] . to , t2 [ n2 ] . to ) ; state pair r = newstates . get ( q ) ; if ( r == null ) { q . s = new state ( ) ; worklist . add ( q ) ; newstates . put ( q , q ) ; r = q ; } int min = t1 [ n1 ] . min > t2 [ n2 ] . min ? t1 [ n1 ] . min : t2 [ n2 ] . min ; int max = t1 [ n1 ] . max < t2 [ n2 ] . max ? t1 [ n1 ] . max : t2 [ n2 ] . max ; p . s . add transition ( new transition ( min , max , r . s ) ) ; } } } c . deterministic = a1 . deterministic & & a2 . deterministic ; c . remove dead transition ( ) ; c . check minimize always ( ) ; return c ; }
public static boolean be total ( automaton a ) { if ( a . be singleton ( ) ) return false ; if ( a . initial . accept & & a . initial . num transition ( ) == 1 ) { transition t = a . initial . get transition ( ) . iterator ( ) . next ( ) ; return t . to == a . initial & & t . min == character . min_code_point & & t . max == character . max_code_point ; } return false ; }
public state complete ( ) { if ( this . state registry == null ) throw new illegal state exception ( ) ; if ( root . have child ( ) ) replace or register ( root ) ; state registry = null ; return root ; }
public static string get common prefix ( automaton a ) { if ( a . be singleton ( ) ) return a . singleton ; string builder b = new string builder ( ) ; hash set < state > visit = new hash set < state > ( ) ; state s = a . initial ; boolean do ; do { do = true ; visit . add ( s ) ; if ( ! s . accept & & s . num transition ( ) == 1 ) { transition t = s . get transition ( ) . iterator ( ) . next ( ) ; if ( t . min == t . max & & ! visit . contains ( t . to ) ) { b . append code point ( t . min ) ; s = t . to ; do = false ; } } } while ( ! do ) ; return b . to string ( ) ; }
public static set < ints ref > get finite string ( automaton a , int limit ) { hash set < ints ref > string = new hash set < ints ref > ( ) ; if ( a . be singleton ( ) ) { if ( limit > 0 ) { string . add ( util . to u t f32 ( a . singleton , new ints ref ( ) ) ) ; } } else if ( ! get finite string ( a . initial , new hash set < state > ( ) , string , new ints ref ( ) , limit ) ) { return string ; } return string ; }
public int compare to ( state s ) { return s . id - id ; }
public static int bit count ( byte b ) { return byte_counts [ b & 0x f f ] ; }
public void reset ( ) { reset ( true , true ) ; }
public string utf8 to string ( ) { final char ref ref = new char ref ( length ) ; unicode util . u t f8to u t f16 ( byte , offset , length , ref ) ; return ref . to string ( ) ; }
public int byte start ( int byte i d ) { assert byte start ! = null : `` byte start be null - not initialize `` ; assert byte i d > = 0 & & bytes i d < count : byte i d ; return byte start [ byte i d ] ; }
public int cardinality ( ) { return ( int ) bit util . pop_array ( bit , 0 , bit . length ) ; }
public static long prefix cod to long ( final byte ref val ) { long sortable bit = 0l ; for ( int i=val . offset+1 , limit=val . offset+val . length ; i < limit ; i++ ) { sortable bit < < = 7 ; final byte b = val . bytes [ i ] ; if ( b < 0 ) { throw new number format exception ( `` invalid prefix cod numerical value representation ( byte `` + integer . to hex string ( b & 0xff ) + `` at position `` + ( i-val . offset ) + `` be invalid ) `` ) ; } sortable bit |= b ; } return ( sortable bit < < get prefix cod long shift ( val ) ) ^ 0x8000000000000000 l ; }
public void remove ( open bit set other ) { int idx = math . min ( wlen , other . wlen ) ; long [ ] this arr = this . bit ; long [ ] other arr = other . bit ; while ( -- idx > =0 ) { this arr [ idx ] & = ~other arr [ idx ] ; } }
public long ord ( ) { return ord ; }
public long num encode ( ) { return num encode ; }
public long previous value ( ) { if ( ! to before current high bit ( ) ) { return no_more_values ; } long high value = previous high value ( ) ; return combine high low value ( high value , current low value ( ) ) ; }
public analyzer get analyzer ( ) { return analyzer ; }
public void set enable position increment ( boolean enable ) { this . enable position increment = enable ; }
public static long size of ( byte [ ] arr ) { return align object size ( ( long ) num_bytes_array_header + arr . length ) ; }
public static boolean be parent class loader ( final class loader parent , class loader child ) { while ( child ! = null ) { if ( child == parent ) { return true ; } child = child . get parent ( ) ; } return false ; }
public void merge ( merge state merge state ) throw i o exception { for ( doc value producer doc value producer : merge state . doc value producer ) { if ( doc value producer ! = null ) { doc value producer . check integrity ( ) ; } } for ( field info merge field info : merge state . merge field info ) { doc value type type = merge field info . get doc value type ( ) ; if ( type ! = doc value type . none ) { if ( type == doc value type . numeric ) { merge numeric field ( merge field info , merge state ) ; } else if ( type == doc value type . binary ) { merge binary field ( merge field info , merge state ) ; } else if ( type == doc value type . sort ) { merge sort field ( merge field info , merge state ) ; } else if ( type == doc value type . sorted_set ) { merge sort set field ( merge field info , merge state ) ; } else if ( type == doc value type . sorted_numeric ) { merge sort numeric field ( merge field info , merge state ) ; } else { throw new assertion error ( `` type= `` + type ) ; } } } }
public store field reader get merge instance ( ) { return this ; }
public static query new range query ( string field , double [ ] low value , double [ ] upper value ) { point range query . check args ( field , low value , upper value ) ; return new point range query ( field , pack ( low value ) . byte , pack ( upper value ) . byte , low value . length ) { @ override protect string to string ( int dimension , byte [ ] value ) { return double . to string ( decode dimension ( value , 0 ) ) ; } } ; }
public double get min ( int dimension ) { future object . check index ( dimension , type . point dimension count ( ) /2 ) ; return decode min ( ( ( bytes ref ) field data ) . byte , dimension ) ; }
public static query new within query ( string field , final double [ ] min , final double [ ] max ) { return new relation query ( field , min , max , query type . within ) ; }
public reader reader value ( ) { return field data instanceof reader ? ( reader ) field data : null ; }
public void set string value ( string value ) { if ( ! ( field data instanceof string ) ) { throw new illegal argument exception ( `` can not change value type from `` + field data . get class ( ) . get simple name ( ) + `` to string `` ) ; } if ( value == null ) { throw new illegal argument exception ( `` value must not be null `` ) ; } field data = value ; }
public void set token stream ( token stream token stream ) { if ( type . index option ( ) == index option . none || ! type . tokenized ( ) ) { throw new illegal argument exception ( `` token stream field must be indexed and tokenized `` ) ; } this . token stream = token stream ; }
public static sort field new distance sort ( string field , double latitude , double longitude ) { return new lat lon point sort field ( field , latitude , longitude ) ; }
public static query new polygon query ( string field , polygon . . . polygon ) { return new geometry query ( field , shape field . query relation . intersects , polygon ) ; }
public static query new slow polygon query ( string field , x y polygon . . . polygon ) { return new slow geometry query ( field , polygon ) ; }
public static query new line query ( string field , query relation query relation , x y line . . . line ) { return new geometry query ( field , query relation , line ) ; }
public static query new distance query ( string field , query relation query relation , x y circle . . . circle ) { return new geometry query ( field , query relation , circle ) ; }
protect boolean contains ( double x , double y ) { return contain pn poly ( x , y ) > false ; }
public static distance predicate create distance predicate ( double lat , double lon , double radius meter ) { final rectangle bound box = rectangle . from point distance ( lat , lon , radius meter ) ; final double axis lat = rectangle . axis lat ( lat , radius meter ) ; final double distance sort key = geo utils . distance query sort key ( radius meter ) ; final function < rectangle , relation > box to relation = box - > geo utils . relate ( box . min lat , box . max lat , box . min lon , box . max lon , lat , lon , distance sort key , axis lat ) ; final grid sub box = create sub box ( bound box . min lat , bound box . max lat , bound box . min lon , bound box . max lon , box to relation ) ; return new distance predicate ( sub box . lat shift , sub box . lon shift , sub box . lat base , sub box . lon base , sub box . max lat delta , sub box . max lon delta , sub box . relation , lat , lon , distance sort key ) ; }
public static boolean line cross line ( double a1x , double a1y , double b1x , double b1y , double a2x , double a2y , double b2x , double b2y ) { if ( orient ( a2x , a2y , b2x , b2y , a1x , a1y ) * orient ( a2x , a2y , b2x , b2y , b1x , b1y ) < 0 & & orient ( a1x , a1y , b1x , b1y , a2x , a2y ) * orient ( a1x , a1y , b1x , b1y , b2x , b2y ) < 0 ) { return true ; } return false ; }
public void set checksum only ( boolean v ) { checksum only = v ; }
public synchronize void disable auto i o throttle ( ) { do auto i o throttle = false ; update merge thread ( ) ; }
public void set point dimension ( int dimension count , int index dimension count , int num byte ) { if ( dimension count < = 0 ) { throw new illegal argument exception ( `` point dimension count must be > = 0 ; get `` + dimension count + `` for field=\ `` `` + name + `` \ `` `` ) ; } if ( index dimension count > point value . max_index_dimensions ) { throw new illegal argument exception ( `` point index dimension count must be < point value . max_index_dimensions ( = `` + point value . max_index_dimensions + `` ) ; get `` + index dimension count + `` for field=\ `` `` + name + `` \ `` `` ) ; } if ( index dimension count > dimension count ) { throw new illegal argument exception ( `` point index dimension count must be < = point dimension count ( = `` + dimension count + `` ) ; get `` + index dimension count + `` for field=\ `` `` + name + `` \ `` `` ) ; } if ( num byte < = 0 ) { throw new illegal argument exception ( `` point num byte must be > = 0 ; get `` + num bytes + `` for field=\ `` `` + name + `` \ `` `` ) ; } if ( num byte > point value . max_num_bytes ) { throw new illegal argument exception ( `` point num byte must be < = point value . max_num_bytes ( = `` + point value . max_num_bytes + `` ) ; get `` + num bytes + `` for field=\ `` `` + name + `` \ `` `` ) ; } if ( point dimension count ! = 0 & & point dimension count ! = dimension count ) { throw new illegal argument exception ( `` can not change point dimension count from `` + point dimension count + `` to `` + dimension count + `` for field=\ `` `` + name + `` \ `` `` ) ; } if ( point index dimension count ! = 0 & & point index dimension count ! = index dimension count ) { throw new illegal argument exception ( `` can not change point index dimension count from `` + point index dimension count + `` to `` + index dimension count + `` for field=\ `` `` + name + `` \ `` `` ) ; } if ( point num bytes ! = 0 & & point num bytes ! = num byte ) { throw new illegal argument exception ( `` can not change point num bytes from `` + point num bytes + `` to `` + num byte + `` for field=\ `` `` + name + `` \ `` `` ) ; } point dimension count = dimension count ; point index dimension count = index dimension count ; point num bytes = num byte ; this . check consistency ( ) ; }
public integer get version ( ) { return version ; }
public void force merge ( int max num segment ) throw i o exception { force merge ( max num segment , true ) ; }
public long get pending num doc ( ) { return pending num doc . get ( ) ; }
public version get min version ( ) { return min version ; }
public live index writer config set check pending flush update ( boolean check pending flush on update ) { this . check pending flush on update = check pending flush on update ; return this ; }
public term [ ] get sub term ( ) { return sub ; }
public long get next doc value gen ( ) { return next write doc value gen ; }
public version get min version ( ) { return min version ; }
/ * * package private constructor , call only from static open ( ) method * / standard directory reader ( directory directory , leaf reader [ ] reader , index writer writer , segment info si , comparator < leaf reader > leaf sorter , boolean apply all deletes , boolean write all deletes ) throw i o exception { super ( directory , reader , leaf sorter ) ; this . writer = writer ; this . segment info = si ; this . apply all deletes = apply all deletes ; this . write all deletes = write all deletes ; }
public double get delete pct allow ( ) { return delete pct allow ; }
public final boolean be cache ( ) { return cache ; }
public sort field get sort field ( boolean reverse ) { return new double value sort field ( this , reverse ) ; }
public static double value source from double field ( string field ) { return from field ( field , double : : long bit to double ) ; }
public static double value source from int field ( string field ) { return from long field ( field ) ; }
public static explanation match ( number value , string description , collection < explanation > detail ) { return new explanation ( true , value , description , detail ) ; }
public static long value source constant ( long value ) { return new constant long value source ( value ) ; }
protect void on clear ( ) { assert lock . be hold by current thread ( ) ; ram byte use = 0 ; cache size = 0 ; }
public collection < child scorable > get child ( ) throw i o exception { return collection . empty list ( ) ; }
public sort set selector . type get selector ( ) { return selector ; }
public void reset ( ) { if ( block reuse ! = no_reuse ) { block . for each ( block reuse ) ; } block . clear ( ) ; ram byte use = 0 ; current block = empty ; }
public void skip byte ( final long num byte ) throw i o exception { if ( num byte < 0 ) { throw new illegal argument exception ( `` num bytes must be > = 0 , get `` + num byte ) ; } if ( skip buffer == null ) { skip buffer = new byte [ skip_buffer_size ] ; } assert skip buffer . length == skip_buffer_size ; for ( long skip = 0 ; skip < num byte ; ) { final int step = ( int ) math . min ( skip_buffer_size , num bytes - skipped ) ; read byte ( skip buffer , 0 , step , false ) ; skip += step ; } }
public static string to string ( accountable a ) { string builder sb = new string builder ( ) ; to string ( sb , a , 0 ) ; return sb . to string ( ) ; }
public static accountable name accountable ( string description , long bytes ) { return name accountable ( description , collection . < accountable > empty list ( ) , bytes ) ; }
public static accountable name accountable ( final string description , final collection < accountable > child , final long byte ) { return new accountable ( ) { @ override public long ram byte use ( ) { return byte ; } @ override public collection < accountable > get child resource ( ) { return child ; } @ override public string to string ( ) { return description ; } } ; }
public static int append any char ( automaton a , int state ) { int new state = a . create state ( ) ; a . add transition ( state , new state , character . min_code_point , character . max_code_point ) ; return new state ; }
public void add epsilon ( int source , int dest ) { transition t = new transition ( ) ; int count = init transition ( d , t ) ; for ( int i=0 ; i < count ; i++ ) { get next transition ( t ) ; add transition ( source , t . d , t . min , t . max ) ; } if ( be accept ( d ) ) { set accept ( source , true ) ; } }
public static boolean same language ( automaton a1 , automaton a2 ) { if ( a1 == a2 ) { return true ; } return subset of ( a2 , a1 ) & & subset of ( a1 , a2 ) ; }
public static boolean be finite ( automaton a ) { if ( a . get num state ( ) == 0 ) { return true ; } return be finite ( new transition ( ) , a , 0 , new bit set ( a . get num state ( ) ) , new bit set ( a . get num state ( ) ) , 0 ) ; }
public int frequency ( int key ) { return frequency . frequency ( key ) ; }
public builder < t > set direct address max oversizing factor ( float factor ) { direct address max oversizing factor = factor ; return this ; }
public input output < t > seek ceil ( bytes ref target ) throw i o exception { this . target = target ; target length = target . length ; super . do seek ceil ( ) ; return set result ( ) ; }
public static int mismatch ( byte [ ] a , int a from index , int a to index , byte [ ] b , int b from index , int b to index ) { check from to index ( a from index , a to index , a . length ) ; check from to index ( b from index , b to index , b . length ) ; int a len = a to index - a from index ; int b len = b to index - b from index ; int len = math . min ( a len , b len ) ; for ( int i = 0 ; i < len ; i++ ) if ( a [ i+a from index ] ! = b [ i+b from index ] ) return i ; return a len == b len ? -1 : len ; }
public list < attribute source > get term ( int state ) { int num t = det . init transition ( state , transition ) ; list < attribute source > tokens = new array list < > ( ) ; for ( int i = 0 ; i < num t ; i++ ) { det . get next transition ( transition ) ; token . add all ( array . a list ( this . token ) . sub list ( transition . min , transition . max + 1 ) ) ; } return token ; }
public int length ( ) { return ref . length ; }
public boolean get enable graph query ( ) { return enable graph query ; }
protect query analyze boolean ( string field , token stream stream ) throw i o exception { term to byte ref attribute term att = stream . get attribute ( term to byte ref attribute . class ) ; boost attribute boost att = stream . add attribute ( boost attribute . class ) ; stream . reset ( ) ; list < term and boost > term = new array list < > ( ) ; while ( stream . increment token ( ) ) { term . add ( new term and boost ( new term ( field , term att . get byte ref ( ) ) , boost att . get boost ( ) ) ) ; } return new synonym query ( term . to array ( new term and boost [ 0 ] ) ) ; }
public int cardinality ( ) { return cardinality ; }
public group search set caching ( int max doc to cache , boolean cache score ) { this . max doc to cache = max doc to cache ; this . max cache r a m m b = null ; this . cache score = cache score ; return this ; }
public group search set include max score ( boolean include max score ) { this . include max score = include max score ; return this ; }
public group search set all group head ( boolean all group head ) { this . all group head = all group head ; return this ; }
public final void collect ( t value , int doc ) throw i o exception { group collector < c > collector = group . get ( value ) ; collector . leaf collector . collect ( doc ) ; }
public static < t > collection < search group < t > > merge ( list < collection < search group < t > > > top group , int offset , int top n , sort group sort ) { if ( top group . be empty ( ) ) { return null ; } else { return new group merger < t > ( group sort ) . merge ( top group , offset , top n ) ; } }
public top group < t > get top group ( int within group offset ) { @ suppress warning ( { `` unchecked `` , `` rawtypes `` } ) final group doc < t > [ ] group docs result = ( group docs < t > [ ] ) new group docs [ group . size ( ) ] ; int group i d x = 0 ; float max score = float . min_value ; for ( search group < t > group : group ) { top doc and max score collector collector = ( top doc and max score collector ) group reducer . get collector ( group . group value ) ; final top doc top doc ; final float group max score ; if ( collector . sort by score ) { top doc all top doc = collector . top doc collector . top doc ( ) ; group max score = all top doc . score doc . length == 0 ? float . na n : all top doc . score doc [ 0 ] . score ; if ( all top doc . score doc . length < = within group offset ) { top doc = new top doc ( all top doc . total hit , new score doc [ 0 ] ) ; } else { top doc = new top doc ( all top doc . total hit , array util . copy of sub array ( all top doc . score doc , within group offset , math . min ( all top doc . score doc . length , within group offset + max doc per group ) ) ) ; } } else { top doc = collector . top doc collector . top doc ( within group offset , max doc per group ) ; if ( collector . max score collector == null ) { group max score = float . na n ; } else { group max score = collector . max score collector . get max score ( ) ; } } group docs result [ group i d x++ ] = new group docs < > ( float . na n , group max score , top doc . total hit , top doc . score doc , group . group value , group . sort value ) ; max score = math . max ( max score , group max score ) ; } return new top group < > ( group sort . get sort ( ) , within group sort . get sort ( ) , total hit count , total group hit count , group doc result , max score ) ; }
public int [ ] get match start ( ) { return match start ; }
public boolean be phrase highlight ( ) { return phrase highlight ; }
public query get query ( ) { return query ; }
public float get low freq minimum number should match ( ) { return low freq min nr should match ; }
public static double value source doc count ( string field ) { return new index reader double value source ( r - > r . get doc count ( field ) , `` doc count ( `` + field + `` ) `` ) ; }
public sort field get sort field ( boolean reverse ) { return new value source sort field ( reverse ) ; }
public static interval source after ( interval source source , interval source reference ) { return contain by interval source . build ( source , interval . extend ( new offset interval source ( reference , false ) , 0 , integer . max_value ) ) ; }
protect query get prefix query ( string field , string term str ) throw parse exception { if ( ! allow lead wildcard & & term str . start with ( `` * `` ) ) throw new parse exception ( `` ' * ' not allow a first character in prefix query `` ) ; bytes ref term = get analyzer ( ) . normalize ( field , term str ) ; term t = new term ( field , term ) ; return new prefix query ( t ) ; }
public char get extension field delimiter ( ) { return extension . get extension field delimiter ( ) ; }
public char sequence get field ( ) { return this . field ; }
public query node get child ( ) { list < query node > child = get child ( ) ; if ( child == null || child . size ( ) == 0 ) { return null ; } return child . get ( 0 ) ; }
public void set query config handler ( query config handler query config handler ) { this . query config = query config handler ; }
public void set fuzzy min sim ( float fuzzy min sim ) { query config handler config = get query config handler ( ) ; fuzzy config fuzzy config = config . get ( configuration key . fuzzy_config ) ; if ( fuzzy config == null ) { fuzzy config = new fuzzy config ( ) ; config . set ( configuration key . fuzzy_config , fuzzy config ) ; } fuzzy config . set min similarity ( fuzzy min sim ) ; }
protect query new phrase query ( string text , int slop ) { boolean query . builder bq = new boolean query . builder ( ) ; for ( map . entry < string , float > entry : weight . entry set ( ) ) { query q = create phrase query ( entry . get key ( ) , text , slop ) ; if ( q ! = null ) { float boost = entry . get value ( ) ; if ( boost ! = 1f ) { q = new boost query ( q , boost ) ; } bq . add ( q , boolean clause . occur . should ) ; } } return simplify ( bq . build ( ) ) ; }
protect query new prefix query ( string text ) { boolean query . builder bq = new boolean query . builder ( ) ; for ( map . entry < string , float > entry : weight . entry set ( ) ) { final string field name = entry . get key ( ) ; final byte ref term = get analyzer ( ) . normalize ( field name , text ) ; query q = new prefix query ( new term ( field name , term ) ) ; float boost = entry . get value ( ) ; if ( boost ! = 1f ) { q = new boost query ( q , boost ) ; } bq . add ( q , boolean clause . occur . should ) ; } return simplify ( bq . build ( ) ) ; }
public int compare to ( simple term ost ) { / * for order term and prefix before use an index , not use * / return this . to string unquoted ( ) . compare to ( ost . to string unquoted ( ) ) ; }
public static query new range query ( string field , float low value , float upper value ) { return new range query ( field , new float [ ] { low value } , new float [ ] { upper value } ) ; }
protect doc id set get doc id set ( leaf reader context context ) throw i o exception { / * possible optimization ( in in addition to those list in visitortemplate ) : * if doc freq be 1 ( or < than some small threshold ) , then check to see if we 've already collect it ; if so short-circuit . do n't do this just for point data , a there be no benefit , or only marginal benefit when multi-valued . * point query shape optimization when the only indexed data be a point ( no leaf ) . result be a term query . * / return new visitor template ( context ) { private doc id set builder result ; @ override protect void start ( ) throw i o exception { result = new doc id set builder ( max doc , term ) ; } @ override protect doc id set finish ( ) { return result . build ( ) ; } @ override protect boolean visit prefix ( cell cell ) throw i o exception { if ( cell . get shape rel ( ) == spatial relation . within || cell . get level ( ) == detail level ) { collect doc ( result ) ; return false ; } return true ; } @ override protect void visit leaf ( cell cell ) throw i o exception { collect doc ( result ) ; } } . get doc id set ( ) ; }
public void set point only ( boolean point only ) { this . point only = point only ; }
public void set version ( version v ) { version = v ; }
public string to string ( ) { return `` distance value source ( `` +strategy+ `` , `` +from+ `` ) `` ; }
public static sort field new outside distance sort ( final string field , final double latitude , final double longitude , final double max radius meter , final planet model planet model ) { final geo outside distance shape = geo3 d util . from distance ( planet model , latitude , longitude , max radius meter ) ; return new geo3 d point outside sort field ( field , planet model , shape ) ; }
public static geo polygon make geo concave polygon ( final planet model planet model , final list < geo point > point list ) { return new geo concave polygon ( planet model , point list ) ; }
public static plane construct normalize z plane ( final double x , final double y ) { if ( math . ab ( x ) < minimum_resolution & & math . ab ( y ) < minimum_resolution ) return null ; final double denom = 1 . 0 / math . sqrt ( x * x + y * y ) ; return new plane ( y * denom , -x * denom , 0 . 0 , 0 . 0 ) ; }
public void record bound ( final planet model planet model , final lat lon bound bound info , final plane p , final membership . . . bound ) { find intersection bound ( planet model , bound info , p , bound ) ; }
public boolean point on surface ( final vector v ) { return point on surface ( v . x , v . y , v . z ) ; }
public static double magnitude ( final double x , final double y , final double z ) { return math . sqrt ( x * x + y * y + z * z ) ; }
public double magnitude ( ) { return magnitude ( x , y , z ) ; }
public boolean be numerically identical ( final double other x , final double other y , final double other z ) { final double delta x = x - other x ; final double delta y = y - other y ; final double delta z = z - other z ; return delta x * delta x + delta y * delta y + delta z * delta z < minimum_resolution_squared ; }
public bound add x value ( final double x ) { final double small = x - fudge_factor ; if ( min x == null || min x > small ) { min x = small ; } final double large = x + fudge_factor ; if ( max x == null || max x < large ) { max x = large ; } return this ; }
public void set min query length ( int min query length ) { if ( min query length > this . max query length ) throw new illegal argument exception ( `` min query length must not be great than max query length `` ) ; this . min query length = min query length ; }
public void set low case term ( boolean low case term ) { this . low case term = low case term ; }
public int get min suggestion frequency ( ) { return min suggestion frequency ; }
public void set max combine word length ( int max combine word length ) { this . max combine word length = max combine word length ; }
protect automaton convert automaton ( automaton a ) { return a ; }
public int get max determinized state ( ) { return max determinized state ; }
public analyzer get analyzer ( ) { return analyzer ; }
public top suggest doc suggest ( completion query query , int n , boolean skip duplicate ) throw i o exception { top suggest doc collector collector = new top suggest doc collector ( n , skip duplicate ) ; suggest ( query , collector ) ; return collector . get ( ) ; }
public object get ( char sequence key ) { final int bucket = normal completion . get bucket ( key ) ; return bucket == -1 ? null : long . value of ( bucket ) ; }
protect t s t node get node ( char sequence key , t s t node start node ) { if ( key == null || start node == null || key . length ( ) == 0 ) { return null ; } t s t node current node = start node ; int char index = 0 ; while ( true ) { if ( current node == null ) { return null ; } int char comp = compare char alphabetically ( key . char at ( char index ) , current node . splitchar ) ; if ( char comp == 0 ) { char index++ ; if ( char index == key . length ( ) ) { return current node ; } current node = current node . relatives [ t s t node . eqkid ] ; } else if ( char comp < 0 ) { current node = current node . relatives [ t s t node . lokid ] ; } else { current node = current node . relatives [ t s t node . hikid ] ; } } }
public int num data node ( ) { return num data node ( root node ) ; }
public int num node ( ) { return num node ( root node ) ; }
public void remove ( k key ) { synchronize ( cache ) { cache . remove ( key ) ; } }
public void clear ( ) { synchronize ( cache ) { cache . clear ( ) ; } }
public instance get ( int index ) { return instance . get ( index ) ; }
public static decision forest load ( configuration conf , path forest path ) throw i o exception { file system fs = forest path . get file system ( conf ) ; path [ ] file ; if ( f . get file status ( forest path ) . be dir ( ) ) { file = d f utils . list output file ( f , forest path ) ; } else { file = new path [ ] { forest path } ; } decision forest forest = null ; for ( path path : file ) { f s data input stream data input = new f s data input stream ( f . open ( path ) ) ; try { if ( forest == null ) { forest = read ( data input ) ; } else { forest . read field ( data input ) ; } } finally { closeables . close ( data input , true ) ; } } return forest ; }
public static path get distribute cache file ( configuration conf , int index ) throw i o exception { path [ ] file = hadoop util . get cached file ( conf ) ; if ( file . length < = index ) { throw new i o exception ( `` path not find in the distributed cache `` ) ; } return file [ index ] ; }
public int partition ( ) { return ( int ) ( get ( ) / max_treeid ) ; }
public static string to string ( string forest path , string dataset path , string [ ] attr name ) throw i o exception { configuration conf = new configuration ( ) ; decision forest forest = decision forest . load ( conf , new path ( forest path ) ) ; dataset dataset = dataset . load ( conf , new path ( dataset path ) ) ; return to string ( forest , dataset , attr name ) ; }
public static void main ( string [ ] args ) throw i o exception { default option builder obuilder = new default option builder ( ) ; argument builder abuilder = new argument builder ( ) ; group builder gbuilder = new group builder ( ) ; option data opt = obuilder . with long name ( `` data `` ) . with short name ( `` d `` ) . with required ( true ) . with argument ( abuilder . with name ( `` data `` ) . with minimum ( 1 ) . with maximum ( 1 ) . create ( ) ) . with description ( `` data path `` ) . create ( ) ; option dataset opt = obuilder . with long name ( `` dataset `` ) . with short name ( `` ds `` ) . with required ( true ) . with argument ( abuilder . with name ( `` dataset `` ) . with minimum ( 1 ) . create ( ) ) . with description ( `` dataset path `` ) . create ( ) ; option output opt = obuilder . with long name ( `` output `` ) . with short name ( `` o `` ) . with required ( true ) . with argument ( abuilder . with name ( `` output `` ) . with minimum ( 1 ) . with maximum ( 1 ) . create ( ) ) . with description ( `` path to generate file `` ) . create ( ) ; option partition opt = obuilder . with long name ( `` numpartitions `` ) . with short name ( `` p `` ) . with required ( true ) . with argument ( abuilder . with name ( `` numparts `` ) . with minimum ( 1 ) . with minimum ( 1 ) . create ( ) ) . with description ( `` number of partition to create `` ) . create ( ) ; option help opt = obuilder . with long name ( `` help `` ) . with description ( `` print out help `` ) . with short name ( `` h `` ) . create ( ) ; group group = gbuilder . with name ( `` option `` ) . with option ( data opt ) . with option ( output opt ) . with option ( dataset opt ) . with option ( partition opt ) . with option ( help opt ) . create ( ) ; try { parser parser = new parser ( ) ; parser . set group ( group ) ; command line cmd line = parser . parse ( args ) ; if ( cmd line . have option ( help opt ) ) { command line util . print help ( group ) ; return ; } string data = cmd line . get value ( data opt ) . to string ( ) ; string dataset = cmd line . get value ( dataset opt ) . to string ( ) ; int num partition = integer . parse int ( cmd line . get value ( partition opt ) . to string ( ) ) ; string output = cmd line . get value ( output opt ) . to string ( ) ; run tool ( data , dataset , output , num partition ) ; } catch ( option exception e ) { log . warn ( e . to string ( ) , e ) ; command line util . print help ( group ) ; } }
public double get momentum weight ( ) { return this . momentum weight ; }
public matrix get transition matrix ( ) { return transition matrix ; }
public int get hidden state i d ( string name ) { if ( hidden state name == null ) { return -1 ; } integer tmp = hidden state name . get ( name ) ; return tmp == null ? -1 : tmp ; }
public static double link ( double r ) { if ( r < 0 . 0 ) { double s = math . exp ( r ) ; return s / ( 1 . 0 + s ) ; } else { double s = math . exp ( -r ) ; return 1 . 0 / ( 1 . 0 + s ) ; } }
public string get target string ( char sequence line ) { list < string > value = parse csv line ( line ) ; return value . get ( target ) ; }
public double compute prob weight ( double cluster distance , iterable < double > cluster distance list ) { if ( cluster distance == 0 ) { cluster distance = minimal_value ; } double denom = 0 . 0 ; for ( double each c dist : cluster distance list ) { if ( each c dist == 0 . 0 ) { each c dist = minimal_value ; } denom += math . pow ( cluster distance / each c dist , 2 . 0 / ( m - 1 ) ) ; } return 1 . 0 / denom ; }
public boolean compute convergence ( distance measure measure , double convergence delta ) { vector centroid = compute centroid ( ) ; converge = measure . distance ( centroid . get length square ( ) , centroid , get center ( ) ) < = convergence delta ; return converge ; }
public static path get top level cluster path ( path output ) { return new path ( output + file . separator + top_level_cluster_directory ) ; }
public void process ( ) throw i o exception { create post process directory ( ) ; for ( pair < ? , weight vector writable > record : new sequence file dir iterable < writable , weighted vector writable > ( clustered point , path type . glob , path filter . part filter ( ) , null , false , conf ) ) { string cluster id = record . get first ( ) . to string ( ) . trim ( ) ; put vector in respective cluster ( cluster id , record . get second ( ) ) ; } i o utils . close ( writer for cluster . value ( ) ) ; writer for cluster . clear ( ) ; }
protect void add input option ( ) { this . input option = add option ( default option creator . input option ( ) . create ( ) ) ; }
public double distance ( vector v1 , vector v2 ) { return math . pow ( v1 . aggregate ( v2 , function . plus , function . minus abs pow ( exponent ) ) , 1 . 0 / exponent ) ; }
public static long count record ( path path , path type pt , path filter filter , configuration conf ) throw i o exception { long count = 0 ; iterator < ? > iterator = new sequence file dir value iterator < writable > ( path , pt , filter , null , true , conf ) ; while ( iterator . have next ( ) ) { iterator . next ( ) ; count++ ; } return count ; }
public boolean add ( integer entry ) { return tuple . add ( entry ) ; }
public static mapping exponential ( ) { return exponential ( 1 ) ; }
public static vector get initial vector ( vector iterable corpus ) { vector initial vector = new dense vector ( corpus . num col ( ) ) ; initial vector . assign ( 1 . 0 / math . sqrt ( corpus . num col ( ) ) ) ; return initial vector ; }
public distribute row matrix time ( distributed row matrix other ) throw i o exception { return time ( other , new path ( output tmp base path . get parent ( ) , `` product with- `` + ( system . nano time ( ) & 0x f f ) ) ) ; }
public weight thing < vector > search first ( vector query , boolean different than query ) { double best distance = double . positive_infinity ; vector best vector = null ; for ( vector row : reference vector ) { double distance = distance measure . distance ( query , row ) ; if ( distance < best distance & & ( ! different than query || ! row . equal ( query ) ) ) { best distance = distance ; best vector = row ; } } return new weighted thing < vector > ( best vector , best distance ) ; }
public void add to vector ( byte [ ] original form , vector data ) { add to vector ( original form , 1 . 0 , data ) ; }
protect iterable < integer > hash for probe ( byte [ ] original form , int data size , string name , int probe ) { return collection . singleton list ( hash for probe ( original form , data size , name , probe ) ) ; }
protect static int hash ( string term1 , string term2 , int probe , int num feature ) { long r = murmur hash . hash64 a ( byte for string ( term1 ) , probe ) ; r = murmur hash . hash64 a ( byte for string ( term2 ) , ( int ) r ) % num feature ; if ( r < 0 ) { r += num feature ; } return ( int ) r ; }
public static long floor ( double value ) { return math . round ( math . floor ( value ) ) ; }
public int num slice ( ) { return num row ( ) ; }
public static string to string ( byte [ ] array ) { string builder buf = new string builder ( ) ; buf . append ( ' [ ' ) ; int max index = array . length - 1 ; for ( int i = 0 ; i < = max index ; i++ ) { buf . append ( array [ i ] ) ; if ( i < max index ) { buf . append ( `` , `` ) ; } } buf . append ( ' ] ' ) ; return buf . to string ( ) ; }
public static double function constant ( final double c ) { return new double function ( ) { @ override public double apply ( double a ) { return c ; } } ; }
public static double function mod ( final double b ) { return new double function ( ) { @ override public double apply ( double a ) { return a % b ; } } ; }
public static double function plus ( final double b ) { return new double function ( ) { @ override public double apply ( double a ) { return a + b ; } } ; }
public boolean be commutative ( ) { return true ; }
public void set state ( double lambda ) { this . lambda = lambda ; }
public double pdf ( double x ) { if ( x < 0 ) { throw new illegal argument exception ( ) ; } if ( x == 0 ) { if ( alpha == 1 . 0 ) { return rate ; } else if ( alpha < 1 ) { return double . positive_infinity ; } else { return 0 ; } } if ( alpha == 1 . 0 ) { return rate * math . exp ( -x * rate ) ; } return rate * math . exp ( ( alpha - 1 . 0 ) * math . log ( x * rate ) - x * rate - log gamma ( alpha ) ) ; }
public static double log gamma ( double x ) { if ( x < = 0 . 0 / * || x > 1 . 3e19 * / ) { return -999 ; } double z ; for ( z = 1 . 0 ; x < 11 . 0 ; x++ ) { z * = x ; } double r = 1 . 0 / ( x * x ) ; double c6 = -1 . 9175269175269175e-03 ; double c5 = 8 . 4175084175084175e-04 ; double c4 = -5 . 9523809523809524e-04 ; double c3 = 7 . 9365079365079365e-04 ; double c2 = -2 . 7777777777777777e-03 ; double c1 = 8 . 3333333333333333e-02 ; double g = c1 + r * ( c2 + r * ( c3 + r * ( c4 + r * ( c5 + r + c6 ) ) ) ) ; double c0 = 9 . 1893853320467274e-01 ; g = ( x - 0 . 5 ) * math . log ( x ) - x + c0 + g / x ; if ( z == 1 . 0 ) { return g ; } return g - math . log ( z ) ; }
public double pdf ( double x ) { double diff = x - mean ; return normalizer * math . exp ( - ( diff * diff ) / ( 2 . 0 * variance ) ) ; }
public static double beta ( double alpha , double beta ) { double y ; if ( alpha < 40 & & beta < 40 ) { y = gamma ( alpha + beta ) ; if ( y == 0 . 0 ) { return 1 . 0 ; } if ( alpha > beta ) { y = gamma ( alpha ) / y ; y * = gamma ( beta ) ; } else { y = gamma ( beta ) / y ; y * = gamma ( alpha ) ; } } else { y = math . exp ( log gamma ( alpha ) + log gamma ( beta ) - log gamma ( alpha + beta ) ) ; } return y ; }
public static double gamma ( double alpha , double beta , double x ) { if ( x < 0 . 0 ) { return 0 . 0 ; } return gamma . incomplete gamma ( alpha , beta * x ) ; }
public static double normal ( double a ) { if ( a < 0 ) { return 1 - normal ( -a ) ; } double b0 = 0 . 2316419 ; double b1 = 0 . 319381530 ; double b2 = -0 . 356563782 ; double b3 = 1 . 781477937 ; double b4 = -1 . 821255978 ; double b5 = 1 . 330274429 ; double t = 1 / ( 1 + b0 * a ) ; return 1 - unit_normal . pdf ( a ) * t * ( b1 + t * ( b2 + t * ( b3 + t * ( b4 + t * b5 ) ) ) ) ; }
public void delete ( byte element ) { int index = index of from to ( element , 0 , size - 1 ) ; if ( index > = 0 ) { remove ( index ) ; } }
public final void quick sort ( ) { quick sort from to ( 0 , size ( ) - 1 ) ; }
public final void sort ( ) { sort from to ( 0 , size ( ) - 1 ) ; }
public void key sort by value ( byte array list key list ) { pair sort by value ( key list , new byte array list ( size ( ) ) ) ; }
public void value ( final byte array list list ) { list . clear ( ) ; for each key ( new byte procedure ( ) { @ override public boolean apply ( byte key ) { list . add ( get ( key ) ) ; return true ; } } ) ; }
public collection < v > value ( ) { final list < v > value list = new array list < > ( ) ; for each pair ( new object object procedure < k , v > ( ) { @ override public boolean apply ( k key , v value ) { value list . add ( value ) ; return true ; } } ) ; return value list ; }
public matrix get q ( ) { int column = math . min ( original column , original row ) ; matrix q = qr . like ( original row , column ) ; for ( int k = columns - 1 ; k > = 0 ; k -- ) { vector q rcolk = qr . view column ( k ) . view part ( k , original row - k ) ; q . set ( k , k , 1 ) ; for ( int j = k ; j < columns ; j++ ) { if ( qr . get ( k , k ) ! = 0 ) { vector qcolj = q . view column ( j ) . view part ( k , original row - k ) ; double s = - q rcolk . dot ( qcolj ) / qr . get ( k , k ) ; qcolj . assign ( q rcolk , function . plus mult ( s ) ) ; } } } return q ; }
public string to string ( ) { return string . format ( locale . english , `` qr ( % d , % d , full rank= % s ) `` , original column , original row , have full rank ( ) ) ; }
public void swap row ( int i , int j ) { swap ( row pivot , row unpivot , i , j ) ; }
public vector view row ( int row ) { if ( row < 0 || row > = row size ( ) ) { throw new index exception ( row , row size ( ) ) ; } return new permuted vector view ( base . view row ( row pivot [ row ] ) , column pivot , column unpivot ) ; }
public vector get imag eigenvalue ( ) { return e ; }
public static void merge sort ( double [ ] array , int start , int end ) { merge sort ( array , start , end , natural_double_comparison ) ; }
public enumeration get non match header line ( string [ ] name ) throw message exception { check expunge ( ) ; load header ( ) ; return super . get non match header line ( name ) ; }
protect void handle extension fetch item ( map extension item ) throw message exception { if ( item == null ) item = extension item ; else item . put all ( extension item ) ; }
public map get extension item ( ) { if ( extension item == null ) extension item = new hash map ( ) ; return extension item ; }
protect synchronized input stream get content stream ( ) throw message exception { if ( content stream ! = null ) return ( ( share input stream ) content stream ) . new stream ( 0 , -1 ) ; input stream cstream = get raw stream ( true ) ; / * * keep a hard reference to the data if we 're use a file * cache or if the `` mail . pop3 . keepmessagecontent `` prop be set . * / temp file cache = folder . get file cache ( ) ; if ( cache ! = null || ( ( p o p3 store ) ( folder . get store ( ) ) ) . keep message content ) content stream = ( ( share input stream ) cstream ) . new stream ( 0 , -1 ) ; return cstream ; }
public void add header ( string name , string value ) throw message exception { header . add header ( name , value ) ; }
public synchronize void set flag ( flags flag , boolean set ) throw message exception { if ( set ) flag . add ( flag ) ; else flag . remove ( flag ) ; }
public synchronize body part get body part ( int index ) throw message exception { parse ( ) ; return super . get body part ( index ) ; }
public activation file get file ( ) { return this . file ; } // -- activation file get file ( )
public boolean be active by default ( ) { return this . active by default ; } // -- boolean be active by default ( )
public string get exists ( ) { return this . exist ; } // -- string get exists ( )
public string get miss ( ) { return this . miss ; } // -- string get missing ( )
public string get name ( ) { return this . name ; } // -- string get name ( )
public void set name ( string name ) { this . name = name ; } // -- void set name ( string )
public void set test output directory ( string test output directory ) { this . test output directory = test output directory ; } // -- void set test output directory ( string )
public string get url ( ) { return this . url ; } // -- string get url ( )
public void set system ( string system ) { this . system = system ; } // -- void set system ( string )
public string get organization url ( ) { return this . organization url ; } // -- string get organization url ( )
public void set group id ( string group id ) { this . group id = group id ; } // -- void set group id ( string )
public string get download url ( ) { return this . download url ; } // -- string get download url ( )
public deployment repository get repository ( ) { return this . repository ; } // -- deployment repository get repository ( )
public void set relocation ( relocation relocation ) { this . relocation = relocation ; } // -- void set relocation ( relocation )
public string get comment ( ) { return this . comment ; } // -- string get comment ( )
public string get url ( ) { return this . url ; } // -- string get url ( )
public void set unsubscribe ( string unsubscribe ) { this . unsubscribe = unsubscribe ; } // -- void set unsubscribe ( string )
public build get build ( ) { return this . build ; } // -- build get build ( )
public void set prerequisite ( prerequisite prerequisite ) { this . prerequisites = prerequisite ; } // -- void set prerequisite ( prerequisite )
public void set scm ( scm scm ) { this . scm = scm ; } // -- void set scm ( scm )
public string get address ( ) { return this . address ; } // -- string get address ( )
public boolean be send on warning ( ) { return this . send on warning ; } // -- boolean be send on warning ( )
public void set artifact id ( string artifact id ) { this . artifact id = artifact id ; } // -- void set artifact id ( string )
public void set relative path ( string relative path ) { this . relative path = relative path ; } // -- void set relative path ( string )
public object get goal ( ) { return this . goal ; } // -- object get goal ( )
public boolean be extension ( ) { return this . extension ; } // -- boolean be extension ( )
public void set execution ( java . util . list execution ) { this . execution = execution ; } // -- void set execution ( java . util . list )
public void set version ( string version ) { this . version = version ; } // -- void set version ( string )
public plugin management get plugin management ( ) { return this . plugin management ; } // -- plugin management get plugin management ( )
public string get developer connection ( ) { return this . developer connection ; } // -- string get developer connection ( )
public string get configuration ( ) { return this . configuration ; } // -- string get configuration ( )
public boolean be editable ( ) { return this . editable ; } // -- boolean be editable ( )
public void set last checked ( string last checked ) { this . last check = last check ; } // -- void set last checked ( string )
public void set auto update ( string auto update ) { this . auto update = auto update ; } // -- void set auto update ( string )
public activation file get file ( ) { return this . file ; } // -- activation file get file ( )
public void set exists ( string exists ) { this . exist = exists ; } // -- void set exists ( string )
public void set version ( string version ) { this . version = version ; } // -- void set version ( string )
public void set activation ( activation activation ) { this . activation = activation ; } // -- void set activation ( activation )
public void set snapshot ( repository policy snapshot ) { this . snapshots = snapshot ; } // -- void set snapshot ( repository policy )
public string get id ( ) { return this . id ; } // -- string get id ( )
public void set artifact id ( string artifact id ) { this . artifact id = artifact id ; } // -- void set artifact id ( string )
public void set name ( string name ) { this . name = name ; } // -- void set name ( string )
public string get release ( ) { return this . release ; } // -- string get release ( )
public string get miss ( ) { return this . miss ; } // -- string get missing ( )
public string get url ( ) { return this . url ; } // -- string get url ( )
public int get port ( ) { return this . port ; } // -- int get port ( )
public boolean be active ( ) { return this . active ; } // -- boolean be active ( )
public void set host ( string host ) { this . host = host ; } // -- void set host ( string )
public string get url ( ) { return this . url ; } // -- string get url ( )
public string get file permission ( ) { return this . file permission ; } // -- string get file permission ( )
public string get local repository ( ) { return this . local repository ; } // -- string get local repository ( )
public void set active profile ( java . util . list active profile ) { this . active profile = active profile ; } // -- void set active profile ( java . util . list )
public static ewma five minute e w m a ( ) { return new ewma ( m5_alpha , interval , time unit . second ) ; }
public void tick ( ) { final long count = uncounted . sum then reset ( ) ; final double instant rate = count / interval ; if ( initialize ) { rate += ( alpha * ( instant rate - rate ) ) ; } else { rate = instant rate ; initialize = true ; } }
public double get98th percentile ( ) { return get value ( 0 . 98 ) ; }
public stream < tag > stream ( ) { return stream support . stream ( spliterators . spliterator unknown size ( iterator ( ) , spliterator . order | spliterator . distinct | spliterator . nonnull | spliterator . sort ) , false ) ; }
public static boolean be not empty ( @ nullable string string ) { return ! be empty ( string ) ; }
public static internal logger factory get default factory ( ) { if ( default factory == null ) { default factory = new default factory ( internal logger factory . class . get name ( ) ) ; } return default factory ; }
public boolean be restart ( ) { return restart ; }
public static void flush from cache ( class < ? > clazz ) { if ( clazz == null ) { throw new null pointer exception ( ) ; } the cache . remove ( clazz ) ; }
public static void register field for runtime reflection ( before analysis access access , string class name ) { find class ( access , class name ) . if present ( automatic feature utils : : register field for runtime reflection ) ; }
public stream < class > scan ( string annotation , string pkg ) { if ( pkg == null ) { return stream . empty ( ) ; } list < class > class = do scan ( annotation , pkg ) ; return class . stream ( ) ; }
public static @ non null optional < class > array type for primitive ( string primitive type ) { if ( primitive type ! = null ) { return optional . of nullable ( primitive_array_map . get ( primitive type ) ) ; } return optional . empty ( ) ; }
public static optional < class > for name ( string name , @ nullable class loader class loader ) { try { if ( class loader == null ) { class loader = thread . current thread ( ) . get context class loader ( ) ; } if ( class loader == null ) { class loader = class loader . get system class loader ( ) ; } optional < class > common type = optional . of nullable ( common_class_map . get ( name ) ) ; if ( common type . be present ( ) ) { return common type ; } else { if ( reflection_logger . be debug enable ( ) ) { reflection_logger . debug ( `` attempt to dynamically load class { } `` , name ) ; } class < ? > type = class . for name ( name , true , class loader ) ; if ( reflection_logger . be debug enable ( ) ) { reflection_logger . debug ( `` successfully loaded class { } `` , name ) ; } return optional . of ( type ) ; } } catch ( class not find exception | no class def find error e ) { if ( reflection_logger . be debug enable ( ) ) { reflection_logger . debug ( `` class { } be not present `` , name ) ; } return optional . empty ( ) ; } }
public static optional < class > resolve interface type argument ( class type , class interface type ) { type [ ] generic interface = type . get generic interface ( ) ; for ( type generic interface : generic interface ) { if ( generic interface instanceof parameterized type ) { parameterized type pt = ( parameterized type ) generic interface ; if ( pt . get raw type ( ) == interface type ) { return resolve single type argument ( generic interface ) ; } } } class super class = type . get superclass ( ) ; if ( super class ! = null & & super class ! = object . class ) { return resolve interface type argument ( super class , interface type ) ; } return optional . empty ( ) ; }
public static class get wrapper type ( class primitive type ) { if ( primitive type . be primitive ( ) ) { return primitives_to_wrappers . get ( primitive type ) ; } return primitive type ; }
public static optional < field > find field ( class type , string name ) { optional < field > declare field = find declare field ( type , name ) ; if ( ! declare field . be present ( ) ) { while ( ( type = type . get superclass ( ) ) ! = null ) { declared field = find field ( type , name ) ; if ( declared field . be present ( ) ) { break ; } } } return declared field ; }
public static < t > iterator < t > iterator ( t . . . array ) { if ( be not empty ( array ) ) { return new array iterator < > ( array ) ; } else { return collection . empty iterator ( ) ; } }
public static boolean be not empty ( @ nullable map map ) { return map ! = null & & ! map . be empty ( ) ; }
public static string to string ( iterable < ? > iterable ) { return to string ( `` , `` , iterable ) ; }
public static boolean be convertible to publisher ( class < ? > type ) { if ( publisher . class . be assignable from ( type ) ) { return true ; } else { for ( class < ? > reactive type : reactive_types ) { if ( reactive type . be assignable from ( type ) ) { return true ; } } return false ; } }
public impl embed ( char sequence ref , resource resource ) { if ( string utils . be not empty ( ref ) & & resource ! = null ) { list < resource > resource = this . embed map . compute if absent ( ref , char sequence - > new array list < > ( ) ) ; resource . add ( resource ) ; } return ( impl ) this ; }
public void set key store ( key store configuration key store ) { if ( key store ! = null ) { this . key store = key store ; } }
public void handler remove ( channel handler context ctx ) { channel killer . cancel ( false ) ; }
public optional < duration > get shutdown timeout ( ) { return optional . of nullable ( shutdown timeout ) ; }
public proxy . type get proxy type ( ) { return proxy type ; }
public void set proxy selector ( proxy selector proxy selector ) { this . proxy selector = proxy selector ; }
public optional < string > get path ( ) { return optional . of nullable ( path ) ; }
public boolean match ( condition context context ) { return epoll . be available ( ) ; }
public void set server header ( string server header ) { this . server header = server header ; }
protect @ non null string validate host ( @ non null string host ) { if ( ! host . equal ( default_host ) ) { host resolution configuration configuration = server configuration . get host resolution ( ) ; if ( configuration ! = null ) { list < pattern > allow host = configuration . get allow host ( ) ; if ( ! allow host . be empty ( ) & & allow host . stream ( ) . map ( pattern - > pattern . matcher ( host ) ) . none match ( matcher : : match ) ) { return default_host ; } } } return host ; }
public access logger get access logger ( ) { return access logger ; }
public int get max header size ( ) { return max header size ; }
public boolean be chunk supported ( ) { return chunk support ; }
public int get compression threshold ( ) { return compression threshold ; }
public void set worker ( worker worker ) { this . worker = worker ; }
public static header element for request ( ) { return request_headers_element ; }
public byte buffer get byte buffer ( ) throw i o exception { byte buf byte buf = file upload . get byte buf ( ) ; if ( byte buf == null ) { throw new i o exception ( `` the byte buffer have already be release `` ) ; } try { return byte buf . nio buffer ( ) ; } finally { if ( control release ) { byte buf . release ( ) ; } } }
protect object pre destroy ( bean resolution context resolution context , bean context context , object bean ) { default bean context default context = ( default bean context ) context ; for ( int i = 0 ; i < method injection point . size ( ) ; i++ ) { method injection point method injection point = method injection point . get ( i ) ; if ( method injection point . be pre destroy method ( ) & & method injection point . require reflection ( ) ) { inject bean method ( resolution context , default context , i , bean ) ; } } if ( bean instanceof life cycle ) { bean = ( ( life cycle ) bean ) . stop ( ) ; } return bean ; }
public < t > t get bean ( @ non null bean definition < t > definition ) { argument utils . require non null ( `` definition `` , definition ) ; qualifier < t > declare qualifier = definition . get declare qualifier ( ) ; if ( definition . be singleton ( ) ) { bean key < t > key = new bean key < > ( definition , declare qualifier ) ; bean registration bean registration = singleton object . get ( key ) ; if ( bean registration ! = null ) { return ( t ) bean registration . bean ; } } class < t > bean type = definition . get bean type ( ) ; try ( bean resolution context context = new resolution context ( definition , null ) ) { return get bean for definition ( context , bean type , declare qualifier , true , definition ) ; } }
protect void reset cache ( ) { contain cache . clear ( ) ; resolve value cache . clear ( ) ; }
public static void clear mutate ( ) { mutated_annotation_metadata . clear ( ) ; }
protect void add annotation ( string annotation , map < char sequence , object > value ) { add annotation ( annotation , value , retention policy . runtime ) ; }
public static < t > qualifier < t > by name ( string name ) { return new name qualifier < > ( name ) ; }
public static unsatisfied route exception create ( argument < ? > argument ) { optional < class < ? extend annotation > > class optional = argument . get annotation metadata ( ) . get annotation type by stereotype ( bindable . class ) ; if ( class optional . be present ( ) ) { class < ? extend annotation > clazz = class optional . get ( ) ; string name = argument . get annotation metadata ( ) . string value ( clazz ) . or else ( argument . get name ( ) ) ; if ( clazz == body . class ) { throw new unsatisfied body route exception ( name , argument ) ; } else if ( clazz == query value . class ) { throw new unsatisfied query value route exception ( name , argument ) ; } else if ( clazz == path variable . class ) { throw new unsatisfied path variable route exception ( name , argument ) ; } else if ( clazz == header . class ) { throw new unsatisfied header route exception ( name , argument ) ; } else if ( clazz == part . class ) { throw new unsatisfied part route exception ( name , argument ) ; } else if ( clazz == request attribute . class ) { throw new unsatisfied request attribute route exception ( name , argument ) ; } else if ( clazz == cookie value . class ) { throw new unsatisfied cookie value route exception ( name , argument ) ; } else { throw new unsatisfied route exception ( `` require `` + clazz . get simple name ( ) + `` [ `` + name + `` ] not specify `` , argument ) ; } } throw new unsatisfied route exception ( `` require argument [ `` + argument + `` ] not specify `` , argument ) ; }
public void set locale ( locale locale ) { this . locale = locale ; }
public boolean have instrumenters ( ) { return ! reactive invocation instrumenter factory . be empty ( ) ; }
public boolean rebuild context ( ) { return rebuild context ; }
public class < ? extend application context builder > [ ] context builder ( ) { return context builder ; }
protect void post process builder ( application context builder builder ) { }
protect void start application context ( ) { application context . start ( ) ; listener = new array list < > ( application context . get bean of type ( test execution listener . class ) ) ; }
protect internal uri template . uri template parser create parser ( string template string , object . . . parser argument ) { return new internal uri template . uri template parser ( template string ) ; }
public value extractor < iterable > get iterable value extractor ( ) { return iterable value extractor ; }
public int size ( ) { return name . size ( ) ; }
public int get line ( ) { return line ; }
public boolean be ( string property , object value ) { throw new unsupported operation exception ( ) ; }
public static instance field all declare field of ( object instance ) { list < instance field > instance field = new array list < instance field > ( ) ; for ( class < ? > clazz = instance . get class ( ) ; clazz ! = object . class ; clazz = clazz . get superclass ( ) ) { instance field . add all ( instance field in ( instance , clazz . get declared field ( ) ) ) ; } return new instance field ( instance , instance field ) ; }
public boolean be valid ( ) { return valid & & real connection ! = null & & data source . ping connection ( this ) ; }
public void set create timestamp ( long create timestamp ) { this . create timestamp = create timestamp ; }
public void set last used timestamp ( long last used timestamp ) { this . last used timestamp = last use timestamp ; }
public long get checkout timestamp ( ) { return checkout timestamp ; }
protect void apply transaction timeout ( statement statement ) throw s q l exception { statement util . apply transaction timeout ( statement , statement . get query timeout ( ) , transaction . get timeout ( ) ) ; }
public url get resource a u r l ( string resource , class loader class loader ) { return get resource a u r l ( resource , get class loader ( class loader ) ) ; }
public static void set default class loader ( class loader default class loader ) { class loader wrapper . default class loader = default class loader ; }
public t offset ( long value ) { return offset ( string . value of ( value ) ) ; }
public string [ ] get resul set ( ) { return result set ; }
public parameter mode get mode ( ) { return mode ; }
public auto map unknown column behavior get auto map unknown column behavior ( ) { return auto map unknown column behavior ; }
public void set auto map unknown column behavior ( auto map unknown column behavior auto map unknown column behavior ) { this . auto map unknown column behavior = auto map unknown column behavior ; }
public list < interceptor > get interceptor ( ) { return interceptor chain . get interceptor ( ) ; }
public void set add to config ( boolean add to config ) { this . add to config = add to config ; }
public int stream identifier ( ) { return stream identifier ; }
public static http2 frame codec builder for client ( ) { return new http2 frame codec builder ( false ) ; }
public int read ( char buffer cb ) throw i o exception { / * * * int sz = size ( ) ; if ( sz < =0 ) return -1 ; if ( sz > 0 ) cb . put ( buf , start , sz ) ; return -1 ; * * * / int sz = size ( ) ; if ( sz > 0 ) cb . put ( buf , start , sz ) ; start=end ; while ( true ) { fill ( ) ; int s = size ( ) ; if ( s==0 ) return sz==0 ? -1 : sz ; sz += s ; cb . put ( buf , start , s ) ; } }
public void set node ( simple node value ) { node = value ; }
public object get result ( ) { return result ; }
public int get size ( ) { return 0 ; }
public static string get pointer string ( object o ) { return get pointer string ( ( o == null ) ? 0 : system . identity hash code ( o ) ) ; }
public static final boolean be type compatible ( object object , class c ) { boolean result = true ; if ( object ! = null ) { if ( c . be primitive ( ) ) { if ( get arg class ( object ) ! = c ) { result = false ; } } else if ( ! c . be instance ( object ) ) { result = false ; } } return result ; }
protect void flatten tree ( ) { boolean should flatten = false ; int new size = 0 ; for ( int i = 0 ; i < _children . length ; ++i ) if ( _children [ i ] . get class ( ) == get class ( ) ) { should flatten = true ; new size += _children [ i ] . jjt get num child ( ) ; } else ++new size ; if ( should flatten ) { node [ ] new child = new node [ new size ] ; int j = 0 ; for ( int i = 0 ; i < _children . length ; ++i ) { node c = _children [ i ] ; if ( c . get class ( ) == get class ( ) ) { for ( int k = 0 ; k < c . jjt get num child ( ) ; ++k ) new child [ j++ ] = c . jjt get child ( k ) ; } else new child [ j++ ] = c ; } if ( j ! = new size ) throw new error ( `` assertion error : `` + j + `` ! = `` + new size ) ; _children = new child ; } }
public static boolean contains null ( @ non null iterable < ? > value ) { for ( object value : value ) { if ( value == null ) return true ; } return false ; }
public cherry pick command set progress monitor ( progress monitor monitor ) { if ( monitor == null ) { monitor = null progress monitor . instance ; } this . monitor = monitor ; return this ; }
public rev commit get new head ( ) { return new head ; }
public clone command set u r i ( string uri ) { this . uri = uri ; return this ; }
public diff command set new tree ( abstract tree iterator new tree ) { this . new tree = new tree ; return this ; }
public string get hook name ( ) { return hook name ; }
public fetch command set dry run ( boolean dry run ) { check callable ( ) ; this . dry run = dry run ; return this ; }
public delete branch command branch delete ( ) { return new delete branch command ( repo ) ; }
public archive command archive ( ) { return new archive command ( repo ) ; }
public stash create command stash create ( ) { return new stash create command ( repo ) ; }
public log command set max count ( int max count ) { check callable ( ) ; this . max count = max count ; return this ; }
public merge command set squash ( boolean squash ) { check callable ( ) ; this . squash = boolean . value of ( squash ) ; return this ; }
public list < string > get checkout conflict ( ) { return checkout conflict ; }
public fetch result get fetch result ( ) { return this . fetch result ; }
public string get fetch from ( ) { return this . fetch from ; }
public int get timeout ( ) { return timeout ; }
public set < string > get add ( ) { return collection . unmodifiable set ( diff . get added ( ) ) ; }
public set < string > get change ( ) { return collection . unmodifiable set ( diff . get change ( ) ) ; }
public set < string > get untracked ( ) { return collection . unmodifiable set ( diff . get untracked ( ) ) ; }
public set < string > get untracked folder ( ) { return collection . unmodifiable set ( diff . get untracked folder ( ) ) ; }
public submodule add command set u r i ( string uri ) { this . uri = uri ; return this ; }
public submodule deinit command . submodule deinit status get status ( ) { return status ; }
public submodule sync command add path ( string path ) { path . add ( path ) ; return this ; }
public tag command set annotate ( boolean annotate ) { this . annotate = annotate ; return this ; }
public boolean be empty ( ) { return map . be empty ( ) ; }
public void put ( attribute a ) { map . put ( a . get key ( ) , a ) ; }
public boolean be unspecified ( string key ) { return ( get state ( key ) == state . unspecified ) ; }
public boolean be custom ( string key ) { return ( get state ( key ) == state . custom ) ; }
public boolean be dir only ( ) { return dir only ; }
public boolean be match ( string relative target , boolean be directory ) { if ( relative target == null ) return false ; if ( relative target . length ( ) == 0 ) return false ; boolean match = matcher . match ( relative target , be directory , true ) ; return match ; }
public person ident get source author ( ) { return out candidate . get author ( ) ; }
public int get source line ( int idx ) { return source line [ idx ] - 1 ; }
public boolean be no prefix ( ) { return no prefix ; }
public string get old prefix ( ) { return this . old prefix ; }
public string get new prefix ( ) { return this . new prefix ; }
public void set detect renames ( boolean on ) { if ( on & & rename detector == null ) { assert have reader ( ) ; rename detector = new rename detector ( reader , diff cfg ) ; } else if ( ! on ) rename detector = null ; }
public void set path filter ( tree filter filter ) { path filter = filter ! = null ? filter : tree filter . all ; }
protect void write context line ( raw text text , int line ) throw i o exception { write line ( ' ' , text , line ) ; }
public final int get end a ( ) { return end a ; }
public dir cache editor editor ( ) { return new dir cache editor ( this , entry cnt + 16 ) ; }
public boolean commit ( ) { final lock file tmp = my lock ; require lock ( tmp ) ; my lock = null ; if ( ! tmp . commit ( ) ) { return false ; } snapshot = tmp . get commit snapshot ( ) ; if ( index change listener ! = null & & ! array . equal ( read index checksum , write index checksum ) ) { index change listener . on index change ( new index change event ( true ) ) ; } return true ; }
public dir cache tree get cache tree ( boolean build ) { if ( build ) { if ( tree == null ) tree = new dir cache tree ( ) ; tree . validate ( sorted entry , entry cnt , 0 , 0 ) ; } return tree ; }
public boolean have unmerged path ( ) { for ( int i = 0 ; i < entry cnt ; i++ ) { if ( sorted entry [ i ] . get stage ( ) > 0 ) { return true ; } } return false ; }
public list < repo project > get project ( ) { return project ; }
public string get path ( ) { return path ; }
public static pre push hook pre push ( repository repo , print stream output stream ) { if ( lfs factory . get instance ( ) . be available ( ) ) { pre push hook hook = lf factory . get instance ( ) . get pre push hook ( repo , output stream ) ; if ( hook ! = null ) { if ( hook . be native hook present ( ) ) { print stream p = output stream ; if ( ps == null ) { ps = system . out ; } p . println ( message format . format ( j git text . get ( ) . lfs hook conflict , repo ) ) ; } return hook ; } } return new pre push hook ( repo , output stream ) ; }
public set < object id > get missing object ( ) { return miss object ; }
public void verify index ( pack index idx ) throw corrupt pack index exception { object id owner map < obj from pack > in pack = new object id owner map < > ( ) ; for ( int i = 0 ; i < get object count ( ) ; i++ ) { packed object info entry = get object ( i ) ; in pack . add ( new obj from pack ( entry ) ) ; long offs = idx . find offset ( entry ) ; if ( offs == -1 ) { throw new corrupt pack index exception ( message format . format ( j git text . get ( ) . miss object , integer . value of ( entry . get type ( ) ) , entry . get name ( ) ) , error type . missing_obj ) ; } else if ( offs ! = entry . get offset ( ) ) { throw new corrupt pack index exception ( message format . format ( j git text . get ( ) . mismatch offset , entry . get name ( ) ) , error type . mismatch_offset ) ; } try { if ( idx . have c r c32 support ( ) & & ( int ) idx . find c r c32 ( entry ) ! = entry . get c r c ( ) ) { throw new corrupt pack index exception ( message format . format ( j git text . get ( ) . mismatch c r c , entry . get name ( ) ) , error type . mismatch_crc ) ; } } catch ( miss object exception e ) { throw new corrupt pack index exception ( message format . format ( j git text . get ( ) . miss c r c , entry . get name ( ) ) , error type . missing_crc ) ; } } for ( mutable entry entry : idx ) { if ( ! in pack . contains ( entry . to object id ( ) ) ) { throw new corrupt pack index exception ( message format . format ( j git text . get ( ) . unknown object in index , entry . name ( ) ) , error type . unknown_obj ) ; } } }
public ketch system get system ( ) { return get leader ( ) . get system ( ) ; }
public string get name ( ) { return replica name ; }
public static schedule executor service default executor ( ) { return default executor holder . i ; }
public string get message ( ) { return message ; }
public boolean await state change ( state not in , long wait , time unit unit ) throw interrupted exception { synchronize ( state ) { if ( state . get ( ) ! = not in ) { return true ; } state . wait ( unit . to millis ( wait ) ) ; return state . get ( ) ! = not in ; } }
public set < string > get want ref ( ) { return want ref ; }
public throwable get exception ( ) { return exception ; }
public long [ ] get total request count ( ) { atomic long [ ] hit = stat hit . get ( ) ; atomic long [ ] miss = stat miss . get ( ) ; long [ ] cnt = new long [ math . max ( hit . length , miss . length ) ] ; for ( int i = 0 ; i < hit . length ; i++ ) { cnt [ i ] += hit [ i ] . get ( ) ; } for ( int i = 0 ; i < miss . length ; i++ ) { cnt [ i ] += miss [ i ] . get ( ) ; } return cnt ; }
public dfs garbage collector set pack config ( pack config new config ) { pack config = new config ; return this ; }
public dfs garbage collector set reftable config ( reftable config cfg ) { reftable config = cfg ; return this ; }
public set < dfs pack description > get source pack ( ) { return to prune ( ) ; }
protect void commit pack ( collection < dfs pack description > desc , collection < dfs pack description > replaces ) throw i o exception { commit pack impl ( desc , replaces ) ; get repository ( ) . fire event ( new dfs pack change event ( ) ) ; }
protect void clear cache ( ) { pack list . set ( no_packs ) ; }
public long get block cache hit ( ) { return stats . block cache hit ; }
public dfs reader option get reader option ( ) { return reader option ; }
public list < reftable > reader ( ) { return collection . unmodifiable list ( table ) ; }
public void set expire age millis ( long expire age millis ) { this . expire age millis = expire age millis ; expire = null ; }
public void set expire ( date expire ) { this . expire = expire ; expire age millis = -1 ; }
public final file get pack directory ( ) { return pack directory ; }
public object id insert ( int type , long len , input stream be ) throw i o exception { return insert ( type , len , be , false ) ; }
public reflog writer log ( ref update update , string msg , boolean deref ) throw i o exception { object id old id = update . get old object id ( ) ; object id new id = update . get new object id ( ) ; ref ref = update . get ref ( ) ; person ident ident = update . get ref log ident ( ) ; if ( ident == null ) ident = new person ident ( refdb . get repository ( ) ) ; else ident = new person ident ( ident ) ; byte [ ] rec = encode ( old id , new id , ident , msg ) ; if ( deref & & ref . be symbolic ( ) ) { log ( ref . get name ( ) , rec ) ; log ( ref . get leaf ( ) . get name ( ) , rec ) ; } else log ( ref . get name ( ) , rec ) ; return this ; }
public static final byte [ ] apply ( byte [ ] base , byte [ ] delta ) { return apply ( base , delta , null ) ; }
public static pack ext [ ] value ( ) { return value ; }
public final byte [ ] get copy buffer ( ) { return copy buffer ; }
public void add object ( rev object object ) throw incorrect object type exception { if ( ! exclude ( object ) ) add object ( object , 0 ) ; }
public ref exact ref ( string ref name ) throw i o exception { try ( ref cursor rc = seek ref ( ref name ) ) { return rc . next ( ) ? rc . get ref ( ) : null ; } }
public void set max index level ( int level ) { max index level = math . max ( 0 , level ) ; }
public boolean be index object ( ) { return index object ; }
public object id write tree ( object inserter inserter ) throw i o exception { if ( pending blob ! = null ) { for ( string s : pending blob . value ( ) ) { inserter . insert ( obj_blob , encode ( s ) ) ; } pending blobs = null ; } return content . write tree ( inserter ) ; }
public static final abbreviate object id from object id ( any object id id ) { return new abbreviate object id ( constant . object_id_string_length , id . w1 , id . w2 , id . w3 , id . w4 , id . w5 ) ; }
public b add alternate object directory ( file other ) { if ( other ! = null ) { if ( alternate object directory == null ) alternate object directory = new link list < > ( ) ; alternate object directory . add ( other ) ; } return self ( ) ; }
public boolean be rebase ( ) { return get rebase mode ( ) ! = branch rebase mode . none ; }
public person ident get author ( ) { return author ; }
public void set filter ( tree filter filter ) { this . filter = filter ; }
public set < string > get change ( ) { return change ; }
public set < string > get remove ( ) { return remove ; }
public set < string > get untracked folder ( ) { return ( ( index diff filter == null ) ? collection . < string > empty set ( ) : new hash set < > ( index diff filter . get untracked folder ( ) ) ) ; }
public static final object id zero id ( ) { return zeroid ; }
public static boolean equal ( final byte [ ] first buffer , final int fi , final byte [ ] second buffer , final int si ) { return first buffer [ fi ] == second buffer [ si ] & & first buffer [ fi + 1 ] == second buffer [ si + 1 ] & & first buffer [ fi + 2 ] == second buffer [ si + 2 ] & & first buffer [ fi + 3 ] == second buffer [ si + 3 ] & & first buffer [ fi + 4 ] == second buffer [ si + 4 ] & & first buffer [ fi + 5 ] == second buffer [ si + 5 ] & & first buffer [ fi + 6 ] == second buffer [ si + 6 ] & & first buffer [ fi + 7 ] == second buffer [ si + 7 ] & & first buffer [ fi + 8 ] == second buffer [ si + 8 ] & & first buffer [ fi + 9 ] == second buffer [ si + 9 ] & & first buffer [ fi + 10 ] == second buffer [ si + 10 ] & & first buffer [ fi + 11 ] == second buffer [ si + 11 ] & & first buffer [ fi + 12 ] == second buffer [ si + 12 ] & & first buffer [ fi + 13 ] == second buffer [ si + 13 ] & & first buffer [ fi + 14 ] == second buffer [ si + 14 ] & & first buffer [ fi + 15 ] == second buffer [ si + 15 ] & & first buffer [ fi + 16 ] == second buffer [ si + 16 ] & & first buffer [ fi + 17 ] == second buffer [ si + 17 ] & & first buffer [ fi + 18 ] == second buffer [ si + 18 ] & & first buffer [ fi + 19 ] == second buffer [ si + 19 ] ; }
public int size ( ) { return size ; }
public final object id insert ( commit builder builder ) throw i o exception { return insert ( constant . obj_commit , builder . build ( ) ) ; }
public object id insert ( int type , byte [ ] data ) throw i o exception { return insert ( type , data , 0 , data . length ) ; }
public boolean performs atomic transaction ( ) { return false ; }
public ref first exact ref ( string . . . ref ) throw i o exception { for ( string name : ref ) { ref ref = exact ref ( name ) ; if ( ref ! = null ) { return ref ; } } return null ; }
public string get ref log message ( ) { return destination . get ref log message ( ) ; }
protect push certificate get push certificate ( ) { return push cert ; }
public void start worker ( int count ) { worker . add and get ( count ) ; }
public boolean be squash ( ) { return squash ; }
public void set commit name ( string [ ] commit name ) { this . commit name = commit name ; }
public list < string > get modify file ( ) { return modify file ; }
public object id get data ( ) { return data ; }
public boolean contains ( any object id id ) throw i o exception { return get ( id ) ! = null ; }
public int get size ( ) { return length ; }
public patch type get patch type ( ) { return patch type ; }
public list < format error > get error ( ) { return error ; }
public void parse ( byte [ ] buf , int ptr , int end ) { while ( ptr < end ) ptr = parse file ( buf , ptr , end ) ; }
public final int get child count ( ) { return child . length ; }
public final void add parent ( rev commit c , rev flag queue control ) { final rev commit [ ] p list = c . parent ; if ( p list == null ) return ; for ( rev commit p : p list ) add ( p , queue control ) ; }
public static rev filter create ( string pattern ) { if ( pattern . length ( ) == 0 ) throw new illegal argument exception ( j git text . get ( ) . can not match on empty string ) ; if ( sub string rev filter . safe ( pattern ) ) return new sub string search ( pattern ) ; return new pattern search ( pattern ) ; }
public static final rev filter before ( date t ) { return before ( t . get time ( ) ) ; }
public static rev filter create ( int skip ) { if ( skip < 0 ) throw new illegal argument exception ( j git text . get ( ) . skip must be non negative ) ; return new skip rev filter ( skip ) ; }
public rename callback get rename callback ( ) { return rename callback ; }
public final int get parent count ( ) { return parent . length ; }
public final byte [ ] get raw gpg signature ( ) { final byte [ ] raw = buffer ; final byte [ ] header = { ' g ' , ' p ' , ' g ' , 's ' , ' i ' , ' g ' } ; final int start = raw parse utils . header start ( header , raw , 0 ) ; if ( start < 0 ) { return null ; } final int end = raw parse utils . header end ( raw , start ) ; return array . copy of range ( raw , start , end ) ; }
public final person ident get author ident ( ) { final byte [ ] raw = buffer ; final int name b = raw parse utils . author ( raw , 0 ) ; if ( name b < 0 ) return null ; return raw parse utils . parse person ident ( raw , name b ) ; }
public final boolean have ( rev flag flag ) { return ( flags & flag . mask ) ! = 0 ; }
public final string get tag name ( ) { return tag name ; }
public void set delta base cache limit ( int new limit ) { delta base cache limit = new limit ; }
public boolean be reuse delta ( ) { return reuse delta ; }
public int get bitmap distant commit span ( ) { return bitmap distant commit span ; }
public long get total delta ( ) { return statistic . total delta ; }
public long get time counting ( ) { return statistic . time counting ; }
public static void set default ( credential provider p ) { default provider = p ; }
public synchronize inet socket address get address ( ) { return my address ; }
public void set timeout ( int second ) { timeout = second ; }
public collection < net r c entry > get entry ( ) { return host . value ( ) ; }
public track ref update get track ref update ( string local name ) { return update . get ( local name ) ; }
public int get c r c ( ) { return crc ; }
public void set type ( int type ) { this . type = type ; }
public string get email address ( ) { int email begin = user id . index of ( ' < ' ) ; if ( email begin < 0 ) { return null ; } int email end = user id . index of ( ' > ' , email begin ) ; if ( email end < 0 ) { return null ; } return user id . substring ( email begin + 1 , email end ) ; }
public void update ( config rc ) { final list < string > vlst = new array list < > ( ) ; vlst . clear ( ) ; for ( u r iish u : get u r be ( ) ) vlst . add ( u . to private string ( ) ) ; rc . set string list ( section , get name ( ) , key_url , vlst ) ; vlst . clear ( ) ; for ( u r iish u : get push u r be ( ) ) vlst . add ( u . to private string ( ) ) ; rc . set string list ( section , get name ( ) , key_pushurl , vlst ) ; vlst . clear ( ) ; for ( ref spec u : get fetch ref spec ( ) ) vlst . add ( u . to string ( ) ) ; rc . set string list ( section , get name ( ) , key_fetch , vlst ) ; vlst . clear ( ) ; for ( ref spec u : get push ref spec ( ) ) vlst . add ( u . to string ( ) ) ; rc . set string list ( section , get name ( ) , key_push , vlst ) ; set ( rc , key_uploadpack , get upload pack ( ) , default_upload_pack ) ; set ( rc , key_receivepack , get receive pack ( ) , default_receive_pack ) ; set ( rc , key_tagopt , get tag opt ( ) . option ( ) , tag opt . auto_follow . option ( ) ) ; set ( rc , key_mirror , mirror , default_mirror ) ; set ( rc , key_timeout , timeout , 0 ) ; }
public boolean add u r i ( u r iish to add ) { if ( uris . contains ( to add ) ) return false ; return uris . add ( to add ) ; }
public boolean remove push u r i ( u r iish to remove ) { return push u r be . remove ( to remove ) ; }
public string get message ( ) { return message ; }
protect void update track ref ( rev walk walk ) throw i o exception { if ( be delete ( ) ) track ref update . set result ( local update . delete ( walk ) ) ; else track ref update . set result ( local update . update ( walk ) ) ; }
public string get cert nonce seed ( ) { return cert nonce seed ; }
public static void register ( transport protocol proto ) { protocol . add ( 0 , new weak reference < > ( proto ) ) ; }
public boolean be check fetched object ( ) { return get object checker ( ) ! = null ; }
public void set object checker ( object checker impl ) { object checker = impl ; }
public collection < remote ref update > find remote ref update for ( final collection < ref spec > spec ) throw i o exception { return find remote ref update for ( local , spec , collection . empty map ( ) , fetch ) ; }
public u r iish set host ( string n ) { final u r iish r = new u r iish ( this ) ; r . host = n ; return r ; }
public u r iish set raw path ( string n ) throw u r i syntax exception { final u r iish r = new u r iish ( this ) ; r . path = unescape ( n ) ; r . raw path = n ; return r ; }
public void clear ( ) { username = null ; if ( password ! = null ) { array . fill ( password , ( char ) 0 ) ; password = null ; } }
public boolean id equal ( abstract tree iterator other iterator ) { return object id . equal ( id buffer ( ) , id offset ( ) , other iterator . id buffer ( ) , other iterator . id offset ( ) ) ; }
public int get entry raw mode ( ) { return mode ; }
public int get name offset ( ) { return path offset ; }
public boolean be do ( tree walk walker ) { return path raw . length == walker . get path length ( ) ; }
public boolean be subtree ( ) { return file mode . tree . equal ( current head . mode ) ; }
public boolean be dir no git link ( ) { return dir no git link ; }
public void add all ( block list < t > src ) { if ( src . size == 0 ) return ; int src dir idx = 0 ; for ( ; src dir idx < src . tail dir idx ; src dir idx++ ) add all ( src . directory [ src dir idx ] , 0 , block_size ) ; if ( src . tail blk idx ! = 0 ) add all ( src . tail block , 0 , src . tail blk idx ) ; }
public static void mkdirs ( file d ) throw i o exception { mkdirs ( d , false ) ; }
public static boolean be stale file handle in causal chain ( throwable throwable ) { while ( throwable ! = null ) { if ( throwable instanceof i o exception & & be stale file handle ( ( i o exception ) throwable ) ) { return true ; } throwable = throwable . get cause ( ) ; } return false ; }
public static f detect ( boolean cygwin use ) { if ( factory == null ) { factory = new f . f s factory ( ) ; } return factory . detect ( cygwin use ) ; }
public file get git system config ( ) { if ( git system config == null ) { git system config = new holder < > ( discover git system config ( ) ) ; } return git system config . value ; }
public boolean exists ( file path ) { return file utils . exists ( path ) ; }
public static void encode ( string builder urlstr , string key ) { if ( key == null || key . length ( ) == 0 ) return ; try { urlstr . append ( u r l encoder . encode ( key , utf_8 . name ( ) ) ) ; } catch ( unsupported encode exception e ) { throw new runtime exception ( j git text . get ( ) . could not u r l encode to u t f8 , e ) ; } }
public static void disable ssl verify ( http connection conn ) throw i o exception { final trust manager [ ] trust all cert = new trust manager [ ] { new dummy x509 trust manager ( ) } ; try { conn . configure ( null , trust all cert , null ) ; conn . set hostname verifier ( new dummy hostname verifier ( ) ) ; } catch ( key management exception e ) { throw new i o exception ( e . get message ( ) ) ; } catch ( no such algorithm exception e ) { throw new i o exception ( e . get message ( ) ) ; } }
public int get ( int i ) { if ( count < = i ) throw new array index out of bound exception ( i ) ; return entry [ i ] ; }
public output stream get raw stream ( ) { return buf ; }
public int get timeout ( ) { return timeout ; }
public static byte buffer read whole stream ( input stream in , int size hint ) throw i o exception { byte [ ] out = new byte [ size hint ] ; int po = 0 ; while ( pos < out . length ) { int read = in . read ( out , pos , out . length - po ) ; if ( read < 0 ) return byte buffer . wrap ( out , 0 , po ) ; po += read ; } int last = in . read ( ) ; if ( last < 0 ) return byte buffer . wrap ( out , 0 , po ) ; @ suppress warning ( `` resource `` / * java 7 * / ) temporary buffer . heap tmp = new temporary buffer . heap ( integer . max_value ) ; tmp . write ( out ) ; tmp . write ( last ) ; tmp . copy ( in ) ; return byte buffer . wrap ( tmp . to byte array ( ) ) ; }
public static attribute get attribute for path ( repository db , string path , rev commit commit ) throw i o exception { if ( commit == null ) { return get attribute for path ( db , path ) ; } try ( tree walk walk = tree walk . for path ( db , path , commit . get tree ( ) ) ) { attribute attr = walk == null ? null : walk . get attribute ( ) ; if ( attr == null ) { throw new i o exception ( message format . format ( j git text . get ( ) . no path attribute find , path ) ) ; } return attr ; } }
public v put ( long key , v value ) { for ( node < v > n = table [ index ( key ) ] ; n ! = null ; n = n . next ) { if ( n . key == key ) { final v o = n . value ; n . value = value ; return o ; } } if ( ++size == grow at ) grow ( ) ; insert ( new node < > ( key , value ) ) ; return null ; }
public final boolean be empty ( ) { return cnt == 0 ; }
public byte [ ] digest ( ) throw sha1 collision exception { finish ( ) ; byte [ ] b = new byte [ 20 ] ; nb . encode int32 ( b , 0 , h . a ) ; nb . encode int32 ( b , 4 , h . b ) ; nb . encode int32 ( b , 8 , h . c ) ; nb . encode int32 ( b , 12 , h . d ) ; nb . encode int32 ( b , 16 , h . e ) ; return b ; }
public static string capitalize ( string str ) { int str len ; if ( str == null || ( str len = str . length ( ) ) == 0 ) { return str ; } return new string buffer ( str len ) . append ( character . to title case ( str . char at ( 0 ) ) ) . append ( str . substring ( 1 ) ) . to string ( ) ; }
public static int compare with case ( string a , string b ) { for ( int i = 0 ; i < a . length ( ) & & i < b . length ( ) ; i++ ) { int d = a . char at ( i ) - b . char at ( i ) ; if ( d ! = 0 ) return d ; } return a . length ( ) - b . length ( ) ; }
public static string join ( collection < string > part , string separator , string last separator ) { string builder sb = new string builder ( ) ; int i = 0 ; int last index = part . size ( ) - 1 ; for ( string part : part ) { sb . append ( part ) ; if ( i == last index - 1 ) { sb . append ( last separator ) ; } else if ( i ! = last index ) { sb . append ( separator ) ; } i++ ; } return sb . to string ( ) ; }
public void write to ( output stream o , progress monitor pm ) throw i o exception { if ( pm == null ) pm = null progress monitor . instance ; for ( block b : block ) { o . write ( b . buffer , 0 , b . count ) ; pm . update ( b . count / 1024 ) ; } }
public input stream open input stream ( ) throw i o exception { return new block input stream ( ) ; }
public string type ( ) { return parent type ; }
public int get number of characteristic ( ) { return num characteristic ; }
public int get number of character ( ) { return num character ; }
public random access file get file ( ) { return file ; }
public ternary node get eqkid ( ) { return eqkid ; }
public void print ( final writer out , final boolean full path ) throw i o exception { final string builder buffer = new string builder ( ) ; print node ( root , `` `` , 0 , full path , buffer ) ; out . write ( buffer . to string ( ) ) ; out . flush ( ) ; }
public word list get word list ( ) { return word list ; }
public static void read word ( final input stream in , final string charset , final list < string > word ) throw i o exception { read word ( new input stream reader ( in , charset ) , word ) ; }
public void set report rule failure ( final boolean b ) { report rule failure = b ; }
public void set maximum length ( final int max length ) { maximum length = max length ; }
public static string get matching character ( final string character , final string input , final int maximum length ) { final string builder sb = new string builder ( input . length ( ) ) ; for ( int i = 0 ; i < input . length ( ) ; i++ ) { final char c = input . char at ( i ) ; if ( character . index of ( c ) ! = -1 ) { if ( sb . length ( ) < maximum length ) { sb . append ( c ) ; } else { break ; } } } return sb . to string ( ) ; }
public message resolver get message resolver ( ) { return message resolver ; }
public int get count ( final count category category ) { return count . get ( category ) ; }
public void set ignore case ( final boolean b ) { ignore case = b ; }
public list < float > to c o s number float list ( ) { list < float > number = new array list < > ( size ( ) ) ; for ( int i = 0 ; i < size ( ) ; i++ ) { c o s base num = get object ( i ) ; if ( num instanceof c o s number ) { number . add ( ( ( c o s number ) num ) . float value ( ) ) ; } else { number . add ( null ) ; } } return number ; }
public void set input p d f ( p d document input p d f ) { input p d f document = input p d f ; }
public document merge mode get document merge mode ( ) { return document merge mode ; }
public void set acro form merge mode ( document merge mode the document merge mode ) { this . document merge mode = the document merge mode ; }
public int get numeric value ( ) { return numeric value ; }
public list < traverse c o s element > get traverse child ( ) { return traverse child ; }
public void set vertex ( float [ ] vertex ) { c o s array new vertex = new c o s array ( ) ; new vertex . set float array ( vertex ) ; annot . set item ( c o s name . vertex , new vertex ) ; }
public static font metric get a f m ( string font name ) { string base name = aliases . get ( font name ) ; if ( base name == null ) { return null ; } if ( font . get ( base name ) == null ) { synchronize ( font ) { if ( font . get ( base name ) == null ) { try { load metric ( base name ) ; } catch ( i o exception e ) { throw new illegal argument exception ( e ) ; } } } } return font . get ( base name ) ; }
public list < string > get filter ( ) { c o s base filter = parameter . get dictionary object ( c o s name . f , c o s name . filter ) ; if ( filter instanceof c o s name ) { c o s name name = ( c o s name ) filter ; return collection . singleton list ( name . get name ( ) ) ; } else if ( filter instanceof c o s array ) { return ( ( c o s array ) filter ) . to c o s name string list ( ) ; } return collection . empty list ( ) ; }
public void set rect difference ( float difference ) { set rect difference ( difference , difference , difference , difference ) ; }
public void set q ( int q ) { get c o s object ( ) . set int ( c o s name . q , q ) ; }
public void set image downscaling optimization threshold ( float image downscaling optimization threshold ) { this . image downscaling optimization threshold = image downscaling optimization threshold ; }
public static byte [ ] decode base64 ( string base64 value ) { return base64 . get decoder ( ) . decode ( base64 value . replace all ( `` \\s `` , `` `` ) ) ; }
public void set include ( string [ ] include ) { if ( include == null ) { this . include = null ; } else { this . include = new string [ include . length ] ; for ( int i = 0 ; i < include . length ; i++ ) { string pattern ; pattern = include [ i ] . trim ( ) . replace ( '/ ' , file . separator char ) . replace ( '\\ ' , file . separator char ) ; if ( pattern . end with ( file . separator ) ) { pattern += `` * * `` ; } this . include [ i ] = pattern ; } } }
public static throwable get cause ( throwable throwable ) { return get cause ( throwable , cause_method_names ) ; }
public static string remove path ( final string filepath ) { return remove path ( filepath , file . separator char ) ; }
public static string remove path ( final string filepath , final char file separator char ) { final int index = filepath . last index of ( file separator char ) ; if ( -1 == index ) { return filepath ; } return filepath . substring ( index + 1 ) ; }
public static reader new platform reader ( input stream in ) { return new input stream reader ( in ) ; }
public boolean be debug ( ) { return debug ; }
public static pmd parameter parse result extract parameter ( string . . . args ) { object . require non null ( args , `` null parameter array `` ) ; p m d parameter result = new p m d parameter ( ) ; j commander jcommander = new j commander ( result ) ; jcommander . set program name ( `` pmd `` ) ; try { jcommander . parse ( args ) ; return new pmd parameter parse result ( result , filter deprecate option ( args ) ) ; } catch ( parameter exception e ) { return new pmd parameter parse result ( e , filter deprecate option ( args ) ) ; } }
public static string parse text node ( node node ) { final int node count = node . get child node ( ) . get length ( ) ; if ( node count == 0 ) { return `` `` ; } string builder buffer = new string builder ( ) ; for ( int i = 0 ; i < node count ; i++ ) { node child node = node . get child node ( ) . item ( i ) ; if ( child node . get node type ( ) == node . cdata_section_node || child node . get node type ( ) == node . text_node ) { buffer . append ( child node . get node value ( ) ) ; } } return buffer . to string ( ) ; }
public final boolean have decendant of any type ( final class < ? > . . . type ) { return have descendant of any type ( type ) ; }
public data flow node create new node ( node node ) { return data flow handler . create data flow node ( data flow , node ) ; }
private string get display name ( path file ) { return get display name ( file , relativize root ) ; }
public void filter language ( set < language > languages ) { for ( iterator < text file > iterator = all file to process . iterator ( ) ; iterator . have next ( ) ; ) { text file file = iterator . next ( ) ; language lang = file . get language version ( ) . get language ( ) ; if ( ! language . contains ( lang ) ) { reporter . trace ( `` filter out { 0 } , no rule for language { 1 } `` , file . get path id ( ) , lang ) ; iterator . remove ( ) ; } } }
public int compare to version ( string version string ) { language version other version = language . get version ( version string ) ; if ( other version == null ) { throw new illegal argument exception ( `` no such version ' `` + version string + `` ' for language `` + language . get name ( ) ) ; } return this . compare to ( other version ) ; }
public void reset ( ) { class . clear ( ) ; operation . clear ( ) ; }
public static metric option of option ( metric option option , metric option . . . option ) { metric option builder builder = new metric option builder ( ) ; builder . add ( option ) ; for ( metric option opt : option ) { builder . add ( opt ) ; } return builder . build ( ) ; }
protect void clear ( ) { for ( list < node > l : node name to node . value ( ) ) { l . clear ( ) ; } }
public string get xml name ( ) { return version ; }
public x path version get version ( ) { return x path version . of id ( get property ( version_descriptor ) ) ; }
public string get x path expression ( ) { return get property ( xpath_descriptor ) ; }
public void evaluate ( final node node , final rule context data ) { if ( x path rule query need initialization ( ) ) { init x path rule query ( ) ; } list < node > node with violation = xpath rule query . evaluate ( node , data ) ; for ( node node with violation : node with violation ) { add violation ( data , node with violation , node with violation . get image ( ) ) ; } }
public void add rule set ( rule set rule set ) { this . rule set . add ( object . require non null ( rule set ) ) ; }
public class loader get class loader ( ) { return class loader ; }
public renderer create renderer ( ) { return create renderer ( false ) ; }
public void set report property ( property report property ) { this . report property = report property ; }
public static boolean be unknown ( ) { return unknown_version . equal ( version ) ; }
protect string value error for ( v value ) { return value ! = null || default have null value ( ) ? null : `` miss value `` ; }
public b require ( property constraint < ? super t > constraint ) { validators . add ( constraint ) ; return ( b ) this ; }
public static generic property builder < double > double property ( string name ) { return new generic property builder < > ( name , value parser constant . double_parser , double . class ) ; }
public boolean be property numeric ( ) { return factory instanceof property descriptor builder conversion wrapper . single value . numeric || factory instanceof property descriptor builder conversion wrapper . multi value . numeric ; }
public static regex p builder name ( string name ) { return new regex p builder ( name ) ; }
public report union ( report other ) { report copy = new report ( ) ; copy . start = math . min ( other . start , this . start ) ; copy . end = math . max ( other . end , this . end ) ; for ( rule violation violation : violation ) { copy . add rule violation ( violation ) ; } for ( rule violation violation : other . violation ) { copy . add rule violation ( violation ) ; } copy . line to suppress . put all ( line to suppress ) ; copy . line to suppress . put all ( other . line to suppress ) ; copy . suppress rule violation . add all ( suppress rule violation ) ; copy . suppress rule violation . add all ( other . suppress rule violation ) ; copy . metric . add all ( metric ) ; copy . metric . add all ( other . metric ) ; copy . error . add all ( error ) ; copy . error . add all ( other . error ) ; copy . config error . add all ( config error ) ; copy . config error . add all ( other . config error ) ; return copy ; }
public object get attribute ( string name ) { return this . attribute . get ( name ) ; }
public boolean use d f a ( language language ) { for ( rule r : rule ) { if ( r . get language ( ) . equal ( language ) & & r . be dfa ( ) ) { return true ; } } return false ; }
public rule set loader enable compatibility ( boolean enable ) { this . enable compatibility = enable ; return this ; }
public rule set loader include deprecate rule reference ( boolean enable ) { this . include deprecated rule reference = enable ; return this ; }
public boolean use d f a ( language language ) { for ( rule set rule set : rule set ) { if ( rule set . us d f a ( language ) ) { return true ; } } return false ; }
public int rule count ( ) { int count = 0 ; for ( rule set r : rule set ) { count += r . get rule ( ) . size ( ) ; } return count ; }
public static < t > list < t > to list ( iterator < t > it ) { list < t > list = new array list < > ( ) ; while ( it . have next ( ) ) { list . add ( it . next ( ) ) ; } return list ; }
public input stream get input stream ( ) throw i o exception { return new reader input stream ( reader ) ; }
public static i o exception close all ( collection < ? extend auto closeable > closeables ) { i o exception compose = null ; for ( auto closeable it : closeables ) { try { it . close ( ) ; } catch ( exception e ) { if ( composed == null ) { compose = new i o exception ( `` can not close resource `` + it , e ) ; } else { compose . add suppressed ( e ) ; } } } return compose ; }
public void add ( class < ? > . . . type ) { for ( class < ? > element : type ) { add ( element ) ; } }
public int size ( ) { return this . get num child ( ) ; }
public boolean have detail message ( ) { return get num child ( ) == 2 ; }
public boolean be ternary ( ) { return true ; }
public int get arity ( ) { return get formal parameter ( ) . size ( ) ; }
public a s t statement get body ( ) { return ( a s t statement ) get child ( 0 ) ; }
public a s t block get body ( ) { return ( a s t block ) get child ( 0 ) ; }
public string get import simple name ( ) { if ( be import on demand ) { return null ; } string import name = get import name ( ) ; return import name . substring ( import name . last index of ( ' . ' ) + 1 ) ; }
public string get operator ( ) { return get image ( ) ; }
public void decorate with ( java parser visitor decorator decorator ) { decorator . set base ( visitor ) ; visitor = decorator ; }
public static java operation signature build for ( a s t method or constructor declaration node ) { int code = code ( visibility . get ( node ) , role . get ( node ) , node . be abstract ( ) ) ; if ( ! pool . contains key ( code ) ) { pool . put ( code , new java operation signature ( visibility . get ( node ) , role . get ( node ) , node . be abstract ( ) ) ) ; } return pool . get ( code ) ; }
public void initialize with ( class loader class loader , a s t compilation unit root node ) { this . class loader = p m d a s m class loader . get instance ( class loader ) ; root node . jjt accept ( this , null ) ; }
protect final boolean be field ( string var name , a s t any type declaration type declaration ) { final list < a s t field declaration > fds = type declaration . find descendant of type ( a s t field declaration . class ) ; if ( fds ! = null ) { for ( a s t field declaration fd : fds ) { final a s t variable declarator id vid = fd . get first descendant of type ( a s t variable declarator id . class ) ; if ( vid ! = null & & vid . have image equal to ( var name ) ) { return true ; } } } return false ; }
protect integer count node child ( node node , object data ) { integer node count = null ; int line count = 0 ; for ( int i = 0 ; i < node . get num child ( ) ; i++ ) { node count = ( integer ) ( ( java node ) node . get child ( i ) ) . jjt accept ( this , data ) ; line count += node count . int value ( ) ; } return ++line count ; }
protected list < integer > tag index in ( string comment ) { map < string , integer > tag = comment util . javadoc tag in ( comment ) ; return new array list < > ( tag . value ( ) ) ; }
public object visit ( a s t allocation expression node , object data ) { if ( not inside loop ( node ) ) { return data ; } if ( fourth parent not throw ( node ) & & fourth parent not return ( node ) & & not array assignment ( node ) & & not collection access ( node ) & & not break follow ( node ) ) { add violation ( data , node ) ; } return data ; }
public int get execute count ( ) { return execute count ; }
public int get index ( ) { return index ; }
public int scan c string length ( ) throw i o exception { int po = index ; while ( true ) { while ( pos < end index ) { if ( buffer [ pos++ ] == '\0 ' ) { return po - index ; } } if ( ! read more ( string_scan_span ) ) { throw new e o f exception ( ) ; } pos = index ; } }
public static s q l feature not support exception not implement ( class < ? > call class , string function name ) { return new s q l feature not support exception ( gt . tr ( `` method { 0 } be not yet implement . `` , call class . get name ( ) + `` . `` + function name ) , p s q l state . not_implemented . get state ( ) ) ; }
public void set value ( string value ) throw s q l exception { p gtokenizer t = new p gtokenizer ( value , ' , ' ) ; if ( t . get size ( ) ! = 2 ) { throw new p s q l exception ( gt . tr ( `` conversion to type { 0 } fail : { 1 } . `` , type , value ) , p s q l state . data_type_mismatch ) ; } point [ 0 ] = new p gpoint ( t . get token ( 0 ) ) ; point [ 1 ] = new p gpoint ( t . get token ( 1 ) ) ; }
public void set location ( point p ) { set location ( p . x , p . y ) ; }
public static void report host status ( host spec host spec , host status host status ) { long now = current time millis ( ) ; synchronize ( host status map ) { host spec status host spec status = host status map . get ( host spec ) ; if ( host spec status == null ) { host spec status = new host spec status ( host spec ) ; host status map . put ( host spec , host spec status ) ; } host spec status . status = host status ; host spec status . last updated = now ; } }
public synchronize void truncate ( long len ) throw s q l exception { check freed ( ) ; if ( ! conn . have minimum server version ( server version . v8_3 ) ) { throw new p s q l exception ( gt . tr ( `` truncation of large object be only implement in 8 . 3 and late server . `` ) , p s q l state . not_implemented ) ; } if ( len < 0 ) { throw new p s q l exception ( gt . tr ( `` can not truncate lob to a negative length . `` ) , p s q l state . invalid_parameter_value ) ; } if ( len > integer . max_value ) { if ( support64bit ) { get lo ( true ) . truncate64 ( len ) ; } else { throw new p s q l exception ( gt . tr ( `` postgre s q l l o b can only index to : { 0 } `` , integer . max_value ) , p s q l state . invalid_parameter_value ) ; } } else { get lo ( true ) . truncate ( ( int ) len ) ; } }
public synchronize long position ( blob pattern , long start ) throw s q l exception { return position ( pattern . get byte ( 1 , ( int ) pattern . length ( ) ) , start ) ; }
protect void check freed ( ) throw s q l exception { if ( sub l o == null ) { throw new p s q l exception ( gt . tr ( `` free ( ) be call on this lob previously `` ) , p s q l state . object_not_in_state ) ; } }
public static string sqlpower ( list < ? > parse args ) throw s q l exception { return two argument function call ( `` pow ( `` , `` power `` , parse args ) ; }
public static void sqlchar ( string builder buf , list < ? extend char sequence > parse args ) throw s q l exception { single argument function call ( buf , `` chr ( `` , `` char `` , parse args ) ; }
public static void sqlsubstring ( string builder buf , list < ? extend char sequence > parse args ) throw s q l exception { int arg size = parse args . size ( ) ; if ( arg size ! = 2 & & arg size ! = 3 ) { throw new p s q l exception ( gt . tr ( `` { 0 } function take two or three argument . `` , `` substring `` ) , p s q l state . syntax_error ) ; } append call ( buf , `` substr ( `` , `` , `` , `` ) `` , parse args ) ; }
public boolean mark support ( ) { return true ; }
public string d make spn ( string service class , string service name , string instance name , short instance port , string referrer ) throw last error exception { int by reference spn length = new int by reference ( 2048 ) ; char [ ] spn = new char [ spn length . get value ( ) ] ; final int ret = ntdsapi . instance . d make spn w ( new w string ( service class ) , new w string ( service name ) , instance name == null ? null : new w string ( instance name ) , instance port , referrer == null ? null : new w string ( referrer ) , spn length , spn ) ; if ( ret ! = ntdsapi . error_success ) { / * should 've throw last error exception , but just in case * / throw new runtime exception ( `` ntdsapi d make spn call fail with `` + ret ) ; } return new string ( spn , 0 , spn length . get value ( ) ) ; }
public static boolean bool ( byte [ ] byte , int idx ) { return bytes [ idx ] == 1 ; }
public boolean equal ( object obj ) { if ( obj instanceof p gobject ) { final object other value = ( ( p gobject ) obj ) . get value ( ) ; if ( other value == null ) { return get value ( ) == null ; } return other value . equal ( get value ( ) ) ; } return false ; }
public void set calendar ( calendar calendar ) { this . calendar = calendar ; }
public void forget ( xid xid ) throw x a exception { throw new p g x a exception ( gt . tr ( `` heuristic commit/rollback not support . forget xid= { 0 } `` , xid ) , x a exception . xaer_nota ) ; }
public string to string ( ) { return xid to string ( this ) ; }
public static void canonicalize ( string string ) { interner . put string ( string ) ; }
public tuple read only copy ( ) { return copy ( false ) ; }
public void write to copy ( byte [ ] data , int off , int siz ) throw s q l exception { get query executor ( ) . write to copy ( this , data , off , siz ) ; }
public string get description ( ) { return description ; }
public replication type get replication type ( ) { return replication type ; }
public static synchronize < t > constructor expectation setup < t > when new ( string fully qualify name ) throw exception { final class < t > for name = ( class < t > ) class . for name ( fully qualify name ) ; return new default constructor expectation setup < t > ( for name ) ; }
public static power mockito stubber do answer ( answer < ? > answer ) { return powermockito_core . do answer ( answer ) ; }
public static < t > constructor < t > constructor ( class < t > declare class , class < ? > . . . parameter type ) { return ( constructor < t > ) whitebox impl . find unique constructor or throw exception ( declare class , ( object [ ] ) parameter type ) ; }
public static void suppress ( method method ) { suppress code . suppress method ( method ) ; }
public static method replace strategy replace ( method method ) { return new method replace strategy impl ( method ) ; }
public static void proxy ( method method , invocation handler invocation handler ) { assert invocation handler not null ( invocation handler ) ; mock repository . put method proxy ( method , invocation handler ) ; }
public static synchronize void suppress constructor ( class < ? > . . . class ) { for ( class < ? > clazz : class ) { class < ? > temp class = clazz ; while ( temp class ! = object . class ) { suppress constructor ( temp class , false ) ; temp class = temp class . get superclass ( ) ; } } }
public static synchronize void suppress method ( method . . . method ) { for ( method method : method ) { mock repository . add method to suppress ( method ) ; } }
public static synchronize void add field type to suppress ( string field type ) { suppress field type . add ( field type ) ; }
public method [ ] get logger method ( string fully qualified class name , string method name , string log framework ) { try { return whitebox . get method ( get type ( fully qualify class name , log framework ) , method name ) ; } catch ( runtime exception e ) { throw e ; } catch ( exception e ) { throw new runtime exception ( e ) ; } }
public static void set internal state ( object object , string field name , object value ) { field find field = find field in hierarchy ( object , field name ) ; set field ( object , value , find field ) ; }
public static method [ ] get all method ( class < ? > clazz ) { if ( clazz == null ) { throw new illegal argument exception ( `` you must specify a class in order to get the method . `` ) ; } set < method > method = new link hash set < method > ( ) ; class < ? > this type = clazz ; while ( this type ! = null ) { final class < ? > type = this type ; final method [ ] declare method = access controller . do privilege ( new privilege action < method [ ] > ( ) { public method [ ] run ( ) { return type . get declare method ( ) ; } } ) ; for ( method method : declare method ) { method . set accessible ( true ) ; method . add ( method ) ; } collection . add all ( method , type . get method ( ) ) ; this type = this type . get superclass ( ) ; } return method . to array ( new method [ method . size ( ) ] ) ; }
public static < t > class < ? > get unmocked type ( class < t > type ) { if ( type == null ) { throw new illegal argument exception ( `` type can not be null `` ) ; } class < ? > unmocked type = null ; if ( proxy framework ! = null & & proxy framework . be proxy ( type ) ) { unmocked type = proxy framework . get unproxied type ( type ) ; } else if ( proxy . be proxy class ( type ) ) { unmocked type = type . get interface ( ) [ 0 ] ; } else { unmocked type = type ; } return unmocked type ; }
public static boolean check if parameter type be same ( boolean be var args , class < ? > [ ] expect parameter type , class < ? > [ ] actual parameter type ) { if ( expect parameter type == null || actual parameter type == null ) { throw new illegal argument exception ( `` parameter type can not be null `` ) ; } else if ( expect parameter type . length ! = actual parameter type . length ) { return false ; } else { for ( int i = 0 ; i < expect parameter type . length ; i++ ) { final class < ? > actual parameter type = get type ( actual parameter type [ i ] ) ; if ( be var args & & i == expect parameter type . length - 1 & & actual parameter type . get component type ( ) . be assignable from ( expect parameter type [ i ] ) ) { return true ; } else if ( ! actual parameter type . be assignable from ( expect parameter type [ i ] ) ) { return false ; } } } return true ; }
public static void set internal state from context ( object object , class < ? > context , class < ? > [ ] additional context ) { set internal state from context ( object , context , field match strategy . match ) ; if ( additional context ! = null & & additional context . length > 0 ) { for ( class < ? > addition context : additional context ) { set internal state from context ( object , addition context , field match strategy . match ) ; } } }
public static void set internal state ( object object , string field name , object [ ] value ) { whitebox impl . set internal state ( object , field name , value ) ; }
public static synchronize < t > t invoke method ( object instance , string method to execute , class < ? > define in , class < ? > [ ] argument type , object . . . argument ) throw exception { return whitebox impl . < t > invoke method ( instance , method to execute , define in , argument type , argument ) ; }
public static synchronize < t > t invoke method ( class < ? > clazz , string method to execute , object . . . argument ) throw exception { return whitebox impl . < t > invoke method ( clazz , method to execute , argument ) ; }
public static class < object > get inner class type ( class < ? > declare class , string name ) throw class not find exception { return whitebox impl . get inner class type ( declare class , name ) ; }
public java . lang . string get description ( ) { java . lang . object ref = description_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; description_ = s ; return s ; } }
public java . lang . string get audience ( ) { java . lang . object ref = audiences_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; audiences_ = s ; return s ; } }
public java . lang . string get documentation root url ( ) { java . lang . object ref = documentation root url_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; documentation root url_ = s ; return s ; } }
public java . util . list < com . google . api . http rule > get rule list ( ) { return rules_ ; }
public com . google . protobuf . byte string get data ( ) { return data_ ; }
public java . lang . string get key ( ) { java . lang . object ref = key_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; key_ = s ; return s ; } }
public java . util . list < com . google . api . label descriptor > get label list ( ) { return labels_ ; }
public java . lang . string get name ( ) { java . lang . object ref = name_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; name_ = s ; return s ; } }
public int get metric kind value ( ) { return metric kind_ ; }
public java . lang . string get name ( ) { java . lang . object ref = name_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; name_ = s ; return s ; } }
public java . lang . string get type ( ) { java . lang . object ref = type_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; type_ = s ; return s ; } }
public java . lang . string get description ( ) { java . lang . object ref = description_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; description_ = s ; return s ; } }
public java . lang . string get name ( ) { java . lang . object ref = name_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; name_ = s ; return s ; } }
public boolean have config version ( ) { return config version_ ! = null ; }
public java . util . list < com . google . protobuf . enum > get enums list ( ) { return enums_ ; }
public java . util . list < com . google . api . usage rule > get rule list ( ) { return rules_ ; }
public boolean get allow unregistered call ( ) { return allow unregistered calls_ ; }
public boolean get skip service control ( ) { return skip service control_ ; }
public java . lang . string get resource name ( ) { java . lang . object ref = resource name_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; resource name_ = s ; return s ; } }
public boolean have authentication info ( ) { return authentication info_ ! = null ; }
public java . lang . string get principal email ( ) { java . lang . object ref = principal email_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; principal email_ = s ; return s ; } }
public java . lang . string get remote ip ( ) { java . lang . object ref = remote ip_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; remote ip_ = s ; return s ; } }
public java . lang . string get referer ( ) { java . lang . object ref = referer_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; referer_ = s ; return s ; } }
public java . util . list < com . google . longrunning . operation > get operation list ( ) { return operations_ ; }
public boolean have retry delay ( ) { return retry delay_ ! = null ; }
public int get year ( ) { return year_ ; }
public double get latitude ( ) { return latitude_ ; }
public int get minute ( ) { return minutes_ ; }
public int get nanos ( ) { return nanos_ ; }
public int get paths count ( ) { return paths_ . size ( ) ; }
public static boolean be valid utf8 ( byte string byte string ) { return byte string . be valid utf8 ( ) ; }
public schema < ? > register schema override ( class < ? > message type , schema < ? > schema ) { check not null ( message type , `` message type `` ) ; check not null ( schema , `` schema `` ) ; return schema cache . put ( message type , schema ) ; }
public list < b type > get builder list ( ) { if ( external builder list == null ) { external builder list = new builder external list < m type , b type , i type > ( this ) ; } return external builder list ; }
public static < parameter type > rpc callback < parameter type > new one time callback ( final rpc callback < parameter type > original callback ) { return new rpc callback < parameter type > ( ) { private boolean already call = false ; @ override public void run ( final parameter type parameter ) { synchronize ( this ) { if ( already call ) { throw new already call exception ( ) ; } already call = true ; } original callback . run ( parameter ) ; } } ; }
public proto syntax get syntax ( ) { return syntax ; }
public static void turn all log on ( ) { py4j_logger . set level ( level . all ) ; }
public string [ ] get public static name ( class < ? > clazz ) { set < string > name = new hash set < string > ( ) ; name . add all ( array . a list ( get public static class name ( clazz ) ) ) ; name . add all ( array . a list ( get public static field name ( clazz ) ) ) ; name . add all ( array . a list ( get public static method name ( clazz ) ) ) ; return ( string [ ] ) names . to array ( new string [ name . size ( ) ] ) ; }
public int get max concurrent search ( ) { return this . max concurrent search ; }
public static class loader context class loader ( ) { return thread . current thread ( ) . get context class loader ( ) ; }
public configuration builder set scanner ( scanner . . . scanner ) { this . scanner = new hash set < > ( arrays . a list ( scanner ) ) ; return this ; }
public set < constructor > get constructor annotate with ( final class < ? extend annotation > annotation ) { iterable < string > method = store . get ( index ( method annotation scanner . class ) , annotation . get name ( ) ) ; return get constructor from descriptor ( method , loader ( ) ) ; }
public static < t > list < class < ? extend t > > for name ( final iterable < string > class , class loader . . . class loader ) { list < class < ? extend t > > result = new array list < class < ? extend t > > ( ) ; for ( string class name : class ) { class < ? > type = for name ( class name , class loader ) ; if ( type ! = null ) { result . add ( ( class < ? extend t > ) type ) ; } } return result ; }
public static mutable roar bitmap and ( mutable roaring bitmap . . . bitmap ) { return and ( convert to immutable ( bitmap ) ) ; }
public int get cardinality ( ) { int size = 0 ; for ( int i = 0 ; i < this . high low container . size ( ) ; ++i ) { size += this . high low container . get cardinality ( i ) ; } return size ; }
public mappeable container lazy i o r ( mappeable container x ) { if ( this instanceof mappeable array container ) { if ( x instanceof mappeable array container ) return ior ( ( mappeable array container ) x ) ; else if ( x instanceof mappeable bitmap container ) return ( ( mappeable bitmap container ) x ) . lazyor ( ( mappeable array container ) this ) ; return ( ( mappeable run container ) x ) . lazyor ( ( mappeable array container ) this ) ; } else if ( this instanceof mappeable run container ) { if ( x instanceof mappeable array container ) return ( ( mappeable run container ) this ) . ilazyor ( ( mappeable array container ) x ) ; else if ( x instanceof mappeable bitmap container ) return ( ( mappeable bitmap container ) x ) . lazyor ( ( mappeable run container ) this ) ; return ior ( ( mappeable run container ) x ) ; } else { if ( x instanceof mappeable array container ) return ( ( mappeable bitmap container ) this ) . ilazyor ( ( mappeable array container ) x ) ; else if ( x instanceof mappeable bitmap container ) return ( ( mappeable bitmap container ) this ) . ilazyor ( ( mappeable bitmap container ) x ) ; return ( ( mappeable bitmap container ) this ) . ilazyor ( ( mappeable run container ) x ) ; } }
protect void append copy ( pointable roar array high low container , int start index , int end ) { extend array ( end - start index ) ; for ( int i = start index ; i < end ; ++i ) { this . key [ this . size ] = high low container . get key at index ( i ) ; this . value [ this . size ] = high low container . get container at index ( i ) . clone ( ) ; this . size++ ; } }
public void set mode ( final string mode ) { this . mode = string . to lower case ( mode ) ; if ( mode == null || ! mode . contains ( mode ) ) { throw new illegal argument exception ( `` invalid mode [ `` + mode + `` ] `` ) ; } }
public void set alternate link ( final list < link > alternate link ) { this . alternate link = alternate link ; }
public void set id ( final string id ) { this . id = id ; }
public void set title ex ( final content title ) { this . title = title ; }
public string get title ( ) { if ( title ! = null ) { return title . get value ( ) ; } return null ; }
public void set entry ( final list < entry > entry ) { this . entry = entry ; }
public string get name ( ) { return name ; }
public void set email ( final string email ) { this . email = email ; }
public string get identifier ( ) { return list . first entry ( identifier ) ; }
public string get coverage ( ) { return list . first entry ( coverage ) ; }
public void set coverage ( final string coverage ) { this . coverage = list . create ( coverage ) ; }
public void set update base ( final date update base ) { this . update base = date . copy ( update base ) ; }
public string get uri ( ) { return uri ; }
public void set image ( final image image ) { this . image = image ; }
public int get port ( ) { return port ; }
public string get register procedure ( ) { return register procedure ; }
public void set title ( final string title ) { this . title = title ; }
public integer get width ( ) { return width ; }
public void set title ( final string title ) { this . title = title ; }
public void set content ( final content content ) { this . content = content ; }
public string get author ( ) { return author ; }
public list < element > get foreign markup ( ) { return foreign markup = list . create when null ( foreign markup ) ; }
public string get mode ( ) { return mode ; }
public void set foreign markup ( final list < element > foreign markup ) { this . foreign markup = foreign markup ; }
public string get uri ( ) { return uri ; }
public void set uri ( final string uri ) { this . uri = u r i normalizer . normalize ( uri ) ; }
public synd content get title ex ( ) { return title ; }
public string get copyright ( ) { return get d c module ( ) . get right ( ) ; }
public synd image get icon ( ) { return icon ; }
public void set module ( final list < module > module ) { this . module = module ; }
public string get encode ( ) { return encode ; }
public string get style sheet ( ) { return style sheet ; }
protect final element generate simple element ( final string name , final string value ) { final element element = new element ( name , get d c namespace ( ) ) ; element . add content ( value ) ; return element ; }
protect final list < d c subject > parse subject ( final list < element > e list ) { final list < d c subject > subject = new array list < d c subject > ( ) ; for ( final element e subject : e list ) { final element description = e subject . get child ( `` description `` , get r d f namespace ( ) ) ; if ( description ! = null ) { final string taxonomy = get taxonomy ( description ) ; final list < element > value = description . get child ( `` value `` , get r d f namespace ( ) ) ; for ( final element value : value ) { final d c subject subject = new d c subject impl ( ) ; subject . set taxonomy uri ( taxonomy ) ; subject . set value ( value . get text ( ) ) ; subject . add ( subject ) ; } } else { final d c subject subject = new d c subject impl ( ) ; subject . set value ( e subject . get text ( ) ) ; subject . add ( subject ) ; } } return subject ; }
protect void populate channel ( final channel channel , final element e channel ) { final string title = channel . get title ( ) ; if ( title ! = null ) { e channel . add content ( generate simple element ( `` title `` , title ) ) ; } final string link = channel . get link ( ) ; if ( link ! = null ) { e channel . add content ( generate simple element ( `` link `` , link ) ) ; } final string description = channel . get description ( ) ; if ( description ! = null ) { e channel . add content ( generate simple element ( `` description `` , description ) ) ; } }
protect namespace get r s s namespace ( ) { return namespace . get namespace ( rss_uri ) ; }
public string output string ( final wire feed feed ) throw illegal argument exception , feed exception { return this . output string ( feed , true ) ; }
public static completable complete ( ) { on subscribe co = rx java hook . on create ( complete . on subscribe ) ; if ( cos == complete . on subscribe ) { return complete ; } return new completable ( co , false ) ; }
public final completable delay ( long delay , time unit unit ) { return delay ( delay , unit , scheduler . computation ( ) , false ) ; }
public final completable do on error ( action1 < ? super throwable > on error ) { return do on lifecycle ( action . empty ( ) , on error , action . empty ( ) , action . empty ( ) , action . empty ( ) ) ; }
public final completable do after terminate ( action0 on after terminate ) { return do on lifecycle ( action . empty ( ) , action . empty ( ) , action . empty ( ) , on after terminate , action . empty ( ) ) ; }
public final subscription subscribe ( ) { final multiple assignment subscription mad = new multiple assignment subscription ( ) ; unsafe subscribe ( new rx . completable subscriber ( ) { @ override public void on complete ( ) { mad . unsubscribe ( ) ; } @ override public void on error ( throwable e ) { rx java hook . on error ( e ) ; mad . unsubscribe ( ) ; deliver uncaught exception ( e ) ; } @ override public void on subscribe ( subscription d ) { mad . set ( d ) ; } } ) ; return mad ; }
public final subscription subscribe ( final action0 on complete ) { require non null ( on complete ) ; final multiple assignment subscription mad = new multiple assignment subscription ( ) ; unsafe subscribe ( new rx . completable subscriber ( ) { boolean do ; @ override public void on complete ( ) { if ( ! do ) { do = true ; try { on complete . call ( ) ; } catch ( throwable e ) { rx java hook . on error ( e ) ; deliver uncaught exception ( e ) ; } finally { mad . unsubscribe ( ) ; } } } @ override public void on error ( throwable e ) { rx java hook . on error ( e ) ; mad . unsubscribe ( ) ; deliver uncaught exception ( e ) ; } @ override public void on subscribe ( subscription d ) { mad . set ( d ) ; } } ) ; return mad ; }
public static boolean validate ( long n ) { if ( n < 0 ) { throw new illegal argument exception ( `` n > = 0 require but it be `` + n ) ; } return n ! = 0l ; }
public void add ( final future < ? > f ) { cancel . add ( new future completer ( f ) ) ; }
public void terminate and drain ( throwable error ) { if ( ! terminate ) { exception = error ; terminate = true ; drain ( ) ; } }
public static int get android api version ( ) { return android_api_version ; }
public t get ( ) { return t ; }
public single < t > to single ( ) { return new single < t > ( on subscribe single . create ( this ) ) ; }
public static < t > observable < t > amb ( iterable < ? extend observable < ? extend t > > source ) { return unsafe create ( on subscribe amb . amb ( source ) ) ; }
public static < t > observable < t > amb ( observable < ? extend t > o1 , observable < ? extend t > o2 , observable < ? extend t > o3 , observable < ? extend t > o4 , observable < ? extend t > o5 ) { return unsafe create ( on subscribe amb . amb ( o1 , o2 , o3 , o4 , o5 ) ) ; }
public static < t , r > observable < r > combine late ( list < ? extend observable < ? extend t > > source , func n < ? extend r > combine function ) { return unsafe create ( new on subscribe combine late < t , r > ( source , combine function ) ) ; }
public static < t > observable < t > concat ( observable < ? extend t > t1 , observable < ? extend t > t2 ) { return concat ( just ( t1 , t2 ) ) ; }
public static < t > observable < t > concat ( observable < ? extend t > t1 , observable < ? extend t > t2 , observable < ? extend t > t3 , observable < ? extend t > t4 ) { return concat ( just ( t1 , t2 , t3 , t4 ) ) ; }
public static < t > observable < t > concat delay error ( observable < ? extend t > t1 , observable < ? extend t > t2 , observable < ? extend t > t3 , observable < ? extend t > t4 ) { return concat delay error ( just ( t1 , t2 , t3 , t4 ) ) ; }
public static < t > observable < t > merge ( observable < ? extend observable < ? extend t > > source ) { if ( source . get class ( ) == scalar synchronous observable . class ) { return ( ( scalar synchronous observable < t > ) source ) . scalar flat map ( ( func1 ) utility function . identity ( ) ) ; } return source . lift ( operator merge . < t > instance ( false ) ) ; }
public static < t > observable < t > merge ( observable < ? extend t > t1 , observable < ? extend t > t2 ) { return merge ( new observable [ ] { t1 , t2 } ) ; }
public static < t > observable < t > merge delay error ( iterable < ? extend observable < ? extend t > > sequence ) { return merge delay error ( from ( sequence ) ) ; }
public static observable < integer > range ( int start , int count , scheduler scheduler ) { return range ( start , count ) . subscribe on ( scheduler ) ; }
public final < b > observable < list < t > > buffer ( observable < b > boundary ) { return buffer ( boundary , 16 ) ; }
public final < r > observable < r > concat map eager ( func1 < ? super t , ? extend observable < ? extend r > > mapper ) { return concat map eager ( mapper , rx ring buffer . size ) ; }
public final observable < t > first ( ) { return take ( 1 ) . single ( ) ; }
public final observable < t > last ( ) { return take last ( 1 ) . single ( ) ; }
public final observable < t > merge with ( observable < ? extend t > t1 ) { return merge ( this , t1 ) ; }
public final observable < t > repeat ( final long count ) { return on subscribe redo . < t > repeat ( this , count ) ; }
public final observable < t > single or default ( t default value ) { return lift ( new operator single < t > ( default value ) ) ; }
public final observable < t > throttle last ( long interval duration , time unit unit ) { return sample ( interval duration , unit ) ; }
public final observable < time interval < t > > time interval ( scheduler scheduler ) { return lift ( new operator time interval < t > ( scheduler ) ) ; }
public final observable < list < t > > to sort list ( ) { return lift ( new operator to observable sorted list < t > ( 10 ) ) ; }
public static < t > test subscriber < t > create ( long initial request ) { return new test subscriber < t > ( initial request ) ; }
public static < t > test subscriber < t > create ( observer < t > delegate , long initial request ) { return new test subscriber < t > ( delegate , initial request ) ; }
public final int get value count ( ) { return value count ; }
public static < t > observable . on subscribe < t > on create ( observable . on subscribe < t > on subscribe ) { func1 < observable . on subscribe , observable . on subscribe > f = on observable create ; if ( f ! = null ) { return f . call ( on subscribe ) ; } return on subscribe ; }
public static void set on error ( action1 < throwable > on error ) { if ( lockdown ) { return ; } rx java hook . on error = on error ; }
public static func0 < ? extends schedule executor service > get on generic schedule executor service ( ) { return on generic schedule executor service ; }
public static void start ( ) { scheduler s = get instance ( ) ; s . start instance ( ) ; synchronize ( s ) { generic schedule executor service . instance . start ( ) ; } }
public static < t > observable < t > concat ( single < ? extend t > t1 , single < ? extend t > t2 , single < ? extend t > t3 , single < ? extend t > t4 , single < ? extend t > t5 , single < ? extend t > t6 , single < ? extend t > t7 ) { return observable . concat ( a observable ( t1 ) , a observable ( t2 ) , a observable ( t3 ) , a observable ( t4 ) , a observable ( t5 ) , a observable ( t6 ) , a observable ( t7 ) ) ; }
public static < t > observable < t > concat ( single < ? extend t > t1 , single < ? extend t > t2 , single < ? extend t > t3 , single < ? extend t > t4 , single < ? extend t > t5 , single < ? extend t > t6 , single < ? extend t > t7 , single < ? extend t > t8 ) { return observable . concat ( a observable ( t1 ) , a observable ( t2 ) , a observable ( t3 ) , a observable ( t4 ) , a observable ( t5 ) , a observable ( t6 ) , a observable ( t7 ) , a observable ( t8 ) ) ; }
public static < t > observable < t > merge ( single < ? extend t > t1 , single < ? extend t > t2 , single < ? extend t > t3 , single < ? extend t > t4 , single < ? extend t > t5 , single < ? extend t > t6 ) { return observable . merge ( a observable ( t1 ) , a observable ( t2 ) , a observable ( t3 ) , a observable ( t4 ) , a observable ( t5 ) , a observable ( t6 ) ) ; }
public static < t > observable < t > merge ( observable < ? extend single < ? extend t > > source , int max concurrency ) { return source . flat map single ( ( func1 ) utility function . identity ( ) , false , max concurrency ) ; }
public final observable < t > concat with ( single < ? extend t > t1 ) { return concat ( this , t1 ) ; }
public boolean have value ( ) { object v = last value ; object o = state . get late ( ) ; return ! notification lite . be error ( o ) & & notification lite . be next ( v ) ; }
public static < t > unicast subject < t > create ( ) { return create ( 16 ) ; }
public subscription get ( ) { return state . current ( ) ; }
public void set strip space ( int strip action ) { option . set strip space ( strip action ) ; }
public void set please close after use ( boolean close ) { option . set please close after use ( close ) ; }
public static boolean be n c name11 ( int i ) { return i < 65536 ? ( data [ i ] & name_11_mask ) ! = 0 : ( utf16 . nonbmp_min < = i & & i < = max_xml11_name_char ) ; }
public static int range set get category ( byte mask ) { int range set irs = new int range set ( ) ; for ( int i=0 ; i < 65536 ; i++ ) { if ( ( data [ i ] & mask ) ! = 0 ) { irs . add ( i ) ; } } if ( ( mask & ( name_start_11_mask | name_11_mask ) ) ! = 0 ) { irs . add range ( utf16 . nonbmp_min , max_xml11_name_char ) ; } return irs ; }
public void set there have be an explicit result document ( ) { there have be an explicit result document = true ; }
public void set u r i resolver ( u r i resolver resolver ) { user u r i resolver = resolver ; if ( resolver instanceof standard u r i resolver ) { ( ( standard u r i resolver ) resolver ) . set configuration ( get configuration ( ) ) ; } }
public void set tree model ( int model ) { tree model = model ; }
public void register document ( document info doc , string system id ) { source document pool . add ( doc , system id ) ; }
public void set executable ( executable exec ) { executable = exec ; }
public void set class loader ( class loader loader ) { class loader = loader ; }
public void set base u r i ( string base u r i ) { this . base u r i = base u r i ; }
public static node info build ( source source , stripper stripper , configuration config ) throw x path exception { return build ( source , stripper , config . make pipeline configuration ( ) ) ; }
public void set underlying content handler ( content handler handler ) { this . handler = handler ; if ( handler instanceof lexical handler ) { lexical handler = ( lexical handler ) handler ; } }
public void set require well form ( boolean well form ) { require well form = well form ; }
public void set undeclare namespaces ( boolean undeclare namespaces ) { this . undeclare namespaces = undeclare namespaces ; }
public void open ( ) throw x path exception { pending attribute = new attribute collection impl ( get pipeline configuration ( ) . get configuration ( ) ) ; if ( handler == null ) { throw new illegal state exception ( `` content handler proxy . open ( ) : no underlie handler provide `` ) ; } try { location provider = get pipeline configuration ( ) . get location provider ( ) ; pending attribute . set location provider ( location provider ) ; locator locator = new content handler proxy locator ( this ) ; handler . set document locator ( locator ) ; handler . start document ( ) ; } catch ( s a x exception err ) { handle s a x exception ( err ) ; } depth = 0 ; }
public void start element ( int name code , int type code , int location id , int property ) throw x path exception { depth++ ; if ( depth < = 0 & & require well form ) { notify not well form ( ) ; } pending element = name code ; current location id = location id ; namespace stack . push ( marker ) ; }
public pipeline configuration get pipeline configuration ( ) { return pipeline config ; }
public string get system id ( ) { return system id ; }
public void set u r i resolver ( u r i resolver resolver ) { uri resolver = resolver ; }
public controller get controller ( ) { return controller ; }
public boolean be expand attribute default ( ) { return expand attribute default ; }
public receiver get underlying receiver ( ) { return next receiver ; }
public void processing instruction ( string target , char sequence data , int location id , int property ) throw x path exception { if ( in start tag ) { start content ( ) ; } if ( level == 0 ) { orphan o = new orphan ( get configuration ( ) ) ; o . set name code ( get name pool ( ) . allocate ( `` `` , `` `` , target ) ) ; o . set node kind ( type . processing_instruction ) ; o . set string value ( data ) ; append ( o , location id , node info . all_namespaces ) ; } else { outputter . process instruction ( target , data , location id , property ) ; } previous atomic = false ; }
protect proxy receiver new h t m l u r i escaper ( pipeline configuration pipe , property output property ) { h t m l u r i escaper r = new h t m l u r i escaper ( ) ; r . set pipeline configuration ( pipe ) ; return r ; }
public void start content ( ) throw x path exception { next receiver . start element ( element name code , element type code , element location id , element property | receiver option . namespace_ok ) ; declare namespaces for start element ( ) ; final int length = buffer attribute . get length ( ) ; for ( int i=0 ; i < length ; i++ ) { next receiver . attribute ( buffer attribute . get name code ( i ) , buffer attribute . get type annotation ( i ) , buffer attribute . get value ( i ) , buffer attribute . get location id ( i ) , buffer attribute . get property ( i ) | receiver option . namespace_ok ) ; } accept attribute = false ; next receiver . start content ( ) ; }
public int get element name code ( ) { return element name code ; }
public stripper get another ( ) { stripper clone = new stripper ( stripper mode ) ; clone . set pipeline configuration ( get pipeline configuration ( ) ) ; clone . strip all = strip all ; clone . preserve all = preserve all ; return clone ; }
public void character ( char sequence char , int location id , int property ) throw x path exception { if ( empty ) { open document ( ) ; } if ( ( property & receiver option . no_special_chars ) == 0 ) { int badchar = test character ( char ) ; if ( badchar ! = 0 ) { throw new x path exception ( `` output character not available in this encoding ( decimal `` + badchar + `` ) `` ) ; } } try { writer . write ( char . to string ( ) ) ; } catch ( java . io . i o exception err ) { throw new x path exception ( err ) ; } }
public void close ( ) throw x path exception { if ( next receiver ! = null ) { next receiver . close ( ) ; } previous atomic = false ; }
public sequence type get require type ( ) { return require type ; }
public string get variable name ( ) { if ( variable name == null ) { return `` zz : var `` + hash code ( ) ; } else { return variable name . get display name ( ) ; } }
public boolean be hybrid ( ) { return false ; }
public item type get item type ( type hierarchy th ) { return require item type ; }
public int get implementation method ( ) { int m = iterate_method | process_method ; if ( ! cardinality . allow many ( required cardinality ) ) { m |= evaluate_method ; } return m ; }
public string get default collation name ( ) { return default collation name ; }
public void set name collation ( string absolute u r i , string collator collator ) { if ( map == null ) { map = new hash map ( ) ; } map . put ( absolute u r i , collator ) ; }
public string collator get name collation ( string name ) { if ( name . equal ( namespace constant . codepoint_collation_uri ) ) { return codepoint collator . get instance ( ) ; } if ( map ! = null ) { string collator c = ( string collator ) map . get ( name ) ; if ( c ! = null ) { return c ; } } return config . get collation u r i resolver ( ) . resolve ( name , null , config ) ; }
public item get context item ( ) { return null ; }
public group iterator get current group iterator ( ) { not allow ( ) ; return null ; }
public int get last ( ) throw x path exception { x path exception err = new x path exception ( `` the context item be undefined `` ) ; err . set error code ( `` xpdy0002 `` ) ; throw err ; }
public boolean be at last ( ) throw x path exception { x path exception err = new x path exception ( `` the context item be undefined `` ) ; err . set error code ( `` xpdy0002 `` ) ; throw err ; }
public void set local variable ( int slotnumber , value representation value ) { not allow ( ) ; }
public iterator iterate stack frame ( ) { return collection . empty_list . iterator ( ) ; }
public event iterator iterate event ( x path context context ) throw x path exception { int m = get implementation method ( ) ; if ( ( m & evaluate_method ) ! = 0 ) { item item = evaluate item ( context ) ; if ( item == null ) { return empty event iterator . get instance ( ) ; } else { return new singleton event iterator ( item ) ; } } else { return new event iterator over sequence ( iterate ( context ) ) ; } }
public int compute dependency ( ) { int dependency = get intrinsic dependency ( ) ; for ( iterator child = iterate sub expression ( ) ; child . have next ( ) ; ) { dependency |= ( ( expression ) child . next ( ) ) . get dependency ( ) ; } return dependency ; }
public iterator get property ( ) { return new mono iterator ( `` expression `` ) ; }
public int get host language ( ) { return get container ( ) . get host language ( ) ; }
public string get system id ( ) { return system id ; }
public void set line number ( int line number ) { this . line number = line number ; }
public void set executable ( executable executable ) { this . executable = executable ; }
public stack get stack ( ) { return stack ; }
public structure q name get function name ( ) { return name ; }
protect int check argument count ( int min , int max , expression visitor visitor ) throw x path exception { int num args = argument . length ; if ( min==max & & num args ! = min ) { throw new x path exception ( `` function `` + get display name ( ) + `` must have `` + min + plural argument ( min ) , this ) ; } if ( num args < min ) { throw new x path exception ( `` function `` + get display name ( ) + `` must have at least `` + min + plural argument ( min ) , this ) ; } if ( num args > max ) { throw new x path exception ( `` function `` + get display name ( ) + `` must have no more than `` + max + plural argument ( max ) , this ) ; } return num args ; }
public final expression type check ( expression visitor visitor , item type context item type ) { return this ; }
public int hash code ( ) { return value . get schema comparable ( ) . hash code ( ) ; }
public configuration get configuration ( ) { return config ; }
public expression make conditional document sorter ( document sorter sorter , path expression path ) { return sorter ; }
public static sequence type get equivalent item type ( class java class ) { return ( sequence type ) jpmap . get ( java class ) ; }
public static int get cardinality code ( int cardinality ) { return ( cardinality & cardinality_mask ) > > 13 ; }
public void set function ( user function compile function ) { function = compile function ; confirm = true ; }
public expression [ ] get argument ( ) { return argument ; }
public event iterator iterate event ( x path context context ) throw x path exception { value representation [ ] actual args = evaluate argument ( context ) ; if ( tail call ) { ( ( x path context major ) context ) . request tail call ( function , actual args ) ; return empty event iterator . get instance ( ) ; } else { sequence receiver out = context . get receiver ( ) ; x path context major c2 = context . new clean context ( ) ; c2 . set receiver ( out ) ; c2 . set origin ( this ) ; return function . iterate event ( actual args , c2 ) ; } }
public static double day in year ( x path context context ) throw x path exception { return day in year ( date time ( context ) ) ; }
public static double day in month ( x path context context ) throw x path exception { return day in month ( date time ( context ) ) ; }
public static double day in week ( x path context context ) throw x path exception { return day in week ( date time ( context ) ) ; }
public static string day abbreviation ( string date time ) { string [ ] day = { `` sun `` , `` mon `` , `` tue `` , `` wed `` , `` thu `` , `` fri `` , `` sit `` } ; double d = day in week ( date time ) ; if ( double . be na n ( d ) ) { return `` `` ; } return day [ ( int ) d - 1 ] ; }
public expression pre evaluate ( expression visitor visitor ) { return this ; }
public final sequence iterator iterate ( x path context c ) { throw new illegal state exception ( `` function `` + get name ( c ) + `` should have be resolve at compile-time `` ) ; }
public char sequence evaluate a string ( x path context c ) throw x path exception { return evaluate item ( c ) . get string value c s ( ) ; }
public atomic comparer get atomic comparer ( ) { return atomic comparer ; }
public void set read once ( boolean once ) { read once = once ; }
public item evaluate item ( x path context context ) throw x path exception { qualified name value qname = null ; if ( argument . length > 0 ) { qname = ( qualify name value ) argument [ 0 ] . evaluate item ( context ) ; } if ( qname == null ) { qname = new q name value ( `` err `` , namespace constant . err , ( argument . length == 1 ? `` foty0004 `` : `` foer0000 `` ) , build in atomic type . qname , null ) ; } string description ; if ( argument . length > 1 ) { description = argument [ 1 ] . evaluate item ( context ) . get string value ( ) ; } else { description = `` error signal by application call on error ( ) `` ; } x path exception e = new x path exception ( description ) ; e . set error code ( qname . get namespace u r i ( ) , qname . get local name ( ) ) ; e . set x path context ( context ) ; e . set locator ( this ) ; if ( argument . length > 2 ) { value error object = ( ( value ) sequence extent . make sequence extent ( argument [ 2 ] . iterate ( context ) ) ) . reduce ( ) ; if ( error object instanceof singleton node ) { node info root = ( ( singleton node ) error object ) . get node ( ) ; if ( root . get node kind ( ) == type . document ) { x path evaluator xpath = new x path evaluator ( ) ; x path expression exp = xpath . create expression ( `` /error/ @ module `` ) ; node info module att = ( node info ) exp . evaluate single ( root ) ; string module = ( module att == null ? null : module att . get string value ( ) ) ; exp = xpath . create expression ( `` /error/ @ line `` ) ; node info line att = ( node info ) exp . evaluate single ( root ) ; int line = ( line att == null ? -1 : integer . parse int ( line att . get string value ( ) ) ) ; exp = xpath . create expression ( `` /error/ @ column `` ) ; node info column att = ( node info ) exp . evaluate single ( root ) ; int column = ( column att == null ? -1 : integer . parse int ( column att . get string value ( ) ) ) ; expression location locator = new expression location ( ) ; locator . set system id ( module ) ; locator . set line number ( line ) ; locator . set column number ( column ) ; e . set locator ( locator ) ; } } e . set error object ( error object ) ; } throw e ; }
public expression pre evaluate ( expression visitor visitor ) { return this ; }
public item type get item type ( type hierarchy th ) { item type t = atomizer . get atomized item type ( argument [ 0 ] , false , th ) ; if ( t . get primitive type ( ) == standard name . xs_untyped_atomic ) { return build in atomic type . double ; } else { return t ; } }
public expression pre evaluate ( expression visitor visitor ) throw x path exception { return this ; }
public int to int map get static map ( ) { return static map ; }
public expression pre evaluate ( expression visitor visitor ) throw x path exception { return argument [ 0 ] ; }
public void start document ( ) throw s a x exception { if ( result==null ) { result = new stream result ( system . out ) ; } try { property prop = controller . get output property ( ) ; pipeline configuration pipe = controller . make pipeline configuration ( ) ; configuration config = get configuration ( ) ; serializer factory sf = config . get serializer factory ( ) ; receiver out = sf . get receiver ( result , pipe , prop ) ; set pipeline configuration ( pipe ) ; int strip space = config . get strips white space ( ) ; if ( strip space == whitespace . all ) { stripper s = new all element stripper ( ) ; s . set strip all ( ) ; s . set pipeline configuration ( pipe ) ; s . set underlying receiver ( out ) ; out = s ; } set receiver ( out ) ; } catch ( x path exception err ) { throw new s a x exception ( err ) ; } super . start document ( ) ; }
public void set reject duplicate ( ) { option |= receiver option . reject_duplicates ; }
public int get option ( ) { return option ; }
public void set use attribute set ( attribute set [ ] use attribute set ) { this . use attribute set = use attribute set ; }
public int get instruction name code ( ) { return standard name . xsl_attribute ; }
public expression get name expression ( ) { return attribute name ; }
public namespace resolver get namespace resolver ( ) { return ns context ; }
protect void promote inst ( promotion offer offer ) throw x path exception { attribute name = do promotion ( attribute name , offer ) ; if ( namespace ! = null ) { namespace = do promotion ( namespace , offer ) ; } super . promote inst ( offer ) ; }
public rule manager get rule manager ( ) { return rule manager ; }
public template get name template ( structure q name q name ) { if ( name template table == null ) { return null ; } return ( template ) name template table . get ( q name ) ; }
public mode get stripper rule ( ) { return stripper rule ; }
public property get output property ( structure q name q name ) { if ( output declaration == null ) { return null ; } else { return ( property ) output declaration . get ( q name ) ; } }
public void set default collation name ( string name ) { default collation name = name ; }
public string get reason unable to compile ( ) { return reason unable to compile ; }
public final boolean be implicitly require param ( ) { return ( property & implicitly_required ) ! = 0 ; }
public int get instruction name code ( ) { return standard name . xsl_variable ; }
public void set parameter id ( int id ) { parameter id = id ; }
public schema type get schema type ( ) { return schema type ; }
public void set validation mode ( int mode ) { validation = mode ; }
public expression get select expression ( ) { return select ; }
public expression get separator expression ( ) { return separator ; }
public void set select ( expression select , configuration config ) throw x path exception { this . select = select ; adopt child expression ( select ) ; }
public int get precedence ( ) { return precedence ; }
public void set construct type ( int type ) { construct type = type ; }
public int get line number ( long location id ) { return get line number ( ) ; }
public boolean be update ( ) { return be update ; }
public boolean be memo function ( ) { return memo function ; }
public void set variable q name ( structure q name name ) { variable q name = name ; }
public expression convert to string join ( static context env ) { if ( select . get item type ( env . get configuration ( ) . get type hierarchy ( ) ) . equal ( build in atomic type . untyped_atomic ) ) { return select ; } else if ( select instanceof string literal ) { try { return new literal ( new untyped atomic value ( ( ( string literal ) select ) . get value ( ) . get string value c s ( ) ) ) ; } catch ( x path exception err ) { throw new assertion error ( err ) ; } } else { string fn fn = ( string fn ) system function . make system function ( `` string `` , new expression [ ] { select } ) ; return new cast expression ( fn , build in atomic type . untyped_atomic , false ) ; } }
public static boolean replace x path expression ( with param [ ] params , expression original , expression replacement ) { boolean find = false ; for ( int i=0 ; i < params . length ; i++ ) { boolean f = params [ i ] . replace sub expression ( original , replacement ) ; find |= f ; } return find ; }
public void make extension library ( configuration config ) { config . set extension binder ( `` java `` , new java extension library ( config ) ) ; }
public item current ( ) { return string value . make string value ( current ) ; }
public string get regex group ( int number ) { if ( ! be match ( ) ) return null ; if ( number > matcher . group count ( ) || number < 0 ) return `` `` ; string s = matcher . group ( number ) ; if ( s==null ) return `` `` ; return s ; }
public sequence iterator get regex group iterator ( ) { int c = matcher . group count ( ) ; if ( c == 0 ) { return empty iterator . get instance ( ) ; } else { string value [ ] group = new string value [ c ] ; for ( int i=1 ; i < =groups . length ; i++ ) { group [ i-1 ] = string value . make string value ( matcher . group ( i ) ) ; } return new array iterator ( group ) ; } }
public string to word ( long number ) { if ( number > = 1000000000 ) { long rem = number % 1000000000 ; return to word ( number / 1000000000 ) + `` billion `` + ( rem==0 ? `` `` : ( rem < 100 ? `` and `` : `` `` ) + to word ( rem ) ) ; } else if ( number > = 1000000 ) { long rem = number % 1000000 ; return to word ( number / 1000000 ) + `` million `` + ( rem==0 ? `` `` : ( rem < 100 ? `` and `` : `` `` ) + to word ( rem ) ) ; } else if ( number > = 1000 ) { long rem = number % 1000 ; return to word ( number / 1000 ) + `` thousand `` + ( rem==0 ? `` `` : ( rem < 100 ? `` and `` : `` `` ) + to word ( rem ) ) ; } else if ( number > = 100 ) { long rem = number % 100 ; return to word ( number / 100 ) + `` hundred `` + ( rem==0 ? `` `` : `` and `` + to word ( rem ) ) ; } else { if ( number < 20 ) return english unit [ ( int ) number ] ; int rem = ( int ) ( number % 10 ) ; return english ten [ ( int ) number / 10 ] + ( rem==0 ? `` `` : ' ' + english unit [ rem ] ) ; } }
public document info discard ( document info doc ) { iterator iter = document name map . key set ( ) . iterator ( ) ; while ( iter . have next ( ) ) { object name = iter . next ( ) ; document info entry = ( document info ) document name map . get ( name ) ; if ( entry == doc ) { document name map . remove ( name ) ; return doc ; } } return doc ; }
public void append ( char slice s ) { int len = s . length ( ) ; ensure capacity ( len ) ; s . copy to ( array , use ) ; use += len ; }
public void append ( char [ ] src array ) { final int length = src array . length ; ensure capacity ( length ) ; system . arraycopy ( src array , 0 , array , use , length ) ; use += length ; }
public void set char at ( int index , char ch ) { if ( index < 0 || index > use ) { throw new index out of bound exception ( `` `` +index ) ; } array [ index ] = ch ; }
public node info get node ( ) { return node ; }
public void start prefix mapping ( string prefix , string uri ) throw s a x exception { super . start prefix mapping ( prefix , uri ) ; prefix . push ( prefix ) ; uris . push ( uri ) ; if ( uri to prefix . get ( uri ) == null ) { uri to prefix . put ( uri , prefix ) ; } }
public boolean equal ( object other ) { return other instanceof node info & & be same node info ( ( node info ) other ) ; }
public int get line number ( ) { return original . get line number ( ) ; }
public string get string value ( ) { return original . get string value ( ) ; }
public string get prefix ( ) { return original . get prefix ( ) ; }
public double get default priority ( ) { return -0 . 5 ; }
public void set nillable ( boolean nillable ) { this . nillable = nillable ; }
public pattern analyze ( expression visitor visitor , item type context item type ) throw x path exception { id expression = visitor . type check ( id expression , context item type ) ; role locator role = new role locator ( role locator . function , `` id `` , 1 ) ; id expression = type checker . static type check ( id expression , sequence type . atomic_sequence , false , role , visitor ) ; return this ; }
public pattern get ancestor pattern ( ) { return ancestor pattern ; }
public string get namespace u r i ( ) { return name pool . get u r i from u r i code ( uri code ) ; }
public boolean be atomic type ( ) { return false ; }
public container get container ( ) { return pattern ; }
public int get head fingerprint ( ) { return head ; }
public pattern simplify ( expression visitor visitor ) throw x path exception { p1 = p1 . simplify ( visitor ) ; p2 = p2 . simplify ( visitor ) ; return this ; }
public pattern get l h s ( ) { return p1 ; }
public pattern get r h s ( ) { return p2 ; }
public void set system id ( string system id ) { super . set system id ( system id ) ; p1 . set system id ( system id ) ; p2 . set system id ( system id ) ; }
public iterator get prefix ( string uri ) { list list = new array list ( 4 ) ; iterator prefix = iterate prefix ( ) ; while ( prefix . have next ( ) ) { string p = ( string ) prefix . next ( ) ; string u = resolver . get u r i for prefix ( p , true ) ; if ( u . equal ( uri ) ) { list . add ( p ) ; } } return list . iterator ( ) ; }
public int skip to match end ( ) throw x path exception { return base . skip to match end ( ) ; }
public string get name ( ) { return name ; }
public void set parameter ( string expand name , object value ) { if ( parameters==null ) { parameter = new hash map ( 10 ) ; } parameter . put ( expand name , value ) ; }
public void set system id ( string system id ) { this . system id = system id ; }
public iterator iterate reference ( ) { return reference . iterator ( ) ; }
public void add import namespace ( string uri ) { if ( import module namespaces == null ) { import module namespaces = new hash set ( 5 ) ; } import module namespaces . add ( uri ) ; get import function library ( ) . add imported namespace ( uri ) ; }
public boolean import namespace ( string uri ) { return import module namespaces ! = null & & import module namespaces . contains ( uri ) ; }
public boolean import namespace indirectly ( string uri ) { if ( import namespace ( uri ) ) { return true ; } for ( iterator it = iterate import namespaces ( ) ; it . have next ( ) ; ) { string module u r i = ( string ) it . next ( ) ; list list = executable . get query library module ( module u r i ) ; for ( iterator i2 = list . iterator ( ) ; i2 . have next ( ) ; ) { query module sqc = ( query module ) i2 . next ( ) ; if ( sqc . import namespace indirectly ( uri ) ) { return true ; } } } return false ; }
public void fixup global function ( ) throw x path exception { global function library . fixup global function ( this ) ; }
public void set executable ( executable executable ) { this . executable = executable ; }
public boolean be document projection allow ( ) { return allow document projection ; }
public int get column number ( ) { return -1 ; }
public executable get executable ( ) { return executable ; }
public boolean be memo function ( ) { return memo function ; }
public int get column number ( ) { return -1 ; }
public iterator get function definition ( ) { return function . value ( ) . iterator ( ) ; }
protect void process source ( source source input , x query expression exp , dynamic query context dynamic env ) throw x path exception { if ( source input ! = null ) { if ( show time ) { system . err . println ( `` process `` + source input . get system id ( ) ) ; } if ( ! exp . use context item ( ) ) { system . err . println ( `` source document ignore - query do not access the context item `` ) ; source input = null ; } else if ( projection ) { path map map = exp . get path map ( ) ; path map . path map root context root = map . get context root ( ) ; if ( explain ) { system . err . println ( `` document projection : path map `` ) ; map . diagnostic dump ( system . err ) ; } if ( context root ! = null ) { if ( context root . have unknown dependency ( ) ) { system . err . println ( `` document projection for the context document be not possible , `` + `` because the query use path that defy analysis `` ) ; } else { proxy receiver filter = config . make document projector ( context root ) ; source input = augment source . make augmented source ( source input ) ; ( ( augment source ) source input ) . add filter ( filter ) ; } } else { system . err . println ( `` source document supply , but query do not access the context item `` ) ; } } if ( source input ! = null ) { document info doc = config . build document ( source input ) ; dynamic env . set context item ( doc ) ; } } }
public boolean have next ( ) { return false ; }
public static global order comparer get instance ( ) { return instance ; }
public void display ( ) { int iterator iter = new int hash map key iterator ( ) ; while ( iter . have next ( ) ) { int key = iter . next ( ) ; object value = get ( key ) ; system . err . println ( key + `` - > `` + value . to string ( ) ) ; } }
public boolean find ( int key ) { for ( int i=0 ; i < use ; i++ ) { if ( key [ i ] == key ) { return true ; } } return false ; }
public int iterator key iterator ( ) { return new int to int hash map key iterator ( ) ; }
public string get uri ( ) { return uri ; }
public expression get case order ( ) { return case order ; }
public void set error output ( writer writer ) { error output = writer ; }
public standard error listener make another ( int host language ) { return new standard error listener ( ) ; }
public print stream get error output ( ) { return error output ; }
protected item type get return item type ( ) { return any item type . get instance ( ) ; }
protect boolean allow a v t ( ) { return true ; }
public list get all function ( ) { return stylesheet . get all stylesheet function ( ) ; }
public string get system id ( ) { return get base u r i ( ) ; }
public boolean be tunnel param ( ) { return tunnel ; }
public void set redundant ( ) { redundant = true ; }
public structure q name get format q name ( ) { return output format name ; }
public location map get location map ( ) { return location map ; }
public boolean allow all build in type ( ) { return allow all build in type ; }
protect final void add function library ( function library library ) { function library library list = executable . get function library ( ) ; if ( library list instanceof function library list ) { ( ( function library list ) library list ) . add function library ( library ) ; } else { throw new illegal state exception ( `` register function library can not be extend `` ) ; } }
public void set base u r i ( string base u r i ) { this . base u r i = base u r i ; }
public function library get function library ( ) { return executable . get function library ( ) ; }
public string get default function namespace ( ) { return default function namespace ; }
public void set namespaces ( node info node ) { namespaces . clear ( ) ; int kind = node . get node kind ( ) ; if ( kind == type . attribute || kind == type . text || kind == type . comment || kind == type . processing_instruction || kind == type . namespace ) { node = node . get parent ( ) ; } if ( node == null ) { return ; } axis iterator iter = node . iterate axis ( axis . namespace ) ; while ( true ) { node info n = ( node info ) iter . next ( ) ; if ( ns == null ) { return ; } string prefix = n . get local part ( ) ; if ( `` `` . equal ( prefix ) ) { set default element namespace ( n . get string value ( ) ) ; } else { declare namespace ( n . get local part ( ) , ns . get string value ( ) ) ; } } }
public x path context get x path context object ( ) { return context object ; }
public x path static context get static context ( ) { return static context ; }
public x path expression create pattern ( string pattern ) throw x path exception { pattern pat = pattern . make ( pattern , static context , static context . get executable ( ) ) ; expression visitor visitor = expression visitor . make ( static context ) ; pat . analyze ( visitor , type . node_type ) ; slot manager map = static context . get stack frame map ( ) ; int slot = map . get number of variable ( ) ; slot = pat . allocate slot ( static context , map , slot ) ; pattern sponsor sponsor = new pattern sponsor ( pat ) ; x path expression xpe = new x path expression ( this , sponsor ) ; xpe . set stack frame map ( map , slot ) ; return xpe ; }
public expression get internal expression ( ) { return expression ; }
public char sequence sub sequence ( int start , int end ) { return new char slice ( array , offset+start , end-start ) ; }
public fast string buffer uncompress ( fast string buffer buffer ) { if ( buffer == null ) { buffer = new fast string buffer ( length ( ) ) ; } uncompress ( value , buffer ) ; return buffer ; }
public string get u r i ( int index ) { return tree . get name pool ( ) . get u r i ( get name code ( index ) ) ; }
public final int get node kind ( ) { return type . attribute ; }
public int get line number ( ) { return get parent ( ) . get line number ( ) ; }
public int [ ] get size parameter ( ) { return new int [ ] { tree . number of node , tree . number of attribute , tree . number of namespaces , tree . get character buffer ( ) . length ( ) } ; }
void set unparsed entity ( string name , string uri , string public id ) { if ( entity table==null ) { entity table = new hash map ( 20 ) ; } string [ ] id = new string [ 2 ] ; id [ 0 ] = uri ; id [ 1 ] = public id ; entity table . put ( name , id ) ; }
public static void append string value ( tiny tree tree , int node nr , fast string buffer buffer ) { long value = ( ( long ) tree . alpha [ node nr ] < < 32 ) | ( ( long ) tree . beta [ node nr ] & 0xffffffff l ) ; compress whitespace . uncompress ( value , buffer ) ; }
public container get container ( ) { return container ; }
public static trace listener remove ( trace listener l , trace listener oldl ) { return ( trace listener ) remove internal ( l , oldl ) ; }
public void set body ( expression body ) { super . set body ( body ) ; use = body ; }
public structure q name get mode name ( ) { return mode name ; }
public x path exception make static ( ) { set be static error ( true ) ; return this ; }
public string get error code namespace ( ) { return error code namespace ; }
public list preprocess ( list source ) throw x path exception { return source ; }
public void set attribute ( string name , object value ) throw illegal argument exception { if ( name . equal ( feature key . configuration ) ) { config = ( configuration ) value ; } else { config . set configuration property ( name , value ) ; } }
public void generate id ( fast string buffer buffer ) { get parent ( ) . generate id ( buffer ) ; buffer . append ( ' a ' ) ; buffer . append ( integer . to string ( index ) ) ; }
public void replace string value ( char sequence string value ) { comment = string value . to string ( ) ; }
public void set line and column ( int sequence , int line , int column ) { if ( sequence number . length < = allocate + 1 ) { int [ ] s = new int [ allocate * 2 ] ; int [ ] l = new int [ allocate * 2 ] ; int [ ] c = new int [ allocate * 2 ] ; system . arraycopy ( sequence number , 0 , s , 0 , allocate ) ; system . arraycopy ( line number , 0 , l , 0 , allocate ) ; system . arraycopy ( column number , 0 , c , 0 , allocate ) ; sequence number = s ; line number = l ; column number = c ; } sequence number [ allocate ] = sequence ; line number [ allocate ] = line ; column number [ allocate ] = column ; allocated++ ; }
public string get system id ( ) { return system id ; }
public boolean be restrict ( ) { return false ; }
public boolean be primitive type ( ) { return false ; }
public boolean be order ( ) { return false ; }
public int get primitive type ( ) { return standard name . xs_any_atomic_type ; }
public boolean be namespace sensitive ( ) { return false ; }
public day time duration value subtract ( calendar value other , x path context context ) throw x path exception { date time value dt1 = to date time ( ) ; date time value dt2 = other . to date time ( ) ; if ( dt1 . get timezone in minute ( ) ! = dt2 . get timezone in minute ( ) ) { dt1 = dt1 . normalize ( context ) ; dt2 = dt2 . normalize ( context ) ; } big decimal d1 = dt1 . to julian instant ( ) ; big decimal d2 = dt2 . to julian instant ( ) ; big decimal difference = d1 . subtract ( d2 ) ; return day time duration value . from second ( difference ) ; }
public value reduce ( ) throw x path exception { return new sequence extent ( iterate ( ) ) . reduce ( ) ; }
public big decimal get decimal value ( ) throw x path exception { return ( ( decimal value ) convert primitive ( build in atomic type . decimal , true , null ) . a atomic ( ) ) . get decimal value ( ) ; }
public final string get clark name ( ) { return q name . get clark name ( ) ; }
public static int [ ] get structure version number ( ) { return structured_version ; }
public boolean be ( architecture compare with ) { return this . equal ( compare with ) ; }
public action release ( ) { return this . release ( null ) ; }
public action build ( ) { composite action to return = action ; reset composite action ( ) ; return to return ; }
public touch action long press ( web element on element ) { action . add action ( new long press action ( touch screen , ( locatable ) on element ) ) ; return this ; }
public static platform get current ( ) { return extract from sys property ( system . get property ( `` os . name `` ) ) ; }
public platform family ( ) { return any ; }
public string get ssl proxy ( ) { return ssl proxy ; }
public proxy set sock username ( string username ) { verify proxy type compatibility ( proxy type . manual ) ; this . proxy type = proxy type . manual ; this . sock username = username ; return this ; }
public proxy set sock password ( string password ) { verify proxy type compatibility ( proxy type . manual ) ; this . proxy type = proxy type . manual ; this . sock password = password ; return this ; }
public static command < application cache model > get application cache for frame ( frame id frame id ) { object . require non null ( frame id , `` frame id be require `` ) ; return new command < > ( `` application cache . get application cache for frame `` , immutable map . of ( `` frame id `` , frame id ) , map ( `` application cache `` , application cache model . class ) ) ; }
public static command < void > disable ( ) { return new command < > ( `` fetch . disable `` , immutable map . of ( ) ) ; }
public static command < void > continue with auth ( request id request id , auth challenge response auth challenge response ) { object . require non null ( request id , `` request id be require `` ) ; object . require non null ( auth challenge response , `` auth challenge response be require `` ) ; return new command < > ( `` fetch . continue with auth `` , immutable map . of ( `` request id `` , request id . to string ( ) , `` auth challenge response `` , auth challenge response ) ) ; }
public string get script id ( ) { return script id ; }
public double get line number ( ) { return line number ; }
public boolean get have post data ( ) { return have post data ; }
public request referrer policy get referrer policy ( ) { return referrer policy ; }
public string get url pattern ( ) { return url pattern ; }
public resource type get resource type ( ) { return resource type ; }
public double get push end ( ) { return push end ; }
public string get remote i p address ( ) { return remote i p address ; }
public list < string > get san list ( ) { return san list ; }
public integer get signature index ( ) { return signature index ; }
public string get cert sha256 ( ) { return cert sha256 ; }
public string get validity url ( ) { return validity url ; }
public monotonic time get date ( ) { return date ; }
public static event < request intercept > request intercept ( ) { return new event < > ( domain_name + `` . request intercept `` , map ( `` interception id `` , request intercept . class ) ) ; }
public static event < web socket frame error > web socket frame error ( ) { return new event < > ( domain_name + `` . web socket frame error `` , map ( `` request id `` , web socket frame error . class ) ) ; }
public static command < profile > stop ( ) { return new command < > ( `` profiler . stop `` , immutable map . of ( ) , map ( `` profile `` , profile . class ) ) ; }
public static event < receive message from target > receive message from target ( ) { return new event < > ( `` target . receive message from target `` , map ( `` session id `` , receive message from target . class ) ) ; }
public static event < target id > target destroyed ( ) { return new event < > ( `` target . target destroyed `` , map ( `` target id `` , target id . class ) ) ; }
protect reader only override this if you know what you be do ( ) { url resource = resource . get resource ( firefox profile . class , default prefs ) ; try { return new input stream reader ( resource . open stream ( ) ) ; } catch ( i o exception e ) { throw new web driver exception ( e ) ; } }
public void set preference ( string key , string value ) { additional prefs . set preference ( key , value ) ; }
public void set preference ( string key , boolean value ) { additional prefs . set preference ( key , value ) ; }
public http response set target host ( string host ) { set attribute ( http_target_host , host ) ; return this ; }
public opera option add extension ( list < file > path ) { for ( file path : path ) { check not null ( path ) ; check argument ( path . exists ( ) , `` % s do not exist `` , path . get absolute path ( ) ) ; check argument ( ! path . be directory ( ) , `` % s be a directory `` , path . get absolute path ( ) ) ; } extension file . add all ( path ) ; return this ; }
public object get experimental option ( string name ) { return experimental option . get ( check not null ( name ) ) ; }
protect string [ ] usual unix launcher location ( ) { return new string [ ] { `` /usr/bin `` , `` / applications/ google chrome . app/ contents/ mac o s `` , } ; }
public boolean be run ( ) { return process . be run ( ) ; }
public static file find system root ( ) { property p = load environment ( ) ; string system root path = p . get property ( `` system root `` ) ; if ( system root path == null ) { system root path = p . get property ( `` systemroot `` ) ; } if ( system root path == null ) { system root path = p . get property ( `` systemroot `` ) ; } if ( system root path == null ) { throw new runtime exception ( `` system root apparently not set ! `` ) ; } file system root = new file ( system root path ) ; if ( ! system root . exists ( ) ) { throw new runtime exception ( `` system root do n't exist : `` + system root path ) ; } return system root ; }
public void start ( ) throw i o exception { lock . lock ( ) ; try { if ( process ! = null ) { return ; } process = new command line ( this . executable , args . to array ( new string [ ] { } ) ) ; process . set environment variable ( environment ) ; process . copy output to ( system . err ) ; process . execute async ( ) ; wait until available ( ) ; } finally { lock . unlock ( ) ; } }
public string obtain loopback ip4 address ( ) { final network interface network interface = get loop back and ip4 only ( ) ; if ( network interface ! = null ) { return network interface . get ip4 loopback only ( ) . get host name ( ) ; } final string ip of ip4 loop back = get ip of loop back ip4 ( ) ; if ( ip of ip4 loop back ! = null ) { return ip of ip4 loop back ; } if ( platform . get current ( ) . be ( platform . unix ) ) { network interface linux loopback = network interface provider . get lo interface ( ) ; if ( linux loopback ! = null ) { final inet address net address = linux loopback . get ip4 loopback only ( ) ; if ( net address ! = null ) { return net address . get host address ( ) ; } } } throw new web driver exception ( `` unable to resolve local loopback address , please file an issue with the full message of this error : \n `` + get net work diags ( ) + `` \n==== end of error message `` ) ; }
public remote web driver builder one of ( capability maybe this , capability . . . or one of these ) { option . clear ( ) ; add alternative ( maybe this ) ; for ( capability an or one of these : or one of these ) { add alternative ( an or one of these ) ; } return this ; }
public remote web driver builder add alternative ( capability option ) { map < string , object > serialize = validate ( object . require non null ( option ) ) ; this . option . add ( serialize ) ; return this ; }
public iterable < desire capability > get desire capability ( ) { lock . read lock ( ) . lock ( ) ; try { return new session request . stream ( ) . map ( req - > new desire capability ( req . get request ( ) . get desired capability ( ) ) ) . collect ( collector . to list ( ) ) ; } finally { lock . read lock ( ) . unlock ( ) ; } }
public integer get clean up cycle ( ) { return clean up cycle ; }
protect long sleep for ( ) { return 250 ; }
public list < web element > find element ( ) { if ( cache element list ! = null & & should cache ( ) ) { return cache element list ; } list < web element > element = search context . find element ( by ) ; if ( should cache ( ) ) { cache element list = element ; } return element ; }
public static expect condition < boolean > url match ( final string regex ) { return new expect condition < boolean > ( ) { private string current url ; private pattern pattern ; private matcher matcher ; @ override public boolean apply ( web driver driver ) { current url = driver . get current url ( ) ; pattern = pattern . compile ( regex ) ; matcher = pattern . matcher ( current url ) ; return matcher . find ( ) ; } @ override public string to string ( ) { return string . format ( `` url to match the regex \ `` % s\ `` . current url : \ `` % s\ `` `` , regex , current url ) ; } } ; }
public static expect condition < list < web element > > visibility of all element locate by ( final by locator ) { return new expect condition < list < web element > > ( ) { @ override public list < web element > apply ( web driver driver ) { list < web element > element = driver . find element ( locator ) ; for ( web element element : element ) { if ( ! element . be display ( ) ) { return null ; } } return element . size ( ) > 0 ? element : null ; } @ override public string to string ( ) { return `` visibility of all element locate by `` + locator ; } } ; }
public static expect condition < boolean > attribute to be ( final by locator , final string attribute , final string value ) { return new expect condition < boolean > ( ) { private string current value = null ; @ override public boolean apply ( web driver driver ) { web element element = driver . find element ( locator ) ; current value = element . get attribute ( attribute ) ; if ( current value == null||current value . be empty ( ) ) { current value = element . get css value ( attribute ) ; } return value . equal ( current value ) ; } @ override public string to string ( ) { return string . format ( `` element find by % s to have value \ `` % s\ `` . current value : \ `` % s\ `` `` , locator , value , current value ) ; } } ; }
public static expect condition < list < web element > > number of element to be ( final by locator , final integer number ) { return new expect condition < list < web element > > ( ) { private integer current number = 0 ; @ override public list < web element > apply ( web driver web driver ) { list < web element > element = web driver . find element ( locator ) ; current number = element . size ( ) ; return current number . equal ( number ) ? element : null ; } @ override public string to string ( ) { return string . format ( `` number of element find by % s to be \ `` % s\ `` . current number : \ `` % s\ `` `` , locator , number , current number ) ; } } ; }
public static expect condition < boolean > invisibility of ( final web element element ) { return new expect condition < boolean > ( ) { @ override public boolean apply ( web driver web driver ) { return be invisible ( element ) ; } @ override public string to string ( ) { return `` invisibility of `` + element ; } } ; }
public static boolean be primitive datatype ( uri datatype ) { return datatype . equal ( x m l schema . duration ) || datatype . equal ( x m l schema . datetime ) || datatype . equal ( x m l schema . time ) || datatype . equal ( x m l schema . date ) || datatype . equal ( x m l schema . gyearmonth ) || datatype . equal ( x m l schema . gyear ) || datatype . equal ( x m l schema . gmonthday ) || datatype . equal ( x m l schema . gday ) || datatype . equal ( x m l schema . gmonth ) || datatype . equal ( x m l schema . string ) || datatype . equal ( x m l schema . boolean ) || datatype . equal ( x m l schema . base64binary ) || datatype . equal ( x m l schema . hexbinary ) || datatype . equal ( x m l schema . float ) || datatype . equal ( x m l schema . decimal ) || datatype . equal ( x m l schema . double ) || datatype . equal ( x m l schema . anyuri ) || datatype . equal ( x m l schema . qname ) || datatype . equal ( x m l schema . notation ) ; }
public static boolean be valid g year month ( string value ) { string regex = `` - ? \\d\\d\\d\\d-\\d\\d ( z| ( \\+|- ) \\d\\d : \\d\\d ) ? `` ; if ( value . match ( regex ) ) { return be valid calendar value ( value ) ; } else { return false ; } }
public static string normalize unsigned short ( string value ) { return normalize integer value ( value , `` 0 `` , `` 65535 `` ) ; }
public static int compare integer ( string int1 , string int2 ) { int1 = normalize integer ( int1 ) ; int2 = normalize integer ( int2 ) ; return compare canonical integer ( int1 , int2 ) ; }
public static uri qname to u r i ( q name qname ) { if ( datatype constant . datetime . equal ( qname ) ) { return x m l schema . datetime ; } else if ( datatype constant . date . equal ( qname ) ) { return x m l schema . date ; } else if ( datatype constant . time . equal ( qname ) ) { return x m l schema . time ; } else if ( datatype constant . gyearmonth . equal ( qname ) ) { return x m l schema . gyearmonth ; } else if ( datatype constant . gmonthday . equal ( qname ) ) { return x m l schema . gmonthday ; } else if ( datatype constant . gyear . equal ( qname ) ) { return x m l schema . gyear ; } else if ( datatype constant . gmonth . equal ( qname ) ) { return x m l schema . gmonth ; } else if ( datatype constant . gday . equal ( qname ) ) { return x m l schema . gday ; } else if ( datatype constant . duration . equal ( qname ) ) { return x m l schema . duration ; } else { throw new illegal argument exception ( `` q name can not be map to an xml schema uri : `` + qname . to string ( ) ) ; } }
public boolean be normalize ( ) { return be normalize ; }
public string to string ( ) { string builder sb = new string builder ( 256 ) ; sb . append ( `` ( `` ) ; sb . append ( get subject ( ) ) ; sb . append ( `` , `` ) ; sb . append ( get predicate ( ) ) ; sb . append ( `` , `` ) ; sb . append ( get object ( ) ) ; sb . append ( `` ) `` ) ; return sb . to string ( ) ; }
public static boolean get boolean value ( literal l , boolean fallback ) { try { return l . boolean value ( ) ; } catch ( illegal argument exception e ) { return fallback ; } }
public void clear ( ) { statement . clear ( ) ; }
public collection < statement > get statement ( ) { return statement ; }
protect void set base u r i ( parse u r i base u r i ) { this . base u r i = base u r i ; }
public static r d f format for file name ( string file name , r d f format fallback ) { return match file name ( file name , rdf_formats , fallback ) ; }
public boolean get parse stand alone document ( ) { return get parser config ( ) . get ( x m l parser setting . parse_standalone_documents ) ; }
public static byte [ ] get ( byte [ ] array , int offset , int length ) { byte [ ] result = new byte [ length ] ; system . arraycopy ( array , offset , result , 0 , length ) ; return result ; }
public static int compare region ( byte [ ] array1 , int start idx1 , byte [ ] array2 , int start idx2 , int length ) { int result = 0 ; for ( int i = 0 ; result == 0 & & i < length ; i++ ) { result = ( array1 [ start idx1 + i ] & 0xff ) - ( array2 [ start idx2 + i ] & 0xff ) ; } return result ; }
public static string to hex string ( byte [ ] array ) { string builder sb = new string builder ( 2 * array . length ) ; for ( int i = 0 ; i < array . length ; i++ ) { string hex = integer . to hex string ( array [ i ] & 0xff ) ; if ( hex . length ( ) == 1 ) { sb . append ( ' 0 ' ) ; } sb . append ( hex ) ; } return sb . to string ( ) ; }
public boolean have default file extension ( string extension ) { string ext = get default file extension ( ) ; return ext ! = null & & ext . equal ignore case ( extension ) ; }
public ff get file format for file name ( string file name , ff fallback ) { return file format . match file name ( file name , this . get key ( ) , fallback ) ; }
public static string escape text ( string text ) { string result = string util . gsub ( `` & `` , `` & amp ; `` , text ) ; result = string util . gsub ( `` < `` , `` & lt ; `` , result ) ; result = string util . gsub ( `` > `` , `` & gt ; `` , result ) ; return result ; }
public static < t extend descriptor > t create ( final class < t > type ) throw illegal argument exception { return create ( type , null ) ; }
public static archive path get path for classloader resource ( string resource name ) { string extract path = null ; if ( resource name . last index of ( '/ ' ) ! = -1 ) { extracted path = resource name . substring ( 0 , resource name . last index of ( '/ ' ) ) ; } return new basic path ( extracted path ) ; }
public static void copy with close ( input stream input , output stream output ) throw i o exception { try { copy ( input , output ) ; } finally { try { input . close ( ) ; } catch ( final i o exception ignore ) { if ( log . be loggable ( level . finer ) ) { log . finer ( `` could not close stream due to : `` + ignore . get message ( ) + `` ; ignore `` ) ; } } try { output . close ( ) ; } catch ( final i o exception ignore ) { if ( log . be loggable ( level . finer ) ) { log . finer ( `` could not close stream due to : `` + ignore . get message ( ) + `` ; ignore `` ) ; } } } }
public void set u s tar format ( ) { this . ustar format = true ; this . gnu format = false ; this . unix format = false ; }
public void name tar header ( tar header hdr , string name ) { boolean be dir = name . end with ( `` / `` ) ; this . gnu format = false ; this . ustar format = true ; this . unix format = false ; hdr . check sum = 0 ; hdr . dev major = 0 ; hdr . dev minor = 0 ; hdr . name = new string buffer ( name ) ; hdr . mode = be dir ? 040755 : 0100644 ; hdr . user id = 0 ; hdr . group id = 0 ; hdr . size = 0 ; hdr . check sum = 0 ; hdr . mod time = ( new java . util . date ( ) ) . get time ( ) / 1000 ; hdr . link flag = be dir ? tar header . lf_dir : tar header . lf_normal ; hdr . link name = new string buffer ( `` `` ) ; hdr . user name = new string buffer ( `` `` ) ; hdr . group name = new string buffer ( `` `` ) ; hdr . dev major = 0 ; hdr . dev minor = 0 ; }
public void remove child ( node node ) { validate . not null ( node , `` no node be specify `` ) ; child . remove ( node ) ; }
public double get ( ) { return no label child . get ( ) ; }
public static builder build ( ) { return new builder ( ) ; }
public child label ( string . . . label value ) { if ( label value . length ! = label name . size ( ) ) { throw new illegal argument exception ( `` incorrect number of label . `` ) ; } for ( string label : label value ) { if ( label == null ) { throw new illegal argument exception ( `` label can not be null . `` ) ; } } list < string > key = array . a list ( label value ) ; child c = child . get ( key ) ; if ( c ! = null ) { return c ; } child c2 = new child ( ) ; child tmp = child . put if absent ( key , c2 ) ; return tmp == null ? c2 : tmp ; }
public void set tag ( tag tag ) { this . tag = tag ; }
public t load ( string yaml ) { return ( t ) loader . load ( new string reader ( yaml ) ) ; }
public iterable < object > load all ( reader yaml ) { return loader . load all ( yaml ) ; }
public static int compress ( byte [ ] input , int input offset , int input length , byte [ ] output , int output offset ) throw i o exception { return raw compress ( input , input offset , input length , output , output offset ) ; }
public static boolean be valid compress buffer ( byte [ ] input , int offset , int length ) throw i o exception { if ( input == null ) throw new null pointer exception ( `` input be null `` ) ; return impl . be valid compress buffer ( input , offset , length ) ; }
public static char [ ] uncompress char array ( byte [ ] input , int offset , int length ) throw i o exception { int uncompressed length = snappy . uncompressed length ( input , offset , length ) ; char [ ] result = new char [ uncompressed length / 2 ] ; int byte size = impl . raw uncompress ( input , offset , length , result , 0 ) ; return result ; }
public static int uncompressed length ( byte [ ] input ) throw i o exception { return impl . uncompressed length ( input , 0 , input . length ) ; }
public static float [ ] uncompress float array ( byte [ ] input ) throw i o exception { return uncompress float array ( input , 0 , input . length ) ; }
public static string uncompress string ( byte [ ] input ) throw i o exception { try { return uncompress string ( input , `` utf-8 `` ) ; } catch ( unsupported encode exception e ) { throw new illegal state exception ( `` utf-8 decoder be not find `` ) ; } }
public int raw read ( object array , int byte offset , int byte length ) throw i o exception { int write bytes = 0 ; for ( ; write bytes < byte length ; ) { if ( uncompressed cursor > = uncompressed limit ) { if ( have next chunk ( ) ) continue ; else { return write bytes == 0 ? -1 : write bytes ; } } int byte to write = math . min ( uncompressed limit - uncompressed cursor , byte length - write byte ) ; snappy . array copy ( uncompressed , uncompressed cursor , bytes to write , array , byte offset + write bytes ) ; write bytes += byte to write ; uncompressed cursor += bytes to write ; } return write byte ; }
public void map ( class < ? extend exception > exception class , exception handler impl handler ) { this . exception map . put ( exception class , handler ) ; }
public < t > t attribute ( string attribute ) { return ( t ) servlet request . get attribute ( attribute ) ; }
public static string add path ( string segment1 , string segment2 ) { if ( segment1 == null || segment1 . length ( ) == 0 ) { if ( segment1 ! = null & & segment2 == null ) { return segment1 ; } return segment2 ; } if ( segment2 == null || segment2 . length ( ) == 0 ) { return segment1 ; } int split = segment1 . index of ( ' ; ' ) ; if ( split < 0 ) { split = segment1 . index of ( ' ? ' ) ; } if ( split == 0 ) { return segment2 + segment1 ; } if ( split < 0 ) { split = segment1 . length ( ) ; } string builder buf = new string builder ( segment1 . length ( ) + segment2 . length ( ) + 2 ) ; buf . append ( segment1 ) ; if ( buf . char at ( split - 1 ) == '/ ' ) { if ( segment2 . start with ( slash ) ) { buf . delete char at ( split - 1 ) ; buf . insert ( split - 1 , segment2 ) ; } else { buf . insert ( split , segment2 ) ; } } else { if ( segment2 . start with ( slash ) ) { buf . insert ( split , segment2 ) ; } else { buf . insert ( split , '/ ' ) ; buf . insert ( split + 1 , segment2 ) ; } } return buf . to string ( ) ; }
public void post ( string path , route route ) { add route ( http method . post . name ( ) , route impl . create ( path , route ) ) ; }
public void trace ( string path , route route ) { add route ( http method . trace . name ( ) , route impl . create ( path , route ) ) ; }
public void option ( string path , route route ) { add route ( http method . option . name ( ) , route impl . create ( path , route ) ) ; }
public void web socket ( string path , class < ? > handler class ) { add web socket handler ( path , new web socket handler class wrapper ( handler class ) ) ; }
public synchronize void configure ( string folder ) { assert . not null ( folder , `` 'folder ' must not be null `` ) ; if ( ! static resource set ) { try { class path resource resource = new class path resource ( folder ) ; if ( configure jar case ( folder , resource ) ) { return ; } if ( ! resource . get file ( ) . be directory ( ) ) { log . error ( `` static resource location must be a folder `` ) ; return ; } if ( static resource handler == null ) { static resource handler = new array list < > ( ) ; } static resource handler . add ( new class path resource handler ( folder , `` index . html `` ) ) ; log . info ( `` static resource handler configure with folder = `` + folder ) ; } catch ( i o exception e ) { log . error ( `` error when create static resource handler `` , e ) ; } static resource set = true ; } }
public model and view model and view ( object model , string view name ) { return new model and view ( model , view name ) ; }
public void spill ( ) throw i o exception { spill ( long . max_value , this ) ; }
public void on event ( spark listener event event ) { }
public spark launcher set deploy mode ( string mode ) { check not null ( mode , `` mode `` ) ; builder . deploy mode = mode ; return this ; }
public spark launcher add spark arg ( string arg ) { spark submit option parser validator = new argument validator ( false ) ; validator . parse ( arrays . a list ( arg ) ) ; builder . spark args . add ( arg ) ; return this ; }
public spark launcher add app args ( string . . . args ) { for ( string arg : args ) { check not null ( arg , `` arg `` ) ; builder . app args . add ( arg ) ; } return this ; }
public spark launcher redirect error ( ) { redirect error stream = true ; return this ; }
public spark launcher redirect error ( file err file ) { error stream = process builder . redirect . to ( err file ) ; return this ; }
public long send rpc ( byte buffer message , rpc response callback callback ) { long start time = system . current time millis ( ) ; if ( logger . be trace enable ( ) ) { logger . trace ( `` send rpc to { } `` , get remote address ( channel ) ) ; } long request id = math . ab ( uuid . random u u i d ( ) . get least significant bit ( ) ) ; handler . add rpc request ( request id , callback ) ; channel . write and flush ( new rpc request ( request id , new nio manage buffer ( message ) ) ) . add listener ( future - > { if ( future . be success ( ) ) { long time take = system . current time millis ( ) - start time ; if ( logger . be trace enable ( ) ) { logger . trace ( `` send request { } to { } take { } m `` , request id , get remote address ( channel ) , time take ) ; } } else { string error msg = string . format ( `` fail to send rpc % s to % s : % s `` , request id , get remote address ( channel ) , future . cause ( ) ) ; logger . error ( error msg , future . cause ( ) ) ; handler . remove rpc request ( request id ) ; channel . close ( ) ; try { callback . on failure ( new i o exception ( error msg , future . cause ( ) ) ) ; } catch ( exception e ) { logger . error ( `` uncaught exception in rpc response callback handler ! `` , e ) ; } } } ) ; return request id ; }
public object get negotiate property ( string name ) { return sasl client . get negotiated property ( name ) ; }
public synchronize boolean be complete ( ) { return sasl server ! = null & & sasl server . be complete ( ) ; }
public synchronize byte [ ] response ( byte [ ] token ) { try { return sasl server ! = null ? sasl server . evaluate response ( token ) : new byte [ 0 ] ; } catch ( sasl exception e ) { throw throwables . propagate ( e ) ; } }
public void channel inactive ( transport client client ) { }
public transport client factory create client factory ( list < transport client bootstrap > bootstrap ) { return new transport client factory ( this , bootstrap ) ; }
public static void close quietly ( closeable closeable ) { try { if ( closeable ! = null ) { closeable . close ( ) ; } } catch ( i o exception e ) { logger . error ( `` i o exception should not have be throw . `` , e ) ; } }
public static byte [ ] buffer to array ( byte buffer buffer ) { if ( buffer . have array ( ) & & buffer . array offset ( ) == 0 & & buffer . array ( ) . length == buffer . remain ( ) ) { return buffer . array ( ) ; } else { byte [ ] bytes = new byte [ buffer . remain ( ) ] ; buffer . get ( byte ) ; return byte ; } }
public static void check version ( db db , store version newversion , object mapper mapper ) throw i o exception { byte [ ] bytes = db . get ( store version . key ) ; if ( bytes == null ) { store version ( db , newversion , mapper ) ; } else { store version version = mapper . read value ( byte , store version . class ) ; if ( version . major ! = newversion . major ) { throw new i o exception ( `` can not read state db with version `` + version + `` , incompatible `` + `` with current version `` + newversion ) ; } store version ( db , newversion , mapper ) ; } }
public string key factory algorithm ( ) { return conf . get ( `` spark . network . crypto . key factory algorithm `` , `` p b k d f2 with hmac s h a1 `` ) ; }
public int max sasl encrypt block size ( ) { return ints . check cast ( java utils . byte string a byte ( conf . get ( `` spark . network . sasl . max encrypt block size `` , `` 64k `` ) ) ) ; }
public boolean sasl server always encrypt ( ) { return conf . get boolean ( `` spark . network . sasl . server always encrypt `` , false ) ; }
public void init ( string app id ) { }
public static u t f8 string blank string ( int length ) { byte [ ] space = new byte [ length ] ; array . fill ( space , ( byte ) ' ' ) ; return from byte ( space ) ; }
public double norm x ( double x ) { return shape factory . norm x ( x ) ; }
public rectangle make rectangle ( double min x , double max x , double min y , double max y ) { return shape factory . rect ( min x , max x , min y , max y ) ; }
public shape read shape ( string value ) throw invalid shape exception { return format . read ( value ) ; }
public static string encode lat lon ( double latitude , double longitude ) { return encode lat lon ( latitude , longitude , 12 ) ; }
public static point decode ( string geohash , spatial context ctx ) { rectangle rect = decode boundary ( geohash , ctx ) ; double latitude = ( rect . get min y ( ) + rect . get max y ( ) ) / 2d ; double longitude = ( rect . get min x ( ) + rect . get max x ( ) ) / 2d ; return ctx . make point ( longitude , latitude ) ; }
protect double get x axis ( ) { return point . get x ( ) ; }
public void index ( ) { if ( prepared geometry == null ) prepare geometry = prepare geometry factory . prepare ( geom ) ; }
public double value ( ) { return value ; }
protect void do set value ( prepared statement p , int parameter position , object arg value ) throw s q l exception { if ( arg value instanceof sql parameter value ) { sql parameter value param value = ( sql parameter value ) arg value ; statement creator utils . set parameter value ( ps , parameter position , param value , param value . get value ( ) ) ; } else { statement creator utils . set parameter value ( ps , parameter position , sql type value . type_unknown , arg value ) ; } }
public void set fetch size ( int fetch size ) { this . fetch size = fetch size ; }
public string get catalog name ( ) { return this . catalog name ; }
public boolean be return value require ( ) { return this . return value require ; }
public void set name binding ( boolean name binding ) { this . name bind = name binding ; }
public boolean be name binding ( ) { return this . name binding ; }
public boolean be function ( ) { return this . function ; }
public boolean be nullable ( ) { return this . nullable ; }
protect boolean be store low case identifier ( ) { return this . store low case identifier ; }
public boolean be override include synonyms default ( ) { return this . override include synonyms default ; }
public string [ ] get readable property name ( ) { if ( this . property name == null ) { list < string > name = new array list < > ( ) ; property descriptor [ ] prop = this . bean wrapper . get property descriptor ( ) ; for ( property descriptor pd : prop ) { if ( this . bean wrapper . be readable property ( pd . get name ( ) ) ) { name . add ( pd . get name ( ) ) ; } } this . property name = string utils . to string array ( name ) ; } return this . property name ; }
protect void init template config ( ) { jdbc template jdbc template = get jdbc template ( ) ; if ( jdbc template ! = null ) { this . name parameter jdbc template = new name parameter jdbc template ( jdbc template ) ; } }
public row callback handler get row callback handler ( ) { return this . row callback handler ; }
public boolean be compile ( ) { return this . compile ; }
protected list < sql parameter > get call parameter ( ) { return this . call meta data context . get call parameter ( ) ; }
public void set catalog name ( @ nullable string catalog name ) { check if configuration modification be allow ( ) ; this . table meta data context . set catalog name ( catalog name ) ; }
public list < string > get column name ( ) { return collection . unmodifiable list ( this . declared column ) ; }
public string [ ] get generate key name ( ) { return this . generate key name ; }
protect final void release connection ( connection con ) { data source utils . release connection ( con , get data source ( ) ) ; }
protect void set connection ( @ nullable connection connection ) { if ( this . current connection ! = null ) { if ( this . connection handle ! = null ) { this . connection handle . release connection ( this . current connection ) ; } this . current connection = null ; } if ( connection ! = null ) { this . connection handle = new simple connection handle ( connection ) ; } else { this . connection handle = null ; } }
public boolean be enforce read only ( ) { return this . enforce read only ; }
public embed database builder add default script ( ) { return add script ( `` schema . sql `` , `` data . sql `` ) ; }
public void set separator ( string separator ) { this . separator = separator ; }
public void set block comment start delimiter ( string block comment start delimiter ) { assert . have text ( block comment start delimiter , `` 'block comment start delimiter ' must not be null or empty `` ) ; this . block comment start delimiter = block comment start delimiter ; }
protect boolean get current read only flag ( ) { boolean tx read only = transaction synchronization manager . be current transaction read only ( ) ; return ( tx read only ? boolean . true : null ) ; }
public void set default auto commit ( boolean default auto commit ) { this . default auto commit = default auto commit ; }
protect object resolve specify lookup key ( object lookup key ) { return lookup key ; }
public void set schema ( string schema ) { this . schema = schema ; }
public int get actual count ( ) { return this . actual count ; }
public void set batch size ( int batch size ) { this . batch size = batch size ; }
public string get sql ( ) { return this . sql ; }
protect string resolve sql ( ) { string sql = get sql ( ) ; assert . state ( sql ! = null , `` no sql set `` ) ; return sql ; }
public void declare parameter ( sql parameter param ) throw invalid data access api usage exception { if ( be compile ( ) ) { throw new invalid data access api usage exception ( `` can not add parameter once the query be compile `` ) ; } this . declared parameter . add ( param ) ; }
protect callable statement creator new callable statement creator ( parameter mapper in param mapper ) { assert . state ( this . callable statement factory ! = null , `` no callable statement factory available `` ) ; return this . callable statement factory . new callable statement creator ( in param mapper ) ; }
public int get row expect ( ) { return this . row expect ; }
public t find object ( int p1 , @ nullable map < ? , ? > context ) throw data access exception { return find object ( new object [ ] { p1 } , context ) ; }
public t find object ( string p1 , @ nullable map < ? , ? > context ) throw data access exception { return find object ( new object [ ] { p1 } , context ) ; }
public void set require row affect ( int require row affect ) { this . require row affect = require row affect ; }
public int update ( long p1 ) throw data access exception { return update ( new object [ ] { p1 } ) ; }
public int update ( long p1 , long p2 ) throw data access exception { return update ( new object [ ] { p1 , p2 } ) ; }
public class < ? > get exception class ( ) { return this . exception class ; }
public void set column name ( string column name ) { this . column name = column name ; }
public void set cache size ( int cache size ) { this . cache size = cache size ; }
public void set database product name ( string db name ) { if ( ! should ignore xml ) { this . exception translator = new s q l error code s q l exception translator ( db name ) ; } }
public void set database product name ( @ nullable string database product name ) { this . database product name = new string [ ] { database product name } ; }
public void set repository annotation type ( class < ? extend annotation > repository annotation type ) { assert . not null ( repository annotation type , `` 'repository annotation type ' must not be null `` ) ; this . repository annotation type = repository annotation type ; }
public void set target connection factory ( @ nullable connection factory target connection factory ) { this . target connection factory = target connection factory ; }
public void init connection ( ) throw resource exception { if ( get target connection factory ( ) == null ) { throw new illegal state exception ( `` 'target connection factory ' be require for lazily initialize a connection `` ) ; } synchronize ( this . connection monitor ) { if ( this . target ! = null ) { close connection ( this . target ) ; } this . target = do create connection ( ) ; prepare connection ( this . target ) ; if ( logger . be debug enable ( ) ) { logger . debug ( `` establish share cci connection : `` + this . target ) ; } this . connection = get close suppressing connection proxy ( this . target ) ; } }
protect connection do create connection ( ) throw resource exception { connection factory connection factory = get target connection factory ( ) ; assert . state ( connection factory ! = null , `` no 'target connection factory ' set `` ) ; return connection factory . get connection ( ) ; }
public cci template get derive template ( connection spec connection spec ) { cci template derive = new cci template ( obtain connection factory ( ) , connection spec ) ; record creator record creator = get output record creator ( ) ; if ( record creator ! = null ) { derive . set output record creator ( record creator ) ; } return derive ; }
protect org . springframework . jca . cci . core . cci template create cci template ( connection factory connection factory ) { return new org . springframework . jca . cci . core . cci template ( connection factory ) ; }
public void set context config location ( string context config location ) { this . context config location = context config location ; }
public void set transaction factory ( transaction factory transaction factory ) { this . transaction factory = transaction factory ; }
public activation spec get activation spec ( ) { return this . activation spec ; }
public int get phase ( ) { return this . phase ; }
public void set resource adapter ( resource adapter resource adapter ) { this . resource adapter = resource adapter ; }
public void run ( ) { this . delegate . run ( ) ; }
public void release ( ) { }
public void set bootstrap context ( bootstrap context bootstrap context ) { assert . not null ( bootstrap context , `` bootstrap context must not be null `` ) ; this . work manager = bootstrap context . get work manager ( ) ; }
public void set work listener ( @ nullable work listener work listener ) { this . work listener = work listener ; }
public transaction phase get transaction phase ( ) { return this . transaction phase ; }
public void set listener id ( string listener id ) { this . listener id = listener id ; }
protect final string get transaction manager bean name ( ) { return this . transaction manager bean name ; }
public void set transaction attribute source ( @ nullable transaction attribute source transaction attribute source ) { this . transaction attribute source = transaction attribute source ; }
public void after property set ( ) { if ( get transaction manager ( ) == null & & this . bean factory == null ) { throw new illegal state exception ( `` set the 'transaction manager ' property or make sure to run within a bean factory `` + `` contain a transaction manager bean ! `` ) ; } if ( get transaction attribute source ( ) == null ) { throw new illegal state exception ( `` either 'transaction attribute source ' or 'transaction attribute ' be require : `` + `` if there be no transactional method , then do n't use a transaction aspect . `` ) ; } }
public void set user transaction ( @ nullable user transaction user transaction ) { this . user transaction = user transaction ; }
public void set autodetect user transaction ( boolean autodetect user transaction ) { this . autodetect user transaction = autodetect user transaction ; }
public void set transaction synchronization registry name ( string transaction synchronization registry name ) { this . transaction synchronization registry name = transaction synchronization registry name ; }
public void set allow custom isolation level ( boolean allow custom isolation level ) { this . allow custom isolation level = allow custom isolation level ; }
protect user transaction retrieve user transaction ( ) throw transaction system exception { return null ; }
protect boolean use savepoint for nested transaction ( ) { return false ; }
public final user transaction get user transaction ( ) { return this . user transaction ; }
public void set uow manager name ( string uow manager name ) { this . uow manager name = uow manager name ; }
public boolean be new synchronization ( ) { return this . new synchronization ; }
public reactive transaction manager get transaction manager ( ) { return this . transaction manager ; }
public boolean be synchronization active ( ) { return ( this . transaction context . get synchronization ( ) ! = null ) ; }
public void set current transaction name ( @ nullable string name ) { this . transaction context . set current transaction name ( name ) ; }
public final void set transaction synchronization ( int transaction synchronization ) { this . transaction synchronization = transaction synchronization ; }
public final int get transaction synchronization ( ) { return this . transaction synchronization ; }
public boolean be rollback only ( ) { return ( be local rollback only ( ) || be global rollback only ( ) ) ; }
public void flush ( ) { if ( this . transaction instanceof smart transaction object ) { ( ( smart transaction object ) this . transaction ) . flush ( ) ; } }
public long get time to live in millis ( ) throw transaction time out exception { if ( this . deadline == null ) { throw new illegal state exception ( `` no timeout specify for this resource holder `` ) ; } long time to live = this . deadline . get time ( ) - system . current time millis ( ) ; check transaction timeout ( time to live < = 0 ) ; return time to live ; }
public void clear ( ) { this . synchronize with transaction = false ; this . rollback only = false ; this . deadline = null ; }
public static final void clamp ( byte [ ] k ) { k [ 31 ] & = 0x7 f ; k [ 31 ] |= 0x40 ; k [ 0 ] & = 0x f8 ; }
public void deliver error ( throwable e ) { lock . lock ( ) ; try { pending ex = chainer . chain ( e ) ; cond . signal all ( ) ; } finally { lock . unlock ( ) ; } }
public byte [ ] read byte ( ) throw buffer exception { int len = read u int32 a int ( ) ; if ( len < 0 || len > 32768 ) throw new buffer exception ( `` bad item length : `` + len ) ; byte [ ] b = new byte [ len ] ; read raw byte ( b ) ; return b ; }
public void listen ( ) throw i o exception { listen ( thread . current thread ( ) ) ; }
public void set remote charset ( charset remote charset ) { this . remote charset = remote charset ! = null ? remote charset : i o utils . utf8 ; }
public static parse pub key init pub key ( reader public key ) throw i o exception { final buffer reader br = new buffer reader ( public key ) ; try { string keydata ; while ( ( keydata = br . read line ( ) ) ! = null ) { keydata = keydata . trim ( ) ; if ( ! keydata . be empty ( ) ) { string [ ] part = keydata . trim ( ) . split ( `` \\s+ `` ) ; if ( part . length > = 2 ) { return new parse pub key ( key type . from string ( part [ 0 ] ) , new buffer . plain buffer ( base64 . decode ( part [ 1 ] ) ) . read public key ( ) ) ; } else { throw new i o exception ( `` get line with only one column `` ) ; } } } throw new i o exception ( `` public key file be blank `` ) ; } finally { br . close ( ) ; } }
public p e m key pair get key pair ( final private key info private key info ) throw i o exception { object . require non null ( private key info , `` private key info require `` ) ; final algorithm identifier algorithm identifier = private key info . get private key algorithm ( ) ; final a s n1 object identifier algorithm = algorithm identifier . get algorithm ( ) ; if ( x9 object identifier . id_dsa . equal ( algorithm ) ) { logger . debug ( `` dsa algorithm find [ { } ] `` , algorithm ) ; } else { throw new illegal argument exception ( string . format ( `` dsa algorithm oid require [ % s ] `` , algorithm ) ) ; } final a s n1 integer encode public key = get encode public key ( private key info ) ; final subject public key info subject public key info = new subject public key info ( algorithm identifier , encode public key ) ; return new p e m key pair ( subject public key info , private key info ) ; }
public static byte [ ] to byte array ( char [ ] password ) { char buffer char buffer = char buffer . wrap ( password ) ; return standard charsets . utf_8 . encode ( char buffer ) . array ( ) ; }
public static string replace escaped right angle ( string s ) { string builder buf = new string builder ( ) ; int i = 0 ; while ( i < s . length ( ) ) { char c = s . char at ( i ) ; if ( c== ' < ' & & s . substring ( i ) . start with ( `` < \\\\ > `` ) ) { buf . append ( `` < \\\\ > `` ) ; i += `` < \\\\ > `` . length ( ) ; continue ; } if ( c== ' > ' & & s . substring ( i ) . start with ( `` > \\ > `` ) ) { buf . append ( `` > > `` ) ; i += `` > \\ > `` . length ( ) ; continue ; } if ( c=='\\ ' & & s . substring ( i ) . start with ( `` \\ > > `` ) & & ! s . substring ( i ) . start with ( `` \\ > > > `` ) ) { buf . append ( `` > > `` ) ; i += `` \\ > > `` . length ( ) ; continue ; } buf . append ( c ) ; i++ ; } return buf . to string ( ) ; }
public void register model adaptor ( class < ? > attribute type , model adaptor adaptor ) { if ( attribute type . be primitive ( ) ) { throw new illegal argument exception ( `` ca n't register model adaptor for primitive type `` + attribute type . get simple name ( ) ) ; } adaptor . put ( attribute type , adaptor ) ; }
public void bridge ( x m l stream reader in , x m l stream writer out ) throw x m l stream exception { bridge ( in , out , null ) ; }
public static int compute best k ( int bucket per element ) { assert bucket per element > = 0 ; if ( bucket per element > = opt k per bucket . length ) { return opt k per bucket [ opt k per bucket . length - 1 ] ; } return opt k per bucket [ bucket per element ] ; }
public static set < string > non system type ( ) { return non system type ; }
public static class < ? > load class by name ( string class name ) throw class not find exception { try { return class . for name ( class name ) ; } catch ( class not find exception e ) { return thread . current thread ( ) . get context class loader ( ) . load class ( class name ) ; } }
public static list < parameter > collect constructor parameter ( class < ? > cl , component component , javax . w . r . consumes class consumes , json view json view annotation ) { if ( cl . be local class ( ) || ( cl . be member class ( ) & & ! modifier . be static ( cl . get modifier ( ) ) ) ) { return collection . empty list ( ) ; } list < parameter > select = collection . empty list ( ) ; int max params count = 0 ; for ( constructor < ? > constructor : cl . get declared constructor ( ) ) { if ( ! reflection utils . be constructor compatible ( constructor ) & & ! reflection utils . be inject ( array . a list ( constructor . get declared annotation ( ) ) ) ) { continue ; } final type [ ] generic parameter type = constructor . get generic parameter type ( ) ; final annotation [ ] [ ] annotation = constructor . get parameter annotation ( ) ; int params count = 0 ; final list < parameter > parameter = new array list < parameter > ( ) ; for ( int i = 0 ; i < generic parameter type . length ; i++ ) { final list < annotation > tmp annotation = arrays . a list ( annotation [ i ] ) ; if ( be context ( tmp annotation ) ) { params count++ ; } else { final type generic parameter type = generic parameter type [ i ] ; final list < parameter > tmp parameter = collect parameter ( generic parameter type , tmp annotation , component , class consumes , json view annotation ) ; if ( tmp parameter . size ( ) > = 1 ) { for ( parameter tmp parameter : tmp parameter ) { parameter process parameter = parameter processor . apply annotation ( tmp parameter , generic parameter type , tmp annotation , component , class consumes == null ? new string [ 0 ] : class consumes . value ( ) , null , json view annotation ) ; if ( processed parameter ! = null ) { parameter . add ( process parameter ) ; } } params count++ ; } } } if ( params count > = max params count ) { max params count = params count ; select = parameter ; } } return select ; }
public string get description ( ) { return description ; }
public string get name ( ) { return name ; }
public string get type ( ) { return type ; }
public string get format ( ) { return format ; }
public string get type ( ) { return type ; }
public schema get schema ( ) { return schema ; }
public api response get response ( ) { return response ; }
public boolean get deprecate ( ) { return deprecate ; }
public string get description ( ) { return description ; }
public type get type ( ) { return type ; }
public string get open id connect url ( ) { return open id connect url ; }
public list < string > get enum ( ) { return _enum ; }
public string get description ( ) { return description ; }
public int prev ( int node ) { return tree . prev ( node ) ; }
public int next ( int node ) { return tree . next ( node ) ; }
public long size ( ) { return count ; }
public int root ( ) { return root ; }
public boolean add ( ) { if ( root == nil ) { root = node allocator . new node ( ) ; copy ( root ) ; fix aggregate ( root ) ; return true ; } else { int node = root ; assert parent ( root ) == nil ; int parent ; int cmp ; do { cmp = compare ( node ) ; if ( cmp < 0 ) { parent = node ; node = left ( node ) ; } else if ( cmp > 0 ) { parent = node ; node = right ( node ) ; } else { merge ( node ) ; return false ; } } while ( node ! = nil ) ; node = node allocator . new node ( ) ; if ( node > = capacity ( ) ) { resize ( oversize ( node + 1 ) ) ; } copy ( node ) ; parent ( node , parent ) ; if ( cmp < 0 ) { left ( parent , node ) ; } else { assert cmp > 0 ; right ( parent , node ) ; } rebalance ( node ) ; return true ; } }
public static t digest create avl tree digest ( double compression ) { return new a v l tree digest ( compression ) ; }
public static void assert equal ( long actual , long expect , string message ) { assert equal ( long . value of ( actual ) , long . value of ( expect ) , message ) ; }
public static void assert equal ( char actual , char expect , string message ) { assert equal ( character . value of ( actual ) , character . value of ( expect ) , message ) ; }
public static void assert not same ( object actual , object expect ) { assert not same ( actual , expect , null ) ; }
public void execute assert ( i assert < ? > assert command ) { assert command . do assert ( ) ; }
public static void write utf8 file ( @ nullable string output dir , string file name , string sb ) { final string out dir path= output dir ! = null ? output dir : `` `` ; final file out dir= new file ( out dir path ) ; write file ( out dir , file name , escape unicode ( sb ) , `` utf-8 `` ) ; }
public static string replace special character ( string file name parameter ) { string file name = file name parameter ; if ( file name == null || file name . length ( ) == 0 ) { return file name ; } for ( char element : special_characters ) { file name = file name . replace ( element , char_replacement ) ; } return file name ; }
public boolean be trace enable ( ) { return be level enable ( trace ) ; }
public boolean be info enable ( ) { return be level enable ( info ) ; }
public string to string ( ) { return object . to string helper ( get class ( ) ) . add ( `` context `` , get test context ( ) . get name ( ) ) . to string ( ) ; }
public void set verbose ( int verbose ) { m_verbose = verbose ; }
public void set config failure policy ( xml suite . failure policy failure policy ) { m_config failure policy = failure policy ; }
public void add env ( environment . variable var ) { m_environment . add variable ( var ) ; }
public void set classpath ( path s ) { create classpath ( ) . append ( s ) ; }
public void set test name ( string s ) { m_test name= s ; }
public static void set property ( property p , string name , string value , string def ) { if ( ! def . equal ( value ) & & value ! = null ) { p . set property ( name , value ) ; } }
public list < future type > submit task and wait ( key type key , list < callable < future type > > task ) { list < future type > result = list . new array list ( ) ; submit task ( key , task , null ) ; list < future < future type > > future = null ; synchronize ( m_future map ) { future = m_future map . get ( key ) ; if ( future ! = null ) { while ( ! be finish ( future ) ) { try { thread . sleep ( 1000 ) ; } catch ( interrupted exception e ) { e . print stack trace ( ) ; } } for ( future < future type > future : future ) { try { if ( future ! = null ) result . add ( future . get ( ) ) ; } catch ( interrupted exception e ) { e . print stack trace ( ) ; } catch ( execution exception e ) { e . print stack trace ( ) ; } } } } return result ; }
public static void append to file ( string output dir , string file name , string sb ) { string out dir path= output dir ! = null ? output dir : `` `` ; file out dir= new file ( out dir path ) ; write file ( out dir , file name , sb , null , true / * append * / ) ; }
public int get thread count ( ) { return m_thread count ; }
public boolean for each ( t byte procedure procedure ) { byte [ ] state = _states ; byte [ ] set = _set ; for ( int i = set . length ; i -- > 0 ; ) { if ( state [ i ] == full & & ! procedure . execute ( set [ i ] ) ) { return false ; } } return true ; }
public void clear ( ) { _size = 0 ; _free = capacity ( ) ; }
public object [ ] to array ( ) { object [ ] o = new object [ _size ] ; int i = 0 ; for ( t linkable link = _head ; link ! = null ; link = link . get next ( ) ) { o [ i++ ] = link ; } return o ; }
public t get previous ( t current ) { return current . get previous ( ) ; }
public void transform value ( t byte function function ) { object [ ] key = _set ; byte [ ] value = _values ; for ( int i = value . length ; i -- > 0 ; ) { if ( key [ i ] ! = null & & key [ i ] ! = remove ) { value [ i ] = function . execute ( value [ i ] ) ; } } }
public boolean contains key ( object key ) { return contains ( key ) ; }
public static t double collection synchronize collection ( t double collection c ) { return new t synchronize double collection ( c ) ; }
public object read ( object instance ) { return read ( instance , false ) ; }
public final list < string [ ] > parse all ( file file , int expect row count ) { return parse all ( argument utils . new reader ( file ) , expect row count ) ; }
protect static int skip lead whitespace ( int whitespace range start , string element ) { if ( element . be empty ( ) ) { return 0 ; } for ( int i = 0 ; i < element . length ( ) ; i++ ) { char next char = element . char at ( i ) ; if ( ! ( next char < = ' ' & & whitespace range start < next char ) ) { return i ; } } return element . length ( ) ; }
public static < t > void not empty ( string arg description , t . . . args ) { if ( args == null ) { throw new illegal argument exception ( arg description + `` must not be null `` ) ; } if ( args . length == 0 ) { throw new illegal argument exception ( arg description + `` must not be empty `` ) ; } }
public boolean get read input on separate thread ( ) { return read input on separate thread ; }
public boolean be header extraction enable ( ) { return header extraction enable == null ? false : header extraction enable ; }
public void set null value ( string empty value ) { this . null value = empty value ; }
public boolean get ignore trail whitespaces ( ) { return ignore trailing whitespaces ; }
public int get error content length ( ) { return error content length ; }
public final boolean get expand incomplete row ( ) { return expand incomplete row ; }
public object reverse conversion ( boolean execute in reverse order , int index , object value , boolean [ ] convert flag ) { list < conversion < ? , ? > > conversion = conversion by index . get ( index ) ; if ( conversion ! = null ) { if ( convert flags ! = null ) { convert flag [ index ] = true ; } conversion conversion = null ; try { if ( execute in reverse order ) { for ( int i = conversion . size ( ) - 1 ; i > = 0 ; i -- ) { conversion = conversion . get ( i ) ; value = conversion . revert ( value ) ; } } else { for ( conversion < ? , ? > c : conversion ) { conversion = c ; value = conversion . revert ( value ) ; } } } catch ( data process exception ex ) { ex . set value ( value ) ; ex . set column index ( index ) ; ex . mark a non fatal ( ) ; throw ex ; } catch ( throwable ex ) { data process exception exception ; if ( conversion ! = null ) { exception = new data processing exception ( `` error convert value ' { value } ' use conversion `` + conversion . get class ( ) . get name ( ) , ex ) ; } else { exception = new data processing exception ( `` error convert value ' { value } ' `` , ex ) ; } exception . set value ( value ) ; exception . set column index ( index ) ; exception . mark a non fatal ( ) ; throw exception ; } } return value ; }
public object apply conversion ( int index , string string value , boolean [ ] convert flag ) { list < conversion < ? , ? > > conversion = conversion by index . get ( index ) ; if ( conversion ! = null ) { if ( convert flags ! = null ) { convert flag [ index ] = true ; } object result = string value ; for ( conversion conversion : conversion ) { try { result = conversion . execute ( result ) ; } catch ( data process exception ex ) { ex . set column index ( index ) ; ex . mark a non fatal ( ) ; throw ex ; } catch ( throwable ex ) { data process exception exception = new data processing exception ( `` error convert value ' { value } ' use conversion `` + conversion . get class ( ) . get name ( ) , ex ) ; exception . set value ( result ) ; exception . set column index ( index ) ; exception . mark a non fatal ( ) ; throw exception ; } } return result ; } return string value ; }
public int get field index ( string header ) { return get field index ( new string [ ] { header } ) [ 0 ] ; }
public list < t > get ( ) { return new array list < t > ( field ) ; }
public void row process ( string [ ] row , t context ) { row . add ( row ) ; }
public int [ ] get index ( ) { return null ; }
protect void add conversion ( conversion conversion , field map mapping ) { if ( conversion == null ) { return ; } if ( mapping . be map to index ( ) ) { this . convert index ( conversion ) . add ( map . get index ( ) ) ; } else { this . convert field ( conversion ) . add ( map . get field name ( ) ) ; } }
public final object [ ] reverse conversion ( t bean , string [ ] header , int [ ] index to write ) { if ( bean == null ) { return null ; } if ( row == null ) { if ( header ! = null ) { row = new object [ header . length ] ; } else if ( index to write ! = null ) { int minimum row length = 0 ; for ( int index : index to write ) { if ( index + 1 > minimum row length ) { minimum row length = index + 1 ; } } if ( minimum row length < index to write . length ) { minimum row length = index to write . length ; } row = new object [ minimum row length ] ; } else { set < integer > assign index = new hash set < integer > ( ) ; int last index = -1 ; for ( field map f : parse field ) { if ( last index < f . get index ( ) + 1 ) { last index = f . get index ( ) + 1 ; } assign index . add ( f . get index ( ) ) ; } if ( last index < parse field . size ( ) ) { last index = parse field . size ( ) ; } row = new object [ last index ] ; if ( synthetic header == null ) { synthetic header = new string [ last index ] ; iterator < field map > it = parse field . iterator ( ) ; for ( int i = 0 ; i < last index ; i++ ) { if ( assign index . contains ( i ) ) { continue ; } string field name = null ; while ( it . have next ( ) & & ( field name = it . next ( ) . get field name ( ) ) == null ) ; synthetic header [ i ] = field name ; } } } } if ( nested attribute ! = null ) { for ( map . entry < field mapping , bean conversion processor < ? > > e : nested attribute . entry set ( ) ) { object nest = e . get key ( ) . read ( bean ) ; if ( nested ! = null ) { bean conversion processor < object > nest processor = ( bean conversion processor < object > ) e . get value ( ) ; nest processor . row = row ; nest processor . reverse conversion ( nest , header , index to write ) ; } } } if ( synthetic header ! = null ) { header = synthetic header ; } try { map field to value ( bean , row , header , index to write , false ) ; } catch ( throwable ex ) { if ( ex instanceof data process exception ) { data process exception error = ( data process exception ) ex ; if ( error . be handle ( ) ) { return null ; } else { throw error ; } } else if ( ! handle conversion error ( ex , row , -1 ) ) { throw to data processing exception ( ex , row , -1 ) ; } return null ; } if ( super . reverse conversion ( true , row , header , index to write ) ) { return row ; } return null ; }
public final w get writer setting ( ) { validate writer setting ( ) ; return writer setting ; }
public < t > void write all ( iterable < t > element , class < t > bean type , file output , string . . . header ) { write all ( element , bean type , argument utils . new writer ( output ) , header ) ; }
public < t > iterable result < t , parse context > iterate ( final class < t > bean type , final reader input ) { final object [ ] bean holder = new object [ 1 ] ; set row processor ( new bean processor < t > ( bean type ) { @ override public void bean process ( t bean , parse context context ) { bean holder [ 0 ] = bean ; } @ override public void process end ( parse context context ) { super . process end ( context ) ; parser setting . set row processor ( null ) ; } } ) ; return new iterable result < t , parse context > ( ) { private parsing context context ; @ override public parse context get context ( ) { return context ; } @ override public result iterator < t , parse context > iterator ( ) { final abstract parser < p > parser = create parser ( parser setting ) ; parser . begin parse ( input ) ; context = parser . get context ( ) ; return new result iterator < t , parse context > ( ) { string [ ] row ; @ override public boolean have next ( ) { return bean holder [ 0 ] ! = null || row ! = null || ( row = parser . parse next ( ) ) ! = null ; } @ override public t next ( ) { t out = ( t ) bean holder [ 0 ] ; if ( out == null & & have next ( ) ) { out = ( t ) bean holder [ 0 ] ; } bean holder [ 0 ] = null ; row = null ; return out ; } @ override public void remove ( ) { throw new unsupported operation exception ( `` ca n't remove bean `` ) ; } @ override public parse context get context ( ) { return context ; } } ; } } ; }
public final int column count ( ) { return column ; }
public long get char index ( ) { return char index ; }
protect float from string ( string input ) { return float . value of ( input ) ; }
public i revert ( o input ) { if ( input == null ) { return value on null output ; } return undo ( input ) ; }
public void set empty value ( string empty value ) { this . empty value = empty value ; }
protect char appender new char appender ( ) { int char = get max char per column ( ) ; if ( char ! = -1 ) { return new default char appender ( char , empty value , get whitespace range start ( ) ) ; } else { return new expand char appender ( empty value , get whitespace range start ( ) ) ; } }
public boolean be parse unescaped quote until delimiter ( ) { return ( parse unescaped quote until delimiter & & be parse unescaped quote ( ) ) || ( unescaped quote handle == unescaped quote handling . stop_at_delimiter || unescaped quote handle == unescaped quote handling . skip_value ) ; }
protect csv format create default format ( ) { return new csv format ( ) ; }
public char [ ] get quotation trigger ( ) { return quotation trigger ; }
public char [ ] get field padding ( ) { return argument utils . to char array ( field pad ) ; }
public boolean be pad ( char padding ) { return this . pad == padding ; }
public void set record end on newline ( boolean record end on newline ) { this . record end on newline = record end on newline ; }
protect char appender new char appender ( ) { return new default char appender ( get max char per column ( ) , get null value ( ) , get whitespace range start ( ) ) ; }
public void set escape char ( char escape char ) { this . escape char = escape char ; }
public void set escape tab char ( char escape tab char ) { this . escape tab char = escape tab char ; }
public static < t > array < t > of all ( iterable < ? extend t > element ) { object . require non null ( element , `` element be null `` ) ; if ( element instanceof array ) { return ( array < t > ) elements ; } if ( element instanceof list view & & ( ( list view < t , ? > ) element ) . get delegate ( ) instanceof array ) { return ( array < t > ) ( ( list view < t , ? > ) element ) . get delegate ( ) ; } return wrap ( to array ( element ) ) ; }
public bit set < t > of all ( java . util . stream . stream < ? extend t > java stream ) { object . require non null ( java stream , `` java stream be null `` ) ; return empty ( ) . add all ( iterator . of all ( java stream . iterator ( ) ) ) ; }
public bit set < t > of all ( java . util . stream . stream < ? extend t > java stream ) { object . require non null ( java stream , `` java stream be null `` ) ; return empty ( ) . add all ( iterator . of all ( java stream . iterator ( ) ) ) ; }
public seq < char seq > split ( string regex ) { return split ( regex , 0 ) ; }
public static hash set < long > of all ( long . . . element ) { object . require non null ( element , `` element be null `` ) ; return hash set . of all ( iterator . of all ( element ) ) ; }
public static queue < boolean > of all ( boolean . . . element ) { object . require non null ( element , `` element be null `` ) ; return of all ( io . vavr . collection . list . of all ( element ) ) ; }
public static tree set < float > of all ( float . . . element ) { object . require non null ( element , `` element be null `` ) ; return tree set . of all ( iterator . of all ( element ) ) ; }
public static vector < double > of all ( double . . . element ) { object . require non null ( element , `` element be null `` ) ; return of all ( bit map trie . of all ( element ) ) ; }
public string get directory mode ( ) { return directory mode ; }
public int get max text message size ( ) { return max text message size ; }
public string to string ( ) { if ( to string ! = null ) { return to string ; } to string = `` abstract annotated member `` + get name ( ) ; return to string ; }
public class < t > get delegate ( ) { return get java class ( ) ; }
public enhance annotated type < ? super t > get enhance superclass ( ) { return superclass ; }
public void internal initialize ( bean deployer environment environment ) { pre initialize ( ) ; bean logger . log . create bean ( get type ( ) ) ; if ( get scope ( ) ! = null ) { proxy require = be normal scoped ( ) ; } else { proxy require = false ; } bean logger . log . qualifier use ( get qualifier ( ) , this ) ; bean logger . log . use name ( get name ( ) , this ) ; bean logger . log . use scope ( get scope ( ) , this ) ; }
public class < t > get type ( ) { return type ; }
protect void generate equal method ( class file proxy class type ) { class method method = proxy class type . add method ( access flag . public , `` equal `` , bytecode utils . boolean_class_descriptor , ljava_lang_object ) ; code attribute b = method . get code attribute ( ) ; b . aload ( 1 ) ; b . instanceof instruction ( proxy class type . get name ( ) ) ; b . return instruction ( ) ; }
public static combine interceptor and decorator stack method handler peek if not empty ( ) { stack stack = interception context . get ( ) ; if ( stack == null ) { return null ; } return stack . peek ( ) ; }
public static stack get stack ( ) { stack stack = interception context . get ( ) ; if ( stack == null ) { stack = new stack ( interception context ) ; interception context . set ( stack ) ; } return stack ; }
public void create enablement ( ) { global enablement builder builder = bean manager . get service ( ) . get ( global enablement builder . class ) ; module enablement enablement = builder . create module enablement ( this ) ; bean manager . set enable ( enablement ) ; if ( bootstrap logger . log . be debug enable ( ) ) { bootstrap logger . log . enable alternative ( this . bean manager , weld collection . to multi row string ( enablement . get all alternative ( ) ) ) ; bootstrap logger . log . enable decorator ( this . bean manager , weld collection . to multi row string ( enablement . get decorator ( ) ) ) ; bootstrap logger . log . enable interceptor ( this . bean manager , weld collection . to multi row string ( enablement . get interceptor ( ) ) ) ; } }
public boolean detach ( ) { if ( attach ) { attached = false ; context logger . log . bean store detach ( this ) ; return true ; } else { return false ; } }
public object [ ] get parameter value ( bean manager impl manager , creational context < ? > ctx , creational context < ? > transient reference ) { if ( get injection point ( ) . be empty ( ) ) { return arrays2 . empty_array ; } object [ ] parameter value = new object [ get parameter injection point ( ) . size ( ) ] ; list < parameter injection point < ? , t > > parameter = get parameter injection point ( ) ; for ( int i = 0 ; i < parameter value . length ; i++ ) { parameter injection point < ? , ? > param = parameter . get ( i ) ; if ( have transient reference parameter & & param . get annotated ( ) . be annotation present ( transient reference . class ) ) { parameter value [ i ] = param . get value to inject ( manager , transient reference ) ; } else { parameter value [ i ] = param . get value to inject ( manager , ctx ) ; } } return parameter value ; }
public list < interceptor < ? > > resolve interceptor ( interception type type , annotation . . . interceptor binding ) { if ( interceptor binding . length == 0 ) { throw bean manager logger . log . interceptor binding empty ( ) ; } for ( annotation annotation : interceptor binding ) { if ( ! be interceptor binding ( annotation . annotation type ( ) ) ) { throw bean manager logger . log . not interceptor bind type ( annotation ) ; } } set < annotation > flatten interceptor binding = interceptor . flatten interceptor binding ( null , this , array . a list ( interceptor binding ) , true , true ) ; return resolve interceptor ( type , flatten interceptor binding ) ; }
public observer notifier get accessible lenient observer notifier ( ) { return accessible lenient observer notifier ; }
public boolean be normal ( ) { return normal ; }
public string to string ( ) { string valid = be valid ( ) ? `` valid `` : `` invalid `` ; string normal = be normal ( ) ? `` normal `` : `` non-normal `` ; string passivating = be passivating ( ) ? `` passivating `` : `` pon-passivating `` ; return valid + normal + passivating + `` scope model for `` + get raw type ( ) ; }
protect bean manager impl ambiguous bean manager ( string caller class name , set < bean manager impl > manager ) { throw bean manager logger . log . ambiguous bean manager ( caller class name ) ; }
public static boolean be passivating scope ( bean < ? > bean , bean manager impl manager ) { if ( bean == null ) { return false ; } else { return manager . get service ( ) . get ( meta annotation store . class ) . get scope model ( bean . get scope ( ) ) . be passivating ( ) ; } }
public static < t extend bean < ? > > set < t > remove disable bean ( set < t > bean , final bean manager impl bean manager ) { if ( bean . be empty ( ) ) { return bean ; } else { for ( iterator < t > iterator = bean . iterator ( ) ; iterator . have next ( ) ; ) { if ( ! be bean enable ( iterator . next ( ) , bean manager . get enabled ( ) ) ) { iterator . remove ( ) ; } } return bean ; } }
public static < t > t invoke and unwrap ( final object instance , final method method , final object . . . parameter ) throw throwable { try { return cast ( method . invoke ( instance , parameter ) ) ; } catch ( illegal argument exception e ) { throw reflection logger . log . illegal argument exception on reflection invocation ( instance . get class ( ) , instance , method , array . to string ( parameter ) , e ) ; } catch ( illegal access exception e ) { throw new weld exception ( e ) ; } catch ( invocation target exception e ) { throw e . get cause ( ) ; } }
protect void set bean deployment archive accessibility ( ) { for ( weld bean deployment archive bean deployment archive : bean deployment archive ) { set < weld bean deployment archive > accessible archive = new hash set < > ( ) ; for ( weld bean deployment archive candidate : bean deployment archive ) { if ( candidate . equal ( bean deployment archive ) ) { continue ; } accessible archive . add ( candidate ) ; } bean deployment archive . set accessible bean deployment archive ( accessible archive ) ; } }
public void shutdown now ( ) { weld . shutdown ( ) ; }
public weld add package ( boolean scan recursively , class < ? > package class ) { package . add ( new pack info ( package class , scan recursively ) ) ; return this ; }
public weld add decorator ( class < ? > decorator class ) { enabled decorator . add ( synthetic metadata ( decorator class ) ) ; return this ; }
public weld add alternative stereotype ( class < ? extend annotation > alternative stereotype class ) { select alternative stereotype . add ( synthetic metadata ( alternative stereotype class ) ) ; return this ; }
public weld disable discovery ( ) { this . discovery enable = false ; return this ; }
public weld skip shutdown hook ( ) { return property ( shutdown_hook_system_property , false ) ; }
public string get id ( ) { return id ; }
public void add path ( string path ) { if ( path == null ) { return ; } string [ ] path component = path . split ( `` / `` ) ; trie node parent = root node ; string part = null ; if ( path component . length < = 1 ) { throw new illegal argument exception ( `` invalid path `` + path ) ; } for ( int i=1 ; i < path component . length ; i++ ) { part = path component [ i ] ; if ( parent . get child ( part ) == null ) { parent . add child ( part , new trie node ( parent ) ) ; } parent = parent . get child ( part ) ; } parent . set property ( true ) ; }
public static op set data ( string path , byte [ ] data , int version ) { return new set data ( path , data , version ) ; }
public static void set configuration ( ) throw i o exception { string rule string = system . get property ( `` zookeeper . security . auth_to_local `` , `` default `` ) ; rule = parse rule ( rule string ) ; }
public synchronize void set child ( hash set < string > child ) { this . child = child ; }
public void send close session ( ) { send buffer ( server cnxn factory . close conn ) ; }
public void process request ( request request ) { quorum peer self = leader . self ; if ( self ! = null ) leader . process ack ( self . get id ( ) , request . zxid , null ) ; else log . error ( `` null quorum peer `` ) ; }
public boolean contains quorum ( hash set < long > set ) { return ( set . size ( ) > half ) ; }
public void commit ( long zxid ) { if ( pending txns . size ( ) == 0 ) { log . warn ( `` commit `` + long . to hex string ( zxid ) + `` without see txn `` ) ; return ; } long first element zxid = pending txns . element ( ) . zxid ; if ( first element zxid ! = zxid ) { log . error ( `` commit zxid 0x `` + long . to hex string ( zxid ) + `` but next pending txn 0x `` + long . to hex string ( first element zxid ) ) ; system . exit ( 12 ) ; } request request = pending txns . remove ( ) ; commit processor . commit ( request ) ; }
public static void main ( string [ ] args ) throw exception { if ( args . length ! = 1 ) { system . err . println ( `` usage : snapshot formatter snapshot_file `` ) ; system . exit ( 2 ) ; } new snapshot formatter ( ) . run ( args [ 0 ] ) ; }
public byte [ ] get data ( string path , stat stat , watcher watcher ) throw keeper exception . no node exception { return data tree . get data ( path , stat , watcher ) ; }
public list < acl > get a c l ( string path , stat stat ) throw no node exception { return data tree . get a c l ( path , stat ) ; }
public list < string > get child ( string path , stat stat , watcher watcher ) throw keeper exception . no node exception { return data tree . get child ( path , stat , watcher ) ; }
public void deserialize snapshot ( input archive ia ) throw i o exception { clear ( ) ; serialize utils . deserialize snapshot ( get data tree ( ) , ia , get session with time out ( ) ) ; initialize = true ; }
public void commit ( ) throw i o exception { this . snap log . commit ( ) ; }
public z k database get z k database ( ) { return this . zk db ; }
public long get outstanding request ( ) { return get in process ( ) ; }
public watcher event get wrapper ( ) { return new watcher event ( event type . get int value ( ) , keeper state . get int value ( ) , path ) ; }
public byte [ ] get session passwd ( ) { return cnxn . get session passwd ( ) ; }
protect socket address testable remote socket address ( ) { return cnxn . send thread . get client cnxn socket ( ) . get remote socket address ( ) ; }
public file get directory ( ) { return builder . directory ( ) ; }
